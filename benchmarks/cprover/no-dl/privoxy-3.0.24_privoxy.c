// tag-#anon#ST[*{S8}_S8_'name'||*{S8}_S8_'svalue'||S32'ivalue'||U32'_pad0'|]
// file cgiedit.c line 110
struct anonymous_0;

// tag-#anon#ST[*{S8}_S8_'text'||U64'length'||S32'backrefs'||ARR33{S32}_S32_'block_offset'||ARR33{U64}_U64_'block_length'||ARR33{S32}_S32_'backref'||ARR35{S32}_S32_'backref_count'|]
// file pcrs.h line 62
struct anonymous_12;

// tag-#anon#ST[*{V}_V_'re_pcre'||U64're_nsub'||U64're_erroffset'|]
// file /usr/include/pcreposix.h line 97
struct anonymous_3;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_13;

// tag-#anon#ST[S32'rm_so'||S32'rm_eo'|]
// file /usr/include/pcreposix.h line 107
struct anonymous_4;

// tag-#anon#ST[S32'submatches'||ARR35{S32}_S32_'submatch_offset'||ARR35{U64}_U64_'submatch_length'|]
// file pcrs.h line 80
struct anonymous_7;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_9;

// tag-#anon#UN[ARR1{SYM#tag-action_spec#}_SYM#tag-action_spec#_'action'||SYM#tag-#anon#ST[*{S8}_S8_'name'||*{S8}_S8_'svalue'||S32'ivalue'||U32'_pad0'|]#'setting'|]
// file cgiedit.c line 103
union anonymous;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_14;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_2;

// tag-#anon#UN[SYM#tag-url_spec#'url_spec'||*{SYM#tag-#anon#ST[*{V}_V_'re_pcre'||U64're_nsub'||U64're_erroffset'|]#}_SYM#tag-#anon#ST[*{V}_V_'re_pcre'||U64're_nsub'||U64're_erroffset'|]#_'tag_regex'|]
// file project.h line 365
union anonymous_5;

// tag-PCRS_JOB
// file pcrs.h line 89
struct PCRS_JOB;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-access_control_addr
// file project.h line 1170
struct access_control_addr;

// tag-access_control_list
// file project.h line 1187
struct access_control_list;

// tag-action_alias
// file actions.h line 46
struct action_alias;

// tag-action_name
// file actions.c line 85
struct action_name;

// tag-action_spec
// file project.h line 602
struct action_spec;

// tag-action_value_type
// file actions.c line 73
enum action_value_type { AV_NONE=0, AV_ADD_STRING=1, AV_REM_STRING=2, AV_ADD_MULTI=3, AV_REM_MULTI=4 };

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-binbuffer
// file deanimate.h line 50
struct binbuffer;

// tag-block_spec
// file project.h line 1081
struct block_spec;

// tag-cgi_dispatcher
// file project.h line 1012
struct cgi_dispatcher;

// tag-chunk_status
// file jcc.c line 1315
enum chunk_status { CHUNK_STATUS_MISSING_DATA=0, CHUNK_STATUS_BODY_COMPLETE=1, CHUNK_STATUS_PARSE_ERROR=2 };

// tag-client_state
// file project.h line 894
struct client_state;

// tag-client_states
// file project.h line 992
struct client_states;

// tag-configuration_spec
// file project.h line 210
struct configuration_spec;

// tag-crunch_reason
// file project.h line 308
enum crunch_reason { UNSUPPORTED=0, BLOCKED=1, UNTRUSTED=2, REDIRECTED=3, CGI_CALL=4, NO_SUCH_DOMAIN=5, FORWARDING_FAILED=6, CONNECT_FAILED=7, OUT_OF_MEMORY=8, INTERNAL_ERROR=9, CONNECTION_TIMEOUT=10, NO_SERVER_DATA=11 };

// tag-cruncher
// file jcc.c line 291
struct cruncher;

// tag-current_action_spec
// file project.h line 580
struct current_action_spec;

// tag-editable_file
// file cgiedit.c line 169
struct editable_file;

// tag-file_line
// file cgiedit.c line 82
struct file_line;

// tag-file_list
// file project.h line 954
struct file_list;

// tag-filter_type
// file project.h line 1124
enum filter_type { FT_CONTENT_FILTER=0, FT_CLIENT_HEADER_FILTER=1, FT_SERVER_HEADER_FILTER=2, FT_CLIENT_HEADER_TAGGER=3, FT_SERVER_HEADER_TAGGER=4, FT_EXTERNAL_CONTENT_FILTER=5, FT_INVALID_FILTER=42 };

// tag-filter_type_info
// file cgiedit.c line 194
struct filter_type_info;

// tag-forward_spec
// file project.h line 935
struct forward_spec;

// tag-forwarder_type
// file project.h line 644
enum forwarder_type { SOCKS_NONE=0, SOCKS_4=40, SOCKS_4A=41, SOCKS_5=50, SOCKS_5T=51, FORWARD_WEBSERVER=52 };

// tag-group
// file /usr/include/grp.h line 42
struct group;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-http_request
// file project.h line 278
struct http_request;

// tag-http_response
// file project.h line 327
struct http_response;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-internal_state
// file /usr/include/zlib.h line 83
struct internal_state;

// tag-iob
// file project.h line 407
struct iob;

// tag-linger
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 379
struct linger;

// tag-list
// file project.h line 233
struct list;

// tag-list_entry
// file project.h line 216
struct list_entry;

// tag-map
// file project.h line 261
struct map;

// tag-map_entry
// file project.h line 246
struct map_entry;

// tag-parsers
// file parsers.c line 165
struct parsers;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pattern_spec
// file project.h line 359
struct pattern_spec;

// tag-pcre_extra
// file /usr/include/pcre.h line 376
struct pcre_extra;

// tag-pcrs_variable
// file pcrs.h line 122
struct pcrs_variable;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-privoxy_err
// file project.h line 140
enum privoxy_err { JB_ERR_OK=0, JB_ERR_MEMORY=1, JB_ERR_CGI_PARAMS=2, JB_ERR_FILE=3, JB_ERR_PARSE=4, JB_ERR_MODIFIED=5, JB_ERR_COMPRESS=6 };

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-re_filterfile_spec
// file project.h line 1149
struct re_filterfile_spec;

// tag-real_pcre
// file /usr/include/pcre.h line 324
struct real_pcre;

// tag-regex_anchoring
// file urlmatch.c line 61
enum regex_anchoring { NO_ANCHORING=0, LEFT_ANCHORED=1, RIGHT_ANCHORED=2, RIGHT_ANCHORED_HOST=3 };

// tag-reusable_connection
// file project.h line 668
struct reusable_connection;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/netinet/in.h line 252
struct sockaddr_in6;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-socks_op
// file gateway.c line 114
struct socks_op;

// tag-socks_reply
// file gateway.c line 125
struct socks_reply;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-url_actions
// file project.h line 633
struct url_actions;

// tag-url_spec
// file project.h line 340
struct url_spec;

// tag-z_stream_s
// file /usr/include/zlib.h line 85
struct z_stream_s;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// _IO_getc
// file /usr/include/libio.h line 434
extern signed int _IO_getc(struct _IO_FILE *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// accept_connection
// file jbsockets.c line 1191
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// acl_addr
// file filters.c line 324
extern signed int acl_addr(const char *aspec, struct access_control_addr *aca);
// action_spec_is_valid
// file actions.c line 1134
static signed int action_spec_is_valid(struct client_state *csp, struct action_spec *cur_action);
// action_used_to_be_valid
// file actions.c line 439
static signed int action_used_to_be_valid(const char *action);
// actions_from_radio
// file cgiedit.c line 4255
static enum privoxy_err actions_from_radio(struct map *parameters, struct action_spec *action);
// actions_to_html
// file actions.c line 1722
extern char * actions_to_html(struct client_state *csp, struct action_spec *action);
// actions_to_line_of_text
// file actions.c line 1922
extern char * actions_to_line_of_text(struct current_action_spec *action);
// actions_to_radio
// file cgiedit.c line 4124
static enum privoxy_err actions_to_radio(struct map *exports, struct action_spec *action);
// actions_to_text
// file actions.c line 1634
extern char * actions_to_text(struct action_spec *action);
// add_cookie_expiry_date
// file parsers.c line 3954
static void add_cookie_expiry_date(char **cookie, signed long int lifetime);
// add_help_link
// file cgi.h line 113
extern char * add_help_link(const char *item, struct configuration_spec *config);
// add_loader
// file loaders.h line 91
extern void add_loader(signed int (*loader)(struct client_state *), struct configuration_spec *config);
// add_loader::loader_object
//
signed int loader_object(struct client_state *);
// add_to_iob
// file parsers.h line 54
extern enum privoxy_err add_to_iob(struct iob *iob, const unsigned long int buffer_limit, char *src, signed long int n);
// alloc_http_response
// file cgi.c line 1771
extern struct http_response * alloc_http_response(void);
// any_loaded_file_changed
// file loaders.h line 95
extern signed int any_loaded_file_changed(struct client_state *csp);
// apply_url_actions
// file filters.c line 2350
extern void apply_url_actions(struct current_action_spec *action, struct http_request *http, struct url_actions *b);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// bind_port
// file jbsockets.c line 837
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// bind_port_helper
// file jcc.c line 3772
static signed int bind_port_helper(const char *haddr, signed int hport);
// bind_ports_helper
// file jcc.c line 3846
static void bind_ports_helper(struct configuration_spec *config, signed int *sockets);
// bindup
// file miscutil.h line 67
extern char * bindup(const char *string, unsigned long int len);
// block_acl
// file filters.c line 242
extern signed int block_acl(struct access_control_addr *dst, struct client_state *csp);
// block_url
// file filters.c line 541
extern struct http_response * block_url(struct client_state *csp);
// buf_copy
// file deanimate.c line 135
static signed int buf_copy(struct binbuffer *src, struct binbuffer *dst, unsigned long int length);
// buf_extend
// file deanimate.c line 94
static signed int buf_extend(struct binbuffer *buf, unsigned long int length);
// buf_free
// file deanimate.c line 63
extern void buf_free(struct binbuffer *buf);
// buf_getbyte
// file deanimate.c line 181
static unsigned char buf_getbyte(struct binbuffer *src, unsigned long int offset);
// build_request_line
// file jcc.c line 888
static void build_request_line(struct client_state *csp, struct forward_spec *fwd, char **request_line);
// cgi_default
// file cgisimple.h line 47
extern enum privoxy_err cgi_default(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_edit_actions
// file cgiedit.h line 47
extern enum privoxy_err cgi_edit_actions(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_edit_actions_add_url
// file cgiedit.h line 65
extern enum privoxy_err cgi_edit_actions_add_url(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_edit_actions_add_url_form
// file cgiedit.h line 68
extern enum privoxy_err cgi_edit_actions_add_url_form(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_edit_actions_for_url
// file cgiedit.h line 50
extern enum privoxy_err cgi_edit_actions_for_url(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_edit_actions_list
// file cgiedit.h line 53
extern enum privoxy_err cgi_edit_actions_list(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_edit_actions_remove_url
// file cgiedit.h line 71
extern enum privoxy_err cgi_edit_actions_remove_url(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_edit_actions_remove_url_form
// file cgiedit.h line 74
extern enum privoxy_err cgi_edit_actions_remove_url_form(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_edit_actions_section_add
// file cgiedit.h line 80
extern enum privoxy_err cgi_edit_actions_section_add(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_edit_actions_section_remove
// file cgiedit.h line 77
extern enum privoxy_err cgi_edit_actions_section_remove(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_edit_actions_section_swap
// file cgiedit.h line 83
extern enum privoxy_err cgi_edit_actions_section_swap(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_edit_actions_submit
// file cgiedit.h line 56
extern enum privoxy_err cgi_edit_actions_submit(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_edit_actions_url
// file cgiedit.h line 59
extern enum privoxy_err cgi_edit_actions_url(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_edit_actions_url_form
// file cgiedit.h line 62
extern enum privoxy_err cgi_edit_actions_url_form(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_error_404
// file cgisimple.h line 50
extern enum privoxy_err cgi_error_404(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_error_bad_param
// file cgi.c line 1308
extern enum privoxy_err cgi_error_bad_param(struct client_state *csp, struct http_response *rsp);
// cgi_error_disabled
// file cgi.c line 1054
extern enum privoxy_err cgi_error_disabled(struct client_state *csp, struct http_response *rsp);
// cgi_error_file
// file cgiedit.c line 2113
enum privoxy_err cgi_error_file(struct client_state *csp, struct http_response *rsp, const char *filename);
// cgi_error_file_read_only
// file cgiedit.c line 2158
enum privoxy_err cgi_error_file_read_only(struct client_state *csp, struct http_response *rsp, const char *filename);
// cgi_error_memory
// file cgi.c line 1129
extern struct http_response * cgi_error_memory(void);
// cgi_error_modified
// file cgiedit.c line 2014
enum privoxy_err cgi_error_modified(struct client_state *csp, struct http_response *rsp, const char *filename);
// cgi_error_no_template
// file cgi.c line 1157
extern enum privoxy_err cgi_error_no_template(struct client_state *csp, struct http_response *rsp, const char *template_name);
// cgi_error_parse
// file cgiedit.c line 2059
enum privoxy_err cgi_error_parse(struct client_state *csp, struct http_response *rsp, struct editable_file *file);
// cgi_error_unknown
// file cgi.c line 1240
extern enum privoxy_err cgi_error_unknown(struct client_state *csp, struct http_response *rsp, enum privoxy_err error_to_report);
// cgi_init_error_messages
// file cgi.c line 1088
extern void cgi_init_error_messages(void);
// cgi_redirect
// file cgi.c line 1342
extern enum privoxy_err cgi_redirect(struct http_response *rsp, const char *target);
// cgi_robots_txt
// file cgisimple.h line 53
extern enum privoxy_err cgi_robots_txt(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_send_banner
// file cgisimple.h line 56
extern enum privoxy_err cgi_send_banner(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_send_default_favicon
// file cgisimple.h line 77
extern enum privoxy_err cgi_send_default_favicon(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_send_error_favicon
// file cgisimple.h line 74
extern enum privoxy_err cgi_send_error_favicon(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_send_stylesheet
// file cgisimple.h line 80
extern enum privoxy_err cgi_send_stylesheet(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_send_url_info_osd
// file cgisimple.h line 83
extern enum privoxy_err cgi_send_url_info_osd(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_send_user_manual
// file cgisimple.h line 86
extern enum privoxy_err cgi_send_user_manual(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_show_file
// file cgisimple.c line 1841
static enum privoxy_err cgi_show_file(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_show_request
// file cgisimple.h line 68
extern enum privoxy_err cgi_show_request(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_show_status
// file cgisimple.h line 59
extern enum privoxy_err cgi_show_status(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_show_url_info
// file cgisimple.h line 62
extern enum privoxy_err cgi_show_url_info(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_show_version
// file cgisimple.h line 65
extern enum privoxy_err cgi_show_version(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_toggle
// file cgiedit.h line 88
extern enum privoxy_err cgi_toggle(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// cgi_transparent_image
// file cgisimple.h line 71
extern enum privoxy_err cgi_transparent_image(struct client_state *csp, struct http_response *rsp, struct map *parameters);
// change_request_destination
// file jcc.c line 945
static enum privoxy_err change_request_destination(struct client_state *csp);
// chat
// file jcc.c line 1818
static void chat(struct client_state *csp);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// check_file_changed
// file loaders.h line 43
extern signed int check_file_changed(struct file_list *current, const char *filename, struct file_list **newfl);
// check_negative_tag_patterns
// file actions.c line 859
extern enum privoxy_err check_negative_tag_patterns(struct client_state *csp, unsigned int flag);
// chomp
// file miscutil.h line 66
extern char * chomp(char *string);
// chroot
// file /usr/include/unistd.h line 944
extern signed int chroot(const char *);
// chunked_body_is_complete
// file jcc.c line 1347
static enum chunk_status chunked_body_is_complete(struct iob *iob, unsigned long int *length);
// clear_iob
// file parsers.h line 55
extern void clear_iob(struct iob *iob);
// client_accept_encoding
// file parsers.c line 2776
static enum privoxy_err client_accept_encoding(struct client_state *csp, char **header);
// client_accept_language
// file parsers.c line 2922
static enum privoxy_err client_accept_language(struct client_state *csp, char **header);
// client_connection
// file parsers.c line 1886
static enum privoxy_err client_connection(struct client_state *csp, char **header);
// client_connection_header_adder
// file parsers.c line 3812
static enum privoxy_err client_connection_header_adder(struct client_state *csp);
// client_expect
// file parsers.c line 2041
static enum privoxy_err client_expect(struct client_state *csp, char **header);
// client_from
// file parsers.c line 3098
static enum privoxy_err client_from(struct client_state *csp, char **header);
// client_has_unsupported_expectations
// file jcc.c line 452
static signed int client_has_unsupported_expectations(struct client_state *csp);
// client_host
// file parsers.c line 3285
static enum privoxy_err client_host(struct client_state *csp, char **header);
// client_host_adder
// file parsers.c line 3596
static enum privoxy_err client_host_adder(struct client_state *csp);
// client_if_modified_since
// file parsers.c line 3348
static enum privoxy_err client_if_modified_since(struct client_state *csp, char **header);
// client_if_none_match
// file parsers.c line 3474
static enum privoxy_err client_if_none_match(struct client_state *csp, char **header);
// client_keep_alive
// file parsers.c line 1744
static enum privoxy_err client_keep_alive(struct client_state *csp, char **header);
// client_max_forwards
// file parsers.c line 3232
static enum privoxy_err client_max_forwards(struct client_state *csp, char **header);
// client_protocol_is_unsupported
// file jcc.c line 393
static signed int client_protocol_is_unsupported(struct client_state *csp, char *req);
// client_proxy_connection
// file parsers.c line 1972
static enum privoxy_err client_proxy_connection(struct client_state *csp, char **header);
// client_range
// file parsers.c line 3567
static enum privoxy_err client_range(struct client_state *csp, char **header);
// client_referrer
// file parsers.c line 2843
static enum privoxy_err client_referrer(struct client_state *csp, char **header);
// client_save_content_length
// file parsers.c line 1844
static enum privoxy_err client_save_content_length(struct client_state *csp, char **header);
// client_send_cookie
// file parsers.c line 3149
static enum privoxy_err client_send_cookie(struct client_state *csp, char **header);
// client_te
// file parsers.c line 2813
static enum privoxy_err client_te(struct client_state *csp, char **header);
// client_transfer_encoding
// file parsers.h line 64
extern enum privoxy_err client_transfer_encoding(struct client_state *csp, char **header);
// client_ua
// file parsers.c line 3068
static enum privoxy_err client_ua(struct client_state *csp, char **header);
// client_uagent
// file parsers.c line 3026
static enum privoxy_err client_uagent(struct client_state *csp, char **header);
// client_x_filter
// file parsers.c line 3503
static enum privoxy_err client_x_filter(struct client_state *csp, char **header);
// client_x_forwarded
// file parsers.c line 3179
static enum privoxy_err client_x_forwarded(struct client_state *csp, char **header);
// client_x_forwarded_for_adder
// file parsers.c line 3680
static enum privoxy_err client_x_forwarded_for_adder(struct client_state *csp);
// client_xtra_adder
// file parsers.c line 3646
static enum privoxy_err client_xtra_adder(struct client_state *csp);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_ports_helper
// file jcc.c line 3880
static void close_ports_helper(signed int *sockets);
// close_socket
// file jbsockets.h line 53
extern void close_socket(signed int fd);
// close_unusable_connections
// file gateway.c line 412
extern signed int close_unusable_connections(void);
// compile_dynamic_pcrs_job_list
// file filters.c line 915
extern struct PCRS_JOB * compile_dynamic_pcrs_job_list(struct client_state *csp, struct re_filterfile_spec *b);
// compile_host_pattern
// file urlmatch.c line 815
static enum privoxy_err compile_host_pattern(struct pattern_spec *url, const char *host_pattern);
// compile_pattern
// file urlmatch.c line 624
static enum privoxy_err compile_pattern(const char *pattern, enum regex_anchoring anchoring, struct pattern_spec *url, struct anonymous_3 **regex);
// compile_url_pattern
// file urlmatch.c line 705
static enum privoxy_err compile_url_pattern(struct pattern_spec *url, char *buf);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// connect_port_is_forbidden
// file filters.c line 521
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// connect_to
// file jbsockets.h line 45
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// connection_destination_matches
// file gateway.c line 359
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// content_filters_enabled
// file filters.c line 2708
extern signed int content_filters_enabled(struct current_action_spec *action);
// content_requires_filtering
// file filters.c line 2634
extern signed int content_requires_filtering(struct client_state *csp);
// copy_action
// file actions.c line 215
extern enum privoxy_err copy_action(struct action_spec *dest, struct action_spec *src);
// create_content_length_header
// file parsers.c line 4622
static void create_content_length_header(unsigned long long int content_length, char *header, unsigned long int buffer_length);
// create_fake_referrer
// file parsers.c line 4526
static enum privoxy_err create_fake_referrer(char **header, const char *fake_referrer);
// create_forged_referrer
// file parsers.c line 4491
static enum privoxy_err create_forged_referrer(char **header, const char *hostport);
// create_pattern_spec
// file urlmatch.h line 56
extern enum privoxy_err create_pattern_spec(struct pattern_spec *pattern, char *buf);
// crumble
// file parsers.c line 2072
static enum privoxy_err crumble(struct client_state *csp, char **header);
// crunch_client_header
// file parsers.c line 2987
static enum privoxy_err crunch_client_header(struct client_state *csp, char **header);
// crunch_reason
// file jcc.c line 653
static const char * crunch_reason(struct http_response *rsp);
// crunch_response_triggered
// file jcc.c line 818
static signed int crunch_response_triggered(struct client_state *csp, struct cruncher *crunchers);
// crunch_server_header
// file parsers.c line 2098
static enum privoxy_err crunch_server_header(struct client_state *csp, char **header);
// current_action_to_html
// file actions.c line 1828
extern char * current_action_to_html(struct client_state *csp, struct current_action_spec *action);
// data_is_available
// file jbsockets.h line 52
extern signed int data_is_available(signed int fd, signed int seconds_to_wait);
// debug_level_is_enabled
// file errlog.c line 263
extern signed int debug_level_is_enabled(signed int debug_level);
// decompress_iob
// file parsers.h line 56
extern enum privoxy_err decompress_iob(struct client_state *csp);
// default_exports
// file cgi.c line 2151
extern struct map * default_exports(struct client_state *csp, const char *caller);
// destroy_list
// file list.h line 49
extern void destroy_list(struct list *the_list);
// difftime
// file /usr/include/time.h line 195
extern double difftime(signed long int, signed long int);
// direct_response
// file filters.c line 2572
extern struct http_response * direct_response(struct client_state *csp);
// disable_logging
// file errlog.c line 280
extern void disable_logging(void);
// dispatch_cgi
// file cgi.c line 303
extern struct http_response * dispatch_cgi(struct client_state *csp);
// dispatch_known_cgi
// file cgi.c line 476
static struct http_response * dispatch_known_cgi(struct client_state *csp, const char *path);
// domain_match
// file urlmatch.c line 1067
static signed int domain_match(struct pattern_spec *p, struct http_request *fqdn);
// drain_and_close_socket
// file jbsockets.c line 760
extern void drain_and_close_socket(signed int fd);
// dump_map
// file cgi.c line 2448
extern char * dump_map(struct map *the_map);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// edit_free_file
// file cgiedit.c line 864
void edit_free_file(struct editable_file *file);
// edit_free_file_lines
// file cgiedit.c line 894
static void edit_free_file_lines(struct file_line *first_line);
// edit_parse_actions_file
// file cgiedit.c line 1094
enum privoxy_err edit_parse_actions_file(struct editable_file *file);
// edit_read_actions_file
// file cgiedit.c line 1614
enum privoxy_err edit_read_actions_file(struct client_state *csp, struct http_response *rsp, struct map *parameters, signed int require_version, struct editable_file **pfile);
// edit_read_file
// file cgiedit.c line 1481
enum privoxy_err edit_read_file(struct client_state *csp, struct map *parameters, signed int require_version, struct editable_file **pfile);
// edit_read_file_lines
// file cgiedit.c line 1385
static enum privoxy_err edit_read_file_lines(struct _IO_FILE *fp, struct file_line **pfile, signed int *newline);
// edit_read_line
// file loaders.h line 47
extern enum privoxy_err edit_read_line(struct _IO_FILE *fp, char **raw_out, char **prefix_out, char **data_out, signed int *newline, unsigned long int *line_number);
// edit_write_file
// file cgiedit.c line 701
enum privoxy_err edit_write_file(struct editable_file *file);
// enforce_header_order
// file parsers.c line 1042
static void enforce_header_order(struct list *headers, struct list *ordered_headers);
// enlist
// file list.h line 51
extern enum privoxy_err enlist(struct list *the_list, const char *str);
// enlist_first
// file list.h line 54
extern enum privoxy_err enlist_first(struct list *the_list, const char *str);
// enlist_unique
// file list.h line 52
extern enum privoxy_err enlist_unique(struct list *the_list, const char *str, unsigned long int num_significant_chars);
// enlist_unique_header
// file list.h line 53
extern enum privoxy_err enlist_unique_header(struct list *the_list, const char *name, const char *value);
// error_response
// file cgi.c line 876
extern struct http_response * error_response(struct client_state *csp, const char *templatename);
// execute_content_filters
// file filters.c line 2230
extern char * execute_content_filters(struct client_state *csp);
// execute_content_filters::1::content_filter_object
//
char * content_filter_object();
// execute_external_filter
// file filters.c line 1794
static char * execute_external_filter(struct client_state *csp, const char *name, char *content, unsigned long int *size);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fatal_error
// file errlog.c line 150
static void fatal_error(const char *error_message);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// file_has_been_modified
// file loaders.c line 1453
static signed int file_has_been_modified(const char *filename, signed long int last_know_modification);
// filter_header
// file parsers.c line 1453
static enum privoxy_err filter_header(struct client_state *csp, char **header);
// filters_available
// file filters.c line 2728
extern signed int filters_available(struct client_state *csp);
// finish_http_response
// file cgi.c line 1575
extern struct http_response * finish_http_response(struct client_state *csp, struct http_response *rsp);
// flush_socket
// file parsers.h line 53
extern signed long int flush_socket(signed int fd, struct iob *iob);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// force_required
// file jcc.c line 1475
static signed int force_required(struct client_state *csp, char *request_line);
// forget_connection
// file gateway.c line 313
extern void forget_connection(signed int sfd);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// forward_url
// file filters.h line 89
extern struct forward_spec * forward_url(struct client_state *csp, struct http_request *http);
// forwarded_connect
// file gateway.c line 600
extern signed int forwarded_connect(struct forward_spec *fwd, struct http_request *http, struct client_state *csp);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_action
// file actions.c line 287
extern void free_action(struct action_spec *src);
// free_action_spec
// file actions.c line 266
void free_action_spec(struct action_spec *src);
// free_alias_list
// file actions.c line 1030
extern void free_alias_list(struct action_alias *alias_list);
// free_current_action
// file actions.c line 928
extern void free_current_action(struct current_action_spec *src);
// free_http_request
// file urlmatch.h line 41
extern void free_http_request(struct http_request *http);
// free_http_response
// file cgi.c line 1791
extern void free_http_response(struct http_response *rsp);
// free_map
// file list.h line 78
extern void free_map(struct map *the_map);
// free_pattern_spec
// file urlmatch.h line 57
extern void free_pattern_spec(struct pattern_spec *pattern);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// get_action_token
// file actions.c line 338
extern enum privoxy_err get_action_token(char **line, char **name, char **value);
// get_actions
// file actions.c line 481
extern enum privoxy_err get_actions(char *line, struct action_alias *alias_list, struct action_spec *cur_action);
// get_char_param
// file cgi.c line 693
extern char get_char_param(struct map *parameters, const char *param_name);
// get_clf_timestamp
// file errlog.c line 513
static inline unsigned long int get_clf_timestamp(char *buffer, unsigned long int buffer_size);
// get_content_length
// file parsers.c line 1811
static enum privoxy_err get_content_length(const char *header_value, unsigned long long int *length);
// get_content_type
// file cgisimple.c line 680
static const char * get_content_type(const char *filename);
// get_destination_from_headers
// file parsers.h line 62
extern enum privoxy_err get_destination_from_headers(struct list *headers, struct http_request *http);
// get_expected_content_length
// file parsers.h line 63
extern unsigned long long int get_expected_content_length(struct list *headers);
// get_external_filter
// file filters.c line 1724
static const char * get_external_filter(struct client_state *csp, const char *name);
// get_file_name_param
// file cgiedit.c line 1716
static enum privoxy_err get_file_name_param(struct client_state *csp, struct map *parameters, const char *param_name, const char **pfilename);
// get_filter
// file filters.h line 82
extern struct re_filterfile_spec * get_filter(struct client_state *csp, const char *requested_name, enum filter_type requested_type);
// get_filter_function
// file filters.c line 2010
static char * (*get_filter_function(struct client_state *csp))();
// get_filter_function::1::filter_function_object
//
char * filter_function_object();
// get_forward_override_settings
// file filters.c line 2396
static struct forward_spec * get_forward_override_settings(struct client_state *csp);
// get_header
// file parsers.h line 57
extern char * get_header(struct iob *iob);
// get_header_line
// file parsers.c line 913
static char * get_header_line(struct iob *iob);
// get_header_value
// file parsers.h line 58
extern char * get_header_value(struct list *header_list, const char *header_name);
// get_host_information
// file jbsockets.h line 58
extern void get_host_information(signed int afd, char **ip_address, char **port, char **hostname);
// get_http_time
// file cgi.c line 1431
extern void get_http_time(signed int time_offset, char *buf, unsigned long int buffer_size);
// get_last_url
// file filters.c line 1046
extern char * get_last_url(char *subject, const char *redirect_mode);
// get_locale_time
// file cgi.c line 1480
static void get_locale_time(char *buf, unsigned long int buffer_size);
// get_log_level_string
// file errlog.c line 584
static inline const char * get_log_level_string(signed int loglevel);
// get_log_timestamp
// file errlog.c line 459
static inline unsigned long int get_log_timestamp(char *buffer, unsigned long int buffer_size);
// get_number_param
// file cgi.c line 804
extern enum privoxy_err get_number_param(struct client_state *csp, struct map *parameters, char *name, unsigned int *pvalue);
// get_request_destination_elsewhere
// file jcc.c line 499
static enum privoxy_err get_request_destination_elsewhere(struct client_state *csp, struct list *headers);
// get_request_line
// file jcc.c line 1244
static char * get_request_line(struct client_state *csp);
// get_reusable_connection
// file gateway.c line 480
static signed int get_reusable_connection(struct http_request *http, struct forward_spec *fwd);
// get_server_headers
// file jcc.c line 568
static enum privoxy_err get_server_headers(struct client_state *csp);
// get_string_param
// file cgi.c line 733
extern enum privoxy_err get_string_param(struct map *parameters, const char *param_name, const char **pparam);
// get_thread_id
// file errlog.c line 410
static signed long int get_thread_id(void);
// get_url_actions
// file filters.h line 76
extern void get_url_actions(struct client_state *csp, struct http_request *http);
// get_url_spec_param
// file cgiedit.c line 1823
static enum privoxy_err get_url_spec_param(struct client_state *csp, struct map *parameters, const char *name, char **pvalue);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getcwd
// file /usr/include/unistd.h line 511
extern char * getcwd(char *, unsigned long int);
// getgrnam
// file /usr/include/grp.h line 110
extern struct group * getgrnam(const char *);
// gethostbyname_r
// file /usr/include/netdb.h line 179
extern signed int gethostbyname_r(const char *, struct hostent *, char *, unsigned long int, struct hostent ** restrict , signed int *);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, struct sockaddr *, unsigned int *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// gif_deanimate
// file deanimate.c line 322
extern signed int gif_deanimate(struct binbuffer *src, struct binbuffer *dst, signed int get_first_image);
// gif_deanimate_response
// file filters.c line 1949
static char * gif_deanimate_response(struct client_state *csp);
// gif_extract_image
// file deanimate.c line 250
static signed int gif_extract_image(struct binbuffer *src, struct binbuffer *dst);
// gif_skip_data_block
// file deanimate.c line 210
static signed int gif_skip_data_block(struct binbuffer *buf);
// gmtime_r
// file /usr/include/time.h line 249
extern struct tm * gmtime_r(const signed long int *, struct tm *);
// grep_cgi_referrer
// file cgi.c line 391
static char * grep_cgi_referrer(struct client_state *csp);
// handle_conditional_hide_referrer_parameter
// file parsers.c line 4568
static enum privoxy_err handle_conditional_hide_referrer_parameter(char **header, const char *host, const signed int parameter_conditional_block);
// hash_string
// file miscutil.h line 56
extern unsigned int hash_string(const char *s);
// header_tagger
// file parsers.c line 1285
static enum privoxy_err header_tagger(struct client_state *csp, char *header);
// host_matches
// file urlmatch.c line 1281
static signed int host_matches(struct http_request *http, struct pattern_spec *pattern);
// html_encode
// file encode.h line 39
extern char * html_encode(const char *s);
// html_encode_and_free_original
// file encode.h line 43
extern char * html_encode_and_free_original(char *s);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// inflate
// file /usr/include/zlib.h line 392
extern signed int inflate(struct z_stream_s *, signed int);
// inflateEnd
// file /usr/include/zlib.h line 508
extern signed int inflateEnd(struct z_stream_s *);
// inflateInit2_
// file /usr/include/zlib.h line 1641
extern signed int inflateInit2_(struct z_stream_s *, signed int, const char *, signed int);
// init_action
// file actions.c line 709
extern void init_action(struct action_spec *dest);
// init_current_action
// file actions.c line 689
extern void init_current_action(struct current_action_spec *dest);
// init_domain_components
// file urlmatch.h line 43
extern enum privoxy_err init_domain_components(struct http_request *http);
// init_error_log
// file errlog.c line 309
extern void init_error_log(const char *prog_name, const char *logfname);
// init_list
// file list.h line 48
extern void init_list(struct list *the_list);
// init_log_module
// file errlog.c line 221
extern void init_log_module(void);
// initgroups
// file /usr/include/grp.h line 200
extern signed int initgroups(const char *, unsigned int);
// initialize_mutexes
// file jcc.c line 3237
static void initialize_mutexes(void);
// initialize_reusable_connections
// file gateway.c line 154
extern void initialize_reusable_connections(void);
// is_hex_sequence
// file pcrs.c line 936
static signed int is_hex_sequence(const char *sequence);
// is_imageurl
// file filters.c line 1334
extern signed int is_imageurl(struct client_state *csp);
// is_untrusted_url
// file filters.c line 1381
extern signed int is_untrusted_url(struct client_state *csp);
// javascriptify
// file cgiedit.c line 4099
static void javascriptify(char *identifier);
// jb_err_to_string
// file errlog.c line 986
extern const char * jb_err_to_string(signed int jb_error);
// list_append_list_unique
// file list.h line 55
extern enum privoxy_err list_append_list_unique(struct list *dest, struct list *src);
// list_contains_item
// file list.h line 66
extern signed int list_contains_item(struct list *the_list, const char *str);
// list_duplicate
// file list.h line 56
extern enum privoxy_err list_duplicate(struct list *dest, struct list *src);
// list_is_empty
// file list.h line 62
extern signed int list_is_empty(struct list *the_list);
// list_is_valid
// file list.c line 147
static signed int list_is_valid(struct list *the_list);
// list_remove_all
// file list.h line 60
extern void list_remove_all(struct list *the_list);
// list_remove_item
// file list.h line 58
extern signed int list_remove_item(struct list *the_list, const char *str);
// list_remove_list
// file list.h line 59
extern signed int list_remove_list(struct list *dest, struct list *src);
// list_to_text
// file list.h line 64
extern char * list_to_text(struct list *the_list);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// listen_loop
// file jcc.c line 3917
static void listen_loop(void);
// load_action_files
// file actions.c line 1057
extern signed int load_action_files(struct client_state *csp);
// load_config
// file loadcfg.h line 64
extern struct configuration_spec * load_config(void);
// load_file
// file cgisimple.c line 1951
static enum privoxy_err load_file(const char *filename, char **buffer, unsigned long int *length);
// load_one_actions_file
// file actions.c line 1174
static signed int load_one_actions_file(struct client_state *csp, signed int fileid);
// load_one_re_filterfile
// file loaders.c line 1111
static signed int load_one_re_filterfile(struct client_state *csp, signed int fileid);
// load_re_filterfiles
// file loaders.h line 76
extern signed int load_re_filterfiles(struct client_state *csp);
// load_trustfile
// file loaders.h line 79
extern signed int load_trustfile(struct client_state *csp);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// lock_logfile
// file errlog.c line 108
static inline void lock_logfile(void);
// lock_loginit
// file errlog.c line 116
static inline void lock_loginit(void);
// log_applied_actions
// file jcc.c line 720
static void log_applied_actions(struct current_action_spec *actions);
// log_error
// file errlog.h line 70
extern void log_error(signed int loglevel, const char *fmt, ...);
// lookup
// file list.h line 85
extern const char * lookup(struct map *the_map, const char *name);
// main::_tmp::return_value_signal_14_object
//
void return_value_signal_14_object(signed int);
// main::_tmp::return_value_signal_15_object
//
void return_value_signal_15_object(signed int);
// make_menu
// file cgi.c line 2382
extern char * make_menu(const char *self, const unsigned int feature_flags);
// make_path
// file miscutil.h line 69
extern char * make_path(const char *dir, const char *file);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// malloc_or_die
// file miscutil.h line 50
extern void * malloc_or_die(unsigned long int buffer_size);
// map
// file list.h line 80
extern enum privoxy_err map(struct map *the_map, const char *name, signed int name_needs_copying, const char *value, signed int value_needs_copying);
// map_block_keep
// file cgi.c line 2293
extern enum privoxy_err map_block_keep(struct map *exports, const char *name);
// map_block_killer
// file cgi.c line 2264
extern enum privoxy_err map_block_killer(struct map *exports, const char *name);
// map_conditional
// file cgi.c line 2340
extern enum privoxy_err map_conditional(struct map *exports, const char *name, signed int choose_first);
// map_copy_parameter_html
// file cgiedit.c line 394
static enum privoxy_err map_copy_parameter_html(struct map *out, struct map *in, const char *name);
// map_radio
// file cgiedit.c line 1955
static enum privoxy_err map_radio(struct map *exports, const char *optionname, const char *values, signed int value);
// mark_connection_closed
// file gateway.c line 280
extern void mark_connection_closed(struct reusable_connection *closed_connection);
// mark_connection_unused
// file gateway.c line 533
static signed int mark_connection_unused(struct reusable_connection *connection);
// mark_server_socket_tainted
// file jcc.c line 1214
static void mark_server_socket_tainted(struct client_state *csp);
// mark_socket_for_close_on_execute
// file jbsockets.h line 65
extern void mark_socket_for_close_on_execute(signed int fd);
// match_actions_file_header_line
// file cgiedit.c line 952
static signed int match_actions_file_header_line(const char *line, const char *name);
// match_portlist
// file urlmatch.h line 58
extern signed int match_portlist(const char *portlist, signed int port);
// match_sockaddr
// file filters.c line 168
static signed int match_sockaddr(struct sockaddr_storage *network, struct sockaddr_storage *netmask, struct sockaddr_storage *address);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// merge_actions
// file actions.c line 144
extern enum privoxy_err merge_actions(struct action_spec *dest, struct action_spec *src);
// merge_current_action
// file actions.c line 737
extern enum privoxy_err merge_current_action(struct current_action_spec *dest, struct action_spec *src);
// mkstemp
// file /usr/include/stdlib.h line 619
extern signed int mkstemp(char *);
// new_map
// file list.h line 77
extern struct map * new_map(void);
// normalize_http_version
// file urlmatch.c line 497
static enum privoxy_err normalize_http_version(char *http_version);
// normalize_lws
// file parsers.c line 768
static void normalize_lws(char *header);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// parse_cgi_parameters
// file cgi.c line 612
static struct map * parse_cgi_parameters(char *argstring);
// parse_client_header_order
// file loadcfg.c line 386
static void parse_client_header_order(struct list *ordered_header_list, const char *ordered_headers);
// parse_client_request
// file jcc.c line 1718
static enum privoxy_err parse_client_request(struct client_state *csp);
// parse_forwarder_address
// file urlmatch.h line 59
extern enum privoxy_err parse_forwarder_address(char *address, char **hostname, signed int *port);
// parse_header_time
// file parsers.c line 4257
static enum privoxy_err parse_header_time(const char *header_time, signed long int *result);
// parse_http_request
// file urlmatch.h line 45
extern enum privoxy_err parse_http_request(const char *req, struct http_request *http);
// parse_http_url
// file urlmatch.h line 46
extern enum privoxy_err parse_http_url(const char *url, struct http_request *http, signed int require_protocol);
// parse_numeric_value
// file loadcfg.c line 300
static signed int parse_numeric_value(const char *name, const char *value);
// parse_time_header
// file parsers.c line 4359
static enum privoxy_err parse_time_header(const char *header, signed long int *result);
// parse_toggle_state
// file loadcfg.c line 341
static signed int parse_toggle_state(const char *name, const char *value);
// path_matches
// file urlmatch.c line 1307
static signed int path_matches(const char *path, struct pattern_spec *pattern);
// pclose
// file /usr/include/stdio.h line 878
extern signed int pclose(struct _IO_FILE *);
// pcre_compile
// file /usr/include/pcre.h line 540
extern struct real_pcre * pcre_compile(const char *, signed int, const char **, signed int *, const unsigned char *);
// pcre_exec
// file /usr/include/pcre.h line 573
extern signed int pcre_exec(const struct real_pcre *, const struct pcre_extra *, const char *, signed int, signed int, signed int, signed int *, signed int);
// pcre_fullinfo
// file /usr/include/pcre.h line 594
extern signed int pcre_fullinfo(const struct real_pcre *, const struct pcre_extra *, signed int, void *);
// pcre_study
// file /usr/include/pcre.h line 633
extern struct pcre_extra * pcre_study(const struct real_pcre *, signed int, const char **);
// pcreposix_regcomp
// file /usr/include/pcreposix.h line 136
extern signed int pcreposix_regcomp(struct anonymous_3 *, const char *, signed int);
// pcreposix_regerror
// file /usr/include/pcreposix.h line 139
extern unsigned long int pcreposix_regerror(signed int, const struct anonymous_3 *, char *, unsigned long int);
// pcreposix_regexec
// file /usr/include/pcreposix.h line 137
extern signed int pcreposix_regexec(const struct anonymous_3 *, const char *, unsigned long int, struct anonymous_4 *, signed int);
// pcreposix_regfree
// file /usr/include/pcreposix.h line 140
extern void pcreposix_regfree(struct anonymous_3 *);
// pcrs_compile
// file pcrs.h line 105
extern struct PCRS_JOB * pcrs_compile(const char *pattern, const char *substitute, const char *options, signed int *errptr);
// pcrs_compile_command
// file pcrs.h line 104
extern struct PCRS_JOB * pcrs_compile_command(const char *command, signed int *errptr);
// pcrs_compile_dynamic_command
// file pcrs.h line 129
extern struct PCRS_JOB * pcrs_compile_dynamic_command(char *pcrs_command, struct pcrs_variable *v, signed int *error);
// pcrs_compile_replacement
// file pcrs.c line 209
static struct anonymous_12 * pcrs_compile_replacement(const char *replacement, signed int trivialflag, signed int capturecount, signed int *errptr);
// pcrs_execute
// file pcrs.h line 106
extern signed int pcrs_execute(struct PCRS_JOB *job, const char *subject, unsigned long int subject_length, char **result, unsigned long int *result_length);
// pcrs_execute_list
// file pcrs.c line 696
extern signed int pcrs_execute_list(struct PCRS_JOB *joblist, char *subject, unsigned long int subject_length, char **result, unsigned long int *result_length);
// pcrs_execute_single_command
// file pcrs.h line 118
extern char * pcrs_execute_single_command(const char *subject, const char *pcrs_command, signed int *hits);
// pcrs_filter_response
// file filters.c line 1576
static char * pcrs_filter_response(struct client_state *csp);
// pcrs_free_job
// file pcrs.h line 110
extern struct PCRS_JOB * pcrs_free_job(struct PCRS_JOB *job);
// pcrs_free_joblist
// file pcrs.h line 111
extern void pcrs_free_joblist(struct PCRS_JOB *joblist);
// pcrs_get_delimiter
// file pcrs.c line 1011
extern char pcrs_get_delimiter(const char *string);
// pcrs_job_is_dynamic
// file pcrs.h line 116
extern signed int pcrs_job_is_dynamic(char *job);
// pcrs_parse_perl_options
// file pcrs.c line 156
static signed int pcrs_parse_perl_options(const char *optstring, signed int *flags);
// pcrs_strerror
// file pcrs.h line 114
extern const char * pcrs_strerror(const signed int error);
// percent_encode_url
// file encode.c line 402
extern char * percent_encode_url(const char *s);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pick_from_range
// file miscutil.c line 722
signed long int pick_from_range(signed long int range);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// popen
// file /usr/include/stdio.h line 872
extern struct _IO_FILE * popen(const char *, const char *);
// port_matches
// file urlmatch.c line 1262
static signed int port_matches(const signed int port, const char *port_list);
// prepare_csp_for_next_request
// file jcc.c line 2802
static void prepare_csp_for_next_request(struct client_state *csp);
// prepare_for_filtering
// file filters.c line 2156
static enum privoxy_err prepare_for_filtering(struct client_state *csp);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// privoxy_mutex_init
// file jcc.c line 3210
static void privoxy_mutex_init(union anonymous_2 *mutex);
// privoxy_mutex_lock
// file jcc.h line 75
extern void privoxy_mutex_lock(union anonymous_2 *mutex);
// privoxy_mutex_unlock
// file jcc.h line 76
extern void privoxy_mutex_unlock(union anonymous_2 *mutex);
// privoxy_strlcat
// file miscutil.h line 90
unsigned long int privoxy_strlcat(char *destination, const char *source, const unsigned long int size);
// privoxy_strlcpy
// file miscutil.h line 83
unsigned long int privoxy_strlcpy(char *destination, const char *source, const unsigned long int size);
// proxy_authentication
// file parsers.c line 1716
static enum privoxy_err proxy_authentication(struct client_state *csp, char **header);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_2 *, const union anonymous_14 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_2 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_2 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// putenv
// file /usr/include/stdlib.h line 578
extern signed int putenv(char *);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_config_line
// file loaders.h line 42
extern char * read_config_line(struct _IO_FILE *fp, unsigned long int *linenum, char **buf);
// read_socket
// file jbsockets.h line 51
extern signed int read_socket(signed int fd, char *buf, signed int len);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// receive_chunked_client_request_body
// file jcc.c line 1415
static enum privoxy_err receive_chunked_client_request_body(struct client_state *csp);
// receive_client_request
// file jcc.c line 1536
static enum privoxy_err receive_client_request(struct client_state *csp);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// redirect_url
// file filters.c line 1185
extern struct http_response * redirect_url(struct client_state *csp);
// referenced_filters_are_missing
// file actions.c line 1099
static signed int referenced_filters_are_missing(struct client_state *csp, struct action_spec *cur_action, signed int multi_index, enum filter_type filter_type);
// referrer_is_safe
// file cgi.c line 423
static signed int referrer_is_safe(struct client_state *csp);
// remember_connection
// file gateway.c line 186
extern void remember_connection(struct reusable_connection *connection);
// remove_chunked_transfer_coding
// file filters.c line 2051
static enum privoxy_err remove_chunked_transfer_coding(char *buffer, unsigned long int *size);
// resolve_hostname_to_ip
// file jbsockets.h line 60
extern unsigned long int resolve_hostname_to_ip(const char *host);
// rewrite_url
// file filters.c line 985
extern char * rewrite_url(char *old_url, const char *pcrs_command);
// rfc2553_connect_to
// file jbsockets.c line 207
static signed int rfc2553_connect_to(const char *host, signed int portnum, struct client_state *csp);
// run_loader
// file loaders.h line 93
extern signed int run_loader(struct client_state *csp);
// save_connection_destination
// file jcc.c line 1057
void save_connection_destination(signed int sfd, struct http_request *http, struct forward_spec *fwd, struct reusable_connection *server_connection);
// savearg
// file loadcfg.c line 1856
static void savearg(char *command, char *argument, struct configuration_spec *config);
// scan_headers
// file parsers.c line 1012
static enum privoxy_err scan_headers(struct client_state *csp);
// section_target
// file cgiedit.c line 345
static char * section_target(const unsigned int sectionid);
// sed
// file parsers.h line 59
extern enum privoxy_err sed(struct client_state *csp, signed int filter_server_headers);

//

// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_13 *, struct anonymous_13 *, struct anonymous_13 *, struct timeval *);
// send_crunch_response
// file jcc.c line 750
static void send_crunch_response(struct client_state *csp, struct http_response *rsp);
// serve
// file jcc.c line 2880
static void serve(struct client_state *csp);
// server_adjust_content_encoding
// file parsers.c line 2410
static enum privoxy_err server_adjust_content_encoding(struct client_state *csp, char **header);
// server_adjust_content_length
// file parsers.c line 2451
static enum privoxy_err server_adjust_content_length(struct client_state *csp, char **header);
// server_connection
// file parsers.c line 1585
static enum privoxy_err server_connection(struct client_state *csp, char **header);
// server_connection_adder
// file parsers.c line 3727
static enum privoxy_err server_connection_adder(struct client_state *csp);
// server_content_disposition
// file parsers.c line 2563
static enum privoxy_err server_content_disposition(struct client_state *csp, char **header);
// server_content_encoding
// file parsers.c line 2315
static enum privoxy_err server_content_encoding(struct client_state *csp, char **header);
// server_content_md5
// file parsers.c line 2533
static enum privoxy_err server_content_md5(struct client_state *csp, char **header);
// server_content_type
// file parsers.c line 2141
static enum privoxy_err server_content_type(struct client_state *csp, char **header);
// server_http
// file parsers.c line 3861
static enum privoxy_err server_http(struct client_state *csp, char **header);
// server_keep_alive
// file parsers.c line 1639
static enum privoxy_err server_keep_alive(struct client_state *csp, char **header);
// server_last_modified
// file parsers.c line 2625
static enum privoxy_err server_last_modified(struct client_state *csp, char **header);
// server_proxy_connection
// file parsers.c line 1691
static enum privoxy_err server_proxy_connection(struct client_state *csp, char **header);
// server_proxy_connection_adder
// file parsers.c line 3778
static enum privoxy_err server_proxy_connection_adder(struct client_state *csp);
// server_response_is_complete
// file jcc.c line 980
static signed int server_response_is_complete(struct client_state *csp, unsigned long long int content_length);
// server_save_content_length
// file parsers.c line 2490
static enum privoxy_err server_save_content_length(struct client_state *csp, char **header);
// server_set_cookie
// file parsers.c line 4003
static enum privoxy_err server_set_cookie(struct client_state *csp, char **header);
// server_transfer_coding
// file parsers.c line 2247
static enum privoxy_err server_transfer_coding(struct client_state *csp, char **header);
// set_debug_level
// file errlog.c line 246
extern void set_debug_level(signed int debug_level);
// set_keep_alive_timeout
// file gateway.c line 578
extern void set_keep_alive_timeout(unsigned int timeout);
// set_no_delay_flag
// file jbsockets.c line 138
static void set_no_delay_flag(signed int fd);
// set_privoxy_variables
// file filters.c line 1754
static void set_privoxy_variables(struct client_state *csp);
// setbuf
// file /usr/include/stdio.h line 332
extern void setbuf(struct _IO_FILE *, char *);
// setenv
// file /usr/include/stdlib.h line 584
extern signed int setenv(const char *, const char *, signed int);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// setgroups
// file /usr/include/grp.h line 179
extern signed int setgroups(unsigned long int, const unsigned int *);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// show_defines
// file cgisimple.c line 1535
static enum privoxy_err show_defines(struct map *exports);
// show_rcs
// file cgisimple.c line 1732
static char * show_rcs(void);
// show_version
// file errlog.c line 197
extern void show_version(const char *prog_name);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// sig_handler
// file jcc.c line 342
static void sig_handler(signed int the_signal);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// simple_domaincmp
// file urlmatch.c line 1033
static signed int simple_domaincmp(char **pv, char **fv, signed int len);
// simple_read_line
// file loaders.c line 341
extern enum privoxy_err simple_read_line(struct _IO_FILE *fp, char **dest, signed int *newline);
// simplematch
// file urlmatch.c line 892
static signed int simplematch(const char *pattern, const char *text);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sockaddr_storage_to_ip
// file filters.c line 103
static signed int sockaddr_storage_to_ip(struct sockaddr_storage *addr, unsigned char **ip, unsigned int *len, unsigned short int **port);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socket_is_still_alive
// file jbsockets.h line 62
extern signed int socket_is_still_alive(signed int sfd);
// socks4_connect
// file gateway.c line 690
static signed int socks4_connect(struct forward_spec *fwd, const char *target_host, signed int target_port, struct client_state *csp);
// socks5_connect
// file gateway.c line 933
static signed int socks5_connect(struct forward_spec *fwd, const char *target_host, signed int target_port, struct client_state *csp);
// split_line_on_equals
// file cgiedit.c line 1016
static enum privoxy_err split_line_on_equals(const char *line, char **pname, char **pvalue);
// srandom
// file /usr/include/stdlib.h line 324
extern void srandom(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// ssplit
// file ssplit.h line 38
extern signed int ssplit(char *str, const char *delim, char **vec, unsigned long int vec_len);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strclean
// file parsers.h line 67
extern signed int strclean(char *string, const char *substring);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcmpic
// file miscutil.h line 58
extern signed int strcmpic(const char *s1, const char *s2);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strdup_or_die
// file miscutil.h line 49
extern char * strdup_or_die(const char *str);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// string_append
// file miscutil.h line 61
extern enum privoxy_err string_append(char **target_string, const char *text_to_append);
// string_join
// file miscutil.h line 62
extern enum privoxy_err string_join(char **target_string, char *text_to_append);
// string_move
// file miscutil.h line 64
extern void string_move(char *dst, char *src);
// string_toupper
// file miscutil.h line 63
extern char * string_toupper(const char *string);
// stringify
// file cgiedit.c line 367
static char * stringify(const unsigned int number);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncmpic
// file miscutil.h line 59
extern signed int strncmpic(const char *s1, const char *s2, unsigned long int n);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strpbrk
// file /usr/include/string.h line 314
extern char * strpbrk(const char *, const char *);
// strptime
// file /usr/include/time.h line 213
extern char * strptime(const char *, const char *, struct tm *);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// sweep
// file loaders.h line 41
extern unsigned int sweep(void);
// template_fill
// file cgi.c line 1981
extern enum privoxy_err template_fill(char **template_ptr, struct map *exports);
// template_fill_for_cgi
// file cgi.c line 2107
extern enum privoxy_err template_fill_for_cgi(struct client_state *csp, const char *templatename, struct map *exports, struct http_response *rsp);
// template_load
// file cgi.c line 1829
extern enum privoxy_err template_load(struct client_state *csp, char **template_ptr, const char *templatename, signed int recursive);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timegm
// file /usr/include/time.h line 319
extern signed long int timegm(struct tm *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// translate_socks5_error
// file gateway.c line 886
static const char * translate_socks5_error(signed int socks_error);
// trust_url
// file filters.c line 754
extern struct http_response * trust_url(struct client_state *csp);
// tzset
// file /usr/include/time.h line 293
extern void tzset(void);
// ungetc
// file /usr/include/stdio.h line 702
extern signed int ungetc(signed int, struct _IO_FILE *);
// unknown_method
// file urlmatch.c line 431
static signed int unknown_method(const char *method);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unload_actions_file
// file actions.c line 994
extern void unload_actions_file(void *file_data);
// unload_configfile
// file loadcfg.c line 192
static void unload_configfile(void *data);
// unload_forward_spec
// file loaders.h line 89
void unload_forward_spec(struct forward_spec *fwd);
// unload_re_filterfile
// file loaders.c line 981
static void unload_re_filterfile(void *f);
// unload_trustfile
// file loaders.c line 773
static void unload_trustfile(void *f);
// unlock_logfile
// file errlog.c line 112
static inline void unlock_logfile(void);
// unlock_loginit
// file errlog.c line 120
static inline void unlock_loginit(void);
// unmap
// file list.h line 83
extern enum privoxy_err unmap(struct map *the_map, const char *name);
// update_action_bits_for_tag
// file actions.c line 797
extern signed int update_action_bits_for_tag(struct client_state *csp, const char *tag);
// update_server_headers
// file parsers.h line 60
extern enum privoxy_err update_server_headers(struct client_state *csp);
// url_decode
// file encode.h line 41
extern char * url_decode(const char *s);
// url_encode
// file encode.h line 40
extern char * url_encode(const char *s);
// url_match
// file urlmatch.h line 53
extern signed int url_match(struct pattern_spec *pattern, struct http_request *http);
// url_requires_percent_encoding
// file urlmatch.h line 49
extern signed int url_requires_percent_encoding(const char *url);
// usage
// file jcc.c line 3115
static void usage(const char *myname);
// verify_request_length
// file jcc.c line 1118
static void verify_request_length(struct client_state *csp);
// wait_for_alive_connections
// file jcc.c line 1023
static void wait_for_alive_connections(void);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_pid_file
// file miscutil.h line 53
extern void write_pid_file(void);
// write_socket
// file jbsockets.h line 49
extern signed int write_socket(signed int fd, const char *buf, unsigned long int len);
// xdtoi
// file encode.c line 276
static signed int xdtoi(const signed int d);
// xtoi
// file encode.c line 310
extern signed int xtoi(const char *s);
// zalloc
// file miscutil.h line 48
extern void * zalloc(unsigned long int size);

struct anonymous_0
{
  // name
  char *name;
  // svalue
  char *svalue;
  // ivalue
  signed int ivalue;
};

struct anonymous_12
{
  // text
  char *text;
  // length
  unsigned long int length;
  // backrefs
  signed int backrefs;
  // block_offset
  signed int block_offset[33l];
  // block_length
  unsigned long int block_length[33l];
  // backref
  signed int backref[33l];
  // backref_count
  signed int backref_count[35l];
};

struct anonymous_3
{
  // re_pcre
  void *re_pcre;
  // re_nsub
  unsigned long int re_nsub;
  // re_erroffset
  unsigned long int re_erroffset;
};

struct anonymous_13
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_4
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous_7
{
  // submatches
  signed int submatches;
  // submatch_offset
  signed int submatch_offset[35l];
  // submatch_length
  unsigned long int submatch_length[35l];
};

union anonymous_9
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

struct list
{
  // first
  struct list_entry *first;
  // last
  struct list_entry *last;
};

struct action_spec
{
  // mask
  unsigned long int mask;
  // add
  unsigned long int add;
  // string
  char *string[19l];
  // multi_remove
  struct list multi_remove[7l][1l];
  // multi_remove_all
  signed int multi_remove_all[7l];
  // multi_add
  struct list multi_add[7l][1l];
};

union anonymous
{
  // action
  struct action_spec action[1l];
  // setting
  struct anonymous_0 setting;
};

union anonymous_14
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_2
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct url_spec
{
  // dbuffer
  char *dbuffer;
  // dvec
  char **dvec;
  // dcount
  signed int dcount;
  // unanchored
  signed int unanchored;
  // port_list
  char *port_list;
  // preg
  struct anonymous_3 *preg;
};

union anonymous_5
{
  // url_spec
  struct url_spec url_spec;
  // tag_regex
  struct anonymous_3 *tag_regex;
};

struct PCRS_JOB
{
  // pattern
  struct real_pcre *pattern;
  // hints
  struct pcre_extra *hints;
  // options
  signed int options;
  // flags
  signed int flags;
  // substitute
  struct anonymous_12 *substitute;
  // next
  struct PCRS_JOB *next;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct access_control_addr
{
  // addr
  struct sockaddr_storage addr;
  // mask
  struct sockaddr_storage mask;
};

struct access_control_list
{
  // src
  struct access_control_addr src[1l];
  // dst
  struct access_control_addr dst[1l];
  // wildcard_dst
  signed int wildcard_dst;
  // action
  signed short int action;
  // next
  struct access_control_list *next;
};

struct action_alias
{
  // name
  const char *name;
  // action
  struct action_spec action[1l];
  // next
  struct action_alias *next;
};

struct action_name
{
  // name
  const char *name;
  // mask
  unsigned long int mask;
  // add
  unsigned long int add;
  // value_type
  enum action_value_type value_type;
  // index
  signed int index;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct binbuffer
{
  // buffer
  char *buffer;
  // offset
  unsigned long int offset;
  // size
  unsigned long int size;
};

struct pattern_spec
{
  // spec
  char *spec;
  // pattern
  union anonymous_5 pattern;
  // flags
  unsigned int flags;
};

struct block_spec
{
  // url
  struct pattern_spec url[1l];
  // reject
  signed int reject;
  // next
  struct block_spec *next;
};

struct cgi_dispatcher
{
  // name
  const char * const name;
  // handler
  enum privoxy_err (* const handler)(struct client_state *, struct http_response *, struct map *);
  // description
  const char * const description;
  // harmless
  signed int harmless;
};

struct current_action_spec
{
  // flags
  unsigned long int flags;
  // string
  char *string[19l];
  // multi
  struct list multi[7l][1l];
};

struct reusable_connection
{
  // sfd
  signed int sfd;
  // in_use
  signed int in_use;
  // timestamp
  signed long int timestamp;
  // request_sent
  signed long int request_sent;
  // response_received
  signed long int response_received;
  // keep_alive_timeout
  unsigned int keep_alive_timeout;
  // requests_sent_total
  unsigned int requests_sent_total;
  // host
  char *host;
  // port
  signed int port;
  // forwarder_type
  enum forwarder_type forwarder_type;
  // gateway_host
  char *gateway_host;
  // gateway_port
  signed int gateway_port;
  // forward_host
  char *forward_host;
  // forward_port
  signed int forward_port;
};

struct http_request
{
  // cmd
  char *cmd;
  // ocmd
  char *ocmd;
  // gpc
  char *gpc;
  // url
  char *url;
  // ver
  char *ver;
  // status
  signed int status;
  // host
  char *host;
  // port
  signed int port;
  // path
  char *path;
  // hostport
  char *hostport;
  // ssl
  signed int ssl;
  // host_ip_addr_str
  char *host_ip_addr_str;
  // dbuffer
  char *dbuffer;
  // dvec
  char **dvec;
  // dcount
  signed int dcount;
};

struct iob
{
  // buf
  char *buf;
  // cur
  char *cur;
  // eod
  char *eod;
  // size
  unsigned long int size;
};

struct file_list
{
  // f
  void *f;
  // unloader
  void (*unloader)(void *);
  // active
  signed int active;
  // lastmodified
  signed long int lastmodified;
  // filename
  char *filename;
  // next
  struct file_list *next;
};

struct client_state
{
  // config
  struct configuration_spec *config;
  // action
  struct current_action_spec action[1l];
  // cfd
  signed int cfd;
  // requests_received_total
  unsigned int requests_received_total;
  // server_connection
  struct reusable_connection server_connection;
  // flags
  unsigned int flags;
  // ip_addr_str
  char *ip_addr_str;
  // tcp_addr
  struct sockaddr_storage tcp_addr;
  // http
  struct http_request http[1l];
  // fwd
  struct forward_spec *fwd;
  // iob
  struct iob iob[1l];
  // client_iob
  struct iob client_iob[1l];
  // headers
  struct list headers[1l];
  // tags
  struct list tags[1l];
  // content_type
  unsigned int content_type;
  // actions_list
  struct file_list *actions_list[30l];
  // rlist
  struct file_list *rlist[30l];
  // content_length
  unsigned long long int content_length;
  // expected_content_length
  unsigned long long int expected_content_length;
  // expected_client_content_length
  unsigned long long int expected_client_content_length;
  // tlist
  struct file_list *tlist;
  // error_message
  char *error_message;
};

struct client_states
{
  // next
  struct client_states *next;
  // csp
  struct client_state csp;
};

struct configuration_spec
{
  // debug
  signed int debug;
  // multi_threaded
  signed int multi_threaded;
  // feature_flags
  unsigned int feature_flags;
  // logfile
  const char *logfile;
  // confdir
  const char *confdir;
  // templdir
  const char *templdir;
  // temporary_directory
  const char *temporary_directory;
  // logdir
  const char *logdir;
  // actions_file
  const char *actions_file[30l];
  // actions_file_short
  const char *actions_file_short[30l];
  // admin_address
  char *admin_address;
  // proxy_info_url
  char *proxy_info_url;
  // usermanual
  char *usermanual;
  // re_filterfile
  const char *re_filterfile[30l];
  // re_filterfile_short
  const char *re_filterfile_short[30l];
  // ordered_client_headers
  struct list ordered_client_headers[1l];
  // hostname
  const char *hostname;
  // haddr
  const char *haddr[10l];
  // hport
  signed int hport[10l];
  // buffer_limit
  unsigned long int buffer_limit;
  // trustfile
  const char *trustfile;
  // trust_info
  struct list trust_info[1l];
  // trust_list
  struct pattern_spec *trust_list[512l];
  // acl
  struct access_control_list *acl;
  // forward
  struct forward_spec *forward;
  // forwarded_connect_retries
  signed int forwarded_connect_retries;
  // max_client_connections
  signed int max_client_connections;
  // socket_timeout
  signed int socket_timeout;
  // keep_alive_timeout
  unsigned int keep_alive_timeout;
  // default_server_timeout
  unsigned int default_server_timeout;
  // proxy_args
  char *proxy_args;
  // config_file_list
  struct file_list *config_file_list;
  // loaders
  signed int (*loaders[8l])(struct client_state *);
  // need_bind
  signed int need_bind;
};

struct cruncher
{
  // cruncher
  struct http_response * (* const cruncher)(struct client_state *);
  // flags
  const signed int flags;
};

struct editable_file
{
  // lines
  struct file_line *lines;
  // filename
  const char *filename;
  // identifier
  unsigned int identifier;
  // version_str
  const char *version_str;
  // version
  unsigned int version;
  // newline
  signed int newline;
  // parse_error
  struct file_line *parse_error;
  // parse_error_text
  const char *parse_error_text;
};

struct file_line
{
  // next
  struct file_line *next;
  // raw
  char *raw;
  // prefix
  char *prefix;
  // unprocessed
  char *unprocessed;
  // type
  signed int type;
  // data
  union anonymous data;
};

struct filter_type_info
{
  // multi_action_index
  const signed int multi_action_index;
  // macro_name
  const char *macro_name;
  // type
  const char *type;
  // disable_all_option
  const char *disable_all_option;
  // disable_all_param
  const char *disable_all_param;
  // abbr_type
  const char *abbr_type;
  // anchor
  const char *anchor;
};

struct forward_spec
{
  // url
  struct pattern_spec url[1l];
  // type
  enum forwarder_type type;
  // gateway_host
  char *gateway_host;
  // gateway_port
  signed int gateway_port;
  // forward_host
  char *forward_host;
  // forward_port
  signed int forward_port;
  // next
  struct forward_spec *next;
};

struct group
{
  // gr_name
  char *gr_name;
  // gr_passwd
  char *gr_passwd;
  // gr_gid
  unsigned int gr_gid;
  // gr_mem
  char **gr_mem;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct http_response
{
  // status
  char *status;
  // headers
  struct list headers[1l];
  // head
  char *head;
  // head_length
  unsigned long int head_length;
  // body
  char *body;
  // content_length
  unsigned long int content_length;
  // is_static
  signed int is_static;
  // crunch_reason
  enum crunch_reason crunch_reason;
};

struct in6_addr
{
  // __in6_u
  union anonymous_9 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct internal_state
{
  // dummy
  signed int dummy;
};

struct linger
{
  // l_onoff
  signed int l_onoff;
  // l_linger
  signed int l_linger;
};

struct list_entry
{
  // str
  char *str;
  // next
  struct list_entry *next;
};

struct map
{
  // first
  struct map_entry *first;
  // last
  struct map_entry *last;
};

struct map_entry
{
  // name
  const char *name;
  // value
  const char *value;
  // next
  struct map_entry *next;
};

struct parsers
{
  // str
  const char *str;
  // len
  const unsigned long int len;
  // parser
  enum privoxy_err (* const parser)(struct client_state *, char **);
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pcre_extra
{
  // flags
  unsigned long int flags;
  // study_data
  void *study_data;
  // match_limit
  unsigned long int match_limit;
  // callout_data
  void *callout_data;
  // tables
  const unsigned char *tables;
  // match_limit_recursion
  unsigned long int match_limit_recursion;
  // mark
  unsigned char **mark;
  // executable_jit
  void *executable_jit;
};

struct pcrs_variable
{
  // name
  const char *name;
  // value
  char *value;
  // static_value
  signed int static_value;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct re_filterfile_spec
{
  // name
  char *name;
  // description
  char *description;
  // patterns
  struct list patterns[1l];
  // joblist
  struct PCRS_JOB *joblist;
  // type
  enum filter_type type;
  // dynamic
  signed int dynamic;
  // next
  struct re_filterfile_spec *next;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct socks_op
{
  // vn
  unsigned char vn;
  // cd
  unsigned char cd;
  // dstport
  unsigned char dstport[2l];
  // dstip
  unsigned char dstip[4l];
  // userid
  char userid;
  // padding
  char padding[3l];
};

struct socks_reply
{
  // vn
  unsigned char vn;
  // cd
  unsigned char cd;
  // dstport
  unsigned char dstport[2l];
  // dstip
  unsigned char dstip[4l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct url_actions
{
  // url
  struct pattern_spec url[1l];
  // action
  struct action_spec *action;
  // next
  struct url_actions *next;
};

struct z_stream_s
{
  // next_in
  unsigned char *next_in;
  // avail_in
  unsigned int avail_in;
  // total_in
  unsigned long int total_in;
  // next_out
  unsigned char *next_out;
  // avail_out
  unsigned int avail_out;
  // total_out
  unsigned long int total_out;
  // msg
  char *msg;
  // state
  struct internal_state *state;
  // zalloc
  void * (*zalloc)(void *, unsigned int, unsigned int);
  // zfree
  void (*zfree)(void *, void *);
  // opaque
  void *opaque;
  // data_type
  signed int data_type;
  // adler
  unsigned long int adler;
  // reserved
  unsigned long int reserved;
};


// Argc
// file loadcfg.c line 103
signed int Argc = 0;
// Argv
// file loadcfg.c line 104
char * const *Argv = (char * const *)(void *)0;
// CHEADER
// file jcc.c line 217
static const char CHEADER[136l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '1', ' ', '4', '0', '0', ' ', 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'h', 'e', 'a', 'd', 'e', 'r', ' ', 'r', 'e', 'c', 'e', 'i', 'v', 'e', 'd', ' ', 'f', 'r', 'o', 'm', ' ', 'c', 'l', 'i', 'e', 'n', 't', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'T', 'y', 'p', 'e', ':', ' ', 't', 'e', 'x', 't', '/', 'p', 'l', 'a', 'i', 'n', '\r', '\n', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'c', 'l', 'o', 's', 'e', '\r', '\n', '\r', '\n', 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'h', 'e', 'a', 'd', 'e', 'r', ' ', 'r', 'e', 'c', 'e', 'i', 'v', 'e', 'd', ' ', 'f', 'r', 'o', 'm', ' ', 'c', 'l', 'i', 'e', 'n', 't', '.', '\r', '\n', 0 };
// CLIENT_BODY_PARSE_ERROR_RESPONSE
// file jcc.c line 268
static const char CLIENT_BODY_PARSE_ERROR_RESPONSE[149l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '1', ' ', '4', '0', '0', ' ', 'F', 'a', 'i', 'l', 'e', 'd', ' ', 'r', 'e', 'a', 'd', 'i', 'n', 'g', ' ', 'c', 'l', 'i', 'e', 'n', 't', ' ', 'b', 'o', 'd', 'y', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'T', 'y', 'p', 'e', ':', ' ', 't', 'e', 'x', 't', '/', 'p', 'l', 'a', 'i', 'n', '\r', '\n', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'c', 'l', 'o', 's', 'e', '\r', '\n', '\r', '\n', 'F', 'a', 'i', 'l', 'e', 'd', ' ', 'p', 'a', 'r', 's', 'i', 'n', 'g', ' ', 'o', 'r', ' ', 'b', 'u', 'f', 'f', 'e', 'r', 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'c', 'h', 'u', 'n', 'k', '-', 'e', 'n', 'c', 'o', 'd', 'e', 'd', ' ', 'c', 'l', 'i', 'e', 'n', 't', ' ', 'b', 'o', 'd', 'y', '.', '\r', '\n', 0 };
// CLIENT_CONNECTION_TIMEOUT_RESPONSE
// file jcc.c line 262
static const char CLIENT_CONNECTION_TIMEOUT_RESPONSE[157l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '1', ' ', '5', '0', '4', ' ', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 't', 'i', 'm', 'e', 'o', 'u', 't', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'T', 'y', 'p', 'e', ':', ' ', 't', 'e', 'x', 't', '/', 'p', 'l', 'a', 'i', 'n', '\r', '\n', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'c', 'l', 'o', 's', 'e', '\r', '\n', '\r', '\n', 'T', 'h', 'e', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 't', 'i', 'm', 'e', 'd', ' ', 'o', 'u', 't', ' ', 'b', 'e', 'c', 'a', 'u', 's', 'e', ' ', 't', 'h', 'e', ' ', 'c', 'l', 'i', 'e', 'n', 't', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', ' ', 'd', 'i', 'd', 'n', '\'', 't', ' ', 'a', 'r', 'r', 'i', 'v', 'e', ' ', 'i', 'n', ' ', 't', 'i', 'm', 'e', '.', '\r', '\n', 0 };
// CSUCCEED
// file jcc.c line 214
static const char CSUCCEED[40l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '1', ' ', '2', '0', '0', ' ', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 'e', 's', 't', 'a', 'b', 'l', 'i', 's', 'h', 'e', 'd', '\r', '\n', '\r', '\n', 0 };
// FTP_RESPONSE
// file jcc.c line 223
static const char FTP_RESPONSE[146l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '1', ' ', '4', '0', '0', ' ', 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', ' ', 'r', 'e', 'c', 'e', 'i', 'v', 'e', 'd', ' ', 'f', 'r', 'o', 'm', ' ', 'c', 'l', 'i', 'e', 'n', 't', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'T', 'y', 'p', 'e', ':', ' ', 't', 'e', 'x', 't', '/', 'p', 'l', 'a', 'i', 'n', '\r', '\n', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'c', 'l', 'o', 's', 'e', '\r', '\n', '\r', '\n', 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', '.', ' ', 'P', 'r', 'i', 'v', 'o', 'x', 'y', ' ', 'd', 'o', 'e', 's', 'n', '\'', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'F', 'T', 'P', '.', '\r', '\n', 0 };
// GOPHER_RESPONSE
// file jcc.c line 229
static const char GOPHER_RESPONSE[149l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '1', ' ', '4', '0', '0', ' ', 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', ' ', 'r', 'e', 'c', 'e', 'i', 'v', 'e', 'd', ' ', 'f', 'r', 'o', 'm', ' ', 'c', 'l', 'i', 'e', 'n', 't', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'T', 'y', 'p', 'e', ':', ' ', 't', 'e', 'x', 't', '/', 'p', 'l', 'a', 'i', 'n', '\r', '\n', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'c', 'l', 'o', 's', 'e', '\r', '\n', '\r', '\n', 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', '.', ' ', 'P', 'r', 'i', 'v', 'o', 'x', 'y', ' ', 'd', 'o', 'e', 's', 'n', '\'', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'g', 'o', 'p', 'h', 'e', 'r', '.', '\r', '\n', 0 };
// INVALID_SERVER_HEADERS_RESPONSE
// file jcc.c line 243
static const char INVALID_SERVER_HEADERS_RESPONSE[171l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '1', ' ', '5', '0', '2', ' ', 'S', 'e', 'r', 'v', 'e', 'r', ' ', 'o', 'r', ' ', 'f', 'o', 'r', 'w', 'a', 'r', 'd', 'e', 'r', ' ', 'r', 'e', 's', 'p', 'o', 'n', 's', 'e', ' ', 'i', 'n', 'v', 'a', 'l', 'i', 'd', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'T', 'y', 'p', 'e', ':', ' ', 't', 'e', 'x', 't', '/', 'p', 'l', 'a', 'i', 'n', '\r', '\n', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'c', 'l', 'o', 's', 'e', '\r', '\n', '\r', '\n', 'B', 'a', 'd', ' ', 'r', 'e', 's', 'p', 'o', 'n', 's', 'e', '.', ' ', 'T', 'h', 'e', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'o', 'r', ' ', 'f', 'o', 'r', 'w', 'a', 'r', 'd', 'e', 'r', ' ', 'r', 'e', 's', 'p', 'o', 'n', 's', 'e', ' ', 'd', 'o', 'e', 's', 'n', '\'', 't', ' ', 'l', 'o', 'o', 'k', ' ', 'l', 'i', 'k', 'e', ' ', 'H', 'T', 'T', 'P', '.', '\r', '\n', 0 };
// MESSED_UP_REQUEST_RESPONSE
// file jcc.c line 250
static const char MESSED_UP_REQUEST_RESPONSE[141l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '1', ' ', '4', '0', '0', ' ', 'M', 'a', 'l', 'f', 'o', 'r', 'm', 'e', 'd', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', ' ', 'a', 'f', 't', 'e', 'r', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'T', 'y', 'p', 'e', ':', ' ', 't', 'e', 'x', 't', '/', 'p', 'l', 'a', 'i', 'n', '\r', '\n', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'c', 'l', 'o', 's', 'e', '\r', '\n', '\r', '\n', 'B', 'a', 'd', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', '.', ' ', 'M', 'e', 's', 's', 'e', 'd', ' ', 'u', 'p', ' ', 'w', 'i', 't', 'h', ' ', 'h', 'e', 'a', 'd', 'e', 'r', ' ', 'f', 'i', 'l', 't', 'e', 'r', 's', '.', '\r', '\n', 0 };
// MISSING_DESTINATION_RESPONSE
// file jcc.c line 236
static const char MISSING_DESTINATION_RESPONSE[156l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '1', ' ', '4', '0', '0', ' ', 'B', 'a', 'd', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', ' ', 'r', 'e', 'c', 'e', 'i', 'v', 'e', 'd', ' ', 'f', 'r', 'o', 'm', ' ', 'c', 'l', 'i', 'e', 'n', 't', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'T', 'y', 'p', 'e', ':', ' ', 't', 'e', 'x', 't', '/', 'p', 'l', 'a', 'i', 'n', '\r', '\n', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'c', 'l', 'o', 's', 'e', '\r', '\n', '\r', '\n', 'B', 'a', 'd', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', '.', ' ', 'P', 'r', 'i', 'v', 'o', 'x', 'y', ' ', 'w', 'a', 's', ' ', 'u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ', 'e', 'x', 't', 'r', 'a', 'c', 't', ' ', 't', 'h', 'e', ' ', 'd', 'e', 's', 't', 'i', 'n', 'a', 't', 'i', 'o', 'n', '.', '\r', '\n', 0 };
// TOO_MANY_CONNECTIONS_RESPONSE
// file jcc.c line 256
static const char TOO_MANY_CONNECTIONS_RESPONSE[133l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '1', ' ', '5', '0', '3', ' ', 'T', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'o', 'p', 'e', 'n', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 's', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'T', 'y', 'p', 'e', ':', ' ', 't', 'e', 'x', 't', '/', 'p', 'l', 'a', 'i', 'n', '\r', '\n', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'c', 'l', 'o', 's', 'e', '\r', '\n', '\r', '\n', 'M', 'a', 'x', 'i', 'm', 'u', 'm', ' ', 'n', 'u', 'm', 'b', 'e', 'r', ' ', 'o', 'f', ' ', 'o', 'p', 'e', 'n', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 's', ' ', 'r', 'e', 'a', 'c', 'h', 'e', 'd', '.', '\r', '\n', 0 };
// UNSUPPORTED_CLIENT_EXPECTATION_ERROR_RESPONSE
// file jcc.c line 274
static const char UNSUPPORTED_CLIENT_EXPECTATION_ERROR_RESPONSE[135l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '1', ' ', '4', '1', '7', ' ', 'E', 'x', 'p', 'e', 'c', 't', 'i', 'n', 'g', ' ', 't', 'o', 'o', ' ', 'm', 'u', 'c', 'h', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'T', 'y', 'p', 'e', ':', ' ', 't', 'e', 'x', 't', '/', 'p', 'l', 'a', 'i', 'n', '\r', '\n', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'c', 'l', 'o', 's', 'e', '\r', '\n', '\r', '\n', 'P', 'r', 'i', 'v', 'o', 'x', 'y', ' ', 'd', 'e', 't', 'e', 'c', 't', 'e', 'd', ' ', 'a', 'n', ' ', 'u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'E', 'x', 'p', 'e', 'c', 't', ' ', 'h', 'e', 'a', 'd', 'e', 'r', ' ', 'v', 'a', 'l', 'u', 'e', '.', '\r', '\n', 0 };
// action_names
// file actions.c line 97
static struct action_name action_names[79l] = { { .name="+add-header", .mask=~0UL, .add=(unsigned long int)0, .value_type=(enum action_value_type)3,
    .index=0 },
    { .name="-add-header", .mask=~0UL, .add=(unsigned long int)0, .value_type=(enum action_value_type)4,
    .index=0 },
    { .name="+block", .mask=~0UL, .add=0x00000001UL, .value_type=(enum action_value_type)1,
    .index=16 },
    { .name="-block", .mask=~0x00000001UL, .add=(unsigned long int)0, .value_type=(enum action_value_type)2,
    .index=16 },
    { .name="+change-x-forwarded-for", .mask=~0UL, .add=0x00000010UL,
    .value_type=(enum action_value_type)1, .index=17 },
    { .name="-change-x-forwarded-for", .mask=~0x00000010UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=17 },
    { .name="+client-header-filter", .mask=~0UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)3, .index=3 },
    { .name="-client-header-filter", .mask=~0UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)4, .index=3 },
    { .name="+client-header-tagger", .mask=~0UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)3, .index=4 },
    { .name="-client-header-tagger", .mask=~0UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)4, .index=4 },
    { .name="+content-type-overwrite", .mask=~0UL, .add=0x00080000UL,
    .value_type=(enum action_value_type)1, .index=9 },
    { .name="-content-type-overwrite", .mask=~0x00080000UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=9 },
    { .name="+crunch-client-header", .mask=~0UL, .add=0x00200000UL,
    .value_type=(enum action_value_type)1, .index=7 },
    { .name="-crunch-client-header", .mask=~0x00200000UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=7 },
    { .name="+crunch-if-none-match", .mask=~0UL, .add=0x00800000UL,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="-crunch-if-none-match", .mask=~0x00800000UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="+crunch-incoming-cookies", .mask=~0UL, .add=0x00002000UL,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="-crunch-incoming-cookies", .mask=~0x00002000UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="+crunch-outgoing-cookies", .mask=~0UL, .add=0x00001000UL,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="-crunch-outgoing-cookies", .mask=~0x00001000UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="+crunch-server-header", .mask=~0UL, .add=0x00100000UL,
    .value_type=(enum action_value_type)1, .index=6 },
    { .name="-crunch-server-header", .mask=~0x00100000UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=6 },
    { .name="+deanimate-gifs", .mask=~0UL, .add=0x00000002UL, .value_type=(enum action_value_type)1,
    .index=0 },
    { .name="-deanimate-gifs", .mask=~0x00000002UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=0 },
    { .name="+downgrade-http-version", .mask=~0UL, .add=0x00000004UL,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="-downgrade-http-version", .mask=~0x00000004UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="+external-filter", .mask=~0UL, .add=(unsigned long int)0, .value_type=(enum action_value_type)3,
    .index=6 },
    { .name="-external-filter", .mask=~0UL, .add=(unsigned long int)0, .value_type=(enum action_value_type)4,
    .index=6 },
    { .name="+fast-redirects", .mask=~0UL, .add=0x00000008UL, .value_type=(enum action_value_type)1,
    .index=14 },
    { .name="-fast-redirects", .mask=~0x00000008UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=14 },
    { .name="+filter", .mask=~0UL, .add=(unsigned long int)0, .value_type=(enum action_value_type)3,
    .index=1 },
    { .name="-filter", .mask=~0UL, .add=(unsigned long int)0, .value_type=(enum action_value_type)4,
    .index=1 },
    { .name="+force-text-mode", .mask=~0UL, .add=0x00400000UL, .value_type=(enum action_value_type)0,
    .index=0 },
    { .name="-force-text-mode", .mask=~0x00400000UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="+forward-override", .mask=~0UL, .add=0x00004000UL,
    .value_type=(enum action_value_type)1, .index=15 },
    { .name="-forward-override", .mask=~0x00004000UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=15 },
    { .name="+handle-as-empty-document", .mask=~0UL, .add=0x00008000UL,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="-handle-as-empty-document", .mask=~0x00008000UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="+handle-as-image", .mask=~0UL, .add=0x00000100UL, .value_type=(enum action_value_type)0,
    .index=0 },
    { .name="-handle-as-image", .mask=~0x00000100UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="+hide-accept-language", .mask=~0UL, .add=0x04000000UL,
    .value_type=(enum action_value_type)1, .index=8 },
    { .name="-hide-accept-language", .mask=~0x04000000UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=8 },
    { .name="+hide-content-disposition", .mask=~0UL, .add=0x01000000UL,
    .value_type=(enum action_value_type)1, .index=10 },
    { .name="-hide-content-disposition", .mask=~0x01000000UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=10 },
    { .name="+hide-from-header", .mask=~0UL, .add=0x00000020UL,
    .value_type=(enum action_value_type)1, .index=1 },
    { .name="-hide-from-header", .mask=~0x00000020UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=1 },
    { .name="+hide-if-modified-since", .mask=~0UL, .add=0x00040000UL,
    .value_type=(enum action_value_type)1, .index=11 },
    { .name="-hide-if-modified-since", .mask=~0x00040000UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=11 },
    { .name="+hide-referrer", .mask=~0UL, .add=0x00000040UL, .value_type=(enum action_value_type)1,
    .index=3 },
    { .name="-hide-referrer", .mask=~0x00000040UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=3 },
    { .name="+hide-user-agent", .mask=~0UL, .add=0x00000080UL, .value_type=(enum action_value_type)1,
    .index=4 },
    { .name="-hide-user-agent", .mask=~0x00000080UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=4 },
    { .name="+limit-connect", .mask=~0UL, .add=0x00010000UL, .value_type=(enum action_value_type)1,
    .index=5 },
    { .name="-limit-connect", .mask=~0x00010000UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=5 },
    { .name="+limit-cookie-lifetime", .mask=~0UL, .add=0x08000000UL,
    .value_type=(enum action_value_type)1, .index=18 },
    { .name="-limit-cookie-lifetime", .mask=~0x08000000UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=18 },
    { .name="+overwrite-last-modified", .mask=~0UL, .add=0x02000000UL,
    .value_type=(enum action_value_type)1, .index=12 },
    { .name="-overwrite-last-modified", .mask=~0x02000000UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=12 },
    { .name="+prevent-compression", .mask=~0UL, .add=0x00000400UL,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="-prevent-compression", .mask=~0x00000400UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="+redirect", .mask=~0UL, .add=0x00020000UL, .value_type=(enum action_value_type)1,
    .index=13 },
    { .name="-redirect", .mask=~0x00020000UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=13 },
    { .name="+server-header-filter", .mask=~0UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)3, .index=2 },
    { .name="-server-header-filter", .mask=~0UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)4, .index=2 },
    { .name="+server-header-tagger", .mask=~0UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)3, .index=5 },
    { .name="-server-header-tagger", .mask=~0UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)4, .index=5 },
    { .name="+session-cookies-only", .mask=~0UL, .add=0x00000800UL,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="-session-cookies-only", .mask=~0x00000800UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="+set-image-blocker", .mask=~0UL, .add=0x00000200UL,
    .value_type=(enum action_value_type)1, .index=2 },
    { .name="-set-image-blocker", .mask=~0x00000200UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=2 },
    { .name="+hide-referer", .mask=~0UL, .add=0x00000040UL, .value_type=(enum action_value_type)1,
    .index=3 },
    { .name="-hide-referer", .mask=~0x00000040UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)2, .index=3 },
    { .name="+prevent-keeping-cookies", .mask=~0UL, .add=0x00000800UL,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="-prevent-keeping-cookies", .mask=~0x00000800UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)0, .index=0 },
    { .name="+filter-client-headers", .mask=~0UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)3, .index=3 },
    { .name="-filter-client-headers", .mask=~0UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)4, .index=3 },
    { .name="+filter-server-headers", .mask=~0UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)3, .index=2 },
    { .name="-filter-server-headers", .mask=~0UL, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)4, .index=2 },
    { .name=(const char *)(void *)0, .mask=(unsigned long int)0, .add=(unsigned long int)0,
    .value_type=(enum action_value_type)0, .index=0 } };
// actions_h_rcs
// file actions.c line 60
const char actions_h_rcs[59l] = { '_', 'I', 'd', ':', ' ', 'a', 'c', 't', 'i', 'o', 'n', 's', '.', 'h', ',', 'v', ' ', '1', '.', '2', '4', ' ', '2', '0', '1', '3', '/', '1', '1', '/', '2', '4', ' ', '1', '4', ':', '2', '7', ':', '2', '7', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// actions_rcs
// file actions.c line 1
const char actions_rcs[59l] = { '_', 'I', 'd', ':', ' ', 'a', 'c', 't', 'i', 'o', 'n', 's', '.', 'c', ',', 'v', ' ', '1', '.', '9', '5', ' ', '2', '0', '1', '6', '/', '0', '1', '/', '1', '6', ' ', '1', '2', ':', '3', '3', ':', '3', '5', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// add_client_headers
// file parsers.c line 237
static enum privoxy_err (* const add_client_headers[5l])(struct client_state *);
// add_client_headers
// file parsers.c line 237
static enum privoxy_err (* const add_client_headers[5l])(struct client_state *) = { client_host_adder, client_x_forwarded_for_adder, client_xtra_adder, client_connection_header_adder, (enum privoxy_err (*)(struct client_state *))(void *)0 };
// add_server_headers
// file parsers.c line 245
static enum privoxy_err (* const add_server_headers[3l])(struct client_state *);
// add_server_headers
// file parsers.c line 245
static enum privoxy_err (* const add_server_headers[3l])(struct client_state *) = { server_connection_adder, server_proxy_connection_adder, (enum privoxy_err (*)(struct client_state *))(void *)0 };
// basedir
// file jcc.c line 208
const char *basedir = (const char *)(void *)0;
// cgi_dispatchers
// file cgi.c line 79
static struct cgi_dispatcher cgi_dispatchers[37l];
// cgi_dispatchers
// file cgi.c line 79
static struct cgi_dispatcher cgi_dispatchers[37l] = { { .name="", .handler=cgi_default, .description="Privoxy main page", .harmless=1 },
    { .name="show-status", .handler=cgi_show_status, .description="View &amp; change the current configuration",
    .harmless=1 },
    { .name="show-version", .handler=cgi_show_version, .description="View the source code version numbers",
    .harmless=1 },
    { .name="show-request", .handler=cgi_show_request, .description="View the request headers",
    .harmless=1 },
    { .name="show-url-info", .handler=cgi_show_url_info, .description="Look up which actions apply to a URL and why",
    .harmless=1 },
    { .name="toggle", .handler=cgi_toggle, .description="Toggle Privoxy on or off", .harmless=0 },
    { .name="edit-actions", .handler=cgi_edit_actions, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="eaa", .handler=cgi_edit_actions_add_url_form, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="eau", .handler=cgi_edit_actions_url_form, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="ear", .handler=cgi_edit_actions_remove_url_form, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="eal", .handler=cgi_edit_actions_list, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="eafu", .handler=cgi_edit_actions_for_url, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="eas", .handler=cgi_edit_actions_submit, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="easa", .handler=cgi_edit_actions_section_add, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="easr", .handler=cgi_edit_actions_section_remove, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="eass", .handler=cgi_edit_actions_section_swap, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="edit-actions-for-url", .handler=cgi_edit_actions_for_url, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="edit-actions-list", .handler=cgi_edit_actions_list, .description=(const char *)(void *)0,
    .harmless=1 },
    { .name="edit-actions-submit", .handler=cgi_edit_actions_submit, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="edit-actions-url", .handler=cgi_edit_actions_url, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="edit-actions-url-form", .handler=cgi_edit_actions_url_form, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="edit-actions-add-url", .handler=cgi_edit_actions_add_url, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="edit-actions-add-url-form", .handler=cgi_edit_actions_add_url_form, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="edit-actions-remove-url", .handler=cgi_edit_actions_remove_url, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="edit-actions-remove-url-form", .handler=cgi_edit_actions_remove_url_form, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="edit-actions-section-add", .handler=cgi_edit_actions_section_add, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="edit-actions-section-remove", .handler=cgi_edit_actions_section_remove, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="edit-actions-section-swap", .handler=cgi_edit_actions_section_swap, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="error-favicon.ico", .handler=cgi_send_error_favicon, .description=(const char *)(void *)0,
    .harmless=1 },
    { .name="favicon.ico", .handler=cgi_send_default_favicon, .description=(const char *)(void *)0,
    .harmless=1 },
    { .name="robots.txt", .handler=cgi_robots_txt, .description=(const char *)(void *)0,
    .harmless=1 },
    { .name="send-banner", .handler=cgi_send_banner, .description=(const char *)(void *)0,
    .harmless=1 },
    { .name="send-stylesheet", .handler=cgi_send_stylesheet, .description=(const char *)(void *)0,
    .harmless=0 },
    { .name="t", .handler=cgi_transparent_image, .description=(const char *)(void *)0,
    .harmless=1 },
    { .name="url-info-osd.xml", .handler=cgi_send_url_info_osd, .description=(const char *)(void *)0,
    .harmless=1 },
    { .name="user-manual", .handler=cgi_send_user_manual, .description=(const char *)(void *)0,
    .harmless=1 },
    { .name=(const char *)(void *)0, .handler=cgi_error_404, .description=(const char *)(void *)0,
    .harmless=1 } };
// cgi_error_memory_response
// file cgi.c line 279
static struct http_response cgi_error_memory_response[1l];
// cgi_h_rcs
// file cgi.c line 72
const char cgi_h_rcs[55l] = { '_', 'I', 'd', ':', ' ', 'c', 'g', 'i', '.', 'h', ',', 'v', ' ', '1', '.', '4', '3', ' ', '2', '0', '1', '3', '/', '1', '1', '/', '2', '4', ' ', '1', '4', ':', '2', '3', ':', '2', '8', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// cgi_rcs
// file cgi.c line 1
const char cgi_rcs[56l] = { '_', 'I', 'd', ':', ' ', 'c', 'g', 'i', '.', 'c', ',', 'v', ' ', '1', '.', '1', '6', '0', ' ', '2', '0', '1', '4', '/', '1', '0', '/', '1', '8', ' ', '1', '1', ':', '3', '1', ':', '5', '2', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// cgiedit_h_rcs
// file cgiedit.c line 74
const char cgiedit_h_rcs[59l] = { '_', 'I', 'd', ':', ' ', 'c', 'g', 'i', 'e', 'd', 'i', 't', '.', 'h', ',', 'v', ' ', '1', '.', '1', '3', ' ', '2', '0', '1', '3', '/', '1', '1', '/', '2', '4', ' ', '1', '4', ':', '2', '3', ':', '2', '8', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// cgiedit_rcs
// file cgiedit.c line 1
const char cgiedit_rcs[59l] = { '_', 'I', 'd', ':', ' ', 'c', 'g', 'i', 'e', 'd', 'i', 't', '.', 'c', ',', 'v', ' ', '1', '.', '8', '7', ' ', '2', '0', '1', '4', '/', '1', '0', '/', '1', '8', ' ', '1', '1', ':', '3', '1', ':', '5', '2', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// cgisimple_h_rcs
// file cgisimple.c line 64
const char cgisimple_h_rcs[61l] = { '_', 'I', 'd', ':', ' ', 'c', 'g', 'i', 's', 'i', 'm', 'p', 'l', 'e', '.', 'h', ',', 'v', ' ', '1', '.', '1', '9', ' ', '2', '0', '1', '3', '/', '1', '1', '/', '2', '4', ' ', '1', '4', ':', '2', '3', ':', '2', '8', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// cgisimple_rcs
// file cgisimple.c line 1
const char cgisimple_rcs[62l] = { '_', 'I', 'd', ':', ' ', 'c', 'g', 'i', 's', 'i', 'm', 'p', 'l', 'e', '.', 'c', ',', 'v', ' ', '1', '.', '1', '3', '2', ' ', '2', '0', '1', '5', '/', '1', '1', '/', '0', '6', ' ', '1', '3', ':', '3', '8', ':', '1', '3', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// client_patterns
// file parsers.c line 177
static struct parsers client_patterns[26l];
// client_patterns
// file parsers.c line 177
static struct parsers client_patterns[26l] = { { .str="referer:", .len=(const unsigned long int)8, .parser=client_referrer },
    { .str="user-agent:", .len=(const unsigned long int)11, .parser=client_uagent },
    { .str="ua-", .len=(const unsigned long int)3, .parser=client_ua },
    { .str="from:", .len=(const unsigned long int)5, .parser=client_from },
    { .str="cookie:", .len=(const unsigned long int)7, .parser=client_send_cookie },
    { .str="x-forwarded-for:", .len=(const unsigned long int)16, .parser=client_x_forwarded },
    { .str="Accept-Encoding:", .len=(const unsigned long int)16, .parser=client_accept_encoding },
    { .str="TE:", .len=(const unsigned long int)3, .parser=client_te },
    { .str="Host:", .len=(const unsigned long int)5, .parser=client_host },
    { .str="if-modified-since:", .len=(const unsigned long int)18, .parser=client_if_modified_since },
    { .str="Keep-Alive:", .len=(const unsigned long int)11, .parser=client_keep_alive },
    { .str="Content-Length:", .len=(const unsigned long int)15, .parser=client_save_content_length },
    { .str="Proxy-Connection:", .len=(const unsigned long int)17, .parser=client_proxy_connection },
    { .str="connection:", .len=(const unsigned long int)11, .parser=client_connection },
    { .str="max-forwards:", .len=(const unsigned long int)13, .parser=client_max_forwards },
    { .str="Accept-Language:", .len=(const unsigned long int)16, .parser=client_accept_language },
    { .str="if-none-match:", .len=(const unsigned long int)14, .parser=client_if_none_match },
    { .str="Range:", .len=(const unsigned long int)6, .parser=client_range },
    { .str="Request-Range:", .len=(const unsigned long int)14, .parser=client_range },
    { .str="If-Range:", .len=(const unsigned long int)9, .parser=client_range },
    { .str="X-Filter:", .len=(const unsigned long int)9, .parser=client_x_filter },
    { .str="Proxy-Authorization:", .len=(const unsigned long int)20, .parser=proxy_authentication },
    { .str="Expect:", .len=(const unsigned long int)7, .parser=client_expect },
    { .str="*", .len=(const unsigned long int)0, .parser=crunch_client_header },
    { .str="*", .len=(const unsigned long int)0, .parser=filter_header },
    { .str=(const char *)(void *)0, .len=(const unsigned long int)0, .parser=(enum privoxy_err (*)(struct client_state *, char **))(void *)0 } };
// clients
// file jcc.c line 123
struct client_states clients[1l];
// configfile
// file loadcfg.c line 97
const char *configfile = (const char *)(void *)0;
// connection_reuse_mutex
// file jcc.c line 183
union anonymous_2 connection_reuse_mutex;
// crunchers_all
// file jcc.c line 300
static struct cruncher crunchers_all[6l];
// crunchers_all
// file jcc.c line 300
static struct cruncher crunchers_all[6l] = { { .cruncher=direct_response, .flags=2 | 1 },
    { .cruncher=block_url, .flags=2 }, { .cruncher=trust_url, .flags=2 }, { .cruncher=redirect_url, .flags=0 }, { .cruncher=dispatch_cgi, .flags=1 }, { .cruncher=(struct http_response * (*)(struct client_state *))(void *)0, .flags=0 } };
// crunchers_light
// file jcc.c line 312
static struct cruncher crunchers_light[3l];
// crunchers_light
// file jcc.c line 312
static struct cruncher crunchers_light[3l] = { { .cruncher=block_url, .flags=2 }, { .cruncher=redirect_url, .flags=0 }, { .cruncher=(struct http_response * (*)(struct client_state *))(void *)0, .flags=0 } };
// current_actions_file
// file actions.c line 946
static struct file_list *current_actions_file[30l] = { (struct file_list *)(void *)0, (struct file_list *)(void *)0, (struct file_list *)(void *)0, (struct file_list *)(void *)0, (struct file_list *)(void *)0, (struct file_list *)(void *)0, (struct file_list *)(void *)0, (struct file_list *)(void *)0, (struct file_list *)(void *)0, (struct file_list *)(void *)0, ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL) };
// current_configfile
// file loadcfg.c line 106
static struct file_list *current_configfile = (struct file_list *)(void *)0;
// current_re_filterfile
// file loaders.c line 79
static struct file_list *current_re_filterfile[30l] = { (struct file_list *)(void *)0, (struct file_list *)(void *)0, (struct file_list *)(void *)0, (struct file_list *)(void *)0, (struct file_list *)(void *)0, (struct file_list *)(void *)0, (struct file_list *)(void *)0, (struct file_list *)(void *)0, (struct file_list *)(void *)0, (struct file_list *)(void *)0, ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL), ((struct file_list *)NULL) };
// current_trustfile
// file loaders.c line 74
static struct file_list *current_trustfile = (struct file_list *)(void *)0;
// daemon_mode
// file jcc.c line 122
signed int daemon_mode = 1;
// deanimate_h_rcs
// file deanimate.c line 49
const char deanimate_h_rcs[61l] = { '_', 'I', 'd', ':', ' ', 'd', 'e', 'a', 'n', 'i', 'm', 'a', 't', 'e', '.', 'h', ',', 'v', ' ', '1', '.', '1', '5', ' ', '2', '0', '1', '3', '/', '1', '1', '/', '2', '4', ' ', '1', '4', ':', '2', '3', ':', '2', '8', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// deanimate_rcs
// file deanimate.c line 1
const char deanimate_rcs[61l] = { '_', 'I', 'd', ':', ' ', 'd', 'e', 'a', 'n', 'i', 'm', 'a', 't', 'e', '.', 'c', ',', 'v', ' ', '1', '.', '2', '3', ' ', '2', '0', '1', '2', '/', '0', '3', '/', '0', '9', ' ', '1', '6', ':', '2', '4', ':', '3', '6', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// debug
// file errlog.c line 96
static signed int debug = 0x4000 | 0x2000;
// encode_h_rcs
// file encode.c line 47
const char encode_h_rcs[58l] = { '_', 'I', 'd', ':', ' ', 'e', 'n', 'c', 'o', 'd', 'e', '.', 'h', ',', 'v', ' ', '1', '.', '1', '3', ' ', '2', '0', '1', '3', '/', '1', '1', '/', '2', '4', ' ', '1', '4', ':', '2', '3', ':', '2', '8', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// encode_rcs
// file encode.c line 1
const char encode_rcs[58l] = { '_', 'I', 'd', ':', ' ', 'e', 'n', 'c', 'o', 'd', 'e', '.', 'c', ',', 'v', ' ', '1', '.', '2', '9', ' ', '2', '0', '1', '3', '/', '0', '2', '/', '1', '9', ' ', '1', '1', ':', '1', '4', ':', '0', '5', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// errlog_h_rcs
// file errlog.c line 82
const char errlog_h_rcs[58l] = { '_', 'I', 'd', ':', ' ', 'e', 'r', 'r', 'l', 'o', 'g', '.', 'h', ',', 'v', ' ', '1', '.', '3', '0', ' ', '2', '0', '1', '3', '/', '1', '1', '/', '2', '4', ' ', '1', '4', ':', '2', '3', ':', '2', '8', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// errlog_rcs
// file errlog.c line 1
const char errlog_rcs[53l] = { '_', 'I', 'd', ':', ' ', 'e', 'r', 'r', 'l', 'o', 'g', '.', 'c', ',', 'v', ' ', '1', '.', '1', '2', '4', ' ', '2', '0', '1', '6', '/', '0', '1', '/', '2', '1', ' ', '2', '0', ':', '5', '3', ':', '0', '1', ' ', 'd', 'i', 'e', 'm', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// external_filter_mutex
// file jcc.c line 186
union anonymous_2 external_filter_mutex;
// files
// file jcc.c line 124
struct file_list files[1l];
// filter_type_info
// file cgiedit.c line 214
static struct filter_type_info filter_type_info[6l] = { { .multi_action_index=1, .macro_name="content-filter-params", .type="filter",
    .disable_all_option="filter-all", .disable_all_param="filter_all",
    .abbr_type="F", .anchor="FILTER" },
    { .multi_action_index=3, .macro_name="client-header-filter-params", .type="client-header-filter",
    .disable_all_option="client-header-filter-all", .disable_all_param="client_header_filter_all",
    .abbr_type="C",
    .anchor="CLIENT-HEADER-FILTER" },
    { .multi_action_index=2, .macro_name="server-header-filter-params", .type="server-header-filter",
    .disable_all_option="server-header-filter-all", .disable_all_param="server_header_filter_all",
    .abbr_type="S",
    .anchor="SERVER-HEADER-FILTER" },
    { .multi_action_index=4, .macro_name="client-header-tagger-params", .type="client-header-tagger",
    .disable_all_option="client-header-tagger-all", .disable_all_param="client_header_tagger_all",
    .abbr_type="L",
    .anchor="CLIENT-HEADER-TAGGER" },
    { .multi_action_index=5, .macro_name="server-header-tagger-params", .type="server-header-tagger",
    .disable_all_option="server-header-tagger-all", .disable_all_param="server_header_tagger_all",
    .abbr_type="E",
    .anchor="SERVER-HEADER-TAGGER" },
    { .multi_action_index=6, .macro_name="external-content-filter-params", .type="external-filter",
    .disable_all_option="external-content-filter-all", .disable_all_param="external_content_filter_all",
    .abbr_type="E",
    .anchor="EXTERNAL-CONTENT-FILTER" } };
// filters_h_rcs
// file filters.c line 78
const char filters_h_rcs[59l] = { '_', 'I', 'd', ':', ' ', 'f', 'i', 'l', 't', 'e', 'r', 's', '.', 'h', ',', 'v', ' ', '1', '.', '4', '6', ' ', '2', '0', '1', '3', '/', '1', '2', '/', '2', '4', ' ', '1', '3', ':', '3', '2', ':', '5', '1', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// filters_rcs
// file filters.c line 1
const char filters_rcs[60l] = { '_', 'I', 'd', ':', ' ', 'f', 'i', 'l', 't', 'e', 'r', 's', '.', 'c', ',', 'v', ' ', '1', '.', '1', '9', '9', ' ', '2', '0', '1', '6', '/', '0', '1', '/', '1', '6', ' ', '1', '2', ':', '3', '3', ':', '3', '5', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// gateway_h_rcs
// file gateway.c line 82
const char gateway_h_rcs[59l] = { '_', 'I', 'd', ':', ' ', 'g', 'a', 't', 'e', 'w', 'a', 'y', '.', 'h', ',', 'v', ' ', '1', '.', '2', '3', ' ', '2', '0', '1', '3', '/', '1', '1', '/', '2', '4', ' ', '1', '4', ':', '2', '3', ':', '2', '8', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// gateway_rcs
// file gateway.c line 1
const char gateway_rcs[59l] = { '_', 'I', 'd', ':', ' ', 'g', 'a', 't', 'e', 'w', 'a', 'y', '.', 'c', ',', 'v', ' ', '1', '.', '9', '6', ' ', '2', '0', '1', '6', '/', '0', '1', '/', '1', '6', ' ', '1', '2', ':', '3', '0', ':', '4', '3', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// global_toggle_state
// file loadcfg.c line 93
signed int global_toggle_state = 1;
// html_code_map
// file encode.c line 80
static const char * const html_code_map[256l] = { (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, "&quot;", (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, "&amp;", "&#39;", (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, "&lt;", (const char *)(void *)0, "&gt;", (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0 };
// image_blank_data
// file cgi.c line 239
const char image_blank_data[109l] = { -119, 'P', 'N', 'G', '\r', '\n', 26, '\n', 0, 0, 0, '\r', 'I', 'H', 'D', 'R', 0, 0, 0, 1, 0, 0, 0, 1, 1, 3, 0, 0, 0, '%', -37, 'V', -54, 0, 0, 0, 3, 'P', 'L', 'T', 'E', -1, -1, -1, -89, -60, 27, -56, 0, 0, 0, 1, 't', 'R', 'N', 'S', 0, '@', -26, -40, 'f', 0, 0, 0, 1, 'b', 'K', 'G', 'D', 0, -120, 5, 29, 'H', 0, 0, 0, '\n', 'I', 'D', 'A', 'T', 'x', 1, 'c', '`', 0, 0, 0, 2, 0, 1, 's', 'u', 1, 24, 0, 0, 0, 0, 'I', 'E', 'N', 'D', -82, 'B', '`', -126, 0 };
// image_blank_length
// file cgi.c line 269
const unsigned long int image_blank_length = sizeof(const char [109l]) /*109ul*/  - (unsigned long int)1;
// image_pattern_data
// file cgi.c line 227
const char image_pattern_data[103l] = { -119, 'P', 'N', 'G', '\r', '\n', 26, '\n', 0, 0, 0, '\r', 'I', 'H', 'D', 'R', 0, 0, 0, 4, 0, 0, 0, 4, 8, 6, 0, 0, 0, -87, -15, -98, 126, 0, 0, 0, 6, 'b', 'K', 'G', 'D', 0, 0, 0, 0, 0, 0, -7, 'C', -69, 127, 0, 0, 0, 27, 'I', 'D', 'A', 'T', 8, -41, 'c', '`', '`', '`', '0', -1, -1, -1, '?', 3, -100, 'F', -31, '0', '0', -104, '3', 16, 'T', 1, 0, 'q', 17, 25, -95, 28, -12, 24, 'c', 0, 0, 0, 0, 'I', 'E', 'N', 'D', -82, 'B', '`', -126, 0 };
// image_pattern_length
// file cgi.c line 268
const unsigned long int image_pattern_length = sizeof(const char [103l]) /*103ul*/  - (unsigned long int)1;
// jbsockets_h_rcs
// file jbsockets.c line 109
const char jbsockets_h_rcs[61l] = { '_', 'I', 'd', ':', ' ', 'j', 'b', 's', 'o', 'c', 'k', 'e', 't', 's', '.', 'h', ',', 'v', ' ', '1', '.', '2', '4', ' ', '2', '0', '1', '4', '/', '0', '6', '/', '0', '2', ' ', '0', '6', ':', '2', '2', ':', '2', '0', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// jbsockets_rcs
// file jbsockets.c line 1
const char jbsockets_rcs[62l] = { '_', 'I', 'd', ':', ' ', 'j', 'b', 's', 'o', 'c', 'k', 'e', 't', 's', '.', 'c', ',', 'v', ' ', '1', '.', '1', '3', '5', ' ', '2', '0', '1', '6', '/', '0', '1', '/', '1', '6', ' ', '1', '2', ':', '3', '3', ':', '3', '5', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// jcc_h_rcs
// file jcc.c line 119
const char jcc_h_rcs[55l] = { '_', 'I', 'd', ':', ' ', 'j', 'c', 'c', '.', 'h', ',', 'v', ' ', '1', '.', '3', '5', ' ', '2', '0', '1', '4', '/', '0', '6', '/', '0', '2', ' ', '0', '6', ':', '2', '2', ':', '2', '1', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// jcc_rcs
// file jcc.c line 1
const char jcc_rcs[56l] = { '_', 'I', 'd', ':', ' ', 'j', 'c', 'c', '.', 'c', ',', 'v', ' ', '1', '.', '4', '4', '0', ' ', '2', '0', '1', '6', '/', '0', '1', '/', '1', '6', ' ', '1', '2', ':', '3', '3', ':', '3', '6', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// keep_alive_timeout
// file gateway.c line 137
static unsigned int keep_alive_timeout = (unsigned int)180;
// list_h_rcs
// file list.c line 59
const char list_h_rcs[56l] = { '_', 'I', 'd', ':', ' ', 'l', 'i', 's', 't', '.', 'h', ',', 'v', ' ', '1', '.', '1', '9', ' ', '2', '0', '1', '3', '/', '1', '1', '/', '2', '4', ' ', '1', '4', ':', '2', '3', ':', '2', '8', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// list_rcs
// file list.c line 1
const char list_rcs[56l] = { '_', 'I', 'd', ':', ' ', 'l', 'i', 's', 't', '.', 'c', ',', 'v', ' ', '1', '.', '3', '2', ' ', '2', '0', '1', '4', '/', '1', '1', '/', '1', '4', ' ', '1', '0', ':', '3', '9', ':', '4', '9', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// loadcfg_h_rcs
// file loadcfg.c line 89
const char loadcfg_h_rcs[59l] = { '_', 'I', 'd', ':', ' ', 'l', 'o', 'a', 'd', 'c', 'f', 'g', '.', 'h', ',', 'v', ' ', '1', '.', '1', '7', ' ', '2', '0', '1', '3', '/', '1', '1', '/', '2', '4', ' ', '1', '4', ':', '2', '3', ':', '2', '8', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// loadcfg_rcs
// file loadcfg.c line 1
const char loadcfg_rcs[60l] = { '_', 'I', 'd', ':', ' ', 'l', 'o', 'a', 'd', 'c', 'f', 'g', '.', 'c', ',', 'v', ' ', '1', '.', '1', '4', '5', ' ', '2', '0', '1', '6', '/', '0', '1', '/', '1', '6', ' ', '1', '2', ':', '3', '3', ':', '3', '6', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// loaders_h_rcs
// file loaders.c line 66
const char loaders_h_rcs[59l] = { '_', 'I', 'd', ':', ' ', 'l', 'o', 'a', 'd', 'e', 'r', 's', '.', 'h', ',', 'v', ' ', '1', '.', '3', '2', ' ', '2', '0', '1', '3', '/', '1', '1', '/', '2', '4', ' ', '1', '4', ':', '2', '3', ':', '2', '8', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// loaders_rcs
// file loaders.c line 1
const char loaders_rcs[60l] = { '_', 'I', 'd', ':', ' ', 'l', 'o', 'a', 'd', 'e', 'r', 's', '.', 'c', ',', 'v', ' ', '1', '.', '1', '0', '0', ' ', '2', '0', '1', '5', '/', '0', '1', '/', '2', '4', ' ', '1', '6', ':', '4', '0', ':', '2', '1', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// log_init_mutex
// file jcc.c line 182
union anonymous_2 log_init_mutex;
// log_mutex
// file jcc.c line 181
union anonymous_2 log_mutex;
// logfp
// file errlog.c line 93
static struct _IO_FILE *logfp = (struct _IO_FILE *)(void *)0;
// miscutil_h_rcs
// file miscutil.c line 68
const char miscutil_h_rcs[60l] = { '_', 'I', 'd', ':', ' ', 'm', 'i', 's', 'c', 'u', 't', 'i', 'l', '.', 'h', ',', 'v', ' ', '1', '.', '3', '7', ' ', '2', '0', '1', '2', '/', '1', '1', '/', '2', '4', ' ', '1', '3', ':', '5', '8', ':', '1', '7', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// miscutil_rcs
// file miscutil.c line 1
const char miscutil_rcs[60l] = { '_', 'I', 'd', ':', ' ', 'm', 'i', 's', 'c', 'u', 't', 'i', 'l', '.', 'c', ',', 'v', ' ', '1', '.', '8', '0', ' ', '2', '0', '1', '6', '/', '0', '1', '/', '1', '6', ' ', '1', '2', ':', '3', '3', ':', '3', '6', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// parsers_h_rcs
// file parsers.c line 93
const char parsers_h_rcs[59l] = { '_', 'I', 'd', ':', ' ', 'p', 'a', 'r', 's', 'e', 'r', 's', '.', 'h', ',', 'v', ' ', '1', '.', '5', '6', ' ', '2', '0', '1', '3', '/', '1', '1', '/', '2', '4', ' ', '1', '4', ':', '2', '3', ':', '2', '8', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// parsers_rcs
// file parsers.c line 1
const char parsers_rcs[60l] = { '_', 'I', 'd', ':', ' ', 'p', 'a', 'r', 's', 'e', 'r', 's', '.', 'c', ',', 'v', ' ', '1', '.', '3', '0', '7', ' ', '2', '0', '1', '6', '/', '0', '1', '/', '1', '7', ' ', '1', '4', ':', '3', '1', ':', '4', '7', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// pcrs_h_rcs
// file pcrs.c line 58
const char pcrs_h_rcs[56l] = { '_', 'I', 'd', ':', ' ', 'p', 'c', 'r', 's', '.', 'h', ',', 'v', ' ', '1', '.', '1', '8', ' ', '2', '0', '1', '3', '/', '1', '1', '/', '2', '4', ' ', '1', '4', ':', '2', '3', ':', '2', '8', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// pcrs_rcs
// file pcrs.c line 1
const char pcrs_rcs[56l] = { '_', 'I', 'd', ':', ' ', 'p', 'c', 'r', 's', '.', 'c', ',', 'v', ' ', '1', '.', '4', '8', ' ', '2', '0', '1', '5', '/', '1', '2', '/', '2', '7', ' ', '1', '2', ':', '4', '5', ':', '4', '6', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// pidfile
// file jcc.c line 209
const char *pidfile = (const char *)(void *)0;
// project_h_rcs
// file jcc.c line 120
const char project_h_rcs[60l] = { '_', 'I', 'd', ':', ' ', 'p', 'r', 'o', 'j', 'e', 'c', 't', '.', 'h', ',', 'v', ' ', '1', '.', '2', '1', '2', ' ', '2', '0', '1', '6', '/', '0', '1', '/', '1', '6', ' ', '1', '2', ':', '3', '0', ':', '4', '3', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// received_hup_signal
// file jcc.c line 210
static signed int received_hup_signal = 0;
// reusable_connection
// file gateway.c line 139
static struct reusable_connection reusable_connection[100l];
// server_patterns
// file parsers.c line 214
static struct parsers server_patterns[16l];
// server_patterns
// file parsers.c line 214
static struct parsers server_patterns[16l] = { { .str="HTTP/", .len=(const unsigned long int)5, .parser=server_http },
    { .str="set-cookie:", .len=(const unsigned long int)11, .parser=server_set_cookie },
    { .str="connection:", .len=(const unsigned long int)11, .parser=server_connection },
    { .str="Content-Type:", .len=(const unsigned long int)13, .parser=server_content_type },
    { .str="Content-MD5:", .len=(const unsigned long int)12, .parser=server_content_md5 },
    { .str="Content-Encoding:", .len=(const unsigned long int)17, .parser=server_content_encoding },
    { .str="Content-Length:", .len=(const unsigned long int)15, .parser=server_save_content_length },
    { .str="Keep-Alive:", .len=(const unsigned long int)11, .parser=server_keep_alive },
    { .str="Proxy-Connection:", .len=(const unsigned long int)17, .parser=server_proxy_connection },
    { .str="Transfer-Encoding:", .len=(const unsigned long int)18, .parser=server_transfer_coding },
    { .str="content-disposition:", .len=(const unsigned long int)20, .parser=server_content_disposition },
    { .str="Last-Modified:", .len=(const unsigned long int)14, .parser=server_last_modified },
    { .str="Proxy-Authenticate:", .len=(const unsigned long int)19, .parser=proxy_authentication },
    { .str="*", .len=(const unsigned long int)0, .parser=crunch_server_header },
    { .str="*", .len=(const unsigned long int)0, .parser=filter_header },
    { .str=(const char *)(void *)0, .len=(const unsigned long int)0, .parser=(enum privoxy_err (*)(struct client_state *, char **))(void *)0 } };
// socks_userid
// file gateway.c line 132
static const char socks_userid[10l] = { 'a', 'n', 'o', 'n', 'y', 'm', 'o', 'u', 's', 0 };
// ssplit_h_rcs
// file ssplit.c line 45
const char ssplit_h_rcs[58l] = { '_', 'I', 'd', ':', ' ', 's', 's', 'p', 'l', 'i', 't', '.', 'h', ',', 'v', ' ', '1', '.', '1', '2', ' ', '2', '0', '1', '3', '/', '1', '1', '/', '2', '4', ' ', '1', '4', ':', '2', '3', ':', '2', '8', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// ssplit_rcs
// file ssplit.c line 1
const char ssplit_rcs[58l] = { '_', 'I', 'd', ':', ' ', 's', 's', 'p', 'l', 'i', 't', '.', 'c', ',', 'v', ' ', '1', '.', '2', '0', ' ', '2', '0', '1', '2', '/', '0', '7', '/', '2', '3', ' ', '1', '2', ':', '4', '7', ':', '0', '1', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// url_code_map
// file encode.c line 50
static const char url_code_map[256l][4l] = { { 0, 0, 0, 0 }, { '%', '0', '1', 0 }, { '%', '0', '2', 0 }, { '%', '0', '3', 0 }, { '%', '0', '4', 0 }, { '%', '0', '5', 0 }, { '%', '0', '6', 0 }, { '%', '0', '7', 0 }, { '%', '0', '8', 0 }, { '%', '0', '9', 0 }, { '%', '0', 'A', 0 }, { '%', '0', 'B', 0 }, { '%', '0', 'C', 0 }, { '%', '0', 'D', 0 }, { '%', '0', 'E', 0 }, { '%', '0', 'F', 0 }, { '%', '1', '0', 0 }, { '%', '1', '1', 0 }, { '%', '1', '2', 0 }, { '%', '1', '3', 0 }, { '%', '1', '4', 0 }, { '%', '1', '5', 0 }, { '%', '1', '6', 0 }, { '%', '1', '7', 0 }, { '%', '1', '8', 0 }, { '%', '1', '9', 0 }, { '%', '1', 'A', 0 }, { '%', '1', 'B', 0 }, { '%', '1', 'C', 0 }, { '%', '1', 'D', 0 }, { '%', '1', 'E', 0 }, { '%', '1', 'F', 0 }, { '%', '2', '0', 0 }, { '%', '2', '1', 0 }, { '%', '2', '2', 0 }, { '%', '2', '3', 0 }, { '%', '2', '4', 0 }, { '%', '2', '5', 0 }, { '%', '2', '6', 0 }, { '%', '2', '7', 0 }, { '%', '2', '8', 0 }, { '%', '2', '9', 0 }, { 0, 0, 0, 0 }, { '%', '2', 'B', 0 }, { '%', '2', 'C', 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { '%', '2', 'F', 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { '%', '3', 'A', 0 }, { '%', '3', 'B', 0 }, { '%', '3', 'C', 0 }, { '%', '3', 'D', 0 }, { '%', '3', 'E', 0 }, { '%', '3', 'F', 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { '%', '5', 'B', 0 }, { '%', '5', 'C', 0 }, { '%', '5', 'D', 0 }, { '%', '5', 'E', 0 }, { 0, 0, 0, 0 }, { '%', '6', '0', 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { '%', '7', 'B', 0 }, { '%', '7', 'C', 0 }, { '%', '7', 'D', 0 }, { '%', '7', 'E', 0 }, { '%', '7', 'F', 0 }, { '%', '8', '0', 0 }, { '%', '8', '1', 0 }, { '%', '8', '2', 0 }, { '%', '8', '3', 0 }, { '%', '8', '4', 0 }, { '%', '8', '5', 0 }, { '%', '8', '6', 0 }, { '%', '8', '7', 0 }, { '%', '8', '8', 0 }, { '%', '8', '9', 0 }, { '%', '8', 'A', 0 }, { '%', '8', 'B', 0 }, { '%', '8', 'C', 0 }, { '%', '8', 'D', 0 }, { '%', '8', 'E', 0 }, { '%', '8', 'F', 0 }, { '%', '9', '0', 0 }, { '%', '9', '1', 0 }, { '%', '9', '2', 0 }, { '%', '9', '3', 0 }, { '%', '9', '4', 0 }, { '%', '9', '5', 0 }, { '%', '9', '6', 0 }, { '%', '9', '7', 0 }, { '%', '9', '8', 0 }, { '%', '9', '9', 0 }, { '%', '9', 'A', 0 }, { '%', '9', 'B', 0 }, { '%', '9', 'C', 0 }, { '%', '9', 'D', 0 }, { '%', '9', 'E', 0 }, { '%', '9', 'F', 0 }, { '%', 'A', '0', 0 }, { '%', 'A', '1', 0 }, { '%', 'A', '2', 0 }, { '%', 'A', '3', 0 }, { '%', 'A', '4', 0 }, { '%', 'A', '5', 0 }, { '%', 'A', '6', 0 }, { '%', 'A', '7', 0 }, { '%', 'A', '8', 0 }, { '%', 'A', '9', 0 }, { '%', 'A', 'A', 0 }, { '%', 'A', 'B', 0 }, { '%', 'A', 'C', 0 }, { '%', 'A', 'D', 0 }, { '%', 'A', 'E', 0 }, { '%', 'A', 'F', 0 }, { '%', 'B', '0', 0 }, { '%', 'B', '1', 0 }, { '%', 'B', '2', 0 }, { '%', 'B', '3', 0 }, { '%', 'B', '4', 0 }, { '%', 'B', '5', 0 }, { '%', 'B', '6', 0 }, { '%', 'B', '7', 0 }, { '%', 'B', '8', 0 }, { '%', 'B', '9', 0 }, { '%', 'B', 'A', 0 }, { '%', 'B', 'B', 0 }, { '%', 'B', 'C', 0 }, { '%', 'B', 'D', 0 }, { '%', 'B', 'E', 0 }, { '%', 'B', 'F', 0 }, { '%', 'C', '0', 0 }, { '%', 'C', '1', 0 }, { '%', 'C', '2', 0 }, { '%', 'C', '3', 0 }, { '%', 'C', '4', 0 }, { '%', 'C', '5', 0 }, { '%', 'C', '6', 0 }, { '%', 'C', '7', 0 }, { '%', 'C', '8', 0 }, { '%', 'C', '9', 0 }, { '%', 'C', 'A', 0 }, { '%', 'C', 'B', 0 }, { '%', 'C', 'C', 0 }, { '%', 'C', 'D', 0 }, { '%', 'C', 'E', 0 }, { '%', 'C', 'F', 0 }, { '%', 'D', '0', 0 }, { '%', 'D', '1', 0 }, { '%', 'D', '2', 0 }, { '%', 'D', '3', 0 }, { '%', 'D', '4', 0 }, { '%', 'D', '5', 0 }, { '%', 'D', '6', 0 }, { '%', 'D', '7', 0 }, { '%', 'D', '8', 0 }, { '%', 'D', '9', 0 }, { '%', 'D', 'A', 0 }, { '%', 'D', 'B', 0 }, { '%', 'D', 'C', 0 }, { '%', 'D', 'D', 0 }, { '%', 'D', 'E', 0 }, { '%', 'D', 'F', 0 }, { '%', 'E', '0', 0 }, { '%', 'E', '1', 0 }, { '%', 'E', '2', 0 }, { '%', 'E', '3', 0 }, { '%', 'E', '4', 0 }, { '%', 'E', '5', 0 }, { '%', 'E', '6', 0 }, { '%', 'E', '7', 0 }, { '%', 'E', '8', 0 }, { '%', 'E', '9', 0 }, { '%', 'E', 'A', 0 }, { '%', 'E', 'B', 0 }, { '%', 'E', 'C', 0 }, { '%', 'E', 'D', 0 }, { '%', 'E', 'E', 0 }, { '%', 'E', 'F', 0 }, { '%', 'F', '0', 0 }, { '%', 'F', '1', 0 }, { '%', 'F', '2', 0 }, { '%', 'F', '3', 0 }, { '%', 'F', '4', 0 }, { '%', 'F', '5', 0 }, { '%', 'F', '6', 0 }, { '%', 'F', '7', 0 }, { '%', 'F', '8', 0 }, { '%', 'F', '9', 0 }, { '%', 'F', 'A', 0 }, { '%', 'F', 'B', 0 }, { '%', 'F', 'C', 0 }, { '%', 'F', 'D', 0 }, { '%', 'F', 'E', 0 }, { '%', 'F', 'F', 0 } };
// urlmatch_h_rcs
// file urlmatch.c line 59
const char urlmatch_h_rcs[60l] = { '_', 'I', 'd', ':', ' ', 'u', 'r', 'l', 'm', 'a', 't', 'c', 'h', '.', 'h', ',', 'v', ' ', '1', '.', '2', '1', ' ', '2', '0', '1', '3', '/', '1', '1', '/', '2', '4', ' ', '1', '4', ':', '2', '5', ':', '1', '9', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// urlmatch_rcs
// file urlmatch.c line 1
const char urlmatch_rcs[60l] = { '_', 'I', 'd', ':', ' ', 'u', 'r', 'l', 'm', 'a', 't', 'c', 'h', '.', 'c', ',', 'v', ' ', '1', '.', '8', '6', ' ', '2', '0', '1', '5', '/', '1', '2', '/', '2', '7', ' ', '1', '2', ':', '4', '7', ':', '1', '7', ' ', 'f', 'a', 'b', 'i', 'a', 'n', 'k', 'e', 'i', 'l', ' ', 'E', 'x', 'p', ' ', '_', 0 };
// urls_read
// file jcc.c line 127
signed int urls_read = 0;
// urls_rejected
// file jcc.c line 128
signed int urls_rejected = 0;
// warning
// file pcrs.c line 1075
static const char warning[26l] = { '.', '.', '.', ' ', '[', 't', 'o', 'o', ' ', 'l', 'o', 'n', 'g', ',', ' ', 't', 'r', 'u', 'n', 'c', 'a', 't', 'e', 'd', ']', 0 };

// accept_connection
// file jbsockets.c line 1191
extern signed int accept_connection(struct client_state *csp, signed int *fds)
{
  signed int afd;
  unsigned int c_length;
  signed int retval;
  signed int i;
  signed int max_selected_socket;
  struct anonymous_13 selected_fds;
  signed int fd;
  c_length = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_13) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&selected_fds)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  max_selected_socket = 0;
  i = 0;
  for( ; !(i >= 10); i = i + 1)
    if(!(fds[(signed long int)i] == -1))
    {
      (&selected_fds)->__fds_bits[(signed long int)(fds[(signed long int)i] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&selected_fds)->__fds_bits[(signed long int)(fds[(signed long int)i] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fds[(signed long int)i] % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      if(!(max_selected_socket >= 1 + fds[(signed long int)i]))
        max_selected_socket = fds[(signed long int)i] + 1;

    }

  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_7;
  signed int *return_value___errno_location_6;
  const char *tmp_if_expr_11;
  const char *return_value_gai_strerror_10;
  if(max_selected_socket == 0)
    return 0;

  else
  {
    do
    {
      retval=select(max_selected_socket, &selected_fds, (struct anonymous_13 *)(void *)0, (struct anonymous_13 *)(void *)0, (struct timeval *)(void *)0);
      if(!(retval >= 0))
      {
        return_value___errno_location_1=__errno_location();
        tmp_if_expr_2 = *return_value___errno_location_1 == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
    }
    while(tmp_if_expr_2);
    if(!(retval >= 1))
    {
      if(retval == 0)
        log_error(0x2000, "Waiting on new client failed because select(2) returned 0. This should not happen.");

      else
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        char *return_value_strerror_4;
        return_value_strerror_4=strerror(*return_value___errno_location_3);
        log_error(0x2000, "Waiting on new client failed because of problems in select(2): %s.", return_value_strerror_4);
      }
      return 0;
    }

    else
    {
      i = 0;
      do
      {
        if(!(i >= 10))
          tmp_if_expr_5 = !(((&selected_fds)->__fds_bits[(signed long int)(fds[(signed long int)i] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & (signed long int)(1UL << fds[(signed long int)i] % (8 * (signed int)sizeof(signed long int) /*8ul*/ ))) != (signed long int)0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        if(!tmp_if_expr_5)
          break;

        i = i + 1;
      }
      while((_Bool)1);
      if(i >= 10)
      {
        log_error(0x2000, "select(2) reported connected clients (number = %u, descriptor boundary = %u), but none found.", retval, max_selected_socket);
        return 0;
      }

      else
      {
        fd = fds[(signed long int)i];
        do
        {
          afd=accept(fd, (struct sockaddr *)&csp->tcp_addr, &c_length);
          if(!(afd >= 0))
          {
            return_value___errno_location_6=__errno_location();
            tmp_if_expr_7 = *return_value___errno_location_6 == 4 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_7 = (_Bool)0;
        }
        while(tmp_if_expr_7);
        if(!(afd >= 0))
          return 0;

        else
        {
          struct linger linger_options;
          linger_options.l_onoff = 1;
          linger_options.l_linger = 5;
          signed int return_value_setsockopt_8;
          return_value_setsockopt_8=setsockopt(afd, 1, 13, (const void *)&linger_options, (unsigned int)sizeof(struct linger) /*8ul*/ );
          if(!(return_value_setsockopt_8 == 0))
            log_error(0x2000, "Setting SO_LINGER on socket %d failed.", afd);

          if(afd >= 1024)
          {
            log_error(0x2000, "Client socket number too high to use select(): %d >= %d", afd, 1024);
            close_socket(afd);
            return 0;
          }

          else
          {
            mark_socket_for_close_on_execute(afd);
            set_no_delay_flag(afd);
            csp->cfd = afd;
            void *return_value_malloc_or_die_9;
            return_value_malloc_or_die_9=malloc_or_die((unsigned long int)1025);
            csp->ip_addr_str = (char *)return_value_malloc_or_die_9;
            retval=getnameinfo((struct sockaddr *)&csp->tcp_addr, c_length, csp->ip_addr_str, (unsigned int)1025, (char *)(void *)0, (unsigned int)0, 1);
            if(csp->ip_addr_str == ((char *)NULL) || !(retval == 0))
            {
              if(!(csp->ip_addr_str == ((char *)NULL)))
              {
                return_value_gai_strerror_10=gai_strerror(retval);
                tmp_if_expr_11 = return_value_gai_strerror_10;
              }

              else
                tmp_if_expr_11 = "Insuffcient memory";
              log_error(0x2000, "Can not save csp->ip_addr_str: %s", tmp_if_expr_11);
              if(!(csp->ip_addr_str == ((char *)NULL)))
              {
                free((void *)csp->ip_addr_str);
                csp->ip_addr_str = (char *)(void *)0;
              }

            }

            return 1;
          }
        }
      }
    }
  }
}

// acl_addr
// file filters.c line 324
extern signed int acl_addr(const char *aspec, struct access_control_addr *aca)
{
  signed int i;
  signed int masklength;
  struct addrinfo hints;
  struct addrinfo *result;
  unsigned char *mask_data;
  unsigned short int *mask_port;
  unsigned int addr_len;
  char *p;
  char *acl_spec = (char *)(void *)0;
  masklength = 128;
  acl_spec=strdup_or_die(aspec);
  p=strchr(acl_spec, 47);
  char *tmp_post_1;
  if(!(p == ((char *)NULL)))
  {
    tmp_post_1 = p;
    p = p + 1l;
    *tmp_post_1 = (char)0;
    const unsigned short int **return_value___ctype_b_loc_2;
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)*p]) == 0)
    {
      if(!(acl_spec == ((char *)NULL)))
      {
        free((void *)acl_spec);
        acl_spec = (char *)(void *)0;
      }

      return -1;
    }

    masklength=atoi(p);
  }

  _Bool tmp_if_expr_3;
  if(masklength >= 129 || !(masklength >= 0))
  {
    if(!(acl_spec == ((char *)NULL)))
    {
      free((void *)acl_spec);
      acl_spec = (char *)(void *)0;
    }

    return -1;
  }

  else
  {
    if((signed int)*acl_spec == 91)
    {
      p=strchr(acl_spec, 93);
      tmp_if_expr_3 = (char *)(void *)0 != p ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      *p = (char)0;
      memmove((void *)acl_spec, (const void *)(acl_spec + (signed long int)1), (unsigned long int)(p - acl_spec));
      p = p + 1l;
      if(!((signed int)*p == 58))
        p = (char *)(void *)0;

    }

    else
      p=strchr(acl_spec, 58);
    if(!(p == ((char *)NULL)))
    {
      /* assertion *p == ':' */
      assert((signed int)*p == 58);
      *p = (char)0;
      p = p + 1l;
    }

    memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
    hints.ai_family = 0;
    hints.ai_socktype = 1;
    i=getaddrinfo(acl_spec, p, &hints, &result);
    if(!(i == 0))
    {
      const char *return_value_gai_strerror_4;
      return_value_gai_strerror_4=gai_strerror(i);
      log_error(0x2000, "Can not resolve [%s]:%s: %s", acl_spec, p, return_value_gai_strerror_4);
      if(!(acl_spec == ((char *)NULL)))
      {
        free((void *)acl_spec);
        acl_spec = (char *)(void *)0;
      }

      return -1;
    }

    if(!(acl_spec == ((char *)NULL)))
    {
      free((void *)acl_spec);
      acl_spec = (char *)(void *)0;
    }

    memcpy((void *)&aca->addr, (const void *)result->ai_addr, (unsigned long int)result->ai_addrlen);
    freeaddrinfo(result);
    if((signed int)aca->addr.ss_family == 2)
    {
      if(masklength >= 33)
        masklength = 32;

    }

    aca->mask.ss_family = aca->addr.ss_family;
    signed int return_value_sockaddr_storage_to_ip_5;
    return_value_sockaddr_storage_to_ip_5=sockaddr_storage_to_ip(&aca->mask, &mask_data, &addr_len, &mask_port);
    if(!(return_value_sockaddr_storage_to_ip_5 == 0))
      return -1;

    else
    {
      if(!(p == ((char *)NULL)))
        *mask_port = (unsigned short int)1;

      i = 0;
      for( ; !(masklength == 0) && !((unsigned int)i >= addr_len); i = i + 1)
        if(masklength >= 8)
        {
          mask_data[(signed long int)i] = (unsigned char)0xFF;
          masklength = masklength - 8;
        }

        else
        {
          mask_data[(signed long int)i] = (unsigned char)~((1 << 8 - masklength) - 1);
          masklength = 0;
        }
      return 0;
    }
  }
}

// action_spec_is_valid
// file actions.c line 1134
static signed int action_spec_is_valid(struct client_state *csp, struct action_spec *cur_action)
{
  /* tag-#anon#lST[S32'multi_index'||lENtag-filter_type#{U32}_U32_'filter_type'|] */
struct anonymous_10
{
  // multi_index
  signed int multi_index;
  // filter_type
  enum filter_type filter_type;
};

/* */
  ;
  struct anonymous_10 filter_map[5l] = { { .multi_index=1, .filter_type=(enum filter_type)FT_CONTENT_FILTER },
    { .multi_index=3, .filter_type=(enum filter_type)FT_CLIENT_HEADER_FILTER },
    { .multi_index=2, .filter_type=(enum filter_type)FT_SERVER_HEADER_FILTER },
    { .multi_index=4, .filter_type=(enum filter_type)FT_CLIENT_HEADER_TAGGER },
    { .multi_index=5, .filter_type=(enum filter_type)FT_SERVER_HEADER_TAGGER } };
  signed int errors = 0;
  signed int i = 0;
  for( ; !((unsigned long int)i >= 5ul); i = i + 1)
  {
    signed int return_value_referenced_filters_are_missing_1;
    return_value_referenced_filters_are_missing_1=referenced_filters_are_missing(csp, cur_action, filter_map[(signed long int)i].multi_index, filter_map[(signed long int)i].filter_type);
    errors = errors + return_value_referenced_filters_are_missing_1;
  }
  return errors;
}

// action_used_to_be_valid
// file actions.c line 439
static signed int action_used_to_be_valid(const char *action)
{
  unsigned int i = (unsigned int)0;
  for( ; !((unsigned long int)i >= 7ul); i = i + 1u)
  {
    signed int return_value_strcmpic_1;
    static const char * const formerly_valid_actions[7l] = { "inspect-jpegs", "kill-popups", "send-vanilla-wafer", "send-wafer", "treat-forbidden-connects-like-blocks", "vanilla-wafer", "wafer" };
    return_value_strcmpic_1=strcmpic(action, formerly_valid_actions[(signed long int)i]);
    if(return_value_strcmpic_1 == 0)
      return 1;

  }
  return 0;
}

// actions_from_radio
// file cgiedit.c line 4255
static enum privoxy_err actions_from_radio(struct map *parameters, struct action_spec *action)
{
  const char *param;
  char *param_dup;
  char ch;
  const char *js_name;
  enum privoxy_err err = (enum privoxy_err)JB_ERR_OK;
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  /* assertion action */
  assert(action != ((struct action_spec *)NULL));
  static char *actions_from_radio__1__1__js_name_arr;
  static signed int actions_from_radio__1__1__first_time = 1;
  if(!(actions_from_radio__1__1__first_time == 0))
  {
    actions_from_radio__1__1__js_name_arr=strdup("add-header");
    javascriptify(actions_from_radio__1__1__js_name_arr);
  }

  js_name = actions_from_radio__1__1__js_name_arr;
  actions_from_radio__1__1__first_time = 0;
  ch=get_char_param(parameters, js_name);
  if(!((signed int)ch == 89))
  {
    if((signed int)ch == 78)
    {
      list_remove_all(action->multi_add[(signed long int)0]);
      list_remove_all(action->multi_remove[(signed long int)0]);
      action->multi_remove_all[(signed long int)0] = 1;
    }

    else
      if((signed int)ch == 88)
      {
        list_remove_all(action->multi_add[(signed long int)0]);
        list_remove_all(action->multi_remove[(signed long int)0]);
        action->multi_remove_all[(signed long int)0] = 0;
      }

  }

  static char *actions_from_radio__1__5__js_name_arr;
  static signed int actions_from_radio__1__5__first_time = 1;
  if(!(actions_from_radio__1__5__first_time == 0))
  {
    actions_from_radio__1__5__js_name_arr=strdup("block");
    javascriptify(actions_from_radio__1__5__js_name_arr);
  }

  js_name = actions_from_radio__1__5__js_name_arr;
  actions_from_radio__1__5__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__6__1__js_name_arr;
    static signed int actions_from_radio__1__6__1__first_time = 1;
    if(!(actions_from_radio__1__6__1__first_time == 0))
    {
      actions_from_radio__1__6__1__js_name_arr=strdup("block-mode");
      javascriptify(actions_from_radio__1__6__1__js_name_arr);
    }

    js_name = actions_from_radio__1__6__1__js_name_arr;
    actions_from_radio__1__6__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_strcmp_1=strcmp(param, "CUSTOM");
      tmp_if_expr_2 = 0 == return_value_strcmp_1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
    {
      static char *actions_from_radio__1__6__2__1__js_name_arr;
      static signed int actions_from_radio__1__6__2__1__first_time = 1;
      if(!(actions_from_radio__1__6__2__1__first_time == 0))
      {
        actions_from_radio__1__6__2__1__js_name_arr=strdup("block-param");
        javascriptify(actions_from_radio__1__6__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__6__2__1__js_name_arr;
      actions_from_radio__1__6__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[16l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)16]);
        action->string[(signed long int)16] = (char *)(void *)0;
      }

      action->add = action->add | 0x00000001UL;
      action->mask = action->mask | 0x00000001UL;
      action->string[(signed long int)16] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x00000001UL & action->add) == 0ul))
      {
        if(!(action->string[16l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)16]);
          action->string[(signed long int)16] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x00000001UL;
      action->mask = action->mask & ~0x00000001UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x00000001UL & action->add) == 0ul))
        {
          if(!(action->string[16l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)16]);
            action->string[(signed long int)16] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x00000001UL;
        action->mask = action->mask | 0x00000001UL;
      }

  static char *actions_from_radio__1__9__js_name_arr;
  static signed int actions_from_radio__1__9__first_time = 1;
  if(!(actions_from_radio__1__9__first_time == 0))
  {
    actions_from_radio__1__9__js_name_arr=strdup("change-x-forwarded-for");
    javascriptify(actions_from_radio__1__9__js_name_arr);
  }

  js_name = actions_from_radio__1__9__js_name_arr;
  actions_from_radio__1__9__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_3;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__10__1__js_name_arr;
    static signed int actions_from_radio__1__10__1__first_time = 1;
    if(!(actions_from_radio__1__10__1__first_time == 0))
    {
      actions_from_radio__1__10__1__js_name_arr=strdup("change-x-forwarded-for-mode");
      javascriptify(actions_from_radio__1__10__1__js_name_arr);
    }

    js_name = actions_from_radio__1__10__1__js_name_arr;
    actions_from_radio__1__10__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_strcmp_3=strcmp(param, "CUSTOM");
      tmp_if_expr_4 = 0 == return_value_strcmp_3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      static char *actions_from_radio__1__10__2__1__js_name_arr;
      static signed int actions_from_radio__1__10__2__1__first_time = 1;
      if(!(actions_from_radio__1__10__2__1__first_time == 0))
      {
        actions_from_radio__1__10__2__1__js_name_arr=strdup("change-x-forwarded-for-param");
        javascriptify(actions_from_radio__1__10__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__10__2__1__js_name_arr;
      actions_from_radio__1__10__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[17l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)17]);
        action->string[(signed long int)17] = (char *)(void *)0;
      }

      action->add = action->add | 0x00000010UL;
      action->mask = action->mask | 0x00000010UL;
      action->string[(signed long int)17] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x00000010UL & action->add) == 0ul))
      {
        if(!(action->string[17l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)17]);
          action->string[(signed long int)17] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x00000010UL;
      action->mask = action->mask & ~0x00000010UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x00000010UL & action->add) == 0ul))
        {
          if(!(action->string[17l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)17]);
            action->string[(signed long int)17] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x00000010UL;
        action->mask = action->mask | 0x00000010UL;
      }

  static char *actions_from_radio__1__13__js_name_arr;
  static signed int actions_from_radio__1__13__first_time = 1;
  if(!(actions_from_radio__1__13__first_time == 0))
  {
    actions_from_radio__1__13__js_name_arr=strdup("client-header-filter");
    javascriptify(actions_from_radio__1__13__js_name_arr);
  }

  js_name = actions_from_radio__1__13__js_name_arr;
  actions_from_radio__1__13__first_time = 0;
  ch=get_char_param(parameters, js_name);
  if(!((signed int)ch == 89))
  {
    if((signed int)ch == 78)
    {
      list_remove_all(action->multi_add[(signed long int)3]);
      list_remove_all(action->multi_remove[(signed long int)3]);
      action->multi_remove_all[(signed long int)3] = 1;
    }

    else
      if((signed int)ch == 88)
      {
        list_remove_all(action->multi_add[(signed long int)3]);
        list_remove_all(action->multi_remove[(signed long int)3]);
        action->multi_remove_all[(signed long int)3] = 0;
      }

  }

  static char *actions_from_radio__1__17__js_name_arr;
  static signed int actions_from_radio__1__17__first_time = 1;
  if(!(actions_from_radio__1__17__first_time == 0))
  {
    actions_from_radio__1__17__js_name_arr=strdup("client-header-tagger");
    javascriptify(actions_from_radio__1__17__js_name_arr);
  }

  js_name = actions_from_radio__1__17__js_name_arr;
  actions_from_radio__1__17__first_time = 0;
  ch=get_char_param(parameters, js_name);
  if(!((signed int)ch == 89))
  {
    if((signed int)ch == 78)
    {
      list_remove_all(action->multi_add[(signed long int)4]);
      list_remove_all(action->multi_remove[(signed long int)4]);
      action->multi_remove_all[(signed long int)4] = 1;
    }

    else
      if((signed int)ch == 88)
      {
        list_remove_all(action->multi_add[(signed long int)4]);
        list_remove_all(action->multi_remove[(signed long int)4]);
        action->multi_remove_all[(signed long int)4] = 0;
      }

  }

  static char *actions_from_radio__1__21__js_name_arr;
  static signed int actions_from_radio__1__21__first_time = 1;
  if(!(actions_from_radio__1__21__first_time == 0))
  {
    actions_from_radio__1__21__js_name_arr=strdup("content-type-overwrite");
    javascriptify(actions_from_radio__1__21__js_name_arr);
  }

  js_name = actions_from_radio__1__21__js_name_arr;
  actions_from_radio__1__21__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_5;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__22__1__js_name_arr;
    static signed int actions_from_radio__1__22__1__first_time = 1;
    if(!(actions_from_radio__1__22__1__first_time == 0))
    {
      actions_from_radio__1__22__1__js_name_arr=strdup("content-type-overwrite-mode");
      javascriptify(actions_from_radio__1__22__1__js_name_arr);
    }

    js_name = actions_from_radio__1__22__1__js_name_arr;
    actions_from_radio__1__22__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_strcmp_5=strcmp(param, "CUSTOM");
      tmp_if_expr_6 = 0 == return_value_strcmp_5 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      static char *actions_from_radio__1__22__2__1__js_name_arr;
      static signed int actions_from_radio__1__22__2__1__first_time = 1;
      if(!(actions_from_radio__1__22__2__1__first_time == 0))
      {
        actions_from_radio__1__22__2__1__js_name_arr=strdup("content-type-overwrite-param");
        javascriptify(actions_from_radio__1__22__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__22__2__1__js_name_arr;
      actions_from_radio__1__22__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[9l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)9]);
        action->string[(signed long int)9] = (char *)(void *)0;
      }

      action->add = action->add | 0x00080000UL;
      action->mask = action->mask | 0x00080000UL;
      action->string[(signed long int)9] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x00080000UL & action->add) == 0ul))
      {
        if(!(action->string[9l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)9]);
          action->string[(signed long int)9] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x00080000UL;
      action->mask = action->mask & ~0x00080000UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x00080000UL & action->add) == 0ul))
        {
          if(!(action->string[9l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)9]);
            action->string[(signed long int)9] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x00080000UL;
        action->mask = action->mask | 0x00080000UL;
      }

  static char *actions_from_radio__1__25__js_name_arr;
  static signed int actions_from_radio__1__25__first_time = 1;
  if(!(actions_from_radio__1__25__first_time == 0))
  {
    actions_from_radio__1__25__js_name_arr=strdup("crunch-client-header");
    javascriptify(actions_from_radio__1__25__js_name_arr);
  }

  js_name = actions_from_radio__1__25__js_name_arr;
  actions_from_radio__1__25__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_8;
  signed int return_value_strcmp_7;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__26__1__js_name_arr;
    static signed int actions_from_radio__1__26__1__first_time = 1;
    if(!(actions_from_radio__1__26__1__first_time == 0))
    {
      actions_from_radio__1__26__1__js_name_arr=strdup("crunch-client-header-mode");
      javascriptify(actions_from_radio__1__26__1__js_name_arr);
    }

    js_name = actions_from_radio__1__26__1__js_name_arr;
    actions_from_radio__1__26__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_8 = (_Bool)1;

    else
    {
      return_value_strcmp_7=strcmp(param, "CUSTOM");
      tmp_if_expr_8 = 0 == return_value_strcmp_7 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_8)
    {
      static char *actions_from_radio__1__26__2__1__js_name_arr;
      static signed int actions_from_radio__1__26__2__1__first_time = 1;
      if(!(actions_from_radio__1__26__2__1__first_time == 0))
      {
        actions_from_radio__1__26__2__1__js_name_arr=strdup("crunch-client-header-param");
        javascriptify(actions_from_radio__1__26__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__26__2__1__js_name_arr;
      actions_from_radio__1__26__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[7l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)7]);
        action->string[(signed long int)7] = (char *)(void *)0;
      }

      action->add = action->add | 0x00200000UL;
      action->mask = action->mask | 0x00200000UL;
      action->string[(signed long int)7] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x00200000UL & action->add) == 0ul))
      {
        if(!(action->string[7l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)7]);
          action->string[(signed long int)7] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x00200000UL;
      action->mask = action->mask & ~0x00200000UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x00200000UL & action->add) == 0ul))
        {
          if(!(action->string[7l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)7]);
            action->string[(signed long int)7] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x00200000UL;
        action->mask = action->mask | 0x00200000UL;
      }

  static char *actions_from_radio__1__29__js_name_arr;
  static signed int actions_from_radio__1__29__first_time = 1;
  if(!(actions_from_radio__1__29__first_time == 0))
  {
    actions_from_radio__1__29__js_name_arr=strdup("crunch-if-none-match");
    javascriptify(actions_from_radio__1__29__js_name_arr);
  }

  js_name = actions_from_radio__1__29__js_name_arr;
  actions_from_radio__1__29__first_time = 0;
  ch=get_char_param(parameters, js_name);
  if((signed int)ch == 89)
  {
    action->add = action->add | 0x00800000UL;
    action->mask = action->mask | 0x00800000UL;
  }

  else
    if((signed int)ch == 78)
    {
      action->add = action->add & ~0x00800000UL;
      action->mask = action->mask & ~0x00800000UL;
    }

    else
      if((signed int)ch == 88)
      {
        action->add = action->add & ~0x00800000UL;
        action->mask = action->mask | 0x00800000UL;
      }

  static char *actions_from_radio__1__33__js_name_arr;
  static signed int actions_from_radio__1__33__first_time = 1;
  if(!(actions_from_radio__1__33__first_time == 0))
  {
    actions_from_radio__1__33__js_name_arr=strdup("crunch-incoming-cookies");
    javascriptify(actions_from_radio__1__33__js_name_arr);
  }

  js_name = actions_from_radio__1__33__js_name_arr;
  actions_from_radio__1__33__first_time = 0;
  ch=get_char_param(parameters, js_name);
  if((signed int)ch == 89)
  {
    action->add = action->add | 0x00002000UL;
    action->mask = action->mask | 0x00002000UL;
  }

  else
    if((signed int)ch == 78)
    {
      action->add = action->add & ~0x00002000UL;
      action->mask = action->mask & ~0x00002000UL;
    }

    else
      if((signed int)ch == 88)
      {
        action->add = action->add & ~0x00002000UL;
        action->mask = action->mask | 0x00002000UL;
      }

  static char *actions_from_radio__1__37__js_name_arr;
  static signed int actions_from_radio__1__37__first_time = 1;
  if(!(actions_from_radio__1__37__first_time == 0))
  {
    actions_from_radio__1__37__js_name_arr=strdup("crunch-outgoing-cookies");
    javascriptify(actions_from_radio__1__37__js_name_arr);
  }

  js_name = actions_from_radio__1__37__js_name_arr;
  actions_from_radio__1__37__first_time = 0;
  ch=get_char_param(parameters, js_name);
  if((signed int)ch == 89)
  {
    action->add = action->add | 0x00001000UL;
    action->mask = action->mask | 0x00001000UL;
  }

  else
    if((signed int)ch == 78)
    {
      action->add = action->add & ~0x00001000UL;
      action->mask = action->mask & ~0x00001000UL;
    }

    else
      if((signed int)ch == 88)
      {
        action->add = action->add & ~0x00001000UL;
        action->mask = action->mask | 0x00001000UL;
      }

  static char *actions_from_radio__1__41__js_name_arr;
  static signed int actions_from_radio__1__41__first_time = 1;
  if(!(actions_from_radio__1__41__first_time == 0))
  {
    actions_from_radio__1__41__js_name_arr=strdup("crunch-server-header");
    javascriptify(actions_from_radio__1__41__js_name_arr);
  }

  js_name = actions_from_radio__1__41__js_name_arr;
  actions_from_radio__1__41__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_10;
  signed int return_value_strcmp_9;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__42__1__js_name_arr;
    static signed int actions_from_radio__1__42__1__first_time = 1;
    if(!(actions_from_radio__1__42__1__first_time == 0))
    {
      actions_from_radio__1__42__1__js_name_arr=strdup("crunch-server-header-mode");
      javascriptify(actions_from_radio__1__42__1__js_name_arr);
    }

    js_name = actions_from_radio__1__42__1__js_name_arr;
    actions_from_radio__1__42__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_10 = (_Bool)1;

    else
    {
      return_value_strcmp_9=strcmp(param, "CUSTOM");
      tmp_if_expr_10 = 0 == return_value_strcmp_9 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_10)
    {
      static char *actions_from_radio__1__42__2__1__js_name_arr;
      static signed int actions_from_radio__1__42__2__1__first_time = 1;
      if(!(actions_from_radio__1__42__2__1__first_time == 0))
      {
        actions_from_radio__1__42__2__1__js_name_arr=strdup("crunch-server-header-param");
        javascriptify(actions_from_radio__1__42__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__42__2__1__js_name_arr;
      actions_from_radio__1__42__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[6l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)6]);
        action->string[(signed long int)6] = (char *)(void *)0;
      }

      action->add = action->add | 0x00100000UL;
      action->mask = action->mask | 0x00100000UL;
      action->string[(signed long int)6] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x00100000UL & action->add) == 0ul))
      {
        if(!(action->string[6l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)6]);
          action->string[(signed long int)6] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x00100000UL;
      action->mask = action->mask & ~0x00100000UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x00100000UL & action->add) == 0ul))
        {
          if(!(action->string[6l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)6]);
            action->string[(signed long int)6] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x00100000UL;
        action->mask = action->mask | 0x00100000UL;
      }

  static char *actions_from_radio__1__45__js_name_arr;
  static signed int actions_from_radio__1__45__first_time = 1;
  if(!(actions_from_radio__1__45__first_time == 0))
  {
    actions_from_radio__1__45__js_name_arr=strdup("deanimate-gifs");
    javascriptify(actions_from_radio__1__45__js_name_arr);
  }

  js_name = actions_from_radio__1__45__js_name_arr;
  actions_from_radio__1__45__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_12;
  signed int return_value_strcmp_11;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__46__1__js_name_arr;
    static signed int actions_from_radio__1__46__1__first_time = 1;
    if(!(actions_from_radio__1__46__1__first_time == 0))
    {
      actions_from_radio__1__46__1__js_name_arr=strdup("deanimate-gifs-mode");
      javascriptify(actions_from_radio__1__46__1__js_name_arr);
    }

    js_name = actions_from_radio__1__46__1__js_name_arr;
    actions_from_radio__1__46__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_12 = (_Bool)1;

    else
    {
      return_value_strcmp_11=strcmp(param, "CUSTOM");
      tmp_if_expr_12 = 0 == return_value_strcmp_11 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_12)
    {
      static char *actions_from_radio__1__46__2__1__js_name_arr;
      static signed int actions_from_radio__1__46__2__1__first_time = 1;
      if(!(actions_from_radio__1__46__2__1__first_time == 0))
      {
        actions_from_radio__1__46__2__1__js_name_arr=strdup("deanimate-gifs-param");
        javascriptify(actions_from_radio__1__46__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__46__2__1__js_name_arr;
      actions_from_radio__1__46__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[0l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)0]);
        action->string[(signed long int)0] = (char *)(void *)0;
      }

      action->add = action->add | 0x00000002UL;
      action->mask = action->mask | 0x00000002UL;
      action->string[(signed long int)0] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x00000002UL & action->add) == 0ul))
      {
        if(!(action->string[0l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)0]);
          action->string[(signed long int)0] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x00000002UL;
      action->mask = action->mask & ~0x00000002UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x00000002UL & action->add) == 0ul))
        {
          if(!(action->string[0l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)0]);
            action->string[(signed long int)0] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x00000002UL;
        action->mask = action->mask | 0x00000002UL;
      }

  static char *actions_from_radio__1__49__js_name_arr;
  static signed int actions_from_radio__1__49__first_time = 1;
  if(!(actions_from_radio__1__49__first_time == 0))
  {
    actions_from_radio__1__49__js_name_arr=strdup("downgrade-http-version");
    javascriptify(actions_from_radio__1__49__js_name_arr);
  }

  js_name = actions_from_radio__1__49__js_name_arr;
  actions_from_radio__1__49__first_time = 0;
  ch=get_char_param(parameters, js_name);
  if((signed int)ch == 89)
  {
    action->add = action->add | 0x00000004UL;
    action->mask = action->mask | 0x00000004UL;
  }

  else
    if((signed int)ch == 78)
    {
      action->add = action->add & ~0x00000004UL;
      action->mask = action->mask & ~0x00000004UL;
    }

    else
      if((signed int)ch == 88)
      {
        action->add = action->add & ~0x00000004UL;
        action->mask = action->mask | 0x00000004UL;
      }

  static char *actions_from_radio__1__53__js_name_arr;
  static signed int actions_from_radio__1__53__first_time = 1;
  if(!(actions_from_radio__1__53__first_time == 0))
  {
    actions_from_radio__1__53__js_name_arr=strdup("external-filter");
    javascriptify(actions_from_radio__1__53__js_name_arr);
  }

  js_name = actions_from_radio__1__53__js_name_arr;
  actions_from_radio__1__53__first_time = 0;
  ch=get_char_param(parameters, js_name);
  if(!((signed int)ch == 89))
  {
    if((signed int)ch == 78)
    {
      list_remove_all(action->multi_add[(signed long int)6]);
      list_remove_all(action->multi_remove[(signed long int)6]);
      action->multi_remove_all[(signed long int)6] = 1;
    }

    else
      if((signed int)ch == 88)
      {
        list_remove_all(action->multi_add[(signed long int)6]);
        list_remove_all(action->multi_remove[(signed long int)6]);
        action->multi_remove_all[(signed long int)6] = 0;
      }

  }

  static char *actions_from_radio__1__57__js_name_arr;
  static signed int actions_from_radio__1__57__first_time = 1;
  if(!(actions_from_radio__1__57__first_time == 0))
  {
    actions_from_radio__1__57__js_name_arr=strdup("fast-redirects");
    javascriptify(actions_from_radio__1__57__js_name_arr);
  }

  js_name = actions_from_radio__1__57__js_name_arr;
  actions_from_radio__1__57__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_14;
  signed int return_value_strcmp_13;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__58__1__js_name_arr;
    static signed int actions_from_radio__1__58__1__first_time = 1;
    if(!(actions_from_radio__1__58__1__first_time == 0))
    {
      actions_from_radio__1__58__1__js_name_arr=strdup("fast-redirects-mode");
      javascriptify(actions_from_radio__1__58__1__js_name_arr);
    }

    js_name = actions_from_radio__1__58__1__js_name_arr;
    actions_from_radio__1__58__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_14 = (_Bool)1;

    else
    {
      return_value_strcmp_13=strcmp(param, "CUSTOM");
      tmp_if_expr_14 = 0 == return_value_strcmp_13 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_14)
    {
      static char *actions_from_radio__1__58__2__1__js_name_arr;
      static signed int actions_from_radio__1__58__2__1__first_time = 1;
      if(!(actions_from_radio__1__58__2__1__first_time == 0))
      {
        actions_from_radio__1__58__2__1__js_name_arr=strdup("fast-redirects-param");
        javascriptify(actions_from_radio__1__58__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__58__2__1__js_name_arr;
      actions_from_radio__1__58__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[14l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)14]);
        action->string[(signed long int)14] = (char *)(void *)0;
      }

      action->add = action->add | 0x00000008UL;
      action->mask = action->mask | 0x00000008UL;
      action->string[(signed long int)14] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x00000008UL & action->add) == 0ul))
      {
        if(!(action->string[14l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)14]);
          action->string[(signed long int)14] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x00000008UL;
      action->mask = action->mask & ~0x00000008UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x00000008UL & action->add) == 0ul))
        {
          if(!(action->string[14l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)14]);
            action->string[(signed long int)14] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x00000008UL;
        action->mask = action->mask | 0x00000008UL;
      }

  static char *actions_from_radio__1__61__js_name_arr;
  static signed int actions_from_radio__1__61__first_time = 1;
  if(!(actions_from_radio__1__61__first_time == 0))
  {
    actions_from_radio__1__61__js_name_arr=strdup("filter");
    javascriptify(actions_from_radio__1__61__js_name_arr);
  }

  js_name = actions_from_radio__1__61__js_name_arr;
  actions_from_radio__1__61__first_time = 0;
  ch=get_char_param(parameters, js_name);
  if(!((signed int)ch == 89))
  {
    if((signed int)ch == 78)
    {
      list_remove_all(action->multi_add[(signed long int)1]);
      list_remove_all(action->multi_remove[(signed long int)1]);
      action->multi_remove_all[(signed long int)1] = 1;
    }

    else
      if((signed int)ch == 88)
      {
        list_remove_all(action->multi_add[(signed long int)1]);
        list_remove_all(action->multi_remove[(signed long int)1]);
        action->multi_remove_all[(signed long int)1] = 0;
      }

  }

  static char *actions_from_radio__1__65__js_name_arr;
  static signed int actions_from_radio__1__65__first_time = 1;
  if(!(actions_from_radio__1__65__first_time == 0))
  {
    actions_from_radio__1__65__js_name_arr=strdup("force-text-mode");
    javascriptify(actions_from_radio__1__65__js_name_arr);
  }

  js_name = actions_from_radio__1__65__js_name_arr;
  actions_from_radio__1__65__first_time = 0;
  ch=get_char_param(parameters, js_name);
  if((signed int)ch == 89)
  {
    action->add = action->add | 0x00400000UL;
    action->mask = action->mask | 0x00400000UL;
  }

  else
    if((signed int)ch == 78)
    {
      action->add = action->add & ~0x00400000UL;
      action->mask = action->mask & ~0x00400000UL;
    }

    else
      if((signed int)ch == 88)
      {
        action->add = action->add & ~0x00400000UL;
        action->mask = action->mask | 0x00400000UL;
      }

  static char *actions_from_radio__1__69__js_name_arr;
  static signed int actions_from_radio__1__69__first_time = 1;
  if(!(actions_from_radio__1__69__first_time == 0))
  {
    actions_from_radio__1__69__js_name_arr=strdup("forward-override");
    javascriptify(actions_from_radio__1__69__js_name_arr);
  }

  js_name = actions_from_radio__1__69__js_name_arr;
  actions_from_radio__1__69__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_16;
  signed int return_value_strcmp_15;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__70__1__js_name_arr;
    static signed int actions_from_radio__1__70__1__first_time = 1;
    if(!(actions_from_radio__1__70__1__first_time == 0))
    {
      actions_from_radio__1__70__1__js_name_arr=strdup("forward-override-mode");
      javascriptify(actions_from_radio__1__70__1__js_name_arr);
    }

    js_name = actions_from_radio__1__70__1__js_name_arr;
    actions_from_radio__1__70__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_16 = (_Bool)1;

    else
    {
      return_value_strcmp_15=strcmp(param, "CUSTOM");
      tmp_if_expr_16 = 0 == return_value_strcmp_15 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_16)
    {
      static char *actions_from_radio__1__70__2__1__js_name_arr;
      static signed int actions_from_radio__1__70__2__1__first_time = 1;
      if(!(actions_from_radio__1__70__2__1__first_time == 0))
      {
        actions_from_radio__1__70__2__1__js_name_arr=strdup("forward-override-param");
        javascriptify(actions_from_radio__1__70__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__70__2__1__js_name_arr;
      actions_from_radio__1__70__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[15l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)15]);
        action->string[(signed long int)15] = (char *)(void *)0;
      }

      action->add = action->add | 0x00004000UL;
      action->mask = action->mask | 0x00004000UL;
      action->string[(signed long int)15] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x00004000UL & action->add) == 0ul))
      {
        if(!(action->string[15l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)15]);
          action->string[(signed long int)15] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x00004000UL;
      action->mask = action->mask & ~0x00004000UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x00004000UL & action->add) == 0ul))
        {
          if(!(action->string[15l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)15]);
            action->string[(signed long int)15] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x00004000UL;
        action->mask = action->mask | 0x00004000UL;
      }

  static char *actions_from_radio__1__73__js_name_arr;
  static signed int actions_from_radio__1__73__first_time = 1;
  if(!(actions_from_radio__1__73__first_time == 0))
  {
    actions_from_radio__1__73__js_name_arr=strdup("handle-as-empty-document");
    javascriptify(actions_from_radio__1__73__js_name_arr);
  }

  js_name = actions_from_radio__1__73__js_name_arr;
  actions_from_radio__1__73__first_time = 0;
  ch=get_char_param(parameters, js_name);
  if((signed int)ch == 89)
  {
    action->add = action->add | 0x00008000UL;
    action->mask = action->mask | 0x00008000UL;
  }

  else
    if((signed int)ch == 78)
    {
      action->add = action->add & ~0x00008000UL;
      action->mask = action->mask & ~0x00008000UL;
    }

    else
      if((signed int)ch == 88)
      {
        action->add = action->add & ~0x00008000UL;
        action->mask = action->mask | 0x00008000UL;
      }

  static char *actions_from_radio__1__77__js_name_arr;
  static signed int actions_from_radio__1__77__first_time = 1;
  if(!(actions_from_radio__1__77__first_time == 0))
  {
    actions_from_radio__1__77__js_name_arr=strdup("handle-as-image");
    javascriptify(actions_from_radio__1__77__js_name_arr);
  }

  js_name = actions_from_radio__1__77__js_name_arr;
  actions_from_radio__1__77__first_time = 0;
  ch=get_char_param(parameters, js_name);
  if((signed int)ch == 89)
  {
    action->add = action->add | 0x00000100UL;
    action->mask = action->mask | 0x00000100UL;
  }

  else
    if((signed int)ch == 78)
    {
      action->add = action->add & ~0x00000100UL;
      action->mask = action->mask & ~0x00000100UL;
    }

    else
      if((signed int)ch == 88)
      {
        action->add = action->add & ~0x00000100UL;
        action->mask = action->mask | 0x00000100UL;
      }

  static char *actions_from_radio__1__81__js_name_arr;
  static signed int actions_from_radio__1__81__first_time = 1;
  if(!(actions_from_radio__1__81__first_time == 0))
  {
    actions_from_radio__1__81__js_name_arr=strdup("hide-accept-language");
    javascriptify(actions_from_radio__1__81__js_name_arr);
  }

  js_name = actions_from_radio__1__81__js_name_arr;
  actions_from_radio__1__81__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_18;
  signed int return_value_strcmp_17;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__82__1__js_name_arr;
    static signed int actions_from_radio__1__82__1__first_time = 1;
    if(!(actions_from_radio__1__82__1__first_time == 0))
    {
      actions_from_radio__1__82__1__js_name_arr=strdup("hide-accept-language-mode");
      javascriptify(actions_from_radio__1__82__1__js_name_arr);
    }

    js_name = actions_from_radio__1__82__1__js_name_arr;
    actions_from_radio__1__82__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_18 = (_Bool)1;

    else
    {
      return_value_strcmp_17=strcmp(param, "CUSTOM");
      tmp_if_expr_18 = 0 == return_value_strcmp_17 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_18)
    {
      static char *actions_from_radio__1__82__2__1__js_name_arr;
      static signed int actions_from_radio__1__82__2__1__first_time = 1;
      if(!(actions_from_radio__1__82__2__1__first_time == 0))
      {
        actions_from_radio__1__82__2__1__js_name_arr=strdup("hide-accept-language-param");
        javascriptify(actions_from_radio__1__82__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__82__2__1__js_name_arr;
      actions_from_radio__1__82__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[8l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)8]);
        action->string[(signed long int)8] = (char *)(void *)0;
      }

      action->add = action->add | 0x04000000UL;
      action->mask = action->mask | 0x04000000UL;
      action->string[(signed long int)8] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x04000000UL & action->add) == 0ul))
      {
        if(!(action->string[8l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)8]);
          action->string[(signed long int)8] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x04000000UL;
      action->mask = action->mask & ~0x04000000UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x04000000UL & action->add) == 0ul))
        {
          if(!(action->string[8l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)8]);
            action->string[(signed long int)8] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x04000000UL;
        action->mask = action->mask | 0x04000000UL;
      }

  static char *actions_from_radio__1__85__js_name_arr;
  static signed int actions_from_radio__1__85__first_time = 1;
  if(!(actions_from_radio__1__85__first_time == 0))
  {
    actions_from_radio__1__85__js_name_arr=strdup("hide-content-disposition");
    javascriptify(actions_from_radio__1__85__js_name_arr);
  }

  js_name = actions_from_radio__1__85__js_name_arr;
  actions_from_radio__1__85__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_20;
  signed int return_value_strcmp_19;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__86__1__js_name_arr;
    static signed int actions_from_radio__1__86__1__first_time = 1;
    if(!(actions_from_radio__1__86__1__first_time == 0))
    {
      actions_from_radio__1__86__1__js_name_arr=strdup("hide-content-disposition-mode");
      javascriptify(actions_from_radio__1__86__1__js_name_arr);
    }

    js_name = actions_from_radio__1__86__1__js_name_arr;
    actions_from_radio__1__86__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_20 = (_Bool)1;

    else
    {
      return_value_strcmp_19=strcmp(param, "CUSTOM");
      tmp_if_expr_20 = 0 == return_value_strcmp_19 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_20)
    {
      static char *actions_from_radio__1__86__2__1__js_name_arr;
      static signed int actions_from_radio__1__86__2__1__first_time = 1;
      if(!(actions_from_radio__1__86__2__1__first_time == 0))
      {
        actions_from_radio__1__86__2__1__js_name_arr=strdup("hide-content-disposition-param");
        javascriptify(actions_from_radio__1__86__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__86__2__1__js_name_arr;
      actions_from_radio__1__86__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[10l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)10]);
        action->string[(signed long int)10] = (char *)(void *)0;
      }

      action->add = action->add | 0x01000000UL;
      action->mask = action->mask | 0x01000000UL;
      action->string[(signed long int)10] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x01000000UL & action->add) == 0ul))
      {
        if(!(action->string[10l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)10]);
          action->string[(signed long int)10] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x01000000UL;
      action->mask = action->mask & ~0x01000000UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x01000000UL & action->add) == 0ul))
        {
          if(!(action->string[10l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)10]);
            action->string[(signed long int)10] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x01000000UL;
        action->mask = action->mask | 0x01000000UL;
      }

  static char *actions_from_radio__1__89__js_name_arr;
  static signed int actions_from_radio__1__89__first_time = 1;
  if(!(actions_from_radio__1__89__first_time == 0))
  {
    actions_from_radio__1__89__js_name_arr=strdup("hide-from-header");
    javascriptify(actions_from_radio__1__89__js_name_arr);
  }

  js_name = actions_from_radio__1__89__js_name_arr;
  actions_from_radio__1__89__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_22;
  signed int return_value_strcmp_21;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__90__1__js_name_arr;
    static signed int actions_from_radio__1__90__1__first_time = 1;
    if(!(actions_from_radio__1__90__1__first_time == 0))
    {
      actions_from_radio__1__90__1__js_name_arr=strdup("hide-from-header-mode");
      javascriptify(actions_from_radio__1__90__1__js_name_arr);
    }

    js_name = actions_from_radio__1__90__1__js_name_arr;
    actions_from_radio__1__90__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_22 = (_Bool)1;

    else
    {
      return_value_strcmp_21=strcmp(param, "CUSTOM");
      tmp_if_expr_22 = 0 == return_value_strcmp_21 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_22)
    {
      static char *actions_from_radio__1__90__2__1__js_name_arr;
      static signed int actions_from_radio__1__90__2__1__first_time = 1;
      if(!(actions_from_radio__1__90__2__1__first_time == 0))
      {
        actions_from_radio__1__90__2__1__js_name_arr=strdup("hide-from-header-param");
        javascriptify(actions_from_radio__1__90__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__90__2__1__js_name_arr;
      actions_from_radio__1__90__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[1l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)1]);
        action->string[(signed long int)1] = (char *)(void *)0;
      }

      action->add = action->add | 0x00000020UL;
      action->mask = action->mask | 0x00000020UL;
      action->string[(signed long int)1] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x00000020UL & action->add) == 0ul))
      {
        if(!(action->string[1l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)1]);
          action->string[(signed long int)1] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x00000020UL;
      action->mask = action->mask & ~0x00000020UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x00000020UL & action->add) == 0ul))
        {
          if(!(action->string[1l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)1]);
            action->string[(signed long int)1] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x00000020UL;
        action->mask = action->mask | 0x00000020UL;
      }

  static char *actions_from_radio__1__93__js_name_arr;
  static signed int actions_from_radio__1__93__first_time = 1;
  if(!(actions_from_radio__1__93__first_time == 0))
  {
    actions_from_radio__1__93__js_name_arr=strdup("hide-if-modified-since");
    javascriptify(actions_from_radio__1__93__js_name_arr);
  }

  js_name = actions_from_radio__1__93__js_name_arr;
  actions_from_radio__1__93__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_24;
  signed int return_value_strcmp_23;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *js_name_arr;
    static signed int actions_from_radio__1__94__1__first_time = 1;
    if(!(actions_from_radio__1__94__1__first_time == 0))
    {
      js_name_arr=strdup("hide-if-modified-since-mode");
      javascriptify(js_name_arr);
    }

    js_name = js_name_arr;
    actions_from_radio__1__94__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_24 = (_Bool)1;

    else
    {
      return_value_strcmp_23=strcmp(param, "CUSTOM");
      tmp_if_expr_24 = 0 == return_value_strcmp_23 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_24)
    {
      static char *actions_from_radio__1__94__2__1__js_name_arr;
      static signed int first_time = 1;
      if(!(first_time == 0))
      {
        actions_from_radio__1__94__2__1__js_name_arr=strdup("hide-if-modified-since-param");
        javascriptify(actions_from_radio__1__94__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__94__2__1__js_name_arr;
      first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[11l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)11]);
        action->string[(signed long int)11] = (char *)(void *)0;
      }

      action->add = action->add | 0x00040000UL;
      action->mask = action->mask | 0x00040000UL;
      action->string[(signed long int)11] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x00040000UL & action->add) == 0ul))
      {
        if(!(action->string[11l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)11]);
          action->string[(signed long int)11] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x00040000UL;
      action->mask = action->mask & ~0x00040000UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x00040000UL & action->add) == 0ul))
        {
          if(!(action->string[11l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)11]);
            action->string[(signed long int)11] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x00040000UL;
        action->mask = action->mask | 0x00040000UL;
      }

  static char *actions_from_radio__1__97__js_name_arr;
  static signed int actions_from_radio__1__97__first_time = 1;
  if(!(actions_from_radio__1__97__first_time == 0))
  {
    actions_from_radio__1__97__js_name_arr=strdup("hide-referrer");
    javascriptify(actions_from_radio__1__97__js_name_arr);
  }

  js_name = actions_from_radio__1__97__js_name_arr;
  actions_from_radio__1__97__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_26;
  signed int return_value_strcmp_25;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__98__1__js_name_arr;
    static signed int actions_from_radio__1__98__1__first_time = 1;
    if(!(actions_from_radio__1__98__1__first_time == 0))
    {
      actions_from_radio__1__98__1__js_name_arr=strdup("hide-referrer-mode");
      javascriptify(actions_from_radio__1__98__1__js_name_arr);
    }

    js_name = actions_from_radio__1__98__1__js_name_arr;
    actions_from_radio__1__98__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_26 = (_Bool)1;

    else
    {
      return_value_strcmp_25=strcmp(param, "CUSTOM");
      tmp_if_expr_26 = 0 == return_value_strcmp_25 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_26)
    {
      static char *actions_from_radio__1__98__2__1__js_name_arr;
      static signed int actions_from_radio__1__98__2__1__first_time = 1;
      if(!(actions_from_radio__1__98__2__1__first_time == 0))
      {
        actions_from_radio__1__98__2__1__js_name_arr=strdup("hide-referrer-param");
        javascriptify(actions_from_radio__1__98__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__98__2__1__js_name_arr;
      actions_from_radio__1__98__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[3l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)3]);
        action->string[(signed long int)3] = (char *)(void *)0;
      }

      action->add = action->add | 0x00000040UL;
      action->mask = action->mask | 0x00000040UL;
      action->string[(signed long int)3] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x00000040UL & action->add) == 0ul))
      {
        if(!(action->string[3l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)3]);
          action->string[(signed long int)3] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x00000040UL;
      action->mask = action->mask & ~0x00000040UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x00000040UL & action->add) == 0ul))
        {
          if(!(action->string[3l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)3]);
            action->string[(signed long int)3] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x00000040UL;
        action->mask = action->mask | 0x00000040UL;
      }

  static char *actions_from_radio__1__101__js_name_arr;
  static signed int actions_from_radio__1__101__first_time = 1;
  if(!(actions_from_radio__1__101__first_time == 0))
  {
    actions_from_radio__1__101__js_name_arr=strdup("hide-user-agent");
    javascriptify(actions_from_radio__1__101__js_name_arr);
  }

  js_name = actions_from_radio__1__101__js_name_arr;
  actions_from_radio__1__101__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_28;
  signed int return_value_strcmp_27;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__102__1__js_name_arr;
    static signed int actions_from_radio__1__102__1__first_time = 1;
    if(!(actions_from_radio__1__102__1__first_time == 0))
    {
      actions_from_radio__1__102__1__js_name_arr=strdup("hide-user-agent-mode");
      javascriptify(actions_from_radio__1__102__1__js_name_arr);
    }

    js_name = actions_from_radio__1__102__1__js_name_arr;
    actions_from_radio__1__102__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_28 = (_Bool)1;

    else
    {
      return_value_strcmp_27=strcmp(param, "CUSTOM");
      tmp_if_expr_28 = 0 == return_value_strcmp_27 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_28)
    {
      static char *actions_from_radio__1__102__2__1__js_name_arr;
      static signed int actions_from_radio__1__102__2__1__first_time = 1;
      if(!(actions_from_radio__1__102__2__1__first_time == 0))
      {
        actions_from_radio__1__102__2__1__js_name_arr=strdup("hide-user-agent-param");
        javascriptify(actions_from_radio__1__102__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__102__2__1__js_name_arr;
      actions_from_radio__1__102__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[4l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)4]);
        action->string[(signed long int)4] = (char *)(void *)0;
      }

      action->add = action->add | 0x00000080UL;
      action->mask = action->mask | 0x00000080UL;
      action->string[(signed long int)4] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x00000080UL & action->add) == 0ul))
      {
        if(!(action->string[4l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)4]);
          action->string[(signed long int)4] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x00000080UL;
      action->mask = action->mask & ~0x00000080UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x00000080UL & action->add) == 0ul))
        {
          if(!(action->string[4l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)4]);
            action->string[(signed long int)4] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x00000080UL;
        action->mask = action->mask | 0x00000080UL;
      }

  static char *actions_from_radio__1__105__js_name_arr;
  static signed int actions_from_radio__1__105__first_time = 1;
  if(!(actions_from_radio__1__105__first_time == 0))
  {
    actions_from_radio__1__105__js_name_arr=strdup("limit-connect");
    javascriptify(actions_from_radio__1__105__js_name_arr);
  }

  js_name = actions_from_radio__1__105__js_name_arr;
  actions_from_radio__1__105__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_30;
  signed int return_value_strcmp_29;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__106__1__js_name_arr;
    static signed int actions_from_radio__1__106__1__first_time = 1;
    if(!(actions_from_radio__1__106__1__first_time == 0))
    {
      actions_from_radio__1__106__1__js_name_arr=strdup("limit-connect-mode");
      javascriptify(actions_from_radio__1__106__1__js_name_arr);
    }

    js_name = actions_from_radio__1__106__1__js_name_arr;
    actions_from_radio__1__106__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_30 = (_Bool)1;

    else
    {
      return_value_strcmp_29=strcmp(param, "CUSTOM");
      tmp_if_expr_30 = 0 == return_value_strcmp_29 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_30)
    {
      static char *actions_from_radio__1__106__2__1__js_name_arr;
      static signed int actions_from_radio__1__106__2__1__first_time = 1;
      if(!(actions_from_radio__1__106__2__1__first_time == 0))
      {
        actions_from_radio__1__106__2__1__js_name_arr=strdup("limit-connect-param");
        javascriptify(actions_from_radio__1__106__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__106__2__1__js_name_arr;
      actions_from_radio__1__106__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[5l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)5]);
        action->string[(signed long int)5] = (char *)(void *)0;
      }

      action->add = action->add | 0x00010000UL;
      action->mask = action->mask | 0x00010000UL;
      action->string[(signed long int)5] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x00010000UL & action->add) == 0ul))
      {
        if(!(action->string[5l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)5]);
          action->string[(signed long int)5] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x00010000UL;
      action->mask = action->mask & ~0x00010000UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x00010000UL & action->add) == 0ul))
        {
          if(!(action->string[5l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)5]);
            action->string[(signed long int)5] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x00010000UL;
        action->mask = action->mask | 0x00010000UL;
      }

  static char *actions_from_radio__1__109__js_name_arr;
  static signed int actions_from_radio__1__109__first_time = 1;
  if(!(actions_from_radio__1__109__first_time == 0))
  {
    actions_from_radio__1__109__js_name_arr=strdup("limit-cookie-lifetime");
    javascriptify(actions_from_radio__1__109__js_name_arr);
  }

  js_name = actions_from_radio__1__109__js_name_arr;
  actions_from_radio__1__109__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_32;
  signed int return_value_strcmp_31;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__110__1__js_name_arr;
    static signed int actions_from_radio__1__110__1__first_time = 1;
    if(!(actions_from_radio__1__110__1__first_time == 0))
    {
      actions_from_radio__1__110__1__js_name_arr=strdup("limit-cookie-lifetime-mode");
      javascriptify(actions_from_radio__1__110__1__js_name_arr);
    }

    js_name = actions_from_radio__1__110__1__js_name_arr;
    actions_from_radio__1__110__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_32 = (_Bool)1;

    else
    {
      return_value_strcmp_31=strcmp(param, "CUSTOM");
      tmp_if_expr_32 = 0 == return_value_strcmp_31 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_32)
    {
      static char *actions_from_radio__1__110__2__1__js_name_arr;
      static signed int actions_from_radio__1__110__2__1__first_time = 1;
      if(!(actions_from_radio__1__110__2__1__first_time == 0))
      {
        actions_from_radio__1__110__2__1__js_name_arr=strdup("limit-cookie-lifetime-param");
        javascriptify(actions_from_radio__1__110__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__110__2__1__js_name_arr;
      actions_from_radio__1__110__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[18l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)18]);
        action->string[(signed long int)18] = (char *)(void *)0;
      }

      action->add = action->add | 0x08000000UL;
      action->mask = action->mask | 0x08000000UL;
      action->string[(signed long int)18] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x08000000UL & action->add) == 0ul))
      {
        if(!(action->string[18l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)18]);
          action->string[(signed long int)18] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x08000000UL;
      action->mask = action->mask & ~0x08000000UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x08000000UL & action->add) == 0ul))
        {
          if(!(action->string[18l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)18]);
            action->string[(signed long int)18] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x08000000UL;
        action->mask = action->mask | 0x08000000UL;
      }

  static char *actions_from_radio__1__113__js_name_arr;
  static signed int actions_from_radio__1__113__first_time = 1;
  if(!(actions_from_radio__1__113__first_time == 0))
  {
    actions_from_radio__1__113__js_name_arr=strdup("overwrite-last-modified");
    javascriptify(actions_from_radio__1__113__js_name_arr);
  }

  js_name = actions_from_radio__1__113__js_name_arr;
  actions_from_radio__1__113__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_34;
  signed int return_value_strcmp_33;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__114__1__js_name_arr;
    static signed int actions_from_radio__1__114__1__first_time = 1;
    if(!(actions_from_radio__1__114__1__first_time == 0))
    {
      actions_from_radio__1__114__1__js_name_arr=strdup("overwrite-last-modified-mode");
      javascriptify(actions_from_radio__1__114__1__js_name_arr);
    }

    js_name = actions_from_radio__1__114__1__js_name_arr;
    actions_from_radio__1__114__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_34 = (_Bool)1;

    else
    {
      return_value_strcmp_33=strcmp(param, "CUSTOM");
      tmp_if_expr_34 = 0 == return_value_strcmp_33 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_34)
    {
      static char *actions_from_radio__1__114__2__1__js_name_arr;
      static signed int actions_from_radio__1__114__2__1__first_time = 1;
      if(!(actions_from_radio__1__114__2__1__first_time == 0))
      {
        actions_from_radio__1__114__2__1__js_name_arr=strdup("overwrite-last-modified-param");
        javascriptify(actions_from_radio__1__114__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__114__2__1__js_name_arr;
      actions_from_radio__1__114__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[12l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)12]);
        action->string[(signed long int)12] = (char *)(void *)0;
      }

      action->add = action->add | 0x02000000UL;
      action->mask = action->mask | 0x02000000UL;
      action->string[(signed long int)12] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x02000000UL & action->add) == 0ul))
      {
        if(!(action->string[12l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)12]);
          action->string[(signed long int)12] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x02000000UL;
      action->mask = action->mask & ~0x02000000UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x02000000UL & action->add) == 0ul))
        {
          if(!(action->string[12l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)12]);
            action->string[(signed long int)12] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x02000000UL;
        action->mask = action->mask | 0x02000000UL;
      }

  static char *actions_from_radio__1__117__js_name_arr;
  static signed int actions_from_radio__1__117__first_time = 1;
  if(!(actions_from_radio__1__117__first_time == 0))
  {
    actions_from_radio__1__117__js_name_arr=strdup("prevent-compression");
    javascriptify(actions_from_radio__1__117__js_name_arr);
  }

  js_name = actions_from_radio__1__117__js_name_arr;
  actions_from_radio__1__117__first_time = 0;
  ch=get_char_param(parameters, js_name);
  if((signed int)ch == 89)
  {
    action->add = action->add | 0x00000400UL;
    action->mask = action->mask | 0x00000400UL;
  }

  else
    if((signed int)ch == 78)
    {
      action->add = action->add & ~0x00000400UL;
      action->mask = action->mask & ~0x00000400UL;
    }

    else
      if((signed int)ch == 88)
      {
        action->add = action->add & ~0x00000400UL;
        action->mask = action->mask | 0x00000400UL;
      }

  static char *actions_from_radio__1__121__js_name_arr;
  static signed int actions_from_radio__1__121__first_time = 1;
  if(!(actions_from_radio__1__121__first_time == 0))
  {
    actions_from_radio__1__121__js_name_arr=strdup("redirect");
    javascriptify(actions_from_radio__1__121__js_name_arr);
  }

  js_name = actions_from_radio__1__121__js_name_arr;
  actions_from_radio__1__121__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_36;
  signed int return_value_strcmp_35;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__122__1__js_name_arr;
    static signed int actions_from_radio__1__122__1__first_time = 1;
    if(!(actions_from_radio__1__122__1__first_time == 0))
    {
      actions_from_radio__1__122__1__js_name_arr=strdup("redirect-mode");
      javascriptify(actions_from_radio__1__122__1__js_name_arr);
    }

    js_name = actions_from_radio__1__122__1__js_name_arr;
    actions_from_radio__1__122__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_36 = (_Bool)1;

    else
    {
      return_value_strcmp_35=strcmp(param, "CUSTOM");
      tmp_if_expr_36 = 0 == return_value_strcmp_35 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_36)
    {
      static char *actions_from_radio__1__122__2__1__js_name_arr;
      static signed int actions_from_radio__1__122__2__1__first_time = 1;
      if(!(actions_from_radio__1__122__2__1__first_time == 0))
      {
        actions_from_radio__1__122__2__1__js_name_arr=strdup("redirect-param");
        javascriptify(actions_from_radio__1__122__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__122__2__1__js_name_arr;
      actions_from_radio__1__122__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[13l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)13]);
        action->string[(signed long int)13] = (char *)(void *)0;
      }

      action->add = action->add | 0x00020000UL;
      action->mask = action->mask | 0x00020000UL;
      action->string[(signed long int)13] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x00020000UL & action->add) == 0ul))
      {
        if(!(action->string[13l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)13]);
          action->string[(signed long int)13] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x00020000UL;
      action->mask = action->mask & ~0x00020000UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x00020000UL & action->add) == 0ul))
        {
          if(!(action->string[13l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)13]);
            action->string[(signed long int)13] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x00020000UL;
        action->mask = action->mask | 0x00020000UL;
      }

  static char *actions_from_radio__1__125__js_name_arr;
  static signed int actions_from_radio__1__125__first_time = 1;
  if(!(actions_from_radio__1__125__first_time == 0))
  {
    actions_from_radio__1__125__js_name_arr=strdup("server-header-filter");
    javascriptify(actions_from_radio__1__125__js_name_arr);
  }

  js_name = actions_from_radio__1__125__js_name_arr;
  actions_from_radio__1__125__first_time = 0;
  ch=get_char_param(parameters, js_name);
  if(!((signed int)ch == 89))
  {
    if((signed int)ch == 78)
    {
      list_remove_all(action->multi_add[(signed long int)2]);
      list_remove_all(action->multi_remove[(signed long int)2]);
      action->multi_remove_all[(signed long int)2] = 1;
    }

    else
      if((signed int)ch == 88)
      {
        list_remove_all(action->multi_add[(signed long int)2]);
        list_remove_all(action->multi_remove[(signed long int)2]);
        action->multi_remove_all[(signed long int)2] = 0;
      }

  }

  static char *actions_from_radio__1__129__js_name_arr;
  static signed int actions_from_radio__1__129__first_time = 1;
  if(!(actions_from_radio__1__129__first_time == 0))
  {
    actions_from_radio__1__129__js_name_arr=strdup("server-header-tagger");
    javascriptify(actions_from_radio__1__129__js_name_arr);
  }

  js_name = actions_from_radio__1__129__js_name_arr;
  actions_from_radio__1__129__first_time = 0;
  ch=get_char_param(parameters, js_name);
  if(!((signed int)ch == 89))
  {
    if((signed int)ch == 78)
    {
      list_remove_all(action->multi_add[(signed long int)5]);
      list_remove_all(action->multi_remove[(signed long int)5]);
      action->multi_remove_all[(signed long int)5] = 1;
    }

    else
      if((signed int)ch == 88)
      {
        list_remove_all(action->multi_add[(signed long int)5]);
        list_remove_all(action->multi_remove[(signed long int)5]);
        action->multi_remove_all[(signed long int)5] = 0;
      }

  }

  static char *actions_from_radio__1__133__js_name_arr;
  static signed int actions_from_radio__1__133__first_time = 1;
  if(!(actions_from_radio__1__133__first_time == 0))
  {
    actions_from_radio__1__133__js_name_arr=strdup("session-cookies-only");
    javascriptify(actions_from_radio__1__133__js_name_arr);
  }

  js_name = actions_from_radio__1__133__js_name_arr;
  actions_from_radio__1__133__first_time = 0;
  ch=get_char_param(parameters, js_name);
  if((signed int)ch == 89)
  {
    action->add = action->add | 0x00000800UL;
    action->mask = action->mask | 0x00000800UL;
  }

  else
    if((signed int)ch == 78)
    {
      action->add = action->add & ~0x00000800UL;
      action->mask = action->mask & ~0x00000800UL;
    }

    else
      if((signed int)ch == 88)
      {
        action->add = action->add & ~0x00000800UL;
        action->mask = action->mask | 0x00000800UL;
      }

  static char *actions_from_radio__1__137__js_name_arr;
  static signed int actions_from_radio__1__137__first_time = 1;
  if(!(actions_from_radio__1__137__first_time == 0))
  {
    actions_from_radio__1__137__js_name_arr=strdup("set-image-blocker");
    javascriptify(actions_from_radio__1__137__js_name_arr);
  }

  js_name = actions_from_radio__1__137__js_name_arr;
  actions_from_radio__1__137__first_time = 0;
  ch=get_char_param(parameters, js_name);
  _Bool tmp_if_expr_38;
  signed int return_value_strcmp_37;
  if((signed int)ch == 89)
  {
    param = (const char *)(void *)0;
    static char *actions_from_radio__1__138__1__js_name_arr;
    static signed int actions_from_radio__1__138__1__first_time = 1;
    if(!(actions_from_radio__1__138__1__first_time == 0))
    {
      actions_from_radio__1__138__1__js_name_arr=strdup("set-image-blocker-mode");
      javascriptify(actions_from_radio__1__138__1__js_name_arr);
    }

    js_name = actions_from_radio__1__138__1__js_name_arr;
    actions_from_radio__1__138__1__first_time = 0;
    if(err == /*enum*/JB_ERR_OK)
      err=get_string_param(parameters, js_name, &param);

    if(param == ((const char *)NULL))
      tmp_if_expr_38 = (_Bool)1;

    else
    {
      return_value_strcmp_37=strcmp(param, "CUSTOM");
      tmp_if_expr_38 = 0 == return_value_strcmp_37 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_38)
    {
      static char *actions_from_radio__1__138__2__1__js_name_arr;
      static signed int actions_from_radio__1__138__2__1__first_time = 1;
      if(!(actions_from_radio__1__138__2__1__first_time == 0))
      {
        actions_from_radio__1__138__2__1__js_name_arr=strdup("set-image-blocker-param");
        javascriptify(actions_from_radio__1__138__2__1__js_name_arr);
      }

      js_name = actions_from_radio__1__138__2__1__js_name_arr;
      actions_from_radio__1__138__2__1__first_time = 0;
      if(err == /*enum*/JB_ERR_OK)
        err=get_string_param(parameters, js_name, &param);

    }

    if(!(param == ((const char *)NULL)))
    {
      param_dup=strdup(param);
      if(param_dup == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      if(!(action->string[2l] == ((char *)NULL)))
      {
        free((void *)action->string[(signed long int)2]);
        action->string[(signed long int)2] = (char *)(void *)0;
      }

      action->add = action->add | 0x00000200UL;
      action->mask = action->mask | 0x00000200UL;
      action->string[(signed long int)2] = param_dup;
    }

  }

  else
    if((signed int)ch == 78)
    {
      if(!((0x00000200UL & action->add) == 0ul))
      {
        if(!(action->string[2l] == ((char *)NULL)))
        {
          free((void *)action->string[(signed long int)2]);
          action->string[(signed long int)2] = (char *)(void *)0;
        }

      }

      action->add = action->add & ~0x00000200UL;
      action->mask = action->mask & ~0x00000200UL;
    }

    else
      if((signed int)ch == 88)
      {
        if(!((0x00000200UL & action->add) == 0ul))
        {
          if(!(action->string[2l] == ((char *)NULL)))
          {
            free((void *)action->string[(signed long int)2]);
            action->string[(signed long int)2] = (char *)(void *)0;
          }

        }

        action->add = action->add & ~0x00000200UL;
        action->mask = action->mask | 0x00000200UL;
      }

  return err;
}

// actions_to_html
// file actions.c line 1722
extern char * actions_to_html(struct client_state *csp, struct action_spec *action)
{
  unsigned long int mask = action->mask;
  unsigned long int add = action->add;
  char *result;
  result=strdup_or_die("");
  struct list_entry *lst;
  mask = mask | add;
  if(!(action->multi_remove_all[0l] == 0))
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_1;
    return_value_add_help_link_1=add_help_link("add-header", csp->config);
    string_join(&result, return_value_add_help_link_1);
  }

  else
  {
    lst = action->multi_remove[(signed long int)0][0l].first;
    while(!(lst == ((struct list_entry *)NULL)))
    {
      string_append(&result, "\n<br>-");
      char *return_value_add_help_link_2;
      return_value_add_help_link_2=add_help_link("add-header", csp->config);
      string_join(&result, return_value_add_help_link_2);
      string_append(&result, "{");
      char *return_value_html_encode_3;
      return_value_html_encode_3=html_encode(lst->str);
      string_join(&result, return_value_html_encode_3);
      string_append(&result, "}");
      lst = lst->next;
    }
  }
  lst = action->multi_add[(signed long int)0][0l].first;
  while(!(lst == ((struct list_entry *)NULL)))
  {
    string_append(&result, "\n<br>+");
    char *return_value_add_help_link_4;
    return_value_add_help_link_4=add_help_link("add-header", csp->config);
    string_join(&result, return_value_add_help_link_4);
    string_append(&result, "{");
    char *return_value_html_encode_5;
    return_value_html_encode_5=html_encode(lst->str);
    string_join(&result, return_value_html_encode_5);
    string_append(&result, "}");
    lst = lst->next;
  }
  if((0x00000001UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_6;
    return_value_add_help_link_6=add_help_link("block", csp->config);
    string_join(&result, return_value_add_help_link_6);
  }

  else
    if(!((0x00000001UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_7;
      return_value_add_help_link_7=add_help_link("block", csp->config);
      string_join(&result, return_value_add_help_link_7);
      string_append(&result, "{");
      char *return_value_html_encode_8;
      return_value_html_encode_8=html_encode(action->string[(signed long int)16]);
      string_join(&result, return_value_html_encode_8);
      string_append(&result, "}");
    }

  if((0x00000010UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_9;
    return_value_add_help_link_9=add_help_link("change-x-forwarded-for", csp->config);
    string_join(&result, return_value_add_help_link_9);
  }

  else
    if(!((0x00000010UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_10;
      return_value_add_help_link_10=add_help_link("change-x-forwarded-for", csp->config);
      string_join(&result, return_value_add_help_link_10);
      string_append(&result, "{");
      char *return_value_html_encode_11;
      return_value_html_encode_11=html_encode(action->string[(signed long int)17]);
      string_join(&result, return_value_html_encode_11);
      string_append(&result, "}");
    }

  if(!(action->multi_remove_all[3l] == 0))
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_12;
    return_value_add_help_link_12=add_help_link("client-header-filter", csp->config);
    string_join(&result, return_value_add_help_link_12);
  }

  else
  {
    lst = action->multi_remove[(signed long int)3][0l].first;
    while(!(lst == ((struct list_entry *)NULL)))
    {
      string_append(&result, "\n<br>-");
      char *return_value_add_help_link_13;
      return_value_add_help_link_13=add_help_link("client-header-filter", csp->config);
      string_join(&result, return_value_add_help_link_13);
      string_append(&result, "{");
      char *return_value_html_encode_14;
      return_value_html_encode_14=html_encode(lst->str);
      string_join(&result, return_value_html_encode_14);
      string_append(&result, "}");
      lst = lst->next;
    }
  }
  lst = action->multi_add[(signed long int)3][0l].first;
  while(!(lst == ((struct list_entry *)NULL)))
  {
    string_append(&result, "\n<br>+");
    char *return_value_add_help_link_15;
    return_value_add_help_link_15=add_help_link("client-header-filter", csp->config);
    string_join(&result, return_value_add_help_link_15);
    string_append(&result, "{");
    char *return_value_html_encode_16;
    return_value_html_encode_16=html_encode(lst->str);
    string_join(&result, return_value_html_encode_16);
    string_append(&result, "}");
    lst = lst->next;
  }
  if(!(action->multi_remove_all[4l] == 0))
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_17;
    return_value_add_help_link_17=add_help_link("client-header-tagger", csp->config);
    string_join(&result, return_value_add_help_link_17);
  }

  else
  {
    lst = action->multi_remove[(signed long int)4][0l].first;
    while(!(lst == ((struct list_entry *)NULL)))
    {
      string_append(&result, "\n<br>-");
      char *return_value_add_help_link_18;
      return_value_add_help_link_18=add_help_link("client-header-tagger", csp->config);
      string_join(&result, return_value_add_help_link_18);
      string_append(&result, "{");
      char *return_value_html_encode_19;
      return_value_html_encode_19=html_encode(lst->str);
      string_join(&result, return_value_html_encode_19);
      string_append(&result, "}");
      lst = lst->next;
    }
  }
  lst = action->multi_add[(signed long int)4][0l].first;
  while(!(lst == ((struct list_entry *)NULL)))
  {
    string_append(&result, "\n<br>+");
    char *return_value_add_help_link_20;
    return_value_add_help_link_20=add_help_link("client-header-tagger", csp->config);
    string_join(&result, return_value_add_help_link_20);
    string_append(&result, "{");
    char *return_value_html_encode_21;
    return_value_html_encode_21=html_encode(lst->str);
    string_join(&result, return_value_html_encode_21);
    string_append(&result, "}");
    lst = lst->next;
  }
  if((0x00080000UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_22;
    return_value_add_help_link_22=add_help_link("content-type-overwrite", csp->config);
    string_join(&result, return_value_add_help_link_22);
  }

  else
    if(!((0x00080000UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_23;
      return_value_add_help_link_23=add_help_link("content-type-overwrite", csp->config);
      string_join(&result, return_value_add_help_link_23);
      string_append(&result, "{");
      char *return_value_html_encode_24;
      return_value_html_encode_24=html_encode(action->string[(signed long int)9]);
      string_join(&result, return_value_html_encode_24);
      string_append(&result, "}");
    }

  if((0x00200000UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_25;
    return_value_add_help_link_25=add_help_link("crunch-client-header", csp->config);
    string_join(&result, return_value_add_help_link_25);
  }

  else
    if(!((0x00200000UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_26;
      return_value_add_help_link_26=add_help_link("crunch-client-header", csp->config);
      string_join(&result, return_value_add_help_link_26);
      string_append(&result, "{");
      char *return_value_html_encode_27;
      return_value_html_encode_27=html_encode(action->string[(signed long int)7]);
      string_join(&result, return_value_html_encode_27);
      string_append(&result, "}");
    }

  if((0x00800000UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_28;
    return_value_add_help_link_28=add_help_link("crunch-if-none-match", csp->config);
    string_join(&result, return_value_add_help_link_28);
  }

  else
    if(!((0x00800000UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_29;
      return_value_add_help_link_29=add_help_link("crunch-if-none-match", csp->config);
      string_join(&result, return_value_add_help_link_29);
    }

  if((0x00002000UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_30;
    return_value_add_help_link_30=add_help_link("crunch-incoming-cookies", csp->config);
    string_join(&result, return_value_add_help_link_30);
  }

  else
    if(!((0x00002000UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_31;
      return_value_add_help_link_31=add_help_link("crunch-incoming-cookies", csp->config);
      string_join(&result, return_value_add_help_link_31);
    }

  if((0x00001000UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_32;
    return_value_add_help_link_32=add_help_link("crunch-outgoing-cookies", csp->config);
    string_join(&result, return_value_add_help_link_32);
  }

  else
    if(!((0x00001000UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_33;
      return_value_add_help_link_33=add_help_link("crunch-outgoing-cookies", csp->config);
      string_join(&result, return_value_add_help_link_33);
    }

  if((0x00100000UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_34;
    return_value_add_help_link_34=add_help_link("crunch-server-header", csp->config);
    string_join(&result, return_value_add_help_link_34);
  }

  else
    if(!((0x00100000UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_35;
      return_value_add_help_link_35=add_help_link("crunch-server-header", csp->config);
      string_join(&result, return_value_add_help_link_35);
      string_append(&result, "{");
      char *return_value_html_encode_36;
      return_value_html_encode_36=html_encode(action->string[(signed long int)6]);
      string_join(&result, return_value_html_encode_36);
      string_append(&result, "}");
    }

  if((0x00000002UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_37;
    return_value_add_help_link_37=add_help_link("deanimate-gifs", csp->config);
    string_join(&result, return_value_add_help_link_37);
  }

  else
    if(!((0x00000002UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_38;
      return_value_add_help_link_38=add_help_link("deanimate-gifs", csp->config);
      string_join(&result, return_value_add_help_link_38);
      string_append(&result, "{");
      char *return_value_html_encode_39;
      return_value_html_encode_39=html_encode(action->string[(signed long int)0]);
      string_join(&result, return_value_html_encode_39);
      string_append(&result, "}");
    }

  if((0x00000004UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_40;
    return_value_add_help_link_40=add_help_link("downgrade-http-version", csp->config);
    string_join(&result, return_value_add_help_link_40);
  }

  else
    if(!((0x00000004UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_41;
      return_value_add_help_link_41=add_help_link("downgrade-http-version", csp->config);
      string_join(&result, return_value_add_help_link_41);
    }

  if(!(action->multi_remove_all[6l] == 0))
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_42;
    return_value_add_help_link_42=add_help_link("external-filter", csp->config);
    string_join(&result, return_value_add_help_link_42);
  }

  else
  {
    lst = action->multi_remove[(signed long int)6][0l].first;
    while(!(lst == ((struct list_entry *)NULL)))
    {
      string_append(&result, "\n<br>-");
      char *return_value_add_help_link_43;
      return_value_add_help_link_43=add_help_link("external-filter", csp->config);
      string_join(&result, return_value_add_help_link_43);
      string_append(&result, "{");
      char *return_value_html_encode_44;
      return_value_html_encode_44=html_encode(lst->str);
      string_join(&result, return_value_html_encode_44);
      string_append(&result, "}");
      lst = lst->next;
    }
  }
  lst = action->multi_add[(signed long int)6][0l].first;
  while(!(lst == ((struct list_entry *)NULL)))
  {
    string_append(&result, "\n<br>+");
    char *return_value_add_help_link_45;
    return_value_add_help_link_45=add_help_link("external-filter", csp->config);
    string_join(&result, return_value_add_help_link_45);
    string_append(&result, "{");
    char *return_value_html_encode_46;
    return_value_html_encode_46=html_encode(lst->str);
    string_join(&result, return_value_html_encode_46);
    string_append(&result, "}");
    lst = lst->next;
  }
  if((0x00000008UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_47;
    return_value_add_help_link_47=add_help_link("fast-redirects", csp->config);
    string_join(&result, return_value_add_help_link_47);
  }

  else
    if(!((0x00000008UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_48;
      return_value_add_help_link_48=add_help_link("fast-redirects", csp->config);
      string_join(&result, return_value_add_help_link_48);
      string_append(&result, "{");
      char *return_value_html_encode_49;
      return_value_html_encode_49=html_encode(action->string[(signed long int)14]);
      string_join(&result, return_value_html_encode_49);
      string_append(&result, "}");
    }

  if(!(action->multi_remove_all[1l] == 0))
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_50;
    return_value_add_help_link_50=add_help_link("filter", csp->config);
    string_join(&result, return_value_add_help_link_50);
  }

  else
  {
    lst = action->multi_remove[(signed long int)1][0l].first;
    while(!(lst == ((struct list_entry *)NULL)))
    {
      string_append(&result, "\n<br>-");
      char *return_value_add_help_link_51;
      return_value_add_help_link_51=add_help_link("filter", csp->config);
      string_join(&result, return_value_add_help_link_51);
      string_append(&result, "{");
      char *return_value_html_encode_52;
      return_value_html_encode_52=html_encode(lst->str);
      string_join(&result, return_value_html_encode_52);
      string_append(&result, "}");
      lst = lst->next;
    }
  }
  lst = action->multi_add[(signed long int)1][0l].first;
  while(!(lst == ((struct list_entry *)NULL)))
  {
    string_append(&result, "\n<br>+");
    char *return_value_add_help_link_53;
    return_value_add_help_link_53=add_help_link("filter", csp->config);
    string_join(&result, return_value_add_help_link_53);
    string_append(&result, "{");
    char *return_value_html_encode_54;
    return_value_html_encode_54=html_encode(lst->str);
    string_join(&result, return_value_html_encode_54);
    string_append(&result, "}");
    lst = lst->next;
  }
  if((0x00400000UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_55;
    return_value_add_help_link_55=add_help_link("force-text-mode", csp->config);
    string_join(&result, return_value_add_help_link_55);
  }

  else
    if(!((0x00400000UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_56;
      return_value_add_help_link_56=add_help_link("force-text-mode", csp->config);
      string_join(&result, return_value_add_help_link_56);
    }

  if((0x00004000UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_57;
    return_value_add_help_link_57=add_help_link("forward-override", csp->config);
    string_join(&result, return_value_add_help_link_57);
  }

  else
    if(!((0x00004000UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_58;
      return_value_add_help_link_58=add_help_link("forward-override", csp->config);
      string_join(&result, return_value_add_help_link_58);
      string_append(&result, "{");
      char *return_value_html_encode_59;
      return_value_html_encode_59=html_encode(action->string[(signed long int)15]);
      string_join(&result, return_value_html_encode_59);
      string_append(&result, "}");
    }

  if((0x00008000UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_60;
    return_value_add_help_link_60=add_help_link("handle-as-empty-document", csp->config);
    string_join(&result, return_value_add_help_link_60);
  }

  else
    if(!((0x00008000UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_61;
      return_value_add_help_link_61=add_help_link("handle-as-empty-document", csp->config);
      string_join(&result, return_value_add_help_link_61);
    }

  if((0x00000100UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_62;
    return_value_add_help_link_62=add_help_link("handle-as-image", csp->config);
    string_join(&result, return_value_add_help_link_62);
  }

  else
    if(!((0x00000100UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_63;
      return_value_add_help_link_63=add_help_link("handle-as-image", csp->config);
      string_join(&result, return_value_add_help_link_63);
    }

  if((0x04000000UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_64;
    return_value_add_help_link_64=add_help_link("hide-accept-language", csp->config);
    string_join(&result, return_value_add_help_link_64);
  }

  else
    if(!((0x04000000UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_65;
      return_value_add_help_link_65=add_help_link("hide-accept-language", csp->config);
      string_join(&result, return_value_add_help_link_65);
      string_append(&result, "{");
      char *return_value_html_encode_66;
      return_value_html_encode_66=html_encode(action->string[(signed long int)8]);
      string_join(&result, return_value_html_encode_66);
      string_append(&result, "}");
    }

  if((0x01000000UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_67;
    return_value_add_help_link_67=add_help_link("hide-content-disposition", csp->config);
    string_join(&result, return_value_add_help_link_67);
  }

  else
    if(!((0x01000000UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_68;
      return_value_add_help_link_68=add_help_link("hide-content-disposition", csp->config);
      string_join(&result, return_value_add_help_link_68);
      string_append(&result, "{");
      char *return_value_html_encode_69;
      return_value_html_encode_69=html_encode(action->string[(signed long int)10]);
      string_join(&result, return_value_html_encode_69);
      string_append(&result, "}");
    }

  if((0x00000020UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_70;
    return_value_add_help_link_70=add_help_link("hide-from-header", csp->config);
    string_join(&result, return_value_add_help_link_70);
  }

  else
    if(!((0x00000020UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_71;
      return_value_add_help_link_71=add_help_link("hide-from-header", csp->config);
      string_join(&result, return_value_add_help_link_71);
      string_append(&result, "{");
      char *return_value_html_encode_72;
      return_value_html_encode_72=html_encode(action->string[(signed long int)1]);
      string_join(&result, return_value_html_encode_72);
      string_append(&result, "}");
    }

  if((0x00040000UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_73;
    return_value_add_help_link_73=add_help_link("hide-if-modified-since", csp->config);
    string_join(&result, return_value_add_help_link_73);
  }

  else
    if(!((0x00040000UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_74;
      return_value_add_help_link_74=add_help_link("hide-if-modified-since", csp->config);
      string_join(&result, return_value_add_help_link_74);
      string_append(&result, "{");
      char *return_value_html_encode_75;
      return_value_html_encode_75=html_encode(action->string[(signed long int)11]);
      string_join(&result, return_value_html_encode_75);
      string_append(&result, "}");
    }

  if((0x00000040UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_76;
    return_value_add_help_link_76=add_help_link("hide-referrer", csp->config);
    string_join(&result, return_value_add_help_link_76);
  }

  else
    if(!((0x00000040UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_77;
      return_value_add_help_link_77=add_help_link("hide-referrer", csp->config);
      string_join(&result, return_value_add_help_link_77);
      string_append(&result, "{");
      char *return_value_html_encode_78;
      return_value_html_encode_78=html_encode(action->string[(signed long int)3]);
      string_join(&result, return_value_html_encode_78);
      string_append(&result, "}");
    }

  if((0x00000080UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_79;
    return_value_add_help_link_79=add_help_link("hide-user-agent", csp->config);
    string_join(&result, return_value_add_help_link_79);
  }

  else
    if(!((0x00000080UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_80;
      return_value_add_help_link_80=add_help_link("hide-user-agent", csp->config);
      string_join(&result, return_value_add_help_link_80);
      string_append(&result, "{");
      char *return_value_html_encode_81;
      return_value_html_encode_81=html_encode(action->string[(signed long int)4]);
      string_join(&result, return_value_html_encode_81);
      string_append(&result, "}");
    }

  if((0x00010000UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_82;
    return_value_add_help_link_82=add_help_link("limit-connect", csp->config);
    string_join(&result, return_value_add_help_link_82);
  }

  else
    if(!((0x00010000UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_83;
      return_value_add_help_link_83=add_help_link("limit-connect", csp->config);
      string_join(&result, return_value_add_help_link_83);
      string_append(&result, "{");
      char *return_value_html_encode_84;
      return_value_html_encode_84=html_encode(action->string[(signed long int)5]);
      string_join(&result, return_value_html_encode_84);
      string_append(&result, "}");
    }

  if((0x08000000UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_85;
    return_value_add_help_link_85=add_help_link("limit-cookie-lifetime", csp->config);
    string_join(&result, return_value_add_help_link_85);
  }

  else
    if(!((0x08000000UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_86;
      return_value_add_help_link_86=add_help_link("limit-cookie-lifetime", csp->config);
      string_join(&result, return_value_add_help_link_86);
      string_append(&result, "{");
      char *return_value_html_encode_87;
      return_value_html_encode_87=html_encode(action->string[(signed long int)18]);
      string_join(&result, return_value_html_encode_87);
      string_append(&result, "}");
    }

  if((0x02000000UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_88;
    return_value_add_help_link_88=add_help_link("overwrite-last-modified", csp->config);
    string_join(&result, return_value_add_help_link_88);
  }

  else
    if(!((0x02000000UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_89;
      return_value_add_help_link_89=add_help_link("overwrite-last-modified", csp->config);
      string_join(&result, return_value_add_help_link_89);
      string_append(&result, "{");
      char *return_value_html_encode_90;
      return_value_html_encode_90=html_encode(action->string[(signed long int)12]);
      string_join(&result, return_value_html_encode_90);
      string_append(&result, "}");
    }

  if((0x00000400UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_91;
    return_value_add_help_link_91=add_help_link("prevent-compression", csp->config);
    string_join(&result, return_value_add_help_link_91);
  }

  else
    if(!((0x00000400UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_92;
      return_value_add_help_link_92=add_help_link("prevent-compression", csp->config);
      string_join(&result, return_value_add_help_link_92);
    }

  if((0x00020000UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_93;
    return_value_add_help_link_93=add_help_link("redirect", csp->config);
    string_join(&result, return_value_add_help_link_93);
  }

  else
    if(!((0x00020000UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_94;
      return_value_add_help_link_94=add_help_link("redirect", csp->config);
      string_join(&result, return_value_add_help_link_94);
      string_append(&result, "{");
      char *return_value_html_encode_95;
      return_value_html_encode_95=html_encode(action->string[(signed long int)13]);
      string_join(&result, return_value_html_encode_95);
      string_append(&result, "}");
    }

  if(!(action->multi_remove_all[2l] == 0))
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_96;
    return_value_add_help_link_96=add_help_link("server-header-filter", csp->config);
    string_join(&result, return_value_add_help_link_96);
  }

  else
  {
    lst = action->multi_remove[(signed long int)2][0l].first;
    while(!(lst == ((struct list_entry *)NULL)))
    {
      string_append(&result, "\n<br>-");
      char *return_value_add_help_link_97;
      return_value_add_help_link_97=add_help_link("server-header-filter", csp->config);
      string_join(&result, return_value_add_help_link_97);
      string_append(&result, "{");
      char *return_value_html_encode_98;
      return_value_html_encode_98=html_encode(lst->str);
      string_join(&result, return_value_html_encode_98);
      string_append(&result, "}");
      lst = lst->next;
    }
  }
  lst = action->multi_add[(signed long int)2][0l].first;
  while(!(lst == ((struct list_entry *)NULL)))
  {
    string_append(&result, "\n<br>+");
    char *return_value_add_help_link_99;
    return_value_add_help_link_99=add_help_link("server-header-filter", csp->config);
    string_join(&result, return_value_add_help_link_99);
    string_append(&result, "{");
    char *return_value_html_encode_100;
    return_value_html_encode_100=html_encode(lst->str);
    string_join(&result, return_value_html_encode_100);
    string_append(&result, "}");
    lst = lst->next;
  }
  if(!(action->multi_remove_all[5l] == 0))
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_101;
    return_value_add_help_link_101=add_help_link("server-header-tagger", csp->config);
    string_join(&result, return_value_add_help_link_101);
  }

  else
  {
    lst = action->multi_remove[(signed long int)5][0l].first;
    while(!(lst == ((struct list_entry *)NULL)))
    {
      string_append(&result, "\n<br>-");
      char *return_value_add_help_link_102;
      return_value_add_help_link_102=add_help_link("server-header-tagger", csp->config);
      string_join(&result, return_value_add_help_link_102);
      string_append(&result, "{");
      char *return_value_html_encode_103;
      return_value_html_encode_103=html_encode(lst->str);
      string_join(&result, return_value_html_encode_103);
      string_append(&result, "}");
      lst = lst->next;
    }
  }
  lst = action->multi_add[(signed long int)5][0l].first;
  while(!(lst == ((struct list_entry *)NULL)))
  {
    string_append(&result, "\n<br>+");
    char *return_value_add_help_link_104;
    return_value_add_help_link_104=add_help_link("server-header-tagger", csp->config);
    string_join(&result, return_value_add_help_link_104);
    string_append(&result, "{");
    char *return_value_html_encode_105;
    return_value_html_encode_105=html_encode(lst->str);
    string_join(&result, return_value_html_encode_105);
    string_append(&result, "}");
    lst = lst->next;
  }
  if((0x00000800UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_106;
    return_value_add_help_link_106=add_help_link("session-cookies-only", csp->config);
    string_join(&result, return_value_add_help_link_106);
  }

  else
    if(!((0x00000800UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_107;
      return_value_add_help_link_107=add_help_link("session-cookies-only", csp->config);
      string_join(&result, return_value_add_help_link_107);
    }

  if((0x00000200UL & mask) == 0ul)
  {
    string_append(&result, "\n<br>-");
    char *return_value_add_help_link_108;
    return_value_add_help_link_108=add_help_link("set-image-blocker", csp->config);
    string_join(&result, return_value_add_help_link_108);
  }

  else
    if(!((0x00000200UL & add) == 0ul))
    {
      string_append(&result, "\n<br>+");
      char *return_value_add_help_link_109;
      return_value_add_help_link_109=add_help_link("set-image-blocker", csp->config);
      string_join(&result, return_value_add_help_link_109);
      string_append(&result, "{");
      char *return_value_html_encode_110;
      return_value_html_encode_110=html_encode(action->string[(signed long int)2]);
      string_join(&result, return_value_html_encode_110);
      string_append(&result, "}");
    }

  if(!(result == ((char *)NULL)))
  {
    if(!(*result == 0))
    {
      char *s = result;
      result=strdup(result + (signed long int)5);
      free((void *)s);
    }

  }

  return result;
}

// actions_to_line_of_text
// file actions.c line 1922
extern char * actions_to_line_of_text(struct current_action_spec *action)
{
  char buffer[200l];
  struct list_entry *lst;
  char *active;
  const unsigned long int flags = action->flags;
  active=strdup_or_die("");
  lst = action->multi[(signed long int)0][0l].first;
  for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"add-header", lst->str);
    string_append(&active, buffer);
  }
  if(!((0x00000001UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"block", action->string[(signed long int)16]);
    string_append(&active, buffer);
  }

  if(!((0x00000010UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"change-x-forwarded-for", action->string[(signed long int)17]);
    string_append(&active, buffer);
  }

  lst = action->multi[(signed long int)3][0l].first;
  for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"client-header-filter", lst->str);
    string_append(&active, buffer);
  }
  lst = action->multi[(signed long int)4][0l].first;
  for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"client-header-tagger", lst->str);
    string_append(&active, buffer);
  }
  if(!((0x00080000UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"content-type-overwrite", action->string[(signed long int)9]);
    string_append(&active, buffer);
  }

  if(!((0x00200000UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"crunch-client-header", action->string[(signed long int)7]);
    string_append(&active, buffer);
  }

  if(!((0x00800000UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s ", (const void *)"crunch-if-none-match");
    string_append(&active, buffer);
  }

  if(!((0x00002000UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s ", (const void *)"crunch-incoming-cookies");
    string_append(&active, buffer);
  }

  if(!((0x00001000UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s ", (const void *)"crunch-outgoing-cookies");
    string_append(&active, buffer);
  }

  if(!((0x00100000UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"crunch-server-header", action->string[(signed long int)6]);
    string_append(&active, buffer);
  }

  if(!((0x00000002UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"deanimate-gifs", action->string[(signed long int)0]);
    string_append(&active, buffer);
  }

  if(!((0x00000004UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s ", (const void *)"downgrade-http-version");
    string_append(&active, buffer);
  }

  lst = action->multi[(signed long int)6][0l].first;
  for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"external-filter", lst->str);
    string_append(&active, buffer);
  }
  if(!((0x00000008UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"fast-redirects", action->string[(signed long int)14]);
    string_append(&active, buffer);
  }

  lst = action->multi[(signed long int)1][0l].first;
  for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"filter", lst->str);
    string_append(&active, buffer);
  }
  if(!((0x00400000UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s ", (const void *)"force-text-mode");
    string_append(&active, buffer);
  }

  if(!((0x00004000UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"forward-override", action->string[(signed long int)15]);
    string_append(&active, buffer);
  }

  if(!((0x00008000UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s ", (const void *)"handle-as-empty-document");
    string_append(&active, buffer);
  }

  if(!((0x00000100UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s ", (const void *)"handle-as-image");
    string_append(&active, buffer);
  }

  if(!((0x04000000UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"hide-accept-language", action->string[(signed long int)8]);
    string_append(&active, buffer);
  }

  if(!((0x01000000UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"hide-content-disposition", action->string[(signed long int)10]);
    string_append(&active, buffer);
  }

  if(!((0x00000020UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"hide-from-header", action->string[(signed long int)1]);
    string_append(&active, buffer);
  }

  if(!((0x00040000UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"hide-if-modified-since", action->string[(signed long int)11]);
    string_append(&active, buffer);
  }

  if(!((0x00000040UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"hide-referrer", action->string[(signed long int)3]);
    string_append(&active, buffer);
  }

  if(!((0x00000080UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"hide-user-agent", action->string[(signed long int)4]);
    string_append(&active, buffer);
  }

  if(!((0x00010000UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"limit-connect", action->string[(signed long int)5]);
    string_append(&active, buffer);
  }

  if(!((0x08000000UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"limit-cookie-lifetime", action->string[(signed long int)18]);
    string_append(&active, buffer);
  }

  if(!((0x02000000UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"overwrite-last-modified", action->string[(signed long int)12]);
    string_append(&active, buffer);
  }

  if(!((0x00000400UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s ", (const void *)"prevent-compression");
    string_append(&active, buffer);
  }

  if(!((0x00020000UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"redirect", action->string[(signed long int)13]);
    string_append(&active, buffer);
  }

  lst = action->multi[(signed long int)2][0l].first;
  for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"server-header-filter", lst->str);
    string_append(&active, buffer);
  }
  lst = action->multi[(signed long int)5][0l].first;
  for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"server-header-tagger", lst->str);
    string_append(&active, buffer);
  }
  if(!((0x00000800UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s ", (const void *)"session-cookies-only");
    string_append(&active, buffer);
  }

  if(!((0x00000200UL & flags) == 0ul))
  {
    snprintf(buffer, sizeof(char [200l]) /*200ul*/ , "+%s{%s} ", (const void *)"set-image-blocker", action->string[(signed long int)2]);
    string_append(&active, buffer);
  }

  if(active == ((char *)NULL))
    log_error(0x4000, "Out of memory in action_to_line_of_text()");

  return active;
}

// actions_to_radio
// file cgiedit.c line 4124
static enum privoxy_err actions_to_radio(struct map *exports, struct action_spec *action)
{
  unsigned long int mask;
  unsigned long int add;
  signed int mapped_param;
  signed int checked;
  char current_mode;
  /* assertion exports */
  assert(exports != ((struct map *)NULL));
  /* assertion action */
  assert(action != ((struct action_spec *)NULL));
  mask = action->mask;
  add = action->add;
  mask = mask | add;
  if(!(action->multi_add[0l][0l].first == ((struct list_entry *)NULL)))
    current_mode = (char)121;

  else
    if(!(action->multi_remove_all[0l] == 0))
      current_mode = (char)110;

    else
      if(!(action->multi_remove[0l][0l].first == ((struct list_entry *)NULL)))
        current_mode = (char)121;

      else
        current_mode = (char)120;
  enum privoxy_err return_value_map_radio_1;
  return_value_map_radio_1=map_radio(exports, "add-header", "ynx", (signed int)current_mode);
  char *tmp_if_expr_3;
  char *tmp_if_expr_13;
  char *tmp_if_expr_16;
  char *tmp_if_expr_22;
  char *tmp_if_expr_40;
  char *tmp_if_expr_48;
  char *tmp_if_expr_54;
  char *tmp_if_expr_60;
  char *tmp_if_expr_66;
  char *tmp_if_expr_78;
  char *tmp_if_expr_81;
  char *tmp_if_expr_84;
  char *tmp_if_expr_88;
  char *tmp_if_expr_99;
  char *tmp_if_expr_110;
  if(!(return_value_map_radio_1 == /*enum*/JB_ERR_OK))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    if((0x00000001UL & mask) == 0ul)
      current_mode = (char)110;

    else
      if(!((0x00000001UL & add) == 0ul))
        current_mode = (char)121;

      else
        current_mode = (char)120;
    enum privoxy_err return_value_map_radio_2;
    return_value_map_radio_2=map_radio(exports, "block", "ynx", (signed int)current_mode);
    if(!(return_value_map_radio_2 == /*enum*/JB_ERR_OK))
      return (enum privoxy_err)JB_ERR_MEMORY;

    else
    {
      mapped_param = 0;
      if(!((0x00000001UL & add) == 0ul))
        tmp_if_expr_3 = action->string[(signed long int)16];

      else
        tmp_if_expr_3 = "No reason specified.";
      enum privoxy_err return_value_map_4;
      return_value_map_4=map(exports, "block-param", 1, tmp_if_expr_3, 1);
      if(!(return_value_map_4 == /*enum*/JB_ERR_OK))
        return (enum privoxy_err)JB_ERR_MEMORY;

      else
      {
        if((0x00000010UL & mask) == 0ul)
          current_mode = (char)110;

        else
          if(!((0x00000010UL & add) == 0ul))
            current_mode = (char)121;

          else
            current_mode = (char)120;
        enum privoxy_err return_value_map_radio_5;
        return_value_map_radio_5=map_radio(exports, "change-x-forwarded-for", "ynx", (signed int)current_mode);
        if(!(return_value_map_radio_5 == /*enum*/JB_ERR_OK))
          return (enum privoxy_err)JB_ERR_MEMORY;

        else
        {
          mapped_param = 0;
          if(!((0x00000010UL & add) == 0ul))
          {
            signed int return_value_strcmp_6;
            return_value_strcmp_6=strcmp(action->string[(signed long int)17], "block");
            checked = (signed int)!(return_value_strcmp_6 != 0);
          }

          else
            checked = 0;
          mapped_param = mapped_param | checked;
          enum privoxy_err return_value_map_7;
          return_value_map_7=map(exports, "change-x-forwarded-for-param-block", 1, checked != 0 ? "checked" : "", 1);
          if(!(return_value_map_7 == /*enum*/JB_ERR_OK))
            return (enum privoxy_err)JB_ERR_MEMORY;

          else
          {
            if(!((0x00000010UL & add) == 0ul))
            {
              signed int return_value_strcmp_8;
              return_value_strcmp_8=strcmp(action->string[(signed long int)17], "add");
              checked = (signed int)!(return_value_strcmp_8 != 0);
            }

            else
              checked = 1;
            mapped_param = mapped_param | checked;
            enum privoxy_err return_value_map_9;
            return_value_map_9=map(exports, "change-x-forwarded-for-param-add", 1, checked != 0 ? "checked" : "", 1);
            if(!(return_value_map_9 == /*enum*/JB_ERR_OK))
              return (enum privoxy_err)JB_ERR_MEMORY;

            else
            {
              if(!(action->multi_add[3l][0l].first == ((struct list_entry *)NULL)))
                current_mode = (char)121;

              else
                if(!(action->multi_remove_all[3l] == 0))
                  current_mode = (char)110;

                else
                  if(!(action->multi_remove[3l][0l].first == ((struct list_entry *)NULL)))
                    current_mode = (char)121;

                  else
                    current_mode = (char)120;
              enum privoxy_err return_value_map_radio_10;
              return_value_map_radio_10=map_radio(exports, "client-header-filter", "ynx", (signed int)current_mode);
              if(!(return_value_map_radio_10 == /*enum*/JB_ERR_OK))
                return (enum privoxy_err)JB_ERR_MEMORY;

              else
              {
                if(!(action->multi_add[4l][0l].first == ((struct list_entry *)NULL)))
                  current_mode = (char)121;

                else
                  if(!(action->multi_remove_all[4l] == 0))
                    current_mode = (char)110;

                  else
                    if(!(action->multi_remove[4l][0l].first == ((struct list_entry *)NULL)))
                      current_mode = (char)121;

                    else
                      current_mode = (char)120;
                enum privoxy_err return_value_map_radio_11;
                return_value_map_radio_11=map_radio(exports, "client-header-tagger", "ynx", (signed int)current_mode);
                if(!(return_value_map_radio_11 == /*enum*/JB_ERR_OK))
                  return (enum privoxy_err)JB_ERR_MEMORY;

                else
                {
                  if((0x00080000UL & mask) == 0ul)
                    current_mode = (char)110;

                  else
                    if(!((0x00080000UL & add) == 0ul))
                      current_mode = (char)121;

                    else
                      current_mode = (char)120;
                  enum privoxy_err return_value_map_radio_12;
                  return_value_map_radio_12=map_radio(exports, "content-type-overwrite", "ynx", (signed int)current_mode);
                  if(!(return_value_map_radio_12 == /*enum*/JB_ERR_OK))
                    return (enum privoxy_err)JB_ERR_MEMORY;

                  else
                  {
                    mapped_param = 0;
                    if(!((0x00080000UL & add) == 0ul))
                      tmp_if_expr_13 = action->string[(signed long int)9];

                    else
                      tmp_if_expr_13 = "text/html";
                    enum privoxy_err return_value_map_14;
                    return_value_map_14=map(exports, "content-type-overwrite-param", 1, tmp_if_expr_13, 1);
                    if(!(return_value_map_14 == /*enum*/JB_ERR_OK))
                      return (enum privoxy_err)JB_ERR_MEMORY;

                    else
                    {
                      if((0x00200000UL & mask) == 0ul)
                        current_mode = (char)110;

                      else
                        if(!((0x00200000UL & add) == 0ul))
                          current_mode = (char)121;

                        else
                          current_mode = (char)120;
                      enum privoxy_err return_value_map_radio_15;
                      return_value_map_radio_15=map_radio(exports, "crunch-client-header", "ynx", (signed int)current_mode);
                      if(!(return_value_map_radio_15 == /*enum*/JB_ERR_OK))
                        return (enum privoxy_err)JB_ERR_MEMORY;

                      else
                      {
                        mapped_param = 0;
                        if(!((0x00200000UL & add) == 0ul))
                          tmp_if_expr_16 = action->string[(signed long int)7];

                        else
                          tmp_if_expr_16 = "X-Whatever:";
                        enum privoxy_err return_value_map_17;
                        return_value_map_17=map(exports, "crunch-client-header-param", 1, tmp_if_expr_16, 1);
                        if(!(return_value_map_17 == /*enum*/JB_ERR_OK))
                          return (enum privoxy_err)JB_ERR_MEMORY;

                        else
                        {
                          if((0x00800000UL & mask) == 0ul)
                            current_mode = (char)110;

                          else
                            if(!((0x00800000UL & add) == 0ul))
                              current_mode = (char)121;

                            else
                              current_mode = (char)120;
                          enum privoxy_err return_value_map_radio_18;
                          return_value_map_radio_18=map_radio(exports, "crunch-if-none-match", "ynx", (signed int)current_mode);
                          if(!(return_value_map_radio_18 == /*enum*/JB_ERR_OK))
                            return (enum privoxy_err)JB_ERR_MEMORY;

                          else
                          {
                            if((0x00002000UL & mask) == 0ul)
                              current_mode = (char)110;

                            else
                              if(!((0x00002000UL & add) == 0ul))
                                current_mode = (char)121;

                              else
                                current_mode = (char)120;
                            enum privoxy_err return_value_map_radio_19;
                            return_value_map_radio_19=map_radio(exports, "crunch-incoming-cookies", "ynx", (signed int)current_mode);
                            if(!(return_value_map_radio_19 == /*enum*/JB_ERR_OK))
                              return (enum privoxy_err)JB_ERR_MEMORY;

                            else
                            {
                              if((0x00001000UL & mask) == 0ul)
                                current_mode = (char)110;

                              else
                                if(!((0x00001000UL & add) == 0ul))
                                  current_mode = (char)121;

                                else
                                  current_mode = (char)120;
                              enum privoxy_err return_value_map_radio_20;
                              return_value_map_radio_20=map_radio(exports, "crunch-outgoing-cookies", "ynx", (signed int)current_mode);
                              if(!(return_value_map_radio_20 == /*enum*/JB_ERR_OK))
                                return (enum privoxy_err)JB_ERR_MEMORY;

                              else
                              {
                                if((0x00100000UL & mask) == 0ul)
                                  current_mode = (char)110;

                                else
                                  if(!((0x00100000UL & add) == 0ul))
                                    current_mode = (char)121;

                                  else
                                    current_mode = (char)120;
                                enum privoxy_err return_value_map_radio_21;
                                return_value_map_radio_21=map_radio(exports, "crunch-server-header", "ynx", (signed int)current_mode);
                                if(!(return_value_map_radio_21 == /*enum*/JB_ERR_OK))
                                  return (enum privoxy_err)JB_ERR_MEMORY;

                                else
                                {
                                  mapped_param = 0;
                                  if(!((0x00100000UL & add) == 0ul))
                                    tmp_if_expr_22 = action->string[(signed long int)6];

                                  else
                                    tmp_if_expr_22 = "X-Whatever:";
                                  enum privoxy_err return_value_map_23;
                                  return_value_map_23=map(exports, "crunch-server-header-param", 1, tmp_if_expr_22, 1);
                                  if(!(return_value_map_23 == /*enum*/JB_ERR_OK))
                                    return (enum privoxy_err)JB_ERR_MEMORY;

                                  else
                                  {
                                    if((0x00000002UL & mask) == 0ul)
                                      current_mode = (char)110;

                                    else
                                      if(!((0x00000002UL & add) == 0ul))
                                        current_mode = (char)121;

                                      else
                                        current_mode = (char)120;
                                    enum privoxy_err return_value_map_radio_24;
                                    return_value_map_radio_24=map_radio(exports, "deanimate-gifs", "ynx", (signed int)current_mode);
                                    if(!(return_value_map_radio_24 == /*enum*/JB_ERR_OK))
                                      return (enum privoxy_err)JB_ERR_MEMORY;

                                    else
                                    {
                                      mapped_param = 0;
                                      if(!((0x00000002UL & add) == 0ul))
                                      {
                                        signed int return_value_strcmp_25;
                                        return_value_strcmp_25=strcmp(action->string[(signed long int)0], "first");
                                        checked = (signed int)!(return_value_strcmp_25 != 0);
                                      }

                                      else
                                        checked = 0;
                                      mapped_param = mapped_param | checked;
                                      enum privoxy_err return_value_map_26;
                                      return_value_map_26=map(exports, "deanimate-gifs-param-first", 1, checked != 0 ? "checked" : "", 1);
                                      if(!(return_value_map_26 == /*enum*/JB_ERR_OK))
                                        return (enum privoxy_err)JB_ERR_MEMORY;

                                      else
                                      {
                                        if(!((0x00000002UL & add) == 0ul))
                                        {
                                          signed int return_value_strcmp_27;
                                          return_value_strcmp_27=strcmp(action->string[(signed long int)0], "last");
                                          checked = (signed int)!(return_value_strcmp_27 != 0);
                                        }

                                        else
                                          checked = 1;
                                        mapped_param = mapped_param | checked;
                                        enum privoxy_err return_value_map_28;
                                        return_value_map_28=map(exports, "deanimate-gifs-param-last", 1, checked != 0 ? "checked" : "", 1);
                                        if(!(return_value_map_28 == /*enum*/JB_ERR_OK))
                                          return (enum privoxy_err)JB_ERR_MEMORY;

                                        else
                                        {
                                          if((0x00000004UL & mask) == 0ul)
                                            current_mode = (char)110;

                                          else
                                            if(!((0x00000004UL & add) == 0ul))
                                              current_mode = (char)121;

                                            else
                                              current_mode = (char)120;
                                          enum privoxy_err return_value_map_radio_29;
                                          return_value_map_radio_29=map_radio(exports, "downgrade-http-version", "ynx", (signed int)current_mode);
                                          if(!(return_value_map_radio_29 == /*enum*/JB_ERR_OK))
                                            return (enum privoxy_err)JB_ERR_MEMORY;

                                          else
                                          {
                                            if(!(action->multi_add[6l][0l].first == ((struct list_entry *)NULL)))
                                              current_mode = (char)121;

                                            else
                                              if(!(action->multi_remove_all[6l] == 0))
                                                current_mode = (char)110;

                                              else
                                                if(!(action->multi_remove[6l][0l].first == ((struct list_entry *)NULL)))
                                                  current_mode = (char)121;

                                                else
                                                  current_mode = (char)120;
                                            enum privoxy_err return_value_map_radio_30;
                                            return_value_map_radio_30=map_radio(exports, "external-filter", "ynx", (signed int)current_mode);
                                            if(!(return_value_map_radio_30 == /*enum*/JB_ERR_OK))
                                              return (enum privoxy_err)JB_ERR_MEMORY;

                                            else
                                            {
                                              if((0x00000008UL & mask) == 0ul)
                                                current_mode = (char)110;

                                              else
                                                if(!((0x00000008UL & add) == 0ul))
                                                  current_mode = (char)121;

                                                else
                                                  current_mode = (char)120;
                                              enum privoxy_err return_value_map_radio_31;
                                              return_value_map_radio_31=map_radio(exports, "fast-redirects", "ynx", (signed int)current_mode);
                                              if(!(return_value_map_radio_31 == /*enum*/JB_ERR_OK))
                                                return (enum privoxy_err)JB_ERR_MEMORY;

                                              else
                                              {
                                                mapped_param = 0;
                                                if(!((0x00000008UL & add) == 0ul))
                                                {
                                                  signed int return_value_strcmp_32;
                                                  return_value_strcmp_32=strcmp(action->string[(signed long int)14], "simple-check");
                                                  checked = (signed int)!(return_value_strcmp_32 != 0);
                                                }

                                                else
                                                  checked = 0;
                                                mapped_param = mapped_param | checked;
                                                enum privoxy_err return_value_map_33;
                                                return_value_map_33=map(exports, "fast-redirects-param-simple-check", 1, checked != 0 ? "checked" : "", 1);
                                                if(!(return_value_map_33 == /*enum*/JB_ERR_OK))
                                                  return (enum privoxy_err)JB_ERR_MEMORY;

                                                else
                                                {
                                                  if(!((0x00000008UL & add) == 0ul))
                                                  {
                                                    signed int return_value_strcmp_34;
                                                    return_value_strcmp_34=strcmp(action->string[(signed long int)14], "check-decoded-url");
                                                    checked = (signed int)!(return_value_strcmp_34 != 0);
                                                  }

                                                  else
                                                    checked = 1;
                                                  mapped_param = mapped_param | checked;
                                                  enum privoxy_err return_value_map_35;
                                                  return_value_map_35=map(exports, "fast-redirects-param-check-decoded-url", 1, checked != 0 ? "checked" : "", 1);
                                                  if(!(return_value_map_35 == /*enum*/JB_ERR_OK))
                                                    return (enum privoxy_err)JB_ERR_MEMORY;

                                                  else
                                                  {
                                                    if(!(action->multi_add[1l][0l].first == ((struct list_entry *)NULL)))
                                                      current_mode = (char)121;

                                                    else
                                                      if(!(action->multi_remove_all[1l] == 0))
                                                        current_mode = (char)110;

                                                      else
                                                        if(!(action->multi_remove[1l][0l].first == ((struct list_entry *)NULL)))
                                                          current_mode = (char)121;

                                                        else
                                                          current_mode = (char)120;
                                                    enum privoxy_err return_value_map_radio_36;
                                                    return_value_map_radio_36=map_radio(exports, "filter", "ynx", (signed int)current_mode);
                                                    if(!(return_value_map_radio_36 == /*enum*/JB_ERR_OK))
                                                      return (enum privoxy_err)JB_ERR_MEMORY;

                                                    else
                                                    {
                                                      if((0x00400000UL & mask) == 0ul)
                                                        current_mode = (char)110;

                                                      else
                                                        if(!((0x00400000UL & add) == 0ul))
                                                          current_mode = (char)121;

                                                        else
                                                          current_mode = (char)120;
                                                      enum privoxy_err return_value_map_radio_37;
                                                      return_value_map_radio_37=map_radio(exports, "force-text-mode", "ynx", (signed int)current_mode);
                                                      if(!(return_value_map_radio_37 == /*enum*/JB_ERR_OK))
                                                        return (enum privoxy_err)JB_ERR_MEMORY;

                                                      else
                                                      {
                                                        if((0x00004000UL & mask) == 0ul)
                                                          current_mode = (char)110;

                                                        else
                                                          if(!((0x00004000UL & add) == 0ul))
                                                            current_mode = (char)121;

                                                          else
                                                            current_mode = (char)120;
                                                        enum privoxy_err return_value_map_radio_38;
                                                        return_value_map_radio_38=map_radio(exports, "forward-override", "ynx", (signed int)current_mode);
                                                        if(!(return_value_map_radio_38 == /*enum*/JB_ERR_OK))
                                                          return (enum privoxy_err)JB_ERR_MEMORY;

                                                        else
                                                        {
                                                          mapped_param = 0;
                                                          enum privoxy_err return_value_map_39;
                                                          return_value_map_39=map(exports, "forward-override-param-custom", 1, !(mapped_param != 0) ? "checked" : "", 1);
                                                          if(!(return_value_map_39 == /*enum*/JB_ERR_OK))
                                                            return (enum privoxy_err)JB_ERR_MEMORY;

                                                          else
                                                          {
                                                            if(mapped_param == 0 && !((0x00004000UL & add) == 0ul))
                                                              tmp_if_expr_40 = action->string[(signed long int)15];

                                                            else
                                                              tmp_if_expr_40 = "forward .";
                                                            enum privoxy_err return_value_map_41;
                                                            return_value_map_41=map(exports, "forward-override-param", 1, tmp_if_expr_40, 1);
                                                            if(!(return_value_map_41 == /*enum*/JB_ERR_OK))
                                                              return (enum privoxy_err)JB_ERR_MEMORY;

                                                            else
                                                            {
                                                              if((0x00008000UL & mask) == 0ul)
                                                                current_mode = (char)110;

                                                              else
                                                                if(!((0x00008000UL & add) == 0ul))
                                                                  current_mode = (char)121;

                                                                else
                                                                  current_mode = (char)120;
                                                              enum privoxy_err return_value_map_radio_42;
                                                              return_value_map_radio_42=map_radio(exports, "handle-as-empty-document", "ynx", (signed int)current_mode);
                                                              if(!(return_value_map_radio_42 == /*enum*/JB_ERR_OK))
                                                                return (enum privoxy_err)JB_ERR_MEMORY;

                                                              else
                                                              {
                                                                if((0x00000100UL & mask) == 0ul)
                                                                  current_mode = (char)110;

                                                                else
                                                                  if(!((0x00000100UL & add) == 0ul))
                                                                    current_mode = (char)121;

                                                                  else
                                                                    current_mode = (char)120;
                                                                enum privoxy_err return_value_map_radio_43;
                                                                return_value_map_radio_43=map_radio(exports, "handle-as-image", "ynx", (signed int)current_mode);
                                                                if(!(return_value_map_radio_43 == /*enum*/JB_ERR_OK))
                                                                  return (enum privoxy_err)JB_ERR_MEMORY;

                                                                else
                                                                {
                                                                  if((0x04000000UL & mask) == 0ul)
                                                                    current_mode = (char)110;

                                                                  else
                                                                    if(!((0x04000000UL & add) == 0ul))
                                                                      current_mode = (char)121;

                                                                    else
                                                                      current_mode = (char)120;
                                                                  enum privoxy_err return_value_map_radio_44;
                                                                  return_value_map_radio_44=map_radio(exports, "hide-accept-language", "ynx", (signed int)current_mode);
                                                                  if(!(return_value_map_radio_44 == /*enum*/JB_ERR_OK))
                                                                    return (enum privoxy_err)JB_ERR_MEMORY;

                                                                  else
                                                                  {
                                                                    mapped_param = 0;
                                                                    if(!((0x04000000UL & add) == 0ul))
                                                                    {
                                                                      signed int return_value_strcmp_45;
                                                                      return_value_strcmp_45=strcmp(action->string[(signed long int)8], "block");
                                                                      checked = (signed int)!(return_value_strcmp_45 != 0);
                                                                    }

                                                                    else
                                                                      checked = 0;
                                                                    mapped_param = mapped_param | checked;
                                                                    enum privoxy_err return_value_map_46;
                                                                    return_value_map_46=map(exports, "hide-accept-language-param-block", 1, checked != 0 ? "checked" : "", 1);
                                                                    if(!(return_value_map_46 == /*enum*/JB_ERR_OK))
                                                                      return (enum privoxy_err)JB_ERR_MEMORY;

                                                                    else
                                                                    {
                                                                      enum privoxy_err return_value_map_47;
                                                                      return_value_map_47=map(exports, "hide-accept-language-param-custom", 1, !(mapped_param != 0) ? "checked" : "", 1);
                                                                      if(!(return_value_map_47 == /*enum*/JB_ERR_OK))
                                                                        return (enum privoxy_err)JB_ERR_MEMORY;

                                                                      else
                                                                      {
                                                                        if(mapped_param == 0 && !((0x04000000UL & add) == 0ul))
                                                                          tmp_if_expr_48 = action->string[(signed long int)8];

                                                                        else
                                                                          tmp_if_expr_48 = "de-de";
                                                                        enum privoxy_err return_value_map_49;
                                                                        return_value_map_49=map(exports, "hide-accept-language-param", 1, tmp_if_expr_48, 1);
                                                                        if(!(return_value_map_49 == /*enum*/JB_ERR_OK))
                                                                          return (enum privoxy_err)JB_ERR_MEMORY;

                                                                        else
                                                                        {
                                                                          if((0x01000000UL & mask) == 0ul)
                                                                            current_mode = (char)110;

                                                                          else
                                                                            if(!((0x01000000UL & add) == 0ul))
                                                                              current_mode = (char)121;

                                                                            else
                                                                              current_mode = (char)120;
                                                                          enum privoxy_err return_value_map_radio_50;
                                                                          return_value_map_radio_50=map_radio(exports, "hide-content-disposition", "ynx", (signed int)current_mode);
                                                                          if(!(return_value_map_radio_50 == /*enum*/JB_ERR_OK))
                                                                            return (enum privoxy_err)JB_ERR_MEMORY;

                                                                          else
                                                                          {
                                                                            mapped_param = 0;
                                                                            if(!((0x01000000UL & add) == 0ul))
                                                                            {
                                                                              signed int return_value_strcmp_51;
                                                                              return_value_strcmp_51=strcmp(action->string[(signed long int)10], "block");
                                                                              checked = (signed int)!(return_value_strcmp_51 != 0);
                                                                            }

                                                                            else
                                                                              checked = 0;
                                                                            mapped_param = mapped_param | checked;
                                                                            enum privoxy_err return_value_map_52;
                                                                            return_value_map_52=map(exports, "hide-content-disposition-param-block", 1, checked != 0 ? "checked" : "", 1);
                                                                            if(!(return_value_map_52 == /*enum*/JB_ERR_OK))
                                                                              return (enum privoxy_err)JB_ERR_MEMORY;

                                                                            else
                                                                            {
                                                                              enum privoxy_err return_value_map_53;
                                                                              return_value_map_53=map(exports, "hide-content-disposition-param-custom", 1, !(mapped_param != 0) ? "checked" : "", 1);
                                                                              if(!(return_value_map_53 == /*enum*/JB_ERR_OK))
                                                                                return (enum privoxy_err)JB_ERR_MEMORY;

                                                                              else
                                                                              {
                                                                                if(mapped_param == 0 && !((0x01000000UL & add) == 0ul))
                                                                                  tmp_if_expr_54 = action->string[(signed long int)10];

                                                                                else
                                                                                  tmp_if_expr_54 = "attachment; filename=WHATEVER.txt";
                                                                                enum privoxy_err return_value_map_55;
                                                                                return_value_map_55=map(exports, "hide-content-disposition-param", 1, tmp_if_expr_54, 1);
                                                                                if(!(return_value_map_55 == /*enum*/JB_ERR_OK))
                                                                                  return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                else
                                                                                {
                                                                                  if((0x00000020UL & mask) == 0ul)
                                                                                    current_mode = (char)110;

                                                                                  else
                                                                                    if(!((0x00000020UL & add) == 0ul))
                                                                                      current_mode = (char)121;

                                                                                    else
                                                                                      current_mode = (char)120;
                                                                                  enum privoxy_err return_value_map_radio_56;
                                                                                  return_value_map_radio_56=map_radio(exports, "hide-from-header", "ynx", (signed int)current_mode);
                                                                                  if(!(return_value_map_radio_56 == /*enum*/JB_ERR_OK))
                                                                                    return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                  else
                                                                                  {
                                                                                    mapped_param = 0;
                                                                                    if(!((0x00000020UL & add) == 0ul))
                                                                                    {
                                                                                      signed int return_value_strcmp_57;
                                                                                      return_value_strcmp_57=strcmp(action->string[(signed long int)1], "block");
                                                                                      checked = (signed int)!(return_value_strcmp_57 != 0);
                                                                                    }

                                                                                    else
                                                                                      checked = 1;
                                                                                    mapped_param = mapped_param | checked;
                                                                                    enum privoxy_err return_value_map_58;
                                                                                    return_value_map_58=map(exports, "hide-from-header-param-block", 1, checked != 0 ? "checked" : "", 1);
                                                                                    if(!(return_value_map_58 == /*enum*/JB_ERR_OK))
                                                                                      return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                    else
                                                                                    {
                                                                                      enum privoxy_err return_value_map_59;
                                                                                      return_value_map_59=map(exports, "hide-from-header-param-custom", 1, !(mapped_param != 0) ? "checked" : "", 1);
                                                                                      if(!(return_value_map_59 == /*enum*/JB_ERR_OK))
                                                                                        return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                      else
                                                                                      {
                                                                                        if(mapped_param == 0 && !((0x00000020UL & add) == 0ul))
                                                                                          tmp_if_expr_60 = action->string[(signed long int)1];

                                                                                        else
                                                                                          tmp_if_expr_60 = "spam_me_senseless@sittingduck.xyz";
                                                                                        enum privoxy_err return_value_map_61;
                                                                                        return_value_map_61=map(exports, "hide-from-header-param", 1, tmp_if_expr_60, 1);
                                                                                        if(!(return_value_map_61 == /*enum*/JB_ERR_OK))
                                                                                          return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                        else
                                                                                        {
                                                                                          if((0x00040000UL & mask) == 0ul)
                                                                                            current_mode = (char)110;

                                                                                          else
                                                                                            if(!((0x00040000UL & add) == 0ul))
                                                                                              current_mode = (char)121;

                                                                                            else
                                                                                              current_mode = (char)120;
                                                                                          enum privoxy_err return_value_map_radio_62;
                                                                                          return_value_map_radio_62=map_radio(exports, "hide-if-modified-since", "ynx", (signed int)current_mode);
                                                                                          if(!(return_value_map_radio_62 == /*enum*/JB_ERR_OK))
                                                                                            return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                          else
                                                                                          {
                                                                                            mapped_param = 0;
                                                                                            if(!((0x00040000UL & add) == 0ul))
                                                                                            {
                                                                                              signed int return_value_strcmp_63;
                                                                                              return_value_strcmp_63=strcmp(action->string[(signed long int)11], "block");
                                                                                              checked = (signed int)!(return_value_strcmp_63 != 0);
                                                                                            }

                                                                                            else
                                                                                              checked = 0;
                                                                                            mapped_param = mapped_param | checked;
                                                                                            enum privoxy_err return_value_map_64;
                                                                                            return_value_map_64=map(exports, "hide-if-modified-since-param-block", 1, checked != 0 ? "checked" : "", 1);
                                                                                            if(!(return_value_map_64 == /*enum*/JB_ERR_OK))
                                                                                              return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                            else
                                                                                            {
                                                                                              enum privoxy_err return_value_map_65;
                                                                                              return_value_map_65=map(exports, "hide-if-modified-since-param-custom", 1, !(mapped_param != 0) ? "checked" : "", 1);
                                                                                              if(!(return_value_map_65 == /*enum*/JB_ERR_OK))
                                                                                                return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                              else
                                                                                              {
                                                                                                if(mapped_param == 0 && !((0x00040000UL & add) == 0ul))
                                                                                                  tmp_if_expr_66 = action->string[(signed long int)11];

                                                                                                else
                                                                                                  tmp_if_expr_66 = "-1";
                                                                                                enum privoxy_err return_value_map_67;
                                                                                                return_value_map_67=map(exports, "hide-if-modified-since-param", 1, tmp_if_expr_66, 1);
                                                                                                if(!(return_value_map_67 == /*enum*/JB_ERR_OK))
                                                                                                  return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                else
                                                                                                {
                                                                                                  if((0x00000040UL & mask) == 0ul)
                                                                                                    current_mode = (char)110;

                                                                                                  else
                                                                                                    if(!((0x00000040UL & add) == 0ul))
                                                                                                      current_mode = (char)121;

                                                                                                    else
                                                                                                      current_mode = (char)120;
                                                                                                  enum privoxy_err return_value_map_radio_68;
                                                                                                  return_value_map_radio_68=map_radio(exports, "hide-referrer", "ynx", (signed int)current_mode);
                                                                                                  if(!(return_value_map_radio_68 == /*enum*/JB_ERR_OK))
                                                                                                    return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                  else
                                                                                                  {
                                                                                                    mapped_param = 0;
                                                                                                    if(!((0x00000040UL & add) == 0ul))
                                                                                                    {
                                                                                                      signed int return_value_strcmp_69;
                                                                                                      return_value_strcmp_69=strcmp(action->string[(signed long int)3], "conditional-forge");
                                                                                                      checked = (signed int)!(return_value_strcmp_69 != 0);
                                                                                                    }

                                                                                                    else
                                                                                                      checked = 3;
                                                                                                    mapped_param = mapped_param | checked;
                                                                                                    enum privoxy_err return_value_map_70;
                                                                                                    return_value_map_70=map(exports, "hide-referrer-param-conditional-forge", 1, checked != 0 ? "checked" : "", 1);
                                                                                                    if(!(return_value_map_70 == /*enum*/JB_ERR_OK))
                                                                                                      return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                    else
                                                                                                    {
                                                                                                      if(!((0x00000040UL & add) == 0ul))
                                                                                                      {
                                                                                                        signed int return_value_strcmp_71;
                                                                                                        return_value_strcmp_71=strcmp(action->string[(signed long int)3], "conditional-block");
                                                                                                        checked = (signed int)!(return_value_strcmp_71 != 0);
                                                                                                      }

                                                                                                      else
                                                                                                        checked = 2;
                                                                                                      mapped_param = mapped_param | checked;
                                                                                                      enum privoxy_err return_value_map_72;
                                                                                                      return_value_map_72=map(exports, "hide-referrer-param-conditional-block", 1, checked != 0 ? "checked" : "", 1);
                                                                                                      if(!(return_value_map_72 == /*enum*/JB_ERR_OK))
                                                                                                        return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                      else
                                                                                                      {
                                                                                                        if(!((0x00000040UL & add) == 0ul))
                                                                                                        {
                                                                                                          signed int return_value_strcmp_73;
                                                                                                          return_value_strcmp_73=strcmp(action->string[(signed long int)3], "forge");
                                                                                                          checked = (signed int)!(return_value_strcmp_73 != 0);
                                                                                                        }

                                                                                                        else
                                                                                                          checked = 1;
                                                                                                        mapped_param = mapped_param | checked;
                                                                                                        enum privoxy_err return_value_map_74;
                                                                                                        return_value_map_74=map(exports, "hide-referrer-param-forge", 1, checked != 0 ? "checked" : "", 1);
                                                                                                        if(!(return_value_map_74 == /*enum*/JB_ERR_OK))
                                                                                                          return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                        else
                                                                                                        {
                                                                                                          if(!((0x00000040UL & add) == 0ul))
                                                                                                          {
                                                                                                            signed int return_value_strcmp_75;
                                                                                                            return_value_strcmp_75=strcmp(action->string[(signed long int)3], "block");
                                                                                                            checked = (signed int)!(return_value_strcmp_75 != 0);
                                                                                                          }

                                                                                                          else
                                                                                                            checked = 0;
                                                                                                          mapped_param = mapped_param | checked;
                                                                                                          enum privoxy_err return_value_map_76;
                                                                                                          return_value_map_76=map(exports, "hide-referrer-param-block", 1, checked != 0 ? "checked" : "", 1);
                                                                                                          if(!(return_value_map_76 == /*enum*/JB_ERR_OK))
                                                                                                            return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                          else
                                                                                                          {
                                                                                                            enum privoxy_err return_value_map_77;
                                                                                                            return_value_map_77=map(exports, "hide-referrer-param-custom", 1, !(mapped_param != 0) ? "checked" : "", 1);
                                                                                                            if(!(return_value_map_77 == /*enum*/JB_ERR_OK))
                                                                                                              return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                            else
                                                                                                            {
                                                                                                              if(mapped_param == 0 && !((0x00000040UL & add) == 0ul))
                                                                                                                tmp_if_expr_78 = action->string[(signed long int)3];

                                                                                                              else
                                                                                                                tmp_if_expr_78 = "http://www.privoxy.org/";
                                                                                                              enum privoxy_err return_value_map_79;
                                                                                                              return_value_map_79=map(exports, "hide-referrer-param", 1, tmp_if_expr_78, 1);
                                                                                                              if(!(return_value_map_79 == /*enum*/JB_ERR_OK))
                                                                                                                return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                              else
                                                                                                              {
                                                                                                                if((0x00000080UL & mask) == 0ul)
                                                                                                                  current_mode = (char)110;

                                                                                                                else
                                                                                                                  if(!((0x00000080UL & add) == 0ul))
                                                                                                                    current_mode = (char)121;

                                                                                                                  else
                                                                                                                    current_mode = (char)120;
                                                                                                                enum privoxy_err return_value_map_radio_80;
                                                                                                                return_value_map_radio_80=map_radio(exports, "hide-user-agent", "ynx", (signed int)current_mode);
                                                                                                                if(!(return_value_map_radio_80 == /*enum*/JB_ERR_OK))
                                                                                                                  return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                else
                                                                                                                {
                                                                                                                  mapped_param = 0;
                                                                                                                  if(!((0x00000080UL & add) == 0ul))
                                                                                                                    tmp_if_expr_81 = action->string[(signed long int)4];

                                                                                                                  else
                                                                                                                    tmp_if_expr_81 = "Privoxy 3.0.24";
                                                                                                                  enum privoxy_err return_value_map_82;
                                                                                                                  return_value_map_82=map(exports, "hide-user-agent-param", 1, tmp_if_expr_81, 1);
                                                                                                                  if(!(return_value_map_82 == /*enum*/JB_ERR_OK))
                                                                                                                    return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                  else
                                                                                                                  {
                                                                                                                    if((0x00010000UL & mask) == 0ul)
                                                                                                                      current_mode = (char)110;

                                                                                                                    else
                                                                                                                      if(!((0x00010000UL & add) == 0ul))
                                                                                                                        current_mode = (char)121;

                                                                                                                      else
                                                                                                                        current_mode = (char)120;
                                                                                                                    enum privoxy_err return_value_map_radio_83;
                                                                                                                    return_value_map_radio_83=map_radio(exports, "limit-connect", "ynx", (signed int)current_mode);
                                                                                                                    if(!(return_value_map_radio_83 == /*enum*/JB_ERR_OK))
                                                                                                                      return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                    else
                                                                                                                    {
                                                                                                                      mapped_param = 0;
                                                                                                                      if(!((0x00010000UL & add) == 0ul))
                                                                                                                        tmp_if_expr_84 = action->string[(signed long int)5];

                                                                                                                      else
                                                                                                                        tmp_if_expr_84 = "443";
                                                                                                                      enum privoxy_err return_value_map_85;
                                                                                                                      return_value_map_85=map(exports, "limit-connect-param", 1, tmp_if_expr_84, 1);
                                                                                                                      if(!(return_value_map_85 == /*enum*/JB_ERR_OK))
                                                                                                                        return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                      else
                                                                                                                      {
                                                                                                                        if((0x08000000UL & mask) == 0ul)
                                                                                                                          current_mode = (char)110;

                                                                                                                        else
                                                                                                                          if(!((0x08000000UL & add) == 0ul))
                                                                                                                            current_mode = (char)121;

                                                                                                                          else
                                                                                                                            current_mode = (char)120;
                                                                                                                        enum privoxy_err return_value_map_radio_86;
                                                                                                                        return_value_map_radio_86=map_radio(exports, "limit-cookie-lifetime", "ynx", (signed int)current_mode);
                                                                                                                        if(!(return_value_map_radio_86 == /*enum*/JB_ERR_OK))
                                                                                                                          return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                        else
                                                                                                                        {
                                                                                                                          mapped_param = 0;
                                                                                                                          enum privoxy_err return_value_map_87;
                                                                                                                          return_value_map_87=map(exports, "limit-cookie-lifetime-param-custom", 1, !(mapped_param != 0) ? "checked" : "", 1);
                                                                                                                          if(!(return_value_map_87 == /*enum*/JB_ERR_OK))
                                                                                                                            return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                          else
                                                                                                                          {
                                                                                                                            if(mapped_param == 0 && !((0x08000000UL & add) == 0ul))
                                                                                                                              tmp_if_expr_88 = action->string[(signed long int)18];

                                                                                                                            else
                                                                                                                              tmp_if_expr_88 = "60";
                                                                                                                            enum privoxy_err return_value_map_89;
                                                                                                                            return_value_map_89=map(exports, "limit-cookie-lifetime-param", 1, tmp_if_expr_88, 1);
                                                                                                                            if(!(return_value_map_89 == /*enum*/JB_ERR_OK))
                                                                                                                              return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                            else
                                                                                                                            {
                                                                                                                              if((0x02000000UL & mask) == 0ul)
                                                                                                                                current_mode = (char)110;

                                                                                                                              else
                                                                                                                                if(!((0x02000000UL & add) == 0ul))
                                                                                                                                  current_mode = (char)121;

                                                                                                                                else
                                                                                                                                  current_mode = (char)120;
                                                                                                                              enum privoxy_err return_value_map_radio_90;
                                                                                                                              return_value_map_radio_90=map_radio(exports, "overwrite-last-modified", "ynx", (signed int)current_mode);
                                                                                                                              if(!(return_value_map_radio_90 == /*enum*/JB_ERR_OK))
                                                                                                                                return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                              else
                                                                                                                              {
                                                                                                                                mapped_param = 0;
                                                                                                                                if(!((0x02000000UL & add) == 0ul))
                                                                                                                                {
                                                                                                                                  signed int return_value_strcmp_91;
                                                                                                                                  return_value_strcmp_91=strcmp(action->string[(signed long int)12], "block");
                                                                                                                                  checked = (signed int)!(return_value_strcmp_91 != 0);
                                                                                                                                }

                                                                                                                                else
                                                                                                                                  checked = 0;
                                                                                                                                mapped_param = mapped_param | checked;
                                                                                                                                enum privoxy_err return_value_map_92;
                                                                                                                                return_value_map_92=map(exports, "overwrite-last-modified-param-block", 1, checked != 0 ? "checked" : "", 1);
                                                                                                                                if(!(return_value_map_92 == /*enum*/JB_ERR_OK))
                                                                                                                                  return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                                else
                                                                                                                                {
                                                                                                                                  if(!((0x02000000UL & add) == 0ul))
                                                                                                                                  {
                                                                                                                                    signed int return_value_strcmp_93;
                                                                                                                                    return_value_strcmp_93=strcmp(action->string[(signed long int)12], "reset-to-request-time");
                                                                                                                                    checked = (signed int)!(return_value_strcmp_93 != 0);
                                                                                                                                  }

                                                                                                                                  else
                                                                                                                                    checked = 1;
                                                                                                                                  mapped_param = mapped_param | checked;
                                                                                                                                  enum privoxy_err return_value_map_94;
                                                                                                                                  return_value_map_94=map(exports, "overwrite-last-modified-param-reset-to-request-time", 1, checked != 0 ? "checked" : "", 1);
                                                                                                                                  if(!(return_value_map_94 == /*enum*/JB_ERR_OK))
                                                                                                                                    return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                                  else
                                                                                                                                  {
                                                                                                                                    if(!((0x02000000UL & add) == 0ul))
                                                                                                                                    {
                                                                                                                                      signed int return_value_strcmp_95;
                                                                                                                                      return_value_strcmp_95=strcmp(action->string[(signed long int)12], "randomize");
                                                                                                                                      checked = (signed int)!(return_value_strcmp_95 != 0);
                                                                                                                                    }

                                                                                                                                    else
                                                                                                                                      checked = 2;
                                                                                                                                    mapped_param = mapped_param | checked;
                                                                                                                                    enum privoxy_err return_value_map_96;
                                                                                                                                    return_value_map_96=map(exports, "overwrite-last-modified-param-randomize", 1, checked != 0 ? "checked" : "", 1);
                                                                                                                                    if(!(return_value_map_96 == /*enum*/JB_ERR_OK))
                                                                                                                                      return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                                    else
                                                                                                                                    {
                                                                                                                                      if((0x00000400UL & mask) == 0ul)
                                                                                                                                        current_mode = (char)110;

                                                                                                                                      else
                                                                                                                                        if(!((0x00000400UL & add) == 0ul))
                                                                                                                                          current_mode = (char)121;

                                                                                                                                        else
                                                                                                                                          current_mode = (char)120;
                                                                                                                                      enum privoxy_err return_value_map_radio_97;
                                                                                                                                      return_value_map_radio_97=map_radio(exports, "prevent-compression", "ynx", (signed int)current_mode);
                                                                                                                                      if(!(return_value_map_radio_97 == /*enum*/JB_ERR_OK))
                                                                                                                                        return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                                      else
                                                                                                                                      {
                                                                                                                                        if((0x00020000UL & mask) == 0ul)
                                                                                                                                          current_mode = (char)110;

                                                                                                                                        else
                                                                                                                                          if(!((0x00020000UL & add) == 0ul))
                                                                                                                                            current_mode = (char)121;

                                                                                                                                          else
                                                                                                                                            current_mode = (char)120;
                                                                                                                                        enum privoxy_err return_value_map_radio_98;
                                                                                                                                        return_value_map_radio_98=map_radio(exports, "redirect", "ynx", (signed int)current_mode);
                                                                                                                                        if(!(return_value_map_radio_98 == /*enum*/JB_ERR_OK))
                                                                                                                                          return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                                        else
                                                                                                                                        {
                                                                                                                                          mapped_param = 0;
                                                                                                                                          if(!((0x00020000UL & add) == 0ul))
                                                                                                                                            tmp_if_expr_99 = action->string[(signed long int)13];

                                                                                                                                          else
                                                                                                                                            tmp_if_expr_99 = "http://localhost/";
                                                                                                                                          enum privoxy_err return_value_map_100;
                                                                                                                                          return_value_map_100=map(exports, "redirect-param", 1, tmp_if_expr_99, 1);
                                                                                                                                          if(!(return_value_map_100 == /*enum*/JB_ERR_OK))
                                                                                                                                            return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                                          else
                                                                                                                                          {
                                                                                                                                            if(!(action->multi_add[2l][0l].first == ((struct list_entry *)NULL)))
                                                                                                                                              current_mode = (char)121;

                                                                                                                                            else
                                                                                                                                              if(!(action->multi_remove_all[2l] == 0))
                                                                                                                                                current_mode = (char)110;

                                                                                                                                              else
                                                                                                                                                if(!(action->multi_remove[2l][0l].first == ((struct list_entry *)NULL)))
                                                                                                                                                  current_mode = (char)121;

                                                                                                                                                else
                                                                                                                                                  current_mode = (char)120;
                                                                                                                                            enum privoxy_err return_value_map_radio_101;
                                                                                                                                            return_value_map_radio_101=map_radio(exports, "server-header-filter", "ynx", (signed int)current_mode);
                                                                                                                                            if(!(return_value_map_radio_101 == /*enum*/JB_ERR_OK))
                                                                                                                                              return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                                            else
                                                                                                                                            {
                                                                                                                                              if(!(action->multi_add[5l][0l].first == ((struct list_entry *)NULL)))
                                                                                                                                                current_mode = (char)121;

                                                                                                                                              else
                                                                                                                                                if(!(action->multi_remove_all[5l] == 0))
                                                                                                                                                  current_mode = (char)110;

                                                                                                                                                else
                                                                                                                                                  if(!(action->multi_remove[5l][0l].first == ((struct list_entry *)NULL)))
                                                                                                                                                    current_mode = (char)121;

                                                                                                                                                  else
                                                                                                                                                    current_mode = (char)120;
                                                                                                                                              enum privoxy_err return_value_map_radio_102;
                                                                                                                                              return_value_map_radio_102=map_radio(exports, "server-header-tagger", "ynx", (signed int)current_mode);
                                                                                                                                              if(!(return_value_map_radio_102 == /*enum*/JB_ERR_OK))
                                                                                                                                                return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                                              else
                                                                                                                                              {
                                                                                                                                                if((0x00000800UL & mask) == 0ul)
                                                                                                                                                  current_mode = (char)110;

                                                                                                                                                else
                                                                                                                                                  if(!((0x00000800UL & add) == 0ul))
                                                                                                                                                    current_mode = (char)121;

                                                                                                                                                  else
                                                                                                                                                    current_mode = (char)120;
                                                                                                                                                enum privoxy_err return_value_map_radio_103;
                                                                                                                                                return_value_map_radio_103=map_radio(exports, "session-cookies-only", "ynx", (signed int)current_mode);
                                                                                                                                                if(!(return_value_map_radio_103 == /*enum*/JB_ERR_OK))
                                                                                                                                                  return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                                                else
                                                                                                                                                {
                                                                                                                                                  if((0x00000200UL & mask) == 0ul)
                                                                                                                                                    current_mode = (char)110;

                                                                                                                                                  else
                                                                                                                                                    if(!((0x00000200UL & add) == 0ul))
                                                                                                                                                      current_mode = (char)121;

                                                                                                                                                    else
                                                                                                                                                      current_mode = (char)120;
                                                                                                                                                  enum privoxy_err return_value_map_radio_104;
                                                                                                                                                  return_value_map_radio_104=map_radio(exports, "set-image-blocker", "ynx", (signed int)current_mode);
                                                                                                                                                  if(!(return_value_map_radio_104 == /*enum*/JB_ERR_OK))
                                                                                                                                                    return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                                                  else
                                                                                                                                                  {
                                                                                                                                                    mapped_param = 0;
                                                                                                                                                    if(!((0x00000200UL & add) == 0ul))
                                                                                                                                                    {
                                                                                                                                                      signed int return_value_strcmp_105;
                                                                                                                                                      return_value_strcmp_105=strcmp(action->string[(signed long int)2], "pattern");
                                                                                                                                                      checked = (signed int)!(return_value_strcmp_105 != 0);
                                                                                                                                                    }

                                                                                                                                                    else
                                                                                                                                                      checked = 1;
                                                                                                                                                    mapped_param = mapped_param | checked;
                                                                                                                                                    enum privoxy_err return_value_map_106;
                                                                                                                                                    return_value_map_106=map(exports, "set-image-blocker-param-pattern", 1, checked != 0 ? "checked" : "", 1);
                                                                                                                                                    if(!(return_value_map_106 == /*enum*/JB_ERR_OK))
                                                                                                                                                      return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                                                    else
                                                                                                                                                    {
                                                                                                                                                      if(!((0x00000200UL & add) == 0ul))
                                                                                                                                                      {
                                                                                                                                                        signed int return_value_strcmp_107;
                                                                                                                                                        return_value_strcmp_107=strcmp(action->string[(signed long int)2], "blank");
                                                                                                                                                        checked = (signed int)!(return_value_strcmp_107 != 0);
                                                                                                                                                      }

                                                                                                                                                      else
                                                                                                                                                        checked = 0;
                                                                                                                                                      mapped_param = mapped_param | checked;
                                                                                                                                                      enum privoxy_err return_value_map_108;
                                                                                                                                                      return_value_map_108=map(exports, "set-image-blocker-param-blank", 1, checked != 0 ? "checked" : "", 1);
                                                                                                                                                      if(!(return_value_map_108 == /*enum*/JB_ERR_OK))
                                                                                                                                                        return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                                                      else
                                                                                                                                                      {
                                                                                                                                                        enum privoxy_err return_value_map_109;
                                                                                                                                                        return_value_map_109=map(exports, "set-image-blocker-param-custom", 1, !(mapped_param != 0) ? "checked" : "", 1);
                                                                                                                                                        if(!(return_value_map_109 == /*enum*/JB_ERR_OK))
                                                                                                                                                          return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                                                        else
                                                                                                                                                        {
                                                                                                                                                          if(mapped_param == 0 && !((0x00000200UL & add) == 0ul))
                                                                                                                                                            tmp_if_expr_110 = action->string[(signed long int)2];

                                                                                                                                                          else
                                                                                                                                                            tmp_if_expr_110 = "http://config.privoxy.org/send-banner?type=pattern";
                                                                                                                                                          enum privoxy_err return_value_map_111;
                                                                                                                                                          return_value_map_111=map(exports, "set-image-blocker-param", 1, tmp_if_expr_110, 1);
                                                                                                                                                          if(!(return_value_map_111 == /*enum*/JB_ERR_OK))
                                                                                                                                                            return (enum privoxy_err)JB_ERR_MEMORY;

                                                                                                                                                          else
                                                                                                                                                            return (enum privoxy_err)JB_ERR_OK;
                                                                                                                                                        }
                                                                                                                                                      }
                                                                                                                                                    }
                                                                                                                                                  }
                                                                                                                                                }
                                                                                                                                              }
                                                                                                                                            }
                                                                                                                                          }
                                                                                                                                        }
                                                                                                                                      }
                                                                                                                                    }
                                                                                                                                  }
                                                                                                                                }
                                                                                                                              }
                                                                                                                            }
                                                                                                                          }
                                                                                                                        }
                                                                                                                      }
                                                                                                                    }
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// actions_to_text
// file actions.c line 1634
extern char * actions_to_text(struct action_spec *action)
{
  unsigned long int mask = action->mask;
  unsigned long int add = action->add;
  char *result;
  result=strdup_or_die("");
  struct list_entry *lst;
  mask = mask | add;
  if(!(action->multi_remove_all[0l] == 0))
    string_append(&result, " -add-header \\\n");

  else
  {
    lst = action->multi_remove[(signed long int)0][0l].first;
    for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
    {
      string_append(&result, " -add-header{");
      string_append(&result, lst->str);
      string_append(&result, "} \\\n");
    }
  }
  lst = action->multi_add[(signed long int)0][0l].first;
  for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
  {
    string_append(&result, " +add-header{");
    string_append(&result, lst->str);
    string_append(&result, "} \\\n");
  }
  if((0x00000001UL & mask) == 0ul)
    string_append(&result, " -block \\\n");

  else
    if(!((0x00000001UL & add) == 0ul))
    {
      string_append(&result, " +block{");
      string_append(&result, action->string[(signed long int)16]);
      string_append(&result, "} \\\n");
    }

  if((0x00000010UL & mask) == 0ul)
    string_append(&result, " -change-x-forwarded-for \\\n");

  else
    if(!((0x00000010UL & add) == 0ul))
    {
      string_append(&result, " +change-x-forwarded-for{");
      string_append(&result, action->string[(signed long int)17]);
      string_append(&result, "} \\\n");
    }

  if(!(action->multi_remove_all[3l] == 0))
    string_append(&result, " -client-header-filter \\\n");

  else
  {
    lst = action->multi_remove[(signed long int)3][0l].first;
    for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
    {
      string_append(&result, " -client-header-filter{");
      string_append(&result, lst->str);
      string_append(&result, "} \\\n");
    }
  }
  lst = action->multi_add[(signed long int)3][0l].first;
  for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
  {
    string_append(&result, " +client-header-filter{");
    string_append(&result, lst->str);
    string_append(&result, "} \\\n");
  }
  if(!(action->multi_remove_all[4l] == 0))
    string_append(&result, " -client-header-tagger \\\n");

  else
  {
    lst = action->multi_remove[(signed long int)4][0l].first;
    for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
    {
      string_append(&result, " -client-header-tagger{");
      string_append(&result, lst->str);
      string_append(&result, "} \\\n");
    }
  }
  lst = action->multi_add[(signed long int)4][0l].first;
  for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
  {
    string_append(&result, " +client-header-tagger{");
    string_append(&result, lst->str);
    string_append(&result, "} \\\n");
  }
  if((0x00080000UL & mask) == 0ul)
    string_append(&result, " -content-type-overwrite \\\n");

  else
    if(!((0x00080000UL & add) == 0ul))
    {
      string_append(&result, " +content-type-overwrite{");
      string_append(&result, action->string[(signed long int)9]);
      string_append(&result, "} \\\n");
    }

  if((0x00200000UL & mask) == 0ul)
    string_append(&result, " -crunch-client-header \\\n");

  else
    if(!((0x00200000UL & add) == 0ul))
    {
      string_append(&result, " +crunch-client-header{");
      string_append(&result, action->string[(signed long int)7]);
      string_append(&result, "} \\\n");
    }

  if((0x00800000UL & mask) == 0ul)
    string_append(&result, " -crunch-if-none-match \\\n");

  else
    if(!((0x00800000UL & add) == 0ul))
      string_append(&result, " +crunch-if-none-match \\\n");

  if((0x00002000UL & mask) == 0ul)
    string_append(&result, " -crunch-incoming-cookies \\\n");

  else
    if(!((0x00002000UL & add) == 0ul))
      string_append(&result, " +crunch-incoming-cookies \\\n");

  if((0x00001000UL & mask) == 0ul)
    string_append(&result, " -crunch-outgoing-cookies \\\n");

  else
    if(!((0x00001000UL & add) == 0ul))
      string_append(&result, " +crunch-outgoing-cookies \\\n");

  if((0x00100000UL & mask) == 0ul)
    string_append(&result, " -crunch-server-header \\\n");

  else
    if(!((0x00100000UL & add) == 0ul))
    {
      string_append(&result, " +crunch-server-header{");
      string_append(&result, action->string[(signed long int)6]);
      string_append(&result, "} \\\n");
    }

  if((0x00000002UL & mask) == 0ul)
    string_append(&result, " -deanimate-gifs \\\n");

  else
    if(!((0x00000002UL & add) == 0ul))
    {
      string_append(&result, " +deanimate-gifs{");
      string_append(&result, action->string[(signed long int)0]);
      string_append(&result, "} \\\n");
    }

  if((0x00000004UL & mask) == 0ul)
    string_append(&result, " -downgrade-http-version \\\n");

  else
    if(!((0x00000004UL & add) == 0ul))
      string_append(&result, " +downgrade-http-version \\\n");

  if(!(action->multi_remove_all[6l] == 0))
    string_append(&result, " -external-filter \\\n");

  else
  {
    lst = action->multi_remove[(signed long int)6][0l].first;
    for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
    {
      string_append(&result, " -external-filter{");
      string_append(&result, lst->str);
      string_append(&result, "} \\\n");
    }
  }
  lst = action->multi_add[(signed long int)6][0l].first;
  for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
  {
    string_append(&result, " +external-filter{");
    string_append(&result, lst->str);
    string_append(&result, "} \\\n");
  }
  if((0x00000008UL & mask) == 0ul)
    string_append(&result, " -fast-redirects \\\n");

  else
    if(!((0x00000008UL & add) == 0ul))
    {
      string_append(&result, " +fast-redirects{");
      string_append(&result, action->string[(signed long int)14]);
      string_append(&result, "} \\\n");
    }

  if(!(action->multi_remove_all[1l] == 0))
    string_append(&result, " -filter \\\n");

  else
  {
    lst = action->multi_remove[(signed long int)1][0l].first;
    for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
    {
      string_append(&result, " -filter{");
      string_append(&result, lst->str);
      string_append(&result, "} \\\n");
    }
  }
  lst = action->multi_add[(signed long int)1][0l].first;
  for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
  {
    string_append(&result, " +filter{");
    string_append(&result, lst->str);
    string_append(&result, "} \\\n");
  }
  if((0x00400000UL & mask) == 0ul)
    string_append(&result, " -force-text-mode \\\n");

  else
    if(!((0x00400000UL & add) == 0ul))
      string_append(&result, " +force-text-mode \\\n");

  if((0x00004000UL & mask) == 0ul)
    string_append(&result, " -forward-override \\\n");

  else
    if(!((0x00004000UL & add) == 0ul))
    {
      string_append(&result, " +forward-override{");
      string_append(&result, action->string[(signed long int)15]);
      string_append(&result, "} \\\n");
    }

  if((0x00008000UL & mask) == 0ul)
    string_append(&result, " -handle-as-empty-document \\\n");

  else
    if(!((0x00008000UL & add) == 0ul))
      string_append(&result, " +handle-as-empty-document \\\n");

  if((0x00000100UL & mask) == 0ul)
    string_append(&result, " -handle-as-image \\\n");

  else
    if(!((0x00000100UL & add) == 0ul))
      string_append(&result, " +handle-as-image \\\n");

  if((0x04000000UL & mask) == 0ul)
    string_append(&result, " -hide-accept-language \\\n");

  else
    if(!((0x04000000UL & add) == 0ul))
    {
      string_append(&result, " +hide-accept-language{");
      string_append(&result, action->string[(signed long int)8]);
      string_append(&result, "} \\\n");
    }

  if((0x01000000UL & mask) == 0ul)
    string_append(&result, " -hide-content-disposition \\\n");

  else
    if(!((0x01000000UL & add) == 0ul))
    {
      string_append(&result, " +hide-content-disposition{");
      string_append(&result, action->string[(signed long int)10]);
      string_append(&result, "} \\\n");
    }

  if((0x00000020UL & mask) == 0ul)
    string_append(&result, " -hide-from-header \\\n");

  else
    if(!((0x00000020UL & add) == 0ul))
    {
      string_append(&result, " +hide-from-header{");
      string_append(&result, action->string[(signed long int)1]);
      string_append(&result, "} \\\n");
    }

  if((0x00040000UL & mask) == 0ul)
    string_append(&result, " -hide-if-modified-since \\\n");

  else
    if(!((0x00040000UL & add) == 0ul))
    {
      string_append(&result, " +hide-if-modified-since{");
      string_append(&result, action->string[(signed long int)11]);
      string_append(&result, "} \\\n");
    }

  if((0x00000040UL & mask) == 0ul)
    string_append(&result, " -hide-referrer \\\n");

  else
    if(!((0x00000040UL & add) == 0ul))
    {
      string_append(&result, " +hide-referrer{");
      string_append(&result, action->string[(signed long int)3]);
      string_append(&result, "} \\\n");
    }

  if((0x00000080UL & mask) == 0ul)
    string_append(&result, " -hide-user-agent \\\n");

  else
    if(!((0x00000080UL & add) == 0ul))
    {
      string_append(&result, " +hide-user-agent{");
      string_append(&result, action->string[(signed long int)4]);
      string_append(&result, "} \\\n");
    }

  if((0x00010000UL & mask) == 0ul)
    string_append(&result, " -limit-connect \\\n");

  else
    if(!((0x00010000UL & add) == 0ul))
    {
      string_append(&result, " +limit-connect{");
      string_append(&result, action->string[(signed long int)5]);
      string_append(&result, "} \\\n");
    }

  if((0x08000000UL & mask) == 0ul)
    string_append(&result, " -limit-cookie-lifetime \\\n");

  else
    if(!((0x08000000UL & add) == 0ul))
    {
      string_append(&result, " +limit-cookie-lifetime{");
      string_append(&result, action->string[(signed long int)18]);
      string_append(&result, "} \\\n");
    }

  if((0x02000000UL & mask) == 0ul)
    string_append(&result, " -overwrite-last-modified \\\n");

  else
    if(!((0x02000000UL & add) == 0ul))
    {
      string_append(&result, " +overwrite-last-modified{");
      string_append(&result, action->string[(signed long int)12]);
      string_append(&result, "} \\\n");
    }

  if((0x00000400UL & mask) == 0ul)
    string_append(&result, " -prevent-compression \\\n");

  else
    if(!((0x00000400UL & add) == 0ul))
      string_append(&result, " +prevent-compression \\\n");

  if((0x00020000UL & mask) == 0ul)
    string_append(&result, " -redirect \\\n");

  else
    if(!((0x00020000UL & add) == 0ul))
    {
      string_append(&result, " +redirect{");
      string_append(&result, action->string[(signed long int)13]);
      string_append(&result, "} \\\n");
    }

  if(!(action->multi_remove_all[2l] == 0))
    string_append(&result, " -server-header-filter \\\n");

  else
  {
    lst = action->multi_remove[(signed long int)2][0l].first;
    for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
    {
      string_append(&result, " -server-header-filter{");
      string_append(&result, lst->str);
      string_append(&result, "} \\\n");
    }
  }
  lst = action->multi_add[(signed long int)2][0l].first;
  for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
  {
    string_append(&result, " +server-header-filter{");
    string_append(&result, lst->str);
    string_append(&result, "} \\\n");
  }
  if(!(action->multi_remove_all[5l] == 0))
    string_append(&result, " -server-header-tagger \\\n");

  else
  {
    lst = action->multi_remove[(signed long int)5][0l].first;
    for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
    {
      string_append(&result, " -server-header-tagger{");
      string_append(&result, lst->str);
      string_append(&result, "} \\\n");
    }
  }
  lst = action->multi_add[(signed long int)5][0l].first;
  for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
  {
    string_append(&result, " +server-header-tagger{");
    string_append(&result, lst->str);
    string_append(&result, "} \\\n");
  }
  if((0x00000800UL & mask) == 0ul)
    string_append(&result, " -session-cookies-only \\\n");

  else
    if(!((0x00000800UL & add) == 0ul))
      string_append(&result, " +session-cookies-only \\\n");

  if((0x00000200UL & mask) == 0ul)
    string_append(&result, " -set-image-blocker \\\n");

  else
    if(!((0x00000200UL & add) == 0ul))
    {
      string_append(&result, " +set-image-blocker{");
      string_append(&result, action->string[(signed long int)2]);
      string_append(&result, "} \\\n");
    }

  return result;
}

// add_cookie_expiry_date
// file parsers.c line 3954
static void add_cookie_expiry_date(char **cookie, signed long int lifetime)
{
  char tmp[50l];
  struct tm *timeptr = (struct tm *)(void *)0;
  signed long int expiry_date;
  signed long int return_value_time_1;
  return_value_time_1=time((signed long int *)(void *)0);
  expiry_date = return_value_time_1 + lifetime;
  struct tm gmt;
  timeptr=gmtime_r(&expiry_date, &gmt);
  if(timeptr == ((struct tm *)NULL))
    log_error(0x4000, "Failed to get the time in add_cooky_expiry_date()");

  strftime(tmp, sizeof(char [50l]) /*50ul*/ , "; expires=%a, %d-%b-%Y %H:%M:%S GMT", timeptr);
  enum privoxy_err return_value_string_append_2;
  return_value_string_append_2=string_append(cookie, tmp);
  if(!((signed int)return_value_string_append_2 == JB_ERR_OK))
    log_error(0x4000, "Out of memory in add_cooky_expiry()");

}

// add_help_link
// file cgi.h line 113
extern char * add_help_link(const char *item, struct configuration_spec *config)
{
  char *result;
  _Bool tmp_if_expr_3;
  signed int return_value_strncmpic_2;
  if(item == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    result=strdup("<a href=\"");
    signed int return_value_strncmpic_1;
    return_value_strncmpic_1=strncmpic(config->usermanual, "file://", (unsigned long int)7);
    if(return_value_strncmpic_1 == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_strncmpic_2=strncmpic(config->usermanual, "http", (unsigned long int)4);
      tmp_if_expr_3 = !(return_value_strncmpic_2 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      string_append(&result, config->usermanual);

    else
    {
      string_append(&result, "http://");
      string_append(&result, "config.privoxy.org");
      string_append(&result, "/user-manual/");
    }
    string_append(&result, "actions-file.html#");
    char *return_value_string_toupper_4;
    return_value_string_toupper_4=string_toupper(item);
    string_join(&result, return_value_string_toupper_4);
    string_append(&result, "\">");
    string_append(&result, item);
    string_append(&result, "</a>");
    return result;
  }
}

// add_loader
// file loaders.h line 91
extern void add_loader(signed int (*loader)(struct client_state *), struct configuration_spec *config)
{
  signed int i = 0;
  for( ; !(i >= 8); i = i + 1)
    if(config->loaders[(signed long int)i] == ((signed int (*)(struct client_state *))NULL))
    {
      config->loaders[(signed long int)i] = loader;
      break;
    }

}

// add_to_iob
// file parsers.h line 54
extern enum privoxy_err add_to_iob(struct iob *iob, const unsigned long int buffer_limit, char *src, signed long int n)
{
  unsigned long int used;
  unsigned long int offset;
  unsigned long int need;
  char *p;
  unsigned long int tmp_if_expr_1;
  _Bool tmp_if_expr_4;
  void *return_value_realloc_3;
  void *return_value_realloc_2;
  if(!(n >= 1l))
    return (enum privoxy_err)JB_ERR_OK;

  else
  {
    used = (unsigned long int)(iob->eod - iob->buf);
    offset = (unsigned long int)(iob->cur - iob->buf);
    need = used + (unsigned long int)n + (unsigned long int)1;
    if(!(buffer_limit >= need))
    {
      log_error(0x1000, "Buffer limit reached while extending the buffer (iob). Needed: %d. Limit: %d", need, buffer_limit);
      return (enum privoxy_err)JB_ERR_MEMORY;
    }

    else
    {
      if(!(iob->size >= need))
      {
        unsigned long int want;
        if(!(iob->size == 0ul))
          tmp_if_expr_1 = iob->size;

        else
          tmp_if_expr_1 = (unsigned long int)512;
        want = tmp_if_expr_1;
        for( ; need >= want; want = want * (unsigned long int)2)
          ;
        if(buffer_limit >= want)
        {
          return_value_realloc_3=realloc((void *)iob->buf, want);
          p = (char *)return_value_realloc_3;
          tmp_if_expr_4 = (char *)(void *)0 != p ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
          iob->size = want;

        else
        {
          return_value_realloc_2=realloc((void *)iob->buf, need);
          p = (char *)return_value_realloc_2;
          if(!(p == ((char *)NULL)))
            iob->size = need;

          else
          {
            log_error(0x2000, "Extending the buffer (iob) failed: %E");
            return (enum privoxy_err)JB_ERR_MEMORY;
          }
        }
        iob->cur = p + (signed long int)offset;
        iob->eod = p + (signed long int)used;
        iob->buf = p;
      }

      memcpy((void *)iob->eod, (const void *)src, (unsigned long int)n);
      iob->eod = iob->eod + n;
      *iob->eod = (char)0;
      return (enum privoxy_err)JB_ERR_OK;
    }
  }
}

// alloc_http_response
// file cgi.c line 1771
extern struct http_response * alloc_http_response(void)
{
  void *return_value_zalloc_1;
  return_value_zalloc_1=zalloc(sizeof(struct http_response) /*64ul*/ );
  return (struct http_response *)return_value_zalloc_1;
}

// any_loaded_file_changed
// file loaders.h line 95
extern signed int any_loaded_file_changed(struct client_state *csp)
{
  struct file_list *file_to_check = csp->config->config_file_list;
  signed int i;
  signed int return_value_file_has_been_modified_1;
  return_value_file_has_been_modified_1=file_has_been_modified(file_to_check->filename, file_to_check->lastmodified);
  if(!(return_value_file_has_been_modified_1 == 0))
    return 1;

  else
  {
    i = 0;
    for( ; !(i >= 30); i = i + 1)
      if(!(csp->actions_list[(signed long int)i] == ((struct file_list *)NULL)))
      {
        file_to_check = csp->actions_list[(signed long int)i];
        signed int return_value_file_has_been_modified_2;
        return_value_file_has_been_modified_2=file_has_been_modified(file_to_check->filename, file_to_check->lastmodified);
        if(!(return_value_file_has_been_modified_2 == 0))
          return 1;

      }

    i = 0;
    for( ; !(i >= 30); i = i + 1)
      if(!(csp->rlist[(signed long int)i] == ((struct file_list *)NULL)))
      {
        file_to_check = csp->rlist[(signed long int)i];
        signed int return_value_file_has_been_modified_3;
        return_value_file_has_been_modified_3=file_has_been_modified(file_to_check->filename, file_to_check->lastmodified);
        if(!(return_value_file_has_been_modified_3 == 0))
          return 1;

      }

    if(!(csp->tlist == ((struct file_list *)NULL)))
    {
      signed int return_value_file_has_been_modified_4;
      return_value_file_has_been_modified_4=file_has_been_modified(csp->tlist->filename, csp->tlist->lastmodified);
      if(!(return_value_file_has_been_modified_4 == 0))
        return 1;

    }

    return 0;
  }
}

// apply_url_actions
// file filters.c line 2350
extern void apply_url_actions(struct current_action_spec *action, struct http_request *http, struct url_actions *b)
{
  if(!(b == ((struct url_actions *)NULL)))
  {
    b = b->next;
    for( ; !(b == ((struct url_actions *)NULL)); b = b->next)
    {
      signed int return_value_url_match_1;
      return_value_url_match_1=url_match(b->url, http);
      if(!(return_value_url_match_1 == 0))
        merge_current_action(action, b->action);

    }
  }

}

// bind_port
// file jbsockets.c line 837
extern signed int bind_port(const char *hostnam, signed int portnum, signed int *pfd)
{
  struct addrinfo hints;
  struct addrinfo *result;
  struct addrinfo *rp;
  char servnam[6l];
  signed int retval;
  signed int fd;
  signed int one = 1;
  *pfd = -1;
  retval=snprintf(servnam, sizeof(char [6l]) /*6ul*/ , "%d", portnum);
  signed int return_value_listen_4;
  if(retval == -1 || (unsigned long int)retval >= sizeof(char [6l]) /*6ul*/ )
  {
    log_error(0x2000, "Port number (%d) ASCII decimal representation doesn't fit into 6 bytes", portnum);
    return -1;
  }

  else
  {
    memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
    hints.ai_family = 0;
    hints.ai_socktype = 1;
    hints.ai_flags = 0x0001;
    hints.ai_protocol = 0;
    hints.ai_canonname = (char *)(void *)0;
    hints.ai_addr = (struct sockaddr *)(void *)0;
    hints.ai_next = (struct addrinfo *)(void *)0;
    retval=getaddrinfo(hostnam, servnam, &hints, &result);
    if(!(retval == 0))
    {
      const char *return_value_gai_strerror_1;
      return_value_gai_strerror_1=gai_strerror(retval);
      log_error(0x2000, "Can not resolve %s: %s", hostnam, return_value_gai_strerror_1);
      return -2;
    }

    rp = result;
    for( ; !(rp == ((struct addrinfo *)NULL)); rp = rp->ai_next)
    {
      fd=socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
      if(fd >= 0)
      {
        mark_socket_for_close_on_execute(fd);
        setsockopt(fd, 1, 2, (const void *)(char *)&one, (unsigned int)sizeof(signed int) /*4ul*/ );
        signed int return_value_bind_3;
        return_value_bind_3=bind(fd, rp->ai_addr, rp->ai_addrlen);
        if(!(return_value_bind_3 >= 0))
        {
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          if(*return_value___errno_location_2 == 98)
          {
            freeaddrinfo(result);
            close_socket(fd);
            return -3;
          }

          else
            close_socket(fd);
        }

        else
          break;
      }

    }
    freeaddrinfo(result);
    if(rp == ((struct addrinfo *)NULL))
      return -1;

    else
    {
      do
      {
        return_value_listen_4=listen(fd, 128);
        if(!(return_value_listen_4 == -1))
          break;

        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        if(!(*return_value___errno_location_5 == 4))
        {
          close_socket(fd);
          return -1;
        }

      }
      while((_Bool)1);
      *pfd = fd;
      return 0;
    }
  }
}

// bind_port_helper
// file jcc.c line 3772
static signed int bind_port_helper(const char *haddr, signed int hport)
{
  signed int result;
  signed int bfd;
  result=bind_port(haddr, hport, &bfd);
  if(!(result >= 0))
  {
    const char *bind_address = (const char *)(void *)0 != haddr ? haddr : "INADDR_ANY";
    if(!(result == -3))
    {
      if(result == -2)
        goto __CPROVER_DUMP_L2;

    }

    else
    {
      log_error(0x4000, "can't bind to %s:%d: There may be another Privoxy or some other proxy running on port %d", bind_address, hport, hport);

    __CPROVER_DUMP_L2:
      ;
      log_error(0x4000, "can't bind to %s:%d: The hostname is not resolvable", bind_address, hport);
    }
    log_error(0x4000, "can't bind to %s:%d: %E", bind_address, hport);
    return -1;
  }

  if(bfd >= 1024)
    log_error(0x4000, "Bind socket number too high to use select(): %d >= %d", bfd, 1024);

  if(haddr == ((const char *)NULL))
    log_error(0x1000, "Listening on port %d on all IP addresses", hport);

  else
    log_error(0x1000, "Listening on port %d on IP address %s", hport, haddr);
  return bfd;
}

// bind_ports_helper
// file jcc.c line 3846
static void bind_ports_helper(struct configuration_spec *config, signed int *sockets)
{
  signed int i = 0;
  for( ; !(i >= 10); i = i + 1)
    if(!(config->hport[(signed long int)i] == 0))
      sockets[(signed long int)i]=bind_port_helper(config->haddr[(signed long int)i], config->hport[(signed long int)i]);

    else
      sockets[(signed long int)i] = -1;
  config->need_bind = 0;
}

// bindup
// file miscutil.h line 67
extern char * bindup(const char *string, unsigned long int len)
{
  char *duplicate;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(len);
  duplicate = (char *)return_value_malloc_1;
  if(!(duplicate == ((char *)NULL)))
    memcpy((void *)duplicate, (const void *)string, len);

  return duplicate;
}

// block_acl
// file filters.c line 242
extern signed int block_acl(struct access_control_addr *dst, struct client_state *csp)
{
  struct access_control_list *acl = csp->config->acl;
  _Bool tmp_if_expr_2;
  signed int return_value_match_sockaddr_1;
  if(acl == ((struct access_control_list *)NULL))
    return 0;

  else
  {
    while(!(acl == ((struct access_control_list *)NULL)))
    {
      signed int return_value_match_sockaddr_3;
      return_value_match_sockaddr_3=match_sockaddr(&acl->src[0l].addr, &acl->src[0l].mask, &csp->tcp_addr);
      if(!(return_value_match_sockaddr_3 == 0))
      {
        if(dst == ((struct access_control_addr *)NULL))
        {
          if((signed int)acl->action == 1)
            return 0;

          else
            return 1;
        }

        else
        {
          if(!(acl->wildcard_dst == 0))
            tmp_if_expr_2 = (_Bool)1;

          else
          {
            return_value_match_sockaddr_1=match_sockaddr(&acl->dst[0l].addr, &acl->dst[0l].mask, &dst->addr);
            tmp_if_expr_2 = return_value_match_sockaddr_1 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_2)
          {
            if((signed int)acl->action == 1)
              return 0;

            else
              return 1;
          }

        }
      }

      acl = acl->next;
    }
    return 1;
  }
}

// block_url
// file filters.c line 541
extern struct http_response * block_url(struct client_state *csp)
{
  struct http_response *rsp;
  const char *new_content_type = (const char *)(void *)0;
  _Bool tmp_if_expr_26;
  signed int return_value_is_imageurl_25;
  _Bool tmp_if_expr_12;
  signed int return_value_strcmpic_11;
  signed int return_value_strcmpic_10;
  _Bool tmp_if_expr_17;
  signed int return_value_strcmpic_16;
  char *return_value_html_encode_18;
  char *return_value_html_encode_19;
  char *return_value_url_encode_20;
  if((0x00000001UL & csp->action[0l].flags) == 0ul)
    return (struct http_response *)(void *)0;

  else
  {
    if(!((0x00020000UL & csp->action[0l].flags) == 0ul))
      log_error(0x2000, "redirect{} overruled by block.");

    rsp=alloc_http_response();
    if(rsp == ((struct http_response *)NULL))
    {
      struct http_response *return_value_cgi_error_memory_1;
      return_value_cgi_error_memory_1=cgi_error_memory();
      return return_value_cgi_error_memory_1;
    }

    if(!((0x00000200UL & csp->action[0l].flags) == 0ul))
    {
      return_value_is_imageurl_25=is_imageurl(csp);
      tmp_if_expr_26 = return_value_is_imageurl_25 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_26 = (_Bool)0;
    if(tmp_if_expr_26)
    {
      char *p = csp->action[0l].string[(signed long int)2];
      if(!((0x00008000UL & csp->action[0l].flags) == 0ul))
        log_error(0x2000, "handle-as-empty-document overruled by handle-as-image.");

      if(p == ((char *)NULL))
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        return_value_strcmpic_11=strcmpic(p, "pattern");
        tmp_if_expr_12 = 0 == return_value_strcmpic_11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12)
      {
        rsp->status=strdup_or_die("403 Request blocked by Privoxy");
        rsp->body=bindup(image_pattern_data, image_pattern_length);
        if(rsp->body == ((char *)NULL))
        {
          free_http_response(rsp);
          struct http_response *return_value_cgi_error_memory_2;
          return_value_cgi_error_memory_2=cgi_error_memory();
          return return_value_cgi_error_memory_2;
        }

        rsp->content_length = image_pattern_length;
        enum privoxy_err return_value_enlist_unique_header_4;
        return_value_enlist_unique_header_4=enlist_unique_header(rsp->headers, "Content-Type", "image/png");
        if(!(return_value_enlist_unique_header_4 == /*enum*/JB_ERR_OK))
        {
          free_http_response(rsp);
          struct http_response *return_value_cgi_error_memory_3;
          return_value_cgi_error_memory_3=cgi_error_memory();
          return return_value_cgi_error_memory_3;
        }

      }

      else
      {
        return_value_strcmpic_10=strcmpic(p, "blank");
        if(return_value_strcmpic_10 == 0)
        {
          rsp->status=strdup_or_die("403 Request blocked by Privoxy");
          rsp->body=bindup(image_blank_data, image_blank_length);
          if(rsp->body == ((char *)NULL))
          {
            free_http_response(rsp);
            struct http_response *return_value_cgi_error_memory_5;
            return_value_cgi_error_memory_5=cgi_error_memory();
            return return_value_cgi_error_memory_5;
          }

          rsp->content_length = image_blank_length;
          enum privoxy_err return_value_enlist_unique_header_7;
          return_value_enlist_unique_header_7=enlist_unique_header(rsp->headers, "Content-Type", "image/png");
          if(!(return_value_enlist_unique_header_7 == /*enum*/JB_ERR_OK))
          {
            free_http_response(rsp);
            struct http_response *return_value_cgi_error_memory_6;
            return_value_cgi_error_memory_6=cgi_error_memory();
            return return_value_cgi_error_memory_6;
          }

        }

        else
        {
          rsp->status=strdup_or_die("302 Local Redirect from Privoxy");
          enum privoxy_err return_value_enlist_unique_header_9;
          return_value_enlist_unique_header_9=enlist_unique_header(rsp->headers, "Location", p);
          if(!(return_value_enlist_unique_header_9 == /*enum*/JB_ERR_OK))
          {
            free_http_response(rsp);
            struct http_response *return_value_cgi_error_memory_8;
            return_value_cgi_error_memory_8=cgi_error_memory();
            return return_value_cgi_error_memory_8;
          }

        }
      }
    }

    else
      if(!((0x00008000UL & csp->action[0l].flags) == 0ul))
      {
        new_content_type = csp->action[0l].string[(signed long int)9];
        if(!(rsp->body == ((char *)NULL)))
        {
          free((void *)rsp->body);
          rsp->body = (char *)(void *)0;
        }

        rsp->body=strdup_or_die(" ");
        rsp->content_length = (unsigned long int)1;
        if(!((512U & csp->config->feature_flags) == 0u))
          rsp->status=strdup_or_die("200 Request blocked by Privoxy");

        else
          rsp->status=strdup_or_die("403 Request blocked by Privoxy");
        if(!(new_content_type == ((const char *)NULL)))
        {
          log_error(0x0008, "Overwriting Content-Type with %s", new_content_type);
          enum privoxy_err return_value_enlist_unique_header_14;
          return_value_enlist_unique_header_14=enlist_unique_header(rsp->headers, "Content-Type", new_content_type);
          if(!(return_value_enlist_unique_header_14 == /*enum*/JB_ERR_OK))
          {
            free_http_response(rsp);
            struct http_response *return_value_cgi_error_memory_13;
            return_value_cgi_error_memory_13=cgi_error_memory();
            return return_value_cgi_error_memory_13;
          }

        }

      }

      else
      {
        enum privoxy_err err;
        struct map *exports;
        rsp->status=strdup_or_die("403 Request blocked by Privoxy");
        exports=default_exports(csp, (const char *)(void *)0);
        if(exports == ((struct map *)NULL))
        {
          free_http_response(rsp);
          struct http_response *return_value_cgi_error_memory_15;
          return_value_cgi_error_memory_15=cgi_error_memory();
          return return_value_cgi_error_memory_15;
        }

        err=map(exports, "force-prefix", 1, "/PRIVOXY-FORCE", 1);
        if(!((32U & csp->config->feature_flags) == 0u))
          tmp_if_expr_17 = (_Bool)1;

        else
        {
          return_value_strcmpic_16=strcmpic(csp->http[0l].gpc, "connect");
          tmp_if_expr_17 = 0 == return_value_strcmpic_16 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_17)
          err=map_block_killer(exports, "force-support");

        if(err == /*enum*/JB_ERR_OK)
          err=map(exports, "protocol", 1, csp->http[0l].ssl != 0 ? "https://" : "http://", 1);

        if(err == /*enum*/JB_ERR_OK)
        {
          return_value_html_encode_18=html_encode(csp->http[0l].hostport);
          err=map(exports, "hostport", 1, return_value_html_encode_18, 0);
        }

        if(err == /*enum*/JB_ERR_OK)
        {
          return_value_html_encode_19=html_encode(csp->http[0l].path);
          err=map(exports, "path", 1, return_value_html_encode_19, 0);
        }

        if(err == /*enum*/JB_ERR_OK)
        {
          return_value_url_encode_20=url_encode(csp->http[0l].path);
          err=map(exports, "path-ue", 1, return_value_url_encode_20, 0);
        }

        if(err == /*enum*/JB_ERR_OK)
        {
          const char *block_reason;
          if(!(csp->action[0l].string[16l] == ((char *)NULL)))
            block_reason = csp->action[0l].string[(signed long int)16];

          else
          {
            signed int return_value_connect_port_is_forbidden_21;
            return_value_connect_port_is_forbidden_21=connect_port_is_forbidden(csp);
            /* assertion connect_port_is_forbidden(csp) */
            assert(return_value_connect_port_is_forbidden_21 != 0);
            block_reason = "Forbidden CONNECT port.";
          }
          char *return_value_html_encode_22;
          return_value_html_encode_22=html_encode(block_reason);
          err=map(exports, "block-reason", 1, return_value_html_encode_22, 0);
        }

        if(!(err == /*enum*/JB_ERR_OK))
        {
          free_map(exports);
          free_http_response(rsp);
          struct http_response *return_value_cgi_error_memory_23;
          return_value_cgi_error_memory_23=cgi_error_memory();
          return return_value_cgi_error_memory_23;
        }

        err=template_fill_for_cgi(csp, "blocked", exports, rsp);
        if(!(err == /*enum*/JB_ERR_OK))
        {
          free_http_response(rsp);
          struct http_response *return_value_cgi_error_memory_24;
          return_value_cgi_error_memory_24=cgi_error_memory();
          return return_value_cgi_error_memory_24;
        }

      }
    rsp->crunch_reason = (enum crunch_reason)BLOCKED;
    struct http_response *return_value_finish_http_response_27;
    return_value_finish_http_response_27=finish_http_response(csp, rsp);
    return return_value_finish_http_response_27;
  }
}

// buf_copy
// file deanimate.c line 135
static signed int buf_copy(struct binbuffer *src, struct binbuffer *dst, unsigned long int length)
{
  if(!(src->size >= src->offset + length))
    return 1;

  else
  {
    signed int return_value_buf_extend_1;
    return_value_buf_extend_1=buf_extend(dst, length);
    if(!(return_value_buf_extend_1 == 0))
      return 1;

    else
    {
      memcpy((void *)(dst->buffer + (signed long int)dst->offset), (const void *)(src->buffer + (signed long int)src->offset), length);
      src->offset = src->offset + length;
      dst->offset = dst->offset + length;
      return 0;
    }
  }
}

// buf_extend
// file deanimate.c line 94
static signed int buf_extend(struct binbuffer *buf, unsigned long int length)
{
  char *newbuf;
  if(!(buf->size >= buf->offset + length))
  {
    buf->size = buf->size + length + (unsigned long int)1023 & ~((unsigned long int)1023);
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)buf->buffer, buf->size);
    newbuf = (char *)return_value_realloc_1;
    if(newbuf == ((char *)NULL))
    {
      if(!(buf->buffer == ((char *)NULL)))
      {
        free((void *)buf->buffer);
        buf->buffer = (char *)(void *)0;
      }

      return 1;
    }

    else
    {
      buf->buffer = newbuf;
      return 0;
    }
  }

  return 0;
}

// buf_free
// file deanimate.c line 63
extern void buf_free(struct binbuffer *buf)
{
  if(!(buf == ((struct binbuffer *)NULL)))
  {
    if(!(buf->buffer == ((char *)NULL)))
      free((void *)buf->buffer);

    free((void *)buf);
  }

}

// buf_getbyte
// file deanimate.c line 181
static unsigned char buf_getbyte(struct binbuffer *src, unsigned long int offset)
{
  if(!(src->offset + offset >= src->size))
    return (unsigned char)(src->buffer + (signed long int)src->offset)[(signed long int)offset];

  else
    return (unsigned char)0;
}

// build_request_line
// file jcc.c line 888
static void build_request_line(struct client_state *csp, struct forward_spec *fwd, char **request_line)
{
  struct http_request *http = csp->http;
  /* assertion http->ssl == 0 */
  assert(http->ssl == 0);
  signed int return_value_strcmpic_1;
  if(!((0x00000004UL & csp->action[0l].flags) == 0ul))
  {
    return_value_strcmpic_1=strcmpic(http->ver, "HTTP/1.1");
    if(return_value_strcmpic_1 == 0)
    {
      if(!(http->ver == ((char *)NULL)))
      {
        free((void *)http->ver);
        http->ver = (char *)(void *)0;
      }

      http->ver=strdup_or_die("HTTP/1.0");
    }

  }

  if(!(*request_line == ((char *)NULL)))
  {
    free((void *)*request_line);
    *request_line = (char *)(void *)0;
  }

  *request_line=strdup(http->gpc);
  string_append(request_line, " ");
  _Bool tmp_if_expr_2;
  if(!(fwd->forward_host == ((char *)NULL)))
    tmp_if_expr_2 = (signed int)fwd->type != FORWARD_WEBSERVER ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    string_append(request_line, http->url);

  else
    string_append(request_line, http->path);
  string_append(request_line, " ");
  string_append(request_line, http->ver);
  if(*request_line == ((char *)NULL))
    log_error(0x4000, "Out of memory writing HTTP command");

  log_error(0x0008, "New HTTP Request-Line: %s", *request_line);
}

// cgi_default
// file cgisimple.h line 47
extern enum privoxy_err cgi_default(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  struct map *exports;
  (void)parameters;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  exports=default_exports(csp, "");
  if(exports == ((struct map *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    enum privoxy_err return_value_template_fill_for_cgi_1;
    return_value_template_fill_for_cgi_1=template_fill_for_cgi(csp, "default", exports, rsp);
    return return_value_template_fill_for_cgi_1;
  }
}

// cgi_edit_actions
// file cgiedit.h line 47
extern enum privoxy_err cgi_edit_actions(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  (void)parameters;
  if((1U & csp->config->feature_flags) == 0u)
  {
    enum privoxy_err return_value_cgi_error_disabled_1;
    return_value_cgi_error_disabled_1=cgi_error_disabled(csp, rsp);
    return return_value_cgi_error_disabled_1;
  }

  enum privoxy_err return_value_cgi_redirect_2;
  return_value_cgi_redirect_2=cgi_redirect(rsp, "http://config.privoxy.org/edit-actions-list?f=default");
  return return_value_cgi_redirect_2;
}

// cgi_edit_actions_add_url
// file cgiedit.h line 65
extern enum privoxy_err cgi_edit_actions_add_url(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  unsigned int sectionid;
  char *new_pattern;
  struct file_line *new_line;
  struct editable_file *file;
  struct file_line *cur_line;
  unsigned int line_number;
  char target[1024l];
  enum privoxy_err err;
  if((1U & csp->config->feature_flags) == 0u)
  {
    enum privoxy_err return_value_cgi_error_disabled_1;
    return_value_cgi_error_disabled_1=cgi_error_disabled(csp, rsp);
    return return_value_cgi_error_disabled_1;
  }

  err=get_number_param(csp, parameters, "s", &sectionid);
  _Bool tmp_if_expr_2;
  if(!(err == /*enum*/JB_ERR_OK))
    return err;

  else
    if(!(sectionid >= 1U))
      return (enum privoxy_err)JB_ERR_CGI_PARAMS;

    else
    {
      err=get_url_spec_param(csp, parameters, "u", &new_pattern);
      if(!(err == /*enum*/JB_ERR_OK))
        return err;

      else
      {
        err=edit_read_actions_file(csp, rsp, parameters, 1, &file);
        if(!(err == /*enum*/JB_ERR_OK))
        {
          free((void *)new_pattern);
          return (enum privoxy_err)((signed int)err == JB_ERR_FILE ? JB_ERR_OK : (signed int)err);
        }

        else
        {
          line_number = (unsigned int)1;
          cur_line = file->lines;
          for( ; !(cur_line == ((struct file_line *)NULL)) && !(line_number >= sectionid); line_number = line_number + 1u)
            cur_line = cur_line->next;
          if(cur_line == ((struct file_line *)NULL))
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = cur_line->type != 5 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_2)
          {
            free((void *)new_pattern);
            edit_free_file(file);
            return (enum privoxy_err)JB_ERR_CGI_PARAMS;
          }

          else
          {
            void *return_value_zalloc_3;
            return_value_zalloc_3=zalloc(sizeof(struct file_line) /*464ul*/ );
            new_line = (struct file_line *)return_value_zalloc_3;
            if(new_line == ((struct file_line *)NULL))
            {
              free((void *)new_pattern);
              edit_free_file(file);
              return (enum privoxy_err)JB_ERR_MEMORY;
            }

            else
            {
              new_line->raw = (char *)(void *)0;
              new_line->prefix = (char *)(void *)0;
              new_line->unprocessed = new_pattern;
              new_line->type = 6;
              new_line->next = cur_line->next;
              cur_line->next = new_line;
              err=edit_write_file(file);
              if(!(err == /*enum*/JB_ERR_OK))
              {
                if((signed int)err == JB_ERR_FILE)
                  err=cgi_error_file_read_only(csp, rsp, file->filename);

                edit_free_file(file);
                return err;
              }

              else
              {
                signed long int return_value_time_4;
                return_value_time_4=time((signed long int *)(void *)0);
                snprintf(target, sizeof(char [1024l]) /*1024ul*/ , "http://config.privoxy.org/edit-actions-list?foo=%lu&f=%i#l%u", (signed long int)return_value_time_4, file->identifier, sectionid);
                edit_free_file(file);
                enum privoxy_err return_value_cgi_redirect_5;
                return_value_cgi_redirect_5=cgi_redirect(rsp, target);
                return return_value_cgi_redirect_5;
              }
            }
          }
        }
      }
    }
}

// cgi_edit_actions_add_url_form
// file cgiedit.h line 68
extern enum privoxy_err cgi_edit_actions_add_url_form(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  struct map *exports;
  enum privoxy_err err;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  if((1U & csp->config->feature_flags) == 0u)
  {
    enum privoxy_err return_value_cgi_error_disabled_1;
    return_value_cgi_error_disabled_1=cgi_error_disabled(csp, rsp);
    return return_value_cgi_error_disabled_1;
  }

  exports=default_exports(csp, (const char *)(void *)0);
  if(exports == ((struct map *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    err=map_copy_parameter_html(exports, parameters, "f");
    if(err == /*enum*/JB_ERR_OK)
      err=map_copy_parameter_html(exports, parameters, "v");

    if(err == /*enum*/JB_ERR_OK)
      err=map_copy_parameter_html(exports, parameters, "s");

    if(!(err == /*enum*/JB_ERR_OK))
    {
      free_map(exports);
      return err;
    }

    else
    {
      enum privoxy_err return_value_template_fill_for_cgi_2;
      return_value_template_fill_for_cgi_2=template_fill_for_cgi(csp, "edit-actions-add-url-form", exports, rsp);
      return return_value_template_fill_for_cgi_2;
    }
  }
}

// cgi_edit_actions_for_url
// file cgiedit.h line 50
extern enum privoxy_err cgi_edit_actions_for_url(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  struct map *exports;
  unsigned int sectionid;
  struct editable_file *file;
  struct file_line *cur_line;
  unsigned int line_number;
  enum privoxy_err err;
  struct re_filterfile_spec *filter_group;
  signed int i;
  signed int have_filters = 0;
  if((1U & csp->config->feature_flags) == 0u)
  {
    enum privoxy_err return_value_cgi_error_disabled_1;
    return_value_cgi_error_disabled_1=cgi_error_disabled(csp, rsp);
    return return_value_cgi_error_disabled_1;
  }

  err=get_number_param(csp, parameters, "s", &sectionid);
  _Bool tmp_if_expr_2;
  const char *return_value_lookup_4;
  char *return_value_url_encode_5;
  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_9;
  signed int tmp_post_10;
  if(!(err == /*enum*/JB_ERR_OK))
    return err;

  else
  {
    err=edit_read_actions_file(csp, rsp, parameters, 1, &file);
    if(!(err == /*enum*/JB_ERR_OK))
      return (enum privoxy_err)((signed int)err == JB_ERR_FILE ? JB_ERR_OK : (signed int)err);

    else
    {
      cur_line = file->lines;
      line_number = (unsigned int)1;
      for( ; !(cur_line == ((struct file_line *)NULL)) && !(line_number >= sectionid); line_number = line_number + 1u)
        cur_line = cur_line->next;
      if(cur_line == ((struct file_line *)NULL) || !(line_number == sectionid) || !(sectionid >= 1u))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = cur_line->type != 5 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        edit_free_file(file);
        return (enum privoxy_err)JB_ERR_CGI_PARAMS;
      }

      else
      {
        exports=default_exports(csp, (const char *)(void *)0);
        if(exports == ((struct map *)NULL))
        {
          edit_free_file(file);
          return (enum privoxy_err)JB_ERR_MEMORY;
        }

        else
        {
          char *return_value_stringify_3;
          return_value_stringify_3=stringify(file->identifier);
          err=map(exports, "f", 1, return_value_stringify_3, 0);
          if(err == /*enum*/JB_ERR_OK)
            err=map(exports, "v", 1, file->version_str, 1);

          if(err == /*enum*/JB_ERR_OK)
          {
            return_value_lookup_4=lookup(parameters, "s");
            return_value_url_encode_5=url_encode(return_value_lookup_4);
            err=map(exports, "s", 1, return_value_url_encode_5, 0);
          }

          if(err == /*enum*/JB_ERR_OK)
            err=actions_to_radio(exports, cur_line->data.action);

          if(err == /*enum*/JB_ERR_OK)
            tmp_if_expr_6 = (csp->config->feature_flags & 8U) != 0u ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_6 = (_Bool)0;
          if(tmp_if_expr_6)
            err=map_block_killer(exports, "one-form-only");

          else
            err=map_block_killer(exports, "multiple-forms");
          i = 0;
          for( ; !(i >= 30); i = i + 1)
            if(!(csp->rlist[(signed long int)i] == ((struct file_list *)NULL)))
            {
              if(!(csp->rlist[(signed long int)i]->f == NULL))
              {
                if(err == /*enum*/JB_ERR_OK)
                  err=map_conditional(exports, "any-filters-defined", 1);

                have_filters = 1;
                break;
              }

            }

          if(!(err == /*enum*/JB_ERR_OK))
          {
            edit_free_file(file);
            free_map(exports);
            return err;
          }

          else
          {
            if(have_filters == 0)
              err=map(exports, "filter-params", 1, "", 1);

            else
            {
              char *filter_template;
              signed int filter_identifier = 0;
              char *prepared_templates[6l];
              i = 0;
              for( ; !(i >= 6); i = i + 1)
                prepared_templates[(signed long int)i]=strdup("");
              err=template_load(csp, &filter_template, "edit-actions-for-url-filter", 0);
              if(!(err == /*enum*/JB_ERR_OK))
              {
                edit_free_file(file);
                free_map(exports);
                if((signed int)err == JB_ERR_FILE)
                {
                  enum privoxy_err return_value_cgi_error_no_template_7;
                  return_value_cgi_error_no_template_7=cgi_error_no_template(csp, rsp, "edit-actions-for-url-filter");
                  return return_value_cgi_error_no_template_7;
                }

                return err;
              }

              err=template_fill(&filter_template, exports);
              i = 0;
              for( ; !(i >= 30); i = i + 1)
                if(!(csp->rlist[(signed long int)i] == ((struct file_list *)NULL)))
                {
                  if(!(csp->rlist[(signed long int)i]->f == NULL))
                  {
                    filter_group = (struct re_filterfile_spec *)csp->rlist[(signed long int)i]->f;
                    for( ; err == /*enum*/JB_ERR_OK && !(filter_group == ((struct re_filterfile_spec *)NULL)); filter_group = filter_group->next)
                    {
                      char current_mode = (char)120;
                      char number[20l];
                      struct list_entry *filter_name;
                      struct map *line_exports;
                      const signed int type = (const signed int)filter_group->type;
                      const signed int multi_action_index = filter_type_info[(signed long int)type].multi_action_index;
                      /* assertion type < 6 */
                      assert(type < 6);
                      filter_name = cur_line->data.action[0l].multi_add[(signed long int)multi_action_index][0l].first;
                      for( ; !(filter_name == ((struct list_entry *)NULL)); filter_name = filter_name->next)
                      {
                        return_value_strcmp_8=strcmp(filter_group->name, filter_name->str);
                        if(return_value_strcmp_8 == 0)
                          break;

                      }
                      if(!(filter_name == ((struct list_entry *)NULL)))
                        current_mode = (char)121;

                      else
                      {
                        filter_name = cur_line->data.action[0l].multi_remove[(signed long int)multi_action_index][0l].first;
                        for( ; !(filter_name == ((struct list_entry *)NULL)); filter_name = filter_name->next)
                        {
                          return_value_strcmp_9=strcmp(filter_group->name, filter_name->str);
                          if(return_value_strcmp_9 == 0)
                            break;

                        }
                        if(!(filter_name == ((struct list_entry *)NULL)))
                          current_mode = (char)110;

                      }
                      tmp_post_10 = filter_identifier;
                      filter_identifier = filter_identifier + 1;
                      snprintf(number, sizeof(char [20l]) /*20ul*/ , "%x", tmp_post_10);
                      number[(signed long int)(sizeof(char [20l]) /*20ul*/  - (unsigned long int)1)] = (char)0;
                      line_exports=new_map();
                      if(line_exports == ((struct map *)NULL))
                        err = (enum privoxy_err)JB_ERR_MEMORY;

                      else
                      {
                        char *filter_line;
                        if(err == /*enum*/JB_ERR_OK)
                          err=map(line_exports, "index", 1, number, 1);

                        if(err == /*enum*/JB_ERR_OK)
                          err=map(line_exports, "name", 1, filter_group->name, 1);

                        if(err == /*enum*/JB_ERR_OK)
                          err=map(line_exports, "description", 1, filter_group->description, 1);

                        if(err == /*enum*/JB_ERR_OK)
                          err=map_radio(line_exports, "this-filter", "ynx", (signed int)current_mode);

                        if(err == /*enum*/JB_ERR_OK)
                          err=map(line_exports, "filter-type", 1, filter_type_info[(signed long int)type].type, 1);

                        if(err == /*enum*/JB_ERR_OK)
                          err=map(line_exports, "abbr-filter-type", 1, filter_type_info[(signed long int)type].abbr_type, 1);

                        if(err == /*enum*/JB_ERR_OK)
                          err=map(line_exports, "anchor", 1, filter_type_info[(signed long int)type].anchor, 1);

                        if(err == /*enum*/JB_ERR_OK)
                        {
                          filter_line=strdup(filter_template);
                          if(filter_line == ((char *)NULL))
                            err = (enum privoxy_err)JB_ERR_MEMORY;

                        }

                        if(err == /*enum*/JB_ERR_OK)
                          err=template_fill(&filter_line, line_exports);

                        string_join(&prepared_templates[(signed long int)type], filter_line);
                        free_map(line_exports);
                      }
                    }
                  }

                }

              if(!(filter_template == ((char *)NULL)))
              {
                free((void *)filter_template);
                filter_template = (char *)(void *)0;
              }

              i = 0;
              for( ; !(i >= 6); i = i + 1)
              {
                if(err != /*enum*/JB_ERR_OK)
                  break;

                err=map(exports, filter_type_info[(signed long int)i].macro_name, 1, prepared_templates[(signed long int)i], 0);
              }
              if(!(err == /*enum*/JB_ERR_OK))
              {
                i = 0;
                for( ; !(i >= 6); i = i + 1)
                  if(!(prepared_templates[(signed long int)i] == ((char *)NULL)))
                  {
                    free((void *)prepared_templates[(signed long int)i]);
                    prepared_templates[(signed long int)i] = (char *)(void *)0;
                  }

              }

            }
            i = 0;
            for( ; !(i >= 6); i = i + 1)
            {
              const signed int a = filter_type_info[(signed long int)i].multi_action_index;
              const signed int disable_all = cur_line->data.action[0l].multi_remove_all[(signed long int)a];
              if(!(err == /*enum*/JB_ERR_OK))
                break;

              err=map_radio(exports, filter_type_info[(signed long int)i].disable_all_option, "nx", disable_all != 0 ? 110 : 120);
            }
            edit_free_file(file);
            if(!(err == /*enum*/JB_ERR_OK))
            {
              free_map(exports);
              return err;
            }

            else
            {
              enum privoxy_err return_value_template_fill_for_cgi_11;
              return_value_template_fill_for_cgi_11=template_fill_for_cgi(csp, "edit-actions-for-url", exports, rsp);
              return return_value_template_fill_for_cgi_11;
            }
          }
        }
      }
    }
  }
}

// cgi_edit_actions_list
// file cgiedit.h line 53
extern enum privoxy_err cgi_edit_actions_list(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  char *section_template;
  char *url_template;
  char *sections;
  char *urls;
  char buf[150l];
  char *s;
  struct map *exports;
  struct map *section_exports;
  struct map *url_exports;
  struct editable_file *file;
  struct file_line *cur_line;
  unsigned int line_number = (unsigned int)0;
  unsigned int prev_section_line_number = (unsigned int)-1;
  signed int i;
  signed int url_1_2;
  struct file_list *fl;
  struct url_actions *b;
  char *buttons = (char *)(void *)0;
  enum privoxy_err err;
  if((1U & csp->config->feature_flags) == 0u)
  {
    enum privoxy_err return_value_cgi_error_disabled_1;
    return_value_cgi_error_disabled_1=cgi_error_disabled(csp, rsp);
    return return_value_cgi_error_disabled_1;
  }

  exports=default_exports(csp, (const char *)(void *)0);
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_10;
  signed int return_value_strcmp_9;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_3;
  char *return_value_actions_to_html_5;
  char *return_value_html_encode_13;
  char *return_value_stringify_14;
  char *return_value_strstr_15;
  char *return_value_actions_to_html_18;
  _Bool tmp_if_expr_19;
  _Bool tmp_if_expr_20;
  char *return_value_html_encode_21;
  char *return_value_url_encode_22;
  _Bool tmp_if_expr_23;
  if(exports == ((struct map *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    err=edit_read_actions_file(csp, rsp, parameters, 0, &file);
    if(!(err == /*enum*/JB_ERR_OK))
    {
      free_map(exports);
      return (enum privoxy_err)((signed int)err == JB_ERR_FILE ? JB_ERR_OK : (signed int)err);
    }

    else
    {
      cur_line = file->lines;
      line_number = (unsigned int)1;
      for( ; !(cur_line == ((struct file_line *)NULL)); line_number = line_number + 1u)
      {
        if(cur_line->type == 5)
          break;

        cur_line = cur_line->next;
      }
      if(!(cur_line == ((struct file_line *)NULL)))
        tmp_if_expr_6 = cur_line->type == 5 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      if(tmp_if_expr_6)
        tmp_if_expr_7 = cur_line->next != (struct file_line *)(void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_7 = (_Bool)0;
      if(tmp_if_expr_7)
        tmp_if_expr_8 = cur_line->next->type == 6 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_8 = (_Bool)0;
      if(tmp_if_expr_8)
      {
        return_value_strcmp_9=strcmp(cur_line->next->unprocessed, "/");
        tmp_if_expr_10 = 0 == return_value_strcmp_9 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_10 = (_Bool)0;
      if(tmp_if_expr_10)
      {
        if(cur_line->next->next == ((struct file_line *)NULL))
          tmp_if_expr_11 = (_Bool)1;

        else
          tmp_if_expr_11 = cur_line->next->next->type != 6 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr_12 = tmp_if_expr_11 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_12 = (_Bool)0;
      if(tmp_if_expr_12)
      {
        err=template_load(csp, &section_template, "edit-actions-list-button", 0);
        if(!(err == /*enum*/JB_ERR_OK))
        {
          edit_free_file(file);
          free_map(exports);
          if((signed int)err == JB_ERR_FILE)
          {
            enum privoxy_err return_value_cgi_error_no_template_2;
            return_value_cgi_error_no_template_2=cgi_error_no_template(csp, rsp, "edit-actions-list-button");
            return return_value_cgi_error_no_template_2;
          }

          return err;
        }

        err=template_fill(&section_template, exports);
        if(!(err == /*enum*/JB_ERR_OK))
        {
          edit_free_file(file);
          free_map(exports);
          return err;
        }

        buttons=strdup("");
        i = 0;
        for( ; !(i >= 30); i = i + 1)
        {
          fl = csp->actions_list[(signed long int)i];
          if(!(fl == ((struct file_list *)NULL)))
          {
            b = (struct url_actions *)fl->f;
            if(!(b == ((struct url_actions *)NULL)))
            {
              b = b->next;
              for( ; !(b == ((struct url_actions *)NULL)); b = b->next)
              {
                signed int return_value_strncmp_4;
                return_value_strncmp_4=strncmp(b->url[0l].spec, "standard.", (unsigned long int)9);
                if(return_value_strncmp_4 == 0)
                {
                  if(!((signed int)b->url[0l].spec[9l] == 0))
                  {
                    if(!(err == /*enum*/JB_ERR_OK))
                    {
                      if(!(buttons == ((char *)NULL)))
                      {
                        free((void *)buttons);
                        buttons = (char *)(void *)0;
                      }

                      free((void *)section_template);
                      edit_free_file(file);
                      free_map(exports);
                      return (enum privoxy_err)JB_ERR_MEMORY;
                    }

                    section_exports=new_map();
                    err=map(section_exports, "button-name", 1, b->url[0l].spec + (signed long int)9, 1);
                    if(!(err == /*enum*/JB_ERR_OK))
                      tmp_if_expr_3 = (_Bool)1;

                    else
                    {
                      s=strdup(section_template);
                      tmp_if_expr_3 = (char *)(void *)0 == s ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr_3)
                    {
                      free_map(section_exports);
                      if(!(buttons == ((char *)NULL)))
                      {
                        free((void *)buttons);
                        buttons = (char *)(void *)0;
                      }

                      free((void *)section_template);
                      edit_free_file(file);
                      free_map(exports);
                      return (enum privoxy_err)JB_ERR_MEMORY;
                    }

                    if(err == /*enum*/JB_ERR_OK)
                      err=template_fill(&s, section_exports);

                    free_map(section_exports);
                    if(err == /*enum*/JB_ERR_OK)
                      err=string_join(&buttons, s);

                  }

                }

              }
            }

          }

        }
        if(!(section_template == ((char *)NULL)))
        {
          free((void *)section_template);
          section_template = (char *)(void *)0;
        }

        if(err == /*enum*/JB_ERR_OK)
          err=map(exports, "all-urls-buttons", 1, buttons, 0);

        if(err == /*enum*/JB_ERR_OK)
          err=map_conditional(exports, "all-urls-present", 1);

        snprintf(buf, sizeof(char [150l]) /*150ul*/ , "%u", line_number);
        if(err == /*enum*/JB_ERR_OK)
          err=map(exports, "all-urls-s", 1, buf, 1);

        snprintf(buf, sizeof(char [150l]) /*150ul*/ , "%u", line_number + (unsigned int)2);
        if(err == /*enum*/JB_ERR_OK)
          err=map(exports, "all-urls-s-next", 1, buf, 1);

        if(err == /*enum*/JB_ERR_OK)
        {
          return_value_actions_to_html_5=actions_to_html(csp, cur_line->data.action);
          err=map(exports, "all-urls-actions", 1, return_value_actions_to_html_5, 0);
        }

        cur_line = cur_line->next->next;
        line_number = line_number + (unsigned int)2;
      }

      else
        if(err == /*enum*/JB_ERR_OK)
          err=map_conditional(exports, "all-urls-present", 0);

      if(err == /*enum*/JB_ERR_OK)
      {
        return_value_html_encode_13=html_encode(file->filename);
        err=map(exports, "actions-file", 1, return_value_html_encode_13, 0);
      }

      if(err == /*enum*/JB_ERR_OK)
      {
        return_value_stringify_14=stringify(file->identifier);
        err=map(exports, "f", 1, return_value_stringify_14, 0);
      }

      if(err == /*enum*/JB_ERR_OK)
        err=map(exports, "v", 1, file->version_str, 1);

      if(err == /*enum*/JB_ERR_OK)
      {
        return_value_strstr_15=strstr("default.action", file->filename);
        err=map_conditional(exports, "default-action", (signed int)(return_value_strstr_15 != (char *)(void *)0));
      }

      if(!(err == /*enum*/JB_ERR_OK))
      {
        edit_free_file(file);
        free_map(exports);
        return err;
      }

      else
      {
        err=template_load(csp, &section_template, "edit-actions-list-section", 0);
        if(!(err == /*enum*/JB_ERR_OK))
        {
          edit_free_file(file);
          free_map(exports);
          if((signed int)err == JB_ERR_FILE)
          {
            enum privoxy_err return_value_cgi_error_no_template_16;
            return_value_cgi_error_no_template_16=cgi_error_no_template(csp, rsp, "edit-actions-list-section");
            return return_value_cgi_error_no_template_16;
          }

          return err;
        }

        else
        {
          err=template_load(csp, &url_template, "edit-actions-list-url", 0);
          if(!(err == /*enum*/JB_ERR_OK))
          {
            free((void *)section_template);
            edit_free_file(file);
            free_map(exports);
            if((signed int)err == JB_ERR_FILE)
            {
              enum privoxy_err return_value_cgi_error_no_template_17;
              return_value_cgi_error_no_template_17=cgi_error_no_template(csp, rsp, "edit-actions-list-url");
              return return_value_cgi_error_no_template_17;
            }

            return err;
          }

          else
          {
            err=template_fill(&section_template, exports);
            if(!(err == /*enum*/JB_ERR_OK))
            {
              free((void *)url_template);
              edit_free_file(file);
              free_map(exports);
              return err;
            }

            else
            {
              err=template_fill(&url_template, exports);
              if(!(err == /*enum*/JB_ERR_OK))
              {
                free((void *)section_template);
                edit_free_file(file);
                free_map(exports);
                return err;
              }

              else
              {
                sections=strdup("");
                if(sections == ((char *)NULL))
                {
                  free((void *)section_template);
                  free((void *)url_template);
                  edit_free_file(file);
                  free_map(exports);
                  return (enum privoxy_err)JB_ERR_MEMORY;
                }

                else
                {
                  while(!(cur_line == ((struct file_line *)NULL)))
                  {
                    if(!(cur_line->type == 5))
                      break;

                    section_exports=new_map();
                    snprintf(buf, sizeof(char [150l]) /*150ul*/ , "%u", line_number);
                    err=map(section_exports, "s", 1, buf, 1);
                    if(err == /*enum*/JB_ERR_OK)
                    {
                      return_value_actions_to_html_18=actions_to_html(csp, cur_line->data.action);
                      err=map(section_exports, "actions", 1, return_value_actions_to_html_18, 0);
                    }

                    if(err == /*enum*/JB_ERR_OK)
                      tmp_if_expr_19 = cur_line->next != (struct file_line *)(void *)0 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_19 = (_Bool)0;
                    if(tmp_if_expr_19)
                      tmp_if_expr_20 = cur_line->next->type == 6 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_20 = (_Bool)0;
                    if(tmp_if_expr_20)
                      err=map_block_killer(section_exports, "empty-section");

                    else
                      if(err == /*enum*/JB_ERR_OK)
                        err=map_block_keep(section_exports, "empty-section");

                    if(!(prev_section_line_number == 4294967295u))
                    {
                      snprintf(buf, sizeof(char [150l]) /*150ul*/ , "%u", prev_section_line_number);
                      if(err == /*enum*/JB_ERR_OK)
                        err=map(section_exports, "s-prev", 1, buf, 1);

                      if(err == /*enum*/JB_ERR_OK)
                        err=map_block_keep(section_exports, "s-prev-exists");

                    }

                    else
                      if(err == /*enum*/JB_ERR_OK)
                        err=map_block_killer(section_exports, "s-prev-exists");

                    prev_section_line_number = line_number;
                    if(!(err == /*enum*/JB_ERR_OK))
                    {
                      free((void *)sections);
                      free((void *)section_template);
                      free((void *)url_template);
                      edit_free_file(file);
                      free_map(exports);
                      free_map(section_exports);
                      return err;
                    }

                    urls=strdup("");
                    if(urls == ((char *)NULL))
                    {
                      free((void *)sections);
                      free((void *)section_template);
                      free((void *)url_template);
                      edit_free_file(file);
                      free_map(exports);
                      free_map(section_exports);
                      return (enum privoxy_err)JB_ERR_MEMORY;
                    }

                    url_1_2 = 2;
                    cur_line = cur_line->next;
                    line_number = line_number + 1u;
                    while(!(cur_line == ((struct file_line *)NULL)))
                    {
                      if(!(cur_line->type == 6))
                        break;

                      url_exports=new_map();
                      snprintf(buf, sizeof(char [150l]) /*150ul*/ , "%u", line_number);
                      err=map(url_exports, "p", 1, buf, 1);
                      snprintf(buf, sizeof(char [150l]) /*150ul*/ , "%d", url_1_2);
                      if(err == /*enum*/JB_ERR_OK)
                        err=map(url_exports, "url-1-2", 1, buf, 1);

                      if(err == /*enum*/JB_ERR_OK)
                      {
                        return_value_html_encode_21=html_encode(cur_line->unprocessed);
                        err=map(url_exports, "url-html", 1, return_value_html_encode_21, 0);
                      }

                      if(err == /*enum*/JB_ERR_OK)
                      {
                        return_value_url_encode_22=url_encode(cur_line->unprocessed);
                        err=map(url_exports, "url", 1, return_value_url_encode_22, 0);
                      }

                      if(!(err == /*enum*/JB_ERR_OK))
                      {
                        free((void *)urls);
                        free((void *)sections);
                        free((void *)section_template);
                        free((void *)url_template);
                        edit_free_file(file);
                        free_map(exports);
                        free_map(section_exports);
                        free_map(url_exports);
                        return err;
                      }

                      s=strdup(url_template);
                      if(s == ((char *)NULL))
                      {
                        free((void *)urls);
                        free((void *)sections);
                        free((void *)section_template);
                        free((void *)url_template);
                        edit_free_file(file);
                        free_map(exports);
                        free_map(section_exports);
                        free_map(url_exports);
                        return (enum privoxy_err)JB_ERR_MEMORY;
                      }

                      err=template_fill(&s, section_exports);
                      if(err == /*enum*/JB_ERR_OK)
                        err=template_fill(&s, url_exports);

                      if(err == /*enum*/JB_ERR_OK)
                        err=string_append(&urls, s);

                      free_map(url_exports);
                      if(!(s == ((char *)NULL)))
                      {
                        free((void *)s);
                        s = (char *)(void *)0;
                      }

                      if(!(err == /*enum*/JB_ERR_OK))
                      {
                        if(!(urls == ((char *)NULL)))
                        {
                          free((void *)urls);
                          urls = (char *)(void *)0;
                        }

                        free((void *)sections);
                        free((void *)section_template);
                        free((void *)url_template);
                        edit_free_file(file);
                        free_map(exports);
                        free_map(section_exports);
                        return err;
                      }

                      url_1_2 = 3 - url_1_2;
                      cur_line = cur_line->next;
                      line_number = line_number + 1u;
                    }
                    err=map(section_exports, "urls", 1, urls, 0);
                    snprintf(buf, sizeof(char [150l]) /*150ul*/ , "%u", line_number);
                    if(err == /*enum*/JB_ERR_OK)
                      err=map(section_exports, "s-next", 1, buf, 1);

                    if(!(cur_line == ((struct file_line *)NULL)))
                      tmp_if_expr_23 = cur_line->type == 5 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_23 = (_Bool)0;
                    if(tmp_if_expr_23)
                    {
                      if(err == /*enum*/JB_ERR_OK)
                        err=map_block_keep(section_exports, "s-next-exists");

                    }

                    else
                      if(err == /*enum*/JB_ERR_OK)
                        err=map_block_killer(section_exports, "s-next-exists");

                    if(!(err == /*enum*/JB_ERR_OK))
                    {
                      free((void *)sections);
                      free((void *)section_template);
                      free((void *)url_template);
                      edit_free_file(file);
                      free_map(exports);
                      free_map(section_exports);
                      return err;
                    }

                    s=strdup(section_template);
                    if(s == ((char *)NULL))
                    {
                      free((void *)sections);
                      free((void *)section_template);
                      free((void *)url_template);
                      edit_free_file(file);
                      free_map(exports);
                      free_map(section_exports);
                      return (enum privoxy_err)JB_ERR_MEMORY;
                    }

                    err=template_fill(&s, section_exports);
                    if(err == /*enum*/JB_ERR_OK)
                      err=string_append(&sections, s);

                    if(!(s == ((char *)NULL)))
                    {
                      free((void *)s);
                      s = (char *)(void *)0;
                    }

                    free_map(section_exports);
                    if(!(err == /*enum*/JB_ERR_OK))
                    {
                      if(!(sections == ((char *)NULL)))
                      {
                        free((void *)sections);
                        sections = (char *)(void *)0;
                      }

                      free((void *)section_template);
                      free((void *)url_template);
                      edit_free_file(file);
                      free_map(exports);
                      return err;
                    }

                  }
                  edit_free_file(file);
                  free((void *)section_template);
                  free((void *)url_template);
                  err=map(exports, "sections", 1, sections, 0);
                  if(!(err == /*enum*/JB_ERR_OK))
                  {
                    free_map(exports);
                    return err;
                  }

                  else
                  {
                    enum privoxy_err return_value_template_fill_for_cgi_24;
                    return_value_template_fill_for_cgi_24=template_fill_for_cgi(csp, "edit-actions-list", exports, rsp);
                    return return_value_template_fill_for_cgi_24;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// cgi_edit_actions_remove_url
// file cgiedit.h line 71
extern enum privoxy_err cgi_edit_actions_remove_url(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  unsigned int patternid;
  struct editable_file *file;
  struct file_line *cur_line;
  struct file_line *prev_line;
  unsigned int line_number;
  unsigned int section_start_line_number = (unsigned int)0;
  char target[1024l];
  enum privoxy_err err;
  if((1U & csp->config->feature_flags) == 0u)
  {
    enum privoxy_err return_value_cgi_error_disabled_1;
    return_value_cgi_error_disabled_1=cgi_error_disabled(csp, rsp);
    return return_value_cgi_error_disabled_1;
  }

  err=get_number_param(csp, parameters, "p", &patternid);
  _Bool tmp_if_expr_2;
  if(!(err == /*enum*/JB_ERR_OK))
    return err;

  else
  {
    err=edit_read_actions_file(csp, rsp, parameters, 1, &file);
    if(!(err == /*enum*/JB_ERR_OK))
      return (enum privoxy_err)((signed int)err == JB_ERR_FILE ? JB_ERR_OK : (signed int)err);

    else
    {
      line_number = (unsigned int)1;
      prev_line = (struct file_line *)(void *)0;
      cur_line = file->lines;
      for( ; !(cur_line == ((struct file_line *)NULL)) && !(line_number >= patternid); line_number = line_number + 1u)
      {
        if(cur_line->type == 5)
          section_start_line_number = line_number;

        prev_line = cur_line;
        cur_line = cur_line->next;
      }
      if(cur_line == ((struct file_line *)NULL) || prev_line == ((struct file_line *)NULL))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = cur_line->type != 6 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        edit_free_file(file);
        return (enum privoxy_err)JB_ERR_CGI_PARAMS;
      }

      else
      {
        prev_line->next = cur_line->next;
        cur_line->next = (struct file_line *)(void *)0;
        edit_free_file_lines(cur_line);
        err=edit_write_file(file);
        if(!(err == /*enum*/JB_ERR_OK))
        {
          if((signed int)err == JB_ERR_FILE)
            err=cgi_error_file_read_only(csp, rsp, file->filename);

          edit_free_file(file);
          return err;
        }

        else
        {
          signed long int return_value_time_3;
          return_value_time_3=time((signed long int *)(void *)0);
          snprintf(target, sizeof(char [1024l]) /*1024ul*/ , "http://config.privoxy.org/edit-actions-list?foo=%lu&f=%u#l%u", (signed long int)return_value_time_3, file->identifier, section_start_line_number);
          edit_free_file(file);
          enum privoxy_err return_value_cgi_redirect_4;
          return_value_cgi_redirect_4=cgi_redirect(rsp, target);
          return return_value_cgi_redirect_4;
        }
      }
    }
  }
}

// cgi_edit_actions_remove_url_form
// file cgiedit.h line 74
extern enum privoxy_err cgi_edit_actions_remove_url_form(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  struct map *exports;
  unsigned int patternid;
  struct editable_file *file;
  struct file_line *cur_line;
  unsigned int line_number;
  unsigned int section_start_line_number = (unsigned int)0;
  enum privoxy_err err;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  if((1U & csp->config->feature_flags) == 0u)
  {
    enum privoxy_err return_value_cgi_error_disabled_1;
    return_value_cgi_error_disabled_1=cgi_error_disabled(csp, rsp);
    return return_value_cgi_error_disabled_1;
  }

  err=get_number_param(csp, parameters, "p", &patternid);
  _Bool tmp_if_expr_2;
  const char *return_value_lookup_4;
  char *return_value_url_encode_5;
  char *return_value_html_encode_6;
  char *return_value_section_target_7;
  char *return_value_html_encode_8;
  if(!(err == /*enum*/JB_ERR_OK))
    return err;

  else
  {
    err=edit_read_actions_file(csp, rsp, parameters, 1, &file);
    if(!(err == /*enum*/JB_ERR_OK))
      return (enum privoxy_err)((signed int)err == JB_ERR_FILE ? JB_ERR_OK : (signed int)err);

    else
    {
      cur_line = file->lines;
      line_number = (unsigned int)1;
      for( ; !(cur_line == ((struct file_line *)NULL)) && !(line_number >= patternid); line_number = line_number + 1u)
      {
        if(cur_line->type == 5)
          section_start_line_number = line_number;

        cur_line = cur_line->next;
      }
      if(cur_line == ((struct file_line *)NULL) || !(line_number == patternid) || !(patternid >= 1U))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = cur_line->type != 6 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        edit_free_file(file);
        return (enum privoxy_err)JB_ERR_CGI_PARAMS;
      }

      else
      {
        exports=default_exports(csp, (const char *)(void *)0);
        if(exports == ((struct map *)NULL))
        {
          edit_free_file(file);
          return (enum privoxy_err)JB_ERR_MEMORY;
        }

        else
        {
          char *return_value_stringify_3;
          return_value_stringify_3=stringify(file->identifier);
          err=map(exports, "f", 1, return_value_stringify_3, 0);
          if(err == /*enum*/JB_ERR_OK)
            err=map(exports, "v", 1, file->version_str, 1);

          if(err == /*enum*/JB_ERR_OK)
          {
            return_value_lookup_4=lookup(parameters, "p");
            return_value_url_encode_5=url_encode(return_value_lookup_4);
            err=map(exports, "p", 1, return_value_url_encode_5, 0);
          }

          if(err == /*enum*/JB_ERR_OK)
          {
            return_value_html_encode_6=html_encode(cur_line->unprocessed);
            err=map(exports, "u", 1, return_value_html_encode_6, 0);
          }

          if(err == /*enum*/JB_ERR_OK)
          {
            return_value_section_target_7=section_target(section_start_line_number);
            err=map(exports, "jumptarget", 1, return_value_section_target_7, 0);
          }

          if(err == /*enum*/JB_ERR_OK)
          {
            return_value_html_encode_8=html_encode(file->filename);
            err=map(exports, "actions-file", 1, return_value_html_encode_8, 0);
          }

          edit_free_file(file);
          if(!(err == /*enum*/JB_ERR_OK))
          {
            free_map(exports);
            return err;
          }

          else
          {
            enum privoxy_err return_value_template_fill_for_cgi_9;
            return_value_template_fill_for_cgi_9=template_fill_for_cgi(csp, "edit-actions-remove-url-form", exports, rsp);
            return return_value_template_fill_for_cgi_9;
          }
        }
      }
    }
  }
}

// cgi_edit_actions_section_add
// file cgiedit.h line 80
extern enum privoxy_err cgi_edit_actions_section_add(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  unsigned int sectionid;
  struct file_line *new_line;
  char *new_text;
  struct editable_file *file;
  struct file_line *cur_line;
  unsigned int line_number;
  char target[1024l];
  enum privoxy_err err;
  if((1U & csp->config->feature_flags) == 0u)
  {
    enum privoxy_err return_value_cgi_error_disabled_1;
    return_value_cgi_error_disabled_1=cgi_error_disabled(csp, rsp);
    return return_value_cgi_error_disabled_1;
  }

  err=get_number_param(csp, parameters, "s", &sectionid);
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if(!(err == /*enum*/JB_ERR_OK))
    return err;

  else
  {
    err=edit_read_actions_file(csp, rsp, parameters, 1, &file);
    if(!(err == /*enum*/JB_ERR_OK))
      return (enum privoxy_err)((signed int)err == JB_ERR_FILE ? JB_ERR_OK : (signed int)err);

    else
    {
      line_number = (unsigned int)1;
      cur_line = file->lines;
      if(!(sectionid >= 2u))
      {
        if(!(cur_line == ((struct file_line *)NULL)))
          tmp_if_expr_2 = cur_line->type != 5 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          for( ; !(cur_line->next == ((struct file_line *)NULL)); line_number = line_number + 1u)
          {
            if(cur_line->next->type == 5)
              break;

            cur_line = cur_line->next;
          }

        else
          cur_line = (struct file_line *)(void *)0;
      }

      else
      {
        for( ; !(cur_line == ((struct file_line *)NULL)) && !(line_number >= sectionid); line_number = line_number + 1u)
          cur_line = cur_line->next;
        if(cur_line == ((struct file_line *)NULL))
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = cur_line->type != 5 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_3)
        {
          edit_free_file(file);
          return (enum privoxy_err)JB_ERR_CGI_PARAMS;
        }

        for( ; !(cur_line->next == ((struct file_line *)NULL)); line_number = line_number + 1u)
        {
          if(cur_line->next->type == 5)
            break;

          cur_line = cur_line->next;
        }
      }
      new_text=strdup("{}");
      if(new_text == ((char *)NULL))
      {
        edit_free_file(file);
        return (enum privoxy_err)JB_ERR_MEMORY;
      }

      else
      {
        void *return_value_zalloc_4;
        return_value_zalloc_4=zalloc(sizeof(struct file_line) /*464ul*/ );
        new_line = (struct file_line *)return_value_zalloc_4;
        if(new_line == ((struct file_line *)NULL))
        {
          free((void *)new_text);
          edit_free_file(file);
          return (enum privoxy_err)JB_ERR_MEMORY;
        }

        else
        {
          new_line->raw = (char *)(void *)0;
          new_line->prefix = (char *)(void *)0;
          new_line->unprocessed = new_text;
          new_line->type = 5;
          if(!(cur_line == ((struct file_line *)NULL)))
          {
            new_line->next = cur_line->next;
            cur_line->next = new_line;
          }

          else
          {
            new_line->next = file->lines;
            file->lines = new_line;
          }
          err=edit_write_file(file);
          if(!(err == /*enum*/JB_ERR_OK))
          {
            if((signed int)err == JB_ERR_FILE)
              err=cgi_error_file_read_only(csp, rsp, file->filename);

            edit_free_file(file);
            return err;
          }

          else
          {
            signed long int return_value_time_5;
            return_value_time_5=time((signed long int *)(void *)0);
            snprintf(target, sizeof(char [1024l]) /*1024ul*/ , "http://config.privoxy.org/edit-actions-list?foo=%lu&f=%u", (signed long int)return_value_time_5, file->identifier);
            edit_free_file(file);
            enum privoxy_err return_value_cgi_redirect_6;
            return_value_cgi_redirect_6=cgi_redirect(rsp, target);
            return return_value_cgi_redirect_6;
          }
        }
      }
    }
  }
}

// cgi_edit_actions_section_remove
// file cgiedit.h line 77
extern enum privoxy_err cgi_edit_actions_section_remove(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  unsigned int sectionid;
  struct editable_file *file;
  struct file_line *cur_line;
  struct file_line *prev_line;
  unsigned int line_number;
  char target[1024l];
  enum privoxy_err err;
  if((1U & csp->config->feature_flags) == 0u)
  {
    enum privoxy_err return_value_cgi_error_disabled_1;
    return_value_cgi_error_disabled_1=cgi_error_disabled(csp, rsp);
    return return_value_cgi_error_disabled_1;
  }

  err=get_number_param(csp, parameters, "s", &sectionid);
  _Bool tmp_if_expr_2;
  if(!(err == /*enum*/JB_ERR_OK))
    return err;

  else
  {
    err=edit_read_actions_file(csp, rsp, parameters, 1, &file);
    if(!(err == /*enum*/JB_ERR_OK))
      return (enum privoxy_err)((signed int)err == JB_ERR_FILE ? JB_ERR_OK : (signed int)err);

    else
    {
      line_number = (unsigned int)1;
      cur_line = file->lines;
      prev_line = (struct file_line *)(void *)0;
      for( ; !(cur_line == ((struct file_line *)NULL)) && !(line_number >= sectionid); line_number = line_number + 1u)
      {
        prev_line = cur_line;
        cur_line = cur_line->next;
      }
      if(cur_line == ((struct file_line *)NULL))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = cur_line->type != 5 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        edit_free_file(file);
        return (enum privoxy_err)JB_ERR_CGI_PARAMS;
      }

      else
        if(!(cur_line->next == ((struct file_line *)NULL)))
        {
          if(!(cur_line->next->type == 6))
            goto __CPROVER_DUMP_L9;

          edit_free_file(file);
          return (enum privoxy_err)JB_ERR_CGI_PARAMS;
        }

        else
        {

        __CPROVER_DUMP_L9:
          ;
          if(prev_line == ((struct file_line *)NULL))
            file->lines = cur_line->next;

          else
            prev_line->next = cur_line->next;
          cur_line->next = (struct file_line *)(void *)0;
          edit_free_file_lines(cur_line);
          err=edit_write_file(file);
          if(!(err == /*enum*/JB_ERR_OK))
          {
            if((signed int)err == JB_ERR_FILE)
              err=cgi_error_file_read_only(csp, rsp, file->filename);

            edit_free_file(file);
            return err;
          }

          else
          {
            signed long int return_value_time_3;
            return_value_time_3=time((signed long int *)(void *)0);
            snprintf(target, sizeof(char [1024l]) /*1024ul*/ , "http://config.privoxy.org/edit-actions-list?foo=%lu&f=%u", (signed long int)return_value_time_3, file->identifier);
            edit_free_file(file);
            enum privoxy_err return_value_cgi_redirect_4;
            return_value_cgi_redirect_4=cgi_redirect(rsp, target);
            return return_value_cgi_redirect_4;
          }
        }
    }
  }
}

// cgi_edit_actions_section_swap
// file cgiedit.h line 83
extern enum privoxy_err cgi_edit_actions_section_swap(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  unsigned int section1;
  unsigned int section2;
  struct editable_file *file;
  struct file_line *cur_line;
  struct file_line *prev_line;
  struct file_line *line_before_section1;
  struct file_line *line_start_section1;
  struct file_line *line_end_section1;
  struct file_line *line_after_section1;
  struct file_line *line_before_section2;
  struct file_line *line_start_section2;
  struct file_line *line_end_section2;
  struct file_line *line_after_section2;
  unsigned int line_number;
  char target[1024l];
  enum privoxy_err err;
  if((1U & csp->config->feature_flags) == 0u)
  {
    enum privoxy_err return_value_cgi_error_disabled_1;
    return_value_cgi_error_disabled_1=cgi_error_disabled(csp, rsp);
    return return_value_cgi_error_disabled_1;
  }

  err=get_number_param(csp, parameters, "s1", &section1);
  if(err == /*enum*/JB_ERR_OK)
    err=get_number_param(csp, parameters, "s2", &section2);

  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(!(err == /*enum*/JB_ERR_OK))
    return err;

  else
  {
    if(!(section2 >= section1))
    {
      unsigned int temp = section2;
      section2 = section1;
      section1 = temp;
    }

    err=edit_read_actions_file(csp, rsp, parameters, 1, &file);
    if(!(err == /*enum*/JB_ERR_OK))
      return (enum privoxy_err)((signed int)err == JB_ERR_FILE ? JB_ERR_OK : (signed int)err);

    else
    {
      line_number = (unsigned int)1;
      cur_line = file->lines;
      prev_line = (struct file_line *)(void *)0;
      for( ; !(cur_line == ((struct file_line *)NULL)) && !(line_number >= section1); line_number = line_number + 1u)
      {
        prev_line = cur_line;
        cur_line = cur_line->next;
      }
      if(cur_line == ((struct file_line *)NULL))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = cur_line->type != 5 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        edit_free_file(file);
        return (enum privoxy_err)JB_ERR_CGI_PARAMS;
      }

      else
        if(!(section1 == section2))
        {
          line_before_section1 = prev_line;
          line_start_section1 = cur_line;
          do
          {
            prev_line = cur_line;
            cur_line = cur_line->next;
            line_number = line_number + 1u;
            if(!(cur_line == ((struct file_line *)NULL)))
              tmp_if_expr_3 = cur_line->type == 6 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_3 = (_Bool)0;
          }
          while(tmp_if_expr_3);
          line_end_section1 = prev_line;
          line_after_section1 = cur_line;
          for( ; !(cur_line == ((struct file_line *)NULL)) && !(line_number >= section2); line_number = line_number + 1u)
          {
            prev_line = cur_line;
            cur_line = cur_line->next;
          }
          if(cur_line == ((struct file_line *)NULL))
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = cur_line->type != 5 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_4)
          {
            edit_free_file(file);
            return (enum privoxy_err)JB_ERR_CGI_PARAMS;
          }

          line_before_section2 = prev_line;
          line_start_section2 = cur_line;
          do
          {
            prev_line = cur_line;
            cur_line = cur_line->next;
            line_number = line_number + 1u;
            if(!(cur_line == ((struct file_line *)NULL)))
              tmp_if_expr_5 = cur_line->type == 6 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_5 = (_Bool)0;
          }
          while(tmp_if_expr_5);
          line_end_section2 = prev_line;
          line_after_section2 = cur_line;
          if(line_before_section1 == ((struct file_line *)NULL))
            file->lines = line_start_section2;

          else
            line_before_section1->next = line_start_section2;
          if(line_before_section2 == line_end_section1)
            line_end_section2->next = line_start_section1;

          else
          {
            line_end_section2->next = line_after_section1;
            line_before_section2->next = line_start_section1;
          }
          line_end_section1->next = line_after_section2;
          err=edit_write_file(file);
          if(err == /*enum*/JB_ERR_OK)
            goto __CPROVER_DUMP_L27;

          if((signed int)err == JB_ERR_FILE)
            err=cgi_error_file_read_only(csp, rsp, file->filename);

          edit_free_file(file);
          return err;
        }

        else
        {

        __CPROVER_DUMP_L27:
          ;
          signed long int return_value_time_6;
          return_value_time_6=time((signed long int *)(void *)0);
          snprintf(target, sizeof(char [1024l]) /*1024ul*/ , "http://config.privoxy.org/edit-actions-list?foo=%lu&f=%u", (signed long int)return_value_time_6, file->identifier);
          edit_free_file(file);
          enum privoxy_err return_value_cgi_redirect_7;
          return_value_cgi_redirect_7=cgi_redirect(rsp, target);
          return return_value_cgi_redirect_7;
        }
    }
  }
}

// cgi_edit_actions_submit
// file cgiedit.h line 56
extern enum privoxy_err cgi_edit_actions_submit(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  unsigned int sectionid;
  char *actiontext;
  char *newtext;
  unsigned long int newtext_size;
  unsigned long int len;
  struct editable_file *file;
  struct file_line *cur_line;
  unsigned int line_number;
  char target[1024l];
  enum privoxy_err err;
  signed int filter_identifier;
  signed int i;
  const char *action_set_name;
  struct file_list *fl;
  struct url_actions *b;
  if((1U & csp->config->feature_flags) == 0u)
  {
    enum privoxy_err return_value_cgi_error_disabled_1;
    return_value_cgi_error_disabled_1=cgi_error_disabled(csp, rsp);
    return return_value_cgi_error_disabled_1;
  }

  err=get_number_param(csp, parameters, "s", &sectionid);
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_3;
  if(!(err == /*enum*/JB_ERR_OK))
    return err;

  else
  {
    err=edit_read_actions_file(csp, rsp, parameters, 1, &file);
    if(!(err == /*enum*/JB_ERR_OK))
      return (enum privoxy_err)((signed int)err == JB_ERR_FILE ? JB_ERR_OK : (signed int)err);

    else
    {
      cur_line = file->lines;
      line_number = (unsigned int)1;
      for( ; !(cur_line == ((struct file_line *)NULL)) && !(line_number >= sectionid); line_number = line_number + 1u)
        cur_line = cur_line->next;
      if(cur_line == ((struct file_line *)NULL) || !(line_number == sectionid) || !(sectionid >= 1u))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = cur_line->type != 5 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        edit_free_file(file);
        return (enum privoxy_err)JB_ERR_CGI_PARAMS;
      }

      else
      {
        get_string_param(parameters, "p", &action_set_name);
        if(!(action_set_name == ((const char *)NULL)))
        {
          filter_identifier = 0;
          for( ; !(filter_identifier >= 30); filter_identifier = filter_identifier + 1)
          {
            fl = csp->actions_list[(signed long int)filter_identifier];
            if(!(fl == ((struct file_list *)NULL)))
            {
              b = (struct url_actions *)fl->f;
              if(!(b == ((struct url_actions *)NULL)))
              {
                b = b->next;
                for( ; !(b == ((struct url_actions *)NULL)); b = b->next)
                {
                  signed int return_value_strncmp_4;
                  return_value_strncmp_4=strncmp(b->url[0l].spec, "standard.", (unsigned long int)9);
                  if(return_value_strncmp_4 == 0)
                  {
                    return_value_strcmp_3=strcmp(b->url[0l].spec + (signed long int)9, action_set_name);
                    if(return_value_strcmp_3 == 0)
                    {
                      copy_action(cur_line->data.action, b->action);
                      goto found;
                    }

                  }

                }
              }

            }

          }
          edit_free_file(file);
          return (enum privoxy_err)JB_ERR_CGI_PARAMS;
        }

        else
          err=actions_from_radio(parameters, cur_line->data.action);

      found:
        ;
        if(!(err == /*enum*/JB_ERR_OK))
        {
          edit_free_file(file);
          return err;
        }

        else
        {
          i = 0;
          for( ; !(i >= 6); i = i + 1)
          {
            const signed int cgi_edit_actions_submit__1__9__1__multi_action_index = filter_type_info[(signed long int)i].multi_action_index;
            char ch;
            ch=get_char_param(parameters, filter_type_info[(signed long int)i].disable_all_param);
            if((signed int)ch == 78)
            {
              list_remove_all(cur_line->data.action[0l].multi_add[(signed long int)cgi_edit_actions_submit__1__9__1__multi_action_index]);
              list_remove_all(cur_line->data.action[0l].multi_remove[(signed long int)cgi_edit_actions_submit__1__9__1__multi_action_index]);
              cur_line->data.action[0l].multi_remove_all[(signed long int)cgi_edit_actions_submit__1__9__1__multi_action_index] = 1;
            }

            else
              if((signed int)ch == 88)
                cur_line->data.action[0l].multi_remove_all[(signed long int)cgi_edit_actions_submit__1__9__1__multi_action_index] = 0;

          }
          filter_identifier = 0;
          for( ; err == /*enum*/JB_ERR_OK; filter_identifier = filter_identifier + 1)
          {
            char key_value[30l];
            char key_name[30l];
            char key_type[30l];
            const char *name;
            char value;
            char type;
            signed int multi_action_index = 0;
            snprintf(key_value, sizeof(char [30l]) /*30ul*/ , "filter_r%x", filter_identifier);
            key_value[(signed long int)(sizeof(char [30l]) /*30ul*/  - (unsigned long int)1)] = (char)0;
            snprintf(key_name, sizeof(char [30l]) /*30ul*/ , "filter_n%x", filter_identifier);
            key_name[(signed long int)(sizeof(char [30l]) /*30ul*/  - (unsigned long int)1)] = (char)0;
            snprintf(key_type, sizeof(char [30l]) /*30ul*/ , "filter_t%x", filter_identifier);
            err=get_string_param(parameters, key_name, &name);
            if(!(err == /*enum*/JB_ERR_OK))
              break;

            if(name == ((const char *)NULL))
              break;

            type=get_char_param(parameters, key_type);
            switch((signed int)type)
            {
              case 70:
              {
                multi_action_index = 1;
                break;
              }
              case 83:
              {
                multi_action_index = 2;
                break;
              }
              case 67:
              {
                multi_action_index = 3;
                break;
              }
              case 76:
              {
                multi_action_index = 4;
                break;
              }
              case 69:
              {
                multi_action_index = 5;
                break;
              }
              default:
              {
                log_error(0x2000, "Unknown filter type: %c for filter %s. Filter ignored.", type, name);
                goto __CPROVER_DUMP_L37;
              }
            }
            /* assertion multi_action_index */
            assert(multi_action_index != 0);
            value=get_char_param(parameters, key_value);
            if((signed int)value == 89)
            {
              list_remove_item(cur_line->data.action[0l].multi_add[(signed long int)multi_action_index], name);
              if(err == /*enum*/JB_ERR_OK)
                err=enlist(cur_line->data.action[0l].multi_add[(signed long int)multi_action_index], name);

              list_remove_item(cur_line->data.action[0l].multi_remove[(signed long int)multi_action_index], name);
            }

            else
              if((signed int)value == 78)
              {
                list_remove_item(cur_line->data.action[0l].multi_add[(signed long int)multi_action_index], name);
                if(cur_line->data.action[0l].multi_remove_all[(signed long int)multi_action_index] == 0)
                {
                  list_remove_item(cur_line->data.action[0l].multi_remove[(signed long int)multi_action_index], name);
                  if(err == /*enum*/JB_ERR_OK)
                    err=enlist(cur_line->data.action[0l].multi_remove[(signed long int)multi_action_index], name);

                }

              }

              else
                if((signed int)value == 88)
                {
                  list_remove_item(cur_line->data.action[0l].multi_add[(signed long int)multi_action_index], name);
                  list_remove_item(cur_line->data.action[0l].multi_remove[(signed long int)multi_action_index], name);
                }


          __CPROVER_DUMP_L37:
            ;
          }
          if(!(err == /*enum*/JB_ERR_OK))
          {
            edit_free_file(file);
            return err;
          }

          else
          {
            actiontext=actions_to_text(cur_line->data.action);
            if(actiontext == ((char *)NULL))
            {
              edit_free_file(file);
              return (enum privoxy_err)JB_ERR_MEMORY;
            }

            else
            {
              len=strlen(actiontext);
              if(len == 0ul)
                len = (unsigned long int)1;

              newtext_size = len + (unsigned long int)2;
              void *return_value_malloc_or_die_5;
              return_value_malloc_or_die_5=malloc_or_die(newtext_size);
              newtext = (char *)return_value_malloc_or_die_5;
              privoxy_strlcpy(newtext, actiontext, newtext_size);
              free((void *)actiontext);
              newtext[(signed long int)0] = (char)123;
              newtext[(signed long int)len] = (char)125;
              newtext[(signed long int)(len + (unsigned long int)1)] = (char)0;
              if(!(cur_line->raw == ((char *)NULL)))
              {
                free((void *)cur_line->raw);
                cur_line->raw = (char *)(void *)0;
              }

              if(!(cur_line->unprocessed == ((char *)NULL)))
              {
                free((void *)cur_line->unprocessed);
                cur_line->unprocessed = (char *)(void *)0;
              }

              cur_line->unprocessed = newtext;
              err=edit_write_file(file);
              if(!(err == /*enum*/JB_ERR_OK))
              {
                if((signed int)err == JB_ERR_FILE)
                  err=cgi_error_file_read_only(csp, rsp, file->filename);

                edit_free_file(file);
                return err;
              }

              else
              {
                signed long int return_value_time_6;
                return_value_time_6=time((signed long int *)(void *)0);
                snprintf(target, sizeof(char [1024l]) /*1024ul*/ , "http://config.privoxy.org/edit-actions-list?foo=%lu&f=%i#l%u", (signed long int)return_value_time_6, file->identifier, sectionid);
                edit_free_file(file);
                enum privoxy_err return_value_cgi_redirect_7;
                return_value_cgi_redirect_7=cgi_redirect(rsp, target);
                return return_value_cgi_redirect_7;
              }
            }
          }
        }
      }
    }
  }
}

// cgi_edit_actions_url
// file cgiedit.h line 59
extern enum privoxy_err cgi_edit_actions_url(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  unsigned int patternid;
  char *new_pattern;
  struct editable_file *file;
  struct file_line *cur_line;
  unsigned int line_number;
  unsigned int section_start_line_number = (unsigned int)0;
  char target[1024l];
  enum privoxy_err err;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  if((1U & csp->config->feature_flags) == 0u)
  {
    enum privoxy_err return_value_cgi_error_disabled_1;
    return_value_cgi_error_disabled_1=cgi_error_disabled(csp, rsp);
    return return_value_cgi_error_disabled_1;
  }

  err=get_number_param(csp, parameters, "p", &patternid);
  _Bool tmp_if_expr_2;
  if(!(err == /*enum*/JB_ERR_OK))
    return err;

  else
    if(!(patternid >= 1U))
      return (enum privoxy_err)JB_ERR_CGI_PARAMS;

    else
    {
      err=get_url_spec_param(csp, parameters, "u", &new_pattern);
      if(!(err == /*enum*/JB_ERR_OK))
        return err;

      else
      {
        err=edit_read_actions_file(csp, rsp, parameters, 1, &file);
        if(!(err == /*enum*/JB_ERR_OK))
        {
          free((void *)new_pattern);
          return (enum privoxy_err)((signed int)err == JB_ERR_FILE ? JB_ERR_OK : (signed int)err);
        }

        else
        {
          line_number = (unsigned int)1;
          cur_line = file->lines;
          for( ; !(cur_line == ((struct file_line *)NULL)) && !(line_number >= patternid); line_number = line_number + 1u)
          {
            if(cur_line->type == 5)
              section_start_line_number = line_number;

            cur_line = cur_line->next;
          }
          if(cur_line == ((struct file_line *)NULL))
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = cur_line->type != 6 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_2)
          {
            free((void *)new_pattern);
            edit_free_file(file);
            return (enum privoxy_err)JB_ERR_CGI_PARAMS;
          }

          else
          {
            if(!(cur_line->raw == ((char *)NULL)))
            {
              free((void *)cur_line->raw);
              cur_line->raw = (char *)(void *)0;
            }

            if(!(cur_line->unprocessed == ((char *)NULL)))
            {
              free((void *)cur_line->unprocessed);
              cur_line->unprocessed = (char *)(void *)0;
            }

            cur_line->unprocessed = new_pattern;
            err=edit_write_file(file);
            if(!(err == /*enum*/JB_ERR_OK))
            {
              if((signed int)err == JB_ERR_FILE)
                err=cgi_error_file_read_only(csp, rsp, file->filename);

              edit_free_file(file);
              return err;
            }

            else
            {
              signed long int return_value_time_3;
              return_value_time_3=time((signed long int *)(void *)0);
              snprintf(target, sizeof(char [1024l]) /*1024ul*/ , "http://config.privoxy.org/edit-actions-list?foo=%lu&f=%i#l%u", (signed long int)return_value_time_3, file->identifier, section_start_line_number);
              edit_free_file(file);
              enum privoxy_err return_value_cgi_redirect_4;
              return_value_cgi_redirect_4=cgi_redirect(rsp, target);
              return return_value_cgi_redirect_4;
            }
          }
        }
      }
    }
}

// cgi_edit_actions_url_form
// file cgiedit.h line 62
extern enum privoxy_err cgi_edit_actions_url_form(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  struct map *exports;
  unsigned int patternid;
  struct editable_file *file;
  struct file_line *cur_line;
  unsigned int line_number;
  unsigned int section_start_line_number = (unsigned int)0;
  enum privoxy_err err;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  if((1U & csp->config->feature_flags) == 0u)
  {
    enum privoxy_err return_value_cgi_error_disabled_1;
    return_value_cgi_error_disabled_1=cgi_error_disabled(csp, rsp);
    return return_value_cgi_error_disabled_1;
  }

  err=get_number_param(csp, parameters, "p", &patternid);
  _Bool tmp_if_expr_2;
  const char *return_value_lookup_4;
  char *return_value_url_encode_5;
  char *return_value_html_encode_6;
  char *return_value_section_target_7;
  if(!(err == /*enum*/JB_ERR_OK))
    return err;

  else
  {
    err=edit_read_actions_file(csp, rsp, parameters, 1, &file);
    if(!(err == /*enum*/JB_ERR_OK))
      return (enum privoxy_err)((signed int)err == JB_ERR_FILE ? JB_ERR_OK : (signed int)err);

    else
    {
      cur_line = file->lines;
      line_number = (unsigned int)1;
      for( ; !(cur_line == ((struct file_line *)NULL)) && !(line_number >= patternid); line_number = line_number + 1u)
      {
        if(cur_line->type == 5)
          section_start_line_number = line_number;

        cur_line = cur_line->next;
      }
      if(cur_line == ((struct file_line *)NULL) || !(line_number == patternid) || !(patternid >= 1U))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = cur_line->type != 6 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        edit_free_file(file);
        return (enum privoxy_err)JB_ERR_CGI_PARAMS;
      }

      else
      {
        exports=default_exports(csp, (const char *)(void *)0);
        if(exports == ((struct map *)NULL))
        {
          edit_free_file(file);
          return (enum privoxy_err)JB_ERR_MEMORY;
        }

        else
        {
          char *return_value_stringify_3;
          return_value_stringify_3=stringify(file->identifier);
          err=map(exports, "f", 1, return_value_stringify_3, 0);
          if(err == /*enum*/JB_ERR_OK)
            err=map(exports, "v", 1, file->version_str, 1);

          if(err == /*enum*/JB_ERR_OK)
          {
            return_value_lookup_4=lookup(parameters, "p");
            return_value_url_encode_5=url_encode(return_value_lookup_4);
            err=map(exports, "p", 1, return_value_url_encode_5, 0);
          }

          if(err == /*enum*/JB_ERR_OK)
          {
            return_value_html_encode_6=html_encode(cur_line->unprocessed);
            err=map(exports, "u", 1, return_value_html_encode_6, 0);
          }

          if(err == /*enum*/JB_ERR_OK)
          {
            return_value_section_target_7=section_target(section_start_line_number);
            err=map(exports, "jumptarget", 1, return_value_section_target_7, 0);
          }

          edit_free_file(file);
          if(!(err == /*enum*/JB_ERR_OK))
          {
            free_map(exports);
            return err;
          }

          else
          {
            enum privoxy_err return_value_template_fill_for_cgi_8;
            return_value_template_fill_for_cgi_8=template_fill_for_cgi(csp, "edit-actions-url-form", exports, rsp);
            return return_value_template_fill_for_cgi_8;
          }
        }
      }
    }
  }
}

// cgi_error_404
// file cgisimple.h line 50
extern enum privoxy_err cgi_error_404(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  struct map *exports;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  exports=default_exports(csp, (const char *)(void *)0);
  if(exports == ((struct map *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    rsp->status=strdup_or_die("404 Privoxy configuration page not found");
    enum privoxy_err return_value_template_fill_for_cgi_1;
    return_value_template_fill_for_cgi_1=template_fill_for_cgi(csp, "cgi-error-404", exports, rsp);
    return return_value_template_fill_for_cgi_1;
  }
}

// cgi_error_bad_param
// file cgi.c line 1308
extern enum privoxy_err cgi_error_bad_param(struct client_state *csp, struct http_response *rsp)
{
  struct map *exports;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  exports=default_exports(csp, (const char *)(void *)0);
  if(exports == ((struct map *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    enum privoxy_err return_value_template_fill_for_cgi_1;
    return_value_template_fill_for_cgi_1=template_fill_for_cgi(csp, "cgi-error-bad-param", exports, rsp);
    return return_value_template_fill_for_cgi_1;
  }
}

// cgi_error_disabled
// file cgi.c line 1054
extern enum privoxy_err cgi_error_disabled(struct client_state *csp, struct http_response *rsp)
{
  struct map *exports;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  exports=default_exports(csp, "cgi-error-disabled");
  if(exports == ((struct map *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    char *return_value_html_encode_1;
    return_value_html_encode_1=html_encode(csp->http[0l].url);
    enum privoxy_err return_value_map_2;
    return_value_map_2=map(exports, "url", 1, return_value_html_encode_1, 0);
    if(!(return_value_map_2 == /*enum*/JB_ERR_OK))
      log_error(0x2000, "Failed to fill in url.");

    enum privoxy_err return_value_template_fill_for_cgi_3;
    return_value_template_fill_for_cgi_3=template_fill_for_cgi(csp, "cgi-error-disabled", exports, rsp);
    return return_value_template_fill_for_cgi_3;
  }
}

// cgi_error_file
// file cgiedit.c line 2113
enum privoxy_err cgi_error_file(struct client_state *csp, struct http_response *rsp, const char *filename)
{
  struct map *exports;
  enum privoxy_err err;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion filename */
  assert(filename != ((const char *)NULL));
  exports=default_exports(csp, (const char *)(void *)0);
  if(exports == ((struct map *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    char *return_value_html_encode_1;
    return_value_html_encode_1=html_encode(filename);
    err=map(exports, "f", 1, return_value_html_encode_1, 0);
    if(!(err == /*enum*/JB_ERR_OK))
    {
      free_map(exports);
      return err;
    }

    else
    {
      enum privoxy_err return_value_template_fill_for_cgi_2;
      return_value_template_fill_for_cgi_2=template_fill_for_cgi(csp, "cgi-error-file", exports, rsp);
      return return_value_template_fill_for_cgi_2;
    }
  }
}

// cgi_error_file_read_only
// file cgiedit.c line 2158
enum privoxy_err cgi_error_file_read_only(struct client_state *csp, struct http_response *rsp, const char *filename)
{
  struct map *exports;
  enum privoxy_err err;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion filename */
  assert(filename != ((const char *)NULL));
  exports=default_exports(csp, (const char *)(void *)0);
  if(exports == ((struct map *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    char *return_value_html_encode_1;
    return_value_html_encode_1=html_encode(filename);
    err=map(exports, "f", 1, return_value_html_encode_1, 0);
    if(!(err == /*enum*/JB_ERR_OK))
    {
      free_map(exports);
      return err;
    }

    else
    {
      enum privoxy_err return_value_template_fill_for_cgi_2;
      return_value_template_fill_for_cgi_2=template_fill_for_cgi(csp, "cgi-error-file-read-only", exports, rsp);
      return return_value_template_fill_for_cgi_2;
    }
  }
}

// cgi_error_memory
// file cgi.c line 1129
extern struct http_response * cgi_error_memory(void)
{
  /* assertion cgi_error_memory_response->head */
  assert(cgi_error_memory_response[0l].head != ((char *)NULL));
  return cgi_error_memory_response;
}

// cgi_error_modified
// file cgiedit.c line 2014
enum privoxy_err cgi_error_modified(struct client_state *csp, struct http_response *rsp, const char *filename)
{
  struct map *exports;
  enum privoxy_err err;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion filename */
  assert(filename != ((const char *)NULL));
  exports=default_exports(csp, (const char *)(void *)0);
  if(exports == ((struct map *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    char *return_value_html_encode_1;
    return_value_html_encode_1=html_encode(filename);
    err=map(exports, "f", 1, return_value_html_encode_1, 0);
    if(!(err == /*enum*/JB_ERR_OK))
    {
      free_map(exports);
      return err;
    }

    else
    {
      enum privoxy_err return_value_template_fill_for_cgi_2;
      return_value_template_fill_for_cgi_2=template_fill_for_cgi(csp, "cgi-error-modified", exports, rsp);
      return return_value_template_fill_for_cgi_2;
    }
  }
}

// cgi_error_no_template
// file cgi.c line 1157
extern enum privoxy_err cgi_error_no_template(struct client_state *csp, struct http_response *rsp, const char *template_name)
{
  unsigned long int body_size;
  unsigned long int return_value_strlen_1;
  static const char body_prefix[315l] = { '<', 'h', 't', 'm', 'l', '>', '\n', '<', 'h', 'e', 'a', 'd', '>', '\n', ' ', '<', 't', 'i', 't', 'l', 'e', '>', '5', '0', '0', ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'P', 'r', 'i', 'v', 'o', 'x', 'y', ' ', 'E', 'r', 'r', 'o', 'r', '<', '/', 't', 'i', 't', 'l', 'e', '>', '\n', ' ', '<', 'l', 'i', 'n', 'k', ' ', 'r', 'e', 'l', '=', '"', 's', 'h', 'o', 'r', 't', 'c', 'u', 't', ' ', 'i', 'c', 'o', 'n', '"', ' ', 'h', 'r', 'e', 'f', '=', '"', 'h', 't', 't', 'p', ':', '/', '/', 'c', 'o', 'n', 'f', 'i', 'g', '.', 'p', 'r', 'i', 'v', 'o', 'x', 'y', '.', 'o', 'r', 'g', '/', 'e', 'r', 'r', 'o', 'r', '-', 'f', 'a', 'v', 'i', 'c', 'o', 'n', '.', 'i', 'c', 'o', '"', ' ', 't', 'y', 'p', 'e', '=', '"', 'i', 'm', 'a', 'g', 'e', '/', 'x', '-', 'i', 'c', 'o', 'n', '"', '>', '<', '/', 'h', 'e', 'a', 'd', '>', '\n', '<', 'b', 'o', 'd', 'y', '>', '\n', '<', 'h', '1', '>', '5', '0', '0', ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'P', 'r', 'i', 'v', 'o', 'x', 'y', ' ', 'E', 'r', 'r', 'o', 'r', '<', '/', 'h', '1', '>', '\n', '<', 'p', '>', 'P', 'r', 'i', 'v', 'o', 'x', 'y', ' ', 'e', 'n', 'c', 'o', 'u', 'n', 't', 'e', 'r', 'e', 'd', ' ', 'a', 'n', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'i', 'l', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'i', 'n', 'g', ' ', 'y', 'o', 'u', 'r', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', ':', '<', '/', 'p', '>', '\n', '<', 'p', '>', '<', 'b', '>', 'C', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'l', 'o', 'a', 'd', ' ', 't', 'e', 'm', 'p', 'l', 'a', 't', 'e', ' ', 'f', 'i', 'l', 'e', ' ', '<', 'c', 'o', 'd', 'e', '>', 0 };
  return_value_strlen_1=strlen(body_prefix);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(template_name);
  unsigned long int return_value_strlen_3;
  static const char body_suffix[448l] = { '<', '/', 'c', 'o', 'd', 'e', '>', ' ', 'o', 'r', ' ', 'o', 'n', 'e', ' ', 'o', 'f', ' ', 'i', 't', 's', ' ', 'i', 'n', 'c', 'l', 'u', 'd', 'e', 'd', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's', '.', '<', '/', 'b', '>', '<', '/', 'p', '>', '\n', '<', 'p', '>', 'P', 'l', 'e', 'a', 's', 'e', ' ', 'c', 'o', 'n', 't', 'a', 'c', 't', ' ', 'y', 'o', 'u', 'r', ' ', 'p', 'r', 'o', 'x', 'y', ' ', 'a', 'd', 'm', 'i', 'n', 'i', 's', 't', 'r', 'a', 't', 'o', 'r', '.', '<', '/', 'p', '>', '\n', '<', 'p', '>', 'I', 'f', ' ', 'y', 'o', 'u', ' ', 'a', 'r', 'e', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'x', 'y', ' ', 'a', 'd', 'm', 'i', 'n', 'i', 's', 't', 'r', 'a', 't', 'o', 'r', ',', ' ', 'p', 'l', 'e', 'a', 's', 'e', ' ', 'p', 'u', 't', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd', ' ', 'f', 'i', 'l', 'e', '(', 's', ')', 'i', 'n', ' ', 't', 'h', 'e', ' ', '<', 'c', 'o', 'd', 'e', '>', '<', 'i', '>', '(', 'c', 'o', 'n', 'f', 'd', 'i', 'r', ')', '<', '/', 'i', '>', '/', 't', 'e', 'm', 'p', 'l', 'a', 't', 'e', 's', '<', '/', 'c', 'o', 'd', 'e', '>', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', '.', ' ', ' ', 'T', 'h', 'e', ' ', 'l', 'o', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', '<', 'c', 'o', 'd', 'e', '>', '<', 'i', '>', '(', 'c', 'o', 'n', 'f', 'd', 'i', 'r', ')', '<', '/', 'i', '>', '<', '/', 'c', 'o', 'd', 'e', '>', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', ' ', 'i', 's', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'd', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'm', 'a', 'i', 'n', ' ', 'P', 'r', 'i', 'v', 'o', 'x', 'y', ' ', '<', 'c', 'o', 'd', 'e', '>', 'c', 'o', 'n', 'f', 'i', 'g', '<', '/', 'c', 'o', 'd', 'e', '>', ' ', 'f', 'i', 'l', 'e', '.', ' ', ' ', '(', 'I', 't', '\'', 's', ' ', 't', 'y', 'p', 'i', 'c', 'a', 'l', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'P', 'r', 'i', 'v', 'o', 'x', 'y', ' ', 'i', 'n', 's', 't', 'a', 'l', 'l', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', ',', ' ', 'o', 'r', ' ', '<', 'c', 'o', 'd', 'e', '>', '/', 'e', 't', 'c', '/', 'p', 'r', 'i', 'v', 'o', 'x', 'y', '/', '<', '/', 'c', 'o', 'd', 'e', '>', ')', '.', '<', '/', 'p', '>', '\n', '<', '/', 'b', 'o', 'd', 'y', '>', '\n', '<', '/', 'h', 't', 'm', 'l', '>', '\n', 0 };
  return_value_strlen_3=strlen(body_suffix);
  body_size = return_value_strlen_1 + return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)1;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion template_name */
  assert(template_name != ((const char *)NULL));
  if(!(rsp->status == ((char *)NULL)))
  {
    free((void *)rsp->status);
    rsp->status = (char *)(void *)0;
  }

  if(!(rsp->head == ((char *)NULL)))
  {
    free((void *)rsp->head);
    rsp->head = (char *)(void *)0;
  }

  if(!(rsp->body == ((char *)NULL)))
  {
    free((void *)rsp->body);
    rsp->body = (char *)(void *)0;
  }

  rsp->content_length = (unsigned long int)0;
  rsp->head_length = (unsigned long int)0;
  rsp->is_static = 0;
  void *return_value_malloc_or_die_4;
  return_value_malloc_or_die_4=malloc_or_die(body_size);
  rsp->body = (char *)return_value_malloc_or_die_4;
  privoxy_strlcpy(rsp->body, body_prefix, body_size);
  privoxy_strlcat(rsp->body, template_name, body_size);
  privoxy_strlcat(rsp->body, body_suffix, body_size);
  static const char status[27l] = { '5', '0', '0', ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'P', 'r', 'i', 'v', 'o', 'x', 'y', ' ', 'E', 'r', 'r', 'o', 'r', 0 };
  rsp->status=strdup(status);
  if(rsp->status == ((char *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
    return (enum privoxy_err)JB_ERR_OK;
}

// cgi_error_parse
// file cgiedit.c line 2059
enum privoxy_err cgi_error_parse(struct client_state *csp, struct http_response *rsp, struct editable_file *file)
{
  struct map *exports;
  enum privoxy_err err;
  struct file_line *cur_line;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion file */
  assert(file != ((struct editable_file *)NULL));
  exports=default_exports(csp, (const char *)(void *)0);
  char *return_value_html_encode_2;
  char *return_value_html_encode_3;
  char *return_value_html_encode_4;
  if(exports == ((struct map *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    char *return_value_stringify_1;
    return_value_stringify_1=stringify(file->identifier);
    err=map(exports, "f", 1, return_value_stringify_1, 0);
    if(err == /*enum*/JB_ERR_OK)
    {
      return_value_html_encode_2=html_encode(file->parse_error_text);
      err=map(exports, "parse-error", 1, return_value_html_encode_2, 0);
    }

    cur_line = file->parse_error;
    /* assertion cur_line */
    assert(cur_line != ((struct file_line *)NULL));
    if(err == /*enum*/JB_ERR_OK)
    {
      return_value_html_encode_3=html_encode(cur_line->raw);
      err=map(exports, "line-raw", 1, return_value_html_encode_3, 0);
    }

    if(err == /*enum*/JB_ERR_OK)
    {
      return_value_html_encode_4=html_encode(cur_line->unprocessed);
      err=map(exports, "line-data", 1, return_value_html_encode_4, 0);
    }

    if(!(err == /*enum*/JB_ERR_OK))
    {
      free_map(exports);
      return err;
    }

    else
    {
      enum privoxy_err return_value_template_fill_for_cgi_5;
      return_value_template_fill_for_cgi_5=template_fill_for_cgi(csp, "cgi-error-parse", exports, rsp);
      return return_value_template_fill_for_cgi_5;
    }
  }
}

// cgi_error_unknown
// file cgi.c line 1240
extern enum privoxy_err cgi_error_unknown(struct client_state *csp, struct http_response *rsp, enum privoxy_err error_to_report)
{
  const unsigned long int body_size = sizeof(const char [307l]) /*307ul*/  + sizeof(const char [136l]) /*136ul*/  + (unsigned long int)5;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  if(!(rsp->status == ((char *)NULL)))
  {
    free((void *)rsp->status);
    rsp->status = (char *)(void *)0;
  }

  if(!(rsp->head == ((char *)NULL)))
  {
    free((void *)rsp->head);
    rsp->head = (char *)(void *)0;
  }

  if(!(rsp->body == ((char *)NULL)))
  {
    free((void *)rsp->body);
    rsp->body = (char *)(void *)0;
  }

  rsp->content_length = (unsigned long int)0;
  rsp->head_length = (unsigned long int)0;
  rsp->is_static = 0;
  rsp->crunch_reason = (enum crunch_reason)INTERNAL_ERROR;
  void *return_value_malloc_or_die_1;
  return_value_malloc_or_die_1=malloc_or_die(body_size);
  rsp->body = (char *)return_value_malloc_or_die_1;
  static const char body_suffix[136l] = { '<', '/', 'b', '>', '<', '/', 'p', '>', '\n', '<', 'p', '>', 'P', 'l', 'e', 'a', 's', 'e', ' ', '<', 'a', ' ', 'h', 'r', 'e', 'f', '=', '"', 'h', 't', 't', 'p', ':', '/', '/', 's', 'o', 'u', 'r', 'c', 'e', 'f', 'o', 'r', 'g', 'e', '.', 'n', 'e', 't', '/', 't', 'r', 'a', 'c', 'k', 'e', 'r', '/', '?', 'g', 'r', 'o', 'u', 'p', '_', 'i', 'd', '=', '1', '1', '1', '1', '8', '&', 'a', 'm', 'p', ';', 'a', 't', 'i', 'd', '=', '1', '1', '1', '1', '1', '8', '"', '>', 'f', 'i', 'l', 'e', ' ', 'a', ' ', 'b', 'u', 'g', ' ', 'r', 'e', 'p', 'o', 'r', 't', '<', '/', 'a', '>', '.', '<', '/', 'p', '>', '\n', '<', '/', 'b', 'o', 'd', 'y', '>', '\n', '<', '/', 'h', 't', 'm', 'l', '>', '\n', 0 };
  static const char body_prefix[307l] = { '<', 'h', 't', 'm', 'l', '>', '\n', '<', 'h', 'e', 'a', 'd', '>', '\n', ' ', '<', 't', 'i', 't', 'l', 'e', '>', '5', '0', '0', ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'P', 'r', 'i', 'v', 'o', 'x', 'y', ' ', 'E', 'r', 'r', 'o', 'r', '<', '/', 't', 'i', 't', 'l', 'e', '>', '\n', ' ', '<', 'l', 'i', 'n', 'k', ' ', 'r', 'e', 'l', '=', '"', 's', 'h', 'o', 'r', 't', 'c', 'u', 't', ' ', 'i', 'c', 'o', 'n', '"', ' ', 'h', 'r', 'e', 'f', '=', '"', 'h', 't', 't', 'p', ':', '/', '/', 'c', 'o', 'n', 'f', 'i', 'g', '.', 'p', 'r', 'i', 'v', 'o', 'x', 'y', '.', 'o', 'r', 'g', '/', 'e', 'r', 'r', 'o', 'r', '-', 'f', 'a', 'v', 'i', 'c', 'o', 'n', '.', 'i', 'c', 'o', '"', ' ', 't', 'y', 'p', 'e', '=', '"', 'i', 'm', 'a', 'g', 'e', '/', 'x', '-', 'i', 'c', 'o', 'n', '"', '>', '<', '/', 'h', 'e', 'a', 'd', '>', '\n', '<', 'b', 'o', 'd', 'y', '>', '\n', '<', 'h', '1', '>', '5', '0', '0', ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'P', 'r', 'i', 'v', 'o', 'x', 'y', ' ', 'E', 'r', 'r', 'o', 'r', '<', '/', 'h', '1', '>', '\n', '<', 'p', '>', 'P', 'r', 'i', 'v', 'o', 'x', 'y', ' ', 'e', 'n', 'c', 'o', 'u', 'n', 't', 'e', 'r', 'e', 'd', ' ', 'a', 'n', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'i', 'l', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'i', 'n', 'g', ' ', 'y', 'o', 'u', 'r', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', ':', '<', '/', 'p', '>', '\n', '<', 'p', '>', '<', 'b', '>', 'U', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'i', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'e', 'r', 'r', 'o', 'r', ':', ' ', 0 };
  snprintf(rsp->body, body_size, "%s%d%s", (const void *)body_prefix, error_to_report, (const void *)body_suffix);
  static const char status[27l] = { '5', '0', '0', ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'P', 'r', 'i', 'v', 'o', 'x', 'y', ' ', 'E', 'r', 'r', 'o', 'r', 0 };
  rsp->status=strdup(status);
  if(rsp->status == ((char *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
    return (enum privoxy_err)JB_ERR_OK;
}

// cgi_init_error_messages
// file cgi.c line 1088
extern void cgi_init_error_messages(void)
{
  memset((void *)cgi_error_memory_response, 0, sizeof(struct http_response) /*64ul*/ );
  cgi_error_memory_response[0l].head = "HTTP/1.0 500 Internal Privoxy Error\r\nContent-Type: text/html\r\n\r\n";
  cgi_error_memory_response[0l].body = "<html>\n<head>\n <title>500 Internal Privoxy Error</title>\n <link rel=\"shortcut icon\" href=\"http://config.privoxy.org/error-favicon.ico\" type=\"image/x-icon\"></head>\n<body>\n<h1>500 Internal Privoxy Error</h1>\n<p>Privoxy <b>ran out of memory</b> while processing your request.</p>\n<p>Please contact your proxy administrator, or try again later</p>\n</body>\n</html>\n";
  cgi_error_memory_response[0l].head_length=strlen(cgi_error_memory_response[0l].head);
  cgi_error_memory_response[0l].content_length=strlen(cgi_error_memory_response[0l].body);
  cgi_error_memory_response[0l].crunch_reason = (enum crunch_reason)OUT_OF_MEMORY;
}

// cgi_redirect
// file cgi.c line 1342
extern enum privoxy_err cgi_redirect(struct http_response *rsp, const char *target)
{
  enum privoxy_err err;
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion target */
  assert(target != ((const char *)NULL));
  err=enlist_unique_header(rsp->headers, "Location", target);
  rsp->status=strdup("302 Local Redirect from Privoxy");
  if(rsp->status == ((char *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
    return err;
}

// cgi_robots_txt
// file cgisimple.h line 53
extern enum privoxy_err cgi_robots_txt(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  char buf[100l];
  enum privoxy_err err;
  (void)csp;
  (void)parameters;
  rsp->body=strdup_or_die("# This is the Privoxy control interface.\n# It isn't very useful to index it, and you're likely to break stuff.\n# So go away!\n\nUser-agent: *\nDisallow: /\n\n");
  err=enlist_unique(rsp->headers, "Content-Type: text/plain", (unsigned long int)13);
  rsp->is_static = 1;
  get_http_time(7 * 24 * 60 * 60, buf, sizeof(char [100l]) /*100ul*/ );
  if(err == /*enum*/JB_ERR_OK)
    err=enlist_unique_header(rsp->headers, "Expires", buf);

  return (enum privoxy_err)(err != (enum privoxy_err)0 ? JB_ERR_MEMORY : JB_ERR_OK);
}

// cgi_send_banner
// file cgisimple.h line 56
extern enum privoxy_err cgi_send_banner(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  char imagetype;
  const char *return_value_lookup_1;
  return_value_lookup_1=lookup(parameters, "type");
  imagetype = return_value_lookup_1[(signed long int)0];
  signed int return_value_strcmpic_5;
  signed int return_value_strcmpic_4;
  signed int return_value_strncmpic_3;
  signed int return_value_strncmpic_2;
  if((signed int)imagetype == 97)
  {
    imagetype = (char)112;
    if(!((0x00000200UL & csp->action[0l].flags) == 0ul))
    {
      const char *p = csp->action[0l].string[(signed long int)2];
      if(!(p == ((const char *)NULL)))
      {
        return_value_strcmpic_5=strcmpic(p, "blank");
        if(return_value_strcmpic_5 == 0)
          imagetype = (char)98;

        else
        {
          return_value_strcmpic_4=strcmpic(p, "pattern");
          if(return_value_strcmpic_4 == 0)
            imagetype = (char)112;

          else
          {
            static const char prefix1[44l] = { 'h', 't', 't', 'p', ':', '/', '/', 'c', 'o', 'n', 'f', 'i', 'g', '.', 'p', 'r', 'i', 'v', 'o', 'x', 'y', '.', 'o', 'r', 'g', '/', 's', 'e', 'n', 'd', '-', 'b', 'a', 'n', 'n', 'e', 'r', '?', 't', 'y', 'p', 'e', '=', 0 };
            return_value_strncmpic_3=strncmpic(p, prefix1, sizeof(const char [44l]) /*44ul*/  - (unsigned long int)1);
            if(return_value_strncmpic_3 == 0)
              imagetype = p[(signed long int)(sizeof(const char [44l]) /*44ul*/  - (unsigned long int)1)];

            else
            {
              static const char prefix2[29l] = { 'h', 't', 't', 'p', ':', '/', '/', 'p', '.', 'p', '/', 's', 'e', 'n', 'd', '-', 'b', 'a', 'n', 'n', 'e', 'r', '?', 't', 'y', 'p', 'e', '=', 0 };
              return_value_strncmpic_2=strncmpic(p, prefix2, sizeof(const char [29l]) /*29ul*/  - (unsigned long int)1);
              if(return_value_strncmpic_2 == 0)
                imagetype = p[(signed long int)(sizeof(const char [29l]) /*29ul*/  - (unsigned long int)1)];

              else
                imagetype = (char)114;
            }
          }
        }
      }

    }

  }

  if((signed int)imagetype == 114)
  {
    rsp->status=strdup_or_die("302 Local Redirect from Privoxy");
    enum privoxy_err return_value_enlist_unique_header_6;
    return_value_enlist_unique_header_6=enlist_unique_header(rsp->headers, "Location", csp->action[0l].string[(signed long int)2]);
    if(!(return_value_enlist_unique_header_6 == /*enum*/JB_ERR_OK))
      return (enum privoxy_err)JB_ERR_MEMORY;

  }

  else
  {
    if((signed int)imagetype == 98 || (signed int)imagetype == 116)
    {
      rsp->body=bindup(image_blank_data, image_blank_length);
      rsp->content_length = image_blank_length;
    }

    else
    {
      rsp->body=bindup(image_pattern_data, image_pattern_length);
      rsp->content_length = image_pattern_length;
    }
    if(rsp->body == ((char *)NULL))
      return (enum privoxy_err)JB_ERR_MEMORY;

    enum privoxy_err return_value_enlist_7;
    return_value_enlist_7=enlist(rsp->headers, "Content-Type: image/png");
    if(!(return_value_enlist_7 == /*enum*/JB_ERR_OK))
      return (enum privoxy_err)JB_ERR_MEMORY;

    rsp->is_static = 1;
  }
  return (enum privoxy_err)JB_ERR_OK;
}

// cgi_send_default_favicon
// file cgisimple.h line 77
extern enum privoxy_err cgi_send_default_favicon(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  (void)csp;
  (void)parameters;
  static const unsigned long int favicon_length = sizeof(const char [199l]) /*199ul*/  - (unsigned long int)1;
  static const char default_favicon_data[199l] = { 0, 0, 1, 0, 1, 0, 16, 16, 2, 0, 0, 0, 0, 0, -80, 0, 0, 0, 22, 0, 0, 0, '(', 0, 0, 0, 16, 0, 0, 0, ' ', 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, '@', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, 0, -1, 0, '*', 0, 15, -16, 0, 0, '?', -4, 0, 0, 'q', -2, 0, 0, 'q', -2, 0, 0, -15, -1, 0, 0, -15, -1, 0, 0, -16, 15, 0, 0, -16, 7, 0, 0, -15, -57, 0, 0, -15, -57, 0, 0, -15, -57, 0, 0, -16, 7, 0, 0, 'p', 30, 0, 0, 127, -2, 0, 0, '?', -4, 0, 0, 15, -16, 0, 0, -16, 15, 0, 0, -64, 3, 0, 0, -128, 1, 0, 0, -128, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -128, 1, 0, 0, -128, 1, 0, 0, -64, 3, 0, 0, -16, 15, 0, 0, 0 };
  rsp->body=bindup(default_favicon_data, favicon_length);
  rsp->content_length = favicon_length;
  if(rsp->body == ((char *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    enum privoxy_err return_value_enlist_1;
    return_value_enlist_1=enlist(rsp->headers, "Content-Type: image/x-icon");
    if(!(return_value_enlist_1 == /*enum*/JB_ERR_OK))
      return (enum privoxy_err)JB_ERR_MEMORY;

    else
    {
      rsp->is_static = 1;
      return (enum privoxy_err)JB_ERR_OK;
    }
  }
}

// cgi_send_error_favicon
// file cgisimple.h line 74
extern enum privoxy_err cgi_send_error_favicon(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  (void)csp;
  (void)parameters;
  static const unsigned long int favicon_length = sizeof(const char [199l]) /*199ul*/  - (unsigned long int)1;
  static const char error_favicon_data[199l] = { 0, 0, 1, 0, 1, 0, 16, 16, 2, 0, 0, 0, 0, 0, -80, 0, 0, 0, 22, 0, 0, 0, '(', 0, 0, 0, 16, 0, 0, 0, ' ', 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, '@', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, 0, 0, 0, -1, 0, 15, -16, 0, 0, '?', -4, 0, 0, 'q', -2, 0, 0, 'q', -2, 0, 0, -15, -1, 0, 0, -15, -1, 0, 0, -16, 15, 0, 0, -16, 7, 0, 0, -15, -57, 0, 0, -15, -57, 0, 0, -15, -57, 0, 0, -16, 7, 0, 0, 'p', 30, 0, 0, 127, -2, 0, 0, '?', -4, 0, 0, 15, -16, 0, 0, -16, 15, 0, 0, -64, 3, 0, 0, -128, 1, 0, 0, -128, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -128, 1, 0, 0, -128, 1, 0, 0, -64, 3, 0, 0, -16, 15, 0, 0, 0 };
  rsp->body=bindup(error_favicon_data, favicon_length);
  rsp->content_length = favicon_length;
  if(rsp->body == ((char *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    enum privoxy_err return_value_enlist_1;
    return_value_enlist_1=enlist(rsp->headers, "Content-Type: image/x-icon");
    if(!(return_value_enlist_1 == /*enum*/JB_ERR_OK))
      return (enum privoxy_err)JB_ERR_MEMORY;

    else
    {
      rsp->is_static = 1;
      return (enum privoxy_err)JB_ERR_OK;
    }
  }
}

// cgi_send_stylesheet
// file cgisimple.h line 80
extern enum privoxy_err cgi_send_stylesheet(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  enum privoxy_err err;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  (void)parameters;
  err=template_load(csp, &rsp->body, "cgi-style.css", 0);
  if((signed int)err == JB_ERR_FILE)
    log_error(0x2000, "Could not find cgi-style.css template");

  else
    if(!(err == /*enum*/JB_ERR_OK))
      return err;

  enum privoxy_err return_value_enlist_1;
  return_value_enlist_1=enlist(rsp->headers, "Content-Type: text/css");
  if(!(return_value_enlist_1 == /*enum*/JB_ERR_OK))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
    return (enum privoxy_err)JB_ERR_OK;
}

// cgi_send_url_info_osd
// file cgisimple.h line 83
extern enum privoxy_err cgi_send_url_info_osd(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  enum privoxy_err err = (enum privoxy_err)JB_ERR_MEMORY;
  struct map *exports;
  exports=default_exports(csp, (const char *)(void *)0);
  (void)csp;
  (void)parameters;
  if(!(exports == ((struct map *)NULL)))
  {
    err=template_fill_for_cgi(csp, "url-info-osd.xml", exports, rsp);
    if((signed int)err == JB_ERR_OK)
      err=enlist(rsp->headers, "Content-Type: application/opensearchdescription+xml");

  }

  return err;
}

// cgi_send_user_manual
// file cgisimple.h line 86
extern enum privoxy_err cgi_send_user_manual(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  const char *filename;
  char *full_path;
  enum privoxy_err err = (enum privoxy_err)JB_ERR_OK;
  const char *content_type;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  signed int return_value_strncmpic_2;
  return_value_strncmpic_2=strncmpic(csp->config->usermanual, "http://", (unsigned long int)7);
  if(return_value_strncmpic_2 == 0)
  {
    log_error(0x0800, "Request for local user-manual received while user-manual delivery is disabled.");
    enum privoxy_err return_value_cgi_error_404_1;
    return_value_cgi_error_404_1=cgi_error_404(csp, rsp, parameters);
    return return_value_cgi_error_404_1;
  }

  if(parameters->first == ((struct map_entry *)NULL))
  {
    enum privoxy_err return_value_cgi_redirect_3;
    return_value_cgi_redirect_3=cgi_redirect(rsp, "http://config.privoxy.org/user-manual/");
    return return_value_cgi_redirect_3;
  }

  get_string_param(parameters, "file", &filename);
  char *return_value_strchr_4;
  _Bool tmp_if_expr_6;
  char *return_value_strstr_5;
  if(filename == ((const char *)NULL))
    filename = "index.html";

  else
  {
    return_value_strchr_4=strchr(filename, 47);
    if(!(return_value_strchr_4 == ((char *)NULL)))
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_strstr_5=strstr(filename, "..");
      tmp_if_expr_6 = (char *)(void *)0 != return_value_strstr_5 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      log_error(0x2000, "Rejecting the request to serve '%s' as it contains '/' or '..'", filename);
      return (enum privoxy_err)JB_ERR_CGI_PARAMS;
    }

  }
  full_path=make_path(csp->config->usermanual, filename);
  if(full_path == ((char *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    err=load_file(full_path, &rsp->body, &rsp->content_length);
    if(!((signed int)err == JB_ERR_OK))
    {
      /* assertion (JB_ERR_FILE == err) || (JB_ERR_MEMORY == err) */
      assert(JB_ERR_FILE == (signed int)err || JB_ERR_MEMORY == (signed int)err);
      if((signed int)err == JB_ERR_FILE)
        err=cgi_error_no_template(csp, rsp, full_path);

      if(!(full_path == ((char *)NULL)))
      {
        free((void *)full_path);
        full_path = (char *)(void *)0;
      }

      return err;
    }

    else
    {
      if(!(full_path == ((char *)NULL)))
      {
        free((void *)full_path);
        full_path = (char *)(void *)0;
      }

      content_type=get_content_type(filename);
      log_error(0x0800, "Content-Type guessed for %s: %s", filename, content_type);
      enum privoxy_err return_value_enlist_unique_header_7;
      return_value_enlist_unique_header_7=enlist_unique_header(rsp->headers, "Content-Type", content_type);
      return return_value_enlist_unique_header_7;
    }
  }
}

// cgi_show_file
// file cgisimple.c line 1841
static enum privoxy_err cgi_show_file(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  unsigned int i;
  const char *filename = (const char *)(void *)0;
  char *file_description = (char *)(void *)0;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  const char *return_value_lookup_1;
  return_value_lookup_1=lookup(parameters, "file");
  enum privoxy_err return_value_get_number_param_2;
  enum privoxy_err return_value_get_number_param_3;
  switch((signed int)*return_value_lookup_1)
  {
    case 97:
    {
      return_value_get_number_param_2=get_number_param(csp, parameters, "index", &i);
      if(return_value_get_number_param_2 == /*enum*/JB_ERR_OK)
      {
        if(!(i >= 30u))
        {
          if(!(csp->actions_list[(signed long int)i] == ((struct file_list *)NULL)))
          {
            filename = csp->actions_list[(signed long int)i]->filename;
            file_description = "Actions File";
          }

        }

      }

      break;
    }
    case 102:
    {
      return_value_get_number_param_3=get_number_param(csp, parameters, "index", &i);
      if(return_value_get_number_param_3 == /*enum*/JB_ERR_OK)
      {
        if(!(i >= 30u))
        {
          if(!(csp->rlist[(signed long int)i] == ((struct file_list *)NULL)))
          {
            filename = csp->rlist[(signed long int)i]->filename;
            file_description = "Filter File";
          }

        }

      }

      break;
    }
    case 116:
      if(!(csp->tlist == ((struct file_list *)NULL)))
      {
        filename = csp->tlist->filename;
        file_description = "Trust File";
      }

  }
  _Bool tmp_if_expr_7;
  char *return_value_html_encode_5;
  enum privoxy_err return_value_map_6;
  if(!(filename == ((const char *)NULL)))
  {
    struct map *exports;
    char *s;
    enum privoxy_err err;
    unsigned long int length;
    exports=default_exports(csp, "show-status");
    if(exports == ((struct map *)NULL))
      return (enum privoxy_err)JB_ERR_MEMORY;

    enum privoxy_err return_value_map_4;
    return_value_map_4=map(exports, "file-description", 1, file_description, 1);
    if(!(return_value_map_4 == /*enum*/JB_ERR_OK))
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_html_encode_5=html_encode(filename);
      return_value_map_6=map(exports, "filepath", 1, return_value_html_encode_5, 0);
      tmp_if_expr_7 = return_value_map_6 != (enum privoxy_err)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
    {
      free_map(exports);
      return (enum privoxy_err)JB_ERR_MEMORY;
    }

    err=load_file(filename, &s, &length);
    if(!((signed int)err == JB_ERR_OK))
    {
      enum privoxy_err return_value_map_8;
      return_value_map_8=map(exports, "contents", 1, "<h1>ERROR OPENING FILE!</h1>", 1);
      if(!(return_value_map_8 == /*enum*/JB_ERR_OK))
      {
        free_map(exports);
        return (enum privoxy_err)JB_ERR_MEMORY;
      }

    }

    else
    {
      s=html_encode_and_free_original(s);
      if(s == ((char *)NULL))
      {
        free_map(exports);
        return (enum privoxy_err)JB_ERR_MEMORY;
      }

      enum privoxy_err return_value_map_9;
      return_value_map_9=map(exports, "contents", 1, s, 0);
      if(!(return_value_map_9 == /*enum*/JB_ERR_OK))
      {
        free_map(exports);
        return (enum privoxy_err)JB_ERR_MEMORY;
      }

    }
    enum privoxy_err return_value_template_fill_for_cgi_10;
    return_value_template_fill_for_cgi_10=template_fill_for_cgi(csp, "show-status-file", exports, rsp);
    return return_value_template_fill_for_cgi_10;
  }

  return (enum privoxy_err)JB_ERR_CGI_PARAMS;
}

// cgi_show_request
// file cgisimple.h line 68
extern enum privoxy_err cgi_show_request(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  char *p;
  struct map *exports;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  exports=default_exports(csp, "show-request");
  if(exports == ((struct map *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    p = csp->client_iob[0l].buf;
    for( ; !(p >= csp->client_iob[0l].cur); p = p + 1l)
      if((signed int)*p == 0)
        *p = (char)10;

    char *return_value_html_encode_1;
    return_value_html_encode_1=html_encode(csp->client_iob[0l].buf);
    enum privoxy_err return_value_map_2;
    return_value_map_2=map(exports, "client-request", 1, return_value_html_encode_1, 0);
    if(!(return_value_map_2 == /*enum*/JB_ERR_OK))
    {
      free_map(exports);
      return (enum privoxy_err)JB_ERR_MEMORY;
    }

    else
    {
      char *return_value_list_to_text_3;
      return_value_list_to_text_3=list_to_text(csp->headers);
      char *return_value_html_encode_and_free_original_4;
      return_value_html_encode_and_free_original_4=html_encode_and_free_original(return_value_list_to_text_3);
      enum privoxy_err return_value_map_5;
      return_value_map_5=map(exports, "processed-request", 1, return_value_html_encode_and_free_original_4, 0);
      if(!(return_value_map_5 == /*enum*/JB_ERR_OK))
      {
        free_map(exports);
        return (enum privoxy_err)JB_ERR_MEMORY;
      }

      else
      {
        enum privoxy_err return_value_template_fill_for_cgi_6;
        return_value_template_fill_for_cgi_6=template_fill_for_cgi(csp, "show-request", exports, rsp);
        return return_value_template_fill_for_cgi_6;
      }
    }
  }
}

// cgi_show_status
// file cgisimple.h line 59
extern enum privoxy_err cgi_show_status(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  char *s = (char *)(void *)0;
  unsigned int i;
  signed int j;
  char buf[5000l];
  float perc_rej;
  signed int local_urls_read;
  signed int local_urls_rejected;
  enum privoxy_err err = (enum privoxy_err)JB_ERR_OK;
  struct map *exports;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  const char *return_value_lookup_2;
  return_value_lookup_2=lookup(parameters, "file");
  if(!((signed int)*return_value_lookup_2 == 0))
  {
    enum privoxy_err return_value_cgi_show_file_1;
    return_value_cgi_show_file_1=cgi_show_file(csp, rsp, parameters);
    return return_value_cgi_show_file_1;
  }

  exports=default_exports(csp, "show-status");
  char *return_value_html_encode_3;
  char *return_value_html_encode_4;
  char *return_value_html_encode_6;
  char *return_value_html_encode_7;
  if(exports == ((struct map *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    s=strdup("");
    j = 0;
    for( ; !(s == ((char *)NULL)) && !(j >= Argc); j = j + 1)
    {
      if(err == /*enum*/JB_ERR_OK)
      {
        return_value_html_encode_3=html_encode(Argv[(signed long int)j]);
        err=string_join(&s, return_value_html_encode_3);
      }

      if(err == /*enum*/JB_ERR_OK)
        err=string_append(&s, " ");

    }
    if(err == /*enum*/JB_ERR_OK)
      err=map(exports, "invocation", 1, s, 0);

    if(err == /*enum*/JB_ERR_OK)
      err=map(exports, "options", 1, csp->config->proxy_args, 1);

    if(err == /*enum*/JB_ERR_OK)
      err=show_defines(exports);

    if(!(err == /*enum*/JB_ERR_OK))
    {
      free_map(exports);
      return (enum privoxy_err)JB_ERR_MEMORY;
    }

    else
    {
      local_urls_read = urls_read;
      local_urls_rejected = urls_rejected;
      if(local_urls_read == 0)
      {
        if(err == /*enum*/JB_ERR_OK)
          err=map_block_killer(exports, "have-stats");

      }

      else
      {
        if(err == /*enum*/JB_ERR_OK)
          err=map_block_killer(exports, "have-no-stats");

        perc_rej = ((float)local_urls_rejected * 100.0F) / (float)local_urls_read;
        snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , "%d", local_urls_read);
        if(err == /*enum*/JB_ERR_OK)
          err=map(exports, "requests-received", 1, buf, 1);

        snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , "%d", local_urls_rejected);
        if(err == /*enum*/JB_ERR_OK)
          err=map(exports, "requests-blocked", 1, buf, 1);

        snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , "%6.2f", perc_rej);
        if(err == /*enum*/JB_ERR_OK)
          err=map(exports, "percent-blocked", 1, buf, 1);

      }
      s=strdup("");
      i = (unsigned int)0;
      for( ; !(i >= 30u); i = i + 1u)
        if(!(csp->actions_list[(signed long int)i] == ((struct file_list *)NULL)))
        {
          if(err == /*enum*/JB_ERR_OK)
            err=string_append(&s, "<tr><td>");

          if(err == /*enum*/JB_ERR_OK)
          {
            return_value_html_encode_4=html_encode(csp->actions_list[(signed long int)i]->filename);
            err=string_join(&s, return_value_html_encode_4);
          }

          snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , "</td><td class=\"buttons\"><a href=\"/show-status?file=actions&amp;index=%u\">View</a>", i);
          if(err == /*enum*/JB_ERR_OK)
            err=string_append(&s, buf);

          if(!((1U & csp->config->feature_flags) == 0u))
          {
            if(!(csp->config->actions_file_short[(signed long int)i] == ((const char *)NULL)))
            {
              signed int return_value_access_5;
              return_value_access_5=access(csp->config->actions_file[(signed long int)i], 2);
              if(return_value_access_5 == 0)
              {
                snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , "&nbsp;&nbsp;<a href=\"/edit-actions-list?f=%u\">Edit</a>", i);
                if(err == /*enum*/JB_ERR_OK)
                  err=string_append(&s, buf);

              }

              else
                if(err == /*enum*/JB_ERR_OK)
                  err=string_append(&s, "&nbsp;&nbsp;<strong>No write access.</strong>");

            }

          }

          if(err == /*enum*/JB_ERR_OK)
            err=string_append(&s, "</td></tr>\n");

        }

      if(!((signed int)*s == 0))
      {
        if(err == /*enum*/JB_ERR_OK)
          err=map(exports, "actions-filenames", 1, s, 0);

      }

      else
        if(err == /*enum*/JB_ERR_OK)
          err=map(exports, "actions-filenames", 1, "<tr><td>None specified</td></tr>", 1);

      s=strdup("");
      i = (unsigned int)0;
      for( ; !(i >= 30u); i = i + 1u)
        if(!(csp->rlist[(signed long int)i] == ((struct file_list *)NULL)))
        {
          if(err == /*enum*/JB_ERR_OK)
            err=string_append(&s, "<tr><td>");

          if(err == /*enum*/JB_ERR_OK)
          {
            return_value_html_encode_6=html_encode(csp->rlist[(signed long int)i]->filename);
            err=string_join(&s, return_value_html_encode_6);
          }

          snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , "</td><td class=\"buttons\"><a href=\"/show-status?file=filter&amp;index=%u\">View</a>", i);
          if(err == /*enum*/JB_ERR_OK)
            err=string_append(&s, buf);

          if(err == /*enum*/JB_ERR_OK)
            err=string_append(&s, "</td></tr>\n");

        }

      if(!((signed int)*s == 0))
      {
        if(err == /*enum*/JB_ERR_OK)
          err=map(exports, "re-filter-filenames", 1, s, 0);

      }

      else
      {
        if(err == /*enum*/JB_ERR_OK)
          err=map(exports, "re-filter-filenames", 1, "<tr><td>None specified</td></tr>", 1);

        if(err == /*enum*/JB_ERR_OK)
          err=map_block_killer(exports, "have-filterfile");

      }
      if(!(csp->tlist == ((struct file_list *)NULL)))
      {
        if(err == /*enum*/JB_ERR_OK)
        {
          return_value_html_encode_7=html_encode(csp->tlist->filename);
          err=map(exports, "trust-filename", 1, return_value_html_encode_7, 0);
        }

      }

      else
      {
        if(err == /*enum*/JB_ERR_OK)
          err=map(exports, "trust-filename", 1, "None specified", 1);

        if(err == /*enum*/JB_ERR_OK)
          err=map_block_killer(exports, "have-trustfile");

      }
      if(err == /*enum*/JB_ERR_OK)
      {
        if(!((1U & csp->config->feature_flags) == 0u))
          err=map_block_killer(exports, "cgi-editor-is-disabled");

      }

      if(err == /*enum*/JB_ERR_OK)
        err=map(exports, "force-prefix", 1, "/PRIVOXY-FORCE", 1);

      if(!(err == /*enum*/JB_ERR_OK))
      {
        free_map(exports);
        return (enum privoxy_err)JB_ERR_MEMORY;
      }

      else
      {
        enum privoxy_err return_value_template_fill_for_cgi_8;
        return_value_template_fill_for_cgi_8=template_fill_for_cgi(csp, "show-status", exports, rsp);
        return return_value_template_fill_for_cgi_8;
      }
    }
  }
}

// cgi_show_url_info
// file cgisimple.h line 62
extern enum privoxy_err cgi_show_url_info(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  char *url_param;
  struct map *exports;
  char buf[150l];
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  exports=default_exports(csp, "show-url-info");
  signed int return_value_strncmp_7;
  char *return_value_strstr_3;
  _Bool tmp_if_expr_6;
  char *return_value_strstr_4;
  char *return_value_strstr_5;
  enum privoxy_err return_value_map_block_killer_9;
  _Bool tmp_if_expr_12;
  enum privoxy_err return_value_map_11;
  _Bool tmp_if_expr_18;
  signed int return_value_strncmpic_17;
  const char *return_value_lookup_19;
  _Bool tmp_if_expr_23;
  signed int return_value_strcmp_22;
  _Bool tmp_if_expr_30;
  _Bool tmp_if_expr_32;
  enum privoxy_err return_value_map_31;
  if(exports == ((struct map *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    const char *return_value_lookup_1;
    return_value_lookup_1=lookup(parameters, "url");
    url_param=strdup_or_die(return_value_lookup_1);
    chomp(url_param);
    signed int return_value_strncmp_8;
    return_value_strncmp_8=strncmp(url_param, "http://", (unsigned long int)7);
    if(return_value_strncmp_8 == 0)
    {
      if((signed int)url_param[7l] == 0)
        url_param[(signed long int)0] = (char)0;

    }

    else
    {
      return_value_strncmp_7=strncmp(url_param, "https://", (unsigned long int)8);
      if(return_value_strncmp_7 == 0)
      {
        if((signed int)url_param[8l] == 0)
          url_param[(signed long int)0] = (char)0;

      }

      else
        if(!((signed int)*url_param == 0))
        {
          return_value_strstr_3=strstr(url_param, "://");
          if(return_value_strstr_3 == ((char *)NULL))
            tmp_if_expr_6 = (_Bool)1;

          else
          {
            return_value_strstr_4=strstr(url_param, "://");
            return_value_strstr_5=strstr(url_param, "/");
            tmp_if_expr_6 = return_value_strstr_4 > return_value_strstr_5 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_6)
          {
            char *url_param_prefixed;
            url_param_prefixed=strdup_or_die("http://");
            enum privoxy_err return_value_string_join_2;
            return_value_string_join_2=string_join(&url_param_prefixed, url_param);
            if(!((signed int)return_value_string_join_2 == JB_ERR_OK))
            {
              free_map(exports);
              return (enum privoxy_err)JB_ERR_MEMORY;
            }

            url_param = url_param_prefixed;
          }

        }

    }
    if(global_toggle_state == 1)
    {
      return_value_map_block_killer_9=map_block_killer(exports, "privoxy-is-toggled-off");
      if(return_value_map_block_killer_9 == /*enum*/JB_ERR_OK)
        goto __CPROVER_DUMP_L11;

      if(!(url_param == ((char *)NULL)))
      {
        free((void *)url_param);
        url_param = (char *)(void *)0;
      }

      free_map(exports);
      return (enum privoxy_err)JB_ERR_MEMORY;
    }

    else
    {

    __CPROVER_DUMP_L11:
      ;
      if((signed int)*url_param == 0)
      {
        free((void *)url_param);
        enum privoxy_err return_value_map_block_killer_10;
        return_value_map_block_killer_10=map_block_killer(exports, "url-given");
        if(!(return_value_map_block_killer_10 == /*enum*/JB_ERR_OK))
          tmp_if_expr_12 = (_Bool)1;

        else
        {
          return_value_map_11=map(exports, "url", 1, "", 1);
          tmp_if_expr_12 = return_value_map_11 != (enum privoxy_err)0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_12)
        {
          free_map(exports);
          return (enum privoxy_err)JB_ERR_MEMORY;
        }

      }

      else
      {
        enum privoxy_err err;
        char *matches;
        char *s;
        signed int hits = 0;
        struct file_list *fl;
        struct url_actions *b;
        struct http_request url_to_query[1l];
        struct current_action_spec action[1l];
        signed int i;
        char *return_value_html_encode_13;
        return_value_html_encode_13=html_encode(url_param);
        enum privoxy_err return_value_map_14;
        return_value_map_14=map(exports, "url", 1, return_value_html_encode_13, 0);
        if(!(return_value_map_14 == /*enum*/JB_ERR_OK))
        {
          free((void *)url_param);
          free_map(exports);
          return (enum privoxy_err)JB_ERR_MEMORY;
        }

        init_current_action(action);
        char *return_value_current_action_to_html_15;
        return_value_current_action_to_html_15=current_action_to_html(csp, action);
        enum privoxy_err return_value_map_16;
        return_value_map_16=map(exports, "default", 1, return_value_current_action_to_html_15, 0);
        if(!(return_value_map_16 == /*enum*/JB_ERR_OK))
        {
          free_current_action(action);
          free((void *)url_param);
          free_map(exports);
          return (enum privoxy_err)JB_ERR_MEMORY;
        }

        memset((void *)url_to_query, 0, sizeof(struct http_request [1l]) /*120ul*/ );
        err=parse_http_url(url_param, url_to_query, 1);
        if(!((signed int)err == JB_ERR_OK))
          tmp_if_expr_18 = (_Bool)1;

        else
        {
          return_value_strncmpic_17=strncmpic(url_param, "https://", (unsigned long int)8);
          tmp_if_expr_18 = url_to_query[0l].ssl == (signed int)!(return_value_strncmpic_17 != 0) ? (_Bool)1 : (_Bool)0;
        }
        /* assertion (err != JB_ERR_OK) || (url_to_query->ssl == !strncmpic(url_param, "https://", 8)) */
        assert(tmp_if_expr_18);
        free((void *)url_param);
        if((signed int)err == JB_ERR_MEMORY)
        {
          free_http_request(url_to_query);
          free_current_action(action);
          free_map(exports);
          return (enum privoxy_err)JB_ERR_MEMORY;
        }

        else
          if(!(err == /*enum*/JB_ERR_OK))
          {
            err=map(exports, "matches", 1, "<b>[Invalid URL specified!]</b>", 1);
            if(err == /*enum*/JB_ERR_OK)
            {
              return_value_lookup_19=lookup(exports, "default");
              err=map(exports, "final", 1, return_value_lookup_19, 1);
            }

            if(err == /*enum*/JB_ERR_OK)
              err=map_block_killer(exports, "valid-url");

            free_current_action(action);
            free_http_request(url_to_query);
            if(!(err == /*enum*/JB_ERR_OK))
            {
              free_map(exports);
              return (enum privoxy_err)JB_ERR_MEMORY;
            }

            enum privoxy_err return_value_template_fill_for_cgi_20;
            return_value_template_fill_for_cgi_20=template_fill_for_cgi(csp, "show-url-info", exports, rsp);
            return return_value_template_fill_for_cgi_20;
          }

        if(url_to_query[0l].ssl == 0)
        {
          enum privoxy_err return_value_map_block_killer_21;
          return_value_map_block_killer_21=map_block_killer(exports, "https");
          if(!(return_value_map_block_killer_21 == /*enum*/JB_ERR_OK))
          {
            free_current_action(action);
            free_map(exports);
            free_http_request(url_to_query);
            return (enum privoxy_err)JB_ERR_MEMORY;
          }

        }

        matches=strdup_or_die("<table summary=\"\" class=\"transparent\">");
        i = 0;
        for( ; !(i >= 30); i = i + 1)
        {
          if(csp->config->actions_file_short[(signed long int)i] == ((const char *)NULL))
            tmp_if_expr_23 = (_Bool)1;

          else
          {
            return_value_strcmp_22=strcmp(csp->config->actions_file_short[(signed long int)i], "standard.action");
            tmp_if_expr_23 = !(return_value_strcmp_22 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr_23)
          {
            b = (struct url_actions *)(void *)0;
            hits = 1;
            fl = csp->actions_list[(signed long int)i];
            if(!(fl == ((struct file_list *)NULL)))
            {
              b = (struct url_actions *)fl->f;
              if(!(b == ((struct url_actions *)NULL)))
              {
                string_append(&matches, "<tr><th>In file: ");
                char *return_value_html_encode_24;
                return_value_html_encode_24=html_encode(csp->config->actions_file_short[(signed long int)i]);
                string_join(&matches, return_value_html_encode_24);
                snprintf(buf, sizeof(char [150l]) /*150ul*/ , " <a class=\"cmd\" href=\"/show-status?file=actions&amp;index=%d\">", i);
                string_append(&matches, buf);
                string_append(&matches, "View</a>");
                if(!((1U & csp->config->feature_flags) == 0u))
                {
                  signed int return_value_access_25;
                  return_value_access_25=access(csp->config->actions_file[(signed long int)i], 2);
                  if(return_value_access_25 == 0)
                  {
                    snprintf(buf, sizeof(char [150l]) /*150ul*/ , " <a class=\"cmd\" href=\"/edit-actions-list?f=%d\">", i);
                    string_append(&matches, buf);
                    string_append(&matches, "Edit</a>");
                  }

                  else
                    string_append(&matches, " <strong>No write access.</strong>");
                }

                string_append(&matches, "</th></tr>\n");
                hits = 0;
                b = b->next;
              }

            }

            for( ; !(matches == ((char *)NULL)) && !(b == ((struct url_actions *)NULL)); b = b->next)
            {
              signed int return_value_url_match_29;
              return_value_url_match_29=url_match(b->url, url_to_query);
              if(!(return_value_url_match_29 == 0))
              {
                string_append(&matches, "<tr><td>{");
                char *return_value_actions_to_html_26;
                return_value_actions_to_html_26=actions_to_html(csp, b->action);
                string_join(&matches, return_value_actions_to_html_26);
                string_append(&matches, " }<br>\n<code>");
                char *return_value_html_encode_27;
                return_value_html_encode_27=html_encode(b->url[0l].spec);
                string_join(&matches, return_value_html_encode_27);
                string_append(&matches, "</code></td></tr>\n");
                enum privoxy_err return_value_merge_current_action_28;
                return_value_merge_current_action_28=merge_current_action(action, b->action);
                if(!(return_value_merge_current_action_28 == /*enum*/JB_ERR_OK))
                {
                  if(!(matches == ((char *)NULL)))
                  {
                    free((void *)matches);
                    matches = (char *)(void *)0;
                  }

                  free_http_request(url_to_query);
                  free_current_action(action);
                  free_map(exports);
                  return (enum privoxy_err)JB_ERR_MEMORY;
                }

                hits = hits + 1;
              }

            }
            if(hits == 0)
              string_append(&matches, "<tr><td>(no matches in this file)</td></tr>\n");

          }

        }
        string_append(&matches, "</table>\n");
        free_current_action(csp->action);
        get_url_actions(csp, url_to_query);
        struct forward_spec *fwd;
        fwd=forward_url(csp, url_to_query);
        if(fwd->gateway_host == ((char *)NULL))
          tmp_if_expr_30 = fwd->forward_host == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_30 = (_Bool)0;
        if(tmp_if_expr_30)
        {
          if(err == /*enum*/JB_ERR_OK)
            err=map_block_killer(exports, "socks-forwarder");

          if(err == /*enum*/JB_ERR_OK)
            err=map_block_killer(exports, "http-forwarder");

        }

        else
        {
          char port[10l];
          if(err == /*enum*/JB_ERR_OK)
            err=map_block_killer(exports, "no-forwarder");

          if(!(fwd->gateway_host == ((char *)NULL)))
          {
            char *socks_type = (char *)(void *)0;
            switch((signed int)fwd->type)
            {
              case SOCKS_4:
              {
                socks_type = "socks4";
                break;
              }
              case SOCKS_4A:
              {
                socks_type = "socks4a";
                break;
              }
              case SOCKS_5:
              {
                socks_type = "socks5";
                break;
              }
              case SOCKS_5T:
              {
                socks_type = "socks5t";
                break;
              }
              default:
                log_error(0x4000, "Unknown socks type: %d.", fwd->type);
            }
            if(err == /*enum*/JB_ERR_OK)
              err=map(exports, "socks-type", 1, socks_type, 1);

            if(err == /*enum*/JB_ERR_OK)
              err=map(exports, "gateway-host", 1, fwd->gateway_host, 1);

            snprintf(port, sizeof(char [10l]) /*10ul*/ , "%d", fwd->gateway_port);
            if(err == /*enum*/JB_ERR_OK)
              err=map(exports, "gateway-port", 1, port, 1);

          }

          else
            if(err == /*enum*/JB_ERR_OK)
              err=map_block_killer(exports, "socks-forwarder");

          if(!(fwd->forward_host == ((char *)NULL)))
          {
            if(err == /*enum*/JB_ERR_OK)
              err=map(exports, "forward-host", 1, fwd->forward_host, 1);

            snprintf(port, sizeof(char [10l]) /*10ul*/ , "%d", fwd->forward_port);
            if(err == /*enum*/JB_ERR_OK)
              err=map(exports, "forward-port", 1, port, 1);

          }

          else
            if(err == /*enum*/JB_ERR_OK)
              err=map_block_killer(exports, "http-forwarder");

        }
        free_http_request(url_to_query);
        if(matches == ((char *)NULL) || !(err == /*enum*/JB_ERR_OK))
        {
          free_current_action(action);
          free_map(exports);
          return (enum privoxy_err)JB_ERR_MEMORY;
        }

        if(!((1U & csp->config->feature_flags) == 0u))
          err=map_block_killer(exports, "cgi-editor-is-disabled");

        if(err == /*enum*/JB_ERR_OK)
          err=map_block_killer(exports, "filters-might-be-ineffective");

        if(!(err == /*enum*/JB_ERR_OK))
          tmp_if_expr_32 = (_Bool)1;

        else
        {
          return_value_map_31=map(exports, "matches", 1, matches, 0);
          tmp_if_expr_32 = return_value_map_31 != (enum privoxy_err)0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_32)
        {
          free_current_action(action);
          free_map(exports);
          return (enum privoxy_err)JB_ERR_MEMORY;
        }

        s=current_action_to_html(csp, action);
        free_current_action(action);
        enum privoxy_err return_value_map_33;
        return_value_map_33=map(exports, "final", 1, s, 0);
        if(!(return_value_map_33 == /*enum*/JB_ERR_OK))
        {
          free_map(exports);
          return (enum privoxy_err)JB_ERR_MEMORY;
        }

      }
      enum privoxy_err return_value_template_fill_for_cgi_34;
      return_value_template_fill_for_cgi_34=template_fill_for_cgi(csp, "show-url-info", exports, rsp);
      return return_value_template_fill_for_cgi_34;
    }
  }
}

// cgi_show_version
// file cgisimple.h line 65
extern enum privoxy_err cgi_show_version(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  struct map *exports;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  exports=default_exports(csp, "show-version");
  if(exports == ((struct map *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    char *return_value_show_rcs_1;
    return_value_show_rcs_1=show_rcs();
    enum privoxy_err return_value_map_2;
    return_value_map_2=map(exports, "sourceversions", 1, return_value_show_rcs_1, 0);
    if(!(return_value_map_2 == /*enum*/JB_ERR_OK))
    {
      free_map(exports);
      return (enum privoxy_err)JB_ERR_MEMORY;
    }

    else
    {
      enum privoxy_err return_value_template_fill_for_cgi_3;
      return_value_template_fill_for_cgi_3=template_fill_for_cgi(csp, "show-version", exports, rsp);
      return return_value_template_fill_for_cgi_3;
    }
  }
}

// cgi_toggle
// file cgiedit.h line 88
extern enum privoxy_err cgi_toggle(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  struct map *exports;
  char mode;
  const char *template_name;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  if((2U & csp->config->feature_flags) == 0u)
  {
    enum privoxy_err return_value_cgi_error_disabled_1;
    return_value_cgi_error_disabled_1=cgi_error_disabled(csp, rsp);
    return return_value_cgi_error_disabled_1;
  }

  mode=get_char_param(parameters, "set");
  if((signed int)mode == 69)
    global_toggle_state = 1;

  else
    if((signed int)mode == 68)
      global_toggle_state = 0;

    else
      if((signed int)mode == 84)
        global_toggle_state = (signed int)!(global_toggle_state != 0);

  exports=default_exports(csp, "toggle");
  if(exports == ((struct map *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    char return_value_get_char_param_2;
    return_value_get_char_param_2=get_char_param(parameters, "mini");
    template_name = return_value_get_char_param_2 != 0 ? "toggle-mini" : "toggle";
    enum privoxy_err return_value_template_fill_for_cgi_3;
    return_value_template_fill_for_cgi_3=template_fill_for_cgi(csp, template_name, exports, rsp);
    return return_value_template_fill_for_cgi_3;
  }
}

// cgi_transparent_image
// file cgisimple.h line 71
extern enum privoxy_err cgi_transparent_image(struct client_state *csp, struct http_response *rsp, struct map *parameters)
{
  (void)csp;
  (void)parameters;
  rsp->body=bindup(image_blank_data, image_blank_length);
  rsp->content_length = image_blank_length;
  if(rsp->body == ((char *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    enum privoxy_err return_value_enlist_1;
    return_value_enlist_1=enlist(rsp->headers, "Content-Type: image/png");
    if(!(return_value_enlist_1 == /*enum*/JB_ERR_OK))
      return (enum privoxy_err)JB_ERR_MEMORY;

    else
    {
      rsp->is_static = 1;
      return (enum privoxy_err)JB_ERR_OK;
    }
  }
}

// change_request_destination
// file jcc.c line 945
static enum privoxy_err change_request_destination(struct client_state *csp)
{
  struct http_request *http = csp->http;
  enum privoxy_err err;
  log_error(0x0080, "Rewrite detected: %s", csp->headers[0l].first->str);
  free_http_request(http);
  err=parse_http_request(csp->headers[0l].first->str, http);
  if(!((signed int)err == JB_ERR_OK))
  {
    const char *return_value_jb_err_to_string_1;
    return_value_jb_err_to_string_1=jb_err_to_string((signed int)err);
    log_error(0x2000, "Couldn't parse rewritten request: %s.", return_value_jb_err_to_string_1);
  }

  return err;
}

// chat
// file jcc.c line 1818
static void chat(struct client_state *csp)
{
  char buf[5000l];
  char *hdr;
  char *p;
  struct anonymous_13 rfds;
  signed int n;
  signed int maxfd;
  signed int server_body;
  signed int ms_iis5_hack = 0;
  unsigned long long int byte_count = (unsigned long long int)0;
  struct forward_spec *fwd;
  struct http_request *http;
  signed long int len = (signed long int)0;
  signed int buffer_and_filter_content = 0;
  struct http_response *rsp;
  struct timeval timeout;
  signed int watch_client_socket;
  memset((void *)buf, 0, sizeof(char [5000l]) /*5000ul*/ );
  http = csp->http;
  enum privoxy_err return_value_receive_client_request_1;
  return_value_receive_client_request_1=receive_client_request(csp);
  signed int return_value_connect_port_is_forbidden_3;
  _Bool tmp_if_expr_8;
  signed int return_value_socket_is_still_alive_7;
  _Bool tmp_if_expr_10;
  signed int return_value_connection_destination_matches_9;
  _Bool tmp_if_expr_6;
  signed int *return_value___errno_location_5;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_16;
  signed long int return_value_flush_socket_13;
  signed int tmp_if_expr_18;
  signed int return_value_memcmp_19;
  signed int return_value_server_response_is_complete_20;
  signed int return_value_socket_is_still_alive_25;
  signed int return_value_read_socket_26;
  _Bool tmp_if_expr_27;
  signed int return_value_memcmp_28;
  _Bool tmp_if_expr_35;
  _Bool tmp_if_expr_34;
  char *tmp_if_expr_32;
  signed int return_value_write_socket_33;
  _Bool tmp_if_expr_59;
  _Bool tmp_if_expr_38;
  _Bool tmp_if_expr_40;
  signed int return_value_write_socket_39;
  signed int return_value_strncmpic_49;
  signed int return_value_memcmp_53;
  _Bool tmp_if_expr_57;
  if((signed int)return_value_receive_client_request_1 == JB_ERR_OK)
  {
    enum privoxy_err return_value_parse_client_request_2;
    return_value_parse_client_request_2=parse_client_request(csp);
    if((signed int)return_value_parse_client_request_2 == JB_ERR_OK)
    {
      fwd=forward_url(csp, http);
      if(fwd == ((struct forward_spec *)NULL))
        log_error(0x4000, "gateway spec is NULL!?!?  This can't happen!");

      else
      {
        if(!(http->ssl == 0))
        {
          return_value_connect_port_is_forbidden_3=connect_port_is_forbidden(csp);
          if(!(return_value_connect_port_is_forbidden_3 == 0))
          {
            const char *acceptable_connect_ports = csp->action[0l].string[(signed long int)5];
            /* assertion ((void *)0) != acceptable_connect_ports */
            assert((const char *)(void *)0 != acceptable_connect_ports);
            log_error(0x1000, "Request from %s marked for blocking. limit-connect{%s} doesn't allow CONNECT requests to %s", csp->ip_addr_str, acceptable_connect_ports, csp->http[0l].hostport);
            csp->action[0l].flags = csp->action[0l].flags | 0x00000001UL;
            http->ssl = 0;
          }

        }

        if(http->ssl == 0)
        {
          if(!(csp->headers[0l].first->str == ((char *)NULL)))
          {
            free((void *)csp->headers[0l].first->str);
            csp->headers[0l].first->str = (char *)(void *)0;
          }

          build_request_line(csp, fwd, &csp->headers[0l].first->str);
        }

        signed int return_value_crunch_response_triggered_4;
        return_value_crunch_response_triggered_4=crunch_response_triggered(csp, crunchers_all);
        if(return_value_crunch_response_triggered_4 == 0)
        {
          log_applied_actions(csp->action);
          log_error(0x0001, "%s%s", http->hostport, http->path);
          if(!(fwd->forward_host == ((char *)NULL)))
            log_error(0x0002, "via [%s]:%d to: %s", fwd->forward_host, fwd->forward_port, http->hostport);

          else
            log_error(0x0002, "to %s", http->hostport);
          if(!(csp->server_connection.sfd == -1))
          {
            return_value_socket_is_still_alive_7=socket_is_still_alive(csp->server_connection.sfd);
            tmp_if_expr_8 = return_value_socket_is_still_alive_7 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_8 = (_Bool)0;
          if(tmp_if_expr_8)
          {
            return_value_connection_destination_matches_9=connection_destination_matches(&csp->server_connection, http, fwd);
            tmp_if_expr_10 = return_value_connection_destination_matches_9 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_10 = (_Bool)0;
          if(tmp_if_expr_10)
            log_error(0x0002, "Reusing server socket %d connected to %s. Total requests: %u.", csp->server_connection.sfd, csp->server_connection.host, csp->server_connection.requests_sent_total);

          else
          {
            if(!(csp->server_connection.sfd == -1))
            {
              if(!((256U & csp->config->feature_flags) == 0u))
                remember_connection(&csp->server_connection);

              else
              {
                log_error(0x0002, "Closing server socket %d connected to %s. Total requests: %u.", csp->server_connection.sfd, csp->server_connection.host, csp->server_connection.requests_sent_total);
                close_socket(csp->server_connection.sfd);
              }
              mark_connection_closed(&csp->server_connection);
            }

            csp->server_connection.sfd=forwarded_connect(fwd, http, csp);
            if(csp->server_connection.sfd == -1)
            {
              if(!((signed int)fwd->type == SOCKS_NONE))
                tmp_if_expr_6 = (signed int)fwd->type != FORWARD_WEBSERVER ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_6 = (_Bool)0;
              if(tmp_if_expr_6)
                rsp=error_response(csp, "forwarding-failed");

              else
              {
                return_value___errno_location_5=__errno_location();
                if(*return_value___errno_location_5 == 22)
                  rsp=error_response(csp, "no-such-domain");

                else
                  rsp=error_response(csp, "connect-failed");
              }
              if(!(rsp == ((struct http_response *)NULL)))
                send_crunch_response(csp, rsp);

              drain_and_close_socket(csp->cfd);
              csp->cfd = -1;
              goto __CPROVER_DUMP_L129;
            }

            save_connection_destination(csp->server_connection.sfd, http, fwd, &csp->server_connection);
            csp->server_connection.keep_alive_timeout = (unsigned int)csp->config->keep_alive_timeout;
          }
          csp->server_connection.requests_sent_total = csp->server_connection.requests_sent_total + 1u;
          if((signed int)fwd->type == SOCKS_5T)
            tmp_if_expr_17 = (struct list_entry *)(void *)0 == csp->headers[0l].first ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_17 = (_Bool)0;
          if(tmp_if_expr_17)
            /* assertion csp->headers->last == ((void *)0) */
            assert(csp->headers[0l].last == (struct list_entry *)(void *)0);

          else
          {
            if(!(fwd->forward_host == ((char *)NULL)))
              tmp_if_expr_16 = (_Bool)1;

            else
              tmp_if_expr_16 = http->ssl == 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_16)
            {
              signed int write_failure;
              hdr=list_to_text(csp->headers);
              if(hdr == ((char *)NULL))
                log_error(0x4000, "Out of memory parsing client header");

              list_remove_all(csp->headers);
              unsigned long int return_value_strlen_11;
              return_value_strlen_11=strlen(hdr);
              signed int return_value_write_socket_12;
              return_value_write_socket_12=write_socket(csp->server_connection.sfd, hdr, return_value_strlen_11);
              write_failure = (signed int)(0 != return_value_write_socket_12);
              if(!(hdr == ((char *)NULL)))
              {
                free((void *)hdr);
                hdr = (char *)(void *)0;
              }

              if(!(write_failure == 0))
                log_error(0x0002, "Failed sending request headers to: %s: %E", http->hostport);

              else
                if((0x00800000U & csp->flags) == 0u)
                {
                  return_value_flush_socket_13=flush_socket(csp->server_connection.sfd, csp->client_iob);
                  if(!(return_value_flush_socket_13 >= 0l))
                  {
                    write_failure = 1;
                    log_error(0x0002, "Failed sending request body to: %s: %E", http->hostport);
                  }

                }

              if(!(write_failure == 0))
              {
                rsp=error_response(csp, "connect-failed");
                if(!(rsp == ((struct http_response *)NULL)))
                  send_crunch_response(csp, rsp);

                goto __CPROVER_DUMP_L129;
              }

            }

            else
            {
              list_remove_all(csp->headers);
              unsigned long int return_value_strlen_14;
              return_value_strlen_14=strlen(CSUCCEED);
              signed int return_value_write_socket_15;
              return_value_write_socket_15=write_socket(csp->cfd, CSUCCEED, return_value_strlen_14);
              if(!(return_value_write_socket_15 == 0))
                goto __CPROVER_DUMP_L129;

              clear_iob(csp->client_iob);
            }
          }
          log_error(0x0002, "to %s successful", http->hostport);
          csp->server_connection.request_sent=time((signed long int *)(void *)0);
          if(!(csp->server_connection.sfd >= csp->cfd))
            tmp_if_expr_18 = csp->cfd;

          else
            tmp_if_expr_18 = csp->server_connection.sfd;
          maxfd = tmp_if_expr_18;
          server_body = 0;
          watch_client_socket = (signed int)((unsigned int)0 == (csp->flags & 0x00800000U));
          do
          {

          __CPROVER_DUMP_L42:
            ;
            signed int __d0;
            signed int __d1;
            asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_13) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfds)->__fds_bits[(signed long int)0]) : "memory");
            if(watch_client_socket == 0)
              maxfd = csp->server_connection.sfd;

            else
              (&rfds)->__fds_bits[(signed long int)(csp->cfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfds)->__fds_bits[(signed long int)(csp->cfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << csp->cfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
            (&rfds)->__fds_bits[(signed long int)(csp->server_connection.sfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfds)->__fds_bits[(signed long int)(csp->server_connection.sfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << csp->server_connection.sfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
            if(!((0x02U & csp->flags) == 0u))
            {
              if((0x00004000U & csp->flags) == 0u)
              {
                if(csp->iob[0l].eod - csp->iob[0l].cur >= 5l)
                {
                  return_value_memcmp_19=memcmp((const void *)(csp->iob[0l].eod - (signed long int)5), (const void *)"0\r\n\r\n", (unsigned long int)5);
                  if(return_value_memcmp_19 == 0)
                  {
                    log_error(0x0002, "Looks like we got the last chunk together with the server headers but didn't detect it earlier. We better stop reading.");
                    byte_count = (unsigned long long int)(csp->iob[0l].eod - csp->iob[0l].cur);
                    csp->expected_content_length = byte_count;
                    csp->flags = csp->flags | 0x00004000U;
                  }

                }

              }

            }

            if(!(server_body == 0))
            {
              return_value_server_response_is_complete_20=server_response_is_complete(csp, byte_count);
              if(return_value_server_response_is_complete_20 == 0)
                goto __CPROVER_DUMP_L48;

              if(csp->expected_content_length == byte_count)
                log_error(0x0002, "Done reading from server. Content length: %llu as expected. Bytes most recently read: %d.", byte_count, len);

              else
                log_error(0x0002, "Done reading from server. Expected content length: %llu. Actual content length: %llu. Bytes most recently read: %d.", csp->expected_content_length, byte_count, len);
              len = (signed long int)0;
            }

            else
            {

            __CPROVER_DUMP_L48:
              ;
              timeout.tv_sec = (signed long int)csp->config->socket_timeout;
              timeout.tv_usec = (signed long int)0;
              n=select((signed int)maxfd + 1, &rfds, (struct anonymous_13 *)(void *)0, (struct anonymous_13 *)(void *)0, &timeout);
              if(n == 0)
              {
                log_error(0x2000, "Didn't receive data in time: %s", http->url);
                if(byte_count == 0ul)
                {
                  if(http->ssl == 0)
                  {
                    struct http_response *return_value_error_response_21;
                    return_value_error_response_21=error_response(csp, "connection-timeout");
                    send_crunch_response(csp, return_value_error_response_21);
                  }

                }

                mark_server_socket_tainted(csp);
                goto __CPROVER_DUMP_L129;
              }

              else
                if(!(n >= 0))
                {
                  log_error(0x2000, "select() failed!: %E");
                  mark_server_socket_tainted(csp);
                  goto __CPROVER_DUMP_L129;
                }

              if(!((rfds.__fds_bits[(signed long int)(csp->cfd / 8)] & (signed long int)(1UL << csp->cfd % 8)) == 0l))
              {
                signed int max_bytes_to_read = (signed int)(sizeof(char [5000l]) /*5000ul*/  - (unsigned long int)1);
                if(!((0x00010000U & csp->flags) == 0u))
                {
                  signed int return_value_data_is_available_22;
                  return_value_data_is_available_22=data_is_available(csp->cfd, 0);
                  if(!(return_value_data_is_available_22 == 0))
                  {
                    watch_client_socket = 0;
                    log_error(0x0002, "Stopping to watch the client socket %d. There's already another request waiting.", csp->cfd);
                    continue;
                  }

                  log_error(0x0002, "The client closed socket %d while the server socket %d is still open.", csp->cfd, csp->server_connection.sfd);
                  mark_server_socket_tainted(csp);
                  break;
                }

                if(!(csp->expected_client_content_length == 0ul))
                {
                  if(!(csp->expected_client_content_length >= 4999ul))
                    max_bytes_to_read = (signed int)csp->expected_client_content_length;

                  log_error(0x0002, "Waiting for up to %d bytes from the client.", max_bytes_to_read);
                }

                /* assertion max_bytes_to_read < sizeof(buf) */
                assert((unsigned long int)max_bytes_to_read < sizeof(char [5000l]) /*5000ul*/ );
                signed int return_value_read_socket_23;
                return_value_read_socket_23=read_socket(csp->cfd, buf, max_bytes_to_read);
                len = (signed long int)return_value_read_socket_23;
                if(!(len >= 1l))
                {
                  mark_server_socket_tainted(csp);
                  break;
                }

                if(!(csp->expected_client_content_length == 0ul))
                {
                  /* assertion len <= max_bytes_to_read */
                  assert(len <= (signed long int)max_bytes_to_read);
                  csp->expected_client_content_length = csp->expected_client_content_length - (unsigned long long int)(unsigned int)len;
                  log_error(0x0002, "Expected client content length set to %llu after reading %d bytes.", csp->expected_client_content_length, len);
                  if(csp->expected_client_content_length == 0ul)
                  {
                    log_error(0x0002, "Done reading from the client.");
                    csp->flags = csp->flags | 0x00010000U;
                  }

                }

                signed int return_value_write_socket_24;
                return_value_write_socket_24=write_socket(csp->server_connection.sfd, buf, (unsigned long int)len);
                if(!(return_value_write_socket_24 == 0))
                {
                  log_error(0x2000, "write to: %s failed: %E", http->host);
                  mark_server_socket_tainted(csp);
                  goto __CPROVER_DUMP_L129;
                }

                continue;
              }

              if((rfds.__fds_bits[(signed long int)(csp->server_connection.sfd / 8)] & (signed long int)(1UL << csp->server_connection.sfd % 8)) == 0l)
                goto __CPROVER_DUMP_L124;

              if(!(buffer_and_filter_content == 0))
              {
                return_value_socket_is_still_alive_25=socket_is_still_alive(csp->cfd);
                if(return_value_socket_is_still_alive_25 == 0)
                {
                  log_error(0x0002, "The server still wants to talk, but the client hung up on us.");
                  mark_server_socket_tainted(csp);
                  goto __CPROVER_DUMP_L129;
                }

              }

              return_value_read_socket_26=read_socket(csp->server_connection.sfd, buf, (signed int)(sizeof(char [5000l]) /*5000ul*/  - (unsigned long int)1));
              len = (signed long int)return_value_read_socket_26;
              if(!(len >= 0l))
              {
                log_error(0x2000, "read from: %s failed: %E", http->host);
                if(!(http->ssl == 0))
                  tmp_if_expr_27 = fwd->forward_host == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_27 = (_Bool)0;
                if(tmp_if_expr_27)
                {
                  log_error(0x2000, "CONNECT already confirmed. Unable to tell the client about the problem.");
                  goto __CPROVER_DUMP_L129;
                }

                else
                  if(!(byte_count == 0ull))
                  {
                    log_error(0x2000, "Already forwarded the original headers. Unable to tell the client about the problem.");
                    mark_server_socket_tainted(csp);
                    goto __CPROVER_DUMP_L129;
                  }

                mark_server_socket_tainted(csp);
                len = (signed long int)0;
              }

              if(!((0x02U & csp->flags) == 0u))
              {
                if(len >= 5l)
                {
                  return_value_memcmp_28=memcmp((const void *)((buf + len) - (signed long int)5), (const void *)"0\r\n\r\n", (unsigned long int)5);
                  if(return_value_memcmp_28 == 0)
                  {
                    log_error(0x0002, "Looks like we reached the end of the last chunk. We better stop reading.");
                    csp->expected_content_length = byte_count + (unsigned long long int)len;
                    csp->flags = csp->flags | 0x00004000U;
                  }

                }

              }

            }

          reading_done:
            ;
            buf[len] = (char)0;
            if(len == 0l)
            {
              if(!(server_body == 0))
                tmp_if_expr_35 = (_Bool)1;

              else
                tmp_if_expr_35 = http->ssl != 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_35)
              {
                if(!(buffer_and_filter_content == 0))
                {
                  p=execute_content_filters(csp);
                  if(p == ((char *)NULL))
                    csp->content_length = (unsigned long int)(csp->iob[0l].eod - csp->iob[0l].cur);

                  enum privoxy_err return_value_update_server_headers_29;
                  return_value_update_server_headers_29=update_server_headers(csp);
                  if(!((signed int)return_value_update_server_headers_29 == JB_ERR_OK))
                    log_error(0x4000, "Failed to update server headers. after filtering.");

                  hdr=list_to_text(csp->headers);
                  if(hdr == ((char *)NULL))
                    log_error(0x4000, "Out of memory parsing server header");

                  unsigned long int return_value_strlen_30;
                  return_value_strlen_30=strlen(hdr);
                  signed int return_value_write_socket_31;
                  return_value_write_socket_31=write_socket(csp->cfd, hdr, return_value_strlen_30);
                  if(!(return_value_write_socket_31 == 0))
                    tmp_if_expr_34 = (_Bool)1;

                  else
                  {
                    if(!(p == ((char *)NULL)))
                      tmp_if_expr_32 = p;

                    else
                      tmp_if_expr_32 = csp->iob[0l].cur;
                    return_value_write_socket_33=write_socket(csp->cfd, tmp_if_expr_32, (unsigned long int)csp->content_length);
                    tmp_if_expr_34 = return_value_write_socket_33 != 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_34)
                  {
                    log_error(0x2000, "write modified content to client failed: %E");
                    if(!(hdr == ((char *)NULL)))
                    {
                      free((void *)hdr);
                      hdr = (char *)(void *)0;
                    }

                    if(!(p == ((char *)NULL)))
                    {
                      free((void *)p);
                      p = (char *)(void *)0;
                    }

                    mark_server_socket_tainted(csp);
                    goto __CPROVER_DUMP_L129;
                  }

                  if(!(hdr == ((char *)NULL)))
                  {
                    free((void *)hdr);
                    hdr = (char *)(void *)0;
                  }

                  if(!(p == ((char *)NULL)))
                  {
                    free((void *)p);
                    p = (char *)(void *)0;
                  }

                }

                break;
              }

              snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , "\r\n");
              unsigned long int return_value_strlen_36;
              return_value_strlen_36=strlen(buf);
              len = (signed long int)(signed int)return_value_strlen_36;
              ms_iis5_hack = 1;
            }

            if(!(server_body == 0))
              tmp_if_expr_59 = (_Bool)1;

            else
              tmp_if_expr_59 = http->ssl != 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_59)
            {
              if(!(buffer_and_filter_content == 0))
              {
                enum privoxy_err return_value_add_to_iob_41;
                return_value_add_to_iob_41=add_to_iob(csp->iob, csp->config->buffer_limit, buf, len);
                if(!(return_value_add_to_iob_41 == /*enum*/JB_ERR_OK))
                {
                  unsigned long int hdrlen;
                  signed long int flushed;
                  log_error(0x1000, "Flushing header and buffers. Stepping back from filtering.");
                  hdr=list_to_text(csp->headers);
                  if(hdr == ((char *)NULL))
                  {
                    log_error(0x2000, "Out of memory while trying to flush.");
                    rsp=cgi_error_memory();
                    send_crunch_response(csp, rsp);
                    mark_server_socket_tainted(csp);
                    goto __CPROVER_DUMP_L129;
                  }

                  hdrlen=strlen(hdr);
                  signed int return_value_write_socket_37;
                  return_value_write_socket_37=write_socket(csp->cfd, hdr, hdrlen);
                  if(!(return_value_write_socket_37 == 0))
                    tmp_if_expr_38 = (_Bool)1;

                  else
                  {
                    flushed=flush_socket(csp->cfd, csp->iob);
                    tmp_if_expr_38 = flushed < (signed long int)0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_38)
                    tmp_if_expr_40 = (_Bool)1;

                  else
                  {
                    return_value_write_socket_39=write_socket(csp->cfd, buf, (unsigned long int)len);
                    tmp_if_expr_40 = return_value_write_socket_39 != 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_40)
                  {
                    log_error(0x0002, "Flush header and buffers to client failed: %E");
                    if(!(hdr == ((char *)NULL)))
                    {
                      free((void *)hdr);
                      hdr = (char *)(void *)0;
                    }

                    mark_server_socket_tainted(csp);
                    goto __CPROVER_DUMP_L129;
                  }

                  byte_count = (unsigned long long int)flushed;
                  if(!(hdr == ((char *)NULL)))
                  {
                    free((void *)hdr);
                    hdr = (char *)(void *)0;
                  }

                  buffer_and_filter_content = 0;
                  server_body = 1;
                }

              }

              else
              {
                signed int return_value_write_socket_42;
                return_value_write_socket_42=write_socket(csp->cfd, buf, (unsigned long int)len);
                if(!(return_value_write_socket_42 == 0))
                {
                  log_error(0x2000, "write to client failed: %E");
                  mark_server_socket_tainted(csp);
                  goto __CPROVER_DUMP_L129;
                }

              }
              byte_count = byte_count + (unsigned long long int)len;
              continue;
            }

            else
            {
              enum privoxy_err return_value_add_to_iob_43;
              return_value_add_to_iob_43=add_to_iob(csp->iob, csp->config->buffer_limit, buf, len);
              if(!(return_value_add_to_iob_43 == /*enum*/JB_ERR_OK))
              {
                log_error(0x2000, "Out of memory while looking for end of server headers.");
                rsp=cgi_error_memory();
                send_crunch_response(csp, rsp);
                mark_server_socket_tainted(csp);
                goto __CPROVER_DUMP_L129;
              }

              enum privoxy_err return_value_get_server_headers_45;
              return_value_get_server_headers_45=get_server_headers(csp);
              if((signed int)return_value_get_server_headers_45 == JB_ERR_PARSE)
              {
                if(!(ms_iis5_hack == 0))
                {
                  log_error(0x2000, "Invalid server headers. Applying the MS IIS5 hack didn't help.");
                  log_error(0x0200, "%s - - [%T] \"%s\" 502 0", csp->ip_addr_str, http->cmd);
                  unsigned long int return_value_strlen_44;
                  return_value_strlen_44=strlen(INVALID_SERVER_HEADERS_RESPONSE);
                  write_socket(csp->cfd, INVALID_SERVER_HEADERS_RESPONSE, return_value_strlen_44);
                  mark_server_socket_tainted(csp);
                  goto __CPROVER_DUMP_L129;
                }

                else
                {
                  log_error(0x0002, "Continuing buffering server headers from socket %d. Bytes most recently read: %d.", csp->cfd, len);
                  continue;
                }
              }

              else
              {
                /* assertion csp->iob->eod >= csp->iob->cur */
                assert(csp->iob[0l].eod >= csp->iob[0l].cur);
                byte_count = (unsigned long long int)(csp->iob[0l].eod - csp->iob[0l].cur);
              }
              if(csp->headers[0l].first == ((struct list_entry *)NULL))
              {
                if(!((0x00100000U & csp->flags) == 0u))
                {
                  log_error(0x2000, "No server or forwarder response received on socket %d. Closing client socket %d without sending data.", csp->server_connection.sfd, csp->cfd);
                  log_error(0x0200, "%s - - [%T] \"%s\" 502 0", csp->ip_addr_str, http->cmd);
                }

                else
                {
                  log_error(0x2000, "No server or forwarder response received on socket %d.", csp->server_connection.sfd);
                  struct http_response *return_value_error_response_46;
                  return_value_error_response_46=error_response(csp, "no-server-data");
                  send_crunch_response(csp, return_value_error_response_46);
                }
                free_http_request(http);
                mark_server_socket_tainted(csp);
                goto __CPROVER_DUMP_L129;
              }

              /* assertion csp->headers->first->str */
              assert(csp->headers[0l].first->str != ((char *)NULL));
              /* assertion !http->ssl */
              assert(!(http->ssl != 0));
              signed int return_value_strncmpic_50;
              return_value_strncmpic_50=strncmpic(csp->headers[0l].first->str, "HTTP", (unsigned long int)4);
              if(!(return_value_strncmpic_50 == 0))
              {
                return_value_strncmpic_49=strncmpic(csp->headers[0l].first->str, "ICY", (unsigned long int)3);
                if(!(return_value_strncmpic_49 == 0))
                {
                  unsigned long int return_value_strlen_47;
                  return_value_strlen_47=strlen(csp->headers[0l].first->str);
                  if(return_value_strlen_47 >= 31ul)
                    csp->headers[0l].first->str[(signed long int)30] = (char)0;

                  log_error(0x2000, "Invalid server or forwarder response. Starts with: %s", csp->headers[0l].first->str);
                  log_error(0x0200, "%s - - [%T] \"%s\" 502 0", csp->ip_addr_str, http->cmd);
                  unsigned long int return_value_strlen_48;
                  return_value_strlen_48=strlen(INVALID_SERVER_HEADERS_RESPONSE);
                  write_socket(csp->cfd, INVALID_SERVER_HEADERS_RESPONSE, return_value_strlen_48);
                  free_http_request(http);
                  mark_server_socket_tainted(csp);
                  goto __CPROVER_DUMP_L129;
                }

              }

              enum privoxy_err return_value_sed_52;
              return_value_sed_52=sed(csp, 1);
              if(!((signed int)return_value_sed_52 == JB_ERR_OK))
              {
                log_error(0x0200, "%s - - [%T] \"%s\" 502 0", csp->ip_addr_str, http->cmd);
                unsigned long int return_value_strlen_51;
                return_value_strlen_51=strlen(INVALID_SERVER_HEADERS_RESPONSE);
                write_socket(csp->cfd, INVALID_SERVER_HEADERS_RESPONSE, return_value_strlen_51);
                free_http_request(http);
                mark_server_socket_tainted(csp);
                goto __CPROVER_DUMP_L129;
              }

              hdr=list_to_text(csp->headers);
              if(hdr == ((char *)NULL))
                log_error(0x4000, "Out of memory parsing server header");

              if(!((0x02U & csp->flags) == 0u))
              {
                if((0x00004000U & csp->flags) == 0u)
                {
                  if(csp->iob[0l].eod - csp->iob[0l].cur >= 5l)
                  {
                    return_value_memcmp_53=memcmp((const void *)(csp->iob[0l].eod - (signed long int)5), (const void *)"0\r\n\r\n", (unsigned long int)5);
                    if(return_value_memcmp_53 == 0)
                    {
                      log_error(0x0002, "Looks like we got the last chunk together with the server headers. We better stop reading.");
                      byte_count = (unsigned long long int)(csp->iob[0l].eod - csp->iob[0l].cur);
                      csp->expected_content_length = byte_count;
                      csp->flags = csp->flags | 0x00004000U;
                    }

                  }

                }

              }

              csp->server_connection.response_received=time((signed long int *)(void *)0);
              signed int return_value_crunch_response_triggered_54;
              return_value_crunch_response_triggered_54=crunch_response_triggered(csp, crunchers_light);
              if(!(return_value_crunch_response_triggered_54 == 0))
              {
                if(!(hdr == ((char *)NULL)))
                {
                  free((void *)hdr);
                  hdr = (char *)(void *)0;
                }

                mark_server_socket_tainted(csp);
                goto __CPROVER_DUMP_L129;
              }

              if(http->ssl == 0)
                buffer_and_filter_content=content_requires_filtering(csp);

              if(buffer_and_filter_content == 0)
              {
                unsigned long int return_value_strlen_55;
                return_value_strlen_55=strlen(hdr);
                signed int return_value_write_socket_56;
                return_value_write_socket_56=write_socket(csp->cfd, hdr, return_value_strlen_55);
                if(!(return_value_write_socket_56 == 0))
                  tmp_if_expr_57 = (_Bool)1;

                else
                {
                  len=flush_socket(csp->cfd, csp->iob);
                  tmp_if_expr_57 = len < (signed long int)0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_57)
                {
                  log_error(0x0002, "write header to client failed: %E");
                  if(!(hdr == ((char *)NULL)))
                  {
                    free((void *)hdr);
                    hdr = (char *)(void *)0;
                  }

                  mark_server_socket_tainted(csp);
                  goto __CPROVER_DUMP_L129;
                }

              }

              if(!(hdr == ((char *)NULL)))
              {
                free((void *)hdr);
                hdr = (char *)(void *)0;
              }

              server_body = 1;
              if(!(ms_iis5_hack == 0))
              {
                log_error(0x2000, "Closed server connection detected. Applying the MS IIS5 hack didn't help.");
                log_error(0x0200, "%s - - [%T] \"%s\" 502 0", csp->ip_addr_str, http->cmd);
                unsigned long int return_value_strlen_58;
                return_value_strlen_58=strlen(INVALID_SERVER_HEADERS_RESPONSE);
                write_socket(csp->cfd, INVALID_SERVER_HEADERS_RESPONSE, return_value_strlen_58);
                mark_server_socket_tainted(csp);
                goto __CPROVER_DUMP_L129;
              }

            }
            continue;

          __CPROVER_DUMP_L124:
            ;
            mark_server_socket_tainted(csp);
            goto __CPROVER_DUMP_L129;
          }
          while((_Bool)1);
          if(csp->content_length == 0ul)
            csp->content_length = byte_count;

          if(!((0x00004000U & csp->flags) == 0u))
          {
            if(!(csp->expected_content_length == byte_count))
            {
              log_error(0x0002, "Received %llu bytes while expecting %llu.", byte_count, csp->expected_content_length);
              mark_server_socket_tainted(csp);
            }

          }

          log_error(0x0200, "%s - - [%T] \"%s\" 200 %llu", csp->ip_addr_str, http->ocmd, csp->content_length);
          csp->server_connection.timestamp=time((signed long int *)(void *)0);
        }

      }
    }

  }


__CPROVER_DUMP_L129:
  ;
}

// check_file_changed
// file loaders.h line 43
extern signed int check_file_changed(struct file_list *current, const char *filename, struct file_list **newfl)
{
  struct file_list *fs;
  struct stat statbuf[1l];
  *newfl = (struct file_list *)(void *)0;
  signed int return_value_stat_1;
  return_value_stat_1=stat(filename, statbuf);
  signed int return_value_strcmp_2;
  if(!(return_value_stat_1 >= 0))
    return 1;

  else
    if(!(current == ((struct file_list *)NULL)))
    {
      if(!(current->lastmodified == statbuf[0l].st_mtim.tv_sec))
        goto __CPROVER_DUMP_L2;

      return_value_strcmp_2=strcmp(current->filename, filename);
      if(!(return_value_strcmp_2 == 0))
        goto __CPROVER_DUMP_L2;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      void *return_value_zalloc_3;
      return_value_zalloc_3=zalloc(sizeof(struct file_list) /*48ul*/ );
      fs = (struct file_list *)return_value_zalloc_3;
      if(fs == ((struct file_list *)NULL))
        return 1;

      else
      {
        fs->filename=strdup(filename);
        fs->lastmodified = statbuf[0l].st_mtim.tv_sec;
        if(fs->filename == ((char *)NULL))
        {
          if(!(fs == ((struct file_list *)NULL)))
          {
            free((void *)fs);
            fs = (struct file_list *)(void *)0;
          }

          return 1;
        }

        else
        {
          *newfl = fs;
          return 1;
        }
      }
    }
}

// check_negative_tag_patterns
// file actions.c line 859
extern enum privoxy_err check_negative_tag_patterns(struct client_state *csp, unsigned int flag)
{
  struct list_entry *tag;
  struct file_list *fl;
  struct url_actions *b = (struct url_actions *)(void *)0;
  signed int i = 0;
  _Bool tmp_if_expr_1;
  for( ; !(i >= 30); i = i + 1)
  {
    fl = csp->actions_list[(signed long int)i];
    if(fl == ((struct file_list *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
    {
      b = (struct url_actions *)fl->f;
      tmp_if_expr_1 = b == (struct url_actions *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_1)
    {
      b = b->next;
      for( ; !(b == ((struct url_actions *)NULL)); b = b->next)
      {
        signed int tag_found = 0;
        if(!((b->url[0l].flags & flag) == 0u))
        {
          tag = csp->tags[0l].first;
          for( ; !(tag == ((struct list_entry *)NULL)); tag = tag->next)
          {
            signed int return_value_pcreposix_regexec_2;
            return_value_pcreposix_regexec_2=pcreposix_regexec(b->url[0l].pattern.tag_regex, tag->str, (unsigned long int)0, (struct anonymous_4 *)(void *)0, 0);
            if(return_value_pcreposix_regexec_2 == 0)
            {
              tag_found = 1;
              break;
            }

          }
          if(tag_found == 0)
          {
            enum privoxy_err return_value_merge_current_action_3;
            return_value_merge_current_action_3=merge_current_action(csp->action, b->action);
            if(!(return_value_merge_current_action_3 == /*enum*/JB_ERR_OK))
            {
              log_error(0x2000, "Out of memory while changing action bits");
              return (enum privoxy_err)JB_ERR_MEMORY;
            }

            log_error(0x0008, "Updated action bits based on: %s", b->url[0l].spec);
          }

        }

      }
    }

  }
  return (enum privoxy_err)JB_ERR_OK;
}

// chomp
// file miscutil.h line 66
extern char * chomp(char *string)
{
  char *p;
  char *q;
  char *r;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  p = string + (signed long int)return_value_strlen_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  for( ; !(string >= p); p = p - 1l)
  {
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)p[-1l]]) == 0)
      break;

  }
  *p = (char)0;
  r = string;
  q = r;
  const unsigned short int **return_value___ctype_b_loc_3;
  for( ; !(*q == 0); q = q + 1l)
  {
    return_value___ctype_b_loc_3=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)(unsigned char)*q]) == 0)
      break;

  }
  char *tmp_post_4;
  char *tmp_post_5;
  if(!(q == string))
    for( ; p >= q; *tmp_post_4 = *tmp_post_5)
    {
      tmp_post_4 = r;
      r = r + 1l;
      tmp_post_5 = q;
      q = q + 1l;
    }

  return string;
}

// chunked_body_is_complete
// file jcc.c line 1347
static enum chunk_status chunked_body_is_complete(struct iob *iob, unsigned long int *length)
{
  unsigned int chunksize;
  char *p = iob->cur;
  while((_Bool)1)
  {
    if(!(iob->eod >= p + 5l))
      return (enum chunk_status)CHUNK_STATUS_MISSING_DATA;

    signed int return_value_sscanf_1;
    return_value_sscanf_1=sscanf(p, "%x", &chunksize);
    if(!(return_value_sscanf_1 == 1))
      return (enum chunk_status)CHUNK_STATUS_PARSE_ERROR;

    if(!(iob->eod >= p + (signed long int)chunksize + 5l))
      return (enum chunk_status)CHUNK_STATUS_MISSING_DATA;

    p=strstr(p, "\r\n");
    if(p == ((char *)NULL))
      return (enum chunk_status)CHUNK_STATUS_PARSE_ERROR;

    p = p + (signed long int)((unsigned int)2 + chunksize);
    signed int return_value_memcmp_2;
    return_value_memcmp_2=memcmp((const void *)p, (const void *)"\r\n", (unsigned long int)2);
    if(!(return_value_memcmp_2 == 0))
      return (enum chunk_status)CHUNK_STATUS_PARSE_ERROR;

    p = p + (signed long int)2;
    if(!(chunksize >= 1u))
      break;

  }
  *length = (unsigned long int)(p - iob->cur);
  /* assertion *length <= (size_t)(iob->eod - iob->cur) */
  assert(*length <= (unsigned long int)(iob->eod - iob->cur));
  /* assertion p <= iob->eod */
  assert(p <= iob->eod);
  return (enum chunk_status)CHUNK_STATUS_BODY_COMPLETE;
}

// clear_iob
// file parsers.h line 55
extern void clear_iob(struct iob *iob)
{
  free((void *)iob->buf);
  memset((void *)iob, 0, sizeof(struct iob) /*32ul*/ );
}

// client_accept_encoding
// file parsers.c line 2776
static enum privoxy_err client_accept_encoding(struct client_state *csp, char **header)
{
  if(!((0x00000400UL & csp->action[0l].flags) == 0ul))
  {
    log_error(0x0008, "Suppressed offer to compress content");
    if(!(*header == ((char *)NULL)))
    {
      free((void *)*header);
      *header = (char *)(void *)0;
    }

  }

  return (enum privoxy_err)JB_ERR_OK;
}

// client_accept_language
// file parsers.c line 2922
static enum privoxy_err client_accept_language(struct client_state *csp, char **header)
{
  const char *newval;
  _Bool tmp_if_expr_2;
  signed int return_value_strcmpic_1;
  if((0x04000000UL & csp->action[0l].flags) == 0ul)
    return (enum privoxy_err)JB_ERR_OK;

  else
  {
    newval = csp->action[0l].string[(signed long int)8];
    if(newval == ((const char *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_strcmpic_1=strcmpic(newval, "block");
      tmp_if_expr_2 = 0 == return_value_strcmpic_1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
    {
      log_error(0x0008, "Crunching Accept-Language!");
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

      return (enum privoxy_err)JB_ERR_OK;
    }

    else
    {
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

      *header=strdup("Accept-Language: ");
      string_append(header, newval);
      if(*header == ((char *)NULL))
        log_error(0x2000, "Insufficient memory. Accept-Language header crunched without replacement.");

      else
        log_error(0x0008, "Accept-Language header crunched and replaced with: %s", *header);
    }
    return (enum privoxy_err)(*header == (char *)(void *)0 ? JB_ERR_MEMORY : JB_ERR_OK);
  }
}

// client_connection
// file parsers.c line 1886
static enum privoxy_err client_connection(struct client_state *csp, char **header)
{
  signed int return_value_strcmpic_4;
  static const char connection_close[18l] = { 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'c', 'l', 'o', 's', 'e', 0 };
  return_value_strcmpic_4=strcmpic(*header, connection_close);
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if(return_value_strcmpic_4 == 0)
  {
    if(!((256U & csp->config->feature_flags) == 0u))
      tmp_if_expr_2 = !((csp->flags & 0x00040000U) != 0u) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
    {
      signed int return_value_strcmpic_1;
      return_value_strcmpic_1=strcmpic(csp->http[0l].ver, "HTTP/1.1");
      if(return_value_strcmpic_1 == 0)
      {
        log_error(0x0008, "Removing '%s' to imply keep-alive.", *header);
        if(!(*header == ((char *)NULL)))
        {
          free((void *)*header);
          *header = (char *)(void *)0;
        }

        csp->flags = csp->flags & ~0x00008000U;
      }

      else
      {
        char *old_header = *header;
        *header=strdup_or_die("Connection: keep-alive");
        log_error(0x0008, "Replaced: '%s' with '%s'", old_header, *header);
        if(!(old_header == ((char *)NULL)))
        {
          free((void *)old_header);
          old_header = (char *)(void *)0;
        }

      }
    }

    else
    {
      log_error(0x0008, "Keeping the client header '%s' around. The connection will not be kept alive.", *header);
      csp->flags = csp->flags & ~0x00008000U;
    }
  }

  else
  {
    if(!((128U & csp->config->feature_flags) == 0u))
      tmp_if_expr_3 = !((csp->flags & 0x00040000U) != 0u) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      log_error(0x0008, "Keeping the client header '%s' around. The server connection will be kept alive if possible.", *header);
      csp->flags = csp->flags | 0x00008000U;
    }

    else
    {
      char *client_connection__1__3__old_header = *header;
      *header=strdup_or_die(connection_close);
      log_error(0x0008, "Replaced: '%s' with '%s'", client_connection__1__3__old_header, *header);
      if(!(client_connection__1__3__old_header == ((char *)NULL)))
      {
        free((void *)client_connection__1__3__old_header);
        client_connection__1__3__old_header = (char *)(void *)0;
      }

    }
  }
  csp->flags = csp->flags | 0x00000040U;
  return (enum privoxy_err)JB_ERR_OK;
}

// client_connection_header_adder
// file parsers.c line 3812
static enum privoxy_err client_connection_header_adder(struct client_state *csp)
{
  signed int return_value_strcmpic_1;
  if((0x00000100U & csp->flags) == 0u)
  {
    if((0x00000040U & csp->flags) == 0u)
      goto __CPROVER_DUMP_L1;

    return (enum privoxy_err)JB_ERR_OK;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!((128U & csp->config->feature_flags) == 0u))
    {
      if(!((0x00040000U & csp->flags) == 0u))
        goto __CPROVER_DUMP_L2;

      if(!(csp->http[0l].ssl == 0))
        goto __CPROVER_DUMP_L2;

      return_value_strcmpic_1=strcmpic(csp->http[0l].ver, "HTTP/1.1");
      if(!(return_value_strcmpic_1 == 0))
        goto __CPROVER_DUMP_L2;

      csp->flags = csp->flags | 0x00008000U;
      return (enum privoxy_err)JB_ERR_OK;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      static const char connection_close[18l] = { 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'c', 'l', 'o', 's', 'e', 0 };
      log_error(0x0008, "Adding: %s", (const void *)connection_close);
      enum privoxy_err return_value_enlist_2;
      return_value_enlist_2=enlist(csp->headers, connection_close);
      return return_value_enlist_2;
    }
  }
}

// client_expect
// file parsers.c line 2041
static enum privoxy_err client_expect(struct client_state *csp, char **header)
{
  signed int return_value_strcmpic_1;
  return_value_strcmpic_1=strcmpic(*header, "Expect: 100-continue");
  if(!(return_value_strcmpic_1 == 0))
  {
    csp->flags = csp->flags | 0x02000000U;
    log_error(0x0008, "Unsupported client expectaction: %s", *header);
  }

  return (enum privoxy_err)JB_ERR_OK;
}

// client_from
// file parsers.c line 3098
static enum privoxy_err client_from(struct client_state *csp, char **header)
{
  const char *newval;
  _Bool tmp_if_expr_2;
  signed int return_value_strcmpic_1;
  if((0x00000020UL & csp->action[0l].flags) == 0ul)
    return (enum privoxy_err)JB_ERR_OK;

  else
  {
    if(!(*header == ((char *)NULL)))
    {
      free((void *)*header);
      *header = (char *)(void *)0;
    }

    newval = csp->action[0l].string[(signed long int)1];
    if(newval == ((const char *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_strcmpic_1=strcmpic(newval, "block");
      tmp_if_expr_2 = 0 == return_value_strcmpic_1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
    {
      log_error(0x0008, "crunched From!");
      return (enum privoxy_err)JB_ERR_OK;
    }

    else
    {
      log_error(0x0008, " modified");
      *header=strdup("From: ");
      string_append(header, newval);
      return (enum privoxy_err)(*header == (char *)(void *)0 ? JB_ERR_MEMORY : JB_ERR_OK);
    }
  }
}

// client_has_unsupported_expectations
// file jcc.c line 452
static signed int client_has_unsupported_expectations(struct client_state *csp)
{
  if(!((0x02000000U & csp->flags) == 0u))
  {
    log_error(0x2000, "Rejecting request from client %s with unsupported Expect header value", csp->ip_addr_str);
    log_error(0x0200, "%s - - [%T] \"%s\" 417 0", csp->ip_addr_str, csp->http[0l].cmd);
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(UNSUPPORTED_CLIENT_EXPECTATION_ERROR_RESPONSE);
    write_socket(csp->cfd, UNSUPPORTED_CLIENT_EXPECTATION_ERROR_RESPONSE, return_value_strlen_1);
    return 1;
  }

  return 0;
}

// client_host
// file parsers.c line 3285
static enum privoxy_err client_host(struct client_state *csp, char **header)
{
  char *p;
  char *q;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(*header);
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  char *tmp_post_2;
  if(!(return_value_strlen_1 >= 7ul))
  {
    log_error(0x0008, "Removing empty Host header");
    if(!(*header == ((char *)NULL)))
    {
      free((void *)*header);
      *header = (char *)(void *)0;
    }

    return (enum privoxy_err)JB_ERR_OK;
  }

  else
  {
    if(csp->http[0l].hostport == ((char *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)*csp->http[0l].hostport == 42 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)*csp->http[0l].hostport == 32 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = (signed int)*csp->http[0l].hostport == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
    {
      p=strdup_or_die(*header + (signed long int)6);
      chomp(p);
      q=strdup_or_die(p);
      if(!(csp->http[0l].hostport == ((char *)NULL)))
      {
        free((void *)csp->http[0l].hostport);
        csp->http[0l].hostport = (char *)(void *)0;
      }

      csp->http[0l].hostport = p;
      if(!(csp->http[0l].host == ((char *)NULL)))
      {
        free((void *)csp->http[0l].host);
        csp->http[0l].host = (char *)(void *)0;
      }

      csp->http[0l].host = q;
      q=strchr(csp->http[0l].host, 58);
      if(!(q == ((char *)NULL)))
      {
        tmp_post_2 = q;
        q = q + 1l;
        *tmp_post_2 = (char)0;
        csp->http[0l].port=atoi(q);
      }

      else
        csp->http[0l].port = csp->http[0l].ssl != 0 ? 443 : 80;
      log_error(0x0008, "New host and port from Host field: %s = %s:%d", csp->http[0l].hostport, csp->http[0l].host, csp->http[0l].port);
    }

    csp->flags = csp->flags | 0x00000200U;
    return (enum privoxy_err)JB_ERR_OK;
  }
}

// client_host_adder
// file parsers.c line 3596
static enum privoxy_err client_host_adder(struct client_state *csp)
{
  char *p;
  enum privoxy_err err;
  _Bool tmp_if_expr_1;
  if(!((0x00000200U & csp->flags) == 0u))
    return (enum privoxy_err)JB_ERR_OK;

  else
  {
    if(csp->http[0l].hostport == ((char *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = !(*csp->http[0l].hostport != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      log_error(0x2000, "Destination host unknown.");
      return (enum privoxy_err)JB_ERR_PARSE;
    }

    else
    {
      p=strchr(csp->http[0l].hostport, 64);
      if(!(p == ((char *)NULL)))
        p = p + 1l;

      else
        p = csp->http[0l].hostport;
      log_error(0x0008, "addh-unique: Host: %s", p);
      err=enlist_unique_header(csp->headers, "Host", p);
      return err;
    }
  }
}

// client_if_modified_since
// file parsers.c line 3348
static enum privoxy_err client_if_modified_since(struct client_state *csp, char **header)
{
  char newheader[50l];
  struct tm gmt;
  struct tm *timeptr = (struct tm *)(void *)0;
  signed long int tm = (signed long int)0;
  const char *newval;
  char *endptr;
  signed int return_value_strcmpic_5;
  return_value_strcmpic_5=strcmpic(*header, "If-Modified-Since: Wed, 08 Jun 1955 12:00:00 GMT");
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strftime_1;
  if(return_value_strcmpic_5 == 0)
  {
    log_error(0x0008, "Crunching useless If-Modified-Since header.");
    if(!(*header == ((char *)NULL)))
    {
      free((void *)*header);
      *header = (char *)(void *)0;
    }

  }

  else
    if(!((0x00040000UL & csp->action[0l].flags) == 0ul))
    {
      newval = csp->action[0l].string[(signed long int)11];
      signed int return_value_strcmpic_4;
      return_value_strcmpic_4=strcmpic(newval, "block");
      if(return_value_strcmpic_4 == 0)
      {
        log_error(0x0008, "Crunching %s", *header);
        if(!(*header == ((char *)NULL)))
        {
          free((void *)*header);
          *header = (char *)(void *)0;
        }

      }

      else
      {
        enum privoxy_err return_value_parse_time_header_3;
        return_value_parse_time_header_3=parse_time_header(*header, &tm);
        if(!((signed int)return_value_parse_time_header_3 == JB_ERR_OK))
        {
          log_error(0x0008, "Couldn't parse time in %s (crunching!)", *header);
          if(!(*header == ((char *)NULL)))
          {
            free((void *)*header);
            *header = (char *)(void *)0;
          }

        }

        else
        {
          signed long int hours;
          signed long int minutes;
          signed long int seconds;
          signed long int rtime;
          rtime=strtol(newval, &endptr, 0);
          const signed int negative_range = (const signed int)(rtime < (signed long int)0);
          if(!(rtime == 0l))
          {
            log_error(0x0008, "Randomizing: %s (random range: %d minut%s)", *header, rtime, rtime == (signed long int)1 || rtime == (signed long int)-1 ? "e" : "es");
            if(!(negative_range == 0))
              rtime = rtime * (signed long int)-1;

            rtime = rtime * (signed long int)60;
            rtime=pick_from_range(rtime);
          }

          else
            log_error(0x2000, "Random range is 0. Assuming time transformation test.", *header);
          tm = tm + rtime * (signed long int)(negative_range != 0 ? -1 : 1);
          timeptr=gmtime_r(&tm, &gmt);
          if(timeptr == ((struct tm *)NULL))
            tmp_if_expr_2 = (_Bool)1;

          else
          {
            return_value_strftime_1=strftime(newheader, sizeof(char [50l]) /*50ul*/ , "%a, %d %b %Y %H:%M:%S GMT", timeptr);
            tmp_if_expr_2 = !(return_value_strftime_1 != 0ul) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_2)
          {
            log_error(0x2000, "Randomizing '%s' failed. Crunching the header without replacement.", *header);
            if(!(*header == ((char *)NULL)))
            {
              free((void *)*header);
              *header = (char *)(void *)0;
            }

            return (enum privoxy_err)JB_ERR_OK;
          }

          if(!(*header == ((char *)NULL)))
          {
            free((void *)*header);
            *header = (char *)(void *)0;
          }

          *header=strdup("If-Modified-Since: ");
          string_append(header, newheader);
          if(*header == ((char *)NULL))
          {
            log_error(0x0008, "Insufficient memory, header crunched without replacement.");
            return (enum privoxy_err)JB_ERR_MEMORY;
          }

          hours = rtime / (signed long int)3600;
          minutes = (rtime / (signed long int)60) % (signed long int)60;
          seconds = rtime % (signed long int)60;
          log_error(0x0008, "Randomized:  %s (%s %d hou%s %d minut%s %d second%s", *header, negative_range != 0 ? "subtracted" : "added", hours, hours == (signed long int)1 ? "r" : "rs", minutes, minutes == (signed long int)1 ? "e" : "es", seconds, seconds == (signed long int)1 ? ")" : "s)");
        }
      }
    }

  return (enum privoxy_err)JB_ERR_OK;
}

// client_if_none_match
// file parsers.c line 3474
static enum privoxy_err client_if_none_match(struct client_state *csp, char **header)
{
  if(!((0x00800000UL & csp->action[0l].flags) == 0ul))
  {
    log_error(0x0008, "Crunching %s", *header);
    if(!(*header == ((char *)NULL)))
    {
      free((void *)*header);
      *header = (char *)(void *)0;
    }

  }

  return (enum privoxy_err)JB_ERR_OK;
}

// client_keep_alive
// file parsers.c line 1744
static enum privoxy_err client_keep_alive(struct client_state *csp, char **header)
{
  unsigned int client_keep_alive__1__keep_alive_timeout;
  char *timeout_position;
  _Bool tmp_if_expr_4;
  signed int return_value_sscanf_3;
  _Bool tmp_if_expr_2;
  signed int return_value_sscanf_1;
  if((128U & csp->config->feature_flags) == 0u)
  {
    log_error(0x0008, "keep-alive support is disabled. Crunching: %s.", *header);
    if(!(*header == ((char *)NULL)))
    {
      free((void *)*header);
      *header = (char *)(void *)0;
    }

    return (enum privoxy_err)JB_ERR_OK;
  }

  else
  {
    timeout_position=strstr(*header, ": ");
    if(timeout_position == ((char *)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_sscanf_3=sscanf(timeout_position, ": %u", &client_keep_alive__1__keep_alive_timeout);
      tmp_if_expr_4 = 1 != return_value_sscanf_3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      timeout_position=strstr(*header, "timeout=");
      if(timeout_position == ((char *)NULL))
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        return_value_sscanf_1=sscanf(timeout_position, "timeout=%u", &client_keep_alive__1__keep_alive_timeout);
        tmp_if_expr_2 = 1 != return_value_sscanf_1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
      {
        log_error(0x0008, "Couldn't parse: '%s'. Using default timeout %u", *header, csp->config->keep_alive_timeout);
        if(!(*header == ((char *)NULL)))
        {
          free((void *)*header);
          *header = (char *)(void *)0;
        }

        return (enum privoxy_err)JB_ERR_OK;
      }

    }

    if(!(client_keep_alive__1__keep_alive_timeout >= csp->config->keep_alive_timeout))
    {
      log_error(0x0008, "Reducing keep-alive timeout from %u to %u.", csp->config->keep_alive_timeout, client_keep_alive__1__keep_alive_timeout);
      csp->server_connection.keep_alive_timeout = client_keep_alive__1__keep_alive_timeout;
    }

    else
    {
      log_error(0x0008, "Client keep-alive timeout is %u. Sticking with %u.", client_keep_alive__1__keep_alive_timeout, csp->config->keep_alive_timeout);
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

    }
    return (enum privoxy_err)JB_ERR_OK;
  }
}

// client_max_forwards
// file parsers.c line 3232
static enum privoxy_err client_max_forwards(struct client_state *csp, char **header)
{
  signed int max_forwards;
  signed int return_value_strcmpic_3;
  return_value_strcmpic_3=strcmpic(csp->http[0l].gpc, "trace");
  _Bool tmp_if_expr_5;
  signed int return_value_strcmpic_4;
  if(return_value_strcmpic_3 == 0)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_strcmpic_4=strcmpic(csp->http[0l].gpc, "options");
    tmp_if_expr_5 = 0 == return_value_strcmpic_4 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
  {
    /* assertion *(*header+12) == ':' */
    assert((signed int)(*header)[(signed long int)12] == 58);
    signed int return_value_sscanf_2;
    return_value_sscanf_2=sscanf(*header + (signed long int)12, ": %d", &max_forwards);
    if(return_value_sscanf_2 == 1)
    {
      if(max_forwards >= 1)
      {
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(*header);
        max_forwards = max_forwards - 1;
        snprintf(*header, return_value_strlen_1 + (unsigned long int)1, "Max-Forwards: %d", max_forwards);
        log_error(0x0008, "Max-Forwards value for %s request reduced to %d.", csp->http[0l].gpc, max_forwards);
      }

      else
        if(!(max_forwards >= 0))
        {
          log_error(0x2000, "Crunching invalid header: %s", *header);
          if(!(*header == ((char *)NULL)))
          {
            free((void *)*header);
            *header = (char *)(void *)0;
          }

        }

    }

    else
    {
      log_error(0x2000, "Crunching invalid header: %s", *header);
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

    }
  }

  return (enum privoxy_err)JB_ERR_OK;
}

// client_protocol_is_unsupported
// file jcc.c line 393
static signed int client_protocol_is_unsupported(struct client_state *csp, char *req)
{
  signed int return_value_strncmpic_3;
  return_value_strncmpic_3=strncmpic(req, "GET ftp://", (unsigned long int)10);
  _Bool tmp_if_expr_5;
  signed int return_value_strncmpic_4;
  if(return_value_strncmpic_3 == 0)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_strncmpic_4=strncmpic(req, "GET gopher://", (unsigned long int)13);
    tmp_if_expr_5 = !(return_value_strncmpic_4 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
  {
    const char *response = (const char *)(void *)0;
    const char *protocol = (const char *)(void *)0;
    signed int return_value_strncmpic_1;
    return_value_strncmpic_1=strncmpic(req, "GET ftp://", (unsigned long int)10);
    if(return_value_strncmpic_1 == 0)
    {
      response = FTP_RESPONSE;
      protocol = "FTP";
    }

    else
    {
      response = GOPHER_RESPONSE;
      protocol = "GOPHER";
    }
    log_error(0x2000, "%s tried to use Privoxy as %s proxy: %s", csp->ip_addr_str, protocol, req);
    log_error(0x0200, "%s - - [%T] \"%s\" 400 0", csp->ip_addr_str, req);
    if(!(req == ((char *)NULL)))
    {
      free((void *)req);
      req = (char *)(void *)0;
    }

    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(response);
    write_socket(csp->cfd, response, return_value_strlen_2);
    return 1;
  }

  return 0;
}

// client_proxy_connection
// file parsers.c line 1972
static enum privoxy_err client_proxy_connection(struct client_state *csp, char **header)
{
  char *return_value_strstr_1;
  if((0x00008000U & csp->flags) == 0u)
  {
    if(csp->http[0l].ssl == 0)
    {
      return_value_strstr_1=strstr(*header, "close");
      if(return_value_strstr_1 == ((char *)NULL))
      {
        log_error(0x0008, "The client connection can be kept alive due to: %s", *header);
        csp->flags = csp->flags | 0x00008000U;
      }

    }

  }

  crumble(csp, header);
  return (enum privoxy_err)JB_ERR_OK;
}

// client_range
// file parsers.c line 3567
static enum privoxy_err client_range(struct client_state *csp, char **header)
{
  signed int return_value_content_filters_enabled_3;
  return_value_content_filters_enabled_3=content_filters_enabled(csp->action);
  char *return_value_strstr_1;
  signed int return_value_strncmpic_2;
  if(!(return_value_content_filters_enabled_3 == 0))
  {
    return_value_strstr_1=strstr(*header, ":");
    return_value_strncmpic_2=strncmpic(return_value_strstr_1, ": bytes=0-", (unsigned long int)10);
    if(!(return_value_strncmpic_2 == 0))
    {
      log_error(0x0008, "Content filtering is enabled. Crunching: '%s' to prevent range-mismatch problems.", *header);
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

    }

  }

  return (enum privoxy_err)JB_ERR_OK;
}

// client_referrer
// file parsers.c line 2843
static enum privoxy_err client_referrer(struct client_state *csp, char **header)
{
  const char *parameter;
  signed int parameter_conditional_block;
  signed int parameter_conditional_forge;
  strclean(*header, "/PRIVOXY-FORCE");
  signed int return_value_strcmpic_6;
  if((0x00000040UL & csp->action[0l].flags) == 0ul)
    return (enum privoxy_err)JB_ERR_OK;

  else
  {
    parameter = csp->action[0l].string[(signed long int)3];
    /* assertion parameter != ((void *)0) */
    assert(parameter != (const char *)(void *)0);
    signed int return_value_strcmpic_1;
    return_value_strcmpic_1=strcmpic(parameter, "conditional-block");
    parameter_conditional_block = (signed int)(0 == return_value_strcmpic_1);
    signed int return_value_strcmpic_2;
    return_value_strcmpic_2=strcmpic(parameter, "conditional-forge");
    parameter_conditional_forge = (signed int)(0 == return_value_strcmpic_2);
    if(parameter_conditional_block == 0 && parameter_conditional_forge == 0)
    {
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

    }

    signed int return_value_strcmpic_7;
    return_value_strcmpic_7=strcmpic(parameter, "block");
    if(return_value_strcmpic_7 == 0)
    {
      log_error(0x0008, "Referer crunched!");
      return (enum privoxy_err)JB_ERR_OK;
    }

    else
      if(!(parameter_conditional_block == 0) || !(parameter_conditional_forge == 0))
      {
        enum privoxy_err return_value_handle_conditional_hide_referrer_parameter_3;
        return_value_handle_conditional_hide_referrer_parameter_3=handle_conditional_hide_referrer_parameter(header, csp->http[0l].hostport, parameter_conditional_block);
        return return_value_handle_conditional_hide_referrer_parameter_3;
      }

      else
      {
        return_value_strcmpic_6=strcmpic(parameter, "forge");
        if(return_value_strcmpic_6 == 0)
        {
          enum privoxy_err return_value_create_forged_referrer_4;
          return_value_create_forged_referrer_4=create_forged_referrer(header, csp->http[0l].hostport);
          return return_value_create_forged_referrer_4;
        }

        else
        {
          enum privoxy_err return_value_create_fake_referrer_5;
          return_value_create_fake_referrer_5=create_fake_referrer(header, parameter);
          return return_value_create_fake_referrer_5;
        }
      }
  }
}

// client_save_content_length
// file parsers.c line 1844
static enum privoxy_err client_save_content_length(struct client_state *csp, char **header)
{
  unsigned long long int content_length = (unsigned long long int)0;
  const char *header_value;
  /* assertion *(*header+14) == ':' */
  assert((signed int)(*header)[(signed long int)14] == 58);
  header_value = *header + (signed long int)15;
  enum privoxy_err return_value_get_content_length_1;
  return_value_get_content_length_1=get_content_length(header_value, &content_length);
  if(!((signed int)return_value_get_content_length_1 == JB_ERR_OK))
  {
    log_error(0x2000, "Crunching invalid header: %s", *header);
    if(!(*header == ((char *)NULL)))
    {
      free((void *)*header);
      *header = (char *)(void *)0;
    }

  }

  else
    csp->expected_client_content_length = content_length;
  return (enum privoxy_err)JB_ERR_OK;
}

// client_send_cookie
// file parsers.c line 3149
static enum privoxy_err client_send_cookie(struct client_state *csp, char **header)
{
  if(!((0x00001000UL & csp->action[0l].flags) == 0ul))
  {
    log_error(0x0008, "Crunched outgoing cookie: %s", *header);
    if(!(*header == ((char *)NULL)))
    {
      free((void *)*header);
      *header = (char *)(void *)0;
    }

  }

  return (enum privoxy_err)JB_ERR_OK;
}

// client_te
// file parsers.c line 2813
static enum privoxy_err client_te(struct client_state *csp, char **header)
{
  if(!((0x00000400UL & csp->action[0l].flags) == 0ul))
  {
    if(!(*header == ((char *)NULL)))
    {
      free((void *)*header);
      *header = (char *)(void *)0;
    }

    log_error(0x0008, "Suppressed offer to compress transfer");
  }

  return (enum privoxy_err)JB_ERR_OK;
}

// client_transfer_encoding
// file parsers.h line 64
extern enum privoxy_err client_transfer_encoding(struct client_state *csp, char **header)
{
  char *return_value_strstr_1;
  return_value_strstr_1=strstr(*header, "chunked");
  if(!(return_value_strstr_1 == ((char *)NULL)))
  {
    csp->flags = csp->flags | 0x01000000U;
    log_error(0x0008, "Expecting chunked client body");
  }

  return (enum privoxy_err)JB_ERR_OK;
}

// client_ua
// file parsers.c line 3068
static enum privoxy_err client_ua(struct client_state *csp, char **header)
{
  if(!((0x00000080UL & csp->action[0l].flags) == 0ul))
  {
    log_error(0x0008, "crunched User-Agent!");
    if(!(*header == ((char *)NULL)))
    {
      free((void *)*header);
      *header = (char *)(void *)0;
    }

  }

  return (enum privoxy_err)JB_ERR_OK;
}

// client_uagent
// file parsers.c line 3026
static enum privoxy_err client_uagent(struct client_state *csp, char **header)
{
  const char *newval;
  if((0x00000080UL & csp->action[0l].flags) == 0ul)
    return (enum privoxy_err)JB_ERR_OK;

  else
  {
    newval = csp->action[0l].string[(signed long int)4];
    if(newval == ((const char *)NULL))
      return (enum privoxy_err)JB_ERR_OK;

    else
    {
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

      *header=strdup("User-Agent: ");
      string_append(header, newval);
      log_error(0x0008, "Modified: %s", *header);
      return (enum privoxy_err)(*header == (char *)(void *)0 ? JB_ERR_MEMORY : JB_ERR_OK);
    }
  }
}

// client_x_filter
// file parsers.c line 3503
static enum privoxy_err client_x_filter(struct client_state *csp, char **header)
{
  signed int return_value_strcmpic_1;
  return_value_strcmpic_1=strcmpic(*header, "X-Filter: No");
  if(return_value_strcmpic_1 == 0)
  {
    if((4U & csp->config->feature_flags) == 0u)
      log_error(0x1000, "Ignored the client's request to fetch without filtering.");

    else
    {
      if(!((0x00400000UL & csp->action[0l].flags) == 0ul))
        log_error(0x0008, "force-text-mode overruled the client's request to fetch without filtering!");

      else
      {
        csp->content_type = 0x0004U;
        csp->flags = csp->flags | 0x00000400U;
        log_error(0x0008, "Accepted the client's request to fetch without filtering.");
      }
      log_error(0x0008, "Crunching %s", *header);
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

    }
  }

  return (enum privoxy_err)JB_ERR_OK;
}

// client_x_forwarded
// file parsers.c line 3179
static enum privoxy_err client_x_forwarded(struct client_state *csp, char **header)
{
  signed int return_value_strcmpic_1;
  if(!((0x00000010UL & csp->action[0l].flags) == 0ul))
  {
    const char *parameter = csp->action[0l].string[(signed long int)17];
    signed int return_value_strcmpic_2;
    return_value_strcmpic_2=strcmpic(parameter, "block");
    if(return_value_strcmpic_2 == 0)
    {
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

      log_error(0x0008, "crunched x-forwarded-for!");
    }

    else
    {
      return_value_strcmpic_1=strcmpic(parameter, "add");
      if(return_value_strcmpic_1 == 0)
      {
        string_append(header, ", ");
        string_append(header, csp->ip_addr_str);
        if(*header == ((char *)NULL))
          return (enum privoxy_err)JB_ERR_MEMORY;

        log_error(0x0008, "Appended client IP address to %s", *header);
        csp->flags = csp->flags | 0x00000800U;
      }

      else
        log_error(0x4000, "Invalid change-x-forwarded-for parameter: '%s'", parameter);
    }
  }

  return (enum privoxy_err)JB_ERR_OK;
}

// client_x_forwarded_for_adder
// file parsers.c line 3680
static enum privoxy_err client_x_forwarded_for_adder(struct client_state *csp)
{
  char *header = (char *)(void *)0;
  enum privoxy_err err;
  _Bool tmp_if_expr_2;
  signed int return_value_strcmpic_1;
  if(!((0x00000010UL & csp->action[0l].flags) == 0ul))
  {
    return_value_strcmpic_1=strcmpic(csp->action[0l].string[(signed long int)17], "add");
    tmp_if_expr_2 = 0 == return_value_strcmpic_1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_3;
  if(!tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (csp->flags & 0x00000800U) != 0u ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
    return (enum privoxy_err)JB_ERR_OK;

  else
  {
    header=strdup("X-Forwarded-For: ");
    string_append(&header, csp->ip_addr_str);
    if(header == ((char *)NULL))
      return (enum privoxy_err)JB_ERR_MEMORY;

    else
    {
      log_error(0x0008, "addh: %s", header);
      err=enlist(csp->headers, header);
      if(!(header == ((char *)NULL)))
      {
        free((void *)header);
        header = (char *)(void *)0;
      }

      return err;
    }
  }
}

// client_xtra_adder
// file parsers.c line 3646
static enum privoxy_err client_xtra_adder(struct client_state *csp)
{
  struct list_entry *lst;
  enum privoxy_err err;
  lst = csp->action[0l].multi[(signed long int)0][0l].first;
  for( ; !(lst == ((struct list_entry *)NULL)); lst = lst->next)
  {
    log_error(0x0008, "addh: %s", lst->str);
    err=enlist(csp->headers, lst->str);
    if(!(err == /*enum*/JB_ERR_OK))
      return err;

  }
  return (enum privoxy_err)JB_ERR_OK;
}

// close_ports_helper
// file jcc.c line 3880
static void close_ports_helper(signed int *sockets)
{
  signed int i = 0;
  for( ; !(i >= 10); i = i + 1)
  {
    if(!(sockets[(signed long int)i] == -1))
      close_socket(sockets[(signed long int)i]);

    sockets[(signed long int)i] = -1;
  }
}

// close_socket
// file jbsockets.h line 53
extern void close_socket(signed int fd)
{
  close(fd);
}

// close_unusable_connections
// file gateway.c line 412
extern signed int close_unusable_connections(void)
{
  unsigned int slot = (unsigned int)0;
  signed int connections_alive = 0;
  privoxy_mutex_lock(&connection_reuse_mutex);
  slot = (unsigned int)0;
  signed int return_value_socket_is_still_alive_2;
  for( ; !((unsigned long int)slot >= 100ul); slot = slot + 1u)
    if(reusable_connection[(signed long int)slot].in_use == 0)
    {
      if(!(reusable_connection[(signed long int)slot].sfd == -1))
      {
        signed long int time_open;
        signed long int return_value_time_1;
        return_value_time_1=time((signed long int *)(void *)0);
        time_open = return_value_time_1 - reusable_connection[(signed long int)slot].timestamp;
        signed long int latency = (reusable_connection[(signed long int)slot].response_received - reusable_connection[(signed long int)slot].request_sent) / (signed long int)2;
        if(!((signed long int)reusable_connection[(signed long int)slot].keep_alive_timeout >= latency + time_open))
        {
          log_error(0x0002, "The connection to %s:%d in slot %d timed out. Closing socket %d. Timeout is: %d. Assumed latency: %d.", reusable_connection[(signed long int)slot].host, reusable_connection[(signed long int)slot].port, slot, reusable_connection[(signed long int)slot].sfd, reusable_connection[(signed long int)slot].keep_alive_timeout, latency);
          close_socket(reusable_connection[(signed long int)slot].sfd);
          mark_connection_closed(&reusable_connection[(signed long int)slot]);
        }

        else
        {
          return_value_socket_is_still_alive_2=socket_is_still_alive(reusable_connection[(signed long int)slot].sfd);
          if(return_value_socket_is_still_alive_2 == 0)
          {
            log_error(0x0002, "The connection to %s:%d in slot %d is no longer usable. Closing socket %d.", reusable_connection[(signed long int)slot].host, reusable_connection[(signed long int)slot].port, slot, reusable_connection[(signed long int)slot].sfd);
            close_socket(reusable_connection[(signed long int)slot].sfd);
            mark_connection_closed(&reusable_connection[(signed long int)slot]);
          }

          else
            connections_alive = connections_alive + 1;
        }
      }

    }

  privoxy_mutex_unlock(&connection_reuse_mutex);
  return connections_alive;
}

// compile_dynamic_pcrs_job_list
// file filters.c line 915
extern struct PCRS_JOB * compile_dynamic_pcrs_job_list(struct client_state *csp, struct re_filterfile_spec *b)
{
  struct list_entry *pattern;
  struct PCRS_JOB *job_list = (struct PCRS_JOB *)(void *)0;
  struct PCRS_JOB *dummy = (struct PCRS_JOB *)(void *)0;
  struct PCRS_JOB *lastjob = (struct PCRS_JOB *)(void *)0;
  signed int error = 0;
  struct pcrs_variable variables[5l] = { { .name="url", .value=csp->http[0l].url, .static_value=1 },
    { .name="path", .value=csp->http[0l].path, .static_value=1 },
    { .name="host", .value=csp->http[0l].host, .static_value=1 },
    { .name="origin", .value=csp->ip_addr_str, .static_value=1 },
    { .name=(const char *)(void *)0, .value=(char *)(void *)0, .static_value=1 } };
  pattern = b->patterns[0l].first;
  for( ; !(pattern == ((struct list_entry *)NULL)); pattern = pattern->next)
  {
    /* assertion pattern->str != ((void *)0) */
    assert(pattern->str != (char *)(void *)0);
    dummy=pcrs_compile_dynamic_command(pattern->str, variables, &error);
    if(dummy == ((struct PCRS_JOB *)NULL))
    {
      const char *return_value_pcrs_strerror_1;
      return_value_pcrs_strerror_1=pcrs_strerror(error);
      log_error(0x2000, "Compiling dynamic pcrs job '%s' for '%s' failed with error code %d: %s", pattern->str, b->name, error, return_value_pcrs_strerror_1);
      goto __CPROVER_DUMP_L6;
    }

    else
    {
      if(error == -105)
        log_error(0x2000, "At least one of the variables in '%s' had to be truncated before compilation", pattern->str);

      if(job_list == ((struct PCRS_JOB *)NULL))
        job_list = dummy;

      else
        lastjob->next = dummy;
      lastjob = dummy;
    }

  __CPROVER_DUMP_L6:
    ;
  }
  return job_list;
}

// compile_host_pattern
// file urlmatch.c line 815
static enum privoxy_err compile_host_pattern(struct pattern_spec *url, const char *host_pattern)
{
  char *v[150l];
  unsigned long int size;
  char *p;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(host_pattern);
  if((signed int)host_pattern[-1l + (signed long int)return_value_strlen_1] == 46)
    url->pattern.url_spec.unanchored = url->pattern.url_spec.unanchored | 2;

  if((signed int)*host_pattern == 46)
    url->pattern.url_spec.unanchored = url->pattern.url_spec.unanchored | 1;

  url->pattern.url_spec.dbuffer=strdup_or_die(host_pattern);
  p = url->pattern.url_spec.dbuffer;
  for( ; !(*p == 0); p = p + 1l)
  {
    signed int return_value_tolower_2;
    return_value_tolower_2=tolower((signed int)(unsigned char)*p);
    *p = (char)return_value_tolower_2;
  }
  url->pattern.url_spec.dcount=ssplit(url->pattern.url_spec.dbuffer, ".", v, sizeof(char *[150l]) /*1200ul*/  / sizeof(char *) /*8ul*/ );
  if(!(url->pattern.url_spec.dcount >= 0))
  {
    free_pattern_spec(url);
    return (enum privoxy_err)JB_ERR_PARSE;
  }

  else
    if(!(url->pattern.url_spec.dcount == 0))
    {
      size = (unsigned long int)url->pattern.url_spec.dcount * sizeof(char *) /*8ul*/ ;
      void *return_value_malloc_or_die_3;
      return_value_malloc_or_die_3=malloc_or_die(size);
      url->pattern.url_spec.dvec = (char **)return_value_malloc_or_die_3;
      memcpy((void *)url->pattern.url_spec.dvec, (const void *)v, size);
    }

  return (enum privoxy_err)JB_ERR_OK;
}

// compile_pattern
// file urlmatch.c line 624
static enum privoxy_err compile_pattern(const char *pattern, enum regex_anchoring anchoring, struct pattern_spec *url, struct anonymous_3 **regex)
{
  signed int errcode;
  char rebuf[5000l];
  const char *fmt = (const char *)(void *)0;
  /* assertion pattern */
  assert(pattern != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(pattern);
  /* assertion strlen(pattern) < sizeof(rebuf) - 2 */
  assert(return_value_strlen_1 < sizeof(char [5000l]) /*5000ul*/  - (unsigned long int)2);
  if((signed int)*pattern == 0)
  {
    *regex = (struct anonymous_3 *)(void *)0;
    return (enum privoxy_err)JB_ERR_OK;
  }

  else
  {
    switch((signed int)anchoring)
    {
      case NO_ANCHORING:
      {
        fmt = "%s";
        break;
      }
      case RIGHT_ANCHORED:
      {
        fmt = "%s_";
        break;
      }
      case RIGHT_ANCHORED_HOST:
      {
        fmt = "%s\\.?_";
        break;
      }
      case LEFT_ANCHORED:
      {
        fmt = "^%s";
        break;
      }
      default:
        log_error(0x4000, "Invalid anchoring in compile_pattern %d", anchoring);
    }
    void *return_value_zalloc_2;
    return_value_zalloc_2=zalloc(sizeof(struct anonymous_3) /*24ul*/ );
    *regex = (struct anonymous_3 *)return_value_zalloc_2;
    if(*regex == ((struct anonymous_3 *)NULL))
    {
      free_pattern_spec(url);
      return (enum privoxy_err)JB_ERR_MEMORY;
    }

    else
    {
      snprintf(rebuf, sizeof(char [5000l]) /*5000ul*/ , fmt, pattern);
      errcode=pcreposix_regcomp(*regex, rebuf, 0 | 0x0020 | 0x0001);
      if(!(errcode == 0))
      {
        unsigned long int errlen;
        errlen=pcreposix_regerror(errcode, *regex, rebuf, sizeof(char [5000l]) /*5000ul*/ );
        if(errlen >= 5000ul)
          errlen = sizeof(char [5000l]) /*5000ul*/  - (unsigned long int)1;

        rebuf[(signed long int)errlen] = (char)0;
        log_error(0x2000, "error compiling %s from %s: %s", pattern, url->spec, (const void *)rebuf);
        free_pattern_spec(url);
        return (enum privoxy_err)JB_ERR_PARSE;
      }

      return (enum privoxy_err)JB_ERR_OK;
    }
  }
}

// compile_url_pattern
// file urlmatch.c line 705
static enum privoxy_err compile_url_pattern(struct pattern_spec *url, char *buf)
{
  char *p;
  p=strchr(buf, 47);
  if(!(p == ((char *)NULL)))
  {
    if(!((signed int)p[1l] == 0))
    {
      enum privoxy_err err;
      err=compile_pattern(p, (enum regex_anchoring)LEFT_ANCHORED, url, &url->pattern.url_spec.preg);
      if(!((signed int)err == JB_ERR_OK))
        return err;

    }

    *p = (char)0;
  }

  _Bool tmp_if_expr_2;
  if((signed int)*buf == 60)
  {
    p=strchr(buf + (signed long int)1, 62);
    tmp_if_expr_2 = (char *)(void *)0 != p ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  char *tmp_post_1;
  if(tmp_if_expr_2)
  {
    tmp_post_1 = p;
    p = p + 1l;
    *tmp_post_1 = (char)0;
    buf = buf + 1l;
    if((signed int)*p == 0)
      p = (char *)(void *)0;

    else
      if(!((signed int)*p == 58))
        return (enum privoxy_err)JB_ERR_PARSE;

  }

  else
    p=strchr(buf, 58);
  char *tmp_post_3;
  if(!(p == ((char *)NULL)))
  {
    tmp_post_3 = p;
    p = p + 1l;
    *tmp_post_3 = (char)0;
    url->pattern.url_spec.port_list=strdup_or_die(p);
  }

  else
    url->pattern.url_spec.port_list = (char *)(void *)0;
  if(!((signed int)*buf == 0))
  {
    enum privoxy_err return_value_compile_host_pattern_4;
    return_value_compile_host_pattern_4=compile_host_pattern(url, buf);
    return return_value_compile_host_pattern_4;
  }

  return (enum privoxy_err)JB_ERR_OK;
}

// connect_port_is_forbidden
// file filters.c line 521
extern signed int connect_port_is_forbidden(struct client_state *csp)
{
  _Bool tmp_if_expr_2;
  signed int return_value_match_portlist_1;
  if(!((0x00010000UL & csp->action[0l].flags) == 0ul))
  {
    return_value_match_portlist_1=match_portlist(csp->action[0l].string[(signed long int)5], csp->http[0l].port);
    tmp_if_expr_2 = !(return_value_match_portlist_1 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  return (signed int)tmp_if_expr_2;
}

// connect_to
// file jbsockets.h line 45
extern signed int connect_to(const char *host, signed int portnum, struct client_state *csp)
{
  signed int fd;
  signed int forwarded_connect_retries = 0;
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  do
  {
    fd=rfc2553_connect_to(host, portnum, csp);
    if(!(fd == -1))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value___errno_location_1=__errno_location();
      tmp_if_expr_2 = *return_value___errno_location_1 == 22 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = csp->fwd == (struct forward_spec *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      if(csp->fwd->forward_host == ((char *)NULL))
        tmp_if_expr_4 = (signed int)csp->fwd->type == SOCKS_NONE ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      break;

    forwarded_connect_retries = forwarded_connect_retries + 1;
    if(!(csp->config->forwarded_connect_retries == 0))
      log_error(0x2000, "Attempt %d of %d to connect to %s failed. Trying again.", forwarded_connect_retries, csp->config->forwarded_connect_retries + 1, host);

  }
  while(!(forwarded_connect_retries >= csp->config->forwarded_connect_retries));
  return fd;
}

// connection_destination_matches
// file gateway.c line 359
extern signed int connection_destination_matches(struct reusable_connection *connection, struct http_request *http, struct forward_spec *fwd)
{
  _Bool tmp_if_expr_1;
  if(!(connection->forwarder_type == fwd->type))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = connection->gateway_port != fwd->gateway_port ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = connection->forward_port != fwd->forward_port ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = connection->port != http->port ? (_Bool)1 : (_Bool)0;
  signed int return_value_strcmpic_4;
  signed int return_value_strcmpic_5;
  if(tmp_if_expr_3)
    return 0;

  else
    if(!(connection->gateway_host == ((char *)NULL)))
    {
      if(fwd->gateway_host == ((char *)NULL))
        goto __CPROVER_DUMP_L8;

      return_value_strcmpic_4=strcmpic(connection->gateway_host, fwd->gateway_host);
      if(return_value_strcmpic_4 == 0)
        goto __CPROVER_DUMP_L8;

      if(connection->gateway_host == fwd->gateway_host)
        goto __CPROVER_DUMP_L8;

      log_error(0x0002, "Gateway mismatch. Previous gateway: %s. Current gateway: %s", connection->gateway_host, fwd->gateway_host);
      return 0;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      if(!(connection->forward_host == ((char *)NULL)))
      {
        if(fwd->forward_host == ((char *)NULL))
          goto __CPROVER_DUMP_L9;

        return_value_strcmpic_5=strcmpic(connection->forward_host, fwd->forward_host);
        if(return_value_strcmpic_5 == 0)
          goto __CPROVER_DUMP_L9;

        if(connection->forward_host == fwd->forward_host)
          goto __CPROVER_DUMP_L9;

        log_error(0x0002, "Forwarding proxy mismatch. Previous proxy: %s. Current proxy: %s", connection->forward_host, fwd->forward_host);
        return 0;
      }

      else
      {

      __CPROVER_DUMP_L9:
        ;
        signed int return_value_strcmpic_6;
        return_value_strcmpic_6=strcmpic(connection->host, http->host);
        return (signed int)!(return_value_strcmpic_6 != 0);
      }
    }
}

// content_filters_enabled
// file filters.c line 2708
extern signed int content_filters_enabled(struct current_action_spec *action)
{
  _Bool tmp_if_expr_2;
  signed int return_value_list_is_empty_1;
  if(!((0x00000002UL & action->flags) == 0ul))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_list_is_empty_1=list_is_empty(action->multi[(signed long int)1]);
    tmp_if_expr_2 = !(return_value_list_is_empty_1 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_4;
  signed int return_value_list_is_empty_3;
  if(tmp_if_expr_2)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_list_is_empty_3=list_is_empty(action->multi[(signed long int)6]);
    tmp_if_expr_4 = !(return_value_list_is_empty_3 != 0) ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr_4;
}

// content_requires_filtering
// file filters.c line 2634
extern signed int content_requires_filtering(struct client_state *csp)
{
  _Bool tmp_if_expr_4;
  signed int return_value_list_is_empty_1;
  _Bool tmp_if_expr_3;
  signed int return_value_list_is_empty_2;
  if(!((0x0004U & csp->content_type) == 0u))
  {
    if(!((0x00400000UL & csp->action[0l].flags) == 0ul))
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!((0x00400000UL & csp->action[0l].flags) == 0ul))
    {
      if(!((0x0001U & csp->content_type) == 0u))
        log_error(0x0008, "Text mode is already enabled.");

      else
      {
        csp->content_type = csp->content_type | 0x0001U;
        log_error(0x0008, "Text mode enabled by force. Take cover!");
      }
    }

    if((0x0040U & csp->content_type) == 0u)
      csp->content_type = csp->content_type | 0x0001U;

    if(!((0x0001U & csp->content_type) == 0u))
    {
      return_value_list_is_empty_1=list_is_empty(csp->action[0l].multi[(signed long int)1]);
      if(return_value_list_is_empty_1 == 0)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_list_is_empty_2=list_is_empty(csp->action[0l].multi[(signed long int)6]);
        tmp_if_expr_3 = !(return_value_list_is_empty_2 != 0) ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      return 1;

    else
      if(!((0x0002U & csp->content_type) == 0u))
      {
        if(!((0x00000002UL & csp->action[0l].flags) == 0ul))
          return 1;

      }

    return 0;
  }
}

// copy_action
// file actions.c line 215
extern enum privoxy_err copy_action(struct action_spec *dest, struct action_spec *src)
{
  signed int i;
  enum privoxy_err err = (enum privoxy_err)JB_ERR_OK;
  free_action(dest);
  memset((void *)dest, 0, sizeof(struct action_spec) /*424ul*/ );
  dest->mask = src->mask;
  dest->add = src->add;
  i = 0;
  for( ; !(i >= 19); i = i + 1)
  {
    char *str = src->string[(signed long int)i];
    if(!(str == ((char *)NULL)))
    {
      str=strdup_or_die(str);
      dest->string[(signed long int)i] = str;
    }

  }
  i = 0;
  for( ; !(i >= 7); i = i + 1)
  {
    dest->multi_remove_all[(signed long int)i] = src->multi_remove_all[(signed long int)i];
    err=list_duplicate(dest->multi_remove[(signed long int)i], src->multi_remove[(signed long int)i]);
    if(!(err == /*enum*/JB_ERR_OK))
      return err;

    err=list_duplicate(dest->multi_add[(signed long int)i], src->multi_add[(signed long int)i]);
    if(!(err == /*enum*/JB_ERR_OK))
      return err;

  }
  return err;
}

// create_content_length_header
// file parsers.c line 4622
static void create_content_length_header(unsigned long long int content_length, char *header, unsigned long int buffer_length)
{
  snprintf(header, buffer_length, "Content-Length: %llu", content_length);
}

// create_fake_referrer
// file parsers.c line 4526
static enum privoxy_err create_fake_referrer(char **header, const char *fake_referrer)
{
  /* assertion ((void *)0) == *header */
  assert((char *)(void *)0 == *header);
  signed int return_value_strncmpic_2;
  return_value_strncmpic_2=strncmpic(fake_referrer, "http://", (unsigned long int)7);
  signed int return_value_strncmpic_1;
  if(!(return_value_strncmpic_2 == 0))
  {
    return_value_strncmpic_1=strncmpic(fake_referrer, "https://", (unsigned long int)8);
    if(!(return_value_strncmpic_1 == 0))
      log_error(0x0008, "Parameter: +hide-referrer{%s} is a bad idea, but I don't care.", fake_referrer);

  }

  *header=strdup("Referer: ");
  string_append(header, fake_referrer);
  if(*header == ((char *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    log_error(0x0008, "Referer replaced with: %s", *header);
    return (enum privoxy_err)JB_ERR_OK;
  }
}

// create_forged_referrer
// file parsers.c line 4491
static enum privoxy_err create_forged_referrer(char **header, const char *hostport)
{
  /* assertion ((void *)0) == *header */
  assert((char *)(void *)0 == *header);
  *header=strdup("Referer: http://");
  string_append(header, hostport);
  string_append(header, "/");
  if(*header == ((char *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    log_error(0x0008, "Referer forged to: %s", *header);
    return (enum privoxy_err)JB_ERR_OK;
  }
}

// create_pattern_spec
// file urlmatch.h line 56
extern enum privoxy_err create_pattern_spec(struct pattern_spec *pattern, char *buf)
{
  signed int i;
  /* assertion pattern */
  assert(pattern != ((struct pattern_spec *)NULL));
  /* assertion buf */
  assert(buf != ((char *)NULL));
  memset((void *)pattern, 0, sizeof(struct pattern_spec) /*56ul*/ );
  pattern->spec=strdup_or_die(buf);
  i = 0;
  for( ; !((unsigned long int)i >= 3ul); i = i + 1)
  {
    signed int return_value_strncmpic_2;
    /* tag-#anon#clST[l*{cS8}_cS8_'prefix'||cU64'prefix_length'||cU32'flag'||U32'_pad0'|] */
struct anonymous_6
{
  // prefix
  const char *prefix;
  // prefix_length
  const unsigned long int prefix_length;
  // flag
  const unsigned int flag;
};

/* */
    ;
    static struct anonymous_6 tag_pattern[3l] = { { .prefix="TAG:", .prefix_length=(const unsigned long int)4, .flag=(const unsigned int)0x00000002UL },
    { .prefix="NO-REQUEST-TAG:", .prefix_length=(const unsigned long int)15, .flag=(const unsigned int)0x00000004UL },
    { .prefix="NO-RESPONSE-TAG:", .prefix_length=(const unsigned long int)16, .flag=(const unsigned int)0x00000008UL } };
    return_value_strncmpic_2=strncmpic(pattern->spec, tag_pattern[(signed long int)i].prefix, tag_pattern[(signed long int)i].prefix_length);
    if(return_value_strncmpic_2 == 0)
    {
      const char *tag_regex = buf + (signed long int)tag_pattern[(signed long int)i].prefix_length;
      pattern->flags = pattern->flags | tag_pattern[(signed long int)i].flag;
      enum privoxy_err return_value_compile_pattern_1;
      return_value_compile_pattern_1=compile_pattern(tag_regex, (enum regex_anchoring)NO_ANCHORING, pattern, &pattern->pattern.tag_regex);
      return return_value_compile_pattern_1;
    }

  }
  pattern->flags = pattern->flags | (unsigned int)0x00000001UL;
  enum privoxy_err return_value_compile_url_pattern_3;
  return_value_compile_url_pattern_3=compile_url_pattern(pattern, buf);
  return return_value_compile_url_pattern_3;
}

// crumble
// file parsers.c line 2072
static enum privoxy_err crumble(struct client_state *csp, char **header)
{
  (void)csp;
  log_error(0x0008, "crumble crunched: %s!", *header);
  if(!(*header == ((char *)NULL)))
  {
    free((void *)*header);
    *header = (char *)(void *)0;
  }

  return (enum privoxy_err)JB_ERR_OK;
}

// crunch_client_header
// file parsers.c line 2987
static enum privoxy_err crunch_client_header(struct client_state *csp, char **header)
{
  const char *crunch_pattern;
  if(!((0x00200000UL & csp->action[0l].flags) == 0ul))
  {
    crunch_pattern = csp->action[0l].string[(signed long int)7];
    char *return_value_strstr_1;
    return_value_strstr_1=strstr(*header, crunch_pattern);
    if(!(return_value_strstr_1 == ((char *)NULL)))
    {
      log_error(0x0008, "Crunching client header: %s (contains: %s)", *header, crunch_pattern);
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

    }

  }

  return (enum privoxy_err)JB_ERR_OK;
}

// crunch_reason
// file jcc.c line 653
static const char * crunch_reason(struct http_response *rsp)
{
  char *reason = (char *)(void *)0;
  /* assertion rsp != ((void *)0) */
  assert(rsp != (struct http_response *)(void *)0);
  if(rsp == ((struct http_response *)NULL))
    return "Internal error while searching for crunch reason";

  else
  {
    switch((signed int)rsp->crunch_reason)
    {
      case UNSUPPORTED:
      {
        reason = "Unsupported HTTP feature";
        break;
      }
      case BLOCKED:
      {
        reason = "Blocked";
        break;
      }
      case UNTRUSTED:
      {
        reason = "Untrusted";
        break;
      }
      case REDIRECTED:
      {
        reason = "Redirected";
        break;
      }
      case CGI_CALL:
      {
        reason = "CGI Call";
        break;
      }
      case NO_SUCH_DOMAIN:
      {
        reason = "DNS failure";
        break;
      }
      case FORWARDING_FAILED:
      {
        reason = "Forwarding failed";
        break;
      }
      case CONNECT_FAILED:
      {
        reason = "Connection failure";
        break;
      }
      case OUT_OF_MEMORY:
      {
        reason = "Out of memory (may mask other reasons)";
        break;
      }
      case CONNECTION_TIMEOUT:
      {
        reason = "Connection timeout";
        break;
      }
      case NO_SERVER_DATA:
      {
        reason = "No server data received";
        break;
      }
      default:
        reason = "No reason recorded";
    }
    return reason;
  }
}

// crunch_response_triggered
// file jcc.c line 818
static signed int crunch_response_triggered(struct client_state *csp, struct cruncher *crunchers)
{
  struct http_response *rsp = (struct http_response *)(void *)0;
  struct cruncher *c;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if((64U & csp->config->feature_flags) == 0u)
  {
    rsp=dispatch_cgi(csp);
    if(rsp == ((struct http_response *)NULL))
      goto __CPROVER_DUMP_L1;

    send_crunch_response(csp, rsp);
    csp->flags = csp->flags | 0x04000000U;
    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    c = crunchers;
    for( ; !(c->cruncher == ((struct http_response * (*)(struct client_state *))NULL)); c = c + 1l)
    {
      if(!((0x20U & csp->flags) == 0u))
        tmp_if_expr_1 = !((csp->flags & 0x04U) != 0u) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (c->flags & 1) != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        rsp=c->cruncher(csp);
        if(!(rsp == ((struct http_response *)NULL)))
        {
          send_crunch_response(csp, rsp);
          csp->flags = csp->flags | 0x04000000U;
          if(!((2 & c->flags) == 0))
            csp->flags = csp->flags | 0x10U;

          return 1;
        }

      }

    }
    return 0;
  }
}

// crunch_server_header
// file parsers.c line 2098
static enum privoxy_err crunch_server_header(struct client_state *csp, char **header)
{
  const char *crunch_pattern;
  if(!((0x00100000UL & csp->action[0l].flags) == 0ul))
  {
    crunch_pattern = csp->action[0l].string[(signed long int)6];
    char *return_value_strstr_1;
    return_value_strstr_1=strstr(*header, crunch_pattern);
    if(!(return_value_strstr_1 == ((char *)NULL)))
    {
      log_error(0x0008, "Crunching server header: %s (contains: %s)", *header, crunch_pattern);
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

    }

  }

  return (enum privoxy_err)JB_ERR_OK;
}

// current_action_to_html
// file actions.c line 1828
extern char * current_action_to_html(struct client_state *csp, struct current_action_spec *action)
{
  unsigned long int flags = action->flags;
  struct list_entry *lst;
  char *result;
  result=strdup_or_die("");
  char *active;
  active=strdup_or_die("");
  char *inactive;
  inactive=strdup_or_die("");
  lst = action->multi[(signed long int)0][0l].first;
  if(lst == ((struct list_entry *)NULL))
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_1;
    return_value_add_help_link_1=add_help_link("add-header", csp->config);
    string_join(&inactive, return_value_add_help_link_1);
  }

  else
    while(!(lst == ((struct list_entry *)NULL)))
    {
      string_append(&active, "\n<br>+");
      char *return_value_add_help_link_2;
      return_value_add_help_link_2=add_help_link("add-header", csp->config);
      string_join(&active, return_value_add_help_link_2);
      string_append(&active, "{");
      char *return_value_html_encode_3;
      return_value_html_encode_3=html_encode(lst->str);
      string_join(&active, return_value_html_encode_3);
      string_append(&active, "}");
      lst = lst->next;
    }
  if(!((0x00000001UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_4;
    return_value_add_help_link_4=add_help_link("block", csp->config);
    string_join(&active, return_value_add_help_link_4);
    string_append(&active, "{");
    char *return_value_html_encode_5;
    return_value_html_encode_5=html_encode(action->string[(signed long int)16]);
    string_join(&active, return_value_html_encode_5);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_6;
    return_value_add_help_link_6=add_help_link("block", csp->config);
    string_join(&inactive, return_value_add_help_link_6);
  }
  if(!((0x00000010UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_7;
    return_value_add_help_link_7=add_help_link("change-x-forwarded-for", csp->config);
    string_join(&active, return_value_add_help_link_7);
    string_append(&active, "{");
    char *return_value_html_encode_8;
    return_value_html_encode_8=html_encode(action->string[(signed long int)17]);
    string_join(&active, return_value_html_encode_8);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_9;
    return_value_add_help_link_9=add_help_link("change-x-forwarded-for", csp->config);
    string_join(&inactive, return_value_add_help_link_9);
  }
  lst = action->multi[(signed long int)3][0l].first;
  if(lst == ((struct list_entry *)NULL))
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_10;
    return_value_add_help_link_10=add_help_link("client-header-filter", csp->config);
    string_join(&inactive, return_value_add_help_link_10);
  }

  else
    while(!(lst == ((struct list_entry *)NULL)))
    {
      string_append(&active, "\n<br>+");
      char *return_value_add_help_link_11;
      return_value_add_help_link_11=add_help_link("client-header-filter", csp->config);
      string_join(&active, return_value_add_help_link_11);
      string_append(&active, "{");
      char *return_value_html_encode_12;
      return_value_html_encode_12=html_encode(lst->str);
      string_join(&active, return_value_html_encode_12);
      string_append(&active, "}");
      lst = lst->next;
    }
  lst = action->multi[(signed long int)4][0l].first;
  if(lst == ((struct list_entry *)NULL))
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_13;
    return_value_add_help_link_13=add_help_link("client-header-tagger", csp->config);
    string_join(&inactive, return_value_add_help_link_13);
  }

  else
    while(!(lst == ((struct list_entry *)NULL)))
    {
      string_append(&active, "\n<br>+");
      char *return_value_add_help_link_14;
      return_value_add_help_link_14=add_help_link("client-header-tagger", csp->config);
      string_join(&active, return_value_add_help_link_14);
      string_append(&active, "{");
      char *return_value_html_encode_15;
      return_value_html_encode_15=html_encode(lst->str);
      string_join(&active, return_value_html_encode_15);
      string_append(&active, "}");
      lst = lst->next;
    }
  if(!((0x00080000UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_16;
    return_value_add_help_link_16=add_help_link("content-type-overwrite", csp->config);
    string_join(&active, return_value_add_help_link_16);
    string_append(&active, "{");
    char *return_value_html_encode_17;
    return_value_html_encode_17=html_encode(action->string[(signed long int)9]);
    string_join(&active, return_value_html_encode_17);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_18;
    return_value_add_help_link_18=add_help_link("content-type-overwrite", csp->config);
    string_join(&inactive, return_value_add_help_link_18);
  }
  if(!((0x00200000UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_19;
    return_value_add_help_link_19=add_help_link("crunch-client-header", csp->config);
    string_join(&active, return_value_add_help_link_19);
    string_append(&active, "{");
    char *return_value_html_encode_20;
    return_value_html_encode_20=html_encode(action->string[(signed long int)7]);
    string_join(&active, return_value_html_encode_20);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_21;
    return_value_add_help_link_21=add_help_link("crunch-client-header", csp->config);
    string_join(&inactive, return_value_add_help_link_21);
  }
  if(!((0x00800000UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_22;
    return_value_add_help_link_22=add_help_link("crunch-if-none-match", csp->config);
    string_join(&active, return_value_add_help_link_22);
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_23;
    return_value_add_help_link_23=add_help_link("crunch-if-none-match", csp->config);
    string_join(&inactive, return_value_add_help_link_23);
  }
  if(!((0x00002000UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_24;
    return_value_add_help_link_24=add_help_link("crunch-incoming-cookies", csp->config);
    string_join(&active, return_value_add_help_link_24);
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_25;
    return_value_add_help_link_25=add_help_link("crunch-incoming-cookies", csp->config);
    string_join(&inactive, return_value_add_help_link_25);
  }
  if(!((0x00001000UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_26;
    return_value_add_help_link_26=add_help_link("crunch-outgoing-cookies", csp->config);
    string_join(&active, return_value_add_help_link_26);
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_27;
    return_value_add_help_link_27=add_help_link("crunch-outgoing-cookies", csp->config);
    string_join(&inactive, return_value_add_help_link_27);
  }
  if(!((0x00100000UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_28;
    return_value_add_help_link_28=add_help_link("crunch-server-header", csp->config);
    string_join(&active, return_value_add_help_link_28);
    string_append(&active, "{");
    char *return_value_html_encode_29;
    return_value_html_encode_29=html_encode(action->string[(signed long int)6]);
    string_join(&active, return_value_html_encode_29);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_30;
    return_value_add_help_link_30=add_help_link("crunch-server-header", csp->config);
    string_join(&inactive, return_value_add_help_link_30);
  }
  if(!((0x00000002UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_31;
    return_value_add_help_link_31=add_help_link("deanimate-gifs", csp->config);
    string_join(&active, return_value_add_help_link_31);
    string_append(&active, "{");
    char *return_value_html_encode_32;
    return_value_html_encode_32=html_encode(action->string[(signed long int)0]);
    string_join(&active, return_value_html_encode_32);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_33;
    return_value_add_help_link_33=add_help_link("deanimate-gifs", csp->config);
    string_join(&inactive, return_value_add_help_link_33);
  }
  if(!((0x00000004UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_34;
    return_value_add_help_link_34=add_help_link("downgrade-http-version", csp->config);
    string_join(&active, return_value_add_help_link_34);
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_35;
    return_value_add_help_link_35=add_help_link("downgrade-http-version", csp->config);
    string_join(&inactive, return_value_add_help_link_35);
  }
  lst = action->multi[(signed long int)6][0l].first;
  if(lst == ((struct list_entry *)NULL))
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_36;
    return_value_add_help_link_36=add_help_link("external-filter", csp->config);
    string_join(&inactive, return_value_add_help_link_36);
  }

  else
    while(!(lst == ((struct list_entry *)NULL)))
    {
      string_append(&active, "\n<br>+");
      char *return_value_add_help_link_37;
      return_value_add_help_link_37=add_help_link("external-filter", csp->config);
      string_join(&active, return_value_add_help_link_37);
      string_append(&active, "{");
      char *return_value_html_encode_38;
      return_value_html_encode_38=html_encode(lst->str);
      string_join(&active, return_value_html_encode_38);
      string_append(&active, "}");
      lst = lst->next;
    }
  if(!((0x00000008UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_39;
    return_value_add_help_link_39=add_help_link("fast-redirects", csp->config);
    string_join(&active, return_value_add_help_link_39);
    string_append(&active, "{");
    char *return_value_html_encode_40;
    return_value_html_encode_40=html_encode(action->string[(signed long int)14]);
    string_join(&active, return_value_html_encode_40);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_41;
    return_value_add_help_link_41=add_help_link("fast-redirects", csp->config);
    string_join(&inactive, return_value_add_help_link_41);
  }
  lst = action->multi[(signed long int)1][0l].first;
  if(lst == ((struct list_entry *)NULL))
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_42;
    return_value_add_help_link_42=add_help_link("filter", csp->config);
    string_join(&inactive, return_value_add_help_link_42);
  }

  else
    while(!(lst == ((struct list_entry *)NULL)))
    {
      string_append(&active, "\n<br>+");
      char *return_value_add_help_link_43;
      return_value_add_help_link_43=add_help_link("filter", csp->config);
      string_join(&active, return_value_add_help_link_43);
      string_append(&active, "{");
      char *return_value_html_encode_44;
      return_value_html_encode_44=html_encode(lst->str);
      string_join(&active, return_value_html_encode_44);
      string_append(&active, "}");
      lst = lst->next;
    }
  if(!((0x00400000UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_45;
    return_value_add_help_link_45=add_help_link("force-text-mode", csp->config);
    string_join(&active, return_value_add_help_link_45);
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_46;
    return_value_add_help_link_46=add_help_link("force-text-mode", csp->config);
    string_join(&inactive, return_value_add_help_link_46);
  }
  if(!((0x00004000UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_47;
    return_value_add_help_link_47=add_help_link("forward-override", csp->config);
    string_join(&active, return_value_add_help_link_47);
    string_append(&active, "{");
    char *return_value_html_encode_48;
    return_value_html_encode_48=html_encode(action->string[(signed long int)15]);
    string_join(&active, return_value_html_encode_48);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_49;
    return_value_add_help_link_49=add_help_link("forward-override", csp->config);
    string_join(&inactive, return_value_add_help_link_49);
  }
  if(!((0x00008000UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_50;
    return_value_add_help_link_50=add_help_link("handle-as-empty-document", csp->config);
    string_join(&active, return_value_add_help_link_50);
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_51;
    return_value_add_help_link_51=add_help_link("handle-as-empty-document", csp->config);
    string_join(&inactive, return_value_add_help_link_51);
  }
  if(!((0x00000100UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_52;
    return_value_add_help_link_52=add_help_link("handle-as-image", csp->config);
    string_join(&active, return_value_add_help_link_52);
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_53;
    return_value_add_help_link_53=add_help_link("handle-as-image", csp->config);
    string_join(&inactive, return_value_add_help_link_53);
  }
  if(!((0x04000000UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_54;
    return_value_add_help_link_54=add_help_link("hide-accept-language", csp->config);
    string_join(&active, return_value_add_help_link_54);
    string_append(&active, "{");
    char *return_value_html_encode_55;
    return_value_html_encode_55=html_encode(action->string[(signed long int)8]);
    string_join(&active, return_value_html_encode_55);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_56;
    return_value_add_help_link_56=add_help_link("hide-accept-language", csp->config);
    string_join(&inactive, return_value_add_help_link_56);
  }
  if(!((0x01000000UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_57;
    return_value_add_help_link_57=add_help_link("hide-content-disposition", csp->config);
    string_join(&active, return_value_add_help_link_57);
    string_append(&active, "{");
    char *return_value_html_encode_58;
    return_value_html_encode_58=html_encode(action->string[(signed long int)10]);
    string_join(&active, return_value_html_encode_58);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_59;
    return_value_add_help_link_59=add_help_link("hide-content-disposition", csp->config);
    string_join(&inactive, return_value_add_help_link_59);
  }
  if(!((0x00000020UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_60;
    return_value_add_help_link_60=add_help_link("hide-from-header", csp->config);
    string_join(&active, return_value_add_help_link_60);
    string_append(&active, "{");
    char *return_value_html_encode_61;
    return_value_html_encode_61=html_encode(action->string[(signed long int)1]);
    string_join(&active, return_value_html_encode_61);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_62;
    return_value_add_help_link_62=add_help_link("hide-from-header", csp->config);
    string_join(&inactive, return_value_add_help_link_62);
  }
  if(!((0x00040000UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_63;
    return_value_add_help_link_63=add_help_link("hide-if-modified-since", csp->config);
    string_join(&active, return_value_add_help_link_63);
    string_append(&active, "{");
    char *return_value_html_encode_64;
    return_value_html_encode_64=html_encode(action->string[(signed long int)11]);
    string_join(&active, return_value_html_encode_64);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_65;
    return_value_add_help_link_65=add_help_link("hide-if-modified-since", csp->config);
    string_join(&inactive, return_value_add_help_link_65);
  }
  if(!((0x00000040UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_66;
    return_value_add_help_link_66=add_help_link("hide-referrer", csp->config);
    string_join(&active, return_value_add_help_link_66);
    string_append(&active, "{");
    char *return_value_html_encode_67;
    return_value_html_encode_67=html_encode(action->string[(signed long int)3]);
    string_join(&active, return_value_html_encode_67);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_68;
    return_value_add_help_link_68=add_help_link("hide-referrer", csp->config);
    string_join(&inactive, return_value_add_help_link_68);
  }
  if(!((0x00000080UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_69;
    return_value_add_help_link_69=add_help_link("hide-user-agent", csp->config);
    string_join(&active, return_value_add_help_link_69);
    string_append(&active, "{");
    char *return_value_html_encode_70;
    return_value_html_encode_70=html_encode(action->string[(signed long int)4]);
    string_join(&active, return_value_html_encode_70);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_71;
    return_value_add_help_link_71=add_help_link("hide-user-agent", csp->config);
    string_join(&inactive, return_value_add_help_link_71);
  }
  if(!((0x00010000UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_72;
    return_value_add_help_link_72=add_help_link("limit-connect", csp->config);
    string_join(&active, return_value_add_help_link_72);
    string_append(&active, "{");
    char *return_value_html_encode_73;
    return_value_html_encode_73=html_encode(action->string[(signed long int)5]);
    string_join(&active, return_value_html_encode_73);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_74;
    return_value_add_help_link_74=add_help_link("limit-connect", csp->config);
    string_join(&inactive, return_value_add_help_link_74);
  }
  if(!((0x08000000UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_75;
    return_value_add_help_link_75=add_help_link("limit-cookie-lifetime", csp->config);
    string_join(&active, return_value_add_help_link_75);
    string_append(&active, "{");
    char *return_value_html_encode_76;
    return_value_html_encode_76=html_encode(action->string[(signed long int)18]);
    string_join(&active, return_value_html_encode_76);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_77;
    return_value_add_help_link_77=add_help_link("limit-cookie-lifetime", csp->config);
    string_join(&inactive, return_value_add_help_link_77);
  }
  if(!((0x02000000UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_78;
    return_value_add_help_link_78=add_help_link("overwrite-last-modified", csp->config);
    string_join(&active, return_value_add_help_link_78);
    string_append(&active, "{");
    char *return_value_html_encode_79;
    return_value_html_encode_79=html_encode(action->string[(signed long int)12]);
    string_join(&active, return_value_html_encode_79);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_80;
    return_value_add_help_link_80=add_help_link("overwrite-last-modified", csp->config);
    string_join(&inactive, return_value_add_help_link_80);
  }
  if(!((0x00000400UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_81;
    return_value_add_help_link_81=add_help_link("prevent-compression", csp->config);
    string_join(&active, return_value_add_help_link_81);
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_82;
    return_value_add_help_link_82=add_help_link("prevent-compression", csp->config);
    string_join(&inactive, return_value_add_help_link_82);
  }
  if(!((0x00020000UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_83;
    return_value_add_help_link_83=add_help_link("redirect", csp->config);
    string_join(&active, return_value_add_help_link_83);
    string_append(&active, "{");
    char *return_value_html_encode_84;
    return_value_html_encode_84=html_encode(action->string[(signed long int)13]);
    string_join(&active, return_value_html_encode_84);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_85;
    return_value_add_help_link_85=add_help_link("redirect", csp->config);
    string_join(&inactive, return_value_add_help_link_85);
  }
  lst = action->multi[(signed long int)2][0l].first;
  if(lst == ((struct list_entry *)NULL))
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_86;
    return_value_add_help_link_86=add_help_link("server-header-filter", csp->config);
    string_join(&inactive, return_value_add_help_link_86);
  }

  else
    while(!(lst == ((struct list_entry *)NULL)))
    {
      string_append(&active, "\n<br>+");
      char *return_value_add_help_link_87;
      return_value_add_help_link_87=add_help_link("server-header-filter", csp->config);
      string_join(&active, return_value_add_help_link_87);
      string_append(&active, "{");
      char *return_value_html_encode_88;
      return_value_html_encode_88=html_encode(lst->str);
      string_join(&active, return_value_html_encode_88);
      string_append(&active, "}");
      lst = lst->next;
    }
  lst = action->multi[(signed long int)5][0l].first;
  if(lst == ((struct list_entry *)NULL))
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_89;
    return_value_add_help_link_89=add_help_link("server-header-tagger", csp->config);
    string_join(&inactive, return_value_add_help_link_89);
  }

  else
    while(!(lst == ((struct list_entry *)NULL)))
    {
      string_append(&active, "\n<br>+");
      char *return_value_add_help_link_90;
      return_value_add_help_link_90=add_help_link("server-header-tagger", csp->config);
      string_join(&active, return_value_add_help_link_90);
      string_append(&active, "{");
      char *return_value_html_encode_91;
      return_value_html_encode_91=html_encode(lst->str);
      string_join(&active, return_value_html_encode_91);
      string_append(&active, "}");
      lst = lst->next;
    }
  if(!((0x00000800UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_92;
    return_value_add_help_link_92=add_help_link("session-cookies-only", csp->config);
    string_join(&active, return_value_add_help_link_92);
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_93;
    return_value_add_help_link_93=add_help_link("session-cookies-only", csp->config);
    string_join(&inactive, return_value_add_help_link_93);
  }
  if(!((0x00000200UL & flags) == 0ul))
  {
    string_append(&active, "\n<br>+");
    char *return_value_add_help_link_94;
    return_value_add_help_link_94=add_help_link("set-image-blocker", csp->config);
    string_join(&active, return_value_add_help_link_94);
    string_append(&active, "{");
    char *return_value_html_encode_95;
    return_value_html_encode_95=html_encode(action->string[(signed long int)2]);
    string_join(&active, return_value_html_encode_95);
    string_append(&active, "}");
  }

  else
  {
    string_append(&inactive, "\n<br>-");
    char *return_value_add_help_link_96;
    return_value_add_help_link_96=add_help_link("set-image-blocker", csp->config);
    string_join(&inactive, return_value_add_help_link_96);
  }
  if(!(active == ((char *)NULL)))
  {
    string_append(&result, active);
    if(!(active == ((char *)NULL)))
    {
      free((void *)active);
      active = (char *)(void *)0;
    }

  }

  string_append(&result, "\n<br>");
  if(!(inactive == ((char *)NULL)))
  {
    string_append(&result, inactive);
    if(!(inactive == ((char *)NULL)))
    {
      free((void *)inactive);
      inactive = (char *)(void *)0;
    }

  }

  return result;
}

// data_is_available
// file jbsockets.h line 52
extern signed int data_is_available(signed int fd, signed int seconds_to_wait)
{
  char buf[10l];
  struct anonymous_13 rfds;
  struct timeval timeout;
  signed int n;
  memset((void *)&timeout, 0, sizeof(struct timeval) /*16ul*/ );
  timeout.tv_sec = (signed long int)seconds_to_wait;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_13) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfds)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&rfds)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfds)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  n=select(fd + 1, &rfds, (struct anonymous_13 *)(void *)0, (struct anonymous_13 *)(void *)0, &timeout);
  _Bool tmp_if_expr_2;
  signed long int return_value_recv_1;
  if(n == 1)
  {
    return_value_recv_1=recv(fd, (void *)buf, (unsigned long int)1, 2);
    tmp_if_expr_2 = (signed long int)1 == return_value_recv_1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  return (signed int)tmp_if_expr_2;
}

// debug_level_is_enabled
// file errlog.c line 263
extern signed int debug_level_is_enabled(signed int debug_level)
{
  return (signed int)(0 != (debug & debug_level));
}

// decompress_iob
// file parsers.h line 56
extern enum privoxy_err decompress_iob(struct client_state *csp)
{
  char *buf;
  char *cur;
  unsigned long int bufsize;
  unsigned long int old_size;
  unsigned long int skip_size;
  signed int status;
  struct z_stream_s zstr;
  /* assertion csp->iob->cur - csp->iob->buf > 0 */
  assert(csp->iob[0l].cur - csp->iob[0l].buf > (signed long int)0);
  /* assertion csp->iob->eod - csp->iob->cur > 0 */
  assert(csp->iob[0l].eod - csp->iob[0l].cur > (signed long int)0);
  bufsize = csp->iob[0l].size;
  skip_size = (unsigned long int)(csp->iob[0l].cur - csp->iob[0l].buf);
  old_size = (unsigned long int)(csp->iob[0l].eod - csp->iob[0l].cur);
  cur = csp->iob[0l].cur;
  char *tmp_post_7;
  _Bool tmp_if_expr_9;
  char *tmp_post_8;
  _Bool tmp_if_expr_11;
  char *tmp_post_10;
  char *tmp_post_1;
  char *tmp_post_2;
  char *tmp_post_3;
  _Bool tmp_if_expr_4;
  char *tmp_post_5;
  char *tmp_post_6;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_17;
  if(!(bufsize >= 10ul))
  {
    log_error(0x2000, "Insufficient data to start decompression. Bytes in buffer: %d", csp->iob[0l].eod - csp->iob[0l].cur);
    return (enum privoxy_err)JB_ERR_COMPRESS;
  }

  else
  {
    if(!((0x0010U & csp->content_type) == 0u))
    {
      tmp_post_7 = cur;
      cur = cur + 1l;
      if(!((0xff & (signed int)*tmp_post_7) == 0x1f))
        tmp_if_expr_9 = (_Bool)1;

      else
      {
        tmp_post_8 = cur;
        cur = cur + 1l;
        tmp_if_expr_9 = ((signed int)*tmp_post_8 & 0xff) != 0x8b ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_9)
        tmp_if_expr_11 = (_Bool)1;

      else
      {
        tmp_post_10 = cur;
        cur = cur + 1l;
        tmp_if_expr_11 = (signed int)*tmp_post_10 != 8 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_11)
      {
        log_error(0x2000, "Invalid gzip header when decompressing");
        return (enum privoxy_err)JB_ERR_COMPRESS;
      }

      else
      {
        signed int flags;
        tmp_post_1 = cur;
        cur = cur + 1l;
        flags = (signed int)*tmp_post_1;
        if(!((0xe0 & flags) == 0))
        {
          log_error(0x2000, "Invalid gzip header flags when decompressing");
          return (enum privoxy_err)JB_ERR_COMPRESS;
        }

        cur = cur + (signed long int)6;
        if(!((0x04 & flags) == 0))
        {
          signed int skip_bytes;
          tmp_post_2 = cur;
          cur = cur + 1l;
          skip_bytes = (signed int)*tmp_post_2;
          tmp_post_3 = cur;
          cur = cur + 1l;
          skip_bytes = skip_bytes + ((signed int)*tmp_post_3 << 8);
          if(!(skip_bytes >= 0))
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = (signed long int)skip_bytes >= csp->iob[0l].eod - cur ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_4)
          {
            log_error(0x2000, "Unreasonable amount of bytes to skip (%d). Stopping decompression", skip_bytes);
            return (enum privoxy_err)JB_ERR_COMPRESS;
          }

          log_error(0x1000, "Skipping %d bytes for gzip compression. Does this sound right?", skip_bytes);
          cur = cur + (signed long int)skip_bytes;
        }

        if(!((0x08 & flags) == 0))
          do
          {
            tmp_post_5 = cur;
            cur = cur + 1l;
            if(*tmp_post_5 == 0)
              break;

            if(cur >= csp->iob[0l].eod)
              break;

          }
          while((_Bool)1);

        if(!((0x10 & flags) == 0))
          do
          {
            tmp_post_6 = cur;
            cur = cur + 1l;
            if(*tmp_post_6 == 0)
              break;

            if(cur >= csp->iob[0l].eod)
              break;

          }
          while((_Bool)1);

        if(!((0x02 & flags) == 0))
          cur = cur + (signed long int)2;

        if(cur >= csp->iob[0l].eod)
        {
          log_error(0x2000, "Malformed gzip header detected. Aborting decompression.");
          return (enum privoxy_err)JB_ERR_COMPRESS;
        }

      }
    }

    else
      if(!((0x0020U & csp->content_type) == 0u))
        csp->iob[0l].eod = csp->iob[0l].eod + 1l;

      else
      {
        log_error(0x2000, "Unable to determine compression format for decompression");
        return (enum privoxy_err)JB_ERR_COMPRESS;
      }
    zstr.next_in = (unsigned char *)cur;
    zstr.avail_in = (unsigned int)(csp->iob[0l].eod - cur);
    zstr.zalloc = ((void * (*)(void *, unsigned int, unsigned int))NULL);
    zstr.zfree = ((void (*)(void *, void *))NULL);
    zstr.opaque = NULL;
    signed int return_value_inflateInit2__12;
    return_value_inflateInit2__12=inflateInit2_(&zstr, -15, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
    if(!(return_value_inflateInit2__12 == 0))
    {
      log_error(0x2000, "Error initializing decompression");
      return (enum privoxy_err)JB_ERR_COMPRESS;
    }

    else
    {
      void *return_value_zalloc_13;
      return_value_zalloc_13=zalloc(bufsize);
      buf = (char *)return_value_zalloc_13;
      if(buf == ((char *)NULL))
      {
        log_error(0x2000, "Out of memory decompressing iob");
        return (enum privoxy_err)JB_ERR_MEMORY;
      }

      else
      {
        /* assertion bufsize >= skip_size */
        assert(bufsize >= skip_size);
        memcpy((void *)buf, (const void *)csp->iob[0l].buf, skip_size);
        zstr.avail_out = (unsigned int)(bufsize - skip_size);
        zstr.next_out = (unsigned char *)buf + (signed long int)skip_size;
        do
        {
          status=inflate(&zstr, 4);
          if(!(status == -5))
            break;

          char *tmpbuf;
          unsigned long int oldbufsize = bufsize;
          if(zstr.avail_in == 0u)
          {
            log_error(0x2000, "Unexpected end of compressed iob. Using what we got so far.");
            break;
          }

          if(bufsize >= csp->config->buffer_limit)
          {
            log_error(0x2000, "Buffer limit reached while decompressing iob");
            return (enum privoxy_err)JB_ERR_MEMORY;
          }

          bufsize = bufsize * (unsigned long int)2;
          if(!(csp->config->buffer_limit >= bufsize))
            bufsize = csp->config->buffer_limit;

          void *return_value_realloc_14;
          return_value_realloc_14=realloc((void *)buf, bufsize);
          tmpbuf = (char *)return_value_realloc_14;
          if(tmpbuf == ((char *)NULL))
          {
            log_error(0x2000, "Out of memory decompressing iob");
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

            return (enum privoxy_err)JB_ERR_MEMORY;
          }

          else
          {
            char *oldnext_out = (char *)zstr.next_out;
            zstr.avail_out = zstr.avail_out + (unsigned int)(bufsize - oldbufsize);
            zstr.next_out = ((unsigned char *)tmpbuf + (signed long int)bufsize) - (signed long int)zstr.avail_out;
            /* assertion zstr.avail_out == tmpbuf + bufsize - (char *)zstr.next_out */
            assert((signed long int)zstr.avail_out == (tmpbuf + (signed long int)bufsize) - (char *)zstr.next_out);
            /* assertion (char *)zstr.next_out == tmpbuf + ((char *)oldnext_out - buf) */
            assert((char *)zstr.next_out == tmpbuf + ((char *)oldnext_out - buf));
            buf = tmpbuf;
          }
        }
        while((_Bool)1);
        signed int return_value_inflateEnd_15;
        return_value_inflateEnd_15=inflateEnd(&zstr);
        if(return_value_inflateEnd_15 == -2)
          log_error(0x2000, "Inconsistent stream state after decompression: %s", zstr.msg);

        if(!(zstr.avail_in == 0u) && !(status == 1))
        {
          log_error(0x2000, "Unexpected error while decompressing to the buffer (iob): %s", zstr.msg);
          return (enum privoxy_err)JB_ERR_COMPRESS;
        }

        else
        {
          if(!(csp->iob[0l].buf == ((char *)NULL)))
          {
            free((void *)csp->iob[0l].buf);
            csp->iob[0l].buf = (char *)(void *)0;
          }

          csp->iob[0l].buf = buf;
          csp->iob[0l].cur = csp->iob[0l].buf + (signed long int)skip_size;
          csp->iob[0l].eod = (char *)zstr.next_out;
          csp->iob[0l].size = bufsize;
          if(!(csp->iob[0l].buf >= csp->iob[0l].cur))
            tmp_if_expr_16 = csp->iob[0l].cur <= csp->iob[0l].eod ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_16 = (_Bool)0;
          if(tmp_if_expr_16)
            tmp_if_expr_17 = csp->iob[0l].eod <= csp->iob[0l].buf + (signed long int)csp->iob[0l].size ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_17 = (_Bool)0;
          if(tmp_if_expr_17)
          {
            const unsigned long int new_size = (unsigned long int)(csp->iob[0l].eod - csp->iob[0l].cur);
            if(new_size >= 1ul)
              log_error(0x0040, "Decompression successful. Old size: %d, new size: %d.", old_size, new_size);

            else
              log_error(0x1000, "Decompression didn't result in any content.");
          }

          else
          {
            log_error(0x2000, "Unexpected error decompressing the buffer (iob): %d==%d, %d>%d, %d<%d", csp->iob[0l].cur, csp->iob[0l].buf + (signed long int)skip_size, csp->iob[0l].eod, csp->iob[0l].buf, csp->iob[0l].eod, csp->iob[0l].buf + (signed long int)csp->iob[0l].size);
            return (enum privoxy_err)JB_ERR_COMPRESS;
          }
          return (enum privoxy_err)JB_ERR_OK;
        }
      }
    }
  }
}

// default_exports
// file cgi.c line 2151
extern struct map * default_exports(struct client_state *csp, const char *caller)
{
  char buf[30l];
  enum privoxy_err err;
  struct map *exports;
  signed int local_help_exists = 0;
  char *ip_address = (char *)(void *)0;
  char *port = (char *)(void *)0;
  char *hostname = (char *)(void *)0;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  exports=new_map();
  if(!(csp->config->hostname == ((const char *)NULL)))
  {
    get_host_information(csp->cfd, &ip_address, &port, (char **)(void *)0);
    hostname=strdup(csp->config->hostname);
  }

  else
    get_host_information(csp->cfd, &ip_address, &port, &hostname);
  char *return_value_html_encode_1;
  return_value_html_encode_1=html_encode("3.0.24");
  err=map(exports, "version", 1, return_value_html_encode_1, 0);
  get_locale_time(buf, sizeof(char [30l]) /*30ul*/ );
  char *return_value_html_encode_2;
  if(err == /*enum*/JB_ERR_OK)
  {
    return_value_html_encode_2=html_encode(buf);
    err=map(exports, "time", 1, return_value_html_encode_2, 0);
  }

  char *return_value_html_encode_3;
  if(err == /*enum*/JB_ERR_OK)
  {
    return_value_html_encode_3=html_encode(ip_address != ((char *)NULL) ? ip_address : "unknown");
    err=map(exports, "my-ip-address", 1, return_value_html_encode_3, 0);
  }

  if(!(ip_address == ((char *)NULL)))
  {
    free((void *)ip_address);
    ip_address = (char *)(void *)0;
  }

  char *return_value_html_encode_4;
  if(err == /*enum*/JB_ERR_OK)
  {
    return_value_html_encode_4=html_encode(port != ((char *)NULL) ? port : "unknown");
    err=map(exports, "my-port", 1, return_value_html_encode_4, 0);
  }

  if(!(port == ((char *)NULL)))
  {
    free((void *)port);
    port = (char *)(void *)0;
  }

  char *return_value_html_encode_5;
  if(err == /*enum*/JB_ERR_OK)
  {
    return_value_html_encode_5=html_encode(hostname != ((char *)NULL) ? hostname : "unknown");
    err=map(exports, "my-hostname", 1, return_value_html_encode_5, 0);
  }

  if(!(hostname == ((char *)NULL)))
  {
    free((void *)hostname);
    hostname = (char *)(void *)0;
  }

  char *return_value_html_encode_6;
  if(err == /*enum*/JB_ERR_OK)
  {
    return_value_html_encode_6=html_encode("http://www.privoxy.org/");
    err=map(exports, "homepage", 1, return_value_html_encode_6, 0);
  }

  char *return_value_html_encode_7;
  if(err == /*enum*/JB_ERR_OK)
  {
    return_value_html_encode_7=html_encode("http://config.privoxy.org/");
    err=map(exports, "default-cgi", 1, return_value_html_encode_7, 0);
  }

  char *return_value_make_menu_8;
  if(err == /*enum*/JB_ERR_OK)
  {
    return_value_make_menu_8=make_menu(caller, csp->config->feature_flags);
    err=map(exports, "menu", 1, return_value_make_menu_8, 0);
  }

  if(err == /*enum*/JB_ERR_OK)
    err=map(exports, "code-status", 1, "stable", 1);

  signed int return_value_strncmpic_11;
  return_value_strncmpic_11=strncmpic(csp->config->usermanual, "file://", (unsigned long int)7);
  _Bool tmp_if_expr_13;
  signed int return_value_strncmpic_12;
  if(return_value_strncmpic_11 == 0)
    tmp_if_expr_13 = (_Bool)1;

  else
  {
    return_value_strncmpic_12=strncmpic(csp->config->usermanual, "http", (unsigned long int)4);
    tmp_if_expr_13 = !(return_value_strncmpic_12 != 0) ? (_Bool)1 : (_Bool)0;
  }
  char *return_value_html_encode_9;
  char *return_value_html_encode_10;
  if(tmp_if_expr_13)
  {
    if(err == /*enum*/JB_ERR_OK)
    {
      return_value_html_encode_9=html_encode(csp->config->usermanual);
      err=map(exports, "user-manual", 1, return_value_html_encode_9, 0);
    }

  }

  else
    if(err == /*enum*/JB_ERR_OK)
    {
      return_value_html_encode_10=html_encode("http://config.privoxy.org/user-manual/");
      err=map(exports, "user-manual", 1, return_value_html_encode_10, 0);
    }

  if(err == /*enum*/JB_ERR_OK)
    err=map(exports, "actions-help-prefix", 1, "actions-file.html#", 1);

  if(err == /*enum*/JB_ERR_OK)
    err=map_conditional(exports, "enabled-display", global_toggle_state);

  signed int return_value_strcmp_14;
  return_value_strcmp_14=strcmp("stable", "stable");
  if(return_value_strcmp_14 == 0)
  {
    if(err == /*enum*/JB_ERR_OK)
      err=map_block_killer(exports, "unstable");

  }

  char *return_value_html_encode_15;
  if(!(csp->config->admin_address == ((char *)NULL)))
  {
    if(err == /*enum*/JB_ERR_OK)
    {
      return_value_html_encode_15=html_encode(csp->config->admin_address);
      err=map(exports, "admin-address", 1, return_value_html_encode_15, 0);
    }

    local_help_exists = 1;
  }

  else
    if(err == /*enum*/JB_ERR_OK)
      err=map_block_killer(exports, "have-adminaddr-info");

  char *return_value_html_encode_16;
  if(!(csp->config->proxy_info_url == ((char *)NULL)))
  {
    if(err == /*enum*/JB_ERR_OK)
    {
      return_value_html_encode_16=html_encode(csp->config->proxy_info_url);
      err=map(exports, "proxy-info-url", 1, return_value_html_encode_16, 0);
    }

    local_help_exists = 1;
  }

  else
    if(err == /*enum*/JB_ERR_OK)
      err=map_block_killer(exports, "have-proxy-info");

  if(local_help_exists == 0)
  {
    if(err == /*enum*/JB_ERR_OK)
      err=map_block_killer(exports, "have-help-info");

  }

  if(!(err == /*enum*/JB_ERR_OK))
  {
    free_map(exports);
    return (struct map *)(void *)0;
  }

  else
    return exports;
}

// destroy_list
// file list.h line 49
extern void destroy_list(struct list *the_list)
{
  struct list_entry *cur_entry;
  struct list_entry *next_entry;
  /* assertion the_list */
  assert(the_list != ((struct list *)NULL));
  cur_entry = the_list->first;
  for( ; !(cur_entry == ((struct list_entry *)NULL)); cur_entry = next_entry)
  {
    next_entry = cur_entry->next;
    if(!(cur_entry->str == ((char *)NULL)))
    {
      free((void *)cur_entry->str);
      cur_entry->str = (char *)(void *)0;
    }

    free((void *)cur_entry);
  }
  the_list->first = (struct list_entry *)(void *)0;
  the_list->last = (struct list_entry *)(void *)0;
}

// direct_response
// file filters.c line 2572
extern struct http_response * direct_response(struct client_state *csp)
{
  struct http_response *rsp;
  struct list_entry *p;
  signed int return_value_strcmpic_5;
  return_value_strcmpic_5=strcmpic(csp->http[0l].gpc, "trace");
  _Bool tmp_if_expr_7;
  signed int return_value_strcmpic_6;
  if(return_value_strcmpic_5 == 0)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_strcmpic_6=strcmpic(csp->http[0l].gpc, "options");
    tmp_if_expr_7 = 0 == return_value_strcmpic_6 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_7)
  {
    p = csp->headers[0l].first;
    for( ; !(p == ((struct list_entry *)NULL)); p = p->next)
    {
      signed int return_value_strncmpic_4;
      return_value_strncmpic_4=strncmpic(p->str, "Max-Forwards:", (unsigned long int)13);
      if(return_value_strncmpic_4 == 0)
      {
        unsigned int max_forwards;
        signed int return_value_sscanf_3;
        return_value_sscanf_3=sscanf(p->str + (signed long int)12, ": %u", &max_forwards);
        if(return_value_sscanf_3 == 1)
        {
          if(max_forwards == 0u)
          {
            log_error(0x0008, "Detected header '%s' in OPTIONS or TRACE request. Returning 501.", p->str);
            rsp=alloc_http_response();
            if(rsp == ((struct http_response *)NULL))
            {
              struct http_response *return_value_cgi_error_memory_1;
              return_value_cgi_error_memory_1=cgi_error_memory();
              return return_value_cgi_error_memory_1;
            }

            rsp->status=strdup_or_die("501 Not Implemented");
            rsp->is_static = 1;
            rsp->crunch_reason = (enum crunch_reason)UNSUPPORTED;
            struct http_response *return_value_finish_http_response_2;
            return_value_finish_http_response_2=finish_http_response(csp, rsp);
            return return_value_finish_http_response_2;
          }

        }

      }

    }
  }

  return (struct http_response *)(void *)0;
}

// disable_logging
// file errlog.c line 280
extern void disable_logging(void)
{
  if(!(logfp == ((struct _IO_FILE *)NULL)))
  {
    log_error(0x1000, "No logfile configured. Please enable it before reporting any problems.");
    lock_logfile();
    fclose(logfp);
    logfp = (struct _IO_FILE *)(void *)0;
    unlock_logfile();
  }

}

// dispatch_cgi
// file cgi.c line 303
extern struct http_response * dispatch_cgi(struct client_state *csp)
{
  const char *host = csp->http[0l].host;
  const char *path = csp->http[0l].path;
  signed int return_value_strcmpic_8;
  return_value_strcmpic_8=strcmpic(host, "p.p");
  _Bool tmp_if_expr_10;
  signed int return_value_strcmpic_9;
  if(return_value_strcmpic_8 == 0)
    tmp_if_expr_10 = (_Bool)1;

  else
  {
    return_value_strcmpic_9=strcmpic(host, "p.p.");
    tmp_if_expr_10 = 0 == return_value_strcmpic_9 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_11;
  if(tmp_if_expr_10)
    tmp_if_expr_11 = (signed int)path[(signed long int)0] == 47 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_11 = (_Bool)0;
  signed int return_value_strcmpic_2;
  _Bool tmp_if_expr_4;
  signed int return_value_strcmpic_3;
  _Bool tmp_if_expr_7;
  unsigned long int return_value_strlen_5;
  signed int return_value_strncmpic_6;
  if(tmp_if_expr_11)
    path = path + 1l;

  else
  {
    return_value_strcmpic_2=strcmpic(host, "config.privoxy.org");
    if(return_value_strcmpic_2 == 0)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_strcmpic_3=strcmpic(host, "config.privoxy.org.");
      tmp_if_expr_4 = 0 == return_value_strcmpic_3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      return_value_strlen_5=strlen("");
      return_value_strncmpic_6=strncmpic(path, "", return_value_strlen_5);
      tmp_if_expr_7 = 0 == return_value_strncmpic_6 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_7 = (_Bool)0;
    if(tmp_if_expr_7)
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen("");
      path = path + (signed long int)return_value_strlen_1;
      if((signed int)*path == 47)
        path = path + 1l;

      else
        if(!((signed int)*path == 0))
          return (struct http_response *)(void *)0;

    }

    else
      return (struct http_response *)(void *)0;
  }
  signed int return_value_strcmpic_13;
  return_value_strcmpic_13=strcmpic(csp->http[0l].gpc, "GET");
  signed int return_value_strcmpic_12;
  if(!(return_value_strcmpic_13 == 0))
  {
    return_value_strcmpic_12=strcmpic(csp->http[0l].gpc, "HEAD");
    if(!(return_value_strcmpic_12 == 0))
    {
      log_error(0x2000, "CGI request with unsupported method received: %s", csp->http[0l].gpc);
      csp->client_iob[0l].eod = csp->client_iob[0l].cur;
    }

  }

  struct http_response *return_value_dispatch_known_cgi_14;
  return_value_dispatch_known_cgi_14=dispatch_known_cgi(csp, path);
  return return_value_dispatch_known_cgi_14;
}

// dispatch_known_cgi
// file cgi.c line 476
static struct http_response * dispatch_known_cgi(struct client_state *csp, const char *path)
{
  struct cgi_dispatcher *d;
  struct map *param_list;
  struct http_response *rsp;
  char *query_args_start;
  char *path_copy;
  enum privoxy_err err;
  path_copy=strdup(path);
  if(path_copy == ((char *)NULL))
  {
    struct http_response *return_value_cgi_error_memory_1;
    return_value_cgi_error_memory_1=cgi_error_memory();
    return return_value_cgi_error_memory_1;
  }

  query_args_start = path_copy;
  for( ; !(*query_args_start == 0); query_args_start = query_args_start + 1l)
  {
    if((signed int)*query_args_start == 63)
      break;

    if((signed int)*query_args_start == 47)
      break;

  }
  char *tmp_post_2;
  char *tmp_post_5;
  if((signed int)*query_args_start == 47)
  {
    tmp_post_2 = query_args_start;
    query_args_start = query_args_start + 1l;
    *tmp_post_2 = (char)0;
    param_list=new_map();
    char *return_value_url_decode_3;
    return_value_url_decode_3=url_decode(query_args_start);
    err=map(param_list, "file", 1, return_value_url_decode_3, 0);
    if(!((signed int)err == JB_ERR_OK))
    {
      free((void *)param_list);
      free((void *)path_copy);
      struct http_response *return_value_cgi_error_memory_4;
      return_value_cgi_error_memory_4=cgi_error_memory();
      return return_value_cgi_error_memory_4;
    }

  }

  else
  {
    if((signed int)*query_args_start == 63)
    {
      tmp_post_5 = query_args_start;
      query_args_start = query_args_start + 1l;
      *tmp_post_5 = (char)0;
    }

    param_list=parse_cgi_parameters(query_args_start);
    if(param_list == ((struct map *)NULL))
    {
      free((void *)path_copy);
      struct http_response *return_value_cgi_error_memory_6;
      return_value_cgi_error_memory_6=cgi_error_memory();
      return return_value_cgi_error_memory_6;
    }

  }
  rsp=alloc_http_response();
  if(rsp == ((struct http_response *)NULL))
  {
    free((void *)path_copy);
    free_map(param_list);
    struct http_response *return_value_cgi_error_memory_7;
    return_value_cgi_error_memory_7=cgi_error_memory();
    return return_value_cgi_error_memory_7;
  }

  d = cgi_dispatchers;
  _Bool tmp_if_expr_14;
  signed int return_value_strcmp_13;
  _Bool tmp_if_expr_10;
  signed int return_value_referrer_is_safe_9;
  do
  {
    if(d->name == ((const char *)NULL))
      tmp_if_expr_14 = (_Bool)1;

    else
    {
      return_value_strcmp_13=strcmp(path_copy, d->name);
      tmp_if_expr_14 = return_value_strcmp_13 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_14)
    {
      if(!(d->harmless == 0))
        tmp_if_expr_10 = (_Bool)1;

      else
      {
        return_value_referrer_is_safe_9=referrer_is_safe(csp);
        tmp_if_expr_10 = return_value_referrer_is_safe_9 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_10)
        err=d->handler(csp, rsp, param_list);

      else
      {
        signed int return_value_strcmp_8;
        return_value_strcmp_8=strcmp(path_copy, "toggle");
        if(return_value_strcmp_8 == 0)
        {
          unmap(param_list, "set");
          err=d->handler(csp, rsp, param_list);
        }

        else
          err=cgi_error_disabled(csp, rsp);
      }
      free((void *)path_copy);
      free_map(param_list);
      if((signed int)err == JB_ERR_CGI_PARAMS)
        err=cgi_error_bad_param(csp, rsp);

      if(!((signed int)err == JB_ERR_MEMORY) && !(err == /*enum*/JB_ERR_OK))
      {
        log_error(0x2000, "Unexpected CGI error %d in top-level handler. Please file a bug report!", err);
        err=cgi_error_unknown(csp, rsp, err);
      }

      if(err == /*enum*/JB_ERR_OK)
      {
        rsp->crunch_reason = (enum crunch_reason)CGI_CALL;
        struct http_response *return_value_finish_http_response_11;
        return_value_finish_http_response_11=finish_http_response(csp, rsp);
        return return_value_finish_http_response_11;
      }

      else
      {
        free_http_response(rsp);
        struct http_response *return_value_cgi_error_memory_12;
        return_value_cgi_error_memory_12=cgi_error_memory();
        return return_value_cgi_error_memory_12;
      }
    }

    d = d + 1l;
  }
  while((_Bool)1);
}

// domain_match
// file urlmatch.c line 1067
static signed int domain_match(struct pattern_spec *p, struct http_request *fqdn)
{
  char **pv;
  char **fv;
  signed int plen;
  signed int flen;
  signed int unanchored = p->pattern.url_spec.unanchored & (2 | 1);
  plen = p->pattern.url_spec.dcount;
  flen = fqdn->dcount;
  if(!(flen >= plen))
    return 1;

  else
  {
    pv = p->pattern.url_spec.dvec;
    fv = fqdn->dvec;
    if(unanchored == 1)
    {
      fv = fv + (signed long int)(flen - plen);
      signed int return_value_simple_domaincmp_1;
      return_value_simple_domaincmp_1=simple_domaincmp(pv, fv, plen);
      return return_value_simple_domaincmp_1;
    }

    else
      if(unanchored == 0)
      {
        if(!(flen == plen))
          return 1;

        signed int return_value_simple_domaincmp_2;
        return_value_simple_domaincmp_2=simple_domaincmp(pv, fv, plen);
        return return_value_simple_domaincmp_2;
      }

      else
        if(unanchored == 2)
        {
          signed int return_value_simple_domaincmp_3;
          return_value_simple_domaincmp_3=simple_domaincmp(pv, fv, plen);
          return return_value_simple_domaincmp_3;
        }

        else
        {
          signed int n;
          signed int maxn = flen - plen;
          n = 0;
          for( ; maxn >= n; n = n + 1)
          {
            signed int return_value_simple_domaincmp_4;
            return_value_simple_domaincmp_4=simple_domaincmp(pv, fv, plen);
            if(return_value_simple_domaincmp_4 == 0)
              return 0;

            fv = fv + 1l;
          }
          return 1;
        }
  }
}

// drain_and_close_socket
// file jbsockets.c line 760
extern void drain_and_close_socket(signed int fd)
{
  signed int return_value_socket_is_still_alive_3;
  return_value_socket_is_still_alive_3=socket_is_still_alive(fd);
  if(!(return_value_socket_is_still_alive_3 == 0))
  {
    signed int bytes_drained_total = 0;
    signed int bytes_drained;
    signed int return_value_shutdown_1;
    return_value_shutdown_1=shutdown(fd, 1);
    if(!(return_value_shutdown_1 == 0))
      log_error(0x0002, "Failed to shutdown socket %d: %E", fd);

    do
    {
      char drainage[500l];
      signed int return_value_data_is_available_2;
      return_value_data_is_available_2=data_is_available(fd, 0);
      if(return_value_data_is_available_2 == 0)
        break;

      bytes_drained=read_socket(fd, drainage, (signed int)sizeof(char [500l]) /*500ul*/ );
      if(!(bytes_drained >= 0))
        log_error(0x0002, "Failed to drain socket %d: %E", fd);

      else
        if(bytes_drained >= 1)
        {
          bytes_drained_total = bytes_drained_total + bytes_drained;
          if(bytes_drained_total >= 10001)
          {
            log_error(0x0002, "Giving up draining socket %d", fd);
            break;
          }

        }

    }
    while(bytes_drained >= 1);
    if(!(bytes_drained_total == 0))
      log_error(0x0002, "Drained %d bytes before closing socket %d", bytes_drained_total, fd);

  }

  close_socket(fd);
}

// dump_map
// file cgi.c line 2448
extern char * dump_map(struct map *the_map)
{
  struct map_entry *cur_entry;
  char *ret;
  ret=strdup("");
  string_append(&ret, "<table>\n");
  cur_entry = the_map->first;
  for( ; !(ret == ((char *)NULL)) && !(cur_entry == ((struct map_entry *)NULL)); cur_entry = cur_entry->next)
  {
    string_append(&ret, "<tr><td><b>");
    char *return_value_html_encode_1;
    return_value_html_encode_1=html_encode(cur_entry->name);
    string_join(&ret, return_value_html_encode_1);
    string_append(&ret, "</b></td><td>");
    char *return_value_html_encode_2;
    return_value_html_encode_2=html_encode(cur_entry->value);
    string_join(&ret, return_value_html_encode_2);
    string_append(&ret, "</td></tr>\n");
  }
  string_append(&ret, "</table>\n");
  return ret;
}

// edit_free_file
// file cgiedit.c line 864
void edit_free_file(struct editable_file *file)
{
  if(!(file == ((struct editable_file *)NULL)))
  {
    edit_free_file_lines(file->lines);
    if(!(file->version_str == ((const char *)NULL)))
    {
      free((void *)file->version_str);
      file->version_str = (const char *)(void *)0;
    }

    file->version = (unsigned int)0;
    file->parse_error_text = (const char *)(void *)0;
    file->parse_error = (struct file_line *)(void *)0;
    free((void *)file);
  }

}

// edit_free_file_lines
// file cgiedit.c line 894
static void edit_free_file_lines(struct file_line *first_line)
{
  struct file_line *next_line;
  for( ; !(first_line == ((struct file_line *)NULL)); first_line = next_line)
  {
    next_line = first_line->next;
    first_line->next = (struct file_line *)(void *)0;
    if(!(first_line->raw == ((char *)NULL)))
    {
      free((void *)first_line->raw);
      first_line->raw = (char *)(void *)0;
    }

    if(!(first_line->prefix == ((char *)NULL)))
    {
      free((void *)first_line->prefix);
      first_line->prefix = (char *)(void *)0;
    }

    if(!(first_line->unprocessed == ((char *)NULL)))
    {
      free((void *)first_line->unprocessed);
      first_line->unprocessed = (char *)(void *)0;
    }

    switch(first_line->type)
    {
      case 0:

      case 1:

      case 2:

      case 3:

      case 7:

      case 9:

      case 10:

      case 4:

      case 6:
        break;
      case 5:
      {
        free_action(first_line->data.action);
        break;
      }
      case 8:
      {
        if(!(first_line->data.setting.name == ((char *)NULL)))
        {
          free((void *)first_line->data.setting.name);
          first_line->data.setting.name = (char *)(void *)0;
        }

        if(!(first_line->data.setting.svalue == ((char *)NULL)))
        {
          free((void *)first_line->data.setting.svalue);
          first_line->data.setting.svalue = (char *)(void *)0;
        }

        break;
      }
      default:
        /* assertion 0 */
        assert(0 != 0);
    }
    first_line->type = 0;
    free((void *)first_line);
  }
}

// edit_parse_actions_file
// file cgiedit.c line 1094
enum privoxy_err edit_parse_actions_file(struct editable_file *file)
{
  struct file_line *cur_line;
  unsigned long int len;
  const char *text;
  char *name;
  char *value;
  struct action_alias *alias_list = (struct action_alias *)(void *)0;
  enum privoxy_err err = (enum privoxy_err)JB_ERR_OK;
  cur_line = file->lines;
  for( ; !(cur_line == ((struct file_line *)NULL)); cur_line = cur_line->next)
  {
    if(!((signed int)*cur_line->unprocessed == 0))
      break;

    cur_line->type = 2;
  }
  signed int return_value_match_actions_file_header_line_1;
  signed int return_value_match_actions_file_header_line_2;
  signed int return_value_match_actions_file_header_line_4;
  if(!(cur_line == ((struct file_line *)NULL)))
  {
    if((signed int)*cur_line->unprocessed == 123)
      goto __CPROVER_DUMP_L3;

    file->parse_error = cur_line;
    file->parse_error_text = "First (non-comment) line of the file must contain a header.";
    return (enum privoxy_err)JB_ERR_PARSE;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    if(!(cur_line == ((struct file_line *)NULL)))
    {
      return_value_match_actions_file_header_line_1=match_actions_file_header_line(cur_line->unprocessed, "settings");
      if(return_value_match_actions_file_header_line_1 == 0)
      {
        cur_line->type = 7;
        cur_line = cur_line->next;
        for( ; !(cur_line == ((struct file_line *)NULL)); cur_line = cur_line->next)
        {
          if((signed int)*cur_line->unprocessed == 123)
            break;

          if(!(*cur_line->unprocessed == 0))
          {
            cur_line->type = 8;
            err=split_line_on_equals(cur_line->unprocessed, &cur_line->data.setting.name, &cur_line->data.setting.svalue);
            if((signed int)err == JB_ERR_MEMORY)
              return err;

            else
              if(!((signed int)err == JB_ERR_OK))
              {
                file->parse_error = cur_line;
                file->parse_error_text = "Expected a name=value pair on this {{description}} line, but couldn't find one.";
                return (enum privoxy_err)JB_ERR_PARSE;
              }

          }

          else
            cur_line->type = 2;
        }
      }

    }

    if(!(cur_line == ((struct file_line *)NULL)))
    {
      return_value_match_actions_file_header_line_2=match_actions_file_header_line(cur_line->unprocessed, "description");
      if(return_value_match_actions_file_header_line_2 == 0)
      {
        cur_line->type = 9;
        cur_line = cur_line->next;
        for( ; !(cur_line == ((struct file_line *)NULL)); cur_line = cur_line->next)
        {
          if((signed int)*cur_line->unprocessed == 123)
            break;

          if(!(*cur_line->unprocessed == 0))
            cur_line->type = 10;

          else
            cur_line->type = 2;
        }
      }

    }

    if(!(cur_line == ((struct file_line *)NULL)))
    {
      return_value_match_actions_file_header_line_4=match_actions_file_header_line(cur_line->unprocessed, "alias");
      if(return_value_match_actions_file_header_line_4 == 0)
      {
        cur_line->type = 3;
        cur_line = cur_line->next;
        for( ; !(cur_line == ((struct file_line *)NULL)); cur_line = cur_line->next)
        {
          if((signed int)*cur_line->unprocessed == 123)
            break;

          if(!(*cur_line->unprocessed == 0))
          {
            struct action_alias *new_alias;
            cur_line->type = 4;
            err=split_line_on_equals(cur_line->unprocessed, &name, &value);
            if((signed int)err == JB_ERR_MEMORY)
            {
              free_alias_list(alias_list);
              return err;
            }

            else
              if(!((signed int)err == JB_ERR_OK))
              {
                file->parse_error = cur_line;
                file->parse_error_text = "Expected a name=value pair on this {{alias}} line, but couldn't find one.";
                free_alias_list(alias_list);
                return (enum privoxy_err)JB_ERR_PARSE;
              }

            void *return_value_zalloc_3;
            return_value_zalloc_3=zalloc(sizeof(struct action_alias) /*440ul*/ );
            new_alias = (struct action_alias *)return_value_zalloc_3;
            if(new_alias == ((struct action_alias *)NULL))
            {
              free((void *)name);
              free((void *)value);
              free_alias_list(alias_list);
              return (enum privoxy_err)JB_ERR_MEMORY;
            }

            err=get_actions(value, alias_list, new_alias->action);
            if(!(err == /*enum*/JB_ERR_OK))
            {
              free((void *)name);
              free((void *)value);
              free((void *)new_alias);
              free_alias_list(alias_list);
              if((signed int)err == JB_ERR_MEMORY)
                return err;

              else
              {
                file->parse_error = cur_line;
                file->parse_error_text = "This alias does not specify a valid set of actions.";
                return (enum privoxy_err)JB_ERR_PARSE;
              }
            }

            free((void *)value);
            new_alias->name = name;
            new_alias->next = alias_list;
            alias_list = new_alias;
          }

          else
            cur_line->type = 2;
        }
      }

    }

    while(!(cur_line == ((struct file_line *)NULL)))
    {
      /* assertion cur_line->unprocessed[0] == '{' */
      assert((signed int)cur_line->unprocessed[(signed long int)0] == 123);
      text = cur_line->unprocessed + (signed long int)1;
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(text);
      len = return_value_strlen_5 - (unsigned long int)1;
      if(!((signed int)text[(signed long int)len] == 125))
      {
        free_alias_list(alias_list);
        file->parse_error = cur_line;
        file->parse_error_text = "Headers starting with '{' must have a closing bracket ('}').  Headers starting with two brackets ('{{') must close with two brackets ('}}').";
        return (enum privoxy_err)JB_ERR_PARSE;
      }

      if((signed int)*text == 123)
      {
        free_alias_list(alias_list);
        file->parse_error = cur_line;
        file->parse_error_text = "Unknown or unexpected two-bracket header.  Please remember that the system (two-bracket) headers must appear in the order {{settings}}, {{description}}, {{alias}}, and must appear before any actions (one-bracket) headers.  Also note that system headers may not be repeated.";
        return (enum privoxy_err)JB_ERR_PARSE;
      }

      for( ; (_Bool)1; len = len - 1ul)
      {
        if(!((signed int)*text == 32))
        {
          if(!((signed int)*text == 9))
            goto __CPROVER_DUMP_L26;

        }

        text = text + 1l;
      }

    __CPROVER_DUMP_L26:
      ;
      for( ; len >= 1ul; len = len - 1ul)
        if(!((signed int)text[-1l + (signed long int)len] == 32))
        {
          if(!((signed int)text[-1l + (signed long int)len] == 9))
            break;

        }

      cur_line->type = 5;
      void *return_value_malloc_or_die_6;
      return_value_malloc_or_die_6=malloc_or_die(len + (unsigned long int)1);
      value = (char *)return_value_malloc_or_die_6;
      strncpy(value, text, len);
      value[(signed long int)len] = (char)0;
      err=get_actions(value, alias_list, cur_line->data.action);
      if(!(err == /*enum*/JB_ERR_OK))
      {
        free((void *)value);
        free_alias_list(alias_list);
        if((signed int)err == JB_ERR_MEMORY)
          return err;

        else
        {
          file->parse_error = cur_line;
          file->parse_error_text = "This header does not specify a valid set of actions.";
          return (enum privoxy_err)JB_ERR_PARSE;
        }
      }

      free((void *)value);
      cur_line = cur_line->next;
      for( ; !(cur_line == ((struct file_line *)NULL)); cur_line = cur_line->next)
      {
        if((signed int)*cur_line->unprocessed == 123)
          break;

        if(!(*cur_line->unprocessed == 0))
          cur_line->type = 6;

        else
          cur_line->type = 2;
      }
    }
    free_alias_list(alias_list);
    return (enum privoxy_err)JB_ERR_OK;
  }
}

// edit_read_actions_file
// file cgiedit.c line 1614
enum privoxy_err edit_read_actions_file(struct client_state *csp, struct http_response *rsp, struct map *parameters, signed int require_version, struct editable_file **pfile)
{
  enum privoxy_err err;
  struct editable_file *file;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  /* assertion pfile */
  assert(pfile != ((struct editable_file **)NULL));
  *pfile = (struct editable_file *)(void *)0;
  err=edit_read_file(csp, parameters, require_version, &file);
  if(!(err == /*enum*/JB_ERR_OK))
  {
    if((signed int)err == JB_ERR_FILE)
    {
      const char *return_value_lookup_1;
      return_value_lookup_1=lookup(parameters, "f");
      err=cgi_error_file(csp, rsp, return_value_lookup_1);
    }

    else
      if((signed int)err == JB_ERR_MODIFIED)
      {
        /* assertion require_version */
        assert(require_version != 0);
        const char *return_value_lookup_2;
        return_value_lookup_2=lookup(parameters, "f");
        err=cgi_error_modified(csp, rsp, return_value_lookup_2);
        log_error(0x2000, "Blocking CGI edit request due to modification time mismatch.");
        static signed int acceptable_failures = 3 - 1;
        if(acceptable_failures >= 1)
        {
          log_error(0x1000, "The CGI editor will be turned off after another %d mismatche(s).", acceptable_failures);
          acceptable_failures = acceptable_failures - 1;
        }

        else
        {
          log_error(0x1000, "Timestamp mismatch limit reached, turning CGI editor off. Reload the configuration file to re-enable it.");
          csp->config->feature_flags = csp->config->feature_flags & ~1U;
        }
      }

    if((signed int)err == JB_ERR_OK)
      err = (enum privoxy_err)JB_ERR_FILE;

    return err;
  }

  else
  {
    err=edit_parse_actions_file(file);
    if(!(err == /*enum*/JB_ERR_OK))
    {
      if((signed int)err == JB_ERR_PARSE)
      {
        err=cgi_error_parse(csp, rsp, file);
        if((signed int)err == JB_ERR_OK)
          err = (enum privoxy_err)JB_ERR_FILE;

      }

      edit_free_file(file);
      return err;
    }

    else
    {
      *pfile = file;
      return (enum privoxy_err)JB_ERR_OK;
    }
  }
}

// edit_read_file
// file cgiedit.c line 1481
enum privoxy_err edit_read_file(struct client_state *csp, struct map *parameters, signed int require_version, struct editable_file **pfile)
{
  struct file_line *lines;
  struct _IO_FILE *fp;
  enum privoxy_err err;
  const char *filename = (const char *)(void *)0;
  struct editable_file *file;
  unsigned int version = (unsigned int)0;
  struct stat statbuf[1l];
  char version_buf[22l];
  signed int newline = 0;
  unsigned int i;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  /* assertion pfile */
  assert(pfile != ((struct editable_file **)NULL));
  *pfile = (struct editable_file *)(void *)0;
  err=get_number_param(csp, parameters, "f", &i);
  _Bool tmp_if_expr_1;
  if((signed int)err == JB_ERR_OK && !(i >= 30u))
    tmp_if_expr_1 = (const char *)(void *)0 != csp->config->actions_file[(signed long int)i] ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    filename = csp->config->actions_file[(signed long int)i];

  else
    if((signed int)err == JB_ERR_CGI_PARAMS)
      get_file_name_param(csp, parameters, "f", &filename);

  _Bool tmp_if_expr_3;
  signed int return_value_stat_2;
  if(filename == ((const char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_stat_2=stat(filename, statbuf);
    tmp_if_expr_3 = return_value_stat_2 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
    return (enum privoxy_err)JB_ERR_FILE;

  else
  {
    version = (unsigned int)statbuf[0l].st_mtim.tv_sec;
    if(!(require_version == 0))
    {
      unsigned int specified_version;
      err=get_number_param(csp, parameters, "v", &specified_version);
      if(!(err == /*enum*/JB_ERR_OK))
        return err;

      if(!(version == specified_version))
        return (enum privoxy_err)JB_ERR_MODIFIED;

    }

    fp=fopen(filename, "rb");
    if(fp == ((struct _IO_FILE *)NULL))
      return (enum privoxy_err)JB_ERR_FILE;

    else
    {
      err=edit_read_file_lines(fp, &lines, &newline);
      fclose(fp);
      if(!(err == /*enum*/JB_ERR_OK))
        return err;

      else
      {
        void *return_value_zalloc_4;
        return_value_zalloc_4=zalloc(sizeof(struct editable_file) /*56ul*/ );
        file = (struct editable_file *)return_value_zalloc_4;
        if(file == ((struct editable_file *)NULL))
        {
          edit_free_file_lines(lines);
          return err;
        }

        else
        {
          file->lines = lines;
          file->newline = newline;
          file->filename = filename;
          file->version = version;
          file->identifier = i;
          if(!(file->version_str == ((const char *)NULL)))
          {
            free((void *)file->version_str);
            file->version_str = (const char *)(void *)0;
          }

          snprintf(version_buf, sizeof(char [22l]) /*22ul*/ , "%u", file->version);
          version_buf[(signed long int)(sizeof(char [22l]) /*22ul*/  - (unsigned long int)1)] = (char)0;
          file->version_str=strdup_or_die(version_buf);
          *pfile = file;
          return (enum privoxy_err)JB_ERR_OK;
        }
      }
    }
  }
}

// edit_read_file_lines
// file cgiedit.c line 1385
static enum privoxy_err edit_read_file_lines(struct _IO_FILE *fp, struct file_line **pfile, signed int *newline)
{
  struct file_line *first_line;
  struct file_line *cur_line;
  struct file_line *prev_line;
  enum privoxy_err rval;
  /* assertion fp */
  assert(fp != ((struct _IO_FILE *)NULL));
  /* assertion pfile */
  assert(pfile != ((struct file_line **)NULL));
  *pfile = (struct file_line *)(void *)0;
  void *return_value_zalloc_1;
  return_value_zalloc_1=zalloc(sizeof(struct file_line) /*464ul*/ );
  first_line = (struct file_line *)return_value_zalloc_1;
  cur_line = first_line;
  if(cur_line == ((struct file_line *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    cur_line->type = 1;
    rval=edit_read_line(fp, &cur_line->raw, &cur_line->prefix, &cur_line->unprocessed, newline, (unsigned long int *)(void *)0);
    if(!(rval == /*enum*/JB_ERR_OK))
    {
      free((void *)cur_line);
      return (enum privoxy_err)((signed int)rval == JB_ERR_FILE ? JB_ERR_OK : (signed int)rval);
    }

    else
    {
      do
      {
        prev_line = cur_line;
        void *return_value_zalloc_2;
        return_value_zalloc_2=zalloc(sizeof(struct file_line) /*464ul*/ );
        prev_line->next = (struct file_line *)return_value_zalloc_2;
        cur_line = prev_line->next;
        if(cur_line == ((struct file_line *)NULL))
        {
          edit_free_file_lines(first_line);
          return (enum privoxy_err)JB_ERR_MEMORY;
        }

        cur_line->type = 1;
        rval=edit_read_line(fp, &cur_line->raw, &cur_line->prefix, &cur_line->unprocessed, newline, (unsigned long int *)(void *)0);
        if(!((signed int)rval == JB_ERR_OK) && !((signed int)rval == JB_ERR_FILE))
        {
          edit_free_file_lines(first_line);
          return (enum privoxy_err)JB_ERR_MEMORY;
        }

      }
      while(!((signed int)rval == JB_ERR_FILE));
      prev_line->next = (struct file_line *)(void *)0;
      free((void *)cur_line);
      *pfile = first_line;
      return (enum privoxy_err)JB_ERR_OK;
    }
  }
}

// edit_read_line
// file loaders.h line 47
extern enum privoxy_err edit_read_line(struct _IO_FILE *fp, char **raw_out, char **prefix_out, char **data_out, signed int *newline, unsigned long int *line_number)
{
  char *p;
  char *linebuf;
  char *linestart;
  signed int contflag = 0;
  signed int is_empty = 1;
  char *raw = (char *)(void *)0;
  char *prefix = (char *)(void *)0;
  char *data = (char *)(void *)0;
  signed int scrapnewline;
  enum privoxy_err rval = (enum privoxy_err)JB_ERR_OK;
  /* assertion fp */
  assert(fp != ((struct _IO_FILE *)NULL));
  /* assertion raw_out || data_out */
  assert(raw_out != ((char **)NULL) || data_out != ((char **)NULL));
  _Bool tmp_if_expr_1;
  if(newline == ((signed int *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = *newline == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = *newline == 1 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = *newline == 2 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = *newline == 3 ? (_Bool)1 : (_Bool)0;
  /* assertion newline == ((void *)0) || *newline == 0 || *newline == 1 || *newline == 2 || *newline == 3 */
  assert(tmp_if_expr_4);
  if(newline == ((signed int *)NULL))
  {
    scrapnewline = 0;
    newline = &scrapnewline;
  }

  if(!(raw_out == ((char **)NULL)))
    *raw_out = (char *)(void *)0;

  if(!(prefix_out == ((char **)NULL)))
    *prefix_out = (char *)(void *)0;

  if(!(data_out == ((char **)NULL)))
    *data_out = (char *)(void *)0;

  char *tmp_if_expr_5;
  _Bool tmp_if_expr_8;
  const unsigned short int **return_value___ctype_b_loc_9;
  _Bool tmp_if_expr_12;
  char *tmp_if_expr_10;
  signed int tmp_if_expr_14;
  if(!(raw_out == ((char **)NULL)))
  {
    raw=strdup("");
    if(!(raw == ((char *)NULL)))
      goto __CPROVER_DUMP_L13;

    return (enum privoxy_err)JB_ERR_MEMORY;
  }

  else
  {

  __CPROVER_DUMP_L13:
    ;
    if(!(prefix_out == ((char **)NULL)))
    {
      prefix=strdup("");
      if(!(prefix == ((char *)NULL)))
        goto __CPROVER_DUMP_L15;

      if(!(raw == ((char *)NULL)))
      {
        free((void *)raw);
        raw = (char *)(void *)0;
      }

      return (enum privoxy_err)JB_ERR_MEMORY;
    }

    else
    {

    __CPROVER_DUMP_L15:
      ;
      if(!(data_out == ((char **)NULL)))
      {
        data=strdup("");
        if(!(data == ((char *)NULL)))
          goto __CPROVER_DUMP_L18;

        if(!(raw == ((char *)NULL)))
        {
          free((void *)raw);
          raw = (char *)(void *)0;
        }

        if(!(prefix == ((char *)NULL)))
        {
          free((void *)prefix);
          prefix = (char *)(void *)0;
        }

        return (enum privoxy_err)JB_ERR_MEMORY;
      }

      else
      {

      __CPROVER_DUMP_L18:
        ;
        while(!(contflag == 0) || !(is_empty == 0))
        {
          rval=simple_read_line(fp, &linebuf, newline);
          if(!((signed int)rval == JB_ERR_OK))
            break;

          if(!(line_number == ((unsigned long int *)NULL)))
            *line_number = *line_number + 1ul;

          if(!(raw == ((char *)NULL)))
          {
            string_append(&raw, linebuf);
            if(*newline == 2)
              tmp_if_expr_5 = "\r\n";

            else
              tmp_if_expr_5 = *newline == 3 ? "\r" : "\n";
            enum privoxy_err return_value_string_append_6;
            return_value_string_append_6=string_append(&raw, tmp_if_expr_5);
            if(!(return_value_string_append_6 == /*enum*/JB_ERR_OK))
            {
              if(!(prefix == ((char *)NULL)))
              {
                free((void *)prefix);
                prefix = (char *)(void *)0;
              }

              if(!(data == ((char *)NULL)))
              {
                free((void *)data);
                data = (char *)(void *)0;
              }

              free((void *)linebuf);
              return (enum privoxy_err)JB_ERR_MEMORY;
            }

          }

          unsigned long int return_value_strlen_7;
          return_value_strlen_7=strlen(linebuf);
          p = (linebuf + (signed long int)return_value_strlen_7) - (signed long int)1;
          if(!((signed int)*linebuf == 0))
            tmp_if_expr_8 = (signed int)*p == 92 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_8 = (_Bool)0;
          contflag = (signed int)tmp_if_expr_8;
          if(!(contflag == 0))
            *p = (char)0;

          linestart = linebuf;
          /* assertion ((void *)0) != data */
          assert((char *)(void *)0 != data);
          if((signed int)*data == 0)
            for( ; !(*linestart == 0); linestart = linestart + 1l)
            {
              return_value___ctype_b_loc_9=__ctype_b_loc();
              if((8192 & (signed int)(*return_value___ctype_b_loc_9)[(signed long int)(signed int)(unsigned char)*linestart]) == 0)
                break;

            }

          p = linestart;
          do
          {
            p=strchr(p, 35);
            if(p == ((char *)NULL))
              break;

            if(!(p == linebuf))
              tmp_if_expr_12 = (signed int)*(p - (signed long int)1) == 92 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_12 = (_Bool)0;
            if(tmp_if_expr_12)
            {
              char *q = p - (signed long int)1;
              do
              {
                *q = q[(signed long int)1];
                if((signed int)*q == 0)
                  break;

                q = q + 1l;
              }
              while((_Bool)1);
            }

            else
            {
              if(p == linestart)
              {
                linestart = linebuf;
                p = linestart;
              }

              if(!(prefix == ((char *)NULL)))
              {
                string_append(&prefix, p);
                if(*newline == 2)
                  tmp_if_expr_10 = "\r\n";

                else
                  tmp_if_expr_10 = *newline == 3 ? "\r" : "\n";
                enum privoxy_err return_value_string_append_11;
                return_value_string_append_11=string_append(&prefix, tmp_if_expr_10);
                if(!(return_value_string_append_11 == /*enum*/JB_ERR_OK))
                {
                  if(!(raw == ((char *)NULL)))
                  {
                    free((void *)raw);
                    raw = (char *)(void *)0;
                  }

                  if(!(data == ((char *)NULL)))
                  {
                    free((void *)data);
                    data = (char *)(void *)0;
                  }

                  free((void *)linebuf);
                  return (enum privoxy_err)JB_ERR_MEMORY;
                }

              }

              *p = (char)0;
            }
          }
          while((_Bool)1);
          if(!(*linestart == 0))
          {
            is_empty = 0;
            if(!(data == ((char *)NULL)))
            {
              enum privoxy_err return_value_string_append_13;
              return_value_string_append_13=string_append(&data, linestart);
              if(!(return_value_string_append_13 == /*enum*/JB_ERR_OK))
              {
                if(!(raw == ((char *)NULL)))
                {
                  free((void *)raw);
                  raw = (char *)(void *)0;
                }

                if(!(prefix == ((char *)NULL)))
                {
                  free((void *)prefix);
                  prefix = (char *)(void *)0;
                }

                free((void *)linebuf);
                return (enum privoxy_err)JB_ERR_MEMORY;
              }

            }

          }

          free((void *)linebuf);
        }
        if(!((signed int)rval == JB_ERR_OK) && !((signed int)rval == JB_ERR_FILE))
        {
          if(!(raw == ((char *)NULL)))
          {
            free((void *)raw);
            raw = (char *)(void *)0;
          }

          if(!(prefix == ((char *)NULL)))
          {
            free((void *)prefix);
            prefix = (char *)(void *)0;
          }

          if(!(data == ((char *)NULL)))
          {
            free((void *)data);
            data = (char *)(void *)0;
          }

          return rval;
        }

        else
        {
          if(!(raw == ((char *)NULL)))
            tmp_if_expr_14 = (signed int)((signed int)*raw == 0);

          else
            tmp_if_expr_14 = is_empty;
          if(!(tmp_if_expr_14 == 0))
          {
            if(!(raw == ((char *)NULL)))
            {
              free((void *)raw);
              raw = (char *)(void *)0;
            }

            if(!(prefix == ((char *)NULL)))
            {
              free((void *)prefix);
              prefix = (char *)(void *)0;
            }

            if(!(data == ((char *)NULL)))
            {
              free((void *)data);
              data = (char *)(void *)0;
            }

            return (enum privoxy_err)JB_ERR_FILE;
          }

          else
          {
            chomp(data);
            if(!(raw_out == ((char **)NULL)))
              *raw_out = raw;

            else
              if(!(raw == ((char *)NULL)))
              {
                free((void *)raw);
                raw = (char *)(void *)0;
              }

            if(!(prefix_out == ((char **)NULL)))
              *prefix_out = prefix;

            else
              if(!(prefix == ((char *)NULL)))
              {
                free((void *)prefix);
                prefix = (char *)(void *)0;
              }

            if(!(data_out == ((char **)NULL)))
              *data_out = data;

            else
              if(!(data == ((char *)NULL)))
              {
                free((void *)data);
                data = (char *)(void *)0;
              }

            return (enum privoxy_err)JB_ERR_OK;
          }
        }
      }
    }
  }
}

// edit_write_file
// file cgiedit.c line 701
enum privoxy_err edit_write_file(struct editable_file *file)
{
  struct _IO_FILE *fp;
  struct file_line *cur_line;
  struct stat statbuf[1l];
  char version_buf[22l];
  /* assertion file */
  assert(file != ((struct editable_file *)NULL));
  /* assertion file->filename */
  assert(file->filename != ((const char *)NULL));
  fp=fopen(file->filename, "wb");
  char *tmp_post_5;
  char *tmp_post_6;
  char *tmp_post_7;
  char *tmp_if_expr_13;
  if(fp == ((struct _IO_FILE *)NULL))
    return (enum privoxy_err)JB_ERR_FILE;

  else
  {
    cur_line = file->lines;
    for( ; !(cur_line == ((struct file_line *)NULL)); cur_line = cur_line->next)
      if(!(cur_line->raw == ((char *)NULL)))
      {
        signed int return_value_fputs_1;
        return_value_fputs_1=fputs(cur_line->raw, fp);
        if(!(return_value_fputs_1 >= 0))
        {
          fclose(fp);
          return (enum privoxy_err)JB_ERR_FILE;
        }

      }

      else
      {
        if(!(cur_line->prefix == ((char *)NULL)))
        {
          signed int return_value_fputs_2;
          return_value_fputs_2=fputs(cur_line->prefix, fp);
          if(!(return_value_fputs_2 >= 0))
          {
            fclose(fp);
            return (enum privoxy_err)JB_ERR_FILE;
          }

        }

        if(!(cur_line->unprocessed == ((char *)NULL)))
        {
          char *return_value_strchr_12;
          return_value_strchr_12=strchr(cur_line->unprocessed, 35);
          if(!(return_value_strchr_12 == ((char *)NULL)))
          {
            signed int numhash = 0;
            unsigned long int len;
            char *src;
            char *dest;
            char *str;
            src = cur_line->unprocessed;
            do
            {
              src=strchr(src, 35);
              if(src == ((char *)NULL))
                break;

              numhash = numhash + 1;
              src = src + 1l;
            }
            while((_Bool)1);
            /* assertion numhash > 0 */
            assert(numhash > 0);
            unsigned long int return_value_strlen_3;
            return_value_strlen_3=strlen(cur_line->unprocessed);
            len = return_value_strlen_3 + (unsigned long int)numhash;
            void *return_value_malloc_or_die_4;
            return_value_malloc_or_die_4=malloc_or_die(len + (unsigned long int)1);
            str = (char *)return_value_malloc_or_die_4;
            src = cur_line->unprocessed;
            dest = str;
            for( ; !(*src == 0); *tmp_post_6 = *tmp_post_7)
            {
              if((signed int)*src == 35)
              {
                tmp_post_5 = dest;
                dest = dest + 1l;
                *tmp_post_5 = (char)92;
                numhash = numhash - 1;
                /* assertion numhash >= 0 */
                assert(numhash >= 0);
              }

              tmp_post_6 = dest;
              dest = dest + 1l;
              tmp_post_7 = src;
              src = src + 1l;
            }
            *dest = (char)0;
            /* assertion numhash == 0 */
            assert(numhash == 0);
            unsigned long int return_value_strlen_8;
            return_value_strlen_8=strlen(str);
            /* assertion strlen(str) == len */
            assert(return_value_strlen_8 == len);
            /* assertion str == dest - len */
            assert(str == dest - (signed long int)len);
            /* assertion src - len <= cur_line->unprocessed */
            assert(src - (signed long int)len <= cur_line->unprocessed);
            unsigned long int return_value_strlen_9;
            return_value_strlen_9=strlen(str);
            if(!(numhash == 0) || !(return_value_strlen_9 == len))
              log_error(0x2000, "Looks like hash escaping failed. %s might be corrupted now.", file->filename);

            signed int return_value_fputs_10;
            return_value_fputs_10=fputs(str, fp);
            if(!(return_value_fputs_10 >= 0))
            {
              free((void *)str);
              fclose(fp);
              return (enum privoxy_err)JB_ERR_FILE;
            }

            free((void *)str);
          }

          else
          {
            signed int return_value_fputs_11;
            return_value_fputs_11=fputs(cur_line->unprocessed, fp);
            if(!(return_value_fputs_11 >= 0))
            {
              fclose(fp);
              return (enum privoxy_err)JB_ERR_FILE;
            }

          }
          if(file->newline == 2)
            tmp_if_expr_13 = "\r\n";

          else
            tmp_if_expr_13 = file->newline == 3 ? "\r" : "\n";
          signed int return_value_fputs_14;
          return_value_fputs_14=fputs(tmp_if_expr_13, fp);
          if(!(return_value_fputs_14 >= 0))
          {
            fclose(fp);
            return (enum privoxy_err)JB_ERR_FILE;
          }

        }

        else
          /* assertion 0 */
          assert(0 != 0);
      }
    fclose(fp);
    signed int return_value_stat_15;
    return_value_stat_15=stat(file->filename, statbuf);
    if(!(return_value_stat_15 >= 0))
      return (enum privoxy_err)JB_ERR_FILE;

    else
    {
      file->version = (unsigned int)statbuf[0l].st_mtim.tv_sec;
      if(!(file->version_str == ((const char *)NULL)))
      {
        free((void *)file->version_str);
        file->version_str = (const char *)(void *)0;
      }

      snprintf(version_buf, sizeof(char [22l]) /*22ul*/ , "%u", file->version);
      version_buf[(signed long int)(sizeof(char [22l]) /*22ul*/  - (unsigned long int)1)] = (char)0;
      file->version_str=strdup_or_die(version_buf);
      return (enum privoxy_err)JB_ERR_OK;
    }
  }
}

// enforce_header_order
// file parsers.c line 1042
static void enforce_header_order(struct list *headers, struct list *ordered_headers)
{
  struct list_entry *sorted_header;
  struct list new_headers[1l];
  struct list_entry *header;
  init_list(new_headers);
  /* assertion ((void *)0) != headers->first->str */
  assert((char *)(void *)0 != headers->first->str);
  enlist(new_headers, headers->first->str);
  if(!(headers->first->str == ((char *)NULL)))
  {
    free((void *)headers->first->str);
    headers->first->str = (char *)(void *)0;
  }

  sorted_header = ordered_headers->first;
  for( ; !(sorted_header == ((struct list_entry *)NULL)); sorted_header = sorted_header->next)
  {
    unsigned long int sorted_header_length;
    sorted_header_length=strlen(sorted_header->str);
    header = headers->first;
    for( ; !(header == ((struct list_entry *)NULL)); header = header->next)
      if(!(header->str == ((char *)NULL)))
      {
        signed int return_value_strncmpic_2;
        return_value_strncmpic_2=strncmpic(sorted_header->str, header->str, sorted_header_length);
        if(return_value_strncmpic_2 == 0)
        {
          if((signed int)header->str[(signed long int)sorted_header_length] == 58)
          {
            log_error(0x0008, "Enlisting sorted header %s", header->str);
            enum privoxy_err return_value_enlist_1;
            return_value_enlist_1=enlist(new_headers, header->str);
            if(!((signed int)return_value_enlist_1 == JB_ERR_OK))
              log_error(0x0008, "Failed to enlist %s", header->str);

            if(!(header->str == ((char *)NULL)))
            {
              free((void *)header->str);
              header->str = (char *)(void *)0;
            }

          }

        }

      }

  }
  header = headers->first;
  for( ; !(header == ((struct list_entry *)NULL)); header = header->next)
    if(!(header->str == ((char *)NULL)))
    {
      log_error(0x0008, "Enlisting left-over header %s", header->str);
      enum privoxy_err return_value_enlist_3;
      return_value_enlist_3=enlist(new_headers, header->str);
      if(!((signed int)return_value_enlist_3 == JB_ERR_OK))
        log_error(0x0008, "Failed to enlist %s", header->str);

      if(!(header->str == ((char *)NULL)))
      {
        free((void *)header->str);
        header->str = (char *)(void *)0;
      }

    }

  list_remove_all(headers);
  list_duplicate(headers, new_headers);
  list_remove_all(new_headers);
  goto __CPROVER_DUMP_L15;

__CPROVER_DUMP_L15:
  ;
}

// enlist
// file list.h line 51
extern enum privoxy_err enlist(struct list *the_list, const char *str)
{
  struct list_entry *cur;
  /* assertion the_list */
  assert(the_list != ((struct list *)NULL));
  signed int return_value_list_is_valid_1;
  return_value_list_is_valid_1=list_is_valid(the_list);
  /* assertion list_is_valid(the_list) */
  assert(return_value_list_is_valid_1 != 0);
  void *return_value_zalloc_2;
  return_value_zalloc_2=zalloc(sizeof(struct list_entry) /*16ul*/ );
  cur = (struct list_entry *)return_value_zalloc_2;
  if(cur == ((struct list_entry *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
    if(!(str == ((const char *)NULL)))
    {
      cur->str=strdup(str);
      if(!(cur->str == ((char *)NULL)))
        goto __CPROVER_DUMP_L2;

      free((void *)cur);
      return (enum privoxy_err)JB_ERR_MEMORY;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(!(the_list->last == ((struct list_entry *)NULL)))
      {
        the_list->last->next = cur;
        the_list->last = cur;
      }

      else
      {
        the_list->first = cur;
        the_list->last = cur;
      }
      signed int return_value_list_is_valid_3;
      return_value_list_is_valid_3=list_is_valid(the_list);
      /* assertion list_is_valid(the_list) */
      assert(return_value_list_is_valid_3 != 0);
      return (enum privoxy_err)JB_ERR_OK;
    }
}

// enlist_first
// file list.h line 54
extern enum privoxy_err enlist_first(struct list *the_list, const char *str)
{
  struct list_entry *cur;
  /* assertion the_list */
  assert(the_list != ((struct list *)NULL));
  signed int return_value_list_is_valid_1;
  return_value_list_is_valid_1=list_is_valid(the_list);
  /* assertion list_is_valid(the_list) */
  assert(return_value_list_is_valid_1 != 0);
  void *return_value_zalloc_2;
  return_value_zalloc_2=zalloc(sizeof(struct list_entry) /*16ul*/ );
  cur = (struct list_entry *)return_value_zalloc_2;
  if(cur == ((struct list_entry *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
    if(!(str == ((const char *)NULL)))
    {
      cur->str=strdup(str);
      if(!(cur->str == ((char *)NULL)))
        goto __CPROVER_DUMP_L2;

      free((void *)cur);
      return (enum privoxy_err)JB_ERR_MEMORY;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      cur->next = the_list->first;
      the_list->first = cur;
      if(the_list->last == ((struct list_entry *)NULL))
        the_list->last = cur;

      signed int return_value_list_is_valid_3;
      return_value_list_is_valid_3=list_is_valid(the_list);
      /* assertion list_is_valid(the_list) */
      assert(return_value_list_is_valid_3 != 0);
      return (enum privoxy_err)JB_ERR_OK;
    }
}

// enlist_unique
// file list.h line 52
extern enum privoxy_err enlist_unique(struct list *the_list, const char *str, unsigned long int num_significant_chars)
{
  struct list_entry *cur_entry;
  /* assertion the_list */
  assert(the_list != ((struct list *)NULL));
  signed int return_value_list_is_valid_1;
  return_value_list_is_valid_1=list_is_valid(the_list);
  /* assertion list_is_valid(the_list) */
  assert(return_value_list_is_valid_1 != 0);
  /* assertion str */
  assert(str != ((const char *)NULL));
  /* assertion num_significant_chars >= 0 */
  assert(num_significant_chars >= (unsigned long int)0);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(str);
  /* assertion num_significant_chars <= strlen(str) */
  assert(num_significant_chars <= return_value_strlen_2);
  signed int return_value_strncmp_3;
  signed int return_value_strcmp_4;
  if(num_significant_chars >= 1ul)
  {
    cur_entry = the_list->first;
    for( ; !(cur_entry == ((struct list_entry *)NULL)); cur_entry = cur_entry->next)
      if(!(cur_entry->str == ((char *)NULL)))
      {
        return_value_strncmp_3=strncmp(str, cur_entry->str, num_significant_chars);
        if(return_value_strncmp_3 == 0)
          return (enum privoxy_err)JB_ERR_OK;

      }

  }

  else
  {
    cur_entry = the_list->first;
    for( ; !(cur_entry == ((struct list_entry *)NULL)); cur_entry = cur_entry->next)
      if(!(cur_entry->str == ((char *)NULL)))
      {
        return_value_strcmp_4=strcmp(str, cur_entry->str);
        if(return_value_strcmp_4 == 0)
          return (enum privoxy_err)JB_ERR_OK;

      }

  }
  enum privoxy_err return_value_enlist_5;
  return_value_enlist_5=enlist(the_list, str);
  return return_value_enlist_5;
}

// enlist_unique_header
// file list.h line 53
extern enum privoxy_err enlist_unique_header(struct list *the_list, const char *name, const char *value)
{
  enum privoxy_err result = (enum privoxy_err)JB_ERR_MEMORY;
  char *header;
  unsigned long int header_size;
  /* assertion the_list */
  assert(the_list != ((struct list *)NULL));
  signed int return_value_list_is_valid_1;
  return_value_list_is_valid_1=list_is_valid(the_list);
  /* assertion list_is_valid(the_list) */
  assert(return_value_list_is_valid_1 != 0);
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion value */
  assert(value != ((const char *)NULL));
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(name);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(value);
  header_size = return_value_strlen_2 + (unsigned long int)2 + return_value_strlen_3 + (unsigned long int)1;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(header_size);
  header = (char *)return_value_malloc_4;
  _Bool tmp_if_expr_7;
  char *tmp_post_6;
  if(!(header == ((char *)NULL)))
  {
    unsigned long int bytes_to_compare;
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen(name);
    bytes_to_compare = return_value_strlen_5 + (unsigned long int)2;
    char *p = header;
    snprintf(header, header_size, "%s: %s", name, value);
    do
    {
      if((signed int)*p == 13)
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = (signed int)*p == 10 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_7)
      {
        /* assertion *p != '\r' */
        assert((signed int)*p != 13);
        /* assertion *p != '\n' */
        assert((signed int)*p != 10);
        *p = (char)0;
      }

      tmp_post_6 = p;
      p = p + 1l;
    }
    while(!(*tmp_post_6 == 0));
    result=enlist_unique(the_list, header, bytes_to_compare);
    free((void *)header);
    signed int return_value_list_is_valid_8;
    return_value_list_is_valid_8=list_is_valid(the_list);
    /* assertion list_is_valid(the_list) */
    assert(return_value_list_is_valid_8 != 0);
  }

  return result;
}

// error_response
// file cgi.c line 876
extern struct http_response * error_response(struct client_state *csp, const char *templatename)
{
  enum privoxy_err err;
  struct http_response *rsp;
  struct map *exports;
  exports=default_exports(csp, (const char *)(void *)0);
  char *path = (char *)(void *)0;
  if(exports == ((struct map *)NULL))
  {
    struct http_response *return_value_cgi_error_memory_1;
    return_value_cgi_error_memory_1=cgi_error_memory();
    return return_value_cgi_error_memory_1;
  }

  rsp=alloc_http_response();
  if(rsp == ((struct http_response *)NULL))
  {
    free_map(exports);
    struct http_response *return_value_cgi_error_memory_2;
    return_value_cgi_error_memory_2=cgi_error_memory();
    return return_value_cgi_error_memory_2;
  }

  if(!((0x04U & csp->flags) == 0u))
    path=strdup("/PRIVOXY-FORCE");

  else
    path=strdup("");
  err=string_append(&path, csp->http[0l].path);
  char *return_value_html_encode_3;
  if(err == /*enum*/JB_ERR_OK)
  {
    return_value_html_encode_3=html_encode(csp->http[0l].host);
    err=map(exports, "host", 1, return_value_html_encode_3, 0);
  }

  char *return_value_html_encode_4;
  if(err == /*enum*/JB_ERR_OK)
  {
    return_value_html_encode_4=html_encode(csp->http[0l].hostport);
    err=map(exports, "hostport", 1, return_value_html_encode_4, 0);
  }

  char *return_value_html_encode_and_free_original_5;
  if(err == /*enum*/JB_ERR_OK)
  {
    return_value_html_encode_and_free_original_5=html_encode_and_free_original(path);
    err=map(exports, "path", 1, return_value_html_encode_and_free_original_5, 0);
  }

  if(err == /*enum*/JB_ERR_OK)
    err=map(exports, "protocol", 1, csp->http[0l].ssl != 0 ? "https://" : "http://", 1);

  if(err == /*enum*/JB_ERR_OK)
  {
    char *return_value_html_encode_6;
    return_value_html_encode_6=html_encode(csp->http[0l].host_ip_addr_str);
    err=map(exports, "host-ip", 1, return_value_html_encode_6, 0);
    if(!(err == /*enum*/JB_ERR_OK))
    {
      char *return_value_html_encode_7;
      return_value_html_encode_7=html_encode(csp->http[0l].host);
      err=map(exports, "host-ip", 1, return_value_html_encode_7, 0);
    }

  }

  if(!(err == /*enum*/JB_ERR_OK))
  {
    free_map(exports);
    free_http_response(rsp);
    struct http_response *return_value_cgi_error_memory_8;
    return_value_cgi_error_memory_8=cgi_error_memory();
    return return_value_cgi_error_memory_8;
  }

  signed int return_value_strcmp_15;
  return_value_strcmp_15=strcmp(templatename, "no-such-domain");
  signed int return_value_strcmp_14;
  char *return_value_html_encode_9;
  signed int return_value_strcmp_13;
  signed int return_value_strcmp_12;
  signed int return_value_strcmp_11;
  if(return_value_strcmp_15 == 0)
  {
    rsp->status=strdup("404 No such domain");
    rsp->crunch_reason = (enum crunch_reason)NO_SUCH_DOMAIN;
  }

  else
  {
    return_value_strcmp_14=strcmp(templatename, "forwarding-failed");
    if(return_value_strcmp_14 == 0)
    {
      struct forward_spec *fwd;
      fwd=forward_url(csp, csp->http);
      char *socks_type = (char *)(void *)0;
      if(fwd == ((struct forward_spec *)NULL))
        log_error(0x4000, "gateway spec is NULL. This shouldn't happen!");

      /* assertion fwd != ((void *)0) */
      assert(fwd != (struct forward_spec *)(void *)0);
      /* assertion fwd->type != SOCKS_NONE */
      assert((signed int)fwd->type != SOCKS_NONE);
      if(csp->error_message == ((char *)NULL))
      {
        log_error(0x2000, "Socks failure reason missing.");
        csp->error_message=strdup("Failure reason missing. Check the log file for details.");
      }

      if(err == /*enum*/JB_ERR_OK)
        err=map(exports, "gateway", 1, fwd->gateway_host, 1);

      switch((signed int)fwd->type)
      {
        case SOCKS_4:
        {
          socks_type = "socks4-";
          break;
        }
        case SOCKS_4A:
        {
          socks_type = "socks4a-";
          break;
        }
        case SOCKS_5:
        {
          socks_type = "socks5-";
          break;
        }
        case SOCKS_5T:
        {
          socks_type = "socks5t-";
          break;
        }
        default:
          log_error(0x4000, "Unknown socks type: %d.", fwd->type);
      }
      if(err == /*enum*/JB_ERR_OK)
        err=map(exports, "forwarding-type", 1, socks_type, 1);

      if(err == /*enum*/JB_ERR_OK)
      {
        return_value_html_encode_9=html_encode(csp->error_message);
        err=map(exports, "error-message", 1, return_value_html_encode_9, 0);
      }

      if(csp->error_message == ((char *)NULL) || !(err == /*enum*/JB_ERR_OK))
      {
        free_map(exports);
        free_http_response(rsp);
        struct http_response *return_value_cgi_error_memory_10;
        return_value_cgi_error_memory_10=cgi_error_memory();
        return return_value_cgi_error_memory_10;
      }

      rsp->status=strdup("503 Forwarding failure");
      rsp->crunch_reason = (enum crunch_reason)FORWARDING_FAILED;
    }

    else
    {
      return_value_strcmp_13=strcmp(templatename, "connect-failed");
      if(return_value_strcmp_13 == 0)
      {
        rsp->status=strdup("503 Connect failed");
        rsp->crunch_reason = (enum crunch_reason)CONNECT_FAILED;
      }

      else
      {
        return_value_strcmp_12=strcmp(templatename, "connection-timeout");
        if(return_value_strcmp_12 == 0)
        {
          rsp->status=strdup("504 Connection timeout");
          rsp->crunch_reason = (enum crunch_reason)CONNECTION_TIMEOUT;
        }

        else
        {
          return_value_strcmp_11=strcmp(templatename, "no-server-data");
          if(return_value_strcmp_11 == 0)
          {
            rsp->status=strdup("502 No data received from server or forwarder");
            rsp->crunch_reason = (enum crunch_reason)NO_SERVER_DATA;
          }

        }
      }
    }
  }
  if(rsp->status == ((char *)NULL))
  {
    free_map(exports);
    free_http_response(rsp);
    struct http_response *return_value_cgi_error_memory_16;
    return_value_cgi_error_memory_16=cgi_error_memory();
    return return_value_cgi_error_memory_16;
  }

  err=template_fill_for_cgi(csp, templatename, exports, rsp);
  if(!(err == /*enum*/JB_ERR_OK))
  {
    free_http_response(rsp);
    struct http_response *return_value_cgi_error_memory_17;
    return_value_cgi_error_memory_17=cgi_error_memory();
    return return_value_cgi_error_memory_17;
  }

  struct http_response *return_value_finish_http_response_18;
  return_value_finish_http_response_18=finish_http_response(csp, rsp);
  return return_value_finish_http_response_18;
}

// execute_content_filters
// file filters.c line 2230
extern char * execute_content_filters(struct client_state *csp)
{
  char *content;
  char * (*content_filter)();
  signed int return_value_content_filters_enabled_1;
  return_value_content_filters_enabled_1=content_filters_enabled(csp->action);
  /* assertion content_filters_enabled(csp->action) */
  assert(return_value_content_filters_enabled_1 != 0);
  char *tmp_if_expr_3;
  char *return_value;
  signed int return_value_list_is_empty_4;
  if(csp->iob[0l].eod - csp->iob[0l].cur == 0l)
    return (char *)(void *)0;

  else
  {
    enum privoxy_err return_value_prepare_for_filtering_2;
    return_value_prepare_for_filtering_2=prepare_for_filtering(csp);
    if(!((signed int)return_value_prepare_for_filtering_2 == JB_ERR_OK))
      return (char *)(void *)0;

    else
      if(csp->iob[0l].eod - csp->iob[0l].cur == 0l)
        return (char *)(void *)0;

      else
      {
        content_filter=get_filter_function(csp);
        if(!(content_filter == ((char * (*)())NULL)))
        {
          return_value=content_filter(csp);
          tmp_if_expr_3 = return_value;
        }

        else
          tmp_if_expr_3 = (char *)(void *)0;
        content = tmp_if_expr_3;
        if(!((0x0001U & csp->content_type) == 0u))
        {
          return_value_list_is_empty_4=list_is_empty(csp->action[0l].multi[(signed long int)6]);
          if(return_value_list_is_empty_4 == 0)
          {
            struct list_entry *filtername;
            unsigned long int size = (unsigned long int)csp->content_length;
            if(content == ((char *)NULL))
            {
              content = csp->iob[0l].cur;
              size = (unsigned long int)(csp->iob[0l].eod - csp->iob[0l].cur);
            }

            filtername = csp->action[0l].multi[(signed long int)6][0l].first;
            for( ; !(filtername == ((struct list_entry *)NULL)); filtername = filtername->next)
            {
              char *result;
              result=execute_external_filter(csp, filtername->str, content, &size);
              if(!(result == ((char *)NULL)))
              {
                if(!(content == csp->iob[0l].cur))
                  free((void *)content);

                content = result;
              }

            }
            csp->flags = csp->flags | 0x08U;
            csp->content_length = size;
          }

        }

        return content;
      }
  }
}

// execute_external_filter
// file filters.c line 1794
static char * execute_external_filter(struct client_state *csp, const char *name, char *content, unsigned long int *size)
{
  char cmd[200l];
  char file_name[4096l];
  struct _IO_FILE *fp;
  char *filter_output;
  signed int fd;
  signed int ret;
  unsigned long int new_size;
  const char *external_filter;
  unsigned long int return_value_fwrite_2;
  signed int return_value_feof_5;
  signed int return_value_ferror_6;
  unsigned long int tmp_if_expr_7;
  if(csp->config->temporary_directory == ((const char *)NULL))
  {
    log_error(0x2000, "No temporary-directory configured. Can't execute filter: %s", name);
    return (char *)(void *)0;
  }

  else
  {
    external_filter=get_external_filter(csp, name);
    signed int return_value_snprintf_1;
    return_value_snprintf_1=snprintf(file_name, sizeof(char [4096l]) /*4096ul*/ , "%s/privoxy-XXXXXXXX", csp->config->temporary_directory);
    if((unsigned long int)return_value_snprintf_1 >= 4097ul)
    {
      log_error(0x2000, "temporary-directory path too long");
      return (char *)(void *)0;
    }

    else
    {
      fd=mkstemp(file_name);
      if(fd == -1)
      {
        log_error(0x2000, "mkstemp() failed to create %s: %E", (const void *)file_name);
        return (char *)(void *)0;
      }

      else
      {
        fp=fdopen(fd, "w");
        if(fp == ((struct _IO_FILE *)NULL))
        {
          log_error(0x2000, "fdopen() failed: %E");
          unlink(file_name);
          return (char *)(void *)0;
        }

        else
          if(!(*size == 0ul))
          {
            return_value_fwrite_2=fwrite((const void *)content, *size, (unsigned long int)1, fp);
            if(return_value_fwrite_2 == 1ul)
              goto __CPROVER_DUMP_L5;

            log_error(0x2000, "fwrite(..., %d, 1, ..) failed: %E", *size);
            unlink(file_name);
            fclose(fp);
            return (char *)(void *)0;
          }

          else
          {

          __CPROVER_DUMP_L5:
            ;
            fclose(fp);
            signed int return_value_snprintf_3;
            return_value_snprintf_3=snprintf(cmd, sizeof(char [200l]) /*200ul*/ , "%s < %s", external_filter, (const void *)file_name);
            if((unsigned long int)return_value_snprintf_3 >= 201ul)
            {
              log_error(0x2000, "temporary-directory or external filter path too long");
              unlink(file_name);
              return (char *)(void *)0;
            }

            else
            {
              log_error(0x0040, "Executing '%s': %s", name, (const void *)cmd);
              privoxy_mutex_lock(&external_filter_mutex);
              set_privoxy_variables(csp);
              fp=popen(cmd, "r");
              privoxy_mutex_unlock(&external_filter_mutex);
              if(fp == ((struct _IO_FILE *)NULL))
              {
                log_error(0x2000, "popen(\"%s\", \"r\") failed: %E", (const void *)cmd);
                unlink(file_name);
                return (char *)(void *)0;
              }

              else
              {
                void *return_value_malloc_or_die_4;
                return_value_malloc_or_die_4=malloc_or_die(*size + (unsigned long int)1);
                filter_output = (char *)return_value_malloc_or_die_4;
                new_size = (unsigned long int)0;
                do
                {
                  return_value_feof_5=feof(fp);
                  if(!(return_value_feof_5 == 0))
                    break;

                  return_value_ferror_6=ferror(fp);
                  if(!(return_value_ferror_6 == 0))
                    break;

                  unsigned long int len;
                  if(2048ul + new_size >= *size)
                  {
                    char *p;
                    if(*size >= 2048ul)
                      tmp_if_expr_7 = *size;

                    else
                      tmp_if_expr_7 = (unsigned long int)2048;
                    *size = *size + tmp_if_expr_7;
                    void *return_value_realloc_8;
                    return_value_realloc_8=realloc((void *)filter_output, *size);
                    p = (char *)return_value_realloc_8;
                    if(p == ((char *)NULL))
                    {
                      log_error(0x2000, "Out of memory while reading external filter output. Using what we got so far.");
                      break;
                    }

                    filter_output = p;
                  }

                  /* assertion new_size + READ_LENGTH < *size */
                  assert(new_size + (unsigned long int)2048 < *size);
                  len=fread((void *)&filter_output[(signed long int)new_size], (unsigned long int)1, (unsigned long int)2048, fp);
                  if(len >= 1ul)
                    new_size = new_size + len;

                }
                while((_Bool)1);
                ret=pclose(fp);
                if(ret == -1)
                  log_error(0x2000, "Executing %s failed: %E", (const void *)cmd);

                else
                  log_error(0x0040, "Executing '%s' resulted in return value %d. Read %d of up to %d bytes.", name, ret >> 8, new_size, *size);
                unlink(file_name);
                *size = new_size;
                return filter_output;
              }
            }
          }
      }
    }
  }
}

// fatal_error
// file errlog.c line 150
static void fatal_error(const char *error_message)
{
  if(!(logfp == ((struct _IO_FILE *)NULL)))
    fputs(error_message, logfp);

  if(!(pidfile == ((const char *)NULL)))
    unlink(pidfile);

  exit(1);
}

// file_has_been_modified
// file loaders.c line 1453
static signed int file_has_been_modified(const char *filename, signed long int last_know_modification)
{
  struct stat statbuf[1l];
  signed int return_value_stat_1;
  return_value_stat_1=stat(filename, statbuf);
  if(!(return_value_stat_1 >= 0))
    return 1;

  else
    return (signed int)(last_know_modification != statbuf[0l].st_mtim.tv_sec);
}

// filter_header
// file parsers.c line 1453
static enum privoxy_err filter_header(struct client_state *csp, char **header)
{
  signed int hits = 0;
  signed int matches;
  unsigned long int size;
  size=strlen(*header);
  char *newheader = (char *)(void *)0;
  struct PCRS_JOB *job;
  struct re_filterfile_spec *b;
  struct list_entry *filtername;
  enum filter_type wanted_filter_type;
  signed int multi_action_index;
  _Bool tmp_if_expr_3;
  signed int return_value_filters_available_2;
  if(!((0x00000400U & csp->flags) == 0u))
    return (enum privoxy_err)JB_ERR_OK;

  else
  {
    if(!((0x00000100U & csp->flags) == 0u))
    {
      wanted_filter_type = (enum filter_type)FT_SERVER_HEADER_FILTER;
      multi_action_index = 2;
    }

    else
    {
      wanted_filter_type = (enum filter_type)FT_CLIENT_HEADER_FILTER;
      multi_action_index = 3;
    }
    signed int return_value_list_is_empty_1;
    return_value_list_is_empty_1=list_is_empty(csp->action[0l].multi[(signed long int)multi_action_index]);
    if(!(return_value_list_is_empty_1 == 0))
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_filters_available_2=filters_available(csp);
      tmp_if_expr_3 = return_value_filters_available_2 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      return (enum privoxy_err)JB_ERR_OK;

    else
    {
      filtername = csp->action[0l].multi[(signed long int)multi_action_index][0l].first;
      for( ; !(filtername == ((struct list_entry *)NULL)); filtername = filtername->next)
      {
        signed int current_hits = 0;
        struct PCRS_JOB *joblist;
        b=get_filter(csp, filtername->str, wanted_filter_type);
        if(!(b == ((struct re_filterfile_spec *)NULL)))
        {
          joblist = b->joblist;
          if(!(b->dynamic == 0))
            joblist=compile_dynamic_pcrs_job_list(csp, b);

          if(joblist == ((struct PCRS_JOB *)NULL))
            log_error(0x0040, "Filter %s has empty joblist. Nothing to do.", b->name);

          else
          {
            log_error(0x0040, "filtering '%s' (size %d) with '%s' ...", *header, size, b->name);
            job = joblist;
            for( ; !(job == ((struct PCRS_JOB *)NULL)); job = job->next)
            {
              matches=pcrs_execute(job, *header, size, &newheader, &size);
              if(matches >= 1)
              {
                current_hits = current_hits + matches;
                log_error(0x0008, "Transforming \"%s\" to \"%s\"", *header, newheader);
                if(!(*header == ((char *)NULL)))
                {
                  free((void *)*header);
                  *header = (char *)(void *)0;
                }

                *header = newheader;
              }

              else
                if(matches == 0)
                {
                  if(!(newheader == ((char *)NULL)))
                  {
                    free((void *)newheader);
                    newheader = (char *)(void *)0;
                  }

                }

                else
                {
                  const char *return_value_pcrs_strerror_4;
                  return_value_pcrs_strerror_4=pcrs_strerror(matches);
                  log_error(0x2000, "Filtering '%s' with '%s' didn't work out: %s", *header, b->name, return_value_pcrs_strerror_4);
                  if(!(newheader == ((char *)NULL)))
                  {
                    log_error(0x2000, "Freeing what's left: %s", newheader);
                    if(!(newheader == ((char *)NULL)))
                    {
                      free((void *)newheader);
                      newheader = (char *)(void *)0;
                    }

                  }

                }
            }
            if(!(b->dynamic == 0))
              pcrs_free_joblist(joblist);

            log_error(0x0040, "... produced %d hits (new size %d).", current_hits, size);
            hits = hits + current_hits;
          }
        }

      }
      if(size == 0ul && !(hits == 0))
      {
        log_error(0x0008, "Removing empty header %s", *header);
        if(!(*header == ((char *)NULL)))
        {
          free((void *)*header);
          *header = (char *)(void *)0;
        }

      }

      return (enum privoxy_err)JB_ERR_OK;
    }
  }
}

// filters_available
// file filters.c line 2728
extern signed int filters_available(struct client_state *csp)
{
  signed int i = 0;
  for( ; !(i >= 30); i = i + 1)
  {
    struct file_list *fl = csp->rlist[(signed long int)i];
    if(!(fl == ((struct file_list *)NULL)))
    {
      if(!(fl->f == NULL))
        return 1;

    }

  }
  return 0;
}

// finish_http_response
// file cgi.c line 1575
extern struct http_response * finish_http_response(struct client_state *csp, struct http_response *rsp)
{
  char buf[5000l];
  enum privoxy_err err;
  char *tmp_if_expr_2;
  unsigned long int tmp_if_expr_4;
  unsigned long int return_value_strlen_3;
  signed int return_value_strncmpic_16;
  _Bool tmp_if_expr_9;
  signed int return_value_strncmpic_8;
  _Bool tmp_if_expr_11;
  signed int return_value_strncmpic_10;
  _Bool tmp_if_expr_13;
  signed int return_value_strncmpic_12;
  _Bool tmp_if_expr_15;
  signed int return_value_strncmpic_14;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_19;
  if(rsp == cgi_error_memory_response)
    return rsp;

  else
  {
    signed int return_value_strcmpic_1;
    return_value_strcmpic_1=strcmpic(csp->http[0l].ver, "HTTP/1.0");
    if(!(rsp->status == ((char *)NULL)))
      tmp_if_expr_2 = rsp->status;

    else
      tmp_if_expr_2 = "200 OK";
    snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , "%s %s", return_value_strcmpic_1 != 0 ? "HTTP/1.1" : "HTTP/1.0", tmp_if_expr_2);
    err=enlist_first(rsp->headers, buf);
    if(rsp->content_length == 0ul)
    {
      if(!(rsp->body == ((char *)NULL)))
      {
        return_value_strlen_3=strlen(rsp->body);
        tmp_if_expr_4 = return_value_strlen_3;
      }

      else
        tmp_if_expr_4 = (unsigned long int)0;
      rsp->content_length = tmp_if_expr_4;
    }

    if(err == /*enum*/JB_ERR_OK)
    {
      snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , "Content-Length: %d", (signed int)rsp->content_length);
      csp->flags = csp->flags | 0x00002000U;
      err=enlist(rsp->headers, buf);
    }

    signed int return_value_strcmpic_5;
    return_value_strcmpic_5=strcmpic(csp->http[0l].gpc, "head");
    if(return_value_strcmpic_5 == 0)
    {
      log_error(0x0800, "Preparing to give head to %s.", csp->ip_addr_str);
      if(!(rsp->body == ((char *)NULL)))
      {
        free((void *)rsp->body);
        rsp->body = (char *)(void *)0;
      }

      rsp->content_length = (unsigned long int)0;
    }

    signed int return_value_strncmpic_6;
    return_value_strncmpic_6=strncmpic(rsp->status, "302", (unsigned long int)3);
    if(!(return_value_strncmpic_6 == 0))
    {
      if(err == /*enum*/JB_ERR_OK)
        err=enlist_unique(rsp->headers, "Content-Type: text/html", (unsigned long int)13);

    }

    if(!(rsp->is_static == 0))
    {
      if(err == /*enum*/JB_ERR_OK)
      {
        get_http_time(0, buf, sizeof(char [5000l]) /*5000ul*/ );
        err=enlist_unique_header(rsp->headers, "Date", buf);
      }

      if(err == /*enum*/JB_ERR_OK)
        err=enlist_unique_header(rsp->headers, "Last-Modified", "Sat, 17 Jun 2000 12:00:00 GMT");

      if(err == /*enum*/JB_ERR_OK)
      {
        get_http_time(10 * 60, buf, sizeof(char [5000l]) /*5000ul*/ );
        err=enlist_unique_header(rsp->headers, "Expires", buf);
      }

    }

    else
    {
      return_value_strncmpic_16=strncmpic(rsp->status, "302", (unsigned long int)3);
      if(return_value_strncmpic_16 == 0)
      {
        get_http_time(0, buf, sizeof(char [5000l]) /*5000ul*/ );
        if(err == /*enum*/JB_ERR_OK)
          err=enlist_unique_header(rsp->headers, "Date", buf);

      }

      else
      {
        if(err == /*enum*/JB_ERR_OK)
          err=enlist_unique_header(rsp->headers, "Cache-Control", "no-cache");

        get_http_time(0, buf, sizeof(char [5000l]) /*5000ul*/ );
        if(err == /*enum*/JB_ERR_OK)
          err=enlist_unique_header(rsp->headers, "Date", buf);

        signed int return_value_strncmpic_7;
        return_value_strncmpic_7=strncmpic(rsp->status, "403", (unsigned long int)3);
        if(return_value_strncmpic_7 == 0)
          tmp_if_expr_9 = (_Bool)1;

        else
        {
          return_value_strncmpic_8=strncmpic(rsp->status, "404", (unsigned long int)3);
          tmp_if_expr_9 = !(return_value_strncmpic_8 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_9)
          tmp_if_expr_11 = (_Bool)1;

        else
        {
          return_value_strncmpic_10=strncmpic(rsp->status, "502", (unsigned long int)3);
          tmp_if_expr_11 = !(return_value_strncmpic_10 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_11)
          tmp_if_expr_13 = (_Bool)1;

        else
        {
          return_value_strncmpic_12=strncmpic(rsp->status, "503", (unsigned long int)3);
          tmp_if_expr_13 = !(return_value_strncmpic_12 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_13)
          tmp_if_expr_15 = (_Bool)1;

        else
        {
          return_value_strncmpic_14=strncmpic(rsp->status, "504", (unsigned long int)3);
          tmp_if_expr_15 = !(return_value_strncmpic_14 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_15)
        {
          if(err == /*enum*/JB_ERR_OK)
            err=enlist_unique_header(rsp->headers, "Last-Modified", "Wed, 08 Jun 1955 12:00:00 GMT");

        }

        else
          if(err == /*enum*/JB_ERR_OK)
            err=enlist_unique_header(rsp->headers, "Last-Modified", buf);

        if(err == /*enum*/JB_ERR_OK)
          err=enlist_unique_header(rsp->headers, "Expires", "Sat, 17 Jun 2000 12:00:00 GMT");

        if(err == /*enum*/JB_ERR_OK)
          err=enlist_unique_header(rsp->headers, "Pragma", "no-cache");

      }
    }
    if(err == /*enum*/JB_ERR_OK)
    {
      if((0x00008000U & csp->flags) == 0u)
        tmp_if_expr_17 = (_Bool)1;

      else
        tmp_if_expr_17 = (csp->flags & 0x00040000U) != 0u ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_17)
        err=enlist_unique_header(rsp->headers, "Connection", "close");

    }

    if(!(err == /*enum*/JB_ERR_OK))
      tmp_if_expr_19 = (_Bool)1;

    else
    {
      rsp->head=list_to_text(rsp->headers);
      tmp_if_expr_19 = (char *)(void *)0 == rsp->head ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_19)
    {
      free_http_response(rsp);
      struct http_response *return_value_cgi_error_memory_18;
      return_value_cgi_error_memory_18=cgi_error_memory();
      return return_value_cgi_error_memory_18;
    }

    rsp->head_length=strlen(rsp->head);
    return rsp;
  }
}

// flush_socket
// file parsers.h line 53
extern signed long int flush_socket(signed int fd, struct iob *iob)
{
  signed long int len = iob->eod - iob->cur;
  if(!(len >= 1l))
    return (signed long int)0;

  else
  {
    signed int return_value_write_socket_1;
    return_value_write_socket_1=write_socket(fd, iob->cur, (unsigned long int)len);
    if(!(return_value_write_socket_1 == 0))
      return (signed long int)-1;

    else
    {
      iob->cur = iob->buf;
      iob->eod = iob->cur;
      return len;
    }
  }
}

// force_required
// file jcc.c line 1475
static signed int force_required(struct client_state *csp, char *request_line)
{
  char *p;
  p=strstr(request_line, "http://");
  if(!(p == ((char *)NULL)))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen("http://");
    p = p + (signed long int)return_value_strlen_1;
  }

  else
    p = request_line;
  p=strstr(p, "/");
  if(p == ((char *)NULL))
    return 0;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen("/PRIVOXY-FORCE");
    signed int return_value_strncmpic_3;
    return_value_strncmpic_3=strncmpic(p, "/PRIVOXY-FORCE", return_value_strlen_2 - (unsigned long int)1);
    if(return_value_strncmpic_3 == 0)
    {
      if((32U & csp->config->feature_flags) == 0u)
      {
        strclean(request_line, "/PRIVOXY-FORCE");
        log_error(0x0020, "Enforcing request: \"%s\".", request_line);
        return 1;
      }

      log_error(0x0020, "Ignored force prefix in request: \"%s\".", request_line);
    }

    return 0;
  }
}

// forget_connection
// file gateway.c line 313
extern void forget_connection(signed int sfd)
{
  unsigned int slot = (unsigned int)0;
  /* assertion sfd != (-1) */
  assert(sfd != -1);
  privoxy_mutex_lock(&connection_reuse_mutex);
  slot = (unsigned int)0;
  for( ; !((unsigned long int)slot >= 100ul); slot = slot + 1u)
    if(reusable_connection[(signed long int)slot].sfd == sfd)
    {
      /* assertion reusable_connection[slot].in_use */
      assert(reusable_connection[(signed long int)slot].in_use != 0);
      log_error(0x0002, "Forgetting socket %d for %s:%d in slot %d.", sfd, reusable_connection[(signed long int)slot].host, reusable_connection[(signed long int)slot].port, slot);
      mark_connection_closed(&reusable_connection[(signed long int)slot]);
      break;
    }

  privoxy_mutex_unlock(&connection_reuse_mutex);
}

// forward_url
// file filters.h line 89
extern struct forward_spec * forward_url(struct client_state *csp, struct http_request *http)
{
  struct forward_spec *fwd = csp->config->forward;
  if(!((0x00004000UL & csp->action[0l].flags) == 0ul))
  {
    struct forward_spec *return_value_get_forward_override_settings_1;
    return_value_get_forward_override_settings_1=get_forward_override_settings(csp);
    return return_value_get_forward_override_settings_1;
  }

  static struct forward_spec fwd_default[1l];
  if(fwd == ((struct forward_spec *)NULL))
    return fwd_default;

  else
  {
    while(!(fwd == ((struct forward_spec *)NULL)))
    {
      signed int return_value_url_match_2;
      return_value_url_match_2=url_match(fwd->url, http);
      if(!(return_value_url_match_2 == 0))
        return fwd;

      fwd = fwd->next;
    }
    return fwd_default;
  }
}

// forwarded_connect
// file gateway.c line 600
extern signed int forwarded_connect(struct forward_spec *fwd, struct http_request *http, struct client_state *csp)
{
  const char *dest_host;
  signed int dest_port;
  signed int sfd = -1;
  if(!((256U & csp->config->feature_flags) == 0u))
  {
    if(!((0x00040000U & csp->flags) == 0u))
      goto __CPROVER_DUMP_L1;

    sfd=get_reusable_connection(http, fwd);
    if(sfd == -1)
      goto __CPROVER_DUMP_L1;

    return sfd;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(fwd->forward_host == ((char *)NULL)))
    {
      dest_host = fwd->forward_host;
      dest_port = fwd->forward_port;
    }

    else
    {
      dest_host = http->host;
      dest_port = http->port;
    }
    switch((signed int)fwd->type)
    {
      case SOCKS_NONE:

      case FORWARD_WEBSERVER:
      {
        sfd=connect_to(dest_host, dest_port, csp);
        break;
      }
      case SOCKS_4:

      case SOCKS_4A:
      {
        sfd=socks4_connect(fwd, dest_host, dest_port, csp);
        break;
      }
      case SOCKS_5:

      case SOCKS_5T:
      {
        sfd=socks5_connect(fwd, dest_host, dest_port, csp);
        break;
      }
      default:
        log_error(0x4000, "Internal error in forwarded_connect(). Bad proxy type: %d", fwd->type);
    }
    if(!(sfd == -1))
      log_error(0x0002, "Created new connection to %s:%d on socket %d.", http->host, http->port, sfd);

    return sfd;
  }
}

// free_action
// file actions.c line 287
extern void free_action(struct action_spec *src)
{
  signed int i;
  if(!(src == ((struct action_spec *)NULL)))
  {
    i = 0;
    for( ; !(i >= 19); i = i + 1)
      if(!(src->string[(signed long int)i] == ((char *)NULL)))
      {
        free((void *)src->string[(signed long int)i]);
        src->string[(signed long int)i] = (char *)(void *)0;
      }

    i = 0;
    for( ; !(i >= 7); i = i + 1)
    {
      destroy_list(src->multi_remove[(signed long int)i]);
      destroy_list(src->multi_add[(signed long int)i]);
    }
    memset((void *)src, 0, sizeof(struct action_spec) /*424ul*/ );
  }

}

// free_action_spec
// file actions.c line 266
void free_action_spec(struct action_spec *src)
{
  free_action(src);
  if(!(src == ((struct action_spec *)NULL)))
  {
    free((void *)src);
    src = (struct action_spec *)(void *)0;
  }

}

// free_alias_list
// file actions.c line 1030
extern void free_alias_list(struct action_alias *alias_list)
{
  while(!(alias_list == ((struct action_alias *)NULL)))
  {
    struct action_alias *next = alias_list->next;
    alias_list->next = (struct action_alias *)(void *)0;
    if(!(alias_list->name == ((const char *)NULL)))
    {
      free((void *)alias_list->name);
      alias_list->name = (const char *)(void *)0;
    }

    free_action(alias_list->action);
    free((void *)alias_list);
    alias_list = next;
  }
}

// free_current_action
// file actions.c line 928
extern void free_current_action(struct current_action_spec *src)
{
  signed int i = 0;
  for( ; !(i >= 19); i = i + 1)
    if(!(src->string[(signed long int)i] == ((char *)NULL)))
    {
      free((void *)src->string[(signed long int)i]);
      src->string[(signed long int)i] = (char *)(void *)0;
    }

  i = 0;
  for( ; !(i >= 7); i = i + 1)
    destroy_list(src->multi[(signed long int)i]);
  memset((void *)src, 0, sizeof(struct current_action_spec) /*272ul*/ );
}

// free_http_request
// file urlmatch.h line 41
extern void free_http_request(struct http_request *http)
{
  /* assertion http */
  assert(http != ((struct http_request *)NULL));
  if(!(http->cmd == ((char *)NULL)))
  {
    free((void *)http->cmd);
    http->cmd = (char *)(void *)0;
  }

  if(!(http->ocmd == ((char *)NULL)))
  {
    free((void *)http->ocmd);
    http->ocmd = (char *)(void *)0;
  }

  if(!(http->gpc == ((char *)NULL)))
  {
    free((void *)http->gpc);
    http->gpc = (char *)(void *)0;
  }

  if(!(http->host == ((char *)NULL)))
  {
    free((void *)http->host);
    http->host = (char *)(void *)0;
  }

  if(!(http->url == ((char *)NULL)))
  {
    free((void *)http->url);
    http->url = (char *)(void *)0;
  }

  if(!(http->hostport == ((char *)NULL)))
  {
    free((void *)http->hostport);
    http->hostport = (char *)(void *)0;
  }

  if(!(http->path == ((char *)NULL)))
  {
    free((void *)http->path);
    http->path = (char *)(void *)0;
  }

  if(!(http->ver == ((char *)NULL)))
  {
    free((void *)http->ver);
    http->ver = (char *)(void *)0;
  }

  if(!(http->host_ip_addr_str == ((char *)NULL)))
  {
    free((void *)http->host_ip_addr_str);
    http->host_ip_addr_str = (char *)(void *)0;
  }

  if(!(http->dbuffer == ((char *)NULL)))
  {
    free((void *)http->dbuffer);
    http->dbuffer = (char *)(void *)0;
  }

  if(!(http->dvec == ((char **)NULL)))
  {
    free((void *)http->dvec);
    http->dvec = (char **)(void *)0;
  }

  http->dcount = 0;
}

// free_http_response
// file cgi.c line 1791
extern void free_http_response(struct http_response *rsp)
{
  if(!(rsp == ((struct http_response *)NULL)))
  {
    if(!(rsp == cgi_error_memory_response))
    {
      if(!(rsp->status == ((char *)NULL)))
      {
        free((void *)rsp->status);
        rsp->status = (char *)(void *)0;
      }

      if(!(rsp->head == ((char *)NULL)))
      {
        free((void *)rsp->head);
        rsp->head = (char *)(void *)0;
      }

      if(!(rsp->body == ((char *)NULL)))
      {
        free((void *)rsp->body);
        rsp->body = (char *)(void *)0;
      }

      destroy_list(rsp->headers);
      free((void *)rsp);
    }

  }

}

// free_map
// file list.h line 78
extern void free_map(struct map *the_map)
{
  struct map_entry *cur_entry;
  struct map_entry *next_entry;
  if(!(the_map == ((struct map *)NULL)))
  {
    cur_entry = the_map->first;
    for( ; !(cur_entry == ((struct map_entry *)NULL)); cur_entry = next_entry)
    {
      if(!(cur_entry->name == ((const char *)NULL)))
      {
        free((void *)cur_entry->name);
        cur_entry->name = (const char *)(void *)0;
      }

      if(!(cur_entry->value == ((const char *)NULL)))
      {
        free((void *)cur_entry->value);
        cur_entry->value = (const char *)(void *)0;
      }

      next_entry = cur_entry->next;
      free((void *)cur_entry);
    }
    the_map->last = (struct map_entry *)(void *)0;
    the_map->first = the_map->last;
    free((void *)the_map);
  }

}

// free_pattern_spec
// file urlmatch.h line 57
extern void free_pattern_spec(struct pattern_spec *pattern)
{
  if(!(pattern == ((struct pattern_spec *)NULL)))
  {
    if(!(pattern->spec == ((char *)NULL)))
    {
      free((void *)pattern->spec);
      pattern->spec = (char *)(void *)0;
    }

    if(!(pattern->pattern.url_spec.dbuffer == ((char *)NULL)))
    {
      free((void *)pattern->pattern.url_spec.dbuffer);
      pattern->pattern.url_spec.dbuffer = (char *)(void *)0;
    }

    if(!(pattern->pattern.url_spec.dvec == ((char **)NULL)))
    {
      free((void *)pattern->pattern.url_spec.dvec);
      pattern->pattern.url_spec.dvec = (char **)(void *)0;
    }

    pattern->pattern.url_spec.dcount = 0;
    if(!(pattern->pattern.url_spec.port_list == ((char *)NULL)))
    {
      free((void *)pattern->pattern.url_spec.port_list);
      pattern->pattern.url_spec.port_list = (char *)(void *)0;
    }

    if(!(pattern->pattern.url_spec.preg == ((struct anonymous_3 *)NULL)))
    {
      pcreposix_regfree(pattern->pattern.url_spec.preg);
      if(!(pattern->pattern.url_spec.preg == ((struct anonymous_3 *)NULL)))
      {
        free((void *)pattern->pattern.url_spec.preg);
        pattern->pattern.url_spec.preg = (struct anonymous_3 *)(void *)0;
      }

    }

    if(!(pattern->pattern.tag_regex == ((struct anonymous_3 *)NULL)))
    {
      pcreposix_regfree(pattern->pattern.tag_regex);
      if(!(pattern->pattern.tag_regex == ((struct anonymous_3 *)NULL)))
      {
        free((void *)pattern->pattern.tag_regex);
        pattern->pattern.tag_regex = (struct anonymous_3 *)(void *)0;
      }

    }

  }

}

// get_action_token
// file actions.c line 338
extern enum privoxy_err get_action_token(char **line, char **name, char **value)
{
  char *str = *line;
  char ch;
  *line = (char *)(void *)0;
  *name = (char *)(void *)0;
  *value = (char *)(void *)0;
  for( ; (_Bool)1; str = str + 1l)
    if(!((signed int)*str == 32))
    {
      if(!((signed int)*str == 9))
        goto __CPROVER_DUMP_L3;

    }


__CPROVER_DUMP_L3:
  ;
  if((signed int)*str == 0)
    return (enum privoxy_err)0;

  else
    if((signed int)*str == 123)
      return (enum privoxy_err)JB_ERR_PARSE;

    else
    {
      *name = str;
      do
      {
        ch = *str;
        if((signed int)ch == 0)
          break;

        if((signed int)ch == 32)
          break;

        if((signed int)ch == 9)
          break;

        if((signed int)ch == 123)
          break;

        if((signed int)ch == 125)
          return (enum privoxy_err)JB_ERR_PARSE;

        str = str + 1l;
      }
      while((_Bool)1);
      *str = (char)0;
      if(!((signed int)ch == 123))
      {
        if((signed int)ch == 0)
          *line = str;

        else
          *line = str + (signed long int)1;
        return (enum privoxy_err)JB_ERR_OK;
      }

      else
      {
        str = str + 1l;
        *value = str;
        do
        {
          str=strchr(str, 125);
          if(str == ((char *)NULL))
            break;

          if((signed int)str[-1l] == 92)
            string_move(str - (signed long int)1, str);

          else
            break;
        }
        while((_Bool)1);
        if(str == ((char *)NULL))
        {
          *value = (char *)(void *)0;
          return (enum privoxy_err)JB_ERR_PARSE;
        }

        else
        {
          *str = (char)0;
          *line = str + (signed long int)1;
          chomp(*value);
          return (enum privoxy_err)JB_ERR_OK;
        }
      }
    }
}

// get_actions
// file actions.c line 481
extern enum privoxy_err get_actions(char *line, struct action_alias *alias_list, struct action_spec *cur_action)
{
  enum privoxy_err err;
  init_action(cur_action);
  cur_action->mask = ~0UL;
  signed int return_value_strcmpic_1;
  _Bool tmp_if_expr_3;
  struct list *get_actions__1__1__2__2__1__4__remove_p;
  struct list *add_p;
  _Bool tmp_if_expr_4;
  struct list *remove_p;
  struct list *get_actions__1__1__2__2__1__5__add_p;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  signed int return_value_strcmpic_8;
  unsigned long int return_value_strlen_12;
  _Bool tmp_if_expr_14;
  signed int return_value_action_used_to_be_valid_13;
  unsigned long int return_value_strlen_9;
  _Bool tmp_if_expr_11;
  signed int return_value_strcmpic_10;
  while(!(line == ((char *)NULL)))
  {
    char *option = (char *)(void *)0;
    char *value = (char *)(void *)0;
    err=get_action_token(&line, &option, &value);
    if(!(err == /*enum*/JB_ERR_OK))
      return err;

    if(!(option == ((char *)NULL)))
    {
      struct action_name *action = action_names;
      for( ; !(action->name == ((const char *)NULL)); action = action + 1l)
      {
        return_value_strcmpic_1=strcmpic(action->name, option);
        if(return_value_strcmpic_1 == 0)
          break;

      }
      if(!(action->name == ((const char *)NULL)))
      {
        cur_action->mask = cur_action->mask & action->mask;
        cur_action->add = cur_action->add & action->mask;
        cur_action->add = cur_action->add | action->add;
        switch((signed int)action->value_type)
        {
          case AV_NONE:
          {
            if(!(value == ((char *)NULL)))
            {
              log_error(0x2000, "Action %s does not take parameters but %s was given.", action->name, value);
              return (enum privoxy_err)JB_ERR_PARSE;
            }

            break;
          }
          case AV_ADD_STRING:
          {
            if(value == ((char *)NULL))
              tmp_if_expr_3 = (_Bool)1;

            else
              tmp_if_expr_3 = (signed int)*value == 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_3)
            {
              signed int return_value_strcmpic_2;
              return_value_strcmpic_2=strcmpic(action->name, "+block");
              if(return_value_strcmpic_2 == 0)
              {
                value = "No reason specified.";
                log_error(0x2000, "block action without reason found. This may become a fatal error in future versions.");
              }

              else
                return (enum privoxy_err)JB_ERR_PARSE;
            }

            if(!(cur_action->string[(signed long int)action->index] == ((char *)NULL)))
            {
              free((void *)cur_action->string[(signed long int)action->index]);
              cur_action->string[(signed long int)action->index] = (char *)(void *)0;
            }

            cur_action->string[(signed long int)action->index]=strdup(value);
            if(cur_action->string[(signed long int)action->index] == ((char *)NULL))
              return (enum privoxy_err)JB_ERR_MEMORY;

            break;
          }
          case AV_REM_STRING:
          {
            if(!(cur_action->string[(signed long int)action->index] == ((char *)NULL)))
            {
              free((void *)cur_action->string[(signed long int)action->index]);
              cur_action->string[(signed long int)action->index] = (char *)(void *)0;
            }

            break;
          }
          case AV_ADD_MULTI:
          {
            get_actions__1__1__2__2__1__4__remove_p = cur_action->multi_remove[(signed long int)action->index];
            add_p = cur_action->multi_add[(signed long int)action->index];
            if(value == ((char *)NULL))
              tmp_if_expr_4 = (_Bool)1;

            else
              tmp_if_expr_4 = (signed int)*value == 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_4)
              return (enum privoxy_err)JB_ERR_PARSE;

            list_remove_item(get_actions__1__1__2__2__1__4__remove_p, value);
            err=enlist_unique(add_p, value, (unsigned long int)0);
            if(!(err == /*enum*/JB_ERR_OK))
              return err;

            break;
          }
          case AV_REM_MULTI:
          {
            remove_p = cur_action->multi_remove[(signed long int)action->index];
            get_actions__1__1__2__2__1__5__add_p = cur_action->multi_add[(signed long int)action->index];
            if(value == ((char *)NULL))
              tmp_if_expr_5 = (_Bool)1;

            else
              tmp_if_expr_5 = (signed int)*value == 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_5)
              tmp_if_expr_7 = (_Bool)1;

            else
            {
              if((signed int)*value == 42)
                tmp_if_expr_6 = (signed int)value[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_6 = (_Bool)0;
              tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_7)
            {
              list_remove_all(remove_p);
              list_remove_all(get_actions__1__1__2__2__1__5__add_p);
              cur_action->multi_remove_all[(signed long int)action->index] = 1;
            }

            else
            {
              if(cur_action->multi_remove_all[(signed long int)action->index] == 0)
              {
                err=enlist_unique(remove_p, value, (unsigned long int)0);
                if(!(err == /*enum*/JB_ERR_OK))
                  return err;

              }

              list_remove_item(get_actions__1__1__2__2__1__5__add_p, value);
            }
            break;
          }
          default:
          {
            /* assertion 0 */
            assert(0 != 0);
            return (enum privoxy_err)JB_ERR_PARSE;
          }
        }
      }

      else
      {
        struct action_alias *alias = alias_list;
        for( ; !(alias == ((struct action_alias *)NULL)); alias = alias->next)
        {
          return_value_strcmpic_8=strcmpic(alias->name, option);
          if(return_value_strcmpic_8 == 0)
            break;

        }
        if(!(alias == ((struct action_alias *)NULL)))
          merge_actions(cur_action, alias->action);

        else
        {
          return_value_strlen_12=strlen(option);
          if(return_value_strlen_12 >= 3ul)
          {
            return_value_action_used_to_be_valid_13=action_used_to_be_valid(option + (signed long int)1);
            tmp_if_expr_14 = return_value_action_used_to_be_valid_13 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_14 = (_Bool)0;
          if(tmp_if_expr_14)
            log_error(0x2000, "Action '%s' is no longer valid in this Privoxy release. Ignored.", option + (signed long int)1);

          else
          {
            return_value_strlen_9=strlen(option);
            if(return_value_strlen_9 >= 3ul)
            {
              return_value_strcmpic_10=strcmpic(option + (signed long int)1, "hide-forwarded-for-headers");
              tmp_if_expr_11 = 0 == return_value_strcmpic_10 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_11 = (_Bool)0;
            if(tmp_if_expr_11)
              log_error(0x4000, "The action 'hide-forwarded-for-headers' is no longer valid in this Privoxy release. Use 'change-x-forwarded-for' instead.");

            else
            {
              log_error(0x2000, "Unknown action or alias: %s", option);
              return (enum privoxy_err)JB_ERR_PARSE;
            }
          }
        }
      }
    }

  }
  return (enum privoxy_err)JB_ERR_OK;
}

// get_char_param
// file cgi.c line 693
extern char get_char_param(struct map *parameters, const char *param_name)
{
  char ch;
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  /* assertion param_name */
  assert(param_name != ((const char *)NULL));
  const char *return_value_lookup_1;
  return_value_lookup_1=lookup(parameters, param_name);
  ch = *return_value_lookup_1;
  if((signed int)ch >= 97 && !((signed int)ch >= 123))
    ch = (char)(((signed int)ch - 97) + 65);

  return ch;
}

// get_clf_timestamp
// file errlog.c line 513
static inline unsigned long int get_clf_timestamp(char *buffer, unsigned long int buffer_size)
{
  signed long int now;
  struct tm *tm_now;
  struct tm gmt;
  struct tm dummy;
  signed int days;
  signed int hrs;
  signed int mins;
  unsigned long int length;
  signed int tz_length = 0;
  time(&now);
  struct tm *return_value_gmtime_r_1;
  return_value_gmtime_r_1=gmtime_r(&now, &gmt);
  gmt = *return_value_gmtime_r_1;
  tm_now=localtime_r(&now, &dummy);
  days = tm_now->tm_yday - gmt.tm_yday;
  hrs = ((days < -1 ? 24 : (1 < days ? -24 : days * 24)) + tm_now->tm_hour) - gmt.tm_hour;
  mins = (hrs * 60 + tm_now->tm_min) - gmt.tm_min;
  length=strftime(buffer, buffer_size, "%d/%b/%Y:%H:%M:%S ", tm_now);
  if(length >= 1ul)
  {
    signed int return_value_abs_2;
    return_value_abs_2=abs(mins);
    tz_length=snprintf(buffer + (signed long int)length, buffer_size - length, "%+03d%02d", mins / 60, return_value_abs_2 % 60);
  }

  if(tz_length >= 1)
    length = length + (unsigned long int)tz_length;

  else
    length = (unsigned long int)0;
  return length;
}

// get_content_length
// file parsers.c line 1811
static enum privoxy_err get_content_length(const char *header_value, unsigned long long int *length)
{
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(header_value, "%llu", length);
  if(!(return_value_sscanf_1 == 1))
    return (enum privoxy_err)JB_ERR_PARSE;

  else
    return (enum privoxy_err)JB_ERR_OK;
}

// get_content_type
// file cgisimple.c line 680
static const char * get_content_type(const char *filename)
{
  signed int i = 0;
  for( ; !((unsigned long int)i >= 4ul); i = i + 1)
  {
    char *return_value_strstr_1;
    /* get_content_type::1::tag-content_type */
struct content_type
{
  // extension
  const char extension[6l];
  // content_type
  const char content_type[11l];
};

/* */
    ;
    static struct content_type content_types[4l] = { { .extension={ '.', 'c', 's', 's', 0, 0 }, .content_type={ 't', 'e', 'x', 't', '/', 'c', 's', 's', 0, 0, 0 } },
    { .extension={ '.', 'j', 'p', 'g', 0, 0 }, .content_type={ 'i', 'm', 'a', 'g', 'e', '/', 'j', 'p', 'e', 'g', 0 } },
    { .extension={ '.', 'j', 'p', 'e', 'g', 0 }, .content_type={ 'i', 'm', 'a', 'g', 'e', '/', 'j', 'p', 'e', 'g', 0 } },
    { .extension={ '.', 'p', 'n', 'g', 0, 0 }, .content_type={ 'i', 'm', 'a', 'g', 'e', '/', 'p', 'n', 'g', 0, 0 } } };
    return_value_strstr_1=strstr(filename, content_types[(signed long int)i].extension);
    if(!(return_value_strstr_1 == ((char *)NULL)))
      return content_types[(signed long int)i].content_type;

  }
  return "text/html";
}

// get_destination_from_headers
// file parsers.h line 62
extern enum privoxy_err get_destination_from_headers(struct list *headers, struct http_request *http)
{
  char *q;
  char *p;
  char *host;
  /* assertion !http->ssl */
  assert(!(http->ssl != 0));
  host=get_header_value(headers, "Host:");
  char *tmp_post_1;
  if(host == ((char *)NULL))
  {
    log_error(0x2000, "No \"Host:\" header found.");
    return (enum privoxy_err)JB_ERR_PARSE;
  }

  else
  {
    p=strdup_or_die(host);
    chomp(p);
    q=strdup_or_die(p);
    if(!(http->hostport == ((char *)NULL)))
    {
      free((void *)http->hostport);
      http->hostport = (char *)(void *)0;
    }

    http->hostport = p;
    if(!(http->host == ((char *)NULL)))
    {
      free((void *)http->host);
      http->host = (char *)(void *)0;
    }

    http->host = q;
    q=strchr(http->host, 58);
    if(!(q == ((char *)NULL)))
    {
      tmp_post_1 = q;
      q = q + 1l;
      *tmp_post_1 = (char)0;
      http->port=atoi(q);
    }

    else
      http->port = 80;
    if(!(http->url == ((char *)NULL)))
    {
      free((void *)http->url);
      http->url = (char *)(void *)0;
    }

    http->url=strdup("http://");
    string_append(&http->url, http->hostport);
    string_append(&http->url, http->path);
    if(http->url == ((char *)NULL))
      return (enum privoxy_err)JB_ERR_MEMORY;

    else
    {
      log_error(0x0008, "Destination extracted from \"Host\" header. New request URL: %s", http->url);
      /* assertion http->cmd != ((void *)0) */
      assert(http->cmd != (char *)(void *)0);
      if(!(http->cmd == ((char *)NULL)))
      {
        free((void *)http->cmd);
        http->cmd = (char *)(void *)0;
      }

      http->cmd=strdup_or_die(http->gpc);
      string_append(&http->cmd, " ");
      string_append(&http->cmd, http->url);
      string_append(&http->cmd, " ");
      string_append(&http->cmd, http->ver);
      if(http->cmd == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      else
        return (enum privoxy_err)JB_ERR_OK;
    }
  }
}

// get_expected_content_length
// file parsers.h line 63
extern unsigned long long int get_expected_content_length(struct list *headers)
{
  const char *content_length_header;
  unsigned long long int content_length = (unsigned long long int)0;
  content_length_header=get_header_value(headers, "Content-Length:");
  if(!(content_length_header == ((const char *)NULL)))
  {
    enum privoxy_err return_value_get_content_length_1;
    return_value_get_content_length_1=get_content_length(content_length_header, &content_length);
    if(!((signed int)return_value_get_content_length_1 == JB_ERR_OK))
    {
      log_error(0x2000, "Failed to get the Content-Length in %s", content_length_header);
      return (unsigned long long int)0;
    }

  }

  return content_length;
}

// get_external_filter
// file filters.c line 1724
static const char * get_external_filter(struct client_state *csp, const char *name)
{
  struct re_filterfile_spec *external_filter;
  external_filter=get_filter(csp, name, (enum filter_type)FT_EXTERNAL_CONTENT_FILTER);
  if(external_filter == ((struct re_filterfile_spec *)NULL))
    log_error(0x4000, "Didn't find stuff to execute for external filter: %s", name);

  return external_filter->patterns[0l].first->str;
}

// get_file_name_param
// file cgiedit.c line 1716
static enum privoxy_err get_file_name_param(struct client_state *csp, struct map *parameters, const char *param_name, const char **pfilename)
{
  const char *param;
  const char suffix[8l] = { '.', 'a', 'c', 't', 'i', 'o', 'n', 0 };
  const char *s;
  char *name;
  char *fullpath;
  char ch;
  unsigned long int len;
  unsigned long int name_size;
  signed int i;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  /* assertion pfilename */
  assert(pfilename != ((const char **)NULL));
  *pfilename = (const char *)(void *)0;
  param=lookup(parameters, param_name);
  const char *tmp_post_1;
  signed int return_value_strcmp_4;
  if(*param == 0)
    return (enum privoxy_err)JB_ERR_CGI_PARAMS;

  else
  {
    len=strlen(param);
    if(len >= 4096ul)
      return (enum privoxy_err)JB_ERR_CGI_PARAMS;

    else
    {
      s = param;
      do
      {
        tmp_post_1 = s;
        s = s + 1l;
        ch = *tmp_post_1;
        if((signed int)ch == 0)
          break;

        if(!((signed int)ch == 45) && !((signed int)ch == 95) && ((signed int)ch >= 58 || !((signed int)ch >= 48)) && ((signed int)ch >= 91 || !((signed int)ch >= 65)) && ((signed int)ch >= 123 || !((signed int)ch >= 97)))
          return (enum privoxy_err)JB_ERR_CGI_PARAMS;

      }
      while((_Bool)1);
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(suffix);
      name_size = len + return_value_strlen_2 + (unsigned long int)1;
      void *return_value_malloc_or_die_3;
      return_value_malloc_or_die_3=malloc_or_die(name_size);
      name = (char *)return_value_malloc_or_die_3;
      privoxy_strlcpy(name, param, name_size);
      privoxy_strlcat(name, suffix, name_size);
      fullpath=make_path(csp->config->confdir, name);
      free((void *)name);
      if(fullpath == ((char *)NULL))
        return (enum privoxy_err)JB_ERR_MEMORY;

      else
      {
        i = 0;
        for( ; !(i >= 30); i = i + 1)
          if(!(csp->config->actions_file[(signed long int)i] == ((const char *)NULL)))
          {
            return_value_strcmp_4=strcmp(fullpath, csp->config->actions_file[(signed long int)i]);
            if(return_value_strcmp_4 == 0)
            {
              *pfilename = csp->config->actions_file[(signed long int)i];
              if(!(fullpath == ((char *)NULL)))
              {
                free((void *)fullpath);
                fullpath = (char *)(void *)0;
              }

              return (enum privoxy_err)JB_ERR_OK;
            }

          }

        if(!(fullpath == ((char *)NULL)))
        {
          free((void *)fullpath);
          fullpath = (char *)(void *)0;
        }

        return (enum privoxy_err)JB_ERR_CGI_PARAMS;
      }
    }
  }
}

// get_filter
// file filters.h line 82
extern struct re_filterfile_spec * get_filter(struct client_state *csp, const char *requested_name, enum filter_type requested_type)
{
  signed int i;
  struct re_filterfile_spec *b;
  struct file_list *fl;
  i = 0;
  _Bool tmp_if_expr_1;
  for( ; !(i >= 30); i = i + 1)
  {
    fl = csp->rlist[(signed long int)i];
    if(fl == ((struct file_list *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (void *)0 == fl->f ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1)
    {
      b = (struct re_filterfile_spec *)fl->f;
      for( ; !(b == ((struct re_filterfile_spec *)NULL)); b = b->next)
        if(b->type == requested_type)
        {
          signed int return_value_strcmp_2;
          return_value_strcmp_2=strcmp(b->name, requested_name);
          if(return_value_strcmp_2 == 0)
            return b;

        }

    }

  }
  return (struct re_filterfile_spec *)(void *)0;
}

// get_filter_function
// file filters.c line 2010
static char * (*get_filter_function(struct client_state *csp))()
{
  char * (*filter_function)() = (char * (*)())(void *)0;
  _Bool tmp_if_expr_2;
  signed int return_value_list_is_empty_1;
  if(!((0x0001U & csp->content_type) == 0u))
  {
    return_value_list_is_empty_1=list_is_empty(csp->action[0l].multi[(signed long int)1]);
    tmp_if_expr_2 = !(return_value_list_is_empty_1 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    filter_function = (char * (*)())pcrs_filter_response;

  else
    if(!((0x0002U & csp->content_type) == 0u))
    {
      if(!((0x00000002UL & csp->action[0l].flags) == 0ul))
        filter_function = (char * (*)())gif_deanimate_response;

    }

  return filter_function;
}

// get_forward_override_settings
// file filters.c line 2396
static struct forward_spec * get_forward_override_settings(struct client_state *csp)
{
  const char *forward_override_line = csp->action[0l].string[(signed long int)15];
  char forward_settings[5000l];
  char *http_parent = (char *)(void *)0;
  struct forward_spec *fwd = (struct forward_spec *)(void *)0;
  signed int vec_count;
  char *vec[3l];
  /* assertion csp->action->flags & 0x00004000UL */
  assert((csp->action[0l].flags & 0x00004000UL) != 0ul);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(forward_override_line);
  /* assertion strlen(forward_override_line) < sizeof(forward_settings) - 1 */
  assert(return_value_strlen_1 < sizeof(char [5000l]) /*5000ul*/  - (unsigned long int)1);
  privoxy_strlcpy(forward_settings, forward_override_line, sizeof(char [5000l]) /*5000ul*/ );
  if(!(csp->fwd == ((struct forward_spec *)NULL)))
    unload_forward_spec(csp->fwd);

  void *return_value_zalloc_2;
  return_value_zalloc_2=zalloc(sizeof(struct forward_spec) /*104ul*/ );
  csp->fwd = (struct forward_spec *)return_value_zalloc_2;
  fwd = csp->fwd;
  _Bool tmp_if_expr_10;
  signed int return_value_strcasecmp_9;
  _Bool tmp_if_expr_8;
  signed int return_value_strcasecmp_7;
  signed int return_value_strcasecmp_5;
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_3;
  if(fwd == ((struct forward_spec *)NULL))
  {
    log_error(0x4000, "can't allocate memory for forward-override{%s}", forward_override_line);
    return (struct forward_spec *)(void *)0;
  }

  else
  {
    vec_count=ssplit(forward_settings, " \t", vec, sizeof(char *[3l]) /*24ul*/  / sizeof(char *) /*8ul*/ );
    if(vec_count == 2)
    {
      return_value_strcasecmp_9=strcasecmp(vec[(signed long int)0], "forward");
      tmp_if_expr_10 = !(return_value_strcasecmp_9 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_10 = (_Bool)0;
    if(tmp_if_expr_10)
    {
      fwd->type = (enum forwarder_type)SOCKS_NONE;
      http_parent = vec[(signed long int)1];
    }

    else
    {
      if(vec_count == 2)
      {
        return_value_strcasecmp_7=strcasecmp(vec[(signed long int)0], "forward-webserver");
        tmp_if_expr_8 = !(return_value_strcasecmp_7 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_8 = (_Bool)0;
      if(tmp_if_expr_8)
      {
        fwd->type = (enum forwarder_type)FORWARD_WEBSERVER;
        http_parent = vec[(signed long int)1];
      }

      else
        if(vec_count == 3)
        {
          char *socks_proxy = (char *)(void *)0;
          signed int return_value_strcasecmp_6;
          return_value_strcasecmp_6=strcasecmp(vec[(signed long int)0], "forward-socks4");
          if(return_value_strcasecmp_6 == 0)
          {
            fwd->type = (enum forwarder_type)SOCKS_4;
            socks_proxy = vec[(signed long int)1];
          }

          else
          {
            return_value_strcasecmp_5=strcasecmp(vec[(signed long int)0], "forward-socks4a");
            if(return_value_strcasecmp_5 == 0)
            {
              fwd->type = (enum forwarder_type)SOCKS_4A;
              socks_proxy = vec[(signed long int)1];
            }

            else
            {
              return_value_strcasecmp_4=strcasecmp(vec[(signed long int)0], "forward-socks5");
              if(return_value_strcasecmp_4 == 0)
              {
                fwd->type = (enum forwarder_type)SOCKS_5;
                socks_proxy = vec[(signed long int)1];
              }

              else
              {
                return_value_strcasecmp_3=strcasecmp(vec[(signed long int)0], "forward-socks5t");
                if(return_value_strcasecmp_3 == 0)
                {
                  fwd->type = (enum forwarder_type)SOCKS_5T;
                  socks_proxy = vec[(signed long int)1];
                }

              }
            }
          }
          if(!(socks_proxy == ((char *)NULL)))
          {
            fwd->gateway_port = 1080;
            parse_forwarder_address(socks_proxy, &fwd->gateway_host, &fwd->gateway_port);
            http_parent = vec[(signed long int)2];
          }

        }

    }
    if(http_parent == ((char *)NULL))
      log_error(0x4000, "Invalid forward-override syntax in: %s", forward_override_line);

    signed int return_value_strcmp_11;
    return_value_strcmp_11=strcmp(http_parent, ".");
    if(!(return_value_strcmp_11 == 0))
    {
      fwd->forward_port = 8000;
      parse_forwarder_address(http_parent, &fwd->forward_host, &fwd->forward_port);
    }

    /* assertion ((void *)0) != fwd */
    assert((struct forward_spec *)(void *)0 != fwd);
    log_error(0x0002, "Overriding forwarding settings based on '%s'", forward_override_line);
    return fwd;
  }
}

// get_header
// file parsers.h line 57
extern char * get_header(struct iob *iob)
{
  char *header;
  header=get_header_line(iob);
  _Bool tmp_if_expr_1;
  if(header == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)*header == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    return header;

  else
  {
    while((_Bool)1)
    {
      if(!((signed int)*iob->cur == 32))
      {
        if(!((signed int)*iob->cur == 9))
          goto __CPROVER_DUMP_L10;

      }

      char *continued_header;
      continued_header=get_header_line(iob);
      if(continued_header == ((char *)NULL))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)*continued_header == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        log_error(0x1000, "Failed to read a multi-line header properly: '%s'", header);
        break;
      }

      enum privoxy_err return_value_string_join_3;
      return_value_string_join_3=string_join(&header, continued_header);
      if(!((signed int)return_value_string_join_3 == JB_ERR_OK))
        log_error(0x4000, "Out of memory while appending multiple headers.");

      else
        log_error(0x0008, "Merged multiple header lines to: '%s'", header);
    }

  __CPROVER_DUMP_L10:
    ;
    normalize_lws(header);
    return header;
  }
}

// get_header_line
// file parsers.c line 913
static char * get_header_line(struct iob *iob)
{
  char *p;
  char *q;
  char *ret;
  _Bool tmp_if_expr_1;
  if(iob->cur == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    p=strchr(iob->cur, 10);
    tmp_if_expr_1 = p == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1)
    return "";

  else
  {
    *p = (char)0;
    ret=strdup(iob->cur);
    if(ret == ((char *)NULL))
      log_error(0x4000, "Out of memory in get_header_line()");

    /* assertion ret != ((void *)0) */
    assert(ret != (char *)(void *)0);
    iob->cur = p + (signed long int)1;
    q=strchr(ret, 13);
    if(!(q == ((char *)NULL)))
      *q = (char)0;

    if((signed int)*ret == 0)
    {
      if(!(ret == ((char *)NULL)))
      {
        free((void *)ret);
        ret = (char *)(void *)0;
      }

      return (char *)(void *)0;
    }

    else
      return ret;
  }
}

// get_header_value
// file parsers.h line 58
extern char * get_header_value(struct list *header_list, const char *header_name)
{
  struct list_entry *cur_entry;
  char *ret = (char *)(void *)0;
  unsigned long int length = (unsigned long int)0;
  /* assertion header_list */
  assert(header_list != ((struct list *)NULL));
  /* assertion header_name */
  assert(header_name != ((const char *)NULL));
  length=strlen(header_name);
  cur_entry = header_list->first;
  const unsigned short int **return_value___ctype_b_loc_1;
  for( ; !(cur_entry == ((struct list_entry *)NULL)); cur_entry = cur_entry->next)
    if(!(cur_entry->str == ((char *)NULL)))
    {
      signed int return_value_strncmpic_2;
      return_value_strncmpic_2=strncmpic(cur_entry->str, header_name, length);
      if(return_value_strncmpic_2 == 0)
      {
        ret = cur_entry->str + (signed long int)length;
        for( ; !(*ret == 0); ret = ret + 1l)
        {
          return_value___ctype_b_loc_1=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)*ret]) == 0)
            break;

        }
        return ret;
      }

    }

  return (char *)(void *)0;
}

// get_host_information
// file jbsockets.h line 58
extern void get_host_information(signed int afd, char **ip_address, char **port, char **hostname)
{
  struct sockaddr_storage server;
  signed int retval;
  unsigned int s_length;
  unsigned int s_length_provided = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  s_length = s_length_provided;
  if(!(hostname == ((char **)NULL)))
    *hostname = (char *)(void *)0;

  *ip_address = (char *)(void *)0;
  *port = (char *)(void *)0;
  signed int return_value_getsockname_6;
  return_value_getsockname_6=getsockname(afd, (struct sockaddr *)&server, &s_length);
  if(return_value_getsockname_6 == 0)
  {
    if(!(s_length_provided >= s_length))
    {
      log_error(0x2000, "getsockname() truncated server address");
      goto __CPROVER_DUMP_L10;
    }

    void *return_value_malloc_or_die_1;
    return_value_malloc_or_die_1=malloc_or_die((unsigned long int)32);
    *port = (char *)return_value_malloc_or_die_1;
    void *return_value_malloc_or_die_2;
    return_value_malloc_or_die_2=malloc_or_die((unsigned long int)1025);
    *ip_address = (char *)return_value_malloc_or_die_2;
    retval=getnameinfo((struct sockaddr *)&server, s_length, *ip_address, (unsigned int)1025, *port, (unsigned int)32, 1 | 2);
    if(!(retval == 0))
    {
      const char *return_value_gai_strerror_3;
      return_value_gai_strerror_3=gai_strerror(retval);
      log_error(0x2000, "Unable to print my own IP address: %s", return_value_gai_strerror_3);
      if(!(*ip_address == ((char *)NULL)))
      {
        free((void *)*ip_address);
        *ip_address = (char *)(void *)0;
      }

      if(!(*port == ((char *)NULL)))
      {
        free((void *)*port);
        *port = (char *)(void *)0;
      }

      goto __CPROVER_DUMP_L10;
    }

    if(hostname == ((char **)NULL))
      goto __CPROVER_DUMP_L10;

    void *return_value_malloc_or_die_4;
    return_value_malloc_or_die_4=malloc_or_die((unsigned long int)1025);
    *hostname = (char *)return_value_malloc_or_die_4;
    retval=getnameinfo((struct sockaddr *)&server, s_length, *hostname, (unsigned int)1025, (char *)(void *)0, (unsigned int)0, 8);
    if(!(retval == 0))
    {
      const char *return_value_gai_strerror_5;
      return_value_gai_strerror_5=gai_strerror(retval);
      log_error(0x2000, "Unable to resolve my own IP address: %s", return_value_gai_strerror_5);
      if(!(*hostname == ((char *)NULL)))
      {
        free((void *)*hostname);
        *hostname = (char *)(void *)0;
      }

    }

  }

  goto __CPROVER_DUMP_L10;

__CPROVER_DUMP_L10:
  ;
}

// get_http_time
// file cgi.c line 1431
extern void get_http_time(signed int time_offset, char *buf, unsigned long int buffer_size)
{
  struct tm *t;
  signed long int current_time;
  struct tm dummy;
  /* assertion buf */
  assert(buf != ((char *)NULL));
  /* assertion buffer_size > (size_t)29 */
  assert(buffer_size > (unsigned long int)29);
  time(&current_time);
  current_time = current_time + (signed long int)time_offset;
  t=gmtime_r(&current_time, &dummy);
  strftime(buf, buffer_size, "%a, %d %b %Y %H:%M:%S GMT", t);
}

// get_last_url
// file filters.c line 1046
extern char * get_last_url(char *subject, const char *redirect_mode)
{
  char *new_url = (char *)(void *)0;
  char *tmp;
  /* assertion subject */
  assert(subject != ((char *)NULL));
  /* assertion redirect_mode */
  assert(redirect_mode != ((const char *)NULL));
  subject=strdup(subject);
  _Bool tmp_if_expr_6;
  char *return_value_strchr_5;
  signed int tmp_post_3;
  char *tmp_post_7;
  char *tmp_post_8;
  _Bool tmp_if_expr_10;
  signed int return_value_strncmpic_9;
  _Bool tmp_if_expr_12;
  signed int return_value_strncmpic_11;
  if(subject == ((char *)NULL))
  {
    log_error(0x2000, "Out of memory while searching for redirects.");
    return (char *)(void *)0;
  }

  else
  {
    signed int return_value_strcmpic_4;
    return_value_strcmpic_4=strcmpic(redirect_mode, "check-decoded-url");
    if(return_value_strcmpic_4 == 0)
    {
      return_value_strchr_5=strchr(subject, 37);
      tmp_if_expr_6 = return_value_strchr_5 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_6 = (_Bool)0;
    if(tmp_if_expr_6)
    {
      char *url_segment = (char *)(void *)0;
      char **url_segments;
      unsigned long int max_segments;
      signed int segments;
      log_error(0x0080, "Checking \"%s\" for encoded redirects.", subject);
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(subject);
      max_segments = return_value_strlen_1 / (unsigned long int)2;
      void *return_value_malloc_2;
      return_value_malloc_2=malloc(max_segments * sizeof(char *) /*8ul*/ );
      url_segments = (char **)return_value_malloc_2;
      if(url_segments == ((char **)NULL))
      {
        log_error(0x2000, "Out of memory while decoding URL: %s", subject);
        if(!(subject == ((char *)NULL)))
        {
          free((void *)subject);
          subject = (char *)(void *)0;
        }

        return (char *)(void *)0;
      }

      segments=ssplit(subject, "?&", url_segments, max_segments);
      do
      {
        tmp_post_3 = segments;
        segments = segments - 1;
        if(!(tmp_post_3 >= 1))
          break;

        char *dtoken;
        dtoken=url_decode(url_segments[(signed long int)segments]);
        if(dtoken == ((char *)NULL))
          log_error(0x2000, "Unable to decode \"%s\".", url_segments[(signed long int)segments]);

        else
        {
          url_segment=strstr(dtoken, "http://");
          if(url_segment == ((char *)NULL))
            url_segment=strstr(dtoken, "https://");

          if(!(url_segment == ((char *)NULL)))
          {
            url_segment=strdup_or_die(url_segment);
            if(!(dtoken == ((char *)NULL)))
            {
              free((void *)dtoken);
              dtoken = (char *)(void *)0;
            }

            break;
          }

          if(!(dtoken == ((char *)NULL)))
          {
            free((void *)dtoken);
            dtoken = (char *)(void *)0;
          }

        }
      }
      while((_Bool)1);
      if(!(subject == ((char *)NULL)))
      {
        free((void *)subject);
        subject = (char *)(void *)0;
      }

      if(!(url_segments == ((char **)NULL)))
      {
        free((void *)url_segments);
        url_segments = (char **)(void *)0;
      }

      if(url_segment == ((char *)NULL))
        return (char *)(void *)0;

      subject = url_segment;
    }

    else
      log_error(0x0080, "Checking \"%s\" for unencoded redirects.", subject);
    tmp = subject;
    do
    {
      tmp=strstr(tmp, "http://");
      if(tmp == ((char *)NULL))
        break;

      tmp_post_7 = tmp;
      tmp = tmp + 1l;
      new_url = tmp_post_7;
    }
    while((_Bool)1);
    tmp = new_url != (char *)(void *)0 ? new_url : subject;
    do
    {
      tmp=strstr(tmp, "https://");
      if(tmp == ((char *)NULL))
        break;

      tmp_post_8 = tmp;
      tmp = tmp + 1l;
      new_url = tmp_post_8;
    }
    while((_Bool)1);
    if(!(new_url == ((char *)NULL)))
    {
      if(!(new_url == subject))
        tmp_if_expr_10 = (_Bool)1;

      else
      {
        return_value_strncmpic_9=strncmpic(subject, "http://", (unsigned long int)7);
        tmp_if_expr_10 = 0 == return_value_strncmpic_9 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_10)
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        return_value_strncmpic_11=strncmpic(subject, "https://", (unsigned long int)8);
        tmp_if_expr_12 = 0 == return_value_strncmpic_11 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_12)
        goto __CPROVER_DUMP_L28;

      new_url=strdup(new_url);
      if(!(subject == ((char *)NULL)))
      {
        free((void *)subject);
        subject = (char *)(void *)0;
      }

      return new_url;
    }

    else
    {

    __CPROVER_DUMP_L28:
      ;
      if(!(subject == ((char *)NULL)))
      {
        free((void *)subject);
        subject = (char *)(void *)0;
      }

      return (char *)(void *)0;
    }
  }
}

// get_locale_time
// file cgi.c line 1480
static void get_locale_time(char *buf, unsigned long int buffer_size)
{
  struct tm *timeptr;
  signed long int current_time;
  struct tm dummy;
  /* assertion buf */
  assert(buf != ((char *)NULL));
  /* assertion buffer_size > (size_t)29 */
  assert(buffer_size > (unsigned long int)29);
  time(&current_time);
  timeptr=localtime_r(&current_time, &dummy);
  strftime(buf, buffer_size, "%a %b %d %X %Z %Y", timeptr);
}

// get_log_level_string
// file errlog.c line 584
static inline const char * get_log_level_string(signed int loglevel)
{
  char *log_level_string = (char *)(void *)0;
  /* assertion 0 < loglevel */
  assert(0 < loglevel);
  switch(loglevel)
  {
    case 0x2000:
    {
      log_level_string = "Error";
      break;
    }
    case 0x4000:
    {
      log_level_string = "Fatal error";
      break;
    }
    case 0x0001:
    {
      log_level_string = "Request";
      break;
    }
    case 0x0002:
    {
      log_level_string = "Connect";
      break;
    }
    case 0x0010:
    {
      log_level_string = "Writing";
      break;
    }
    case 0x8000:
    {
      log_level_string = "Received";
      break;
    }
    case 0x0008:
    {
      log_level_string = "Header";
      break;
    }
    case 0x1000:
    {
      log_level_string = "Info";
      break;
    }
    case 0x0040:
    {
      log_level_string = "Re-Filter";
      break;
    }
    case 0x0020:
    {
      log_level_string = "Force";
      break;
    }
    case 0x0080:
    {
      log_level_string = "Redirect";
      break;
    }
    case 0x0100:
    {
      log_level_string = "Gif-Deanimate";
      break;
    }
    case 0x0400:
    {
      log_level_string = "Crunch";
      break;
    }
    case 0x0800:
    {
      log_level_string = "CGI";
      break;
    }
    case 0x10000:
    {
      log_level_string = "Actions";
      break;
    }
    default:
      log_level_string = "Unknown log level";
  }
  /* assertion ((void *)0) != log_level_string */
  assert((char *)(void *)0 != log_level_string);
  return log_level_string;
}

// get_log_timestamp
// file errlog.c line 459
static inline unsigned long int get_log_timestamp(char *buffer, unsigned long int buffer_size)
{
  unsigned long int length;
  signed long int now;
  struct tm tm_now;
  struct timeval tv_now;
  signed long int msecs;
  signed int msecs_length = 0;
  gettimeofday(&tv_now, (struct timezone *)(void *)0);
  msecs = tv_now.tv_usec / (signed long int)1000;
  now = tv_now.tv_sec;
  struct tm *return_value_localtime_r_1;
  return_value_localtime_r_1=localtime_r(&now, &tm_now);
  tm_now = *return_value_localtime_r_1;
  length=strftime(buffer, buffer_size, "%Y-%m-%d %H:%M:%S", &tm_now);
  if(length >= 1ul)
    msecs_length=snprintf(buffer + (signed long int)length, buffer_size - length, ".%.3ld", msecs);

  if(msecs_length >= 1)
    length = length + (unsigned long int)msecs_length;

  else
    length = (unsigned long int)0;
  return length;
}

// get_number_param
// file cgi.c line 804
extern enum privoxy_err get_number_param(struct client_state *csp, struct map *parameters, char *name, unsigned int *pvalue)
{
  const char *param;
  char ch;
  unsigned int value;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  /* assertion name */
  assert(name != ((char *)NULL));
  /* assertion pvalue */
  assert(pvalue != ((unsigned int *)NULL));
  *pvalue = (unsigned int)0;
  param=lookup(parameters, name);
  const char *tmp_post_1;
  if(*param == 0)
    return (enum privoxy_err)JB_ERR_CGI_PARAMS;

  else
  {
    value = (unsigned int)0;
    do
    {
      tmp_post_1 = param;
      param = param + 1l;
      ch = *tmp_post_1;
      if((signed int)ch == 0)
        break;

      if((signed int)ch >= 58 || !((signed int)ch >= 48))
        return (enum privoxy_err)JB_ERR_CGI_PARAMS;

      ch = (char)((signed int)ch - 48);
      if(!((1U + -((unsigned int)ch)) / 10U >= value))
        return (enum privoxy_err)JB_ERR_CGI_PARAMS;

      value = value * (unsigned int)10 + (unsigned int)ch;
    }
    while((_Bool)1);
    *pvalue = value;
    return (enum privoxy_err)JB_ERR_OK;
  }
}

// get_request_destination_elsewhere
// file jcc.c line 499
static enum privoxy_err get_request_destination_elsewhere(struct client_state *csp, struct list *headers)
{
  char *req;
  enum privoxy_err return_value_get_destination_from_headers_3;
  if((16U & csp->config->feature_flags) == 0u)
  {
    log_error(0x2000, "%s's request: '%s' is invalid. Privoxy isn't configured to accept intercepted requests.", csp->ip_addr_str, csp->http[0l].cmd);
    log_error(0x0200, "%s - - [%T] \"%s\" 400 0", csp->ip_addr_str, csp->http[0l].cmd);
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(CHEADER);
    write_socket(csp->cfd, CHEADER, return_value_strlen_1);
    destroy_list(headers);
    return (enum privoxy_err)JB_ERR_PARSE;
  }

  else
  {
    return_value_get_destination_from_headers_3=get_destination_from_headers(headers, csp->http);
    if((signed int)return_value_get_destination_from_headers_3 == JB_ERR_OK)
    {
      init_domain_components(csp->http);
      return (enum privoxy_err)JB_ERR_OK;
    }

    else
    {
      req=list_to_text(headers);
      chomp(req);
      log_error(0x0200, "%s - - [%T] \"%s\" 400 0", csp->ip_addr_str, csp->http[0l].cmd);
      log_error(0x2000, "Privoxy was unable to get the destination for %s's request:\n%s\n%s", csp->ip_addr_str, csp->http[0l].cmd, req);
      if(!(req == ((char *)NULL)))
      {
        free((void *)req);
        req = (char *)(void *)0;
      }

      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(MISSING_DESTINATION_RESPONSE);
      write_socket(csp->cfd, MISSING_DESTINATION_RESPONSE, return_value_strlen_2);
      destroy_list(headers);
      return (enum privoxy_err)JB_ERR_PARSE;
    }
  }
}

// get_request_line
// file jcc.c line 1244
static char * get_request_line(struct client_state *csp)
{
  char buf[5000l];
  char *request_line = (char *)(void *)0;
  signed int len;
  memset((void *)buf, 0, sizeof(char [5000l]) /*5000ul*/ );
  _Bool tmp_if_expr_1;
  if(!((0x00800000U & csp->flags) == 0u))
  {
    csp->flags = csp->flags & ~0x00800000U;
    request_line=get_header(csp->client_iob);
    if(!(request_line == ((char *)NULL)))
      tmp_if_expr_1 = 0 != (signed int)*request_line ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      return request_line;

    else
      log_error(0x0002, "No complete request line received yet. Continuing reading from %d.", csp->cfd);
  }

  _Bool tmp_if_expr_2;
  do
  {
    signed int return_value_data_is_available_5;
    return_value_data_is_available_5=data_is_available(csp->cfd, csp->config->socket_timeout);
    if(return_value_data_is_available_5 == 0)
    {
      signed int return_value_socket_is_still_alive_4;
      return_value_socket_is_still_alive_4=socket_is_still_alive(csp->cfd);
      if(!(return_value_socket_is_still_alive_4 == 0))
      {
        log_error(0x0002, "No request line on socket %d received in time. Timeout: %d.", csp->cfd, csp->config->socket_timeout);
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(CLIENT_CONNECTION_TIMEOUT_RESPONSE);
        write_socket(csp->cfd, CLIENT_CONNECTION_TIMEOUT_RESPONSE, return_value_strlen_3);
      }

      else
        log_error(0x0002, "The client side of the connection on socket %d got closed without sending a complete request line.", csp->cfd);
      return (char *)(void *)0;
    }

    len=read_socket(csp->cfd, buf, (signed int)(sizeof(char [5000l]) /*5000ul*/  - (unsigned long int)1));
    if(!(len >= 1))
      return (char *)(void *)0;

    enum privoxy_err return_value_add_to_iob_6;
    return_value_add_to_iob_6=add_to_iob(csp->client_iob, csp->config->buffer_limit, buf, (signed long int)len);
    if(!(return_value_add_to_iob_6 == /*enum*/JB_ERR_OK))
      return (char *)(void *)0;

    request_line=get_header(csp->client_iob);
    if(!(request_line == ((char *)NULL)))
      tmp_if_expr_2 = 0 == (signed int)*request_line ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  return request_line;
}

// get_reusable_connection
// file gateway.c line 480
static signed int get_reusable_connection(struct http_request *http, struct forward_spec *fwd)
{
  signed int sfd = -1;
  unsigned int slot = (unsigned int)0;
  close_unusable_connections();
  privoxy_mutex_lock(&connection_reuse_mutex);
  slot = (unsigned int)0;
  for( ; !((unsigned long int)slot >= 100ul); slot = slot + 1u)
    if(reusable_connection[(signed long int)slot].in_use == 0)
    {
      if(!(reusable_connection[(signed long int)slot].sfd == -1))
      {
        signed int return_value_connection_destination_matches_2;
        return_value_connection_destination_matches_2=connection_destination_matches(&reusable_connection[(signed long int)slot], http, fwd);
        if(!(return_value_connection_destination_matches_2 == 0))
        {
          reusable_connection[(signed long int)slot].in_use = 1;
          sfd = reusable_connection[(signed long int)slot].sfd;
          signed long int return_value_time_1;
          return_value_time_1=time((signed long int *)(void *)0);
          log_error(0x0002, "Found reusable socket %d for %s:%d in slot %d. Timestamp made %d seconds ago. Timeout: %d. Latency: %d. Requests served: %d", sfd, reusable_connection[(signed long int)slot].host, reusable_connection[(signed long int)slot].port, slot, return_value_time_1 - reusable_connection[(signed long int)slot].timestamp, reusable_connection[(signed long int)slot].keep_alive_timeout, (signed int)(reusable_connection[(signed long int)slot].response_received - reusable_connection[(signed long int)slot].request_sent), reusable_connection[(signed long int)slot].requests_sent_total);
          break;
        }

      }

    }

  privoxy_mutex_unlock(&connection_reuse_mutex);
  return sfd;
}

// get_server_headers
// file jcc.c line 568
static enum privoxy_err get_server_headers(struct client_state *csp)
{
  signed int continue_hack_in_da_house = 0;
  char *header;
  signed int return_value_strncmpic_1;
  do
  {
    header=get_header(csp->iob);
    if(header == ((char *)NULL))
    {
      if(continue_hack_in_da_house == 0)
        break;

    }

    if(header == ((char *)NULL))
    {
      enlist(csp->headers, "");
      continue_hack_in_da_house = 0;
      continue;
    }

    else
    {
      return_value_strncmpic_1=strncmpic(header, "HTTP/1.1 100", (unsigned long int)12);
      if(return_value_strncmpic_1 == 0)
      {
        log_error(0x0008, "Continue hack in da house.");
        continue_hack_in_da_house = 1;
      }

      else
        if((signed int)*header == 0)
          return (enum privoxy_err)JB_ERR_PARSE;

    }
    enum privoxy_err return_value_enlist_2;
    return_value_enlist_2=enlist(csp->headers, header);
    if((signed int)return_value_enlist_2 == JB_ERR_MEMORY)
      log_error(0x2000, "Out of memory while enlisting server headers. %s lost.", header);

    if(!(header == ((char *)NULL)))
    {
      free((void *)header);
      header = (char *)(void *)0;
    }

  }
  while((_Bool)1);
  return (enum privoxy_err)JB_ERR_OK;
}

// get_string_param
// file cgi.c line 733
extern enum privoxy_err get_string_param(struct map *parameters, const char *param_name, const char **pparam)
{
  const char *param;
  const char *s;
  char ch;
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  /* assertion param_name */
  assert(param_name != ((const char *)NULL));
  /* assertion pparam */
  assert(pparam != ((const char **)NULL));
  *pparam = (const char *)(void *)0;
  param=lookup(parameters, param_name);
  const char *tmp_post_2;
  if(*param == 0)
    return (enum privoxy_err)JB_ERR_OK;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(param);
    if(return_value_strlen_1 >= 500ul)
      return (enum privoxy_err)JB_ERR_CGI_PARAMS;

    else
    {
      s = param;
      do
      {
        tmp_post_2 = s;
        s = s + 1l;
        ch = *tmp_post_2;
        if((signed int)ch == 0)
          break;

        if((signed int)ch == 125 || !((signed int)(unsigned char)ch >= 32))
          return (enum privoxy_err)JB_ERR_CGI_PARAMS;

      }
      while((_Bool)1);
      *pparam = param;
      return (enum privoxy_err)JB_ERR_OK;
    }
  }
}

// get_thread_id
// file errlog.c line 410
static signed long int get_thread_id(void)
{
  signed long int this_thread;
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  this_thread = (signed long int)return_value_pthread_self_1;
  return this_thread;
}

// get_url_actions
// file filters.h line 76
extern void get_url_actions(struct client_state *csp, struct http_request *http)
{
  struct file_list *fl;
  struct url_actions *b;
  signed int i;
  init_current_action(csp->action);
  i = 0;
  _Bool tmp_if_expr_1;
  for( ; !(i >= 30); i = i + 1)
  {
    fl = csp->actions_list[(signed long int)i];
    if(fl == ((struct file_list *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
    {
      b = (struct url_actions *)fl->f;
      tmp_if_expr_1 = b == (struct url_actions *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_1)
      goto __CPROVER_DUMP_L6;

    apply_url_actions(csp->action, http, b);
  }
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// get_url_spec_param
// file cgiedit.c line 1823
static enum privoxy_err get_url_spec_param(struct client_state *csp, struct map *parameters, const char *name, char **pvalue)
{
  const char *orig_param;
  char *param;
  char *s;
  struct pattern_spec compiled[1l];
  enum privoxy_err err;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion parameters */
  assert(parameters != ((struct map *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion pvalue */
  assert(pvalue != ((char **)NULL));
  *pvalue = (char *)(void *)0;
  orig_param=lookup(parameters, name);
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(*orig_param == 0)
    return (enum privoxy_err)JB_ERR_CGI_PARAMS;

  else
  {
    param=strdup(orig_param);
    if(param == ((char *)NULL))
      return (enum privoxy_err)JB_ERR_MEMORY;

    else
    {
      chomp(param);
      if((signed int)*param == 0)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = (signed int)param[(signed long int)0] == 123 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        free((void *)param);
        return (enum privoxy_err)JB_ERR_CGI_PARAMS;
      }

      else
      {
        s = param;
        for( ; !((signed int)*s == 0); s = s + 1l)
        {
          if((signed int)*s == 13)
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = (signed int)*s == 10 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_2)
          {
            free((void *)param);
            return (enum privoxy_err)JB_ERR_CGI_PARAMS;
          }

        }
        s=strdup(param);
        if(s == ((char *)NULL))
        {
          free((void *)param);
          return (enum privoxy_err)JB_ERR_MEMORY;
        }

        else
        {
          err=create_pattern_spec(compiled, s);
          free((void *)s);
          if(!(err == /*enum*/JB_ERR_OK))
          {
            free((void *)param);
            return (enum privoxy_err)((signed int)err == JB_ERR_MEMORY ? JB_ERR_MEMORY : JB_ERR_CGI_PARAMS);
          }

          else
          {
            free_pattern_spec(compiled);
            unsigned long int return_value_strlen_4;
            return_value_strlen_4=strlen(param);
            if((signed int)param[-1l + (signed long int)return_value_strlen_4] == 92)
            {
              char *return_value_strchr_3;
              return_value_strchr_3=strchr(param, 47);
              if(return_value_strchr_3 == ((char *)NULL))
                err=string_append(&param, "/");

              else
                err=string_append(&param, "(?:)");
              if(!(err == /*enum*/JB_ERR_OK))
                return err;

              s=strdup(param);
              if(s == ((char *)NULL))
              {
                free((void *)param);
                return (enum privoxy_err)JB_ERR_MEMORY;
              }

              err=create_pattern_spec(compiled, s);
              free((void *)s);
              if(!(err == /*enum*/JB_ERR_OK))
              {
                free((void *)param);
                return (enum privoxy_err)((signed int)err == JB_ERR_MEMORY ? JB_ERR_MEMORY : JB_ERR_CGI_PARAMS);
              }

              free_pattern_spec(compiled);
            }

            *pvalue = param;
            return (enum privoxy_err)JB_ERR_OK;
          }
        }
      }
    }
  }
}

// gif_deanimate
// file deanimate.c line 322
extern signed int gif_deanimate(struct binbuffer *src, struct binbuffer *dst, signed int get_first_image)
{
  unsigned char c;
  struct binbuffer *image;
  _Bool tmp_if_expr_4;
  signed int return_value_strncmp_3;
  signed int return_value_gif_extract_image_8;
  unsigned char return_value_buf_getbyte_9;
  signed int return_value_buf_copy_10;
  _Bool tmp_if_expr_12;
  unsigned char return_value_buf_getbyte_11;
  signed int return_value_gif_extract_image_13;
  _Bool tmp_if_expr_15;
  signed int return_value_gif_skip_data_block_14;
  _Bool tmp_if_expr_17;
  signed int return_value_gif_skip_data_block_16;
  _Bool tmp_if_expr_19;
  signed int return_value_gif_skip_data_block_18;
  unsigned long int tmp_post_22;
  if(dst == ((struct binbuffer *)NULL) || src == ((struct binbuffer *)NULL))
    return 1;

  else
  {
    c=buf_getbyte(src, (unsigned long int)10);
    signed int return_value_strncmp_2;
    return_value_strncmp_2=strncmp(src->buffer, "GIF89a", (unsigned long int)6);
    if(!(return_value_strncmp_2 == 0))
    {
      return_value_strncmp_3=strncmp(src->buffer, "GIF87a", (unsigned long int)6);
      tmp_if_expr_4 = return_value_strncmp_3 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      return 1;

    else
    {
      signed int return_value_buf_copy_1;
      return_value_buf_copy_1=buf_copy(src, dst, (unsigned long int)13);
      if(!(return_value_buf_copy_1 == 0))
        return 1;

    }
    if(!((0x80 & (signed int)c) == 0))
    {
      signed int map_length = 3 * (1 << ((signed int)c & 0x07) + 1);
      if(!(map_length >= 1))
      {
        log_error(0x0100, "colormap length = %d (%c)?", map_length, c);
        return 1;
      }

      signed int return_value_buf_copy_5;
      return_value_buf_copy_5=buf_copy(src, dst, (unsigned long int)map_length);
      if(!(return_value_buf_copy_5 == 0))
        return 1;

    }

    void *return_value_zalloc_6;
    return_value_zalloc_6=zalloc(sizeof(struct binbuffer) /*24ul*/ );
    image = (struct binbuffer *)return_value_zalloc_6;
    if(image == ((struct binbuffer *)NULL))
      return 1;

    else
    {
      while(!(src->offset >= src->size))
      {
        unsigned char return_value_buf_getbyte_7;
        return_value_buf_getbyte_7=buf_getbyte(src, (unsigned long int)0);
        switch((signed int)return_value_buf_getbyte_7)
        {
          case 0x3b:
            goto write;
          case 0x2c:
          {
            image->offset = (unsigned long int)0;
            return_value_gif_extract_image_8=gif_extract_image(src, image);
            if(!(return_value_gif_extract_image_8 == 0))
              goto failed;

            if(!(get_first_image == 0))
              goto write;

            break;
          }
          case 0x21:
          {
            return_value_buf_getbyte_9=buf_getbyte(src, (unsigned long int)1);
            switch((signed int)return_value_buf_getbyte_9)
            {
              case 0xf9:
              {
                image->offset = (unsigned long int)0;
                return_value_buf_copy_10=buf_copy(src, image, (unsigned long int)8);
                if(!(return_value_buf_copy_10 == 0))
                  tmp_if_expr_12 = (_Bool)1;

                else
                {
                  return_value_buf_getbyte_11=buf_getbyte(src, (unsigned long int)0);
                  tmp_if_expr_12 = (signed int)return_value_buf_getbyte_11 != 0x2c ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_12)
                  goto failed;

                return_value_gif_extract_image_13=gif_extract_image(src, image);
                if(!(return_value_gif_extract_image_13 == 0))
                  goto failed;

                if(!(get_first_image == 0))
                  goto write;

                goto __CPROVER_DUMP_L28;
              }
              case 0xff:
              {
                src->offset = src->offset + (unsigned long int)14;
                if(src->offset >= src->size)
                  tmp_if_expr_15 = (_Bool)1;

                else
                {
                  return_value_gif_skip_data_block_14=gif_skip_data_block(src);
                  tmp_if_expr_15 = return_value_gif_skip_data_block_14 != 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_15)
                  goto failed;

                goto __CPROVER_DUMP_L28;
              }
              case 0xfe:
              {
                src->offset = src->offset + (unsigned long int)2;
                if(src->offset >= src->size)
                  tmp_if_expr_17 = (_Bool)1;

                else
                {
                  return_value_gif_skip_data_block_16=gif_skip_data_block(src);
                  tmp_if_expr_17 = return_value_gif_skip_data_block_16 != 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_17)
                  goto failed;

                goto __CPROVER_DUMP_L28;
              }
              case 0x01:
              {
                src->offset = src->offset + (unsigned long int)15;
                if(src->offset >= src->size)
                  tmp_if_expr_19 = (_Bool)1;

                else
                {
                  return_value_gif_skip_data_block_18=gif_skip_data_block(src);
                  tmp_if_expr_19 = return_value_gif_skip_data_block_18 != 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_19)
                  goto failed;

                goto __CPROVER_DUMP_L28;
              }
              default:
                goto failed;
            }
          }
          default:
            goto failed;
        }

      __CPROVER_DUMP_L28:
        ;
      }

    failed:
      ;
      buf_free(image);
      return 1;

    write:
      ;
      signed int return_value_buf_copy_20;
      return_value_buf_copy_20=buf_copy(image, dst, image->size);
      if(!(return_value_buf_copy_20 == 0))
        goto failed;

      signed int return_value_buf_extend_21;
      return_value_buf_extend_21=buf_extend(dst, (unsigned long int)1);
      if(!(return_value_buf_extend_21 == 0))
        goto failed;

      tmp_post_22 = dst->offset;
      dst->offset = dst->offset + 1ul;
      dst->buffer[(signed long int)tmp_post_22] = (char)0x3b;
      buf_free(image);
      return 0;
    }
  }
}

// gif_deanimate_response
// file filters.c line 1949
static char * gif_deanimate_response(struct client_state *csp)
{
  struct binbuffer *in;
  struct binbuffer *out;
  char *p;
  unsigned long int size = (unsigned long int)(csp->iob[0l].eod - csp->iob[0l].cur);
  void *return_value_zalloc_1;
  return_value_zalloc_1=zalloc(sizeof(struct binbuffer) /*24ul*/ );
  in = (struct binbuffer *)return_value_zalloc_1;
  _Bool tmp_if_expr_3;
  void *return_value_zalloc_2;
  if(in == ((struct binbuffer *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_zalloc_2=zalloc(sizeof(struct binbuffer) /*24ul*/ );
    out = (struct binbuffer *)return_value_zalloc_2;
    tmp_if_expr_3 = (struct binbuffer *)(void *)0 == out ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
  {
    log_error(0x0100, "failed! (no mem)");
    return (char *)(void *)0;
  }

  else
  {
    in->buffer = csp->iob[0l].cur;
    in->size = size;
    signed int return_value_strncmp_4;
    return_value_strncmp_4=strncmp("last", csp->action[0l].string[(signed long int)0], (unsigned long int)4);
    signed int return_value_gif_deanimate_5;
    return_value_gif_deanimate_5=gif_deanimate(in, out, return_value_strncmp_4);
    if(!(return_value_gif_deanimate_5 == 0))
    {
      log_error(0x0100, "failed! (gif parsing)");
      if(!(in == ((struct binbuffer *)NULL)))
      {
        free((void *)in);
        in = (struct binbuffer *)(void *)0;
      }

      buf_free(out);
      return (char *)(void *)0;
    }

    else
    {
      if((unsigned long int)(signed int)size == out->offset)
        log_error(0x0100, "GIF not changed.");

      else
        log_error(0x0100, "Success! GIF shrunk from %d bytes to %d.", size, out->offset);
      csp->content_length = out->offset;
      csp->flags = csp->flags | 0x08U;
      p = out->buffer;
      if(!(in == ((struct binbuffer *)NULL)))
      {
        free((void *)in);
        in = (struct binbuffer *)(void *)0;
      }

      if(!(out == ((struct binbuffer *)NULL)))
      {
        free((void *)out);
        out = (struct binbuffer *)(void *)0;
      }

      return p;
    }
  }
}

// gif_extract_image
// file deanimate.c line 250
static signed int gif_extract_image(struct binbuffer *src, struct binbuffer *dst)
{
  unsigned char c;
  c=buf_getbyte(src, (unsigned long int)9);
  signed int return_value_buf_copy_1;
  return_value_buf_copy_1=buf_copy(src, dst, (unsigned long int)10);
  if(!(return_value_buf_copy_1 == 0))
    return 1;

  else
  {
    if(!((0x80 & (signed int)c) == 0))
    {
      signed int map_length = 3 * (1 << ((signed int)c & 0x07) + 1);
      if(!(map_length >= 1))
      {
        log_error(0x0100, "colormap length = %d (%c)?", map_length, c);
        return 1;
      }

      signed int return_value_buf_copy_2;
      return_value_buf_copy_2=buf_copy(src, dst, (unsigned long int)map_length);
      if(!(return_value_buf_copy_2 == 0))
        return 1;

    }

    signed int return_value_buf_copy_3;
    return_value_buf_copy_3=buf_copy(src, dst, (unsigned long int)1);
    if(!(return_value_buf_copy_3 == 0))
      return 1;

    else
    {
      do
      {
        c=buf_getbyte(src, (unsigned long int)0);
        if((signed int)c == 0)
          break;

        signed int return_value_buf_copy_4;
        return_value_buf_copy_4=buf_copy(src, dst, (unsigned long int)1 + (unsigned long int)c);
        if(!(return_value_buf_copy_4 == 0))
          return 1;

      }
      while((_Bool)1);
      signed int return_value_buf_copy_5;
      return_value_buf_copy_5=buf_copy(src, dst, (unsigned long int)1);
      if(!(return_value_buf_copy_5 == 0))
        return 1;

      else
      {
        void *return_value_realloc_6;
        return_value_realloc_6=realloc((void *)dst->buffer, dst->offset);
        dst->buffer = (char *)return_value_realloc_6;
        if(dst->buffer == ((char *)NULL))
          return 1;

        else
        {
          dst->size = dst->offset;
          dst->offset = (unsigned long int)0;
          return 0;
        }
      }
    }
  }
}

// gif_skip_data_block
// file deanimate.c line 210
static signed int gif_skip_data_block(struct binbuffer *buf)
{
  unsigned char c;
  do
  {
    c=buf_getbyte(buf, (unsigned long int)0);
    if((signed int)c == 0)
      break;

    buf->offset = buf->offset + (unsigned long int)c + (unsigned long int)1;
    if(buf->offset >= buf->size + 18446744073709551615ul)
      return 1;

  }
  while((_Bool)1);
  buf->offset = buf->offset + 1ul;
  return 0;
}

// grep_cgi_referrer
// file cgi.c line 391
static char * grep_cgi_referrer(struct client_state *csp)
{
  struct list_entry *p = csp->headers[0l].first;
  for( ; !(p == ((struct list_entry *)NULL)); p = p->next)
    if(!(p->str == ((char *)NULL)))
    {
      signed int return_value_strncmpic_1;
      return_value_strncmpic_1=strncmpic(p->str, "Referer: ", (unsigned long int)9);
      if(return_value_strncmpic_1 == 0)
        return p->str + (signed long int)9;

    }

  return (char *)(void *)0;
}

// handle_conditional_hide_referrer_parameter
// file parsers.c line 4568
static enum privoxy_err handle_conditional_hide_referrer_parameter(char **header, const char *host, const signed int parameter_conditional_block)
{
  char *referer;
  referer=strdup_or_die(*header);
  unsigned long int hostlength;
  hostlength=strlen(host);
  const char *referer_url = (const char *)(void *)0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(referer);
  if(!(17ul + hostlength >= return_value_strlen_1))
    referer[(signed long int)(hostlength + (unsigned long int)17)] = (char)0;

  referer_url=strstr(referer, "http://");
  _Bool tmp_if_expr_4;
  char *return_value_strstr_3;
  if(referer_url == ((const char *)NULL))
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_strstr_3=strstr(referer_url, host);
    tmp_if_expr_4 = (char *)(void *)0 == return_value_strstr_3 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_4)
  {
    if(!(parameter_conditional_block == 0))
    {
      log_error(0x0008, "New host is: %s. Crunching %s!", host, *header);
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

    }

    else
    {
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

      if(!(referer == ((char *)NULL)))
      {
        free((void *)referer);
        referer = (char *)(void *)0;
      }

      enum privoxy_err return_value_create_forged_referrer_2;
      return_value_create_forged_referrer_2=create_forged_referrer(header, host);
      return return_value_create_forged_referrer_2;
    }
  }

  if(!(referer == ((char *)NULL)))
  {
    free((void *)referer);
    referer = (char *)(void *)0;
  }

  return (enum privoxy_err)JB_ERR_OK;
}

// hash_string
// file miscutil.h line 56
extern unsigned int hash_string(const char *s)
{
  unsigned int h = (unsigned int)0;
  for( ; !(*s == 0); s = s + 1l)
    h = (unsigned int)5 * h + (unsigned int)*s;
  return h;
}

// header_tagger
// file parsers.c line 1285
static enum privoxy_err header_tagger(struct client_state *csp, char *header)
{
  enum filter_type wanted_filter_type;
  signed int multi_action_index;
  struct PCRS_JOB *job;
  struct re_filterfile_spec *b;
  struct list_entry *tag_name;
  unsigned long int header_length;
  header_length=strlen(header);
  if(!((0x00000100U & csp->flags) == 0u))
  {
    wanted_filter_type = (enum filter_type)FT_SERVER_HEADER_TAGGER;
    multi_action_index = 5;
  }

  else
  {
    wanted_filter_type = (enum filter_type)FT_CLIENT_HEADER_TAGGER;
    multi_action_index = 4;
  }
  signed int return_value_list_is_empty_1;
  return_value_list_is_empty_1=list_is_empty(csp->action[0l].multi[(signed long int)multi_action_index]);
  _Bool tmp_if_expr_3;
  signed int return_value_filters_available_2;
  if(!(return_value_list_is_empty_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_filters_available_2=filters_available(csp);
    tmp_if_expr_3 = return_value_filters_available_2 == 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
    return (enum privoxy_err)JB_ERR_OK;

  else
  {
    tag_name = csp->action[0l].multi[(signed long int)multi_action_index][0l].first;
    for( ; !(tag_name == ((struct list_entry *)NULL)); tag_name = tag_name->next)
    {
      char *modified_tag = (char *)(void *)0;
      char *tag = header;
      unsigned long int size = header_length;
      struct PCRS_JOB *joblist;
      b=get_filter(csp, tag_name->str, wanted_filter_type);
      if(!(b == ((struct re_filterfile_spec *)NULL)))
      {
        joblist = b->joblist;
        if(!(b->dynamic == 0))
          joblist=compile_dynamic_pcrs_job_list(csp, b);

        if(joblist == ((struct PCRS_JOB *)NULL))
          log_error(0x0040, "Tagger %s has empty joblist. Nothing to do.", b->name);

        else
        {
          job = joblist;
          for( ; !(job == ((struct PCRS_JOB *)NULL)); job = job->next)
          {
            signed int hits;
            hits=pcrs_execute(job, tag, size, &modified_tag, &size);
            if(hits >= 1)
            {
              if(!(tag == header))
              {
                if(!(tag == ((char *)NULL)))
                {
                  free((void *)tag);
                  tag = (char *)(void *)0;
                }

              }

              tag = modified_tag;
            }

            else
            {
              if(!(hits >= 0))
              {
                /* assertion ((void *)0) != header */
                assert((char *)(void *)0 != header);
                const char *return_value_pcrs_strerror_4;
                return_value_pcrs_strerror_4=pcrs_strerror(hits);
                log_error(0x2000, "Problems with tagger '%s' and header '%s': %s", b->name, *header, return_value_pcrs_strerror_4);
              }

              if(!(modified_tag == ((char *)NULL)))
              {
                free((void *)modified_tag);
                modified_tag = (char *)(void *)0;
              }

            }
          }
          if(!(b->dynamic == 0))
            pcrs_free_joblist(joblist);

          if(!(tag == header))
          {
            if(size == 0ul)
            {
              if(!(tag == ((char *)NULL)))
              {
                free((void *)tag);
                tag = (char *)(void *)0;
              }

              log_error(0x1000, "Tagger '%s' created an empty tag. Ignored.", b->name);
              goto __CPROVER_DUMP_L27;
            }

            signed int return_value_list_contains_item_7;
            return_value_list_contains_item_7=list_contains_item(csp->tags, tag);
            if(return_value_list_contains_item_7 == 0)
            {
              enum privoxy_err return_value_enlist_6;
              return_value_enlist_6=enlist(csp->tags, tag);
              if(!((signed int)return_value_enlist_6 == JB_ERR_OK))
                log_error(0x2000, "Insufficient memory to add tag '%s', based on tagger '%s' and header '%s'", tag, b->name, *header);

              else
              {
                char *action_message;
                signed int return_value_update_action_bits_for_tag_5;
                return_value_update_action_bits_for_tag_5=update_action_bits_for_tag(csp, tag);
                if(!(return_value_update_action_bits_for_tag_5 == 0))
                  action_message = "Action bits updated accordingly.";

                else
                  action_message = "No action bits update necessary.";
                log_error(0x0008, "Tagger '%s' added tag '%s'. %s", b->name, tag, action_message);
              }
            }

            else
              log_error(0x0008, "Tagger '%s' didn't add tag '%s'. Tag already present", b->name, tag);
            if(!(tag == ((char *)NULL)))
            {
              free((void *)tag);
              tag = (char *)(void *)0;
            }

          }

        }
      }


    __CPROVER_DUMP_L27:
      ;
    }
    return (enum privoxy_err)JB_ERR_OK;
  }
}

// host_matches
// file urlmatch.c line 1281
static signed int host_matches(struct http_request *http, struct pattern_spec *pattern)
{
  /* assertion http->host != ((void *)0) */
  assert(http->host != (char *)(void *)0);
  _Bool tmp_if_expr_2;
  signed int return_value_domain_match_1;
  if(pattern->pattern.url_spec.dbuffer == ((char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_domain_match_1=domain_match(pattern, http);
    tmp_if_expr_2 = 0 == return_value_domain_match_1 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr_2;
}

// html_encode
// file encode.h line 39
extern char * html_encode(const char *s)
{
  char *buf;
  unsigned long int buf_size;
  const char *tmp_post_3;
  char *tmp_post_5;
  if(s == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(s);
    buf_size = return_value_strlen_1 * (unsigned long int)6 + (unsigned long int)1;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(buf_size);
    buf = (char *)return_value_malloc_2;
    if(!(buf == ((char *)NULL)))
    {
      char c;
      char *p = buf;
      do
      {
        tmp_post_3 = s;
        s = s + 1l;
        c = *tmp_post_3;
        if((signed int)c == 0)
          break;

        const char *replace_with = html_code_map[(signed long int)(unsigned char)c];
        if(!(replace_with == ((const char *)NULL)))
        {
          const unsigned long int bytes_written = (unsigned long int)(p - buf);
          /* assertion bytes_written < buf_size */
          assert(bytes_written < buf_size);
          unsigned long int return_value_privoxy_strlcpy_4;
          return_value_privoxy_strlcpy_4=privoxy_strlcpy(p, replace_with, buf_size - bytes_written);
          p = p + (signed long int)return_value_privoxy_strlcpy_4;
        }

        else
        {
          tmp_post_5 = p;
          p = p + 1l;
          *tmp_post_5 = c;
        }
      }
      while((_Bool)1);
      *p = (char)0;
      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(buf);
      /* assertion strlen(buf) < buf_size */
      assert(return_value_strlen_6 < buf_size);
    }

    return buf;
  }
}

// html_encode_and_free_original
// file encode.h line 43
extern char * html_encode_and_free_original(char *s)
{
  char *result;
  if(s == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    result=html_encode(s);
    free((void *)s);
    return result;
  }
}

// init_action
// file actions.c line 709
extern void init_action(struct action_spec *dest)
{
  memset((void *)dest, 0, sizeof(struct action_spec) /*424ul*/ );
}

// init_current_action
// file actions.c line 689
extern void init_current_action(struct current_action_spec *dest)
{
  memset((void *)dest, 0, sizeof(struct current_action_spec) /*272ul*/ );
  dest->flags = 0x00000000UL;
}

// init_domain_components
// file urlmatch.h line 43
extern enum privoxy_err init_domain_components(struct http_request *http)
{
  char *vec[5000l];
  unsigned long int size;
  char *p;
  http->dbuffer=strdup_or_die(http->host);
  p = http->dbuffer;
  for( ; !(*p == 0); p = p + 1l)
  {
    signed int return_value_tolower_1;
    return_value_tolower_1=tolower((signed int)(unsigned char)*p);
    *p = (char)return_value_tolower_1;
  }
  http->dcount=ssplit(http->dbuffer, ".", vec, sizeof(char *[5000l]) /*40000ul*/  / sizeof(char *) /*8ul*/ );
  if(!(http->dcount >= 1))
  {
    log_error(0x2000, "More than SZ(vec) components in domain or none at all.");
    return (enum privoxy_err)JB_ERR_PARSE;
  }

  else
  {
    size = (unsigned long int)http->dcount * sizeof(char *) /*8ul*/ ;
    void *return_value_malloc_or_die_2;
    return_value_malloc_or_die_2=malloc_or_die(size);
    http->dvec = (char **)return_value_malloc_or_die_2;
    memcpy((void *)http->dvec, (const void *)vec, size);
    return (enum privoxy_err)JB_ERR_OK;
  }
}

// init_error_log
// file errlog.c line 309
extern void init_error_log(const char *prog_name, const char *logfname)
{
  struct _IO_FILE *fp;
  /* assertion ((void *)0) != logfname */
  assert((const char *)(void *)0 != logfname);
  lock_loginit();
  if(!(logfp == ((struct _IO_FILE *)NULL)) && !(logfp == stderr))
    log_error(0x1000, "(Re-)Opening logfile '%s'", logfname);

  fp=fopen(logfname, "a");
  if(fp == ((struct _IO_FILE *)NULL) && !(logfp == ((struct _IO_FILE *)NULL)))
  {
    log_error(0x1000, "Failed to reopen logfile: '%s'. Retrying after closing the old file descriptor first. If that doesn't work, Privoxy will exit without being able to log a message.", logfname);
    lock_logfile();
    fclose(logfp);
    logfp = (struct _IO_FILE *)(void *)0;
    unlock_logfile();
    fp=fopen(logfname, "a");
  }

  if(fp == ((struct _IO_FILE *)NULL))
    log_error(0x4000, "init_error_log(): can't open logfile: '%s'", logfname);

  mark_socket_for_close_on_execute(3);
  setbuf(fp, (char *)(void *)0);
  lock_logfile();
  if(!(logfp == ((struct _IO_FILE *)NULL)))
    fclose(logfp);

  if(logfp == stderr && !(daemon_mode == 0))
  {
    signed int return_value_dup2_1;
    return_value_dup2_1=dup2(1, 2);
    if(return_value_dup2_1 == -1)
      fatal_error("Failed to reserve fd 2.");

  }

  logfp = fp;
  unlock_logfile();
  show_version(prog_name);
  unlock_loginit();
}

// init_list
// file list.h line 48
extern void init_list(struct list *the_list)
{
  memset((void *)the_list, 0, sizeof(struct list) /*16ul*/ );
}

// init_log_module
// file errlog.c line 221
extern void init_log_module(void)
{
  lock_logfile();
  logfp = stderr;
  unlock_logfile();
  set_debug_level(debug);
}

// initialize_mutexes
// file jcc.c line 3237
static void initialize_mutexes(void)
{
  privoxy_mutex_init(&log_mutex);
  privoxy_mutex_init(&log_init_mutex);
  privoxy_mutex_init(&connection_reuse_mutex);
  privoxy_mutex_init(&external_filter_mutex);
}

// initialize_reusable_connections
// file gateway.c line 154
extern void initialize_reusable_connections(void)
{
  unsigned int slot = (unsigned int)0;
  slot = (unsigned int)0;
  for( ; !((unsigned long int)slot >= 100ul); slot = slot + 1u)
    mark_connection_closed(&reusable_connection[(signed long int)slot]);
  log_error(0x0002, "Initialized %d socket slots.", slot);
}

// is_hex_sequence
// file pcrs.c line 936
static signed int is_hex_sequence(const char *sequence)
{
  _Bool tmp_if_expr_1;
  if((signed int)*sequence == 92)
    tmp_if_expr_1 = (signed int)sequence[(signed long int)1] == 120 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  signed int return_value_toupper_2;
  char *return_value_strchr_3;
  if(tmp_if_expr_1)
  {
    if(!(sequence[2l] == 0))
    {
      return_value_toupper_2=toupper((signed int)sequence[(signed long int)2]);
      return_value_strchr_3=strchr("0123456789ABCDEF", return_value_toupper_2);
      tmp_if_expr_4 = return_value_strchr_3 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_5 = (_Bool)0;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  signed int return_value_toupper_6;
  char *return_value_strchr_7;
  if(tmp_if_expr_5)
  {
    if(!(sequence[3l] == 0))
    {
      return_value_toupper_6=toupper((signed int)sequence[(signed long int)3]);
      return_value_strchr_7=strchr("0123456789ABCDEF", return_value_toupper_6);
      tmp_if_expr_8 = return_value_strchr_7 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    tmp_if_expr_9 = tmp_if_expr_8 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_9 = (_Bool)0;
  return (signed int)tmp_if_expr_9;
}

// is_imageurl
// file filters.c line 1334
extern signed int is_imageurl(struct client_state *csp)
{
  return (signed int)((csp->action[0l].flags & 0x00000100UL) != (unsigned long int)0);
}

// is_untrusted_url
// file filters.c line 1381
extern signed int is_untrusted_url(struct client_state *csp)
{
  struct file_list *fl;
  struct block_spec *b;
  struct pattern_spec **trusted_url;
  struct http_request rhttp[1l];
  const char *referer;
  enum privoxy_err err;
  fl = csp->tlist;
  _Bool tmp_if_expr_1;
  if(fl == ((struct file_list *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    b = (struct block_spec *)fl->f;
    tmp_if_expr_1 = b == (struct block_spec *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1)
    return 0;

  else
  {
    memset((void *)rhttp, 0, sizeof(struct http_request) /*120ul*/ );
    b = b->next;
    for( ; !(b == ((struct block_spec *)NULL)); b = b->next)
    {
      signed int return_value_url_match_2;
      return_value_url_match_2=url_match(b->url, csp->http);
      if(!(return_value_url_match_2 == 0))
        return b->reject;

    }
    referer=get_header_value(csp->headers, "Referer:");
    if(referer == ((const char *)NULL))
      return 1;

    else
    {
      err=parse_http_url(referer, rhttp, 1);
      if(!(err == /*enum*/JB_ERR_OK))
        return 1;

      else
      {
        trusted_url = csp->config->trust_list;
        for( ; !(*trusted_url == ((struct pattern_spec *)NULL)); trusted_url = trusted_url + 1l)
        {
          signed int return_value_url_match_4;
          return_value_url_match_4=url_match(*trusted_url, rhttp);
          if(!(return_value_url_match_4 == 0))
          {
            struct _IO_FILE *fp;
            fp=fopen(csp->config->trustfile, "a");
            if(!(fp == ((struct _IO_FILE *)NULL)))
            {
              char *path;
              char *path_end;
              char *new_entry;
              new_entry=strdup_or_die("~");
              string_append(&new_entry, csp->http[0l].hostport);
              path = csp->http[0l].path;
              if((signed int)*path == 47)
              {
                if((signed int)path[1l] == 126)
                {
                  path_end=strchr(path + (signed long int)2, 47);
                  if(!(path_end == ((char *)NULL)))
                  {
                    signed long int path_len = path_end - path;
                    path=strdup(path);
                    if(!(path == ((char *)NULL)))
                    {
                      path_end = path + path_len;
                      path_end[(signed long int)1] = (char)0;
                    }

                    string_join(&new_entry, path);
                  }

                }

              }

              string_append(&new_entry, " # Trusted referrer was: ");
              string_append(&new_entry, referer);
              if(!(new_entry == ((char *)NULL)))
              {
                signed int return_value_fprintf_3;
                return_value_fprintf_3=fprintf(fp, "%s\n", new_entry);
                if(return_value_fprintf_3 == -1)
                  log_error(0x2000, "Failed to append '%s' to trustfile '%s': %E", new_entry, csp->config->trustfile);

                if(!(new_entry == ((char *)NULL)))
                {
                  free((void *)new_entry);
                  new_entry = (char *)(void *)0;
                }

              }

              else
                log_error(0x2000, "Out of memory adding pattern to trust file");
              fclose(fp);
            }

            else
              log_error(0x2000, "Failed to append new entry for '%s' to trustfile '%s': %E", csp->http[0l].hostport, csp->config->trustfile);
            return 0;
          }

        }
        return 1;
      }
    }
  }
}

// javascriptify
// file cgiedit.c line 4099
static void javascriptify(char *identifier)
{
  char *p = identifier;
  char *tmp_post_1;
  do
  {
    p=strchr(p, 45);
    if(p == ((char *)NULL))
      break;

    tmp_post_1 = p;
    p = p + 1l;
    *tmp_post_1 = (char)95;
  }
  while((_Bool)1);
}

// jb_err_to_string
// file errlog.c line 986
extern const char * jb_err_to_string(signed int jb_error)
{
  switch(jb_error)
  {
    case JB_ERR_OK:
      return "Success, no error";
    case JB_ERR_MEMORY:
      return "Out of memory";
    case JB_ERR_CGI_PARAMS:
      return "Missing or corrupt CGI parameters";
    case JB_ERR_FILE:
      return "Error opening, reading or writing a file";
    case JB_ERR_PARSE:
      return "Parse error";
    case JB_ERR_MODIFIED:
      return "File has been modified outside of the CGI actions editor.";
    case JB_ERR_COMPRESS:
      return "(De)compression failure";
    default:
    {
      /* assertion 0 */
      assert(0 != 0);
      return "Internal error";
    }
  }
}

// list_append_list_unique
// file list.h line 55
extern enum privoxy_err list_append_list_unique(struct list *dest, struct list *src)
{
  struct list_entry *cur;
  /* assertion src */
  assert(src != ((struct list *)NULL));
  /* assertion dest */
  assert(dest != ((struct list *)NULL));
  signed int return_value_list_is_valid_1;
  return_value_list_is_valid_1=list_is_valid(src);
  /* assertion list_is_valid(src) */
  assert(return_value_list_is_valid_1 != 0);
  signed int return_value_list_is_valid_2;
  return_value_list_is_valid_2=list_is_valid(dest);
  /* assertion list_is_valid(dest) */
  assert(return_value_list_is_valid_2 != 0);
  cur = src->first;
  for( ; !(cur == ((struct list_entry *)NULL)); cur = cur->next)
    if(!(cur->str == ((char *)NULL)))
    {
      enum privoxy_err return_value_enlist_unique_5;
      return_value_enlist_unique_5=enlist_unique(dest, cur->str, (unsigned long int)0);
      if(!(return_value_enlist_unique_5 == /*enum*/JB_ERR_OK))
      {
        signed int return_value_list_is_valid_3;
        return_value_list_is_valid_3=list_is_valid(src);
        /* assertion list_is_valid(src) */
        assert(return_value_list_is_valid_3 != 0);
        signed int return_value_list_is_valid_4;
        return_value_list_is_valid_4=list_is_valid(dest);
        /* assertion list_is_valid(dest) */
        assert(return_value_list_is_valid_4 != 0);
        return (enum privoxy_err)JB_ERR_MEMORY;
      }

    }

  signed int return_value_list_is_valid_6;
  return_value_list_is_valid_6=list_is_valid(src);
  /* assertion list_is_valid(src) */
  assert(return_value_list_is_valid_6 != 0);
  signed int return_value_list_is_valid_7;
  return_value_list_is_valid_7=list_is_valid(dest);
  /* assertion list_is_valid(dest) */
  assert(return_value_list_is_valid_7 != 0);
  return (enum privoxy_err)JB_ERR_OK;
}

// list_contains_item
// file list.h line 66
extern signed int list_contains_item(struct list *the_list, const char *str)
{
  struct list_entry *entry;
  /* assertion the_list */
  assert(the_list != ((struct list *)NULL));
  signed int return_value_list_is_valid_1;
  return_value_list_is_valid_1=list_is_valid(the_list);
  /* assertion list_is_valid(the_list) */
  assert(return_value_list_is_valid_1 != 0);
  /* assertion str */
  assert(str != ((const char *)NULL));
  entry = the_list->first;
  for( ; !(entry == ((struct list_entry *)NULL)); entry = entry->next)
    if(!(entry->str == ((char *)NULL)))
    {
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(str, entry->str);
      if(return_value_strcmp_2 == 0)
        return 1;

    }

  return 0;
}

// list_duplicate
// file list.h line 56
extern enum privoxy_err list_duplicate(struct list *dest, struct list *src)
{
  struct list_entry *cur_src;
  struct list_entry *cur_dest;
  /* assertion src */
  assert(src != ((struct list *)NULL));
  /* assertion dest */
  assert(dest != ((struct list *)NULL));
  signed int return_value_list_is_valid_1;
  return_value_list_is_valid_1=list_is_valid(src);
  /* assertion list_is_valid(src) */
  assert(return_value_list_is_valid_1 != 0);
  signed int return_value_list_is_valid_2;
  return_value_list_is_valid_2=list_is_valid(dest);
  /* assertion list_is_valid(dest) */
  assert(return_value_list_is_valid_2 != 0);
  list_remove_all(dest);
  cur_src = src->first;
  if(!(cur_src == ((struct list_entry *)NULL)))
  {
    void *return_value_zalloc_3;
    return_value_zalloc_3=zalloc(sizeof(struct list_entry) /*16ul*/ );
    dest->first = (struct list_entry *)return_value_zalloc_3;
    cur_dest = dest->first;
    if(cur_dest == ((struct list_entry *)NULL))
    {
      destroy_list(dest);
      signed int return_value_list_is_valid_4;
      return_value_list_is_valid_4=list_is_valid(src);
      /* assertion list_is_valid(src) */
      assert(return_value_list_is_valid_4 != 0);
      signed int return_value_list_is_valid_5;
      return_value_list_is_valid_5=list_is_valid(dest);
      /* assertion list_is_valid(dest) */
      assert(return_value_list_is_valid_5 != 0);
      return (enum privoxy_err)JB_ERR_MEMORY;
    }

    if(!(cur_src->str == ((char *)NULL)))
    {
      cur_dest->str=strdup(cur_src->str);
      if(cur_dest->str == ((char *)NULL))
      {
        destroy_list(dest);
        signed int return_value_list_is_valid_6;
        return_value_list_is_valid_6=list_is_valid(src);
        /* assertion list_is_valid(src) */
        assert(return_value_list_is_valid_6 != 0);
        signed int return_value_list_is_valid_7;
        return_value_list_is_valid_7=list_is_valid(dest);
        /* assertion list_is_valid(dest) */
        assert(return_value_list_is_valid_7 != 0);
        return (enum privoxy_err)JB_ERR_MEMORY;
      }

    }

    cur_src = cur_src->next;
    for( ; !(cur_src == ((struct list_entry *)NULL)); cur_src = cur_src->next)
    {
      void *return_value_zalloc_8;
      return_value_zalloc_8=zalloc(sizeof(struct list_entry) /*16ul*/ );
      cur_dest->next = (struct list_entry *)return_value_zalloc_8;
      cur_dest = cur_dest->next;
      if(cur_dest == ((struct list_entry *)NULL))
      {
        destroy_list(dest);
        signed int return_value_list_is_valid_9;
        return_value_list_is_valid_9=list_is_valid(src);
        /* assertion list_is_valid(src) */
        assert(return_value_list_is_valid_9 != 0);
        signed int return_value_list_is_valid_10;
        return_value_list_is_valid_10=list_is_valid(dest);
        /* assertion list_is_valid(dest) */
        assert(return_value_list_is_valid_10 != 0);
        return (enum privoxy_err)JB_ERR_MEMORY;
      }

      if(!(cur_src->str == ((char *)NULL)))
      {
        cur_dest->str=strdup(cur_src->str);
        if(cur_dest->str == ((char *)NULL))
        {
          destroy_list(dest);
          signed int return_value_list_is_valid_11;
          return_value_list_is_valid_11=list_is_valid(src);
          /* assertion list_is_valid(src) */
          assert(return_value_list_is_valid_11 != 0);
          signed int return_value_list_is_valid_12;
          return_value_list_is_valid_12=list_is_valid(dest);
          /* assertion list_is_valid(dest) */
          assert(return_value_list_is_valid_12 != 0);
          return (enum privoxy_err)JB_ERR_MEMORY;
        }

      }

    }
    dest->last = cur_dest;
  }

  signed int return_value_list_is_valid_13;
  return_value_list_is_valid_13=list_is_valid(src);
  /* assertion list_is_valid(src) */
  assert(return_value_list_is_valid_13 != 0);
  signed int return_value_list_is_valid_14;
  return_value_list_is_valid_14=list_is_valid(dest);
  /* assertion list_is_valid(dest) */
  assert(return_value_list_is_valid_14 != 0);
  return (enum privoxy_err)JB_ERR_OK;
}

// list_is_empty
// file list.h line 62
extern signed int list_is_empty(struct list *the_list)
{
  /* assertion the_list */
  assert(the_list != ((struct list *)NULL));
  signed int return_value_list_is_valid_1;
  return_value_list_is_valid_1=list_is_valid(the_list);
  /* assertion list_is_valid(the_list) */
  assert(return_value_list_is_valid_1 != 0);
  return (signed int)(the_list->first == (struct list_entry *)(void *)0);
}

// list_is_valid
// file list.c line 147
static signed int list_is_valid(struct list *the_list)
{
  struct list_entry *cur_entry;
  struct list_entry *last_entry = (struct list_entry *)(void *)0;
  signed int entry = 0;
  /* assertion the_list */
  assert(the_list != ((struct list *)NULL));
  cur_entry = the_list->first;
  signed int tmp_post_1;
  for( ; !(cur_entry == ((struct list_entry *)NULL)); cur_entry = cur_entry->next)
  {
    last_entry = cur_entry;
    if(!(cur_entry->str == ((char *)NULL)))
      strlen(cur_entry->str);

    tmp_post_1 = entry;
    entry = entry + 1;
    if(!(tmp_post_1 == 0))
    {
      if(cur_entry == the_list->first)
        return 0;

    }

    if(the_list->last == cur_entry)
    {
      if(!(cur_entry->next == ((struct list_entry *)NULL)))
        return 0;

    }

  }
  return (signed int)(the_list->last == last_entry);
}

// list_remove_all
// file list.h line 60
extern void list_remove_all(struct list *the_list)
{
  struct list_entry *cur_entry;
  struct list_entry *next_entry;
  /* assertion the_list */
  assert(the_list != ((struct list *)NULL));
  signed int return_value_list_is_valid_1;
  return_value_list_is_valid_1=list_is_valid(the_list);
  /* assertion list_is_valid(the_list) */
  assert(return_value_list_is_valid_1 != 0);
  cur_entry = the_list->first;
  for( ; !(cur_entry == ((struct list_entry *)NULL)); cur_entry = next_entry)
  {
    next_entry = cur_entry->next;
    if(!(cur_entry->str == ((char *)NULL)))
    {
      free((void *)cur_entry->str);
      cur_entry->str = (char *)(void *)0;
    }

    free((void *)cur_entry);
  }
  the_list->last = (struct list_entry *)(void *)0;
  the_list->first = the_list->last;
  signed int return_value_list_is_valid_2;
  return_value_list_is_valid_2=list_is_valid(the_list);
  /* assertion list_is_valid(the_list) */
  assert(return_value_list_is_valid_2 != 0);
}

// list_remove_item
// file list.h line 58
extern signed int list_remove_item(struct list *the_list, const char *str)
{
  struct list_entry *prev = (struct list_entry *)(void *)0;
  struct list_entry *cur;
  struct list_entry *next;
  signed int count = 0;
  /* assertion the_list */
  assert(the_list != ((struct list *)NULL));
  signed int return_value_list_is_valid_1;
  return_value_list_is_valid_1=list_is_valid(the_list);
  /* assertion list_is_valid(the_list) */
  assert(return_value_list_is_valid_1 != 0);
  /* assertion str */
  assert(str != ((const char *)NULL));
  cur = the_list->first;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  while(!(cur == ((struct list_entry *)NULL)))
  {
    next = cur->next;
    if(!(cur->str == ((char *)NULL)))
    {
      return_value_strcmp_2=strcmp(str, cur->str);
      tmp_if_expr_3 = 0 == return_value_strcmp_2 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      count = count + 1;
      if(!(prev == ((struct list_entry *)NULL)))
        prev->next = next;

      else
        the_list->first = next;
      free((void *)(char *)cur->str);
      free((void *)cur);
    }

    else
      prev = cur;
    cur = next;
  }
  the_list->last = prev;
  signed int return_value_list_is_valid_4;
  return_value_list_is_valid_4=list_is_valid(the_list);
  /* assertion list_is_valid(the_list) */
  assert(return_value_list_is_valid_4 != 0);
  return count;
}

// list_remove_list
// file list.h line 59
extern signed int list_remove_list(struct list *dest, struct list *src)
{
  struct list_entry *cur;
  signed int count = 0;
  /* assertion src */
  assert(src != ((struct list *)NULL));
  /* assertion dest */
  assert(dest != ((struct list *)NULL));
  signed int return_value_list_is_valid_1;
  return_value_list_is_valid_1=list_is_valid(src);
  /* assertion list_is_valid(src) */
  assert(return_value_list_is_valid_1 != 0);
  signed int return_value_list_is_valid_2;
  return_value_list_is_valid_2=list_is_valid(dest);
  /* assertion list_is_valid(dest) */
  assert(return_value_list_is_valid_2 != 0);
  cur = src->first;
  for( ; !(cur == ((struct list_entry *)NULL)); cur = cur->next)
    if(!(cur->str == ((char *)NULL)))
    {
      signed int return_value_list_remove_item_3;
      return_value_list_remove_item_3=list_remove_item(dest, cur->str);
      count = count + return_value_list_remove_item_3;
    }

  signed int return_value_list_is_valid_4;
  return_value_list_is_valid_4=list_is_valid(src);
  /* assertion list_is_valid(src) */
  assert(return_value_list_is_valid_4 != 0);
  signed int return_value_list_is_valid_5;
  return_value_list_is_valid_5=list_is_valid(dest);
  /* assertion list_is_valid(dest) */
  assert(return_value_list_is_valid_5 != 0);
  return count;
}

// list_to_text
// file list.h line 64
extern char * list_to_text(struct list *the_list)
{
  struct list_entry *cur_entry;
  char *text;
  unsigned long int text_length;
  char *cursor;
  unsigned long int bytes_left;
  /* assertion the_list */
  assert(the_list != ((struct list *)NULL));
  signed int return_value_list_is_valid_1;
  return_value_list_is_valid_1=list_is_valid(the_list);
  /* assertion list_is_valid(the_list) */
  assert(return_value_list_is_valid_1 != 0);
  text_length = (unsigned long int)2;
  cur_entry = the_list->first;
  for( ; !(cur_entry == ((struct list_entry *)NULL)); cur_entry = cur_entry->next)
    if(!(cur_entry->str == ((char *)NULL)))
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(cur_entry->str);
      text_length = text_length + return_value_strlen_2 + (unsigned long int)2;
    }

  bytes_left = text_length + (unsigned long int)1;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(bytes_left);
  text = (char *)return_value_malloc_3;
  char *tmp_post_4;
  char *tmp_post_5;
  if(text == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    cursor = text;
    cur_entry = the_list->first;
    for( ; !(cur_entry == ((struct list_entry *)NULL)); cur_entry = cur_entry->next)
      if(!(cur_entry->str == ((char *)NULL)))
      {
        signed int written;
        written=snprintf(cursor, bytes_left, "%s\r\n", cur_entry->str);
        /* assertion written > 0 */
        assert(written > 0);
        /* assertion written < bytes_left */
        assert((unsigned long int)written < bytes_left);
        bytes_left = bytes_left - (unsigned long int)written;
        cursor = cursor + (signed long int)(unsigned long int)written;
      }

    /* assertion bytes_left == 3 */
    assert(bytes_left == (unsigned long int)3);
    tmp_post_4 = cursor;
    cursor = cursor + 1l;
    *tmp_post_4 = (char)13;
    tmp_post_5 = cursor;
    cursor = cursor + 1l;
    *tmp_post_5 = (char)10;
    *cursor = (char)0;
    /* assertion text_length == cursor - text */
    assert(text_length == (unsigned long int)(cursor - text));
    /* assertion text[text_length] == '\0' */
    assert((signed int)text[(signed long int)text_length] == 0);
    return text;
  }
}

// listen_loop
// file jcc.c line 3917
static void listen_loop(void)
{
  struct client_states *csp_list = (struct client_states *)(void *)0;
  struct client_state *csp = (struct client_state *)(void *)0;
  signed int bfds[10l];
  struct configuration_spec *config;
  unsigned int active_threads = (unsigned int)0;
  config=load_config();
  initialize_reusable_connections();
  bind_ports_helper(config, bfds);
  do
  {
    active_threads=sweep();
    if(!(received_hup_signal == 0))
    {
      if(!(config->logfile == ((const char *)NULL)))
        init_error_log(Argv[(signed long int)0], config->logfile);

      received_hup_signal = 0;
    }

    void *return_value_zalloc_1;
    return_value_zalloc_1=zalloc(sizeof(struct client_states) /*1280ul*/ );
    csp_list = (struct client_states *)return_value_zalloc_1;
    if(csp_list == ((struct client_states *)NULL))
      log_error(0x4000, "malloc(%d) for csp_list failed: %E", sizeof(struct client_states) /*1280ul*/ );

    else
    {
      csp = &csp_list->csp;
      log_error(0x0002, "Waiting for the next client connection. Currently active threads: %d", active_threads);
      signed int return_value_accept_connection_2;
      return_value_accept_connection_2=accept_connection(csp, bfds);
      if(return_value_accept_connection_2 == 0)
      {
        log_error(0x0002, "accept failed: %E");
        if(!(csp_list == ((struct client_states *)NULL)))
        {
          free((void *)csp_list);
          csp_list = (struct client_states *)(void *)0;
        }

      }

      else
      {
        csp->flags = csp->flags | 0x01U;
        csp->server_connection.sfd = -1;
        config=load_config();
        csp->config = config;
        if(!(config->need_bind == 0))
        {
          close_ports_helper(bfds);
          bind_ports_helper(config, bfds);
        }

        if(!(global_toggle_state == 0))
          csp->flags = csp->flags | 0x20U;

        signed int return_value_run_loader_3;
        return_value_run_loader_3=run_loader(csp);
        if(!(return_value_run_loader_3 == 0))
          log_error(0x4000, "a loader failed - must exit");

        signed int return_value_block_acl_4;
        return_value_block_acl_4=block_acl((struct access_control_addr *)(void *)0, csp);
        if(!(return_value_block_acl_4 == 0))
        {
          log_error(0x0002, "Connection from %s on socket %d dropped due to ACL", csp->ip_addr_str, csp->cfd);
          close_socket(csp->cfd);
          if(!(csp->ip_addr_str == ((char *)NULL)))
          {
            free((void *)csp->ip_addr_str);
            csp->ip_addr_str = (char *)(void *)0;
          }

          if(!(csp_list == ((struct client_states *)NULL)))
          {
            free((void *)csp_list);
            csp_list = (struct client_states *)(void *)0;
          }

        }

        else
        {
          if(!(config->max_client_connections == 0))
          {
            if(active_threads >= (unsigned int)config->max_client_connections)
            {
              log_error(0x0002, "Rejecting connection from %s. Maximum number of connections reached.", csp->ip_addr_str);
              unsigned long int return_value_strlen_5;
              return_value_strlen_5=strlen(TOO_MANY_CONNECTIONS_RESPONSE);
              write_socket(csp->cfd, TOO_MANY_CONNECTIONS_RESPONSE, return_value_strlen_5);
              close_socket(csp->cfd);
              if(!(csp->ip_addr_str == ((char *)NULL)))
              {
                free((void *)csp->ip_addr_str);
                csp->ip_addr_str = (char *)(void *)0;
              }

              if(!(csp_list == ((struct client_states *)NULL)))
              {
                free((void *)csp_list);
                csp_list = (struct client_states *)(void *)0;
              }

              continue;
            }

          }

          csp_list->next = clients[0l].next;
          clients[0l].next = csp_list;
          if(!(config->multi_threaded == 0))
          {
            signed int child_id;
            unsigned long int the_thread;
            union pthread_attr_t attrs;
            pthread_attr_init(&attrs);
            pthread_attr_setdetachstate(&attrs, 1);
            signed int *return_value___errno_location_6;
            return_value___errno_location_6=__errno_location();
            *return_value___errno_location_6=pthread_create(&the_thread, &attrs, (void * (*)(void *))serve, (void *)csp);
            signed int *return_value___errno_location_7;
            return_value___errno_location_7=__errno_location();
            child_id = *return_value___errno_location_7 != 0 ? -1 : 0;
            pthread_attr_destroy(&attrs);
            if(!(child_id >= 0))
            {
              log_error(0x2000, "Unable to take any additional connections: %E. Active threads: %d", active_threads);
              unsigned long int return_value_strlen_8;
              return_value_strlen_8=strlen(TOO_MANY_CONNECTIONS_RESPONSE);
              write_socket(csp->cfd, TOO_MANY_CONNECTIONS_RESPONSE, return_value_strlen_8);
              close_socket(csp->cfd);
              csp->flags = csp->flags & ~0x01U;
            }

          }

          else
            serve(csp);
        }
      }
    }
  }
  while((_Bool)1);
}

// load_action_files
// file actions.c line 1057
extern signed int load_action_files(struct client_state *csp)
{
  signed int i;
  signed int result;
  i = 0;
  for( ; !(i >= 30); i = i + 1)
    if(!(csp->config->actions_file[(signed long int)i] == ((const char *)NULL)))
    {
      result=load_one_actions_file(csp, i);
      if(!(result == 0))
        return result;

    }

    else
      if(!(current_actions_file[(signed long int)i] == ((struct file_list *)NULL)))
      {
        current_actions_file[(signed long int)i]->unloader = unload_actions_file;
        current_actions_file[(signed long int)i] = (struct file_list *)(void *)0;
      }

  return 0;
}

// load_config
// file loadcfg.h line 64
extern struct configuration_spec * load_config(void)
{
  char *buf = (char *)(void *)0;
  char *p;
  char *q;
  struct _IO_FILE *configfp = (struct _IO_FILE *)(void *)0;
  struct configuration_spec *config = (struct configuration_spec *)(void *)0;
  struct client_state *fake_csp;
  struct file_list *fs;
  unsigned long int linenum = (unsigned long int)0;
  signed int i;
  char *logfile = (char *)(void *)0;
  signed int return_value_check_file_changed_1;
  return_value_check_file_changed_1=check_file_changed(current_configfile, configfile, &fs);
  char *return_value_read_config_line_3;
  char *tmp_post_4;
  char *tmp_post_5;
  signed int return_value_parse_toggle_state_9;
  signed int return_value_parse_toggle_state_10;
  signed int return_value_parse_numeric_value_11;
  signed int return_value_parse_toggle_state_12;
  signed int return_value_parse_numeric_value_13;
  signed int timeout;
  void *return_value_zalloc_14;
  signed int return_value_acl_addr_15;
  signed int return_value_parse_toggle_state_17;
  signed int return_value_parse_toggle_state_18;
  signed int return_value_parse_toggle_state_19;
  signed int return_value_parse_toggle_state_20;
  signed int return_value_parse_toggle_state_21;
  void *return_value_zalloc_22;
  enum privoxy_err return_value_create_pattern_spec_23;
  signed int return_value_strcmp_24;
  void *return_value_zalloc_25;
  enum privoxy_err return_value_create_pattern_spec_26;
  signed int return_value_strcmp_27;
  signed int return_value_strcmp_28;
  void *return_value_zalloc_29;
  enum privoxy_err return_value_create_pattern_spec_30;
  signed int return_value_strcmp_31;
  signed int return_value_parse_toggle_state_32;
  signed int load_config__1__6__6__49__timeout;
  signed int max_client_connections;
  void *return_value_zalloc_33;
  signed int return_value_acl_addr_34;
  signed int return_value_parse_toggle_state_36;
  signed int socket_timeout;
  signed int return_value_parse_toggle_state_37;
  signed int return_value_parse_toggle_state_38;
  _Bool tmp_if_expr_39;
  _Bool tmp_if_expr_41;
  _Bool tmp_if_expr_42;
  _Bool tmp_if_expr_43;
  _Bool tmp_if_expr_40;
  signed int return_value_strcmp_46;
  if(return_value_check_file_changed_1 == 0)
    return (struct configuration_spec *)current_configfile->f;

  else
    if(fs == ((struct file_list *)NULL))
    {
      log_error(0x4000, "can't check configuration file '%s':  %E", configfile);
      return (struct configuration_spec *)(void *)0;
    }

    else
    {
      if(!(current_configfile == ((struct file_list *)NULL)))
        log_error(0x1000, "Reloading configuration file '%s'", configfile);

      global_toggle_state = 1;
      void *return_value_zalloc_2;
      return_value_zalloc_2=zalloc(sizeof(struct configuration_spec) /*5440ul*/ );
      config = (struct configuration_spec *)return_value_zalloc_2;
      fs->f = (void *)config;
      if(config == ((struct configuration_spec *)NULL))
      {
        if(!(fs->filename == ((char *)NULL)))
        {
          free((void *)fs->filename);
          fs->filename = (char *)(void *)0;
        }

        if(!(fs == ((struct file_list *)NULL)))
        {
          free((void *)fs);
          fs = (struct file_list *)(void *)0;
        }

        log_error(0x4000, "can't allocate memory for configuration");
        return (struct configuration_spec *)(void *)0;
      }

      else
      {
        config->config_file_list = fs;
        config->multi_threaded = 1;
        config->buffer_limit = (unsigned long int)(4096 * 1024);
        config->usermanual=strdup("http://www.privoxy.org/3.0.24/user-manual/");
        config->proxy_args=strdup("");
        config->forwarded_connect_retries = 0;
        config->max_client_connections = 128;
        config->socket_timeout = 300;
        config->default_server_timeout = (unsigned int)0;
        config->keep_alive_timeout = (unsigned int)180;
        config->feature_flags = config->feature_flags & ~128U;
        config->feature_flags = config->feature_flags & ~256U;
        config->feature_flags = config->feature_flags & ~2U;
        config->feature_flags = config->feature_flags & ~8U;
        config->feature_flags = config->feature_flags & ~16U;
        config->feature_flags = config->feature_flags & ~512U;
        config->feature_flags = config->feature_flags & ~4096U;
        config->feature_flags = config->feature_flags & ~2048U;
        configfp=fopen(configfile, "r");
        if(configfp == ((struct _IO_FILE *)NULL))
          log_error(0x4000, "can't open configuration file '%s':  %E", configfile);

        do
        {
          return_value_read_config_line_3=read_config_line(configfp, &linenum, &buf);
          if(return_value_read_config_line_3 == ((char *)NULL))
            break;

          char cmd[5000l];
          char arg[5000l];
          char tmp[5000l];
          struct access_control_list *cur_acl;
          struct forward_spec *cur_fwd;
          signed int vec_count;
          char *vec[3l];
          unsigned int directive_hash;
          privoxy_strlcpy(tmp, buf, sizeof(char [5000l]) /*5000ul*/ );
          p = buf;
          q = cmd;
          for( ; !(*p == 0); *tmp_post_4 = *tmp_post_5)
          {
            if((signed int)*p == 32)
              break;

            if((signed int)*p == 9)
              break;

            tmp_post_4 = q;
            q = q + 1l;
            tmp_post_5 = p;
            p = p + 1l;
          }
          *q = (char)0;
          for( ; !(*p == 0); p = p + 1l)
            if(!((signed int)*p == 32))
            {
              if(!((signed int)*p == 9))
                break;

            }

          unsigned long int return_value_privoxy_strlcpy_6;
          return_value_privoxy_strlcpy_6=privoxy_strlcpy(arg, p, sizeof(char [5000l]) /*5000ul*/ );
          if(return_value_privoxy_strlcpy_6 >= sizeof(char [5000l]) /*5000ul*/ )
            log_error(0x4000, "Config line too long: %s", buf);

          if((signed int)cmd[0l] == 0)
          {
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          }

          else
          {
            p = cmd;
            for( ; !(*p == 0); p = p + 1l)
            {
              const unsigned short int **return_value___ctype_b_loc_8;
              return_value___ctype_b_loc_8=__ctype_b_loc();
              if(!((256 & (signed int)(*return_value___ctype_b_loc_8)[(signed long int)(signed int)(unsigned char)*p]) == 0))
              {
                signed int return_value_tolower_7;
                return_value_tolower_7=tolower((signed int)(unsigned char)*p);
                *p = (char)return_value_tolower_7;
              }

            }
            directive_hash=hash_string(cmd);
            switch(directive_hash)
            {
              case 1196306641U:
              {
                i = 0;
                for( ; !(i >= 30); i = i + 1)
                  if(config->actions_file[(signed long int)i] == ((const char *)NULL))
                    break;

                if(i >= 30)
                  log_error(0x4000, "Too many 'actionsfile' directives in config file - limit is %d.\n(You can increase this limit by changing MAX_AF_FILES in project.h and recompiling).", 30);

                config->actions_file_short[(signed long int)i]=strdup(arg);
                config->actions_file[(signed long int)i]=make_path(config->confdir, arg);
                break;
              }
              case 1513024973U:
              {
                return_value_parse_toggle_state_9=parse_toggle_state(cmd, arg);
                if(return_value_parse_toggle_state_9 == 1)
                  config->feature_flags = config->feature_flags | 16U;

                else
                  config->feature_flags = config->feature_flags & ~16U;
                break;
              }
              case 4112573064U:
              {
                if(!(config->admin_address == ((char *)NULL)))
                {
                  free((void *)config->admin_address);
                  config->admin_address = (char *)(void *)0;
                }

                config->admin_address=strdup(arg);
                break;
              }
              case 258915987U:
              {
                return_value_parse_toggle_state_10=parse_toggle_state(cmd, arg);
                if(return_value_parse_toggle_state_10 == 1)
                  config->feature_flags = config->feature_flags | 64U;

                else
                  config->feature_flags = config->feature_flags & ~64U;
                break;
              }
              case 1881726070U:
              {
                return_value_parse_numeric_value_11=parse_numeric_value(cmd, arg);
                config->buffer_limit = (unsigned long int)(1024 * return_value_parse_numeric_value_11);
                break;
              }
              case 2701453514U:
              {
                list_remove_all(config->ordered_client_headers);
                parse_client_header_order(config->ordered_client_headers, arg);
                break;
              }
              case 1978389U:
              {
                if(!(config->confdir == ((const char *)NULL)))
                {
                  free((void *)config->confdir);
                  config->confdir = (const char *)(void *)0;
                }

                config->confdir=make_path((const char *)(void *)0, arg);
                break;
              }
              case 1348841265U:
              {
                return_value_parse_toggle_state_12=parse_toggle_state(cmd, arg);
                if(return_value_parse_toggle_state_12 == 1)
                  config->feature_flags = config->feature_flags | 256U;

                else
                  config->feature_flags = config->feature_flags & ~256U;
                break;
              }
              case 78263U:
              {
                return_value_parse_numeric_value_13=parse_numeric_value(cmd, arg);
                config->debug = config->debug | return_value_parse_numeric_value_13;
                break;
              }
              case 2530089913U:
              {
                timeout=parse_numeric_value(cmd, arg);
                if(timeout >= 0)
                  config->default_server_timeout = (unsigned int)timeout;

                else
                  log_error(0x4000, "Invalid default-server-timeout value: %s", (const void *)arg);
                break;
              }
              case 1227333715U:
              {
                privoxy_strlcpy(tmp, arg, sizeof(char [5000l]) /*5000ul*/ );
                vec_count=ssplit(tmp, " \t", vec, sizeof(char *[3l]) /*24ul*/  / sizeof(char *) /*8ul*/ );
                if(!(vec_count == 1) && !(vec_count == 2))
                {
                  log_error(0x2000, "Wrong number of parameters for deny-access directive in configuration file.");
                  string_append(&config->proxy_args, "<br>\nWARNING: Wrong number of parameters for deny-access directive in configuration file.<br><br>\n");
                  break;
                }

                return_value_zalloc_14=zalloc(sizeof(struct access_control_list) /*528ul*/ );
                cur_acl = (struct access_control_list *)return_value_zalloc_14;
                if(cur_acl == ((struct access_control_list *)NULL))
                {
                  log_error(0x4000, "can't allocate memory for configuration");
                  break;
                }

                cur_acl->action = (signed short int)2;
                return_value_acl_addr_15=acl_addr(vec[(signed long int)0], cur_acl->src);
                if(!(return_value_acl_addr_15 >= 0))
                {
                  log_error(0x2000, "Invalid source address, port or netmask for deny-access directive in configuration file: \"%s\"", vec[(signed long int)0]);
                  string_append(&config->proxy_args, "<br>\nWARNING: Invalid source address, port or netmask for deny-access directive in configuration file: \"");
                  string_append(&config->proxy_args, vec[(signed long int)0]);
                  string_append(&config->proxy_args, "\"<br><br>\n");
                  if(!(cur_acl == ((struct access_control_list *)NULL)))
                  {
                    free((void *)cur_acl);
                    cur_acl = (struct access_control_list *)(void *)0;
                  }

                  break;
                }

                if(vec_count == 2)
                {
                  signed int return_value_acl_addr_16;
                  return_value_acl_addr_16=acl_addr(vec[(signed long int)1], cur_acl->dst);
                  if(!(return_value_acl_addr_16 >= 0))
                  {
                    log_error(0x2000, "Invalid destination address, port or netmask for deny-access directive in configuration file: \"%s\"", vec[(signed long int)1]);
                    string_append(&config->proxy_args, "<br>\nWARNING: Invalid destination address, port or netmask for deny-access directive in configuration file: \"");
                    string_append(&config->proxy_args, vec[(signed long int)1]);
                    string_append(&config->proxy_args, "\"<br><br>\n");
                    if(!(cur_acl == ((struct access_control_list *)NULL)))
                    {
                      free((void *)cur_acl);
                      cur_acl = (struct access_control_list *)(void *)0;
                    }

                    break;
                  }

                }

                else
                  cur_acl->wildcard_dst = 1;
                cur_acl->next = config->acl;
                config->acl = cur_acl;
                break;
              }
              case 2517097536U:
              {
                return_value_parse_toggle_state_17=parse_toggle_state(cmd, arg);
                if(return_value_parse_toggle_state_17 == 1)
                  config->feature_flags = config->feature_flags | 1U;

                else
                  config->feature_flags = config->feature_flags & ~1U;
                break;
              }
              case 4040610791U:
              {
                return_value_parse_toggle_state_18=parse_toggle_state(cmd, arg);
                if(return_value_parse_toggle_state_18 == 1)
                  config->feature_flags = config->feature_flags | 4096U;

                else
                  config->feature_flags = config->feature_flags & ~4096U;
                break;
              }
              case 2979744683U:
              {
                return_value_parse_toggle_state_19=parse_toggle_state(cmd, arg);
                if(return_value_parse_toggle_state_19 == 1)
                  config->feature_flags = config->feature_flags | 2U;

                else
                  config->feature_flags = config->feature_flags & ~2U;
                break;
              }
              case 110543988U:
              {
                return_value_parse_toggle_state_20=parse_toggle_state(cmd, arg);
                if(return_value_parse_toggle_state_20 == 1)
                  config->feature_flags = config->feature_flags | 4U;

                else
                  config->feature_flags = config->feature_flags & ~4U;
                break;
              }
              case 1862427469U:
              {
                return_value_parse_toggle_state_21=parse_toggle_state(cmd, arg);
                if(return_value_parse_toggle_state_21 == 1)
                  config->feature_flags = config->feature_flags | 32U;

                else
                  config->feature_flags = config->feature_flags & ~32U;
                break;
              }
              case 250887266U:
              {
                i = 0;
                for( ; !(i >= 30); i = i + 1)
                  if(config->re_filterfile[(signed long int)i] == ((const char *)NULL))
                    break;

                if(i >= 30)
                  log_error(0x4000, "Too many 'filterfile' directives in config file - limit is %d.\n(You can increase this limit by changing MAX_AF_FILES in project.h and recompiling).", 30);

                config->re_filterfile_short[(signed long int)i]=strdup(arg);
                config->re_filterfile[(signed long int)i]=make_path(config->confdir, arg);
                break;
              }
              case 2029845U:
              {
                privoxy_strlcpy(tmp, arg, sizeof(char [5000l]) /*5000ul*/ );
                vec_count=ssplit(tmp, " \t", vec, sizeof(char *[3l]) /*24ul*/  / sizeof(char *) /*8ul*/ );
                if(!(vec_count == 2))
                {
                  log_error(0x2000, "Wrong number of parameters for forward directive in configuration file.");
                  string_append(&config->proxy_args, "<br>\nWARNING: Wrong number of parameters for forward directive in configuration file.");
                  break;
                }

                return_value_zalloc_22=zalloc(sizeof(struct forward_spec) /*104ul*/ );
                cur_fwd = (struct forward_spec *)return_value_zalloc_22;
                if(cur_fwd == ((struct forward_spec *)NULL))
                {
                  log_error(0x4000, "can't allocate memory for configuration");
                  break;
                }

                cur_fwd->type = (enum forwarder_type)SOCKS_NONE;
                return_value_create_pattern_spec_23=create_pattern_spec(cur_fwd->url, vec[(signed long int)0]);
                if(!(return_value_create_pattern_spec_23 == /*enum*/JB_ERR_OK))
                {
                  log_error(0x2000, "Bad URL specifier for forward directive in configuration file.");
                  string_append(&config->proxy_args, "<br>\nWARNING: Bad URL specifier for forward directive in configuration file.");
                  if(!(cur_fwd == ((struct forward_spec *)NULL)))
                  {
                    free((void *)cur_fwd);
                    cur_fwd = (struct forward_spec *)(void *)0;
                  }

                  break;
                }

                p = vec[(signed long int)1];
                return_value_strcmp_24=strcmp(p, ".");
                if(!(return_value_strcmp_24 == 0))
                {
                  cur_fwd->forward_port = 8000;
                  parse_forwarder_address(p, &cur_fwd->forward_host, &cur_fwd->forward_port);
                }

                cur_fwd->next = config->forward;
                config->forward = cur_fwd;
                break;
              }
              case 3963965521U:
              {
                privoxy_strlcpy(tmp, arg, sizeof(char [5000l]) /*5000ul*/ );
                vec_count=ssplit(tmp, " \t", vec, sizeof(char *[3l]) /*24ul*/  / sizeof(char *) /*8ul*/ );
                if(!(vec_count == 3))
                {
                  log_error(0x2000, "Wrong number of parameters for forward-socks4 directive in configuration file.");
                  string_append(&config->proxy_args, "<br>\nWARNING: Wrong number of parameters for forward-socks4 directive in configuration file.");
                  break;
                }

                return_value_zalloc_25=zalloc(sizeof(struct forward_spec) /*104ul*/ );
                cur_fwd = (struct forward_spec *)return_value_zalloc_25;
                if(cur_fwd == ((struct forward_spec *)NULL))
                {
                  log_error(0x4000, "can't allocate memory for configuration");
                  break;
                }

                cur_fwd->type = (enum forwarder_type)SOCKS_4;
                return_value_create_pattern_spec_26=create_pattern_spec(cur_fwd->url, vec[(signed long int)0]);
                if(!(return_value_create_pattern_spec_26 == /*enum*/JB_ERR_OK))
                {
                  log_error(0x2000, "Bad URL specifier for forward-socks4 directive in configuration file.");
                  string_append(&config->proxy_args, "<br>\nWARNING: Bad URL specifier for forward-socks4 directive in configuration file.");
                  if(!(cur_fwd == ((struct forward_spec *)NULL)))
                  {
                    free((void *)cur_fwd);
                    cur_fwd = (struct forward_spec *)(void *)0;
                  }

                  break;
                }

                p = vec[(signed long int)1];
                return_value_strcmp_27=strcmp(p, ".");
                if(!(return_value_strcmp_27 == 0))
                {
                  cur_fwd->gateway_port = 1080;
                  parse_forwarder_address(p, &cur_fwd->gateway_host, &cur_fwd->gateway_port);
                }

                p = vec[(signed long int)2];
                return_value_strcmp_28=strcmp(p, ".");
                if(!(return_value_strcmp_28 == 0))
                {
                  cur_fwd->forward_port = 8000;
                  parse_forwarder_address(p, &cur_fwd->forward_host, &cur_fwd->forward_port);
                }

                cur_fwd->next = config->forward;
                config->forward = cur_fwd;
                break;
              }
              case 2639958518U:

              case 3963965522U:

              case 2639958542U:
              {
                privoxy_strlcpy(tmp, arg, sizeof(char [5000l]) /*5000ul*/ );
                vec_count=ssplit(tmp, " \t", vec, sizeof(char *[3l]) /*24ul*/  / sizeof(char *) /*8ul*/ );
                if(!(vec_count == 3))
                {
                  log_error(0x2000, "Wrong number of parameters for %s in configuration file.", (const void *)cmd);
                  string_append(&config->proxy_args, "<br>\nWARNING: Wrong number of parameters for ");
                  string_append(&config->proxy_args, cmd);
                  string_append(&config->proxy_args, "directive in configuration file.");
                  break;
                }

                return_value_zalloc_29=zalloc(sizeof(struct forward_spec) /*104ul*/ );
                cur_fwd = (struct forward_spec *)return_value_zalloc_29;
                if(cur_fwd == ((struct forward_spec *)NULL))
                {
                  log_error(0x4000, "can't allocate memory for configuration");
                  break;
                }

                if(directive_hash == 2639958518U)
                  cur_fwd->type = (enum forwarder_type)SOCKS_4A;

                else
                  if(directive_hash == 3963965522U)
                    cur_fwd->type = (enum forwarder_type)SOCKS_5;

                  else
                  {
                    /* assertion directive_hash == 2639958542U */
                    assert(directive_hash == 2639958542U);
                    cur_fwd->type = (enum forwarder_type)SOCKS_5T;
                  }
                return_value_create_pattern_spec_30=create_pattern_spec(cur_fwd->url, vec[(signed long int)0]);
                if(!(return_value_create_pattern_spec_30 == /*enum*/JB_ERR_OK))
                {
                  log_error(0x2000, "Bad URL specifier for %s in configuration file.", (const void *)cmd);
                  string_append(&config->proxy_args, "<br>\nWARNING: Bad URL specifier for ");
                  string_append(&config->proxy_args, cmd);
                  string_append(&config->proxy_args, "directive in configuration file.");
                  if(!(cur_fwd == ((struct forward_spec *)NULL)))
                  {
                    free((void *)cur_fwd);
                    cur_fwd = (struct forward_spec *)(void *)0;
                  }

                  break;
                }

                p = vec[(signed long int)1];
                cur_fwd->gateway_port = 1080;
                parse_forwarder_address(p, &cur_fwd->gateway_host, &cur_fwd->gateway_port);
                p = vec[(signed long int)2];
                return_value_strcmp_31=strcmp(p, ".");
                if(!(return_value_strcmp_31 == 0))
                {
                  cur_fwd->forward_port = 8000;
                  parse_forwarder_address(p, &cur_fwd->forward_host, &cur_fwd->forward_port);
                }

                cur_fwd->next = config->forward;
                config->forward = cur_fwd;
                break;
              }
              case 101465292U:
              {
                config->forwarded_connect_retries=parse_numeric_value(cmd, arg);
                break;
              }
              case 1444873247U:
              {
                return_value_parse_toggle_state_32=parse_toggle_state(cmd, arg);
                if(return_value_parse_toggle_state_32 == 1)
                  config->feature_flags = config->feature_flags | 512U;

                else
                  config->feature_flags = config->feature_flags & ~512U;
                break;
              }
              case 10308071U:
              {
                if(!(config->hostname == ((const char *)NULL)))
                {
                  free((void *)config->hostname);
                  config->hostname = (const char *)(void *)0;
                }

                config->hostname=strdup(arg);
                if(config->hostname == ((const char *)NULL))
                  log_error(0x4000, "Out of memory saving hostname.");

                break;
              }
              case 3878599515U:
              {
                load_config__1__6__6__49__timeout=parse_numeric_value(cmd, arg);
                if(load_config__1__6__6__49__timeout >= 1)
                {
                  config->feature_flags = config->feature_flags | 128U;
                  config->keep_alive_timeout = (unsigned int)load_config__1__6__6__49__timeout;
                }

                else
                  config->feature_flags = config->feature_flags & ~128U;
                break;
              }
              case 1255650842U:
              {
                i = 0;
                for( ; !(i >= 10); i = i + 1)
                  if(config->haddr[(signed long int)i] == ((const char *)NULL))
                    break;

                if(i >= 10)
                  log_error(0x4000, "Too many 'listen-address' directives in config file - limit is %d.\n(You can increase this limit by changing MAX_LISTENING_SOCKETS in project.h and recompiling).", 10);

                config->haddr[(signed long int)i]=strdup(arg);
                if(config->haddr[(signed long int)i] == ((const char *)NULL))
                  log_error(0x4000, "Out of memory while copying listening address");

                break;
              }
              case 422889U:
              {
                if(!(config->logdir == ((const char *)NULL)))
                {
                  free((void *)config->logdir);
                  config->logdir = (const char *)(void *)0;
                }

                config->logdir=make_path((const char *)(void *)0, arg);
                break;
              }
              case 2114766U:
              {
                if(!(daemon_mode == 0))
                {
                  logfile=make_path(config->logdir, arg);
                  if(logfile == ((char *)NULL))
                    log_error(0x4000, "Out of memory while creating logfile path");

                }

                break;
              }
              case 3595884446U:
              {
                max_client_connections=parse_numeric_value(cmd, arg);
                if(max_client_connections >= 0)
                  config->max_client_connections = max_client_connections;

                break;
              }
              case 3587953268U:
              {
                privoxy_strlcpy(tmp, arg, sizeof(char [5000l]) /*5000ul*/ );
                vec_count=ssplit(tmp, " \t", vec, sizeof(char *[3l]) /*24ul*/  / sizeof(char *) /*8ul*/ );
                if(!(vec_count == 1) && !(vec_count == 2))
                {
                  log_error(0x2000, "Wrong number of parameters for permit-access directive in configuration file.");
                  string_append(&config->proxy_args, "<br>\nWARNING: Wrong number of parameters for permit-access directive in configuration file.<br><br>\n");
                  break;
                }

                return_value_zalloc_33=zalloc(sizeof(struct access_control_list) /*528ul*/ );
                cur_acl = (struct access_control_list *)return_value_zalloc_33;
                if(cur_acl == ((struct access_control_list *)NULL))
                {
                  log_error(0x4000, "can't allocate memory for configuration");
                  break;
                }

                cur_acl->action = (signed short int)1;
                return_value_acl_addr_34=acl_addr(vec[(signed long int)0], cur_acl->src);
                if(!(return_value_acl_addr_34 >= 0))
                {
                  log_error(0x2000, "Invalid source address, port or netmask for permit-access directive in configuration file: \"%s\"", vec[(signed long int)0]);
                  string_append(&config->proxy_args, "<br>\nWARNING: Invalid source address, port or netmask for permit-access directive in configuration file: \"");
                  string_append(&config->proxy_args, vec[(signed long int)0]);
                  string_append(&config->proxy_args, "\"<br><br>\n");
                  if(!(cur_acl == ((struct access_control_list *)NULL)))
                  {
                    free((void *)cur_acl);
                    cur_acl = (struct access_control_list *)(void *)0;
                  }

                  break;
                }

                if(vec_count == 2)
                {
                  signed int return_value_acl_addr_35;
                  return_value_acl_addr_35=acl_addr(vec[(signed long int)1], cur_acl->dst);
                  if(!(return_value_acl_addr_35 >= 0))
                  {
                    log_error(0x2000, "Invalid destination address, port or netmask for permit-access directive in configuration file: \"%s\"", vec[(signed long int)1]);
                    string_append(&config->proxy_args, "<br>\nWARNING: Invalid destination address, port or netmask for permit-access directive in configuration file: \"");
                    string_append(&config->proxy_args, vec[(signed long int)1]);
                    string_append(&config->proxy_args, "\"<br><br>\n");
                    if(!(cur_acl == ((struct access_control_list *)NULL)))
                    {
                      free((void *)cur_acl);
                      cur_acl = (struct access_control_list *)(void *)0;
                    }

                    break;
                  }

                }

                else
                  cur_acl->wildcard_dst = 1;
                cur_acl->next = config->acl;
                config->acl = cur_acl;
                break;
              }
              case 3903079059U:
              {
                if(!(config->proxy_info_url == ((char *)NULL)))
                {
                  free((void *)config->proxy_info_url);
                  config->proxy_info_url = (char *)(void *)0;
                }

                config->proxy_info_url=strdup(arg);
                break;
              }
              case 4250084780U:
              {
                return_value_parse_toggle_state_36=parse_toggle_state(cmd, arg);
                config->multi_threaded = (signed int)(0 == return_value_parse_toggle_state_36);
                break;
              }
              case 1809001761U:
              {
                socket_timeout=parse_numeric_value(cmd, arg);
                if(socket_timeout >= 0)
                  config->socket_timeout = socket_timeout;

                else
                  log_error(0x4000, "Invalid socket-timeout: '%s'", (const void *)arg);
                break;
              }
              case 671658948U:
              {
                return_value_parse_toggle_state_37=parse_toggle_state(cmd, arg);
                if(return_value_parse_toggle_state_37 == 1)
                  config->feature_flags = config->feature_flags | 8U;

                else
                  config->feature_flags = config->feature_flags & ~8U;
                break;
              }
              case 11067889U:
              {
                if(!(config->templdir == ((const char *)NULL)))
                {
                  free((void *)config->templdir);
                  config->templdir = (const char *)(void *)0;
                }

                config->templdir=make_path((const char *)(void *)0, arg);
                break;
              }
              case 1824125181U:
              {
                if(!(config->temporary_directory == ((const char *)NULL)))
                {
                  free((void *)config->temporary_directory);
                  config->temporary_directory = (const char *)(void *)0;
                }

                config->temporary_directory=make_path((const char *)(void *)0, arg);
                break;
              }
              case 1360286620U:
              {
                return_value_parse_toggle_state_38=parse_toggle_state(cmd, arg);
                if(return_value_parse_toggle_state_38 == 1)
                  config->feature_flags = config->feature_flags | 2048U;

                else
                  config->feature_flags = config->feature_flags & ~2048U;
                break;
              }
              case 447966U:
              {
                global_toggle_state=parse_toggle_state(cmd, arg);
                break;
              }
              case 430331967U:
              {
                enlist(config->trust_info, arg);
                break;
              }
              case 56494766U:
              {
                if(!(config->trustfile == ((const char *)NULL)))
                {
                  free((void *)config->trustfile);
                  config->trustfile = (const char *)(void *)0;
                }

                config->trustfile=make_path(config->confdir, arg);
                break;
              }
              case 1416668518U:
              {
                if(!(config->usermanual == ((char *)NULL)))
                {
                  free((void *)config->usermanual);
                  config->usermanual = (char *)(void *)0;
                }

                config->usermanual=strdup(arg);
                break;
              }
              case 2048809870U:

              case 1817904738U:

              case 3651284693U:

              case 2918070425U:

              case 2866730124U:

              case 2866731014U:

              case 4032101240U:

              case 2868344173U:

              case 2291744899U:

              case 215410365U:
                break;
              default:
              {
                log_error(0x2000, "Ignoring unrecognized directive '%s' (%uU) in line %lu in configuration file (%s).", buf, directive_hash, linenum, configfile);
                string_append(&config->proxy_args, " <strong class='warning'>Warning: Ignoring unrecognized directive:</strong>");
              }
            }
            savearg(cmd, arg, config);
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          }
        }
        while((_Bool)1);
        fclose(configfp);
        set_debug_level(config->debug);
        if(!(config->logfile == ((const char *)NULL)))
        {
          free((void *)config->logfile);
          config->logfile = (const char *)(void *)0;
        }

        if(!(daemon_mode == 0))
        {
          if(!(logfile == ((char *)NULL)))
          {
            config->logfile = logfile;
            init_error_log(Argv[(signed long int)0], config->logfile);
          }

          else
            disable_logging();
        }

        if(!(config->keep_alive_timeout >= config->default_server_timeout))
        {
          log_error(0x2000, "Reducing the default-server-timeout from %d to the keep-alive-timeout %d.", config->default_server_timeout, config->keep_alive_timeout);
          config->default_server_timeout = config->keep_alive_timeout;
        }

        if(!((128U & config->feature_flags) == 0u))
        {
          if(!(config->multi_threaded == 0))
            set_keep_alive_timeout(config->keep_alive_timeout);

          else
          {
            config->feature_flags = config->feature_flags & ~128U;
            log_error(0x2000, "Config option single-threaded disables connection keep-alive.");
          }
        }

        else
          if(!((256U & config->feature_flags) == 0u))
          {
            log_error(0x2000, "Config option connection-sharing has no effect if keep-alive-timeout isn't set.");
            config->feature_flags = config->feature_flags & ~256U;
          }

        if(config->proxy_args == ((char *)NULL))
          log_error(0x4000, "Out of memory loading config - insufficient memory for config->proxy_args");

        if(!(config->re_filterfile[0l] == ((const char *)NULL)))
          add_loader(load_re_filterfiles, config);

        if(!(config->actions_file[0l] == ((const char *)NULL)))
          add_loader(load_action_files, config);

        if(!(config->trustfile == ((const char *)NULL)))
          add_loader(load_trustfile, config);

        if(config->haddr[0l] == ((const char *)NULL))
        {
          config->haddr[(signed long int)0]=strdup("127.0.0.1:8118");
          if(config->haddr[0l] == ((const char *)NULL))
            log_error(0x4000, "Out of memory while copying default listening address");

        }

        i = 0;
        do
        {
          if(!(i >= 10))
            tmp_if_expr_39 = (const char *)(void *)0 != config->haddr[(signed long int)i] ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_39 = (_Bool)0;
          if(!tmp_if_expr_39)
            break;

          if((signed int)*config->haddr[(signed long int)i] == 91)
          {
            p=strchr(config->haddr[(signed long int)i], 93);
            tmp_if_expr_41 = (char *)(void *)0 != p ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_41 = (_Bool)0;
          if(tmp_if_expr_41)
            tmp_if_expr_42 = (signed int)p[(signed long int)1] == 58 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_42 = (_Bool)0;
          if(tmp_if_expr_42)
          {
            config->hport[(signed long int)i]=atoi(p + (signed long int)2);
            tmp_if_expr_43 = 0 < config->hport[(signed long int)i] ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_43 = (_Bool)0;
          if(tmp_if_expr_43)
          {
            *p = (char)0;
            memmove((void *)config->haddr[(signed long int)i], (const void *)(config->haddr[(signed long int)i] + (signed long int)1), (unsigned long int)(p - config->haddr[(signed long int)i]));
          }

          else
          {
            p=strchr(config->haddr[(signed long int)i], 58);
            if(!(p == ((char *)NULL)))
            {
              config->hport[(signed long int)i]=atoi(p + (signed long int)1);
              tmp_if_expr_40 = 0 < config->hport[(signed long int)i] ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_40 = (_Bool)0;
            if(tmp_if_expr_40)
              *p = (char)0;

            else
              log_error(0x4000, "invalid bind port spec %s", config->haddr[(signed long int)i]);
          }
          if((signed int)*config->haddr[(signed long int)i] == 0)
          {
            if(!(config->haddr[(signed long int)i] == ((const char *)NULL)))
            {
              free((void *)config->haddr[(signed long int)i]);
              config->haddr[(signed long int)i] = (const char *)(void *)0;
            }

          }

          i = i + 1;
        }
        while((_Bool)1);
        void *return_value_zalloc_44;
        return_value_zalloc_44=zalloc(sizeof(struct client_state) /*1272ul*/ );
        fake_csp = (struct client_state *)return_value_zalloc_44;
        fake_csp->config = config;
        signed int return_value_run_loader_45;
        return_value_run_loader_45=run_loader(fake_csp);
        if(!(return_value_run_loader_45 == 0))
        {
          if(!(fake_csp == ((struct client_state *)NULL)))
          {
            free((void *)fake_csp);
            fake_csp = (struct client_state *)(void *)0;
          }

          log_error(0x4000, "A loader failed while loading config file. Exiting.");
        }

        if(!(fake_csp == ((struct client_state *)NULL)))
        {
          free((void *)fake_csp);
          fake_csp = (struct client_state *)(void *)0;
        }

        config->need_bind = 1;
        if(!(current_configfile == ((struct file_list *)NULL)))
        {
          struct configuration_spec *oldcfg = (struct configuration_spec *)current_configfile->f;
          config->need_bind = 0;
          i = 0;
          for( ; !(i >= 10); i = i + 1)
            if(!(config->hport[(signed long int)i] == oldcfg->hport[(signed long int)i]))
              config->need_bind = 1;

            else
              if(config->haddr[(signed long int)i] == ((const char *)NULL))
              {
                if(!(oldcfg->haddr[(signed long int)i] == ((const char *)NULL)))
                  config->need_bind = 1;

              }

              else
                if(oldcfg->haddr[(signed long int)i] == ((const char *)NULL))
                  config->need_bind = 1;

                else
                {
                  return_value_strcmp_46=strcmp(config->haddr[(signed long int)i], oldcfg->haddr[(signed long int)i]);
                  if(!(return_value_strcmp_46 == 0))
                    config->need_bind = 1;

                }
          current_configfile->unloader = unload_configfile;
        }

        fs->next = files[0l].next;
        files[0l].next = fs;
        current_configfile = fs;
        return config;
      }
    }
}

// load_file
// file cgisimple.c line 1951
static enum privoxy_err load_file(const char *filename, char **buffer, unsigned long int *length)
{
  struct _IO_FILE *fp;
  signed long int ret;
  enum privoxy_err err = (enum privoxy_err)JB_ERR_OK;
  fp=fopen(filename, "rb");
  unsigned long int return_value_fread_4;
  if(fp == ((struct _IO_FILE *)NULL))
  {
    log_error(0x2000, "Failed to open %s: %E", filename);
    return (enum privoxy_err)JB_ERR_FILE;
  }

  else
  {
    signed int return_value_fseek_1;
    return_value_fseek_1=fseek(fp, (signed long int)0, 2);
    if(!(return_value_fseek_1 == 0))
      log_error(0x4000, "Unexpected error while fseek()ing to the end of %s: %E", filename);

    ret=ftell(fp);
    if(ret == -1l)
      log_error(0x4000, "Unexpected ftell() error while loading %s: %E", filename);

    *length = (unsigned long int)ret;
    signed int return_value_fseek_2;
    return_value_fseek_2=fseek(fp, (signed long int)0, 0);
    if(!(return_value_fseek_2 == 0))
      log_error(0x4000, "Unexpected error while fseek()ing to the beginning of %s: %E", filename);

    void *return_value_zalloc_3;
    return_value_zalloc_3=zalloc(*length + (unsigned long int)1);
    *buffer = (char *)return_value_zalloc_3;
    if(*buffer == ((char *)NULL))
      err = (enum privoxy_err)JB_ERR_MEMORY;

    else
    {
      return_value_fread_4=fread((void *)*buffer, *length, (unsigned long int)1, fp);
      if(!(return_value_fread_4 == 1ul))
      {
        log_error(0x2000, "Couldn't completely read file %s.", filename);
        if(!(*buffer == ((char *)NULL)))
        {
          free((void *)*buffer);
          *buffer = (char *)(void *)0;
        }

        err = (enum privoxy_err)JB_ERR_FILE;
      }

    }
    fclose(fp);
    return err;
  }
}

// load_one_actions_file
// file actions.c line 1174
static signed int load_one_actions_file(struct client_state *csp, signed int fileid)
{
  /* #anon_enum_MODE_START_OF_FILE=1_MODE_SETTINGS=2_MODE_DESCRIPTION=3_MODE_ALIAS=4_MODE_ACTIONS=5 */
enum anonymous_11 { MODE_START_OF_FILE=1, MODE_SETTINGS=2, MODE_DESCRIPTION=3, MODE_ALIAS=4, MODE_ACTIONS=5 };

/* */
  ;
  enum anonymous_11 mode;
  struct _IO_FILE *fp;
  struct url_actions *last_perm;
  struct url_actions *perm;
  char *buf;
  struct file_list *fs;
  struct action_spec *cur_action = (struct action_spec *)(void *)0;
  signed int cur_action_used = 0;
  struct action_alias *alias_list = (struct action_alias *)(void *)0;
  unsigned long int linenum = (unsigned long int)0;
  mode = (enum anonymous_11)MODE_START_OF_FILE;
  signed int return_value_check_file_changed_1;
  return_value_check_file_changed_1=check_file_changed(current_actions_file[(signed long int)fileid], csp->config->actions_file[(signed long int)fileid], &fs);
  char *return_value_read_config_line_3;
  _Bool tmp_if_expr_5;
  char *tmp_post_4;
  _Bool tmp_if_expr_7;
  char *tmp_post_6;
  signed int return_value_strcmpic_9;
  signed int return_value_strcmpic_8;
  _Bool tmp_if_expr_24;
  signed int return_value_atoi_23;
  signed int return_value_atoi_16;
  _Bool tmp_if_expr_19;
  _Bool tmp_if_expr_18;
  signed int return_value_atoi_17;
  _Bool tmp_if_expr_22;
  _Bool tmp_if_expr_21;
  signed int return_value_atoi_20;
  if(return_value_check_file_changed_1 == 0)
  {
    csp->actions_list[(signed long int)fileid] = current_actions_file[(signed long int)fileid];
    return 0;
  }

  else
    if(fs == ((struct file_list *)NULL))
    {
      log_error(0x4000, "can't load actions file '%s': %E. Note that beginning with Privoxy 3.0.7, actions files have to be specified with their complete file names.", csp->config->actions_file[(signed long int)fileid]);
      return 1;
    }

    else
    {
      void *return_value_zalloc_2;
      return_value_zalloc_2=zalloc(sizeof(struct url_actions) /*72ul*/ );
      last_perm = (struct url_actions *)return_value_zalloc_2;
      fs->f = (void *)last_perm;
      if(last_perm == ((struct url_actions *)NULL))
      {
        log_error(0x4000, "can't load actions file '%s': out of memory!", csp->config->actions_file[(signed long int)fileid]);
        return 1;
      }

      else
      {
        fp=fopen(csp->config->actions_file[(signed long int)fileid], "r");
        if(fp == ((struct _IO_FILE *)NULL))
        {
          log_error(0x4000, "can't load actions file '%s': error opening file: %E", csp->config->actions_file[(signed long int)fileid]);
          return 1;
        }

        else
        {
          log_error(0x1000, "Loading actions file: %s", csp->config->actions_file[(signed long int)fileid]);
          do
          {
            return_value_read_config_line_3=read_config_line(fp, &linenum, &buf);
            if(return_value_read_config_line_3 == ((char *)NULL))
              break;

            if((signed int)*buf == 123)
            {
              if((signed int)buf[1l] == 123)
              {
                unsigned long int len;
                len=strlen(buf);
                char *start = buf + (signed long int)2;
                char *load_one_actions_file__1__5__1__1__end = (buf + (signed long int)len) - (signed long int)1;
                if(!(len >= 5ul))
                  tmp_if_expr_5 = (_Bool)1;

                else
                {
                  tmp_post_4 = load_one_actions_file__1__5__1__1__end;
                  load_one_actions_file__1__5__1__1__end = load_one_actions_file__1__5__1__1__end - 1l;
                  tmp_if_expr_5 = (signed int)*tmp_post_4 != 125 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_5)
                  tmp_if_expr_7 = (_Bool)1;

                else
                {
                  tmp_post_6 = load_one_actions_file__1__5__1__1__end;
                  load_one_actions_file__1__5__1__1__end = load_one_actions_file__1__5__1__1__end - 1l;
                  tmp_if_expr_7 = (signed int)*tmp_post_6 != 125 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_7)
                {
                  fclose(fp);
                  log_error(0x4000, "can't load actions file '%s': invalid line (%lu): %s", csp->config->actions_file[(signed long int)fileid], linenum, buf);
                  return 1;
                }

                load_one_actions_file__1__5__1__1__end[(signed long int)1] = (char)0;
                chomp(start);
                if((signed int)*start == 0)
                {
                  fclose(fp);
                  log_error(0x4000, "can't load actions file '%s': invalid line (%lu): {{ }}", csp->config->actions_file[(signed long int)fileid], linenum);
                  return 1;
                }

                signed int return_value_strcmpic_10;
                return_value_strcmpic_10=strcmpic(start, "settings");
                if(return_value_strcmpic_10 == 0)
                {
                  if((signed int)mode >= MODE_SETTINGS)
                  {
                    fclose(fp);
                    log_error(0x4000, "can't load actions file '%s': line %lu: {{settings}} must only appear once, and it must be before anything else.", csp->config->actions_file[(signed long int)fileid], linenum);
                  }

                  mode = (enum anonymous_11)MODE_SETTINGS;
                }

                else
                {
                  return_value_strcmpic_9=strcmpic(start, "description");
                  if(return_value_strcmpic_9 == 0)
                  {
                    if((signed int)mode >= MODE_DESCRIPTION)
                    {
                      fclose(fp);
                      log_error(0x4000, "can't load actions file '%s': line %lu: {{description}} must only appear once, and only a {{settings}} block may be above it.", csp->config->actions_file[(signed long int)fileid], linenum);
                    }

                    mode = (enum anonymous_11)MODE_DESCRIPTION;
                  }

                  else
                  {
                    return_value_strcmpic_8=strcmpic(start, "alias");
                    if(return_value_strcmpic_8 == 0)
                    {
                      if((signed int)mode >= MODE_ALIAS)
                      {
                        fclose(fp);
                        log_error(0x4000, "can't load actions file '%s': line %lu: {{alias}} must only appear once, and it must be before all actions.", csp->config->actions_file[(signed long int)fileid], linenum);
                      }

                      mode = (enum anonymous_11)MODE_ALIAS;
                    }

                    else
                    {
                      fclose(fp);
                      log_error(0x4000, "can't load actions file '%s': invalid line (%lu): {{%s}}", csp->config->actions_file[(signed long int)fileid], linenum, start);
                      return 1;
                    }
                  }
                }
              }

              else
              {
                char *load_one_actions_file__1__5__1__2__actions_buf;
                char *load_one_actions_file__1__5__1__2__end;
                mode = (enum anonymous_11)MODE_ACTIONS;
                if(!(cur_action == ((struct action_spec *)NULL)))
                {
                  if(cur_action_used == 0)
                    free_action_spec(cur_action);

                  cur_action = (struct action_spec *)(void *)0;
                }

                cur_action_used = 0;
                void *return_value_zalloc_11;
                return_value_zalloc_11=zalloc(sizeof(struct action_spec) /*424ul*/ );
                cur_action = (struct action_spec *)return_value_zalloc_11;
                if(cur_action == ((struct action_spec *)NULL))
                {
                  fclose(fp);
                  log_error(0x4000, "can't load actions file '%s': out of memory", csp->config->actions_file[(signed long int)fileid]);
                  return 1;
                }

                init_action(cur_action);
                load_one_actions_file__1__5__1__2__end=strdup_or_die(buf + (signed long int)1);
                load_one_actions_file__1__5__1__2__actions_buf = load_one_actions_file__1__5__1__2__end;
                unsigned long int return_value_strlen_13;
                return_value_strlen_13=strlen(load_one_actions_file__1__5__1__2__actions_buf);
                if(!(return_value_strlen_13 == 0ul))
                {
                  unsigned long int return_value_strlen_12;
                  return_value_strlen_12=strlen(load_one_actions_file__1__5__1__2__actions_buf);
                  load_one_actions_file__1__5__1__2__end = load_one_actions_file__1__5__1__2__end + (signed long int)(return_value_strlen_12 - (unsigned long int)1);
                }

                if(!((signed int)*load_one_actions_file__1__5__1__2__end == 125))
                {
                  fclose(fp);
                  if(!(load_one_actions_file__1__5__1__2__actions_buf == ((char *)NULL)))
                  {
                    free((void *)load_one_actions_file__1__5__1__2__actions_buf);
                    load_one_actions_file__1__5__1__2__actions_buf = (char *)(void *)0;
                  }

                  log_error(0x4000, "can't load actions file '%s': Missing trailing '}' in action section starting at line (%lu): %s", csp->config->actions_file[(signed long int)fileid], linenum, buf);
                  return 1;
                }

                *load_one_actions_file__1__5__1__2__end = (char)0;
                chomp(load_one_actions_file__1__5__1__2__actions_buf);
                enum privoxy_err return_value_get_actions_14;
                return_value_get_actions_14=get_actions(load_one_actions_file__1__5__1__2__actions_buf, alias_list, cur_action);
                if(!(return_value_get_actions_14 == /*enum*/JB_ERR_OK))
                {
                  fclose(fp);
                  if(!(load_one_actions_file__1__5__1__2__actions_buf == ((char *)NULL)))
                  {
                    free((void *)load_one_actions_file__1__5__1__2__actions_buf);
                    load_one_actions_file__1__5__1__2__actions_buf = (char *)(void *)0;
                  }

                  log_error(0x4000, "can't load actions file '%s': can't completely parse the action section starting at line (%lu): %s", csp->config->actions_file[(signed long int)fileid], linenum, buf);
                  return 1;
                }

                signed int return_value_action_spec_is_valid_15;
                return_value_action_spec_is_valid_15=action_spec_is_valid(csp, cur_action);
                if(!(return_value_action_spec_is_valid_15 == 0))
                  log_error(0x2000, "Invalid action section in file '%s', starting at line %lu: %s", csp->config->actions_file[(signed long int)fileid], linenum, buf);

                if(!(load_one_actions_file__1__5__1__2__actions_buf == ((char *)NULL)))
                {
                  free((void *)load_one_actions_file__1__5__1__2__actions_buf);
                  load_one_actions_file__1__5__1__2__actions_buf = (char *)(void *)0;
                }

              }
            }

            else
              if((signed int)mode == MODE_SETTINGS)
              {
                signed int return_value_strncmp_25;
                return_value_strncmp_25=strncmp(buf, "for-privoxy-version=", (unsigned long int)20);
                if(return_value_strncmp_25 == 0)
                {
                  char *version_string;
                  char *fields[3l];
                  signed int num_fields;
                  version_string=strdup_or_die(buf + (signed long int)20);
                  num_fields=ssplit(version_string, ".", fields, sizeof(char *[3l]) /*24ul*/  / sizeof(char *) /*8ul*/ );
                  if(!(num_fields >= 1))
                    tmp_if_expr_24 = (_Bool)1;

                  else
                  {
                    return_value_atoi_23=atoi(fields[(signed long int)0]);
                    tmp_if_expr_24 = return_value_atoi_23 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_24)
                    log_error(0x2000, "While loading actions file '%s': invalid line (%lu): %s", csp->config->actions_file[(signed long int)fileid], linenum, buf);

                  else
                  {
                    return_value_atoi_16=atoi(fields[(signed long int)0]);
                    if(return_value_atoi_16 >= 4)
                      tmp_if_expr_19 = (_Bool)1;

                    else
                    {
                      if(num_fields >= 2)
                      {
                        return_value_atoi_17=atoi(fields[(signed long int)1]);
                        tmp_if_expr_18 = return_value_atoi_17 > 0 ? (_Bool)1 : (_Bool)0;
                      }

                      else
                        tmp_if_expr_18 = (_Bool)0;
                      tmp_if_expr_19 = tmp_if_expr_18 ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr_19)
                      tmp_if_expr_22 = (_Bool)1;

                    else
                    {
                      if(num_fields >= 3)
                      {
                        return_value_atoi_20=atoi(fields[(signed long int)2]);
                        tmp_if_expr_21 = return_value_atoi_20 > 24 ? (_Bool)1 : (_Bool)0;
                      }

                      else
                        tmp_if_expr_21 = (_Bool)0;
                      tmp_if_expr_22 = tmp_if_expr_21 ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr_22)
                    {
                      fclose(fp);
                      log_error(0x4000, "Actions file '%s', line %lu requires newer Privoxy version: %s", csp->config->actions_file[(signed long int)fileid], linenum, buf);
                      return 1;
                    }

                  }
                  free((void *)version_string);
                }

              }

              else
                if(!((signed int)mode == MODE_DESCRIPTION))
                {
                  if((signed int)mode == MODE_ALIAS)
                  {
                    char actions_buf[5000l];
                    struct action_alias *new_alias;
                    char *load_one_actions_file__1__5__4__start;
                    load_one_actions_file__1__5__4__start=strchr(buf, 61);
                    char *end = load_one_actions_file__1__5__4__start;
                    if(load_one_actions_file__1__5__4__start == ((char *)NULL) || load_one_actions_file__1__5__4__start == buf)
                    {
                      log_error(0x4000, "can't load actions file '%s': invalid alias line (%lu): %s", csp->config->actions_file[(signed long int)fileid], linenum, buf);
                      return 1;
                    }

                    void *return_value_zalloc_26;
                    return_value_zalloc_26=zalloc(sizeof(struct action_alias) /*440ul*/ );
                    new_alias = (struct action_alias *)return_value_zalloc_26;
                    if(new_alias == ((struct action_alias *)NULL))
                    {
                      fclose(fp);
                      log_error(0x4000, "can't load actions file '%s': out of memory!", csp->config->actions_file[(signed long int)fileid]);
                      return 1;
                    }

                    end = end - 1l;
                    for( ; (_Bool)1; end = end - 1l)
                      if(!((signed int)*end == 32))
                      {
                        if(!((signed int)*end == 9))
                          goto __CPROVER_DUMP_L50;

                      }


                  __CPROVER_DUMP_L50:
                    ;
                    end[(signed long int)1] = (char)0;
                    load_one_actions_file__1__5__4__start = load_one_actions_file__1__5__4__start + 1l;
                    for( ; (_Bool)1; load_one_actions_file__1__5__4__start = load_one_actions_file__1__5__4__start + 1l)
                      if(!((signed int)*load_one_actions_file__1__5__4__start == 32))
                      {
                        if(!((signed int)*load_one_actions_file__1__5__4__start == 9))
                          goto __CPROVER_DUMP_L53;

                      }


                  __CPROVER_DUMP_L53:
                    ;
                    if((signed int)*load_one_actions_file__1__5__4__start == 0)
                    {
                      log_error(0x4000, "can't load actions file '%s': invalid alias line (%lu): %s", csp->config->actions_file[(signed long int)fileid], linenum, buf);
                      return 1;
                    }

                    new_alias->name=strdup_or_die(buf);
                    privoxy_strlcpy(actions_buf, load_one_actions_file__1__5__4__start, sizeof(char [5000l]) /*5000ul*/ );
                    enum privoxy_err return_value_get_actions_27;
                    return_value_get_actions_27=get_actions(actions_buf, alias_list, new_alias->action);
                    if(!(return_value_get_actions_27 == /*enum*/JB_ERR_OK))
                    {
                      fclose(fp);
                      log_error(0x4000, "can't load actions file '%s': invalid alias line (%lu): %s = %s", csp->config->actions_file[(signed long int)fileid], linenum, buf, load_one_actions_file__1__5__4__start);
                      return 1;
                    }

                    new_alias->next = alias_list;
                    alias_list = new_alias;
                  }

                  else
                    if((signed int)mode == MODE_ACTIONS)
                    {
                      void *return_value_zalloc_28;
                      return_value_zalloc_28=zalloc(sizeof(struct url_actions) /*72ul*/ );
                      perm = (struct url_actions *)return_value_zalloc_28;
                      if(perm == ((struct url_actions *)NULL))
                      {
                        fclose(fp);
                        log_error(0x4000, "can't load actions file '%s': out of memory!", csp->config->actions_file[(signed long int)fileid]);
                        return 1;
                      }

                      perm->action = cur_action;
                      cur_action_used = 1;
                      enum privoxy_err return_value_create_pattern_spec_29;
                      return_value_create_pattern_spec_29=create_pattern_spec(perm->url, buf);
                      if(!(return_value_create_pattern_spec_29 == /*enum*/JB_ERR_OK))
                      {
                        fclose(fp);
                        log_error(0x4000, "can't load actions file '%s': line %lu: cannot create URL or TAG pattern from: %s", csp->config->actions_file[(signed long int)fileid], linenum, buf);
                        return 1;
                      }

                      last_perm->next = perm;
                      last_perm = perm;
                    }

                    else
                      if((signed int)mode == MODE_START_OF_FILE)
                      {
                        fclose(fp);
                        log_error(0x4000, "can't load actions file '%s': line %lu should begin with a '{': %s", csp->config->actions_file[(signed long int)fileid], linenum, buf);
                        return 1;
                      }

                      else
                      {
                        fclose(fp);
                        log_error(0x4000, "can't load actions file '%s': INTERNAL ERROR - mode = %d", csp->config->actions_file[(signed long int)fileid], mode);
                        return 1;
                      }
                }

            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          }
          while((_Bool)1);
          fclose(fp);
          if(cur_action_used == 0)
            free_action_spec(cur_action);

          free_alias_list(alias_list);
          if(!(current_actions_file[(signed long int)fileid] == ((struct file_list *)NULL)))
            current_actions_file[(signed long int)fileid]->unloader = unload_actions_file;

          fs->next = files[0l].next;
          files[0l].next = fs;
          current_actions_file[(signed long int)fileid] = fs;
          csp->actions_list[(signed long int)fileid] = fs;
          return 0;
        }
      }
    }
}

// load_one_re_filterfile
// file loaders.c line 1111
static signed int load_one_re_filterfile(struct client_state *csp, signed int fileid)
{
  struct _IO_FILE *fp;
  struct re_filterfile_spec *new_bl;
  struct re_filterfile_spec *bl = (struct re_filterfile_spec *)(void *)0;
  struct file_list *fs;
  char *buf = (char *)(void *)0;
  signed int error;
  unsigned long int linenum = (unsigned long int)0;
  struct PCRS_JOB *dummy;
  struct PCRS_JOB *lastjob = (struct PCRS_JOB *)(void *)0;
  signed int return_value_check_file_changed_1;
  return_value_check_file_changed_1=check_file_changed(current_re_filterfile[(signed long int)fileid], csp->config->re_filterfile[(signed long int)fileid], &fs);
  char *return_value_read_config_line_2;
  signed int return_value_strncmp_7;
  signed int return_value_strncmp_6;
  signed int return_value_strncmp_5;
  signed int return_value_strncmp_4;
  signed int return_value_strncmp_3;
  char *tmp_post_10;
  if(return_value_check_file_changed_1 == 0)
  {
    csp->rlist[(signed long int)fileid] = current_re_filterfile[(signed long int)fileid];
    return 0;
  }

  else
    if(!(fs == ((struct file_list *)NULL)))
    {
      fp=fopen(csp->config->re_filterfile[(signed long int)fileid], "r");
      if(fp == ((struct _IO_FILE *)NULL))
        goto load_re_filterfile_error;

      log_error(0x1000, "Loading filter file: %s", csp->config->re_filterfile[(signed long int)fileid]);
      do
      {
        return_value_read_config_line_2=read_config_line(fp, &linenum, &buf);
        if(return_value_read_config_line_2 == ((char *)NULL))
          break;

        enum filter_type new_filter = (enum filter_type)FT_INVALID_FILTER;
        signed int return_value_strncmp_8;
        return_value_strncmp_8=strncmp(buf, "FILTER:", (unsigned long int)7);
        if(return_value_strncmp_8 == 0)
          new_filter = (enum filter_type)FT_CONTENT_FILTER;

        else
        {
          return_value_strncmp_7=strncmp(buf, "SERVER-HEADER-FILTER:", (unsigned long int)21);
          if(return_value_strncmp_7 == 0)
            new_filter = (enum filter_type)FT_SERVER_HEADER_FILTER;

          else
          {
            return_value_strncmp_6=strncmp(buf, "CLIENT-HEADER-FILTER:", (unsigned long int)21);
            if(return_value_strncmp_6 == 0)
              new_filter = (enum filter_type)FT_CLIENT_HEADER_FILTER;

            else
            {
              return_value_strncmp_5=strncmp(buf, "CLIENT-HEADER-TAGGER:", (unsigned long int)21);
              if(return_value_strncmp_5 == 0)
                new_filter = (enum filter_type)FT_CLIENT_HEADER_TAGGER;

              else
              {
                return_value_strncmp_4=strncmp(buf, "SERVER-HEADER-TAGGER:", (unsigned long int)21);
                if(return_value_strncmp_4 == 0)
                  new_filter = (enum filter_type)FT_SERVER_HEADER_TAGGER;

                else
                {
                  return_value_strncmp_3=strncmp(buf, "EXTERNAL-FILTER:", (unsigned long int)16);
                  if(return_value_strncmp_3 == 0)
                    new_filter = (enum filter_type)FT_EXTERNAL_CONTENT_FILTER;

                }
              }
            }
          }
        }
        if(!((signed int)new_filter == FT_INVALID_FILTER))
        {
          void *return_value_zalloc_9;
          return_value_zalloc_9=zalloc(sizeof(struct re_filterfile_spec) /*56ul*/ );
          new_bl = (struct re_filterfile_spec *)return_value_zalloc_9;
          if(new_bl == ((struct re_filterfile_spec *)NULL))
            goto load_re_filterfile_error;

          if((signed int)new_filter == FT_CONTENT_FILTER)
            new_bl->name=chomp(buf + (signed long int)7);

          else
            if((signed int)new_filter == FT_EXTERNAL_CONTENT_FILTER)
              new_bl->name=chomp(buf + (signed long int)16);

            else
              new_bl->name=chomp(buf + (signed long int)21);
          new_bl->type = new_filter;
          new_bl->description=strpbrk(new_bl->name, " \t");
          if(!(new_bl->description == ((char *)NULL)))
          {
            tmp_post_10 = new_bl->description;
            new_bl->description = new_bl->description + 1l;
            *tmp_post_10 = (char)0;
            char *return_value_chomp_11;
            return_value_chomp_11=chomp(new_bl->description);
            new_bl->description=html_encode(return_value_chomp_11);
            if(new_bl->description == ((char *)NULL))
              new_bl->description=strdup("Out of memory while encoding this filter's description to HTML");

          }

          else
            new_bl->description=strdup("No description available for this filter");
          char *return_value_chomp_12;
          return_value_chomp_12=chomp(new_bl->name);
          new_bl->name=strdup(return_value_chomp_12);
          if(fs->f == NULL)
            fs->f = (void *)new_bl;

          else
          {
            /* assertion ((void *)0) != bl */
            assert((struct re_filterfile_spec *)(void *)0 != bl);
            bl->next = new_bl;
          }
          bl = new_bl;
          log_error(0x0040, "Reading in filter \"%s\" (\"%s\")", bl->name, bl->description);
          if(!(buf == ((char *)NULL)))
          {
            free((void *)buf);
            buf = (char *)(void *)0;
          }

          continue;
        }

        if(!(bl == ((struct re_filterfile_spec *)NULL)))
        {
          if((signed int)bl->type == FT_EXTERNAL_CONTENT_FILTER)
          {
            if(!(bl->patterns[0l].first == ((struct list_entry *)NULL)))
              log_error(0x4000, "External filter '%s' contains several jobss. Did you forget to escape a line break?", bl->name);

            enum privoxy_err return_value_enlist_13;
            return_value_enlist_13=enlist(bl->patterns, buf);
            error = (signed int)return_value_enlist_13;
            if(error == JB_ERR_MEMORY)
              log_error(0x4000, "Out of memory while enlisting external filter code '%s' for filter %s.", buf, bl->name);

            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

            continue;
          }

        }

        if(!(bl == ((struct re_filterfile_spec *)NULL)))
        {
          enum privoxy_err return_value_enlist_14;
          return_value_enlist_14=enlist(bl->patterns, buf);
          error = (signed int)return_value_enlist_14;
          if(error == JB_ERR_MEMORY)
            log_error(0x4000, "Out of memory while enlisting re_filter job '%s' for filter %s.", buf, bl->name);

          /* assertion JB_ERR_OK == error */
          assert(JB_ERR_OK == error);
          signed int return_value_pcrs_job_is_dynamic_15;
          return_value_pcrs_job_is_dynamic_15=pcrs_job_is_dynamic(buf);
          if(!(return_value_pcrs_job_is_dynamic_15 == 0))
          {
            if(!(bl->joblist == ((struct PCRS_JOB *)NULL)))
            {
              pcrs_free_joblist(bl->joblist);
              bl->joblist = (struct PCRS_JOB *)(void *)0;
            }

            bl->dynamic = 1;
            log_error(0x0040, "Adding dynamic re_filter job '%s' to filter %s succeeded.", buf, bl->name);
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

            continue;
          }

          else
            if(!(bl->dynamic == 0))
            {
              log_error(0x0040, "Adding static re_filter job '%s' to dynamic filter %s succeeded.", buf, bl->name);
              if(!(buf == ((char *)NULL)))
              {
                free((void *)buf);
                buf = (char *)(void *)0;
              }

              continue;
            }

          dummy=pcrs_compile_command(buf, &error);
          if(dummy == ((struct PCRS_JOB *)NULL))
          {
            const char *return_value_pcrs_strerror_16;
            return_value_pcrs_strerror_16=pcrs_strerror(error);
            log_error(0x2000, "Adding re_filter job '%s' to filter %s failed: %s", buf, bl->name, return_value_pcrs_strerror_16);
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

            continue;
          }

          else
          {
            if(bl->joblist == ((struct PCRS_JOB *)NULL))
              bl->joblist = dummy;

            else
              if(!(lastjob == ((struct PCRS_JOB *)NULL)))
                lastjob->next = dummy;

            lastjob = dummy;
            log_error(0x0040, "Adding re_filter job '%s' to filter %s succeeded.", buf, bl->name);
          }
        }

        else
          log_error(0x2000, "Ignoring job %s outside filter block in %s, line %d", buf, csp->config->re_filterfile[(signed long int)fileid], linenum);
        if(!(buf == ((char *)NULL)))
        {
          free((void *)buf);
          buf = (char *)(void *)0;
        }

      }
      while((_Bool)1);
      fclose(fp);
      if(!(current_re_filterfile[(signed long int)fileid] == ((struct file_list *)NULL)))
        current_re_filterfile[(signed long int)fileid]->unloader = unload_re_filterfile;

      fs->next = files[0l].next;
      files[0l].next = fs;
      current_re_filterfile[(signed long int)fileid] = fs;
      csp->rlist[(signed long int)fileid] = fs;
      return 0;
    }

    else
    {

    load_re_filterfile_error:
      ;
      log_error(0x4000, "can't load re_filterfile '%s': %E", csp->config->re_filterfile[(signed long int)fileid]);
      return -1;
    }
}

// load_re_filterfiles
// file loaders.h line 76
extern signed int load_re_filterfiles(struct client_state *csp)
{
  signed int i;
  signed int result;
  i = 0;
  for( ; !(i >= 30); i = i + 1)
    if(!(csp->config->re_filterfile[(signed long int)i] == ((const char *)NULL)))
    {
      result=load_one_re_filterfile(csp, i);
      if(!(result == 0))
        return result;

    }

    else
      if(!(current_re_filterfile[(signed long int)i] == ((struct file_list *)NULL)))
      {
        current_re_filterfile[(signed long int)i]->unloader = unload_re_filterfile;
        current_re_filterfile[(signed long int)i] = (struct file_list *)(void *)0;
      }

  return 0;
}

// load_trustfile
// file loaders.h line 79
extern signed int load_trustfile(struct client_state *csp)
{
  struct _IO_FILE *fp;
  struct block_spec *b;
  struct block_spec *bl;
  struct pattern_spec **tl;
  char *buf = (char *)(void *)0;
  signed int reject;
  signed int trusted;
  struct file_list *fs;
  unsigned long int linenum = (unsigned long int)0;
  signed int trusted_referrers = 0;
  signed int return_value_check_file_changed_1;
  return_value_check_file_changed_1=check_file_changed(current_trustfile, csp->config->trustfile, &fs);
  void *return_value_zalloc_2;
  char *return_value_read_config_line_3;
  char *tmp_post_4;
  char *tmp_post_5;
  struct pattern_spec **tmp_post_8;
  if(return_value_check_file_changed_1 == 0)
  {
    csp->tlist = current_trustfile;
    return 0;
  }

  else
    if(!(fs == ((struct file_list *)NULL)))
    {
      return_value_zalloc_2=zalloc(sizeof(struct block_spec) /*72ul*/ );
      bl = (struct block_spec *)return_value_zalloc_2;
      fs->f = (void *)bl;
      if(bl == ((struct block_spec *)NULL))
        goto load_trustfile_error;

      fp=fopen(csp->config->trustfile, "r");
      if(fp == ((struct _IO_FILE *)NULL))
        goto load_trustfile_error;

      log_error(0x1000, "Loading trust file: %s", csp->config->trustfile);
      tl = csp->config->trust_list;
      do
      {
        return_value_read_config_line_3=read_config_line(fp, &linenum, &buf);
        if(return_value_read_config_line_3 == ((char *)NULL))
          break;

        trusted = 0;
        reject = 1;
        if((signed int)*buf == 43)
        {
          trusted = 1;
          *buf = (char)126;
        }

        if((signed int)*buf == 126)
        {
          char *p;
          char *q;
          reject = 0;
          p = buf;
          q = p + (signed long int)1;
          do
          {
            tmp_post_4 = p;
            p = p + 1l;
            tmp_post_5 = q;
            q = q + 1l;
            *tmp_post_4 = *tmp_post_5;
            if((signed int)*tmp_post_4 == 0)
              break;

          }
          while((_Bool)1);
        }

        if((signed int)*buf == 0)
        {
          if(!(buf == ((char *)NULL)))
          {
            free((void *)buf);
            buf = (char *)(void *)0;
          }

        }

        else
        {
          void *return_value_zalloc_6;
          return_value_zalloc_6=zalloc(sizeof(struct block_spec) /*72ul*/ );
          b = (struct block_spec *)return_value_zalloc_6;
          if(b == ((struct block_spec *)NULL))
          {
            fclose(fp);
            goto load_trustfile_error;
          }

          b->next = bl->next;
          bl->next = b;
          b->reject = reject;
          enum privoxy_err return_value_create_pattern_spec_7;
          return_value_create_pattern_spec_7=create_pattern_spec(b->url, buf);
          if(!(return_value_create_pattern_spec_7 == /*enum*/JB_ERR_OK))
          {
            fclose(fp);
            goto load_trustfile_error;
          }

          if(!(trusted == 0))
          {
            trusted_referrers = trusted_referrers + 1;
            if(!(trusted_referrers >= 512))
            {
              tmp_post_8 = tl;
              tl = tl + 1l;
              *tmp_post_8 = b->url;
            }

          }

          if(!(buf == ((char *)NULL)))
          {
            free((void *)buf);
            buf = (char *)(void *)0;
          }

        }
      }
      while((_Bool)1);
      if(trusted_referrers >= 512)
        log_error(0x2000, "Too many trusted referrers. Current limit is %d, you are using %d.\n  Additional trusted referrers are treated like ordinary trusted URLs.\n  (You can increase this limit by changing MAX_TRUSTED_REFERRERS in project.h and recompiling).", 512, trusted_referrers);

      *tl = (struct pattern_spec *)(void *)0;
      fclose(fp);
      if(!(current_trustfile == ((struct file_list *)NULL)))
        current_trustfile->unloader = unload_trustfile;

      fs->next = files[0l].next;
      files[0l].next = fs;
      current_trustfile = fs;
      csp->tlist = fs;
      return 0;
    }

    else
    {

    load_trustfile_error:
      ;
      log_error(0x4000, "can't load trustfile '%s': %E", csp->config->trustfile);
      if(!(buf == ((char *)NULL)))
      {
        free((void *)buf);
        buf = (char *)(void *)0;
      }

      return -1;
    }
}

// lock_logfile
// file errlog.c line 108
static inline void lock_logfile(void)
{
  privoxy_mutex_lock(&log_mutex);
}

// lock_loginit
// file errlog.c line 116
static inline void lock_loginit(void)
{
  privoxy_mutex_lock(&log_init_mutex);
}

// log_applied_actions
// file jcc.c line 720
static void log_applied_actions(struct current_action_spec *actions)
{
  signed int return_value_debug_level_is_enabled_1;
  return_value_debug_level_is_enabled_1=debug_level_is_enabled(0x10000);
  if(!(return_value_debug_level_is_enabled_1 == 0))
  {
    char *actions_as_text;
    actions_as_text=actions_to_line_of_text(actions);
    log_error(0x10000, "%s", actions_as_text);
    if(!(actions_as_text == ((char *)NULL)))
    {
      free((void *)actions_as_text);
      actions_as_text = (char *)(void *)0;
    }

  }

}

// log_error
// file errlog.h line 70
extern void log_error(signed int loglevel, const char *fmt, ...)
{
  __builtin_va_list ap;
  char *outbuf = (char *)(void *)0;
  char tempbuf[5000l];
  unsigned long int length = (unsigned long int)0;
  const char *src = fmt;
  signed long int thread_id;
  char timestamp[30l];
  unsigned long int log_buffer_size = (unsigned long int)5000;
  const char *tmp_post_4;
  unsigned long int tmp_post_5;
  const char *tmp_post_6;
  const char *tmp_post_7;
  _Bool tmp_if_expr_8;
  signed int return_value_gcc_builtin_va_arg_9;
  signed int tmp_post_10;
  _Bool tmp_if_expr_13;
  unsigned long int tmp_post_11;
  signed int *return_value___errno_location_14;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_19;
  if((debug & loglevel) == 0 || logfp == ((struct _IO_FILE *)NULL))
  {
    if(loglevel == 0x4000)
      fatal_error("Fatal error. You're not supposed tosee this message. Please file a bug report.");

  }

  else
  {
    thread_id=get_thread_id();
    get_log_timestamp(timestamp, sizeof(char [30l]) /*30ul*/ );
    lock_logfile();
    static char *outbuf_save = (char *)(void *)0;
    if(outbuf_save == ((char *)NULL))
    {
      void *return_value_zalloc_1;
      return_value_zalloc_1=zalloc(log_buffer_size + (unsigned long int)1);
      outbuf_save = (char *)return_value_zalloc_1;
      if(outbuf_save == ((char *)NULL))
      {
        snprintf(tempbuf, sizeof(char [5000l]) /*5000ul*/ , "%s %08lx Fatal error: Out of memory in log_error().", (const void *)timestamp, thread_id);
        fatal_error(tempbuf);
        goto __CPROVER_DUMP_L43;
      }

    }

    outbuf = outbuf_save;
    memset((void *)outbuf, 0, log_buffer_size);
    if(!(loglevel == 0x0200))
    {
      const char *return_value_get_log_level_string_2;
      return_value_get_log_level_string_2=get_log_level_string(loglevel);
      signed int return_value_snprintf_3;
      return_value_snprintf_3=snprintf(outbuf, log_buffer_size, "%s %08lx %s: ", (const void *)timestamp, thread_id, return_value_get_log_level_string_2);
      length = (unsigned long int)return_value_snprintf_3;
    }

    va_start(ap, fmt);
    while(!(*src == 0))
    {
      if(length >= log_buffer_size + 18446744073709551614ul)
        break;

      const char *sval = (const char *)(void *)0;
      signed int ival;
      unsigned int uval;
      signed long int lval;
      unsigned long int ulval;
      char ch;
      const char *format_string = tempbuf;
      tmp_post_4 = src;
      src = src + 1l;
      ch = *tmp_post_4;
      if(!((signed int)ch == 37))
      {
        tmp_post_5 = length;
        length = length + 1ul;
        outbuf[(signed long int)tmp_post_5] = ch;
        outbuf[(signed long int)length] = (char)0;
      }

      else
      {
        outbuf[(signed long int)length] = (char)0;
        tmp_post_6 = src;
        src = src + 1l;
        ch = *tmp_post_6;
        switch((signed int)ch)
        {
          case 37:
          {
            tempbuf[(signed long int)0] = (char)37;
            tempbuf[(signed long int)1] = (char)0;
            break;
          }
          case 100:
          {
            ival=va_arg(ap, __typeof__(ival));
            snprintf(tempbuf, sizeof(char [5000l]) /*5000ul*/ , "%d", ival);
            break;
          }
          case 117:
          {
            uval=va_arg(ap, __typeof__(uval));
            snprintf(tempbuf, sizeof(char [5000l]) /*5000ul*/ , "%u", uval);
            break;
          }
          case 108:
          {
            tmp_post_7 = src;
            src = src + 1l;
            ch = *tmp_post_7;
            if((signed int)ch == 100)
            {
              lval=va_arg(ap, __typeof__(lval));
              snprintf(tempbuf, sizeof(char [5000l]) /*5000ul*/ , "%ld", lval);
            }

            else
              if((signed int)ch == 117)
              {
                ulval=va_arg(ap, __typeof__(ulval));
                snprintf(tempbuf, sizeof(char [5000l]) /*5000ul*/ , "%lu", ulval);
              }

              else
              {
                if((signed int)ch == 108)
                  tmp_if_expr_8 = (signed int)*src == 117 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_8 = (_Bool)0;
                if(tmp_if_expr_8)
                {
                  unsigned long long int lluval;
                  lluval=va_arg(ap, __typeof__(lluval));
                  snprintf(tempbuf, sizeof(char [5000l]) /*5000ul*/ , "%llu", lluval);
                  src = src + 1l;
                }

                else
                {
                  snprintf(tempbuf, sizeof(char [5000l]) /*5000ul*/ , "Bad format string: \"%s\"", fmt);
                  loglevel = 0x4000;
                }
              }
            break;
          }
          case 99:
          {
            return_value_gcc_builtin_va_arg_9=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_9));
            tempbuf[(signed long int)0] = (char)return_value_gcc_builtin_va_arg_9;
            tempbuf[(signed long int)1] = (char)0;
            break;
          }
          case 115:
          {
            format_string=va_arg(ap, __typeof__(format_string));
            if(format_string == ((const char *)NULL))
              format_string = "[null]";

            break;
          }
          case 78:
          {
            ival=va_arg(ap, __typeof__(ival));
            /* assertion ival >= 0 */
            assert(ival >= 0);
            sval=va_arg(ap, __typeof__(sval));
            /* assertion sval != ((void *)0) */
            assert(sval != (const char *)(void *)0);
            do
            {
              tmp_post_10 = ival;
              ival = ival - 1;
              if(!(tmp_post_10 >= 1))
                break;

              if(length >= log_buffer_size + 18446744073709551610ul)
                break;

              const unsigned short int **return_value___ctype_b_loc_12;
              return_value___ctype_b_loc_12=__ctype_b_loc();
              if(!((16384 & (signed int)(*return_value___ctype_b_loc_12)[(signed long int)(signed int)*sval]) == 0))
                tmp_if_expr_13 = (signed int)*sval != 92 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_13 = (_Bool)0;
              if(tmp_if_expr_13)
              {
                tmp_post_11 = length;
                length = length + 1ul;
                outbuf[(signed long int)tmp_post_11] = *sval;
                outbuf[(signed long int)length] = (char)0;
              }

              else
              {
                signed int ret;
                ret=snprintf(outbuf + (signed long int)length, (log_buffer_size - length) - (unsigned long int)2, "\\x%.2x", (unsigned char)*sval);
                /* assertion ret == 4 */
                assert(ret == 4);
                length = length + (unsigned long int)4;
              }
              sval = sval + 1l;
            }
            while((_Bool)1);
            format_string = length < log_buffer_size - (unsigned long int)6 ? "" : "[too long]";
            break;
          }
          case 69:
          {
            return_value___errno_location_14=__errno_location();
            ival = *return_value___errno_location_14;
            format_string=strerror(ival);
            if(sval == ((const char *)NULL))
              snprintf(tempbuf, sizeof(char [5000l]) /*5000ul*/ , "(errno = %d)", ival);

            break;
          }
          case 84:
          {
            get_clf_timestamp(tempbuf, sizeof(char [5000l]) /*5000ul*/ );
            break;
          }
          default:
          {
            snprintf(tempbuf, sizeof(char [5000l]) /*5000ul*/ , "Bad format string: \"%s\"", fmt);
            loglevel = 0x4000;
          }
        }
        /* assertion length < log_buffer_size */
        assert(length < log_buffer_size);
        unsigned long int return_value_privoxy_strlcpy_15;
        return_value_privoxy_strlcpy_15=privoxy_strlcpy(outbuf + (signed long int)length, format_string, log_buffer_size - length);
        length = length + return_value_privoxy_strlcpy_15;
        if(length >= log_buffer_size + 18446744073709551614ul)
        {
          length = (log_buffer_size - sizeof(const char [26l]) /*26ul*/ ) - (unsigned long int)1;
          unsigned long int return_value_privoxy_strlcpy_16;
          static const char log_error__1__4__3__warning[26l] = { '.', '.', '.', ' ', '[', 't', 'o', 'o', ' ', 'l', 'o', 'n', 'g', ',', ' ', 't', 'r', 'u', 'n', 'c', 'a', 't', 'e', 'd', ']', 0 };
          return_value_privoxy_strlcpy_16=privoxy_strlcpy(outbuf + (signed long int)length, log_error__1__4__3__warning, log_buffer_size - length);
          length = length + return_value_privoxy_strlcpy_16;
          /* assertion length < log_buffer_size */
          assert(length < log_buffer_size);
          break;
        }

      }
    }
    va_end(ap);
    /* assertion length < log_buffer_size */
    assert(length < log_buffer_size);
    unsigned long int return_value_privoxy_strlcpy_17;
    return_value_privoxy_strlcpy_17=privoxy_strlcpy(outbuf + (signed long int)length, "\n", log_buffer_size - length);
    length = length + return_value_privoxy_strlcpy_17;
    if(length >= log_buffer_size)
      tmp_if_expr_18 = (_Bool)1;

    else
      tmp_if_expr_18 = (signed int)outbuf[(signed long int)(log_buffer_size - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_18)
      tmp_if_expr_19 = (_Bool)1;

    else
      tmp_if_expr_19 = (signed int)outbuf[(signed long int)log_buffer_size] != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_19)
    {
      /* assertion length < log_buffer_size */
      assert(length < log_buffer_size);
      /* assertion outbuf[log_buffer_size-1] == '\0' */
      assert((signed int)outbuf[(signed long int)(log_buffer_size - (unsigned long int)1)] == 0);
      /* assertion outbuf[log_buffer_size] == '\0' */
      assert((signed int)outbuf[(signed long int)log_buffer_size] == 0);
      snprintf(outbuf, log_buffer_size, "%s %08lx Fatal error: log_error()'s sanity checks failed.length: %d. Exiting.", (const void *)timestamp, thread_id, (signed int)length);
      loglevel = 0x4000;
    }

    /* assertion ((void *)0) != logfp */
    assert((struct _IO_FILE *)(void *)0 != logfp);
    if(loglevel == 0x4000)
      fatal_error(outbuf_save);

    if(!(logfp == ((struct _IO_FILE *)NULL)))
      fputs(outbuf_save, logfp);

    unlock_logfile();
  }

__CPROVER_DUMP_L43:
  ;
}

// lookup
// file list.h line 85
extern const char * lookup(struct map *the_map, const char *name)
{
  struct map_entry *cur_entry;
  /* assertion the_map */
  assert(the_map != ((struct map *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  cur_entry = the_map->first;
  for( ; !(cur_entry == ((struct map_entry *)NULL)); cur_entry = cur_entry->next)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(name, cur_entry->name);
    if(return_value_strcmp_1 == 0)
      return cur_entry->value;

  }
  return "";
}

// main
// file jcc.c line 3307
signed int main(signed int argc, char **argv)
{
  signed int argc_pos = 0;
  signed int do_config_test = 0;
  unsigned int random_seed;
  struct passwd *pw = (struct passwd *)(void *)0;
  struct group *grp = (struct group *)(void *)0;
  signed int do_chroot = 0;
  char *pre_chroot_nslookup_to_load_resolver = (char *)(void *)0;
  Argc = argc;
  Argv = argv;
  configfile = "config";
  initialize_mutexes();
  init_log_module();
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  do
  {
    argc_pos = argc_pos + 1;
    if(argc_pos >= argc)
      break;

    signed int return_value_strcmp_8;
    return_value_strcmp_8=strcmp(argv[(signed long int)argc_pos], "--help");
    if(return_value_strcmp_8 == 0)
      usage(argv[(signed long int)0]);

    else
    {
      return_value_strcmp_7=strcmp(argv[(signed long int)argc_pos], "--version");
      if(return_value_strcmp_7 == 0)
      {
        printf("Privoxy version 3.0.24 (http://www.privoxy.org/)\n");
        exit(0);
      }

      else
      {
        return_value_strcmp_6=strcmp(argv[(signed long int)argc_pos], "--no-daemon");
        if(return_value_strcmp_6 == 0)
        {
          set_debug_level(0x4000 | 0x2000 | 0x1000);
          daemon_mode = 0;
        }

        else
        {
          return_value_strcmp_5=strcmp(argv[(signed long int)argc_pos], "--pidfile");
          if(return_value_strcmp_5 == 0)
          {
            argc_pos = argc_pos + 1;
            if(argc_pos == argc)
              usage(argv[(signed long int)0]);

            pidfile=strdup_or_die(argv[(signed long int)argc_pos]);
          }

          else
          {
            return_value_strcmp_4=strcmp(argv[(signed long int)argc_pos], "--user");
            if(return_value_strcmp_4 == 0)
            {
              char *user_arg;
              char *group_name;
              argc_pos = argc_pos + 1;
              if(argc_pos == argc)
                usage(argv[(signed long int)argc_pos]);

              user_arg=strdup_or_die(argv[(signed long int)argc_pos]);
              group_name=strchr(user_arg, 46);
              if(!(group_name == ((char *)NULL)))
              {
                *group_name = (char)0;
                group_name = group_name + 1l;
                grp=getgrnam(group_name);
                if(grp == ((struct group *)NULL))
                  log_error(0x4000, "Group '%s' not found.", group_name);

              }

              pw=getpwnam(user_arg);
              if(pw == ((struct passwd *)NULL))
                log_error(0x4000, "User '%s' not found.", user_arg);

              if(!(user_arg == ((char *)NULL)))
              {
                free((void *)user_arg);
                user_arg = (char *)(void *)0;
              }

            }

            else
            {
              return_value_strcmp_3=strcmp(argv[(signed long int)argc_pos], "--pre-chroot-nslookup");
              if(return_value_strcmp_3 == 0)
              {
                argc_pos = argc_pos + 1;
                if(argc_pos == argc)
                  usage(argv[(signed long int)0]);

                pre_chroot_nslookup_to_load_resolver=strdup_or_die(argv[(signed long int)argc_pos]);
              }

              else
              {
                return_value_strcmp_2=strcmp(argv[(signed long int)argc_pos], "--chroot");
                if(return_value_strcmp_2 == 0)
                  do_chroot = 1;

                else
                {
                  return_value_strcmp_1=strcmp(argv[(signed long int)argc_pos], "--config-test");
                  if(return_value_strcmp_1 == 0)
                    do_config_test = 1;

                  else
                    if(!(1 + argc_pos == argc))
                      usage(argv[(signed long int)0]);

                    else
                      configfile = argv[(signed long int)argc_pos];
                }
              }
            }
          }
        }
      }
    }
  }
  while((_Bool)1);
  show_version(Argv[(signed long int)0]);
  if(!((signed int)*configfile == 47))
  {
    char cwd[5000l];
    char *abs_file;
    unsigned long int abs_file_size;
    char *return_value_getcwd_9;
    return_value_getcwd_9=getcwd(cwd, sizeof(char [5000l]) /*5000ul*/ );
    if(return_value_getcwd_9 == ((char *)NULL))
    {
      perror("failed to get current working directory");
      exit(1);
    }

    basedir=strdup_or_die(cwd);
    unsigned long int return_value_strlen_10;
    return_value_strlen_10=strlen(cwd);
    unsigned long int return_value_strlen_11;
    return_value_strlen_11=strlen(configfile);
    abs_file_size = return_value_strlen_10 + return_value_strlen_11 + (unsigned long int)5;
    void *return_value_malloc_or_die_12;
    return_value_malloc_or_die_12=malloc_or_die(abs_file_size);
    abs_file = (char *)return_value_malloc_or_die_12;
    privoxy_strlcpy(abs_file, basedir, abs_file_size);
    privoxy_strlcat(abs_file, "/", abs_file_size);
    privoxy_strlcat(abs_file, configfile, abs_file_size);
    configfile = abs_file;
  }

  files[0l].next = (struct file_list *)(void *)0;
  clients[0l].next = (struct client_states *)(void *)0;
  signed long int return_value_time_13;
  return_value_time_13=time((signed long int *)(void *)0);
  random_seed = (unsigned int)return_value_time_13;
  srandom(random_seed);
  signed int idx;
  const signed int catched_signals[3l] = { 15, 2, 1 };
  idx = 0;
  for( ; !((unsigned long int)idx >= 3ul); idx = idx + 1)
  {
    void (*return_value_signal_14)(signed int);
    return_value_signal_14=signal(catched_signals[(signed long int)idx], sig_handler);
    if(return_value_signal_14 == (void (*)(signed int))-1)
      log_error(0x4000, "Can't set signal-handler for signal %d: %E", catched_signals[(signed long int)idx]);

  }
  void (*return_value_signal_15)(signed int);
  return_value_signal_15=signal(13, (void (*)(signed int))1);
  if(return_value_signal_15 == (void (*)(signed int))-1)
    log_error(0x4000, "Can't set ignore-handler for SIGPIPE: %E");

  if(!(do_config_test == 0))
  {
    struct configuration_spec *return_value_load_config_16;
    return_value_load_config_16=load_config();
    exit((signed int)((struct configuration_spec *)(void *)0 == return_value_load_config_16));
  }

  cgi_init_error_messages();
  if(!(daemon_mode == 0))
  {
    signed int fd;
    signed int pid;
    pid=fork();
    if(!(pid >= 0))
    {
      perror("fork");
      exit(3);
    }

    else
      if(!(pid == 0))
      {
        signed int status;
        signed int wpid;
        sleep((unsigned int)1);
        wpid=waitpid(pid, &status, 1);
        if(!(wpid == 0))
          exit(1);

        exit(0);
      }

    setsid();
    close(0);
    close(1);
    fd=open("/dev/null", 00);
    if(fd == -1)
      log_error(0x4000, "Failed to open /dev/null: %E");

    else
      if(!(fd == 0))
      {
        signed int return_value_dup2_17;
        return_value_dup2_17=dup2(fd, 0);
        if(return_value_dup2_17 == -1)
          log_error(0x4000, "Failed to reserve fd 0: %E");

        close(fd);
      }

    fd=open("/dev/null", 01);
    if(fd == -1)
      log_error(0x4000, "Failed to open /dev/null: %E");

    else
      if(!(fd == 1))
      {
        signed int return_value_dup2_18;
        return_value_dup2_18=dup2(fd, 1);
        if(return_value_dup2_18 == -1)
          log_error(0x4000, "Failed to reserve fd 1: %E");

        close(fd);
      }

    fd = 0;
    for( ; !(fd >= 3); fd = fd + 1)
      mark_socket_for_close_on_execute(fd);
    chdir("/");
  }

  write_pid_file();
  unsigned int tmp_if_expr_19;
  signed int return_value_initgroups_22;
  if(!(pw == ((struct passwd *)NULL)))
  {
    if(!(grp == ((struct group *)NULL)))
      tmp_if_expr_19 = grp->gr_gid;

    else
      tmp_if_expr_19 = pw->pw_gid;
    signed int return_value_setgid_20;
    return_value_setgid_20=setgid(tmp_if_expr_19);
    if(!(return_value_setgid_20 == 0))
      log_error(0x4000, "Cannot setgid(): Insufficient permissions.");

    if(!(grp == ((struct group *)NULL)))
    {
      signed int return_value_setgroups_21;
      return_value_setgroups_21=setgroups((unsigned long int)1, &grp->gr_gid);
      if(!(return_value_setgroups_21 == 0))
        log_error(0x4000, "setgroups() failed: %E");

    }

    else
    {
      return_value_initgroups_22=initgroups(pw->pw_name, pw->pw_gid);
      if(!(return_value_initgroups_22 == 0))
        log_error(0x4000, "initgroups() failed: %E");

    }
    if(!(do_chroot == 0))
    {
      if(pw->pw_dir == ((char *)NULL))
        log_error(0x4000, "Home directory for %s undefined", pw->pw_name);

      tzset();
      if(!(pre_chroot_nslookup_to_load_resolver == ((char *)NULL)))
      {
        if(!((signed int)*pre_chroot_nslookup_to_load_resolver == 0))
          resolve_hostname_to_ip(pre_chroot_nslookup_to_load_resolver);

      }

      signed int return_value_chroot_23;
      return_value_chroot_23=chroot(pw->pw_dir);
      if(!(return_value_chroot_23 >= 0))
        log_error(0x4000, "Cannot chroot to %s", pw->pw_dir);

      signed int return_value_chdir_24;
      return_value_chdir_24=chdir("/");
      if(!(return_value_chdir_24 == 0))
        log_error(0x4000, "Cannot chdir /");

    }

    signed int return_value_setuid_25;
    return_value_setuid_25=setuid(pw->pw_uid);
    if(!(return_value_setuid_25 == 0))
      log_error(0x4000, "Cannot setuid(): Insufficient permissions.");

    if(!(do_chroot == 0))
    {
      char putenv_dummy[64l];
      privoxy_strlcpy(putenv_dummy, "HOME=/", sizeof(char [64l]) /*64ul*/ );
      signed int return_value_putenv_26;
      return_value_putenv_26=putenv(putenv_dummy);
      if(!(return_value_putenv_26 == 0))
        log_error(0x4000, "Cannot putenv(): HOME");

      snprintf(putenv_dummy, sizeof(char [64l]) /*64ul*/ , "USER=%s", pw->pw_name);
      signed int return_value_putenv_27;
      return_value_putenv_27=putenv(putenv_dummy);
      if(!(return_value_putenv_27 == 0))
        log_error(0x4000, "Cannot putenv(): USER");

    }

  }

  else
    if(!(do_chroot == 0))
      log_error(0x4000, "Cannot chroot without --user argument.");

  listen_loop();
  return -1;
}

// make_menu
// file cgi.c line 2382
extern char * make_menu(const char *self, const unsigned int feature_flags)
{
  struct cgi_dispatcher *d;
  char *result;
  result=strdup("");
  if(self == ((const char *)NULL))
    self = "NO-SUCH-CGI!";

  d = cgi_dispatchers;
  signed int return_value_strcmp_1;
  signed int return_value_strcmp_2;
  for( ; !(d->name == ((const char *)NULL)); d = d + 1l)
  {
    if((2U & feature_flags) == 0u)
    {
      return_value_strcmp_1=strcmp(d->name, "toggle");
      if(return_value_strcmp_1 == 0)
        goto __CPROVER_DUMP_L7;

    }

    if(!(d->description == ((const char *)NULL)))
    {
      return_value_strcmp_2=strcmp(d->name, self);
      if(!(return_value_strcmp_2 == 0))
      {
        char *html_encoded_prefix;
        string_append(&result, "<li><a href=\"");
        html_encoded_prefix=html_encode("http://config.privoxy.org/");
        if(html_encoded_prefix == ((char *)NULL))
          return (char *)(void *)0;

        else
        {
          string_append(&result, html_encoded_prefix);
          free((void *)html_encoded_prefix);
        }
        string_append(&result, d->name);
        string_append(&result, "\">");
        string_append(&result, d->description);
        string_append(&result, "</a></li>");
      }

    }


  __CPROVER_DUMP_L7:
    ;
  }
  return result;
}

// make_path
// file miscutil.h line 69
extern char * make_path(const char *dir, const char *file)
{
  _Bool tmp_if_expr_1;
  if(file == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)*file == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_8;
  if(tmp_if_expr_1)
    return (char *)(void *)0;

  else
  {
    if(dir == ((const char *)NULL))
      tmp_if_expr_10 = (_Bool)1;

    else
      tmp_if_expr_10 = (signed int)*dir == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_10)
      tmp_if_expr_11 = (_Bool)1;

    else
      tmp_if_expr_11 = (signed int)*file == 47 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_11)
    {
      char *return_value_strdup_2;
      return_value_strdup_2=strdup(file);
      return return_value_strdup_2;
    }

    else
    {
      char *path;
      unsigned long int path_size;
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(dir);
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(file);
      path_size = return_value_strlen_3 + return_value_strlen_4 + (unsigned long int)2;
      if(!(basedir == ((const char *)NULL)) && !((signed int)*dir == 47))
        tmp_if_expr_8 = *basedir != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_8 = (_Bool)0;
      if(tmp_if_expr_8)
      {
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(basedir);
        path_size = path_size + return_value_strlen_5 + (unsigned long int)1;
        void *return_value_malloc_6;
        return_value_malloc_6=malloc(path_size);
        path = (char *)return_value_malloc_6;
        if(path == ((char *)NULL))
          log_error(0x4000, "malloc failed!");

        privoxy_strlcpy(path, basedir, path_size);
        privoxy_strlcat(path, "/", path_size);
        privoxy_strlcat(path, dir, path_size);
      }

      else
      {
        void *return_value_malloc_7;
        return_value_malloc_7=malloc(path_size);
        path = (char *)return_value_malloc_7;
        if(path == ((char *)NULL))
          log_error(0x4000, "malloc failed!");

        privoxy_strlcpy(path, dir, path_size);
      }
      /* assertion ((void *)0) != path */
      assert((char *)(void *)0 != path);
      unsigned long int return_value_strlen_9;
      return_value_strlen_9=strlen(path);
      if(!((signed int)path[-1l + (signed long int)return_value_strlen_9] == 47))
        privoxy_strlcat(path, "/", path_size);

      privoxy_strlcat(path, file, path_size);
      return path;
    }
  }
}

// malloc_or_die
// file miscutil.h line 50
extern void * malloc_or_die(unsigned long int buffer_size)
{
  char *new_buf;
  if(buffer_size == 0ul)
  {
    log_error(0x2000, "malloc_or_die() called with buffer size 0");
    /* assertion buffer_size != 0 */
    assert(buffer_size != (unsigned long int)0);
    buffer_size = (unsigned long int)4096;
  }

  void *return_value_malloc_1;
  return_value_malloc_1=malloc(buffer_size);
  new_buf = (char *)return_value_malloc_1;
  if(new_buf == ((char *)NULL))
  {
    /* assertion new_buf != ((void *)0) */
    assert(new_buf != (char *)(void *)0);
    log_error(0x4000, "Out of memory in malloc_or_die().");
    exit(1);
  }

  return (void *)new_buf;
}

// map
// file list.h line 80
extern enum privoxy_err map(struct map *the_map, const char *name, signed int name_needs_copying, const char *value, signed int value_needs_copying)
{
  struct map_entry *new_entry;
  /* assertion the_map */
  assert(the_map != ((struct map *)NULL));
  _Bool tmp_if_expr_2;
  void *return_value_zalloc_1;
  if(name == ((const char *)NULL) || value == ((const char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_zalloc_1=zalloc(sizeof(struct map_entry) /*24ul*/ );
    new_entry = (struct map_entry *)return_value_zalloc_1;
    tmp_if_expr_2 = (struct map_entry *)(void *)0 == new_entry ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
  {
    if(name_needs_copying == 0 && !(name == ((const char *)NULL)))
      free((void *)(char *)name);

    if(value_needs_copying == 0 && !(value == ((const char *)NULL)))
      free((void *)(char *)value);

    return (enum privoxy_err)JB_ERR_MEMORY;
  }

  else
    if(!(name_needs_copying == 0))
    {
      name=strdup(name);
      if(!(name == ((const char *)NULL)))
        goto __CPROVER_DUMP_L7;

      free((void *)new_entry);
      if(value_needs_copying == 0)
        free((void *)(char *)value);

      return (enum privoxy_err)JB_ERR_MEMORY;
    }

    else
    {

    __CPROVER_DUMP_L7:
      ;
      if(!(value_needs_copying == 0))
      {
        value=strdup(value);
        if(!(value == ((const char *)NULL)))
          goto __CPROVER_DUMP_L8;

        free((void *)(char *)name);
        free((void *)new_entry);
        return (enum privoxy_err)JB_ERR_MEMORY;
      }

      else
      {

      __CPROVER_DUMP_L8:
        ;
        new_entry->name = name;
        new_entry->value = value;
        if(!(the_map->last == ((struct map_entry *)NULL)))
        {
          the_map->last->next = new_entry;
          the_map->last = new_entry;
        }

        else
        {
          the_map->first = new_entry;
          the_map->last = new_entry;
        }
        return (enum privoxy_err)JB_ERR_OK;
      }
    }
}

// map_block_keep
// file cgi.c line 2293
extern enum privoxy_err map_block_keep(struct map *exports, const char *name)
{
  enum privoxy_err err;
  char buf[500l];
  /* assertion exports */
  assert(exports != ((struct map *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  /* assertion strlen(name) < (size_t)490 */
  assert(return_value_strlen_1 < (unsigned long int)490);
  snprintf(buf, sizeof(char [500l]) /*500ul*/ , "if-%s-start", name);
  err=map(exports, buf, 1, "", 1);
  if(!(err == /*enum*/JB_ERR_OK))
    return err;

  else
  {
    snprintf(buf, sizeof(char [500l]) /*500ul*/ , "if-%s-end", name);
    enum privoxy_err return_value_map_2;
    return_value_map_2=map(exports, buf, 1, "", 1);
    return return_value_map_2;
  }
}

// map_block_killer
// file cgi.c line 2264
extern enum privoxy_err map_block_killer(struct map *exports, const char *name)
{
  char buf[1000l];
  /* assertion exports */
  assert(exports != ((struct map *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  /* assertion strlen(name) < (size_t)490 */
  assert(return_value_strlen_1 < (unsigned long int)490);
  snprintf(buf, sizeof(char [1000l]) /*1000ul*/ , "if-%s-start.*if-%s-end", name, name);
  enum privoxy_err return_value_map_2;
  return_value_map_2=map(exports, buf, 1, "", 1);
  return return_value_map_2;
}

// map_conditional
// file cgi.c line 2340
extern enum privoxy_err map_conditional(struct map *exports, const char *name, signed int choose_first)
{
  char buf[1000l];
  enum privoxy_err err;
  /* assertion exports */
  assert(exports != ((struct map *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  /* assertion strlen(name) < (size_t)480 */
  assert(return_value_strlen_1 < (unsigned long int)480);
  snprintf(buf, sizeof(char [1000l]) /*1000ul*/ , choose_first != 0 ? "else-not-%s@.*@endif-%s" : "if-%s-then@.*@else-not-%s", name, name);
  err=map(exports, buf, 1, "", 1);
  if(!(err == /*enum*/JB_ERR_OK))
    return err;

  else
  {
    snprintf(buf, sizeof(char [1000l]) /*1000ul*/ , choose_first != 0 ? "if-%s-then" : "endif-%s", name);
    enum privoxy_err return_value_map_2;
    return_value_map_2=map(exports, buf, 1, "", 1);
    return return_value_map_2;
  }
}

// map_copy_parameter_html
// file cgiedit.c line 394
static enum privoxy_err map_copy_parameter_html(struct map *out, struct map *in, const char *name)
{
  const char *value;
  enum privoxy_err err;
  /* assertion out */
  assert(out != ((struct map *)NULL));
  /* assertion in */
  assert(in != ((struct map *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  value=lookup(in, name);
  char *return_value_html_encode_1;
  return_value_html_encode_1=html_encode(value);
  err=map(out, name, 1, return_value_html_encode_1, 0);
  if(!(err == /*enum*/JB_ERR_OK))
    return err;

  else
    if((signed int)*value == 0)
      return (enum privoxy_err)JB_ERR_CGI_PARAMS;

    else
      return (enum privoxy_err)JB_ERR_OK;
}

// map_radio
// file cgiedit.c line 1955
static enum privoxy_err map_radio(struct map *exports, const char *optionname, const char *values, signed int value)
{
  char *buf;
  char *p;
  char c;
  unsigned long int len;
  len=strlen(optionname);
  const unsigned long int buf_size = len + (unsigned long int)3;
  /* assertion exports */
  assert(exports != ((struct map *)NULL));
  /* assertion optionname */
  assert(optionname != ((const char *)NULL));
  /* assertion values */
  assert(values != ((const char *)NULL));
  void *return_value_malloc_or_die_1;
  return_value_malloc_or_die_1=malloc_or_die(buf_size);
  buf = (char *)return_value_malloc_or_die_1;
  privoxy_strlcpy(buf, optionname, buf_size);
  p = buf + (signed long int)len;
  char *tmp_post_2 = p;
  p = p + 1l;
  *tmp_post_2 = (char)45;
  p[(signed long int)1] = (char)0;
  const char *tmp_post_3;
  do
  {
    tmp_post_3 = values;
    values = values + 1l;
    c = *tmp_post_3;
    if((signed int)c == 0)
      break;

    if(!((signed int)c == value))
    {
      *p = c;
      enum privoxy_err return_value_map_4;
      return_value_map_4=map(exports, buf, 1, "", 1);
      if(!(return_value_map_4 == /*enum*/JB_ERR_OK))
        return (enum privoxy_err)JB_ERR_MEMORY;

    }

  }
  while((_Bool)1);
  *p = (char)value;
  enum privoxy_err return_value_map_5;
  return_value_map_5=map(exports, buf, 0, "checked", 1);
  return return_value_map_5;
}

// mark_connection_closed
// file gateway.c line 280
extern void mark_connection_closed(struct reusable_connection *closed_connection)
{
  closed_connection->in_use = 0;
  closed_connection->sfd = -1;
  if(!(closed_connection->host == ((char *)NULL)))
  {
    free((void *)closed_connection->host);
    closed_connection->host = (char *)(void *)0;
  }

  closed_connection->port = 0;
  closed_connection->timestamp = (signed long int)0;
  closed_connection->request_sent = (signed long int)0;
  closed_connection->response_received = (signed long int)0;
  closed_connection->keep_alive_timeout = (unsigned int)0;
  closed_connection->requests_sent_total = (unsigned int)0;
  closed_connection->forwarder_type = (enum forwarder_type)SOCKS_NONE;
  if(!(closed_connection->gateway_host == ((char *)NULL)))
  {
    free((void *)closed_connection->gateway_host);
    closed_connection->gateway_host = (char *)(void *)0;
  }

  closed_connection->gateway_port = 0;
  if(!(closed_connection->forward_host == ((char *)NULL)))
  {
    free((void *)closed_connection->forward_host);
    closed_connection->forward_host = (char *)(void *)0;
  }

  closed_connection->forward_port = 0;
}

// mark_connection_unused
// file gateway.c line 533
static signed int mark_connection_unused(struct reusable_connection *connection)
{
  unsigned int slot = (unsigned int)0;
  signed int socket_found = 0;
  /* assertion connection->sfd != (-1) */
  assert(connection->sfd != -1);
  privoxy_mutex_lock(&connection_reuse_mutex);
  slot = (unsigned int)0;
  for( ; !((unsigned long int)slot >= 100ul); slot = slot + 1u)
    if(reusable_connection[(signed long int)slot].sfd == connection->sfd)
    {
      /* assertion reusable_connection[slot].in_use */
      assert(reusable_connection[(signed long int)slot].in_use != 0);
      socket_found = 1;
      log_error(0x0002, "Marking open socket %d for %s:%d in slot %d as unused.", connection->sfd, reusable_connection[(signed long int)slot].host, reusable_connection[(signed long int)slot].port, slot);
      reusable_connection[(signed long int)slot].in_use = 0;
      reusable_connection[(signed long int)slot].timestamp = connection->timestamp;
      break;
    }

  privoxy_mutex_unlock(&connection_reuse_mutex);
  return socket_found;
}

// mark_server_socket_tainted
// file jcc.c line 1214
static void mark_server_socket_tainted(struct client_state *csp)
{
  if(!((0x00001000U & csp->flags) == 0u))
  {
    if((0x00040000U & csp->flags) == 0u)
      log_error(0x0002, "Marking the server socket %d tainted.", csp->server_connection.sfd);

  }

  csp->flags = csp->flags | 0x00040000U;
}

// mark_socket_for_close_on_execute
// file jbsockets.h line 65
extern void mark_socket_for_close_on_execute(signed int fd)
{
  signed int ret;
  ret=fcntl(fd, 2, 1);
  if(ret == -1)
    log_error(0x2000, "fcntl(%d, F_SETFD, FD_CLOEXEC) failed", fd);

}

// match_actions_file_header_line
// file cgiedit.c line 952
static signed int match_actions_file_header_line(const char *line, const char *name)
{
  unsigned long int len;
  /* assertion line */
  assert(line != ((const char *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  _Bool tmp_if_expr_1;
  if(!((signed int)*line == 123))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)line[(signed long int)1] != 123 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_1)
    return 1;

  else
  {
    line = line + (signed long int)2;
    for( ; (_Bool)1; line = line + 1l)
      if(!((signed int)*line == 32))
      {
        if(!((signed int)*line == 9))
          goto __CPROVER_DUMP_L6;

      }


  __CPROVER_DUMP_L6:
    ;
    len=strlen(name);
    signed int return_value_strncmpic_2;
    return_value_strncmpic_2=strncmpic(line, name, len);
    if(!(return_value_strncmpic_2 == 0))
      return 1;

    else
    {
      line = line + (signed long int)len;
      for( ; (_Bool)1; line = line + 1l)
        if(!((signed int)*line == 32))
        {
          if(!((signed int)*line == 9))
            goto __CPROVER_DUMP_L10;

        }


    __CPROVER_DUMP_L10:
      ;
      if(!((signed int)*line == 125))
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)line[(signed long int)1] != 125 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = (signed int)line[(signed long int)2] != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
        return 1;

      else
        return 0;
    }
  }
}

// match_portlist
// file urlmatch.h line 58
extern signed int match_portlist(const char *portlist, signed int port)
{
  char *min;
  char *max;
  char *next;
  char *portlist_copy;
  portlist_copy=strdup_or_die(portlist);
  min = portlist_copy;
  next=strchr(portlist_copy, (signed int)44);
  char *tmp_post_1;
  if(!(next == ((char *)NULL)))
  {
    tmp_post_1 = next;
    next = next + 1l;
    *tmp_post_1 = (char)0;
  }

  char *tmp_post_3;
  signed int return_value_atoi_4;
  signed int tmp_if_expr_6;
  signed int return_value_atoi_5;
  char *tmp_post_8;
  while(!(min == ((char *)NULL)))
  {
    max=strchr(min, (signed int)45);
    if(max == ((char *)NULL))
    {
      signed int return_value_atoi_2;
      return_value_atoi_2=atoi(min);
      if(port == return_value_atoi_2)
      {
        if(!(portlist_copy == ((char *)NULL)))
        {
          free((void *)portlist_copy);
          portlist_copy = (char *)(void *)0;
        }

        return 1;
      }

    }

    else
    {
      tmp_post_3 = max;
      max = max + 1l;
      *tmp_post_3 = (char)0;
      signed int return_value_atoi_7;
      return_value_atoi_7=atoi(min);
      if(port >= return_value_atoi_7)
      {
        return_value_atoi_4=atoi(max);
        if(!(return_value_atoi_4 == 0))
        {
          return_value_atoi_5=atoi(max);
          tmp_if_expr_6 = return_value_atoi_5;
        }

        else
          tmp_if_expr_6 = 65535;
        if(tmp_if_expr_6 >= port)
        {
          if(!(portlist_copy == ((char *)NULL)))
          {
            free((void *)portlist_copy);
            portlist_copy = (char *)(void *)0;
          }

          return 1;
        }

      }

    }
    min = next;
    if(!(next == ((char *)NULL)))
    {
      next=strchr(next, (signed int)44);
      if(!(next == ((char *)NULL)))
      {
        tmp_post_8 = next;
        next = next + 1l;
        *tmp_post_8 = (char)0;
      }

    }

  }
  if(!(portlist_copy == ((char *)NULL)))
  {
    free((void *)portlist_copy);
    portlist_copy = (char *)(void *)0;
  }

  return 0;
}

// match_sockaddr
// file filters.c line 168
static signed int match_sockaddr(struct sockaddr_storage *network, struct sockaddr_storage *netmask, struct sockaddr_storage *address)
{
  unsigned char *network_addr;
  unsigned char *netmask_addr;
  unsigned char *address_addr;
  unsigned int addr_len;
  unsigned short int *network_port;
  unsigned short int *netmask_port;
  unsigned short int *address_port;
  signed int i;
  if(!(network->ss_family == netmask->ss_family))
  {
    /* assertion network->ss_family == netmask->ss_family */
    assert(network->ss_family == netmask->ss_family);
    log_error(0x4000, "Network and netmask differ in family.");
  }

  sockaddr_storage_to_ip(network, &network_addr, &addr_len, &network_port);
  sockaddr_storage_to_ip(netmask, &netmask_addr, (unsigned int *)(void *)0, &netmask_port);
  sockaddr_storage_to_ip(address, &address_addr, (unsigned int *)(void *)0, &address_port);
  _Bool tmp_if_expr_5;
  if((signed int)network->ss_family == 2)
    tmp_if_expr_5 = (signed int)address->ss_family == 10 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_5 = (_Bool)0;
  _Bool tmp_if_expr_10;
  _Bool tmp_statement_expression_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_9;
  unsigned int return_value_htonl_8;
  if(tmp_if_expr_5)
  {
    struct in6_addr *match_sockaddr__1__2____a = (struct in6_addr *)address_addr;
    if(match_sockaddr__1__2____a->__in6_u.__u6_addr32[0l] == 0u)
      tmp_if_expr_7 = match_sockaddr__1__2____a->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_7 = (_Bool)0;
    if(tmp_if_expr_7)
    {
      return_value_htonl_8=htonl((unsigned int)0xffff);
      tmp_if_expr_9 = match_sockaddr__1__2____a->__in6_u.__u6_addr32[(signed long int)2] == return_value_htonl_8 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_9 = (_Bool)0;
    tmp_statement_expression_6 = tmp_if_expr_9;
    tmp_if_expr_10 = tmp_statement_expression_6 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_10 = (_Bool)0;
  _Bool tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  unsigned int return_value_htonl_3;
  if(tmp_if_expr_10)
  {
    address_addr = address_addr + (signed long int)12;
    addr_len = (unsigned int)4;
  }

  else
    if((signed int)network->ss_family == 10)
    {
      if((signed int)address->ss_family == 2)
      {
        struct in6_addr *__a = (struct in6_addr *)network_addr;
        if(__a->__in6_u.__u6_addr32[0l] == 0u)
          tmp_if_expr_2 = __a->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
        {
          return_value_htonl_3=htonl((unsigned int)0xffff);
          tmp_if_expr_4 = __a->__in6_u.__u6_addr32[(signed long int)2] == return_value_htonl_3 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_4 = (_Bool)0;
        tmp_statement_expression_1 = tmp_if_expr_4;
        if(tmp_statement_expression_1)
        {
          network_addr = network_addr + (signed long int)12;
          netmask_addr = netmask_addr + (signed long int)12;
          addr_len = (unsigned int)4;
        }

      }

    }

  _Bool tmp_if_expr_11;
  if(!(*netmask_port == 0))
  {
    if(*network_port == *address_port)
      goto __CPROVER_DUMP_L16;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L16:
    ;
    i = 0;
    do
    {
      if(!((unsigned int)i >= addr_len))
        tmp_if_expr_11 = netmask_addr[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_11 = (_Bool)0;
      if(!tmp_if_expr_11)
        break;

      if(!(((signed int)netmask_addr[(signed long int)i] & (signed int)network_addr[(signed long int)i]) == ((signed int)address_addr[(signed long int)i] & (signed int)netmask_addr[(signed long int)i])))
        return 0;

      i = i + 1;
    }
    while((_Bool)1);
    return 1;
  }
}

// merge_actions
// file actions.c line 144
extern enum privoxy_err merge_actions(struct action_spec *dest, struct action_spec *src)
{
  signed int i;
  enum privoxy_err err;
  dest->mask = dest->mask & src->mask;
  dest->add = dest->add & src->mask;
  dest->add = dest->add | src->add;
  i = 0;
  for( ; !(i >= 19); i = i + 1)
  {
    char *str = src->string[(signed long int)i];
    if(!(str == ((char *)NULL)))
    {
      if(!(dest->string[(signed long int)i] == ((char *)NULL)))
      {
        free((void *)dest->string[(signed long int)i]);
        dest->string[(signed long int)i] = (char *)(void *)0;
      }

      dest->string[(signed long int)i]=strdup_or_die(str);
    }

  }
  i = 0;
  for( ; !(i >= 7); i = i + 1)
  {
    if(!(src->multi_remove_all[(signed long int)i] == 0))
    {
      list_remove_all(dest->multi_remove[(signed long int)i]);
      dest->multi_remove_all[(signed long int)i] = 1;
      err=list_duplicate(dest->multi_add[(signed long int)i], src->multi_add[(signed long int)i]);
    }

    else
      if(!(dest->multi_remove_all[(signed long int)i] == 0))
      {
        list_remove_list(dest->multi_add[(signed long int)i], src->multi_remove[(signed long int)i]);
        err=list_append_list_unique(dest->multi_add[(signed long int)i], src->multi_add[(signed long int)i]);
      }

      else
      {
        list_remove_list(dest->multi_add[(signed long int)i], src->multi_remove[(signed long int)i]);
        err=list_append_list_unique(dest->multi_remove[(signed long int)i], src->multi_remove[(signed long int)i]);
        if(err == /*enum*/JB_ERR_OK)
          err=list_append_list_unique(dest->multi_add[(signed long int)i], src->multi_add[(signed long int)i]);

      }
    if(!(err == /*enum*/JB_ERR_OK))
      return err;

  }
  return (enum privoxy_err)JB_ERR_OK;
}

// merge_current_action
// file actions.c line 737
extern enum privoxy_err merge_current_action(struct current_action_spec *dest, struct action_spec *src)
{
  signed int i;
  enum privoxy_err err = (enum privoxy_err)JB_ERR_OK;
  dest->flags = dest->flags & src->mask;
  dest->flags = dest->flags | src->add;
  i = 0;
  for( ; !(i >= 19); i = i + 1)
  {
    char *str = src->string[(signed long int)i];
    if(!(str == ((char *)NULL)))
    {
      str=strdup_or_die(str);
      if(!(dest->string[(signed long int)i] == ((char *)NULL)))
      {
        free((void *)dest->string[(signed long int)i]);
        dest->string[(signed long int)i] = (char *)(void *)0;
      }

      dest->string[(signed long int)i] = str;
    }

  }
  i = 0;
  for( ; !(i >= 7); i = i + 1)
    if(!(src->multi_remove_all[(signed long int)i] == 0))
    {
      err=list_duplicate(dest->multi[(signed long int)i], src->multi_add[(signed long int)i]);
      if(!(err == /*enum*/JB_ERR_OK))
        return err;

    }

    else
    {
      list_remove_list(dest->multi[(signed long int)i], src->multi_remove[(signed long int)i]);
      err=list_append_list_unique(dest->multi[(signed long int)i], src->multi_add[(signed long int)i]);
      if(!(err == /*enum*/JB_ERR_OK))
        return err;

    }
  return err;
}

// new_map
// file list.h line 77
extern struct map * new_map(void)
{
  struct map *empty_map;
  void *return_value_zalloc_1;
  return_value_zalloc_1=zalloc(sizeof(struct map) /*16ul*/ );
  empty_map = (struct map *)return_value_zalloc_1;
  if(empty_map == ((struct map *)NULL))
    exit(1);

  return empty_map;
}

// normalize_http_version
// file urlmatch.c line 497
static enum privoxy_err normalize_http_version(char *http_version)
{
  unsigned int major_version;
  unsigned int minor_version;
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(http_version, "HTTP/%u.%u", &major_version, &minor_version);
  if(!(return_value_sscanf_1 == 2))
  {
    log_error(0x2000, "Unsupported HTTP version: %s", http_version);
    return (enum privoxy_err)JB_ERR_PARSE;
  }

  else
    if(!(minor_version == 0u) && !(minor_version == 1u) || !(major_version == 1u))
    {
      log_error(0x2000, "The only supported HTTP versions are 1.0 and 1.1. This rules out: %s", http_version);
      return (enum privoxy_err)JB_ERR_PARSE;
    }

    else
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(http_version);
      /* assertion strlen(http_version) >= 8 */
      assert(return_value_strlen_2 >= (unsigned long int)8);
      snprintf(http_version, (unsigned long int)9, "HTTP/%u.%u", major_version, minor_version);
      return (enum privoxy_err)JB_ERR_OK;
    }
}

// normalize_lws
// file parsers.c line 768
static void normalize_lws(char *header)
{
  char *p = header;
  const unsigned short int **return_value___ctype_b_loc_2;
  const unsigned short int **return_value___ctype_b_loc_1;
  while(!((signed int)*p == 0))
  {
    const unsigned short int **return_value___ctype_b_loc_3;
    return_value___ctype_b_loc_3=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)(unsigned char)*p]) == 0))
    {
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)p[1l]]) == 0))
      {
        char *q = p + (signed long int)1;
        do
        {
          return_value___ctype_b_loc_1=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)*q]) == 0)
            break;

          q = q + 1l;
        }
        while((_Bool)1);
        log_error(0x0008, "Reducing whitespace in '%s'", header);
        string_move(p + (signed long int)1, q);
      }

    }

    if((signed int)*p == 9)
    {
      log_error(0x0008, "Converting tab to space in '%s'", header);
      *p = (char)32;
    }

    else
      if((signed int)*p == 34)
      {
        char *end_of_token;
        end_of_token=strstr(p + (signed long int)1, "\"");
        if(!(end_of_token == ((char *)NULL)))
          p = end_of_token;

        else
          log_error(0x0008, "Ignoring single quote in '%s'", header);
      }

    p = p + 1l;
  }
  p=strchr(header, 58);
  const unsigned short int **return_value___ctype_b_loc_4;
  if(!(p == ((char *)NULL)) && !(p == header))
  {
    return_value___ctype_b_loc_4=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(unsigned char)p[-1l]]) == 0))
      string_move(p - (signed long int)1, p);

  }

}

// parse_cgi_parameters
// file cgi.c line 612
static struct map * parse_cgi_parameters(char *argstring)
{
  char *p;
  char **vector;
  signed int pairs;
  signed int i;
  struct map *cgi_params;
  unsigned long int max_segments;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(argstring);
  max_segments = return_value_strlen_1 / (unsigned long int)2;
  if(max_segments == 0ul)
    max_segments = (unsigned long int)1;

  void *return_value_malloc_or_die_2;
  return_value_malloc_or_die_2=malloc_or_die(max_segments * sizeof(char *) /*8ul*/ );
  vector = (char **)return_value_malloc_or_die_2;
  cgi_params=new_map();
  p=strchr(argstring, 35);
  if(!(p == ((char *)NULL)))
    *p = (char)0;

  pairs=ssplit(argstring, "&", vector, max_segments);
  /* assertion pairs != -1 */
  assert(pairs != -1);
  if(pairs == -1)
  {
    if(!(vector == ((char **)NULL)))
    {
      free((void *)vector);
      vector = (char **)(void *)0;
    }

    free_map(cgi_params);
    return (struct map *)(void *)0;
  }

  else
  {
    i = 0;
    for( ; !(i >= pairs); i = i + 1)
    {
      p=strchr(vector[(signed long int)i], 61);
      if(!(p == ((char *)NULL)))
      {
        if(!((signed int)p[1l] == 0))
        {
          *p = (char)0;
          char *return_value_url_decode_3;
          return_value_url_decode_3=url_decode(vector[(signed long int)i]);
          p = p + 1l;
          char *return_value_url_decode_4;
          return_value_url_decode_4=url_decode(p);
          enum privoxy_err return_value_map_5;
          return_value_map_5=map(cgi_params, return_value_url_decode_3, 0, return_value_url_decode_4, 0);
          if(!(return_value_map_5 == /*enum*/JB_ERR_OK))
          {
            if(!(vector == ((char **)NULL)))
            {
              free((void *)vector);
              vector = (char **)(void *)0;
            }

            free_map(cgi_params);
            return (struct map *)(void *)0;
          }

        }

      }

    }
    if(!(vector == ((char **)NULL)))
    {
      free((void *)vector);
      vector = (char **)(void *)0;
    }

    return cgi_params;
  }
}

// parse_client_header_order
// file loadcfg.c line 386
static void parse_client_header_order(struct list *ordered_header_list, const char *ordered_headers)
{
  char *original_headers_copy;
  char **vector;
  unsigned long int max_segments;
  signed int number_of_headers;
  signed int i;
  /* assertion ordered_header_list != ((void *)0) */
  assert(ordered_header_list != (struct list *)(void *)0);
  /* assertion ordered_headers != ((void *)0) */
  assert(ordered_headers != (const char *)(void *)0);
  if(ordered_headers == ((const char *)NULL))
    log_error(0x4000, "header-order used without argument");

  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(ordered_headers);
  max_segments = return_value_strlen_1 / (unsigned long int)2;
  if(max_segments == 0ul)
    max_segments = (unsigned long int)1;

  void *return_value_malloc_or_die_2;
  return_value_malloc_or_die_2=malloc_or_die(max_segments * sizeof(char *) /*8ul*/ );
  vector = (char **)return_value_malloc_or_die_2;
  original_headers_copy=strdup_or_die(ordered_headers);
  number_of_headers=ssplit(original_headers_copy, "\t ", vector, max_segments);
  if(number_of_headers == -1)
    log_error(0x4000, "Failed to split ordered headers");

  i = 0;
  for( ; !(i >= number_of_headers); i = i + 1)
  {
    enum privoxy_err return_value_enlist_3;
    return_value_enlist_3=enlist(ordered_header_list, vector[(signed long int)i]);
    if(!((signed int)return_value_enlist_3 == JB_ERR_OK))
      log_error(0x4000, "Failed to enlist ordered header: %s", vector[(signed long int)i]);

  }
  if(!(vector == ((char **)NULL)))
  {
    free((void *)vector);
    vector = (char **)(void *)0;
  }

  if(!(original_headers_copy == ((char *)NULL)))
  {
    free((void *)original_headers_copy);
    original_headers_copy = (char *)(void *)0;
  }

  goto __CPROVER_DUMP_L9;

__CPROVER_DUMP_L9:
  ;
}

// parse_client_request
// file jcc.c line 1718
static enum privoxy_err parse_client_request(struct client_state *csp)
{
  struct http_request *http = csp->http;
  enum privoxy_err err;
  signed int return_value_strcmpic_1;
  if(!((128U & csp->config->feature_flags) == 0u))
  {
    return_value_strcmpic_1=strcmpic(csp->http[0l].ver, "HTTP/1.1");
    if(return_value_strcmpic_1 == 0)
    {
      if(csp->http[0l].ssl == 0)
        csp->flags = csp->flags | 0x00008000U;

    }

  }

  if(csp->http[0l].ssl == 0)
  {
    if(!((0x01000000U & csp->flags) == 0u))
    {
      enum privoxy_err return_value_receive_chunked_client_request_body_2;
      return_value_receive_chunked_client_request_body_2=receive_chunked_client_request_body(csp);
      if(!((signed int)return_value_receive_chunked_client_request_body_2 == JB_ERR_OK))
        return (enum privoxy_err)JB_ERR_PARSE;

    }

    else
      csp->expected_client_content_length=get_expected_content_length(csp->headers);
    verify_request_length(csp);
  }

  err=sed(csp, 0);
  if(!((signed int)err == JB_ERR_OK))
  {
    log_error(0x2000, "Failed to parse client request from %s.", csp->ip_addr_str);
    log_error(0x0200, "%s - - [%T] \"%s\" 400 0", csp->ip_addr_str, csp->http[0l].cmd);
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(CHEADER);
    write_socket(csp->cfd, CHEADER, return_value_strlen_3);
    return (enum privoxy_err)JB_ERR_PARSE;
  }

  csp->flags = csp->flags | 0x00000100U;
  _Bool tmp_if_expr_8;
  signed int return_value_strcmp_5;
  _Bool tmp_if_expr_7;
  enum privoxy_err return_value_change_request_destination_6;
  if(csp->headers[0l].first->str == ((char *)NULL))
    tmp_if_expr_8 = (_Bool)1;

  else
  {
    return_value_strcmp_5=strcmp(http->cmd, csp->headers[0l].first->str);
    if(!(return_value_strcmp_5 == 0))
    {
      return_value_change_request_destination_6=change_request_destination(csp);
      tmp_if_expr_7 = JB_ERR_OK != (signed int)return_value_change_request_destination_6 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_7 = (_Bool)0;
    tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_8)
  {
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(MESSED_UP_REQUEST_RESPONSE);
    write_socket(csp->cfd, MESSED_UP_REQUEST_RESPONSE, return_value_strlen_4);
    log_error(0x0200, "%s - - [%T] \"Invalid request generated\" 500 0", csp->ip_addr_str);
    log_error(0x2000, "Invalid request line after applying header filters.");
    free_http_request(http);
    return (enum privoxy_err)JB_ERR_PARSE;
  }

  signed int return_value_client_has_unsupported_expectations_9;
  return_value_client_has_unsupported_expectations_9=client_has_unsupported_expectations(csp);
  if(!(return_value_client_has_unsupported_expectations_9 == 0))
    return (enum privoxy_err)JB_ERR_PARSE;

  else
    return (enum privoxy_err)JB_ERR_OK;
}

// parse_forwarder_address
// file urlmatch.h line 59
extern enum privoxy_err parse_forwarder_address(char *address, char **hostname, signed int *port)
{
  char *p = address;
  char *return_value_strchr_1;
  _Bool tmp_if_expr_6;
  char *tmp_post_2;
  char *tmp_post_4;
  if((signed int)*address == 91)
  {
    return_value_strchr_1=strchr(address, 93);
    if(!(return_value_strchr_1 == ((char *)NULL)))
      goto __CPROVER_DUMP_L1;

    return (enum privoxy_err)JB_ERR_PARSE;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    *hostname=strdup_or_die(address);
    if((signed int)*(*hostname) == 91)
    {
      p=strchr(*hostname, 93);
      tmp_if_expr_6 = (char *)(void *)0 != p ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_6 = (_Bool)0;
    if(tmp_if_expr_6)
    {
      tmp_post_2 = p;
      p = p + 1l;
      *tmp_post_2 = (char)0;
      memmove((void *)*hostname, (const void *)(*hostname + (signed long int)1), (unsigned long int)(p - *hostname));
      if((signed int)*p == 58)
      {
        p = p + 1l;
        signed long int return_value_strtol_3;
        return_value_strtol_3=strtol(p, (char ** restrict )(void *)0, 0);
        *port = (signed int)return_value_strtol_3;
      }

    }

    else
    {
      p=strchr(*hostname, 58);
      if(!(p == ((char *)NULL)))
      {
        tmp_post_4 = p;
        p = p + 1l;
        *tmp_post_4 = (char)0;
        signed long int return_value_strtol_5;
        return_value_strtol_5=strtol(p, (char ** restrict )(void *)0, 0);
        *port = (signed int)return_value_strtol_5;
      }

    }
    return (enum privoxy_err)JB_ERR_OK;
  }
}

// parse_header_time
// file parsers.c line 4257
static enum privoxy_err parse_header_time(const char *header_time, signed long int *result)
{
  struct tm gmt;
  unsigned int i = (unsigned int)0;
  for( ; !((unsigned long int)i >= 5ul); i = i + 1u)
  {
    memset((void *)&gmt, 0, sizeof(struct tm) /*56ul*/ );
    char *return_value_strptime_1;
    static const char time_formats[5l][22l] = { { '%', 'a', ',', ' ', '%', 'd', '-', '%', 'b', '-', '%', 'y', ' ', '%', 'H', ':', '%', 'M', ':', '%', 'S', 0 },
    { '%', 'a', ',', ' ', '%', 'd', ' ', '%', 'b', ' ', '%', 'Y', ' ', '%', 'H', ':', '%', 'M', ':', '%', 'S', 0 },
    { '%', 'a', ',', ' ', '%', 'd', '-', '%', 'b', '-', '%', 'Y', ' ', '%', 'H', ':', '%', 'M', ':', '%', 'S', 0 },
    { '%', 'A', ',', ' ', '%', 'd', '-', '%', 'b', '-', '%', 'Y', ' ', '%', 'H', ':', '%', 'M', ':', '%', 'S', 0 },
    { '%', 'A', ' ', '%', 'b', ' ', '%', 'd', ' ', '%', 'H', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'Y', 0, 0 } };
    return_value_strptime_1=strptime(header_time, time_formats[(signed long int)i], &gmt);
    if(!(return_value_strptime_1 == ((char *)NULL)))
    {
      if(!(gmt.tm_year >= 0))
      {
        log_error(0x0008, "Failed to parse '%s' using '%s'. Moving on.", header_time, (const void *)time_formats[(signed long int)i]);
        goto __CPROVER_DUMP_L4;
      }

      *result=timegm(&gmt);
      return (enum privoxy_err)JB_ERR_OK;
    }


  __CPROVER_DUMP_L4:
    ;
  }
  return (enum privoxy_err)JB_ERR_PARSE;
}

// parse_http_request
// file urlmatch.h line 45
extern enum privoxy_err parse_http_request(const char *req, struct http_request *http)
{
  char *buf;
  char *v[3l];
  signed int n;
  enum privoxy_err err;
  memset((void *)http, 0, sizeof(struct http_request) /*120ul*/ );
  buf=strdup_or_die(req);
  n=ssplit(buf, " \r\n", v, sizeof(char *[3l]) /*24ul*/  / sizeof(char *) /*8ul*/ );
  if(!(n == 3))
  {
    if(!(buf == ((char *)NULL)))
    {
      free((void *)buf);
      buf = (char *)(void *)0;
    }

    return (enum privoxy_err)JB_ERR_PARSE;
  }

  else
  {
    signed int return_value_unknown_method_1;
    return_value_unknown_method_1=unknown_method(v[(signed long int)0]);
    if(!(return_value_unknown_method_1 == 0))
    {
      log_error(0x2000, "Unknown HTTP method detected: %s", v[(signed long int)0]);
      if(!(buf == ((char *)NULL)))
      {
        free((void *)buf);
        buf = (char *)(void *)0;
      }

      return (enum privoxy_err)JB_ERR_PARSE;
    }

    else
    {
      enum privoxy_err return_value_normalize_http_version_2;
      return_value_normalize_http_version_2=normalize_http_version(v[(signed long int)2]);
      if(!((signed int)return_value_normalize_http_version_2 == JB_ERR_OK))
      {
        if(!(buf == ((char *)NULL)))
        {
          free((void *)buf);
          buf = (char *)(void *)0;
        }

        return (enum privoxy_err)JB_ERR_PARSE;
      }

      else
      {
        signed int return_value_strcmpic_3;
        return_value_strcmpic_3=strcmpic(v[(signed long int)0], "CONNECT");
        http->ssl = (signed int)!(return_value_strcmpic_3 != 0);
        err=parse_http_url(v[(signed long int)1], http, (signed int)!(http->ssl != 0));
        if(!(err == /*enum*/JB_ERR_OK))
        {
          if(!(buf == ((char *)NULL)))
          {
            free((void *)buf);
            buf = (char *)(void *)0;
          }

          return err;
        }

        else
        {
          http->cmd=strdup_or_die(req);
          http->gpc=strdup_or_die(v[(signed long int)0]);
          http->ver=strdup_or_die(v[(signed long int)2]);
          http->ocmd=strdup_or_die(http->cmd);
          if(!(buf == ((char *)NULL)))
          {
            free((void *)buf);
            buf = (char *)(void *)0;
          }

          return (enum privoxy_err)JB_ERR_OK;
        }
      }
    }
  }
}

// parse_http_url
// file urlmatch.h line 46
extern enum privoxy_err parse_http_url(const char *url, struct http_request *http, signed int require_protocol)
{
  signed int host_available = 1;
  http->url=strdup_or_die(url);
  signed int return_value_strncmpic_1;
  char *tmp_post_3;
  char *tmp_post_4;
  _Bool tmp_if_expr_5;
  if((signed int)*http->url == 42)
  {
    http->path=strdup_or_die("*");
    http->hostport=strdup_or_die("");
    if(!((signed int)http->url[1l] == 0))
      return (enum privoxy_err)JB_ERR_PARSE;

    return (enum privoxy_err)JB_ERR_OK;
  }

  else
  {
    char *buf;
    char *url_noproto;
    char *url_path;
    buf=strdup_or_die(url);
    url_noproto = buf;
    signed int return_value_strncmpic_2;
    return_value_strncmpic_2=strncmpic(url_noproto, "http://", (unsigned long int)7);
    if(return_value_strncmpic_2 == 0)
      url_noproto = url_noproto + (signed long int)7;

    else
    {
      return_value_strncmpic_1=strncmpic(url_noproto, "https://", (unsigned long int)8);
      if(return_value_strncmpic_1 == 0)
      {
        url_noproto = url_noproto + (signed long int)8;
        http->ssl = 1;
      }

      else
        if((signed int)*url_noproto == 47)
        {
          http->host = (char *)(void *)0;
          host_available = 0;
        }

        else
          if(!(require_protocol == 0))
          {
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

            return (enum privoxy_err)JB_ERR_PARSE;
          }

    }
    url_path=strchr(url_noproto, 47);
    if(!(url_path == ((char *)NULL)))
    {
      http->path=strdup_or_die(http->ssl != 0 ? "/" : url_path);
      *url_path = (char)0;
      http->hostport=strdup_or_die(url_noproto);
    }

    else
    {
      http->path=strdup_or_die("/");
      http->hostport=strdup_or_die(url_noproto);
    }
    if(!(buf == ((char *)NULL)))
    {
      free((void *)buf);
      buf = (char *)(void *)0;
    }

    if(host_available == 0)
      return (enum privoxy_err)JB_ERR_OK;

    else
    {
      char *parse_http_url__1__4__buf;
      char *host;
      char *port;
      parse_http_url__1__4__buf=strdup_or_die(http->hostport);
      host=strchr(parse_http_url__1__4__buf, 64);
      if(!(host == ((char *)NULL)))
        host = host + 1l;

      else
        host = parse_http_url__1__4__buf;
      if((signed int)*host == 91)
      {
        host = host + 1l;
        port=strchr(host, 93);
        if(port == ((char *)NULL))
        {
          if(!(parse_http_url__1__4__buf == ((char *)NULL)))
          {
            free((void *)parse_http_url__1__4__buf);
            parse_http_url__1__4__buf = (char *)(void *)0;
          }

          return (enum privoxy_err)JB_ERR_PARSE;
        }

        tmp_post_3 = port;
        port = port + 1l;
        *tmp_post_3 = (char)0;
        if((signed int)*port == 0)
          port = (char *)(void *)0;

        else
          if(!((signed int)*port == 58))
          {
            if(!(parse_http_url__1__4__buf == ((char *)NULL)))
            {
              free((void *)parse_http_url__1__4__buf);
              parse_http_url__1__4__buf = (char *)(void *)0;
            }

            return (enum privoxy_err)JB_ERR_PARSE;
          }

      }

      else
        port=strchr(host, 58);
      if(!(port == ((char *)NULL)))
      {
        char *endptr;
        signed long int parsed_port;
        tmp_post_4 = port;
        port = port + 1l;
        *tmp_post_4 = (char)0;
        parsed_port=strtol(port, &endptr, 10);
        if(parsed_port >= 65536l || !(parsed_port >= 1l))
          tmp_if_expr_5 = (_Bool)1;

        else
          tmp_if_expr_5 = (signed int)*endptr != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_5)
        {
          log_error(0x2000, "Invalid port in URL: %s.", url);
          if(!(parse_http_url__1__4__buf == ((char *)NULL)))
          {
            free((void *)parse_http_url__1__4__buf);
            parse_http_url__1__4__buf = (char *)(void *)0;
          }

          return (enum privoxy_err)JB_ERR_PARSE;
        }

        http->port = (signed int)parsed_port;
      }

      else
        http->port = http->ssl != 0 ? 443 : 80;
      http->host=strdup_or_die(host);
      if(!(parse_http_url__1__4__buf == ((char *)NULL)))
      {
        free((void *)parse_http_url__1__4__buf);
        parse_http_url__1__4__buf = (char *)(void *)0;
      }

      enum privoxy_err return_value_init_domain_components_6;
      return_value_init_domain_components_6=init_domain_components(http);
      return return_value_init_domain_components_6;
    }
  }
}

// parse_numeric_value
// file loadcfg.c line 300
static signed int parse_numeric_value(const char *name, const char *value)
{
  signed int number;
  char *endptr;
  /* assertion name != ((void *)0) */
  assert(name != (const char *)(void *)0);
  /* assertion value != ((void *)0) */
  assert(value != (const char *)(void *)0);
  _Bool tmp_if_expr_1;
  if(value == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)*value == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    log_error(0x4000, "Directive %s used without argument", name);

  signed long int return_value_strtol_2;
  return_value_strtol_2=strtol(value, &endptr, 0);
  number = (signed int)return_value_strtol_2;
  if(!((signed int)*endptr == 0))
    log_error(0x4000, "Directive '%s' used with non-numerical value: '%s'", name, value);

  return number;
}

// parse_time_header
// file parsers.c line 4359
static enum privoxy_err parse_time_header(const char *header, signed long int *result)
{
  const char *header_time;
  header_time=strchr(header, 58);
  /* assertion header_time != ((void *)0) */
  assert(header_time != (const char *)(void *)0);
  header_time = header_time + 1l;
  if((signed int)*header_time == 32)
    header_time = header_time + 1l;

  enum privoxy_err return_value_parse_header_time_1;
  return_value_parse_header_time_1=parse_header_time(header_time, result);
  return return_value_parse_header_time_1;
}

// parse_toggle_state
// file loadcfg.c line 341
static signed int parse_toggle_state(const char *name, const char *value)
{
  signed int toggle_state;
  /* assertion name != ((void *)0) */
  assert(name != (const char *)(void *)0);
  /* assertion value != ((void *)0) */
  assert(value != (const char *)(void *)0);
  _Bool tmp_if_expr_1;
  if(value == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)*value == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    log_error(0x4000, "Directive %s used without argument", name);

  toggle_state=atoi(value);
  _Bool tmp_if_expr_3;
  unsigned long int return_value_strlen_2;
  if(!(toggle_state == 0) && !(toggle_state == 1))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strlen_2=strlen(value);
    tmp_if_expr_3 = return_value_strlen_2 != (unsigned long int)1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
    log_error(0x4000, "Directive %s used with invalid argument '%s'. Use either '0' or '1'.", name, value);

  return toggle_state;
}

// path_matches
// file urlmatch.c line 1307
static signed int path_matches(const char *path, struct pattern_spec *pattern)
{
  _Bool tmp_if_expr_2;
  signed int return_value_pcreposix_regexec_1;
  if(pattern->pattern.url_spec.preg == ((struct anonymous_3 *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_pcreposix_regexec_1=pcreposix_regexec(pattern->pattern.url_spec.preg, path, (unsigned long int)0, (struct anonymous_4 *)(void *)0, 0);
    tmp_if_expr_2 = 0 == return_value_pcreposix_regexec_1 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr_2;
}

// pcrs_compile
// file pcrs.h line 105
extern struct PCRS_JOB * pcrs_compile(const char *pattern, const char *substitute, const char *options, signed int *errptr)
{
  struct PCRS_JOB *newjob;
  signed int flags;
  signed int capturecount;
  const char *error;
  *errptr = 0;
  if(pattern == ((const char *)NULL))
    pattern = "";

  if(substitute == ((const char *)NULL))
    substitute = "";

  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct PCRS_JOB) /*40ul*/ );
  newjob = (struct PCRS_JOB *)return_value_malloc_1;
  if(newjob == ((struct PCRS_JOB *)NULL))
  {
    *errptr = -100;
    return (struct PCRS_JOB *)(void *)0;
  }

  else
  {
    memset((void *)newjob, 0, sizeof(struct PCRS_JOB) /*40ul*/ );
    newjob->options=pcrs_parse_perl_options(options, &flags);
    newjob->flags = flags;
    newjob->pattern=pcre_compile(pattern, newjob->options, &error, errptr, (const unsigned char *)(void *)0);
    if(newjob->pattern == ((struct real_pcre *)NULL))
    {
      pcrs_free_job(newjob);
      return (struct PCRS_JOB *)(void *)0;
    }

    else
    {
      newjob->hints=pcre_study(newjob->pattern, 0, &error);
      if(!(error == ((const char *)NULL)))
      {
        *errptr = -102;
        pcrs_free_job(newjob);
        return (struct PCRS_JOB *)(void *)0;
      }

      else
      {
        *errptr=pcre_fullinfo(newjob->pattern, newjob->hints, 2, (void *)&capturecount);
        if(!(*errptr >= 0))
        {
          pcrs_free_job(newjob);
          return (struct PCRS_JOB *)(void *)0;
        }

        else
        {
          newjob->substitute=pcrs_compile_replacement(substitute, newjob->flags & 2, capturecount, errptr);
          if(newjob->substitute == ((struct anonymous_12 *)NULL))
          {
            pcrs_free_job(newjob);
            return (struct PCRS_JOB *)(void *)0;
          }

          else
            return newjob;
        }
      }
    }
  }
}

// pcrs_compile_command
// file pcrs.h line 104
extern struct PCRS_JOB * pcrs_compile_command(const char *command, signed int *errptr)
{
  signed int i;
  signed int k;
  signed int l;
  signed int quoted = 0;
  unsigned long int limit;
  char delimiter;
  char *tokens[4l];
  struct PCRS_JOB *newjob;
  l = 0;
  k = l;
  limit=strlen(command);
  if(!(limit >= 4ul))
  {
    *errptr = -101;
    return (struct PCRS_JOB *)(void *)0;
  }

  else
    delimiter = command[(signed long int)1];
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(limit + (unsigned long int)1);
  tokens[(signed long int)l] = (char *)return_value_malloc_1;
  i = 0;
  signed int tmp_post_2;
  signed int tmp_post_3;
  for( ; (signed int)limit >= i; i = i + 1)
  {
    if(command[(signed long int)i] == delimiter && quoted == 0)
    {
      if(l == 3)
      {
        l = -1;
        break;
      }

      tmp_post_2 = k;
      k = k + 1;
      tokens[(signed long int)0][(signed long int)tmp_post_2] = (char)0;
      l = l + 1;
      tokens[(signed long int)l] = tokens[(signed long int)0] + (signed long int)k;
      goto __CPROVER_DUMP_L8;
    }

    else
      if(quoted == 0 && (signed int)command[(signed long int)i] == 92)
      {
        quoted = 1;
        if(command[(signed long int)(1 + i)] == delimiter)
          goto __CPROVER_DUMP_L8;

      }

      else
        quoted = 0;
    tmp_post_3 = k;
    k = k + 1;
    tokens[(signed long int)0][(signed long int)tmp_post_3] = command[(signed long int)i];

  __CPROVER_DUMP_L8:
    ;
  }
  if(!(l == 3))
  {
    *errptr = -101;
    free((void *)tokens[(signed long int)0]);
    return (struct PCRS_JOB *)(void *)0;
  }

  else
  {
    newjob=pcrs_compile(tokens[(signed long int)1], tokens[(signed long int)2], tokens[(signed long int)3], errptr);
    free((void *)tokens[(signed long int)0]);
    return newjob;
  }
}

// pcrs_compile_dynamic_command
// file pcrs.h line 129
extern struct PCRS_JOB * pcrs_compile_dynamic_command(char *pcrs_command, struct pcrs_variable *v, signed int *error)
{
  char buf[4000l];
  const char *original_pcrs_command = pcrs_command;
  char *pcrs_command_tmp = (char *)(void *)0;
  struct PCRS_JOB *job = (struct PCRS_JOB *)(void *)0;
  signed int truncation = 0;
  char d;
  signed int ret;
  while(!(v->name == ((const char *)NULL)))
  {
    if(pcrs_command == ((char *)NULL))
      break;

    /* assertion ((void *)0) != v->value */
    assert((char *)(void *)0 != v->value);
    char *return_value_strstr_1;
    return_value_strstr_1=strstr(pcrs_command, v->name);
    if(return_value_strstr_1 == ((char *)NULL))
      v = v + 1l;

    else
    {
      d=pcrs_get_delimiter(v->value);
      if((signed int)d == 0)
      {
        *error = -101;
        if(!(pcrs_command_tmp == ((char *)NULL)))
        {
          free((void *)pcrs_command_tmp);
          pcrs_command_tmp = (char *)(void *)0;
        }

        return (struct PCRS_JOB *)(void *)0;
      }

      char *return_value_strchr_2;
      return_value_strchr_2=strchr(v->name, (signed int)d);
      /* assertion ((void *)0) == strchr(v->name, d) */
      assert((char *)(void *)0 == return_value_strchr_2);
      ret=snprintf(buf, sizeof(char [4000l]) /*4000ul*/ , "s%c\\_%s%c%s%cgT", d, v->name, d, v->value, d);
      /* assertion ret >= 0 */
      assert(ret >= 0);
      if((unsigned long int)ret >= sizeof(char [4000l]) /*4000ul*/ )
      {
        const unsigned long int trailer_size = sizeof(const char [26l]) /*26ul*/  + (unsigned long int)3;
        char *trailer_start = (buf + (signed long int)sizeof(char [4000l]) /*4000ul*/ ) - (signed long int)trailer_size;
        ret=snprintf(trailer_start, trailer_size, "%s%cgT", (const void *)warning, d);
        /* assertion ret == trailer_size - 1 */
        assert((unsigned long int)ret == trailer_size - (unsigned long int)1);
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(buf);
        /* assertion sizeof(buf) == strlen(buf) + 1 */
        assert(sizeof(char [4000l]) /*4000ul*/  == return_value_strlen_3 + (unsigned long int)1);
        truncation = 1;
      }

      pcrs_command_tmp=pcrs_execute_single_command(pcrs_command, buf, error);
      if(pcrs_command_tmp == ((char *)NULL))
        return (struct PCRS_JOB *)(void *)0;

      if(!(pcrs_command == original_pcrs_command))
      {
        if(!(pcrs_command == ((char *)NULL)))
        {
          free((void *)pcrs_command);
          pcrs_command = (char *)(void *)0;
        }

      }

      pcrs_command = pcrs_command_tmp;
      v = v + 1l;
    }
  }
  job=pcrs_compile_command(pcrs_command, error);
  if(!(pcrs_command == original_pcrs_command))
  {
    if(!(pcrs_command == ((char *)NULL)))
    {
      free((void *)pcrs_command);
      pcrs_command = (char *)(void *)0;
    }

  }

  if(!(truncation == 0))
    *error = -105;

  return job;
}

// pcrs_compile_replacement
// file pcrs.c line 209
static struct anonymous_12 * pcrs_compile_replacement(const char *replacement, signed int trivialflag, signed int capturecount, signed int *errptr)
{
  signed int i;
  signed int k;
  signed int l;
  signed int quoted;
  unsigned long int length;
  char *text;
  struct anonymous_12 *r;
  quoted = 0;
  l = quoted;
  k = l;
  i = k;
  if(replacement == ((const char *)NULL))
    replacement = "";

  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_12) /*688ul*/ );
  r = (struct anonymous_12 *)return_value_malloc_1;
  signed int tmp_post_3;
  signed int tmp_post_4;
  _Bool tmp_if_expr_15;
  char *return_value_strchr_14;
  signed int tmp_post_5;
  signed int tmp_post_6;
  signed int tmp_post_7;
  signed int tmp_post_8;
  signed int tmp_post_9;
  signed int tmp_post_10;
  signed int tmp_post_11;
  signed int return_value_is_hex_sequence_13;
  signed int tmp_post_12;
  const unsigned short int **return_value___ctype_b_loc_16;
  _Bool tmp_if_expr_18;
  signed int tmp_post_19;
  signed int tmp_post_20;
  if(r == ((struct anonymous_12 *)NULL))
  {
    *errptr = -100;
    return (struct anonymous_12 *)(void *)0;
  }

  else
  {
    memset((void *)r, 0, sizeof(struct anonymous_12) /*688ul*/ );
    length=strlen(replacement);
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(length + (unsigned long int)1);
    text = (char *)return_value_malloc_2;
    if(text == ((char *)NULL))
    {
      free((void *)r);
      *errptr = -100;
      return (struct anonymous_12 *)(void *)0;
    }

    else
    {
      memset((void *)text, 0, length + (unsigned long int)1);
      if(!(trivialflag == 0))
      {
        text=strncpy(text, replacement, length + (unsigned long int)1);
        k = (signed int)length;
      }

      else
        while(!(i >= (signed int)length))
          if((signed int)replacement[(signed long int)i] == 92)
          {
            if(!(quoted == 0))
            {
              tmp_post_3 = k;
              k = k + 1;
              tmp_post_4 = i;
              i = i + 1;
              text[(signed long int)tmp_post_3] = replacement[(signed long int)tmp_post_4];
              quoted = 0;
            }

            else
            {
              if(!(replacement[(signed long int)(1 + i)] == 0))
              {
                return_value_strchr_14=strchr("tnrfae0", (signed int)replacement[(signed long int)(i + 1)]);
                tmp_if_expr_15 = return_value_strchr_14 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_15 = (_Bool)0;
              if(tmp_if_expr_15)
              {
                i = i + 1;
                switch((signed int)replacement[(signed long int)i])
                {
                  case 116:
                  {
                    tmp_post_5 = k;
                    k = k + 1;
                    text[(signed long int)tmp_post_5] = (char)9;
                    break;
                  }
                  case 110:
                  {
                    tmp_post_6 = k;
                    k = k + 1;
                    text[(signed long int)tmp_post_6] = (char)10;
                    break;
                  }
                  case 114:
                  {
                    tmp_post_7 = k;
                    k = k + 1;
                    text[(signed long int)tmp_post_7] = (char)13;
                    break;
                  }
                  case 102:
                  {
                    tmp_post_8 = k;
                    k = k + 1;
                    text[(signed long int)tmp_post_8] = (char)12;
                    break;
                  }
                  case 97:
                  {
                    tmp_post_9 = k;
                    k = k + 1;
                    text[(signed long int)tmp_post_9] = (char)7;
                    break;
                  }
                  case 101:
                  {
                    tmp_post_10 = k;
                    k = k + 1;
                    text[(signed long int)tmp_post_10] = (char)27;
                    break;
                  }
                  case 48:
                  {
                    tmp_post_11 = k;
                    k = k + 1;
                    text[(signed long int)tmp_post_11] = (char)0;
                  }
                }
                i = i + 1;
              }

              else
              {
                return_value_is_hex_sequence_13=is_hex_sequence(&replacement[(signed long int)i]);
                if(!(return_value_is_hex_sequence_13 == 0))
                {
                  signed int ascii_value;
                  ascii_value=xtoi(&replacement[(signed long int)(i + 2)]);
                  /* assertion ascii_value >= 0 */
                  assert(ascii_value >= 0);
                  /* assertion ascii_value < 256 */
                  assert(ascii_value < 256);
                  tmp_post_12 = k;
                  k = k + 1;
                  text[(signed long int)tmp_post_12] = (char)ascii_value;
                  i = i + 4;
                }

                else
                {
                  quoted = 1;
                  i = i + 1;
                }
              }
            }
          }

          else
          {
            if((signed int)replacement[(signed long int)i] == 36)
            {
              if(quoted == 0)
              {
                if(!(i >= -1 + (signed int)length))
                {
                  char *symbol;
                  char symbols[5l] = { '\'', '`', '+', '&', 0 };
                  if(l >= 33)
                  {
                    if(!(text == ((char *)NULL)))
                    {
                      free((void *)text);
                      text = (char *)(void *)0;
                    }

                    if(!(r == ((struct anonymous_12 *)NULL)))
                    {
                      free((void *)r);
                      r = (struct anonymous_12 *)(void *)0;
                    }

                    *errptr = -104;
                    return (struct anonymous_12 *)(void *)0;
                  }

                  r->block_length[(signed long int)l] = (unsigned long int)(k - r->block_offset[(signed long int)l]);
                  const unsigned short int **return_value___ctype_b_loc_17;
                  return_value___ctype_b_loc_17=__ctype_b_loc();
                  if(!((2048 & (signed int)(*return_value___ctype_b_loc_17)[(signed long int)(signed int)replacement[(signed long int)(1 + i)]]) == 0))
                  {
                    for( ; !(i >= (signed int)length); r->backref[(signed long int)l] = (r->backref[(signed long int)l] * 10 + (signed int)replacement[(signed long int)i]) - 48)
                    {
                      return_value___ctype_b_loc_16=__ctype_b_loc();
                      i = i + 1;
                      if((2048 & (signed int)(*return_value___ctype_b_loc_16)[(signed long int)(signed int)replacement[(signed long int)i]]) == 0)
                        break;

                    }
                    if(!(capturecount >= r->backref[(signed long int)l]))
                    {
                      if(!(text == ((char *)NULL)))
                      {
                        free((void *)text);
                        text = (char *)(void *)0;
                      }

                      if(!(r == ((struct anonymous_12 *)NULL)))
                      {
                        free((void *)r);
                        r = (struct anonymous_12 *)(void *)0;
                      }

                      *errptr = -104;
                      return (struct anonymous_12 *)(void *)0;
                    }

                  }

                  else
                  {
                    symbol=strchr(symbols, (signed int)replacement[(signed long int)(i + 1)]);
                    if(!(symbol == ((char *)NULL)))
                    {
                      if(symbol - symbols == 2l)
                        r->backref[(signed long int)l] = capturecount;

                      else
                        if(symbol - symbols == 3l)
                          r->backref[(signed long int)l] = 0;

                        else
                          r->backref[(signed long int)l] = (signed int)((signed long int)(33 + 1) - (symbol - symbols));
                      i = i + 2;
                    }

                    else
                      goto plainchar;
                  }
                  if(r->backref[(signed long int)l] >= 0)
                    tmp_if_expr_18 = r->backref[(signed long int)l] < 33 + 2 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_18 = (_Bool)0;
                  if(tmp_if_expr_18)
                  {
                    r->backref_count[(signed long int)r->backref[(signed long int)l]] = r->backref_count[(signed long int)r->backref[(signed long int)l]] + 1;
                    l = l + 1;
                    r->block_offset[(signed long int)l] = k;
                  }

                  else
                  {
                    if(!(text == ((char *)NULL)))
                    {
                      free((void *)text);
                      text = (char *)(void *)0;
                    }

                    if(!(r == ((struct anonymous_12 *)NULL)))
                    {
                      free((void *)r);
                      r = (struct anonymous_12 *)(void *)0;
                    }

                    *errptr = -104;
                    return (struct anonymous_12 *)(void *)0;
                  }
                  continue;
                }

              }

            }


          plainchar:
            ;
            tmp_post_19 = k;
            k = k + 1;
            tmp_post_20 = i;
            i = i + 1;
            text[(signed long int)tmp_post_19] = replacement[(signed long int)tmp_post_20];
            quoted = 0;
          }
      r->text = text;
      r->backrefs = l;
      r->length = (unsigned long int)k;
      r->block_length[(signed long int)l] = (unsigned long int)(k - r->block_offset[(signed long int)l]);
      return r;
    }
  }
}

// pcrs_execute
// file pcrs.h line 106
extern signed int pcrs_execute(struct PCRS_JOB *job, const char *subject, unsigned long int subject_length, char **result, unsigned long int *result_length)
{
  signed int offsets[99l];
  signed int offset;
  signed int i;
  signed int k;
  signed int matches_found;
  signed int submatches;
  signed int max_matches = 40;
  unsigned long int newsize;
  struct anonymous_7 *matches;
  struct anonymous_7 *dummy;
  char *result_offset;
  i = 0;
  offset = i;
  *result = (char *)(void *)0;
  _Bool tmp_if_expr_1;
  if(job == ((struct PCRS_JOB *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = job->pattern == (struct real_pcre *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = job->substitute == (struct anonymous_12 *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(subject == ((const char *)NULL) || tmp_if_expr_2)
    return -103;

  else
  {
    void *return_value_malloc_3;
    return_value_malloc_3=malloc((unsigned long int)max_matches * sizeof(struct anonymous_7) /*424ul*/ );
    matches = (struct anonymous_7 *)return_value_malloc_3;
    if(matches == ((struct anonymous_7 *)NULL))
      return -100;

    else
    {
      memset((void *)matches, 0, (unsigned long int)max_matches * sizeof(struct anonymous_7) /*424ul*/ );
      newsize = subject_length;
      do
      {
        submatches=pcre_exec(job->pattern, job->hints, subject, (signed int)subject_length, offset, 0, offsets, 3 * 33);
        if(!(submatches >= 1))
          break;

        job->flags = job->flags | 4;
        (matches + (signed long int)i)->submatches = submatches;
        k = 0;
        for( ; !(k >= submatches); k = k + 1)
        {
          (matches + (signed long int)i)->submatch_offset[(signed long int)k] = offsets[(signed long int)(2 * k)];
          (matches + (signed long int)i)->submatch_length[(signed long int)k] = (unsigned long int)(offsets[(signed long int)(2 * k + 1)] - offsets[(signed long int)(2 * k)]);
          newsize = newsize + (matches + (signed long int)i)->submatch_length[(signed long int)k] * (unsigned long int)job->substitute->backref_count[(signed long int)k];
        }
        newsize = newsize + (job->substitute->length - (matches + (signed long int)i)->submatch_length[(signed long int)0]);
        (matches + (signed long int)i)->submatch_offset[(signed long int)33] = 0;
        (matches + (signed long int)i)->submatch_length[(signed long int)33] = (unsigned long int)offsets[(signed long int)0];
        newsize = newsize + (unsigned long int)offsets[(signed long int)0] * (unsigned long int)job->substitute->backref_count[(signed long int)33];
        (matches + (signed long int)i)->submatch_offset[(signed long int)(33 + 1)] = offsets[(signed long int)1];
        (matches + (signed long int)i)->submatch_length[(signed long int)(33 + 1)] = (subject_length - (unsigned long int)offsets[(signed long int)1]) - (unsigned long int)1;
        newsize = newsize + (subject_length - (unsigned long int)offsets[(signed long int)1]) * (unsigned long int)job->substitute->backref_count[(signed long int)(33 + 1)];
        i = i + 1;
        if(i >= max_matches)
        {
          max_matches = (signed int)((double)max_matches * 1.6);
          void *return_value_realloc_4;
          return_value_realloc_4=realloc((void *)matches, (unsigned long int)max_matches * sizeof(struct anonymous_7) /*424ul*/ );
          dummy = (struct anonymous_7 *)return_value_realloc_4;
          if(dummy == ((struct anonymous_7 *)NULL))
          {
            free((void *)matches);
            return -100;
          }

          matches = dummy;
        }

        if((1 & job->flags) == 0)
          break;

        if(offsets[1l] == offset)
        {
          if(!((unsigned long int)offset >= subject_length))
            offset = offset + 1;

          else
            break;
        }

        else
          offset = offsets[(signed long int)1];
      }
      while((_Bool)1);
      if(!(submatches >= -1))
      {
        free((void *)matches);
        return submatches;
      }

      else
      {
        matches_found = i;
        void *return_value_malloc_5;
        return_value_malloc_5=malloc(newsize + (unsigned long int)1);
        *result = (char *)return_value_malloc_5;
        if(*result == ((char *)NULL))
        {
          free((void *)matches);
          return -100;
        }

        else
          (*result)[(signed long int)newsize] = (char)0;
        offset = 0;
        result_offset = *result;
        i = 0;
        for( ; !(i >= matches_found); i = i + 1)
        {
          memcpy((void *)result_offset, (const void *)(subject + (signed long int)offset), (unsigned long int)((matches + (signed long int)i)->submatch_offset[(signed long int)0] - offset));
          result_offset = result_offset + (signed long int)((matches + (signed long int)i)->submatch_offset[(signed long int)0] - offset);
          k = 0;
          for( ; job->substitute->backrefs >= k; k = k + 1)
          {
            memcpy((void *)result_offset, (const void *)(job->substitute->text + (signed long int)job->substitute->block_offset[(signed long int)k]), job->substitute->block_length[(signed long int)k]);
            result_offset = result_offset + (signed long int)job->substitute->block_length[(signed long int)k];
            if(!(k == job->substitute->backrefs))
            {
              if(!(job->substitute->backref[(signed long int)k] >= 2))
              {
                if(!(job->substitute->backref[(signed long int)k] >= (matches + (signed long int)i)->submatches))
                {
                  if((matches + (signed long int)i)->submatch_length[(signed long int)job->substitute->backref[(signed long int)k]] >= 1ul)
                  {
                    memcpy((void *)result_offset, (const void *)(subject + (signed long int)(matches + (signed long int)i)->submatch_offset[(signed long int)job->substitute->backref[(signed long int)k]]), (matches + (signed long int)i)->submatch_length[(signed long int)job->substitute->backref[(signed long int)k]]);
                    result_offset = result_offset + (signed long int)(matches + (signed long int)i)->submatch_length[(signed long int)job->substitute->backref[(signed long int)k]];
                  }

                }

              }

            }

          }
          offset = (matches + (signed long int)i)->submatch_offset[(signed long int)0] + (signed int)(matches + (signed long int)i)->submatch_length[(signed long int)0];
        }
        memcpy((void *)result_offset, (const void *)(subject + (signed long int)offset), subject_length - (unsigned long int)offset);
        *result_length = newsize;
        free((void *)matches);
        return matches_found;
      }
    }
  }
}

// pcrs_execute_list
// file pcrs.c line 696
extern signed int pcrs_execute_list(struct PCRS_JOB *joblist, char *subject, unsigned long int subject_length, char **result, unsigned long int *result_length)
{
  struct PCRS_JOB *job;
  char *old;
  char *new = (char *)(void *)0;
  signed int hits;
  signed int total_hits;
  old = subject;
  *result_length = subject_length;
  total_hits = 0;
  job = joblist;
  for( ; !(job == ((struct PCRS_JOB *)NULL)); job = job->next)
  {
    hits=pcrs_execute(job, old, *result_length, &new, result_length);
    if(!(old == subject))
      free((void *)old);

    if(!(hits >= 0))
      return hits;

    else
    {
      total_hits = total_hits + hits;
      old = new;
    }
  }
  *result = new;
  return total_hits;
}

// pcrs_execute_single_command
// file pcrs.h line 118
extern char * pcrs_execute_single_command(const char *subject, const char *pcrs_command, signed int *hits)
{
  unsigned long int size;
  char *result = (char *)(void *)0;
  struct PCRS_JOB *job;
  /* assertion subject */
  assert(subject != ((const char *)NULL));
  /* assertion pcrs_command */
  assert(pcrs_command != ((const char *)NULL));
  *hits = 0;
  size=strlen(subject);
  job=pcrs_compile_command(pcrs_command, hits);
  if(!(job == ((struct PCRS_JOB *)NULL)))
  {
    *hits=pcrs_execute(job, subject, size, &result, &size);
    if(!(*hits >= 0))
    {
      if(!(result == ((char *)NULL)))
      {
        free((void *)result);
        result = (char *)(void *)0;
      }

    }

    pcrs_free_job(job);
  }

  return result;
}

// pcrs_filter_response
// file filters.c line 1576
static char * pcrs_filter_response(struct client_state *csp)
{
  signed int hits = 0;
  unsigned long int size;
  unsigned long int prev_size;
  char *old = (char *)(void *)0;
  char *new = (char *)(void *)0;
  struct PCRS_JOB *job;
  struct re_filterfile_spec *b;
  struct list_entry *filtername;
  if(csp->iob[0l].cur >= csp->iob[0l].eod)
    return (char *)(void *)0;

  else
  {
    signed int return_value_filters_available_1;
    return_value_filters_available_1=filters_available(csp);
    if(return_value_filters_available_1 == 0)
    {
      log_error(0x2000, "Inconsistent configuration: content filtering enabled, but no content filters available.");
      return (char *)(void *)0;
    }

    else
    {
      size = (unsigned long int)(csp->iob[0l].eod - csp->iob[0l].cur);
      old = csp->iob[0l].cur;
      filtername = csp->action[0l].multi[(signed long int)1][0l].first;
      for( ; !(filtername == ((struct list_entry *)NULL)); filtername = filtername->next)
      {
        signed int current_hits = 0;
        signed int job_number = 0;
        signed int job_hits = 0;
        struct PCRS_JOB *joblist;
        b=get_filter(csp, filtername->str, (enum filter_type)FT_CONTENT_FILTER);
        if(!(b == ((struct re_filterfile_spec *)NULL)))
        {
          joblist = b->joblist;
          if(!(b->dynamic == 0))
            joblist=compile_dynamic_pcrs_job_list(csp, b);

          if(joblist == ((struct PCRS_JOB *)NULL))
            log_error(0x0040, "Filter %s has empty joblist. Nothing to do.", b->name);

          else
          {
            prev_size = size;
            job = joblist;
            for( ; !(job == ((struct PCRS_JOB *)NULL)); job = job->next)
            {
              job_number = job_number + 1;
              job_hits=pcrs_execute(job, old, size, &new, &size);
              if(job_hits >= 0)
              {
                current_hits = current_hits + job_hits;
                if(!(old == csp->iob[0l].cur))
                {
                  if(!(old == ((char *)NULL)))
                  {
                    free((void *)old);
                    old = (char *)(void *)0;
                  }

                }

                old = new;
              }

              else
              {
                const char *return_value_pcrs_strerror_2;
                return_value_pcrs_strerror_2=pcrs_strerror(job_hits);
                log_error(0x2000, "Skipped filter '%s' after job number %u: %s (%d)", b->name, job_number, return_value_pcrs_strerror_2, job_hits);
                break;
              }
            }
            if(!(b->dynamic == 0))
              pcrs_free_joblist(joblist);

            log_error(0x0040, "filtering %s%s (size %d) with '%s' produced %d hits (new size %d).", csp->http[0l].hostport, csp->http[0l].path, prev_size, b->name, current_hits, size);
            hits = hits + current_hits;
          }
        }

      }
      if(hits == 0)
      {
        if(!(new == ((char *)NULL)))
        {
          free((void *)new);
          new = (char *)(void *)0;
        }

        return (char *)(void *)0;
      }

      else
      {
        csp->flags = csp->flags | 0x08U;
        csp->content_length = size;
        clear_iob(csp->iob);
        return new;
      }
    }
  }
}

// pcrs_free_job
// file pcrs.h line 110
extern struct PCRS_JOB * pcrs_free_job(struct PCRS_JOB *job)
{
  struct PCRS_JOB *next;
  if(job == ((struct PCRS_JOB *)NULL))
    return (struct PCRS_JOB *)(void *)0;

  else
  {
    next = job->next;
    if(!(job->pattern == ((struct real_pcre *)NULL)))
      free((void *)job->pattern);

    if(!(job->hints == ((struct pcre_extra *)NULL)))
      free((void *)job->hints);

    if(!(job->substitute == ((struct anonymous_12 *)NULL)))
    {
      if(!(job->substitute->text == ((char *)NULL)))
        free((void *)job->substitute->text);

      free((void *)job->substitute);
    }

    free((void *)job);
  }
  return next;
}

// pcrs_free_joblist
// file pcrs.h line 111
extern void pcrs_free_joblist(struct PCRS_JOB *joblist)
{
  do
  {
    joblist=pcrs_free_job(joblist);
    if(joblist == ((struct PCRS_JOB *)NULL))
      break;

  }
  while((_Bool)1);
}

// pcrs_get_delimiter
// file pcrs.c line 1011
extern char pcrs_get_delimiter(const char *string)
{
  static const char delimiters[14l] = { '>', '<', '#', '+', '*', 126, '%', '^', '-', ':', ';', '!', '@', 0 };
  const char *d = delimiters;
  char *return_value_strchr_1;
  for( ; !(*d == 0); d = d + 1l)
  {
    return_value_strchr_1=strchr(string, (signed int)*d);
    if(return_value_strchr_1 == ((char *)NULL))
      break;

  }
  return *d;
}

// pcrs_job_is_dynamic
// file pcrs.h line 116
extern signed int pcrs_job_is_dynamic(char *job)
{
  const char delimiter = job[(signed long int)1];
  unsigned long int length;
  length=strlen(job);
  char *option;
  if(!(length >= 5ul))
    return 0;

  else
  {
    option = job + (signed long int)length;
    for( ; !(*option == delimiter); option = option - 1l)
      if((signed int)*option == 68)
        return 1;

    return 0;
  }
}

// pcrs_parse_perl_options
// file pcrs.c line 156
static signed int pcrs_parse_perl_options(const char *optstring, signed int *flags)
{
  unsigned long int i;
  signed int rc = 0;
  *flags = 0;
  unsigned long int return_value_strlen_1;
  if(optstring == ((const char *)NULL))
    return 0;

  else
  {
    i = (unsigned long int)0;
    do
    {
      return_value_strlen_1=strlen(optstring);
      if(i >= return_value_strlen_1)
        break;

      switch((signed int)optstring[(signed long int)i])
      {
        case 101:
          break;
        case 103:
        {
          *flags = *flags | 1;
          break;
        }
        case 105:
        {
          rc = rc | 0x00000001;
          break;
        }
        case 109:
        {
          rc = rc | 0x00000002;
          break;
        }
        case 111:
          break;
        case 115:
        {
          rc = rc | 0x00000004;
          break;
        }
        case 120:
        {
          rc = rc | 0x00000008;
          break;
        }
        case 85:
        {
          rc = rc | 0x00000200;
          break;
        }
        case 84:
          *flags = *flags | 2;
      }
      i = i + 1ul;
    }
    while((_Bool)1);
    return rc;
  }
}

// pcrs_strerror
// file pcrs.h line 114
extern const char * pcrs_strerror(const signed int error)
{
  if(!(error == 0))
  {
    if(!(error == -6))
    {
      if(error == -2)
        goto __CPROVER_DUMP_L2;

      if(error == -3)
        goto __CPROVER_DUMP_L3;

      if(error == -4)
        goto __CPROVER_DUMP_L4;

      if(error == -5)
        goto __CPROVER_DUMP_L5;

      if(error == -7)
        goto __CPROVER_DUMP_L6;

      if(error == -1)
        goto __CPROVER_DUMP_L7;

      if(error == -8)
        goto __CPROVER_DUMP_L8;

      if(error == -100)
        goto __CPROVER_DUMP_L9;

      if(error == -101)
        goto __CPROVER_DUMP_L10;

      if(error == -102)
        goto __CPROVER_DUMP_L11;

      if(error == -103)
        goto __CPROVER_DUMP_L12;

      if(error == -104)
        goto __CPROVER_DUMP_L13;

      if(error == -105)
        goto __CPROVER_DUMP_L14;

    }

    else
    {
      return "(pcre:) No memory";

    __CPROVER_DUMP_L2:
      ;
      return "(pcre:) NULL code or subject or ovector";

    __CPROVER_DUMP_L3:
      ;
      return "(pcre:) Unrecognized option bit";

    __CPROVER_DUMP_L4:
      ;
      return "(pcre:) Bad magic number in code";

    __CPROVER_DUMP_L5:
      ;
      return "(pcre:) Bad node in pattern";

    __CPROVER_DUMP_L6:
      ;
      return "(pcre:) Fire in power supply";

    __CPROVER_DUMP_L7:
      ;
      return "(pcre:) Water in power supply";

    __CPROVER_DUMP_L8:
      ;
      return "(pcre:) Match limit reached";

    __CPROVER_DUMP_L9:
      ;
      return "(pcrs:) No memory";

    __CPROVER_DUMP_L10:
      ;
      return "(pcrs:) Syntax error while parsing command";

    __CPROVER_DUMP_L11:
      ;
      return "(pcrs:) PCRE error while studying the pattern";

    __CPROVER_DUMP_L12:
      ;
      return "(pcrs:) Bad job - NULL job, pattern or substitute";

    __CPROVER_DUMP_L13:
      ;
      return "(pcrs:) Backreference out of range";

    __CPROVER_DUMP_L14:
      ;
      return "(pcrs:) At least one variable was too big and has been truncated before compilation";
    }
    static char buf[100l];
    snprintf(buf, sizeof(char [100l]) /*100ul*/ , "Error code %d. For details, check the pcre documentation.", error);
    return buf;
  }

  else
    return "(pcrs:) Everything's just fine. Thanks for asking.";
}

// percent_encode_url
// file encode.c line 402
extern char * percent_encode_url(const char *s)
{
  char *buf;
  unsigned long int buf_size;
  /* assertion s != ((void *)0) */
  assert(s != (const char *)(void *)0);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  buf_size = return_value_strlen_1 * (unsigned long int)3 + (unsigned long int)1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(buf_size);
  buf = (char *)return_value_malloc_2;
  const char *tmp_post_3;
  _Bool tmp_if_expr_6;
  char *tmp_post_5;
  if(!(buf == ((char *)NULL)))
  {
    char c;
    char *p = buf;
    do
    {
      tmp_post_3 = s;
      s = s + 1l;
      c = *tmp_post_3;
      if((signed int)c == 0)
        break;

      const unsigned int i = (const unsigned int)(unsigned char)c;
      static const char allowed_characters[128l] = { (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)33, (const char)0, (const char)35, (const char)36, (const char)37, (const char)38, (const char)39, (const char)40, (const char)41, (const char)42, (const char)43, (const char)44, (const char)45, (const char)46, (const char)47, (const char)48, (const char)49, (const char)50, (const char)51, (const char)52, (const char)53, (const char)54, (const char)55, (const char)56, (const char)57, (const char)58, (const char)59, (const char)0, (const char)61, (const char)0, (const char)63, (const char)64, (const char)65, (const char)66, (const char)67, (const char)68, (const char)69, (const char)70, (const char)71, (const char)72, (const char)73, (const char)74, (const char)75, (const char)76, (const char)77, (const char)78, (const char)79, (const char)80, (const char)81, (const char)82, (const char)83, (const char)84, (const char)85, (const char)86, (const char)87, (const char)88, (const char)89, (const char)90, (const char)91, (const char)0, (const char)93, (const char)0, (const char)95, (const char)0, (const char)97, (const char)98, (const char)99, (const char)100, (const char)101, (const char)102, (const char)103, (const char)104, (const char)105, (const char)106, (const char)107, (const char)108, (const char)109, (const char)110, (const char)111, (const char)112, (const char)113, (const char)114, (const char)115, (const char)116, (const char)117, (const char)118, (const char)119, (const char)120, (const char)121, (const char)122, (const char)0, (const char)0, (const char)0, (const char)126, (const char)0 };
      if((unsigned long int)i >= sizeof(const char [128l]) /*128ul*/ )
        tmp_if_expr_6 = (_Bool)1;

      else
        tmp_if_expr_6 = 0 == (signed int)allowed_characters[(signed long int)i] ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_6)
      {
        const char *replace_with = url_code_map[(signed long int)i];
        /* assertion *replace_with != '\0' */
        assert((signed int)*replace_with != 0);
        if(!((signed int)*replace_with == 0))
        {
          const unsigned long int bytes_written = (unsigned long int)(p - buf);
          /* assertion bytes_written < buf_size */
          assert(bytes_written < buf_size);
          unsigned long int return_value_privoxy_strlcpy_4;
          return_value_privoxy_strlcpy_4=privoxy_strlcpy(p, replace_with, buf_size - bytes_written);
          p = p + (signed long int)return_value_privoxy_strlcpy_4;
        }

      }

      else
      {
        tmp_post_5 = p;
        p = p + 1l;
        *tmp_post_5 = c;
      }
    }
    while((_Bool)1);
    *p = (char)0;
    unsigned long int return_value_strlen_7;
    return_value_strlen_7=strlen(buf);
    /* assertion strlen(buf) < buf_size */
    assert(return_value_strlen_7 < buf_size);
  }

  return buf;
}

// pick_from_range
// file miscutil.c line 722
signed long int pick_from_range(signed long int range)
{
  signed long int number;
  /* assertion range != 0 */
  assert(range != (signed long int)0);
  /* assertion range > 0 */
  assert(range > (signed long int)0);
  if(!(range >= 1l))
    return (signed long int)0;

  else
  {
    signed long int return_value_random_1;
    return_value_random_1=random();
    number = return_value_random_1 % range + (signed long int)1;
    return number;
  }
}

// port_matches
// file urlmatch.c line 1262
static signed int port_matches(const signed int port, const char *port_list)
{
  _Bool tmp_if_expr_2;
  signed int return_value_match_portlist_1;
  if(port_list == ((const char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_match_portlist_1=match_portlist(port_list, port);
    tmp_if_expr_2 = return_value_match_portlist_1 != 0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr_2;
}

// prepare_csp_for_next_request
// file jcc.c line 2802
static void prepare_csp_for_next_request(struct client_state *csp)
{
  unsigned int toggled_on_flag_set = (unsigned int)((unsigned int)0 != (csp->flags & 0x20U));
  csp->content_type = (unsigned int)0;
  csp->content_length = (unsigned long long int)0;
  csp->expected_content_length = (unsigned long long int)0;
  csp->expected_client_content_length = (unsigned long long int)0;
  list_remove_all(csp->headers);
  clear_iob(csp->iob);
  if(!(csp->error_message == ((char *)NULL)))
  {
    free((void *)csp->error_message);
    csp->error_message = (char *)(void *)0;
  }

  free_http_request(csp->http);
  destroy_list(csp->headers);
  destroy_list(csp->tags);
  free_current_action(csp->action);
  if(!(csp->fwd == ((struct forward_spec *)NULL)))
  {
    unload_forward_spec(csp->fwd);
    csp->fwd = (struct forward_spec *)(void *)0;
  }

  csp->flags = 0x01U | 0x00100000U;
  if(!(toggled_on_flag_set == 0u))
    csp->flags = csp->flags | 0x20U;

  if(!(csp->client_iob[0l].cur >= csp->client_iob[0l].eod))
  {
    signed long int bytes_to_shift = csp->client_iob[0l].cur - csp->client_iob[0l].buf;
    unsigned long int data_length = (unsigned long int)(csp->client_iob[0l].eod - csp->client_iob[0l].cur);
    /* assertion bytes_to_shift > 0 */
    assert(bytes_to_shift > (signed long int)0);
    /* assertion data_length > 0 */
    assert(data_length > (unsigned long int)0);
    log_error(0x0002, "Shifting %d pipelined bytes by %d bytes", data_length, bytes_to_shift);
    memmove((void *)csp->client_iob[0l].buf, (const void *)csp->client_iob[0l].cur, data_length);
    csp->client_iob[0l].cur = csp->client_iob[0l].buf;
    /* assertion csp->client_iob->eod == csp->client_iob->buf + bytes_to_shift + data_length */
    assert(csp->client_iob[0l].eod == csp->client_iob[0l].buf + bytes_to_shift + (signed long int)data_length);
    csp->client_iob[0l].eod = csp->client_iob[0l].buf + (signed long int)data_length;
    memset((void *)csp->client_iob[0l].eod, 0, (unsigned long int)bytes_to_shift);
    csp->flags = csp->flags | 0x00800000U;
  }

  else
    clear_iob(csp->client_iob);
}

// prepare_for_filtering
// file filters.c line 2156
static enum privoxy_err prepare_for_filtering(struct client_state *csp)
{
  enum privoxy_err err = (enum privoxy_err)JB_ERR_OK;
  if(!((0x02U & csp->flags) == 0u))
  {
    unsigned long int size = (unsigned long int)(csp->iob[0l].eod - csp->iob[0l].cur);
    log_error(0x0040, "Need to de-chunk first");
    err=remove_chunked_transfer_coding(csp->iob[0l].cur, &size);
    if((signed int)err == JB_ERR_OK)
    {
      csp->iob[0l].eod = csp->iob[0l].cur + (signed long int)size;
      csp->flags = csp->flags | 0x08U;
    }

    else
      return (enum privoxy_err)JB_ERR_PARSE;
  }

  if(!((48u & csp->content_type) == 0u))
  {
    if(csp->iob[0l].eod - csp->iob[0l].cur == 0l)
      return (enum privoxy_err)JB_ERR_OK;

    err=decompress_iob(csp);
    if((signed int)err == JB_ERR_OK)
    {
      csp->flags = csp->flags | 0x08U;
      csp->content_type = csp->content_type & ~0x0004U;
    }

    else
    {
      csp->content_type = csp->content_type & ~0x0010U;
      csp->content_type = csp->content_type & ~0x0020U;
    }
  }

  return err;
}

// privoxy_mutex_init
// file jcc.c line 3210
static void privoxy_mutex_init(union anonymous_2 *mutex)
{
  signed int err;
  err=pthread_mutex_init(mutex, ((const union anonymous_14 *)NULL));
  if(!(err == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(err);
    printf("Fatal error. Mutex initialization failed: %s.\n", return_value_strerror_1);
    exit(1);
  }

}

// privoxy_mutex_lock
// file jcc.h line 75
extern void privoxy_mutex_lock(union anonymous_2 *mutex)
{
  signed int err;
  err=pthread_mutex_lock(mutex);
  if(!(err == 0))
  {
    if(!(mutex == &log_mutex))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(err);
      log_error(0x4000, "Mutex locking failed: %s.\n", return_value_strerror_1);
    }

    exit(1);
  }

}

// privoxy_mutex_unlock
// file jcc.h line 76
extern void privoxy_mutex_unlock(union anonymous_2 *mutex)
{
  signed int err;
  err=pthread_mutex_unlock(mutex);
  if(!(err == 0))
  {
    if(!(mutex == &log_mutex))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(err);
      log_error(0x4000, "Mutex unlocking failed: %s.\n", return_value_strerror_1);
    }

    exit(1);
  }

}

// privoxy_strlcat
// file miscutil.h line 90
unsigned long int privoxy_strlcat(char *destination, const char *source, const unsigned long int size)
{
  unsigned long int old_length;
  old_length=strlen(destination);
  unsigned long int return_value_privoxy_strlcpy_1;
  return_value_privoxy_strlcpy_1=privoxy_strlcpy(destination + (signed long int)old_length, source, size - old_length);
  return old_length + return_value_privoxy_strlcpy_1;
}

// privoxy_strlcpy
// file miscutil.h line 83
unsigned long int privoxy_strlcpy(char *destination, const char *source, const unsigned long int size)
{
  if(size >= 1ul)
  {
    snprintf(destination, size, "%s", source);
    destination[(signed long int)(size - (unsigned long int)1)] = (char)0;
  }

  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(source);
  return return_value_strlen_1;
}

// proxy_authentication
// file parsers.c line 1716
static enum privoxy_err proxy_authentication(struct client_state *csp, char **header)
{
  if((4096U & csp->config->feature_flags) == 0u)
  {
    log_error(0x0008, "Forwarding proxy authentication headers is disabled. Crunching: %s", *header);
    if(!(*header == ((char *)NULL)))
    {
      free((void *)*header);
      *header = (char *)(void *)0;
    }

  }

  return (enum privoxy_err)JB_ERR_OK;
}

// read_config_line
// file loaders.h line 42
extern char * read_config_line(struct _IO_FILE *fp, unsigned long int *linenum, char **buf)
{
  enum privoxy_err err;
  err=edit_read_line(fp, (char **)(void *)0, (char **)(void *)0, buf, (signed int *)(void *)0, linenum);
  if(!(err == /*enum*/JB_ERR_OK))
  {
    if((signed int)err == JB_ERR_MEMORY)
      log_error(0x4000, "Out of memory loading a config file");

    *buf = (char *)(void *)0;
  }

  return *buf;
}

// read_socket
// file jbsockets.h line 51
extern signed int read_socket(signed int fd, char *buf, signed int len)
{
  signed int ret;
  if(!(len >= 1))
    return 0;

  else
  {
    signed long int return_value_read_1;
    return_value_read_1=read(fd, (void *)buf, (unsigned long int)len);
    ret = (signed int)return_value_read_1;
    if(ret >= 1)
      log_error(0x8000, "from socket %d: %N", fd, ret, buf);

    return ret;
  }
}

// receive_chunked_client_request_body
// file jcc.c line 1415
static enum privoxy_err receive_chunked_client_request_body(struct client_state *csp)
{
  unsigned long int body_length;
  enum chunk_status status;
  do
  {
    status=chunked_body_is_complete(csp->client_iob, &body_length);
    if(!((signed int)status == CHUNK_STATUS_MISSING_DATA))
      break;

    char buf[5000l];
    signed int len;
    signed int return_value_data_is_available_1;
    return_value_data_is_available_1=data_is_available(csp->cfd, csp->config->socket_timeout);
    if(return_value_data_is_available_1 == 0)
    {
      log_error(0x2000, "Timeout while waiting for the client body.");
      break;
    }

    len=read_socket(csp->cfd, buf, (signed int)(sizeof(char [5000l]) /*5000ul*/  - (unsigned long int)1));
    if(!(len >= 1))
    {
      log_error(0x2000, "Read the client body failed: %E");
      break;
    }

    enum privoxy_err return_value_add_to_iob_2;
    return_value_add_to_iob_2=add_to_iob(csp->client_iob, csp->config->buffer_limit, buf, (signed long int)len);
    if(!(return_value_add_to_iob_2 == /*enum*/JB_ERR_OK))
      break;

  }
  while((_Bool)1);
  if(!((signed int)status == CHUNK_STATUS_BODY_COMPLETE))
  {
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(CLIENT_BODY_PARSE_ERROR_RESPONSE);
    write_socket(csp->cfd, CLIENT_BODY_PARSE_ERROR_RESPONSE, return_value_strlen_3);
    log_error(0x0200, "%s - - [%T] \"Failed reading chunked client body\" 400 0", csp->ip_addr_str);
    return (enum privoxy_err)JB_ERR_PARSE;
  }

  log_error(0x0002, "Chunked client body completely read. Length: %d", body_length);
  csp->expected_client_content_length = body_length;
  return (enum privoxy_err)JB_ERR_OK;
}

// receive_client_request
// file jcc.c line 1536
static enum privoxy_err receive_client_request(struct client_state *csp)
{
  char buf[5000l];
  char *p;
  char *req = (char *)(void *)0;
  struct http_request *http;
  signed int len;
  enum privoxy_err err;
  struct list header_list;
  struct list *headers = &header_list;
  csp->requests_received_total = csp->requests_received_total + 1u;
  http = csp->http;
  memset((void *)buf, 0, sizeof(char [5000l]) /*5000ul*/ );
  req=get_request_line(csp);
  if(req == ((char *)NULL))
  {
    mark_server_socket_tainted(csp);
    return (enum privoxy_err)JB_ERR_PARSE;
  }

  else
  {
    /* assertion *req != '\0' */
    assert((signed int)*req != 0);
    signed int return_value_client_protocol_is_unsupported_1;
    return_value_client_protocol_is_unsupported_1=client_protocol_is_unsupported(csp, req);
    if(!(return_value_client_protocol_is_unsupported_1 == 0))
      return (enum privoxy_err)JB_ERR_PARSE;

    else
    {
      signed int return_value_force_required_2;
      return_value_force_required_2=force_required(csp, req);
      if(!(return_value_force_required_2 == 0))
        csp->flags = csp->flags | 0x04U;

      err=parse_http_request(req, http);
      if(!(req == ((char *)NULL)))
      {
        free((void *)req);
        req = (char *)(void *)0;
      }

      if(!((signed int)err == JB_ERR_OK))
      {
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(CHEADER);
        write_socket(csp->cfd, CHEADER, return_value_strlen_3);
        log_error(0x0200, "%s - - [%T] \"Invalid request\" 400 0", csp->ip_addr_str);
        const char *return_value_jb_err_to_string_4;
        return_value_jb_err_to_string_4=jb_err_to_string((signed int)err);
        log_error(0x2000, "Couldn't parse request line received from %s: %s", csp->ip_addr_str, return_value_jb_err_to_string_4);
        free_http_request(http);
        return (enum privoxy_err)JB_ERR_PARSE;
      }

      init_list(headers);
      do
      {
        p=get_header(csp->client_iob);
        if(p == ((char *)NULL))
          break;

        if((signed int)*p == 0)
        {
          signed int return_value_data_is_available_5;
          return_value_data_is_available_5=data_is_available(csp->cfd, csp->config->socket_timeout);
          if(return_value_data_is_available_5 == 0)
          {
            log_error(0x2000, "Stopped grabbing the client headers.");
            destroy_list(headers);
            return (enum privoxy_err)JB_ERR_PARSE;
          }

          len=read_socket(csp->cfd, buf, (signed int)(sizeof(char [5000l]) /*5000ul*/  - (unsigned long int)1));
          if(!(len >= 1))
          {
            log_error(0x2000, "read from client failed: %E");
            destroy_list(headers);
            return (enum privoxy_err)JB_ERR_PARSE;
          }

          enum privoxy_err return_value_add_to_iob_6;
          return_value_add_to_iob_6=add_to_iob(csp->client_iob, csp->config->buffer_limit, buf, (signed long int)len);
          if(!(return_value_add_to_iob_6 == /*enum*/JB_ERR_OK))
          {
            destroy_list(headers);
            return (enum privoxy_err)JB_ERR_MEMORY;
          }

        }

        else
        {
          signed int return_value_strncmpic_7;
          return_value_strncmpic_7=strncmpic(p, "Transfer-Encoding:", (unsigned long int)18);
          if(return_value_strncmpic_7 == 0)
            client_transfer_encoding(csp, &p);

          enlist(headers, p);
          if(!(p == ((char *)NULL)))
          {
            free((void *)p);
            p = (char *)(void *)0;
          }

        }
      }
      while((_Bool)1);
      if(http->host == ((char *)NULL))
      {
        enum privoxy_err return_value_get_request_destination_elsewhere_8;
        return_value_get_request_destination_elsewhere_8=get_request_destination_elsewhere(csp, headers);
        if(!((signed int)return_value_get_request_destination_elsewhere_8 == JB_ERR_OK))
          return (enum privoxy_err)JB_ERR_PARSE;

      }

      if((0x20U & csp->flags) == 0u)
        init_current_action(csp->action);

      else
        get_url_actions(csp, http);
      enlist(csp->headers, http->cmd);
      err=list_append_list_unique(csp->headers, headers);
      destroy_list(headers);
      return err;
    }
  }
}

// redirect_url
// file filters.c line 1185
extern struct http_response * redirect_url(struct client_state *csp)
{
  struct http_response *rsp;
  char *redirect_mode;
  char *old_url = (char *)(void *)0;
  char *new_url = (char *)(void *)0;
  char *redirection_string;
  if(!((0x00020000UL & csp->action[0l].flags) == 0ul))
  {
    redirection_string = csp->action[0l].string[(signed long int)13];
    if((signed int)*redirection_string == 115)
    {
      old_url = csp->http[0l].url;
      new_url=rewrite_url(old_url, redirection_string);
    }

    else
    {
      log_error(0x0080, "No pcrs command recognized, assuming that \"%s\" is already properly formatted.", redirection_string);
      new_url=strdup(redirection_string);
    }
  }

  char *tmp_if_expr_2;
  char *return_value_strdup_1;
  if(!((0x00000008UL & csp->action[0l].flags) == 0ul))
  {
    redirect_mode = csp->action[0l].string[(signed long int)14];
    if(!(new_url == ((char *)NULL)))
      tmp_if_expr_2 = new_url;

    else
    {
      return_value_strdup_1=strdup(csp->http[0l].path);
      tmp_if_expr_2 = return_value_strdup_1;
    }
    old_url = tmp_if_expr_2;
    new_url=get_last_url(old_url, redirect_mode);
    if(!(old_url == ((char *)NULL)))
    {
      free((void *)old_url);
      old_url = (char *)(void *)0;
    }

  }

  csp->action[0l].flags = csp->action[0l].flags & ~0x00000008UL;
  csp->action[0l].flags = csp->action[0l].flags & ~0x00020000UL;
  if(!(new_url == ((char *)NULL)))
  {
    signed int return_value_url_requires_percent_encoding_6;
    return_value_url_requires_percent_encoding_6=url_requires_percent_encoding(new_url);
    if(!(return_value_url_requires_percent_encoding_6 == 0))
    {
      char *encoded_url;
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(new_url);
      log_error(0x0080, "Percent-encoding redirect URL: %N", return_value_strlen_3, new_url);
      encoded_url=percent_encode_url(new_url);
      if(!(new_url == ((char *)NULL)))
      {
        free((void *)new_url);
        new_url = (char *)(void *)0;
      }

      if(encoded_url == ((char *)NULL))
      {
        struct http_response *return_value_cgi_error_memory_4;
        return_value_cgi_error_memory_4=cgi_error_memory();
        return return_value_cgi_error_memory_4;
      }

      new_url = encoded_url;
      signed int return_value_url_requires_percent_encoding_5;
      return_value_url_requires_percent_encoding_5=url_requires_percent_encoding(new_url);
      /* assertion 0 == url_requires_percent_encoding(new_url) */
      assert(0 == return_value_url_requires_percent_encoding_5);
    }

    signed int return_value_strcmpic_11;
    return_value_strcmpic_11=strcmpic(new_url, csp->http[0l].url);
    if(return_value_strcmpic_11 == 0)
    {
      log_error(0x2000, "New URL \"%s\" and old URL \"%s\" are the same. Redirection loop prevented.", csp->http[0l].url, new_url);
      if(!(new_url == ((char *)NULL)))
      {
        free((void *)new_url);
        new_url = (char *)(void *)0;
      }

    }

    else
    {
      log_error(0x0080, "New URL is: %s", new_url);
      rsp=alloc_http_response();
      if(rsp == ((struct http_response *)NULL))
      {
        if(!(new_url == ((char *)NULL)))
        {
          free((void *)new_url);
          new_url = (char *)(void *)0;
        }

        struct http_response *return_value_cgi_error_memory_7;
        return_value_cgi_error_memory_7=cgi_error_memory();
        return return_value_cgi_error_memory_7;
      }

      rsp->status=strdup_or_die("302 Local Redirect from Privoxy");
      enum privoxy_err return_value_enlist_unique_header_9;
      return_value_enlist_unique_header_9=enlist_unique_header(rsp->headers, "Location", new_url);
      if(!(return_value_enlist_unique_header_9 == /*enum*/JB_ERR_OK))
      {
        if(!(new_url == ((char *)NULL)))
        {
          free((void *)new_url);
          new_url = (char *)(void *)0;
        }

        free_http_response(rsp);
        struct http_response *return_value_cgi_error_memory_8;
        return_value_cgi_error_memory_8=cgi_error_memory();
        return return_value_cgi_error_memory_8;
      }

      rsp->crunch_reason = (enum crunch_reason)REDIRECTED;
      if(!(new_url == ((char *)NULL)))
      {
        free((void *)new_url);
        new_url = (char *)(void *)0;
      }

      struct http_response *return_value_finish_http_response_10;
      return_value_finish_http_response_10=finish_http_response(csp, rsp);
      return return_value_finish_http_response_10;
    }
  }

  return (struct http_response *)(void *)0;
}

// referenced_filters_are_missing
// file actions.c line 1099
static signed int referenced_filters_are_missing(struct client_state *csp, struct action_spec *cur_action, signed int multi_index, enum filter_type filter_type)
{
  struct list_entry *filtername = cur_action->multi_add[(signed long int)multi_index][0l].first;
  for( ; !(filtername == ((struct list_entry *)NULL)); filtername = filtername->next)
  {
    struct re_filterfile_spec *return_value_get_filter_1;
    return_value_get_filter_1=get_filter(csp, filtername->str, filter_type);
    if(return_value_get_filter_1 == ((struct re_filterfile_spec *)NULL))
    {
      log_error(0x2000, "Missing filter '%s'", filtername->str);
      return 1;
    }

  }
  return 0;
}

// referrer_is_safe
// file cgi.c line 423
static signed int referrer_is_safe(struct client_state *csp)
{
  char *referrer;
  referrer=grep_cgi_referrer(csp);
  signed int return_value_strncmp_1;
  _Bool tmp_if_expr_4;
  unsigned long int return_value_strlen_2;
  signed int return_value_strncmp_3;
  if(referrer == ((char *)NULL))
    log_error(0x2000, "Denying access to %s. No referrer found.", csp->http[0l].url);

  else
  {
    return_value_strncmp_1=strncmp(referrer, "http://config.privoxy.org/", sizeof(char [27l]) /*27ul*/  - (unsigned long int)1);
    if(return_value_strncmp_1 == 0)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      static const char alternative_prefix[12l] = { 'h', 't', 't', 'p', ':', '/', '/', 'p', '.', 'p', '/', 0 };
      return_value_strlen_2=strlen(alternative_prefix);
      return_value_strncmp_3=strncmp(referrer, alternative_prefix, return_value_strlen_2);
      tmp_if_expr_4 = 0 == return_value_strncmp_3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      log_error(0x0800, "Granting access to %s, referrer %s is trustworthy.", csp->http[0l].url, referrer);
      return 1;
    }

    else
      log_error(0x2000, "Denying access to %s, referrer %s isn't trustworthy.", csp->http[0l].url, referrer);
  }
  return 0;
}

// remember_connection
// file gateway.c line 186
extern void remember_connection(struct reusable_connection *connection)
{
  unsigned int slot = (unsigned int)0;
  signed int free_slot_found = 0;
  /* assertion ((void *)0) != connection */
  assert((struct reusable_connection *)(void *)0 != connection);
  /* assertion connection->sfd != (-1) */
  assert(connection->sfd != -1);
  signed int return_value_mark_connection_unused_1;
  return_value_mark_connection_unused_1=mark_connection_unused(connection);
  if(return_value_mark_connection_unused_1 == 0)
  {
    privoxy_mutex_lock(&connection_reuse_mutex);
    slot = (unsigned int)0;
    for( ; !((unsigned long int)slot >= 100ul); slot = slot + 1u)
      if(reusable_connection[(signed long int)slot].sfd == -1)
      {
        /* assertion reusable_connection[slot].in_use == 0 */
        assert(reusable_connection[(signed long int)slot].in_use == 0);
        log_error(0x0002, "Remembering socket %d for %s:%d in slot %d.", connection->sfd, connection->host, connection->port, slot);
        free_slot_found = 1;
        break;
      }

    if(free_slot_found == 0)
    {
      log_error(0x0002, "No free slots found to remember socket for %s:%d. Last slot %d.", connection->host, connection->port, slot);
      privoxy_mutex_unlock(&connection_reuse_mutex);
      close_socket(connection->sfd);
    }

    else
    {
      /* assertion ((void *)0) != connection->host */
      assert((char *)(void *)0 != connection->host);
      reusable_connection[(signed long int)slot].host=strdup_or_die(connection->host);
      reusable_connection[(signed long int)slot].sfd = connection->sfd;
      reusable_connection[(signed long int)slot].port = connection->port;
      reusable_connection[(signed long int)slot].in_use = 0;
      reusable_connection[(signed long int)slot].timestamp = connection->timestamp;
      reusable_connection[(signed long int)slot].request_sent = connection->request_sent;
      reusable_connection[(signed long int)slot].response_received = connection->response_received;
      reusable_connection[(signed long int)slot].keep_alive_timeout = connection->keep_alive_timeout;
      reusable_connection[(signed long int)slot].requests_sent_total = connection->requests_sent_total;
      /* assertion reusable_connection[slot].gateway_host == ((void *)0) */
      assert(reusable_connection[(signed long int)slot].gateway_host == (char *)(void *)0);
      /* assertion reusable_connection[slot].gateway_port == 0 */
      assert(reusable_connection[(signed long int)slot].gateway_port == 0);
      /* assertion reusable_connection[slot].forwarder_type == SOCKS_NONE */
      assert((signed int)reusable_connection[(signed long int)slot].forwarder_type == SOCKS_NONE);
      /* assertion reusable_connection[slot].forward_host == ((void *)0) */
      assert(reusable_connection[(signed long int)slot].forward_host == (char *)(void *)0);
      /* assertion reusable_connection[slot].forward_port == 0 */
      assert(reusable_connection[(signed long int)slot].forward_port == 0);
      reusable_connection[(signed long int)slot].forwarder_type = connection->forwarder_type;
      if(!(connection->gateway_host == ((char *)NULL)))
        reusable_connection[(signed long int)slot].gateway_host=strdup_or_die(connection->gateway_host);

      else
        reusable_connection[(signed long int)slot].gateway_host = (char *)(void *)0;
      reusable_connection[(signed long int)slot].gateway_port = connection->gateway_port;
      if(!(connection->forward_host == ((char *)NULL)))
        reusable_connection[(signed long int)slot].forward_host=strdup_or_die(connection->forward_host);

      else
        reusable_connection[(signed long int)slot].forward_host = (char *)(void *)0;
      reusable_connection[(signed long int)slot].forward_port = connection->forward_port;
      privoxy_mutex_unlock(&connection_reuse_mutex);
    }
  }

}

// remove_chunked_transfer_coding
// file filters.c line 2051
static enum privoxy_err remove_chunked_transfer_coding(char *buffer, unsigned long int *size)
{
  unsigned long int newsize = (unsigned long int)0;
  unsigned int chunksize = (unsigned int)0;
  char *from_p;
  char *to_p;
  const char *end_of_buffer = buffer + (signed long int)*size;
  /* assertion buffer */
  assert(buffer != ((char *)NULL));
  to_p = buffer;
  from_p = to_p;
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(buffer, "%x", &chunksize);
  if(!(return_value_sscanf_1 == 1))
  {
    log_error(0x2000, "Invalid first chunksize while stripping \"chunked\" transfer coding");
    return (enum privoxy_err)JB_ERR_PARSE;
  }

  else
  {
    while(chunksize >= 1u)
    {
      if((unsigned long int)(5u + chunksize) >= *size + -newsize)
      {
        log_error(0x2000, "Chunk size %u exceeds buffered data left. Already digested %u of %u buffered bytes.", chunksize, (unsigned int)newsize, (unsigned int)*size);
        return (enum privoxy_err)JB_ERR_PARSE;
      }

      from_p=strstr(from_p, "\r\n");
      if(from_p == ((char *)NULL))
      {
        log_error(0x2000, "Parse error while stripping \"chunked\" transfer coding");
        return (enum privoxy_err)JB_ERR_PARSE;
      }

      from_p = from_p + (signed long int)2;
      if(from_p + (signed long int)chunksize >= end_of_buffer)
      {
        log_error(0x2000, "End of chunk is beyond the end of the buffer.");
        return (enum privoxy_err)JB_ERR_PARSE;
      }

      memmove((void *)to_p, (const void *)from_p, (unsigned long int)chunksize);
      newsize = newsize + (unsigned long int)chunksize;
      to_p = buffer + (signed long int)newsize;
      from_p = from_p + (signed long int)chunksize;
      if(from_p + 2l >= end_of_buffer)
      {
        log_error(0x2000, "Not enough room for trailing CRLF.");
        return (enum privoxy_err)JB_ERR_PARSE;
      }

      from_p = from_p + (signed long int)2;
      signed int return_value_sscanf_2;
      return_value_sscanf_2=sscanf(from_p, "%x", &chunksize);
      if(!(return_value_sscanf_2 == 1))
      {
        log_error(0x1000, "Invalid \"chunked\" transfer encoding detected and ignored.");
        break;
      }

    }
    log_error(0x0040, "De-chunking successful. Shrunk from %d to %d", *size, newsize);
    *size = newsize;
    return (enum privoxy_err)JB_ERR_OK;
  }
}

// resolve_hostname_to_ip
// file jbsockets.h line 60
extern unsigned long int resolve_hostname_to_ip(const char *host)
{
  struct sockaddr_in inaddr;
  struct hostent *hostp;
  struct hostent result;
  char hbuf[2048l];
  signed int thd_err;
  _Bool tmp_if_expr_1;
  if(host == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)*host == 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_gethostbyname_r_2;
  unsigned int tmp_post_3;
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_1)
    return (unsigned long int)(unsigned int)0x00000000;

  else
  {
    memset((void *)(char *)&inaddr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    inaddr.sin_addr.s_addr=inet_addr(host);
    if(inaddr.sin_addr.s_addr == 4294967295u)
    {
      unsigned int dns_retries = (unsigned int)0;
      do
      {
        return_value_gethostbyname_r_2=gethostbyname_r(host, &result, hbuf, (unsigned long int)2048, &hostp, &thd_err);
        if(return_value_gethostbyname_r_2 == 0)
          break;

        if(!(thd_err == 2))
          break;

        tmp_post_3 = dns_retries;
        dns_retries = dns_retries + 1u;
        if(tmp_post_3 >= 10u)
          break;

        log_error(0x2000, "Timeout #%u while trying to resolve %s. Trying again.", dns_retries, host);
      }
      while((_Bool)1);
      if(hostp == ((struct hostent *)NULL))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = hostp->h_addr_list[(signed long int)0] == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        *return_value___errno_location_4 = 22;
        log_error(0x2000, "could not resolve hostname %s", host);
        return (unsigned long int)(unsigned int)0xffffffff;
      }

      if(!(hostp->h_addrtype == 2))
      {
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        *return_value___errno_location_6 = 91;
        log_error(0x2000, "hostname %s resolves to unknown address type.", host);
        return (unsigned long int)(unsigned int)0xffffffff;
      }

      memcpy((void *)(char *)&inaddr.sin_addr, (const void *)(char *)hostp->h_addr_list[(signed long int)0], sizeof(struct in_addr) /*4ul*/ );
    }

    return (unsigned long int)inaddr.sin_addr.s_addr;
  }
}

// rewrite_url
// file filters.c line 985
extern char * rewrite_url(char *old_url, const char *pcrs_command)
{
  char *new_url = (char *)(void *)0;
  signed int hits;
  /* assertion old_url */
  assert(old_url != ((char *)NULL));
  /* assertion pcrs_command */
  assert(pcrs_command != ((const char *)NULL));
  new_url=pcrs_execute_single_command(old_url, pcrs_command, &hits);
  signed int return_value_strncmpic_2;
  _Bool tmp_if_expr_4;
  signed int return_value_strncmpic_3;
  if(hits == 0)
  {
    log_error(0x0080, "pcrs command \"%s\" didn't change \"%s\".", pcrs_command, old_url);
    if(!(new_url == ((char *)NULL)))
    {
      free((void *)new_url);
      new_url = (char *)(void *)0;
    }

  }

  else
    if(!(hits >= 0))
    {
      const char *return_value_pcrs_strerror_1;
      return_value_pcrs_strerror_1=pcrs_strerror(hits);
      log_error(0x0080, "executing pcrs command \"%s\" to rewrite %s failed: %s", pcrs_command, old_url, return_value_pcrs_strerror_1);
      if(!(new_url == ((char *)NULL)))
      {
        free((void *)new_url);
        new_url = (char *)(void *)0;
      }

    }

    else
    {
      return_value_strncmpic_2=strncmpic(new_url, "http://", (unsigned long int)7);
      if(!(return_value_strncmpic_2 == 0))
      {
        return_value_strncmpic_3=strncmpic(new_url, "https://", (unsigned long int)8);
        tmp_if_expr_4 = return_value_strncmpic_3 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
      {
        log_error(0x2000, "pcrs command \"%s\" changed \"%s\" to \"%s\" (%u hi%s), but the result doesn't look like a valid URL and will be ignored.", pcrs_command, old_url, new_url, hits, hits == 1 ? "t" : "ts");
        if(!(new_url == ((char *)NULL)))
        {
          free((void *)new_url);
          new_url = (char *)(void *)0;
        }

      }

      else
        log_error(0x0080, "pcrs command \"%s\" changed \"%s\" to \"%s\" (%u hi%s).", pcrs_command, old_url, new_url, hits, hits == 1 ? "t" : "ts");
    }
  return new_url;
}

// rfc2553_connect_to
// file jbsockets.c line 207
static signed int rfc2553_connect_to(const char *host, signed int portnum, struct client_state *csp)
{
  struct addrinfo hints;
  struct addrinfo *result;
  struct addrinfo *rp;
  char service[6l];
  signed int retval;
  signed int fd;
  struct anonymous_13 wfds;
  struct timeval timeout;
  signed int flags;
  signed int connect_failed;
  signed int socket_error = 0;
  struct access_control_addr dst[1l];
  if(!(csp->error_message == ((char *)NULL)))
  {
    free((void *)csp->error_message);
    csp->error_message = (char *)(void *)0;
  }

  if(!(csp->http[0l].host_ip_addr_str == ((char *)NULL)))
  {
    free((void *)csp->http[0l].host_ip_addr_str);
    csp->http[0l].host_ip_addr_str = (char *)(void *)0;
  }

  retval=snprintf(service, sizeof(char [6l]) /*6ul*/ , "%d", portnum);
  signed int return_value_connect_8;
  if(retval == -1 || (unsigned long int)retval >= sizeof(char [6l]) /*6ul*/ )
  {
    log_error(0x2000, "Port number (%d) ASCII decimal representation doesn't fit into 6 bytes", portnum);
    csp->error_message=strdup("Invalid port number");
    csp->http[0l].host_ip_addr_str=strdup("unknown");
    return -1;
  }

  else
  {
    memset((void *)(char *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
    hints.ai_family = 0;
    hints.ai_socktype = 1;
    hints.ai_flags = 0x0400;
    hints.ai_flags = hints.ai_flags | 0x0020;
    retval=getaddrinfo(host, service, &hints, &result);
    if(!(retval == 0))
    {
      const char *return_value_gai_strerror_1;
      return_value_gai_strerror_1=gai_strerror(retval);
      log_error(0x1000, "Can not resolve %s: %s", host, return_value_gai_strerror_1);
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 22;
      const char *return_value_gai_strerror_3;
      return_value_gai_strerror_3=gai_strerror(retval);
      csp->error_message=strdup(return_value_gai_strerror_3);
      csp->http[0l].host_ip_addr_str=strdup("unknown");
      return -1;
    }

    void *return_value_malloc_or_die_4;
    return_value_malloc_or_die_4=malloc_or_die((unsigned long int)1025);
    csp->http[0l].host_ip_addr_str = (char *)return_value_malloc_or_die_4;
    rp = result;
    for( ; !(rp == ((struct addrinfo *)NULL)); rp = rp->ai_next)
    {
      memcpy((void *)&dst[0l].addr, (const void *)rp->ai_addr, (unsigned long int)rp->ai_addrlen);
      signed int return_value_block_acl_6;
      return_value_block_acl_6=block_acl(dst, csp);
      if(!(return_value_block_acl_6 == 0))
      {
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        *return_value___errno_location_5 = 1;
        socket_error = *return_value___errno_location_5;
        goto __CPROVER_DUMP_L20;
      }

      retval=getnameinfo(rp->ai_addr, rp->ai_addrlen, csp->http[0l].host_ip_addr_str, (unsigned int)1025, (char *)(void *)0, (unsigned int)0, 1);
      if(!(retval == 0))
      {
        const char *return_value_gai_strerror_7;
        return_value_gai_strerror_7=gai_strerror(retval);
        log_error(0x2000, "Failed to get the host name from the socket structure: %s", return_value_gai_strerror_7);
        goto __CPROVER_DUMP_L20;
      }

      fd=socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
      if(fd >= 0)
      {
        if(fd >= 1024)
        {
          log_error(0x2000, "Server socket number too high to use select(): %d >= %d", fd, 1024);
          close_socket(fd);
          freeaddrinfo(result);
          return -1;
        }

        mark_socket_for_close_on_execute(fd);
        set_no_delay_flag(fd);
        flags=fcntl(fd, 3, 0);
        if(!(flags == -1))
        {
          flags = flags | 04000;
          fcntl(fd, 4, flags);
        }

        connect_failed = 0;
        do
        {
          return_value_connect_8=connect(fd, rp->ai_addr, rp->ai_addrlen);
          if(!(return_value_connect_8 == -1))
            break;

          signed int *return_value___errno_location_9;
          return_value___errno_location_9=__errno_location();
          if(*return_value___errno_location_9 == 115)
            break;

          signed int *return_value___errno_location_11;
          return_value___errno_location_11=__errno_location();
          if(!(*return_value___errno_location_11 == 4))
          {
            signed int *return_value___errno_location_10;
            return_value___errno_location_10=__errno_location();
            socket_error = *return_value___errno_location_10;
            close_socket(fd);
            connect_failed = 1;
            break;
          }

        }
        while((_Bool)1);
        if(connect_failed == 0)
        {
          if(!(flags == -1))
          {
            flags = flags & ~04000;
            fcntl(fd, 4, flags);
          }

          do
          {
            signed int __d0;
            signed int __d1;
            asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_13) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wfds)->__fds_bits[(signed long int)0]) : "memory");
          }
          while((_Bool)0);
          (&wfds)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wfds)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
          memset((void *)&timeout, 0, sizeof(struct timeval) /*16ul*/ );
          timeout.tv_sec = (signed long int)30;
          signed int return_value_select_17;
          return_value_select_17=select((signed int)fd + 1, (struct anonymous_13 *)(void *)0, &wfds, (struct anonymous_13 *)(void *)0, &timeout);
          if(return_value_select_17 >= 1)
          {
            if(!((wfds.__fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
            {
              unsigned int optlen = (unsigned int)sizeof(signed int) /*4ul*/ ;
              signed int return_value_getsockopt_16;
              return_value_getsockopt_16=getsockopt(fd, 1, 4, (void *)&socket_error, &optlen);
              if(return_value_getsockopt_16 == 0)
              {
                if(socket_error == 0)
                  break;

                if(!(rp->ai_next == ((struct addrinfo *)NULL)))
                {
                  char *return_value_strerror_12;
                  return_value_strerror_12=strerror(socket_error);
                  log_error(0x0002, "Could not connect to [%s]:%s: %s.", csp->http[0l].host_ip_addr_str, (const void *)service, return_value_strerror_12);
                }

              }

              else
              {
                signed int *return_value___errno_location_13;
                return_value___errno_location_13=__errno_location();
                socket_error = *return_value___errno_location_13;
                signed int *return_value___errno_location_14;
                return_value___errno_location_14=__errno_location();
                char *return_value_strerror_15;
                return_value_strerror_15=strerror(*return_value___errno_location_14);
                log_error(0x2000, "Could not get the state of the connection to [%s]:%s: %s; dropping connection.", csp->http[0l].host_ip_addr_str, (const void *)service, return_value_strerror_15);
              }
            }

          }

          close_socket(fd);
        }

      }


    __CPROVER_DUMP_L20:
      ;
    }
    freeaddrinfo(result);
    if(rp == ((struct addrinfo *)NULL))
    {
      char *return_value_strerror_18;
      return_value_strerror_18=strerror(socket_error);
      log_error(0x0002, "Could not connect to [%s]:%s: %s.", host, (const void *)service, return_value_strerror_18);
      char *return_value_strerror_19;
      return_value_strerror_19=strerror(socket_error);
      csp->error_message=strdup(return_value_strerror_19);
      return -1;
    }

    log_error(0x0002, "Connected to %s[%s]:%s.", host, csp->http[0l].host_ip_addr_str, (const void *)service);
    return fd;
  }
}

// run_loader
// file loaders.h line 93
extern signed int run_loader(struct client_state *csp)
{
  signed int ret = 0;
  signed int i = 0;
  if(!(i >= 8))
  {
    if(!(csp->config->loaders[(signed long int)i] == ((signed int (*)(struct client_state *))NULL)))
    {
      signed int return_value;
      return_value=csp->config->loaders[(signed long int)i](csp);
      ret = ret | return_value;
      i = i + 1;
    }

  }

  return ret;
}

// save_connection_destination
// file jcc.c line 1057
void save_connection_destination(signed int sfd, struct http_request *http, struct forward_spec *fwd, struct reusable_connection *server_connection)
{
  /* assertion sfd != (-1) */
  assert(sfd != -1);
  /* assertion ((void *)0) != http->host */
  assert((char *)(void *)0 != http->host);
  server_connection->sfd = sfd;
  server_connection->host=strdup_or_die(http->host);
  server_connection->port = http->port;
  /* assertion ((void *)0) != fwd */
  assert((struct forward_spec *)(void *)0 != fwd);
  /* assertion server_connection->gateway_host == ((void *)0) */
  assert(server_connection->gateway_host == (char *)(void *)0);
  /* assertion server_connection->gateway_port == 0 */
  assert(server_connection->gateway_port == 0);
  /* assertion server_connection->forwarder_type == 0 */
  assert((signed int)server_connection->forwarder_type == 0);
  /* assertion server_connection->forward_host == ((void *)0) */
  assert(server_connection->forward_host == (char *)(void *)0);
  /* assertion server_connection->forward_port == 0 */
  assert(server_connection->forward_port == 0);
  server_connection->forwarder_type = fwd->type;
  if(!(fwd->gateway_host == ((char *)NULL)))
    server_connection->gateway_host=strdup_or_die(fwd->gateway_host);

  else
    server_connection->gateway_host = (char *)(void *)0;
  server_connection->gateway_port = fwd->gateway_port;
  if(!(fwd->forward_host == ((char *)NULL)))
    server_connection->forward_host=strdup_or_die(fwd->forward_host);

  else
    server_connection->forward_host = (char *)(void *)0;
  server_connection->forward_port = fwd->forward_port;
}

// savearg
// file loadcfg.c line 1856
static void savearg(char *command, char *argument, struct configuration_spec *config)
{
  char *buf;
  char *s;
  /* assertion command */
  assert(command != ((char *)NULL));
  /* assertion argument */
  assert(argument != ((char *)NULL));
  buf=strdup("\n<a href=\"");
  signed int return_value_strncmpic_1;
  return_value_strncmpic_1=strncmpic(config->usermanual, "file://", (unsigned long int)7);
  _Bool tmp_if_expr_3;
  signed int return_value_strncmpic_2;
  if(return_value_strncmpic_1 == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strncmpic_2=strncmpic(config->usermanual, "http", (unsigned long int)4);
    tmp_if_expr_3 = !(return_value_strncmpic_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
    string_append(&buf, config->usermanual);

  else
    string_append(&buf, "http://config.privoxy.org/user-manual/");
  string_append(&buf, "config.html#");
  char *return_value_string_toupper_4;
  return_value_string_toupper_4=string_toupper(command);
  string_join(&buf, return_value_string_toupper_4);
  string_append(&buf, "\">");
  string_append(&buf, command);
  string_append(&buf, "</a> ");
  if(buf == ((char *)NULL))
  {
    if(!(config->proxy_args == ((char *)NULL)))
    {
      free((void *)config->proxy_args);
      config->proxy_args = (char *)(void *)0;
    }

  }

  else
  {
    if(!(argument == ((char *)NULL)))
    {
      if(!((signed int)*argument == 0))
      {
        s=html_encode(argument);
        if(s == ((char *)NULL))
        {
          if(!(buf == ((char *)NULL)))
          {
            free((void *)buf);
            buf = (char *)(void *)0;
          }

          if(!(config->proxy_args == ((char *)NULL)))
          {
            free((void *)config->proxy_args);
            config->proxy_args = (char *)(void *)0;
          }

          goto __CPROVER_DUMP_L13;
        }

        signed int return_value_strncmpic_5;
        return_value_strncmpic_5=strncmpic(argument, "http://", (unsigned long int)7);
        if(return_value_strncmpic_5 == 0)
        {
          string_append(&buf, "<a href=\"");
          string_append(&buf, s);
          string_append(&buf, "\">");
          string_join(&buf, s);
          string_append(&buf, "</a>");
        }

        else
          string_join(&buf, s);
      }

    }

    string_append(&buf, "<br>");
    string_join(&config->proxy_args, buf);
  }

__CPROVER_DUMP_L13:
  ;
}

// scan_headers
// file parsers.c line 1012
static enum privoxy_err scan_headers(struct client_state *csp)
{
  struct list_entry *h;
  enum privoxy_err err = (enum privoxy_err)JB_ERR_OK;
  h = csp->headers[0l].first;
  for( ; (signed int)err == JB_ERR_OK && !(h == ((struct list_entry *)NULL)); h = h->next)
    if(!(h->str == ((char *)NULL)))
    {
      log_error(0x0008, "scan: %s", h->str);
      err=header_tagger(csp, h->str);
    }

  return err;
}

// section_target
// file cgiedit.c line 345
static char * section_target(const unsigned int sectionid)
{
  char buf[30l];
  snprintf(buf, sizeof(char [30l]) /*30ul*/ , "#l%u", sectionid);
  char *return_value_strdup_1;
  return_value_strdup_1=strdup(buf);
  return return_value_strdup_1;
}

// sed
// file parsers.h line 59
extern enum privoxy_err sed(struct client_state *csp, signed int filter_server_headers)
{
  struct list_entry *p;
  struct parsers *v;
  enum privoxy_err (* const *f)(struct client_state *);
  enum privoxy_err err = (enum privoxy_err)JB_ERR_OK;
  scan_headers(csp);
  if(!(filter_server_headers == 0))
  {
    v = server_patterns;
    f = add_server_headers;
    check_negative_tag_patterns(csp, (unsigned int)0x00000008UL);
  }

  else
  {
    v = client_patterns;
    f = add_client_headers;
    check_negative_tag_patterns(csp, (unsigned int)0x00000004UL);
  }
  _Bool tmp_if_expr_2;
  for( ; !(v->str == ((const char *)NULL)); v = v + 1l)
  {
    p = csp->headers[0l].first;
    for( ; !(p == ((struct list_entry *)NULL)); p = p->next)
      if(!(p->str == ((char *)NULL)))
      {
        signed int return_value_strncmpic_1;
        return_value_strncmpic_1=strncmpic(p->str, v->str, v->len);
        if(return_value_strncmpic_1 == 0)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = v->len == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
        {
          err=v->parser(csp, &p->str);
          if(!((signed int)err == JB_ERR_OK))
            return err;

        }

      }

  }
  if((signed int)err == JB_ERR_OK)
  {
    if(!(*f == ((enum privoxy_err (*)(struct client_state *))NULL)))
    {
      err=(*f)(csp);
      f = f + 1l;
    }

  }

  signed int return_value_list_is_empty_3;
  if(filter_server_headers == 0)
  {
    return_value_list_is_empty_3=list_is_empty(csp->config->ordered_client_headers);
    if(return_value_list_is_empty_3 == 0)
      enforce_header_order(csp->headers, csp->config->ordered_client_headers);

  }

  return err;
}

// send_crunch_response
// file jcc.c line 750
static void send_crunch_response(struct client_state *csp, struct http_response *rsp)
{
  struct http_request *http = csp->http;
  char status_code[4l];
  /* assertion rsp != ((void *)0) */
  assert(rsp != (struct http_response *)(void *)0);
  /* assertion rsp->head != ((void *)0) */
  assert(rsp->head != (char *)(void *)0);
  if(rsp == ((struct http_response *)NULL))
    log_error(0x4000, "NULL response in send_crunch_response.");

  status_code[(signed long int)0] = rsp->head[(signed long int)9];
  status_code[(signed long int)1] = rsp->head[(signed long int)10];
  status_code[(signed long int)2] = rsp->head[(signed long int)11];
  status_code[(signed long int)3] = (char)0;
  log_applied_actions(csp->action);
  const char *return_value_crunch_reason_1;
  return_value_crunch_reason_1=crunch_reason(rsp);
  log_error(0x0400, "%s: %s", return_value_crunch_reason_1, http->url);
  log_error(0x0200, "%s - - [%T] \"%s\" %s %u", csp->ip_addr_str, http->ocmd, (const void *)status_code, rsp->content_length);
  signed int return_value_write_socket_2;
  return_value_write_socket_2=write_socket(csp->cfd, rsp->head, rsp->head_length);
  _Bool tmp_if_expr_4;
  signed int return_value_write_socket_3;
  if(!(return_value_write_socket_2 == 0))
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_write_socket_3=write_socket(csp->cfd, rsp->body, rsp->content_length);
    tmp_if_expr_4 = return_value_write_socket_3 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_4)
    log_error(0x2000, "Couldn't deliver the error message through client socket %d: %E", csp->cfd);

  struct http_response *return_value_cgi_error_memory_5;
  return_value_cgi_error_memory_5=cgi_error_memory();
  if(!(return_value_cgi_error_memory_5 == rsp))
    free_http_response(rsp);

  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// serve
// file jcc.c line 2880
static void serve(struct client_state *csp)
{
  signed int config_file_change_detected = 0;
  signed int continue_chatting = 0;
  log_error(0x0002, "Accepted connection from %s on socket %d", csp->ip_addr_str, csp->cfd);
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_9;
  signed int return_value_socket_is_still_alive_8;
  _Bool tmp_if_expr_10;
  signed int return_value_any_loaded_file_changed_11;
  signed int return_value_socket_is_still_alive_12;
  _Bool tmp_if_expr_16;
  signed int return_value_data_is_available_15;
  _Bool tmp_if_expr_18;
  signed int return_value_socket_is_still_alive_17;
  signed int return_value_socket_is_still_alive_14;
  do
  {
    unsigned int latency;
    chat(csp);
    latency = (unsigned int)(csp->server_connection.response_received - csp->server_connection.request_sent) / (unsigned int)2;
    if(!((0x00008000U & csp->flags) == 0u))
    {
      if(!((0x04000000U & csp->flags) == 0u))
      {
        if(!(csp->expected_client_content_length == 0ul))
        {
          csp->flags = csp->flags | 0x00040000U;
          log_error(0x0002, "Tainting client socket %d due to unread data.", csp->cfd);
        }

      }

    }

    if(!((128U & csp->config->feature_flags) == 0u))
      tmp_if_expr_1 = !((csp->flags & 0x00040000U) != 0u) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = csp->cfd != -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (csp->flags & 0x00008000U) != 0u ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      if(!((0x00002000U & csp->flags) == 0u))
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = (csp->flags & 0x02U) != 0u ? (_Bool)1 : (_Bool)0;
      tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_5 = (_Bool)0;
    continue_chatting = (signed int)tmp_if_expr_5;
    if((0x04000000U & csp->flags) == 0u)
    {
      if(!(csp->server_connection.sfd == -1))
      {
        if((0x00020000U & csp->flags) == 0u)
          csp->server_connection.keep_alive_timeout = csp->config->default_server_timeout;

        if((0x00001000U & csp->flags) == 0u)
          tmp_if_expr_7 = (_Bool)1;

        else
          tmp_if_expr_7 = (csp->flags & 0x00040000U) != 0u ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_7)
          tmp_if_expr_9 = (_Bool)1;

        else
        {
          return_value_socket_is_still_alive_8=socket_is_still_alive(csp->server_connection.sfd);
          tmp_if_expr_9 = !(return_value_socket_is_still_alive_8 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_9)
          tmp_if_expr_10 = (_Bool)1;

        else
          tmp_if_expr_10 = !(latency < csp->server_connection.keep_alive_timeout) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_10)
        {
          signed int return_value_socket_is_still_alive_6;
          return_value_socket_is_still_alive_6=socket_is_still_alive(csp->server_connection.sfd);
          log_error(0x0002, "Closing server socket %d connected to %s. Keep-alive %u. Tainted: %u. Socket alive %u. Timeout: %u.", csp->server_connection.sfd, csp->server_connection.host, (unsigned int)0 != (csp->flags & 0x00001000U), (unsigned int)0 != (csp->flags & 0x00040000U), return_value_socket_is_still_alive_6, csp->server_connection.keep_alive_timeout);
          if(!((256U & csp->config->feature_flags) == 0u))
            forget_connection(csp->server_connection.sfd);

          close_socket(csp->server_connection.sfd);
          mark_connection_closed(&csp->server_connection);
        }

      }

    }

    if(!(continue_chatting == 0))
    {
      return_value_any_loaded_file_changed_11=any_loaded_file_changed(csp);
      if(!(return_value_any_loaded_file_changed_11 == 0))
      {
        continue_chatting = 0;
        config_file_change_detected = 1;
      }

    }

    if(!(continue_chatting == 0))
    {
      if(!((0x00800000U & csp->flags) == 0u))
      {
        return_value_socket_is_still_alive_12=socket_is_still_alive(csp->cfd);
        if(!(return_value_socket_is_still_alive_12 == 0))
        {
          log_error(0x0002, "Client request %d has been pipelined on socket %d and the socket is still alive.", csp->requests_received_total + (unsigned int)1, csp->cfd);
          prepare_csp_for_next_request(csp);
          continue;
        }

      }

      if(!((0x00008000U & csp->flags) == 0u))
      {
        if(!(csp->server_connection.sfd == -1))
          log_error(0x0002, "Waiting for the next client request on socket %d. Keeping the server socket %d to %s open.", csp->cfd, csp->server_connection.sfd, csp->server_connection.host);

        else
          log_error(0x0002, "Waiting for the next client request on socket %d. No server socket to keep open.", csp->cfd);
      }

      if(!((0x00008000U & csp->flags) == 0u))
      {
        return_value_data_is_available_15=data_is_available(csp->cfd, (signed int)csp->config->keep_alive_timeout);
        tmp_if_expr_16 = return_value_data_is_available_15 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_16 = (_Bool)0;
      if(tmp_if_expr_16)
      {
        return_value_socket_is_still_alive_17=socket_is_still_alive(csp->cfd);
        tmp_if_expr_18 = return_value_socket_is_still_alive_17 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_18 = (_Bool)0;
      if(tmp_if_expr_18)
      {
        log_error(0x0002, "Client request %u arrived in time on socket %d.", csp->requests_received_total + (unsigned int)1, csp->cfd);
        prepare_csp_for_next_request(csp);
      }

      else
      {
        if(!((256U & csp->config->feature_flags) == 0u))
        {
          if(!(csp->server_connection.sfd == -1))
          {
            return_value_socket_is_still_alive_14=socket_is_still_alive(csp->server_connection.sfd);
            if(!(return_value_socket_is_still_alive_14 == 0))
            {
              signed long int time_open;
              signed long int return_value_time_13;
              return_value_time_13=time((signed long int *)(void *)0);
              time_open = return_value_time_13 - csp->server_connection.timestamp;
              if(!((signed long int)csp->server_connection.keep_alive_timeout >= time_open + -((signed long int)latency)))
                break;

              remember_connection(&csp->server_connection);
              csp->server_connection.sfd = -1;
              drain_and_close_socket(csp->cfd);
              csp->cfd = -1;
              privoxy_mutex_lock(&connection_reuse_mutex);
              static signed int monitor_thread_running = 0;
              if(monitor_thread_running == 0)
              {
                monitor_thread_running = 1;
                privoxy_mutex_unlock(&connection_reuse_mutex);
                wait_for_alive_connections();
                privoxy_mutex_lock(&connection_reuse_mutex);
                monitor_thread_running = 0;
              }

              privoxy_mutex_unlock(&connection_reuse_mutex);
            }

          }

        }

        break;
      }
    }

    else
      if(!(csp->server_connection.sfd == -1))
      {
        signed int return_value_socket_is_still_alive_19;
        return_value_socket_is_still_alive_19=socket_is_still_alive(csp->server_connection.sfd);
        log_error(0x0002, "Closing server socket %d connected to %s. Keep-alive: %u. Tainted: %u. Socket alive: %u. Timeout: %u. Configuration file change detected: %u", csp->server_connection.sfd, csp->server_connection.host, (unsigned int)0 != (csp->flags & 0x00001000U), (unsigned int)0 != (csp->flags & 0x00040000U), return_value_socket_is_still_alive_19, csp->server_connection.keep_alive_timeout, config_file_change_detected);
      }

  }
  while(!(continue_chatting == 0));
  if(!(csp->server_connection.sfd == -1))
  {
    if(!((256U & csp->config->feature_flags) == 0u))
      forget_connection(csp->server_connection.sfd);

    close_socket(csp->server_connection.sfd);
  }

  mark_connection_closed(&csp->server_connection);
  if(!(csp->cfd == -1))
  {
    signed int return_value_socket_is_still_alive_20;
    return_value_socket_is_still_alive_20=socket_is_still_alive(csp->cfd);
    signed int return_value_data_is_available_21;
    return_value_data_is_available_21=data_is_available(csp->cfd, 0);
    log_error(0x0002, "Closing client socket %d. Keep-alive: %u. Socket alive: %u. Data available: %u. Configuration file change detected: %u. Requests received: %u.", csp->cfd, (unsigned int)0 != (csp->flags & 0x00008000U), return_value_socket_is_still_alive_20, return_value_data_is_available_21, config_file_change_detected, csp->requests_received_total);
    drain_and_close_socket(csp->cfd);
  }

  csp->flags = csp->flags & ~0x01U;
}

// server_adjust_content_encoding
// file parsers.c line 2410
static enum privoxy_err server_adjust_content_encoding(struct client_state *csp, char **header)
{
  if(!((0x08U & csp->flags) == 0u))
  {
    if(!((48u & csp->content_type) == 0u))
    {
      log_error(0x0008, "Crunching: %s", *header);
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

    }

  }

  return (enum privoxy_err)JB_ERR_OK;
}

// server_adjust_content_length
// file parsers.c line 2451
static enum privoxy_err server_adjust_content_length(struct client_state *csp, char **header)
{
  if(!((0x08U & csp->flags) == 0u))
  {
    const unsigned long int header_length = (const unsigned long int)50;
    if(!(*header == ((char *)NULL)))
    {
      free((void *)*header);
      *header = (char *)(void *)0;
    }

    void *return_value_malloc_1;
    return_value_malloc_1=malloc(header_length);
    *header = (char *)return_value_malloc_1;
    if(*header == ((char *)NULL))
      return (enum privoxy_err)JB_ERR_MEMORY;

    create_content_length_header(csp->content_length, *header, header_length);
    log_error(0x0008, "Adjusted Content-Length to %llu", csp->content_length);
  }

  return (enum privoxy_err)JB_ERR_OK;
}

// server_connection
// file parsers.c line 1585
static enum privoxy_err server_connection(struct client_state *csp, char **header)
{
  signed int return_value_strcmpic_1;
  return_value_strcmpic_1=strcmpic(*header, "Connection: keep-alive");
  if(return_value_strcmpic_1 == 0)
  {
    if((0x00040000U & csp->flags) == 0u)
    {
      if(!((128U & csp->config->feature_flags) == 0u))
        csp->flags = csp->flags | 0x00001000U;

      if(!((0x00008000U & csp->flags) == 0u))
        log_error(0x0008, "Keeping the server header '%s' around.", *header);

      else
      {
        char *old_header = *header;
        *header=strdup_or_die("Connection: close");
        log_error(0x0008, "Replaced: '%s' with '%s'", old_header, *header);
        if(!(old_header == ((char *)NULL)))
        {
          free((void *)old_header);
          old_header = (char *)(void *)0;
        }

      }
    }

  }

  csp->flags = csp->flags | 0x00000080U;
  return (enum privoxy_err)JB_ERR_OK;
}

// server_connection_adder
// file parsers.c line 3727
static enum privoxy_err server_connection_adder(struct client_state *csp)
{
  const unsigned int flags = csp->flags;
  const char *response_status_line = csp->headers[0l].first->str;
  signed int return_value_strncmpic_1;
  if(!((0x00000080U & flags) == 0u) && !((0x00000100U & flags) == 0u))
    return (enum privoxy_err)JB_ERR_OK;

  else
    if(!((128U & csp->config->feature_flags) == 0u))
    {
      if(response_status_line == ((const char *)NULL))
        goto __CPROVER_DUMP_L2;

      return_value_strncmpic_1=strncmpic(response_status_line, "HTTP/1.1", (unsigned long int)8);
      if(!(return_value_strncmpic_1 == 0))
        goto __CPROVER_DUMP_L2;

      if(!((0x00040000U & csp->flags) == 0u))
        goto __CPROVER_DUMP_L2;

      log_error(0x0008, "A HTTP/1.1 response without Connection header implies keep-alive.");
      csp->flags = csp->flags | 0x00001000U;
      return (enum privoxy_err)JB_ERR_OK;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      static const char connection_close[18l] = { 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'c', 'l', 'o', 's', 'e', 0 };
      log_error(0x0008, "Adding: %s", (const void *)connection_close);
      enum privoxy_err return_value_enlist_2;
      return_value_enlist_2=enlist(csp->headers, connection_close);
      return return_value_enlist_2;
    }
}

// server_content_disposition
// file parsers.c line 2563
static enum privoxy_err server_content_disposition(struct client_state *csp, char **header)
{
  const char *newval;
  _Bool tmp_if_expr_2;
  signed int return_value_strcmpic_1;
  if((0x01000000UL & csp->action[0l].flags) == 0ul)
    return (enum privoxy_err)JB_ERR_OK;

  else
  {
    newval = csp->action[0l].string[(signed long int)10];
    if(newval == ((const char *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_strcmpic_1=strcmpic(newval, "block");
      tmp_if_expr_2 = 0 == return_value_strcmpic_1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
    {
      log_error(0x0008, "Crunching %s!", *header);
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

      return (enum privoxy_err)JB_ERR_OK;
    }

    else
    {
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

      *header=strdup("Content-Disposition: ");
      string_append(header, newval);
      if(!(*header == ((char *)NULL)))
        log_error(0x0008, "Content-Disposition header crunched and replaced with: %s", *header);

    }
    return (enum privoxy_err)(*header == (char *)(void *)0 ? JB_ERR_MEMORY : JB_ERR_OK);
  }
}

// server_content_encoding
// file parsers.c line 2315
static enum privoxy_err server_content_encoding(struct client_state *csp, char **header)
{
  char *return_value_strstr_5;
  return_value_strstr_5=strstr(*header, "sdch");
  char *return_value_strstr_4;
  char *return_value_strstr_3;
  char *return_value_strstr_2;
  if(!(return_value_strstr_5 == ((char *)NULL)))
  {
    csp->content_type = csp->content_type | 0x0004U;
    signed int return_value_content_filters_enabled_1;
    return_value_content_filters_enabled_1=content_filters_enabled(csp->action);
    if(!(return_value_content_filters_enabled_1 == 0))
      log_error(0x1000, "SDCH-compressed content detected, content filtering disabled. Consider suppressing SDCH offers made by the client.");

  }

  else
  {
    return_value_strstr_4=strstr(*header, "gzip");
    if(!(return_value_strstr_4 == ((char *)NULL)))
      csp->content_type = csp->content_type | 0x0010U;

    else
    {
      return_value_strstr_3=strstr(*header, "deflate");
      if(!(return_value_strstr_3 == ((char *)NULL)))
        csp->content_type = csp->content_type | 0x0020U;

      else
      {
        return_value_strstr_2=strstr(*header, "compress");
        if(!(return_value_strstr_2 == ((char *)NULL)))
          csp->content_type = csp->content_type | 0x0004U;

      }
    }
  }
  return (enum privoxy_err)JB_ERR_OK;
}

// server_content_md5
// file parsers.c line 2533
static enum privoxy_err server_content_md5(struct client_state *csp, char **header)
{
  if(!((0x08U & csp->flags) == 0u))
  {
    log_error(0x0008, "Crunching Content-MD5");
    if(!(*header == ((char *)NULL)))
    {
      free((void *)*header);
      *header = (char *)(void *)0;
    }

  }

  return (enum privoxy_err)JB_ERR_OK;
}

// server_content_type
// file parsers.c line 2141
static enum privoxy_err server_content_type(struct client_state *csp, char **header)
{
  if(!((0x0040U & csp->content_type) == 0u))
  {
    signed int return_value_content_filters_enabled_1;
    return_value_content_filters_enabled_1=content_filters_enabled(csp->action);
    if(!(return_value_content_filters_enabled_1 == 0))
    {
      log_error(0x0008, "Multiple Content-Type headers detected. Removing and ignoring: %s", *header);
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

    }

    return (enum privoxy_err)JB_ERR_OK;
  }

  csp->content_type = csp->content_type | 0x0040U;
  _Bool tmp_if_expr_5;
  char *return_value_strstr_4;
  _Bool tmp_if_expr_7;
  char *return_value_strstr_6;
  _Bool tmp_if_expr_9;
  char *return_value_strstr_8;
  char *return_value_strstr_2;
  if((0x0004U & csp->content_type) == 0u)
  {
    char *return_value_strstr_3;
    return_value_strstr_3=strstr(*header, "text/");
    if(!(return_value_strstr_3 == ((char *)NULL)))
    {
      return_value_strstr_4=strstr(*header, "plain");
      tmp_if_expr_5 = !(return_value_strstr_4 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_strstr_6=strstr(*header, "xml");
      tmp_if_expr_7 = return_value_strstr_6 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_strstr_8=strstr(*header, "script");
      tmp_if_expr_9 = return_value_strstr_8 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_9)
      csp->content_type = csp->content_type | 0x0001U;

    else
    {
      return_value_strstr_2=strstr(*header, "image/gif");
      if(!(return_value_strstr_2 == ((char *)NULL)))
        csp->content_type = csp->content_type | 0x0002U;

    }
  }

  _Bool tmp_if_expr_10;
  if(!((0x00080000UL & csp->action[0l].flags) == 0ul))
  {
    if(!((0x0001U & csp->content_type) == 0u))
      tmp_if_expr_10 = (_Bool)1;

    else
      tmp_if_expr_10 = (csp->action[0l].flags & 0x00400000UL) != 0ul ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_10)
    {
      enum privoxy_err err;
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

      *header=strdup_or_die("Content-Type: ");
      err=string_append(header, csp->action[0l].string[(signed long int)9]);
      if(!((signed int)err == JB_ERR_OK))
      {
        log_error(0x0008, "Insufficient memory to replace Content-Type!");
        return (enum privoxy_err)JB_ERR_MEMORY;
      }

      log_error(0x0008, "Modified: %s!", *header);
    }

    else
      log_error(0x0008, "%s not replaced. It doesn't look like a content type that should be filtered. Enable force-text-mode if you know what you're doing.", *header);
  }

  return (enum privoxy_err)JB_ERR_OK;
}

// server_http
// file parsers.c line 3861
static enum privoxy_err server_http(struct client_state *csp, char **header)
{
  char *reason_phrase = (char *)(void *)0;
  char *new_response_line;
  char *p;
  unsigned long int length;
  unsigned int major_version;
  unsigned int minor_version;
  p=strchr(*header, 32);
  if(!(p == ((char *)NULL)))
  {
    p = p + 1l;
    reason_phrase=strchr(p, 32);
  }

  if(!(reason_phrase == ((char *)NULL)))
    reason_phrase = reason_phrase + 1l;

  else
  {
    log_error(0x2000, "Response line lacks reason phrase: %s", *header);
    reason_phrase = "";
  }
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(*header, "HTTP/%u.%u %d", &major_version, &minor_version, &csp->http[0l].status);
  if(!(return_value_sscanf_1 == 3))
  {
    log_error(0x2000, "Failed to parse the response line: %s", *header);
    return (enum privoxy_err)JB_ERR_PARSE;
  }

  else
  {
    if(csp->http[0l].status == 206)
      csp->content_type = 0x0004U;

    if(!(minor_version == 0u) && !(minor_version == 1u) || !(major_version == 1u))
    {
      log_error(0x2000, "Unsupported HTTP version. Downgrading to 1.1.");
      major_version = (unsigned int)1;
      minor_version = (unsigned int)1;
    }

    if(!((0x00000004UL & csp->action[0l].flags) == 0ul))
    {
      if(minor_version == 1u)
      {
        log_error(0x0008, "Downgrading answer to HTTP/1.0");
        minor_version = (unsigned int)0;
      }

    }

    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(reason_phrase);
    length = sizeof(char [14l]) /*14ul*/  + return_value_strlen_2 + (unsigned long int)1;
    void *return_value_malloc_or_die_3;
    return_value_malloc_or_die_3=malloc_or_die(length);
    new_response_line = (char *)return_value_malloc_or_die_3;
    snprintf(new_response_line, length, "HTTP/%u.%u %d %s", major_version, minor_version, csp->http[0l].status, reason_phrase);
    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(*header, new_response_line);
    if(!(return_value_strcmp_4 == 0))
      log_error(0x0008, "Response line '%s' changed to '%s'", *header, new_response_line);

    if(!(*header == ((char *)NULL)))
    {
      free((void *)*header);
      *header = (char *)(void *)0;
    }

    *header = new_response_line;
    return (enum privoxy_err)JB_ERR_OK;
  }
}

// server_keep_alive
// file parsers.c line 1639
static enum privoxy_err server_keep_alive(struct client_state *csp, char **header)
{
  unsigned int server_keep_alive__1__keep_alive_timeout;
  const char *timeout_position;
  timeout_position=strstr(*header, "timeout=");
  _Bool tmp_if_expr_2;
  signed int return_value_sscanf_1;
  if(timeout_position == ((const char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_sscanf_1=sscanf(timeout_position, "timeout=%u", &server_keep_alive__1__keep_alive_timeout);
    tmp_if_expr_2 = 1 != return_value_sscanf_1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    log_error(0x2000, "Couldn't parse: %s", *header);

  else
  {
    if(!(server_keep_alive__1__keep_alive_timeout >= csp->server_connection.keep_alive_timeout))
    {
      log_error(0x0008, "Reducing keep-alive timeout from %u to %u.", csp->server_connection.keep_alive_timeout, server_keep_alive__1__keep_alive_timeout);
      csp->server_connection.keep_alive_timeout = server_keep_alive__1__keep_alive_timeout;
    }

    else
      log_error(0x0008, "Server keep-alive timeout is %u. Sticking with %u.", server_keep_alive__1__keep_alive_timeout, csp->server_connection.keep_alive_timeout);
    csp->flags = csp->flags | 0x00020000U;
  }
  if(!(*header == ((char *)NULL)))
  {
    free((void *)*header);
    *header = (char *)(void *)0;
  }

  return (enum privoxy_err)JB_ERR_OK;
}

// server_last_modified
// file parsers.c line 2625
static enum privoxy_err server_last_modified(struct client_state *csp, char **header)
{
  const char *newval;
  signed long int last_modified;
  char newheader[50l];
  signed int return_value_strcmpic_6;
  signed int return_value_strcmpic_5;
  _Bool tmp_if_expr_3;
  unsigned long int return_value_strftime_2;
  if((0x02000000UL & csp->action[0l].flags) == 0ul)
    return (enum privoxy_err)JB_ERR_OK;

  else
  {
    newval = csp->action[0l].string[(signed long int)12];
    signed int return_value_strcmpic_7;
    return_value_strcmpic_7=strcmpic(newval, "block");
    if(return_value_strcmpic_7 == 0)
    {
      log_error(0x0008, "Crunching %s!", *header);
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

      return (enum privoxy_err)JB_ERR_OK;
    }

    else
    {
      return_value_strcmpic_6=strcmpic(newval, "reset-to-request-time");
      if(return_value_strcmpic_6 == 0)
      {
        char buf[30l];
        get_http_time(0, buf, sizeof(char [30l]) /*30ul*/ );
        if(!(*header == ((char *)NULL)))
        {
          free((void *)*header);
          *header = (char *)(void *)0;
        }

        *header=strdup("Last-Modified: ");
        string_append(header, buf);
        if(*header == ((char *)NULL))
          log_error(0x0008, "Insufficient memory. Last-Modified header got lost, boohoo.");

        else
          log_error(0x0008, "Reset to present time: %s", *header);
      }

      else
      {
        return_value_strcmpic_5=strcmpic(newval, "randomize");
        if(return_value_strcmpic_5 == 0)
        {
          log_error(0x0008, "Randomizing: %s", *header);
          enum privoxy_err return_value_parse_time_header_4;
          return_value_parse_time_header_4=parse_time_header(*header, &last_modified);
          if(!((signed int)return_value_parse_time_header_4 == JB_ERR_OK))
          {
            log_error(0x0008, "Couldn't parse time in %s (crunching!)", *header);
            if(!(*header == ((char *)NULL)))
            {
              free((void *)*header);
              *header = (char *)(void *)0;
            }

          }

          else
          {
            signed long int now;
            struct tm *timeptr = (struct tm *)(void *)0;
            signed long int rtime;
            struct tm gmt;
            now=time((signed long int *)(void *)0);
            double return_value_difftime_1;
            return_value_difftime_1=difftime(now, last_modified);
            rtime = (signed long int)return_value_difftime_1;
            if(!(rtime == 0l))
            {
              signed long int days;
              signed long int hours;
              signed long int minutes;
              signed long int seconds;
              const signed int negative_delta = (const signed int)(rtime < (signed long int)0);
              if(!(negative_delta == 0))
              {
                rtime = rtime * (signed long int)-1;
                log_error(0x0008, "Server time in the future.");
              }

              rtime=pick_from_range(rtime);
              if(!(negative_delta == 0))
                rtime = rtime * (signed long int)-1;

              last_modified = last_modified + rtime;
              timeptr=gmtime_r(&last_modified, &gmt);
              if(timeptr == ((struct tm *)NULL))
                tmp_if_expr_3 = (_Bool)1;

              else
              {
                return_value_strftime_2=strftime(newheader, sizeof(char [50l]) /*50ul*/ , "%a, %d %b %Y %H:%M:%S GMT", timeptr);
                tmp_if_expr_3 = !(return_value_strftime_2 != 0ul) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_3)
              {
                log_error(0x2000, "Randomizing '%s' failed. Crunching the header without replacement.", *header);
                if(!(*header == ((char *)NULL)))
                {
                  free((void *)*header);
                  *header = (char *)(void *)0;
                }

                return (enum privoxy_err)JB_ERR_OK;
              }

              if(!(*header == ((char *)NULL)))
              {
                free((void *)*header);
                *header = (char *)(void *)0;
              }

              *header=strdup("Last-Modified: ");
              string_append(header, newheader);
              if(*header == ((char *)NULL))
              {
                log_error(0x2000, "Insufficient memory, header crunched without replacement.");
                return (enum privoxy_err)JB_ERR_MEMORY;
              }

              days = rtime / (signed long int)(3600 * 24);
              hours = (rtime / (signed long int)3600) % (signed long int)24;
              minutes = (rtime / (signed long int)60) % (signed long int)60;
              seconds = rtime % (signed long int)60;
              log_error(0x0008, "Randomized:  %s (added %d da%s %d hou%s %d minut%s %d second%s", *header, days, days == (signed long int)1 ? "y" : "ys", hours, hours == (signed long int)1 ? "r" : "rs", minutes, minutes == (signed long int)1 ? "e" : "es", seconds, seconds == (signed long int)1 ? ")" : "s)");
            }

            else
              log_error(0x0008, "Randomized ... or not. No time difference to work with.");
          }
        }

      }
    }
    return (enum privoxy_err)JB_ERR_OK;
  }
}

// server_proxy_connection
// file parsers.c line 1691
static enum privoxy_err server_proxy_connection(struct client_state *csp, char **header)
{
  csp->flags = csp->flags | 0x00080000U;
  return (enum privoxy_err)JB_ERR_OK;
}

// server_proxy_connection_adder
// file parsers.c line 3778
static enum privoxy_err server_proxy_connection_adder(struct client_state *csp)
{
  enum privoxy_err err = (enum privoxy_err)JB_ERR_OK;
  _Bool tmp_if_expr_1;
  if(!((0x00008000U & csp->flags) == 0u))
  {
    if((0x00040000U & csp->flags) == 0u)
    {
      if((0x00080000U & csp->flags) == 0u)
      {
        if(!((0x00002000U & csp->flags) == 0u))
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = (csp->flags & 0x02U) != 0u ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
        {
          static const char proxy_connection_header[29l] = { 'P', 'r', 'o', 'x', 'y', '-', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'k', 'e', 'e', 'p', '-', 'a', 'l', 'i', 'v', 'e', 0 };
          log_error(0x0008, "Adding: %s", (const void *)proxy_connection_header);
          err=enlist(csp->headers, proxy_connection_header);
        }

      }

    }

  }

  return err;
}

// server_response_is_complete
// file jcc.c line 980
static signed int server_response_is_complete(struct client_state *csp, unsigned long long int content_length)
{
  signed int content_length_known = (signed int)!(!((csp->flags & 0x00004000U) != 0u));
  signed int return_value_strcmpic_1;
  return_value_strcmpic_1=strcmpic(csp->http[0l].gpc, "HEAD");
  if(return_value_strcmpic_1 == 0)
  {
    csp->expected_content_length = (unsigned long long int)0;
    content_length_known = 1;
    csp->flags = csp->flags | 0x00002000U;
  }

  _Bool tmp_if_expr_2;
  if(csp->http[0l].status == 204)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = csp->http[0l].status == 304 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    csp->expected_content_length = (unsigned long long int)0;
    content_length_known = 1;
    csp->flags = csp->flags | 0x00002000U;
  }

  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  if(!(content_length_known == 0))
  {
    if(csp->expected_content_length == 0ul)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = csp->expected_content_length <= content_length ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_4 = (_Bool)0;
  return (signed int)tmp_if_expr_4;
}

// server_save_content_length
// file parsers.c line 2490
static enum privoxy_err server_save_content_length(struct client_state *csp, char **header)
{
  unsigned long long int content_length = (unsigned long long int)0;
  const char *header_value;
  /* assertion *(*header+14) == ':' */
  assert((signed int)(*header)[(signed long int)14] == 58);
  header_value = *header + (signed long int)15;
  enum privoxy_err return_value_get_content_length_1;
  return_value_get_content_length_1=get_content_length(header_value, &content_length);
  if(!((signed int)return_value_get_content_length_1 == JB_ERR_OK))
  {
    log_error(0x2000, "Crunching invalid header: %s", *header);
    if(!(*header == ((char *)NULL)))
    {
      free((void *)*header);
      *header = (char *)(void *)0;
    }

  }

  else
  {
    csp->expected_content_length = content_length;
    csp->flags = csp->flags | 0x00002000U;
    csp->flags = csp->flags | 0x00004000U;
  }
  return (enum privoxy_err)JB_ERR_OK;
}

// server_set_cookie
// file parsers.c line 4003
static enum privoxy_err server_set_cookie(struct client_state *csp, char **header)
{
  _Bool tmp_if_expr_7;
  const unsigned short int **return_value___ctype_b_loc_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  _Bool tmp_if_expr_6;
  if(!((0x00002000UL & csp->action[0l].flags) == 0ul))
  {
    log_error(0x0008, "Crunching incoming cookie: %s", *header);
    if(!(*header == ((char *)NULL)))
    {
      free((void *)*header);
      *header = (char *)(void *)0;
    }

  }

  else
  {
    if(!((0x00000800UL & csp->action[0l].flags) == 0ul))
      tmp_if_expr_7 = (_Bool)1;

    else
      tmp_if_expr_7 = (unsigned long int)0 != (csp->action[0l].flags & 0x08000000UL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_7)
    {
      signed long int now;
      signed long int cookie_time;
      signed long int cookie_lifetime = (signed long int)0;
      /* #anon_enum_NO_EXPIRY_DATE_SPECIFIED=0_EXPIRY_DATE_ACCEPTABLE=1_EXPIRY_DATE_UNACCEPTABLE=2 */
enum anonymous_1 { NO_EXPIRY_DATE_SPECIFIED=0, EXPIRY_DATE_ACCEPTABLE=1, EXPIRY_DATE_UNACCEPTABLE=2 };

/* */
      ;
      enum anonymous_1 expiry_date_status = (enum anonymous_1)NO_EXPIRY_DATE_SPECIFIED;
      char *cur_tag = *header + (signed long int)11;
      for( ; !(*cur_tag == 0); cur_tag = cur_tag + 1l)
      {
        return_value___ctype_b_loc_1=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)*cur_tag]) == 0)
          break;

      }
      time(&now);
      if(!((0x08000000UL & csp->action[0l].flags) == 0ul))
      {
        const char *param = csp->action[0l].string[(signed long int)18];
        cookie_lifetime=strtol(param, (char ** restrict )(void *)0, 0);
        if(!(cookie_lifetime >= 0l))
          log_error(0x4000, "Invalid cookie lifetime limit: %s", param);

        cookie_lifetime = cookie_lifetime * (signed long int)60;
      }

      while(!(*cur_tag == 0))
      {
        char *next_tag;
        next_tag=strchr(cur_tag, 59);
        if(!(next_tag == ((char *)NULL)))
        {
          next_tag = next_tag + 1l;
          for( ; !(*next_tag == 0); next_tag = next_tag + 1l)
          {
            return_value___ctype_b_loc_2=__ctype_b_loc();
            if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)*next_tag]) == 0)
              break;

          }
        }

        else
        {
          unsigned long int return_value_strlen_3;
          return_value_strlen_3=strlen(cur_tag);
          next_tag = cur_tag + (signed long int)return_value_strlen_3;
        }
        signed int return_value_strncmpic_5;
        return_value_strncmpic_5=strncmpic(cur_tag, "expires=", (unsigned long int)8);
        if(return_value_strncmpic_5 == 0)
          tmp_if_expr_6 = cur_tag[(signed long int)8] != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_6 = (_Bool)0;
        if(tmp_if_expr_6)
        {
          char *expiration_date = cur_tag + (signed long int)8;
          if((signed int)*expiration_date == 34)
          {
            if(!((signed int)expiration_date[1l] == 0))
              expiration_date = expiration_date + 1l;

          }

          enum privoxy_err return_value_parse_header_time_4;
          return_value_parse_header_time_4=parse_header_time(expiration_date, &cookie_time);
          if(!((signed int)return_value_parse_header_time_4 == JB_ERR_OK))
          {
            log_error(0x2000, "Can't parse '%s', send by %s. Unsupported time format?", cur_tag, csp->http[0l].url);
            string_move(cur_tag, next_tag);
            expiry_date_status = (enum anonymous_1)EXPIRY_DATE_UNACCEPTABLE;
          }

          else
            if(!(cookie_time >= now))
            {
              log_error(0x0008, "Cookie '%s' is already expired and can pass unmodified.", *header);
              cur_tag = next_tag;
              expiry_date_status = (enum anonymous_1)EXPIRY_DATE_ACCEPTABLE;
            }

            else
              if(!(cookie_lifetime == 0l) && !(cookie_time >= cookie_lifetime + now))
              {
                log_error(0x0008, "Cookie '%s' can pass unmodified. Its lifetime is below the limit.", *header);
                cur_tag = next_tag;
                expiry_date_status = (enum anonymous_1)EXPIRY_DATE_ACCEPTABLE;
              }

              else
              {
                string_move(cur_tag, next_tag);
                expiry_date_status = (enum anonymous_1)EXPIRY_DATE_UNACCEPTABLE;
              }
        }

        else
          cur_tag = next_tag;
      }
      if(!((signed int)expiry_date_status == EXPIRY_DATE_ACCEPTABLE))
      {
        /* assertion ((void *)0) != *header */
        assert((char *)(void *)0 != *header);
        if(!(cookie_lifetime == 0l))
        {
          add_cookie_expiry_date(header, cookie_lifetime);
          log_error(0x0008, "Cookie rewritten to: %s", *header);
        }

        else
          if(!((signed int)expiry_date_status == NO_EXPIRY_DATE_SPECIFIED))
            log_error(0x0008, "Cookie rewritten to a temporary one: %s", *header);

      }

    }

  }
  return (enum privoxy_err)JB_ERR_OK;
}

// server_transfer_coding
// file parsers.c line 2247
static enum privoxy_err server_transfer_coding(struct client_state *csp, char **header)
{
  char *return_value_strstr_1;
  return_value_strstr_1=strstr(*header, "gzip");
  _Bool tmp_if_expr_3;
  char *return_value_strstr_2;
  if(!(return_value_strstr_1 == ((char *)NULL)))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strstr_2=strstr(*header, "compress");
    tmp_if_expr_3 = return_value_strstr_2 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  char *return_value_strstr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_strstr_4=strstr(*header, "deflate");
    tmp_if_expr_5 = return_value_strstr_4 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
  {
    log_error(0x1000, "Marking content type for %s as CT_TABOO because of %s.", csp->http[0l].cmd, *header);
    csp->content_type = 0x0004U;
  }

  char *return_value_strstr_6;
  return_value_strstr_6=strstr(*header, "chunked");
  if(!(return_value_strstr_6 == ((char *)NULL)))
  {
    csp->flags = csp->flags | 0x02U;
    if(!((0x08U & csp->flags) == 0u))
    {
      log_error(0x0008, "Removing: %s", *header);
      if(!(*header == ((char *)NULL)))
      {
        free((void *)*header);
        *header = (char *)(void *)0;
      }

    }

  }

  return (enum privoxy_err)JB_ERR_OK;
}

// set_debug_level
// file errlog.c line 246
extern void set_debug_level(signed int debug_level)
{
  debug = debug_level | 0x4000;
}

// set_keep_alive_timeout
// file gateway.c line 578
extern void set_keep_alive_timeout(unsigned int timeout)
{
  keep_alive_timeout = timeout;
}

// set_no_delay_flag
// file jbsockets.c line 138
static void set_no_delay_flag(signed int fd)
{
  signed int mi = 1;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 6, 1, (const void *)&mi, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_setsockopt_1 == 0))
    log_error(0x2000, "Failed to disable TCP coalescence for socket %d", fd);

}

// set_privoxy_variables
// file filters.c line 1754
static void set_privoxy_variables(struct client_state *csp)
{
  signed int i;
  /* tag-#anon#lST[l*{cS8}_cS8_'name'||l*{cS8}_cS8_'value'|] */
struct anonymous_8
{
  // name
  const char *name;
  // value
  const char *value;
};

/* */
  ;
  struct anonymous_8 env[4l] = { { .name="PRIVOXY_URL", .value=csp->http[0l].url },
    { .name="PRIVOXY_PATH", .value=csp->http[0l].path },
    { .name="PRIVOXY_HOST", .value=csp->http[0l].host },
    { .name="PRIVOXY_ORIGIN", .value=csp->ip_addr_str } };
  i = 0;
  for( ; !((unsigned long int)i >= 4ul); i = i + 1)
  {
    signed int return_value_setenv_1;
    return_value_setenv_1=setenv(env[(signed long int)i].name, env[(signed long int)i].value, 1);
    if(!(return_value_setenv_1 == 0))
      log_error(0x2000, "Failed to set %s=%s: %E", env[(signed long int)i].name, env[(signed long int)i].value);

  }
}

// show_defines
// file cgisimple.c line 1535
static enum privoxy_err show_defines(struct map *exports)
{
  enum privoxy_err err = (enum privoxy_err)JB_ERR_OK;
  signed int i = 0;
  for( ; !((unsigned long int)i >= 20ul); i = i + 1)
  {
    /* show_defines::1::tag-feature */
struct feature
{
  // name
  const char name[31l];
  // is_available
  const unsigned char is_available;
};

/* */
    ;
    static struct feature features[20l] = { { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'A', 'C', 'C', 'E', 'P', 'T', '_', 'F', 'I', 'L', 'T', 'E', 'R', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)0 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'A', 'C', 'L', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)1 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'C', 'G', 'I', '_', 'E', 'D', 'I', 'T', '_', 'A', 'C', 'T', 'I', 'O', 'N', 'S', 0, 0, 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)1 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'C', 'O', 'M', 'P', 'R', 'E', 'S', 'S', 'I', 'O', 'N', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)0 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'C', 'O', 'N', 'N', 'E', 'C', 'T', 'I', 'O', 'N', '_', 'K', 'E', 'E', 'P', '_', 'A', 'L', 'I', 'V', 'E', 0, 0 }, .is_available=(const unsigned char)1 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'C', 'O', 'N', 'N', 'E', 'C', 'T', 'I', 'O', 'N', '_', 'S', 'H', 'A', 'R', 'I', 'N', 'G', 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)1 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'F', 'A', 'S', 'T', '_', 'R', 'E', 'D', 'I', 'R', 'E', 'C', 'T', 'S', 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)1 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'F', 'O', 'R', 'C', 'E', '_', 'L', 'O', 'A', 'D', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)1 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'G', 'R', 'A', 'C', 'E', 'F', 'U', 'L', '_', 'T', 'E', 'R', 'M', 'I', 'N', 'A', 'T', 'I', 'O', 'N', 0, 0, 0 }, .is_available=(const unsigned char)0 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'I', 'M', 'A', 'G', 'E', '_', 'B', 'L', 'O', 'C', 'K', 'I', 'N', 'G', 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)1 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'I', 'M', 'A', 'G', 'E', '_', 'D', 'E', 'T', 'E', 'C', 'T', '_', 'M', 'S', 'I', 'E', 0, 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)0 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'I', 'P', 'V', '6', '_', 'S', 'U', 'P', 'P', 'O', 'R', 'T', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)1 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'N', 'O', '_', 'G', 'I', 'F', 'S', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)1 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'P', 'T', 'H', 'R', 'E', 'A', 'D', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)1 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'S', 'T', 'A', 'T', 'I', 'S', 'T', 'I', 'C', 'S', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)1 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'S', 'T', 'R', 'P', 'T', 'I', 'M', 'E', '_', 'S', 'A', 'N', 'I', 'T', 'Y', '_', 'C', 'H', 'E', 'C', 'K', 'S', 0 }, .is_available=(const unsigned char)0 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'T', 'O', 'G', 'G', 'L', 'E', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)1 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'T', 'R', 'U', 'S', 'T', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)1 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'Z', 'L', 'I', 'B', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)1 },
    { .name={ 'F', 'E', 'A', 'T', 'U', 'R', 'E', '_', 'D', 'Y', 'N', 'A', 'M', 'I', 'C', '_', 'P', 'C', 'R', 'E', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .is_available=(const unsigned char)1 } };
    err=map_conditional(exports, features[(signed long int)i].name, (signed int)features[(signed long int)i].is_available);
    if(err != /*enum*/JB_ERR_OK)
      break;

  }
  return err;
}

// show_rcs
// file cgisimple.c line 1732
static char * show_rcs(void)
{
  char *result;
  result=strdup_or_die("");
  char buf[5000l];
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)actions_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)actions_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)cgi_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)cgi_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)cgiedit_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)cgiedit_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)cgisimple_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)cgisimple_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)deanimate_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)deanimate_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)encode_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)encode_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)errlog_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)errlog_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)filters_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)filters_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)gateway_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)gateway_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)jbsockets_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)jbsockets_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)jcc_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)jcc_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)list_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)list_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)loadcfg_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)loadcfg_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)loaders_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)loaders_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)miscutil_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)miscutil_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)parsers_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)parsers_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)pcrs_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)pcrs_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)project_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)ssplit_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)ssplit_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)urlmatch_h_rcs);
  string_append(&result, buf);
  snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , " %s\n", (const void *)urlmatch_rcs);
  string_append(&result, buf);
  return result;
}

// show_version
// file errlog.c line 197
extern void show_version(const char *prog_name)
{
  log_error(0x1000, "Privoxy version 3.0.24");
  if(!(prog_name == ((const char *)NULL)))
    log_error(0x1000, "Program name: %s", prog_name);

}

// sig_handler
// file jcc.c line 342
static void sig_handler(signed int the_signal)
{
  switch(the_signal)
  {
    case 15:

    case 2:
    {
      log_error(0x1000, "exiting by signal %d .. bye", the_signal);
      if(!(pidfile == ((const char *)NULL)))
        unlink(pidfile);

      exit(the_signal);
      break;
    }
    case 1:
    {
      received_hup_signal = 1;
      break;
    }
    default:
      log_error(0x4000, "sig_handler: exiting on unexpected signal %d", the_signal);
  }
}

// simple_domaincmp
// file urlmatch.c line 1033
static signed int simple_domaincmp(char **pv, char **fv, signed int len)
{
  signed int n = 0;
  for( ; !(n >= len); n = n + 1)
  {
    signed int return_value_simplematch_1;
    return_value_simplematch_1=simplematch(pv[(signed long int)n], fv[(signed long int)n]);
    if(!(return_value_simplematch_1 == 0))
      return 1;

  }
  return 0;
}

// simple_read_line
// file loaders.c line 341
extern enum privoxy_err simple_read_line(struct _IO_FILE *fp, char **dest, signed int *newline)
{
  unsigned long int len = (unsigned long int)0;
  unsigned long int buflen = (unsigned long int)5000;
  char *buf;
  char *p;
  signed int ch;
  signed int realnewline = 0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(buflen);
  buf = (char *)return_value_malloc_1;
  char *tmp_post_2;
  if(buf == ((char *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
  {
    p = buf;
    do
    {
      ch=_IO_getc(fp);
      if(ch == -1)
      {
        if(len >= 1ul)
        {
          *p = (char)0;
          *dest = buf;
          return (enum privoxy_err)JB_ERR_OK;
        }

        else
        {
          free((void *)buf);
          *dest = (char *)(void *)0;
          return (enum privoxy_err)JB_ERR_FILE;
        }
      }

      else
        if(ch == 13)
        {
          ch=_IO_getc(fp);
          if(ch == 10)
          {
            if(*newline == 0)
              *newline = 2;

          }

          else
          {
            if(!(ch == -1))
              ungetc(ch, fp);

            if(*newline == 0)
              *newline = 3;

          }
          *p = (char)0;
          *dest = buf;
          if(*newline == 0)
            *newline = realnewline;

          return (enum privoxy_err)JB_ERR_OK;
        }

        else
          if(ch == 10)
          {
            *p = (char)0;
            *dest = buf;
            if(*newline == 0)
              *newline = 1;

            return (enum privoxy_err)JB_ERR_OK;
          }

          else
            if(ch == 0)
            {
              *p = (char)0;
              *dest = buf;
              return (enum privoxy_err)JB_ERR_OK;
            }

      tmp_post_2 = p;
      p = p + 1l;
      *tmp_post_2 = (char)ch;
      len = len + 1ul;
      if(len >= buflen)
      {
        buflen = buflen + (unsigned long int)5000;
        void *return_value_realloc_3;
        return_value_realloc_3=realloc((void *)buf, buflen);
        p = (char *)return_value_realloc_3;
        if(p == ((char *)NULL))
        {
          free((void *)buf);
          return (enum privoxy_err)JB_ERR_MEMORY;
        }

        buf = p;
        p = buf + (signed long int)len;
      }

    }
    while((_Bool)1);
  }
}

// simplematch
// file urlmatch.c line 892
static signed int simplematch(const char *pattern, const char *text)
{
  const unsigned char *pat = (const unsigned char *)pattern;
  const unsigned char *txt = (const unsigned char *)text;
  const unsigned char *fallback = pat;
  signed int wildcard = 0;
  unsigned char lastchar = (unsigned char)97;
  unsigned int i;
  unsigned char charmap[32l];
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  while(!(*txt == 0))
  {
    if((signed int)*pat == 0)
    {
      if(!(wildcard == 0))
        pat = fallback;

      else
        return 1;
    }

    if((signed int)*pat == 42)
    {
      pat = pat + 1l;
      if((signed int)*pat == 0)
        return 0;

      wildcard = 1;
      fallback = pat;
    }

    if((signed int)*pat == 91)
    {
      memset((void *)charmap, 0, sizeof(unsigned char [32l]) /*32ul*/ );
      do
      {
        pat = pat + 1l;
        if((signed int)*pat == 93)
          break;

        if(*pat == 0)
          return 1;

        else
          if((signed int)*pat == 45)
          {
            pat = pat + 1l;
            if((signed int)*pat == 93)
              tmp_if_expr_1 = (_Bool)1;

            else
              tmp_if_expr_1 = (signed int)*pat == 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_1)
              return 1;

            i = (unsigned int)lastchar;
            for( ; (unsigned int)*pat >= i; i = i + 1u)
              charmap[(signed long int)(i / (unsigned int)8)] = charmap[(signed long int)(i / (unsigned int)8)] | (unsigned char)(1 << i % (unsigned int)8);
          }

          else
          {
            charmap[(signed long int)((signed int)*pat / 8)] = charmap[(signed long int)((signed int)*pat / 8)] | (unsigned char)(1 << (signed int)*pat % 8);
            lastchar = *pat;
          }
      }
      while((_Bool)1);
    }

    if(*pat == *txt)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)*pat == 63 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      if((signed int)*pat == 93)
        tmp_if_expr_3 = ((signed int)charmap[(signed long int)((signed int)*txt / 8)] & 1 << (signed int)*txt % 8) != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      pat = pat + 1l;

    else
      if(wildcard == 0)
        return 1;

      else
        if(!(pat == fallback))
        {
          if((signed int)*pat == 93)
            txt = txt + 1l;

          pat = fallback;
          continue;
        }

    txt = txt + 1l;
  }
  if((signed int)*pat == 42)
    pat = pat + 1l;

  return (signed int)*pat;
}

// sockaddr_storage_to_ip
// file filters.c line 103
static signed int sockaddr_storage_to_ip(struct sockaddr_storage *addr, unsigned char **ip, unsigned int *len, unsigned short int **port)
{
  if(addr == ((struct sockaddr_storage *)NULL))
    return -1;

  else
  {
    switch((signed int)addr->ss_family)
    {
      case 2:
      {
        if(!(len == ((unsigned int *)NULL)))
          *len = (unsigned int)4;

        if(!(ip == ((unsigned char **)NULL)))
          *ip = (unsigned char *)&((struct sockaddr_in *)addr)->sin_addr.s_addr;

        if(!(port == ((unsigned short int **)NULL)))
          *port = &((struct sockaddr_in *)addr)->sin_port;

        break;
      }
      case 10:
      {
        if(!(len == ((unsigned int *)NULL)))
          *len = (unsigned int)16;

        if(!(ip == ((unsigned char **)NULL)))
          *ip = ((struct sockaddr_in6 *)addr)->sin6_addr.__in6_u.__u6_addr8;

        if(!(port == ((unsigned short int **)NULL)))
          *port = &((struct sockaddr_in6 *)addr)->sin6_port;

        break;
      }
      default:
        return -1;
    }
    return 0;
  }
}

// socket_is_still_alive
// file jbsockets.h line 62
extern signed int socket_is_still_alive(signed int sfd)
{
  char buf[10l];
  signed int no_data_waiting;
  signed int poll_result;
  struct pollfd poll_fd[1l];
  memset((void *)poll_fd, 0, sizeof(struct pollfd [1l]) /*8ul*/ );
  poll_fd[(signed long int)0].fd = sfd;
  poll_fd[(signed long int)0].events = (signed short int)0x001;
  poll_result=poll(poll_fd, (unsigned long int)1, 0);
  _Bool tmp_if_expr_2;
  signed long int return_value_recv_1;
  if(poll_result == -1)
  {
    log_error(0x0002, "Polling socket %d failed.", sfd);
    return 0;
  }

  else
  {
    no_data_waiting = (signed int)!(((signed int)poll_fd[(signed long int)0].revents & 0x001) != 0);
    if(!(no_data_waiting == 0))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_recv_1=recv(sfd, (void *)buf, (unsigned long int)1, 2);
      tmp_if_expr_2 = (signed long int)1 == return_value_recv_1 ? (_Bool)1 : (_Bool)0;
    }
    return (signed int)tmp_if_expr_2;
  }
}

// socks4_connect
// file gateway.c line 690
static signed int socks4_connect(struct forward_spec *fwd, const char *target_host, signed int target_port, struct client_state *csp)
{
  unsigned long int web_server_addr;
  char buf[5000l];
  struct socks_op *c = (struct socks_op *)buf;
  struct socks_reply *s = (struct socks_reply *)buf;
  unsigned long int n;
  unsigned long int csiz;
  signed int sfd;
  signed int err = 0;
  char *errstr = (char *)(void *)0;
  _Bool tmp_if_expr_1;
  if(fwd->gateway_host == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)*fwd->gateway_host == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    errstr = "NULL gateway host specified.";
    err = 1;
  }

  if(!(fwd->gateway_port >= 1))
  {
    errstr = "invalid gateway port specified.";
    err = 1;
  }

  if(!(err == 0))
  {
    log_error(0x0002, "socks4_connect: %s", errstr);
    csp->error_message=strdup(errstr);
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 22;
    return -1;
  }

  privoxy_strlcpy(&c->userid, socks_userid, sizeof(char [5000l]) /*5000ul*/  - sizeof(struct socks_op) /*12ul*/ );
  csiz = ((sizeof(struct socks_op) /*12ul*/  + sizeof(const char [10l]) /*10ul*/ ) - sizeof(char) /*1ul*/ ) - sizeof(char [3l]) /*3ul*/ ;
  unsigned long int return_value_strlen_4;
  switch((signed int)fwd->type)
  {
    case SOCKS_4:
    {
      web_server_addr=resolve_hostname_to_ip(target_host);
      if(web_server_addr == 4294967295ul)
      {
        errstr = "could not resolve target host";
        log_error(0x0002, "socks4_connect: %s %s", errstr, target_host);
        err = 1;
      }

      else
      {
        unsigned int return_value_htonl_3;
        return_value_htonl_3=htonl((unsigned int)web_server_addr);
        web_server_addr = (unsigned long int)return_value_htonl_3;
      }
      break;
    }
    case SOCKS_4A:
    {
      web_server_addr = (unsigned long int)0x00000001;
      return_value_strlen_4=strlen(target_host);
      n = csiz + return_value_strlen_4 + (unsigned long int)1;
      if(n >= 5001ul)
      {
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        *return_value___errno_location_5 = 22;
        errstr = "buffer cbuf too small.";
        log_error(0x0002, "socks4_connect: %s", errstr);
        err = 1;
      }

      else
      {
        privoxy_strlcpy(buf + (signed long int)csiz, target_host, (sizeof(char [5000l]) /*5000ul*/  - sizeof(struct socks_op) /*12ul*/ ) - csiz);
        unsigned long int return_value_strlen_6;
        return_value_strlen_6=strlen(&c->userid);
        unsigned long int return_value_strlen_7;
        return_value_strlen_7=strlen(buf + (signed long int)csiz);
        /* assertion n == sizeof(struct socks_op) + strlen(&(c->userid)) - sizeof(c->padding) + strlen(buf + csiz) + 1 */
        assert(n == ((sizeof(struct socks_op) /*12ul*/  + return_value_strlen_6) - sizeof(char [3l]) /*3ul*/ ) + return_value_strlen_7 + (unsigned long int)1);
        csiz = n;
      }
      break;
    }
    default:
    {
      log_error(0x4000, "socks4_connect: SOCKS4 impossible internal error - bad SOCKS type.");
      return -1;
    }
  }
  signed int return_value_write_socket_11;
  signed int return_value_data_is_available_10;
  signed int return_value_read_socket_9;
  signed int *return_value___errno_location_12;
  signed int *return_value___errno_location_13;
  signed int *return_value___errno_location_14;
  if(!(err == 0))
  {
    csp->error_message=strdup(errstr);
    return -1;
  }

  else
  {
    c->vn = (unsigned char)4;
    c->cd = (unsigned char)1;
    c->dstport[(signed long int)0] = (unsigned char)(target_port >> 8 & 0xff);
    c->dstport[(signed long int)1] = (unsigned char)(target_port & 0xff);
    c->dstip[(signed long int)0] = (unsigned char)(web_server_addr >> 24 & (unsigned long int)0xff);
    c->dstip[(signed long int)1] = (unsigned char)(web_server_addr >> 16 & (unsigned long int)0xff);
    c->dstip[(signed long int)2] = (unsigned char)(web_server_addr >> 8 & (unsigned long int)0xff);
    c->dstip[(signed long int)3] = (unsigned char)(web_server_addr & (unsigned long int)0xff);
    sfd=connect_to(fwd->gateway_host, fwd->gateway_port, csp);
    if(sfd == -1)
      return -1;

    else
    {
      return_value_write_socket_11=write_socket(sfd, (char *)c, csiz);
      if(!(return_value_write_socket_11 == 0))
      {
        errstr = "SOCKS4 negotiation write failed.";
        log_error(0x0002, "socks4_connect: %s", errstr);
        err = 1;
        close_socket(sfd);
      }

      else
      {
        return_value_data_is_available_10=data_is_available(sfd, csp->config->socket_timeout);
        if(return_value_data_is_available_10 == 0)
        {
          signed int return_value_socket_is_still_alive_8;
          return_value_socket_is_still_alive_8=socket_is_still_alive(sfd);
          if(!(return_value_socket_is_still_alive_8 == 0))
            errstr = "SOCKS4 negotiation timed out";

          else
            errstr = "SOCKS4 negotiation got aborted by the server";
          log_error(0x0002, "socks4_connect: %s", errstr);
          err = 1;
          close_socket(sfd);
        }

        else
        {
          return_value_read_socket_9=read_socket(sfd, buf, (signed int)sizeof(char [5000l]) /*5000ul*/ );
          if(!((unsigned long int)return_value_read_socket_9 == sizeof(struct socks_reply) /*8ul*/ ))
          {
            errstr = "SOCKS4 negotiation read failed.";
            log_error(0x0002, "socks4_connect: %s", errstr);
            err = 1;
            close_socket(sfd);
          }

        }
      }
    }
    if(!(err == 0))
    {
      csp->error_message=strdup(errstr);
      return -1;
    }

    else
    {
      switch((signed int)s->cd)
      {
        case 90:
          return sfd;
        case 91:
        {
          errstr = "SOCKS request rejected or failed.";
          return_value___errno_location_12=__errno_location();
          *return_value___errno_location_12 = 22;
          break;
        }
        case 92:
        {
          errstr = "SOCKS request rejected because SOCKS server cannot connect to identd on the client.";
          return_value___errno_location_13=__errno_location();
          *return_value___errno_location_13 = 13;
          break;
        }
        case 93:
        {
          errstr = "SOCKS request rejected because the client program and identd report different user-ids.";
          return_value___errno_location_14=__errno_location();
          *return_value___errno_location_14 = 13;
          break;
        }
        default:
        {
          signed int *return_value___errno_location_15;
          return_value___errno_location_15=__errno_location();
          *return_value___errno_location_15 = 2;
          snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , "SOCKS request rejected for reason code %d.", s->cd);
          errstr = buf;
        }
      }
      log_error(0x0002, "socks4_connect: %s", errstr);
      csp->error_message=strdup(errstr);
      close_socket(sfd);
      return -1;
    }
  }
}

// socks5_connect
// file gateway.c line 933
static signed int socks5_connect(struct forward_spec *fwd, const char *target_host, signed int target_port, struct client_state *csp)
{
  signed int err = 0;
  char cbuf[300l];
  char sbuf[10l];
  unsigned long int client_pos = (unsigned long int)0;
  signed int server_size = 0;
  unsigned long int hostlen = (unsigned long int)0;
  signed int sfd;
  const char *errstr = (const char *)(void *)0;
  /* assertion fwd->gateway_host */
  assert(fwd->gateway_host != ((char *)NULL));
  _Bool tmp_if_expr_1;
  if(fwd->gateway_host == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)*fwd->gateway_host == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    errstr = "NULL gateway host specified";
    err = 1;
  }

  if(!(fwd->gateway_port >= 1))
  {
    errstr = "invalid gateway port specified";
    err = 1;
  }

  hostlen=strlen(target_host);
  if(hostlen >= 256ul)
  {
    errstr = "target host name is longer than 255 characters";
    err = 1;
  }

  if(!((signed int)fwd->type == SOCKS_5))
  {
    if(!((signed int)fwd->type == SOCKS_5T))
    {
      log_error(0x4000, "SOCKS5 impossible internal error - bad SOCKS type");
      err = 1;
    }

  }

  if(!(err == 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 22;
    /* assertion errstr != ((void *)0) */
    assert(errstr != (const char *)(void *)0);
    log_error(0x0002, "socks5_connect: %s", errstr);
    csp->error_message=strdup(errstr);
    return -1;
  }

  sfd=connect_to(fwd->gateway_host, fwd->gateway_port, csp);
  unsigned long int tmp_post_3;
  unsigned long int tmp_post_4;
  unsigned long int tmp_post_5;
  signed int return_value_read_socket_9;
  unsigned long int tmp_post_11;
  unsigned long int tmp_post_12;
  unsigned long int tmp_post_13;
  unsigned long int tmp_post_14;
  unsigned long int tmp_post_15;
  unsigned long int tmp_post_16;
  unsigned long int tmp_post_17;
  if(sfd == -1)
  {
    errstr = "socks5 server unreachable";
    log_error(0x0002, "socks5_connect: %s", errstr);
    if(!(csp->error_message == ((char *)NULL)))
    {
      free((void *)csp->error_message);
      csp->error_message = (char *)(void *)0;
    }

    csp->error_message=strdup(errstr);
    return -1;
  }

  else
  {
    client_pos = (unsigned long int)0;
    tmp_post_3 = client_pos;
    client_pos = client_pos + 1ul;
    cbuf[(signed long int)tmp_post_3] = (char)5;
    tmp_post_4 = client_pos;
    client_pos = client_pos + 1ul;
    cbuf[(signed long int)tmp_post_4] = (char)1;
    tmp_post_5 = client_pos;
    client_pos = client_pos + 1ul;
    cbuf[(signed long int)tmp_post_5] = (char)0;
    signed int return_value_write_socket_6;
    return_value_write_socket_6=write_socket(sfd, cbuf, client_pos);
    if(!(return_value_write_socket_6 == 0))
    {
      errstr = "SOCKS5 negotiation write failed";
      csp->error_message=strdup(errstr);
      log_error(0x0002, "%s", errstr);
      close_socket(sfd);
      return -1;
    }

    else
    {
      signed int return_value_data_is_available_8;
      return_value_data_is_available_8=data_is_available(sfd, csp->config->socket_timeout);
      if(return_value_data_is_available_8 == 0)
      {
        signed int return_value_socket_is_still_alive_7;
        return_value_socket_is_still_alive_7=socket_is_still_alive(sfd);
        if(!(return_value_socket_is_still_alive_7 == 0))
          errstr = "SOCKS5 negotiation timed out";

        else
          errstr = "SOCKS5 negotiation got aborted by the server";
        err = 1;
      }

      if(err == 0)
      {
        return_value_read_socket_9=read_socket(sfd, sbuf, (signed int)sizeof(char [10l]) /*10ul*/ );
        if(!(return_value_read_socket_9 == 2))
        {
          errstr = "SOCKS5 negotiation read failed";
          err = 1;
        }

      }

      if(err == 0)
      {
        if(!((signed int)sbuf[0l] == 5))
        {
          errstr = "SOCKS5 negotiation protocol version error";
          err = 1;
        }

      }

      if(err == 0)
      {
        if((signed int)sbuf[1l] == -1)
        {
          errstr = "SOCKS5 authentication required";
          err = 1;
        }

      }

      if(err == 0)
      {
        if(!((signed int)sbuf[1l] == 0))
        {
          errstr = "SOCKS5 negotiation protocol error";
          err = 1;
        }

      }

      if(!(err == 0))
      {
        /* assertion errstr != ((void *)0) */
        assert(errstr != (const char *)(void *)0);
        log_error(0x0002, "socks5_connect: %s", errstr);
        csp->error_message=strdup(errstr);
        close_socket(sfd);
        signed int *return_value___errno_location_10;
        return_value___errno_location_10=__errno_location();
        *return_value___errno_location_10 = 22;
        return -1;
      }

      client_pos = (unsigned long int)0;
      tmp_post_11 = client_pos;
      client_pos = client_pos + 1ul;
      cbuf[(signed long int)tmp_post_11] = (char)5;
      tmp_post_12 = client_pos;
      client_pos = client_pos + 1ul;
      cbuf[(signed long int)tmp_post_12] = (char)1;
      tmp_post_13 = client_pos;
      client_pos = client_pos + 1ul;
      cbuf[(signed long int)tmp_post_13] = (char)0;
      tmp_post_14 = client_pos;
      client_pos = client_pos + 1ul;
      cbuf[(signed long int)tmp_post_14] = (char)3;
      tmp_post_15 = client_pos;
      client_pos = client_pos + 1ul;
      cbuf[(signed long int)tmp_post_15] = (char)(hostlen & (unsigned long int)0xffu);
      /* assertion sizeof(cbuf) - client_pos > (size_t)255 */
      assert(sizeof(char [300l]) /*300ul*/  - client_pos > (unsigned long int)255);
      strncpy(cbuf + (signed long int)client_pos, target_host, sizeof(char [300l]) /*300ul*/  - client_pos);
      client_pos = client_pos + (hostlen & (unsigned long int)0xffu);
      tmp_post_16 = client_pos;
      client_pos = client_pos + 1ul;
      cbuf[(signed long int)tmp_post_16] = (char)(target_port >> 8 & 0xff);
      tmp_post_17 = client_pos;
      client_pos = client_pos + 1ul;
      cbuf[(signed long int)tmp_post_17] = (char)(target_port & 0xff);
      signed int return_value_write_socket_19;
      return_value_write_socket_19=write_socket(sfd, cbuf, client_pos);
      if(!(return_value_write_socket_19 == 0))
      {
        errstr = "SOCKS5 negotiation write failed";
        csp->error_message=strdup(errstr);
        log_error(0x0002, "%s", errstr);
        close_socket(sfd);
        signed int *return_value___errno_location_18;
        return_value___errno_location_18=__errno_location();
        *return_value___errno_location_18 = 22;
        return -1;
      }

      if((signed int)fwd->type == SOCKS_5T)
      {
        if(csp->http[0l].ssl == 0)
        {
          if(!((0x00010000U & csp->flags) == 0u))
          {
            char *client_headers;
            client_headers=list_to_text(csp->headers);
            unsigned long int header_length;
            if(client_headers == ((char *)NULL))
              log_error(0x4000, "Out of memory rebuilding client headers");

            list_remove_all(csp->headers);
            header_length=strlen(client_headers);
            log_error(0x0002, "Optimistically sending %d bytes of client headers intended for %s", header_length, csp->http[0l].hostport);
            signed int return_value_write_socket_20;
            return_value_write_socket_20=write_socket(sfd, client_headers, header_length);
            if(!(return_value_write_socket_20 == 0))
            {
              log_error(0x0002, "optimistically writing header to: %s failed: %E", csp->http[0l].hostport);
              if(!(client_headers == ((char *)NULL)))
              {
                free((void *)client_headers);
                client_headers = (char *)(void *)0;
              }

              return -1;
            }

            if(!(client_headers == ((char *)NULL)))
            {
              free((void *)client_headers);
              client_headers = (char *)(void *)0;
            }

            if(!(csp->expected_client_content_length == 0ul))
            {
              unsigned long long int buffered_request_bytes = (unsigned long long int)(csp->client_iob[0l].eod - csp->client_iob[0l].cur);
              log_error(0x0002, "Optimistically sending %d bytes of client body. Expected %d", csp->expected_client_content_length, buffered_request_bytes);
              /* assertion csp->expected_client_content_length == buffered_request_bytes */
              assert(csp->expected_client_content_length == buffered_request_bytes);
              signed int return_value_write_socket_21;
              return_value_write_socket_21=write_socket(sfd, csp->client_iob[0l].cur, buffered_request_bytes);
              if(!(return_value_write_socket_21 == 0))
              {
                log_error(0x0002, "optimistically writing %d bytes of client body to: %s failed: %E", buffered_request_bytes, csp->http[0l].hostport);
                return -1;
              }

              clear_iob(csp->client_iob);
            }

          }

        }

      }

      server_size=read_socket(sfd, sbuf, (signed int)sizeof(char [10l]) /*10ul*/ );
      if(!((unsigned long int)server_size == sizeof(char [10l]) /*10ul*/ ))
        errstr = "SOCKS5 negotiation read failed";

      else
        if(!((signed int)sbuf[0l] == 5))
          errstr = "SOCKS5 negotiation protocol version error";

        else
          if(!((signed int)sbuf[2l] == 0))
            errstr = "SOCKS5 negotiation protocol error";

          else
            if(!((signed int)sbuf[1l] == 0))
              errstr=translate_socks5_error((signed int)sbuf[(signed long int)1]);

            else
              return sfd;
      /* assertion errstr != ((void *)0) */
      assert(errstr != (const char *)(void *)0);
      csp->error_message=strdup(errstr);
      log_error(0x0002, "socks5_connect: %s", errstr);
      close_socket(sfd);
      signed int *return_value___errno_location_22;
      return_value___errno_location_22=__errno_location();
      *return_value___errno_location_22 = 22;
      return -1;
    }
  }
}

// split_line_on_equals
// file cgiedit.c line 1016
static enum privoxy_err split_line_on_equals(const char *line, char **pname, char **pvalue)
{
  const char *name_end;
  const char *value_start;
  unsigned long int name_len;
  /* assertion line */
  assert(line != ((const char *)NULL));
  /* assertion pname */
  assert(pname != ((char **)NULL));
  /* assertion pvalue */
  assert(pvalue != ((char **)NULL));
  /* assertion *line != ' ' */
  assert((signed int)*line != 32);
  /* assertion *line != '\t' */
  assert((signed int)*line != 9);
  *pname = (char *)(void *)0;
  *pvalue = (char *)(void *)0;
  value_start=strchr(line, 61);
  if(value_start == ((const char *)NULL) || value_start == line)
    return (enum privoxy_err)JB_ERR_PARSE;

  else
  {
    name_end = value_start - (signed long int)1;
    for( ; (_Bool)1; name_end = name_end - 1l)
      if(!((signed int)*name_end == 32))
      {
        if(!((signed int)*name_end == 9))
          goto __CPROVER_DUMP_L4;

      }


  __CPROVER_DUMP_L4:
    ;
    name_len = (unsigned long int)(name_end - line) + (unsigned long int)1;
    void *return_value_malloc_or_die_1;
    return_value_malloc_or_die_1=malloc_or_die(name_len + (unsigned long int)1);
    *pname = (char *)return_value_malloc_or_die_1;
    strncpy(*pname, line, name_len);
    (*pname)[(signed long int)name_len] = (char)0;
    value_start = value_start + 1l;
    for( ; (_Bool)1; value_start = value_start + 1l)
      if(!((signed int)*value_start == 32))
      {
        if(!((signed int)*value_start == 9))
          goto __CPROVER_DUMP_L7;

      }


  __CPROVER_DUMP_L7:
    ;
    *pvalue=strdup(value_start);
    if(*pvalue == ((char *)NULL))
    {
      free((void *)*pname);
      *pname = (char *)(void *)0;
      return (enum privoxy_err)JB_ERR_MEMORY;
    }

    else
      return (enum privoxy_err)JB_ERR_OK;
  }
}

// ssplit
// file ssplit.h line 38
extern signed int ssplit(char *str, const char *delim, char **vec, unsigned long int vec_len)
{
  unsigned char is_delim[256l];
  unsigned char char_type;
  signed int vec_count = 0;
  const char *tmp_post_1;
  signed int tmp_post_2;
  char *tmp_post_3;
  signed int tmp_post_4;
  if(str == ((char *)NULL))
    return -1;

  else
  {
    memset((void *)is_delim, 0, sizeof(unsigned char [256l]) /*256ul*/ );
    if(delim == ((const char *)NULL))
      delim = " \t";

    for( ; !(*delim == 0); is_delim[(signed long int)(unsigned int)(unsigned char)*tmp_post_1] = (unsigned char)1)
    {
      tmp_post_1 = delim;
      delim = delim + 1l;
    }
    is_delim[(signed long int)(unsigned int)(unsigned char)0] = (unsigned char)2;
    is_delim[(signed long int)(unsigned int)(unsigned char)10] = (unsigned char)2;
    for( ; (signed int)is_delim[(signed long int)(unsigned int)(unsigned char)*str] == 1; str = str + 1l)
      ;
    if((signed int)is_delim[(signed long int)(unsigned int)(unsigned char)*str] == 0)
    {
      if((unsigned long int)vec_count >= vec_len)
        return -1;

      tmp_post_2 = vec_count;
      vec_count = vec_count + 1;
      vec[(signed long int)tmp_post_2] = str;
    }

    do
    {
      char_type = is_delim[(signed long int)(unsigned int)(unsigned char)*str];
      if((signed int)char_type == 2)
        break;

      if((signed int)char_type == 1)
      {
        tmp_post_3 = str;
        str = str + 1l;
        *tmp_post_3 = (char)0;
        if((signed int)is_delim[(signed long int)(unsigned int)(unsigned char)*str] == 0)
        {
          if((unsigned long int)vec_count >= vec_len)
            return -1;

          tmp_post_4 = vec_count;
          vec_count = vec_count + 1;
          vec[(signed long int)tmp_post_4] = str;
        }

      }

      else
        str = str + 1l;
    }
    while((_Bool)1);
    /* assertion *str == '\0' */
    assert((signed int)*str == 0);
    *str = (char)0;
    return vec_count;
  }
}

// strclean
// file parsers.h line 67
extern signed int strclean(char *string, const char *substring)
{
  signed int hits = 0;
  unsigned long int len;
  char *pos;
  char *p;
  len=strlen(substring);
  char *tmp_post_1;
  do
  {
    pos=strstr(string, substring);
    if(pos == ((char *)NULL))
      break;

    p = pos + (signed long int)len;
    do
    {
      *(p - (signed long int)len) = *p;
      tmp_post_1 = p;
      p = p + 1l;
    }
    while(!((signed int)*tmp_post_1 == 0));
    hits = hits + 1;
  }
  while((_Bool)1);
  return hits;
}

// strcmpic
// file miscutil.h line 58
extern signed int strcmpic(const char *s1, const char *s2)
{
  if(s1 == ((const char *)NULL))
    s1 = "";

  if(s2 == ((const char *)NULL))
    s2 = "";

  signed int return_value_tolower_1;
  signed int return_value_tolower_2;
  while(!(*s1 == 0))
  {
    if(*s2 == 0)
      break;

    if(!(*s1 == *s2))
    {
      return_value_tolower_1=tolower((signed int)(unsigned char)*s1);
      return_value_tolower_2=tolower((signed int)(unsigned char)*s2);
      if(!(return_value_tolower_1 == return_value_tolower_2))
        break;

    }

    s1 = s1 + 1l;
    s2 = s2 + 1l;
  }
  signed int return_value_tolower_3;
  return_value_tolower_3=tolower((signed int)(unsigned char)*s1);
  signed int return_value_tolower_4;
  return_value_tolower_4=tolower((signed int)(unsigned char)*s2);
  return return_value_tolower_3 - return_value_tolower_4;
}

// strdup_or_die
// file miscutil.h line 49
extern char * strdup_or_die(const char *str)
{
  char *new_str;
  new_str=strdup(str);
  if(new_str == ((char *)NULL))
  {
    /* assertion new_str != ((void *)0) */
    assert(new_str != (char *)(void *)0);
    log_error(0x4000, "Out of memory in strdup_or_die().");
    exit(1);
  }

  return new_str;
}

// string_append
// file miscutil.h line 61
extern enum privoxy_err string_append(char **target_string, const char *text_to_append)
{
  unsigned long int old_len;
  char *new_string;
  unsigned long int new_size;
  /* assertion target_string */
  assert(target_string != ((char **)NULL));
  /* assertion text_to_append */
  assert(text_to_append != ((const char *)NULL));
  if(*target_string == ((char *)NULL))
    return (enum privoxy_err)JB_ERR_MEMORY;

  else
    if((signed int)*text_to_append == 0)
      return (enum privoxy_err)JB_ERR_OK;

    else
    {
      old_len=strlen(*target_string);
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(text_to_append);
      new_size = return_value_strlen_1 + old_len + (unsigned long int)1;
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)*target_string, new_size);
      new_string = (char *)return_value_realloc_2;
      if(new_string == ((char *)NULL))
      {
        free((void *)*target_string);
        *target_string = (char *)(void *)0;
        return (enum privoxy_err)JB_ERR_MEMORY;
      }

      else
      {
        privoxy_strlcpy(new_string + (signed long int)old_len, text_to_append, new_size - old_len);
        *target_string = new_string;
        return (enum privoxy_err)JB_ERR_OK;
      }
    }
}

// string_join
// file miscutil.h line 62
extern enum privoxy_err string_join(char **target_string, char *text_to_append)
{
  enum privoxy_err err;
  /* assertion target_string */
  assert(target_string != ((char **)NULL));
  if(text_to_append == ((char *)NULL))
  {
    if(!(*target_string == ((char *)NULL)))
    {
      free((void *)*target_string);
      *target_string = (char *)(void *)0;
    }

    return (enum privoxy_err)JB_ERR_MEMORY;
  }

  else
  {
    err=string_append(target_string, text_to_append);
    if(!(text_to_append == ((char *)NULL)))
    {
      free((void *)text_to_append);
      text_to_append = (char *)(void *)0;
    }

    return err;
  }
}

// string_move
// file miscutil.h line 64
extern void string_move(char *dst, char *src)
{
  /* assertion dst < src */
  assert(dst < src);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(src);
  memmove((void *)dst, (const void *)src, return_value_strlen_1 + (unsigned long int)1);
}

// string_toupper
// file miscutil.h line 63
extern char * string_toupper(const char *string)
{
  char *result;
  char *p;
  const char *q;
  _Bool tmp_if_expr_3;
  unsigned long int return_value_strlen_1;
  void *return_value_zalloc_2;
  if(string == ((const char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strlen_1=strlen(string);
    return_value_zalloc_2=zalloc(return_value_strlen_1 + (unsigned long int)1);
    result = (char *)return_value_zalloc_2;
    tmp_if_expr_3 = result == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  char *tmp_post_4;
  const char *tmp_post_5;
  if(tmp_if_expr_3)
    return (char *)(void *)0;

  else
  {
    q = string;
    p = result;
    while(!((signed int)*q == 0))
    {
      tmp_post_4 = p;
      p = p + 1l;
      tmp_post_5 = q;
      q = q + 1l;
      signed int return_value_toupper_6;
      return_value_toupper_6=toupper((signed int)*tmp_post_5);
      *tmp_post_4 = (char)return_value_toupper_6;
    }
    return result;
  }
}

// stringify
// file cgiedit.c line 367
static char * stringify(const unsigned int number)
{
  char buf[6l];
  snprintf(buf, sizeof(char [6l]) /*6ul*/ , "%u", number);
  char *return_value_strdup_1;
  return_value_strdup_1=strdup(buf);
  return return_value_strdup_1;
}

// strncmpic
// file miscutil.h line 59
extern signed int strncmpic(const char *s1, const char *s2, unsigned long int n)
{
  signed int return_value_tolower_1;
  signed int return_value_tolower_2;
  if(!(n >= 1ul))
    return 0;

  else
  {
    if(s1 == ((const char *)NULL))
      s1 = "";

    if(s2 == ((const char *)NULL))
      s2 = "";

    while(!(*s1 == 0))
    {
      if(*s2 == 0)
        break;

      if(!(*s1 == *s2))
      {
        return_value_tolower_1=tolower((signed int)(unsigned char)*s1);
        return_value_tolower_2=tolower((signed int)(unsigned char)*s2);
        if(!(return_value_tolower_1 == return_value_tolower_2))
          break;

      }

      n = n - 1ul;
      if(!(n >= 1ul))
        break;

      s1 = s1 + 1l;
      s2 = s2 + 1l;
    }
    signed int return_value_tolower_3;
    return_value_tolower_3=tolower((signed int)(unsigned char)*s1);
    signed int return_value_tolower_4;
    return_value_tolower_4=tolower((signed int)(unsigned char)*s2);
    return return_value_tolower_3 - return_value_tolower_4;
  }
}

// sweep
// file loaders.h line 41
extern unsigned int sweep(void)
{
  struct file_list *fl;
  struct file_list *nfl;
  struct client_state *csp;
  struct client_states *last_active;
  struct client_states *client_list;
  signed int i;
  unsigned int active_threads = (unsigned int)0;
  fl = files[0l].next;
  for( ; !(fl == ((struct file_list *)NULL)); fl = fl->next)
    fl->active = 0;
  last_active = clients;
  client_list = clients[0l].next;
  while(!(client_list == ((struct client_states *)NULL)))
  {
    csp = &client_list->csp;
    if(!((0x01U & csp->flags) == 0u))
    {
      csp->config->config_file_list->active = 1;
      i = 0;
      for( ; !(i >= 30); i = i + 1)
        if(!(csp->actions_list[(signed long int)i] == ((struct file_list *)NULL)))
          csp->actions_list[(signed long int)i]->active = 1;

      i = 0;
      for( ; !(i >= 30); i = i + 1)
        if(!(csp->rlist[(signed long int)i] == ((struct file_list *)NULL)))
          csp->rlist[(signed long int)i]->active = 1;

      if(!(csp->tlist == ((struct file_list *)NULL)))
        csp->tlist->active = 1;

      active_threads = active_threads + 1u;
      last_active = client_list;
      client_list = client_list->next;
    }

    else
    {
      last_active->next = client_list->next;
      if(!(csp->ip_addr_str == ((char *)NULL)))
      {
        free((void *)csp->ip_addr_str);
        csp->ip_addr_str = (char *)(void *)0;
      }

      if(!(csp->client_iob[0l].buf == ((char *)NULL)))
      {
        free((void *)csp->client_iob[0l].buf);
        csp->client_iob[0l].buf = (char *)(void *)0;
      }

      if(!(csp->iob[0l].buf == ((char *)NULL)))
      {
        free((void *)csp->iob[0l].buf);
        csp->iob[0l].buf = (char *)(void *)0;
      }

      if(!(csp->error_message == ((char *)NULL)))
      {
        free((void *)csp->error_message);
        csp->error_message = (char *)(void *)0;
      }

      if(!((0x00004000UL & csp->action[0l].flags) == 0ul))
      {
        if(!(csp->fwd == ((struct forward_spec *)NULL)))
          unload_forward_spec(csp->fwd);

      }

      free_http_request(csp->http);
      destroy_list(csp->headers);
      destroy_list(csp->tags);
      free_current_action(csp->action);
      urls_read = urls_read + 1;
      if(!((0x10U & csp->flags) == 0u))
        urls_rejected = urls_rejected + 1;

      if(!(client_list == ((struct client_states *)NULL)))
      {
        free((void *)client_list);
        client_list = (struct client_states *)(void *)0;
      }

      client_list = last_active->next;
    }
  }
  nfl = files;
  fl = files[0l].next;
  _Bool tmp_if_expr_1;
  while(!(fl == ((struct file_list *)NULL)))
  {
    if(fl->active == 0)
      tmp_if_expr_1 = (void (*)(void *))(void *)0 != fl->unloader ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
    {
      nfl->next = fl->next;
      fl->unloader(fl->f);
      if(!(fl->filename == ((char *)NULL)))
      {
        free((void *)fl->filename);
        fl->filename = (char *)(void *)0;
      }

      if(!(fl == ((struct file_list *)NULL)))
      {
        free((void *)fl);
        fl = (struct file_list *)(void *)0;
      }

      fl = nfl->next;
    }

    else
    {
      nfl = fl;
      fl = fl->next;
    }
  }
  return active_threads;
}

// template_fill
// file cgi.c line 1981
extern enum privoxy_err template_fill(char **template_ptr, struct map *exports)
{
  struct map_entry *m;
  struct PCRS_JOB *job;
  char buf[5000l];
  char *tmp_out_buffer;
  char *file_buffer;
  unsigned long int size;
  signed int error;
  const char *flags;
  /* assertion template_ptr */
  assert(template_ptr != ((char **)NULL));
  /* assertion *template_ptr */
  assert(*template_ptr != ((char *)NULL));
  /* assertion exports */
  assert(exports != ((struct map *)NULL));
  file_buffer = *template_ptr;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(file_buffer);
  size = return_value_strlen_1 + (unsigned long int)1;
  m = exports->first;
  for( ; !(m == ((struct map_entry *)NULL)); m = m->next)
  {
    if((signed int)*m->name == 36)
    {
      snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , "%s", m->name + (signed long int)1);
      flags = "sigU";
    }

    else
    {
      flags = "sigTU";
      snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , "@%s@", m->name);
    }
    log_error(0x0800, "Substituting: s/%s/%s/%s", (const void *)buf, m->value, flags);
    job=pcrs_compile(buf, m->value, flags, &error);
    if(job == ((struct PCRS_JOB *)NULL))
    {
      if(error == -100)
      {
        free((void *)file_buffer);
        *template_ptr = (char *)(void *)0;
        return (enum privoxy_err)JB_ERR_MEMORY;
      }

      else
        log_error(0x2000, "Error compiling template fill job %s: %d", m->name, error);
    }

    else
    {
      error=pcrs_execute(job, file_buffer, size, &tmp_out_buffer, &size);
      pcrs_free_job(job);
      if(tmp_out_buffer == ((char *)NULL))
      {
        *template_ptr = (char *)(void *)0;
        return (enum privoxy_err)JB_ERR_MEMORY;
      }

      if(!(error >= 0))
      {
        free((void *)tmp_out_buffer);
        const char *return_value_pcrs_strerror_2;
        return_value_pcrs_strerror_2=pcrs_strerror(error);
        log_error(0x2000, "Failed to execute s/%s/%s/%s. %s", (const void *)buf, m->value, flags, return_value_pcrs_strerror_2);
      }

      else
      {
        free((void *)file_buffer);
        file_buffer = tmp_out_buffer;
      }
    }
  }
  *template_ptr = file_buffer;
  return (enum privoxy_err)JB_ERR_OK;
}

// template_fill_for_cgi
// file cgi.c line 2107
extern enum privoxy_err template_fill_for_cgi(struct client_state *csp, const char *templatename, struct map *exports, struct http_response *rsp)
{
  enum privoxy_err err;
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion templatename */
  assert(templatename != ((const char *)NULL));
  /* assertion exports */
  assert(exports != ((struct map *)NULL));
  /* assertion rsp */
  assert(rsp != ((struct http_response *)NULL));
  err=template_load(csp, &rsp->body, templatename, 0);
  if((signed int)err == JB_ERR_FILE)
  {
    free_map(exports);
    enum privoxy_err return_value_cgi_error_no_template_1;
    return_value_cgi_error_no_template_1=cgi_error_no_template(csp, rsp, templatename);
    return return_value_cgi_error_no_template_1;
  }

  else
    if(!(err == /*enum*/JB_ERR_OK))
    {
      free_map(exports);
      return err;
    }

  err=template_fill(&rsp->body, exports);
  free_map(exports);
  return err;
}

// template_load
// file cgi.c line 1829
extern enum privoxy_err template_load(struct client_state *csp, char **template_ptr, const char *templatename, signed int recursive)
{
  enum privoxy_err err;
  char *templates_dir_path;
  char *full_path;
  char *file_buffer;
  char *included_module;
  const char *p;
  struct _IO_FILE *fp;
  char buf[5000l];
  /* assertion csp */
  assert(csp != ((struct client_state *)NULL));
  /* assertion template_ptr */
  assert(template_ptr != ((char **)NULL));
  /* assertion templatename */
  assert(templatename != ((const char *)NULL));
  *template_ptr = (char *)(void *)0;
  p = templatename;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  for( ; !((signed int)*p == 0); p = p + 1l)
  {
    if(!((signed int)*p >= 97))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)*p > 122 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      if(!((signed int)*p >= 65))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)*p > 90 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        if(!((signed int)*p >= 48))
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = (signed int)*p > 57 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
        {
          if(!((signed int)*p == 45))
          {
            if(!((signed int)*p == 46))
              return (enum privoxy_err)JB_ERR_FILE;

          }

        }

      }

    }

  }
  if(!(csp->config->templdir == ((const char *)NULL)))
    templates_dir_path=strdup(csp->config->templdir);

  else
    templates_dir_path=make_path(csp->config->confdir, "templates");
  char *return_value_fgets_4;
  signed int return_value_strncmp_7;
  if(templates_dir_path == ((char *)NULL))
  {
    log_error(0x2000, "Out of memory while generating template path for %s.", templatename);
    return (enum privoxy_err)JB_ERR_MEMORY;
  }

  else
  {
    full_path=make_path(templates_dir_path, templatename);
    free((void *)templates_dir_path);
    if(full_path == ((char *)NULL))
    {
      log_error(0x2000, "Out of memory while generating full template path for %s.", templatename);
      return (enum privoxy_err)JB_ERR_MEMORY;
    }

    else
    {
      file_buffer=strdup("");
      if(file_buffer == ((char *)NULL))
      {
        log_error(0x2000, "Not enough free memory to buffer %s.", full_path);
        free((void *)full_path);
        return (enum privoxy_err)JB_ERR_MEMORY;
      }

      else
      {
        fp=fopen(full_path, "r");
        if(fp == ((struct _IO_FILE *)NULL))
        {
          log_error(0x2000, "Cannot open template file %s: %E", full_path);
          free((void *)full_path);
          free((void *)file_buffer);
          return (enum privoxy_err)JB_ERR_FILE;
        }

        else
        {
          free((void *)full_path);
          do
          {
            return_value_fgets_4=fgets(buf, (signed int)sizeof(char [5000l]) /*5000ul*/ , fp);
            if(return_value_fgets_4 == ((char *)NULL))
              break;

            if(recursive == 0)
            {
              return_value_strncmp_7=strncmp(buf, "#include ", (unsigned long int)9);
              if(return_value_strncmp_7 == 0)
              {
                char *return_value_chomp_5;
                return_value_chomp_5=chomp(buf + (signed long int)9);
                err=template_load(csp, &included_module, return_value_chomp_5, 1);
                if(!((signed int)err == JB_ERR_OK))
                {
                  free((void *)file_buffer);
                  fclose(fp);
                  return err;
                }

                enum privoxy_err return_value_string_join_6;
                return_value_string_join_6=string_join(&file_buffer, included_module);
                if(!(return_value_string_join_6 == /*enum*/JB_ERR_OK))
                {
                  fclose(fp);
                  return (enum privoxy_err)JB_ERR_MEMORY;
                }

                continue;
              }

            }

            if(!((signed int)buf[0l] == 35))
            {
              enum privoxy_err return_value_string_append_8;
              return_value_string_append_8=string_append(&file_buffer, buf);
              if(!(return_value_string_append_8 == /*enum*/JB_ERR_OK))
              {
                fclose(fp);
                return (enum privoxy_err)JB_ERR_MEMORY;
              }

            }

          }
          while((_Bool)1);
          fclose(fp);
          *template_ptr = file_buffer;
          return (enum privoxy_err)JB_ERR_OK;
        }
      }
    }
  }
}

// translate_socks5_error
// file gateway.c line 886
static const char * translate_socks5_error(signed int socks_error)
{
  switch(socks_error)
  {
    case 1:
      return "SOCKS5 request failed";
    case 2:
      return "SOCKS5 request denied";
    case 3:
      return "SOCKS5 network unreachable";
    case 4:
      return "SOCKS5 destination host unreachable";
    case 5:
      return "SOCKS5 connection refused";
    case 6:
      return "SOCKS5 TTL expired";
    case 7:
      return "SOCKS5 client protocol error";
    case 8:
      return "SOCKS5 domain names unsupported";
    case 0:
      return "everything's peachy";
    default:
      return "SOCKS5 negotiation protocol error";
  }
}

// trust_url
// file filters.c line 754
extern struct http_response * trust_url(struct client_state *csp)
{
  struct http_response *rsp;
  struct map *exports;
  char buf[5000l];
  char *p;
  struct pattern_spec **tl;
  struct pattern_spec *t;
  enum privoxy_err err;
  signed int return_value_is_untrusted_url_1;
  return_value_is_untrusted_url_1=is_untrusted_url(csp);
  char *return_value_html_encode_4;
  _Bool tmp_if_expr_9;
  signed int return_value_strcmpic_8;
  if(return_value_is_untrusted_url_1 == 0)
    return (struct http_response *)(void *)0;

  else
  {
    rsp=alloc_http_response();
    if(rsp == ((struct http_response *)NULL))
    {
      struct http_response *return_value_cgi_error_memory_2;
      return_value_cgi_error_memory_2=cgi_error_memory();
      return return_value_cgi_error_memory_2;
    }

    rsp->status=strdup_or_die("403 Request blocked by Privoxy");
    exports=default_exports(csp, (const char *)(void *)0);
    if(exports == ((struct map *)NULL))
    {
      free_http_response(rsp);
      struct http_response *return_value_cgi_error_memory_3;
      return_value_cgi_error_memory_3=cgi_error_memory();
      return return_value_cgi_error_memory_3;
    }

    err=map(exports, "hostport", 1, csp->http[0l].hostport, 1);
    if(err == /*enum*/JB_ERR_OK)
      err=map(exports, "protocol", 1, csp->http[0l].ssl != 0 ? "https://" : "http://", 1);

    if(err == /*enum*/JB_ERR_OK)
      err=map(exports, "path", 1, csp->http[0l].path, 1);

    p=get_header_value(csp->headers, "Referer:");
    if(!(p == ((char *)NULL)))
    {
      if(err == /*enum*/JB_ERR_OK)
      {
        return_value_html_encode_4=html_encode(p);
        err=map(exports, "referrer", 1, return_value_html_encode_4, 0);
      }

    }

    else
      if(err == /*enum*/JB_ERR_OK)
        err=map(exports, "referrer", 1, "none set", 1);

    if(!(err == /*enum*/JB_ERR_OK))
    {
      free_map(exports);
      free_http_response(rsp);
      struct http_response *return_value_cgi_error_memory_5;
      return_value_cgi_error_memory_5=cgi_error_memory();
      return return_value_cgi_error_memory_5;
    }

    p=strdup_or_die("");
    tl = csp->config->trust_list;
    do
    {
      t = *tl;
      if(t == ((struct pattern_spec *)NULL))
        break;

      snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , "<li>%s</li>\n", t->spec);
      string_append(&p, buf);
      tl = tl + 1l;
    }
    while((_Bool)1);
    err=map(exports, "trusted-referrers", 1, p, 0);
    if(!(err == /*enum*/JB_ERR_OK))
    {
      free_map(exports);
      free_http_response(rsp);
      struct http_response *return_value_cgi_error_memory_6;
      return_value_cgi_error_memory_6=cgi_error_memory();
      return return_value_cgi_error_memory_6;
    }

    if(!(csp->config->trust_info[0l].first == ((struct list_entry *)NULL)))
    {
      struct list_entry *l;
      p=strdup_or_die("");
      l = csp->config->trust_info[0l].first;
      for( ; !(l == ((struct list_entry *)NULL)); l = l->next)
      {
        snprintf(buf, sizeof(char [5000l]) /*5000ul*/ , "<li> <a href=\"%s\">%s</a><br>\n", l->str, l->str);
        string_append(&p, buf);
      }
      err=map(exports, "trust-info", 1, p, 0);
    }

    else
      err=map_block_killer(exports, "have-trust-info");
    if(!(err == /*enum*/JB_ERR_OK))
    {
      free_map(exports);
      free_http_response(rsp);
      struct http_response *return_value_cgi_error_memory_7;
      return_value_cgi_error_memory_7=cgi_error_memory();
      return return_value_cgi_error_memory_7;
    }

    if(!((32U & csp->config->feature_flags) == 0u))
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_strcmpic_8=strcmpic(csp->http[0l].gpc, "connect");
      tmp_if_expr_9 = 0 == return_value_strcmpic_8 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_9)
      err=map_block_killer(exports, "force-support");

    else
      err=map(exports, "force-prefix", 1, "/PRIVOXY-FORCE", 1);
    if(!(err == /*enum*/JB_ERR_OK))
    {
      free_map(exports);
      free_http_response(rsp);
      struct http_response *return_value_cgi_error_memory_10;
      return_value_cgi_error_memory_10=cgi_error_memory();
      return return_value_cgi_error_memory_10;
    }

    err=template_fill_for_cgi(csp, "untrusted", exports, rsp);
    if(!(err == /*enum*/JB_ERR_OK))
    {
      free_http_response(rsp);
      struct http_response *return_value_cgi_error_memory_11;
      return_value_cgi_error_memory_11=cgi_error_memory();
      return return_value_cgi_error_memory_11;
    }

    rsp->crunch_reason = (enum crunch_reason)UNTRUSTED;
    struct http_response *return_value_finish_http_response_12;
    return_value_finish_http_response_12=finish_http_response(csp, rsp);
    return return_value_finish_http_response_12;
  }
}

// unknown_method
// file urlmatch.c line 431
static signed int unknown_method(const char *method)
{
  signed int i = 0;
  for( ; !((unsigned long int)i >= 36ul); i = i + 1)
  {
    signed int return_value_strcmpic_1;
    static const char * const known_http_methods[36l] = { "GET", "HEAD", "POST", "PUT", "DELETE", "OPTIONS", "TRACE", "CONNECT", "PROPFIND", "PROPPATCH", "MOVE", "COPY", "MKCOL", "LOCK", "UNLOCK", "BCOPY", "BMOVE", "BDELETE", "BPROPFIND", "BPROPPATCH", "SUBSCRIBE", "UNSUBSCRIBE", "NOTIFY", "POLL", "VERSION-CONTROL", "REPORT", "CHECKOUT", "CHECKIN", "UNCHECKOUT", "MKWORKSPACE", "UPDATE", "LABEL", "MERGE", "BASELINE-CONTROL", "MKACTIVITY", "PATCH" };
    return_value_strcmpic_1=strcmpic(method, known_http_methods[(signed long int)i]);
    if(return_value_strcmpic_1 == 0)
      return 0;

  }
  return 1;
}

// unload_actions_file
// file actions.c line 994
extern void unload_actions_file(void *file_data)
{
  struct url_actions *next;
  struct url_actions *cur = (struct url_actions *)file_data;
  _Bool tmp_if_expr_1;
  for( ; !(cur == ((struct url_actions *)NULL)); cur = next)
  {
    next = cur->next;
    free_pattern_spec(cur->url);
    if(next == ((struct url_actions *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = next->action != cur->action ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      free_action_spec(cur->action);

    if(!(cur == ((struct url_actions *)NULL)))
    {
      free((void *)cur);
      cur = (struct url_actions *)(void *)0;
    }

  }
}

// unload_configfile
// file loadcfg.c line 192
static void unload_configfile(void *data)
{
  struct configuration_spec *config = (struct configuration_spec *)data;
  struct forward_spec *cur_fwd = config->forward;
  signed int i;
  struct access_control_list *cur_acl = config->acl;
  while(!(cur_acl == ((struct access_control_list *)NULL)))
  {
    struct access_control_list *next_acl = cur_acl->next;
    free((void *)cur_acl);
    cur_acl = next_acl;
  }
  config->acl = (struct access_control_list *)(void *)0;
  while(!(cur_fwd == ((struct forward_spec *)NULL)))
  {
    struct forward_spec *next_fwd = cur_fwd->next;
    free_pattern_spec(cur_fwd->url);
    if(!(cur_fwd->gateway_host == ((char *)NULL)))
    {
      free((void *)cur_fwd->gateway_host);
      cur_fwd->gateway_host = (char *)(void *)0;
    }

    if(!(cur_fwd->forward_host == ((char *)NULL)))
    {
      free((void *)cur_fwd->forward_host);
      cur_fwd->forward_host = (char *)(void *)0;
    }

    free((void *)cur_fwd);
    cur_fwd = next_fwd;
  }
  config->forward = (struct forward_spec *)(void *)0;
  if(!(config->confdir == ((const char *)NULL)))
  {
    free((void *)config->confdir);
    config->confdir = (const char *)(void *)0;
  }

  if(!(config->logdir == ((const char *)NULL)))
  {
    free((void *)config->logdir);
    config->logdir = (const char *)(void *)0;
  }

  if(!(config->templdir == ((const char *)NULL)))
  {
    free((void *)config->templdir);
    config->templdir = (const char *)(void *)0;
  }

  if(!(config->hostname == ((const char *)NULL)))
  {
    free((void *)config->hostname);
    config->hostname = (const char *)(void *)0;
  }

  if(!(config->temporary_directory == ((const char *)NULL)))
  {
    free((void *)config->temporary_directory);
    config->temporary_directory = (const char *)(void *)0;
  }

  i = 0;
  for( ; !(i >= 10); i = i + 1)
    if(!(config->haddr[(signed long int)i] == ((const char *)NULL)))
    {
      free((void *)config->haddr[(signed long int)i]);
      config->haddr[(signed long int)i] = (const char *)(void *)0;
    }

  if(!(config->logfile == ((const char *)NULL)))
  {
    free((void *)config->logfile);
    config->logfile = (const char *)(void *)0;
  }

  i = 0;
  for( ; !(i >= 30); i = i + 1)
  {
    if(!(config->actions_file_short[(signed long int)i] == ((const char *)NULL)))
    {
      free((void *)config->actions_file_short[(signed long int)i]);
      config->actions_file_short[(signed long int)i] = (const char *)(void *)0;
    }

    if(!(config->actions_file[(signed long int)i] == ((const char *)NULL)))
    {
      free((void *)config->actions_file[(signed long int)i]);
      config->actions_file[(signed long int)i] = (const char *)(void *)0;
    }

    if(!(config->re_filterfile_short[(signed long int)i] == ((const char *)NULL)))
    {
      free((void *)config->re_filterfile_short[(signed long int)i]);
      config->re_filterfile_short[(signed long int)i] = (const char *)(void *)0;
    }

    if(!(config->re_filterfile[(signed long int)i] == ((const char *)NULL)))
    {
      free((void *)config->re_filterfile[(signed long int)i]);
      config->re_filterfile[(signed long int)i] = (const char *)(void *)0;
    }

  }
  list_remove_all(config->ordered_client_headers);
  if(!(config->admin_address == ((char *)NULL)))
  {
    free((void *)config->admin_address);
    config->admin_address = (char *)(void *)0;
  }

  if(!(config->proxy_info_url == ((char *)NULL)))
  {
    free((void *)config->proxy_info_url);
    config->proxy_info_url = (char *)(void *)0;
  }

  if(!(config->proxy_args == ((char *)NULL)))
  {
    free((void *)config->proxy_args);
    config->proxy_args = (char *)(void *)0;
  }

  if(!(config->usermanual == ((char *)NULL)))
  {
    free((void *)config->usermanual);
    config->usermanual = (char *)(void *)0;
  }

  if(!(config->trustfile == ((const char *)NULL)))
  {
    free((void *)config->trustfile);
    config->trustfile = (const char *)(void *)0;
  }

  list_remove_all(config->trust_info);
  if(!(config == ((struct configuration_spec *)NULL)))
  {
    free((void *)config);
    config = (struct configuration_spec *)(void *)0;
  }

}

// unload_forward_spec
// file loaders.h line 89
void unload_forward_spec(struct forward_spec *fwd)
{
  free_pattern_spec(fwd->url);
  if(!(fwd->gateway_host == ((char *)NULL)))
  {
    free((void *)fwd->gateway_host);
    fwd->gateway_host = (char *)(void *)0;
  }

  if(!(fwd->forward_host == ((char *)NULL)))
  {
    free((void *)fwd->forward_host);
    fwd->forward_host = (char *)(void *)0;
  }

  free((void *)fwd);
}

// unload_re_filterfile
// file loaders.c line 981
static void unload_re_filterfile(void *f)
{
  struct re_filterfile_spec *a;
  struct re_filterfile_spec *b = (struct re_filterfile_spec *)f;
  for( ; !(b == ((struct re_filterfile_spec *)NULL)); b = a)
  {
    a = b->next;
    destroy_list(b->patterns);
    pcrs_free_joblist(b->joblist);
    if(!(b->name == ((char *)NULL)))
    {
      free((void *)b->name);
      b->name = (char *)(void *)0;
    }

    if(!(b->description == ((char *)NULL)))
    {
      free((void *)b->description);
      b->description = (char *)(void *)0;
    }

    if(!(b == ((struct re_filterfile_spec *)NULL)))
    {
      free((void *)b);
      b = (struct re_filterfile_spec *)(void *)0;
    }

  }
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// unload_trustfile
// file loaders.c line 773
static void unload_trustfile(void *f)
{
  struct block_spec *cur = (struct block_spec *)f;
  struct block_spec *next;
  for( ; !(cur == ((struct block_spec *)NULL)); cur = next)
  {
    next = cur->next;
    free_pattern_spec(cur->url);
    free((void *)cur);
  }
}

// unlock_logfile
// file errlog.c line 112
static inline void unlock_logfile(void)
{
  privoxy_mutex_unlock(&log_mutex);
}

// unlock_loginit
// file errlog.c line 120
static inline void unlock_loginit(void)
{
  privoxy_mutex_unlock(&log_init_mutex);
}

// unmap
// file list.h line 83
extern enum privoxy_err unmap(struct map *the_map, const char *name)
{
  struct map_entry *cur_entry;
  struct map_entry *last_entry;
  /* assertion the_map */
  assert(the_map != ((struct map *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  last_entry = (struct map_entry *)(void *)0;
  cur_entry = the_map->first;
  for( ; !(cur_entry == ((struct map_entry *)NULL)); cur_entry = cur_entry->next)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(name, cur_entry->name);
    if(return_value_strcmp_1 == 0)
    {
      if(cur_entry == the_map->first)
        the_map->first = cur_entry->next;

      else
        last_entry->next = cur_entry->next;
      if(cur_entry == the_map->last)
        the_map->last = last_entry;

      if(!(cur_entry->name == ((const char *)NULL)))
      {
        free((void *)cur_entry->name);
        cur_entry->name = (const char *)(void *)0;
      }

      if(!(cur_entry->value == ((const char *)NULL)))
      {
        free((void *)cur_entry->value);
        cur_entry->value = (const char *)(void *)0;
      }

      if(!(cur_entry == ((struct map_entry *)NULL)))
      {
        free((void *)cur_entry);
        cur_entry = (struct map_entry *)(void *)0;
      }

      if(last_entry == ((struct map_entry *)NULL))
        break;

      cur_entry = last_entry;
    }

    else
      last_entry = cur_entry;
  }
  return (enum privoxy_err)JB_ERR_OK;
}

// update_action_bits_for_tag
// file actions.c line 797
extern signed int update_action_bits_for_tag(struct client_state *csp, const char *tag)
{
  struct file_list *fl;
  struct url_actions *b;
  signed int updated = 0;
  signed int i;
  /* assertion tag */
  assert(tag != ((const char *)NULL));
  signed int return_value_list_contains_item_1;
  return_value_list_contains_item_1=list_contains_item(csp->tags, tag);
  /* assertion list_contains_item(csp->tags, tag) */
  assert(return_value_list_contains_item_1 != 0);
  i = 0;
  _Bool tmp_if_expr_2;
  for( ; !(i >= 30); i = i + 1)
  {
    fl = csp->actions_list[(signed long int)i];
    if(fl == ((struct file_list *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      b = (struct url_actions *)fl->f;
      tmp_if_expr_2 = b == (struct url_actions *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_2)
    {
      b = b->next;
      for( ; !(b == ((struct url_actions *)NULL)); b = b->next)
        if(!((0x00000002UL & (unsigned long int)b->url[0l].flags) == 0ul))
        {
          signed int return_value_pcreposix_regexec_4;
          return_value_pcreposix_regexec_4=pcreposix_regexec(b->url[0l].pattern.tag_regex, tag, (unsigned long int)0, (struct anonymous_4 *)(void *)0, 0);
          if(return_value_pcreposix_regexec_4 == 0)
          {
            enum privoxy_err return_value_merge_current_action_3;
            return_value_merge_current_action_3=merge_current_action(csp->action, b->action);
            if(!(return_value_merge_current_action_3 == /*enum*/JB_ERR_OK))
              log_error(0x2000, "Out of memory while changing action bits");

            updated = 1;
          }

        }

    }

  }
  return updated;
}

// update_server_headers
// file parsers.h line 60
extern enum privoxy_err update_server_headers(struct client_state *csp)
{
  enum privoxy_err err = (enum privoxy_err)JB_ERR_OK;
  signed int return_value_strncmpic_3;
  return_value_strncmpic_3=strncmpic(csp->http[0l].cmd, "HEAD", (unsigned long int)4);
  _Bool tmp_if_expr_1;
  if(!(return_value_strncmpic_3 == 0))
  {
    struct parsers *v;
    struct list_entry *p;
    static struct parsers server_patterns_light[4l] = { { .str="Content-Length:", .len=(const unsigned long int)15, .parser=server_adjust_content_length },
    { .str="Transfer-Encoding:", .len=(const unsigned long int)18, .parser=server_transfer_coding },
    { .str="Content-Encoding:", .len=(const unsigned long int)17, .parser=server_adjust_content_encoding },
    { .str=(const char *)(void *)0, .len=(const unsigned long int)0, .parser=(enum privoxy_err (*)(struct client_state *, char **))(void *)0 } };
    v = server_patterns_light;
    do
    {
      if((signed int)err == JB_ERR_OK)
        tmp_if_expr_1 = v->str != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      p = csp->headers[0l].first;
      for( ; (signed int)err == JB_ERR_OK && !(p == ((struct list_entry *)NULL)); p = p->next)
        if(!(p->str == ((char *)NULL)))
        {
          signed int return_value_strncmpic_2;
          return_value_strncmpic_2=strncmpic(p->str, v->str, v->len);
          if(return_value_strncmpic_2 == 0)
            err=v->parser(csp, (char **)&p->str);

        }

      v = v + 1l;
    }
    while((_Bool)1);
  }

  if((signed int)err == JB_ERR_OK)
  {
    if(!((0x08U & csp->flags) == 0u))
    {
      if(!((0x00008000U & csp->flags) == 0u))
      {
        if((0x00002000U & csp->flags) == 0u)
        {
          char header[50l];
          create_content_length_header(csp->content_length, header, sizeof(char [50l]) /*50ul*/ );
          err=enlist(csp->headers, header);
          if((signed int)err == JB_ERR_OK)
          {
            log_error(0x0008, "Content modified with no Content-Length header set. Created: %s.", (const void *)header);
            csp->flags = csp->flags | 0x00002000U;
          }

        }

      }

    }

  }

  return err;
}

// url_decode
// file encode.h line 41
extern char * url_decode(const char *s)
{
  char *buf;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(return_value_strlen_1 + (unsigned long int)1);
  buf = (char *)return_value_malloc_2;
  char *q = buf;
  char *tmp_post_3;
  signed int return_value_xtoi_6;
  char *tmp_post_4;
  const char *tmp_post_5;
  char *tmp_post_7;
  const char *tmp_post_8;
  if(!(buf == ((char *)NULL)))
  {
    while(!(*s == 0))
      switch((signed int)*s)
      {
        case 43:
        {
          s = s + 1l;
          tmp_post_3 = q;
          q = q + 1l;
          *tmp_post_3 = (char)32;
          break;
        }
        case 37:
        {
          return_value_xtoi_6=xtoi(s + (signed long int)1);
          *q = (char)return_value_xtoi_6;
          if(!((signed int)*q == 0))
          {
            s = s + (signed long int)3;
            q = q + 1l;
          }

          else
          {
            tmp_post_4 = q;
            q = q + 1l;
            tmp_post_5 = s;
            s = s + 1l;
            *tmp_post_4 = *tmp_post_5;
          }
          break;
        }
        default:
        {
          tmp_post_7 = q;
          q = q + 1l;
          tmp_post_8 = s;
          s = s + 1l;
          *tmp_post_7 = *tmp_post_8;
        }
      }
    *q = (char)0;
  }

  return buf;
}

// url_encode
// file encode.h line 40
extern char * url_encode(const char *s)
{
  char *buf;
  unsigned long int buf_size;
  const char *tmp_post_3;
  char *tmp_post_5;
  if(s == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(s);
    buf_size = return_value_strlen_1 * (unsigned long int)3 + (unsigned long int)1;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(buf_size);
    buf = (char *)return_value_malloc_2;
    if(!(buf == ((char *)NULL)))
    {
      char c;
      char *p = buf;
      do
      {
        tmp_post_3 = s;
        s = s + 1l;
        c = *tmp_post_3;
        if((signed int)c == 0)
          break;

        const char *replace_with = url_code_map[(signed long int)(unsigned char)c];
        if(!((signed int)*replace_with == 0))
        {
          const unsigned long int bytes_written = (unsigned long int)(p - buf);
          /* assertion bytes_written < buf_size */
          assert(bytes_written < buf_size);
          unsigned long int return_value_privoxy_strlcpy_4;
          return_value_privoxy_strlcpy_4=privoxy_strlcpy(p, replace_with, buf_size - bytes_written);
          p = p + (signed long int)return_value_privoxy_strlcpy_4;
        }

        else
        {
          tmp_post_5 = p;
          p = p + 1l;
          *tmp_post_5 = c;
        }
      }
      while((_Bool)1);
      *p = (char)0;
      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(buf);
      /* assertion strlen(buf) < buf_size */
      assert(return_value_strlen_6 < buf_size);
    }

    return buf;
  }
}

// url_match
// file urlmatch.h line 53
extern signed int url_match(struct pattern_spec *pattern, struct http_request *http)
{
  _Bool tmp_if_expr_3;
  signed int return_value_host_matches_2;
  _Bool tmp_if_expr_5;
  signed int return_value_path_matches_4;
  if((0x00000001UL & (unsigned long int)pattern->flags) == 0ul)
    return 0;

  else
  {
    signed int return_value_port_matches_1;
    return_value_port_matches_1=port_matches(http->port, pattern->pattern.url_spec.port_list);
    if(!(return_value_port_matches_1 == 0))
    {
      return_value_host_matches_2=host_matches(http, pattern);
      tmp_if_expr_3 = return_value_host_matches_2 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      return_value_path_matches_4=path_matches(http->path, pattern);
      tmp_if_expr_5 = return_value_path_matches_4 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_5 = (_Bool)0;
    return (signed int)tmp_if_expr_5;
  }
}

// url_requires_percent_encoding
// file urlmatch.h line 49
extern signed int url_requires_percent_encoding(const char *url)
{
  const char *tmp_post_1;
  _Bool tmp_if_expr_2;
  while(!((signed int)*url == 0))
  {
    unsigned int i;
    tmp_post_1 = url;
    url = url + 1l;
    i = (const unsigned int)(unsigned char)*tmp_post_1;
    static const char allowed_characters[128l] = { (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)33, (const char)0, (const char)35, (const char)36, (const char)37, (const char)38, (const char)39, (const char)40, (const char)41, (const char)42, (const char)43, (const char)44, (const char)45, (const char)46, (const char)47, (const char)48, (const char)49, (const char)50, (const char)51, (const char)52, (const char)53, (const char)54, (const char)55, (const char)56, (const char)57, (const char)58, (const char)59, (const char)0, (const char)61, (const char)0, (const char)63, (const char)64, (const char)65, (const char)66, (const char)67, (const char)68, (const char)69, (const char)70, (const char)71, (const char)72, (const char)73, (const char)74, (const char)75, (const char)76, (const char)77, (const char)78, (const char)79, (const char)80, (const char)81, (const char)82, (const char)83, (const char)84, (const char)85, (const char)86, (const char)87, (const char)88, (const char)89, (const char)90, (const char)91, (const char)0, (const char)93, (const char)0, (const char)95, (const char)0, (const char)97, (const char)98, (const char)99, (const char)100, (const char)101, (const char)102, (const char)103, (const char)104, (const char)105, (const char)106, (const char)107, (const char)108, (const char)109, (const char)110, (const char)111, (const char)112, (const char)113, (const char)114, (const char)115, (const char)116, (const char)117, (const char)118, (const char)119, (const char)120, (const char)121, (const char)122, (const char)0, (const char)0, (const char)0, (const char)126, (const char)0 };
    if((unsigned long int)i >= sizeof(const char [128l]) /*128ul*/ )
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = 0 == (signed int)allowed_characters[(signed long int)i] ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return 1;

  }
  return 0;
}

// usage
// file jcc.c line 3115
static void usage(const char *myname)
{
  printf("Privoxy version 3.0.24 (http://www.privoxy.org/)\nUsage: %s [--config-test] [--chroot] [--help] [--no-daemon] [--pidfile pidfile] [--pre-chroot-nslookup hostname] [--user user[.group]] [--version] [configfile]\nAborting\n", myname);
  exit(2);
}

// verify_request_length
// file jcc.c line 1118
static void verify_request_length(struct client_state *csp)
{
  unsigned long long int buffered_request_bytes = (unsigned long long int)(csp->client_iob[0l].eod - csp->client_iob[0l].cur);
  if(!(csp->expected_client_content_length == 0ul))
  {
    if(!(buffered_request_bytes == 0ul))
    {
      if(csp->expected_client_content_length >= buffered_request_bytes)
      {
        csp->expected_client_content_length = csp->expected_client_content_length - buffered_request_bytes;
        log_error(0x0002, "Reduced expected bytes to %llu to account for the %llu ones we already got.", csp->expected_client_content_length, buffered_request_bytes);
      }

      else
      {
        /* assertion csp->client_iob->eod > csp->client_iob->cur + csp->expected_client_content_length */
        assert(csp->client_iob[0l].eod > csp->client_iob[0l].cur + (signed long int)csp->expected_client_content_length);
        csp->client_iob[0l].eod = csp->client_iob[0l].cur + (signed long int)csp->expected_client_content_length;
        log_error(0x0002, "Reducing expected bytes to 0. Marking the server socket tainted after throwing %llu bytes away.", buffered_request_bytes - csp->expected_client_content_length);
        csp->expected_client_content_length = (unsigned long long int)0;
        csp->flags = csp->flags | 0x00040000U;
      }
      if(csp->expected_client_content_length == 0ul)
        csp->flags = csp->flags | 0x00010000U;

    }

  }

  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_10;
  if((0x00010000U & csp->flags) == 0u)
  {
    if(!(csp->client_iob[0l].cur >= csp->client_iob[0l].eod))
      tmp_if_expr_10 = (_Bool)1;

    else
      tmp_if_expr_10 = csp->expected_client_content_length != (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_11 = tmp_if_expr_10 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_11 = (_Bool)0;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmpic_2;
  _Bool tmp_if_expr_5;
  signed int return_value_strcmpic_4;
  _Bool tmp_if_expr_7;
  signed int return_value_strcmpic_6;
  _Bool tmp_if_expr_9;
  signed int return_value_strcmpic_8;
  if(tmp_if_expr_11)
  {
    signed int return_value_strcmpic_1;
    return_value_strcmpic_1=strcmpic(csp->http[0l].gpc, "GET");
    if(!(return_value_strcmpic_1 == 0))
    {
      return_value_strcmpic_2=strcmpic(csp->http[0l].gpc, "HEAD");
      tmp_if_expr_3 = return_value_strcmpic_2 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      return_value_strcmpic_4=strcmpic(csp->http[0l].gpc, "TRACE");
      tmp_if_expr_5 = return_value_strcmpic_4 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      return_value_strcmpic_6=strcmpic(csp->http[0l].gpc, "OPTIONS");
      tmp_if_expr_7 = return_value_strcmpic_6 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_7 = (_Bool)0;
    if(tmp_if_expr_7)
    {
      return_value_strcmpic_8=strcmpic(csp->http[0l].gpc, "DELETE");
      tmp_if_expr_9 = return_value_strcmpic_8 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_9 = (_Bool)0;
    if(tmp_if_expr_9)
    {
      csp->flags = csp->flags & ~0x00010000U;
      log_error(0x0002, "There better be a request body.");
    }

    else
    {
      csp->flags = csp->flags | 0x00010000U;
      if((2048U & csp->config->feature_flags) == 0u)
      {
        csp->flags = csp->flags | 0x00040000U;
        log_error(0x0002, "Possible pipeline attempt detected. The connection will not be kept alive and we will only serve the first request.");
        clear_iob(csp->client_iob);
      }

      else
      {
        csp->flags = csp->flags | 0x00800000U;
        /* assertion csp->client_iob->eod >= csp->client_iob->cur */
        assert(csp->client_iob[0l].eod >= csp->client_iob[0l].cur);
        log_error(0x0002, "Complete client request followed by %d bytes of pipelined data received.", (signed int)(csp->client_iob[0l].eod - csp->client_iob[0l].cur));
      }
    }
  }

  else
  {
    csp->flags = csp->flags | 0x00010000U;
    log_error(0x0002, "Complete client request received.");
  }
}

// wait_for_alive_connections
// file jcc.c line 1023
static void wait_for_alive_connections(void)
{
  signed int connections_alive;
  connections_alive=close_unusable_connections();
  while(connections_alive >= 1)
  {
    log_error(0x0002, "Waiting for %d connections to timeout.", connections_alive);
    sleep((unsigned int)60);
    connections_alive=close_unusable_connections();
  }
  log_error(0x0002, "No connections to wait for left.");
}

// write_pid_file
// file miscutil.h line 53
extern void write_pid_file(void)
{
  struct _IO_FILE *fp;
  if(!(pidfile == ((const char *)NULL)))
  {
    fp=fopen(pidfile, "w");
    if(fp == ((struct _IO_FILE *)NULL))
      log_error(0x1000, "can't open pidfile '%s': %E", pidfile);

    else
    {
      signed int return_value_getpid_1;
      return_value_getpid_1=getpid();
      fprintf(fp, "%u\n", (unsigned int)return_value_getpid_1);
      fclose(fp);
    }
    goto __CPROVER_DUMP_L4;
  }


__CPROVER_DUMP_L4:
  ;
}

// write_socket
// file jbsockets.h line 49
extern signed int write_socket(signed int fd, const char *buf, unsigned long int len)
{
  if(len == 0ul)
    return 0;

  else
  {
    log_error(0x0010, "to socket %d: %N", fd, len, buf);
    signed long int return_value_write_1;
    return_value_write_1=write(fd, (const void *)buf, len);
    return (signed int)((unsigned long int)return_value_write_1 != len);
  }
}

// xdtoi
// file encode.c line 276
static signed int xdtoi(const signed int d)
{
  if(d >= 48 && !(d >= 58))
    return d - 48;

  else
    if(d >= 97 && !(d >= 103))
      return (d - 97) + 10;

    else
      if(d >= 65 && !(d >= 71))
        return (d - 65) + 10;

      else
        return -1;
}

// xtoi
// file encode.c line 310
extern signed int xtoi(const char *s)
{
  signed int d1;
  d1=xdtoi((const signed int)*s);
  if(d1 >= 0)
  {
    signed int d2;
    d2=xdtoi((const signed int)s[(signed long int)1]);
    if(d2 >= 0)
      return (d1 << 4) + d2;

  }

  return 0;
}

// zalloc
// file miscutil.h line 48
extern void * zalloc(unsigned long int size)
{
  void *ret;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(size);
  ret = (void *)return_value_malloc_1;
  if(!(ret == NULL))
    memset(ret, 0, size);

  return ret;
}

