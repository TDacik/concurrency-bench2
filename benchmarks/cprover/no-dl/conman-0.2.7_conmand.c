// #anon_enum_TPOLL_ZERO_FDS=1_TPOLL_ZERO_TIMERS=2_TPOLL_ZERO_ALL=3
// file tpoll.h line 48
enum anonymous_1 { TPOLL_ZERO_FDS=1, TPOLL_ZERO_TIMERS=2, TPOLL_ZERO_ALL=3 };

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_7;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_5;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_13;

// tag-#anon#ST[S32'rm_so'||S32'rm_eo'|]
// file /usr/include/regex.h line 452
struct anonymous_2;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_8;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_4;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_3;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_11;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_9;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_6;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_12;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_10;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_0;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-aux_obj
// file server.h line 213
union aux_obj;

// tag-base_obj
// file server.h line 112
struct base_obj;

// tag-bps_tag
// file server-serial.c line 49
struct bps_tag;

// tag-client_args
// file server.h line 278
struct client_args;

// tag-client_obj
// file server.h line 91
struct client_obj;

// tag-console_strs
// file server-conf.c line 170
struct console_strs;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-inevent
// file inevent.c line 131
struct inevent;

// tag-inotify_event
// file /usr/include/x86_64-linux-gnu/sys/inotify.h line 28
struct inotify_event;

// tag-ipmi_connect_state
// file server.h line 195
enum ipmi_connect_state { CONMAN_IPMI_DOWN=0, CONMAN_IPMI_PENDING=1, CONMAN_IPMI_UP=2 };

// tag-ipmi_obj
// file server.h line 201
struct ipmi_obj;

// tag-ipmi_opt
// file server.h line 183
struct ipmi_opt;

// tag-ipmiconsole_ctx
// file /usr/include/ipmiconsole.h line 654
struct ipmiconsole_ctx;

// tag-ipmiconsole_ctx_status
// file /usr/include/ipmiconsole.h line 424
enum ipmiconsole_ctx_status { IPMICONSOLE_CTX_STATUS_ERROR=-1, IPMICONSOLE_CTX_STATUS_NOT_SUBMITTED=0, IPMICONSOLE_CTX_STATUS_SUBMITTED=1, IPMICONSOLE_CTX_STATUS_SOL_ERROR=2, IPMICONSOLE_CTX_STATUS_SOL_ESTABLISHED=3 };

// tag-ipmiconsole_engine_config
// file /usr/include/ipmiconsole.h line 620
struct ipmiconsole_engine_config;

// tag-ipmiconsole_ipmi_config
// file /usr/include/ipmiconsole.h line 510
struct ipmiconsole_ipmi_config;

// tag-ipmiconsole_protocol_config
// file /usr/include/ipmiconsole.h line 583
struct ipmiconsole_protocol_config;

// tag-lexer_state
// file lex.h line 80
struct lexer_state;

// tag-list
// file list.h line 47
struct list;

// tag-listIterator
// file list.h line 52
struct listIterator;

// tag-listNode
// file list.c line 72
struct listNode;

// tag-logfile_obj
// file server.h line 111
struct logfile_obj;

// tag-logfile_opt
// file server.h line 98
struct logfile_opt;

// tag-obj_type
// file server.h line 80
enum obj_type { CONMAN_OBJ_CLIENT=0, CONMAN_OBJ_LOGFILE=1, CONMAN_OBJ_PROCESS=2, CONMAN_OBJ_SERIAL=3, CONMAN_OBJ_TELNET=4, CONMAN_OBJ_UNIXSOCK=5, CONMAN_OBJ_IPMI=6, CONMAN_OBJ_LAST_ENTRY=7 };

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-process_obj
// file server.h line 125
struct process_obj;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-request
// file common.h line 132
struct request;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-serial_obj
// file server.h line 143
struct serial_obj;

// tag-serial_opt
// file server.h line 136
struct serial_opt;

// tag-server_conf
// file server.h line 241
struct server_conf;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/un.h line 29
struct sockaddr_un;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-tag
// file server-conf.c line 124
struct tag;

// tag-telnet_obj
// file server.h line 157
struct telnet_obj;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-tpoll
// file tpoll.h line 38
struct tpoll;

// tag-tpoll_timer
// file tpoll.c line 85
struct tpoll_timer;

// tag-unixsock_obj
// file server.h line 173
struct unixsock_obj;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __h_errno_location
// file /usr/include/netdb.h line 61
extern signed int * __h_errno_location(void);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// _inevent_create
// file inevent.c line 411
static struct inevent * _inevent_create(const char *pathname, void (*cb_fnc)(void *), void *cb_arg);

//

// _inevent_destroy
// file inevent.c line 472
static void _inevent_destroy(struct inevent *inevent_ptr);
// _inevent_fini
// file inevent.c line 390
static void _inevent_fini(void);
// _inevent_init
// file inevent.c line 358
static signed int _inevent_init(void);
// _list_find_by_event
// file inevent.c line 527
static signed int _list_find_by_event(const struct inevent *inevent_ptr, struct inotify_event *event_ptr);
// _list_find_by_path
// file inevent.c line 499
static signed int _list_find_by_path(const struct inevent *inevent_ptr, const char *pathname);
// _list_find_by_wd
// file inevent.c line 513
static signed int _list_find_by_wd(const struct inevent *inevent_ptr, const signed int *wd_ptr);
// _tpoll_diff_timeval
// file tpoll.c line 882
static signed int _tpoll_diff_timeval(struct timeval *tvp1, struct timeval *tvp0);
// _tpoll_get_timeval
// file tpoll.c line 859
static void _tpoll_get_timeval(struct timeval *tvp, signed int ms);
// _tpoll_grow
// file tpoll.c line 812
static signed int _tpoll_grow(struct tpoll *tp, signed int num_fds_req);
// _tpoll_init
// file tpoll.c line 698
static void _tpoll_init(struct tpoll *tp, enum anonymous_1 how);
// _tpoll_signal_recv
// file tpoll.c line 771
static void _tpoll_signal_recv(struct tpoll *tp);
// _tpoll_signal_send
// file tpoll.c line 734
static void _tpoll_signal_send(struct tpoll *tp);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// accept_client
// file server.c line 985
static void accept_client(struct server_conf *conf);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// append_format_string
// file util-str.h line 85
unsigned long int append_format_string(char *dst, unsigned long int size, const char *fmt, ...);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// begin_daemonize
// file server.c line 173
static void begin_daemonize(signed int *fd_ptr, signed int *pgid_ptr);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// cfsetispeed
// file /usr/include/termios.h line 57
extern signed int cfsetispeed(struct termios *, unsigned int);
// cfsetospeed
// file /usr/include/termios.h line 54
extern signed int cfsetospeed(struct termios *, unsigned int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// check_busy_consoles
// file server-sock.c line 621
static signed int check_busy_consoles(struct request *req);
// check_console_state
// file server-sock.c line 882
static void check_console_state(struct base_obj *console, struct base_obj *client);
// check_process_prog
// file server-process.c line 389
static signed int check_process_prog(struct base_obj *process);
// check_too_many_consoles
// file server-sock.c line 579
static signed int check_too_many_consoles(struct request *req);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// compare_objs
// file server-obj.c line 424
signed int compare_objs(struct base_obj *obj1, struct base_obj *obj2);
// complete_ipmi_connect
// file server-ipmi.c line 945
static signed int complete_ipmi_connect(struct base_obj *ipmi);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// connect_ipmi_obj
// file server-ipmi.c line 813
static signed int connect_ipmi_obj(struct base_obj *ipmi);
// connect_process_obj
// file server-process.c line 299
static signed int connect_process_obj(struct base_obj *process);
// connect_telnet_obj
// file server-telnet.c line 175
static signed int connect_telnet_obj(struct base_obj *telnet);
// connect_unixsock_obj
// file server-unixsock.c line 186
static signed int connect_unixsock_obj(struct base_obj *unixsock);
// copy_hostent
// file util-net.c line 200
static signed int copy_hostent(struct hostent *src, char *buf, signed int len);
// coredump_handler
// file server.c line 389
static void coredump_handler(signed int signum);
// create_client_obj
// file server-obj.c line 98
struct base_obj * create_client_obj(struct server_conf *conf, struct request *req);
// create_dirs
// file util-file.h line 129
signed int create_dirs(const char *dir_name);
// create_format_string
// file util-str.h line 45
char * create_format_string(const char *fmt, ...);
// create_ipmi_ctx
// file server-ipmi.c line 898
static signed int create_ipmi_ctx(struct base_obj *ipmi);
// create_ipmi_obj
// file server.h line 369
struct base_obj * create_ipmi_obj(struct server_conf *conf, char *name, struct ipmi_opt *iconf, char *host, char *errbuf, signed int errlen);
// create_listen_socket
// file server.c line 631
static void create_listen_socket(struct server_conf *conf);
// create_logfile_obj
// file server.h line 384
struct base_obj * create_logfile_obj(struct server_conf *conf, char *name, struct base_obj *console, struct logfile_opt *opts, char *errbuf, signed int errlen);
// create_long_time_string
// file util-str.h line 105
char * create_long_time_string(signed long int t);
// create_obj
// file server.h line 396
struct base_obj * create_obj(struct server_conf *conf, char *name, signed int fd, enum obj_type type);
// create_process_obj
// file server.h line 435
struct base_obj * create_process_obj(struct server_conf *conf, char *name, struct list *args, char *errbuf, signed int errlen);
// create_req
// file common.h line 196
struct request * create_req(void);
// create_serial_obj
// file server.h line 450
struct base_obj * create_serial_obj(struct server_conf *conf, char *name, char *dev, struct serial_opt *opts, char *errbuf, signed int errlen);
// create_server_conf
// file server.h line 340
struct server_conf * create_server_conf(void);
// create_short_time_string
// file util-str.h line 114
char * create_short_time_string(signed long int t);
// create_string
// file util-str.h line 38
char * create_string(const char *str);
// create_telnet_obj
// file server.h line 465
struct base_obj * create_telnet_obj(struct server_conf *conf, char *name, char *host, signed int port, char *errbuf, signed int errlen);
// create_time_delta_string
// file util-str.h line 123
char * create_time_delta_string(signed long int t0, signed long int t1);
// create_unixsock_obj
// file server.h line 479
struct base_obj * create_unixsock_obj(struct server_conf *conf, char *name, char *dev, char *errbuf, signed int errlen);
// debug_printf
// file log.c line 64
void debug_printf(signed int level, const char *format, ...);
// destroy_obj
// file server.h line 401
void destroy_obj(struct base_obj *obj);
// destroy_req
// file common.h line 198
void destroy_req(struct request *req);
// destroy_server_conf
// file server.h line 342
void destroy_server_conf(struct server_conf *conf);
// destroy_string
// file util-str.h line 58
void destroy_string(char *str);
// difftime
// file /usr/include/time.h line 195
extern double difftime(signed long int, signed long int);
// disconnect_ipmi_obj
// file server-ipmi.c line 777
static void disconnect_ipmi_obj(struct base_obj *ipmi);
// disconnect_process_obj
// file server-process.c line 256
static signed int disconnect_process_obj(struct base_obj *process);
// disconnect_telnet_obj
// file server-telnet.c line 294
static void disconnect_telnet_obj(struct base_obj *telnet);
// disconnect_unixsock_obj
// file server-unixsock.c line 270
static signed int disconnect_unixsock_obj(struct base_obj *unixsock);
// display_configuration
// file server.c line 482
static void display_configuration(struct server_conf *conf);
// display_server_help
// file server-conf.c line 495
static void display_server_help(char *prog);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// end_daemonize
// file server.c line 274
static void end_daemonize(signed int fd);
// execl
// file /usr/include/unistd.h line 573
extern signed int execl(const char *, const char *, ...);
// execv
// file /usr/include/unistd.h line 563
extern signed int execv(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exit_handler
// file server.c line 382
static void exit_handler(signed int signum);
// fail_ipmi_connect
// file server-ipmi.c line 988
static void fail_ipmi_connect(struct base_obj *ipmi);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// find_obj
// file server-obj.c line 476
signed int find_obj(struct base_obj *obj, struct base_obj *key);
// find_trailing_int_str
// file server-obj.c line 459
static char * find_trailing_int_str(char *str);
// fnmatch
// file /usr/include/fnmatch.h line 56
extern signed int fnmatch(const char *, const char *, signed int);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// format_obj_string
// file server.h line 405
signed int format_obj_string(char *buf, signed int buflen, struct base_obj *obj, const char *fmt);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fscanf
// file /usr/include/stdio.h line 425
extern signed int fscanf(struct _IO_FILE *, const char *, ...);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// get_console_logfile_obj
// file server.h line 389
struct base_obj * get_console_logfile_obj(struct base_obj *console);
// get_dir_name
// file util-file.h line 119
char * get_dir_name(const char *srcpath, char *dstdir, unsigned long int dstdirlen);
// get_file_lock
// file util-file.c line 129
static signed int get_file_lock(signed int fd, signed int cmd, signed int type);
// get_host_by_addr
// file util-net.c line 90
struct hostent * get_host_by_addr(const char *addr, signed int len, signed int type, void *buf, signed int buflen, signed int *h_err);
// get_host_by_name
// file util-net.c line 63
struct hostent * get_host_by_name(const char *name, void *buf, signed int buflen, signed int *h_err);
// get_localtime
// file util-str.h line 140
struct tm * get_localtime(signed long int *tPtr, struct tm *tmPtr);
// get_read_lock
// file util-file.h line 53
signed int get_read_lock(signed int fd);
// get_readw_lock
// file util-file.c line 93
signed int get_readw_lock(signed int fd);
// get_sane_env
// file server.c line 410
static char ** get_sane_env(void);
// get_tty_mode
// file common.h line 200
void get_tty_mode(struct termios *tty, signed int fd);
// get_tty_raw
// file common.h line 204
void get_tty_raw(struct termios *tty, signed int fd);
// get_write_lock
// file util-file.h line 66
signed int get_write_lock(signed int fd);
// get_writew_lock
// file util-file.c line 105
signed int get_writew_lock(signed int fd);
// getcwd
// file /usr/include/unistd.h line 511
extern char * getcwd(char *, unsigned long int);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyaddr
// file /usr/include/netdb.h line 137
extern struct hostent * gethostbyaddr(const void *, unsigned int, signed int);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpeername
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 141
extern signed int getpeername(signed int, struct sockaddr *, unsigned int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 50
extern signed int getrlimit(signed int, struct rlimit *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// host_addr4_to_name
// file util-net.h line 75
char * host_addr4_to_name(struct in_addr *addr, char *dst, signed int dstlen);
// host_name_to_addr4
// file util-net.h line 68
signed int host_name_to_addr4(const char *name, struct in_addr *addr);
// host_name_to_cname
// file util-net.c line 170
char * host_name_to_cname(const char *src, char *dst, signed int dstlen);
// host_strerror
// file util-net.c line 117
const char * host_strerror(signed int h_err);
// hosts_ctl
// file /usr/include/tcpd.h line 121
extern signed int hosts_ctl(char *, char *, char *, char *);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inevent_add
// file inevent.h line 45
signed int inevent_add(const char *pathname, void (*cb_fnc)(void *), void *cb_arg);

//

// inevent_get_fd
// file inevent.h line 49
signed int inevent_get_fd(void);
// inevent_process
// file inevent.h line 51
signed int inevent_process(void);
// inevent_remove
// file inevent.h line 47
signed int inevent_remove(const char *pathname);
// init_ipmi_opts
// file server.h line 364
signed int init_ipmi_opts(struct ipmi_opt *iopts);
// initiate_ipmi_connect
// file server-ipmi.c line 859
static signed int initiate_ipmi_connect(struct base_obj *ipmi);
// inotify_add_watch
// file /usr/include/x86_64-linux-gnu/sys/inotify.h line 91
extern signed int inotify_add_watch(signed int, const char *, unsigned int);
// inotify_init
// file /usr/include/x86_64-linux-gnu/sys/inotify.h line 84
extern signed int inotify_init(void);
// inotify_rm_watch
// file /usr/include/x86_64-linux-gnu/sys/inotify.h line 95
extern signed int inotify_rm_watch(signed int, signed int);
// int_to_bps
// file server-serial.c line 206
static unsigned int int_to_bps(signed int val);
// ipmi_fini
// file server.h line 360
void ipmi_fini(void);
// ipmi_init
// file server.h line 358
void ipmi_init(signed int num_consoles);
// ipmiconsole_cipher_suite_id_is_valid
// file /usr/include/ipmiconsole.h line 999
signed int ipmiconsole_cipher_suite_id_is_valid(signed int);
// ipmiconsole_ctx_create
// file /usr/include/ipmiconsole.h line 834
struct ipmiconsole_ctx * ipmiconsole_ctx_create(const char *, struct ipmiconsole_ipmi_config *, struct ipmiconsole_protocol_config *, struct ipmiconsole_engine_config *);
// ipmiconsole_ctx_destroy
// file /usr/include/ipmiconsole.h line 944
void ipmiconsole_ctx_destroy(struct ipmiconsole_ctx *);
// ipmiconsole_ctx_errnum
// file /usr/include/ipmiconsole.h line 878
signed int ipmiconsole_ctx_errnum(struct ipmiconsole_ctx *);
// ipmiconsole_ctx_fd
// file /usr/include/ipmiconsole.h line 926
signed int ipmiconsole_ctx_fd(struct ipmiconsole_ctx *);
// ipmiconsole_ctx_generate_break
// file /usr/include/ipmiconsole.h line 936
signed int ipmiconsole_ctx_generate_break(struct ipmiconsole_ctx *);
// ipmiconsole_ctx_status
// file /usr/include/ipmiconsole.h line 904
enum ipmiconsole_ctx_status ipmiconsole_ctx_status(struct ipmiconsole_ctx *);
// ipmiconsole_ctx_strerror
// file /usr/include/ipmiconsole.h line 886
char * ipmiconsole_ctx_strerror(signed int);
// ipmiconsole_engine_init
// file /usr/include/ipmiconsole.h line 688
signed int ipmiconsole_engine_init(unsigned int, unsigned int);
// ipmiconsole_engine_submit
// file /usr/include/ipmiconsole.h line 763
signed int ipmiconsole_engine_submit(struct ipmiconsole_ctx *, void (*)(void *), void *);
// ipmiconsole_engine_teardown
// file /usr/include/ipmiconsole.h line 795
void ipmiconsole_engine_teardown(signed int);
// ipmiconsole_k_g_is_valid
// file /usr/include/ipmiconsole.h line 977
signed int ipmiconsole_k_g_is_valid(const unsigned char *, unsigned int);
// ipmiconsole_password_is_valid
// file /usr/include/ipmiconsole.h line 966
signed int ipmiconsole_password_is_valid(const char *);
// ipmiconsole_privilege_level_is_valid
// file /usr/include/ipmiconsole.h line 988
signed int ipmiconsole_privilege_level_is_valid(signed int);
// ipmiconsole_username_is_valid
// file /usr/include/ipmiconsole.h line 955
signed int ipmiconsole_username_is_valid(const char *);
// ipmiconsole_workaround_flags_is_valid
// file /usr/include/ipmiconsole.h line 1011
signed int ipmiconsole_workaround_flags_is_valid(unsigned int);
// is_empty_string
// file util-str.h line 63
signed int is_empty_string(const char *str);
// is_ipmi_dev
// file server.h line 362
signed int is_ipmi_dev(const char *dev, char **host_ref);
// is_ipmi_opt_tag
// file server-ipmi.c line 329
static signed int is_ipmi_opt_tag(const char *str);
// is_process_dev
// file server.h line 432
signed int is_process_dev(const char *dev, const char *cwd, const char *exec_path, char **path_ref);
// is_read_lock_blocked
// file util-file.c line 117
signed int is_read_lock_blocked(signed int fd);
// is_serial_dev
// file server.h line 443
signed int is_serial_dev(const char *dev, const char *cwd, char **path_ref);
// is_telnet_dev
// file server.h line 463
signed int is_telnet_dev(const char *dev, char **host_ref, signed int *port_ref);
// is_unixsock_dev
// file server.h line 477
signed int is_unixsock_dev(const char *dev, const char *cwd, char **path_ref);
// is_write_lock_blocked
// file util-file.h line 92
signed int is_write_lock_blocked(signed int fd);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// kill_console_reset
// file server.c line 1120
static void kill_console_reset(signed int *arg);
// lex_create
// file lex.h line 104
struct lexer_state * lex_create(void *buf, char **toks);
// lex_decode
// file lex.h line 159
char * lex_decode(char *str);
// lex_destroy
// file lex.h line 116
void lex_destroy(struct lexer_state *l);
// lex_encode
// file lex.h line 151
char * lex_encode(char *str);
// lex_line
// file lex.h line 136
signed int lex_line(struct lexer_state *l);
// lex_next
// file lex.h line 121
signed int lex_next(struct lexer_state *l);
// lex_parse_test
// file lex.c line 358
void lex_parse_test(char *buf, char **toks);
// lex_prev
// file lex.h line 131
signed int lex_prev(struct lexer_state *l);
// lex_text
// file lex.h line 141
const char * lex_text(struct lexer_state *l);
// link_objs
// file server.h line 415
void link_objs(struct base_obj *src, struct base_obj *dst);
// list_alloc
// file list.c line 637
static struct list * list_alloc(void);
// list_append
// file list.h line 114
void * list_append(struct list *l, void *x);
// list_count
// file list.h line 104
signed int list_count(struct list *l);
// list_create
// file list.h line 82
struct list * list_create(void (*f)(void *));

//

// list_delete
// file list.h line 248
signed int list_delete(struct listIterator *i);
// list_delete_all
// file list.h line 136
signed int list_delete_all(struct list *l, signed int (*f)(void *, void *), void *key);

//

// list_dequeue
// file list.c line 427
void * list_dequeue(struct list *l);
// list_destroy
// file list.h line 92
void list_destroy(struct list *l);
// list_enqueue
// file list.c line 413
void * list_enqueue(struct list *l, void *x);
// list_find
// file list.h line 232
void * list_find(struct listIterator *i, signed int (*f)(void *, void *), void *key);

//

// list_find_first
// file list.h line 126
void * list_find_first(struct list *l, signed int (*f)(void *, void *), void *key);

//

// list_free
// file list.c line 703
static void list_free(struct list *l);
// list_insert
// file list.h line 224
void * list_insert(struct listIterator *i, void *x);
// list_is_empty
// file list.h line 99
signed int list_is_empty(struct list *l);
// list_iterator_alloc
// file list.c line 681
static struct listIterator * list_iterator_alloc(void);
// list_iterator_create
// file list.h line 198
struct listIterator * list_iterator_create(struct list *l);
// list_iterator_destroy
// file list.h line 210
void list_iterator_destroy(struct listIterator *i);
// list_iterator_free
// file list.c line 723
static void list_iterator_free(struct listIterator *i);
// list_iterator_reset
// file list.h line 204
void list_iterator_reset(struct listIterator *i);
// list_next
// file list.h line 217
void * list_next(struct listIterator *i);
// list_node_alloc
// file list.c line 659
static struct listNode * list_node_alloc(void);
// list_node_create
// file list.c line 570
static void * list_node_create(struct list *l, struct listNode **pp, void *x);
// list_node_destroy
// file list.c line 603
static void * list_node_destroy(struct list *l, struct listNode **pp);
// list_node_free
// file list.c line 713
static void list_node_free(struct listNode *p);
// list_peek
// file list.h line 169
void * list_peek(struct list *l);
// list_pop
// file list.h line 163
void * list_pop(struct list *l);
// list_prepend
// file list.c line 265
void * list_prepend(struct list *l, void *x);
// list_push
// file list.h line 157
void * list_push(struct list *l, void *x);
// list_remove
// file list.h line 241
void * list_remove(struct listIterator *i);
// list_sort
// file list.h line 145
void list_sort(struct list *l, signed int (*f)(void *, void *));

//

// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// log_aux
// file log.c line 183
static void log_aux(signed int errnum, signed int priority, char *msgbuf, signed int msgbuflen, const char *format, void **vargs);
// log_err
// file ./log.h line 86
void log_err(signed int errnum, const char *format, ...);
// log_msg
// file ./log.h line 96
void log_msg(signed int priority, const char *format, ...);
// log_prefix
// file log.c line 266
static const char * log_prefix(signed int priority);
// log_set_err_pipe
// file ./log.h line 77
void log_set_err_pipe(signed int fd);
// log_set_file
// file ./log.h line 61
void log_set_file(struct _IO_FILE *fp, signed int priority, signed int timestamp);
// log_set_syslog
// file ./log.h line 69
void log_set_syslog(char *ident, signed int facility);
// lookup_syslog_facility
// file server-conf.c line 1537
static signed int lookup_syslog_facility(const char *facility);
// lookup_syslog_priority
// file server-conf.c line 1516
static signed int lookup_syslog_priority(const char *priority);
// lookup_token
// file lex.c line 302
static signed int lookup_token(char *str, char **toks, signed int numtoks);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// max_unixsock_dev_strlen
// file server-unixsock.c line 170
static signed int max_unixsock_dev_strlen(void);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mktime
// file /usr/include/time.h line 199
extern signed long int mktime(struct tm *);
// mux_io
// file server.c line 706
static void mux_io(struct server_conf *conf);
// notify_console_objs
// file server.h line 413
void notify_console_objs(struct base_obj *console, char *msg);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// open_daemon_logfile
// file server.c line 858
static void open_daemon_logfile(struct server_conf *conf);
// open_ipmi_obj
// file server.h line 372
signed int open_ipmi_obj(struct base_obj *ipmi);
// open_logfile_obj
// file server.h line 387
signed int open_logfile_obj(struct base_obj *logfile);
// open_objs
// file server.c line 671
static void open_objs(struct server_conf *conf);
// open_process_obj
// file server.h line 438
signed int open_process_obj(struct base_obj *process);
// open_serial_obj
// file server.h line 453
signed int open_serial_obj(struct base_obj *serial);
// open_telnet_obj
// file server.h line 468
signed int open_telnet_obj(struct base_obj *telnet);
// open_unixsock_obj
// file server.h line 482
signed int open_unixsock_obj(struct base_obj *unixsock);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// opt2str
// file server-telnet.c line 566
static char * opt2str(signed int opt, char *buf, signed int buflen);
// parse_cmd_opts
// file server-sock.c line 374
static void parse_cmd_opts(struct lexer_state *l, struct request *req);
// parse_console_directive
// file server-conf.c line 592
static void parse_console_directive(struct server_conf *conf, struct lexer_state *l);
// parse_global_directive
// file server-conf.c line 937
static void parse_global_directive(struct server_conf *conf, struct lexer_state *l);
// parse_greeting
// file server-sock.c line 279
static void parse_greeting(struct lexer_state *l, struct request *req);
// parse_ipmi_opts
// file server.h line 366
signed int parse_ipmi_opts(struct ipmi_opt *iopts, const char *str, char *errbuf, signed int errlen);
// parse_ipmi_opts_v1
// file server-ipmi.c line 222
static signed int parse_ipmi_opts_v1(struct ipmi_opt *iopts, char *str, char *errbuf, signed int errlen);
// parse_key
// file server-ipmi.c line 633
static signed int parse_key(char *dst, const char *src, unsigned long int dstlen);
// parse_logfile_opts
// file server.h line 381
signed int parse_logfile_opts(struct logfile_opt *opts, const char *str, char *errbuf, signed int errlen);
// parse_serial_opts
// file server.h line 445
signed int parse_serial_opts(struct serial_opt *opts, const char *str, char *errbuf, signed int errlen);
// parse_server_directive
// file server-conf.c line 1062
static void parse_server_directive(struct server_conf *conf, struct lexer_state *l);
// parse_string
// file util-str.h line 70
signed int parse_string(char *src, char **dst_p, char **ptr_p, char *quote_p);
// perform_connect_cmd
// file server-sock.c line 834
static signed int perform_connect_cmd(struct request *req, struct server_conf *conf);
// perform_console_writer_linkage
// file server-esc.c line 220
static void perform_console_writer_linkage(struct base_obj *client);
// perform_del_char_seq
// file server-esc.c line 194
static void perform_del_char_seq(struct base_obj *client);
// perform_log_replay
// file server-esc.c line 258
static void perform_log_replay(struct base_obj *client);
// perform_monitor_cmd
// file server-sock.c line 807
static signed int perform_monitor_cmd(struct request *req, struct server_conf *conf);
// perform_query_cmd
// file server-sock.c line 785
static signed int perform_query_cmd(struct request *req);
// perform_quiet_toggle
// file server-esc.c line 366
static void perform_quiet_toggle(struct base_obj *client);
// perform_reset
// file server-esc.c line 396
static void perform_reset(struct base_obj *client);
// perform_serial_break
// file server-esc.c line 132
static void perform_serial_break(struct base_obj *client);
// perform_suspend
// file server-esc.c line 437
static void perform_suspend(struct base_obj *client);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// posix_signal
// file util.h line 49
void (*posix_signal(signed int signum, void (*f)(signed int)))(signed int);

//

// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_client
// file server.h line 458
void process_client(struct client_args *args);
// process_client_escapes
// file server-esc.c line 55
signed int process_client_escapes(struct base_obj *client, void *src, signed int len);
// process_cmdline
// file server.h line 344
void process_cmdline(struct server_conf *conf, signed int argc, char **argv);
// process_config
// file server.h line 346
void process_config(struct server_conf *conf);
// process_console
// file server-conf.c line 761
static signed int process_console(struct server_conf *conf, struct console_strs *con_p, char *errbuf, signed int errbuflen);
// process_ipmi_opt
// file server-ipmi.c line 275
static signed int process_ipmi_opt(struct ipmi_opt *iopts, const char *str, char *errbuf, signed int errlen);
// process_ipmi_opt_cipher
// file server-ipmi.c line 510
static signed int process_ipmi_opt_cipher(struct ipmi_opt *iopts, const char *str, char *errbuf, signed int errlen);
// process_ipmi_opt_k_g
// file server-ipmi.c line 420
static signed int process_ipmi_opt_k_g(struct ipmi_opt *iopts, const char *str, char *errbuf, signed int errlen);
// process_ipmi_opt_password
// file server-ipmi.c line 382
static signed int process_ipmi_opt_password(struct ipmi_opt *iopts, const char *str, char *errbuf, signed int errlen);
// process_ipmi_opt_privilege
// file server-ipmi.c line 460
static signed int process_ipmi_opt_privilege(struct ipmi_opt *iopts, const char *str, char *errbuf, signed int errlen);
// process_ipmi_opt_username
// file server-ipmi.c line 344
static signed int process_ipmi_opt_username(struct ipmi_opt *iopts, const char *str, char *errbuf, signed int errlen);
// process_ipmi_opt_workaround
// file server-ipmi.c line 551
static signed int process_ipmi_opt_workaround(struct ipmi_opt *iopts, const char *str, char *errbuf, signed int errlen);
// process_telnet_cmd
// file server-telnet.c line 501
static signed int process_telnet_cmd(struct base_obj *telnet, signed int cmd, signed int opt);
// process_telnet_escapes
// file server.h line 470
signed int process_telnet_escapes(struct base_obj *telnet, void *src, signed int len);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous *, const union anonymous_0 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// query_consoles
// file server-sock.c line 418
static signed int query_consoles(struct server_conf *conf, struct request *req);
// query_consoles_via_globbing
// file server-sock.c line 460
static signed int query_consoles_via_globbing(struct server_conf *conf, struct request *req, struct list *matches);
// query_consoles_via_regex
// file server-sock.c line 500
static signed int query_consoles_via_regex(struct server_conf *conf, struct request *req, struct list *matches);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_from_obj
// file server.h line 423
signed int read_from_obj(struct base_obj *obj, struct tpoll *tp);
// read_line
// file util-file.h line 111
signed long int read_line(signed int fd, void *buf, unsigned long int maxlen);
// read_n
// file util-file.h line 99
signed long int read_n(signed int fd, void *buf, unsigned long int n);
// read_pidfile
// file server-conf.c line 1424
static signed int read_pidfile(const char *pidfile);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv_greeting
// file server-sock.c line 220
static signed int recv_greeting(struct request *req);
// recv_req
// file server-sock.c line 318
static signed int recv_req(struct request *req);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regerror
// file /usr/include/regex.h line 571
extern unsigned long int regerror(signed int, const struct re_pattern_buffer *, char *, unsigned long int);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous_2 *, signed int);
// regfree
// file /usr/include/regex.h line 574
extern void regfree(struct re_pattern_buffer *);
// release_lock
// file util-file.c line 111
signed int release_lock(signed int fd);
// reopen_logfiles
// file server.c line 962
static void reopen_logfiles(struct server_conf *conf);
// reopen_obj
// file server.h line 403
void reopen_obj(struct base_obj *obj);
// replace_string
// file util-str.h line 52
signed int replace_string(char **dst, const char *src);
// reset_console
// file server.c line 1050
static void reset_console(struct base_obj *console, const char *cmd);
// reset_ipmi_delay
// file server-ipmi.c line 1029
static void reset_ipmi_delay(struct base_obj *ipmi);
// reset_process_delay
// file server-process.c line 423
static void reset_process_delay(struct base_obj *process);
// reset_telnet_delay
// file server-telnet.c line 339
static void reset_telnet_delay(struct base_obj *telnet);
// resolve_addr
// file server-sock.c line 161
static signed int resolve_addr(struct server_conf *conf, struct request *req, signed int sd);
// sanitize_file_string
// file server-obj.c line 407
static char * sanitize_file_string(char *str);
// schedule_timestamp
// file server.c line 551
static void schedule_timestamp(struct server_conf *conf);
// search_exec_path
// file server-process.c line 97
static signed int search_exec_path(const char *path, const char *src, char *dst, signed int dstlen);
// send_ipmi_break
// file server.h line 374
signed int send_ipmi_break(struct base_obj *ipmi);
// send_rsp
// file server-sock.c line 707
static signed int send_rsp(struct request *req, signed int errnum, char *errmsg);
// send_telnet_cmd
// file server.h line 472
signed int send_telnet_cmd(struct base_obj *telnet, signed int cmd, signed int opt);
// set_fd_blocking
// file util-file.h line 43
void set_fd_blocking(signed int fd);
// set_fd_closed_on_exec
// file util-file.h line 38
void set_fd_closed_on_exec(signed int fd);
// set_fd_nonblocking
// file util-file.h line 48
void set_fd_nonblocking(signed int fd);
// set_serial_opts
// file server-serial.c line 256
void set_serial_opts(struct termios *tty, struct base_obj *serial, struct serial_opt *opts);
// set_tty_mode
// file common.h line 202
void set_tty_mode(struct termios *tty, signed int fd);
// setpgid
// file /usr/include/unistd.h line 646
extern signed int setpgid(signed int, signed int);
// setrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 69
extern signed int setrlimit(signed int, struct rlimit *);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setup_coredump
// file server.c line 317
static void setup_coredump(struct server_conf *conf);
// setup_signals
// file server.c line 346
static void setup_signals(struct server_conf *conf);
// setvbuf
// file /usr/include/stdio.h line 336
extern signed int setvbuf(struct _IO_FILE *, char *, signed int, unsigned long int);
// shutdown_obj
// file server-obj.c line 758
signed int shutdown_obj(struct base_obj *obj);
// sig_chld_handler
// file server.c line 366
static void sig_chld_handler(signed int signum);
// sig_hup_handler
// file server.c line 375
static void sig_hup_handler(signed int signum);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_13 *);
// signal_daemon
// file server-conf.c line 517
static void signal_daemon(struct server_conf *conf);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlcat
// file util-str.h line 168
unsigned long int strlcat(char *dst, const char *src, unsigned long int siz);
// strlcpy
// file util-str.h line 178
unsigned long int strlcpy(char *dst, const char *src, unsigned long int siz);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strspn
// file /usr/include/string.h line 288
extern unsigned long int strspn(const char *, const char *);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// substitute_string
// file util-str.h line 94
signed int substitute_string(char *dst, unsigned long int dstlen, const char *src, char c, const char *sub);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// tcflush
// file /usr/include/termios.h line 90
extern signed int tcflush(signed int, signed int);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsendbreak
// file /usr/include/termios.h line 80
extern signed int tcsendbreak(signed int, signed int);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// test_file_lock
// file util-file.c line 144
static signed int test_file_lock(signed int fd, signed int type);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timestamp_logfiles
// file server.c line 596
static void timestamp_logfiles(struct server_conf *conf);
// toint
// file util-str.h line 187
signed int toint(signed int c);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// tpoll
// file tpoll.h line 81
signed int tpoll(struct tpoll *tp, signed int ms);
// tpoll_clear
// file tpoll.c line 274
signed int tpoll_clear(struct tpoll *tp, signed int fd, signed short int events);
// tpoll_create
// file tpoll.h line 62
struct tpoll * tpoll_create(signed int n);
// tpoll_destroy
// file tpoll.h line 64
void tpoll_destroy(struct tpoll *tp);
// tpoll_is_set
// file tpoll.h line 70
signed int tpoll_is_set(struct tpoll *tp, signed int fd, signed short int events);
// tpoll_set
// file tpoll.h line 72
signed int tpoll_set(struct tpoll *tp, signed int fd, signed short int events);
// tpoll_timeout_absolute
// file tpoll.h line 74
signed int tpoll_timeout_absolute(struct tpoll *tp, void (*cb)(void *), void *arg, struct timeval *tvp);

//

// tpoll_timeout_cancel
// file tpoll.h line 79
signed int tpoll_timeout_cancel(struct tpoll *tp, signed int id);
// tpoll_timeout_relative
// file tpoll.h line 77
signed int tpoll_timeout_relative(struct tpoll *tp, void (*cb)(void *), void *arg, signed int ms);

//

// tpoll_zero
// file tpoll.h line 66
signed int tpoll_zero(struct tpoll *tp, enum anonymous_1 how);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unlink_obj
// file server-obj.c line 703
void unlink_obj(struct base_obj *obj);
// unlink_objs
// file server.h line 417
void unlink_objs(struct base_obj *src, struct base_obj *dst);
// validate_req
// file server-sock.c line 561
static signed int validate_req(struct request *req);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_log_data
// file server-logfile.c line 346
signed int write_log_data(struct base_obj *log, const void *src, signed int len);
// write_n
// file util-file.h line 105
signed long int write_n(signed int fd, void *buf, unsigned long int n);
// write_notify_msg
// file server-obj.c line 489
signed int write_notify_msg(struct base_obj *console, signed int priority, char *fmt, ...);
// write_obj_data
// file server.h line 425
signed int write_obj_data(struct base_obj *obj, const void *src, signed int len, signed int isInfo);
// write_pidfile
// file server-conf.c line 1457
static signed int write_pidfile(const char *pidfile);
// write_time_string
// file util-str.h line 132
signed int write_time_string(signed long int t, char *dst, unsigned long int dstlen);
// write_to_obj
// file server.h line 427
signed int write_to_obj(struct base_obj *obj);

struct anonymous_7
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_5
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_13
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_2
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous_8
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_4
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_3
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_9
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_6
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_10
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_8 _kill;
  // _timer
  struct anonymous_9 _timer;
  // _rt
  struct anonymous_3 _rt;
  // _sigchld
  struct anonymous_4 _sigchld;
  // _sigfault
  struct anonymous_5 _sigfault;
  // _sigpoll
  struct anonymous_6 _sigpoll;
  // _sigsys
  struct anonymous_7 _sigsys;
};

struct anonymous_11
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_10 _sifields;
};

union anonymous_12
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_11 *, void *);
};

union anonymous_0
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct client_obj
{
  // req
  struct request *req;
  // timeLastRead
  signed long int timeLastRead;
  // gotEscape
  unsigned int gotEscape : 1;
  // gotSuspend
  unsigned int gotSuspend : 1;
};

struct logfile_opt
{
  // enableLock
  unsigned int enableLock : 1;
  // enableSanitize
  unsigned int enableSanitize : 1;
  // enableTimestamp
  unsigned int enableTimestamp : 1;
};

struct logfile_obj
{
  // console
  struct base_obj *console;
  // fmtName
  char *fmtName;
  // opts
  struct logfile_opt opts;
  // gotProcessing
  unsigned int gotProcessing : 1;
  // gotTruncate
  unsigned int gotTruncate : 1;
  // lineState
  unsigned int lineState : 2;
};

struct process_obj
{
  // argv
  char **argv;
  // prog
  char *prog;
  // timer
  signed int timer;
  // delay
  signed int delay;
  // pid
  signed int pid;
  // tStart
  signed long int tStart;
  // logfile
  struct base_obj *logfile;
  // state
  unsigned int state : 1;
};

struct serial_opt
{
  // bps
  unsigned int bps;
  // databits
  signed int databits;
  // parity
  signed int parity;
  // stopbits
  signed int stopbits;
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct serial_obj
{
  // dev
  char *dev;
  // opts
  struct serial_opt opts;
  // logfile
  struct base_obj *logfile;
  // tty
  struct termios tty;
};

struct telnet_obj
{
  // host
  char *host;
  // port
  signed int port;
  // logfile
  struct base_obj *logfile;
  // timer
  signed int timer;
  // delay
  signed int delay;
  // iac
  signed int iac;
  // state
  unsigned int state : 2;
  // enableKeepAlive
  unsigned int enableKeepAlive : 1;
};

struct unixsock_obj
{
  // dev
  char *dev;
  // logfile
  struct base_obj *logfile;
  // timer
  signed int timer;
  // state
  unsigned int state : 1;
};

struct ipmi_opt
{
  // username
  char username[17l];
  // password
  char password[21l];
  // kg
  unsigned char kg[21l];
  // kgLen
  unsigned int kgLen;
  // privilegeLevel
  signed int privilegeLevel;
  // cipherSuite
  signed int cipherSuite;
  // workaroundFlags
  unsigned int workaroundFlags;
};

struct ipmi_obj
{
  // host
  char *host;
  // iconf
  struct ipmi_opt iconf;
  // ctx
  struct ipmiconsole_ctx *ctx;
  // logfile
  struct base_obj *logfile;
  // state
  enum ipmi_connect_state state;
  // timer
  signed int timer;
  // delay
  signed int delay;
  // mutex
  union anonymous mutex;
};

union aux_obj
{
  // client
  struct client_obj client;
  // logfile
  struct logfile_obj logfile;
  // process
  struct process_obj process;
  // serial
  struct serial_obj serial;
  // telnet
  struct telnet_obj telnet;
  // unixsock
  struct unixsock_obj unixsock;
  // ipmi
  struct ipmi_obj ipmi;
};

struct base_obj
{
  // name
  char *name;
  // fd
  signed int fd;
  // buf
  unsigned char buf[8192l];
  // bufInPtr
  unsigned char *bufInPtr;
  // bufOutPtr
  unsigned char *bufOutPtr;
  // bufLock
  union anonymous bufLock;
  // readers
  struct list *readers;
  // writers
  struct list *writers;
  // type
  unsigned int type : 3;
  // gotBufWrap
  unsigned int gotBufWrap : 1;
  // gotEOF
  unsigned int gotEOF : 1;
  // gotReset
  unsigned int gotReset : 1;
  // aux
  union aux_obj aux;
};

struct bps_tag
{
  // bps
  unsigned int bps;
  // val
  signed int val;
};

struct client_args
{
  // sd
  signed int sd;
  // conf
  struct server_conf *conf;
};

struct console_strs
{
  // name
  char *name;
  // dev
  char *dev;
  // log
  char *log;
  // lopts
  char *lopts;
  // sopts
  char *sopts;
  // iopts
  char *iopts;
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct inevent
{
  // pathname
  char *pathname;
  // dirname
  char *dirname;
  // filename
  char *filename;
  // cb_fnc
  void (*cb_fnc)(void *);
  // cb_arg
  void *cb_arg;
  // wd
  signed int wd;
};

struct inotify_event
{
  // wd
  signed int wd;
  // mask
  unsigned int mask;
  // cookie
  unsigned int cookie;
  // len
  unsigned int len;
  // name
  char name[0l];
};

struct ipmiconsole_engine_config
{
  // engine_flags
  unsigned int engine_flags;
  // behavior_flags
  unsigned int behavior_flags;
  // debug_flags
  unsigned int debug_flags;
};

struct ipmiconsole_ipmi_config
{
  // username
  char *username;
  // password
  char *password;
  // k_g
  unsigned char *k_g;
  // k_g_len
  unsigned int k_g_len;
  // privilege_level
  signed int privilege_level;
  // cipher_suite_id
  signed int cipher_suite_id;
  // workaround_flags
  unsigned int workaround_flags;
};

struct ipmiconsole_protocol_config
{
  // session_timeout_len
  signed int session_timeout_len;
  // retransmission_timeout_len
  signed int retransmission_timeout_len;
  // retransmission_backoff_count
  signed int retransmission_backoff_count;
  // keepalive_timeout_len
  signed int keepalive_timeout_len;
  // retransmission_keepalive_timeout_len
  signed int retransmission_keepalive_timeout_len;
  // acceptable_packet_errors_count
  signed int acceptable_packet_errors_count;
  // maximum_retransmission_count
  signed int maximum_retransmission_count;
};

struct lexer_state
{
  // pos
  char *pos;
  // toks
  char **toks;
  // numtoks
  signed int numtoks;
  // text
  char text[1024l];
  // prev
  signed int prev;
  // line
  signed int line;
  // gotEOL
  signed int gotEOL;
};

struct list
{
  // head
  struct listNode *head;
  // tail
  struct listNode **tail;
  // iNext
  struct listIterator *iNext;
  // fDel
  void (*fDel)(void *);
  // count
  signed int count;
  // mutex
  union anonymous mutex;
};

struct listIterator
{
  // list
  struct list *list;
  // pos
  struct listNode *pos;
  // prev
  struct listNode **prev;
  // iNext
  struct listIterator *iNext;
};

struct listNode
{
  // data
  void *data;
  // next
  struct listNode *next;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct re_pattern_buffer
{
  // __buffer
  unsigned char *__buffer;
  // __allocated
  unsigned long int __allocated;
  // __used
  unsigned long int __used;
  // __syntax
  unsigned long int __syntax;
  // __fastmap
  char *__fastmap;
  // __translate
  unsigned char *__translate;
  // re_nsub
  unsigned long int re_nsub;
  // __can_be_null
  unsigned int __can_be_null : 1;
  // __regs_allocated
  unsigned int __regs_allocated : 2;
  // __fastmap_accurate
  unsigned int __fastmap_accurate : 1;
  // __no_sub
  unsigned int __no_sub : 1;
  // __not_bol
  unsigned int __not_bol : 1;
  // __not_eol
  unsigned int __not_eol : 1;
  // __newline_anchor
  unsigned int __newline_anchor : 1;
};

struct request
{
  // sd
  signed int sd;
  // user
  char *user;
  // tty
  char *tty;
  // fqdn
  char *fqdn;
  // host
  char *host;
  // ip
  char *ip;
  // port
  signed int port;
  // consoles
  struct list *consoles;
  // command
  unsigned int command : 2;
  // enableBroadcast
  unsigned int enableBroadcast : 1;
  // enableEcho
  unsigned int enableEcho : 1;
  // enableForce
  unsigned int enableForce : 1;
  // enableJoin
  unsigned int enableJoin : 1;
  // enableQuiet
  unsigned int enableQuiet : 1;
  // enableRegex
  unsigned int enableRegex : 1;
  // enableReset
  unsigned int enableReset : 1;
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct server_conf
{
  // confFileName
  char *confFileName;
  // coreDumpDir
  char *coreDumpDir;
  // cwd
  char *cwd;
  // execPath
  char *execPath;
  // logDirName
  char *logDirName;
  // logFileName
  char *logFileName;
  // logFmtName
  char *logFmtName;
  // logFilePtr
  struct _IO_FILE *logFilePtr;
  // logFileLevel
  signed int logFileLevel;
  // pidFileName
  char *pidFileName;
  // resetCmd
  char *resetCmd;
  // syslogFacility
  signed int syslogFacility;
  // throwSignal
  signed int throwSignal;
  // tStampMinutes
  signed int tStampMinutes;
  // tStampNext
  signed long int tStampNext;
  // fd
  signed int fd;
  // port
  signed int port;
  // ld
  signed int ld;
  // objs
  struct list *objs;
  // tp
  struct tpoll *tp;
  // globalLogName
  char *globalLogName;
  // globalLogOpts
  struct logfile_opt globalLogOpts;
  // globalSerOpts
  struct serial_opt globalSerOpts;
  // globalIpmiOpts
  struct ipmi_opt globalIpmiOpts;
  // numIpmiObjs
  signed int numIpmiObjs;
  // enableCoreDump
  unsigned int enableCoreDump : 1;
  // enableKeepAlive
  unsigned int enableKeepAlive : 1;
  // enableLoopBack
  unsigned int enableLoopBack : 1;
  // enableTCPWrap
  unsigned int enableTCPWrap : 1;
  // enableVerbose
  unsigned int enableVerbose : 1;
  // enableZeroLogs
  unsigned int enableZeroLogs : 1;
  // enableForeground
  unsigned int enableForeground : 1;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_12 __sigaction_handler;
  // sa_mask
  struct anonymous_13 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct tag
{
  // key
  const char *key;
  // val
  signed int val;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct tpoll
{
  // fd_array
  struct pollfd *fd_array;
  // fd_pipe
  signed int fd_pipe[2l];
  // num_fds_alloc
  signed int num_fds_alloc;
  // num_fds_used
  signed int num_fds_used;
  // max_fd
  signed int max_fd;
  // timers_active
  struct tpoll_timer *timers_active;
  // timers_next_id
  signed int timers_next_id;
  // mutex
  union anonymous mutex;
  // is_blocked
  _Bool is_blocked;
  // is_signaled
  _Bool is_signaled;
  // is_mutex_inited
  _Bool is_mutex_inited;
};

struct tpoll_timer
{
  // id
  signed int id;
  // fnc
  void (*fnc)(void *);
  // arg
  void *arg;
  // tv
  struct timeval tv;
  // next
  struct tpoll_timer *next;
};


// allow_severity
// file server-sock.c line 65
signed int allow_severity = 6;
// bps_table
// file server-serial.c line 55
static struct bps_tag bps_table[20l] = { { .bps=(unsigned int)0000001, .val=50 },
    { .bps=(unsigned int)0000002, .val=75 },
    { .bps=(unsigned int)0000003, .val=110 },
    { .bps=(unsigned int)0000004, .val=134 },
    { .bps=(unsigned int)0000005, .val=150 },
    { .bps=(unsigned int)0000006, .val=200 },
    { .bps=(unsigned int)0000007, .val=300 },
    { .bps=(unsigned int)0000010, .val=600 },
    { .bps=(unsigned int)0000011, .val=1200 },
    { .bps=(unsigned int)0000012, .val=1800 },
    { .bps=(unsigned int)0000013, .val=2400 },
    { .bps=(unsigned int)0000014, .val=4800 },
    { .bps=(unsigned int)0000015, .val=9600 },
    { .bps=(unsigned int)0000016, .val=19200 },
    { .bps=(unsigned int)0000017, .val=38400 },
    { .bps=(unsigned int)0010001, .val=57600 },
    { .bps=(unsigned int)0010002, .val=115200 },
    { .bps=(unsigned int)0010003, .val=230400 },
    { .bps=(unsigned int)0010004, .val=460800 },
    { .bps=(unsigned int)0, .val=0 } };
// conman_license
// file common.c line 41
const char *conman_license = "ConMan: The Console Manager\nhttp://conman.googlecode.com/\n\nWritten by Chris Dunlap <cdunlap@llnl.gov>.\nCopyright (C) 2007-2011 Lawrence Livermore National Security, LLC.\nCopyright (C) 2001-2007 The Regents of the University of California.\n\nConMan is free software: you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3 of the License, or\n(at your option) any later version.\n\n";
// coredump
// file server.c line 83
static signed int coredump = 0;
// coredumpdir
// file server.c line 84
static char coredumpdir[4096l];
// deny_severity
// file server-sock.c line 66
signed int deny_severity = 4;
// done
// file server.c line 81
static volatile signed int done = 0;
// environ
// file server.c line 91
extern char **environ;
// freeListIterators
// file list.c line 124
static struct listIterator *freeListIterators = (struct listIterator *)(void *)0;
// freeListIteratorsLock
// file list.c line 128
static union anonymous freeListIteratorsLock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// freeListNodes
// file list.c line 123
static struct listNode *freeListNodes = (struct listNode *)(void *)0;
// freeListNodesLock
// file list.c line 127
static union anonymous freeListNodesLock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// freeLists
// file list.c line 122
static struct list *freeLists = (struct list *)(void *)0;
// freeListsLock
// file list.c line 126
static union anonymous freeListsLock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// hostentLock
// file util-net.c line 53
static union anonymous hostentLock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// inevent_fd
// file inevent.c line 170
static signed int inevent_fd = -1;
// inevent_list
// file inevent.c line 171
static struct list *inevent_list = (struct list *)(void *)0;
// is_ipmi_engine_started
// file server-ipmi.c line 82
static signed int is_ipmi_engine_started = 0;
// logFacilities
// file server-conf.c line 146
static struct tag logFacilities[19l] = { { .key="auth", .val=4 << 3 }, { .key="authpriv", .val=10 << 3 }, { .key="cron", .val=9 << 3 }, { .key="daemon", .val=3 << 3 }, { .key="kern", .val=0 << 3 }, { .key="lpr", .val=6 << 3 }, { .key="mail", .val=2 << 3 }, { .key="news", .val=7 << 3 }, { .key="user", .val=1 << 3 }, { .key="uucp", .val=8 << 3 }, { .key="local0", .val=16 << 3 }, { .key="local1", .val=17 << 3 }, { .key="local2", .val=18 << 3 }, { .key="local3", .val=19 << 3 }, { .key="local4", .val=20 << 3 }, { .key="local5", .val=21 << 3 }, { .key="local6", .val=22 << 3 }, { .key="local7", .val=23 << 3 }, { .key=(const char *)(void *)0, .val=-1 } };
// logPriorities
// file server-conf.c line 129
static struct tag logPriorities[14l] = { { .key="alert", .val=1 }, { .key="crit", .val=2 }, { .key="critical", .val=2 }, { .key="debug", .val=7 }, { .key="emerg", .val=0 }, { .key="emergency", .val=0 }, { .key="err", .val=3 }, { .key="error", .val=3 }, { .key="info", .val=6 }, { .key="notice", .val=5 }, { .key="panic", .val=0 }, { .key="warn", .val=4 }, { .key="warning", .val=4 }, { .key=(const char *)(void *)0, .val=-1 } };
// log_fd_daemonize
// file log.c line 55
static signed int log_fd_daemonize = -1;
// log_file_fp
// file log.c line 51
static struct _IO_FILE *log_file_fp = (struct _IO_FILE *)(void *)0;
// log_file_priority
// file log.c line 52
static signed int log_file_priority = -1;
// log_file_timestamp
// file log.c line 53
static signed int log_file_timestamp = 0;
// log_syslog
// file log.c line 54
static signed int log_syslog = 0;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// opterr
// file /usr/include/getopt.h line 76
extern signed int opterr;
// optopt
// file /usr/include/getopt.h line 80
extern signed int optopt;
// proto_strs
// file common.c line 56
char *proto_strs[19l] = { "BROADCAST", "CODE", "CONNECT", "CONSOLE", "ERROR", "FORCE", "HELLO", "JOIN", "MESSAGE", "MONITOR", "OK", "OPTION", "QUERY", "QUIET", "REGEX", "RESET", "TTY", "USER", (char *)(void *)0 };
// reconfig
// file server.c line 82
static volatile signed int reconfig = 0;
// server_conf_strs
// file server-conf.c line 86
static char *server_conf_strs[25l] = { "CONSOLE", "COREDUMP", "COREDUMPDIR", "DEV", "EXECPATH", "GLOBAL", "IPMIOPTS", "KEEPALIVE", "LOG", "LOGDIR", "LOGFILE", "LOGOPTS", "LOOPBACK", "NAME", "OFF", "ON", "PIDFILE", "PORT", "RESETCMD", "SEROPTS", "SERVER", "SYSLOG", "TCPWRAPPERS", "TIMESTAMP", (char *)(void *)0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// telcmds
// file /usr/include/arpa/telnet.h line 62
char *telcmds[21l] = { "EOF", "SUSP", "ABORT", "EOR", "SE", "NOP", "DMARK", "BRK", "IP", "AO", "AYT", "EC", "EL", "GA", "SB", "WILL", "WONT", "DO", "DONT", "IAC", ((char *)NULL) };
// telopts
// file /usr/include/arpa/telnet.h line 123
char *telopts[41l] = { "BINARY", "ECHO", "RCP", "SUPPRESS GO AHEAD", "NAME", "STATUS", "TIMING MARK", "RCTE", "NAOL", "NAOP", "NAOCRD", "NAOHTS", "NAOHTD", "NAOFFD", "NAOVTS", "NAOVTD", "NAOLFD", "EXTEND ASCII", "LOGOUT", "BYTE MACRO", "DATA ENTRY TERMINAL", "SUPDUP", "SUPDUP OUTPUT", "SEND LOCATION", "TERMINAL TYPE", "END OF RECORD", "TACACS UID", "OUTPUT MARKING", "TTYLOC", "3270 REGIME", "X.3 PAD", "NAWS", "TSPEED", "LFLOW", "LINEMODE", "XDISPLOC", "OLD-ENVIRON", "AUTHENTICATION", "ENCRYPT", "NEW-ENVIRON", ((char *)NULL) };
// tp_global
// file server.c line 89
struct tpoll *tp_global = (struct tpoll *)(void *)0;

// _inevent_create
// file inevent.c line 411
static struct inevent * _inevent_create(const char *pathname, void (*cb_fnc)(void *), void *cb_arg)
{
  struct inevent *inevent_ptr = (struct inevent *)(void *)0;
  char *p;
  unsigned int event_mask = (unsigned int)(0x00000100 | 0x00000080);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct inevent) /*48ul*/ );
  inevent_ptr = (struct inevent *)return_value_malloc_1;
  if(!(inevent_ptr == ((struct inevent *)NULL)))
  {
    memset((void *)inevent_ptr, 0, sizeof(struct inevent) /*48ul*/ );
    inevent_ptr->wd = -1;
    inevent_ptr->pathname=strdup(pathname);
    if(inevent_ptr->pathname == ((char *)NULL))
      goto err;

    inevent_ptr->dirname=strdup(pathname);
    if(inevent_ptr->dirname == ((char *)NULL))
      goto err;

    p=strrchr(inevent_ptr->dirname, 47);
    inevent_ptr->filename=strdup(p + (signed long int)1);
    if(inevent_ptr->filename == ((char *)NULL))
      goto err;

    if(p == inevent_ptr->dirname)
    {
      p = p + 1l;
      *p = (char)0;
    }

    else
      *p = (char)0;
    inevent_ptr->cb_fnc = cb_fnc;
    inevent_ptr->cb_arg = cb_arg;
    inevent_ptr->wd=inotify_add_watch(inevent_fd, inevent_ptr->dirname, event_mask);
    if(inevent_ptr->wd == -1)
      goto err;

    return inevent_ptr;
  }

  else
  {

  err:
    ;
    _inevent_destroy(inevent_ptr);
    return (struct inevent *)(void *)0;
  }
}

// _inevent_destroy
// file inevent.c line 472
static void _inevent_destroy(struct inevent *inevent_ptr)
{
  if(!(inevent_ptr == ((struct inevent *)NULL)))
  {
    if(!(inevent_ptr->pathname == ((char *)NULL)))
      free((void *)inevent_ptr->pathname);

    if(!(inevent_ptr->dirname == ((char *)NULL)))
      free((void *)inevent_ptr->dirname);

    if(!(inevent_ptr->filename == ((char *)NULL)))
      free((void *)inevent_ptr->filename);

    free((void *)inevent_ptr);
  }

}

// _inevent_fini
// file inevent.c line 390
static void _inevent_fini(void)
{
  if(inevent_fd >= 0)
  {
    close(inevent_fd);
    inevent_fd = -1;
  }

  if(!(inevent_list == ((struct list *)NULL)))
  {
    list_destroy(inevent_list);
    inevent_list = (struct list *)(void *)0;
  }

}

// _inevent_init
// file inevent.c line 358
static signed int _inevent_init(void)
{
  if(inevent_fd == -1)
  {
    inevent_fd=inotify_init();
    if(inevent_fd == -1)
      goto err;

    set_fd_closed_on_exec(inevent_fd);
    set_fd_nonblocking(inevent_fd);
  }

  if(inevent_list == ((struct list *)NULL))
  {
    inevent_list=list_create((void (*)(void *))_inevent_destroy);
    if(inevent_list == ((struct list *)NULL))
      goto err;

  }

  return inevent_fd;

err:
  ;
  _inevent_fini();
  return -1;
}

// _list_find_by_event
// file inevent.c line 527
static signed int _list_find_by_event(const struct inevent *inevent_ptr, struct inotify_event *event_ptr)
{
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  if(inevent_ptr->wd == event_ptr->wd)
  {
    return_value_strcmp_1=strcmp(inevent_ptr->filename, event_ptr->name);
    tmp_if_expr_2 = return_value_strcmp_1 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  return (signed int)tmp_if_expr_2;
}

// _list_find_by_path
// file inevent.c line 499
static signed int _list_find_by_path(const struct inevent *inevent_ptr, const char *pathname)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(inevent_ptr->pathname, pathname);
  return (signed int)(return_value_strcmp_1 == 0);
}

// _list_find_by_wd
// file inevent.c line 513
static signed int _list_find_by_wd(const struct inevent *inevent_ptr, const signed int *wd_ptr)
{
  return (signed int)(inevent_ptr->wd == *wd_ptr);
}

// _tpoll_diff_timeval
// file tpoll.c line 882
static signed int _tpoll_diff_timeval(struct timeval *tvp1, struct timeval *tvp0)
{
  struct timeval tv;
  signed int ms;
  if(tvp0 == ((struct timeval *)NULL) || tvp1 == ((struct timeval *)NULL))
  {
    signed int return_value_gettimeofday_1;
    return_value_gettimeofday_1=gettimeofday(&tv, (struct timezone *)(void *)0);
    if(!(return_value_gettimeofday_1 >= 0))
      log_err(0, "Unable to get time of day");

    if(tvp0 == ((struct timeval *)NULL))
      tvp0 = &tv;

    if(tvp1 == ((struct timeval *)NULL))
      tvp1 = &tv;

  }

  ms = (signed int)((tvp1->tv_sec - tvp0->tv_sec) * (signed long int)1000 + (tvp1->tv_usec - tvp0->tv_usec) / (signed long int)1000);
  _Bool tmp_if_expr_2;
  if(tvp1->tv_sec >= tvp0->tv_sec)
    tmp_if_expr_2 = tvp1->tv_usec > tvp0->tv_usec ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    ms = ms + 1;

  else
    if(tvp0->tv_sec >= tvp1->tv_sec)
    {
      if(!(tvp1->tv_usec >= tvp0->tv_usec))
        ms = ms - 1;

    }

  return ms;
}

// _tpoll_get_timeval
// file tpoll.c line 859
static void _tpoll_get_timeval(struct timeval *tvp, signed int ms)
{
  signed int return_value_gettimeofday_1;
  return_value_gettimeofday_1=gettimeofday(tvp, (struct timezone *)(void *)0);
  if(!(return_value_gettimeofday_1 >= 0))
    log_err(0, "Unable to get time of day");

  if(ms >= 1)
  {
    tvp->tv_sec = tvp->tv_sec + (signed long int)(ms / 1000);
    tvp->tv_usec = tvp->tv_usec + (signed long int)((ms % 1000) * 1000);
    if(tvp->tv_usec >= 1000000l)
    {
      tvp->tv_sec = tvp->tv_sec + tvp->tv_usec / (signed long int)1000000;
      tvp->tv_usec = tvp->tv_usec % (signed long int)1000000;
    }

  }

  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// _tpoll_grow
// file tpoll.c line 812
static signed int _tpoll_grow(struct tpoll *tp, signed int num_fds_req)
{
  struct pollfd *fd_array_tmp;
  struct pollfd *fd_array_new;
  signed int num_fds_tmp;
  signed int num_fds_new;
  signed int i;
  if(tp->num_fds_alloc >= num_fds_req)
    return 0;

  else
  {
    num_fds_tmp = tp->num_fds_alloc;
    for( ; num_fds_tmp >= 1 && !(num_fds_tmp >= num_fds_req); num_fds_tmp = num_fds_tmp * 2)
      ;
    if(!(num_fds_tmp >= num_fds_req))
      num_fds_tmp = num_fds_req;

    _tpoll_signal_send(tp);
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)tp->fd_array, (unsigned long int)num_fds_tmp * sizeof(struct pollfd) /*8ul*/ );
    fd_array_tmp = (struct pollfd *)return_value_realloc_1;
    if(fd_array_tmp == ((struct pollfd *)NULL))
      return -1;

    else
    {
      fd_array_new = fd_array_tmp + (signed long int)tp->num_fds_alloc;
      num_fds_new = num_fds_tmp - tp->num_fds_alloc;
      memset((void *)fd_array_new, 0, (unsigned long int)num_fds_new * sizeof(struct pollfd) /*8ul*/ );
      i = tp->num_fds_alloc;
      for( ; !(i >= num_fds_tmp); i = i + 1)
        (fd_array_tmp + (signed long int)i)->fd = -1;
      tp->fd_array = fd_array_tmp;
      tp->num_fds_alloc = num_fds_tmp;
      return 0;
    }
  }
}

// _tpoll_init
// file tpoll.c line 698
static void _tpoll_init(struct tpoll *tp, enum anonymous_1 how)
{
  signed int i;
  struct tpoll_timer *t;
  if(!((TPOLL_ZERO_FDS & (signed int)how) == 0))
  {
    memset((void *)tp->fd_array, 0, (unsigned long int)tp->num_fds_alloc * sizeof(struct pollfd) /*8ul*/ );
    i = 0;
    for( ; !(i >= tp->num_fds_alloc); i = i + 1)
      (tp->fd_array + (signed long int)i)->fd = -1;
    (tp->fd_array + (signed long int)tp->fd_pipe[(signed long int)0])->fd = tp->fd_pipe[(signed long int)0];
    (tp->fd_array + (signed long int)tp->fd_pipe[(signed long int)0])->events = (signed short int)0x001;
    tp->max_fd = tp->fd_pipe[(signed long int)0];
    tp->num_fds_used = 0;
  }

  if(!((TPOLL_ZERO_TIMERS & (signed int)how) == 0))
  {
    while(!(tp->timers_active == ((struct tpoll_timer *)NULL)))
    {
      t = tp->timers_active;
      tp->timers_active = t->next;
      free((void *)t);
    }
    tp->timers_next_id = 1;
  }

  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
}

// _tpoll_signal_recv
// file tpoll.c line 771
static void _tpoll_signal_recv(struct tpoll *tp)
{
  signed int n;
  unsigned char c[2l];
  _Bool tmp_if_expr_5;
  signed int *return_value___errno_location_4;
  if(!(tp->is_signaled == (_Bool)0))
  {
    do
    {
      signed long int return_value_read_1;
      return_value_read_1=read(tp->fd_pipe[(signed long int)0], (void *)&c, sizeof(unsigned char [2l]) /*2ul*/ );
      n = (signed int)return_value_read_1;
      if(!(n >= 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        if(*return_value___errno_location_2 == 4)
          continue;

        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        if(*return_value___errno_location_3 == 11)
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          return_value___errno_location_4=__errno_location();
          tmp_if_expr_5 = *return_value___errno_location_4 == 11 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
          break;

        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        log_err(*return_value___errno_location_6, "Unable to read signal from tpoll");
      }

      else
        if(n == 0)
          log_err(0, "Got an unexpected EOF reading from tpoll's pipe");

        else
          if((unsigned long int)n == sizeof(unsigned char [2l]) /*2ul*/ )
            continue;

      break;
    }
    while((_Bool)1);
    tp->is_signaled = (_Bool)0;
    goto __CPROVER_DUMP_L11;
  }


__CPROVER_DUMP_L11:
  ;
}

// _tpoll_signal_send
// file tpoll.c line 734
static void _tpoll_signal_send(struct tpoll *tp)
{
  signed int n;
  unsigned char c = (unsigned char)0;
  _Bool tmp_if_expr_1;
  if(!(tp->is_signaled == (_Bool)0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(tp->is_blocked != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_6;
  signed int *return_value___errno_location_5;
  if(!tmp_if_expr_1)
  {
    do
    {
      signed long int return_value_write_2;
      return_value_write_2=write(tp->fd_pipe[(signed long int)1], (const void *)&c, (unsigned long int)1);
      n = (signed int)return_value_write_2;
      if(!(n >= 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        if(*return_value___errno_location_3 == 4)
          continue;

        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        if(*return_value___errno_location_4 == 11)
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          return_value___errno_location_5=__errno_location();
          tmp_if_expr_6 = *return_value___errno_location_5 == 11 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
          break;

        signed int *return_value___errno_location_7;
        return_value___errno_location_7=__errno_location();
        log_err(*return_value___errno_location_7, "Unable to write signal to tpoll");
      }

      else
        if(n == 0)
          log_err(0, "Got an unexpected 0 writing to tpoll's pipe");

      break;
    }
    while((_Bool)1);
    tp->is_signaled = (_Bool)1;
    goto __CPROVER_DUMP_L12;
  }


__CPROVER_DUMP_L12:
  ;
}

// accept_client
// file server.c line 985
static void accept_client(struct server_conf *conf)
{
  signed int sd;
  const signed int on = 1;
  struct client_args *args;
  signed int rc;
  unsigned long int tid;
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_3;
  do
  {
    sd=accept(conf->ld, (struct sockaddr *)(void *)0, (unsigned int *)(void *)0);
    if(sd >= 0)
      break;

    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 4))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      if(*return_value___errno_location_2 == 11)
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        return_value___errno_location_3=__errno_location();
        tmp_if_expr_4 = *return_value___errno_location_3 == 11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
        goto __CPROVER_DUMP_L12;

      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      if(*return_value___errno_location_5 == 103)
        goto __CPROVER_DUMP_L12;

      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      log_err(*return_value___errno_location_6, "Unable to accept new connection");
    }

  }
  while((_Bool)1);
  set_fd_blocking(sd);
  if(!(conf->enableKeepAlive == 0u))
  {
    signed int return_value_setsockopt_8;
    return_value_setsockopt_8=setsockopt(sd, 1, 9, (const void *)&on, (unsigned int)sizeof(const signed int) /*4ul*/ );
    if(!(return_value_setsockopt_8 >= 0))
    {
      signed int *return_value___errno_location_7;
      return_value___errno_location_7=__errno_location();
      log_err(*return_value___errno_location_7, "Unable to set KEEPALIVE socket option");
    }

  }

  void *return_value_malloc_9;
  return_value_malloc_9=malloc(sizeof(struct client_args) /*16ul*/ );
  args = (struct client_args *)return_value_malloc_9;
  if(args == ((struct client_args *)NULL))
  {
    log_err(0, "Out of memory");
    (void *)0;
  }

  args->sd = sd;
  args->conf = conf;
  rc=pthread_create(&tid, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))process_client, (void *)args);
  if(!(rc == 0))
    log_err(rc, "Unable to create new thread");

  goto __CPROVER_DUMP_L12;

__CPROVER_DUMP_L12:
  ;
}

// append_format_string
// file util-str.h line 85
unsigned long int append_format_string(char *dst, unsigned long int size, const char *fmt, ...)
{
  char *p;
  signed int nAvail;
  signed int lenOrig;
  void **vargs;
  signed int n;
  if(fmt == ((const char *)NULL) || size == 0ul)
    return (unsigned long int)0;

  else
  {
    p = dst;
    nAvail = (signed int)size;
    for( ; !(*p == 0); nAvail = nAvail - 1)
    {
      if(!(nAvail >= 1))
        break;

      p = p + 1l;
    }
    if(!(nAvail >= 2))
      return (unsigned long int)-1;

    else
    {
      lenOrig = (signed int)(p - dst);
      vargs = (void **)&fmt;
      n=vsnprintf(p, (unsigned long int)nAvail, fmt, vargs);
      vargs = ((void **)NULL);
      if(n >= nAvail || !(n >= 0))
      {
        dst[(signed long int)(size - (unsigned long int)1)] = (char)0;
        return (unsigned long int)-1;
      }

      else
        return (unsigned long int)(lenOrig + n);
    }
  }
}

// begin_daemonize
// file server.c line 173
static void begin_daemonize(signed int *fd_ptr, signed int *pgid_ptr)
{
  signed int fds[2l];
  signed int pid;
  signed int n;
  signed char priority;
  char ebuf[1024l];
  signed int pgid;
  umask((unsigned int)0);
  signed int return_value_pipe_2;
  return_value_pipe_2=pipe(fds);
  if(!(return_value_pipe_2 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    log_err(*return_value___errno_location_1, "Unable to create daemon pipe");
  }

  log_set_err_pipe(fds[(signed long int)1]);
  pid=fork();
  if(!(pid >= 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    log_err(*return_value___errno_location_3, "Unable to create child process");
  }

  else
    if(pid >= 1)
    {
      log_set_err_pipe(-1);
      signed int return_value_close_5;
      return_value_close_5=close(fds[(signed long int)1]);
      if(!(return_value_close_5 >= 0))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        log_err(*return_value___errno_location_4, "Unable to close write-pipe in parent process");
      }

      signed long int return_value_read_7;
      return_value_read_7=read(fds[(signed long int)0], (void *)&priority, sizeof(signed char) /*1ul*/ );
      n = (signed int)return_value_read_7;
      if(!(n >= 0))
      {
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        log_err(*return_value___errno_location_6, "Unable to read status from grandchild process");
      }

      if(n >= 1 && (signed int)priority >= 0)
      {
        signed long int return_value_read_9;
        return_value_read_9=read(fds[(signed long int)0], (void *)ebuf, sizeof(char [1024l]) /*1024ul*/ );
        n = (signed int)return_value_read_9;
        if(!(n >= 0))
        {
          signed int *return_value___errno_location_8;
          return_value___errno_location_8=__errno_location();
          log_err(*return_value___errno_location_8, "Unable to read error message from grandchild process");
        }

        if(n >= 1)
        {
          if(!((signed int)ebuf[0l] == 0))
          {
            log_set_file(stderr, (signed int)priority, 0);
            log_msg((signed int)priority, "%s", (const void *)ebuf);
          }

        }

        exit(1);
      }

      exit(0);
    }

  signed int return_value_close_11;
  return_value_close_11=close(fds[(signed long int)0]);
  if(!(return_value_close_11 >= 0))
  {
    signed int *return_value___errno_location_10;
    return_value___errno_location_10=__errno_location();
    log_err(*return_value___errno_location_10, "Unable to close read-pipe in child process");
  }

  pgid=setsid();
  if(!(pgid >= 0))
  {
    signed int *return_value___errno_location_12;
    return_value___errno_location_12=__errno_location();
    log_err(*return_value___errno_location_12, "Unable to disassociate controlling tty");
  }

  posix_signal(1, (void (*)(signed int))1);
  pid=fork();
  if(!(pid >= 0))
  {
    signed int *return_value___errno_location_13;
    return_value___errno_location_13=__errno_location();
    log_err(*return_value___errno_location_13, "Unable to create grandchild process");
  }

  else
    if(pid >= 1)
      exit(0);

  if(!(fd_ptr == ((signed int *)NULL)))
    *fd_ptr = fds[(signed long int)1];

  if(!(pgid_ptr == ((signed int *)NULL)))
    *pgid_ptr = pgid;

  goto __CPROVER_DUMP_L15;

__CPROVER_DUMP_L15:
  ;
}

// check_busy_consoles
// file server-sock.c line 621
static signed int check_busy_consoles(struct request *req)
{
  struct list *busy;
  struct listIterator *i;
  struct base_obj *console;
  struct base_obj *writer;
  signed int gotBcast;
  char *tty;
  signed long int t;
  char *delta;
  char buf[1024l];
  _Bool tmp_if_expr_1;
  if((signed int)req->command == 3)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)req->command == 2 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  void *return_value_list_next_3;
  void *return_value_list_pop_8;
  void *return_value_list_next_9;
  signed int *return_value___errno_location_10;
  signed int *return_value___errno_location_12;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    if(!(req->enableForce == 0u))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = req->enableJoin != 0u ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return 0;

    else
    {
      busy=list_create((void (*)(void *))(void *)0);
      i=list_iterator_create(req->consoles);
      do
      {
        return_value_list_next_3=list_next(i);
        console = (struct base_obj *)return_value_list_next_3;
        if(console == ((struct base_obj *)NULL))
          break;

        signed int return_value_list_is_empty_4;
        return_value_list_is_empty_4=list_is_empty(console->writers);
        if(return_value_list_is_empty_4 == 0)
          list_append(busy, (void *)console);

      }
      while((_Bool)1);
      list_iterator_destroy(i);
      signed int return_value_list_is_empty_5;
      return_value_list_is_empty_5=list_is_empty(busy);
      if(!(return_value_list_is_empty_5 == 0))
      {
        list_destroy(busy);
        return 0;
      }

      else
      {
        signed int return_value_list_count_7;
        return_value_list_count_7=list_count(busy);
        if(return_value_list_count_7 == 1)
          snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "Found console already in use");

        else
        {
          signed int return_value_list_count_6;
          return_value_list_count_6=list_count(busy);
          snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "Found %d consoles already in use", return_value_list_count_6);
        }
        send_rsp(req, 7, buf);
        do
        {
          return_value_list_pop_8=list_pop(busy);
          console = (struct base_obj *)return_value_list_pop_8;
          if(console == ((struct base_obj *)NULL))
            break;

          i=list_iterator_create(console->writers);
          do
          {
            return_value_list_next_9=list_next(i);
            writer = (struct base_obj *)return_value_list_next_9;
            if(writer == ((struct base_obj *)NULL))
              break;

            do
            {
              signed int *return_value___errno_location_11;
              return_value___errno_location_11=__errno_location();
              *return_value___errno_location_11=pthread_mutex_lock(&writer->bufLock);
              if(!(*return_value___errno_location_11 == 0))
              {
                return_value___errno_location_10=__errno_location();
                log_err(*return_value___errno_location_10, "pthread_mutex_lock() failed");
              }

            }
            while((_Bool)0);
            t = writer->aux.client.timeLastRead;
            gotBcast=list_is_empty(writer->writers);
            tty = writer->aux.client.req->tty;
            do
            {
              signed int *return_value___errno_location_13;
              return_value___errno_location_13=__errno_location();
              *return_value___errno_location_13=pthread_mutex_unlock(&writer->bufLock);
              if(!(*return_value___errno_location_13 == 0))
              {
                return_value___errno_location_12=__errno_location();
                log_err(*return_value___errno_location_12, "pthread_mutex_unlock() failed");
              }

            }
            while((_Bool)0);
            delta=create_time_delta_string(t, (signed long int)-1);
            snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "Console [%s] open %s by <%s@%s>%s%s (idle %s).\n", console->name, gotBcast != 0 ? "B/C" : "R/W", writer->aux.client.req->user, writer->aux.client.req->host, tty != ((char *)NULL) ? " on " : "", tty != ((char *)NULL) ? tty : "", delta != ((char *)NULL) ? delta : "???");
            buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)2)] = (char)10;
            buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
            if(!(delta == ((char *)NULL)))
              free((void *)delta);

            unsigned long int return_value_strlen_16;
            return_value_strlen_16=strlen(buf);
            signed long int return_value_write_n_17;
            return_value_write_n_17=write_n(req->sd, (void *)buf, return_value_strlen_16);
            if(!(return_value_write_n_17 >= 0l))
            {
              signed int *return_value___errno_location_14;
              return_value___errno_location_14=__errno_location();
              char *return_value_strerror_15;
              return_value_strerror_15=strerror(*return_value___errno_location_14);
              log_msg(5, "Unable to write to <%s:%d>: %s", req->fqdn, req->port, return_value_strerror_15);
              break;
            }

          }
          while((_Bool)1);
          list_iterator_destroy(i);
        }
        while((_Bool)1);
        list_destroy(busy);
        return -1;
      }
    }
  }
}

// check_console_state
// file server-sock.c line 882
static void check_console_state(struct base_obj *console, struct base_obj *client)
{
  char buf[1024l];
  _Bool tmp_if_expr_9;
  if((signed int)console->type == CONMAN_OBJ_PROCESS)
    tmp_if_expr_9 = console->fd < 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_9 = (_Bool)0;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  if(tmp_if_expr_9)
  {
    snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%sConsole [%s] is currently disconnected from \"%s\"%s", (const void *)"\r\n<ConMan> ", console->name, console->aux.process.prog, (const void *)".\r\n");
    strcpy(&buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)3)], "\r\n");
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(buf);
    write_obj_data(client, (const void *)buf, (signed int)return_value_strlen_1, 1);
    open_process_obj(console);
  }

  else
  {
    if((signed int)console->type == CONMAN_OBJ_SERIAL)
      tmp_if_expr_8 = console->fd < 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_8 = (_Bool)0;
    if(tmp_if_expr_8)
    {
      snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%sConsole [%s] is currently disconnected from \"%s\"%s", (const void *)"\r\n<ConMan> ", console->name, console->aux.serial.dev, (const void *)".\r\n");
      strcpy(&buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)3)], "\r\n");
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(buf);
      write_obj_data(client, (const void *)buf, (signed int)return_value_strlen_2, 1);
      open_serial_obj(console);
    }

    else
    {
      if((signed int)console->type == CONMAN_OBJ_TELNET)
        tmp_if_expr_7 = (signed int)console->aux.telnet.state != 3 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_7 = (_Bool)0;
      if(tmp_if_expr_7)
      {
        snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%sConsole [%s] is currently disconnected from <%s:%d>%s", (const void *)"\r\n<ConMan> ", console->name, console->aux.telnet.host, console->aux.telnet.port, (const void *)".\r\n");
        strcpy(&buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)3)], "\r\n");
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(buf);
        write_obj_data(client, (const void *)buf, (signed int)return_value_strlen_3, 1);
        console->aux.telnet.delay = 15;
        if((signed int)console->aux.telnet.state == 1)
          open_telnet_obj(console);

      }

      else
      {
        if((signed int)console->type == CONMAN_OBJ_UNIXSOCK)
          tmp_if_expr_6 = console->fd < 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_6 = (_Bool)0;
        if(tmp_if_expr_6)
        {
          snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%sConsole [%s] is currently disconnected from \"%s\"%s", (const void *)"\r\n<ConMan> ", console->name, console->aux.unixsock.dev, (const void *)".\r\n");
          strcpy(&buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)3)], "\r\n");
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(buf);
          write_obj_data(client, (const void *)buf, (signed int)return_value_strlen_4, 1);
          open_unixsock_obj(console);
        }

        else
          if((signed int)console->type == CONMAN_OBJ_IPMI)
          {
            if(!((signed int)console->aux.ipmi.state == CONMAN_IPMI_UP))
            {
              snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%sConsole [%s] is currently disconnected from <%s>%s", (const void *)"\r\n<ConMan> ", console->name, console->aux.ipmi.host, (const void *)".\r\n");
              strcpy(&buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)3)], "\r\n");
              unsigned long int return_value_strlen_5;
              return_value_strlen_5=strlen(buf);
              write_obj_data(client, (const void *)buf, (signed int)return_value_strlen_5, 1);
              if((signed int)console->aux.ipmi.state == CONMAN_IPMI_DOWN)
                open_ipmi_obj(console);

            }

          }

      }
    }
  }
  goto __CPROVER_DUMP_L16;

__CPROVER_DUMP_L16:
  ;
}

// check_process_prog
// file server-process.c line 389
static signed int check_process_prog(struct base_obj *process)
{
  struct process_obj *auxp;
  struct stat st;
  auxp = &process->aux.process;
  signed int return_value_stat_3;
  return_value_stat_3=stat(auxp->argv[(signed long int)0], &st);
  if(!(return_value_stat_3 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    write_notify_msg(process, 4, "Console [%s] connection failed: \"%s\" stat error: %s", process->name, auxp->prog, return_value_strerror_2);
    return -1;
  }

  if(!((61440u & st.st_mode) == 32768u))
  {
    write_notify_msg(process, 4, "Console [%s] connection failed: \"%s\" not a regular file", process->name, auxp->prog);
    return -1;
  }

  else
  {
    signed int return_value_access_4;
    return_value_access_4=access(auxp->argv[(signed long int)0], 1);
    if(!(return_value_access_4 >= 0))
    {
      write_notify_msg(process, 4, "Console [%s] connection failed: \"%s\" not executable", process->name, auxp->prog);
      return -1;
    }

    else
      return 0;
  }
}

// check_too_many_consoles
// file server-sock.c line 579
static signed int check_too_many_consoles(struct request *req)
{
  struct listIterator *i;
  struct base_obj *obj;
  char buf[32768l];
  void *return_value_list_next_3;
  if((signed int)req->command == 3)
    return 0;

  else
  {
    signed int return_value_list_count_1;
    return_value_list_count_1=list_count(req->consoles);
    if(return_value_list_count_1 == 1)
      return 0;

    else
      if((signed int)req->command == 1)
      {
        if(req->enableBroadcast == 0u)
          goto __CPROVER_DUMP_L3;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        signed int return_value_list_count_2;
        return_value_list_count_2=list_count(req->consoles);
        snprintf(buf, sizeof(char [32768l]) /*32768ul*/ , "Found %d matching consoles", return_value_list_count_2);
        send_rsp(req, 6, buf);
        i=list_iterator_create(req->consoles);
        do
        {
          return_value_list_next_3=list_next(i);
          obj = (struct base_obj *)return_value_list_next_3;
          if(obj == ((struct base_obj *)NULL))
            break;

          strlcpy(buf, obj->name, sizeof(char [32768l]) /*32768ul*/ );
          strlcat(buf, "\n", sizeof(char [32768l]) /*32768ul*/ );
          unsigned long int return_value_strlen_6;
          return_value_strlen_6=strlen(buf);
          signed long int return_value_write_n_7;
          return_value_write_n_7=write_n(req->sd, (void *)buf, return_value_strlen_6);
          if(!(return_value_write_n_7 >= 0l))
          {
            signed int *return_value___errno_location_4;
            return_value___errno_location_4=__errno_location();
            char *return_value_strerror_5;
            return_value_strerror_5=strerror(*return_value___errno_location_4);
            log_msg(5, "Unable to write to <%s:%d>: %s", req->fqdn, req->port, return_value_strerror_5);
            break;
          }

        }
        while((_Bool)1);
        list_iterator_destroy(i);
        return -1;
      }
  }
}

// compare_objs
// file server-obj.c line 424
signed int compare_objs(struct base_obj *obj1, struct base_obj *obj2)
{
  char *str1;
  char *str2;
  char *int1;
  char *int2;
  str1 = obj1->name;
  str2 = obj2->name;
  int1=find_trailing_int_str(str1);
  int2=find_trailing_int_str(str2);
  signed int return_value_atoi_1;
  signed int return_value_atoi_2;
  while(!(*str1 == 0))
    if(str1 == int1 && str2 == int2)
    {
      return_value_atoi_1=atoi(int1);
      return_value_atoi_2=atoi(int2);
      return return_value_atoi_1 - return_value_atoi_2;
    }

    else
      if(*str1 == *str2)
      {
        str1 = str1 + 1l;
        str2 = str2 + 1l;
      }

      else
        break;
  return (signed int)*str1 - (signed int)*str2;
}

// complete_ipmi_connect
// file server-ipmi.c line 945
static signed int complete_ipmi_connect(struct base_obj *ipmi)
{
  enum ipmiconsole_ctx_status status;
  status=ipmiconsole_ctx_status(ipmi->aux.ipmi.ctx);
  if(!((signed int)status == IPMICONSOLE_CTX_STATUS_SOL_ESTABLISHED))
    return -1;

  else
  {
    ipmi->fd=ipmiconsole_ctx_fd(ipmi->aux.ipmi.ctx);
    if(!(ipmi->fd >= 0))
      return -1;

    else
    {
      set_fd_nonblocking(ipmi->fd);
      set_fd_closed_on_exec(ipmi->fd);
      ipmi->gotEOF = (unsigned int)0;
      ipmi->aux.ipmi.state = (enum ipmi_connect_state)CONMAN_IPMI_UP;
      ipmi->aux.ipmi.timer=tpoll_timeout_relative(tp_global, (void (*)(void *))reset_ipmi_delay, (void *)ipmi, 60 * 1000);
      write_notify_msg(ipmi, 6, "Console [%s] connected to <%s>", ipmi->name, ipmi->aux.ipmi.host);
      return 0;
    }
  }
}

// connect_ipmi_obj
// file server-ipmi.c line 813
static signed int connect_ipmi_obj(struct base_obj *ipmi)
{
  signed int rc = 0;
  signed int *return_value___errno_location_1;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_lock(&ipmi->aux.ipmi.mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      return_value___errno_location_1=__errno_location();
      log_err(*return_value___errno_location_1, "pthread_mutex_lock() failed");
    }

  }
  while((_Bool)0);
  if(!((signed int)ipmi->aux.ipmi.state == CONMAN_IPMI_UP))
  {
    if(ipmi->aux.ipmi.timer >= 0)
    {
      tpoll_timeout_cancel(tp_global, ipmi->aux.ipmi.timer);
      ipmi->aux.ipmi.timer = -1;
    }

    if((signed int)ipmi->aux.ipmi.state == CONMAN_IPMI_DOWN)
      rc=initiate_ipmi_connect(ipmi);

    else
      if((signed int)ipmi->aux.ipmi.state == CONMAN_IPMI_PENDING)
        rc=complete_ipmi_connect(ipmi);

      else
        log_err(0, "Console [%s] in unexpected IPMI state=%d", ipmi->name, (signed int)ipmi->aux.ipmi.state);
    if(!(rc >= 0))
      fail_ipmi_connect(ipmi);

  }

  signed int *return_value___errno_location_3;
  do
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    *return_value___errno_location_4=pthread_mutex_unlock(&ipmi->aux.ipmi.mutex);
    if(!(*return_value___errno_location_4 == 0))
    {
      return_value___errno_location_3=__errno_location();
      log_err(*return_value___errno_location_3, "pthread_mutex_unlock() failed");
    }

  }
  while((_Bool)0);
  return rc;
}

// connect_process_obj
// file server-process.c line 299
static signed int connect_process_obj(struct base_obj *process)
{
  struct process_obj *auxp;
  signed int fd_pair[2l] = { -1, -1 };
  signed int pid;
  auxp = &process->aux.process;
  signed int return_value_check_process_prog_1;
  return_value_check_process_prog_1=check_process_prog(process);
  signed int return_value_socketpair_4;
  signed int return_value_close_16;
  signed long int return_value_time_18;
  if(return_value_check_process_prog_1 >= 0)
  {
    return_value_socketpair_4=socketpair(1, 1, 0, fd_pair);
    if(!(return_value_socketpair_4 >= 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      write_notify_msg(process, 4, "Console [%s] connection failed: socketpair error: %s", process->name, return_value_strerror_3);
      goto err;
    }

    set_fd_nonblocking(fd_pair[(signed long int)0]);
    set_fd_nonblocking(fd_pair[(signed long int)1]);
    set_fd_closed_on_exec(fd_pair[(signed long int)0]);
    set_fd_closed_on_exec(fd_pair[(signed long int)1]);
    pid=fork();
    if(!(pid >= 0))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      char *return_value_strerror_6;
      return_value_strerror_6=strerror(*return_value___errno_location_5);
      write_notify_msg(process, 4, "Console [%s] connection failed: fork error: %s", process->name, return_value_strerror_6);
      goto err;
    }

    else
      if(pid == 0)
      {
        signed int return_value_close_8;
        return_value_close_8=close(fd_pair[(signed long int)0]);
        if(!(return_value_close_8 >= 0))
        {
          signed int *return_value___errno_location_7;
          return_value___errno_location_7=__errno_location();
          log_err(*return_value___errno_location_7, "close() of child fd_pair failed");
        }

        signed int return_value_dup2_10;
        return_value_dup2_10=dup2(fd_pair[(signed long int)1], 0);
        if(!(return_value_dup2_10 >= 0))
        {
          signed int *return_value___errno_location_9;
          return_value___errno_location_9=__errno_location();
          log_err(*return_value___errno_location_9, "dup2() of child stdin failed");
        }

        signed int return_value_dup2_12;
        return_value_dup2_12=dup2(fd_pair[(signed long int)1], 1);
        if(!(return_value_dup2_12 >= 0))
        {
          signed int *return_value___errno_location_11;
          return_value___errno_location_11=__errno_location();
          log_err(*return_value___errno_location_11, "dup2() of child stdout failed");
        }

        signed int return_value_dup2_14;
        return_value_dup2_14=dup2(fd_pair[(signed long int)1], 2);
        if(!(return_value_dup2_14 >= 0))
        {
          signed int *return_value___errno_location_13;
          return_value___errno_location_13=__errno_location();
          log_err(*return_value___errno_location_13, "dup2() of child stderr failed");
        }

        execv(auxp->argv[(signed long int)0], auxp->argv);
        _exit(127);
      }

    return_value_close_16=close(fd_pair[(signed long int)1]);
    if(!(return_value_close_16 >= 0))
    {
      signed int *return_value___errno_location_15;
      return_value___errno_location_15=__errno_location();
      log_err(*return_value___errno_location_15, "close() of parent fd_pair failed");
    }

    return_value_time_18=time(&auxp->tStart);
    if(return_value_time_18 == -1l)
    {
      signed int *return_value___errno_location_17;
      return_value___errno_location_17=__errno_location();
      log_err(*return_value___errno_location_17, "time() failed");
    }

    process->fd = fd_pair[(signed long int)0];
    auxp->pid = pid;
    process->gotEOF = (unsigned int)0;
    auxp->state = (unsigned int)1;
    auxp->timer=tpoll_timeout_relative(tp_global, (void (*)(void *))reset_process_delay, (void *)process, 60 * 1000);
    write_notify_msg(process, 6, "Console [%s] connected to \"%s\" (pid %d)", process->name, auxp->prog, auxp->pid);
    return 0;
  }

  else
  {

  err:
    ;
    if(fd_pair[0l] >= 0)
      close(fd_pair[(signed long int)0]);

    if(fd_pair[1l] >= 0)
      close(fd_pair[(signed long int)1]);

    return -1;
  }
}

// connect_telnet_obj
// file server-telnet.c line 175
static signed int connect_telnet_obj(struct base_obj *telnet)
{
  struct sockaddr_in saddr;
  const signed int on = 1;
  if(telnet->aux.telnet.timer >= 0)
  {
    tpoll_timeout_cancel(tp_global, telnet->aux.telnet.timer);
    telnet->aux.telnet.timer = -1;
  }

  if((signed int)telnet->aux.telnet.state == 1)
  {
    memset((void *)&saddr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    saddr.sin_family = (unsigned short int)2;
    saddr.sin_port=htons((unsigned short int)telnet->aux.telnet.port);
    signed int return_value_host_name_to_addr4_1;
    return_value_host_name_to_addr4_1=host_name_to_addr4(telnet->aux.telnet.host, &saddr.sin_addr);
    if(!(return_value_host_name_to_addr4_1 >= 0))
    {
      log_msg(4, "Unable to resolve hostname \"%s\" for [%s]", telnet->aux.telnet.host, telnet->name);
      telnet->aux.telnet.timer=tpoll_timeout_relative(tp_global, (void (*)(void *))connect_telnet_obj, (void *)telnet, 1800 * 1000);
      return -1;
    }

    telnet->fd=socket(2, 1, 0);
    if(!(telnet->fd >= 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      log_err(*return_value___errno_location_2, "Unable to create socket for [%s]", telnet->name);
    }

    signed int return_value_setsockopt_4;
    return_value_setsockopt_4=setsockopt(telnet->fd, 1, 10, (const void *)&on, (unsigned int)sizeof(const signed int) /*4ul*/ );
    if(!(return_value_setsockopt_4 >= 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      log_err(*return_value___errno_location_3, "Unable to set OOBINLINE socket option");
    }

    if(!(telnet->aux.telnet.enableKeepAlive == 0u))
    {
      signed int return_value_setsockopt_6;
      return_value_setsockopt_6=setsockopt(telnet->fd, 1, 9, (const void *)&on, (unsigned int)sizeof(const signed int) /*4ul*/ );
      if(!(return_value_setsockopt_6 >= 0))
      {
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        log_err(*return_value___errno_location_5, "Unable to set KEEPALIVE socket option");
      }

    }

    set_fd_nonblocking(telnet->fd);
    set_fd_closed_on_exec(telnet->fd);
    signed int return_value_connect_8;
    return_value_connect_8=connect(telnet->fd, (struct sockaddr *)&saddr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_connect_8 >= 0))
    {
      signed int *return_value___errno_location_7;
      return_value___errno_location_7=__errno_location();
      if(*return_value___errno_location_7 == 115)
        telnet->aux.telnet.state = (unsigned int)2;

      else
        disconnect_telnet_obj(telnet);
      return -1;
    }

  }

  else
    if((signed int)telnet->aux.telnet.state == 2)
    {
      signed int err = 0;
      unsigned int len = (unsigned int)sizeof(signed int) /*4ul*/ ;
      signed int rc;
      rc=getsockopt(telnet->fd, 1, 4, (void *)&err, &len);
      if(!(rc >= 0))
      {
        signed int *return_value___errno_location_9;
        return_value___errno_location_9=__errno_location();
        err = *return_value___errno_location_9;
      }

      if(!(err == 0))
      {
        close(telnet->fd);
        telnet->fd = -1;
        disconnect_telnet_obj(telnet);
        return -1;
      }

    }

    else
      log_err(0, "Console [%s] is in unexpected telnet state=%d", telnet->aux.telnet.state);
  telnet->gotEOF = (unsigned int)0;
  telnet->aux.telnet.state = (unsigned int)3;
  write_notify_msg(telnet, 6, "Console [%s] connected to <%s:%d>", telnet->name, telnet->aux.telnet.host, telnet->aux.telnet.port);
  telnet->aux.telnet.timer=tpoll_timeout_relative(tp_global, (void (*)(void *))reset_telnet_delay, (void *)telnet, 15 * 1000);
  send_telnet_cmd(telnet, 253, 3);
  send_telnet_cmd(telnet, 253, 1);
  return 0;
}

// connect_unixsock_obj
// file server-unixsock.c line 186
static signed int connect_unixsock_obj(struct base_obj *unixsock)
{
  struct unixsock_obj *auxp;
  struct stat st;
  struct sockaddr_un saddr;
  signed int rc;
  auxp = &unixsock->aux.unixsock;
  if(auxp->timer >= 0)
  {
    tpoll_timeout_cancel(tp_global, auxp->timer);
    auxp->timer = -1;
  }

  signed int return_value_stat_4;
  return_value_stat_4=stat(auxp->dev, &st);
  if(!(return_value_stat_4 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_msg(7, "Console [%s] cannot stat device \"%s\": %s", unixsock->name, auxp->dev, return_value_strerror_2);
    signed int return_value_disconnect_unixsock_obj_3;
    return_value_disconnect_unixsock_obj_3=disconnect_unixsock_obj(unixsock);
    return return_value_disconnect_unixsock_obj_3;
  }

  if(!((61440u & st.st_mode) == 49152u))
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    char *return_value_strerror_6;
    return_value_strerror_6=strerror(*return_value___errno_location_5);
    log_msg(6, "Console [%s] device \"%s\" is not a socket", unixsock->name, auxp->dev, return_value_strerror_6);
    signed int return_value_disconnect_unixsock_obj_7;
    return_value_disconnect_unixsock_obj_7=disconnect_unixsock_obj(unixsock);
    return return_value_disconnect_unixsock_obj_7;
  }

  memset((void *)&saddr, 0, sizeof(struct sockaddr_un) /*110ul*/ );
  saddr.sun_family = (unsigned short int)1;
  unsigned long int return_value_strlcpy_8;
  return_value_strlcpy_8=strlcpy(saddr.sun_path, auxp->dev, sizeof(char [108l]) /*108ul*/ );
  rc = (signed int)return_value_strlcpy_8;
  unixsock->fd=socket(1, 1, 0);
  if(!(unixsock->fd >= 0))
  {
    signed int *return_value___errno_location_9;
    return_value___errno_location_9=__errno_location();
    log_err(*return_value___errno_location_9, "Unable to create console [%s] socket", unixsock->name);
  }

  set_fd_nonblocking(unixsock->fd);
  set_fd_closed_on_exec(unixsock->fd);
  signed int return_value_connect_13;
  return_value_connect_13=connect(unixsock->fd, (struct sockaddr *)&saddr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
  if(!(return_value_connect_13 >= 0))
  {
    signed int *return_value___errno_location_10;
    return_value___errno_location_10=__errno_location();
    char *return_value_strerror_11;
    return_value_strerror_11=strerror(*return_value___errno_location_10);
    log_msg(6, "Console [%s] cannot connect to device \"%s\": %s", unixsock->name, auxp->dev, return_value_strerror_11);
    signed int return_value_disconnect_unixsock_obj_12;
    return_value_disconnect_unixsock_obj_12=disconnect_unixsock_obj(unixsock);
    return return_value_disconnect_unixsock_obj_12;
  }

  unixsock->gotEOF = (unsigned int)0;
  auxp->state = (unsigned int)1;
  write_notify_msg(unixsock, 5, "Console [%s] connected to \"%s\"", unixsock->name, auxp->dev);
  return 0;
}

// copy_hostent
// file util-net.c line 200
static signed int copy_hostent(struct hostent *src, char *buf, signed int len)
{
  struct hostent *dst;
  signed int n;
  char **p;
  char **q;
  dst = (struct hostent *)buf;
  len = len - (signed int)sizeof(struct hostent) /*32ul*/ ;
  if(!(len >= 0))
    return -1;

  else
  {
    dst->h_addrtype = src->h_addrtype;
    dst->h_length = src->h_length;
    buf = buf + (signed long int)sizeof(struct hostent) /*32ul*/ ;
    dst->h_aliases = (char **)buf;
    p = src->h_aliases;
    q = dst->h_aliases;
    n = 0;
    for( ; !(*p == ((char *)NULL)); n = n + 1)
    {
      p = p + 1l;
      q = q + 1l;
    }
    n = n + 1;
    len = len - (signed int)((unsigned long int)n * sizeof(char *) /*8ul*/ );
    if(!(len >= 0))
      return -1;

    else
    {
      buf = (char *)(q + (signed long int)1);
      dst->h_addr_list = (char **)buf;
      p = src->h_addr_list;
      q = dst->h_addr_list;
      n = 0;
      for( ; !(*p == ((char *)NULL)); n = n + 1)
      {
        p = p + 1l;
        q = q + 1l;
      }
      n = n + 1;
      len = len - (signed int)((unsigned long int)n * sizeof(char *) /*8ul*/ );
      if(!(len >= 0))
        return -1;

      else
      {
        buf = (char *)(q + (signed long int)1);
        p = src->h_addr_list;
        q = dst->h_addr_list;
        for( ; !(*p == ((char *)NULL)); q = q + 1l)
        {
          len = len - src->h_length;
          if(!(len >= 0))
            return -1;

          memcpy((void *)buf, (const void *)*p, (unsigned long int)src->h_length);
          *q = buf;
          buf = buf + (signed long int)src->h_length;
          p = p + 1l;
        }
        *q = (char *)(void *)0;
        p = src->h_aliases;
        q = dst->h_aliases;
        for( ; !(*p == ((char *)NULL)); q = q + 1l)
        {
          unsigned long int return_value_strlcpy_1;
          return_value_strlcpy_1=strlcpy(buf, *p, (unsigned long int)len);
          n = (signed int)return_value_strlcpy_1;
          *q = buf;
          n = n + 1;
          buf = buf + (signed long int)n;
          len = len - n;
          if(!(len >= 0))
            return -1;

          p = p + 1l;
        }
        *q = (char *)(void *)0;
        dst->h_name = buf;
        unsigned long int return_value_strlcpy_2;
        return_value_strlcpy_2=strlcpy(buf, src->h_name, (unsigned long int)len);
        n = (signed int)return_value_strlcpy_2;
        n = n + 1;
        buf = buf + (signed long int)n;
        len = len - n;
        if(!(len >= 0))
          return -1;

        else
          return 0;
      }
    }
  }
}

// coredump_handler
// file server.c line 389
static void coredump_handler(signed int signum)
{
  _Bool tmp_if_expr_1;
  if(!(coredump == 0))
    tmp_if_expr_1 = coredumpdir[0l] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    log_msg(3, "Terminating on signal=%d (check \"%s\" for core)", signum, (const void *)coredumpdir);

  else
    log_msg(3, "Terminating on signal=%d", signum);
  umask((unsigned int)077);
  if(!(coredump == 0))
  {
    if(!(coredumpdir[0l] == 0))
      chdir(coredumpdir);

  }

  posix_signal(signum, (void (*)(signed int))0);
  signed int return_value_getpid_2;
  return_value_getpid_2=getpid();
  kill(return_value_getpid_2, signum);
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// create_client_obj
// file server-obj.c line 98
struct base_obj * create_client_obj(struct server_conf *conf, struct request *req)
{
  char name[1024l];
  struct base_obj *client;
  set_fd_nonblocking(req->sd);
  set_fd_closed_on_exec(req->sd);
  snprintf(name, sizeof(char [1024l]) /*1024ul*/ , "%s@%s:%d", req->user, req->host, req->port);
  name[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
  client=create_obj(conf, name, req->sd, (enum obj_type)CONMAN_OBJ_CLIENT);
  client->aux.client.req = req;
  time(&client->aux.client.timeLastRead);
  signed int *return_value___errno_location_1;
  if(client->aux.client.timeLastRead == -1l)
  {
    return_value___errno_location_1=__errno_location();
    log_err(*return_value___errno_location_1, "time() failed");
  }

  client->aux.client.gotEscape = (unsigned int)0;
  client->aux.client.gotSuspend = (unsigned int)0;
  list_append(conf->objs, (void *)client);
  return client;
}

// create_dirs
// file util-file.h line 129
signed int create_dirs(const char *dir_name)
{
  struct stat st_buf;
  char dir_buf[4096l];
  char *p;
  char *slash_ptr;
  unsigned int dir_mode = (unsigned int)(0400 | 0200 | 0100 | 0400 >> 3 | 0100 >> 3 | (0400 >> 3) >> 3 | (0100 >> 3) >> 3);
  _Bool tmp_if_expr_2;
  if(dir_name == ((const char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)*dir_name == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    log_msg(4, "No directory specified for creation");
    return -1;
  }

  signed int return_value_stat_6;
  return_value_stat_6=stat(dir_name, &st_buf);
  if(return_value_stat_6 == 0)
  {
    if((61440u & st_buf.st_mode) == 16384u)
      return 0;

    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = 17;
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    log_msg(4, "Cannot create directory \"%s\": %s", dir_name, return_value_strerror_5);
    return -1;
  }

  unsigned long int return_value_strlcpy_8;
  return_value_strlcpy_8=strlcpy(dir_buf, dir_name, sizeof(char [4096l]) /*4096ul*/ );
  if(return_value_strlcpy_8 >= sizeof(char [4096l]) /*4096ul*/ )
  {
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    *return_value___errno_location_7 = 36;
    log_msg(4, "Exceeded maximum directory length of %d bytes", sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
    return -1;
  }

  unsigned long int return_value_strlen_9;
  return_value_strlen_9=strlen(dir_buf);
  p = (dir_buf + (signed long int)return_value_strlen_9) - (signed long int)1;
  char *tmp_post_10;
  for( ; !(dir_buf >= p); *tmp_post_10 = (char)0)
  {
    if(!((signed int)*p == 47))
      break;

    tmp_post_10 = p;
    p = p - 1l;
  }
  slash_ptr = dir_buf;
  _Bool tmp_if_expr_14;
  signed int return_value_stat_13;
  char *tmp_post_16;
  while((_Bool)1)
  {
    for( ; (signed int)*slash_ptr == 47; slash_ptr = slash_ptr + 1l)
      ;
    slash_ptr=strchr(slash_ptr, 47);
    if(!(slash_ptr == ((char *)NULL)))
      *slash_ptr = (char)0;

    signed int return_value_mkdir_15;
    return_value_mkdir_15=mkdir(dir_buf, dir_mode);
    if(!(return_value_mkdir_15 >= 0))
    {
      signed int mkdir_errno;
      signed int *return_value___errno_location_11;
      return_value___errno_location_11=__errno_location();
      mkdir_errno = *return_value___errno_location_11;
      if(!(mkdir_errno == 17))
        tmp_if_expr_14 = (_Bool)1;

      else
      {
        return_value_stat_13=stat(dir_buf, &st_buf);
        tmp_if_expr_14 = return_value_stat_13 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(!((61440u & st_buf.st_mode) == 16384u) || tmp_if_expr_14)
      {
        char *return_value_strerror_12;
        return_value_strerror_12=strerror(mkdir_errno);
        log_msg(4, "Cannot create directory \"%s\": %s", (const void *)dir_buf, return_value_strerror_12);
        return -1;
      }

    }

    if(slash_ptr == ((char *)NULL))
      break;

    tmp_post_16 = slash_ptr;
    slash_ptr = slash_ptr + 1l;
    *tmp_post_16 = (char)47;
  }
  return 0;
}

// create_format_string
// file util-str.h line 45
char * create_format_string(const char *fmt, ...)
{
  char buf[1024l];
  void **vargs;
  char *p;
  if(fmt == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    vargs = (void **)&fmt;
    vsnprintf(buf, sizeof(char [1024l]) /*1024ul*/ , fmt, vargs);
    vargs = ((void **)NULL);
    buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
    p=strdup(buf);
    if(p == ((char *)NULL))
    {
      log_err(0, "Out of memory");
      (void *)0;
    }

    return p;
  }
}

// create_ipmi_ctx
// file server-ipmi.c line 898
static signed int create_ipmi_ctx(struct base_obj *ipmi)
{
  struct ipmiconsole_ipmi_config ipmi_config;
  struct ipmiconsole_protocol_config protocol_config;
  struct ipmiconsole_engine_config engine_config;
  ipmi_config.username = ipmi->aux.ipmi.iconf.username;
  ipmi_config.password = ipmi->aux.ipmi.iconf.password;
  ipmi_config.k_g = ipmi->aux.ipmi.iconf.kg;
  ipmi_config.k_g_len = ipmi->aux.ipmi.iconf.kgLen;
  ipmi_config.privilege_level = ipmi->aux.ipmi.iconf.privilegeLevel;
  ipmi_config.cipher_suite_id = ipmi->aux.ipmi.iconf.cipherSuite;
  ipmi_config.workaround_flags = ipmi->aux.ipmi.iconf.workaroundFlags;
  protocol_config.session_timeout_len = -1;
  protocol_config.retransmission_timeout_len = -1;
  protocol_config.retransmission_backoff_count = -1;
  protocol_config.keepalive_timeout_len = -1;
  protocol_config.retransmission_keepalive_timeout_len = -1;
  protocol_config.acceptable_packet_errors_count = -1;
  protocol_config.maximum_retransmission_count = -1;
  engine_config.engine_flags = (unsigned int)0;
  engine_config.behavior_flags = (unsigned int)0;
  engine_config.debug_flags = (unsigned int)0;
  if(!(ipmi->aux.ipmi.ctx == ((struct ipmiconsole_ctx *)NULL)))
    ipmiconsole_ctx_destroy(ipmi->aux.ipmi.ctx);

  ipmi->aux.ipmi.ctx=ipmiconsole_ctx_create(ipmi->aux.ipmi.host, &ipmi_config, &protocol_config, &engine_config);
  if(ipmi->aux.ipmi.ctx == ((struct ipmiconsole_ctx *)NULL))
    return -1;

  else
    return 0;
}

// create_ipmi_obj
// file server.h line 369
struct base_obj * create_ipmi_obj(struct server_conf *conf, char *name, struct ipmi_opt *iconf, char *host, char *errbuf, signed int errlen)
{
  struct listIterator *i;
  struct base_obj *ipmi;
  i=list_iterator_create(conf->objs);
  void *return_value_list_next_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_7;
  do
  {
    return_value_list_next_1=list_next(i);
    ipmi = (struct base_obj *)return_value_list_next_1;
    if(ipmi == ((struct base_obj *)NULL))
      break;

    if((signed int)ipmi->type == CONMAN_OBJ_TELNET)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)ipmi->type == CONMAN_OBJ_IPMI ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)ipmi->type == CONMAN_OBJ_PROCESS ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = (signed int)ipmi->type == CONMAN_OBJ_SERIAL ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = (signed int)ipmi->type == CONMAN_OBJ_UNIXSOCK ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      return_value_strcmp_2=strcmp(ipmi->name, name);
      if(return_value_strcmp_2 == 0)
      {
        snprintf(errbuf, (unsigned long int)errlen, "console [%s] specifies duplicate console name", name);
        break;
      }

    }

    if((signed int)ipmi->type == CONMAN_OBJ_IPMI)
    {
      return_value_strcmp_7=strcmp(ipmi->aux.ipmi.host, host);
      if(return_value_strcmp_7 == 0)
      {
        snprintf(errbuf, (unsigned long int)errlen, "console [%s] specifies duplicate hostname \"%s\"", name, host);
        break;
      }

    }

  }
  while((_Bool)1);
  list_iterator_destroy(i);
  signed int *return_value___errno_location_8;
  if(!(ipmi == ((struct base_obj *)NULL)))
    return (struct base_obj *)(void *)0;

  else
  {
    ipmi=create_obj(conf, name, -1, (enum obj_type)CONMAN_OBJ_IPMI);
    ipmi->aux.ipmi.host=create_string(host);
    ipmi->aux.ipmi.iconf = *iconf;
    ipmi->aux.ipmi.ctx = (struct ipmiconsole_ctx *)(void *)0;
    ipmi->aux.ipmi.logfile = (struct base_obj *)(void *)0;
    ipmi->aux.ipmi.state = (enum ipmi_connect_state)CONMAN_IPMI_DOWN;
    ipmi->aux.ipmi.timer = -1;
    ipmi->aux.ipmi.delay = 60;
    do
    {
      signed int *return_value___errno_location_9;
      return_value___errno_location_9=__errno_location();
      *return_value___errno_location_9=pthread_mutex_init(&ipmi->aux.ipmi.mutex, (const union anonymous_0 *)(void *)0);
      if(!(*return_value___errno_location_9 == 0))
      {
        return_value___errno_location_8=__errno_location();
        log_err(*return_value___errno_location_8, "pthread_mutex_init() failed");
      }

    }
    while((_Bool)0);
    conf->numIpmiObjs = conf->numIpmiObjs + 1;
    list_append(conf->objs, (void *)ipmi);
    return ipmi;
  }
}

// create_listen_socket
// file server.c line 631
static void create_listen_socket(struct server_conf *conf)
{
  signed int ld;
  struct sockaddr_in addr;
  const signed int on = 1;
  ld=socket(2, 1, 0);
  if(!(ld >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    log_err(*return_value___errno_location_1, "Unable to create listening socket");
  }

  set_fd_nonblocking(ld);
  set_fd_closed_on_exec(ld);
  memset((void *)&addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  addr.sin_family = (unsigned short int)2;
  addr.sin_port=htons((unsigned short int)conf->port);
  if(!(conf->enableLoopBack == 0u))
    addr.sin_addr.s_addr=htonl((unsigned int)0x7f000001);

  else
    addr.sin_addr.s_addr=htonl((unsigned int)0x00000000);
  signed int return_value_setsockopt_3;
  return_value_setsockopt_3=setsockopt(ld, 1, 2, (const void *)&on, (unsigned int)sizeof(const signed int) /*4ul*/ );
  if(!(return_value_setsockopt_3 >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    log_err(*return_value___errno_location_2, "Unable to set REUSEADDR socket option");
  }

  signed int return_value_bind_5;
  return_value_bind_5=bind(ld, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(return_value_bind_5 >= 0))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    log_err(*return_value___errno_location_4, "Unable to bind to port %d", conf->port);
  }

  signed int return_value_listen_7;
  return_value_listen_7=listen(ld, 10);
  if(!(return_value_listen_7 >= 0))
  {
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    log_err(*return_value___errno_location_6, "Unable to listen on port %d", conf->port);
  }

  conf->ld = ld;
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
}

// create_logfile_obj
// file server.h line 384
struct base_obj * create_logfile_obj(struct server_conf *conf, char *name, struct base_obj *console, struct logfile_opt *opts, char *errbuf, signed int errlen)
{
  struct listIterator *i;
  struct base_obj *logfile;
  char buf[1024l];
  char *pname;
  struct base_obj *obj;
  char *return_value_strchr_1;
  return_value_strchr_1=strchr(name, 37);
  _Bool tmp_if_expr_3;
  signed int return_value_format_obj_string_2;
  if(!(return_value_strchr_1 == ((char *)NULL)))
  {
    return_value_format_obj_string_2=format_obj_string(buf, (signed int)sizeof(char [1024l]) /*1024ul*/ , console, name);
    tmp_if_expr_3 = return_value_format_obj_string_2 >= 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  if(tmp_if_expr_3)
    pname = buf;

  else
    pname = name;
  i=list_iterator_create(conf->objs);
  void *return_value_list_next_4;
  do
  {
    return_value_list_next_4=list_next(i);
    logfile = (struct base_obj *)return_value_list_next_4;
    if(logfile == ((struct base_obj *)NULL))
      break;

    if((signed int)logfile->type == CONMAN_OBJ_LOGFILE)
    {
      signed int return_value_strcmp_5;
      return_value_strcmp_5=strcmp(logfile->name, pname);
      if(return_value_strcmp_5 == 0)
        break;

    }

  }
  while((_Bool)1);
  list_iterator_destroy(i);
  _Bool tmp_if_expr_6;
  void *return_value_list_next_8;
  if(!(logfile == ((struct base_obj *)NULL)))
  {
    snprintf(errbuf, (unsigned long int)errlen, "console [%s] already logging to \"%s\"", logfile->aux.logfile.console->name, pname);
    return (struct base_obj *)(void *)0;
  }

  else
  {
    logfile=create_obj(conf, name, -1, (enum obj_type)CONMAN_OBJ_LOGFILE);
    logfile->aux.logfile.console = console;
    logfile->aux.logfile.lineState = (unsigned int)0;
    logfile->aux.logfile.opts = *opts;
    logfile->aux.logfile.gotTruncate = (unsigned int)!(!(conf->enableZeroLogs != 0u));
    if(!(logfile->aux.logfile.opts.enableSanitize == 0u))
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = logfile->aux.logfile.opts.enableTimestamp != 0u ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
      logfile->aux.logfile.gotProcessing = (unsigned int)1;

    else
      logfile->aux.logfile.gotProcessing = (unsigned int)0;
    char *return_value_strchr_7;
    return_value_strchr_7=strchr(name, 37);
    if(!(return_value_strchr_7 == ((char *)NULL)))
      logfile->aux.logfile.fmtName=create_string(name);

    else
      logfile->aux.logfile.fmtName = (char *)(void *)0;
    if((signed int)console->type == CONMAN_OBJ_PROCESS)
      console->aux.process.logfile = logfile;

    else
      if((signed int)console->type == CONMAN_OBJ_SERIAL)
        console->aux.serial.logfile = logfile;

      else
        if((signed int)console->type == CONMAN_OBJ_TELNET)
          console->aux.telnet.logfile = logfile;

        else
          if((signed int)console->type == CONMAN_OBJ_UNIXSOCK)
            console->aux.unixsock.logfile = logfile;

          else
            if((signed int)console->type == CONMAN_OBJ_IPMI)
              console->aux.ipmi.logfile = logfile;

            else
              log_err(0, "INTERNAL: Unrecognized console [%s] type=%d", console->name, console->type);
    i=list_iterator_create(conf->objs);
    do
    {
      return_value_list_next_8=list_next(i);
      obj = (struct base_obj *)return_value_list_next_8;
      if(obj == ((struct base_obj *)NULL))
        break;

      if(obj == console)
      {
        list_insert(i, (void *)logfile);
        break;
      }

    }
    while((_Bool)1);
    list_iterator_destroy(i);
    if(obj == ((struct base_obj *)NULL))
      log_err(0, "INTERNAL: Console [%s] object not found in master list", console->name);

    return logfile;
  }
}

// create_long_time_string
// file util-str.h line 105
char * create_long_time_string(signed long int t)
{
  char *p;
  struct tm tm;
  const signed int len = 25;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)len);
  p = (char *)return_value_malloc_1;
  if(p == ((char *)NULL))
  {
    log_err(0, "Out of memory");
    (void *)0;
  }

  get_localtime(&t, &tm);
  unsigned long int return_value_strftime_2;
  return_value_strftime_2=strftime(p, (unsigned long int)len, "%Y-%m-%d %H:%M:%S %Z", &tm);
  if(return_value_strftime_2 == 0ul)
    log_err(0, "strftime() failed");

  return p;
}

// create_obj
// file server.h line 396
struct base_obj * create_obj(struct server_conf *conf, char *name, signed int fd, enum obj_type type)
{
  struct base_obj *obj;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct base_obj) /*8448ul*/ );
  obj = (struct base_obj *)return_value_malloc_1;
  if(obj == ((struct base_obj *)NULL))
  {
    log_err(0, "Out of memory");
    (void *)0;
  }

  obj->name=create_string(name);
  obj->fd = fd;
  obj->bufOutPtr = obj->buf;
  obj->bufInPtr = obj->bufOutPtr;
  signed int *return_value___errno_location_2;
  do
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3=pthread_mutex_init(&obj->bufLock, (const union anonymous_0 *)(void *)0);
    if(!(*return_value___errno_location_3 == 0))
    {
      return_value___errno_location_2=__errno_location();
      log_err(*return_value___errno_location_2, "pthread_mutex_init() failed");
    }

  }
  while((_Bool)0);
  obj->readers=list_create((void (*)(void *))(void *)0);
  obj->writers=list_create((void (*)(void *))(void *)0);
  if((signed int)type >= CONMAN_OBJ_LAST_ENTRY || !((signed int)type >= 0))
    log_err(0, "INTERNAL: Unrecognized object [%s] type=%d", name, type);

  obj->type = (unsigned int)type;
  obj->gotBufWrap = (unsigned int)0;
  obj->gotEOF = (unsigned int)0;
  obj->gotReset = (unsigned int)0;
  return obj;
}

// create_process_obj
// file server.h line 435
struct base_obj * create_process_obj(struct server_conf *conf, char *name, struct list *args, char *errbuf, signed int errlen)
{
  struct listIterator *i;
  struct base_obj *process;
  struct process_obj *auxp;
  signed int num_args;
  signed int n;
  char *arg;
  i=list_iterator_create(conf->objs);
  void *return_value_list_next_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_2;
  do
  {
    return_value_list_next_1=list_next(i);
    process = (struct base_obj *)return_value_list_next_1;
    if(process == ((struct base_obj *)NULL))
      break;

    if((signed int)process->type == CONMAN_OBJ_TELNET)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)process->type == CONMAN_OBJ_IPMI ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)process->type == CONMAN_OBJ_PROCESS ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = (signed int)process->type == CONMAN_OBJ_SERIAL ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = (signed int)process->type == CONMAN_OBJ_UNIXSOCK ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      return_value_strcmp_2=strcmp(process->name, name);
      if(return_value_strcmp_2 == 0)
      {
        snprintf(errbuf, (unsigned long int)errlen, "console [%s] specifies duplicate console name", name);
        break;
      }

    }

  }
  while((_Bool)1);
  list_iterator_destroy(i);
  _Bool tmp_if_expr_9;
  void *return_value_list_pop_8;
  if(!(process == ((struct base_obj *)NULL)))
    return (struct base_obj *)(void *)0;

  else
  {
    process=create_obj(conf, name, -1, (enum obj_type)CONMAN_OBJ_PROCESS);
    auxp = &process->aux.process;
    auxp->timer = -1;
    auxp->delay = 60;
    auxp->pid = -1;
    auxp->tStart = (signed long int)0;
    auxp->logfile = (struct base_obj *)(void *)0;
    auxp->state = (unsigned int)0;
    num_args=list_count(args);
    void *return_value_calloc_7;
    return_value_calloc_7=calloc((unsigned long int)(num_args + 1), sizeof(char *) /*8ul*/ );
    auxp->argv = (char **)return_value_calloc_7;
    if(auxp->argv == ((char **)NULL))
    {
      log_err(0, "Out of memory");
      (void *)0;
    }

    n = 0;
    do
    {
      if(!(n >= num_args))
      {
        return_value_list_pop_8=list_pop(args);
        arg = (char *)return_value_list_pop_8;
        tmp_if_expr_9 = arg != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_9 = (_Bool)0;
      if(!tmp_if_expr_9)
        break;

      auxp->argv[(signed long int)n] = arg;
      n = n + 1;
    }
    while((_Bool)1);
    auxp->argv[(signed long int)n] = (char *)(void *)0;
    arg=strrchr(auxp->argv[(signed long int)0], 47);
    if(!(arg == ((char *)NULL)))
      auxp->prog = arg + (signed long int)1;

    else
      auxp->prog = auxp->argv[(signed long int)0];
    list_append(conf->objs, (void *)process);
    return process;
  }
}

// create_req
// file common.h line 196
struct request * create_req(void)
{
  struct request *req;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct request) /*72ul*/ );
  req = (struct request *)return_value_malloc_1;
  if(req == ((struct request *)NULL))
  {
    log_err(0, "Out of memory");
    (void *)0;
  }

  req->sd = -1;
  req->user = (char *)(void *)0;
  req->tty = (char *)(void *)0;
  req->fqdn = (char *)(void *)0;
  req->host = (char *)(void *)0;
  req->ip = (char *)(void *)0;
  req->port = 0;
  req->consoles=list_create((void (*)(void *))destroy_string);
  req->command = (unsigned int)0;
  req->enableBroadcast = (unsigned int)0;
  req->enableEcho = (unsigned int)0;
  req->enableForce = (unsigned int)0;
  req->enableJoin = (unsigned int)0;
  req->enableQuiet = (unsigned int)0;
  req->enableRegex = (unsigned int)0;
  req->enableReset = (unsigned int)0;
  return req;
}

// create_serial_obj
// file server.h line 450
struct base_obj * create_serial_obj(struct server_conf *conf, char *name, char *dev, struct serial_opt *opts, char *errbuf, signed int errlen)
{
  struct listIterator *i;
  struct base_obj *serial;
  i=list_iterator_create(conf->objs);
  void *return_value_list_next_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_7;
  do
  {
    return_value_list_next_1=list_next(i);
    serial = (struct base_obj *)return_value_list_next_1;
    if(serial == ((struct base_obj *)NULL))
      break;

    if((signed int)serial->type == CONMAN_OBJ_TELNET)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)serial->type == CONMAN_OBJ_IPMI ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)serial->type == CONMAN_OBJ_PROCESS ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = (signed int)serial->type == CONMAN_OBJ_SERIAL ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = (signed int)serial->type == CONMAN_OBJ_UNIXSOCK ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      return_value_strcmp_2=strcmp(serial->name, name);
      if(return_value_strcmp_2 == 0)
      {
        snprintf(errbuf, (unsigned long int)errlen, "console [%s] specifies duplicate console name", name);
        break;
      }

    }

    if((signed int)serial->type == CONMAN_OBJ_SERIAL)
    {
      return_value_strcmp_7=strcmp(serial->aux.serial.dev, dev);
      if(return_value_strcmp_7 == 0)
      {
        snprintf(errbuf, (unsigned long int)errlen, "console [%s] specifies duplicate device \"%s\"", name, dev);
        break;
      }

    }

  }
  while((_Bool)1);
  list_iterator_destroy(i);
  if(!(serial == ((struct base_obj *)NULL)))
    return (struct base_obj *)(void *)0;

  else
  {
    serial=create_obj(conf, name, -1, (enum obj_type)CONMAN_OBJ_SERIAL);
    serial->aux.serial.dev=create_string(dev);
    serial->aux.serial.opts = *opts;
    serial->aux.serial.logfile = (struct base_obj *)(void *)0;
    list_append(conf->objs, (void *)serial);
    return serial;
  }
}

// create_server_conf
// file server.h line 340
struct server_conf * create_server_conf(void)
{
  struct server_conf *conf;
  char buf[4096l];
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct server_conf) /*256ul*/ );
  conf = (struct server_conf *)return_value_malloc_1;
  if(conf == ((struct server_conf *)NULL))
  {
    log_err(0, "Out of memory");
    (void *)0;
  }

  conf->cwd = (char *)(void *)0;
  conf->confFileName=create_string("/etc/conman.conf");
  conf->coreDumpDir = (char *)(void *)0;
  conf->execPath = (char *)(void *)0;
  conf->logDirName = (char *)(void *)0;
  conf->logFileName = (char *)(void *)0;
  conf->logFmtName = (char *)(void *)0;
  conf->logFilePtr = (struct _IO_FILE *)(void *)0;
  conf->logFileLevel = 6;
  conf->pidFileName = (char *)(void *)0;
  conf->resetCmd = (char *)(void *)0;
  conf->syslogFacility = -1;
  conf->throwSignal = -1;
  conf->tStampMinutes = 0;
  conf->tStampNext = (signed long int)0;
  conf->fd = -1;
  conf->port = 0;
  conf->ld = -1;
  conf->objs=list_create((void (*)(void *))destroy_obj);
  conf->tp=tpoll_create(0);
  if(conf->tp == ((struct tpoll *)NULL))
    log_err(0, "Unable to create object for multiplexing I/O");

  conf->globalLogName = (char *)(void *)0;
  conf->globalLogOpts.enableSanitize = (unsigned int)0;
  conf->globalLogOpts.enableTimestamp = (unsigned int)0;
  conf->globalLogOpts.enableLock = (unsigned int)1;
  conf->globalSerOpts.bps = (unsigned int)0000015;
  conf->globalSerOpts.databits = 8;
  conf->globalSerOpts.parity = 0;
  conf->globalSerOpts.stopbits = 1;
  signed int return_value_init_ipmi_opts_2;
  return_value_init_ipmi_opts_2=init_ipmi_opts(&conf->globalIpmiOpts);
  if(!(return_value_init_ipmi_opts_2 >= 0))
    log_err(0, "Unable to initialize default IPMI options");

  conf->numIpmiObjs = 0;
  conf->enableCoreDump = (unsigned int)0;
  conf->enableKeepAlive = (unsigned int)1;
  conf->enableLoopBack = (unsigned int)0;
  conf->enableTCPWrap = (unsigned int)0;
  conf->enableVerbose = (unsigned int)0;
  conf->enableZeroLogs = (unsigned int)0;
  conf->enableForeground = (unsigned int)0;
  char *return_value_getcwd_4;
  return_value_getcwd_4=getcwd(buf, sizeof(char [4096l]) /*4096ul*/ );
  if(return_value_getcwd_4 == ((char *)NULL))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    log_err(*return_value___errno_location_3, "Unable to determine working directory");
  }

  conf->cwd=create_string(buf);
  conf->logDirName=create_string(buf);
  return conf;
}

// create_short_time_string
// file util-str.h line 114
char * create_short_time_string(signed long int t)
{
  char *p;
  struct tm tm;
  const signed int len = 12;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)len);
  p = (char *)return_value_malloc_1;
  if(p == ((char *)NULL))
  {
    log_err(0, "Out of memory");
    (void *)0;
  }

  get_localtime(&t, &tm);
  unsigned long int return_value_strftime_2;
  return_value_strftime_2=strftime(p, (unsigned long int)len, "%m-%d %H:%M", &tm);
  if(return_value_strftime_2 == 0ul)
    log_err(0, "strftime() failed");

  return p;
}

// create_string
// file util-str.h line 38
char * create_string(const char *str)
{
  char *p;
  if(str == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    p=strdup(str);
    if(p == ((char *)NULL))
    {
      log_err(0, "Out of memory");
      (void *)0;
    }

    return p;
  }
}

// create_telnet_obj
// file server.h line 465
struct base_obj * create_telnet_obj(struct server_conf *conf, char *name, char *host, signed int port, char *errbuf, signed int errlen)
{
  struct listIterator *i;
  struct base_obj *telnet;
  void *return_value_list_next_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_2;
  if(!(port >= 1))
  {
    snprintf(errbuf, (unsigned long int)errlen, "console [%s] specifies invalid port \"%d\"", name, port);
    return (struct base_obj *)(void *)0;
  }

  else
  {
    i=list_iterator_create(conf->objs);
    do
    {
      return_value_list_next_1=list_next(i);
      telnet = (struct base_obj *)return_value_list_next_1;
      if(telnet == ((struct base_obj *)NULL))
        break;

      if((signed int)telnet->type == CONMAN_OBJ_TELNET)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)telnet->type == CONMAN_OBJ_IPMI ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = (signed int)telnet->type == CONMAN_OBJ_PROCESS ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)telnet->type == CONMAN_OBJ_SERIAL ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
        tmp_if_expr_6 = (_Bool)1;

      else
        tmp_if_expr_6 = (signed int)telnet->type == CONMAN_OBJ_UNIXSOCK ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_6)
      {
        return_value_strcmp_2=strcmp(telnet->name, name);
        if(return_value_strcmp_2 == 0)
        {
          snprintf(errbuf, (unsigned long int)errlen, "console [%s] specifies duplicate console name", name);
          break;
        }

      }

    }
    while((_Bool)1);
    list_iterator_destroy(i);
    if(!(telnet == ((struct base_obj *)NULL)))
      return (struct base_obj *)(void *)0;

    else
    {
      telnet=create_obj(conf, name, -1, (enum obj_type)CONMAN_OBJ_TELNET);
      telnet->aux.telnet.host=create_string(host);
      telnet->aux.telnet.port = port;
      telnet->aux.telnet.logfile = (struct base_obj *)(void *)0;
      telnet->aux.telnet.timer = -1;
      telnet->aux.telnet.delay = 15;
      telnet->aux.telnet.iac = -1;
      telnet->aux.telnet.state = (unsigned int)1;
      telnet->aux.telnet.enableKeepAlive = (unsigned int)conf->enableKeepAlive;
      list_append(conf->objs, (void *)telnet);
      return telnet;
    }
  }
}

// create_time_delta_string
// file util-str.h line 123
char * create_time_delta_string(signed long int t0, signed long int t1)
{
  signed long int n;
  signed int years;
  signed int weeks;
  signed int days;
  signed int hours;
  signed int minutes;
  signed int seconds;
  char buf[25l];
  if(t1 == -1l)
  {
    signed long int return_value_time_2;
    return_value_time_2=time(&t1);
    if(return_value_time_2 == -1l)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      log_err(*return_value___errno_location_1, "time() failed");
    }

  }

  double return_value_difftime_3;
  return_value_difftime_3=difftime(t1, t0);
  n = (signed long int)return_value_difftime_3;
  seconds = (signed int)(n % (signed long int)60);
  n = n / (signed long int)60;
  minutes = (signed int)(n % (signed long int)60);
  n = n / (signed long int)60;
  hours = (signed int)(n % (signed long int)24);
  n = n / (signed long int)24;
  days = (signed int)(n % (signed long int)7);
  n = n / (signed long int)7;
  weeks = (signed int)(n % (signed long int)52);
  n = n / (signed long int)52;
  years = (signed int)n;
  if(years >= 1)
  {
    signed int return_value_snprintf_4;
    return_value_snprintf_4=snprintf(buf, sizeof(char [25l]) /*25ul*/ , "%dy%dw%dd%dh%dm%ds", years, weeks, days, hours, minutes, seconds);
    n = (signed long int)return_value_snprintf_4;
  }

  else
    if(weeks >= 1)
    {
      signed int return_value_snprintf_5;
      return_value_snprintf_5=snprintf(buf, sizeof(char [25l]) /*25ul*/ , "%dw%dd%dh%dm%ds", weeks, days, hours, minutes, seconds);
      n = (signed long int)return_value_snprintf_5;
    }

    else
      if(days >= 1)
      {
        signed int return_value_snprintf_6;
        return_value_snprintf_6=snprintf(buf, sizeof(char [25l]) /*25ul*/ , "%dd%dh%dm%ds", days, hours, minutes, seconds);
        n = (signed long int)return_value_snprintf_6;
      }

      else
        if(hours >= 1)
        {
          signed int return_value_snprintf_7;
          return_value_snprintf_7=snprintf(buf, sizeof(char [25l]) /*25ul*/ , "%dh%dm%ds", hours, minutes, seconds);
          n = (signed long int)return_value_snprintf_7;
        }

        else
          if(minutes >= 1)
          {
            signed int return_value_snprintf_8;
            return_value_snprintf_8=snprintf(buf, sizeof(char [25l]) /*25ul*/ , "%dm%ds", minutes, seconds);
            n = (signed long int)return_value_snprintf_8;
          }

          else
          {
            signed int return_value_snprintf_9;
            return_value_snprintf_9=snprintf(buf, sizeof(char [25l]) /*25ul*/ , "%ds", seconds);
            n = (signed long int)return_value_snprintf_9;
          }
  char *return_value_create_string_10;
  return_value_create_string_10=create_string(buf);
  return return_value_create_string_10;
}

// create_unixsock_obj
// file server.h line 479
struct base_obj * create_unixsock_obj(struct server_conf *conf, char *name, char *dev, char *errbuf, signed int errlen)
{
  signed int n;
  struct listIterator *i;
  struct base_obj *unixsock;
  signed int rv;
  n=max_unixsock_dev_strlen();
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(dev);
  void *return_value_list_next_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_8;
  if(!((unsigned long int)n >= return_value_strlen_1))
  {
    snprintf(errbuf, (unsigned long int)errlen, "console [%s] exceeds maximum device length of %d bytes", name, n);
    return (struct base_obj *)(void *)0;
  }

  else
  {
    i=list_iterator_create(conf->objs);
    do
    {
      return_value_list_next_2=list_next(i);
      unixsock = (struct base_obj *)return_value_list_next_2;
      if(unixsock == ((struct base_obj *)NULL))
        break;

      if((signed int)unixsock->type == CONMAN_OBJ_TELNET)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = (signed int)unixsock->type == CONMAN_OBJ_IPMI ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)unixsock->type == CONMAN_OBJ_PROCESS ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
        tmp_if_expr_6 = (_Bool)1;

      else
        tmp_if_expr_6 = (signed int)unixsock->type == CONMAN_OBJ_SERIAL ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_6)
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = (signed int)unixsock->type == CONMAN_OBJ_UNIXSOCK ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_7)
      {
        return_value_strcmp_3=strcmp(unixsock->name, name);
        if(return_value_strcmp_3 == 0)
        {
          snprintf(errbuf, (unsigned long int)errlen, "console [%s] specifies duplicate console name", name);
          break;
        }

      }

      if((signed int)unixsock->type == CONMAN_OBJ_UNIXSOCK)
      {
        return_value_strcmp_8=strcmp(unixsock->aux.unixsock.dev, dev);
        if(return_value_strcmp_8 == 0)
        {
          snprintf(errbuf, (unsigned long int)errlen, "console [%s] specifies duplicate device \"%s\"", name, dev);
          break;
        }

      }

    }
    while((_Bool)1);
    list_iterator_destroy(i);
    if(!(unixsock == ((struct base_obj *)NULL)))
      return (struct base_obj *)(void *)0;

    else
    {
      unixsock=create_obj(conf, name, -1, (enum obj_type)CONMAN_OBJ_UNIXSOCK);
      unixsock->aux.unixsock.dev=create_string(dev);
      unixsock->aux.unixsock.logfile = (struct base_obj *)(void *)0;
      unixsock->aux.unixsock.timer = -1;
      unixsock->aux.unixsock.state = (unsigned int)0;
      list_append(conf->objs, (void *)unixsock);
      rv=inevent_add(unixsock->aux.unixsock.dev, (void (*)(void *))open_unixsock_obj, (void *)unixsock);
      if(!(rv >= 0))
        log_msg(6, "Console [%s] unable to register device \"%s\" for inotify events", unixsock->name, unixsock->aux.unixsock.dev);

      return unixsock;
    }
  }
}

// debug_printf
// file log.c line 64
void debug_printf(signed int level, const char *format, ...)
{
  void **vargs;
  char *p;
  signed int i = 0;
  static signed int debug_level = -1;
  if(!(debug_level >= 0))
  {
    p=getenv("DEBUG");
    if(!(p == ((char *)NULL)))
      i=atoi(p);

    debug_level = i > 0 ? i : 0;
  }

  if(debug_level >= level && level >= 1)
  {
    vargs = (void **)&format;
    vfprintf(stderr, format, vargs);
    vargs = ((void **)NULL);
  }

  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L4:
  ;
}

// destroy_obj
// file server.h line 401
void destroy_obj(struct base_obj *obj)
{
  char **pp;
  signed int *return_value___errno_location_2;
  switch((signed int)obj->type)
  {
    case CONMAN_OBJ_CLIENT:
    {
      if(!(obj->aux.client.req == ((struct request *)NULL)))
      {
        obj->aux.client.req->sd = -1;
        destroy_req(obj->aux.client.req);
      }

      break;
    }
    case CONMAN_OBJ_LOGFILE:
    {
      if(!(obj->aux.logfile.fmtName == ((char *)NULL)))
        free((void *)obj->aux.logfile.fmtName);

      break;
    }
    case CONMAN_OBJ_PROCESS:
    {
      pp = obj->aux.process.argv;
      for( ; !(*pp == ((char *)NULL)); pp = pp + 1l)
        free((void *)*pp);
      break;
    }
    case CONMAN_OBJ_SERIAL:
    {
      if(obj->fd >= 0)
      {
        set_tty_mode(&obj->aux.serial.tty, obj->fd);
        signed int return_value_tcflush_1;
        return_value_tcflush_1=tcflush(obj->fd, 2);
        if(!(return_value_tcflush_1 >= 0))
          log_msg(6, "Unable to flush tty device for console [%s]", obj->name);

      }

      if(!(obj->aux.serial.dev == ((char *)NULL)))
        free((void *)obj->aux.serial.dev);

      break;
    }
    case CONMAN_OBJ_TELNET:
    {
      if(!(obj->aux.telnet.host == ((char *)NULL)))
        free((void *)obj->aux.telnet.host);

      break;
    }
    case CONMAN_OBJ_UNIXSOCK:
    {
      if(!(obj->aux.unixsock.dev == ((char *)NULL)))
      {
        inevent_remove(obj->aux.unixsock.dev);
        free((void *)obj->aux.unixsock.dev);
      }

      break;
    }
    case CONMAN_OBJ_IPMI:
    {
      if(!(obj->aux.ipmi.host == ((char *)NULL)))
        free((void *)obj->aux.ipmi.host);

      if(!(obj->aux.ipmi.ctx == ((struct ipmiconsole_ctx *)NULL)))
        ipmiconsole_ctx_destroy(obj->aux.ipmi.ctx);

      do
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3=pthread_mutex_destroy(&obj->aux.ipmi.mutex);
        if(!(*return_value___errno_location_3 == 0))
        {
          return_value___errno_location_2=__errno_location();
          log_err(*return_value___errno_location_2, "pthread_mutex_destroy() failed");
        }

      }
      while((_Bool)0);
      break;
    }
    default:
      log_err(0, "INTERNAL: Unrecognized object [%s] type=%d", obj->name, obj->type);
  }
  signed int *return_value___errno_location_4;
  do
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    *return_value___errno_location_5=pthread_mutex_destroy(&obj->bufLock);
    if(!(*return_value___errno_location_5 == 0))
    {
      return_value___errno_location_4=__errno_location();
      log_err(*return_value___errno_location_4, "pthread_mutex_destroy() failed");
    }

  }
  while((_Bool)0);
  if(!(obj->readers == ((struct list *)NULL)))
    list_destroy(obj->readers);

  if(!(obj->writers == ((struct list *)NULL)))
    list_destroy(obj->writers);

  signed int *return_value___errno_location_6;
  if(obj->fd >= 0)
  {
    signed int return_value_close_7;
    return_value_close_7=close(obj->fd);
    if(!(return_value_close_7 >= 0))
    {
      return_value___errno_location_6=__errno_location();
      log_err(*return_value___errno_location_6, "Unable to close object [%s]", obj->name);
    }

    obj->fd = -1;
  }

  if(!(obj->name == ((char *)NULL)))
    free((void *)obj->name);

  free((void *)obj);
  goto __CPROVER_DUMP_L28;

__CPROVER_DUMP_L28:
  ;
}

// destroy_req
// file common.h line 198
void destroy_req(struct request *req)
{
  signed int *return_value___errno_location_1;
  if(!(req == ((struct request *)NULL)))
  {
    if(req->sd >= 0)
    {
      signed int return_value_close_2;
      return_value_close_2=close(req->sd);
      if(!(return_value_close_2 >= 0))
      {
        return_value___errno_location_1=__errno_location();
        log_err(*return_value___errno_location_1, "close() failed on fd=%d", req->sd);
      }

      req->sd = -1;
    }

    if(!(req->user == ((char *)NULL)))
      free((void *)req->user);

    if(!(req->tty == ((char *)NULL)))
      free((void *)req->tty);

    if(!(req->fqdn == ((char *)NULL)))
      free((void *)req->fqdn);

    if(!(req->host == ((char *)NULL)))
      free((void *)req->host);

    if(!(req->ip == ((char *)NULL)))
      free((void *)req->ip);

    if(!(req->consoles == ((struct list *)NULL)))
      list_destroy(req->consoles);

    free((void *)req);
  }

}

// destroy_server_conf
// file server.h line 342
void destroy_server_conf(struct server_conf *conf)
{
  if(!(conf == ((struct server_conf *)NULL)))
  {
    if(!(conf->pidFileName == ((char *)NULL)))
    {
      signed int return_value_unlink_3;
      return_value_unlink_3=unlink(conf->pidFileName);
      if(!(return_value_unlink_3 >= 0))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        char *return_value_strerror_2;
        return_value_strerror_2=strerror(*return_value___errno_location_1);
        log_msg(3, "Unable to delete pid file \"%s\": %s", conf->pidFileName, return_value_strerror_2);
      }

    }

    if(conf->fd >= 0)
    {
      signed int return_value_close_6;
      return_value_close_6=close(conf->fd);
      if(!(return_value_close_6 >= 0))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        char *return_value_strerror_5;
        return_value_strerror_5=strerror(*return_value___errno_location_4);
        log_msg(3, "Unable to close config file \"%s\": %s", conf->confFileName, return_value_strerror_5);
      }

      conf->fd = -1;
    }

    if(conf->ld >= 0)
    {
      signed int return_value_close_9;
      return_value_close_9=close(conf->ld);
      if(!(return_value_close_9 >= 0))
      {
        signed int *return_value___errno_location_7;
        return_value___errno_location_7=__errno_location();
        char *return_value_strerror_8;
        return_value_strerror_8=strerror(*return_value___errno_location_7);
        log_msg(3, "Unable to close listening socket: %s", return_value_strerror_8);
      }

      conf->ld = -1;
    }

    if(!(conf->objs == ((struct list *)NULL)))
      list_destroy(conf->objs);

    if(!(conf->tp == ((struct tpoll *)NULL)))
      tpoll_destroy(conf->tp);

    destroy_string(conf->confFileName);
    destroy_string(conf->coreDumpDir);
    destroy_string(conf->cwd);
    destroy_string(conf->execPath);
    destroy_string(conf->globalLogName);
    destroy_string(conf->logDirName);
    destroy_string(conf->logFileName);
    destroy_string(conf->logFmtName);
    destroy_string(conf->pidFileName);
    destroy_string(conf->resetCmd);
    free((void *)conf);
  }

}

// destroy_string
// file util-str.h line 58
void destroy_string(char *str)
{
  if(!(str == ((char *)NULL)))
    free((void *)str);

}

// disconnect_ipmi_obj
// file server-ipmi.c line 777
static void disconnect_ipmi_obj(struct base_obj *ipmi)
{
  signed int *return_value___errno_location_1;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_lock(&ipmi->aux.ipmi.mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      return_value___errno_location_1=__errno_location();
      log_err(*return_value___errno_location_1, "pthread_mutex_lock() failed");
    }

  }
  while((_Bool)0);
  if(ipmi->aux.ipmi.timer >= 0)
  {
    tpoll_timeout_cancel(tp_global, ipmi->aux.ipmi.timer);
    ipmi->aux.ipmi.timer = -1;
  }

  if(ipmi->fd >= 0)
  {
    signed int return_value_close_5;
    return_value_close_5=close(ipmi->fd);
    if(!(return_value_close_5 >= 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      log_msg(3, "Unable to close connection to <%s> for console [%s]: %s", ipmi->aux.ipmi.host, ipmi->name, return_value_strerror_4);
    }

    ipmi->fd = -1;
  }

  if((signed int)ipmi->aux.ipmi.state == CONMAN_IPMI_UP)
    write_notify_msg(ipmi, 5, "Console [%s] disconnected from <%s>", ipmi->name, ipmi->aux.ipmi.host);

  ipmi->aux.ipmi.state = (enum ipmi_connect_state)CONMAN_IPMI_DOWN;
  signed int *return_value___errno_location_6;
  do
  {
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    *return_value___errno_location_7=pthread_mutex_unlock(&ipmi->aux.ipmi.mutex);
    if(!(*return_value___errno_location_7 == 0))
    {
      return_value___errno_location_6=__errno_location();
      log_err(*return_value___errno_location_6, "pthread_mutex_unlock() failed");
    }

  }
  while((_Bool)0);
}

// disconnect_process_obj
// file server-process.c line 256
static signed int disconnect_process_obj(struct base_obj *process)
{
  struct process_obj *auxp;
  signed long int tNow;
  signed int n;
  char *delta_str;
  auxp = &process->aux.process;
  if(process->fd >= 0)
  {
    close(process->fd);
    process->fd = -1;
  }

  signed long int return_value_time_2;
  return_value_time_2=time(&tNow);
  if(return_value_time_2 == -1l)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    log_err(*return_value___errno_location_1, "time() failed");
  }

  n = (signed int)(tNow - auxp->tStart);
  delta_str=create_time_delta_string(auxp->tStart, tNow);
  write_notify_msg(process, 6, "Console [%s] disconnected from \"%s\" (pid %d) after %s", process->name, auxp->prog, auxp->pid, delta_str);
  free((void *)delta_str);
  kill(auxp->pid, 9);
  auxp->pid = -1;
  auxp->tStart = (signed long int)0;
  auxp->state = (unsigned int)0;
  return -1;
}

// disconnect_telnet_obj
// file server-telnet.c line 294
static void disconnect_telnet_obj(struct base_obj *telnet)
{
  if(telnet->aux.telnet.timer >= 0)
  {
    tpoll_timeout_cancel(tp_global, telnet->aux.telnet.timer);
    telnet->aux.telnet.timer = -1;
  }

  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(telnet->fd >= 0)
  {
    signed int return_value_close_3;
    return_value_close_3=close(telnet->fd);
    if(!(return_value_close_3 >= 0))
    {
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_msg(3, "Unable to close connection to <%s:%d> for [%s]: %s", telnet->aux.telnet.host, telnet->aux.telnet.port, telnet->name, return_value_strerror_2);
    }

    telnet->fd = -1;
  }

  if((signed int)telnet->aux.telnet.state == 3)
    write_notify_msg(telnet, 5, "Console [%s] disconnected from <%s:%d>", telnet->name, telnet->aux.telnet.host, telnet->aux.telnet.port);

  telnet->aux.telnet.state = (unsigned int)1;
  telnet->aux.telnet.timer=tpoll_timeout_relative(tp_global, (void (*)(void *))connect_telnet_obj, (void *)telnet, telnet->aux.telnet.delay * 1000);
  signed int tmp_if_expr_4;
  if(telnet->aux.telnet.delay == 0)
    telnet->aux.telnet.delay = 15;

  else
    if(!(telnet->aux.telnet.delay >= 1800))
    {
      if(!(2 * telnet->aux.telnet.delay >= 1801))
        tmp_if_expr_4 = telnet->aux.telnet.delay * 2;

      else
        tmp_if_expr_4 = 1800;
      telnet->aux.telnet.delay = tmp_if_expr_4;
    }

}

// disconnect_unixsock_obj
// file server-unixsock.c line 270
static signed int disconnect_unixsock_obj(struct base_obj *unixsock)
{
  struct unixsock_obj *auxp = &unixsock->aux.unixsock;
  if(auxp->timer >= 0)
  {
    tpoll_timeout_cancel(tp_global, auxp->timer);
    auxp->timer = -1;
  }

  if(unixsock->fd >= 0)
  {
    signed int return_value_close_3;
    return_value_close_3=close(unixsock->fd);
    if(!(return_value_close_3 >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_msg(3, "Unable to close console [%s] socket \"%s\": %s", unixsock->name, auxp->dev, return_value_strerror_2);
    }

    unixsock->fd = -1;
  }

  if((signed int)auxp->state == 1)
  {
    auxp->state = (unsigned int)0;
    write_notify_msg(unixsock, 5, "Console [%s] disconnected from \"%s\"", unixsock->name, auxp->dev);
  }

  auxp->timer=tpoll_timeout_relative(tp_global, (void (*)(void *))connect_unixsock_obj, (void *)unixsock, 60 * 1000);
  return -1;
}

// display_configuration
// file server.c line 482
static void display_configuration(struct server_conf *conf)
{
  struct listIterator *i;
  struct base_obj *obj;
  signed int n = 0;
  signed int gotOptions = 0;
  i=list_iterator_create(conf->objs);
  void *return_value_list_next_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  do
  {
    return_value_list_next_1=list_next(i);
    obj = (struct base_obj *)return_value_list_next_1;
    if(obj == ((struct base_obj *)NULL))
      break;

    if((signed int)obj->type == CONMAN_OBJ_TELNET)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)obj->type == CONMAN_OBJ_IPMI ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)obj->type == CONMAN_OBJ_PROCESS ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)obj->type == CONMAN_OBJ_SERIAL ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = (signed int)obj->type == CONMAN_OBJ_UNIXSOCK ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      n = n + 1;

  }
  while((_Bool)1);
  list_iterator_destroy(i);
  signed int return_value_getpid_6;
  return_value_getpid_6=getpid();
  fprintf(stderr, "\nStarting ConMan daemon %s (pid %d)\n", (const void *)"0.2.7", (signed int)return_value_getpid_6);
  fprintf(stderr, "Configuration: %s\n", conf->confFileName);
  fprintf(stderr, "Options:");
  if(!(conf->enableCoreDump == 0u))
  {
    fprintf(stderr, " CoreDump");
    gotOptions = gotOptions + 1;
  }

  if(!(conf->enableKeepAlive == 0u))
  {
    fprintf(stderr, " KeepAlive");
    gotOptions = gotOptions + 1;
  }

  if(!(conf->logFileName == ((char *)NULL)))
  {
    fprintf(stderr, " LogFile");
    gotOptions = gotOptions + 1;
  }

  if(!(conf->enableLoopBack == 0u))
  {
    fprintf(stderr, " LoopBack");
    gotOptions = gotOptions + 1;
  }

  if(!(conf->resetCmd == ((char *)NULL)))
  {
    fprintf(stderr, " ResetCmd");
    gotOptions = gotOptions + 1;
  }

  if(conf->syslogFacility >= 0)
  {
    fprintf(stderr, " SysLog");
    gotOptions = gotOptions + 1;
  }

  if(!(conf->enableTCPWrap == 0u))
  {
    fprintf(stderr, " TCP-Wrappers");
    gotOptions = gotOptions + 1;
  }

  if(conf->tStampMinutes >= 1)
  {
    fprintf(stderr, " TimeStamp=%dm", conf->tStampMinutes);
    gotOptions = gotOptions + 1;
  }

  if(!(conf->enableZeroLogs == 0u))
  {
    fprintf(stderr, " ZeroLogs");
    gotOptions = gotOptions + 1;
  }

  if(gotOptions == 0)
    fprintf(stderr, " None");

  fprintf(stderr, "\n");
  fprintf(stderr, "Listening on port %d\n", conf->port);
  fprintf(stderr, "Monitoring %d console%s\n", n, n == 1 ? "" : "s");
  fprintf(stderr, "\n");
  goto __CPROVER_DUMP_L22;

__CPROVER_DUMP_L22:
  ;
}

// display_server_help
// file server-conf.c line 495
static void display_server_help(char *prog)
{
  printf("Usage: %s [OPTIONS]\n", prog);
  printf("\n");
  printf("  -c FILE   Specify configuration. [%s]\n", (const void *)"/etc/conman.conf");
  printf("  -F        Run daemon in foreground.\n");
  printf("  -h        Display this help.\n");
  printf("  -k        Kill daemon.\n");
  printf("  -L        Display license information.\n");
  signed int return_value_atoi_1;
  return_value_atoi_1=atoi("7890");
  printf("  -p PORT   Specify port number. [%d]\n", return_value_atoi_1);
  printf("  -q        Query daemon's pid.\n");
  printf("  -r        Re-open log files.\n");
  printf("  -v        Be verbose.\n");
  printf("  -V        Display version information.\n");
  printf("  -z        Zero log files.\n");
  printf("\n");
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// end_daemonize
// file server.c line 274
static void end_daemonize(signed int fd)
{
  signed int dev_null;
  signed int return_value_chdir_2;
  return_value_chdir_2=chdir("/");
  if(!(return_value_chdir_2 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    log_err(*return_value___errno_location_1, "Unable to change to root directory");
  }

  dev_null=open("/dev/null", 02);
  if(!(dev_null >= 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    log_err(*return_value___errno_location_3, "Unable to open \"/dev/null\"");
  }

  signed int return_value_dup2_5;
  return_value_dup2_5=dup2(dev_null, 0);
  if(!(return_value_dup2_5 >= 0))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    log_err(*return_value___errno_location_4, "Unable to dup \"/dev/null\" onto stdin");
  }

  signed int return_value_dup2_7;
  return_value_dup2_7=dup2(dev_null, 1);
  if(!(return_value_dup2_7 >= 0))
  {
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    log_err(*return_value___errno_location_6, "Unable to dup \"/dev/null\" onto stdout");
  }

  signed int return_value_dup2_9;
  return_value_dup2_9=dup2(dev_null, 2);
  if(!(return_value_dup2_9 >= 0))
  {
    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    log_err(*return_value___errno_location_8, "Unable to dup \"/dev/null\" onto stderr");
  }

  signed int return_value_close_11;
  return_value_close_11=close(dev_null);
  if(!(return_value_close_11 >= 0))
  {
    signed int *return_value___errno_location_10;
    return_value___errno_location_10=__errno_location();
    log_err(*return_value___errno_location_10, "Unable to close \"/dev/null\"");
  }

  log_set_err_pipe(-1);
  signed int return_value_close_13;
  if(fd >= 0)
  {
    return_value_close_13=close(fd);
    if(!(return_value_close_13 >= 0))
    {
      signed int *return_value___errno_location_12;
      return_value___errno_location_12=__errno_location();
      log_err(*return_value___errno_location_12, "Unable to close write-pipe in grandchild process");
    }

  }

  goto __CPROVER_DUMP_L8;

__CPROVER_DUMP_L8:
  ;
}

// exit_handler
// file server.c line 382
static void exit_handler(signed int signum)
{
  done = signum;
}

// fail_ipmi_connect
// file server-ipmi.c line 988
static void fail_ipmi_connect(struct base_obj *ipmi)
{
  ipmi->aux.ipmi.state = (enum ipmi_connect_state)CONMAN_IPMI_DOWN;
  if(ipmi->aux.ipmi.ctx == ((struct ipmiconsole_ctx *)NULL))
    log_msg(6, "Unable to create IPMI context for [%s]", ipmi->name);

  else
  {
    signed int e;
    e=ipmiconsole_ctx_errnum(ipmi->aux.ipmi.ctx);
    char *return_value_ipmiconsole_ctx_strerror_1;
    return_value_ipmiconsole_ctx_strerror_1=ipmiconsole_ctx_strerror(e);
    log_msg(6, "Unable to connect to <%s> via IPMI for [%s]: %s", ipmi->aux.ipmi.host, ipmi->name, return_value_ipmiconsole_ctx_strerror_1);
  }
  ipmi->aux.ipmi.timer=tpoll_timeout_relative(tp_global, (void (*)(void *))connect_ipmi_obj, (void *)ipmi, ipmi->aux.ipmi.delay * 1000);
  signed int tmp_if_expr_2;
  if(!(ipmi->aux.ipmi.delay >= 1800))
  {
    if(!(2 * ipmi->aux.ipmi.delay >= 1801))
      tmp_if_expr_2 = ipmi->aux.ipmi.delay * 2;

    else
      tmp_if_expr_2 = 1800;
    ipmi->aux.ipmi.delay = tmp_if_expr_2;
  }

}

// find_obj
// file server-obj.c line 476
signed int find_obj(struct base_obj *obj, struct base_obj *key)
{
  return (signed int)(obj == key);
}

// find_trailing_int_str
// file server-obj.c line 459
static char * find_trailing_int_str(char *str)
{
  char *p;
  char *q;
  p = str;
  q = (char *)(void *)0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(p == ((char *)NULL)))
      tmp_if_expr_1 = *p != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    const unsigned short int **return_value___ctype_b_loc_2;
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*p]) == 0)
      q = (char *)(void *)0;

    else
      if(q == ((char *)NULL))
        q = p;

    p = p + 1l;
  }
  while((_Bool)1);
  return q;
}

// format_obj_string
// file server.h line 405
signed int format_obj_string(char *buf, signed int buflen, struct base_obj *obj, const char *fmt)
{
  const char *psrc;
  char *pdst;
  signed int n;
  signed int m;
  signed long int t;
  struct tm tm;
  char *p;
  char *q;
  char c;
  char tfmt[3l] = { '%', '%', 0 };
  char * const pspec = &tfmt[(signed long int)1];
  psrc = fmt;
  pdst = buf;
  n = buflen;
  t = (signed long int)0;
  get_localtime(&t, &tm);
  const char *tmp_post_1;
  _Bool tmp_if_expr_16;
  const char *tmp_post_15;
  char *tmp_post_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_9;
  signed int return_value_getpid_10;
  unsigned long int return_value_strftime_11;
  char *tmp_post_12;
  char *tmp_post_13;
  char *tmp_post_14;
  do
  {
    tmp_post_1 = psrc;
    psrc = psrc + 1l;
    c = *tmp_post_1;
    if((signed int)c == 0)
      break;

    if(!(n >= 1))
      break;

    if(!((signed int)c == 37))
      tmp_if_expr_16 = (_Bool)1;

    else
    {
      tmp_post_15 = psrc;
      psrc = psrc + 1l;
      *pspec = *tmp_post_15;
      tmp_if_expr_16 = (signed int)*pspec == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_16)
    {
      n = n - 1;
      if(n >= 1)
      {
        tmp_post_2 = pdst;
        pdst = pdst + 1l;
        *tmp_post_2 = c;
      }

    }

    else
      switch((signed int)*pspec)
      {
        case 78:
        {
          if(obj == ((struct base_obj *)NULL))
            goto ignore_specifier;

          if((signed int)obj->type == CONMAN_OBJ_TELNET)
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = (signed int)obj->type == CONMAN_OBJ_IPMI ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_4)
            tmp_if_expr_5 = (_Bool)1;

          else
            tmp_if_expr_5 = (signed int)obj->type == CONMAN_OBJ_PROCESS ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_5)
            tmp_if_expr_6 = (_Bool)1;

          else
            tmp_if_expr_6 = (signed int)obj->type == CONMAN_OBJ_SERIAL ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_6)
            tmp_if_expr_7 = (_Bool)1;

          else
            tmp_if_expr_7 = (signed int)obj->type == CONMAN_OBJ_UNIXSOCK ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_7)
          {
            p = obj->name;
            unsigned long int return_value_strlen_3;
            return_value_strlen_3=strlen(p);
            m = (signed int)return_value_strlen_3;
            n = n - m;
            if(n >= 1)
            {
              strcpy(pdst, p);
              sanitize_file_string(pdst);
              pdst = pdst + (signed long int)m;
            }

          }

          break;
        }
        case 68:
        {
          if(obj == ((struct base_obj *)NULL))
            goto ignore_specifier;

          if((signed int)obj->type == CONMAN_OBJ_SERIAL)
            tmp_if_expr_9 = (_Bool)1;

          else
            tmp_if_expr_9 = (signed int)obj->type == CONMAN_OBJ_UNIXSOCK ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_9)
          {
            q = obj->aux.serial.dev;
            p=strrchr(q, 47);
            p = p != ((char *)NULL) ? p + (signed long int)1 : q;
            unsigned long int return_value_strlen_8;
            return_value_strlen_8=strlen(p);
            m = (signed int)return_value_strlen_8;
            n = n - m;
            if(n >= 1)
            {
              strcpy(pdst, p);
              sanitize_file_string(pdst);
              pdst = pdst + (signed long int)m;
            }

          }

          else
            if((signed int)obj->type == CONMAN_OBJ_TELNET)
            {
              m=snprintf(pdst, (unsigned long int)n, "%s:%d", obj->aux.telnet.host, obj->aux.telnet.port);
              if(m >= n || !(m >= 0))
                n = 0;

              else
              {
                sanitize_file_string(pdst);
                n = n - m;
                pdst = pdst + (signed long int)m;
              }
            }

          break;
        }
        case 80:
        {
          return_value_getpid_10=getpid();
          m=snprintf(pdst, (unsigned long int)n, "%d", (signed int)return_value_getpid_10);
          if(m >= n || !(m >= 0))
            n = 0;

          else
          {
            n = n - m;
            pdst = pdst + (signed long int)m;
          }
          break;
        }
        case 89:

        case 121:

        case 109:

        case 100:

        case 72:

        case 77:

        case 83:

        case 115:
        {
          return_value_strftime_11=strftime(pdst, (unsigned long int)n, tfmt, &tm);
          m = (signed int)return_value_strftime_11;
          if(m == 0)
            n = 0;

          else
          {
            n = n - m;
            pdst = pdst + (signed long int)m;
          }
          break;
        }
        case 37:
        {
          n = n - 1;
          if(n >= 1)
          {
            tmp_post_12 = pdst;
            pdst = pdst + 1l;
            *tmp_post_12 = *pspec;
          }

          break;
        }
        default:
        {

        ignore_specifier:
          ;
          n = n - 2;
          if(n >= 1)
          {
            tmp_post_13 = pdst;
            pdst = pdst + 1l;
            *tmp_post_13 = (char)37;
            tmp_post_14 = pdst;
            pdst = pdst + 1l;
            *tmp_post_14 = *pspec;
          }

        }
      }
  }
  while((_Bool)1);
  *pdst = (char)0;
  return (signed int)(n <= 0 ? (signed long int)-1 : pdst - buf);
}

// get_console_logfile_obj
// file server.h line 389
struct base_obj * get_console_logfile_obj(struct base_obj *console)
{
  struct base_obj *logfile = (struct base_obj *)(void *)0;
  if((signed int)console->type == CONMAN_OBJ_PROCESS)
    logfile = console->aux.process.logfile;

  else
    if((signed int)console->type == CONMAN_OBJ_SERIAL)
      logfile = console->aux.serial.logfile;

    else
      if((signed int)console->type == CONMAN_OBJ_TELNET)
        logfile = console->aux.telnet.logfile;

      else
        if((signed int)console->type == CONMAN_OBJ_UNIXSOCK)
          logfile = console->aux.unixsock.logfile;

        else
          if((signed int)console->type == CONMAN_OBJ_IPMI)
            logfile = console->aux.ipmi.logfile;

          else
            log_err(0, "INTERNAL: Unrecognized console [%s] type=%d", console->name, console->type);
  _Bool tmp_if_expr_1;
  if(logfile == ((struct base_obj *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = logfile->fd < 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (struct base_obj *)(void *)0;

  else
    return logfile;
}

// get_dir_name
// file util-file.h line 119
char * get_dir_name(const char *srcpath, char *dstdir, unsigned long int dstdirlen)
{
  const char *p;
  signed int len;
  if(dstdir == ((char *)NULL) || srcpath == ((const char *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return (char *)(void *)0;
  }

  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(srcpath);
  p = (srcpath + (signed long int)return_value_strlen_2) - (signed long int)1;
  for( ; !(srcpath >= p); p = p - 1l)
    if(!((signed int)*p == 47))
      break;

  for( ; p >= srcpath; p = p - 1l)
    if((signed int)*p == 47)
      break;

  for( ; !(srcpath >= p); p = p - 1l)
    if(!((signed int)*p == 47))
      break;

  if(!(p >= srcpath))
  {
    if(!(dstdirlen >= 2ul))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 36;
      return (char *)(void *)0;
    }

    dstdir[(signed long int)0] = (char)46;
    dstdir[(signed long int)1] = (char)0;
  }

  else
  {
    len = (signed int)((p - srcpath) + (signed long int)1);
    if((unsigned long int)len >= dstdirlen || !(len >= 1))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = 36;
      return (char *)(void *)0;
    }

    strncpy(dstdir, srcpath, (unsigned long int)len);
    dstdir[(signed long int)len] = (char)0;
  }
  return dstdir;
}

// get_file_lock
// file util-file.c line 129
static signed int get_file_lock(signed int fd, signed int cmd, signed int type)
{
  struct flock lock;
  lock.l_type = (signed short int)type;
  lock.l_start = (signed long int)0;
  lock.l_whence = (signed short int)0;
  lock.l_len = (signed long int)0;
  signed int return_value_fcntl_1;
  return_value_fcntl_1=fcntl(fd, cmd, &lock);
  return return_value_fcntl_1;
}

// get_host_by_addr
// file util-net.c line 90
struct hostent * get_host_by_addr(const char *addr, signed int len, signed int type, void *buf, signed int buflen, signed int *h_err)
{
  struct hostent *hptr;
  signed int n = 0;
  signed int *return_value___errno_location_1;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_lock(&hostentLock);
    if(!(*return_value___errno_location_2 == 0))
    {
      return_value___errno_location_1=__errno_location();
      log_err(*return_value___errno_location_1, "pthread_mutex_lock() failed");
    }

  }
  while((_Bool)0);
  hptr=gethostbyaddr((const void *)addr, (unsigned int)len, type);
  if(!(hptr == ((struct hostent *)NULL)))
    n=copy_hostent(hptr, (char *)buf, buflen);

  signed int *return_value___h_errno_location_3;
  if(!(h_err == ((signed int *)NULL)))
  {
    return_value___h_errno_location_3=__h_errno_location();
    *h_err = *return_value___h_errno_location_3;
  }

  signed int *return_value___errno_location_4;
  do
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    *return_value___errno_location_5=pthread_mutex_unlock(&hostentLock);
    if(!(*return_value___errno_location_5 == 0))
    {
      return_value___errno_location_4=__errno_location();
      log_err(*return_value___errno_location_4, "pthread_mutex_unlock() failed");
    }

  }
  while((_Bool)0);
  if(!(n >= 0))
  {
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    *return_value___errno_location_6 = 34;
    return (struct hostent *)(void *)0;
  }

  return hptr != ((struct hostent *)NULL) ? (struct hostent *)buf : (struct hostent *)(void *)0;
}

// get_host_by_name
// file util-net.c line 63
struct hostent * get_host_by_name(const char *name, void *buf, signed int buflen, signed int *h_err)
{
  struct hostent *hptr;
  signed int n = 0;
  signed int *return_value___errno_location_1;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_lock(&hostentLock);
    if(!(*return_value___errno_location_2 == 0))
    {
      return_value___errno_location_1=__errno_location();
      log_err(*return_value___errno_location_1, "pthread_mutex_lock() failed");
    }

  }
  while((_Bool)0);
  hptr=gethostbyname(name);
  if(!(hptr == ((struct hostent *)NULL)))
    n=copy_hostent(hptr, (char *)buf, buflen);

  signed int *return_value___h_errno_location_3;
  if(!(h_err == ((signed int *)NULL)))
  {
    return_value___h_errno_location_3=__h_errno_location();
    *h_err = *return_value___h_errno_location_3;
  }

  signed int *return_value___errno_location_4;
  do
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    *return_value___errno_location_5=pthread_mutex_unlock(&hostentLock);
    if(!(*return_value___errno_location_5 == 0))
    {
      return_value___errno_location_4=__errno_location();
      log_err(*return_value___errno_location_4, "pthread_mutex_unlock() failed");
    }

  }
  while((_Bool)0);
  if(!(n >= 0))
  {
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    *return_value___errno_location_6 = 34;
    return (struct hostent *)(void *)0;
  }

  return hptr != ((struct hostent *)NULL) ? (struct hostent *)buf : (struct hostent *)(void *)0;
}

// get_localtime
// file util-str.h line 140
struct tm * get_localtime(signed long int *tPtr, struct tm *tmPtr)
{
  if(*tPtr == 0l)
  {
    signed long int return_value_time_2;
    return_value_time_2=time(tPtr);
    if(return_value_time_2 == -1l)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      log_err(*return_value___errno_location_1, "time() failed");
    }

  }

  struct tm *return_value_localtime_r_4;
  return_value_localtime_r_4=localtime_r(tPtr, tmPtr);
  if(return_value_localtime_r_4 == ((struct tm *)NULL))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    log_err(*return_value___errno_location_3, "localtime_r() failed");
  }

  return tmPtr;
}

// get_read_lock
// file util-file.h line 53
signed int get_read_lock(signed int fd)
{
  signed int return_value_get_file_lock_1;
  return_value_get_file_lock_1=get_file_lock(fd, 6, 0);
  return return_value_get_file_lock_1;
}

// get_readw_lock
// file util-file.c line 93
signed int get_readw_lock(signed int fd)
{
  signed int return_value_get_file_lock_1;
  return_value_get_file_lock_1=get_file_lock(fd, 7, 0);
  return return_value_get_file_lock_1;
}

// get_sane_env
// file server.c line 410
static char ** get_sane_env(void)
{
  signed int env_num;
  signed int env_len;
  char **pp;
  char *p;
  char **env;
  char *ptr;
  signed int num;
  signed int len;
  char *env_restrict[4l] = { "IFS= \t\n", "PATH=/usr/bin:/bin:/usr/sbin:/sbin", "TERM=dumb", (char *)(void *)0 };
  char *env_preserve[3l] = { "DEBUG", "TZ", (char *)(void *)0 };
  env_num = 1;
  env_len = 0;
  pp = env_restrict;
  for( ; !(*pp == ((char *)NULL)); pp = pp + 1l)
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(*pp);
    env_len = env_len + (signed int)(return_value_strlen_1 + (unsigned long int)1);
    env_num = env_num + 1;
  }
  pp = env_preserve;
  for( ; !(*pp == ((char *)NULL)); pp = pp + 1l)
  {
    p=getenv(*pp);
    if(!(p == ((char *)NULL)))
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(*pp);
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(p);
      env_len = env_len + (signed int)(return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)2);
      env_num = env_num + 1;
    }

  }
  env_len = env_len + (signed int)((unsigned long int)env_num * sizeof(char *) /*8ul*/ );
  void *return_value_malloc_4;
  return_value_malloc_4=malloc((unsigned long int)env_len);
  env = (char **)return_value_malloc_4;
  signed int tmp_post_5;
  signed int tmp_post_7;
  char *tmp_post_9;
  signed int tmp_post_11;
  if(env == ((char **)NULL))
    return (char **)(void *)0;

  else
  {
    ptr = (char *)env + (signed long int)((unsigned long int)env_num * sizeof(char *) /*8ul*/ );
    num = 0;
    pp = env_restrict;
    for( ; !(*pp == ((char *)NULL)); pp = pp + 1l)
    {
      tmp_post_5 = num;
      num = num + 1;
      env[(signed long int)tmp_post_5] = ptr;
      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(*pp);
      len = (signed int)(return_value_strlen_6 + (unsigned long int)1);
      memcpy((void *)ptr, (const void *)*pp, (unsigned long int)len);
      ptr = ptr + (signed long int)len;
    }
    pp = env_preserve;
    for( ; !(*pp == ((char *)NULL)); pp = pp + 1l)
    {
      p=getenv(*pp);
      if(!(p == ((char *)NULL)))
      {
        tmp_post_7 = num;
        num = num + 1;
        env[(signed long int)tmp_post_7] = ptr;
        unsigned long int return_value_strlen_8;
        return_value_strlen_8=strlen(*pp);
        len = (signed int)return_value_strlen_8;
        memcpy((void *)ptr, (const void *)*pp, (unsigned long int)len);
        ptr = ptr + (signed long int)len;
        tmp_post_9 = ptr;
        ptr = ptr + 1l;
        *tmp_post_9 = (char)61;
        unsigned long int return_value_strlen_10;
        return_value_strlen_10=strlen(p);
        len = (signed int)(return_value_strlen_10 + (unsigned long int)1);
        memcpy((void *)ptr, (const void *)p, (unsigned long int)len);
        ptr = ptr + (signed long int)len;
      }

    }
    tmp_post_11 = num;
    num = num + 1;
    env[(signed long int)tmp_post_11] = (char *)(void *)0;
    return env;
  }
}

// get_tty_mode
// file common.h line 200
void get_tty_mode(struct termios *tty, signed int fd)
{
  signed int return_value_isatty_1;
  return_value_isatty_1=isatty(fd);
  signed int *return_value___errno_location_2;
  if(!(return_value_isatty_1 == 0))
  {
    signed int return_value_tcgetattr_3;
    return_value_tcgetattr_3=tcgetattr(fd, tty);
    if(!(return_value_tcgetattr_3 >= 0))
    {
      return_value___errno_location_2=__errno_location();
      log_err(*return_value___errno_location_2, "tcgetattr() failed on fd=%d", fd);
    }

    goto __CPROVER_DUMP_L2;
  }


__CPROVER_DUMP_L2:
  ;
}

// get_tty_raw
// file common.h line 204
void get_tty_raw(struct termios *tty, signed int fd)
{
  get_tty_mode(tty, fd);
  tty->c_iflag = tty->c_iflag & (unsigned int)~(0000002 | 0000400 | 0000020 | 0000040 | 0002000);
  tty->c_oflag = tty->c_oflag & (unsigned int)~0000001;
  tty->c_cflag = tty->c_cflag & (unsigned int)~0000060;
  tty->c_cflag = tty->c_cflag | (unsigned int)0000060;
  tty->c_cflag = tty->c_cflag & (unsigned int)~0000400;
  tty->c_cflag = tty->c_cflag | (unsigned int)0004000;
  tty->c_lflag = tty->c_lflag & (unsigned int)~(0000010 | 0001000 | 0000002 | 0100000 | 0000001);
  tty->c_cc[(signed long int)6] = (unsigned char)1;
  tty->c_cc[(signed long int)5] = (unsigned char)0;
}

// get_write_lock
// file util-file.h line 66
signed int get_write_lock(signed int fd)
{
  signed int return_value_get_file_lock_1;
  return_value_get_file_lock_1=get_file_lock(fd, 6, 1);
  return return_value_get_file_lock_1;
}

// get_writew_lock
// file util-file.c line 105
signed int get_writew_lock(signed int fd)
{
  signed int return_value_get_file_lock_1;
  return_value_get_file_lock_1=get_file_lock(fd, 7, 1);
  return return_value_get_file_lock_1;
}

// host_addr4_to_name
// file util-net.h line 75
char * host_addr4_to_name(struct in_addr *addr, char *dst, signed int dstlen)
{
  struct hostent *hptr;
  unsigned char buf[8192l];
  hptr=get_host_by_addr((char *)addr, 4, 2, (void *)buf, (signed int)sizeof(unsigned char [8192l]) /*8192ul*/ , (signed int *)(void *)0);
  if(hptr == ((struct hostent *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(hptr->h_name);
    if(return_value_strlen_2 >= (unsigned long int)dstlen)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 34;
      return (char *)(void *)0;
    }

    strcpy(dst, hptr->h_name);
    return dst;
  }
}

// host_name_to_addr4
// file util-net.h line 68
signed int host_name_to_addr4(const char *name, struct in_addr *addr)
{
  struct hostent *hptr;
  unsigned char buf[8192l];
  hptr=get_host_by_name(name, (void *)buf, (signed int)sizeof(unsigned char [8192l]) /*8192ul*/ , (signed int *)(void *)0);
  if(hptr == ((struct hostent *)NULL))
    return -1;

  else
  {
    if(hptr->h_length >= 5)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 34;
      return -1;
    }

    memcpy((void *)addr, (const void *)hptr->h_addr_list[(signed long int)0], (unsigned long int)hptr->h_length);
    return 0;
  }
}

// host_name_to_cname
// file util-net.c line 170
char * host_name_to_cname(const char *src, char *dst, signed int dstlen)
{
  struct hostent *hptr;
  unsigned char buf[8192l];
  struct in_addr addr;
  hptr=get_host_by_name(src, (void *)buf, (signed int)sizeof(unsigned char [8192l]) /*8192ul*/ , (signed int *)(void *)0);
  if(hptr == ((struct hostent *)NULL))
    return (char *)(void *)0;

  else
  {
    memcpy((void *)&addr, (const void *)hptr->h_addr_list[(signed long int)0], (unsigned long int)hptr->h_length);
    hptr=get_host_by_addr((char *)&addr, 4, 2, (void *)buf, (signed int)sizeof(unsigned char [8192l]) /*8192ul*/ , (signed int *)(void *)0);
    if(hptr == ((struct hostent *)NULL))
      return (char *)(void *)0;

    else
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(hptr->h_name);
      if(return_value_strlen_2 >= (unsigned long int)dstlen)
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = 34;
        return (char *)(void *)0;
      }

      strcpy(dst, hptr->h_name);
      return dst;
    }
  }
}

// host_strerror
// file util-net.c line 117
const char * host_strerror(signed int h_err)
{
  if(h_err == 1)
    return "Unknown host";

  else
    if(h_err == 2)
      return "Transient host name lookup failure";

    else
      if(h_err == 3)
        return "Unknown server error";

      else
        if(h_err == 4)
          return "No address associated with name";

  return "Unknown error";
}

// inevent_add
// file inevent.h line 45
signed int inevent_add(const char *pathname, void (*cb_fnc)(void *), void *cb_arg)
{
  struct inevent *inevent_ptr;
  if(pathname == ((const char *)NULL))
  {
    log_msg(3, "inotify event pathname not specified");
    return -1;
  }

  else
    if(cb_fnc == ((void (*)(void *))NULL))
    {
      log_msg(3, "inotify event callback not specified");
      return -1;
    }

    else
      if(!((signed int)*pathname == 47))
      {
        log_msg(3, "inotify event path \"%s\" is not absolute", pathname);
        return -1;
      }

      else
      {
        if(inevent_fd == -1)
        {
          signed int return_value__inevent_init_3;
          return_value__inevent_init_3=_inevent_init();
          if(!(return_value__inevent_init_3 >= 0))
          {
            signed int *return_value___errno_location_1;
            return_value___errno_location_1=__errno_location();
            char *return_value_strerror_2;
            return_value_strerror_2=strerror(*return_value___errno_location_1);
            log_msg(3, "unable to initialize inotify: %s", return_value_strerror_2);
            return -1;
          }

        }

        void *return_value_list_find_first_4;
        return_value_list_find_first_4=list_find_first(inevent_list, (signed int (*)(void *, void *))_list_find_by_path, (void *)pathname);
        if(!(return_value_list_find_first_4 == NULL))
        {
          log_msg(3, "inotify event path \"%s\" already specified", pathname);
          return -1;
        }

        else
        {
          inevent_ptr=_inevent_create(pathname, cb_fnc, cb_arg);
          if(inevent_ptr == ((struct inevent *)NULL))
            return -1;

          else
          {
            list_append(inevent_list, (void *)inevent_ptr);
            return 0;
          }
        }
      }
}

// inevent_get_fd
// file inevent.h line 49
signed int inevent_get_fd(void)
{
  return inevent_fd;
}

// inevent_process
// file inevent.h line 51
signed int inevent_process(void)
{
  char buf[(signed long int)(sizeof(struct inotify_event) * 256) /*4096l*/ ];
  signed int len;
  signed int n = 0;
  signed long int return_value_read_1;
  signed int *return_value___errno_location_2;
  if(inevent_fd == -1)
    return -1;

  else
  {
    do
    {

    retry_read:
      ;
      return_value_read_1=read(inevent_fd, (void *)buf, sizeof(char [4096l]) /*4096ul*/ );
      len = (signed int)return_value_read_1;
      if(len >= 0)
        goto __CPROVER_DUMP_L2;

      return_value___errno_location_2=__errno_location();
    }
    while(*return_value___errno_location_2 == 4);
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    log_msg(3, "unable to read inotify fd: %s", return_value_strerror_4);
    return -1;

  __CPROVER_DUMP_L2:
    ;
    if(len == 0)
    {
      log_msg(3, "inotify read buffer is too small");
      return -1;
    }

    else
    {
      unsigned int i = (unsigned int)0;
      unsigned int event_mask = (unsigned int)(0x00000100 | 0x00000080);
      while(!(i >= (unsigned int)len))
      {
        struct inotify_event *event_ptr;
        struct inevent *inevent_ptr;
        event_ptr = (struct inotify_event *)&buf[(signed long int)i];
        if(!((32768u & event_ptr->mask) == 0u))
          list_delete_all(inevent_list, (signed int (*)(void *, void *))_list_find_by_wd, (void *)&event_ptr->wd);

        else
          if(!((event_ptr->mask & event_mask) == 0u))
          {
            if(event_ptr->len >= 1u)
            {
              void *return_value_list_find_first_5;
              return_value_list_find_first_5=list_find_first(inevent_list, (signed int (*)(void *, void *))_list_find_by_event, (void *)event_ptr);
              inevent_ptr = (struct inevent *)return_value_list_find_first_5;
              if(!(inevent_ptr == ((struct inevent *)NULL)))
              {
                if(!(inevent_ptr->cb_fnc == ((void (*)(void *))NULL)))
                  inevent_ptr->cb_fnc(inevent_ptr->cb_arg);

              }

            }

          }

        i = i + (unsigned int)(sizeof(struct inotify_event) /*16ul*/  + (unsigned long int)event_ptr->len);
        n = n + 1;
      }
    }
    return n;
  }
}

// inevent_remove
// file inevent.h line 47
signed int inevent_remove(const char *pathname)
{
  struct listIterator *li = (struct listIterator *)(void *)0;
  struct inevent *inevent_ptr;
  signed int wd_cnt;
  void *return_value_list_find_2;
  if(pathname == ((const char *)NULL))
    return 0;

  else
    if(inevent_list == ((struct list *)NULL))
      return 0;

    else
    {
      li=list_iterator_create(inevent_list);
      void *return_value_list_find_1;
      return_value_list_find_1=list_find(li, (signed int (*)(void *, void *))_list_find_by_path, (void *)pathname);
      inevent_ptr = (struct inevent *)return_value_list_find_1;
      if(inevent_ptr == ((struct inevent *)NULL))
      {
        log_msg(3, "inotify event path \"%s\" not registered", pathname);
        list_iterator_destroy(li);
        return 0;
      }

      else
      {
        list_remove(li);
        list_iterator_reset(li);
        wd_cnt = 0;
        do
        {
          return_value_list_find_2=list_find(li, (signed int (*)(void *, void *))_list_find_by_wd, (void *)&inevent_ptr->wd);
          if(return_value_list_find_2 == NULL)
            break;

          wd_cnt = wd_cnt + 1;
        }
        while((_Bool)1);
        list_iterator_destroy(li);
        if(inevent_ptr->wd >= 0)
        {
          if(wd_cnt == 0)
            inotify_rm_watch(inevent_fd, inevent_ptr->wd);

        }

        _inevent_destroy(inevent_ptr);
        signed int return_value_list_is_empty_3;
        return_value_list_is_empty_3=list_is_empty(inevent_list);
        if(!(return_value_list_is_empty_3 == 0))
          _inevent_fini();

        return 0;
      }
    }
}

// init_ipmi_opts
// file server.h line 364
signed int init_ipmi_opts(struct ipmi_opt *iopts)
{
  if(iopts == ((struct ipmi_opt *)NULL))
    return -1;

  else
  {
    memset((void *)iopts, 0, sizeof(struct ipmi_opt) /*76ul*/ );
    iopts->privilegeLevel = -1;
    iopts->cipherSuite = -1;
    iopts->workaroundFlags = (unsigned int)0;
    return 0;
  }
}

// initiate_ipmi_connect
// file server-ipmi.c line 859
static signed int initiate_ipmi_connect(struct base_obj *ipmi)
{
  signed int rc;
  signed int return_value_create_ipmi_ctx_1;
  return_value_create_ipmi_ctx_1=create_ipmi_ctx(ipmi);
  if(!(return_value_create_ipmi_ctx_1 >= 0))
    return -1;

  else
  {
    rc=ipmiconsole_engine_submit(ipmi->aux.ipmi.ctx, (void (*)(void *))connect_ipmi_obj, (void *)ipmi);
    if(!(rc >= 0))
      return -1;

    else
    {
      ipmi->aux.ipmi.state = (enum ipmi_connect_state)CONMAN_IPMI_PENDING;
      ipmi->aux.ipmi.timer=tpoll_timeout_relative(tp_global, (void (*)(void *))connect_ipmi_obj, (void *)ipmi, 300 * 1000);
      return 0;
    }
  }
}

// int_to_bps
// file server-serial.c line 206
static unsigned int int_to_bps(signed int val)
{
  struct bps_tag *tag;
  unsigned int bps = (unsigned int)0;
  tag = bps_table;
  for( ; tag->val >= 1; tag = tag + 1l)
    if(val >= tag->val)
      bps = tag->bps;

    else
      break;
  return bps;
}

// ipmi_fini
// file server.h line 360
void ipmi_fini(void)
{
  signed int do_sol_session_cleanup = 1;
  if(!(is_ipmi_engine_started == 0))
  {
    ipmiconsole_engine_teardown(do_sol_session_cleanup);
    is_ipmi_engine_started = 0;
    goto __CPROVER_DUMP_L2;
  }


__CPROVER_DUMP_L2:
  ;
}

// ipmi_init
// file server.h line 358
void ipmi_init(signed int num_consoles)
{
  signed int num_threads;
  if(num_consoles >= 1)
  {
    if(is_ipmi_engine_started == 0)
    {
      num_threads = (num_consoles - 1) / 128 + 1;
      signed int return_value_ipmiconsole_engine_init_1;
      return_value_ipmiconsole_engine_init_1=ipmiconsole_engine_init((unsigned int)num_threads, (unsigned int)0);
      if(!(return_value_ipmiconsole_engine_init_1 >= 0))
        log_err(0, "Unable to start IPMI SOL engine");

      else
        log_msg(6, "IPMI SOL engine started with %d thread%s for %d console%s", num_threads, num_threads == 1 ? "" : "s", num_consoles, num_consoles == 1 ? "" : "s");
      is_ipmi_engine_started = 1;
      goto __CPROVER_DUMP_L5;
    }

  }


__CPROVER_DUMP_L5:
  ;
}

// is_empty_string
// file util-str.h line 63
signed int is_empty_string(const char *str)
{
  if(str == ((const char *)NULL))
    return -1;

  else
  {
    for( ; !(*str == 0); str = str + 1l)
    {
      const unsigned short int **return_value___ctype_b_loc_1;
      return_value___ctype_b_loc_1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*str]) == 0)
        return 0;

    }
    return 1;
  }
}

// is_ipmi_dev
// file server.h line 362
signed int is_ipmi_dev(const char *dev, char **host_ref)
{
  const char * const prefix = "ipmi:";
  if(dev == ((const char *)NULL))
    return 0;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(prefix);
    signed int return_value_strncasecmp_2;
    return_value_strncasecmp_2=strncasecmp(dev, prefix, return_value_strlen_1);
    if(!(return_value_strncasecmp_2 == 0))
      return 0;

    else
    {
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(prefix);
      dev = dev + (signed long int)return_value_strlen_3;
      if((signed int)*dev == 0)
        return 0;

      else
      {
        if(!(host_ref == ((char **)NULL)))
          *host_ref=create_string(dev);

        return 1;
      }
    }
  }
}

// is_ipmi_opt_tag
// file server-ipmi.c line 329
static signed int is_ipmi_opt_tag(const char *str)
{
  _Bool tmp_if_expr_1;
  if(str == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)str[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)str[(signed long int)1] != 58 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
    return 0;

  else
  {
    signed int return_value_toupper_3;
    return_value_toupper_3=toupper((signed int)str[(signed long int)0]);
    if(return_value_toupper_3 == 67 || return_value_toupper_3 == 75 || return_value_toupper_3 == 76 || return_value_toupper_3 == 80 || return_value_toupper_3 == 85 || return_value_toupper_3 == 87)
      return 1;

    return 0;
  }
}

// is_process_dev
// file server.h line 432
signed int is_process_dev(const char *dev, const char *cwd, const char *exec_path, char **path_ref)
{
  char buf[4096l];
  signed int n;
  struct stat st;
  char *return_value_strchr_1;
  return_value_strchr_1=strchr(dev, 47);
  _Bool tmp_if_expr_3;
  signed int return_value_search_exec_path_2;
  if(return_value_strchr_1 == ((char *)NULL))
  {
    return_value_search_exec_path_2=search_exec_path(exec_path, dev, buf, (signed int)sizeof(char [4096l]) /*4096ul*/ );
    tmp_if_expr_3 = return_value_search_exec_path_2 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  if(tmp_if_expr_3)
    dev = buf;

  else
    if(!((signed int)*dev == 47))
    {
      if(!(cwd == ((const char *)NULL)))
      {
        n=snprintf(buf, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", cwd, dev);
        if((unsigned long int)n >= sizeof(char [4096l]) /*4096ul*/  || !(n >= 0))
          return 0;

        dev = buf;
      }

    }

  signed int return_value_stat_4;
  return_value_stat_4=stat(dev, &st);
  if(!(return_value_stat_4 >= 0))
    return 0;

  else
    if(!((61440u & st.st_mode) == 32768u))
      return 0;

    else
    {
      signed int return_value_access_5;
      return_value_access_5=access(dev, 1);
      if(!(return_value_access_5 >= 0))
        return 0;

      else
      {
        if(!(path_ref == ((char **)NULL)))
          *path_ref=create_string(dev);

        return 1;
      }
    }
}

// is_read_lock_blocked
// file util-file.c line 117
signed int is_read_lock_blocked(signed int fd)
{
  signed int return_value_test_file_lock_1;
  return_value_test_file_lock_1=test_file_lock(fd, 0);
  return return_value_test_file_lock_1;
}

// is_serial_dev
// file server.h line 443
signed int is_serial_dev(const char *dev, const char *cwd, char **path_ref)
{
  char buf[4096l];
  signed int n;
  struct stat st;
  if(!((signed int)*dev == 47))
  {
    if(!(cwd == ((const char *)NULL)))
    {
      n=snprintf(buf, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", cwd, dev);
      if((unsigned long int)n >= sizeof(char [4096l]) /*4096ul*/  || !(n >= 0))
        return 0;

      dev = buf;
    }

  }

  signed int return_value_stat_1;
  return_value_stat_1=stat(dev, &st);
  if(!(return_value_stat_1 >= 0))
    return 0;

  else
    if(!((61440u & st.st_mode) == 8192u))
      return 0;

    else
    {
      if(!(path_ref == ((char **)NULL)))
        *path_ref=create_string(dev);

      return 1;
    }
}

// is_telnet_dev
// file server.h line 463
signed int is_telnet_dev(const char *dev, char **host_ref, signed int *port_ref)
{
  char buf[1024l];
  char *p;
  signed int n;
  unsigned long int return_value_strlcpy_1;
  return_value_strlcpy_1=strlcpy(buf, dev, sizeof(char [1024l]) /*1024ul*/ );
  char *tmp_post_3;
  if(return_value_strlcpy_1 >= sizeof(char [1024l]) /*1024ul*/ )
    return 0;

  else
  {
    p=strchr(buf, 58);
    if(p == ((char *)NULL))
      return 0;

    else
    {
      unsigned long int return_value_strspn_2;
      return_value_strspn_2=strspn(p + (signed long int)1, "0123456789");
      n = (signed int)return_value_strspn_2;
      if(n == 0)
        return 0;

      else
        if(!((signed int)p[(signed long int)(1 + n)] == 0))
          return 0;

        else
        {
          tmp_post_3 = p;
          p = p + 1l;
          *tmp_post_3 = (char)0;
          if(!(host_ref == ((char **)NULL)))
            *host_ref=create_string(buf);

          if(!(port_ref == ((signed int *)NULL)))
            *port_ref=atoi(p);

          return 1;
        }
    }
  }
}

// is_unixsock_dev
// file server.h line 477
signed int is_unixsock_dev(const char *dev, const char *cwd, char **path_ref)
{
  const char *prefix = "unix:";
  signed int n;
  char buf[4096l];
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(prefix);
  signed int return_value_strncasecmp_2;
  return_value_strncasecmp_2=strncasecmp(dev, prefix, return_value_strlen_1);
  if(!(return_value_strncasecmp_2 == 0))
    return 0;

  else
  {
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(prefix);
    dev = dev + (signed long int)return_value_strlen_3;
    if((signed int)*dev == 0)
      return 0;

    else
    {
      if(!((signed int)*dev == 47))
      {
        if(!(cwd == ((const char *)NULL)))
        {
          n=snprintf(buf, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", cwd, dev);
          if((unsigned long int)n >= sizeof(char [4096l]) /*4096ul*/  || !(n >= 0))
            return 0;

          dev = buf;
        }

      }

      if(!(path_ref == ((char **)NULL)))
        *path_ref=create_string(dev);

      return 1;
    }
  }
}

// is_write_lock_blocked
// file util-file.h line 92
signed int is_write_lock_blocked(signed int fd)
{
  signed int return_value_test_file_lock_1;
  return_value_test_file_lock_1=test_file_lock(fd, 1);
  return return_value_test_file_lock_1;
}

// kill_console_reset
// file server.c line 1120
static void kill_console_reset(signed int *arg)
{
  signed int pid = *arg;
  free((void *)arg);
  signed int return_value_kill_1;
  return_value_kill_1=kill(pid, 0);
  if(return_value_kill_1 >= 0)
  {
    signed int return_value_kill_2;
    return_value_kill_2=kill(-pid, 9);
    if(return_value_kill_2 == 0)
      log_msg(5, "ResetCmd process pid=%d exceeded %ds time limit", (signed int)pid, 60);

    goto __CPROVER_DUMP_L3;
  }


__CPROVER_DUMP_L3:
  ;
}

// lex_create
// file lex.h line 104
struct lexer_state * lex_create(void *buf, char **toks)
{
  struct lexer_state *l;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct lexer_state) /*1056ul*/ );
  l = (struct lexer_state *)return_value_malloc_1;
  if(l == ((struct lexer_state *)NULL))
  {
    log_err(0, "Out of memory");
    return (struct lexer_state *)(void *)0;
  }

  else
  {
    l->pos = (char *)buf;
    l->toks = toks;
    if(toks == ((char **)NULL))
      l->numtoks = 0;

    else
    {
      signed int n = 0;
      for( ; !(toks[(signed long int)n] == ((char *)NULL)); n = n + 1)
        ;
      l->numtoks = n;
    }
    l->text[(signed long int)0] = (char)0;
    l->prev = 0;
    l->line = 0;
    l->gotEOL = 1;
    return l;
  }
}

// lex_decode
// file lex.h line 159
char * lex_decode(char *str)
{
  char *p;
  if(str == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    p = str;
    for( ; !(*p == 0); p = p + 1l)
      *p = *p & (char)0x7F;
    return str;
  }
}

// lex_destroy
// file lex.h line 116
void lex_destroy(struct lexer_state *l)
{
  free((void *)l);
}

// lex_encode
// file lex.h line 151
char * lex_encode(char *str)
{
  char *p;
  _Bool tmp_if_expr_1;
  if(str == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    p = str;
    for( ; !(*p == 0); p = p + 1l)
    {
      if((signed int)*p == 39)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = (signed int)*p == 34 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        *p = *p | (char)0x80;

    }
    return str;
  }
}

// lex_line
// file lex.h line 136
signed int lex_line(struct lexer_state *l)
{
  return l->line;
}

// lex_next
// file lex.h line 121
signed int lex_next(struct lexer_state *l)
{
  char *p;
  signed int len;
  if(!(l->gotEOL == 0))
  {
    l->line = l->line + 1;
    l->gotEOL = 0;
  }

  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  char *tmp_post_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  signed long int tmp_if_expr_7;
  const unsigned short int **return_value___ctype_b_loc_20;
  _Bool tmp_if_expr_21;
  _Bool tmp_if_expr_10;
  const unsigned short int **return_value___ctype_b_loc_8;
  _Bool tmp_if_expr_9;
  signed long int tmp_if_expr_11;
  const unsigned short int **return_value___ctype_b_loc_15;
  _Bool tmp_if_expr_19;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_18;
  const unsigned short int **return_value___ctype_b_loc_17;
  _Bool tmp_if_expr_13;
  const unsigned short int **return_value___ctype_b_loc_12;
  signed long int tmp_if_expr_14;
  char *tmp_post_22;
  while((_Bool)1)
    switch((signed int)*l->pos)
    {
      case 0:
      {
        l->text[(signed long int)0] = (char)0;
        l->prev = 0;
        return l->prev;
      }
      case 32:

      case 9:

      case 11:

      case 12:
      {
        l->pos = l->pos + 1l;
        break;
      }
      case 35:
      {
        do
        {
          l->pos = l->pos + 1l;
          if(!(*l->pos == 0))
            tmp_if_expr_1 = (signed int)*l->pos != 10 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_1 = (_Bool)0;
          if(tmp_if_expr_1)
            tmp_if_expr_2 = (signed int)*l->pos != 13 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_2 = (_Bool)0;
        }
        while(tmp_if_expr_2);
        break;
      }
      case 13:
        if((signed int)l->pos[1l] == 10)
          l->pos = l->pos + 1l;

      case 10:
      {
        tmp_post_3 = l->pos;
        l->pos = l->pos + 1l;
        l->text[(signed long int)0] = *tmp_post_3;
        l->text[(signed long int)1] = (char)0;
        l->gotEOL = 1;
        l->prev = 256;
        return l->prev;
      }
      case 34:

      case 39:
      {
        p = l->pos + (signed long int)1;
        do
        {
          if(!(*p == 0))
            tmp_if_expr_4 = *p != *l->pos ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(tmp_if_expr_4)
            tmp_if_expr_5 = (signed int)*p != 13 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_5 = (_Bool)0;
          if(tmp_if_expr_5)
            tmp_if_expr_6 = (signed int)*p != 10 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_6 = (_Bool)0;
          if(!tmp_if_expr_6)
            break;

          p = p + 1l;
        }
        while((_Bool)1);
        if(*p == *l->pos)
        {
          if(!((p - l->pos) + -1l >= 1024l))
            tmp_if_expr_7 = (p - l->pos) - (signed long int)1;

          else
            tmp_if_expr_7 = (signed long int)(1024 - 1);
          len = (signed int)tmp_if_expr_7;
          memcpy((void *)l->text, (const void *)(l->pos + (signed long int)1), (unsigned long int)len);
          l->text[(signed long int)len] = (char)0;
          l->pos = p + (signed long int)1;
          l->prev = 258;
          return l->prev;
        }

        else
        {
          l->text[(signed long int)0] = (char)0;
          l->pos = p;
          l->prev = -1;
          return l->prev;
        }
      }
      case 92:
        if((signed int)l->pos[1l] == 10)
        {
          l->pos = l->pos + (signed long int)2;
          l->line = l->line + 1;
          break;
        }

        else
          if((signed int)l->pos[1l] == 13)
          {
            if((signed int)l->pos[2l] == 10)
            {
              l->pos = l->pos + (signed long int)3;
              l->line = l->line + 1;
              break;
            }

          }

      default:
      {
        return_value___ctype_b_loc_20=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc_20)[(signed long int)(signed int)*l->pos]) == 0))
          tmp_if_expr_21 = (_Bool)1;

        else
          tmp_if_expr_21 = (signed int)*l->pos == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_21)
        {
          p = l->pos + (signed long int)1;
          do
          {
            if(!(*p == 0))
            {
              return_value___ctype_b_loc_8=__ctype_b_loc();
              if(!((8 & (signed int)(*return_value___ctype_b_loc_8)[(signed long int)(signed int)*p]) == 0))
                tmp_if_expr_9 = (_Bool)1;

              else
                tmp_if_expr_9 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
              tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_10 = (_Bool)0;
            if(!tmp_if_expr_10)
              break;

            p = p + 1l;
          }
          while((_Bool)1);
          if(!(p - l->pos >= 1024l))
            tmp_if_expr_11 = p - l->pos;

          else
            tmp_if_expr_11 = (signed long int)(1024 - 1);
          len = (signed int)tmp_if_expr_11;
          memcpy((void *)l->text, (const void *)l->pos, (unsigned long int)len);
          l->text[(signed long int)len] = (char)0;
          l->pos = p;
          l->prev=lookup_token(l->text, l->toks, l->numtoks);
          return l->prev;
        }

        else
        {
          return_value___ctype_b_loc_15=__ctype_b_loc();
          if(!((2048 & (signed int)(*return_value___ctype_b_loc_15)[(signed long int)(signed int)*l->pos]) == 0))
            tmp_if_expr_19 = (_Bool)1;

          else
          {
            if((signed int)*l->pos == 45)
              tmp_if_expr_16 = (_Bool)1;

            else
              tmp_if_expr_16 = (signed int)*l->pos == 43 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_16)
            {
              return_value___ctype_b_loc_17=__ctype_b_loc();
              tmp_if_expr_18 = ((signed int)(*return_value___ctype_b_loc_17)[(signed long int)(signed int)l->pos[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_18 = (_Bool)0;
            tmp_if_expr_19 = tmp_if_expr_18 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_19)
          {
            p = l->pos + (signed long int)1;
            do
            {
              if(!(*p == 0))
              {
                return_value___ctype_b_loc_12=__ctype_b_loc();
                tmp_if_expr_13 = ((signed int)(*return_value___ctype_b_loc_12)[(signed long int)(signed int)*p] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_13 = (_Bool)0;
              if(!tmp_if_expr_13)
                break;

              p = p + 1l;
            }
            while((_Bool)1);
            if(!(p - l->pos >= 1024l))
              tmp_if_expr_14 = p - l->pos;

            else
              tmp_if_expr_14 = (signed long int)(1024 - 1);
            len = (signed int)tmp_if_expr_14;
            memcpy((void *)l->text, (const void *)l->pos, (unsigned long int)len);
            l->text[(signed long int)len] = (char)0;
            l->pos = p;
            l->prev = 257;
            return l->prev;
          }

        }
        tmp_post_22 = l->pos;
        l->pos = l->pos + 1l;
        l->text[(signed long int)0] = *tmp_post_22;
        l->text[(signed long int)1] = (char)0;
        l->prev = (signed int)l->text[(signed long int)0];
        return l->prev;
      }
    }
}

// lex_parse_test
// file lex.c line 358
void lex_parse_test(char *buf, char **toks)
{
  struct lexer_state *l;
  signed int tok;
  signed int newline = 1;
  _Bool tmp_if_expr_1;
  if(buf == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    l=lex_create((void *)buf, toks);
    tmp_if_expr_1 = !(l != ((struct lexer_state *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  const char *return_value_lex_text_3;
  signed int return_value_atoi_4;
  const char *return_value_lex_text_5;
  const char *return_value_lex_text_6;
  signed int return_value_lex_line_7;
  signed int return_value_lex_prev_8;
  const char *return_value_lex_text_9;
  if(!tmp_if_expr_1)
  {
    do
    {
      tok=lex_next(l);
      if(tok == 0)
        break;

      if(!(newline == 0))
      {
        signed int return_value_lex_line_2;
        return_value_lex_line_2=lex_line(l);
        printf("%3d: ", return_value_lex_line_2);
        newline = 0;
      }

      switch(tok)
      {
        case -1:
        {
          printf("ERR\n");
          newline = 1;
          break;
        }
        case 256:
        {
          printf("EOL\n");
          newline = 1;
          break;
        }
        case 257:
        {
          return_value_lex_text_3=lex_text(l);
          return_value_atoi_4=atoi(return_value_lex_text_3);
          printf("INT(%d) ", return_value_atoi_4);
          break;
        }
        case 258:
        {
          return_value_lex_text_5=lex_text(l);
          printf("STR(%s) ", return_value_lex_text_5);
          break;
        }
        default:
          if(!(tok >= 259))
          {
            return_value_lex_text_6=lex_text(l);
            printf("CHR(%c) ", return_value_lex_text_6[(signed long int)0]);
          }

          else
            if(!(toks == ((char **)NULL)))
              printf("TOK(%d:%s) ", tok, toks[(signed long int)(tok < 259 ? tok : tok - 259)]);

            else
            {
              return_value_lex_line_7=lex_line(l);
              return_value_lex_prev_8=lex_prev(l);
              return_value_lex_text_9=lex_text(l);
              printf("\nINTERNAL ERROR: line=%d, tok=%d, str=\"%s\"\n", return_value_lex_line_7, return_value_lex_prev_8, return_value_lex_text_9);
            }
      }
    }
    while((_Bool)1);
    lex_destroy(l);
    goto __CPROVER_DUMP_L15;
  }


__CPROVER_DUMP_L15:
  ;
}

// lex_prev
// file lex.h line 131
signed int lex_prev(struct lexer_state *l)
{
  return l->prev;
}

// lex_text
// file lex.h line 141
const char * lex_text(struct lexer_state *l)
{
  return l->text;
}

// link_objs
// file server.h line 415
void link_objs(struct base_obj *src, struct base_obj *dst)
{
  signed int gotBcast;
  signed int gotStolen;
  char *now;
  char *tty;
  char buf[1024l];
  struct listIterator *i;
  struct base_obj *writer;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_2;
  signed int return_value_list_is_empty_1;
  void *return_value_list_next_3;
  void *return_value_list_next_5;
  if((signed int)src->type == CONMAN_OBJ_CLIENT)
  {
    if((signed int)dst->type == CONMAN_OBJ_TELNET)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = (signed int)dst->type == CONMAN_OBJ_IPMI ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
      tmp_if_expr_7 = (_Bool)1;

    else
      tmp_if_expr_7 = (signed int)dst->type == CONMAN_OBJ_PROCESS ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_7)
      tmp_if_expr_8 = (_Bool)1;

    else
      tmp_if_expr_8 = (signed int)dst->type == CONMAN_OBJ_SERIAL ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_8)
      tmp_if_expr_9 = (_Bool)1;

    else
      tmp_if_expr_9 = (signed int)dst->type == CONMAN_OBJ_UNIXSOCK ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_9)
    {
      gotBcast = (signed int)src->aux.client.req->enableBroadcast;
      if(!(src->aux.client.req->enableForce == 0u))
      {
        return_value_list_is_empty_1=list_is_empty(dst->writers);
        tmp_if_expr_2 = !(return_value_list_is_empty_1 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
      gotStolen = (signed int)tmp_if_expr_2;
      now=create_short_time_string((signed long int)0);
      tty = src->aux.client.req->tty;
      snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%sConsole [%s] %s%s by <%s@%s>%s%s at %s%s", (const void *)"\r\n<ConMan> ", dst->name, gotStolen != 0 ? "stolen" : "joined", gotBcast != 0 ? " for B/C" : "", src->aux.client.req->user, src->aux.client.req->host, tty != ((char *)NULL) ? " on " : "", tty != ((char *)NULL) ? tty : "", now, (const void *)".\r\n");
      strcpy(&buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)3)], "\r\n");
      notify_console_objs(dst, buf);
      i=list_iterator_create(dst->writers);
      do
      {
        return_value_list_next_3=list_next(i);
        writer = (struct base_obj *)return_value_list_next_3;
        if(writer == ((struct base_obj *)NULL))
          break;

        tty = writer->aux.client.req->tty;
        snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%sConsole [%s] %s <%s@%s>%s%s at %s%s", (const void *)"\r\n<ConMan> ", dst->name, gotStolen != 0 ? "stolen from" : "joined with", writer->aux.client.req->user, writer->aux.client.req->host, tty != ((char *)NULL) ? " on " : "", tty != ((char *)NULL) ? tty : "", now, (const void *)".\r\n");
        strcpy(&buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)3)], "\r\n");
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(buf);
        write_obj_data(src, (const void *)buf, (signed int)return_value_strlen_4, 1);
      }
      while((_Bool)1);
      list_iterator_destroy(i);
      if(!(gotStolen == 0))
      {
        i=list_iterator_create(dst->writers);
        do
        {
          return_value_list_next_5=list_next(i);
          writer = (struct base_obj *)return_value_list_next_5;
          if(writer == ((struct base_obj *)NULL))
            break;

          unlink_obj(writer);
        }
        while((_Bool)1);
        list_iterator_destroy(i);
      }

      free((void *)now);
    }

  }

  list_append(src->readers, (void *)dst);
  list_append(dst->writers, (void *)src);
  goto __CPROVER_DUMP_L17;

__CPROVER_DUMP_L17:
  ;
}

// list_alloc
// file list.c line 637
static struct list * list_alloc(void)
{
  struct list *l;
  struct list *last;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&freeListsLock);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  if(freeLists == ((struct list *)NULL))
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)10 * sizeof(struct list) /*80ul*/ );
    freeLists = (struct list *)return_value_malloc_2;
    if(!(freeLists == ((struct list *)NULL)))
    {
      last = (freeLists + (signed long int)10) - (signed long int)1;
      l = freeLists;
      for( ; !(l >= last); l = l + 1l)
        l->iNext = (struct listIterator *)(l + (signed long int)1);
      last->iNext = (struct listIterator *)(void *)0;
    }

  }

  l = freeLists;
  if(!(l == ((struct list *)NULL)))
    freeLists = (struct list *)freeLists->iNext;

  do
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3=pthread_mutex_unlock(&freeListsLock);
    if(!(*return_value___errno_location_3 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  return l;
}

// list_append
// file list.h line 114
void * list_append(struct list *l, void *x)
{
  void *v;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&l->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  v=list_node_create(l, l->tail, x);
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&l->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  return v;
}

// list_count
// file list.h line 104
signed int list_count(struct list *l)
{
  signed int n;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&l->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  n = l->count;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&l->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  return n;
}

// list_create
// file list.h line 82
struct list * list_create(void (*f)(void *))
{
  struct list *l;
  l=list_alloc();
  if(l == ((struct list *)NULL))
  {
    log_err(0, "Out of memory");
    return (struct list *)(void *)0;
  }

  else
  {
    l->head = (struct listNode *)(void *)0;
    l->tail = &l->head;
    l->iNext = (struct listIterator *)(void *)0;
    l->fDel = f;
    l->count = 0;
    do
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1=pthread_mutex_init(&l->mutex, (const union anonymous_0 *)(void *)0);
      if(!(*return_value___errno_location_1 == 0))
      {
        perror("ERROR: pthread_mutex_init() failed");
        exit(1);
      }

    }
    while((_Bool)0);
    return l;
  }
}

// list_delete
// file list.h line 248
signed int list_delete(struct listIterator *i)
{
  void *v;
  v=list_remove(i);
  if(!(v == NULL))
  {
    if(!(i->list->fDel == ((void (*)(void *))NULL)))
      i->list->fDel(v);

    return 1;
  }

  else
    return 0;
}

// list_delete_all
// file list.h line 136
signed int list_delete_all(struct list *l, signed int (*f)(void *, void *), void *key)
{
  struct listNode **pp;
  void *v;
  signed int n = 0;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&l->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  pp = &l->head;
  if(!(*pp == ((struct listNode *)NULL)))
  {
    signed int return_value;
    return_value=f((*pp)->data, key);
    if(!(return_value == 0))
    {
      v=list_node_destroy(l, pp);
      if(!(v == NULL))
      {
        if(!(l->fDel == ((void (*)(void *))NULL)))
          l->fDel(v);

        n = n + 1;
      }

    }

    else
      pp = &(*pp)->next;
  }

  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&l->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  return n;
}

// list_dequeue
// file list.c line 427
void * list_dequeue(struct list *l)
{
  void *v;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&l->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  v=list_node_destroy(l, &l->head);
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&l->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  return v;
}

// list_destroy
// file list.h line 92
void list_destroy(struct list *l)
{
  struct listIterator *i;
  struct listIterator *iTmp;
  struct listNode *p;
  struct listNode *pTmp;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&l->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  i = l->iNext;
  for( ; !(i == ((struct listIterator *)NULL)); i = iTmp)
  {
    iTmp = i->iNext;
    list_iterator_free(i);
  }
  p = l->head;
  for( ; !(p == ((struct listNode *)NULL)); p = pTmp)
  {
    pTmp = p->next;
    if(!(p->data == NULL))
    {
      if(!(l->fDel == ((void (*)(void *))NULL)))
        l->fDel(p->data);

    }

    list_node_free(p);
  }
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&l->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  do
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3=pthread_mutex_destroy(&l->mutex);
    if(!(*return_value___errno_location_3 == 0))
    {
      perror("ERROR: pthread_mutex_destroy() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  list_free(l);
  goto __CPROVER_DUMP_L11;

__CPROVER_DUMP_L11:
  ;
}

// list_enqueue
// file list.c line 413
void * list_enqueue(struct list *l, void *x)
{
  void *v;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&l->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  v=list_node_create(l, l->tail, x);
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&l->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  return v;
}

// list_find
// file list.h line 232
void * list_find(struct listIterator *i, signed int (*f)(void *, void *), void *key)
{
  void *v;
  v=list_next(i);
  signed int return_value;
  if(!(v == NULL))
    return_value=f(v, key);

  return v;
}

// list_find_first
// file list.h line 126
void * list_find_first(struct list *l, signed int (*f)(void *, void *), void *key)
{
  struct listNode *p;
  void *v = (void *)0;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&l->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  p = l->head;
  if(!(p == ((struct listNode *)NULL)))
  {
    signed int return_value;
    return_value=f(p->data, key);
    if(!(return_value == 0))
      v = p->data;

    else
      p = p->next;
  }

  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&l->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  return v;
}

// list_free
// file list.c line 703
static void list_free(struct list *l)
{
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&freeListsLock);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  l->iNext = (struct listIterator *)freeLists;
  freeLists = l;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&freeListsLock);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
}

// list_insert
// file list.h line 224
void * list_insert(struct listIterator *i, void *x)
{
  void *v;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&i->list->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  v=list_node_create(i->list, i->prev, x);
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&i->list->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  return v;
}

// list_is_empty
// file list.h line 99
signed int list_is_empty(struct list *l)
{
  signed int n;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&l->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  n = l->count;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&l->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  return (signed int)(n == 0);
}

// list_iterator_alloc
// file list.c line 681
static struct listIterator * list_iterator_alloc(void)
{
  struct listIterator *i;
  struct listIterator *last;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&freeListIteratorsLock);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  if(freeListIterators == ((struct listIterator *)NULL))
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)10 * sizeof(struct listIterator) /*32ul*/ );
    freeListIterators = (struct listIterator *)return_value_malloc_2;
    if(!(freeListIterators == ((struct listIterator *)NULL)))
    {
      last = (freeListIterators + (signed long int)10) - (signed long int)1;
      i = freeListIterators;
      for( ; !(i >= last); i = i + 1l)
        i->iNext = i + (signed long int)1;
      last->iNext = (struct listIterator *)(void *)0;
    }

  }

  i = freeListIterators;
  if(!(i == ((struct listIterator *)NULL)))
    freeListIterators = freeListIterators->iNext;

  do
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3=pthread_mutex_unlock(&freeListIteratorsLock);
    if(!(*return_value___errno_location_3 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  return i;
}

// list_iterator_create
// file list.h line 198
struct listIterator * list_iterator_create(struct list *l)
{
  struct listIterator *i;
  i=list_iterator_alloc();
  if(i == ((struct listIterator *)NULL))
  {
    log_err(0, "Out of memory");
    return (struct listIterator *)(void *)0;
  }

  else
  {
    i->list = l;
    do
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1=pthread_mutex_lock(&l->mutex);
      if(!(*return_value___errno_location_1 == 0))
      {
        perror("ERROR: pthread_mutex_lock() failed");
        exit(1);
      }

    }
    while((_Bool)0);
    i->pos = l->head;
    i->prev = &l->head;
    i->iNext = l->iNext;
    l->iNext = i;
    do
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2=pthread_mutex_unlock(&l->mutex);
      if(!(*return_value___errno_location_2 == 0))
      {
        perror("ERROR: pthread_mutex_unlock() failed");
        exit(1);
      }

    }
    while((_Bool)0);
    return i;
  }
}

// list_iterator_destroy
// file list.h line 210
void list_iterator_destroy(struct listIterator *i)
{
  struct listIterator **pi;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&i->list->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  pi = &i->list->iNext;
  for( ; !(*pi == ((struct listIterator *)NULL)); pi = &(*pi)->iNext)
    if(*pi == i)
    {
      *pi = (*pi)->iNext;
      break;
    }

  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&i->list->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  list_iterator_free(i);
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
}

// list_iterator_free
// file list.c line 723
static void list_iterator_free(struct listIterator *i)
{
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&freeListIteratorsLock);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  i->iNext = freeListIterators;
  freeListIterators = i;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&freeListIteratorsLock);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
}

// list_iterator_reset
// file list.h line 204
void list_iterator_reset(struct listIterator *i)
{
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&i->list->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  i->pos = i->list->head;
  i->prev = &i->list->head;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&i->list->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
}

// list_next
// file list.h line 217
void * list_next(struct listIterator *i)
{
  struct listNode *p;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&i->list->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  p = i->pos;
  if(!(p == ((struct listNode *)NULL)))
    i->pos = p->next;

  if(!(*i->prev == p))
    i->prev = &(*i->prev)->next;

  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&i->list->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  void *tmp_if_expr_3;
  if(!(p == ((struct listNode *)NULL)))
    tmp_if_expr_3 = p->data;

  else
    tmp_if_expr_3 = (void *)0;
  return tmp_if_expr_3;
}

// list_node_alloc
// file list.c line 659
static struct listNode * list_node_alloc(void)
{
  struct listNode *p;
  struct listNode *last;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&freeListNodesLock);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  if(freeListNodes == ((struct listNode *)NULL))
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)10 * sizeof(struct listNode) /*16ul*/ );
    freeListNodes = (struct listNode *)return_value_malloc_2;
    if(!(freeListNodes == ((struct listNode *)NULL)))
    {
      last = (freeListNodes + (signed long int)10) - (signed long int)1;
      p = freeListNodes;
      for( ; !(p >= last); p = p + 1l)
        p->next = p + (signed long int)1;
      last->next = (struct listNode *)(void *)0;
    }

  }

  p = freeListNodes;
  if(!(p == ((struct listNode *)NULL)))
    freeListNodes = freeListNodes->next;

  do
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3=pthread_mutex_unlock(&freeListNodesLock);
    if(!(*return_value___errno_location_3 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  return p;
}

// list_node_create
// file list.c line 570
static void * list_node_create(struct list *l, struct listNode **pp, void *x)
{
  struct listNode *p;
  struct listIterator *i;
  p=list_node_alloc();
  if(p == ((struct listNode *)NULL))
  {
    log_err(0, "Out of memory");
    return (void *)0;
  }

  else
  {
    p->data = x;
    p->next = *pp;
    if(p->next == ((struct listNode *)NULL))
      l->tail = &p->next;

    *pp = p;
    l->count = l->count + 1;
    i = l->iNext;
    for( ; !(i == ((struct listIterator *)NULL)); i = i->iNext)
      if(i->prev == pp)
        i->prev = &p->next;

      else
        if(i->pos == p->next)
          i->pos = p;

    return x;
  }
}

// list_node_destroy
// file list.c line 603
static void * list_node_destroy(struct list *l, struct listNode **pp)
{
  void *v;
  struct listNode *p;
  struct listIterator *i;
  p = *pp;
  if(p == ((struct listNode *)NULL))
    return (void *)0;

  else
  {
    v = p->data;
    *pp = p->next;
    if(*pp == ((struct listNode *)NULL))
      l->tail = pp;

    l->count = l->count - 1;
    i = l->iNext;
    for( ; !(i == ((struct listIterator *)NULL)); i = i->iNext)
      if(i->pos == p)
      {
        i->pos = p->next;
        i->prev = pp;
      }

      else
        if(i->prev == &p->next)
          i->prev = pp;

    list_node_free(p);
    return v;
  }
}

// list_node_free
// file list.c line 713
static void list_node_free(struct listNode *p)
{
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&freeListNodesLock);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  p->next = freeListNodes;
  freeListNodes = p;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&freeListNodesLock);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
}

// list_peek
// file list.h line 169
void * list_peek(struct list *l)
{
  void *v;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&l->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  void *tmp_if_expr_2;
  if(!(l->head == ((struct listNode *)NULL)))
    tmp_if_expr_2 = l->head->data;

  else
    tmp_if_expr_2 = (void *)0;
  v = tmp_if_expr_2;
  do
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3=pthread_mutex_unlock(&l->mutex);
    if(!(*return_value___errno_location_3 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  return v;
}

// list_pop
// file list.h line 163
void * list_pop(struct list *l)
{
  void *v;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&l->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  v=list_node_destroy(l, &l->head);
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&l->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  return v;
}

// list_prepend
// file list.c line 265
void * list_prepend(struct list *l, void *x)
{
  void *v;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&l->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  v=list_node_create(l, &l->head, x);
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&l->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  return v;
}

// list_push
// file list.h line 157
void * list_push(struct list *l, void *x)
{
  void *v;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&l->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  v=list_node_create(l, &l->head, x);
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&l->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  return v;
}

// list_remove
// file list.h line 241
void * list_remove(struct listIterator *i)
{
  void *v = (void *)0;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&i->list->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  if(!(*i->prev == i->pos))
    v=list_node_destroy(i->list, i->prev);

  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&i->list->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  return v;
}

// list_sort
// file list.h line 145
void list_sort(struct list *l, signed int (*f)(void *, void *))
{
  struct listNode **pp;
  struct listNode **ppPrev;
  struct listNode **ppPos;
  struct listNode *pTmp;
  struct listIterator *i;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&l->mutex);
    if(!(*return_value___errno_location_1 == 0))
    {
      perror("ERROR: pthread_mutex_lock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  if(l->count >= 2)
  {
    ppPrev = &l->head;
    pp = &(*ppPrev)->next;
    if(!(*pp == ((struct listNode *)NULL)))
    {
      signed int return_value_1;
      return_value_1=f((*pp)->data, (*ppPrev)->data);
      if(!(return_value_1 >= 0))
      {
        ppPos = &l->head;
        signed int return_value;
        return_value=f((*pp)->data, (*ppPos)->data);
        if(return_value >= 0)
          ppPos = &(*ppPos)->next;

        pTmp = (*pp)->next;
        (*pp)->next = *ppPos;
        *ppPos = *pp;
        *pp = pTmp;
        if(ppPrev == ppPos)
          ppPrev = &(*ppPrev)->next;

      }

      else
      {
        ppPrev = pp;
        pp = &(*pp)->next;
      }
    }

    l->tail = pp;
    i = l->iNext;
    for( ; !(i == ((struct listIterator *)NULL)); i = i->iNext)
    {
      i->pos = i->list->head;
      i->prev = &i->list->head;
    }
  }

  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&l->mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      perror("ERROR: pthread_mutex_unlock() failed");
      exit(1);
    }

  }
  while((_Bool)0);
  goto __CPROVER_DUMP_L13;

__CPROVER_DUMP_L13:
  ;
}

// log_aux
// file log.c line 183
static void log_aux(signed int errnum, signed int priority, char *msgbuf, signed int msgbuflen, const char *format, void **vargs)
{
  signed long int t;
  struct tm tm;
  const char *prefix;
  char buf[1024l];
  char *pbuf;
  char *sbuf;
  char *p;
  signed int len;
  signed int n;
  pbuf = buf;
  sbuf = pbuf;
  p = sbuf;
  len = (signed int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
  t = (signed long int)0;
  get_localtime(&t, &tm);
  unsigned long int return_value_strftime_1;
  return_value_strftime_1=strftime(p, (unsigned long int)len, "%Y-%m-%d %H:%M:%S ", &tm);
  n = (signed int)return_value_strftime_1;
  if(n == 0)
  {
    *p = (char)0;
    len = 0;
  }

  pbuf = pbuf + (signed long int)n;
  sbuf = pbuf;
  p = sbuf;
  len = len - n;
  prefix=log_prefix(priority);
  if(!(prefix == ((const char *)NULL)))
  {
    signed int m;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(prefix);
    m = (signed int)((unsigned long int)10 - return_value_strlen_2);
    if(!(m >= 1))
      m = 1;

    n=snprintf(p, (unsigned long int)len, "%s:%*c", prefix, m, 0x20);
    if(n >= len || !(n >= 0))
      n = len - 1;

    sbuf = sbuf + (signed long int)n;
    p = sbuf;
    len = len - n;
  }

  n=vsnprintf(p, (unsigned long int)len, format, vargs);
  if(n >= len || !(n >= 0))
    n = len - 1;

  p = p + (signed long int)n;
  len = len - n;
  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(format);
  if(!((signed int)format[-1l + (signed long int)return_value_strlen_4] == 10))
  {
    if(len >= 1 && errnum >= 1)
    {
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(errnum);
      n=snprintf(p, (unsigned long int)len, ": %s", return_value_strerror_3);
      if(n >= len || !(n >= 0))
        n = len - 1;

      p = p + (signed long int)n;
      len = len - n;
    }

    strcat(p, "\n");
  }

  if(msgbuflen >= 1 && !(msgbuf == ((char *)NULL)))
  {
    if(!(sbuf == ((char *)NULL)))
    {
      strncpy(msgbuf, sbuf, (unsigned long int)msgbuflen);
      msgbuf[(signed long int)(msgbuflen - 1)] = (char)0;
    }

    else
      msgbuf[(signed long int)0] = (char)0;
  }

  if(!(log_syslog == 0))
    syslog(priority, "%s", sbuf);

  char *tmp_if_expr_5;
  if(log_file_priority >= priority && !(log_file_fp == ((struct _IO_FILE *)NULL)))
  {
    if(!(log_file_timestamp == 0))
      tmp_if_expr_5 = buf;

    else
      tmp_if_expr_5 = pbuf;
    n=fprintf(log_file_fp, "%s", tmp_if_expr_5);
    if(n == -1)
    {
      syslog(2, "Logging stopped due to error");
      log_file_fp = (struct _IO_FILE *)(void *)0;
    }

  }

  goto __CPROVER_DUMP_L15;

__CPROVER_DUMP_L15:
  ;
}

// log_err
// file ./log.h line 86
void log_err(signed int errnum, const char *format, ...)
{
  signed int priority = 3;
  void **vargs;
  char msg[1024l];
  signed char c;
  signed int n;
  char *p;
  vargs = (void **)&format;
  log_aux(errnum, priority, msg, (signed int)sizeof(char [1024l]) /*1024ul*/ , format, vargs);
  vargs = ((void **)NULL);
  if(log_fd_daemonize >= 0)
  {
    c = (signed char)priority;
    signed long int return_value_write_1;
    return_value_write_1=write(log_fd_daemonize, (const void *)&c, sizeof(signed char) /*1ul*/ );
    n = (signed int)return_value_write_1;
    if(n >= 1)
    {
      if(!((signed int)msg[0l] == 0))
      {
        if(!(log_file_fp == stderr))
        {
          p=strchr(msg, 10);
          if(!(p == ((char *)NULL)))
            *p = (char)0;

          unsigned long int return_value_strlen_2;
          return_value_strlen_2=strlen(msg);
          signed long int return_value_write_3;
          return_value_write_3=write(log_fd_daemonize, (const void *)msg, return_value_strlen_2 + (unsigned long int)1);
          n = (signed int)return_value_write_3;
        }

      }

    }

  }

  exit(1);
}

// log_msg
// file ./log.h line 96
void log_msg(signed int priority, const char *format, ...)
{
  void **vargs = (void **)&format;
  log_aux(0, priority, (char *)(void *)0, 0, format, vargs);
  vargs = ((void **)NULL);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// log_prefix
// file log.c line 266
static const char * log_prefix(signed int priority)
{
  switch(priority)
  {
    case 0:
      return "EMERGENCY";
    case 1:
      return "ALERT";
    case 2:
      return "CRITICAL";
    case 3:
      return "ERROR";
    case 4:
      return "WARNING";
    case 5:
      return "NOTICE";
    case 6:
      return "INFO";
    case 7:
      return "DEBUG";
    default:
      return "UNKNOWN";
  }
}

// log_set_err_pipe
// file ./log.h line 77
void log_set_err_pipe(signed int fd)
{
  log_fd_daemonize = fd >= 0 ? fd : -1;
}

// log_set_file
// file ./log.h line 61
void log_set_file(struct _IO_FILE *fp, signed int priority, signed int timestamp)
{
  _Bool tmp_if_expr_2;
  signed int return_value_ferror_1;
  if(!(fp == ((struct _IO_FILE *)NULL)))
  {
    return_value_ferror_1=ferror(fp);
    tmp_if_expr_2 = !(return_value_ferror_1 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
  {
    log_file_fp = fp;
    log_file_priority = priority > 0 ? priority : 0;
    log_file_timestamp = (signed int)!(!(timestamp != 0));
    setvbuf(fp, (char *)(void *)0, 2, (unsigned long int)0);
  }

  else
  {
    log_file_fp = (struct _IO_FILE *)(void *)0;
    log_file_priority = -1;
    log_file_timestamp = 0;
  }
  goto __CPROVER_DUMP_L5;

__CPROVER_DUMP_L5:
  ;
}

// log_set_syslog
// file ./log.h line 69
void log_set_syslog(char *ident, signed int facility)
{
  char *p;
  if(!(ident == ((char *)NULL)))
  {
    p=strrchr(ident, 47);
    if(!(p == ((char *)NULL)))
      ident = p + (signed long int)1;

    openlog(ident, 0x08 | 0x01, facility);
    log_syslog = 1;
  }

  else
  {
    closelog();
    log_syslog = 0;
  }
  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L4:
  ;
}

// lookup_syslog_facility
// file server-conf.c line 1537
static signed int lookup_syslog_facility(const char *facility)
{
  struct tag *t;
  const unsigned short int **return_value___ctype_b_loc_1;
  for( ; !(*facility == 0); facility = facility + 1l)
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*facility]) == 0)
      break;

  }
  t = logFacilities;
  for( ; !(t->key == ((const char *)NULL)); t = t + 1l)
  {
    signed int return_value_strcasecmp_2;
    return_value_strcasecmp_2=strcasecmp(t->key, facility);
    if(return_value_strcasecmp_2 == 0)
      return t->val;

  }
  return -1;
}

// lookup_syslog_priority
// file server-conf.c line 1516
static signed int lookup_syslog_priority(const char *priority)
{
  struct tag *t;
  const unsigned short int **return_value___ctype_b_loc_1;
  for( ; !(*priority == 0); priority = priority + 1l)
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*priority]) == 0)
      break;

  }
  t = logPriorities;
  for( ; !(t->key == ((const char *)NULL)); t = t + 1l)
  {
    signed int return_value_strcasecmp_2;
    return_value_strcasecmp_2=strcasecmp(t->key, priority);
    if(return_value_strcasecmp_2 == 0)
      return t->val;

  }
  return -1;
}

// lookup_token
// file lex.c line 302
static signed int lookup_token(char *str, char **toks, signed int numtoks)
{
  signed int low;
  signed int middle;
  signed int high;
  signed int x;
  if(!(toks == ((char **)NULL)))
  {
    low = 0;
    high = numtoks - 1;
    while(high >= low)
    {
      middle = (low + high) / 2;
      x=strcasecmp(str, toks[(signed long int)middle]);
      if(!(x >= 0))
        high = middle - 1;

      else
        if(x >= 1)
          low = middle + 1;

        else
          return middle + 259;
    }
  }

  return 258;
}

// main
// file server.c line 94
signed int main(signed int argc, char **argv)
{
  signed int fd = -1;
  signed int pgid = -1;
  struct server_conf *conf;
  signed int log_priority = 6;
  log_set_file(stderr, log_priority, 0);
  conf=create_server_conf();
  tp_global = conf->tp;
  process_cmdline(conf, argc, argv);
  if(conf->enableForeground == 0u)
    begin_daemonize(&fd, &pgid);

  process_config(conf);
  setup_coredump(conf);
  setup_signals(conf);
  environ=get_sane_env();
  if(environ == ((char **)NULL))
    log_err(12, "Unable to create sanitized environment");

  if(!(conf->enableVerbose == 0u))
    display_configuration(conf);

  signed int return_value_list_is_empty_1;
  return_value_list_is_empty_1=list_is_empty(conf->objs);
  if(!(return_value_list_is_empty_1 == 0))
    log_err(0, "Configuration \"%s\" has no consoles defined", conf->confFileName);

  if(conf->tStampMinutes >= 1)
    schedule_timestamp(conf);

  create_listen_socket(conf);
  if(conf->enableForeground == 0u)
  {
    if(conf->syslogFacility >= 1)
      log_set_syslog(argv[(signed long int)0], conf->syslogFacility);

    if(!(conf->logFileName == ((char *)NULL)))
      open_daemon_logfile(conf);

    else
      log_set_file((struct _IO_FILE *)(void *)0, 0, 0);
    end_daemonize(fd);
  }

  signed int return_value_getpid_2;
  return_value_getpid_2=getpid();
  log_msg(5, "Starting ConMan daemon %s (pid %d)", (const void *)"0.2.7", (signed int)return_value_getpid_2);
  ipmi_init(conf->numIpmiObjs);
  open_objs(conf);
  mux_io(conf);
  ipmi_fini();
  destroy_server_conf(conf);
  if(pgid >= 1)
  {
    signed int return_value_kill_5;
    return_value_kill_5=kill(-pgid, 15);
    if(!(return_value_kill_5 >= 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      log_msg(4, "Unable to terminate process group ID %d: %s", pgid, return_value_strerror_4);
    }

  }

  signed int return_value_getpid_6;
  return_value_getpid_6=getpid();
  log_msg(5, "Stopping ConMan daemon %s (pid %d)", (const void *)"0.2.7", (signed int)return_value_getpid_6);
  exit(0);
}

// max_unixsock_dev_strlen
// file server-unixsock.c line 170
static signed int max_unixsock_dev_strlen(void)
{
  struct sockaddr_un saddr;
  return (signed int)(sizeof(char [108l]) /*108ul*/  - (unsigned long int)1);
}

// mux_io
// file server.c line 706
static void mux_io(struct server_conf *conf)
{
  struct listIterator *i;
  signed int n;
  struct base_obj *obj;
  signed int mux_io__1__inevent_fd;
  i=list_iterator_create(conf->objs);
  void *return_value_list_next_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_15;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_12;
  signed int return_value_tpoll_is_set_21;
  void *return_value_list_next_22;
  signed int return_value_tpoll_is_set_23;
  while(done == 0)
  {
    if(!(reconfig == 0))
    {
      log_msg(5, "Performing reconfig on signal=%d", reconfig);
      reopen_logfiles(conf);
      reconfig = 0;
    }

    tpoll_zero(conf->tp, (enum anonymous_1)TPOLL_ZERO_FDS);
    tpoll_set(conf->tp, conf->ld, (signed short int)0x001);
    mux_io__1__inevent_fd=inevent_get_fd();
    if(mux_io__1__inevent_fd >= 0)
    {
      signed int return_value_inevent_get_fd_1;
      return_value_inevent_get_fd_1=inevent_get_fd();
      tpoll_set(conf->tp, return_value_inevent_get_fd_1, (signed short int)0x001);
    }

    list_iterator_reset(i);
    do
    {
      return_value_list_next_2=list_next(i);
      obj = (struct base_obj *)return_value_list_next_2;
      if(obj == ((struct base_obj *)NULL))
        break;

      if(!(obj->gotReset == 0u))
        reset_console(obj, conf->resetCmd);

      if(obj->fd >= 0)
      {
        if((signed int)obj->type == CONMAN_OBJ_TELNET)
          tmp_if_expr_3 = (signed int)obj->aux.telnet.state == 3 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          if((signed int)obj->type == CONMAN_OBJ_PROCESS)
            tmp_if_expr_4 = (signed int)obj->aux.process.state == 1 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          if((signed int)obj->type == CONMAN_OBJ_IPMI)
            tmp_if_expr_6 = (signed int)obj->aux.ipmi.state == CONMAN_IPMI_UP ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_6 = (_Bool)0;
          tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
          tmp_if_expr_9 = (_Bool)1;

        else
        {
          if((signed int)obj->type == CONMAN_OBJ_UNIXSOCK)
            tmp_if_expr_8 = (signed int)obj->aux.unixsock.state == 1 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_8 = (_Bool)0;
          tmp_if_expr_9 = tmp_if_expr_8 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_9)
          tmp_if_expr_10 = (_Bool)1;

        else
          tmp_if_expr_10 = (signed int)obj->type == CONMAN_OBJ_SERIAL ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_10)
          tmp_if_expr_11 = (_Bool)1;

        else
          tmp_if_expr_11 = (signed int)obj->type == CONMAN_OBJ_CLIENT ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_11)
        {
          if(obj->gotEOF == 0u)
            tpoll_set(conf->tp, obj->fd, (signed short int)0x001);

        }

        if(!(obj->bufInPtr == obj->bufOutPtr))
          tmp_if_expr_17 = (_Bool)1;

        else
          tmp_if_expr_17 = obj->gotEOF != 0u ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_17)
        {
          if((signed int)obj->type == CONMAN_OBJ_TELNET)
            tmp_if_expr_16 = (signed int)obj->aux.telnet.state != 3 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_16 = (_Bool)0;
          if(!tmp_if_expr_16)
          {
            if((signed int)obj->type == CONMAN_OBJ_PROCESS)
              tmp_if_expr_15 = (signed int)obj->aux.process.state != 1 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_15 = (_Bool)0;
            if(!tmp_if_expr_15)
            {
              if((signed int)obj->type == CONMAN_OBJ_IPMI)
                tmp_if_expr_14 = (signed int)obj->aux.ipmi.state != CONMAN_IPMI_UP ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_14 = (_Bool)0;
              if(!tmp_if_expr_14)
              {
                if((signed int)obj->type == CONMAN_OBJ_UNIXSOCK)
                  tmp_if_expr_13 = (signed int)obj->aux.unixsock.state != 1 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_13 = (_Bool)0;
                if(!tmp_if_expr_13)
                {
                  if((signed int)obj->type == CONMAN_OBJ_CLIENT)
                    tmp_if_expr_12 = obj->aux.client.gotSuspend != 0u ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_12 = (_Bool)0;
                  if(!tmp_if_expr_12)
                    tpoll_set(conf->tp, obj->fd, (signed short int)0x004);

                }

              }

            }

          }

        }

        if((signed int)obj->type == CONMAN_OBJ_TELNET)
        {
          if((signed int)obj->aux.telnet.state == 2)
            tpoll_set(conf->tp, obj->fd, (signed short int)(0x001 | 0x004));

        }

      }

    }
    while((_Bool)1);
    do
    {
      n=tpoll(conf->tp, 1000);
      if(n >= 0)
        break;

      signed int *return_value___errno_location_19;
      return_value___errno_location_19=__errno_location();
      if(!(*return_value___errno_location_19 == 4))
      {
        signed int *return_value___errno_location_18;
        return_value___errno_location_18=__errno_location();
        log_err(*return_value___errno_location_18, "Unable to multiplex I/O");
      }

      else
        if(!(done == 0) || !(reconfig == 0))
          break;

    }
    while((_Bool)1);
    if(n >= 1)
    {
      signed int return_value_tpoll_is_set_20;
      return_value_tpoll_is_set_20=tpoll_is_set(conf->tp, conf->ld, (signed short int)0x001);
      if(!(return_value_tpoll_is_set_20 == 0))
        accept_client(conf);

      if(mux_io__1__inevent_fd >= 0)
      {
        return_value_tpoll_is_set_21=tpoll_is_set(conf->tp, mux_io__1__inevent_fd, (signed short int)0x001);
        if(!(return_value_tpoll_is_set_21 == 0))
          inevent_process();

      }

      list_iterator_reset(i);
      do
      {
        return_value_list_next_22=list_next(i);
        obj = (struct base_obj *)return_value_list_next_22;
        if(obj == ((struct base_obj *)NULL))
          break;

        if(obj->fd >= 0)
        {
          if((signed int)obj->type == CONMAN_OBJ_TELNET)
          {
            return_value_tpoll_is_set_23=tpoll_is_set(conf->tp, obj->fd, (signed short int)(0x001 | 0x004));
            if(return_value_tpoll_is_set_23 == 0)
              goto __CPROVER_DUMP_L46;

            if(!((signed int)obj->aux.telnet.state == 2))
              goto __CPROVER_DUMP_L46;

            open_telnet_obj(obj);
          }

          else
          {

          __CPROVER_DUMP_L46:
            ;
            signed int return_value_tpoll_is_set_25;
            return_value_tpoll_is_set_25=tpoll_is_set(conf->tp, obj->fd, (signed short int)(0x001 | 0x010 | 0x008));
            if(!(return_value_tpoll_is_set_25 == 0))
            {
              signed int return_value_read_from_obj_24;
              return_value_read_from_obj_24=read_from_obj(obj, conf->tp);
              if(!(return_value_read_from_obj_24 >= 0))
              {
                list_delete(i);
                continue;
              }

              if(!(obj->fd >= 0))
                continue;

            }

            signed int return_value_tpoll_is_set_27;
            return_value_tpoll_is_set_27=tpoll_is_set(conf->tp, obj->fd, (signed short int)0x004);
            if(!(return_value_tpoll_is_set_27 == 0))
            {
              signed int return_value_write_to_obj_26;
              return_value_write_to_obj_26=write_to_obj(obj);
              if(!(return_value_write_to_obj_26 >= 0))
              {
                list_delete(i);
                continue;
              }

              if(!(obj->fd >= 0))
                continue;

            }

          }
        }

      }
      while((_Bool)1);
    }

  }
  log_msg(5, "Exiting on signal=%d", done);
  list_iterator_destroy(i);
  goto __CPROVER_DUMP_L57;

__CPROVER_DUMP_L57:
  ;
}

// notify_console_objs
// file server.h line 413
void notify_console_objs(struct base_obj *console, char *msg)
{
  struct listIterator *i;
  struct base_obj *obj;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(msg == ((char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_strlen_1=strlen(msg);
    tmp_if_expr_2 = !(return_value_strlen_1 != 0ul) ? (_Bool)1 : (_Bool)0;
  }
  void *return_value_list_next_3;
  void *return_value_list_next_5;
  if(!tmp_if_expr_2)
  {
    i=list_iterator_create(console->readers);
    do
    {
      return_value_list_next_3=list_next(i);
      obj = (struct base_obj *)return_value_list_next_3;
      if(obj == ((struct base_obj *)NULL))
        break;

      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(msg);
      write_obj_data(obj, (const void *)msg, (signed int)return_value_strlen_4, 1);
    }
    while((_Bool)1);
    list_iterator_destroy(i);
    i=list_iterator_create(console->writers);
    do
    {
      return_value_list_next_5=list_next(i);
      obj = (struct base_obj *)return_value_list_next_5;
      if(obj == ((struct base_obj *)NULL))
        break;

      void *return_value_list_find_first_7;
      return_value_list_find_first_7=list_find_first(console->readers, (signed int (*)(void *, void *))find_obj, (void *)obj);
      if(return_value_list_find_first_7 == NULL)
      {
        unsigned long int return_value_strlen_6;
        return_value_strlen_6=strlen(msg);
        write_obj_data(obj, (const void *)msg, (signed int)return_value_strlen_6, 1);
      }

    }
    while((_Bool)1);
    list_iterator_destroy(i);
    goto __CPROVER_DUMP_L9;
  }


__CPROVER_DUMP_L9:
  ;
}

// open_daemon_logfile
// file server.c line 858
static void open_daemon_logfile(struct server_conf *conf)
{
  const char *mode = "a";
  unsigned int mask;
  char dirname[4096l];
  struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  signed int fd;
  static signed int once = 1;
  if(!(once == 0))
  {
    if(!(conf->enableZeroLogs == 0u))
      mode = "w";

    once = 0;
  }

  if(!(conf->logFmtName == ((char *)NULL)))
  {
    char buf[1024l];
    signed int return_value_format_obj_string_1;
    return_value_format_obj_string_1=format_obj_string(buf, (signed int)sizeof(char [1024l]) /*1024ul*/ , (struct base_obj *)(void *)0, conf->logFmtName);
    if(!(return_value_format_obj_string_1 >= 0))
    {
      log_msg(4, "Unable to open daemon logfile: filename too long");
      goto err;
    }

    free((void *)conf->logFileName);
    conf->logFileName=create_string(buf);
  }

  mask=umask((unsigned int)0);
  umask(mask | (unsigned int)022);
  char *return_value_get_dir_name_2;
  return_value_get_dir_name_2=get_dir_name(conf->logFileName, dirname, sizeof(char [4096l]) /*4096ul*/ );
  if(!(return_value_get_dir_name_2 == ((char *)NULL)))
    create_dirs(dirname);

  fp=fopen(conf->logFileName, mode);
  umask(mask);
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    log_msg(4, "Unable to open daemon logfile \"%s\": %s", conf->logFileName, return_value_strerror_4);
    goto err;
  }

  fd=fileno(fp);
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    char *return_value_strerror_6;
    return_value_strerror_6=strerror(*return_value___errno_location_5);
    log_msg(4, "Unable to obtain descriptor for daemon logfile \"%s\": %s", conf->logFileName, return_value_strerror_6);
    goto err;
  }

  signed int return_value_get_write_lock_7;
  return_value_get_write_lock_7=get_write_lock(fd);
  if(!(return_value_get_write_lock_7 >= 0))
    log_msg(4, "Unable to lock daemon logfile \"%s\"", conf->logFileName);

  else
  {
    set_fd_closed_on_exec(fd);
    log_set_file(fp, conf->logFileLevel, 1);
    if(!(conf->logFilePtr == ((struct _IO_FILE *)NULL)))
    {
      signed int return_value_fclose_8;
      return_value_fclose_8=fclose(conf->logFilePtr);
      if(return_value_fclose_8 == -1)
        log_msg(4, "Unable to close daemon logfile \"%s\"", conf->logFileName);

    }

    conf->logFilePtr = fp;
    goto __CPROVER_DUMP_L15;
  }

err:
  ;
  if(!(fp == ((struct _IO_FILE *)NULL)))
    fclose(fp);

  log_set_file((struct _IO_FILE *)(void *)0, 0, 0);
  if(!(conf->logFilePtr == ((struct _IO_FILE *)NULL)))
  {
    signed int return_value_fclose_9;
    return_value_fclose_9=fclose(conf->logFilePtr);
    if(return_value_fclose_9 == -1)
      log_msg(4, "Unable to close daemon logfile \"%s\"", conf->logFileName);

  }

  conf->logFilePtr = (struct _IO_FILE *)(void *)0;
  goto __CPROVER_DUMP_L15;

__CPROVER_DUMP_L15:
  ;
}

// open_ipmi_obj
// file server.h line 372
signed int open_ipmi_obj(struct base_obj *ipmi)
{
  signed int rc = 0;
  enum ipmi_connect_state state;
  signed int *return_value___errno_location_1;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_lock(&ipmi->aux.ipmi.mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      return_value___errno_location_1=__errno_location();
      log_err(*return_value___errno_location_1, "pthread_mutex_lock() failed");
    }

  }
  while((_Bool)0);
  state = ipmi->aux.ipmi.state;
  signed int *return_value___errno_location_3;
  do
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    *return_value___errno_location_4=pthread_mutex_unlock(&ipmi->aux.ipmi.mutex);
    if(!(*return_value___errno_location_4 == 0))
    {
      return_value___errno_location_3=__errno_location();
      log_err(*return_value___errno_location_3, "pthread_mutex_unlock() failed");
    }

  }
  while((_Bool)0);
  if((signed int)state == CONMAN_IPMI_UP)
  {
    disconnect_ipmi_obj(ipmi);
    rc=connect_ipmi_obj(ipmi);
  }

  else
    if((signed int)state == CONMAN_IPMI_DOWN)
      rc=connect_ipmi_obj(ipmi);

  return rc;
}

// open_logfile_obj
// file server.h line 387
signed int open_logfile_obj(struct base_obj *logfile)
{
  char dirname[4096l];
  signed int flags;
  char *now;
  char *msg;
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(logfile->fd >= 0)
  {
    signed int return_value_close_3;
    return_value_close_3=close(logfile->fd);
    if(!(return_value_close_3 >= 0))
    {
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_msg(4, "Unable to close logfile \"%s\": %s", logfile->name, return_value_strerror_2);
    }

    logfile->fd = -1;
  }

  if(!(logfile->aux.logfile.fmtName == ((char *)NULL)))
  {
    char buf[1024l];
    signed int return_value_format_obj_string_4;
    return_value_format_obj_string_4=format_obj_string(buf, (signed int)sizeof(char [1024l]) /*1024ul*/ , logfile->aux.logfile.console, logfile->aux.logfile.fmtName);
    if(!(return_value_format_obj_string_4 >= 0))
    {
      log_msg(4, "Unable to open logfile for [%s]: filename exceeded buffer", logfile->aux.logfile.console->name);
      logfile->fd = -1;
      return -1;
    }

    free((void *)logfile->name);
    logfile->name=create_string(buf);
  }

  char *return_value_get_dir_name_5;
  return_value_get_dir_name_5=get_dir_name(logfile->name, dirname, sizeof(char [4096l]) /*4096ul*/ );
  if(!(return_value_get_dir_name_5 == ((char *)NULL)))
    create_dirs(dirname);

  flags = 01 | 0100 | 02000 | 04000;
  if(!(logfile->aux.logfile.gotTruncate == 0u))
  {
    logfile->aux.logfile.gotTruncate = (unsigned int)0;
    flags = flags | 01000;
  }

  logfile->fd=open(logfile->name, flags, 0400 | 0200);
  if(!(logfile->fd >= 0))
  {
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    char *return_value_strerror_7;
    return_value_strerror_7=strerror(*return_value___errno_location_6);
    log_msg(4, "Unable to open logfile \"%s\": %s", logfile->name, return_value_strerror_7);
    return -1;
  }

  signed int return_value_get_write_lock_8;
  if(!(logfile->aux.logfile.opts.enableLock == 0u))
  {
    return_value_get_write_lock_8=get_write_lock(logfile->fd);
    if(return_value_get_write_lock_8 >= 0)
      goto __CPROVER_DUMP_L8;

    log_msg(4, "Unable to lock \"%s\"", logfile->name);
    close(logfile->fd);
    logfile->fd = -1;
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L8:
    ;
    logfile->gotEOF = (unsigned int)0;
    set_fd_nonblocking(logfile->fd);
    set_fd_closed_on_exec(logfile->fd);
    now=create_long_time_string((signed long int)0);
    msg=create_format_string("%sConsole [%s] log opened at %s%s", (const void *)"\r\n<ConMan> ", logfile->aux.logfile.console->name, now, (const void *)".\r\n");
    unsigned long int return_value_strlen_9;
    return_value_strlen_9=strlen(msg);
    write_obj_data(logfile, (const void *)msg, (signed int)return_value_strlen_9, 0);
    free((void *)now);
    free((void *)msg);
    logfile->aux.logfile.lineState = (unsigned int)0;
    return 0;
  }
}

// open_objs
// file server.c line 671
static void open_objs(struct server_conf *conf)
{
  struct rlimit limit;
  struct listIterator *i;
  struct base_obj *obj;
  signed int return_value_getrlimit_2;
  return_value_getrlimit_2=getrlimit(7, &limit);
  if(!(return_value_getrlimit_2 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    log_err(*return_value___errno_location_1, "Unable to get open file limit");
  }

  if(!(limit.rlim_cur >= limit.rlim_max))
  {
    limit.rlim_cur = limit.rlim_max;
    signed int return_value_setrlimit_3;
    return_value_setrlimit_3=setrlimit(7, &limit);
    if(!(return_value_setrlimit_3 >= 0))
      log_msg(3, "Unable to set open file limit to %d", limit.rlim_cur);

    else
      log_msg(6, "Increased open file limit to %d", limit.rlim_cur);
  }

  else
    log_msg(6, "Open file limit set to %d", limit.rlim_cur);
  i=list_iterator_create(conf->objs);
  void *return_value_list_next_4;
  do
  {
    return_value_list_next_4=list_next(i);
    obj = (struct base_obj *)return_value_list_next_4;
    if(obj == ((struct base_obj *)NULL))
      break;

    reopen_obj(obj);
  }
  while((_Bool)1);
  list_iterator_destroy(i);
  goto __CPROVER_DUMP_L8;

__CPROVER_DUMP_L8:
  ;
}

// open_process_obj
// file server.h line 438
signed int open_process_obj(struct base_obj *process)
{
  struct process_obj *auxp;
  signed int rc = 0;
  auxp = &process->aux.process;
  if(auxp->timer >= 0)
  {
    tpoll_timeout_cancel(tp_global, auxp->timer);
    auxp->timer = -1;
  }

  if((signed int)auxp->state == 1)
    rc=disconnect_process_obj(process);

  else
    if((signed int)auxp->state == 0)
      rc=connect_process_obj(process);

  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  if(!(rc >= 0))
  {
    auxp->timer=tpoll_timeout_relative(tp_global, (void (*)(void *))open_process_obj, (void *)process, auxp->delay * 1000);
    if(auxp->delay == 0)
      tmp_if_expr_2 = 60;

    else
    {
      if(!(2 * auxp->delay >= 1801))
        tmp_if_expr_1 = auxp->delay * 2;

      else
        tmp_if_expr_1 = 1800;
      tmp_if_expr_2 = tmp_if_expr_1;
    }
    auxp->delay = tmp_if_expr_2;
  }

  return rc;
}

// open_serial_obj
// file server.h line 453
signed int open_serial_obj(struct base_obj *serial)
{
  signed int fd;
  signed int flags;
  struct termios tty;
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(serial->fd >= 0)
  {
    write_notify_msg(serial, 6, "Console [%s] disconnected from \"%s\"", serial->name, serial->aux.serial.dev);
    set_tty_mode(&serial->aux.serial.tty, serial->fd);
    signed int return_value_close_3;
    return_value_close_3=close(serial->fd);
    if(!(return_value_close_3 >= 0))
    {
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_msg(4, "Unable to close [%s] device \"%s\": %s", serial->name, serial->aux.serial.dev, return_value_strerror_2);
    }

    serial->fd = -1;
  }

  flags = 02 | 04000 | 0400;
  fd=open(serial->aux.serial.dev, flags);
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    log_msg(4, "Unable to open [%s] device \"%s\": %s", serial->name, serial->aux.serial.dev, return_value_strerror_5);
    goto err;
  }

  signed int return_value_get_write_lock_6;
  return_value_get_write_lock_6=get_write_lock(fd);
  signed int return_value_isatty_7;
  if(!(return_value_get_write_lock_6 >= 0))
    log_msg(4, "Unable to lock [%s] device \"%s\"", serial->name, serial->aux.serial.dev);

  else
  {
    return_value_isatty_7=isatty(fd);
    if(return_value_isatty_7 == 0)
      log_msg(4, "[%s] device \"%s\" not a terminal", serial->name, serial->aux.serial.dev);

    else
    {
      set_fd_nonblocking(fd);
      set_fd_closed_on_exec(fd);
      get_tty_mode(&serial->aux.serial.tty, fd);
      get_tty_raw(&tty, fd);
      set_serial_opts(&tty, serial, &serial->aux.serial.opts);
      set_tty_mode(&tty, fd);
      serial->fd = fd;
      serial->gotEOF = (unsigned int)0;
      write_notify_msg(serial, 6, "Console [%s] connected to \"%s\"", serial->name, serial->aux.serial.dev);
      return 0;
    }
  }

err:
  ;
  if(fd >= 0)
    close(fd);

  return -1;
}

// open_telnet_obj
// file server.h line 468
signed int open_telnet_obj(struct base_obj *telnet)
{
  signed int rc = 0;
  if((signed int)telnet->aux.telnet.state == 3)
    disconnect_telnet_obj(telnet);

  else
    rc=connect_telnet_obj(telnet);
  return rc;
}

// open_unixsock_obj
// file server.h line 482
signed int open_unixsock_obj(struct base_obj *unixsock)
{
  signed int rc = 0;
  if((signed int)unixsock->aux.unixsock.state == 1)
    rc=disconnect_unixsock_obj(unixsock);

  else
    rc=connect_unixsock_obj(unixsock);
  return rc;
}

// opt2str
// file server-telnet.c line 566
static char * opt2str(signed int opt, char *buf, signed int buflen)
{
  snprintf(buf, (unsigned long int)buflen, "OPT:%d", opt);
  return buf;
}

// parse_cmd_opts
// file server-sock.c line 374
static void parse_cmd_opts(struct lexer_state *l, struct request *req)
{
  signed int parse_cmd_opts__1__done = 0;
  signed int tok;
  char *str;
  signed int return_value_lex_next_5;
  signed int return_value_lex_next_4;
  const char *return_value_lex_text_3;
  signed int return_value_lex_next_11;
  signed int return_value_lex_prev_9;
  signed int return_value_lex_prev_8;
  signed int return_value_lex_prev_7;
  signed int return_value_lex_prev_6;
  while(parse_cmd_opts__1__done == 0)
  {
    tok=lex_next(l);
    switch(tok)
    {
      case 262:
      {
        return_value_lex_next_5=lex_next(l);
        if(return_value_lex_next_5 == 61)
        {
          return_value_lex_next_4=lex_next(l);
          if(return_value_lex_next_4 == 258)
          {
            return_value_lex_text_3=lex_text(l);
            if(!((signed int)*return_value_lex_text_3 == 0))
            {
              const char *return_value_lex_text_1;
              return_value_lex_text_1=lex_text(l);
              char *return_value_create_string_2;
              return_value_create_string_2=create_string(return_value_lex_text_1);
              str=lex_decode(return_value_create_string_2);
              list_append(req->consoles, (void *)str);
            }

          }

        }

        break;
      }
      case 270:
      {
        return_value_lex_next_11=lex_next(l);
        if(return_value_lex_next_11 == 61)
        {
          signed int return_value_lex_next_10;
          return_value_lex_next_10=lex_next(l);
          if(return_value_lex_next_10 == 259)
            req->enableBroadcast = (unsigned int)1;

          else
          {
            return_value_lex_prev_9=lex_prev(l);
            if(return_value_lex_prev_9 == 264)
              req->enableForce = (unsigned int)1;

            else
            {
              return_value_lex_prev_8=lex_prev(l);
              if(return_value_lex_prev_8 == 266)
                req->enableJoin = (unsigned int)1;

              else
              {
                return_value_lex_prev_7=lex_prev(l);
                if(return_value_lex_prev_7 == 272)
                  req->enableQuiet = (unsigned int)1;

                else
                {
                  return_value_lex_prev_6=lex_prev(l);
                  if(return_value_lex_prev_6 == 273)
                    req->enableRegex = (unsigned int)1;

                }
              }
            }
          }
        }

        break;
      }
      case 0:

      case 256:
      {
        parse_cmd_opts__1__done = 1;
        break;
      }
      default:
        ;
    }
  }
  goto __CPROVER_DUMP_L15;

__CPROVER_DUMP_L15:
  ;
}

// parse_console_directive
// file server-conf.c line 592
static void parse_console_directive(struct server_conf *conf, struct lexer_state *l)
{
  char *directive;
  signed int line;
  signed int tok;
  signed int parse_console_directive__1__done = 0;
  char err[1024l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct console_strs con;
  memset((void *)&con, 0, sizeof(struct console_strs) /*48ul*/ );
  signed int return_value_lex_prev_1;
  return_value_lex_prev_1=lex_prev(l);
  signed int tmp_if_expr_4;
  signed int return_value_lex_prev_2;
  signed int return_value_lex_prev_3;
  if(!(return_value_lex_prev_1 >= 259))
  {
    return_value_lex_prev_2=lex_prev(l);
    tmp_if_expr_4 = return_value_lex_prev_2;
  }

  else
  {
    return_value_lex_prev_3=lex_prev(l);
    tmp_if_expr_4 = return_value_lex_prev_3 - 259;
  }
  directive = server_conf_strs[(signed long int)tmp_if_expr_4];
  line=lex_line(l);
  signed int return_value_lex_next_10;
  signed int return_value_lex_next_6;
  _Bool tmp_if_expr_9;
  const char *return_value_lex_text_7;
  signed int return_value_is_empty_string_8;
  signed int return_value_lex_next_16;
  signed int return_value_lex_next_12;
  _Bool tmp_if_expr_15;
  const char *return_value_lex_text_13;
  signed int return_value_is_empty_string_14;
  signed int return_value_lex_next_26;
  signed int return_value_lex_next_25;
  const char *return_value_lex_text_23;
  char *return_value_strchr_24;
  const char *return_value_lex_text_21;
  signed int return_value_is_empty_string_22;
  const char *return_value_lex_text_19;
  _Bool tmp_if_expr_20;
  signed int return_value_lex_next_32;
  signed int return_value_lex_next_28;
  _Bool tmp_if_expr_31;
  const char *return_value_lex_text_29;
  signed int return_value_is_empty_string_30;
  signed int return_value_lex_next_38;
  signed int return_value_lex_next_34;
  _Bool tmp_if_expr_37;
  const char *return_value_lex_text_35;
  signed int return_value_is_empty_string_36;
  signed int return_value_lex_next_41;
  signed int return_value_lex_next_40;
  const char *return_value_lex_text_42;
  while(parse_console_directive__1__done == 0)
  {
    if(!(err[0l] == 0))
      break;

    tok=lex_next(l);
    switch(tok)
    {
      case 272:
      {
        return_value_lex_next_10=lex_next(l);
        if(!(return_value_lex_next_10 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_6=lex_next(l);
          if(!(return_value_lex_next_6 == 258))
            tmp_if_expr_9 = (_Bool)1;

          else
          {
            return_value_lex_text_7=lex_text(l);
            return_value_is_empty_string_8=is_empty_string(return_value_lex_text_7);
            tmp_if_expr_9 = return_value_is_empty_string_8 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_9)
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            const char *return_value_lex_text_5;
            return_value_lex_text_5=lex_text(l);
            replace_string(&con.name, return_value_lex_text_5);
          }
        }
        break;
      }
      case 262:
      {
        return_value_lex_next_16=lex_next(l);
        if(!(return_value_lex_next_16 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_12=lex_next(l);
          if(!(return_value_lex_next_12 == 258))
            tmp_if_expr_15 = (_Bool)1;

          else
          {
            return_value_lex_text_13=lex_text(l);
            return_value_is_empty_string_14=is_empty_string(return_value_lex_text_13);
            tmp_if_expr_15 = return_value_is_empty_string_14 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_15)
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            const char *return_value_lex_text_11;
            return_value_lex_text_11=lex_text(l);
            replace_string(&con.dev, return_value_lex_text_11);
          }
        }
        break;
      }
      case 267:
      {
        return_value_lex_next_26=lex_next(l);
        if(!(return_value_lex_next_26 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_25=lex_next(l);
          if(!(return_value_lex_next_25 == 258))
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            return_value_lex_text_23=lex_text(l);
            return_value_strchr_24=strchr(return_value_lex_text_23, 38);
            if(!(return_value_strchr_24 == ((char *)NULL)))
              snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "ignoring %s %s value with deprecated '%c' -- use '%%N'", directive, server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)], 38);

            else
            {
              return_value_lex_text_21=lex_text(l);
              return_value_is_empty_string_22=is_empty_string(return_value_lex_text_21);
              if(!(return_value_is_empty_string_22 == 0))
                replace_string(&con.log, "");

              else
              {
                return_value_lex_text_19=lex_text(l);
                if(!((signed int)*return_value_lex_text_19 == 47))
                  tmp_if_expr_20 = conf->logDirName != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_20 = (_Bool)0;
                if(tmp_if_expr_20)
                {
                  destroy_string(con.log);
                  const char *return_value_lex_text_17;
                  return_value_lex_text_17=lex_text(l);
                  con.log=create_format_string("%s/%s", conf->logDirName, return_value_lex_text_17);
                }

                else
                {
                  const char *return_value_lex_text_18;
                  return_value_lex_text_18=lex_text(l);
                  replace_string(&con.log, return_value_lex_text_18);
                }
              }
            }
          }
        }
        break;
      }
      case 270:
      {
        return_value_lex_next_32=lex_next(l);
        if(!(return_value_lex_next_32 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_28=lex_next(l);
          if(!(return_value_lex_next_28 == 258))
            tmp_if_expr_31 = (_Bool)1;

          else
          {
            return_value_lex_text_29=lex_text(l);
            return_value_is_empty_string_30=is_empty_string(return_value_lex_text_29);
            tmp_if_expr_31 = return_value_is_empty_string_30 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_31)
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            const char *return_value_lex_text_27;
            return_value_lex_text_27=lex_text(l);
            replace_string(&con.lopts, return_value_lex_text_27);
          }
        }
        break;
      }
      case 278:
      {
        return_value_lex_next_38=lex_next(l);
        if(!(return_value_lex_next_38 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_34=lex_next(l);
          if(!(return_value_lex_next_34 == 258))
            tmp_if_expr_37 = (_Bool)1;

          else
          {
            return_value_lex_text_35=lex_text(l);
            return_value_is_empty_string_36=is_empty_string(return_value_lex_text_35);
            tmp_if_expr_37 = return_value_is_empty_string_36 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_37)
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            const char *return_value_lex_text_33;
            return_value_lex_text_33=lex_text(l);
            replace_string(&con.sopts, return_value_lex_text_33);
          }
        }
        break;
      }
      case 265:
      {
        return_value_lex_next_41=lex_next(l);
        if(!(return_value_lex_next_41 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "unexpected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_40=lex_next(l);
          if(!(return_value_lex_next_40 == 258))
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            const char *return_value_lex_text_39;
            return_value_lex_text_39=lex_text(l);
            replace_string(&con.iopts, return_value_lex_text_39);
          }
        }
        break;
      }
      case 0:

      case 256:
      {
        parse_console_directive__1__done = 1;
        break;
      }
      case -1:
      {
        snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "unmatched quote");
        break;
      }
      default:
      {
        return_value_lex_text_42=lex_text(l);
        snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "unrecognized token '%s'", return_value_lex_text_42);
      }
    }
  }
  if(err[0l] == 0)
  {
    if(con.dev == ((char *)NULL) || con.name == ((char *)NULL))
      snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "incomplete %s directive", directive);

    else
      process_console(conf, &con, err, (signed int)sizeof(char [1024l]) /*1024ul*/ );
  }

  signed int return_value_lex_prev_44;
  signed int return_value_lex_prev_45;
  if(!(err[0l] == 0))
  {
    signed int return_value_lex_line_43;
    return_value_lex_line_43=lex_line(l);
    log_msg(3, "CONFIG[%s:%d]: %s", conf->confFileName, return_value_lex_line_43, (const void *)err);
    do
    {
      return_value_lex_prev_44=lex_prev(l);
      if(return_value_lex_prev_44 == 256)
        break;

      return_value_lex_prev_45=lex_prev(l);
      if(return_value_lex_prev_45 == 0)
        break;

      lex_next(l);
    }
    while((_Bool)1);
  }

  destroy_string(con.name);
  destroy_string(con.dev);
  destroy_string(con.log);
  destroy_string(con.lopts);
  destroy_string(con.sopts);
  destroy_string(con.iopts);
  goto __CPROVER_DUMP_L51;

__CPROVER_DUMP_L51:
  ;
}

// parse_global_directive
// file server-conf.c line 937
static void parse_global_directive(struct server_conf *conf, struct lexer_state *l)
{
  char *directive;
  signed int tok;
  signed int parse_global_directive__1__done = 0;
  char err[1024l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int return_value_lex_prev_1;
  return_value_lex_prev_1=lex_prev(l);
  signed int tmp_if_expr_4;
  signed int return_value_lex_prev_2;
  signed int return_value_lex_prev_3;
  if(!(return_value_lex_prev_1 >= 259))
  {
    return_value_lex_prev_2=lex_prev(l);
    tmp_if_expr_4 = return_value_lex_prev_2;
  }

  else
  {
    return_value_lex_prev_3=lex_prev(l);
    tmp_if_expr_4 = return_value_lex_prev_3 - 259;
  }
  directive = server_conf_strs[(signed long int)tmp_if_expr_4];
  signed int return_value_lex_next_16;
  signed int return_value_lex_next_15;
  const char *return_value_lex_text_13;
  signed int return_value_is_empty_string_14;
  const char *return_value_lex_text_11;
  char *return_value_strchr_12;
  const char *return_value_lex_text_6;
  char *return_value_strstr_7;
  _Bool tmp_if_expr_10;
  const char *return_value_lex_text_8;
  char *return_value_strstr_9;
  signed int return_value_lex_next_22;
  signed int return_value_lex_next_18;
  _Bool tmp_if_expr_21;
  const char *return_value_lex_text_19;
  signed int return_value_is_empty_string_20;
  signed int return_value_lex_next_28;
  signed int return_value_lex_next_24;
  _Bool tmp_if_expr_27;
  const char *return_value_lex_text_25;
  signed int return_value_is_empty_string_26;
  signed int return_value_lex_next_34;
  signed int return_value_lex_next_30;
  _Bool tmp_if_expr_33;
  const char *return_value_lex_text_31;
  signed int return_value_is_empty_string_32;
  const char *return_value_lex_text_35;
  while(parse_global_directive__1__done == 0)
  {
    if(!(err[0l] == 0))
      break;

    tok=lex_next(l);
    switch(tok)
    {
      case 267:
      {
        return_value_lex_next_16=lex_next(l);
        if(!(return_value_lex_next_16 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_15=lex_next(l);
          if(!(return_value_lex_next_15 == 258))
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            return_value_lex_text_13=lex_text(l);
            return_value_is_empty_string_14=is_empty_string(return_value_lex_text_13);
            if(!(return_value_is_empty_string_14 == 0))
            {
              destroy_string(conf->globalLogName);
              conf->globalLogName = (char *)(void *)0;
            }

            else
            {
              return_value_lex_text_11=lex_text(l);
              return_value_strchr_12=strchr(return_value_lex_text_11, 38);
              if(!(return_value_strchr_12 == ((char *)NULL)))
                snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "ignoring %s %s value with deprecated '%c' -- use '%%N'", directive, server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)], 38);

              else
              {
                return_value_lex_text_6=lex_text(l);
                return_value_strstr_7=strstr(return_value_lex_text_6, "%N");
                if(return_value_strstr_7 == ((char *)NULL))
                {
                  return_value_lex_text_8=lex_text(l);
                  return_value_strstr_9=strstr(return_value_lex_text_8, "%D");
                  tmp_if_expr_10 = !(return_value_strstr_9 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_10 = (_Bool)0;
                if(tmp_if_expr_10)
                  snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "ignoring %s %s value without '%%N' or '%%D'", directive, server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

                else
                {
                  destroy_string(conf->globalLogName);
                  const char *return_value_lex_text_5;
                  return_value_lex_text_5=lex_text(l);
                  conf->globalLogName=create_string(return_value_lex_text_5);
                }
              }
            }
          }
        }
        break;
      }
      case 270:
      {
        return_value_lex_next_22=lex_next(l);
        if(!(return_value_lex_next_22 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_18=lex_next(l);
          if(!(return_value_lex_next_18 == 258))
            tmp_if_expr_21 = (_Bool)1;

          else
          {
            return_value_lex_text_19=lex_text(l);
            return_value_is_empty_string_20=is_empty_string(return_value_lex_text_19);
            tmp_if_expr_21 = return_value_is_empty_string_20 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_21)
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            const char *return_value_lex_text_17;
            return_value_lex_text_17=lex_text(l);
            parse_logfile_opts(&conf->globalLogOpts, return_value_lex_text_17, err, (signed int)sizeof(char [1024l]) /*1024ul*/ );
          }
        }
        break;
      }
      case 278:
      {
        return_value_lex_next_28=lex_next(l);
        if(!(return_value_lex_next_28 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_24=lex_next(l);
          if(!(return_value_lex_next_24 == 258))
            tmp_if_expr_27 = (_Bool)1;

          else
          {
            return_value_lex_text_25=lex_text(l);
            return_value_is_empty_string_26=is_empty_string(return_value_lex_text_25);
            tmp_if_expr_27 = return_value_is_empty_string_26 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_27)
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            const char *return_value_lex_text_23;
            return_value_lex_text_23=lex_text(l);
            parse_serial_opts(&conf->globalSerOpts, return_value_lex_text_23, err, (signed int)sizeof(char [1024l]) /*1024ul*/ );
          }
        }
        break;
      }
      case 265:
      {
        return_value_lex_next_34=lex_next(l);
        if(!(return_value_lex_next_34 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_30=lex_next(l);
          if(!(return_value_lex_next_30 == 258))
            tmp_if_expr_33 = (_Bool)1;

          else
          {
            return_value_lex_text_31=lex_text(l);
            return_value_is_empty_string_32=is_empty_string(return_value_lex_text_31);
            tmp_if_expr_33 = return_value_is_empty_string_32 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_33)
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            const char *return_value_lex_text_29;
            return_value_lex_text_29=lex_text(l);
            parse_ipmi_opts(&conf->globalIpmiOpts, return_value_lex_text_29, err, (signed int)sizeof(char [1024l]) /*1024ul*/ );
          }
        }
        break;
      }
      case 0:

      case 256:
      {
        parse_global_directive__1__done = 1;
        break;
      }
      case -1:
      {
        snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "unmatched quote");
        break;
      }
      default:
      {
        return_value_lex_text_35=lex_text(l);
        snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "unrecognized token '%s'", return_value_lex_text_35);
      }
    }
  }
  signed int return_value_lex_prev_37;
  signed int return_value_lex_prev_38;
  if(!(err[0l] == 0))
  {
    signed int return_value_lex_line_36;
    return_value_lex_line_36=lex_line(l);
    log_msg(3, "CONFIG[%s:%d]: %s", conf->confFileName, return_value_lex_line_36, (const void *)err);
    do
    {
      return_value_lex_prev_37=lex_prev(l);
      if(return_value_lex_prev_37 == 256)
        break;

      return_value_lex_prev_38=lex_prev(l);
      if(return_value_lex_prev_38 == 0)
        break;

      lex_next(l);
    }
    while((_Bool)1);
  }

  goto __CPROVER_DUMP_L39;

__CPROVER_DUMP_L39:
  ;
}

// parse_greeting
// file server-sock.c line 279
static void parse_greeting(struct lexer_state *l, struct request *req)
{
  signed int parse_greeting__1__done = 0;
  signed int tok;
  signed int return_value_lex_next_5;
  signed int return_value_lex_next_4;
  const char *return_value_lex_text_3;
  signed int return_value_lex_next_10;
  signed int return_value_lex_next_9;
  const char *return_value_lex_text_8;
  while(parse_greeting__1__done == 0)
  {
    tok=lex_next(l);
    switch(tok)
    {
      case 276:
      {
        return_value_lex_next_5=lex_next(l);
        if(return_value_lex_next_5 == 61)
        {
          return_value_lex_next_4=lex_next(l);
          if(return_value_lex_next_4 == 258)
          {
            return_value_lex_text_3=lex_text(l);
            if(!((signed int)*return_value_lex_text_3 == 0))
            {
              if(!(req->user == ((char *)NULL)))
                free((void *)req->user);

              const char *return_value_lex_text_1;
              return_value_lex_text_1=lex_text(l);
              char *return_value_create_string_2;
              return_value_create_string_2=create_string(return_value_lex_text_1);
              req->user=lex_decode(return_value_create_string_2);
            }

          }

        }

        break;
      }
      case 275:
      {
        return_value_lex_next_10=lex_next(l);
        if(return_value_lex_next_10 == 61)
        {
          return_value_lex_next_9=lex_next(l);
          if(return_value_lex_next_9 == 258)
          {
            return_value_lex_text_8=lex_text(l);
            if(!((signed int)*return_value_lex_text_8 == 0))
            {
              if(!(req->tty == ((char *)NULL)))
                free((void *)req->tty);

              const char *return_value_lex_text_6;
              return_value_lex_text_6=lex_text(l);
              char *return_value_create_string_7;
              return_value_create_string_7=create_string(return_value_lex_text_6);
              req->tty=lex_decode(return_value_create_string_7);
            }

          }

        }

        break;
      }
      case 0:

      case 256:
      {
        parse_greeting__1__done = 1;
        break;
      }
      default:
        ;
    }
  }
  goto __CPROVER_DUMP_L12;

__CPROVER_DUMP_L12:
  ;
}

// parse_ipmi_opts
// file server.h line 366
signed int parse_ipmi_opts(struct ipmi_opt *iopts, const char *str, char *errbuf, signed int errlen)
{
  struct ipmi_opt ioptsTmp;
  char buf[1024l];
  char *tok;
  const char * const separators = ",";
  if(iopts == ((struct ipmi_opt *)NULL))
    log_err(0, "parse_ipmi_opts: iopts ptr is NULL");

  ioptsTmp = *iopts;
  unsigned long int return_value_strlcpy_1;
  return_value_strlcpy_1=strlcpy(buf, str, sizeof(char [1024l]) /*1024ul*/ );
  _Bool tmp_if_expr_4;
  if(return_value_strlcpy_1 >= sizeof(char [1024l]) /*1024ul*/ )
  {
    if(errlen >= 1 && !(errbuf == ((char *)NULL)))
      snprintf(errbuf, (unsigned long int)errlen, "ipmiopts string exceeds %d-byte maximum", (signed int)sizeof(char [1024l]) /*1024ul*/  - 1);

    return -1;
  }

  else
  {
    if(!((signed int)buf[0l] == 0))
      tmp_if_expr_4 = (signed int)buf[(signed long int)1] != 58 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      signed int return_value_parse_ipmi_opts_v1_2;
      return_value_parse_ipmi_opts_v1_2=parse_ipmi_opts_v1(&ioptsTmp, buf, errbuf, errlen);
      if(!(return_value_parse_ipmi_opts_v1_2 >= 0))
        return -1;

    }

    else
    {
      tok=strtok(buf, separators);
      while(!(tok == ((char *)NULL)))
      {
        signed int return_value_process_ipmi_opt_3;
        return_value_process_ipmi_opt_3=process_ipmi_opt(&ioptsTmp, tok, errbuf, errlen);
        if(!(return_value_process_ipmi_opt_3 >= 0))
          return -1;

        tok=strtok((char *)(void *)0, separators);
      }
    }
    *iopts = ioptsTmp;
    return 0;
  }
}

// parse_ipmi_opts_v1
// file server-ipmi.c line 222
static signed int parse_ipmi_opts_v1(struct ipmi_opt *iopts, char *str, char *errbuf, signed int errlen)
{
  char *tok;
  const char * const separators = ",";
  tok=strtok(str, separators);
  if(!(tok == ((char *)NULL)))
  {
    if((signed int)*tok == 45)
    {
      if((signed int)tok[1l] == 0)
        tok = tok + 1l;

    }

    signed int return_value_process_ipmi_opt_username_1;
    return_value_process_ipmi_opt_username_1=process_ipmi_opt_username(iopts, tok, errbuf, errlen);
    if(!(return_value_process_ipmi_opt_username_1 >= 0))
      return -1;

  }

  tok=strtok((char *)(void *)0, separators);
  if(!(tok == ((char *)NULL)))
  {
    if((signed int)*tok == 45)
    {
      if((signed int)tok[1l] == 0)
        tok = tok + 1l;

    }

    signed int return_value_process_ipmi_opt_password_2;
    return_value_process_ipmi_opt_password_2=process_ipmi_opt_password(iopts, tok, errbuf, errlen);
    if(!(return_value_process_ipmi_opt_password_2 >= 0))
      return -1;

  }

  tok=strtok((char *)(void *)0, separators);
  if(!(tok == ((char *)NULL)))
  {
    if((signed int)*tok == 45)
    {
      if((signed int)tok[1l] == 0)
        tok = tok + 1l;

    }

    signed int return_value_process_ipmi_opt_k_g_3;
    return_value_process_ipmi_opt_k_g_3=process_ipmi_opt_k_g(iopts, tok, errbuf, errlen);
    if(!(return_value_process_ipmi_opt_k_g_3 >= 0))
      return -1;

  }

  do
  {
    tok=strtok((char *)(void *)0, separators);
    if(tok == ((char *)NULL))
      break;

    if((signed int)*tok == 45)
    {
      if((signed int)tok[1l] == 0)
        tok = tok + 1l;

    }

    signed int return_value_process_ipmi_opt_workaround_4;
    return_value_process_ipmi_opt_workaround_4=process_ipmi_opt_workaround(iopts, tok, errbuf, errlen);
    if(!(return_value_process_ipmi_opt_workaround_4 >= 0))
      return -1;

  }
  while((_Bool)1);
  return 0;
}

// parse_key
// file server-ipmi.c line 633
static signed int parse_key(char *dst, const char *src, unsigned long int dstlen)
{
  const char *hexdigits = "0123456789ABCDEFabcdef";
  char *dstend;
  char *p;
  char *q;
  signed int n;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_11;
  unsigned long int return_value_strspn_9;
  unsigned long int return_value_strlen_10;
  char *tmp_post_1;
  char *tmp_post_3;
  char *tmp_post_4;
  if(dstlen == 0ul)
    return -1;

  else
  {
    if((signed int)*src == 48)
    {
      if((signed int)src[1l] == 120)
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = (signed int)src[(signed long int)1] == 88 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    if(tmp_if_expr_8)
    {
      return_value_strspn_9=strspn(src + (signed long int)2, hexdigits);
      return_value_strlen_10=strlen(src + (signed long int)2);
      tmp_if_expr_11 = return_value_strspn_9 == return_value_strlen_10 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_11 = (_Bool)0;
    if(tmp_if_expr_11)
    {
      dstend = (dst + (signed long int)dstlen) - (signed long int)1;
      p = (char *)src + (signed long int)2;
      q = dst;
      n = 0;
      while(!(*p == 0))
      {
        if(q >= dstend)
          break;

        if((p - src & 1l) == 0l)
        {
          tmp_post_1 = p;
          p = p + 1l;
          signed int return_value_toint_2;
          return_value_toint_2=toint((signed int)*tmp_post_1);
          *q = (char)(return_value_toint_2 << 4 & 0xf0);
          n = n + 1;
        }

        else
        {
          tmp_post_3 = q;
          q = q + 1l;
          tmp_post_4 = p;
          p = p + 1l;
          signed int return_value_toint_5;
          return_value_toint_5=toint((signed int)*tmp_post_4);
          *tmp_post_3 = *tmp_post_3 | (char)(return_value_toint_5 & 0x0f);
        }
      }
      dst[(signed long int)n] = (char)0;
      if(!(*p == 0))
        return -1;

    }

    else
    {
      unsigned long int return_value_strlcpy_6;
      return_value_strlcpy_6=strlcpy(dst, src, dstlen);
      n = (signed int)return_value_strlcpy_6;
      if((unsigned long int)n >= dstlen)
        return -1;

    }
    return n;
  }
}

// parse_logfile_opts
// file server.h line 381
signed int parse_logfile_opts(struct logfile_opt *opts, const char *str, char *errbuf, signed int errlen)
{
  struct logfile_opt optsTmp;
  char buf[1024l];
  const char * const separators = " \t\n.,;";
  char *tok;
  optsTmp = *opts;
  _Bool tmp_if_expr_1;
  if(str == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)str[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_strcasecmp_7;
  signed int return_value_strcasecmp_6;
  signed int return_value_strcasecmp_5;
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_3;
  if(tmp_if_expr_1)
  {
    if(errlen >= 1 && !(errbuf == ((char *)NULL)))
      snprintf(errbuf, (unsigned long int)errlen, "encountered empty options string");

    return -1;
  }

  else
  {
    unsigned long int return_value_strlcpy_2;
    return_value_strlcpy_2=strlcpy(buf, str, sizeof(char [1024l]) /*1024ul*/ );
    if(return_value_strlcpy_2 >= sizeof(char [1024l]) /*1024ul*/ )
    {
      if(errlen >= 1 && !(errbuf == ((char *)NULL)))
        snprintf(errbuf, (unsigned long int)errlen, "logopt string exceeded buffer size");

      return -1;
    }

    else
    {
      tok=strtok(buf, separators);
      while(!(tok == ((char *)NULL)))
      {
        signed int return_value_strcasecmp_8;
        return_value_strcasecmp_8=strcasecmp(tok, "lock");
        if(return_value_strcasecmp_8 == 0)
          optsTmp.enableLock = (unsigned int)1;

        else
        {
          return_value_strcasecmp_7=strcasecmp(tok, "nolock");
          if(return_value_strcasecmp_7 == 0)
            optsTmp.enableLock = (unsigned int)0;

          else
          {
            return_value_strcasecmp_6=strcasecmp(tok, "sanitize");
            if(return_value_strcasecmp_6 == 0)
              optsTmp.enableSanitize = (unsigned int)1;

            else
            {
              return_value_strcasecmp_5=strcasecmp(tok, "nosanitize");
              if(return_value_strcasecmp_5 == 0)
                optsTmp.enableSanitize = (unsigned int)0;

              else
              {
                return_value_strcasecmp_4=strcasecmp(tok, "timestamp");
                if(return_value_strcasecmp_4 == 0)
                  optsTmp.enableTimestamp = (unsigned int)1;

                else
                {
                  return_value_strcasecmp_3=strcasecmp(tok, "notimestamp");
                  if(return_value_strcasecmp_3 == 0)
                    optsTmp.enableTimestamp = (unsigned int)0;

                  else
                    log_msg(4, "ignoring unrecognized token '%s'", tok);
                }
              }
            }
          }
        }
        tok=strtok((char *)(void *)0, separators);
      }
      *opts = optsTmp;
      return 0;
    }
  }
}

// parse_serial_opts
// file server.h line 445
signed int parse_serial_opts(struct serial_opt *opts, const char *str, char *errbuf, signed int errlen)
{
  signed int n;
  struct serial_opt optsTmp;
  signed int bpsTmp;
  char parityTmp;
  optsTmp = *opts;
  _Bool tmp_if_expr_1;
  if(str == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)str[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    if(errlen >= 1 && !(errbuf == ((char *)NULL)))
      snprintf(errbuf, (unsigned long int)errlen, "encountered empty options string");

    return -1;
  }

  else
  {
    n=sscanf(str, "%d,%d%c%d", &bpsTmp, &optsTmp.databits, &parityTmp, &optsTmp.stopbits);
    if(n >= 1)
    {
      optsTmp.bps=int_to_bps(bpsTmp);
      if(optsTmp.bps >= 1u)
        goto __CPROVER_DUMP_L6;

      if(errlen >= 1 && !(errbuf == ((char *)NULL)))
        snprintf(errbuf, (unsigned long int)errlen, "expected INTEGER >0 for bps setting");

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      if(n >= 2)
      {
        if(!(optsTmp.databits >= 9) && optsTmp.databits >= 5)
          goto __CPROVER_DUMP_L8;

        if(errlen >= 1 && !(errbuf == ((char *)NULL)))
          snprintf(errbuf, (unsigned long int)errlen, "expected INTEGER 5-8 for databits setting");

        return -1;
      }

      else
      {

      __CPROVER_DUMP_L8:
        ;
        if(n >= 3)
          switch((signed int)parityTmp)
          {
            case 78:

            case 110:
            {
              optsTmp.parity = 0;
              goto __CPROVER_DUMP_L14;
            }
            case 79:

            case 111:
            {
              optsTmp.parity = 1;
              goto __CPROVER_DUMP_L14;
            }
            case 69:

            case 101:
            {
              optsTmp.parity = 2;
              goto __CPROVER_DUMP_L14;
            }
            default:
            {
              if(errlen >= 1 && !(errbuf == ((char *)NULL)))
                snprintf(errbuf, (unsigned long int)errlen, "expected (N|O|E) for parity setting");

              return -1;
            }
          }

        else
        {

        __CPROVER_DUMP_L14:
          ;
          if(n >= 4)
          {
            if(!(optsTmp.stopbits >= 3) && optsTmp.stopbits >= 1)
              goto __CPROVER_DUMP_L16;

            if(errlen >= 1 && !(errbuf == ((char *)NULL)))
              snprintf(errbuf, (unsigned long int)errlen, "expected INTEGER 1-2 for stopbits setting");

            return -1;
          }

          else
          {

          __CPROVER_DUMP_L16:
            ;
            *opts = optsTmp;
            return 0;
          }
        }
      }
    }
  }
}

// parse_server_directive
// file server-conf.c line 1062
static void parse_server_directive(struct server_conf *conf, struct lexer_state *l)
{
  char *directive;
  signed int tok;
  signed int parse_server_directive__1__done = 0;
  char err[1024l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char *p;
  signed int n;
  struct stat st;
  signed int return_value_lex_prev_1;
  return_value_lex_prev_1=lex_prev(l);
  signed int tmp_if_expr_4;
  signed int return_value_lex_prev_2;
  signed int return_value_lex_prev_3;
  if(!(return_value_lex_prev_1 >= 259))
  {
    return_value_lex_prev_2=lex_prev(l);
    tmp_if_expr_4 = return_value_lex_prev_2;
  }

  else
  {
    return_value_lex_prev_3=lex_prev(l);
    tmp_if_expr_4 = return_value_lex_prev_3 - 259;
  }
  directive = server_conf_strs[(signed long int)tmp_if_expr_4];
  signed int return_value_lex_next_7;
  signed int return_value_lex_next_6;
  signed int return_value_lex_prev_5;
  signed int return_value_lex_next_23;
  signed int return_value_lex_next_22;
  const char *return_value_lex_text_20;
  signed int return_value_is_empty_string_21;
  const char *return_value_lex_text_18;
  signed int return_value_stat_19;
  char *tmp_if_expr_15;
  const char *return_value_lex_text_11;
  char *return_value_create_format_string_12;
  const char *return_value_lex_text_13;
  char *return_value_create_string_14;
  char *tmp_post_17;
  signed int return_value_lex_next_30;
  signed int return_value_lex_next_29;
  const char *return_value_lex_text_27;
  unsigned long int return_value_strlen_28;
  const char *return_value_lex_text_25;
  signed int return_value_is_empty_string_26;
  signed int return_value_lex_next_33;
  signed int return_value_lex_next_32;
  signed int return_value_lex_prev_31;
  signed int return_value_lex_next_43;
  signed int return_value_lex_next_42;
  const char *return_value_lex_text_40;
  signed int return_value_is_empty_string_41;
  char *tmp_if_expr_39;
  const char *return_value_lex_text_35;
  char *return_value_create_format_string_36;
  const char *return_value_lex_text_37;
  char *return_value_create_string_38;
  signed int return_value_lex_next_53;
  signed int return_value_lex_next_49;
  _Bool tmp_if_expr_52;
  const char *return_value_lex_text_50;
  signed int return_value_is_empty_string_51;
  _Bool tmp_if_expr_47;
  char *tmp_post_48;
  signed int return_value_lex_next_56;
  signed int return_value_lex_next_55;
  signed int return_value_lex_prev_54;
  signed int return_value_lex_next_64;
  signed int return_value_lex_next_60;
  _Bool tmp_if_expr_63;
  const char *return_value_lex_text_61;
  signed int return_value_is_empty_string_62;
  signed int return_value_lex_next_67;
  signed int return_value_lex_next_66;
  const char *return_value_lex_text_65;
  signed int return_value_lex_next_75;
  signed int return_value_lex_next_71;
  _Bool tmp_if_expr_74;
  const char *return_value_lex_text_72;
  signed int return_value_is_empty_string_73;
  const char *return_value_lex_text_69;
  char *return_value_strchr_70;
  signed int return_value_lex_next_82;
  signed int return_value_lex_next_78;
  _Bool tmp_if_expr_81;
  const char *return_value_lex_text_79;
  signed int return_value_is_empty_string_80;
  const char *return_value_lex_text_77;
  signed int return_value_lex_next_85;
  signed int return_value_lex_next_84;
  signed int return_value_lex_prev_83;
  signed int return_value_lex_next_102;
  signed int return_value_lex_next_101;
  const char *return_value_lex_text_100;
  _Bool tmp_if_expr_99;
  signed int return_value_lex_prev_98;
  signed int return_value_lex_prev_96;
  const char *return_value_lex_text_92;
  _Bool tmp_if_expr_94;
  const char *return_value_lex_text_93;
  const char *return_value_lex_text_89;
  _Bool tmp_if_expr_91;
  const char *return_value_lex_text_90;
  const char *return_value_lex_text_86;
  _Bool tmp_if_expr_88;
  const char *return_value_lex_text_87;
  const char *return_value_lex_text_103;
  while(parse_server_directive__1__done == 0)
  {
    if(!(err[0l] == 0))
      break;

    tok=lex_next(l);
    switch(tok)
    {
      case 260:
      {
        return_value_lex_next_7=lex_next(l);
        if(!(return_value_lex_next_7 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_6=lex_next(l);
          if(return_value_lex_next_6 == 274)
            conf->enableCoreDump = (unsigned int)1;

          else
          {
            return_value_lex_prev_5=lex_prev(l);
            if(return_value_lex_prev_5 == 273)
              conf->enableCoreDump = (unsigned int)0;

            else
              snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected ON or OFF for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);
          }
        }
        break;
      }
      case 261:
      {
        return_value_lex_next_23=lex_next(l);
        if(!(return_value_lex_next_23 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_22=lex_next(l);
          if(!(return_value_lex_next_22 == 258))
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            return_value_lex_text_20=lex_text(l);
            return_value_is_empty_string_21=is_empty_string(return_value_lex_text_20);
            if(!(return_value_is_empty_string_21 == 0))
            {
              destroy_string(conf->coreDumpDir);
              conf->coreDumpDir = (char *)(void *)0;
            }

            else
            {
              return_value_lex_text_18=lex_text(l);
              return_value_stat_19=stat(return_value_lex_text_18, &st);
              if(!(return_value_stat_19 >= 0))
              {
                const char *return_value_lex_text_8;
                return_value_lex_text_8=lex_text(l);
                snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "cannot stat %s \"%s\"", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)], return_value_lex_text_8);
              }

              else
                if(!((61440u & st.st_mode) == 16384u))
                {
                  const char *return_value_lex_text_9;
                  return_value_lex_text_9=lex_text(l);
                  snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "invalid %s \"%s\" not a directory", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)], return_value_lex_text_9);
                }

                else
                {
                  const char *return_value_lex_text_10;
                  return_value_lex_text_10=lex_text(l);
                  if(!((signed int)*return_value_lex_text_10 == 47))
                  {
                    return_value_lex_text_11=lex_text(l);
                    return_value_create_format_string_12=create_format_string("%s/%s", conf->cwd, return_value_lex_text_11);
                    tmp_if_expr_15 = return_value_create_format_string_12;
                  }

                  else
                  {
                    return_value_lex_text_13=lex_text(l);
                    return_value_create_string_14=create_string(return_value_lex_text_13);
                    tmp_if_expr_15 = return_value_create_string_14;
                  }
                  p = tmp_if_expr_15;
                  destroy_string(conf->coreDumpDir);
                  conf->coreDumpDir = p;
                  unsigned long int return_value_strlen_16;
                  return_value_strlen_16=strlen(p);
                  p = p + (signed long int)(return_value_strlen_16 - (unsigned long int)1);
                  for( ; !(conf->coreDumpDir >= p); *tmp_post_17 = (char)0)
                  {
                    if(!((signed int)*p == 47))
                      break;

                    tmp_post_17 = p;
                    p = p - 1l;
                  }
                }
            }
          }
        }
        break;
      }
      case 263:
      {
        return_value_lex_next_30=lex_next(l);
        if(!(return_value_lex_next_30 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_29=lex_next(l);
          if(!(return_value_lex_next_29 == 258))
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            return_value_lex_text_27=lex_text(l);
            return_value_strlen_28=strlen(return_value_lex_text_27);
            if(return_value_strlen_28 >= 4096ul)
              snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "exceeded max length for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

            else
            {
              return_value_lex_text_25=lex_text(l);
              return_value_is_empty_string_26=is_empty_string(return_value_lex_text_25);
              if(!(return_value_is_empty_string_26 == 0))
              {
                destroy_string(conf->execPath);
                conf->execPath = (char *)(void *)0;
              }

              else
              {
                destroy_string(conf->execPath);
                const char *return_value_lex_text_24;
                return_value_lex_text_24=lex_text(l);
                conf->execPath=create_string(return_value_lex_text_24);
              }
            }
          }
        }
        break;
      }
      case 266:
      {
        return_value_lex_next_33=lex_next(l);
        if(!(return_value_lex_next_33 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_32=lex_next(l);
          if(return_value_lex_next_32 == 274)
            conf->enableKeepAlive = (unsigned int)1;

          else
          {
            return_value_lex_prev_31=lex_prev(l);
            if(return_value_lex_prev_31 == 273)
              conf->enableKeepAlive = (unsigned int)0;

            else
              snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected ON or OFF for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);
          }
        }
        break;
      }
      case 268:
      {
        return_value_lex_next_43=lex_next(l);
        if(!(return_value_lex_next_43 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_42=lex_next(l);
          if(!(return_value_lex_next_42 == 258))
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            return_value_lex_text_40=lex_text(l);
            return_value_is_empty_string_41=is_empty_string(return_value_lex_text_40);
            if(!(return_value_is_empty_string_41 == 0))
            {
              destroy_string(conf->logDirName);
              conf->logDirName=create_string(conf->cwd);
            }

            else
            {
              const char *return_value_lex_text_34;
              return_value_lex_text_34=lex_text(l);
              if(!((signed int)*return_value_lex_text_34 == 47))
              {
                return_value_lex_text_35=lex_text(l);
                return_value_create_format_string_36=create_format_string("%s/%s", conf->cwd, return_value_lex_text_35);
                tmp_if_expr_39 = return_value_create_format_string_36;
              }

              else
              {
                return_value_lex_text_37=lex_text(l);
                return_value_create_string_38=create_string(return_value_lex_text_37);
                tmp_if_expr_39 = return_value_create_string_38;
              }
              p = tmp_if_expr_39;
              destroy_string(conf->logDirName);
              conf->logDirName = p;
            }
          }
        }
        break;
      }
      case 269:
      {
        return_value_lex_next_53=lex_next(l);
        if(!(return_value_lex_next_53 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_49=lex_next(l);
          if(!(return_value_lex_next_49 == 258))
            tmp_if_expr_52 = (_Bool)1;

          else
          {
            return_value_lex_text_50=lex_text(l);
            return_value_is_empty_string_51=is_empty_string(return_value_lex_text_50);
            tmp_if_expr_52 = return_value_is_empty_string_51 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_52)
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            destroy_string(conf->logFileName);
            const char *return_value_lex_text_46;
            return_value_lex_text_46=lex_text(l);
            if(!((signed int)*return_value_lex_text_46 == 47))
              tmp_if_expr_47 = conf->logDirName != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_47 = (_Bool)0;
            if(tmp_if_expr_47)
            {
              const char *return_value_lex_text_44;
              return_value_lex_text_44=lex_text(l);
              conf->logFileName=create_format_string("%s/%s", conf->logDirName, return_value_lex_text_44);
            }

            else
            {
              const char *return_value_lex_text_45;
              return_value_lex_text_45=lex_text(l);
              conf->logFileName=create_string(return_value_lex_text_45);
            }
            p=strrchr(conf->logFileName, 44);
            if(!(p == ((char *)NULL)))
            {
              tmp_post_48 = p;
              p = p + 1l;
              *tmp_post_48 = (char)0;
              n=lookup_syslog_priority(p);
              if(!(n >= 0))
                snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "invalid %s priority \"%s\"", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)], p);

              else
                conf->logFileLevel = n;
            }

          }
        }
        break;
      }
      case 271:
      {
        return_value_lex_next_56=lex_next(l);
        if(!(return_value_lex_next_56 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_55=lex_next(l);
          if(return_value_lex_next_55 == 274)
            conf->enableLoopBack = (unsigned int)1;

          else
          {
            return_value_lex_prev_54=lex_prev(l);
            if(return_value_lex_prev_54 == 273)
              conf->enableLoopBack = (unsigned int)0;

            else
              snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected ON or OFF for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);
          }
        }
        break;
      }
      case 275:
      {
        return_value_lex_next_64=lex_next(l);
        if(!(return_value_lex_next_64 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_60=lex_next(l);
          if(!(return_value_lex_next_60 == 258))
            tmp_if_expr_63 = (_Bool)1;

          else
          {
            return_value_lex_text_61=lex_text(l);
            return_value_is_empty_string_62=is_empty_string(return_value_lex_text_61);
            tmp_if_expr_63 = return_value_is_empty_string_62 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_63)
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            destroy_string(conf->pidFileName);
            const char *return_value_lex_text_59;
            return_value_lex_text_59=lex_text(l);
            if(!((signed int)*return_value_lex_text_59 == 47))
            {
              const char *return_value_lex_text_57;
              return_value_lex_text_57=lex_text(l);
              conf->pidFileName=create_format_string("%s/%s", conf->cwd, return_value_lex_text_57);
            }

            else
            {
              const char *return_value_lex_text_58;
              return_value_lex_text_58=lex_text(l);
              conf->pidFileName=create_string(return_value_lex_text_58);
            }
          }
        }
        break;
      }
      case 276:
      {
        return_value_lex_next_67=lex_next(l);
        if(!(return_value_lex_next_67 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_66=lex_next(l);
          if(!(return_value_lex_next_66 == 257))
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected INTEGER for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            return_value_lex_text_65=lex_text(l);
            n=atoi(return_value_lex_text_65);
            if(!(n >= 1))
              snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "invalid %s value %d", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)], n);

            else
              conf->port = n;
          }
        }
        break;
      }
      case 277:
      {
        return_value_lex_next_75=lex_next(l);
        if(!(return_value_lex_next_75 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_71=lex_next(l);
          if(!(return_value_lex_next_71 == 258))
            tmp_if_expr_74 = (_Bool)1;

          else
          {
            return_value_lex_text_72=lex_text(l);
            return_value_is_empty_string_73=is_empty_string(return_value_lex_text_72);
            tmp_if_expr_74 = return_value_is_empty_string_73 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_74)
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            return_value_lex_text_69=lex_text(l);
            return_value_strchr_70=strchr(return_value_lex_text_69, 38);
            if(!(return_value_strchr_70 == ((char *)NULL)))
              snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "ignoring %s %s value with deprecated '%c' -- use '%%N'", directive, server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)], 38);

            else
            {
              destroy_string(conf->resetCmd);
              const char *return_value_lex_text_68;
              return_value_lex_text_68=lex_text(l);
              conf->resetCmd=create_string(return_value_lex_text_68);
            }
          }
        }
        break;
      }
      case 280:
      {
        return_value_lex_next_82=lex_next(l);
        if(!(return_value_lex_next_82 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_78=lex_next(l);
          if(!(return_value_lex_next_78 == 258))
            tmp_if_expr_81 = (_Bool)1;

          else
          {
            return_value_lex_text_79=lex_text(l);
            return_value_is_empty_string_80=is_empty_string(return_value_lex_text_79);
            tmp_if_expr_81 = return_value_is_empty_string_80 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_81)
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected STRING for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            return_value_lex_text_77=lex_text(l);
            n=lookup_syslog_facility(return_value_lex_text_77);
            if(!(n >= 0))
            {
              const char *return_value_lex_text_76;
              return_value_lex_text_76=lex_text(l);
              snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "invalid %s facility \"%s\"", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)], return_value_lex_text_76);
            }

            else
              conf->syslogFacility = n;
          }
        }
        break;
      }
      case 281:
      {
        return_value_lex_next_85=lex_next(l);
        if(!(return_value_lex_next_85 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_84=lex_next(l);
          if(return_value_lex_next_84 == 274)
            conf->enableTCPWrap = (unsigned int)1;

          else
          {
            return_value_lex_prev_83=lex_prev(l);
            if(return_value_lex_prev_83 == 273)
              conf->enableTCPWrap = (unsigned int)0;

            else
              snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected ON or OFF for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);
          }
        }
        break;
      }
      case 282:
      {
        return_value_lex_next_102=lex_next(l);
        if(!(return_value_lex_next_102 == 61))
          snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected '=' after %s keyword", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

        else
        {
          return_value_lex_next_101=lex_next(l);
          if(!(return_value_lex_next_101 == 257))
            snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected INTEGER for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);

          else
          {
            return_value_lex_text_100=lex_text(l);
            n=atoi(return_value_lex_text_100);
            if(!(n >= 0))
              snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "invalid %s value %d", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)], n);

            else
            {
              conf->tStampMinutes = n;
              signed int return_value_lex_next_97;
              return_value_lex_next_97=lex_next(l);
              if(return_value_lex_next_97 == 0)
                tmp_if_expr_99 = (_Bool)1;

              else
              {
                return_value_lex_prev_98=lex_prev(l);
                tmp_if_expr_99 = return_value_lex_prev_98 == 256 ? (_Bool)1 : (_Bool)0;
              }
              if(!tmp_if_expr_99)
              {
                return_value_lex_prev_96=lex_prev(l);
                if(return_value_lex_prev_96 == 258)
                {
                  const char *return_value_lex_text_95;
                  return_value_lex_text_95=lex_text(l);
                  if(!((signed int)return_value_lex_text_95[1l] == 0))
                    conf->tStampMinutes = -1;

                  else
                  {
                    return_value_lex_text_92=lex_text(l);
                    if((signed int)*return_value_lex_text_92 == 109)
                      tmp_if_expr_94 = (_Bool)1;

                    else
                    {
                      return_value_lex_text_93=lex_text(l);
                      tmp_if_expr_94 = (signed int)return_value_lex_text_93[(signed long int)0] == 77 ? (_Bool)1 : (_Bool)0;
                    }
                    if(!tmp_if_expr_94)
                    {
                      return_value_lex_text_89=lex_text(l);
                      if((signed int)*return_value_lex_text_89 == 104)
                        tmp_if_expr_91 = (_Bool)1;

                      else
                      {
                        return_value_lex_text_90=lex_text(l);
                        tmp_if_expr_91 = (signed int)return_value_lex_text_90[(signed long int)0] == 72 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr_91)
                        conf->tStampMinutes = conf->tStampMinutes * 60;

                      else
                      {
                        return_value_lex_text_86=lex_text(l);
                        if((signed int)*return_value_lex_text_86 == 100)
                          tmp_if_expr_88 = (_Bool)1;

                        else
                        {
                          return_value_lex_text_87=lex_text(l);
                          tmp_if_expr_88 = (signed int)return_value_lex_text_87[(signed long int)0] == 68 ? (_Bool)1 : (_Bool)0;
                        }
                        if(tmp_if_expr_88)
                          conf->tStampMinutes = conf->tStampMinutes * 60 * 24;

                        else
                          conf->tStampMinutes = -1;
                      }
                    }

                  }
                }

                else
                  conf->tStampMinutes = -1;
              }

              if(!(conf->tStampMinutes >= 0))
              {
                conf->tStampMinutes = 0;
                snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "expected (m|d|h) qualifier for %s value", server_conf_strs[(signed long int)(tok < 259 ? tok : tok - 259)]);
              }

            }
          }
        }
        break;
      }
      case 0:

      case 256:
      {
        parse_server_directive__1__done = 1;
        break;
      }
      case -1:
      {
        snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "unmatched quote");
        break;
      }
      default:
      {
        return_value_lex_text_103=lex_text(l);
        snprintf(err, sizeof(char [1024l]) /*1024ul*/ , "unrecognized token '%s'", return_value_lex_text_103);
      }
    }
  }
  signed int return_value_lex_prev_105;
  signed int return_value_lex_prev_106;
  if(!(err[0l] == 0))
  {
    signed int return_value_lex_line_104;
    return_value_lex_line_104=lex_line(l);
    log_msg(3, "CONFIG[%s:%d]: %s", conf->confFileName, return_value_lex_line_104, (const void *)err);
    do
    {
      return_value_lex_prev_105=lex_prev(l);
      if(return_value_lex_prev_105 == 256)
        break;

      return_value_lex_prev_106=lex_prev(l);
      if(return_value_lex_prev_106 == 0)
        break;

      lex_next(l);
    }
    while((_Bool)1);
  }

  goto __CPROVER_DUMP_L117;

__CPROVER_DUMP_L117:
  ;
}

// parse_string
// file util-str.h line 70
signed int parse_string(char *src, char **dst_p, char **ptr_p, char *quote_p)
{
  char *p;
  char *q;
  char c = (char)0;
  if(dst_p == ((char **)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(ptr_p == ((char **)NULL) || src == ((char *)NULL))
  {
    *dst_p = (char *)(void *)0;
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 22;
    return -1;
  }

  if(*ptr_p == ((char *)NULL))
    *ptr_p = src;

  p = *ptr_p;
  _Bool tmp_if_expr_4;
  const unsigned short int **return_value___ctype_b_loc_3;
  do
  {
    if(!(*p == 0))
    {
      return_value___ctype_b_loc_3=__ctype_b_loc();
      tmp_if_expr_4 = ((signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*p] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(!tmp_if_expr_4)
      break;

    p = p + 1l;
  }
  while((_Bool)1);
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_10;
  const unsigned short int **return_value___ctype_b_loc_8;
  _Bool tmp_if_expr_9;
  char *tmp_post_5;
  char *tmp_post_6;
  const unsigned short int **return_value___ctype_b_loc_12;
  char *tmp_post_11;
  if((signed int)*p == 0)
  {
    *ptr_p = p;
    *dst_p = *ptr_p;
    return 0;
  }

  else
  {
    q = p + (signed long int)1;
    for( ; !(*q == 0); q = q + 1l)
    {
      if((signed int)*p == 34)
        tmp_if_expr_13 = (_Bool)1;

      else
        tmp_if_expr_13 = (signed int)*p == 39 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_13)
      {
        if(*q == *p)
        {
          return_value___ctype_b_loc_8=__ctype_b_loc();
          if(!((8192 & (signed int)(*return_value___ctype_b_loc_8)[(signed long int)(signed int)q[1l]]) == 0))
            tmp_if_expr_9 = (_Bool)1;

          else
            tmp_if_expr_9 = (signed int)q[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_10 = (_Bool)0;
        if(tmp_if_expr_10)
        {
          tmp_post_5 = p;
          p = p + 1l;
          c = *tmp_post_5;
          tmp_post_6 = q;
          q = q + 1l;
          *tmp_post_6 = (char)0;
          break;
        }

        else
          if((signed int)q[1l] == 0)
          {
            signed int *return_value___errno_location_7;
            return_value___errno_location_7=__errno_location();
            *return_value___errno_location_7 = 5;
            *dst_p = p;
            *ptr_p = q + (signed long int)1;
            return -1;
          }

      }

      else
      {
        return_value___ctype_b_loc_12=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc_12)[(signed long int)(signed int)*q]) == 0))
        {
          tmp_post_11 = q;
          q = q + 1l;
          *tmp_post_11 = (char)0;
          break;
        }

      }
    }
    *dst_p = p;
    *ptr_p = q;
    if(!(quote_p == ((char *)NULL)))
      *quote_p = c;

    return 1;
  }
}

// perform_connect_cmd
// file server-sock.c line 834
static signed int perform_connect_cmd(struct request *req, struct server_conf *conf)
{
  struct base_obj *client;
  struct base_obj *console;
  struct listIterator *i;
  log_msg(6, "Client <%s@%s:%d> issued connect command", req->user, req->fqdn, req->port);
  signed int return_value_send_rsp_1;
  return_value_send_rsp_1=send_rsp(req, 0, (char *)(void *)0);
  void *return_value_list_next_3;
  if(!(return_value_send_rsp_1 >= 0))
    return -1;

  else
  {
    client=create_client_obj(conf, req);
    signed int return_value_list_count_4;
    return_value_list_count_4=list_count(req->consoles);
    if(return_value_list_count_4 == 1)
    {
      void *return_value_list_peek_2;
      return_value_list_peek_2=list_peek(req->consoles);
      console = (struct base_obj *)return_value_list_peek_2;
      link_objs(client, console);
      link_objs(console, client);
      check_console_state(console, client);
    }

    else
    {
      i=list_iterator_create(req->consoles);
      do
      {
        return_value_list_next_3=list_next(i);
        console = (struct base_obj *)return_value_list_next_3;
        if(console == ((struct base_obj *)NULL))
          break;

        link_objs(client, console);
        check_console_state(console, client);
      }
      while((_Bool)1);
      list_iterator_destroy(i);
    }
    return 0;
  }
}

// perform_console_writer_linkage
// file server-esc.c line 220
static void perform_console_writer_linkage(struct base_obj *client)
{
  struct base_obj *console;
  signed int gotWrite;
  if(client->aux.client.req->enableBroadcast == 0u)
  {
    void *return_value_list_peek_1;
    return_value_list_peek_1=list_peek(client->writers);
    console = (struct base_obj *)return_value_list_peek_1;
    gotWrite=list_count(client->readers);
    if(!(gotWrite == 0))
    {
      client->aux.client.req->command = (unsigned int)2;
      unlink_objs(client, console);
    }

    else
    {
      client->aux.client.req->command = (unsigned int)1;
      link_objs(client, console);
    }
    goto __CPROVER_DUMP_L4;
  }


__CPROVER_DUMP_L4:
  ;
}

// perform_del_char_seq
// file server-esc.c line 194
static void perform_del_char_seq(struct base_obj *client)
{
  struct listIterator *i;
  struct base_obj *console;
  unsigned char del = (unsigned char)0x7F;
  i=list_iterator_create(client->readers);
  void *return_value_list_next_1;
  do
  {
    return_value_list_next_1=list_next(i);
    console = (struct base_obj *)return_value_list_next_1;
    if(console == ((struct base_obj *)NULL))
      break;

    write_obj_data(console, (const void *)&del, 1, 0);
  }
  while((_Bool)1);
  list_iterator_destroy(i);
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// perform_log_replay
// file server-esc.c line 258
static void perform_log_replay(struct base_obj *client)
{
  struct base_obj *console;
  struct base_obj *logfile;
  unsigned char buf[8191l];
  unsigned char *ptr = buf;
  signed int len = (signed int)sizeof(unsigned char [8191l]) /*8191ul*/ ;
  unsigned char *p;
  signed int n;
  signed int m;
  signed int return_value_list_is_empty_1;
  return_value_list_is_empty_1=list_is_empty(client->writers);
  signed int *return_value___errno_location_3;
  signed long int tmp_if_expr_5;
  signed int *return_value___errno_location_6;
  if(return_value_list_is_empty_1 == 0)
  {
    void *return_value_list_peek_2;
    return_value_list_peek_2=list_peek(client->writers);
    console = (struct base_obj *)return_value_list_peek_2;
    logfile=get_console_logfile_obj(console);
    if(logfile == ((struct base_obj *)NULL))
    {
      n=snprintf((char *)ptr, (unsigned long int)len, "%sConsole [%s] is not being logged -- cannot replay%s", (const void *)"\r\n<ConMan> ", console->name, (const void *)".\r\n");
      if(n >= len || !(n >= 0))
      {
        log_msg(4, "Insufficient buffer to write message to console %s log", console->name);
        goto __CPROVER_DUMP_L15;
      }

      ptr = ptr + (signed long int)n;
    }

    else
    {
      n=snprintf((char *)ptr, (unsigned long int)len, "%sBegin log replay of console [%s]%s", (const void *)"\r\n<ConMan> ", console->name, (const void *)".\r\n");
      if(n >= len || (unsigned long int)(2 * n + -2) >= sizeof(unsigned char [8191l]) /*8191ul*/  || !(n >= 0))
      {
        log_msg(4, "Insufficient buffer to replay console %s log for %s", console->name, client->name);
        goto __CPROVER_DUMP_L15;
      }

      ptr = ptr + (signed long int)n;
      len = len - (2 * n - 2);
      do
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        *return_value___errno_location_4=pthread_mutex_lock(&logfile->bufLock);
        if(!(*return_value___errno_location_4 == 0))
        {
          return_value___errno_location_3=__errno_location();
          log_err(*return_value___errno_location_3, "pthread_mutex_lock() failed");
        }

      }
      while((_Bool)0);
      if(logfile->gotBufWrap == 0u)
      {
        if(logfile->bufInPtr - logfile->buf >= 4096l)
          tmp_if_expr_5 = (signed long int)4096;

        else
          tmp_if_expr_5 = logfile->bufInPtr - logfile->buf;
        n = (signed int)tmp_if_expr_5;
      }

      else
        n = 4096 <= 8192 - 1 ? 4096 : 8192 - 1;
      n = n <= len ? n : len;
      p = logfile->bufInPtr - (signed long int)n;
      if(p >= logfile->buf)
      {
        memcpy((void *)ptr, (const void *)p, (unsigned long int)n);
        ptr = ptr + (signed long int)n;
      }

      else
      {
        m = (signed int)(logfile->buf - p);
        p = &logfile->buf[(signed long int)8192] - (signed long int)m;
        memcpy((void *)ptr, (const void *)p, (unsigned long int)m);
        ptr = ptr + (signed long int)m;
        n = n - m;
        memcpy((void *)ptr, (const void *)logfile->buf, (unsigned long int)n);
        ptr = ptr + (signed long int)n;
      }
      do
      {
        signed int *return_value___errno_location_7;
        return_value___errno_location_7=__errno_location();
        *return_value___errno_location_7=pthread_mutex_unlock(&logfile->bufLock);
        if(!(*return_value___errno_location_7 == 0))
        {
          return_value___errno_location_6=__errno_location();
          log_err(*return_value___errno_location_6, "pthread_mutex_unlock() failed");
        }

      }
      while((_Bool)0);
      len = (signed int)(&buf[(signed long int)sizeof(unsigned char [8191l]) /*8191ul*/ ] - ptr);
      n=snprintf((char *)ptr, (unsigned long int)len, "%sEnd log replay of console [%s]%s", (const void *)"\r\n<ConMan> ", console->name, (const void *)".\r\n");
      ptr = ptr + (signed long int)n;
    }
    write_obj_data(client, (const void *)buf, (signed int)(ptr - buf), 0);
    goto __CPROVER_DUMP_L15;
  }


__CPROVER_DUMP_L15:
  ;
}

// perform_monitor_cmd
// file server-sock.c line 807
static signed int perform_monitor_cmd(struct request *req, struct server_conf *conf)
{
  struct base_obj *client;
  struct base_obj *console;
  log_msg(6, "Client <%s@%s:%d> issued monitor command", req->user, req->fqdn, req->port);
  signed int return_value_send_rsp_1;
  return_value_send_rsp_1=send_rsp(req, 0, (char *)(void *)0);
  if(!(return_value_send_rsp_1 >= 0))
    return -1;

  else
  {
    client=create_client_obj(conf, req);
    void *return_value_list_peek_2;
    return_value_list_peek_2=list_peek(req->consoles);
    console = (struct base_obj *)return_value_list_peek_2;
    link_objs(console, client);
    check_console_state(console, client);
    return 0;
  }
}

// perform_query_cmd
// file server-sock.c line 785
static signed int perform_query_cmd(struct request *req)
{
  log_msg(6, "Client <%s@%s:%d> issued query command", req->user, req->fqdn, req->port);
  signed int return_value_send_rsp_1;
  return_value_send_rsp_1=send_rsp(req, 0, (char *)(void *)0);
  if(!(return_value_send_rsp_1 >= 0))
    return -1;

  else
  {
    destroy_req(req);
    return 0;
  }
}

// perform_quiet_toggle
// file server-esc.c line 366
static void perform_quiet_toggle(struct base_obj *client)
{
  const char *op;
  const char *action;
  char *str;
  client->aux.client.req->enableQuiet = (unsigned int)client->aux.client.req->enableQuiet ^ (unsigned int)1;
  if(!(client->aux.client.req->enableQuiet == 0u))
  {
    op = "enabled";
    action = "suppressed";
  }

  else
  {
    op = "disabled";
    action = "displayed";
  }
  str=create_format_string("%sQuiet-mode %s -- info msgs will be %s%s", (const void *)"\r\n<ConMan> ", op, action, (const void *)".\r\n");
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  write_obj_data(client, (const void *)str, (signed int)return_value_strlen_1, 0);
  free((void *)str);
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// perform_reset
// file server-esc.c line 396
static void perform_reset(struct base_obj *client)
{
  struct listIterator *i;
  struct base_obj *console;
  char *tty;
  char *now;
  char buf[1024l];
  tty = client->aux.client.req->tty;
  now=create_short_time_string((signed long int)0);
  i=list_iterator_create(client->readers);
  void *return_value_list_next_1;
  do
  {
    return_value_list_next_1=list_next(i);
    console = (struct base_obj *)return_value_list_next_1;
    if(console == ((struct base_obj *)NULL))
      break;

    if(console->gotReset == 0u)
    {
      console->gotReset = (unsigned int)1;
      log_msg(5, "Console [%s] reset by <%s@%s>", console->name, client->aux.client.req->user, client->aux.client.req->host);
      snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%sConsole [%s] reset by <%s@%s>%s%s at %s%s", (const void *)"\r\n<ConMan> ", console->name, client->aux.client.req->user, client->aux.client.req->host, tty != ((char *)NULL) ? " on " : "", tty != ((char *)NULL) ? tty : "", now, (const void *)".\r\n");
      strcpy(&buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)3)], "\r\n");
      notify_console_objs(console, buf);
    }

  }
  while((_Bool)1);
  list_iterator_destroy(i);
  free((void *)now);
  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L4:
  ;
}

// perform_serial_break
// file server-esc.c line 132
static void perform_serial_break(struct base_obj *client)
{
  struct listIterator *i;
  struct base_obj *console;
  i=list_iterator_create(client->readers);
  void *return_value_list_next_1;
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  do
  {
    return_value_list_next_1=list_next(i);
    console = (struct base_obj *)return_value_list_next_1;
    if(console == ((struct base_obj *)NULL))
      break;

    if((signed int)console->type == CONMAN_OBJ_PROCESS)
    {
      unsigned char brk[2l];
      brk[(signed long int)0] = (unsigned char)38;
      brk[(signed long int)1] = (unsigned char)66;
      write_obj_data(console, (const void *)&brk, 2, 0);
    }

    else
      if((signed int)console->type == CONMAN_OBJ_SERIAL)
      {
        signed int return_value_tcsendbreak_4;
        return_value_tcsendbreak_4=tcsendbreak(console->fd, 0);
        if(!(return_value_tcsendbreak_4 >= 0))
        {
          return_value___errno_location_2=__errno_location();
          return_value_strerror_3=strerror(*return_value___errno_location_2);
          log_msg(4, "Unable to send serial-break to console [%s]: %s", console->name, return_value_strerror_3);
        }

      }

      else
        if((signed int)console->type == CONMAN_OBJ_TELNET)
        {
          signed int return_value_send_telnet_cmd_5;
          return_value_send_telnet_cmd_5=send_telnet_cmd(console, 243, -1);
          if(!(return_value_send_telnet_cmd_5 >= 0))
            log_msg(4, "Unable to send serial-break to console [%s]", console->name);

        }

        else
          if((signed int)console->type == CONMAN_OBJ_IPMI)
          {
            signed int return_value_send_ipmi_break_6;
            return_value_send_ipmi_break_6=send_ipmi_break(console);
            if(!(return_value_send_ipmi_break_6 >= 0))
              log_msg(4, "Unable to send serial-break to console [%s]", console->name);

          }

  }
  while((_Bool)1);
  list_iterator_destroy(i);
  goto __CPROVER_DUMP_L10;

__CPROVER_DUMP_L10:
  ;
}

// perform_suspend
// file server-esc.c line 437
static void perform_suspend(struct base_obj *client)
{
  signed int gotSuspend;
  client->aux.client.gotSuspend = (unsigned int)client->aux.client.gotSuspend ^ (unsigned int)1;
  gotSuspend = (signed int)(unsigned int)client->aux.client.gotSuspend;
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// posix_signal
// file util.h line 49
void (*posix_signal(signed int signum, void (*f)(signed int)))(signed int)
{
  struct sigaction act0;
  struct sigaction act1;
  act1.__sigaction_handler.sa_handler = f;
  sigemptyset(&act1.sa_mask);
  act1.sa_flags = 0;
  if(signum == 14)
    act1.sa_flags = act1.sa_flags | 0x20000000;

  else
    act1.sa_flags = act1.sa_flags | 0x10000000;
  signed int return_value_sigaction_2;
  return_value_sigaction_2=sigaction(signum, &act1, &act0);
  signed int *return_value___errno_location_1;
  if(!(return_value_sigaction_2 >= 0))
  {
    return_value___errno_location_1=__errno_location();
    log_err(*return_value___errno_location_1, "signal(%d) failed", signum);
  }

  return act0.__sigaction_handler.sa_handler;
}

// process_client
// file server.h line 458
void process_client(struct client_args *args)
{
  signed int sd;
  struct server_conf *conf;
  struct request *req;
  sd = args->sd;
  conf = args->conf;
  free((void *)args);
  signed int *return_value___errno_location_1;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    unsigned long int return_value_pthread_self_3;
    return_value_pthread_self_3=pthread_self();
    *return_value___errno_location_2=pthread_detach(return_value_pthread_self_3);
    if(!(*return_value___errno_location_2 == 0))
    {
      return_value___errno_location_1=__errno_location();
      log_err(*return_value___errno_location_1, "pthread_detach() failed");
    }

  }
  while((_Bool)0);
  req=create_req();
  signed int return_value_resolve_addr_4;
  return_value_resolve_addr_4=resolve_addr(conf, req, sd);
  signed int return_value_recv_greeting_5;
  signed int return_value_recv_req_6;
  signed int return_value_query_consoles_7;
  signed int return_value_validate_req_8;
  signed int return_value_perform_connect_cmd_9;
  signed int return_value_perform_monitor_cmd_10;
  signed int return_value_perform_query_cmd_11;
  if(return_value_resolve_addr_4 >= 0)
  {
    return_value_recv_greeting_5=recv_greeting(req);
    if(!(return_value_recv_greeting_5 >= 0))
      goto err;

    return_value_recv_req_6=recv_req(req);
    if(!(return_value_recv_req_6 >= 0))
      goto err;

    return_value_query_consoles_7=query_consoles(conf, req);
    if(!(return_value_query_consoles_7 >= 0))
      goto err;

    return_value_validate_req_8=validate_req(req);
    if(!(return_value_validate_req_8 >= 0))
      goto err;

    if(!(conf->resetCmd == ((char *)NULL)))
      req->enableReset = (unsigned int)1;

    switch((signed int)req->command)
    {
      case 1:
      {
        return_value_perform_connect_cmd_9=perform_connect_cmd(req, conf);
        if(!(return_value_perform_connect_cmd_9 >= 0))
          goto err;

        break;
      }
      case 2:
      {
        return_value_perform_monitor_cmd_10=perform_monitor_cmd(req, conf);
        if(!(return_value_perform_monitor_cmd_10 >= 0))
          goto err;

        break;
      }
      case 3:
      {
        return_value_perform_query_cmd_11=perform_query_cmd(req);
        if(!(return_value_perform_query_cmd_11 >= 0))
          goto err;

        break;
      }
      default:
      {
        log_msg(4, "Received invalid command=%d from <%s@%s:%d>", req->command, req->user, req->fqdn, req->port);
        goto err;
      }
    }
  }

  else
  {

  err:
    ;
    destroy_req(req);
    goto __CPROVER_DUMP_L10;
  }

__CPROVER_DUMP_L10:
  ;
}

// process_client_escapes
// file server-esc.c line 55
signed int process_client_escapes(struct base_obj *client, void *src, signed int len)
{
  const unsigned char *last = (unsigned char *)src + (signed long int)len;
  unsigned char *p;
  unsigned char *q;
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  if(src == NULL || !(len >= 1))
    return 0;

  else
  {
    q = (unsigned char *)src;
    p = q;
    for( ; !(p >= last); p = p + 1l)
      if(!(client->aux.client.gotEscape == 0u))
      {
        client->aux.client.gotEscape = (unsigned int)0;
        switch((signed int)*p)
        {
          case 0xFF:
          {
            tmp_post_1 = q;
            q = q + 1l;
            *tmp_post_1 = *p;
            break;
          }
          case 66:
          {
            perform_serial_break(client);
            break;
          }
          case 68:
          {
            perform_del_char_seq(client);
            break;
          }
          case 70:
          {
            client->aux.client.req->enableForce = (unsigned int)1;
            client->aux.client.req->enableJoin = (unsigned int)0;
            perform_console_writer_linkage(client);
            break;
          }
          case 74:
          {
            client->aux.client.req->enableForce = (unsigned int)0;
            client->aux.client.req->enableJoin = (unsigned int)1;
            perform_console_writer_linkage(client);
            break;
          }
          case 76:
          {
            perform_log_replay(client);
            break;
          }
          case 77:
          {
            client->aux.client.req->enableForce = (unsigned int)0;
            client->aux.client.req->enableJoin = (unsigned int)0;
            perform_console_writer_linkage(client);
            break;
          }
          case 81:
          {
            perform_quiet_toggle(client);
            break;
          }
          case 82:
          {
            perform_reset(client);
            break;
          }
          case 90:
          {
            perform_suspend(client);
            break;
          }
          default:
            log_msg(4, "Received invalid escape '%c' from %s", *p, client->name);
        }
      }

      else
        if((signed int)*p == 0xFF)
          client->aux.client.gotEscape = (unsigned int)1;

        else
        {
          tmp_post_2 = q;
          q = q + 1l;
          *tmp_post_2 = *p;
        }
    len = (signed int)(q - (unsigned char *)src);
    return len;
  }
}

// process_cmdline
// file server.h line 344
void process_cmdline(struct server_conf *conf, signed int argc, char **argv)
{
  signed int c;
  opterr = 0;
  do
  {
    c=getopt(argc, argv, "c:FhkLp:qrvVz");
    if(c == -1)
      break;

    switch(c)
    {
      case 99:
      {
        destroy_string(conf->confFileName);
        conf->confFileName=create_string(optarg);
        break;
      }
      case 70:
      {
        conf->enableForeground = (unsigned int)1;
        break;
      }
      case 104:
      {
        display_server_help(argv[(signed long int)0]);
        exit(0);
      }
      case 107:
      {
        conf->throwSignal = 15;
        break;
      }
      case 76:
      {
        printf("%s", conman_license);
        exit(0);
      }
      case 112:
      {
        conf->port=atoi(optarg);
        if(!(conf->port >= 1))
          log_err(0, "CMDLINE: invalid port \"%d\"", conf->port);

        break;
      }
      case 113:
      {
        conf->throwSignal = 0;
        break;
      }
      case 114:
      {
        conf->throwSignal = 1;
        break;
      }
      case 118:
      {
        conf->enableVerbose = (unsigned int)1;
        break;
      }
      case 86:
      {
        printf("%s-%s%s\n", (const void *)"conman", (const void *)"0.2.7", (const void *)" FREEIPMI TCP-WRAPPERS");
        exit(0);
      }
      case 122:
      {
        conf->enableZeroLogs = (unsigned int)1;
        break;
      }
      case 63:
      {
        log_err(0, "CMDLINE: invalid option \"%c\"", optopt);
        break;
      }
      default:
        log_err(0, "CMDLINE: option \"%c\" not implemented", c);
    }
  }
  while((_Bool)1);
  goto __CPROVER_DUMP_L18;

__CPROVER_DUMP_L18:
  ;
}

// process_config
// file server.h line 346
void process_config(struct server_conf *conf)
{
  signed int port;
  signed int pid;
  struct stat fdStat;
  signed int len;
  char *buf;
  signed int n;
  struct lexer_state *l;
  signed int tok;
  port = conf->port;
  conf->fd=open(conf->confFileName, 00);
  if(!(conf->fd >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    log_err(*return_value___errno_location_1, "Unable to open \"%s\"", conf->confFileName);
  }

  if(conf->throwSignal >= 0)
  {
    signal_daemon(conf);
    exit(0);
  }

  signed int return_value_get_read_lock_2;
  return_value_get_read_lock_2=get_read_lock(conf->fd);
  if(!(return_value_get_read_lock_2 >= 0))
    log_err(0, "Unable to lock configuration \"%s\"", conf->confFileName);

  pid=is_write_lock_blocked(conf->fd);
  if(pid >= 1)
    log_err(0, "Configuration \"%s\" in use by pid %d", conf->confFileName, pid);

  set_fd_closed_on_exec(conf->fd);
  signed int return_value_fstat_4;
  return_value_fstat_4=fstat(conf->fd, &fdStat);
  if(!(return_value_fstat_4 >= 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    log_err(*return_value___errno_location_3, "Unable to stat \"%s\"", conf->confFileName);
  }

  len = (signed int)fdStat.st_size;
  void *return_value_malloc_5;
  return_value_malloc_5=malloc((unsigned long int)(len + 1));
  buf = (char *)return_value_malloc_5;
  if(buf == ((char *)NULL))
  {
    log_err(0, "Out of memory");
    (void *)0;
  }

  signed long int return_value_read_n_7;
  return_value_read_n_7=read_n(conf->fd, (void *)buf, (unsigned long int)len);
  n = (signed int)return_value_read_n_7;
  if(!(n >= 0))
  {
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    log_err(*return_value___errno_location_6, "Unable to read \"%s\"", conf->confFileName);
  }

  buf[(signed long int)len] = (char)0;
  l=lex_create((void *)buf, server_conf_strs);
  signed int return_value_lex_line_8;
  signed int return_value_lex_line_9;
  const char *return_value_lex_text_10;
  do
  {
    tok=lex_next(l);
    if(tok == 0)
      break;

    switch(tok)
    {
      case 259:
      {
        parse_console_directive(conf, l);
        break;
      }
      case 264:
      {
        parse_global_directive(conf, l);
        break;
      }
      case 279:
      {
        parse_server_directive(conf, l);
        break;
      }
      case 256:
        break;
      case -1:
      {
        return_value_lex_line_8=lex_line(l);
        log_msg(3, "CONFIG[%s:%d]: unmatched quote", conf->confFileName, return_value_lex_line_8);
        break;
      }
      default:
      {
        return_value_lex_line_9=lex_line(l);
        return_value_lex_text_10=lex_text(l);
        log_msg(3, "CONFIG[%s:%d]: unrecognized token '%s'", conf->confFileName, return_value_lex_line_9, return_value_lex_text_10);
        while(!(tok == 0) && !(tok == 256))
          tok=lex_next(l);
      }
    }
  }
  while((_Bool)1);
  lex_destroy(l);
  free((void *)buf);
  if(port >= 1)
    conf->port = port;

  else
    if(!(conf->port >= 1))
      conf->port=atoi("7890");

  if(!(conf->logFileName == ((char *)NULL)))
  {
    char *return_value_strchr_11;
    return_value_strchr_11=strchr(conf->logFileName, 37);
    if(!(return_value_strchr_11 == ((char *)NULL)))
      conf->logFmtName=create_string(conf->logFileName);

  }

  if(!(conf->pidFileName == ((char *)NULL)))
  {
    signed int return_value_write_pidfile_12;
    return_value_write_pidfile_12=write_pidfile(conf->pidFileName);
    if(!(return_value_write_pidfile_12 >= 0))
    {
      free((void *)conf->pidFileName);
      conf->pidFileName = (char *)(void *)0;
    }

  }

  goto __CPROVER_DUMP_L25;

__CPROVER_DUMP_L25:
  ;
}

// process_console
// file server-conf.c line 761
static signed int process_console(struct server_conf *conf, struct console_strs *con_p, char *errbuf, signed int errbuflen)
{
  struct list *args = (struct list *)(void *)0;
  char *p;
  char *q;
  char quote;
  signed int rc;
  char buf[1024l];
  char *arg0;
  char *host = (char *)(void *)0;
  signed int port;
  char *path = (char *)(void *)0;
  struct base_obj *console;
  struct serial_opt seropts;
  struct ipmi_opt ipmiopts;
  struct logfile_opt logopts;
  struct base_obj *logfile;
  errbuf[(signed long int)0] = (char)0;
  args=list_create((void (*)(void *))destroy_string);
  if(args == ((struct list *)NULL))
  {
    log_err(0, "Out of memory");
    (void *)0;
  }

  q = (char *)(void *)0;
  do
  {
    rc=parse_string(con_p->dev, &p, &q, &quote);
    if(!(rc >= 1))
      break;

    if(!((signed int)quote == 39))
    {
      signed int return_value_substitute_string_1;
      return_value_substitute_string_1=substitute_string(buf, sizeof(char [1024l]) /*1024ul*/ , p, (char)78, con_p->name);
      if(!(return_value_substitute_string_1 >= 0))
      {
        snprintf(errbuf, (unsigned long int)errbuflen, "console [%s] dev string substitution failed", con_p->name);
        goto err;
      }

      p = buf;
    }

    char *return_value_create_string_2;
    return_value_create_string_2=create_string(p);
    list_append(args, (void *)return_value_create_string_2);
  }
  while((_Bool)1);
  void *return_value_list_peek_3;
  signed int return_value_is_unixsock_dev_17;
  signed int return_value_is_telnet_dev_16;
  signed int return_value_is_serial_dev_15;
  signed int return_value_parse_serial_opts_8;
  signed int return_value_is_process_dev_14;
  signed int return_value_is_ipmi_dev_13;
  signed int return_value_parse_ipmi_opts_12;
  _Bool tmp_if_expr_20;
  _Bool tmp_if_expr_22;
  _Bool tmp_if_expr_21;
  _Bool tmp_if_expr_18;
  signed int return_value_parse_logfile_opts_19;
  if(!(rc >= 0))
    snprintf(errbuf, (unsigned long int)errbuflen, "console [%s] dev string parse error", con_p->name);

  else
  {
    return_value_list_peek_3=list_peek(args);
    arg0 = (char *)return_value_list_peek_3;
    if(arg0 == ((char *)NULL))
      snprintf(errbuf, (unsigned long int)errbuflen, "console [%s] dev string is empty", con_p->name);

    else
    {
      return_value_is_unixsock_dev_17=is_unixsock_dev(arg0, conf->cwd, &path);
      if(!(return_value_is_unixsock_dev_17 == 0))
      {
        signed int return_value_list_count_4;
        return_value_list_count_4=list_count(args);
        if(!(return_value_list_count_4 == 1))
        {
          snprintf(errbuf, (unsigned long int)errbuflen, "console [%s] dev string has too many args", con_p->name);
          goto err;
        }

        console=create_unixsock_obj(conf, con_p->name, path, errbuf, errbuflen);
        if(console == ((struct base_obj *)NULL))
          goto err;

        free((void *)host);
        host = (char *)(void *)0;
      }

      else
      {
        return_value_is_telnet_dev_16=is_telnet_dev(arg0, &host, &port);
        if(!(return_value_is_telnet_dev_16 == 0))
        {
          signed int return_value_list_count_5;
          return_value_list_count_5=list_count(args);
          if(!(return_value_list_count_5 == 1))
          {
            snprintf(errbuf, (unsigned long int)errbuflen, "console [%s] dev string has too many args", con_p->name);
            goto err;
          }

          console=create_telnet_obj(conf, con_p->name, host, port, errbuf, errbuflen);
          if(console == ((struct base_obj *)NULL))
            goto err;

          free((void *)host);
          host = (char *)(void *)0;
        }

        else
        {
          return_value_is_serial_dev_15=is_serial_dev(arg0, conf->cwd, &path);
          if(!(return_value_is_serial_dev_15 == 0))
          {
            signed int return_value_list_count_6;
            return_value_list_count_6=list_count(args);
            if(!(return_value_list_count_6 == 1))
            {
              snprintf(errbuf, (unsigned long int)errbuflen, "console [%s] dev string has too many args", con_p->name);
              goto err;
            }

            signed int return_value_access_7;
            return_value_access_7=access(path, 4 | 2);
            if(!(return_value_access_7 >= 0))
            {
              snprintf(errbuf, (unsigned long int)errbuflen, "console [%s] device \"%s\" is not readable/writable", con_p->name, path);
              goto err;
            }

            seropts = conf->globalSerOpts;
            if(!(con_p->sopts == ((char *)NULL)))
            {
              return_value_parse_serial_opts_8=parse_serial_opts(&seropts, con_p->sopts, errbuf, errbuflen);
              if(!(return_value_parse_serial_opts_8 >= 0))
                goto err;

            }

            console=create_serial_obj(conf, con_p->name, path, &seropts, errbuf, errbuflen);
            if(console == ((struct base_obj *)NULL))
              goto err;

            free((void *)path);
            path = (char *)(void *)0;
          }

          else
          {
            return_value_is_process_dev_14=is_process_dev(arg0, conf->cwd, conf->execPath, &path);
            if(!(return_value_is_process_dev_14 == 0))
            {
              void *return_value_list_pop_9;
              return_value_list_pop_9=list_pop(args);
              free(return_value_list_pop_9);
              void *return_value_list_push_10;
              return_value_list_push_10=list_push(args, (void *)path);
              arg0 = (char *)return_value_list_push_10;
              path = (char *)(void *)0;
              console=create_process_obj(conf, con_p->name, args, errbuf, errbuflen);
              if(console == ((struct base_obj *)NULL))
                goto err;

            }

            else
            {
              return_value_is_ipmi_dev_13=is_ipmi_dev(arg0, &host);
              if(!(return_value_is_ipmi_dev_13 == 0))
              {
                signed int return_value_list_count_11;
                return_value_list_count_11=list_count(args);
                if(!(return_value_list_count_11 == 1))
                {
                  snprintf(errbuf, (unsigned long int)errbuflen, "console [%s] dev string has too many args", con_p->name);
                  goto err;
                }

                ipmiopts = conf->globalIpmiOpts;
                if(!(con_p->iopts == ((char *)NULL)))
                {
                  return_value_parse_ipmi_opts_12=parse_ipmi_opts(&ipmiopts, con_p->iopts, errbuf, errbuflen);
                  if(!(return_value_parse_ipmi_opts_12 >= 0))
                    goto err;

                }

                console=create_ipmi_obj(conf, con_p->name, &ipmiopts, host, errbuf, errbuflen);
                if(console == ((struct base_obj *)NULL))
                  goto err;

                free((void *)host);
                host = (char *)(void *)0;
              }

              else
              {
                snprintf(errbuf, (unsigned long int)errbuflen, "console [%s] device \"%s\" type unrecognized", con_p->name, arg0);
                goto err;
              }
            }
          }
        }
      }
      if(!(con_p->log == ((char *)NULL)))
        tmp_if_expr_20 = (signed int)con_p->log[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_20 = (_Bool)0;
      if(tmp_if_expr_20)
        tmp_if_expr_22 = (_Bool)1;

      else
      {
        if(con_p->log == ((char *)NULL))
          tmp_if_expr_21 = conf->globalLogName != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_21 = (_Bool)0;
        tmp_if_expr_22 = tmp_if_expr_21 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_22)
      {
        if(!(con_p->log == ((char *)NULL)))
          strlcpy(buf, con_p->log, sizeof(char [1024l]) /*1024ul*/ );

        else
        {
          if(!((signed int)*conf->globalLogName == 47))
            tmp_if_expr_18 = conf->logDirName != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_18 = (_Bool)0;
          if(tmp_if_expr_18)
          {
            snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%s/%s", conf->logDirName, conf->globalLogName);
            buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
          }

          else
            strlcpy(buf, conf->globalLogName, sizeof(char [1024l]) /*1024ul*/ );
        }
        logopts = conf->globalLogOpts;
        if(!(con_p->lopts == ((char *)NULL)))
        {
          return_value_parse_logfile_opts_19=parse_logfile_opts(&logopts, con_p->lopts, errbuf, errbuflen);
          if(!(return_value_parse_logfile_opts_19 >= 0))
            goto err;

        }

        logfile=create_logfile_obj(conf, buf, console, &logopts, errbuf, errbuflen);
        if(logfile == ((struct base_obj *)NULL))
          goto err;

        link_objs(console, logfile);
      }

      list_destroy(args);
      return 0;
    }
  }

err:
  ;
  errbuf[(signed long int)(errbuflen - 1)] = (char)0;
  list_destroy(args);
  destroy_string(host);
  destroy_string(path);
  return -1;
}

// process_ipmi_opt
// file server-ipmi.c line 275
static signed int process_ipmi_opt(struct ipmi_opt *iopts, const char *str, char *errbuf, signed int errlen)
{
  char c;
  const char *p;
  signed int rv = -1;
  signed int return_value_is_ipmi_opt_tag_1;
  return_value_is_ipmi_opt_tag_1=is_ipmi_opt_tag(str);
  if(return_value_is_ipmi_opt_tag_1 == 0)
  {
    if(errlen >= 1 && !(errbuf == ((char *)NULL)))
      snprintf(errbuf, (unsigned long int)errlen, "invalid ipmiopts string \"%s\"", str);

    return -1;
  }

  else
  {
    signed int return_value_toupper_2;
    return_value_toupper_2=toupper((signed int)str[(signed long int)0]);
    c = (char)return_value_toupper_2;
    p = str + (signed long int)2;
    switch((signed int)c)
    {
      case 85:
      {
        rv=process_ipmi_opt_username(iopts, p, errbuf, errlen);
        break;
      }
      case 80:
      {
        rv=process_ipmi_opt_password(iopts, p, errbuf, errlen);
        break;
      }
      case 75:
      {
        rv=process_ipmi_opt_k_g(iopts, p, errbuf, errlen);
        break;
      }
      case 76:
      {
        rv=process_ipmi_opt_privilege(iopts, p, errbuf, errlen);
        break;
      }
      case 67:
      {
        rv=process_ipmi_opt_cipher(iopts, p, errbuf, errlen);
        break;
      }
      case 87:
      {
        rv=process_ipmi_opt_workaround(iopts, p, errbuf, errlen);
        break;
      }
      default:
        log_err(0, "invalid ipmiopts tag '%c'", c);
    }
    return rv == 0 ? 0 : -1;
  }
}

// process_ipmi_opt_cipher
// file server-ipmi.c line 510
static signed int process_ipmi_opt_cipher(struct ipmi_opt *iopts, const char *str, char *errbuf, signed int errlen)
{
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  if((signed int)*str == 0)
    iopts->cipherSuite = -1;

  else
  {
    signed long int n;
    char *p;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 0;
    n=strtol(str, &p, 0);
    if(!((signed int)*p == 0))
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value___errno_location_2=__errno_location();
      tmp_if_expr_3 = *return_value___errno_location_2 == 34 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
    {
      if(errlen >= 1 && !(errbuf == ((char *)NULL)))
        snprintf(errbuf, (unsigned long int)errlen, "invalid IPMI cipher suite \"%s\"", str);

      return -1;
    }

    signed int return_value_ipmiconsole_cipher_suite_id_is_valid_4;
    return_value_ipmiconsole_cipher_suite_id_is_valid_4=ipmiconsole_cipher_suite_id_is_valid((signed int)n);
    if(return_value_ipmiconsole_cipher_suite_id_is_valid_4 == 0)
    {
      if(errlen >= 1 && !(errbuf == ((char *)NULL)))
        snprintf(errbuf, (unsigned long int)errlen, "invalid IPMI cipher suite %ld", n);

      return -1;
    }

    iopts->cipherSuite = (signed int)n;
  }
  return 0;
}

// process_ipmi_opt_k_g
// file server-ipmi.c line 420
static signed int process_ipmi_opt_k_g(struct ipmi_opt *iopts, const char *str, char *errbuf, signed int errlen)
{
  if((signed int)*str == 0)
  {
    iopts->kg[(signed long int)0] = (unsigned char)0;
    iopts->kgLen = (unsigned int)0;
  }

  else
  {
    signed int n;
    n=parse_key((char *)iopts->kg, str, sizeof(unsigned char [21l]) /*21ul*/ );
    if(!(n >= 0))
    {
      if(errlen >= 1 && !(errbuf == ((char *)NULL)))
        snprintf(errbuf, (unsigned long int)errlen, "IPMI K_g exceeds %d-byte maximum", 20);

      return -1;
    }

    signed int return_value_ipmiconsole_k_g_is_valid_1;
    return_value_ipmiconsole_k_g_is_valid_1=ipmiconsole_k_g_is_valid(iopts->kg, (unsigned int)n);
    if(return_value_ipmiconsole_k_g_is_valid_1 == 0)
    {
      if(errlen >= 1 && !(errbuf == ((char *)NULL)))
        snprintf(errbuf, (unsigned long int)errlen, "invalid IPMI K_g");

      return -1;
    }

    iopts->kgLen = (unsigned int)n;
  }
  return 0;
}

// process_ipmi_opt_password
// file server-ipmi.c line 382
static signed int process_ipmi_opt_password(struct ipmi_opt *iopts, const char *str, char *errbuf, signed int errlen)
{
  if((signed int)*str == 0)
    iopts->password[(signed long int)0] = (char)0;

  else
  {
    signed int n;
    n=parse_key(iopts->password, str, sizeof(char [21l]) /*21ul*/ );
    if(!(n >= 0))
    {
      if(errlen >= 1 && !(errbuf == ((char *)NULL)))
        snprintf(errbuf, (unsigned long int)errlen, "IPMI password exceeds %d-byte maximum", 20);

      return -1;
    }

    signed int return_value_ipmiconsole_password_is_valid_1;
    return_value_ipmiconsole_password_is_valid_1=ipmiconsole_password_is_valid(iopts->password);
    if(return_value_ipmiconsole_password_is_valid_1 == 0)
    {
      if(errlen >= 1 && !(errbuf == ((char *)NULL)))
        snprintf(errbuf, (unsigned long int)errlen, "invalid IPMI password");

      return -1;
    }

  }
  return 0;
}

// process_ipmi_opt_privilege
// file server-ipmi.c line 460
static signed int process_ipmi_opt_privilege(struct ipmi_opt *iopts, const char *str, char *errbuf, signed int errlen)
{
  signed int return_value_strcasecmp_11;
  signed int return_value_strcasecmp_8;
  _Bool tmp_if_expr_10;
  signed int return_value_strcasecmp_9;
  signed int return_value_strcasecmp_5;
  _Bool tmp_if_expr_7;
  signed int return_value_strcasecmp_6;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  if((signed int)*str == 0)
    iopts->privilegeLevel = -1;

  else
  {
    return_value_strcasecmp_11=strcasecmp(str, "user");
    if(return_value_strcasecmp_11 == 0)
      iopts->privilegeLevel = 0;

    else
    {
      return_value_strcasecmp_8=strcasecmp(str, "op");
      if(return_value_strcasecmp_8 == 0)
        tmp_if_expr_10 = (_Bool)1;

      else
      {
        return_value_strcasecmp_9=strcasecmp(str, "operator");
        tmp_if_expr_10 = !(return_value_strcasecmp_9 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_10)
        iopts->privilegeLevel = 1;

      else
      {
        return_value_strcasecmp_5=strcasecmp(str, "admin");
        if(return_value_strcasecmp_5 == 0)
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_strcasecmp_6=strcasecmp(str, "administrator");
          tmp_if_expr_7 = !(return_value_strcasecmp_6 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
          iopts->privilegeLevel = 2;

        else
        {
          signed long int n;
          char *p;
          signed int *return_value___errno_location_1;
          return_value___errno_location_1=__errno_location();
          *return_value___errno_location_1 = 0;
          n=strtol(str, &p, 0);
          if(!((signed int)*p == 0))
            tmp_if_expr_3 = (_Bool)1;

          else
          {
            return_value___errno_location_2=__errno_location();
            tmp_if_expr_3 = *return_value___errno_location_2 == 34 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_3)
          {
            if(errlen >= 1 && !(errbuf == ((char *)NULL)))
              snprintf(errbuf, (unsigned long int)errlen, "invalid IPMI privilege level \"%s\"", str);

            return -1;
          }

          signed int return_value_ipmiconsole_privilege_level_is_valid_4;
          return_value_ipmiconsole_privilege_level_is_valid_4=ipmiconsole_privilege_level_is_valid((signed int)n);
          if(return_value_ipmiconsole_privilege_level_is_valid_4 == 0)
          {
            if(errlen >= 1 && !(errbuf == ((char *)NULL)))
              snprintf(errbuf, (unsigned long int)errlen, "invalid IPMI privilege level %ld", n);

            return -1;
          }

          iopts->privilegeLevel = (signed int)n;
        }
      }
    }
  }
  return 0;
}

// process_ipmi_opt_username
// file server-ipmi.c line 344
static signed int process_ipmi_opt_username(struct ipmi_opt *iopts, const char *str, char *errbuf, signed int errlen)
{
  if((signed int)*str == 0)
    iopts->username[(signed long int)0] = (char)0;

  else
  {
    signed int n;
    unsigned long int return_value_strlcpy_1;
    return_value_strlcpy_1=strlcpy(iopts->username, str, sizeof(char [17l]) /*17ul*/ );
    n = (signed int)return_value_strlcpy_1;
    if((unsigned long int)n >= sizeof(char [17l]) /*17ul*/ )
    {
      if(errlen >= 1 && !(errbuf == ((char *)NULL)))
        snprintf(errbuf, (unsigned long int)errlen, "IPMI username exceeds %d-byte maximum", 16);

      return -1;
    }

    signed int return_value_ipmiconsole_username_is_valid_2;
    return_value_ipmiconsole_username_is_valid_2=ipmiconsole_username_is_valid(iopts->username);
    if(return_value_ipmiconsole_username_is_valid_2 == 0)
    {
      if(errlen >= 1 && !(errbuf == ((char *)NULL)))
        snprintf(errbuf, (unsigned long int)errlen, "invalid IPMI username");

      return -1;
    }

  }
  return 0;
}

// process_ipmi_opt_workaround
// file server-ipmi.c line 551
static signed int process_ipmi_opt_workaround(struct ipmi_opt *iopts, const char *str, char *errbuf, signed int errlen)
{
  signed int return_value_strcasecmp_14;
  signed int return_value_strcasecmp_13;
  signed int return_value_strcasecmp_12;
  signed int return_value_strcasecmp_11;
  signed int return_value_strcasecmp_10;
  signed int return_value_strcasecmp_9;
  signed int return_value_strcasecmp_8;
  signed int return_value_strcasecmp_7;
  signed int return_value_strcasecmp_6;
  _Bool tmp_if_expr_5;
  signed int *return_value___errno_location_4;
  signed int return_value_ipmiconsole_workaround_flags_is_valid_3;
  if((signed int)*str == 0)
    iopts->workaroundFlags = (unsigned int)0;

  else
  {
    return_value_strcasecmp_14=strcasecmp(str, "authcap");
    if(return_value_strcasecmp_14 == 0)
      iopts->workaroundFlags = iopts->workaroundFlags | (unsigned int)0x00000001;

    else
    {
      return_value_strcasecmp_13=strcasecmp(str, "intel20");
      if(return_value_strcasecmp_13 == 0)
        iopts->workaroundFlags = iopts->workaroundFlags | (unsigned int)0x00000002;

      else
      {
        return_value_strcasecmp_12=strcasecmp(str, "supermicro20");
        if(return_value_strcasecmp_12 == 0)
          iopts->workaroundFlags = iopts->workaroundFlags | (unsigned int)0x00000004;

        else
        {
          return_value_strcasecmp_11=strcasecmp(str, "sun20");
          if(return_value_strcasecmp_11 == 0)
            iopts->workaroundFlags = iopts->workaroundFlags | (unsigned int)0x00000008;

          else
          {
            return_value_strcasecmp_10=strcasecmp(str, "opensesspriv");
            if(return_value_strcasecmp_10 == 0)
              iopts->workaroundFlags = iopts->workaroundFlags | (unsigned int)0x00000010;

            else
            {
              return_value_strcasecmp_9=strcasecmp(str, "integritycheckvalue");
              if(return_value_strcasecmp_9 == 0)
                iopts->workaroundFlags = iopts->workaroundFlags | (unsigned int)0x00000020;

              else
              {
                return_value_strcasecmp_8=strcasecmp(str, "solpayloadsize");
                if(return_value_strcasecmp_8 == 0)
                  iopts->workaroundFlags = iopts->workaroundFlags | (unsigned int)0x01000000;

                else
                {
                  return_value_strcasecmp_7=strcasecmp(str, "solport");
                  if(return_value_strcasecmp_7 == 0)
                    iopts->workaroundFlags = iopts->workaroundFlags | (unsigned int)0x02000000;

                  else
                  {
                    return_value_strcasecmp_6=strcasecmp(str, "solstatus");
                    if(return_value_strcasecmp_6 == 0)
                      iopts->workaroundFlags = iopts->workaroundFlags | (unsigned int)0x04000000;

                    else
                    {
                      unsigned int u;
                      char *p;
                      signed int *return_value___errno_location_1;
                      return_value___errno_location_1=__errno_location();
                      *return_value___errno_location_1 = 0;
                      unsigned long int return_value_strtoul_2;
                      return_value_strtoul_2=strtoul(str, &p, 0);
                      u = (unsigned int)return_value_strtoul_2;
                      if(!((signed int)*p == 0))
                        tmp_if_expr_5 = (_Bool)1;

                      else
                      {
                        return_value___errno_location_4=__errno_location();
                        tmp_if_expr_5 = *return_value___errno_location_4 == 34 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr_5)
                      {
                        if(errlen >= 1 && !(errbuf == ((char *)NULL)))
                          snprintf(errbuf, (unsigned long int)errlen, "invalid IPMI workaround flag \"%s\"", str);

                        return -1;
                      }

                      else
                      {
                        return_value_ipmiconsole_workaround_flags_is_valid_3=ipmiconsole_workaround_flags_is_valid(u);
                        if(return_value_ipmiconsole_workaround_flags_is_valid_3 == 0)
                        {
                          if(errlen >= 1 && !(errbuf == ((char *)NULL)))
                            snprintf(errbuf, (unsigned long int)errlen, "invalid IPMI workaround flag 0x%X", u);

                          return -1;
                        }

                        else
                          if(u == 0u)
                            iopts->workaroundFlags = (unsigned int)0;

                          else
                            iopts->workaroundFlags = iopts->workaroundFlags | u;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

// process_telnet_cmd
// file server-telnet.c line 501
static signed int process_telnet_cmd(struct base_obj *telnet, signed int cmd, signed int opt)
{
  char opt_buf[8l];
  char *tmp_if_expr_2;
  char *return_value_opt2str_1;
  if(!((unsigned int)cmd >= 236u) || (unsigned int)cmd >= 256u)
  {
    log_msg(7, "Received invalid telnet cmd %#.2x from console [%s]", cmd, telnet->name);
    return -1;
  }

  else
  {
    switch(cmd)
    {
      case 254:

      case 253:
      {
        if(!(opt == 1) && !(opt == 3))
          send_telnet_cmd(telnet, 252, opt);

        break;
      }
      case 252:

      case 251:
      {
        if(!(opt == 1) && !(opt == 3))
          send_telnet_cmd(telnet, 254, opt);

        break;
      }
      default:
      {
        if(!((unsigned int)opt >= 40u))
          tmp_if_expr_2 = telopts[(signed long int)(opt - 0)];

        else
        {
          return_value_opt2str_1=opt2str(opt, opt_buf, (signed int)sizeof(char [8l]) /*8ul*/ );
          tmp_if_expr_2 = return_value_opt2str_1;
        }
        log_msg(6, "Ignoring telnet cmd %s %s from console [%s]", telcmds[(signed long int)(cmd - 236)], tmp_if_expr_2, telnet->name);
      }
    }
    return 0;
  }
}

// process_telnet_escapes
// file server.h line 470
signed int process_telnet_escapes(struct base_obj *telnet, void *src, signed int len)
{
  const unsigned char *last = (unsigned char *)src + (signed long int)len;
  unsigned char *p;
  unsigned char *q;
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  if(src == NULL || !(len >= 1))
    return 0;

  else
  {
    q = (unsigned char *)src;
    p = q;
    for( ; !(p >= last); p = p + 1l)
    {
      if(!(telnet->aux.telnet.iac == -1))
      {
        if(telnet->aux.telnet.iac == 255)
          goto __CPROVER_DUMP_L6;

        if(telnet->aux.telnet.iac == 251 || telnet->aux.telnet.iac == 252 || telnet->aux.telnet.iac == 253 || telnet->aux.telnet.iac == 254)
          goto __CPROVER_DUMP_L12;

        if(telnet->aux.telnet.iac == 250)
          goto __CPROVER_DUMP_L13;

      }

      else
      {
        if((signed int)*p == 255)
          telnet->aux.telnet.iac = (signed int)*p;

        else
        {
          tmp_post_1 = q;
          q = q + 1l;
          *tmp_post_1 = *p;
        }
        goto __CPROVER_DUMP_L16;

      __CPROVER_DUMP_L6:
        ;
        switch((signed int)*p)
        {
          case 255:
          {
            tmp_post_2 = q;
            q = q + 1l;
            *tmp_post_2 = *p;
            telnet->aux.telnet.iac = -1;
            break;
          }
          case 254:

          case 253:

          case 252:

          case 251:

          case 250:
          {
            telnet->aux.telnet.iac = (signed int)*p;
            break;
          }
          case 240:
          {
            telnet->aux.telnet.iac = -1;
            break;
          }
          default:
          {
            process_telnet_cmd(telnet, (signed int)*p, -1);
            telnet->aux.telnet.iac = -1;
          }
        }
        goto __CPROVER_DUMP_L16;

      __CPROVER_DUMP_L12:
        ;
        process_telnet_cmd(telnet, telnet->aux.telnet.iac, (signed int)*p);
        telnet->aux.telnet.iac = -1;
        goto __CPROVER_DUMP_L16;

      __CPROVER_DUMP_L13:
        ;
        if((signed int)*p == 255)
          telnet->aux.telnet.iac = (signed int)*p;

        goto __CPROVER_DUMP_L16;
      }
      log_err(0, "Reached invalid state %#.2x%.2x for console [%s]", telnet->aux.telnet.iac, *p, telnet->name);

    __CPROVER_DUMP_L16:
      ;
    }
    len = (signed int)(q - (unsigned char *)src);
    return len;
  }
}

// query_consoles
// file server-sock.c line 418
static signed int query_consoles(struct server_conf *conf, struct request *req)
{
  struct list *matches;
  signed int rc;
  signed int return_value_list_is_empty_1;
  return_value_list_is_empty_1=list_is_empty(req->consoles);
  if(!(return_value_list_is_empty_1 == 0))
  {
    if((signed int)req->command == 3)
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    matches=list_create((void (*)(void *))(void *)0);
    if(!(req->enableRegex == 0u))
      rc=query_consoles_via_regex(conf, req, matches);

    else
      rc=query_consoles_via_globbing(conf, req, matches);
    list_destroy(req->consoles);
    req->consoles = matches;
    list_sort(req->consoles, (signed int (*)(void *, void *))compare_objs);
    signed int return_value_list_count_2;
    return_value_list_count_2=list_count(req->consoles);
    if(return_value_list_count_2 == 1)
      req->enableBroadcast = (unsigned int)0;

    return rc;
  }
}

// query_consoles_via_globbing
// file server-sock.c line 460
static signed int query_consoles_via_globbing(struct server_conf *conf, struct request *req, struct list *matches)
{
  char *p;
  struct listIterator *i;
  struct listIterator *j;
  char *pat;
  struct base_obj *obj;
  signed int return_value_list_is_empty_1;
  return_value_list_is_empty_1=list_is_empty(req->consoles);
  if(!(return_value_list_is_empty_1 == 0))
  {
    p=create_string("*");
    list_append(req->consoles, (void *)p);
  }

  i=list_iterator_create(req->consoles);
  j=list_iterator_create(conf->objs);
  void *return_value_list_next_2;
  void *return_value_list_next_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  void *return_value_list_find_first_8;
  do
  {
    return_value_list_next_2=list_next(i);
    pat = (char *)return_value_list_next_2;
    if(pat == ((char *)NULL))
      break;

    list_iterator_reset(j);
    do
    {
      return_value_list_next_3=list_next(j);
      obj = (struct base_obj *)return_value_list_next_3;
      if(obj == ((struct base_obj *)NULL))
        break;

      if((signed int)obj->type == CONMAN_OBJ_TELNET)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = (signed int)obj->type == CONMAN_OBJ_IPMI ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)obj->type == CONMAN_OBJ_PROCESS ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
        tmp_if_expr_6 = (_Bool)1;

      else
        tmp_if_expr_6 = (signed int)obj->type == CONMAN_OBJ_SERIAL ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_6)
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = (signed int)obj->type == CONMAN_OBJ_UNIXSOCK ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_7)
      {
        signed int return_value_fnmatch_9;
        return_value_fnmatch_9=fnmatch(pat, obj->name, 0);
        if(return_value_fnmatch_9 == 0)
        {
          return_value_list_find_first_8=list_find_first(matches, (signed int (*)(void *, void *))find_obj, (void *)obj);
          if(return_value_list_find_first_8 == NULL)
            list_append(matches, (void *)obj);

        }

      }

    }
    while((_Bool)1);
  }
  while((_Bool)1);
  list_iterator_destroy(i);
  list_iterator_destroy(j);
  return 0;
}

// query_consoles_via_regex
// file server-sock.c line 500
static signed int query_consoles_via_regex(struct server_conf *conf, struct request *req, struct list *matches)
{
  char *p;
  struct listIterator *i;
  char buf[32768l];
  signed int rc;
  struct re_pattern_buffer rex;
  struct anonymous_2 match;
  struct base_obj *obj;
  signed int return_value_list_is_empty_1;
  return_value_list_is_empty_1=list_is_empty(req->consoles);
  if(!(return_value_list_is_empty_1 == 0))
  {
    p=create_string(".*");
    list_append(req->consoles, (void *)p);
  }

  i=list_iterator_create(req->consoles);
  void *return_value_list_next_2;
  return_value_list_next_2=list_next(i);
  strlcpy(buf, (const char *)return_value_list_next_2, sizeof(char [32768l]) /*32768ul*/ );
  void *return_value_list_next_3;
  do
  {
    return_value_list_next_3=list_next(i);
    p = (char *)return_value_list_next_3;
    if(p == ((char *)NULL))
      break;

    strlcat(buf, "|", sizeof(char [32768l]) /*32768ul*/ );
    strlcat(buf, p, sizeof(char [32768l]) /*32768ul*/ );
  }
  while((_Bool)1);
  list_iterator_destroy(i);
  memset((void *)&rex, 0, sizeof(struct re_pattern_buffer) /*64ul*/ );
  rc=regcomp(&rex, buf, 1 | 1 << 1);
  if(!(rc == 0))
  {
    unsigned long int return_value_regerror_4;
    return_value_regerror_4=regerror(rc, &rex, buf, sizeof(char [32768l]) /*32768ul*/ );
    if(return_value_regerror_4 >= 32769ul)
      log_msg(4, "Got regerror() buffer overrun");

    regfree(&rex);
    send_rsp(req, 3, buf);
    return -1;
  }

  i=list_iterator_create(conf->objs);
  void *return_value_list_next_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  unsigned long int return_value_strlen_10;
  do
  {
    return_value_list_next_5=list_next(i);
    obj = (struct base_obj *)return_value_list_next_5;
    if(obj == ((struct base_obj *)NULL))
      break;

    if((signed int)obj->type == CONMAN_OBJ_TELNET)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = (signed int)obj->type == CONMAN_OBJ_IPMI ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
      tmp_if_expr_7 = (_Bool)1;

    else
      tmp_if_expr_7 = (signed int)obj->type == CONMAN_OBJ_PROCESS ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_7)
      tmp_if_expr_8 = (_Bool)1;

    else
      tmp_if_expr_8 = (signed int)obj->type == CONMAN_OBJ_SERIAL ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_8)
      tmp_if_expr_9 = (_Bool)1;

    else
      tmp_if_expr_9 = (signed int)obj->type == CONMAN_OBJ_UNIXSOCK ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_9)
    {
      signed int return_value_regexec_11;
      return_value_regexec_11=regexec(&rex, obj->name, (unsigned long int)1, &match, 0);
      if(return_value_regexec_11 == 0)
      {
        if(match.rm_so == 0)
        {
          return_value_strlen_10=strlen(obj->name);
          if((unsigned long int)match.rm_eo == return_value_strlen_10)
            list_append(matches, (void *)obj);

        }

      }

    }

  }
  while((_Bool)1);
  list_iterator_destroy(i);
  regfree(&rex);
  return 0;
}

// read_from_obj
// file server.h line 423
signed int read_from_obj(struct base_obj *obj, struct tpoll *tp)
{
  unsigned char buf[4095l];
  signed int n;
  signed int m;
  struct listIterator *i;
  struct base_obj *reader;
  if(!(obj->gotEOF == 0u))
  {
    signed int return_value_shutdown_obj_1;
    return_value_shutdown_obj_1=shutdown_obj(obj);
    return return_value_shutdown_obj_1;
  }

  signed long int return_value_read_15;
  signed int *return_value___errno_location_2;
  _Bool tmp_if_expr_5;
  signed int *return_value___errno_location_4;
  signed int *return_value___errno_location_9;
  signed int *return_value___errno_location_12;
  void *return_value_list_next_14;
  if((signed int)obj->type == CONMAN_OBJ_TELNET)
  {
    if((signed int)obj->aux.telnet.state == 3)
      goto again;

    return 0;
  }

  else
  {
    do
    {

    again:
      ;
      return_value_read_15=read(obj->fd, (void *)buf, sizeof(unsigned char [4095l]) /*4095ul*/ );
      n = (signed int)return_value_read_15;
      if(n >= 0)
        goto __CPROVER_DUMP_L6;

      return_value___errno_location_2=__errno_location();
    }
    while(*return_value___errno_location_2 == 4);
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    if(*return_value___errno_location_3 == 11)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value___errno_location_4=__errno_location();
      tmp_if_expr_5 = *return_value___errno_location_4 == 11 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      return 0;

    else
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      char *return_value_strerror_7;
      return_value_strerror_7=strerror(*return_value___errno_location_6);
      log_msg(6, "Unable to read from [%s]: %s", obj->name, return_value_strerror_7);
      signed int return_value_shutdown_obj_8;
      return_value_shutdown_obj_8=shutdown_obj(obj);
      return return_value_shutdown_obj_8;

    __CPROVER_DUMP_L6:
      ;
      if(n == 0)
      {
        obj->gotEOF = (unsigned int)1;
        tpoll_set(tp, obj->fd, (signed short int)0x004);
        return 0;
      }

      else
      {
        if((signed int)obj->type == CONMAN_OBJ_CLIENT)
        {
          do
          {
            signed int *return_value___errno_location_10;
            return_value___errno_location_10=__errno_location();
            *return_value___errno_location_10=pthread_mutex_lock(&obj->bufLock);
            if(!(*return_value___errno_location_10 == 0))
            {
              return_value___errno_location_9=__errno_location();
              log_err(*return_value___errno_location_9, "pthread_mutex_lock() failed");
            }

          }
          while((_Bool)0);
          time(&obj->aux.client.timeLastRead);
          if(obj->aux.client.timeLastRead == -1l)
          {
            signed int *return_value___errno_location_11;
            return_value___errno_location_11=__errno_location();
            log_err(*return_value___errno_location_11, "time() failed");
          }

          do
          {
            signed int *return_value___errno_location_13;
            return_value___errno_location_13=__errno_location();
            *return_value___errno_location_13=pthread_mutex_unlock(&obj->bufLock);
            if(!(*return_value___errno_location_13 == 0))
            {
              return_value___errno_location_12=__errno_location();
              log_err(*return_value___errno_location_12, "pthread_mutex_unlock() failed");
            }

          }
          while((_Bool)0);
          n=process_client_escapes(obj, (void *)buf, n);
        }

        else
          if((signed int)obj->type == CONMAN_OBJ_TELNET)
            n=process_telnet_escapes(obj, (void *)buf, n);

        if(n >= 1)
        {
          i=list_iterator_create(obj->readers);
          do
          {
            return_value_list_next_14=list_next(i);
            reader = (struct base_obj *)return_value_list_next_14;
            if(reader == ((struct base_obj *)NULL))
              break;

            if(reader->gotEOF == 0u)
            {
              if((signed int)reader->type == CONMAN_OBJ_LOGFILE)
                m=write_log_data(reader, (const void *)buf, n);

              else
                m=write_obj_data(reader, (const void *)buf, n, 0);
              if(m >= 1)
                tpoll_set(tp, reader->fd, (signed short int)0x004);

            }

          }
          while((_Bool)1);
          list_iterator_destroy(i);
        }

      }
      return n;
    }
  }
}

// read_line
// file util-file.h line 111
signed long int read_line(signed int fd, void *buf, unsigned long int maxlen)
{
  signed long int n;
  signed long int rc;
  unsigned char c;
  unsigned char *p;
  n = (signed long int)0;
  p = (unsigned char *)buf;
  unsigned char *tmp_post_1;
  while(!((unsigned long int)n >= maxlen + 18446744073709551615ul))
  {
    rc=read(fd, (void *)&c, (unsigned long int)1);
    if(rc == 1l)
    {
      n = n + 1l;
      tmp_post_1 = p;
      p = p + 1l;
      *tmp_post_1 = c;
      if((signed int)c == 10)
        break;

    }

    else
      if(rc == 0l)
      {
        if(n == 0l)
          return (signed long int)0;

        else
          break;
      }

      else
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        if(!(*return_value___errno_location_2 == 4))
          return (signed long int)-1;

      }
  }
  *p = (unsigned char)0;
  return n;
}

// read_n
// file util-file.h line 99
signed long int read_n(signed int fd, void *buf, unsigned long int n)
{
  unsigned long int nleft;
  signed long int nread;
  unsigned char *p = (unsigned char *)buf;
  nleft = n;
  while(nleft >= 1ul)
  {
    nread=read(fd, (void *)p, nleft);
    if(!(nread >= 0l))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        continue;

      else
        return (signed long int)-1;
    }

    else
      if(nread == 0l)
        break;

    nleft = nleft - (unsigned long int)nread;
    p = p + nread;
  }
  return (signed long int)(n - nleft);
}

// read_pidfile
// file server-conf.c line 1424
static signed int read_pidfile(const char *pidfile)
{
  struct _IO_FILE *fp;
  signed int n;
  signed int pid = 0;
  if(pidfile == ((const char *)NULL))
    return 0;

  else
  {
    fp=fopen(pidfile, "r");
    if(fp == ((struct _IO_FILE *)NULL))
      return 0;

    else
    {
      n=fscanf(fp, "%d", &pid);
      if(n == -1)
        log_msg(4, "Unable to read from pidfile \"%s\"", pidfile);

      else
        if(!(n == 1))
          log_msg(4, "Unable to obtain pid from pidfile \"%s\"", pidfile);

      signed int return_value_fclose_1;
      return_value_fclose_1=fclose(fp);
      if(return_value_fclose_1 == -1)
        log_msg(4, "Unable to close pidfile \"%s\"", pidfile);

      return n == 1 && pid > 1 ? pid : 0;
    }
  }
}

// recv_greeting
// file server-sock.c line 220
static signed int recv_greeting(struct request *req)
{
  signed int n;
  char buf[32768l];
  struct lexer_state *l;
  signed int recv_greeting__1__done = 0;
  signed int tok;
  signed long int return_value_read_line_3;
  return_value_read_line_3=read_line(req->sd, (void *)buf, sizeof(char [32768l]) /*32768ul*/ );
  n = (signed int)return_value_read_line_3;
  if(!(n >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_msg(5, "Unable to read greeting from <%s:%d>: %s", req->fqdn, req->port, return_value_strerror_2);
    return -1;
  }

  else
    if(n == 0)
    {
      log_msg(5, "Connection terminated by <%s:%d>", req->fqdn, req->port);
      return -1;
    }

  l=lex_create((void *)buf, proto_strs);
  while(recv_greeting__1__done == 0)
  {
    tok=lex_next(l);
    switch(tok)
    {
      case 265:
      {
        parse_greeting(l, req);
        break;
      }
      case 0:

      case 256:
        recv_greeting__1__done = 1;
      default:
        ;
    }
  }
  lex_destroy(l);
  if(req->user == ((char *)NULL))
  {
    req->user=create_string("unknown");
    send_rsp(req, 2, "Invalid greeting: no user specified");
    return -1;
  }

  else
  {
    signed int return_value_send_rsp_4;
    return_value_send_rsp_4=send_rsp(req, 0, (char *)(void *)0);
    return return_value_send_rsp_4;
  }
}

// recv_req
// file server-sock.c line 318
static signed int recv_req(struct request *req)
{
  signed int n;
  char buf[32768l];
  struct lexer_state *l;
  signed int recv_req__1__done = 0;
  signed int tok;
  signed long int return_value_read_line_3;
  return_value_read_line_3=read_line(req->sd, (void *)buf, sizeof(char [32768l]) /*32768ul*/ );
  n = (signed int)return_value_read_line_3;
  if(!(n >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_msg(5, "Unable to read request from <%s:%d>: %s", req->fqdn, req->port, return_value_strerror_2);
    return -1;
  }

  else
    if(n == 0)
    {
      log_msg(5, "Connection terminated by <%s:%d>", req->fqdn, req->port);
      return -1;
    }

  l=lex_create((void *)buf, proto_strs);
  while(recv_req__1__done == 0)
  {
    tok=lex_next(l);
    switch(tok)
    {
      case 261:
      {
        req->command = (unsigned int)1;
        parse_cmd_opts(l, req);
        break;
      }
      case 268:
      {
        req->command = (unsigned int)2;
        parse_cmd_opts(l, req);
        break;
      }
      case 271:
      {
        req->command = (unsigned int)3;
        parse_cmd_opts(l, req);
        break;
      }
      case 0:

      case 256:
        recv_req__1__done = 1;
      default:
        ;
    }
  }
  lex_destroy(l);
  return 0;
}

// release_lock
// file util-file.c line 111
signed int release_lock(signed int fd)
{
  signed int return_value_get_file_lock_1;
  return_value_get_file_lock_1=get_file_lock(fd, 6, 2);
  return return_value_get_file_lock_1;
}

// reopen_logfiles
// file server.c line 962
static void reopen_logfiles(struct server_conf *conf)
{
  struct listIterator *i;
  struct base_obj *logfile;
  i=list_iterator_create(conf->objs);
  void *return_value_list_next_1;
  do
  {
    return_value_list_next_1=list_next(i);
    logfile = (struct base_obj *)return_value_list_next_1;
    if(logfile == ((struct base_obj *)NULL))
      break;

    if((signed int)logfile->type == CONMAN_OBJ_LOGFILE)
      open_logfile_obj(logfile);

  }
  while((_Bool)1);
  list_iterator_destroy(i);
  if(!(conf->logFileName == ((char *)NULL)))
  {
    if(conf->enableForeground == 0u)
      open_daemon_logfile(conf);

  }

  goto __CPROVER_DUMP_L5;

__CPROVER_DUMP_L5:
  ;
}

// reopen_obj
// file server.h line 403
void reopen_obj(struct base_obj *obj)
{
  if((signed int)obj->type == CONMAN_OBJ_LOGFILE)
    open_logfile_obj(obj);

  else
    if((signed int)obj->type == CONMAN_OBJ_PROCESS)
      open_process_obj(obj);

    else
      if((signed int)obj->type == CONMAN_OBJ_SERIAL)
        open_serial_obj(obj);

      else
        if((signed int)obj->type == CONMAN_OBJ_TELNET)
          open_telnet_obj(obj);

        else
          if((signed int)obj->type == CONMAN_OBJ_UNIXSOCK)
            open_unixsock_obj(obj);

          else
            if((signed int)obj->type == CONMAN_OBJ_IPMI)
              open_ipmi_obj(obj);

            else
              if(!((signed int)obj->type == CONMAN_OBJ_CLIENT))
                log_err(0, "INTERNAL: Cannot re-open unrecognized object [%s] type=%d", obj->name, obj->type);

}

// replace_string
// file util-str.h line 52
signed int replace_string(char **dst, const char *src)
{
  if(dst == ((char **)NULL))
    return -1;

  else
  {
    if(!(*dst == ((char *)NULL)))
      free((void *)*dst);

    *dst=strdup(src);
    if(*dst == ((char *)NULL))
    {
      log_err(0, "Out of memory");
      (void *)0;
    }

    return 0;
  }
}

// reset_console
// file server.c line 1050
static void reset_console(struct base_obj *console, const char *cmd)
{
  char buf[1024l];
  signed int pid;
  signed int *arg;
  console->gotReset = (unsigned int)0;
  signed int return_value_format_obj_string_1;
  return_value_format_obj_string_1=format_obj_string(buf, (signed int)sizeof(char [1024l]) /*1024ul*/ , console, cmd);
  if(!(return_value_format_obj_string_1 >= 0))
    log_msg(5, "Unable to reset console [%s]: command too long", console->name);

  else
  {
    pid=fork();
    if(!(pid >= 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      log_msg(5, "Unable to reset console [%s]: %s", console->name, return_value_strerror_3);
      goto __CPROVER_DUMP_L6;
    }

    else
      if(pid == 0)
      {
        setpgid(pid, 0);
        close(0);
        close(1);
        close(2);
        execl("/bin/sh", "sh", (const void *)"-c", (const void *)buf, (char *)(void *)0);
        _exit(127);
      }

    setpgid(pid, 0);
    log_msg(6, "Reset console [%s] (pid %d)", console->name, pid);
    void *return_value_malloc_4;
    return_value_malloc_4=malloc(sizeof(signed int) /*4ul*/ );
    arg = (signed int *)return_value_malloc_4;
    if(arg == ((signed int *)NULL))
    {
      log_err(0, "Out of memory");
      (void *)0;
    }

    *arg = pid;
    signed int return_value_tpoll_timeout_relative_5;
    return_value_tpoll_timeout_relative_5=tpoll_timeout_relative(tp_global, (void (*)(void *))kill_console_reset, (void *)arg, 60 * 1000);
    if(!(return_value_tpoll_timeout_relative_5 >= 0))
      log_msg(3, "Unable to create timer for resetting console [%s]", console->name);

    goto __CPROVER_DUMP_L6;
  }

__CPROVER_DUMP_L6:
  ;
}

// reset_ipmi_delay
// file server-ipmi.c line 1029
static void reset_ipmi_delay(struct base_obj *ipmi)
{
  signed int *return_value___errno_location_1;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_lock(&ipmi->aux.ipmi.mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      return_value___errno_location_1=__errno_location();
      log_err(*return_value___errno_location_1, "pthread_mutex_lock() failed");
    }

  }
  while((_Bool)0);
  ipmi->aux.ipmi.delay = 60;
  ipmi->aux.ipmi.timer = -1;
  signed int *return_value___errno_location_3;
  do
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    *return_value___errno_location_4=pthread_mutex_unlock(&ipmi->aux.ipmi.mutex);
    if(!(*return_value___errno_location_4 == 0))
    {
      return_value___errno_location_3=__errno_location();
      log_err(*return_value___errno_location_3, "pthread_mutex_unlock() failed");
    }

  }
  while((_Bool)0);
}

// reset_process_delay
// file server-process.c line 423
static void reset_process_delay(struct base_obj *process)
{
  struct process_obj *auxp = &process->aux.process;
  auxp->timer = -1;
  auxp->delay = 0;
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// reset_telnet_delay
// file server-telnet.c line 339
static void reset_telnet_delay(struct base_obj *telnet)
{
  telnet->aux.telnet.delay = 0;
  telnet->aux.telnet.timer = -1;
}

// resolve_addr
// file server-sock.c line 161
static signed int resolve_addr(struct server_conf *conf, struct request *req, signed int sd)
{
  struct sockaddr_in addr;
  unsigned int addrlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  char buf[1024l];
  char *p;
  signed int gotHostName = 0;
  req->sd = sd;
  signed int return_value_getpeername_2;
  return_value_getpeername_2=getpeername(sd, (struct sockaddr *)&addr, &addrlen);
  signed int *return_value___errno_location_1;
  if(!(return_value_getpeername_2 >= 0))
  {
    return_value___errno_location_1=__errno_location();
    log_err(*return_value___errno_location_1, "Unable to get address of remote peer");
  }

  const char *return_value_inet_ntop_4;
  return_value_inet_ntop_4=inet_ntop(2, (const void *)&addr.sin_addr, buf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ );
  signed int *return_value___errno_location_3;
  if(return_value_inet_ntop_4 == ((const char *)NULL))
  {
    return_value___errno_location_3=__errno_location();
    log_err(*return_value___errno_location_3, "Unable to convert network address into string");
  }

  unsigned short int return_value_ntohs_5;
  return_value_ntohs_5=ntohs(addr.sin_port);
  req->port = (signed int)return_value_ntohs_5;
  req->ip=create_string(buf);
  char *return_value_host_addr4_to_name_6;
  return_value_host_addr4_to_name_6=host_addr4_to_name(&addr.sin_addr, buf, (signed int)sizeof(char [1024l]) /*1024ul*/ );
  if(!(return_value_host_addr4_to_name_6 == ((char *)NULL)))
  {
    gotHostName = 1;
    req->fqdn=create_string(buf);
    p=strchr(buf, 46);
    if(!(p == ((char *)NULL)))
      *p = (char)0;

    req->host=create_string(buf);
  }

  else
  {
    req->fqdn=create_string(buf);
    req->host=create_string(buf);
  }
  char *tmp_if_expr_7;
  if(!(conf->enableTCPWrap == 0u))
  {
    if(!(gotHostName == 0))
      tmp_if_expr_7 = req->fqdn;

    else
      tmp_if_expr_7 = "unknown";
    signed int return_value_hosts_ctl_8;
    return_value_hosts_ctl_8=hosts_ctl("conmand", tmp_if_expr_7, req->ip, "unknown");
    if(return_value_hosts_ctl_8 == 0)
    {
      log_msg(5, "TCP-Wrappers rejected connection from <%s:%d>", req->fqdn, req->port);
      return -1;
    }

  }

  return 0;
}

// sanitize_file_string
// file server-obj.c line 407
static char * sanitize_file_string(char *str)
{
  char *p;
  _Bool tmp_if_expr_2;
  if(!(str == ((char *)NULL)))
  {
    p = str;
    for( ; !(*p == 0); p = p + 1l)
    {
      const unsigned short int **return_value___ctype_b_loc_1;
      return_value___ctype_b_loc_1=__ctype_b_loc();
      if((32768 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*p]) == 0)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)*p == 47 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        *p = (char)95;

    }
  }

  return str;
}

// schedule_timestamp
// file server.c line 551
static void schedule_timestamp(struct server_conf *conf)
{
  signed long int t;
  struct tm tm;
  struct timeval tv;
  signed int numCompleted;
  t = conf->tStampNext;
  get_localtime(&t, &tm);
  if(conf->tStampNext == 0l)
  {
    numCompleted = (tm.tm_hour * 60 + tm.tm_min) / conf->tStampMinutes;
    tm.tm_min = (numCompleted + 1) * conf->tStampMinutes;
    tm.tm_hour = 0;
  }

  else
    tm.tm_min = tm.tm_min + conf->tStampMinutes;
  tm.tm_sec = 0;
  t=mktime(&tm);
  if(t == -1l)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    log_err(*return_value___errno_location_1, "Unable to determine time of next logfile timestamp");
  }

  tv.tv_sec = t;
  tv.tv_usec = (signed long int)0;
  conf->tStampNext = t;
  signed int return_value_tpoll_timeout_absolute_2;
  return_value_tpoll_timeout_absolute_2=tpoll_timeout_absolute(tp_global, (void (*)(void *))timestamp_logfiles, (void *)conf, &tv);
  if(!(return_value_tpoll_timeout_absolute_2 >= 0))
    log_err(0, "Unable to create timer for timestamping logfiles");

  goto __CPROVER_DUMP_L5;

__CPROVER_DUMP_L5:
  ;
}

// search_exec_path
// file server-process.c line 97
static signed int search_exec_path(const char *path, const char *src, char *dst, signed int dstlen)
{
  char path_buf[4096l];
  char file_buf[4096l];
  char *p;
  char *q;
  struct stat st;
  signed int n;
  _Bool tmp_if_expr_2;
  char *tmp_post_3;
  if(path == ((const char *)NULL))
    return -1;

  else
  {
    unsigned long int return_value_strlcpy_1;
    return_value_strlcpy_1=strlcpy(path_buf, path, sizeof(char [4096l]) /*4096ul*/ );
    if(return_value_strlcpy_1 >= sizeof(char [4096l]) /*4096ul*/ )
      return -1;

    else
    {
      p = path_buf;
      do
      {
        if(!(p == ((char *)NULL)))
          tmp_if_expr_2 = *p != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(!tmp_if_expr_2)
          break;

        q=strchr(p, 58);
        if(!(q == ((char *)NULL)))
        {
          tmp_post_3 = q;
          q = q + 1l;
          *tmp_post_3 = (char)0;
        }

        else
          q=strchr(p, 0);
        signed int return_value_stat_4;
        return_value_stat_4=stat(p, &st);
        if(return_value_stat_4 >= 0)
        {
          if((61440u & st.st_mode) == 16384u)
          {
            n=snprintf(file_buf, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", p, src);
            if(!((unsigned long int)n >= sizeof(char [4096l]) /*4096ul*/ ) && n >= 0)
            {
              signed int return_value_access_5;
              return_value_access_5=access(file_buf, 1);
              if(return_value_access_5 >= 0)
              {
                if(dstlen >= 1 && !(dst == ((char *)NULL)))
                {
                  unsigned long int return_value_strlcpy_6;
                  return_value_strlcpy_6=strlcpy(dst, file_buf, (unsigned long int)dstlen);
                  if(return_value_strlcpy_6 >= (unsigned long int)dstlen)
                    return 1;

                }

                return 0;
              }

            }

          }

        }

        p = q;
      }
      while((_Bool)1);
      return -1;
    }
  }
}

// send_ipmi_break
// file server.h line 374
signed int send_ipmi_break(struct base_obj *ipmi)
{
  signed int rc;
  signed int *return_value___errno_location_1;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_lock(&ipmi->aux.ipmi.mutex);
    if(!(*return_value___errno_location_2 == 0))
    {
      return_value___errno_location_1=__errno_location();
      log_err(*return_value___errno_location_1, "pthread_mutex_lock() failed");
    }

  }
  while((_Bool)0);
  if(ipmi->aux.ipmi.ctx == ((struct ipmiconsole_ctx *)NULL))
  {
    log_msg(3, "Unable to send serial-break to [%s]: NULL IPMI context", ipmi->name);
    rc = -1;
  }

  else
    rc=ipmiconsole_ctx_generate_break(ipmi->aux.ipmi.ctx);
  signed int *return_value___errno_location_3;
  do
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    *return_value___errno_location_4=pthread_mutex_unlock(&ipmi->aux.ipmi.mutex);
    if(!(*return_value___errno_location_4 == 0))
    {
      return_value___errno_location_3=__errno_location();
      log_err(*return_value___errno_location_3, "pthread_mutex_unlock() failed");
    }

  }
  while((_Bool)0);
  return rc;
}

// send_rsp
// file server-sock.c line 707
static signed int send_rsp(struct request *req, signed int errnum, char *errmsg)
{
  char buf[32768l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char tmp[1024l];
  signed int n;
  struct listIterator *i;
  struct base_obj *console;
  void *return_value_list_next_3;
  if(errnum == 0)
  {
    unsigned long int return_value_append_format_string_1;
    return_value_append_format_string_1=append_format_string(buf, sizeof(char [32768l]) /*32768ul*/ , "%s", proto_strs[(signed long int)(269 < 259 ? 269 : 269 - 259)]);
    n = (signed int)return_value_append_format_string_1;
    signed int return_value_list_count_7;
    return_value_list_count_7=list_count(req->consoles);
    if(return_value_list_count_7 >= 1)
    {
      if(!(req->enableReset == 0u))
      {
        unsigned long int return_value_append_format_string_2;
        return_value_append_format_string_2=append_format_string(buf, sizeof(char [32768l]) /*32768ul*/ , " %s=%s", proto_strs[(signed long int)(270 < 259 ? 270 : 270 - 259)], proto_strs[(signed long int)(274 < 259 ? 274 : 274 - 259)]);
        n = (signed int)return_value_append_format_string_2;
      }

      i=list_iterator_create(req->consoles);
      do
      {
        return_value_list_next_3=list_next(i);
        console = (struct base_obj *)return_value_list_next_3;
        if(console == ((struct base_obj *)NULL))
          break;

        unsigned long int return_value_strlcpy_4;
        return_value_strlcpy_4=strlcpy(tmp, console->name, sizeof(char [1024l]) /*1024ul*/ );
        n = (signed int)return_value_strlcpy_4;
        char *return_value_lex_encode_5;
        return_value_lex_encode_5=lex_encode(tmp);
        unsigned long int return_value_append_format_string_6;
        return_value_append_format_string_6=append_format_string(buf, sizeof(char [32768l]) /*32768ul*/ , " %s='%s'", proto_strs[(signed long int)(262 < 259 ? 262 : 262 - 259)], return_value_lex_encode_5);
        n = (signed int)return_value_append_format_string_6;
      }
      while((_Bool)1);
      list_iterator_destroy(i);
    }

    unsigned long int return_value_append_format_string_8;
    return_value_append_format_string_8=append_format_string(buf, sizeof(char [32768l]) /*32768ul*/ , "\n");
    n = (signed int)return_value_append_format_string_8;
  }

  else
  {
    unsigned long int return_value_strlcpy_9;
    return_value_strlcpy_9=strlcpy(tmp, errmsg != ((char *)NULL) ? errmsg : "unspecified error", sizeof(char [1024l]) /*1024ul*/ );
    n = (signed int)return_value_strlcpy_9;
    char *return_value_lex_encode_10;
    return_value_lex_encode_10=lex_encode(tmp);
    n=snprintf(buf, sizeof(char [32768l]) /*32768ul*/ , "%s %s=%d %s='%s'\n", proto_strs[(signed long int)(263 < 259 ? 263 : 263 - 259)], proto_strs[(signed long int)(260 < 259 ? 260 : 260 - 259)], errnum, proto_strs[(signed long int)(267 < 259 ? 267 : 267 - 259)], return_value_lex_encode_10);
    log_msg(5, "Client <%s@%s:%d> request failed: %s", req->user, req->fqdn, req->port, errmsg);
  }
  if((unsigned long int)n >= sizeof(char [32768l]) /*32768ul*/  || !(n >= 0))
  {
    log_msg(4, "Client <%s@%s:%d> request terminated by buffer overrun", req->user, req->fqdn, req->port);
    return -1;
  }

  else
  {
    unsigned long int return_value_strlen_13;
    return_value_strlen_13=strlen(buf);
    signed long int return_value_write_n_14;
    return_value_write_n_14=write_n(req->sd, (void *)buf, return_value_strlen_13);
    if(!(return_value_write_n_14 >= 0l))
    {
      signed int *return_value___errno_location_11;
      return_value___errno_location_11=__errno_location();
      char *return_value_strerror_12;
      return_value_strerror_12=strerror(*return_value___errno_location_11);
      log_msg(5, "Unable to write to <%s:%d>: %s", req->fqdn, req->port, return_value_strerror_12);
      return -1;
    }

    return 0;
  }
}

// send_telnet_cmd
// file server.h line 472
signed int send_telnet_cmd(struct base_obj *telnet, signed int cmd, signed int opt)
{
  unsigned char buf[3l];
  unsigned char *p = buf;
  char opt_buf[8l];
  _Bool tmp_if_expr_1;
  if(!(telnet->fd >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)telnet->aux.telnet.state != 3 ? (_Bool)1 : (_Bool)0;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    tmp_post_2 = p;
    p = p + 1l;
    *tmp_post_2 = (unsigned char)255;
    if(!((unsigned int)cmd >= 236u) || (unsigned int)cmd >= 256u)
    {
      log_msg(4, "Invalid telnet cmd=%#.2x for console [%s]", cmd, telnet->name);
      return -1;
    }

    else
    {
      tmp_post_3 = p;
      p = p + 1l;
      *tmp_post_3 = (unsigned char)cmd;
      if(cmd == 251 || cmd == 252 || cmd == 253 || cmd == 254)
      {
        tmp_post_4 = p;
        p = p + 1l;
        *tmp_post_4 = (unsigned char)opt;
      }

      signed int return_value_write_obj_data_5;
      return_value_write_obj_data_5=write_obj_data(telnet, (const void *)buf, (signed int)(p - buf), 0);
      if(!(return_value_write_obj_data_5 >= 1))
        return -1;

      else
      {
        opt_buf[(signed long int)0] = (char)0;
        return 0;
      }
    }
  }
}

// set_fd_blocking
// file util-file.h line 43
void set_fd_blocking(signed int fd)
{
  signed int fval;
  fval=fcntl(fd, 3, 0);
  signed int *return_value___errno_location_1;
  if(!(fval >= 0))
  {
    return_value___errno_location_1=__errno_location();
    log_err(*return_value___errno_location_1, "fcntl(F_GETFL) failed");
  }

  signed int return_value_fcntl_3;
  return_value_fcntl_3=fcntl(fd, 4, fval & ~04000);
  signed int *return_value___errno_location_2;
  if(!(return_value_fcntl_3 >= 0))
  {
    return_value___errno_location_2=__errno_location();
    log_err(*return_value___errno_location_2, "fcntl(F_SETFL) failed");
  }

  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// set_fd_closed_on_exec
// file util-file.h line 38
void set_fd_closed_on_exec(signed int fd)
{
  signed int return_value_fcntl_2;
  return_value_fcntl_2=fcntl(fd, 2, 1);
  signed int *return_value___errno_location_1;
  if(!(return_value_fcntl_2 >= 0))
  {
    return_value___errno_location_1=__errno_location();
    log_err(*return_value___errno_location_1, "fcntl(F_SETFD) failed");
  }

  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// set_fd_nonblocking
// file util-file.h line 48
void set_fd_nonblocking(signed int fd)
{
  signed int fval;
  fval=fcntl(fd, 3, 0);
  signed int *return_value___errno_location_1;
  if(!(fval >= 0))
  {
    return_value___errno_location_1=__errno_location();
    log_err(*return_value___errno_location_1, "fcntl(F_GETFL) failed");
  }

  signed int return_value_fcntl_3;
  return_value_fcntl_3=fcntl(fd, 4, fval | 04000);
  signed int *return_value___errno_location_2;
  if(!(return_value_fcntl_3 >= 0))
  {
    return_value___errno_location_2=__errno_location();
    log_err(*return_value___errno_location_2, "fcntl(F_SETFL) failed");
  }

  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// set_serial_opts
// file server-serial.c line 256
void set_serial_opts(struct termios *tty, struct base_obj *serial, struct serial_opt *opts)
{
  signed int return_value_cfsetispeed_2;
  return_value_cfsetispeed_2=cfsetispeed(tty, opts->bps);
  signed int *return_value___errno_location_1;
  if(!(return_value_cfsetispeed_2 >= 0))
  {
    return_value___errno_location_1=__errno_location();
    log_err(*return_value___errno_location_1, "Unable to set [%s] input baud rate to %d", serial->name, opts->bps);
  }

  signed int return_value_cfsetospeed_4;
  return_value_cfsetospeed_4=cfsetospeed(tty, opts->bps);
  signed int *return_value___errno_location_3;
  if(!(return_value_cfsetospeed_4 >= 0))
  {
    return_value___errno_location_3=__errno_location();
    log_err(*return_value___errno_location_3, "Unable to set [%s] output baud rate to %d", serial->name, opts->bps);
  }

  tty->c_cflag = tty->c_cflag & (unsigned int)~0000060;
  if(opts->databits == 5)
    tty->c_cflag = tty->c_cflag | (unsigned int)0000000;

  else
    if(opts->databits == 6)
      tty->c_cflag = tty->c_cflag | (unsigned int)0000020;

    else
      if(opts->databits == 7)
        tty->c_cflag = tty->c_cflag | (unsigned int)0000040;

      else
        tty->c_cflag = tty->c_cflag | (unsigned int)0000060;
  if(opts->parity == 1)
    tty->c_cflag = tty->c_cflag | (unsigned int)(0000400 | 0001000);

  else
    if(opts->parity == 2)
    {
      tty->c_cflag = tty->c_cflag | (unsigned int)0000400;
      tty->c_cflag = tty->c_cflag & (unsigned int)~0001000;
    }

    else
      tty->c_cflag = tty->c_cflag & (unsigned int)~(0000400 | 0001000);
  if(opts->stopbits == 2)
    tty->c_cflag = tty->c_cflag | (unsigned int)0000100;

  else
    tty->c_cflag = tty->c_cflag & (unsigned int)~0000100;
  goto __CPROVER_DUMP_L12;

__CPROVER_DUMP_L12:
  ;
}

// set_tty_mode
// file common.h line 202
void set_tty_mode(struct termios *tty, signed int fd)
{
  signed int return_value_isatty_1;
  return_value_isatty_1=isatty(fd);
  signed int *return_value___errno_location_2;
  if(!(return_value_isatty_1 == 0))
  {
    signed int return_value_tcsetattr_3;
    return_value_tcsetattr_3=tcsetattr(fd, 2, tty);
    if(!(return_value_tcsetattr_3 >= 0))
    {
      return_value___errno_location_2=__errno_location();
      log_err(*return_value___errno_location_2, "tcgetattr() failed on fd=%d", fd);
    }

    goto __CPROVER_DUMP_L2;
  }


__CPROVER_DUMP_L2:
  ;
}

// setup_coredump
// file server.c line 317
static void setup_coredump(struct server_conf *conf)
{
  struct rlimit limit;
  if(!(conf->enableCoreDump == 0u))
  {
    limit.rlim_cur = (unsigned long int)-1;
    limit.rlim_max = (unsigned long int)-1;
    coredump = 1;
    if(!(conf->coreDumpDir == ((char *)NULL)))
      strlcpy(coredumpdir, conf->coreDumpDir, sizeof(char [4096l]) /*4096ul*/ );

    else
      getcwd(coredumpdir, sizeof(char [4096l]) /*4096ul*/ );
  }

  else
  {
    limit.rlim_cur = (unsigned long int)0;
    limit.rlim_max = (unsigned long int)0;
    coredump = 0;
    coredumpdir[(signed long int)0] = (char)0;
  }
  signed int return_value_setrlimit_2;
  return_value_setrlimit_2=setrlimit(4, &limit);
  if(!(return_value_setrlimit_2 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    log_err(*return_value___errno_location_1, "Unable to set core dump file limit");
  }

  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// setup_signals
// file server.c line 346
static void setup_signals(struct server_conf *conf)
{
  posix_signal(17, sig_chld_handler);
  posix_signal(1, sig_hup_handler);
  posix_signal(2, exit_handler);
  posix_signal(13, (void (*)(signed int))1);
  posix_signal(15, exit_handler);
  posix_signal(6, coredump_handler);
  posix_signal(7, coredump_handler);
  posix_signal(8, coredump_handler);
  posix_signal(4, coredump_handler);
  posix_signal(3, coredump_handler);
  posix_signal(11, coredump_handler);
}

// shutdown_obj
// file server-obj.c line 758
signed int shutdown_obj(struct base_obj *obj)
{
  signed int *return_value___errno_location_3;
  signed int *return_value___errno_location_5;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_10;
  if(!(obj->fd >= 0))
    return 0;

  else
  {
    signed int return_value_close_2;
    return_value_close_2=close(obj->fd);
    if(!(return_value_close_2 >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      log_err(*return_value___errno_location_1, "Unable to close object [%s]", obj->name);
    }

    obj->fd = -1;
    do
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4=pthread_mutex_lock(&obj->bufLock);
      if(!(*return_value___errno_location_4 == 0))
      {
        return_value___errno_location_3=__errno_location();
        log_err(*return_value___errno_location_3, "pthread_mutex_lock() failed");
      }

    }
    while((_Bool)0);
    obj->bufOutPtr = obj->buf;
    obj->bufInPtr = obj->bufOutPtr;
    do
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      *return_value___errno_location_6=pthread_mutex_unlock(&obj->bufLock);
      if(!(*return_value___errno_location_6 == 0))
      {
        return_value___errno_location_5=__errno_location();
        log_err(*return_value___errno_location_5, "pthread_mutex_unlock() failed");
      }

    }
    while((_Bool)0);
    if((signed int)obj->type == CONMAN_OBJ_CLIENT)
    {
      unlink_obj(obj);
      return -1;
    }

    else
      if((signed int)obj->type == CONMAN_OBJ_LOGFILE)
        return 0;

      else
      {
        if((signed int)obj->type == CONMAN_OBJ_TELNET)
          tmp_if_expr_7 = (_Bool)1;

        else
          tmp_if_expr_7 = (signed int)obj->type == CONMAN_OBJ_IPMI ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_7)
          tmp_if_expr_8 = (_Bool)1;

        else
          tmp_if_expr_8 = (signed int)obj->type == CONMAN_OBJ_PROCESS ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_8)
          tmp_if_expr_9 = (_Bool)1;

        else
          tmp_if_expr_9 = (signed int)obj->type == CONMAN_OBJ_SERIAL ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_9)
          tmp_if_expr_10 = (_Bool)1;

        else
          tmp_if_expr_10 = (signed int)obj->type == CONMAN_OBJ_UNIXSOCK ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_10)
        {
          reopen_obj(obj);
          return 0;
        }

        else
        {
          log_err(0, "Unable to shutdown unrecognized object [%s] type=%d", obj->name, obj->type);
          return -1;
        }
      }
  }
}

// sig_chld_handler
// file server.c line 366
static void sig_chld_handler(signed int signum)
{
  signed int pid;
  do
  {
    pid=waitpid(-1, (signed int *)(void *)0, 1);
    if(!(pid >= 1))
      break;

  }
  while((_Bool)1);
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// sig_hup_handler
// file server.c line 375
static void sig_hup_handler(signed int signum)
{
  reconfig = signum;
}

// signal_daemon
// file server-conf.c line 517
static void signal_daemon(struct server_conf *conf)
{
  signed int pid;
  const char *msg;
  pid=is_write_lock_blocked(conf->fd);
  if(pid == 0)
  {
    pid=read_pidfile(conf->pidFileName);
    if(pid == 0)
      log_err(0, "Configuration \"%s\" does not appear to be active", conf->confFileName);

  }

  if(!(conf->pidFileName == ((char *)NULL)))
  {
    free((void *)conf->pidFileName);
    conf->pidFileName = (char *)(void *)0;
  }

  signed int return_value_kill_5;
  return_value_kill_5=kill(pid, conf->throwSignal);
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_3;
  signed int *return_value___errno_location_2;
  if(!(return_value_kill_5 >= 0))
  {
    if(conf->throwSignal == 0)
    {
      return_value___errno_location_3=__errno_location();
      tmp_if_expr_4 = *return_value___errno_location_3 == 1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(!tmp_if_expr_4)
    {
      return_value___errno_location_2=__errno_location();
      if(*return_value___errno_location_2 == 3)
        log_err(0, "Configuration \"%s\" does not appear to be active", conf->confFileName);

      else
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        log_err(*return_value___errno_location_1, "Configuration \"%s\" (pid %d) cannot be sent signal=%d", conf->confFileName, (signed int)pid, conf->throwSignal);
      }
    }

  }

  if(conf->throwSignal == 0)
    printf("%d\n", (signed int)pid);

  else
    if(!(conf->enableVerbose == 0u))
    {
      if(conf->throwSignal == 1)
        msg = "reconfigured on";

      else
        if(conf->throwSignal == 15)
          msg = "terminated on";

        else
          msg = "sent";
      fprintf(stderr, "Configuration \"%s\" (pid %d) %s signal=%d\n", conf->confFileName, (signed int)pid, msg, conf->throwSignal);
    }

  ipmi_fini();
  destroy_server_conf(conf);
  exit(0);
}

// strlcat
// file util-str.h line 168
unsigned long int strlcat(char *dst, const char *src, unsigned long int siz)
{
  char *d = dst;
  const char *s = src;
  unsigned long int n = siz;
  unsigned long int dlen;
  unsigned long int tmp_post_1;
  do
  {
    tmp_post_1 = n;
    n = n - 1ul;
    if(tmp_post_1 == 0ul)
      break;

    if((signed int)*d == 0)
      break;

    d = d + 1l;
  }
  while((_Bool)1);
  dlen = (unsigned long int)(d - dst);
  n = siz - dlen;
  unsigned long int return_value_strlen_2;
  char *tmp_post_3;
  if(n == 0ul)
  {
    return_value_strlen_2=strlen(s);
    return dlen + return_value_strlen_2;
  }

  else
  {
    for( ; !((signed int)*s == 0); s = s + 1l)
      if(!(n == 1ul))
      {
        tmp_post_3 = d;
        d = d + 1l;
        *tmp_post_3 = *s;
        n = n - 1ul;
      }

    *d = (char)0;
    return dlen + (unsigned long int)(s - src);
  }
}

// strlcpy
// file util-str.h line 178
unsigned long int strlcpy(char *dst, const char *src, unsigned long int siz)
{
  char *d = dst;
  const char *s = src;
  unsigned long int n = siz;
  char *tmp_post_1;
  const char *tmp_post_2;
  if(!(n == 0ul))
  {
    n = n - 1ul;
    if(!(n == 0ul))
      do
      {
        tmp_post_1 = d;
        d = d + 1l;
        tmp_post_2 = s;
        s = s + 1l;
        *tmp_post_1 = *tmp_post_2;
        if((signed int)*tmp_post_1 == 0)
          break;

        n = n - 1ul;
      }
      while(!(n == 0ul));

  }

  const char *tmp_post_3;
  if(n == 0ul)
  {
    if(!(siz == 0ul))
      *d = (char)0;

    do
    {
      tmp_post_3 = s;
      s = s + 1l;
      if(*tmp_post_3 == 0)
        break;

    }
    while((_Bool)1);
  }

  return (unsigned long int)((s - src) - (signed long int)1);
}

// substitute_string
// file util-str.h line 94
signed int substitute_string(char *dst, unsigned long int dstlen, const char *src, char c, const char *sub)
{
  const char *p;
  char *q;
  signed int len;
  signed int n;
  if(dst == ((char *)NULL) || src == ((const char *)NULL) || c == 0 || !(dstlen >= 1ul))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  p = src;
  q = dst;
  len = (signed int)dstlen;
  _Bool tmp_if_expr_5;
  char *tmp_post_3;
  const char *tmp_post_4;
  while(!(*p == 0))
  {
    if(!(len >= 1))
      break;

    if((signed int)*p == 37)
      tmp_if_expr_5 = p[(signed long int)1] == c ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      if(!(sub == ((const char *)NULL)))
      {
        unsigned long int return_value_strlcpy_2;
        return_value_strlcpy_2=strlcpy(q, sub, (unsigned long int)len);
        n = (signed int)return_value_strlcpy_2;
        q = q + (signed long int)n;
        len = len - n;
      }

      p = p + (signed long int)2;
    }

    else
    {
      tmp_post_3 = q;
      q = q + 1l;
      tmp_post_4 = p;
      p = p + 1l;
      *tmp_post_3 = *tmp_post_4;
      len = len - 1;
    }
  }
  if(len >= 1)
  {
    *q = (char)0;
    return (signed int)(dstlen - (unsigned long int)len);
  }

  else
  {
    dst[(signed long int)(dstlen - (unsigned long int)1)] = (char)0;
    return -1;
  }
}

// test_file_lock
// file util-file.c line 144
static signed int test_file_lock(signed int fd, signed int type)
{
  struct flock lock;
  lock.l_type = (signed short int)type;
  lock.l_start = (signed long int)0;
  lock.l_whence = (signed short int)0;
  lock.l_len = (signed long int)0;
  signed int return_value_fcntl_2;
  return_value_fcntl_2=fcntl(fd, 5, &lock);
  signed int *return_value___errno_location_1;
  if(!(return_value_fcntl_2 >= 0))
  {
    return_value___errno_location_1=__errno_location();
    log_err(*return_value___errno_location_1, "Unable to test for file lock");
  }

  if((signed int)lock.l_type == 2)
    return 0;

  else
    return lock.l_pid;
}

// timestamp_logfiles
// file server.c line 596
static void timestamp_logfiles(struct server_conf *conf)
{
  char *now;
  struct listIterator *i;
  struct base_obj *logfile;
  char buf[1024l];
  signed int gotLogs = 0;
  now=create_long_time_string((signed long int)0);
  i=list_iterator_create(conf->objs);
  void *return_value_list_next_1;
  do
  {
    return_value_list_next_1=list_next(i);
    logfile = (struct base_obj *)return_value_list_next_1;
    if(logfile == ((struct base_obj *)NULL))
      break;

    if((signed int)logfile->type == CONMAN_OBJ_LOGFILE)
    {
      snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%sConsole [%s] log at %s%s", (const void *)"\r\n<ConMan> ", logfile->aux.logfile.console->name, now, (const void *)".\r\n");
      strcpy(&buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)3)], "\r\n");
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(buf);
      write_obj_data(logfile, (const void *)buf, (signed int)return_value_strlen_2, 1);
      gotLogs = 1;
    }

  }
  while((_Bool)1);
  list_iterator_destroy(i);
  free((void *)now);
  if(!(gotLogs == 0))
    schedule_timestamp(conf);

  goto __CPROVER_DUMP_L5;

__CPROVER_DUMP_L5:
  ;
}

// toint
// file util-str.h line 187
signed int toint(signed int c)
{
  if(c >= 48 && !(c >= 58))
    return c - 48;

  else
    if(c >= 65 && !(c >= 71))
      return (c - 65) + 10;

    else
      if(c >= 97 && !(c >= 103))
        return (c - 97) + 10;

      else
        return 0;
}

// tpoll
// file tpoll.h line 81
signed int tpoll(struct tpoll *tp, signed int ms)
{
  struct timeval tv_timeout;
  struct timeval tv_now;
  struct tpoll_timer *t;
  signed int timeout;
  signed int ms_diff;
  struct pollfd *fd_array_bak;
  signed int n;
  signed int e;
  if(tp == ((struct tpoll *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(ms >= 1)
    _tpoll_get_timeval(&tv_timeout, ms);

  e=pthread_mutex_lock(&tp->mutex);
  if(!(e == 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = e;
    log_err(*return_value___errno_location_2, "Unable to lock tpoll mutex");
  }

  _tpoll_get_timeval(&tv_now, 0);
  signed int tmp_if_expr_3;
  _Bool tmp_if_expr_7;
  signed int tmp_if_expr_6;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_11;
  signed int tmp_if_expr_13;
  while((_Bool)1)
  {
    if(!(tp->timers_active == ((struct tpoll_timer *)NULL)))
    {
      if(tp->timers_active->tv.tv_sec == tv_now.tv_sec)
        tmp_if_expr_3 = (signed int)((&tp->timers_active->tv)->tv_usec > (&tv_now)->tv_usec);

      else
        tmp_if_expr_3 = (signed int)((&tp->timers_active->tv)->tv_sec > (&tv_now)->tv_sec);
      if(tmp_if_expr_3 == 0)
      {
        t = tp->timers_active;
        tp->timers_active = t->next;
        e=pthread_mutex_unlock(&tp->mutex);
        if(!(e == 0))
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          *return_value___errno_location_4 = e;
          log_err(*return_value___errno_location_4, "Unable to unlock tpoll mutex");
        }

        t->fnc(t->arg);
        free((void *)t);
        e=pthread_mutex_lock(&tp->mutex);
        if(!(e == 0))
        {
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          *return_value___errno_location_5 = e;
          log_err(*return_value___errno_location_5, "Unable to lock tpoll mutex");
        }

      }

    }

    if(ms == 0)
      timeout = 0;

    else
    {
      if(!(ms >= 0))
        tmp_if_expr_7 = !(tp->timers_active != ((struct tpoll_timer *)NULL)) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_7 = (_Bool)0;
      if(tmp_if_expr_7)
      {
        if(tp->num_fds_used >= 1)
          timeout = -1;

        else
          timeout = 0;
      }

      else
      {
        _tpoll_get_timeval(&tv_now, 0);
        if(!(ms >= 0))
          ms_diff=_tpoll_diff_timeval(&tp->timers_active->tv, &tv_now);

        else
          if(tp->timers_active == ((struct tpoll_timer *)NULL))
            ms_diff=_tpoll_diff_timeval(&tv_timeout, &tv_now);

          else
          {
            if(tp->timers_active->tv.tv_sec == tv_timeout.tv_sec)
              tmp_if_expr_6 = (signed int)((&tp->timers_active->tv)->tv_usec > (&tv_timeout)->tv_usec);

            else
              tmp_if_expr_6 = (signed int)((&tp->timers_active->tv)->tv_sec > (&tv_timeout)->tv_sec);
            if(tmp_if_expr_6 == 0)
              ms_diff=_tpoll_diff_timeval(&tp->timers_active->tv, &tv_now);

            else
              ms_diff=_tpoll_diff_timeval(&tv_timeout, &tv_now);
          }
        timeout = ms_diff > 0 ? ms_diff : 0;
      }
    }
    fd_array_bak = tp->fd_array;
    tp->is_blocked = (_Bool)1;
    e=pthread_mutex_unlock(&tp->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_8;
      return_value___errno_location_8=__errno_location();
      *return_value___errno_location_8 = e;
      log_err(*return_value___errno_location_8, "Unable to unlock tpoll mutex");
    }

    n=poll(tp->fd_array, (unsigned long int)(tp->max_fd + 1), timeout);
    e=pthread_mutex_lock(&tp->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_9;
      return_value___errno_location_9=__errno_location();
      *return_value___errno_location_9 = e;
      log_err(*return_value___errno_location_9, "Unable to lock tpoll mutex");
    }

    tp->is_blocked = (_Bool)0;
    if(!(n >= 0))
      break;

    if(!(tp->fd_array == fd_array_bak))
      _tpoll_signal_recv(tp);

    else
    {
      if(!((0x001 & (signed int)(tp->fd_array + (signed long int)tp->fd_pipe[0l])->revents) == 0))
      {
        _tpoll_signal_recv(tp);
        n = n - 1;
      }

      if(n >= 1)
        break;

      if(ms == 0)
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        if(!(ms >= 0))
          tmp_if_expr_10 = !(tp->num_fds_used != 0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_10 = (_Bool)0;
        if(tmp_if_expr_10)
          tmp_if_expr_11 = !(tp->timers_active != ((struct tpoll_timer *)NULL)) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_11 = (_Bool)0;
        tmp_if_expr_12 = tmp_if_expr_11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12)
        break;

      _tpoll_get_timeval(&tv_now, 0);
      if(ms >= 1)
      {
        if(tv_timeout.tv_sec == tv_now.tv_sec)
          tmp_if_expr_13 = (signed int)((&tv_timeout)->tv_usec > (&tv_now)->tv_usec);

        else
          tmp_if_expr_13 = (signed int)((&tv_timeout)->tv_sec > (&tv_now)->tv_sec);
        if(tmp_if_expr_13 == 0)
          break;

      }

    }
  }
  e=pthread_mutex_unlock(&tp->mutex);
  if(!(e == 0))
  {
    signed int *return_value___errno_location_14;
    return_value___errno_location_14=__errno_location();
    *return_value___errno_location_14 = e;
    log_err(*return_value___errno_location_14, "Unable to unlock tpoll mutex");
  }

  return n;
}

// tpoll_clear
// file tpoll.c line 274
signed int tpoll_clear(struct tpoll *tp, signed int fd, signed short int events)
{
  signed short int events_new;
  signed int i;
  signed int e;
  if(tp == ((struct tpoll *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(!(fd >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 22;
    return -1;
  }

  if((signed int)events == 0)
    return 0;

  else
  {
    e=pthread_mutex_lock(&tp->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = e;
      log_err(*return_value___errno_location_3, "Unable to lock tpoll mutex");
    }

    if(tp->max_fd >= fd)
    {
      if((tp->fd_array + (signed long int)fd)->fd >= 0)
      {
        events_new = (signed short int)((signed int)(tp->fd_array + (signed long int)fd)->events & ~((signed int)events));
        if(!((tp->fd_array + (signed long int)fd)->events == events_new))
        {
          (tp->fd_array + (signed long int)fd)->events = events_new;
          if((signed int)events_new == 0)
          {
            (tp->fd_array + (signed long int)fd)->revents = (signed short int)0;
            (tp->fd_array + (signed long int)fd)->fd = -1;
            tp->num_fds_used = tp->num_fds_used - 1;
            if(tp->max_fd == fd)
            {
              i = fd - 1;
              for( ; i >= 0; i = i - 1)
                if((tp->fd_array + (signed long int)i)->fd >= 0)
                  break;

              tp->max_fd = i;
            }

          }

          _tpoll_signal_send(tp);
        }

      }

    }

    e=pthread_mutex_unlock(&tp->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = e;
      log_err(*return_value___errno_location_4, "Unable to unlock tpoll mutex");
    }

    return 0;
  }
}

// tpoll_create
// file tpoll.h line 62
struct tpoll * tpoll_create(signed int n)
{
  struct tpoll *tp = (struct tpoll *)(void *)0;
  signed int i;
  signed int fval;
  signed int e;
  if(!(n >= 1))
    n = 256;

  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct tpoll) /*96ul*/ );
  tp = (struct tpoll *)return_value_malloc_1;
  void *return_value_malloc_2;
  signed int return_value_pipe_3;
  if(!(tp == ((struct tpoll *)NULL)))
  {
    tp->fd_pipe[(signed long int)1] = -1;
    tp->fd_pipe[(signed long int)0] = tp->fd_pipe[(signed long int)1];
    tp->timers_active = (struct tpoll_timer *)(void *)0;
    tp->is_blocked = (_Bool)0;
    tp->is_signaled = (_Bool)0;
    tp->is_mutex_inited = (_Bool)0;
    return_value_malloc_2=malloc((unsigned long int)n * sizeof(struct pollfd) /*8ul*/ );
    tp->fd_array = (struct pollfd *)return_value_malloc_2;
    if(tp->fd_array == ((struct pollfd *)NULL))
      goto err;

    tp->num_fds_alloc = n;
    return_value_pipe_3=pipe(tp->fd_pipe);
    if(!(return_value_pipe_3 >= 0))
      goto err;

    i = 0;
    for( ; !(i >= 2); i = i + 1)
    {
      fval=fcntl(tp->fd_pipe[(signed long int)i], 3, 0);
      if(!(fval >= 0))
        goto err;

      signed int return_value_fcntl_4;
      return_value_fcntl_4=fcntl(tp->fd_pipe[(signed long int)i], 4, fval | 04000);
      if(!(return_value_fcntl_4 >= 0))
        goto err;

      signed int return_value_fcntl_5;
      return_value_fcntl_5=fcntl(tp->fd_pipe[(signed long int)i], 2, 1);
      if(!(return_value_fcntl_5 >= 0))
        goto err;

    }
    e=pthread_mutex_init(&tp->mutex, (const union anonymous_0 *)(void *)0);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      *return_value___errno_location_6 = e;
      goto err;
    }

    tp->is_mutex_inited = (_Bool)1;
    _tpoll_init(tp, (enum anonymous_1)TPOLL_ZERO_ALL);
    return tp;
  }

  else
  {

  err:
    ;
    tpoll_destroy(tp);
    return (struct tpoll *)(void *)0;
  }
}

// tpoll_destroy
// file tpoll.h line 64
void tpoll_destroy(struct tpoll *tp)
{
  signed int i;
  struct tpoll_timer *t;
  signed int e;
  if(!(tp == ((struct tpoll *)NULL)))
  {
    if(!(tp->is_mutex_inited == (_Bool)0))
    {
      e=pthread_mutex_lock(&tp->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = e;
        log_err(*return_value___errno_location_1, "Unable to lock tpoll mutex");
      }

    }

    if(!(tp->fd_array == ((struct pollfd *)NULL)))
    {
      free((void *)tp->fd_array);
      tp->fd_array = (struct pollfd *)(void *)0;
    }

    i = 0;
    for( ; !(i >= 2); i = i + 1)
      if(tp->fd_pipe[(signed long int)i] >= 0)
      {
        close(tp->fd_pipe[(signed long int)i]);
        tp->fd_pipe[(signed long int)i] = -1;
      }

    while(!(tp->timers_active == ((struct tpoll_timer *)NULL)))
    {
      t = tp->timers_active;
      tp->timers_active = t->next;
      free((void *)t);
    }
    if(!(tp->is_mutex_inited == (_Bool)0))
    {
      e=pthread_mutex_unlock(&tp->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        log_err(*return_value___errno_location_2, "Unable to unlock tpoll mutex");
      }

      e=pthread_mutex_destroy(&tp->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = e;
        log_err(*return_value___errno_location_3, "Unable to destroy tpoll mutex");
      }

      tp->is_mutex_inited = (_Bool)0;
    }

    free((void *)tp);
    goto __CPROVER_DUMP_L11;
  }


__CPROVER_DUMP_L11:
  ;
}

// tpoll_is_set
// file tpoll.h line 70
signed int tpoll_is_set(struct tpoll *tp, signed int fd, signed short int events)
{
  signed int rc;
  signed int e;
  if(tp == ((struct tpoll *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(!(fd >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 22;
    return -1;
  }

  e=pthread_mutex_lock(&tp->mutex);
  if(!(e == 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = e;
    log_err(*return_value___errno_location_3, "Unable to lock tpoll mutex");
  }

  if(!(tp->max_fd >= fd))
    rc = 0;

  else
    if(!((tp->fd_array + (signed long int)fd)->fd >= 0))
      rc = 0;

    else
      rc = (signed int)(tp->fd_array + (signed long int)fd)->revents & (signed int)events;
  e=pthread_mutex_unlock(&tp->mutex);
  if(!(e == 0))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    *return_value___errno_location_4 = e;
    log_err(*return_value___errno_location_4, "Unable to unlock tpoll mutex");
  }

  return rc;
}

// tpoll_set
// file tpoll.h line 72
signed int tpoll_set(struct tpoll *tp, signed int fd, signed short int events)
{
  signed int rc;
  signed short int events_new;
  signed int e;
  if(tp == ((struct tpoll *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(!(fd >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 22;
    return -1;
  }

  _Bool tmp_if_expr_5;
  signed int return_value__tpoll_grow_4;
  if((signed int)events == 0)
    return 0;

  else
  {
    e=pthread_mutex_lock(&tp->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = e;
      log_err(*return_value___errno_location_3, "Unable to lock tpoll mutex");
    }

    if(fd >= tp->num_fds_alloc)
    {
      return_value__tpoll_grow_4=_tpoll_grow(tp, fd + 1);
      tmp_if_expr_5 = return_value__tpoll_grow_4 < 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
      rc = -1;

    else
    {
      if(!((tp->fd_array + (signed long int)fd)->fd >= 0))
      {
        (tp->fd_array + (signed long int)fd)->fd = fd;
        tp->num_fds_used = tp->num_fds_used + 1;
        events_new = events;
      }

      else
        events_new = (signed short int)((signed int)(tp->fd_array + (signed long int)fd)->events | (signed int)events);
      if(!((tp->fd_array + (signed long int)fd)->events == events_new))
      {
        (tp->fd_array + (signed long int)fd)->events = events_new;
        if(!(tp->max_fd >= fd))
          tp->max_fd = fd;

        _tpoll_signal_send(tp);
      }

      rc = 0;
    }
    e=pthread_mutex_unlock(&tp->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      *return_value___errno_location_6 = e;
      log_err(*return_value___errno_location_6, "Unable to unlock tpoll mutex");
    }

    return rc;
  }
}

// tpoll_timeout_absolute
// file tpoll.h line 74
signed int tpoll_timeout_absolute(struct tpoll *tp, void (*cb)(void *), void *arg, struct timeval *tvp)
{
  struct tpoll_timer *t;
  struct tpoll_timer **t_ptr;
  signed int rc;
  signed int e;
  if(tp == ((struct tpoll *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(cb == ((void (*)(void *))NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 22;
    return -1;
  }

  if(tvp == ((struct timeval *)NULL))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = 22;
    return -1;
  }

  void *return_value_malloc_4;
  return_value_malloc_4=malloc(sizeof(struct tpoll_timer) /*48ul*/ );
  t = (struct tpoll_timer *)return_value_malloc_4;
  signed int tmp_post_6;
  signed int tmp_if_expr_7;
  if(t == ((struct tpoll_timer *)NULL))
    return -1;

  else
  {
    t->fnc = cb;
    t->arg = arg;
    t->tv = *tvp;
    e=pthread_mutex_lock(&tp->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      *return_value___errno_location_5 = e;
      log_err(*return_value___errno_location_5, "Unable to lock tpoll mutex");
    }

    tmp_post_6 = tp->timers_next_id;
    tp->timers_next_id = tp->timers_next_id + 1;
    t->id = tmp_post_6;
    rc = t->id;
    if(!(tp->timers_next_id >= 1))
      tp->timers_next_id = 1;

    t_ptr = &tp->timers_active;
    for( ; !(*t_ptr == ((struct tpoll_timer *)NULL)); t_ptr = &(*t_ptr)->next)
    {
      if(tvp->tv_sec == (*t_ptr)->tv.tv_sec)
        tmp_if_expr_7 = (signed int)(tvp->tv_usec < (&(*t_ptr)->tv)->tv_usec);

      else
        tmp_if_expr_7 = (signed int)(tvp->tv_sec < (&(*t_ptr)->tv)->tv_sec);
      if(!(tmp_if_expr_7 == 0))
        break;

    }
    if(*t_ptr == tp->timers_active)
      _tpoll_signal_send(tp);

    t->next = *t_ptr;
    *t_ptr = t;
    e=pthread_mutex_unlock(&tp->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_8;
      return_value___errno_location_8=__errno_location();
      *return_value___errno_location_8 = e;
      log_err(*return_value___errno_location_8, "Unable to unlock tpoll mutex");
    }

    return rc;
  }
}

// tpoll_timeout_cancel
// file tpoll.h line 79
signed int tpoll_timeout_cancel(struct tpoll *tp, signed int id)
{
  struct tpoll_timer *t;
  struct tpoll_timer **t_ptr;
  signed int rc;
  signed int e;
  if(tp == ((struct tpoll *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(!(id >= 1))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 22;
    return -1;
  }

  e=pthread_mutex_lock(&tp->mutex);
  if(!(e == 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = e;
    log_err(*return_value___errno_location_3, "Unable to lock tpoll mutex");
  }

  t_ptr = &tp->timers_active;
  for( ; !(*t_ptr == ((struct tpoll_timer *)NULL)); t_ptr = &(*t_ptr)->next)
    if(id == (*t_ptr)->id)
      break;

  if(*t_ptr == ((struct tpoll_timer *)NULL))
    rc = 0;

  else
  {
    if(*t_ptr == tp->timers_active)
      _tpoll_signal_send(tp);

    t = *t_ptr;
    *t_ptr = t->next;
    free((void *)t);
    rc = 1;
  }
  e=pthread_mutex_unlock(&tp->mutex);
  if(!(e == 0))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    *return_value___errno_location_4 = e;
    log_err(*return_value___errno_location_4, "Unable to unlock tpoll mutex");
  }

  return rc;
}

// tpoll_timeout_relative
// file tpoll.h line 77
signed int tpoll_timeout_relative(struct tpoll *tp, void (*cb)(void *), void *arg, signed int ms)
{
  struct timeval tv;
  _tpoll_get_timeval(&tv, ms);
  signed int return_value_tpoll_timeout_absolute_1;
  return_value_tpoll_timeout_absolute_1=tpoll_timeout_absolute(tp, cb, arg, &tv);
  return return_value_tpoll_timeout_absolute_1;
}

// tpoll_zero
// file tpoll.h line 66
signed int tpoll_zero(struct tpoll *tp, enum anonymous_1 how)
{
  signed int e;
  if(tp == ((struct tpoll *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(!((-4 & (signed int)how) == 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 22;
    return -1;
  }

  e=pthread_mutex_lock(&tp->mutex);
  if(!(e == 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = e;
    log_err(*return_value___errno_location_3, "Unable to lock tpoll mutex");
  }

  _tpoll_init(tp, how);
  _tpoll_signal_send(tp);
  e=pthread_mutex_unlock(&tp->mutex);
  if(!(e == 0))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    *return_value___errno_location_4 = e;
    log_err(*return_value___errno_location_4, "Unable to unlock tpoll mutex");
  }

  return 0;
}

// unlink_obj
// file server-obj.c line 703
void unlink_obj(struct base_obj *obj)
{
  struct base_obj *x;
  void *return_value_list_peek_1;
  do
  {
    return_value_list_peek_1=list_peek(obj->writers);
    x = (struct base_obj *)return_value_list_peek_1;
    if(x == ((struct base_obj *)NULL))
      break;

    unlink_objs(x, obj);
  }
  while((_Bool)1);
  void *return_value_list_peek_2;
  do
  {
    return_value_list_peek_2=list_peek(obj->readers);
    x = (struct base_obj *)return_value_list_peek_2;
    if(x == ((struct base_obj *)NULL))
      break;

    unlink_objs(obj, x);
  }
  while((_Bool)1);
  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L4:
  ;
}

// unlink_objs
// file server.h line 417
void unlink_objs(struct base_obj *src, struct base_obj *dst)
{
  signed int n;
  char *now;
  char *tty;
  char buf[1024l];
  signed int return_value_list_delete_all_1;
  return_value_list_delete_all_1=list_delete_all(src->readers, (signed int (*)(void *, void *))find_obj, (void *)dst);
  n=list_delete_all(dst->writers, (signed int (*)(void *, void *))find_obj, (void *)src);
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(n >= 1)
  {
    if((signed int)src->type == CONMAN_OBJ_CLIENT)
    {
      if((signed int)dst->type == CONMAN_OBJ_TELNET)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)dst->type == CONMAN_OBJ_IPMI ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)dst->type == CONMAN_OBJ_PROCESS ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = (signed int)dst->type == CONMAN_OBJ_SERIAL ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)dst->type == CONMAN_OBJ_UNIXSOCK ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
      {
        now=create_short_time_string((signed long int)0);
        tty = src->aux.client.req->tty;
        snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%sConsole [%s] departed by <%s@%s>%s%s at %s%s", (const void *)"\r\n<ConMan> ", dst->name, src->aux.client.req->user, src->aux.client.req->host, tty != ((char *)NULL) ? " on " : "", tty != ((char *)NULL) ? tty : "", now, (const void *)".\r\n");
        free((void *)now);
        strcpy(&buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)3)], "\r\n");
        notify_console_objs(dst, buf);
      }

    }

  }

  _Bool tmp_if_expr_9;
  signed int return_value_list_is_empty_8;
  if((signed int)src->type == CONMAN_OBJ_CLIENT)
  {
    return_value_list_is_empty_8=list_is_empty(src->readers);
    tmp_if_expr_9 = return_value_list_is_empty_8 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_9 = (_Bool)0;
  _Bool tmp_if_expr_11;
  signed int return_value_list_is_empty_10;
  if(tmp_if_expr_9)
  {
    return_value_list_is_empty_10=list_is_empty(src->writers);
    tmp_if_expr_11 = return_value_list_is_empty_10 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_11 = (_Bool)0;
  signed int return_value_list_is_empty_7;
  signed int return_value_list_is_empty_6;
  if(tmp_if_expr_11)
    src->gotEOF = (unsigned int)1;

  else
    if((signed int)dst->type == CONMAN_OBJ_CLIENT)
    {
      return_value_list_is_empty_7=list_is_empty(dst->readers);
      if(!(return_value_list_is_empty_7 == 0))
      {
        return_value_list_is_empty_6=list_is_empty(dst->writers);
        if(!(return_value_list_is_empty_6 == 0))
          dst->gotEOF = (unsigned int)1;

      }

    }

  goto __CPROVER_DUMP_L16;

__CPROVER_DUMP_L16:
  ;
}

// validate_req
// file server-sock.c line 561
static signed int validate_req(struct request *req)
{
  signed int return_value_list_is_empty_1;
  return_value_list_is_empty_1=list_is_empty(req->consoles);
  if(!(return_value_list_is_empty_1 == 0))
  {
    send_rsp(req, 5, "Found no matching consoles");
    return -1;
  }

  else
  {
    signed int return_value_check_too_many_consoles_2;
    return_value_check_too_many_consoles_2=check_too_many_consoles(req);
    if(!(return_value_check_too_many_consoles_2 >= 0))
      return -1;

    else
    {
      signed int return_value_check_busy_consoles_3;
      return_value_check_busy_consoles_3=check_busy_consoles(req);
      if(!(return_value_check_busy_consoles_3 >= 0))
        return -1;

      else
        return 0;
    }
  }
}

// write_log_data
// file server-logfile.c line 346
signed int write_log_data(struct base_obj *log, const void *src, signed int len)
{
  const signed int minbuf = 25;
  unsigned char buf[8191l];
  const unsigned char *p;
  unsigned char *q;
  const unsigned char * const qLast = buf + (signed long int)sizeof(unsigned char [8191l]) /*8191ul*/ ;
  signed int n = 0;
  if(log->aux.logfile.gotProcessing == 0u)
  {
    signed int return_value_write_obj_data_1;
    return_value_write_obj_data_1=write_obj_data(log, src, len, 0);
    return return_value_write_obj_data_1;
  }

  p = (const unsigned char *)src;
  q = buf;
  signed int return_value_write_time_string_2;
  _Bool tmp_if_expr_4;
  signed int return_value_write_time_string_3;
  unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_17;
  unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  signed int return_value_write_time_string_9;
  unsigned char *tmp_post_10;
  unsigned char *tmp_post_11;
  unsigned char *tmp_post_12;
  unsigned char *tmp_post_13;
  unsigned char *tmp_post_14;
  unsigned char *tmp_post_15;
  unsigned char *tmp_post_16;
  for( ; len >= 1; len = len - 1)
  {
    if((signed int)*p == 13)
    {
      if((signed int)log->aux.logfile.lineState == 1)
        log->aux.logfile.lineState = (unsigned int)2;

      else
        if((signed int)log->aux.logfile.lineState == 0)
        {
          if(!(log->aux.logfile.opts.enableTimestamp == 0u))
          {
            return_value_write_time_string_2=write_time_string((signed long int)0, (char *)q, (unsigned long int)(qLast - q));
            q = q + (signed long int)return_value_write_time_string_2;
          }

          log->aux.logfile.lineState = (unsigned int)2;
        }

    }

    else
      if((signed int)*p == 10)
      {
        if((signed int)log->aux.logfile.lineState == 0)
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = (signed int)log->aux.logfile.lineState == 3 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_4)
        {
          if(!(log->aux.logfile.opts.enableTimestamp == 0u))
          {
            return_value_write_time_string_3=write_time_string((signed long int)0, (char *)q, (unsigned long int)(qLast - q));
            q = q + (signed long int)return_value_write_time_string_3;
          }

        }

        tmp_post_5 = q;
        q = q + 1l;
        *tmp_post_5 = (unsigned char)13;
        tmp_post_6 = q;
        q = q + 1l;
        *tmp_post_6 = (unsigned char)10;
        log->aux.logfile.lineState = (unsigned int)3;
      }

      else
      {
        if((signed int)*p == 0)
        {
          if((signed int)log->aux.logfile.lineState == 2)
            tmp_if_expr_17 = (_Bool)1;

          else
            tmp_if_expr_17 = (signed int)log->aux.logfile.lineState == 3 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr_18 = tmp_if_expr_17 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_18 = (_Bool)0;
        if(!tmp_if_expr_18)
        {
          if((signed int)log->aux.logfile.lineState == 2)
          {
            tmp_post_7 = q;
            q = q + 1l;
            *tmp_post_7 = (unsigned char)13;
            tmp_post_8 = q;
            q = q + 1l;
            *tmp_post_8 = (unsigned char)10;
          }

          if(!((signed int)log->aux.logfile.lineState == 1))
          {
            if(!(log->aux.logfile.opts.enableTimestamp == 0u))
            {
              return_value_write_time_string_9=write_time_string((signed long int)0, (char *)q, (unsigned long int)(qLast - q));
              q = q + (signed long int)return_value_write_time_string_9;
            }

          }

          log->aux.logfile.lineState = (unsigned int)1;
          if(!(log->aux.logfile.opts.enableSanitize == 0u))
          {
            signed int c = (signed int)*p & 0x7F;
            if(!(c >= 0x20))
            {
              tmp_post_10 = q;
              q = q + 1l;
              *tmp_post_10 = (unsigned char)(((signed int)*p & 0x80) != 0 ? 126 : 94);
              tmp_post_11 = q;
              q = q + 1l;
              *tmp_post_11 = (unsigned char)(c + 64);
            }

            else
              if(c == 0x7F)
              {
                tmp_post_12 = q;
                q = q + 1l;
                *tmp_post_12 = (unsigned char)(((signed int)*p & 0x80) != 0 ? 126 : 94);
                tmp_post_13 = q;
                q = q + 1l;
                *tmp_post_13 = (unsigned char)63;
              }

              else
              {
                if(!((0x80 & (signed int)*p) == 0))
                {
                  tmp_post_14 = q;
                  q = q + 1l;
                  *tmp_post_14 = (unsigned char)96;
                }

                tmp_post_15 = q;
                q = q + 1l;
                *tmp_post_15 = (unsigned char)c;
              }
          }

          else
          {
            tmp_post_16 = q;
            q = q + 1l;
            *tmp_post_16 = *p;
          }
        }

      }
    if(!(qLast - q >= (signed long int)minbuf))
    {
      signed int return_value_write_obj_data_19;
      return_value_write_obj_data_19=write_obj_data(log, (const void *)buf, (signed int)(q - buf), 0);
      n = n + return_value_write_obj_data_19;
      q = buf;
    }

    p = p + 1l;
  }
  signed int return_value_write_obj_data_20;
  return_value_write_obj_data_20=write_obj_data(log, (const void *)buf, (signed int)(q - buf), 0);
  n = n + return_value_write_obj_data_20;
  return n;
}

// write_n
// file util-file.h line 105
signed long int write_n(signed int fd, void *buf, unsigned long int n)
{
  unsigned long int nleft;
  signed long int nwritten;
  unsigned char *p = (unsigned char *)buf;
  nleft = n;
  while(nleft >= 1ul)
  {
    nwritten=write(fd, (const void *)p, nleft);
    if(!(nwritten >= 0l))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        continue;

      else
        return (signed long int)-1;
    }

    nleft = nleft - (unsigned long int)nwritten;
    p = p + nwritten;
  }
  return (signed long int)n;
}

// write_notify_msg
// file server-obj.c line 489
signed int write_notify_msg(struct base_obj *console, signed int priority, char *fmt, ...)
{
  signed int n;
  char buf[1024l];
  char *p;
  signed int len;
  void **vargs;
  char *now;
  p = buf;
  len = (signed int)sizeof(char [1024l]) /*1024ul*/ ;
  n=snprintf(p, (unsigned long int)len, "%s", (const void *)"\r\n<ConMan> ");
  if(n >= len || !(n >= 0))
    return -1;

  else
  {
    p = p + (signed long int)n;
    len = len - n;
    vargs = (void **)&fmt;
    n=vsnprintf(p, (unsigned long int)len, fmt, vargs);
    vargs = ((void **)NULL);
    if(n >= len || !(n >= 0))
      return -1;

    else
    {
      log_msg(priority, "%s", p);
      p = p + (signed long int)n;
      len = len - n;
      now=create_short_time_string((signed long int)0);
      n=snprintf(p, (unsigned long int)len, " at %s%s", now, (const void *)".\r\n");
      free((void *)now);
      if(n >= len || !(n >= 0))
        return -1;

      else
      {
        notify_console_objs(console, buf);
        return 0;
      }
    }
  }
}

// write_obj_data
// file server.h line 425
signed int write_obj_data(struct base_obj *obj, const void *src, signed int len, signed int isInfo)
{
  signed int avail;
  signed int n;
  signed int m;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_11;
  signed int *return_value___errno_location_13;
  signed int *return_value___errno_location_15;
  signed long int tmp_if_expr_17;
  _Bool tmp_if_expr_18;
  signed int *return_value___errno_location_19;
  if(src == NULL || !(len >= 1))
    return 0;

  else
  {
    if(!(obj->gotEOF == 0u))
    {
      signed int return_value_shutdown_obj_1;
      return_value_shutdown_obj_1=shutdown_obj(obj);
      return return_value_shutdown_obj_1;
    }

    if((signed int)obj->type == CONMAN_OBJ_TELNET)
      tmp_if_expr_2 = (signed int)obj->aux.telnet.state != 3 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      if((signed int)obj->type == CONMAN_OBJ_UNIXSOCK)
        tmp_if_expr_3 = (signed int)obj->aux.unixsock.state != 1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      if((signed int)obj->type == CONMAN_OBJ_PROCESS)
        tmp_if_expr_5 = (signed int)obj->aux.process.state != 1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
      tmp_if_expr_12 = (_Bool)1;

    else
    {
      if((signed int)obj->type == CONMAN_OBJ_TELNET)
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = (signed int)obj->type == CONMAN_OBJ_IPMI ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_7)
        tmp_if_expr_8 = (_Bool)1;

      else
        tmp_if_expr_8 = (signed int)obj->type == CONMAN_OBJ_PROCESS ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_8)
        tmp_if_expr_9 = (_Bool)1;

      else
        tmp_if_expr_9 = (signed int)obj->type == CONMAN_OBJ_SERIAL ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_9)
        tmp_if_expr_10 = (_Bool)1;

      else
        tmp_if_expr_10 = (signed int)obj->type == CONMAN_OBJ_UNIXSOCK ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_10)
        tmp_if_expr_11 = obj->fd < 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_11 = (_Bool)0;
      tmp_if_expr_12 = tmp_if_expr_11 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_12)
      return 0;

    else
    {
      if(len >= 8192)
        len = 8192 - 1;

      do
      {
        signed int *return_value___errno_location_14;
        return_value___errno_location_14=__errno_location();
        *return_value___errno_location_14=pthread_mutex_lock(&obj->bufLock);
        if(!(*return_value___errno_location_14 == 0))
        {
          return_value___errno_location_13=__errno_location();
          log_err(*return_value___errno_location_13, "pthread_mutex_lock() failed");
        }

      }
      while((_Bool)0);
      if(!(isInfo == 0))
      {
        if(!((signed int)obj->type == CONMAN_OBJ_CLIENT))
          goto __CPROVER_DUMP_L30;

        if(obj->aux.client.req->enableQuiet == 0u)
          goto __CPROVER_DUMP_L30;

        do
        {
          signed int *return_value___errno_location_16;
          return_value___errno_location_16=__errno_location();
          *return_value___errno_location_16=pthread_mutex_unlock(&obj->bufLock);
          if(!(*return_value___errno_location_16 == 0))
          {
            return_value___errno_location_15=__errno_location();
            log_err(*return_value___errno_location_15, "pthread_mutex_unlock() failed");
          }

        }
        while((_Bool)0);
        return 0;
      }

      else
      {

      __CPROVER_DUMP_L30:
        ;
        n = len;
        if(obj->bufOutPtr == obj->bufInPtr)
          avail = 8192 - 1;

        else
          if(!(obj->bufInPtr >= obj->bufOutPtr))
            avail = (signed int)((obj->bufOutPtr - obj->bufInPtr) - (signed long int)1);

          else
            avail = (signed int)(((&obj->buf[(signed long int)8192] - obj->bufInPtr) + (obj->bufOutPtr - obj->buf)) - (signed long int)1);
        if((obj->buf + 8192l) - obj->bufInPtr >= (signed long int)len)
          tmp_if_expr_17 = (signed long int)len;

        else
          tmp_if_expr_17 = &obj->buf[(signed long int)8192] - obj->bufInPtr;
        m = (signed int)tmp_if_expr_17;
        if(m >= 1)
        {
          memcpy((void *)obj->bufInPtr, src, (unsigned long int)m);
          n = n - m;
          src = (const void *)((unsigned char *)src + (signed long int)m);
          obj->bufInPtr = obj->bufInPtr + (signed long int)m;
          if(obj->bufInPtr == obj->buf + 8192l)
          {
            obj->bufInPtr = obj->buf;
            obj->gotBufWrap = (unsigned int)1;
          }

        }

        if(n >= 1)
        {
          memcpy((void *)obj->bufInPtr, src, (unsigned long int)n);
          obj->bufInPtr = obj->bufInPtr + (signed long int)n;
        }

        if(!(avail >= len))
        {
          if(!((signed int)obj->type == CONMAN_OBJ_CLIENT))
            tmp_if_expr_18 = (_Bool)1;

          else
            tmp_if_expr_18 = !(obj->aux.client.gotSuspend != 0u) ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_18)
            log_msg(5, "Overwrote %d bytes in buffer for %s", len - avail, obj->name);

          obj->bufOutPtr = obj->bufInPtr + (signed long int)1;
          if(obj->bufOutPtr == obj->buf + 8192l)
            obj->bufOutPtr = obj->buf;

        }

        do
        {
          signed int *return_value___errno_location_20;
          return_value___errno_location_20=__errno_location();
          *return_value___errno_location_20=pthread_mutex_unlock(&obj->bufLock);
          if(!(*return_value___errno_location_20 == 0))
          {
            return_value___errno_location_19=__errno_location();
            log_err(*return_value___errno_location_19, "pthread_mutex_unlock() failed");
          }

        }
        while((_Bool)0);
        if(!(isInfo == 0))
        {
          if((signed int)obj->type == CONMAN_OBJ_LOGFILE)
            obj->aux.logfile.lineState = (unsigned int)0;

        }

        return len;
      }
    }
  }
}

// write_pidfile
// file server-conf.c line 1457
static signed int write_pidfile(const char *pidfile)
{
  unsigned int mask;
  char dirname[4096l];
  struct _IO_FILE *fp;
  signed int return_value_getpid_9;
  signed int return_value_fprintf_10;
  signed int return_value_fclose_8;
  if(pidfile == ((const char *)NULL))
    return 0;

  else
    if(!((signed int)*pidfile == 47))
    {
      log_msg(0, "Unable to create relative-path pidfile \"%s\"", pidfile);
      return -1;
    }

    else
    {
      unlink(pidfile);
      mask=umask((unsigned int)0);
      umask(mask | (unsigned int)022);
      char *return_value_get_dir_name_1;
      return_value_get_dir_name_1=get_dir_name(pidfile, dirname, sizeof(char [4096l]) /*4096ul*/ );
      if(!(return_value_get_dir_name_1 == ((char *)NULL)))
        create_dirs(dirname);

      fp=fopen(pidfile, "w");
      umask(mask);
      if(fp == ((struct _IO_FILE *)NULL))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        char *return_value_strerror_3;
        return_value_strerror_3=strerror(*return_value___errno_location_2);
        log_msg(3, "Unable to open pidfile \"%s\": %s", pidfile, return_value_strerror_3);
      }

      else
      {
        return_value_getpid_9=getpid();
        return_value_fprintf_10=fprintf(fp, "%d\n", (signed int)return_value_getpid_9);
        if(return_value_fprintf_10 == -1)
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          char *return_value_strerror_5;
          return_value_strerror_5=strerror(*return_value___errno_location_4);
          log_msg(3, "Unable to write to pidfile \"%s\": %s", pidfile, return_value_strerror_5);
          fclose(fp);
        }

        else
        {
          return_value_fclose_8=fclose(fp);
          if(return_value_fclose_8 == -1)
          {
            signed int *return_value___errno_location_6;
            return_value___errno_location_6=__errno_location();
            char *return_value_strerror_7;
            return_value_strerror_7=strerror(*return_value___errno_location_6);
            log_msg(3, "Unable to close pidfile \"%s\": %s", pidfile, return_value_strerror_7);
          }

          else
            return 0;
        }
      }
      unlink(pidfile);
      return -1;
    }
}

// write_time_string
// file util-str.h line 132
signed int write_time_string(signed long int t, char *dst, unsigned long int dstlen)
{
  struct tm tm;
  signed int n;
  if(!(dstlen >= 21ul))
    return 0;

  else
  {
    get_localtime(&t, &tm);
    unsigned long int return_value_strftime_1;
    return_value_strftime_1=strftime(dst, dstlen, "%Y-%m-%d %H:%M:%S ", &tm);
    n = (signed int)return_value_strftime_1;
    if(n == 0)
      return 0;

    else
      return n;
  }
}

// write_to_obj
// file server.h line 427
signed int write_to_obj(struct base_obj *obj)
{
  signed int avail;
  signed int n;
  signed int isDead = 0;
  signed int *return_value___errno_location_1;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_lock(&obj->bufLock);
    if(!(*return_value___errno_location_2 == 0))
    {
      return_value___errno_location_1=__errno_location();
      log_err(*return_value___errno_location_1, "pthread_mutex_lock() failed");
    }

  }
  while((_Bool)0);
  _Bool tmp_if_expr_8;
  if((signed int)obj->type == CONMAN_OBJ_CLIENT)
    tmp_if_expr_8 = obj->aux.client.gotSuspend != 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_8 = (_Bool)0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  if(tmp_if_expr_8)
    avail = 0;

  else
  {
    if((signed int)obj->type == CONMAN_OBJ_TELNET)
      tmp_if_expr_3 = (signed int)obj->aux.telnet.state != 3 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      if((signed int)obj->type == CONMAN_OBJ_UNIXSOCK)
        tmp_if_expr_4 = (signed int)obj->aux.unixsock.state != 1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      if((signed int)obj->type == CONMAN_OBJ_PROCESS)
        tmp_if_expr_6 = (signed int)obj->aux.process.state != 1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
    {
      avail = 0;
      obj->bufOutPtr = obj->buf;
      obj->bufInPtr = obj->bufOutPtr;
    }

    else
      if(obj->bufInPtr >= obj->bufOutPtr)
        avail = (signed int)(obj->bufInPtr - obj->bufOutPtr);

      else
        avail = (signed int)(&obj->buf[(signed long int)8192] - obj->bufOutPtr);
  }
  signed long int return_value_write_14;
  signed int *return_value___errno_location_9;
  signed int *return_value___errno_location_12;
  if(avail >= 1)
  {
    do
    {

    again:
      ;
      return_value_write_14=write(obj->fd, (const void *)obj->bufOutPtr, (unsigned long int)avail);
      n = (signed int)return_value_write_14;
      if(n >= 0)
        goto __CPROVER_DUMP_L21;

      return_value___errno_location_9=__errno_location();
    }
    while(*return_value___errno_location_9 == 4);
    signed int *return_value___errno_location_13;
    return_value___errno_location_13=__errno_location();
    if(!(*return_value___errno_location_13 == 11))
    {
      return_value___errno_location_12=__errno_location();
      if(!(*return_value___errno_location_12 == 11))
      {
        signed int *return_value___errno_location_10;
        return_value___errno_location_10=__errno_location();
        char *return_value_strerror_11;
        return_value_strerror_11=strerror(*return_value___errno_location_10);
        log_msg(6, "Unable to write to [%s]: %s", obj->name, return_value_strerror_11);
        obj->gotEOF = (unsigned int)1;
        obj->bufOutPtr = obj->buf;
        obj->bufInPtr = obj->bufOutPtr;
      }

    }

    goto __CPROVER_DUMP_L22;

  __CPROVER_DUMP_L21:
    ;
    if(n >= 1)
    {
      obj->bufOutPtr = obj->bufOutPtr + (signed long int)n;
      if(obj->bufOutPtr == obj->buf + 8192l)
        obj->bufOutPtr = obj->buf;

    }

  }


__CPROVER_DUMP_L22:
  ;
  if(!(obj->gotEOF == 0u))
  {
    if(obj->bufInPtr == obj->bufOutPtr)
      isDead = 1;

  }

  signed int *return_value___errno_location_15;
  do
  {
    signed int *return_value___errno_location_16;
    return_value___errno_location_16=__errno_location();
    *return_value___errno_location_16=pthread_mutex_unlock(&obj->bufLock);
    if(!(*return_value___errno_location_16 == 0))
    {
      return_value___errno_location_15=__errno_location();
      log_err(*return_value___errno_location_15, "pthread_mutex_unlock() failed");
    }

  }
  while((_Bool)0);
  signed int tmp_if_expr_18;
  signed int return_value_shutdown_obj_17;
  if(!(isDead == 0))
  {
    return_value_shutdown_obj_17=shutdown_obj(obj);
    tmp_if_expr_18 = return_value_shutdown_obj_17;
  }

  else
    tmp_if_expr_18 = 0;
  return tmp_if_expr_18;
}

