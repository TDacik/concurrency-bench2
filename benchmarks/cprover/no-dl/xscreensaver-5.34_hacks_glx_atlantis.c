// #anon_enum_XrmoptionNoArg=0_XrmoptionIsArg=1_XrmoptionStickyArg=2_XrmoptionSepArg=3_XrmoptionResArg=4_XrmoptionSkipArg=5_XrmoptionSkipLine=6_XrmoptionSkipNArgs=7
// file /usr/include/X11/Xresource.h line 326
enum anonymous_57 { XrmoptionNoArg=0, XrmoptionIsArg=1, XrmoptionStickyArg=2, XrmoptionSepArg=3, XrmoptionResArg=4, XrmoptionSkipArg=5, XrmoptionSkipLine=6, XrmoptionSkipNArgs=7 };

// #anon_enum_XtGeometryYes=0_XtGeometryNo=1_XtGeometryAlmost=2_XtGeometryDone=3
// file /usr/include/X11/Intrinsic.h line 340
enum anonymous_14 { XtGeometryYes=0, XtGeometryNo=1, XtGeometryAlmost=2, XtGeometryDone=3 };

// #anon_enum_XtGrabNone=0_XtGrabNonexclusive=1_XtGrabExclusive=2
// file /usr/include/X11/Intrinsic.h line 347
enum anonymous_15 { XtGrabNone=0, XtGrabNonexclusive=1, XtGrabExclusive=2 };

// #anon_enum_color_scheme_default=0_color_scheme_uniform=1_color_scheme_smooth=2_color_scheme_bright=3
// file ./../xlockmoreI.h line 154
enum anonymous_1 { color_scheme_default=0, color_scheme_uniform=1, color_scheme_smooth=2, color_scheme_bright=3 };

// #anon_enum_t_String=0_t_Float=1_t_Int=2_t_Bool=3
// file ./../xlockmoreI.h line 127
enum anonymous_60 { t_String=0, t_Float=1, t_Int=2, t_Bool=3 };

// tag-#anon#ST[*{S8}_S8_'name'|S64'value']
// file /usr/include/X11/Intrinsic.h line 316
struct anonymous_7;

// tag-#anon#ST[*{S8}_S8_'opt'|*{S8}_S8_'desc']
// file ./../xlockmoreI.h line 137
struct anonymous_56;

// tag-#anon#ST[*{S8}_S8_'option'|*{S8}_S8_'specifier'|SYM##anon_enum_XrmoptionNoArg=0_XrmoptionIsArg=1_XrmoptionStickyArg=2_XrmoptionSepArg=3_XrmoptionResArg=4_XrmoptionSkipArg=5_XrmoptionSkipLine=6_XrmoptionSkipNArgs=7#'argKind'|U32'_pad0'|*{S8}_S8_'value']
// file /usr/include/X11/Xresource.h line 338
struct anonymous_51;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visual'|U64'visualid'|S32'screen'|S32'depth'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'colormap_size'|S32'bits_per_rgb']
// file /usr/include/X11/Xutil.h line 287
struct anonymous_62;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']
// file /usr/include/X11/Xlib.h line 257
struct anonymous_58;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private1'|S32'fd'|S32'private2'|S32'proto_major_version'|S32'proto_minor_version'|*{S8}_S8_'vendor'|U64'private3'|U64'private4'|U64'private5'|S32'private6'|U32'_pad0'|*{U64(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->U64}_U64(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->U64_'resource_alloc'|S32'byte_order'|S32'bitmap_unit'|S32'bitmap_pad'|S32'bitmap_bit_order'|S32'nformats'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|S32'depth'|S32'bits_per_pixel'|S32'scanline_pad'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|S32'depth'|S32'bits_per_pixel'|S32'scanline_pad'|U32'_pad0']#_'pixmap_format'|S32'private8'|S32'release'|*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private9'|*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private10'|S32'qlen'|U32'_pad2'|U64'last_request_read'|U64'request'|*{S8}_S8_'private11'|*{S8}_S8_'private12'|*{S8}_S8_'private13'|*{S8}_S8_'private14'|U32'max_request_size'|U32'_pad3'|*{SYM#tag-_XrmHashBucketRec#}_SYM#tag-_XrmHashBucketRec#_'db'|*{S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->S32}_S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->S32_'private15'|*{S8}_S8_'display_name'|S32'default_screen'|S32'nscreens'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#_'screens'|U64'motion_buffer'|U64'private16'|S32'min_keycode'|S32'max_keycode'|*{S8}_S8_'private17'|*{S8}_S8_'private18'|S32'private19'|U32'_pad4'|*{S8}_S8_'xdefaults']
// file /usr/include/X11/Xlib.h line 493
struct anonymous_0;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|S32'depth'|S32'bits_per_pixel'|S32'scanline_pad'|U32'_pad0']
// file /usr/include/X11/Xlib.h line 280
struct anonymous_27;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'fid'|U32'direction'|U32'min_char_or_byte2'|U32'max_char_or_byte2'|U32'min_byte1'|U32'max_byte1'|S32'all_chars_exist'|U32'default_char'|S32'n_properties'|*{SYM#tag-#anon#ST[U64'name'|U64'card32']#}_SYM#tag-#anon#ST[U64'name'|U64'card32']#_'properties'|SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#'min_bounds'|SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#'max_bounds'|*{SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#}_SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#_'per_char'|S32'ascent'|S32'descent']
// file /usr/include/X11/Xlib.h line 1035
struct anonymous_13;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']
// file /usr/include/X11/Xlib.h line 227
struct anonymous_59;

// tag-#anon#ST[*{SYM#tag-texture_font_data#}_SYM#tag-texture_font_data#_'texfont'|S32'line_height'|S32'top_p']
// file fps-gl.c line 38
struct anonymous_5;

// tag-#anon#ST[*{V}_V_'var'|*{S8}_S8_'name'|*{S8}_S8_'classname'|*{S8}_S8_'def'|SYM##anon_enum_t_String=0_t_Float=1_t_Int=2_t_Bool=3#'type'|U32'_pad0']
// file ./../xlockmoreI.h line 129
struct anonymous_18;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_47;

// tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']
// file /usr/include/X11/Xlib.h line 1017
struct anonymous_11;

// tag-#anon#ST[S16'x'|S16'y']
// file /usr/include/X11/Xlib.h line 426
struct anonymous_70;

// tag-#anon#ST[S32'WinH'|S32'WinW'|*{*{SYM#tag-__GLXcontextRec#}_SYM#tag-__GLXcontextRec#_}_*{SYM#tag-__GLXcontextRec#}_SYM#tag-__GLXcontextRec#__'glx_context'|S32'num_sharks'|F32'sharkspeed'|F32'whalespeed'|S32'sharksize'|S32'wire'|S32'whaledir'|*{SYM#tag-_fishRec#}_SYM#tag-_fishRec#_'sharks'|SYM#tag-_fishRec#'momWhale'|SYM#tag-_fishRec#'babyWhale'|SYM#tag-_fishRec#'dolph'|*{SYM#tag-_XImage#}_SYM#tag-_XImage#_'texture']
// file atlantis.h line 107
struct anonymous;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_68;

// tag-#anon#ST[S32'depth'|S32'bits_per_pixel'|S32'scanline_pad']
// file /usr/include/X11/Xlib.h line 171
struct anonymous_31;

// tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']
// file /usr/include/X11/Xlib.h line 243
struct anonymous_3;

// tag-#anon#ST[S32'function'|U32'_pad0'|U64'plane_mask'|U64'foreground'|U64'background'|S32'line_width'|S32'line_style'|S32'cap_style'|S32'join_style'|S32'fill_style'|S32'fill_rule'|S32'arc_mode'|U32'_pad1'|U64'tile'|U64'stipple'|S32'ts_x_origin'|S32'ts_y_origin'|U64'font'|S32'subwindow_mode'|S32'graphics_exposures'|S32'clip_x_origin'|S32'clip_y_origin'|U64'clip_mask'|S32'dash_offset'|S8'dashes'|U24'_pad2']
// file /usr/include/X11/Xlib.h line 181
struct anonymous_34;

// tag-#anon#ST[S32'numopts'|U32'_pad0'|*{SYM#tag-#anon#ST[*{S8}_S8_'option'|*{S8}_S8_'specifier'|SYM##anon_enum_XrmoptionNoArg=0_XrmoptionIsArg=1_XrmoptionStickyArg=2_XrmoptionSepArg=3_XrmoptionResArg=4_XrmoptionSkipArg=5_XrmoptionSkipLine=6_XrmoptionSkipNArgs=7#'argKind'|U32'_pad0'|*{S8}_S8_'value']#}_SYM#tag-#anon#ST[*{S8}_S8_'option'|*{S8}_S8_'specifier'|SYM##anon_enum_XrmoptionNoArg=0_XrmoptionIsArg=1_XrmoptionStickyArg=2_XrmoptionSepArg=3_XrmoptionResArg=4_XrmoptionSkipArg=5_XrmoptionSkipLine=6_XrmoptionSkipNArgs=7#'argKind'|U32'_pad0'|*{S8}_S8_'value']#_'opts'|S32'numvarsdesc'|U32'_pad1'|*{SYM#tag-#anon#ST[*{V}_V_'var'|*{S8}_S8_'name'|*{S8}_S8_'classname'|*{S8}_S8_'def'|SYM##anon_enum_t_String=0_t_Float=1_t_Int=2_t_Bool=3#'type'|U32'_pad0']#}_SYM#tag-#anon#ST[*{V}_V_'var'|*{S8}_S8_'name'|*{S8}_S8_'classname'|*{S8}_S8_'def'|SYM##anon_enum_t_String=0_t_Float=1_t_Int=2_t_Bool=3#'type'|U32'_pad0']#_'vars'|*{SYM#tag-#anon#ST[*{S8}_S8_'opt'|*{S8}_S8_'desc']#}_SYM#tag-#anon#ST[*{S8}_S8_'opt'|*{S8}_S8_'desc']#_'desc']
// file ./../xlockmoreI.h line 142
struct anonymous_16;

// tag-#anon#ST[S32'type'|U32'_pad0'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'resourceid'|U64'serial'|U8'error_code'|U8'request_code'|U8'minor_code'|U40'_pad1']
// file /usr/include/X11/Xlib.h line 924
struct anonymous_64;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|S32'extension'|S32'evtype']
// file /usr/include/X11/Xlib.h line 948
struct anonymous_54;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|S32'extension'|S32'evtype'|U32'cookie'|U32'_pad2'|*{V}_V_'data']
// file /usr/include/X11/Xlib.h line 958
struct anonymous_55;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'drawable'|S32'major_code'|S32'minor_code']
// file /usr/include/X11/Xlib.h line 686
struct anonymous_25;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'drawable'|S32'x'|S32'y'|S32'width'|S32'height'|S32'count'|S32'major_code'|S32'minor_code'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 673
struct anonymous_23;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window']
// file /usr/include/X11/Xlib.h line 718
struct anonymous_29;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'from_configure'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 727
struct anonymous_30;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'override_redirect'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 737
struct anonymous_32;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'place'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 816
struct anonymous_41;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'x'|S32'y']
// file /usr/include/X11/Xlib.h line 782
struct anonymous_38;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|U32'_pad2'|U64'above'|S32'override_redirect'|U32'_pad3']
// file /usr/include/X11/Xlib.h line 768
struct anonymous_37;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|U64'parent'|S32'x'|S32'y'|S32'override_redirect'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 756
struct anonymous_35;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'owner'|U64'requestor'|U64'selection'|U64'target'|U64'property'|U64'time']
// file /usr/include/X11/Xlib.h line 857
struct anonymous_45;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window']
// file /usr/include/X11/Xlib.h line 747
struct anonymous_33;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window'|S32'place'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 826
struct anonymous_42;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|S32'override_redirect']
// file /usr/include/X11/Xlib.h line 705
struct anonymous_28;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|U32'_pad2'|U64'above'|S32'detail'|U32'_pad3'|U64'value_mask']
// file /usr/include/X11/Xlib.h line 801
struct anonymous_40;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'requestor'|U64'selection'|U64'target'|U64'property'|U64'time']
// file /usr/include/X11/Xlib.h line 870
struct anonymous_46;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window']
// file /usr/include/X11/Xlib.h line 934
struct anonymous_53;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|ARR32{S8}_S8_'key_vector']
// file /usr/include/X11/Xlib.h line 653
struct anonymous_21;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'mode'|S32'detail']
// file /usr/include/X11/Xlib.h line 634
struct anonymous_20;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'request'|S32'first_keycode'|S32'count'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 912
struct anonymous_52;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'state'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 696
struct anonymous_26;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'width'|S32'height']
// file /usr/include/X11/Xlib.h line 792
struct anonymous_39;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'count'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 662
struct anonymous_22;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'atom'|U64'time'|S32'state'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 836
struct anonymous_43;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'colormap'|S32'new'|S32'state']
// file /usr/include/X11/Xlib.h line 882
struct anonymous_48;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'message_type'|S32'format'|U32'_pad2'|SYM#tag-#anon#UN[ARR20{S8}_S8_'b'|ARR10{S16}_S16_'s'|ARR5{S64}_S64_'l']#'data']
// file /usr/include/X11/Xlib.h line 897
struct anonymous_50;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|S32'mode'|S32'detail'|S32'same_screen'|S32'focus'|U32'state'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 610
struct anonymous_19;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|S8'is_hint'|U24'_pad2'|S32'same_screen'|U32'_pad3']
// file /usr/include/X11/Xlib.h line 593
struct anonymous_17;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|U32'button'|S32'same_screen'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 575
struct anonymous_12;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|U32'keycode'|S32'same_screen'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 557
struct anonymous_8;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'selection'|U64'time']
// file /usr/include/X11/Xlib.h line 847
struct anonymous_44;

// tag-#anon#ST[S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|S32'depth'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visual'|U64'root'|S32'class'|S32'bit_gravity'|S32'win_gravity'|S32'backing_store'|U64'backing_planes'|U64'backing_pixel'|S32'save_under'|U32'_pad0'|U64'colormap'|S32'map_installed'|S32'map_state'|S64'all_event_masks'|S64'your_event_mask'|S64'do_not_propagate_mask'|S32'override_redirect'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#_'screen']
// file /usr/include/X11/Xlib.h line 308
struct anonymous_65;

// tag-#anon#ST[U16'red'|U16'green'|U16'blue'|U16'alpha']
// file /usr/include/X11/extensions/Xrender.h line 83
struct anonymous_66;

// tag-#anon#ST[U32'request_mode'|S16'x'|S16'y'|U16'width'|U16'height'|U16'border_width'|U16'_pad0'|*{SYM#tag-_WidgetRec#}_SYM#tag-_WidgetRec#_'sibling'|S32'stack_mode'|U32'_pad1']
// file /usr/include/X11/Intrinsic.h line 212
struct anonymous_6;

// tag-#anon#ST[U32'size'|U32'_pad0'|*{S8}_S8_'addr']
// file /usr/include/X11/Xresource.h line 160
struct anonymous_9;

// tag-#anon#ST[U64'background_pixmap'|U64'background_pixel'|U64'border_pixmap'|U64'border_pixel'|S32'bit_gravity'|S32'win_gravity'|S32'backing_store'|U32'_pad0'|U64'backing_planes'|U64'backing_pixel'|S32'save_under'|U32'_pad1'|S64'event_mask'|S64'do_not_propagate_mask'|S32'override_redirect'|U32'_pad2'|U64'colormap'|U64'cursor']
// file /usr/include/X11/Xlib.h line 290
struct anonymous_24;

// tag-#anon#ST[U64'name'|U64'card32']
// file /usr/include/X11/Xlib.h line 1030
struct anonymous_10;

// tag-#anon#ST[U64'pixel'|U16'red'|U16'green'|U16'blue'|S8'flags'|S8'pad']
// file /usr/include/X11/Xlib.h line 410
struct anonymous_36;

// tag-#anon#ST[U64'shmseg'|S32'shmid'|U32'_pad0'|*{S8}_S8_'shmaddr'|S32'readOnly'|U32'_pad1']
// file /usr/include/X11/extensions/XShm.h line 50
struct anonymous_2;

// tag-#anon#ST[U8'byte1'|U8'byte2']
// file /usr/include/X11/Xlib.h line 1064
struct anonymous_4;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'|ARR8{U16}_U16_'__u6_addr16'|ARR4{U32}_U32_'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous_63;

// tag-#anon#UN[ARR20{S8}_S8_'b'|ARR10{S16}_S16_'s'|ARR5{S64}_S64_'l']
// file /usr/include/X11/Xlib.h line 905
union anonymous_49;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_69;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_67;

// tag-ModeInfo
// file ./../xlockmoreI.h line 27
struct ModeInfo;

// tag-_CoreClassPart
// file /usr/include/X11/CoreP.h line 125
struct _CoreClassPart;

// tag-_CorePart
// file /usr/include/X11/CoreP.h line 72
struct _CorePart;

// tag-_FcCharSet
// file /usr/include/fontconfig/fontconfig.h line 212
struct _FcCharSet;

// tag-_FcPattern
// file /usr/include/fontconfig/fontconfig.h line 230
struct _FcPattern;

// tag-_GError
// file /usr/include/glib-2.0/glib/gerror.h line 42
struct _GError;

// tag-_GdkPixbuf
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 155
struct _GdkPixbuf;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 156
struct _IO_marker;

// tag-_TranslationData
// file /usr/include/X11/Intrinsic.h line 170
struct _TranslationData;

// tag-_WidgetClassRec
// file /usr/include/X11/Intrinsic.h line 109
struct _WidgetClassRec;

// tag-_WidgetRec
// file /usr/include/X11/Intrinsic.h line 107
struct _WidgetRec;

// tag-_XComposeStatus
// file /usr/include/X11/Xutil.h line 231
struct _XComposeStatus;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XEvent
// file /usr/include/X11/Xlib.h line 973
union _XEvent;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XGlyphInfo
// file /usr/include/X11/extensions/Xrender.h line 90
struct _XGlyphInfo;

// tag-_XImage
// file /usr/include/X11/Xlib.h line 360
struct _XImage;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XRegion
// file /usr/include/X11/Xutil.h line 273
struct _XRegion;

// tag-_XftColor
// file /usr/include/X11/Xft/Xft.h line 75
struct _XftColor;

// tag-_XftDraw
// file /usr/include/X11/Xft/Xft.h line 73
struct _XftDraw;

// tag-_XftFont
// file /usr/include/X11/Xft/Xft.h line 64
struct _XftFont;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-_XtActionsRec
// file /usr/include/X11/Intrinsic.h line 111
struct _XtActionsRec;

// tag-_XtAppStruct
// file /usr/include/X11/Intrinsic.h line 114
struct _XtAppStruct;

// tag-_XtCallbackRec
// file /usr/include/X11/Intrinsic.h line 329
struct _XtCallbackRec;

// tag-_XtEventRec
// file /usr/include/X11/Intrinsic.h line 112
struct _XtEventRec;

// tag-_XtResource
// file /usr/include/X11/Intrinsic.h line 354
struct _XtResource;

// tag-_XtStateRec
// file /usr/include/X11/IntrinsicP.h line 187
struct _XtStateRec;

// tag-_XtTMRec
// file /usr/include/X11/IntrinsicP.h line 189
struct _XtTMRec;

// tag-__GLXcontextRec
// file /usr/include/GL/glx.h line 165
struct __GLXcontextRec;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_async_name_from_addr_param
// file async_netdb.h line 90
struct _async_name_from_addr_param;

// tag-_fishRec
// file atlantis.h line 98
struct _fishRec;

// tag-_io_thread_status
// file thread_util.h line 360
enum _io_thread_status { _io_thread_working=0, _io_thread_done=1, _io_thread_cancelled=2 };

// tag-_parallel_startup_type
// file thread_util.c line 534
struct _parallel_startup_type;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-async_addr_from_name
// file async_netdb.h line 155
struct async_addr_from_name;

// tag-async_name_from_addr
// file async_netdb.h line 96
struct async_name_from_addr;

// tag-fps_state
// file fps.h line 20
struct fps_state;

// tag-funcs
// file /usr/include/X11/Xlib.h line 376
struct funcs;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-io_thread
// file thread_util.h line 365
struct io_thread;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 153
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/netinet/in.h line 252
struct sockaddr_in6;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 166
struct sockaddr_storage;

// tag-texfont_cache
// file texfont.c line 64
struct texfont_cache;

// tag-texture_font_data
// file texfont.h line 16
struct texture_font_data;

// tag-threadpool
// file thread_util.h line 227
struct threadpool;

// tag-threadpool_class
// file thread_util.h line 277
struct threadpool_class;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-xlockmore_function_table
// file ./../xlockmoreI.h line 87
struct xlockmore_function_table;

// tag-xscreensaver_function_table
// file ./../screenhackI.h line 114
struct xscreensaver_function_table;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// AllDisplay
// file atlantis.c line 399
static void AllDisplay(struct anonymous *ap);
// Animate
// file atlantis.c line 382
static void Animate(struct anonymous *ap);
// BadValue_ehandler
// file xlock-gl-utils.c line 36
static signed int BadValue_ehandler(struct _XDisplay *dpy, struct anonymous_64 *error);
// Dolphin001
// file dolphin.c line 461
static void Dolphin001(unsigned int cap);
// Dolphin002
// file dolphin.c line 518
static void Dolphin002(unsigned int cap);
// Dolphin003
// file dolphin.c line 575
static void Dolphin003(unsigned int cap);
// Dolphin004
// file dolphin.c line 644
static void Dolphin004(unsigned int cap);
// Dolphin005
// file dolphin.c line 729
static void Dolphin005(unsigned int cap);
// Dolphin006
// file dolphin.c line 850
static void Dolphin006(unsigned int cap);
// Dolphin007
// file dolphin.c line 907
static void Dolphin007(unsigned int cap);
// Dolphin008
// file dolphin.c line 1028
static void Dolphin008(unsigned int cap);
// Dolphin009
// file dolphin.c line 1149
static void Dolphin009(unsigned int cap);
// Dolphin010
// file dolphin.c line 1270
static void Dolphin010(unsigned int cap);
// Dolphin011
// file dolphin.c line 1355
static void Dolphin011(unsigned int cap);
// Dolphin012
// file dolphin.c line 1440
static void Dolphin012(unsigned int cap);
// Dolphin013
// file dolphin.c line 1545
static void Dolphin013(unsigned int cap);
// Dolphin014
// file dolphin.c line 1630
static void Dolphin014(unsigned int cap);
// Dolphin015
// file dolphin.c line 1757
static void Dolphin015(unsigned int cap);
// Dolphin016
// file dolphin.c line 1900
static void Dolphin016(unsigned int cap);
// DrawDolphin
// file atlantis.h line 129
extern void DrawDolphin(struct _fishRec *fish, signed int wire);
// DrawShark
// file atlantis.h line 128
extern void DrawShark(struct _fishRec *fish, signed int wire);
// DrawWhale
// file atlantis.h line 127
extern void DrawWhale(struct _fishRec *fish, signed int wire);
// Fish001
// file shark.c line 302
static void Fish001(unsigned int cap);
// Fish002
// file shark.c line 523
static void Fish002(unsigned int cap);
// Fish003
// file shark.c line 642
static void Fish003(unsigned int cap);
// Fish004
// file shark.c line 747
static void Fish004(unsigned int cap);
// Fish005
// file shark.c line 892
static void Fish005(unsigned int cap);
// Fish006
// file shark.c line 985
static void Fish006(unsigned int cap);
// Fish007
// file shark.c line 1038
static void Fish007(unsigned int cap);
// Fish008
// file shark.c line 1075
static void Fish008(unsigned int cap);
// Fish009
// file shark.c line 1112
static void Fish009(unsigned int cap);
// FishTransform
// file atlantis.h line 123
extern void FishTransform(struct _fishRec *fish);
// Fish_1
// file shark.c line 1129
static void Fish_1(unsigned int cap);
// Fish_2
// file shark.c line 1143
static void Fish_2(unsigned int cap);
// Fish_3
// file shark.c line 1157
static void Fish_3(unsigned int cap);
// Fish_4
// file shark.c line 1171
static void Fish_4(unsigned int cap);
// Fish_5
// file shark.c line 1185
static void Fish_5(unsigned int cap);
// Fish_6
// file shark.c line 1199
static void Fish_6(unsigned int cap);
// Fish_7
// file shark.c line 1213
static void Fish_7(unsigned int cap);
// Fish_8
// file shark.c line 1227
static void Fish_8(unsigned int cap);
// Init
// file atlantis.c line 221
static void Init(struct ModeInfo *mi);
// InitFishs
// file atlantis.c line 183
static void InitFishs(struct anonymous *ap);
// MapNotify_event_p
// file screenhack.c line 256
static signed int MapNotify_event_p(struct _XDisplay *dpy, union _XEvent *event, char *window);
// SharkMiss
// file atlantis.h line 126
extern void SharkMiss(struct anonymous *ap, signed int i);
// SharkPilot
// file atlantis.h line 125
extern void SharkPilot(struct _fishRec *fish, float sharkspeed);
// VirtualRootWindowOfScreen
// file ./../utils/vroot.h line 87
static unsigned long int VirtualRootWindowOfScreen(struct anonymous_58 *screen);
// Whale001
// file whale.c line 403
static void Whale001(unsigned int cap);
// Whale002
// file whale.c line 488
static void Whale002(unsigned int cap);
// Whale003
// file whale.c line 573
static void Whale003(unsigned int cap);
// Whale004
// file whale.c line 642
static void Whale004(unsigned int cap);
// Whale005
// file whale.c line 727
static void Whale005(unsigned int cap);
// Whale006
// file whale.c line 848
static void Whale006(unsigned int cap);
// Whale007
// file whale.c line 889
static void Whale007(unsigned int cap);
// Whale008
// file whale.c line 1010
static void Whale008(unsigned int cap);
// Whale009
// file whale.c line 1131
static void Whale009(unsigned int cap);
// Whale010
// file whale.c line 1252
static void Whale010(unsigned int cap);
// Whale011
// file whale.c line 1337
static void Whale011(unsigned int cap);
// Whale012
// file whale.c line 1422
static void Whale012(unsigned int cap);
// Whale013
// file whale.c line 1533
static void Whale013(unsigned int cap);
// Whale014
// file whale.c line 1612
static void Whale014(unsigned int cap);
// Whale015
// file whale.c line 1663
static void Whale015(unsigned int cap);
// Whale016
// file whale.c line 1724
static void Whale016(unsigned int cap);
// WhalePilot
// file atlantis.h line 124
extern void WhalePilot(struct _fishRec *fish, float whalespeed, signed int whaledir);
// XAllocColor
// file /usr/include/X11/Xlib.h line 1958
extern signed int XAllocColor(struct _XDisplay *, unsigned long int, struct anonymous_36 *);
// XAllocColorCells
// file /usr/include/X11/Xlib.h line 1964
extern signed int XAllocColorCells(struct _XDisplay *, unsigned long int, signed int, unsigned long int *, unsigned int, unsigned long int *, unsigned int);
// XBell
// file /usr/include/X11/Xlib.h line 2010
extern signed int XBell(struct _XDisplay *, signed int);
// XChangeProperty
// file /usr/include/X11/Xlib.h line 2068
extern signed int XChangeProperty(struct _XDisplay *, unsigned long int, unsigned long int, unsigned long int, signed int, signed int, const unsigned char *, signed int);
// XChar2b_to_utf8
// file utf8wc.c line 306
extern char * XChar2b_to_utf8(const struct anonymous_4 *in, signed int *length_ret);
// XClearWindow
// file /usr/include/X11/Xlib.h line 2155
extern signed int XClearWindow(struct _XDisplay *, unsigned long int);
// XCreateColormap
// file /usr/include/X11/Xlib.h line 1552
extern unsigned long int XCreateColormap(struct _XDisplay *, unsigned long int, struct anonymous_59 *, signed int);
// XCreateGC
// file /usr/include/X11/Xlib.h line 1584
extern struct _XGC * XCreateGC(struct _XDisplay *, unsigned long int, unsigned long int, struct anonymous_34 *);
// XCreateImage
// file /usr/include/X11/Xlib.h line 1441
extern struct _XImage * XCreateImage(struct _XDisplay *, struct anonymous_59 *, unsigned int, signed int, signed int, char *, unsigned int, unsigned int, signed int, signed int);
// XCreatePixmap
// file /usr/include/X11/Xlib.h line 1597
extern unsigned long int XCreatePixmap(struct _XDisplay *, unsigned long int, unsigned int, unsigned int, unsigned int);
// XDrawString
// file /usr/include/X11/Xlib.h line 2404
extern signed int XDrawString(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, const char *, signed int);
// XFillRectangle
// file /usr/include/X11/Xlib.h line 2489
extern signed int XFillRectangle(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, unsigned int, unsigned int);
// XFlush
// file /usr/include/X11/Xlib.h line 2507
extern signed int XFlush(struct _XDisplay *);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XFreeColors
// file /usr/include/X11/Xlib.h line 2525
extern signed int XFreeColors(struct _XDisplay *, unsigned long int, unsigned long int *, signed int, unsigned long int);
// XFreeFont
// file /usr/include/X11/Xlib.h line 2542
extern signed int XFreeFont(struct _XDisplay *, struct anonymous_13 *);
// XFreeGC
// file /usr/include/X11/Xlib.h line 2561
extern signed int XFreeGC(struct _XDisplay *, struct _XGC *);
// XFreePixmap
// file /usr/include/X11/Xlib.h line 2570
extern signed int XFreePixmap(struct _XDisplay *, unsigned long int);
// XGetAtomName
// file /usr/include/X11/Xlib.h line 1500
extern char * XGetAtomName(struct _XDisplay *, unsigned long int);
// XGetImage
// file /usr/include/X11/Xlib.h line 1456
extern struct _XImage * XGetImage(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, unsigned long int, signed int);
// XGetVisualInfo
// file /usr/include/X11/Xutil.h line 471
extern struct anonymous_62 * XGetVisualInfo(struct _XDisplay *, signed long int, struct anonymous_62 *, signed int *);
// XGetWindowAttributes
// file /usr/include/X11/Xlib.h line 2691
extern signed int XGetWindowAttributes(struct _XDisplay *, unsigned long int, struct anonymous_65 *);
// XGetWindowProperty
// file /usr/include/X11/Xlib.h line 2676
extern signed int XGetWindowProperty(struct _XDisplay *, unsigned long int, unsigned long int, signed long int, signed long int, signed int, unsigned long int, unsigned long int *, signed int *, unsigned long int *, unsigned long int *, unsigned char **);
// XIfEvent
// file /usr/include/X11/Xlib.h line 2753
extern signed int XIfEvent(struct _XDisplay *, union _XEvent *, signed int (*)(struct _XDisplay *, union _XEvent *, char *), char *);
// XInternAtom
// file /usr/include/X11/Xlib.h line 1536
extern unsigned long int XInternAtom(struct _XDisplay *, const char *, signed int);
// XListDepths
// file /usr/include/X11/Xlib.h line 1866
extern signed int * XListDepths(struct _XDisplay *, signed int, signed int *);
// XListPixmapFormats
// file /usr/include/X11/Xlib.h line 1862
extern struct anonymous_31 * XListPixmapFormats(struct _XDisplay *, signed int *);
// XLoadQueryFont
// file /usr/include/X11/Xlib.h line 1394
extern struct anonymous_13 * XLoadQueryFont(struct _XDisplay *, const char *);
// XLookupString
// file /usr/include/X11/Xutil.h line 534
extern signed int XLookupString(struct anonymous_8 *, char *, signed int, unsigned long int *, struct _XComposeStatus *);
// XNextEvent
// file /usr/include/X11/Xlib.h line 2841
extern signed int XNextEvent(struct _XDisplay *, union _XEvent *);
// XParseColor
// file /usr/include/X11/Xlib.h line 2850
extern signed int XParseColor(struct _XDisplay *, unsigned long int, const char *, struct anonymous_36 *);
// XPending
// file /usr/include/X11/Xlib.h line 2881
extern signed int XPending(struct _XDisplay *);
// XQueryTree
// file /usr/include/X11/Xlib.h line 3017
extern signed int XQueryTree(struct _XDisplay *, unsigned long int, unsigned long int *, unsigned long int *, unsigned long int **, unsigned int *);
// XSelectInput
// file /usr/include/X11/Xlib.h line 3129
extern signed int XSelectInput(struct _XDisplay *, unsigned long int, signed long int);
// XSetErrorHandler
// file /usr/include/X11/Xlib.h line 1848
extern signed int (*XSetErrorHandler(signed int (*)(struct _XDisplay *, struct anonymous_64 *)))(struct _XDisplay *, struct anonymous_64 *);
// XSetFont
// file /usr/include/X11/Xlib.h line 3215
extern signed int XSetFont(struct _XDisplay *, struct _XGC *, unsigned long int);
// XSetWindowBackground
// file /usr/include/X11/Xlib.h line 3333
extern signed int XSetWindowBackground(struct _XDisplay *, unsigned long int, unsigned long int);
// XSetWindowColormap
// file /usr/include/X11/Xlib.h line 3363
extern signed int XSetWindowColormap(struct _XDisplay *, unsigned long int, unsigned long int);
// XStoreColors
// file /usr/include/X11/Xlib.h line 3388
extern signed int XStoreColors(struct _XDisplay *, unsigned long int, struct anonymous_36 *, signed int);
// XSync
// file /usr/include/X11/Xlib.h line 3409
extern signed int XSync(struct _XDisplay *, signed int);
// XVisualIDFromVisual
// file /usr/include/X11/Xlib.h line 1728
extern unsigned long int XVisualIDFromVisual(struct anonymous_59 *);
// XftColorAllocValue
// file /usr/include/X11/Xft/Xft.h line 118
signed int XftColorAllocValue(struct _XDisplay *, struct anonymous_59 *, unsigned long int, const struct anonymous_66 *, struct _XftColor *);
// XftColorFree
// file /usr/include/X11/Xft/Xft.h line 125
void XftColorFree(struct _XDisplay *, struct anonymous_59 *, unsigned long int, struct _XftColor *);
// XftDrawCreate
// file /usr/include/X11/Xft/Xft.h line 143
struct _XftDraw * XftDrawCreate(struct _XDisplay *, unsigned long int, struct anonymous_59 *, unsigned long int);
// XftDrawDestroy
// file /usr/include/X11/Xft/Xft.h line 174
void XftDrawDestroy(struct _XftDraw *);
// XftDrawStringUtf8
// file /usr/include/X11/Xft/Xft.h line 219
void XftDrawStringUtf8(struct _XftDraw *, const struct _XftColor *, struct _XftFont *, signed int, signed int, const unsigned char *, signed int);
// XftFontClose
// file /usr/include/X11/Xft/Xft.h line 381
void XftFontClose(struct _XDisplay *, struct _XftFont *);
// XftFontOpenXlfd
// file /usr/include/X11/Xft/Xft.h line 347
struct _XftFont * XftFontOpenXlfd(struct _XDisplay *, signed int, const char *);
// XftTextExtentsUtf8
// file /usr/include/X11/Xft/Xft.h line 319
void XftTextExtentsUtf8(struct _XDisplay *, struct _XftFont *, const unsigned char *, signed int, struct _XGlyphInfo *);
// XmuPrintDefaultErrorMessage
// file ./../utils/xmu.h line 12
signed int XmuPrintDefaultErrorMessage(struct _XDisplay *, struct anonymous_64 *, struct _IO_FILE *);
// XrmGetResource
// file /usr/include/X11/Xresource.h line 223
extern signed int XrmGetResource(struct _XrmHashBucketRec *, const char *, const char *, char **, struct anonymous_9 *);
// XtAppInitialize
// file /usr/include/X11/Intrinsic.h line 1468
extern struct _WidgetRec * XtAppInitialize(struct _XtAppStruct **, const char *, struct anonymous_51 *, unsigned int, signed int *, char **, char **, struct anonymous_7 *, unsigned int);
// XtAppPending
// file /usr/include/X11/Intrinsic.h line 1045
extern unsigned long int XtAppPending(struct _XtAppStruct *);
// XtAppProcessEvent
// file /usr/include/X11/Intrinsic.h line 931
extern void XtAppProcessEvent(struct _XtAppStruct *, unsigned long int);
// XtDatabase
// file resources.c line 27
extern struct _XrmHashBucketRec * XtDatabase(struct _XDisplay *);
// XtDestroyApplicationContext
// file /usr/include/X11/Intrinsic.h line 1520
extern void XtDestroyApplicationContext(struct _XtAppStruct *);
// XtDestroyWidget
// file /usr/include/X11/Intrinsic.h line 1112
extern void XtDestroyWidget(struct _WidgetRec *);
// XtDisplayToApplicationContext
// file /usr/include/X11/Intrinsic.h line 1532
extern struct _XtAppStruct * XtDisplayToApplicationContext(struct _XDisplay *);
// XtGetApplicationNameAndClass
// file /usr/include/X11/Intrinsic.h line 2176
extern void XtGetApplicationNameAndClass(struct _XDisplay *, char **, char **);
// XtPopup
// file /usr/include/X11/Intrinsic.h line 1318
extern void XtPopup(struct _WidgetRec *, enum anonymous_15);
// XtRealizeWidget
// file /usr/include/X11/Intrinsic.h line 1104
extern void XtRealizeWidget(struct _WidgetRec *);
// XtVaAppCreateShell
// file /usr/include/X11/Intrinsic.h line 1408
extern struct _WidgetRec * XtVaAppCreateShell(const char *, const char *, struct _WidgetClassRec *, struct _XDisplay *, ...);
// XtVaSetValues
// file /usr/include/X11/Intrinsic.h line 1592
extern void XtVaSetValues(struct _WidgetRec *, ...);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __atomic_exchange_n
// file thread_util.c line 993 function io_thread_return
signed int __atomic_exchange_n(void);
// __atomic_load_n
// file thread_util.c line 1006 function io_thread_is_done
signed int __atomic_load_n(void);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __h_errno_location
// file /usr/include/netdb.h line 61
extern signed int * __h_errno_location(void);
// __isoc99_sscanf
// file /usr/include/stdio.h line 448
extern signed int __isoc99_sscanf(const char *, const char *, ...);
// _add_next_thread
// file thread_util.c line 551
static void _add_next_thread(struct _parallel_startup_type *self);
// _async_addr_from_name_free
// file async_netdb.c line 283
static void _async_addr_from_name_free(struct async_addr_from_name *self);
// _async_addr_from_name_hostname
// file async_netdb.c line 277
static char * _async_addr_from_name_hostname(struct async_addr_from_name *self);
// _async_addr_from_name_thread
// file async_netdb.c line 295
static void * _async_addr_from_name_thread(void *self_raw);
// _async_name_from_addr_set_param
// file async_netdb.c line 128
static void _async_name_from_addr_set_param(struct _async_name_from_addr_param *self, struct sockaddr *addr, unsigned int addrlen);
// _async_name_from_addr_thread
// file async_netdb.c line 102
static void * _async_name_from_addr_thread(void *self_raw);
// _async_netdb_is_done
// file async_netdb.c line 39
signed int _async_netdb_is_done(struct io_thread *io);
// _get_cache_line_size
// file thread_util.c line 184
static unsigned int _get_cache_line_size(void);
// _hardware_concurrency
// file thread_util.c line 462
static unsigned int _hardware_concurrency(void);
// _parallel_abort
// file thread_util.c line 527
static void _parallel_abort(struct threadpool *self);
// _serial_destroy
// file thread_util.c line 511
static void _serial_destroy(struct threadpool *self);
// _start_routine
// file thread_util.c line 585
static void * _start_routine(void *startup_raw);
// _thread_destroy_and_unlock
// file thread_util.c line 577
static void * _thread_destroy_and_unlock(struct threadpool *self, void *thread);
// _thread_free_and_unlock
// file thread_util.c line 568
static void * _thread_free_and_unlock(struct threadpool *self, void *thread);
// _threadpool_count_parallel
// file thread_util.c line 541
static unsigned int _threadpool_count_parallel(struct threadpool *self);
// _threadpool_count_serial
// file thread_util.c line 501
static unsigned int _threadpool_count_serial(struct threadpool *self);
// _translate_h_errno
// file async_netdb.c line 82
static signed int _translate_h_errno(signed int error);
// _unlock_and_destroy
// file thread_util.c line 685
static void _unlock_and_destroy(struct threadpool *self);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// aligned_free
// file aligned_malloc.h line 35
void aligned_free(void *ptr);
// aligned_malloc
// file aligned_malloc.h line 34
signed int aligned_malloc(void **ptr, unsigned int alignment, unsigned long int size);
// allocate_writable_colors
// file colors.c line 42
extern void allocate_writable_colors(struct anonymous_58 *screen, unsigned long int cmap, unsigned long int *pixels, signed int *ncolorsP);
// async_addr_from_name_cancel
// file async_netdb.c line 344
void async_addr_from_name_cancel(struct async_addr_from_name *self);
// async_addr_from_name_finish
// file async_netdb.c line 361
signed int async_addr_from_name_finish(struct async_addr_from_name *self, void *addr, unsigned int *addrlen, signed int *errno_error);
// async_addr_from_name_start
// file async_netdb.c line 315
struct async_addr_from_name * async_addr_from_name_start(struct _XDisplay *dpy, const char *hostname);
// async_name_from_addr_cancel
// file async_netdb.c line 182
void async_name_from_addr_cancel(struct async_name_from_addr *self);
// async_name_from_addr_finish
// file async_netdb.c line 197
signed int async_name_from_addr_finish(struct async_name_from_addr *self_raw, char **host, signed int *errno_error);
// async_name_from_addr_start
// file async_netdb.c line 141
struct async_name_from_addr * async_name_from_addr_start(struct _XDisplay *dpy, struct sockaddr *addr, unsigned int addrlen);
// atan
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 58
extern double atan(double);
// atan2
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 60
extern double atan2(double, double);
// bigendian
// file xpm-ximage.c line 35
static signed int bigendian(void);
// bitmap_to_texture
// file texfont.c line 108
static void bitmap_to_texture(struct _XDisplay *dpy, unsigned long int p, struct anonymous_59 *visual, signed int depth, signed int *wP, signed int *hP);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_gl_error
// file ./../xlockmoreI.h line 64
extern void check_gl_error(const char *type);
// clear_gl_error
// file ./../xlockmoreI.h line 63
extern void clear_gl_error(void);
// clear_tank
// file atlantis.c line 340
static void clear_tank(struct anonymous *ap);
// close
// file /usr/include/unistd.h line 356
extern signed int close(signed int);
// complain
// file colors.c line 79
static void complain(signed int wanted_colors, signed int got_colors, signed int wanted_writable, signed int got_writable);
// cos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
extern double cos(double);
// describe_gl_visual
// file visual-gl.c line 116
extern void describe_gl_visual(struct _IO_FILE *f, struct anonymous_58 *screen, struct anonymous_59 *visual, signed int private_cmap_p);
// describe_visual
// file visual.c line 445
extern void describe_visual(struct _IO_FILE *f, struct anonymous_58 *screen, struct anonymous_59 *visual, signed int private_cmap_p);
// draw_atlantis
// file atlantis.c line 504
static void draw_atlantis(struct ModeInfo *mi);
// enable_texture_string_parameters
// file texfont.c line 576
void enable_texture_string_parameters(void);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fabs
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 181
extern double fabs(double);
// find_similar_visual
// file visual.c line 503
extern struct anonymous_59 * find_similar_visual(struct anonymous_58 *screen, struct anonymous_59 *old_visual);
// fix_fds
// file screenhack.c line 403
static void fix_fds(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fps_compute
// file fps.h line 25
extern double fps_compute(struct fps_state *st, unsigned long int polys, double depth);
// fps_draw
// file fps.h line 26
extern void fps_draw(struct fps_state *st);
// fps_free
// file fps.h line 23
extern void fps_free(struct fps_state *st);
// fps_init
// file fps.h line 22
extern struct fps_state * fps_init(struct _XDisplay *dpy, unsigned long int window);
// fps_slept
// file fps.h line 24
extern void fps_slept(struct fps_state *st, unsigned long int usecs);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_colors
// file colors.c line 25
extern void free_colors(struct anonymous_58 *screen, unsigned long int cmap, struct anonymous_36 *colors, signed int ncolors);
// free_texture_font
// file texfont.c line 925
extern void free_texture_font(struct texture_font_data *data);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// g_error_free
// file /usr/include/glib-2.0/glib/gerror.h line 68
extern void g_error_free(struct _GError *);
// g_object_unref
// file /usr/include/glib-2.0/gobject/gobject.h line 480
extern void g_object_unref(void *);
// gdk_pixbuf_get_height
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 237
signed int gdk_pixbuf_get_height(const struct _GdkPixbuf *);
// gdk_pixbuf_get_n_channels
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 232
signed int gdk_pixbuf_get_n_channels(const struct _GdkPixbuf *);
// gdk_pixbuf_get_pixels
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 235
unsigned char * gdk_pixbuf_get_pixels(const struct _GdkPixbuf *);
// gdk_pixbuf_get_rowstride
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 238
signed int gdk_pixbuf_get_rowstride(const struct _GdkPixbuf *);
// gdk_pixbuf_get_width
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 236
signed int gdk_pixbuf_get_width(const struct _GdkPixbuf *);
// gdk_pixbuf_new_from_file
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 275
struct _GdkPixbuf * gdk_pixbuf_new_from_file(const char *, struct _GError **);
// gdk_pixbuf_new_from_xpm_data
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 310
struct _GdkPixbuf * gdk_pixbuf_new_from_xpm_data(const char **);
// gdk_pixbuf_xlib_init
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf-xlib/gdk-pixbuf-xlib.h line 33
void gdk_pixbuf_xlib_init(struct _XDisplay *, signed int);
// get_bits_per_pixel
// file visual.c line 545
extern signed int get_bits_per_pixel(struct _XDisplay *dpy, signed int depth);
// get_boolean_resource
// file ./../utils/resources.h line 16
extern signed int get_boolean_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_cache
// file texfont.c line 458
static struct texfont_cache * get_cache(struct texture_font_data *data, const char *string);
// get_float_resource
// file ./../../utils/resources.h line 18
extern double get_float_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_gl_visual
// file ./../../utils/visual.h line 29
extern struct anonymous_59 * get_gl_visual(struct anonymous_58 *screen);
// get_integer_resource
// file ./../utils/resources.h line 17
extern signed int get_integer_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_minutes_resource
// file resources.c line 261
extern unsigned int get_minutes_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_pixel_resource
// file ./../utils/resources.h line 19
extern unsigned int get_pixel_resource(struct _XDisplay *dpy, unsigned long int cmap, char *res_name, char *res_class);
// get_seconds_resource
// file resources.c line 255
extern unsigned int get_seconds_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_string_resource
// file ./../utils/resources.h line 15
extern char * get_string_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_time_resource
// file resources.c line 244
static unsigned int get_time_resource(struct _XDisplay *dpy, char *res_name, char *res_class, signed int sec_p);
// get_visual
// file visual.c line 50
extern struct anonymous_59 * get_visual(struct anonymous_58 *screen, const char *string, signed int prefer_writable_cells, signed int verbose_p);
// get_visual_resource
// file ./../utils/visual.h line 16
extern struct anonymous_59 * get_visual_resource(struct anonymous_58 *screen, char *name, char *class, signed int prefer_writable_cells);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyaddr
// file /usr/include/netdb.h line 137
extern struct hostent * gethostbyaddr(const void *, unsigned int, signed int);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getpid
// file /usr/include/unistd.h line 631
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// glAlphaFunc
// file /usr/include/GL/gl.h line 758
void glAlphaFunc(unsigned int, float);
// glBegin
// file /usr/include/GL/gl.h line 929
void glBegin(unsigned int);
// glBindTexture
// file /usr/include/GL/gl.h line 1311
void glBindTexture(unsigned int, unsigned int);
// glBlendFunc
// file /usr/include/GL/gl.h line 760
void glBlendFunc(unsigned int, unsigned int);
// glClear
// file /usr/include/GL/gl.h line 752
void glClear(unsigned int);
// glClearColor
// file /usr/include/GL/gl.h line 750
void glClearColor(float, float, float, float);
// glClearIndex
// file /usr/include/GL/gl.h line 748
void glClearIndex(float);
// glColor3f
// file /usr/include/GL/gl.h line 992
void glColor3f(float, float, float);
// glColor3fv
// file /usr/include/GL/gl.h line 1019
void glColor3fv(const float *);
// glColor4fv
// file /usr/include/GL/gl.h line 1028
void glColor4fv(const float *);
// glDeleteTextures
// file /usr/include/GL/gl.h line 1309
void glDeleteTextures(signed int, const unsigned int *);
// glDepthFunc
// file /usr/include/GL/gl.h line 846
void glDepthFunc(unsigned int);
// glDisable
// file /usr/include/GL/gl.h line 798
void glDisable(unsigned int);
// glDrawBuffer
// file /usr/include/GL/gl.h line 792
void glDrawBuffer(unsigned int);
// glEnable
// file /usr/include/GL/gl.h line 796
void glEnable(unsigned int);
// glEnd
// file /usr/include/GL/gl.h line 931
void glEnd(void);
// glFrontFace
// file /usr/include/GL/gl.h line 766
void glFrontFace(unsigned int);
// glGenTextures
// file /usr/include/GL/gl.h line 1307
void glGenTextures(signed int, unsigned int *);
// glGetBooleanv
// file /usr/include/GL/gl.h line 808
void glGetBooleanv(unsigned int, unsigned char *);
// glGetError
// file /usr/include/GL/gl.h line 829
unsigned int glGetError(void);
// glGetFloatv
// file /usr/include/GL/gl.h line 812
void glGetFloatv(unsigned int, float *);
// glGetIntegerv
// file /usr/include/GL/gl.h line 814
void glGetIntegerv(unsigned int, signed int *);
// glIndexi
// file /usr/include/GL/gl.h line 980
void glIndexi(signed int);
// glIsEnabled
// file /usr/include/GL/gl.h line 800
unsigned char glIsEnabled(unsigned int);
// glLightModelfv
// file /usr/include/GL/gl.h line 1173
void glLightModelfv(unsigned int, const float *);
// glLightfv
// file /usr/include/GL/gl.h line 1161
void glLightfv(unsigned int, unsigned int, const float *);
// glLoadIdentity
// file /usr/include/GL/gl.h line 883
void glLoadIdentity(void);
// glMaterialfv
// file /usr/include/GL/gl.h line 1178
void glMaterialfv(unsigned int, unsigned int, const float *);
// glMatrixMode
// file /usr/include/GL/gl.h line 866
void glMatrixMode(unsigned int);
// glMultMatrixf
// file /usr/include/GL/gl.h line 889
void glMultMatrixf(const float *);
// glNormal3f
// file /usr/include/GL/gl.h line 967
void glNormal3f(float, float, float);
// glNormal3fv
// file /usr/include/GL/gl.h line 973
void glNormal3fv(const float *);
// glOrtho
// file /usr/include/GL/gl.h line 868
void glOrtho(double, double, double, double, double, double);
// glPolygonMode
// file /usr/include/GL/gl.h line 774
void glPolygonMode(unsigned int, unsigned int);
// glPopMatrix
// file /usr/include/GL/gl.h line 881
void glPopMatrix(void);
// glPushMatrix
// file /usr/include/GL/gl.h line 879
void glPushMatrix(void);
// glRotatef
// file /usr/include/GL/gl.h line 893
void glRotatef(float, float, float, float);
// glScalef
// file /usr/include/GL/gl.h line 897
void glScalef(float, float, float);
// glShadeModel
// file /usr/include/GL/gl.h line 1157
void glShadeModel(unsigned int);
// glTexCoord2f
// file /usr/include/GL/gl.h line 1042
void glTexCoord2f(float, float);
// glTexEnvf
// file /usr/include/GL/gl.h line 1259
void glTexEnvf(unsigned int, unsigned int, float);
// glTexGenfv
// file /usr/include/GL/gl.h line 1251
void glTexGenfv(unsigned int, unsigned int, const float *);
// glTexGeni
// file /usr/include/GL/gl.h line 1248
void glTexGeni(unsigned int, unsigned int, signed int);
// glTexImage2D
// file /usr/include/GL/gl.h line 1294
void glTexImage2D(unsigned int, signed int, signed int, signed int, signed int, signed int, unsigned int, unsigned int, const void *);
// glTexParameterf
// file /usr/include/GL/gl.h line 1269
void glTexParameterf(unsigned int, unsigned int, float);
// glTexParameteri
// file /usr/include/GL/gl.h line 1270
void glTexParameteri(unsigned int, unsigned int, signed int);
// glTranslatef
// file /usr/include/GL/gl.h line 900
void glTranslatef(float, float, float);
// glVertex3f
// file /usr/include/GL/gl.h line 940
void glVertex3f(float, float, float);
// glVertex3fv
// file /usr/include/GL/gl.h line 955
void glVertex3fv(const float *);
// glViewport
// file /usr/include/GL/gl.h line 876
void glViewport(signed int, signed int, signed int, signed int);
// glXChooseVisual
// file /usr/include/GL/glx.h line 187
extern struct anonymous_62 * glXChooseVisual(struct _XDisplay *, signed int, signed int *);
// glXCreateContext
// file /usr/include/GL/glx.h line 190
extern struct __GLXcontextRec * glXCreateContext(struct _XDisplay *, struct anonymous_62 *, struct __GLXcontextRec *, signed int);
// glXGetConfig
// file /usr/include/GL/glx.h line 214
extern signed int glXGetConfig(struct _XDisplay *, struct anonymous_62 *, signed int, signed int *);
// glXMakeCurrent
// file /usr/include/GL/glx.h line 195
extern signed int glXMakeCurrent(struct _XDisplay *, unsigned long int, struct __GLXcontextRec *);
// glXSwapBuffers
// file /usr/include/GL/glx.h line 201
extern void glXSwapBuffers(struct _XDisplay *, unsigned long int);
// gluBuild2DMipmaps
// file /usr/include/GL/glu.h line 296
signed int gluBuild2DMipmaps(unsigned int, signed int, signed int, signed int, unsigned int, unsigned int, const void *);
// gluPerspective
// file /usr/include/GL/glu.h line 327
void gluPerspective(double, double, double, double);
// hardware_concurrency
// file thread_util.c line 478
unsigned int hardware_concurrency(struct _XDisplay *dpy);
// has_writable_cells
// file ./../utils/visual.h line 25
extern signed int has_writable_cells(struct anonymous_58 *screen, struct anonymous_59 *visual);
// hsv_to_rgb
// file hsv.c line 20
extern void hsv_to_rgb(signed int h, double s, double v, unsigned short int *r, unsigned short int *g, unsigned short int *b);
// id_to_visual
// file visual.c line 340
extern struct anonymous_59 * id_to_visual(struct anonymous_58 *screen, signed int id);
// init_GL
// file ./../xlockmoreI.h line 61
extern struct __GLXcontextRec ** init_GL(struct ModeInfo *mi);
// init_atlantis
// file atlantis.c line 444
static void init_atlantis(struct ModeInfo *mi);
// init_window
// file screenhack.c line 675
static void init_window(struct _XDisplay *dpy, struct _WidgetRec *toplevel, const char *title);
// io_thread_cancel
// file thread_util.h line 406
signed int io_thread_cancel(struct io_thread *self);
// io_thread_create
// file thread_util.h line 380
void * io_thread_create(struct io_thread *self, void *parent, void * (*start_routine)(void *), struct _XDisplay *dpy, unsigned int stacksize);
// io_thread_create::start_routine_object
//
void * start_routine_object(void *);
// io_thread_finish
// file thread_util.h line 411
void io_thread_finish(struct io_thread *self);
// io_thread_is_done
// file thread_util.h line 403
signed int io_thread_is_done(struct io_thread *self);
// io_thread_return
// file thread_util.h line 399
signed int io_thread_return(struct io_thread *self);
// iterate_texture_string
// file texfont.c line 340
static void iterate_texture_string(struct texture_font_data *data, const char *s, signed int draw_x, signed int draw_y, struct _XftDraw *xftdraw, struct _XftColor *xftcolor, struct anonymous_11 *metrics_ret);
// load_texture_font
// file texfont.c line 257
extern struct texture_font_data * load_texture_font(struct _XDisplay *dpy, char *res);
// make_color_loop
// file colors.c line 451
extern void make_color_loop(struct anonymous_58 *screen, struct anonymous_59 *visual, unsigned long int cmap, signed int h0, double s0, double v0, signed int h1, double s1, double v1, signed int h2, double s2, double v2, struct anonymous_36 *colors, signed int *ncolorsP, signed int allocate_p, signed int *writable_pP);
// make_color_path
// file colors.c line 224
static void make_color_path(struct anonymous_58 *screen, struct anonymous_59 *visual, unsigned long int cmap, signed int npoints, signed int *h, double *s, double *v, struct anonymous_36 *colors, signed int *ncolorsP, signed int allocate_p, signed int *writable_pP);
// make_color_ramp
// file colors.c line 99
extern void make_color_ramp(struct anonymous_58 *screen, struct anonymous_59 *visual, unsigned long int cmap, signed int h1, double s1, double v1, signed int h2, double s2, double v2, struct anonymous_36 *colors, signed int *ncolorsP, signed int closed_p, signed int allocate_p, signed int *writable_pP);
// make_random_colormap
// file ./../../utils/colors.h line 132
extern void make_random_colormap(struct anonymous_58 *screen, struct anonymous_59 *visual, unsigned long int cmap, struct anonymous_36 *colors, signed int *ncolorsP, signed int bright_p, signed int allocate_p, signed int *writable_pP, signed int verbose_p);
// make_shell
// file screenhack.c line 612
static struct _WidgetRec * make_shell(struct anonymous_58 *screen, struct _WidgetRec *toplevel, signed int width, signed int height);
// make_smooth_colormap
// file ./../../utils/colors.h line 88
extern void make_smooth_colormap(struct anonymous_58 *screen, struct anonymous_59 *visual, unsigned long int cmap, struct anonymous_36 *colors, signed int *ncolorsP, signed int allocate_p, signed int *writable_pP, signed int verbose_p);
// make_uniform_colormap
// file ./../../utils/colors.h line 110
extern void make_uniform_colormap(struct anonymous_58 *screen, struct anonymous_59 *visual, unsigned long int cmap, struct anonymous_36 *colors, signed int *ncolorsP, signed int allocate_p, signed int *writable_pP, signed int verbose_p);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// merge_options
// file screenhack.c line 182
static void merge_options(void);
// open
// file /usr/include/fcntl.h line 156
extern signed int open(const char *, signed int, ...);
// orig_ehandler_object
//
signed int orig_ehandler_object(struct _XDisplay *, struct anonymous_64 *);
// parse_image_data
// file atlantis.c line 173
static void parse_image_data(struct ModeInfo *mi);
// parse_time
// file resources.c line 203
extern signed int parse_time(const char *string, signed int seconds_default_p, signed int silent_p);
// pick_best_gl_visual
// file visual.c line 281
static struct anonymous_59 * pick_best_gl_visual(struct anonymous_58 *screen);
// pick_best_visual
// file visual.c line 174
static struct anonymous_59 * pick_best_visual(struct anonymous_58 *screen, signed int prefer_writable_cells, signed int color_only);
// pick_best_visual_of_class
// file visual.c line 242
static struct anonymous_59 * pick_best_visual_of_class(struct anonymous_58 *screen, signed int visual_class);
// pick_mono_visual
// file visual.c line 218
static struct anonymous_59 * pick_mono_visual(struct anonymous_58 *screen);
// pick_visual
// file screenhack.c line 321
static struct anonymous_59 * pick_visual(struct anonymous_58 *screen);
// print_texture_label
// file texfont.c line 758
void print_texture_label(struct _XDisplay *dpy, struct texture_font_data *data, signed int window_width, signed int window_height, signed int position, const char *string);
// print_texture_string
// file texfont.c line 620
extern void print_texture_string(struct texture_font_data *data, const char *string);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_destroy
// file /usr/include/pthread.h line 290
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 287
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setstacksize
// file /usr/include/pthread.h line 375
extern signed int pthread_attr_setstacksize(union pthread_attr_t *, unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 981
extern signed int pthread_cond_broadcast(union anonymous_69 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 973
extern signed int pthread_cond_destroy(union anonymous_69 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 989
extern signed int pthread_cond_wait(union anonymous_69 *, union anonymous_67 *);
// pthread_create
// file /usr/include/pthread.h line 233
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 271
extern signed int pthread_detach(unsigned long int);
// pthread_join
// file /usr/include/pthread.h line 250
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 754
extern signed int pthread_mutex_destroy(union anonymous_67 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 762
extern signed int pthread_mutex_lock(union anonymous_67 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_unlock(union anonymous_67 *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// refresh_atlantis
// file atlantis.c line 560
static void refresh_atlantis(struct ModeInfo *mi);
// release_atlantis
// file atlantis.c line 540
static void release_atlantis(struct ModeInfo *mi);
// reshape_atlantis
// file atlantis.c line 322
static void reshape_atlantis(struct ModeInfo *mi, signed int width, signed int height);
// rgb_to_hsv
// file hsv.c line 52
extern void rgb_to_hsv(unsigned short int r, unsigned short int g, unsigned short int b, signed int *h, double *s, double *v);
// rotate_colors
// file colors.c line 711
extern void rotate_colors(struct anonymous_58 *screen, unsigned long int cmap, struct anonymous_36 *colors, signed int ncolors, signed int distance);
// run_screenhack_table
// file screenhack.c line 536
static void run_screenhack_table(struct _XDisplay *dpy, unsigned long int window, unsigned long int window2, struct xscreensaver_function_table *ft);
// run_screenhack_table::1::fps_cb_object
//
void fps_cb_object(struct _XDisplay *, unsigned long int, struct fps_state *, void *);
// run_screenhack_table::1::init_cb_object
//
void * init_cb_object(struct _XDisplay *, unsigned long int, void *);
// screen_number
// file ./../../utils/visual.h line 21
extern signed int screen_number(struct anonymous_58 *screen);
// screenhack_do_fps
// file screenhack.c line 528
static void screenhack_do_fps(struct _XDisplay *dpy, unsigned long int w, struct fps_state *fpst, void *closure);
// screenhack_ehandler
// file screenhack.c line 245
static signed int screenhack_ehandler(struct _XDisplay *dpy, struct anonymous_64 *error);
// screenhack_event_helper
// file resources.c line 276
extern signed int screenhack_event_helper(struct _XDisplay *dpy, unsigned long int window, union _XEvent *event);
// screenhack_handle_event_1
// file screenhack.c line 270
static signed int screenhack_handle_event_1(struct _XDisplay *dpy, union _XEvent *event);
// screenhack_table_handle_events
// file screenhack.c line 433
static char screenhack_table_handle_events(struct _XDisplay *dpy, struct xscreensaver_function_table *ft, unsigned long int window, void *closure, unsigned long int window2, void *closure2);
// screenhack_usleep
// file ./../utils/usleep.h line 23
extern void screenhack_usleep(unsigned long int usecs);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_47 *, struct anonymous_47 *, struct anonymous_47 *, struct timeval *);
// sin
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 65
extern double sin(double);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern double sqrt(double);
// strcasecmp
// file /usr/include/string.h line 529
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 133
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 231
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 140
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 125
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 171
extern char * strdup(const char *);
// string_to_texture
// file texfont.c line 518
void string_to_texture(struct texture_font_data *data, const char *string, struct anonymous_11 *extents_ret, signed int *tex_width_ret, signed int *tex_height_ret);
// string_width
// file fps.c line 175
static signed int string_width(struct anonymous_13 *f, const char *c, signed int *height_ret);
// strlen
// file /usr/include/string.h line 394
extern unsigned long int strlen(const char *);
// strncpy
// file /usr/include/string.h line 128
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 258
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 337
extern char * strstr(const char *, const char *);
// sysconf
// file /usr/include/unistd.h line 622
extern signed long int sysconf(signed int);
// texture_string_metrics
// file texfont.c line 442
extern void texture_string_metrics(struct texture_font_data *data, const char *s, struct anonymous_11 *metrics_ret, signed int *ascent_ret, signed int *descent_ret);
// thread_memory_alignment
// file thread_util.h line 112
unsigned int thread_memory_alignment(struct _XDisplay *dpy);
// threadpool_create
// file thread_util.c line 713
signed int threadpool_create(struct threadpool *self, struct threadpool_class *cls, struct _XDisplay *dpy, unsigned int count);
// threadpool_destroy
// file thread_util.c line 812
void threadpool_destroy(struct threadpool *self);
// threadpool_run
// file thread_util.c line 826
void threadpool_run(struct threadpool *self, void (*func)(void *));
// threadpool_run::func_object
//
void func_object(void *);
// threadpool_wait
// file thread_util.c line 858
void threadpool_wait(struct threadpool *self);
// threads_available
// file thread_util.h line 93
signed int threads_available(struct _XDisplay *dpy);
// to_pow2
// file texfont.c line 87
static signed int to_pow2(signed int i);
// uc_truncate
// file utf8wc.c line 38
static unsigned long int uc_truncate(unsigned long int uc);
// usleep_and_process_events
// file screenhack.c line 481
static char usleep_and_process_events(struct _XDisplay *dpy, struct xscreensaver_function_table *ft, unsigned long int window, struct fps_state *fpst, void *closure, unsigned long int delay, unsigned long int window2, struct fps_state *fpst2, void *closure2, unsigned long int delay2);
// utf8_decode
// file utf8wc.c line 56
extern signed long int utf8_decode(const unsigned char *in, signed long int length, unsigned long int *unicode_ret);
// utf8_encode
// file utf8wc.c line 160
extern signed int utf8_encode(unsigned long int uc, char *out, signed long int length);
// utf8_split
// file utf8wc.c line 256
extern char ** utf8_split(const char *string, signed int *length_ret);
// utf8_to_XChar2b
// file utf8wc.c line 215
extern struct anonymous_4 * utf8_to_XChar2b(const char *string, signed int *length_ret);
// utf8_to_latin1
// file utf8wc.c line 347
extern char * utf8_to_latin1(const char *string, signed int ascii_p);
// validate_gl_visual
// file ./../../utils/visual.h line 31
extern signed int validate_gl_visual(struct _IO_FILE *out, struct anonymous_58 *screen, const char *window_desc, struct anonymous_59 *visual);
// visual_cells
// file visual.c line 487
extern signed int visual_cells(struct anonymous_58 *screen, struct anonymous_59 *visual);
// visual_class
// file visual.c line 409
extern signed int visual_class(struct anonymous_58 *screen, struct anonymous_59 *visual);
// visual_depth
// file ./../utils/visual.h line 17
extern signed int visual_depth(struct anonymous_58 *screen, struct anonymous_59 *visual);
// visual_warning
// file screenhack.c line 341
static void visual_warning(struct anonymous_58 *screen, unsigned long int window, struct anonymous_59 *visual, unsigned long int cmap, signed int window_p);
// xlib_rgb_init
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf-xlib/gdk-pixbuf-xlibrgb.h line 75
void xlib_rgb_init(struct _XDisplay *, struct anonymous_58 *);
// xlockmore_do_fps
// file ./../xlockmore.c line 533
extern void xlockmore_do_fps(struct _XDisplay *dpy, unsigned long int w, struct fps_state *fpst, void *closure);
// xlockmore_draw
// file ./../xlockmore.c line 495
static unsigned long int xlockmore_draw(struct _XDisplay *dpy, unsigned long int window, void *closure);
// xlockmore_event
// file ./../xlockmore.c line 523
static signed int xlockmore_event(struct _XDisplay *dpy, unsigned long int window, void *closure, union _XEvent *event);
// xlockmore_free
// file ./../xlockmore.c line 542
static void xlockmore_free(struct _XDisplay *dpy, unsigned long int window, void *closure);
// xlockmore_gl_compute_fps
// file ./../xlockmoreI.h line 74
extern void xlockmore_gl_compute_fps(struct _XDisplay *dpy, unsigned long int w, struct fps_state *fpst, void *closure);
// xlockmore_gl_draw_fps
// file ./../xlockmoreI.h line 75
extern void xlockmore_gl_draw_fps(struct ModeInfo *mi);
// xlockmore_gl_fps_init
// file fps-gl.c line 46
static void xlockmore_gl_fps_init(struct fps_state *st);
// xlockmore_init
// file ./../xlockmore.c line 278
static void * xlockmore_init(struct _XDisplay *dpy, unsigned long int window, struct xlockmore_function_table *xlmft);
// xlockmore_pick_gl_visual
// file ./../xlockmoreI.h line 66
extern struct anonymous_59 * xlockmore_pick_gl_visual(struct anonymous_58 *screen);
// xlockmore_read_resources
// file ./../xlockmore.c line 239
static void xlockmore_read_resources(struct ModeInfo *mi);
// xlockmore_reshape
// file ./../xlockmore.c line 511
static void xlockmore_reshape(struct _XDisplay *dpy, unsigned long int window, void *closure, unsigned int w, unsigned int h);
// xlockmore_setup
// file ./../xlockmoreI.h line 79
extern void xlockmore_setup(struct xscreensaver_function_table *xsft, void *arg);
// xlockmore_validate_gl_visual
// file ./../xlockmoreI.h line 67
extern signed int xlockmore_validate_gl_visual(struct anonymous_58 *screen, const char *name, struct anonymous_59 *visual);
// xpm_file_to_ximage
// file xpm-ximage.c line 463
extern struct _XImage * xpm_file_to_ximage(struct _XDisplay *dpy, struct anonymous_59 *visual, unsigned long int cmap, const char *filename);
// xpm_to_ximage
// file xpm-ximage.h line 26
extern struct _XImage * xpm_to_ximage(struct _XDisplay *dpy, struct anonymous_59 *visual, unsigned long int cmap, char **xpm_data);
// xpm_to_ximage_1
// file xpm-ximage.c line 68
static struct _XImage * xpm_to_ximage_1(struct _XDisplay *dpy, struct anonymous_59 *visual, unsigned long int cmap, const char *filename, char **xpm_data);
// ya_rand_init
// file ./../utils/yarandom.h line 37
extern void ya_rand_init(unsigned int seed);
// ya_random
// file ./../../utils/yarandom.h line 36
extern unsigned int ya_random(void);

struct anonymous_7
{
  // name
  char *name;
  // value
  signed long int value;
};

struct anonymous_56
{
  // opt
  char *opt;
  // desc
  char *desc;
};

struct anonymous_51
{
  // option
  char *option;
  // specifier
  char *specifier;
  // argKind
  enum anonymous_57 argKind;
  // value
  char *value;
};

struct anonymous_62
{
  // visual
  struct anonymous_59 *visual;
  // visualid
  unsigned long int visualid;
  // screen
  signed int screen;
  // depth
  signed int depth;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
};

struct anonymous_58
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous_3 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous_59 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous_0
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous_27 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous_58 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous_27
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous_11
{
  // lbearing
  signed short int lbearing;
  // rbearing
  signed short int rbearing;
  // width
  signed short int width;
  // ascent
  signed short int ascent;
  // descent
  signed short int descent;
  // attributes
  unsigned short int attributes;
};

struct anonymous_13
{
  // ext_data
  struct _XExtData *ext_data;
  // fid
  unsigned long int fid;
  // direction
  unsigned int direction;
  // min_char_or_byte2
  unsigned int min_char_or_byte2;
  // max_char_or_byte2
  unsigned int max_char_or_byte2;
  // min_byte1
  unsigned int min_byte1;
  // max_byte1
  unsigned int max_byte1;
  // all_chars_exist
  signed int all_chars_exist;
  // default_char
  unsigned int default_char;
  // n_properties
  signed int n_properties;
  // properties
  struct anonymous_10 *properties;
  // min_bounds
  struct anonymous_11 min_bounds;
  // max_bounds
  struct anonymous_11 max_bounds;
  // per_char
  struct anonymous_11 *per_char;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct anonymous_59
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous_5
{
  // texfont
  struct texture_font_data *texfont;
  // line_height
  signed int line_height;
  // top_p
  signed int top_p;
};

struct anonymous_18
{
  // var
  void *var;
  // name
  char *name;
  // classname
  char *classname;
  // def
  char *def;
  // type
  enum anonymous_60 type;
};

struct anonymous_47
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_70
{
  // x
  signed short int x;
  // y
  signed short int y;
};

struct _fishRec
{
  // x
  float x;
  // y
  float y;
  // z
  float z;
  // phi
  float phi;
  // theta
  float theta;
  // psi
  float psi;
  // v
  float v;
  // xt
  float xt;
  // yt
  float yt;
  // zt
  float zt;
  // htail
  float htail;
  // vtail
  float vtail;
  // dtheta
  float dtheta;
  // spurt
  signed int spurt;
  // attack
  signed int attack;
  // sign
  signed int sign;
};

struct anonymous
{
  // WinH
  signed int WinH;
  // WinW
  signed int WinW;
  // glx_context
  struct __GLXcontextRec **glx_context;
  // num_sharks
  signed int num_sharks;
  // sharkspeed
  float sharkspeed;
  // whalespeed
  float whalespeed;
  // sharksize
  signed int sharksize;
  // wire
  signed int wire;
  // whaledir
  signed int whaledir;
  // sharks
  struct _fishRec *sharks;
  // momWhale
  struct _fishRec momWhale;
  // babyWhale
  struct _fishRec babyWhale;
  // dolph
  struct _fishRec dolph;
  // texture
  struct _XImage *texture;
};

struct anonymous_68
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_31
{
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous_3
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous_59 *visuals;
};

struct anonymous_34
{
  // function
  signed int function;
  // plane_mask
  unsigned long int plane_mask;
  // foreground
  unsigned long int foreground;
  // background
  unsigned long int background;
  // line_width
  signed int line_width;
  // line_style
  signed int line_style;
  // cap_style
  signed int cap_style;
  // join_style
  signed int join_style;
  // fill_style
  signed int fill_style;
  // fill_rule
  signed int fill_rule;
  // arc_mode
  signed int arc_mode;
  // tile
  unsigned long int tile;
  // stipple
  unsigned long int stipple;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // font
  unsigned long int font;
  // subwindow_mode
  signed int subwindow_mode;
  // graphics_exposures
  signed int graphics_exposures;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // clip_mask
  unsigned long int clip_mask;
  // dash_offset
  signed int dash_offset;
  // dashes
  char dashes;
};

struct anonymous_16
{
  // numopts
  signed int numopts;
  // opts
  struct anonymous_51 *opts;
  // numvarsdesc
  signed int numvarsdesc;
  // vars
  struct anonymous_18 *vars;
  // desc
  struct anonymous_56 *desc;
};

struct anonymous_64
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous_54
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
};

struct anonymous_55
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
  // cookie
  unsigned int cookie;
  // data
  void *data;
};

struct anonymous_25
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous_23
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous_29
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
};

struct anonymous_30
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // from_configure
  signed int from_configure;
};

struct anonymous_32
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_41
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous_38
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous_37
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_35
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // parent
  unsigned long int parent;
  // x
  signed int x;
  // y
  signed int y;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_45
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // owner
  unsigned long int owner;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous_33
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
};

struct anonymous_42
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous_28
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_40
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // detail
  signed int detail;
  // value_mask
  unsigned long int value_mask;
};

struct anonymous_46
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous_53
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
};

struct anonymous_21
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // key_vector
  char key_vector[32l];
};

struct anonymous_20
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // mode
  signed int mode;
  // detail
  signed int detail;
};

struct anonymous_52
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // request
  signed int request;
  // first_keycode
  signed int first_keycode;
  // count
  signed int count;
};

struct anonymous_26
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // state
  signed int state;
};

struct anonymous_39
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous_22
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
};

struct anonymous_43
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // atom
  unsigned long int atom;
  // time
  unsigned long int time;
  // state
  signed int state;
};

struct anonymous_48
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // colormap
  unsigned long int colormap;
  // new
  signed int new;
  // state
  signed int state;
};

union anonymous_49
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

struct anonymous_50
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // message_type
  unsigned long int message_type;
  // format
  signed int format;
  // data
  union anonymous_49 data;
};

struct anonymous_19
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // mode
  signed int mode;
  // detail
  signed int detail;
  // same_screen
  signed int same_screen;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct anonymous_17
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // is_hint
  char is_hint;
  // same_screen
  signed int same_screen;
};

struct anonymous_12
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // same_screen
  signed int same_screen;
};

struct anonymous_8
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // keycode
  unsigned int keycode;
  // same_screen
  signed int same_screen;
};

struct anonymous_44
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // selection
  unsigned long int selection;
  // time
  unsigned long int time;
};

struct anonymous_65
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // depth
  signed int depth;
  // visual
  struct anonymous_59 *visual;
  // root
  unsigned long int root;
  // class
  signed int class;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // colormap
  unsigned long int colormap;
  // map_installed
  signed int map_installed;
  // map_state
  signed int map_state;
  // all_event_masks
  signed long int all_event_masks;
  // your_event_mask
  signed long int your_event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // screen
  struct anonymous_58 *screen;
};

struct anonymous_66
{
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // alpha
  unsigned short int alpha;
};

struct anonymous_6
{
  // request_mode
  unsigned int request_mode;
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // border_width
  unsigned short int border_width;
  // sibling
  struct _WidgetRec *sibling;
  // stack_mode
  signed int stack_mode;
};

struct anonymous_9
{
  // size
  unsigned int size;
  // addr
  char *addr;
};

struct anonymous_24
{
  // background_pixmap
  unsigned long int background_pixmap;
  // background_pixel
  unsigned long int background_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // border_pixel
  unsigned long int border_pixel;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // event_mask
  signed long int event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // colormap
  unsigned long int colormap;
  // cursor
  unsigned long int cursor;
};

struct anonymous_10
{
  // name
  unsigned long int name;
  // card32
  unsigned long int card32;
};

struct anonymous_36
{
  // pixel
  unsigned long int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // flags
  char flags;
  // pad
  char pad;
};

struct anonymous_2
{
  // shmseg
  unsigned long int shmseg;
  // shmid
  signed int shmid;
  // shmaddr
  char *shmaddr;
  // readOnly
  signed int readOnly;
};

struct anonymous_4
{
  // byte1
  unsigned char byte1;
  // byte2
  unsigned char byte2;
};

union anonymous_63
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_69
{
  // __data
  struct anonymous_68 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_67
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ModeInfo
{
  // xlmft
  struct xlockmore_function_table *xlmft;
  // dpy
  struct _XDisplay *dpy;
  // window
  unsigned long int window;
  // root_p
  signed int root_p;
  // num_screens
  signed int num_screens;
  // screen_number
  signed int screen_number;
  // npixels
  signed int npixels;
  // pixels
  unsigned long int *pixels;
  // colors
  struct anonymous_36 *colors;
  // writable_p
  signed int writable_p;
  // white
  unsigned long int white;
  // black
  unsigned long int black;
  // xgwa
  struct anonymous_65 xgwa;
  // gc
  struct _XGC *gc;
  // pause
  signed long int pause;
  // fullrandom
  signed int fullrandom;
  // cycles
  signed long int cycles;
  // batchcount
  signed long int batchcount;
  // size
  signed long int size;
  // threed
  signed int threed;
  // threed_left_color
  signed long int threed_left_color;
  // threed_right_color
  signed long int threed_right_color;
  // threed_both_color
  signed long int threed_both_color;
  // threed_none_color
  signed long int threed_none_color;
  // threed_delta
  signed long int threed_delta;
  // wireframe_p
  signed int wireframe_p;
  // is_drawn
  signed int is_drawn;
  // fpst
  struct fps_state *fpst;
  // fps_p
  signed int fps_p;
  // polygon_count
  unsigned long int polygon_count;
  // recursion_depth
  double recursion_depth;
  // use_shm
  signed int use_shm;
  // shm_info
  struct anonymous_2 shm_info;
};

struct _CoreClassPart
{
  // superclass
  struct _WidgetClassRec *superclass;
  // class_name
  char *class_name;
  // widget_size
  unsigned int widget_size;
  // class_initialize
  void (*class_initialize)(void);
  // class_part_initialize
  void (*class_part_initialize)(struct _WidgetClassRec *);
  // class_inited
  unsigned char class_inited;
  // initialize
  void (*initialize)(struct _WidgetRec *, struct _WidgetRec *, struct anonymous_7 *, unsigned int *);
  // initialize_hook
  void (*initialize_hook)(struct _WidgetRec *, struct anonymous_7 *, unsigned int *);
  // realize
  void (*realize)(struct _WidgetRec *, unsigned long int *, struct anonymous_24 *);
  // actions
  struct _XtActionsRec *actions;
  // num_actions
  unsigned int num_actions;
  // resources
  struct _XtResource *resources;
  // num_resources
  unsigned int num_resources;
  // xrm_class
  signed int xrm_class;
  // compress_motion
  char compress_motion;
  // compress_exposure
  unsigned char compress_exposure;
  // compress_enterleave
  char compress_enterleave;
  // visible_interest
  char visible_interest;
  // destroy
  void (*destroy)(struct _WidgetRec *);
  // resize
  void (*resize)(struct _WidgetRec *);
  // expose
  void (*expose)(struct _WidgetRec *, union _XEvent *, struct _XRegion *);
  // set_values
  char (*set_values)(struct _WidgetRec *, struct _WidgetRec *, struct _WidgetRec *, struct anonymous_7 *, unsigned int *);
  // set_values_hook
  char (*set_values_hook)(struct _WidgetRec *, struct anonymous_7 *, unsigned int *);
  // set_values_almost
  void (*set_values_almost)(struct _WidgetRec *, struct _WidgetRec *, struct anonymous_6 *, struct anonymous_6 *);
  // get_values_hook
  void (*get_values_hook)(struct _WidgetRec *, struct anonymous_7 *, unsigned int *);
  // accept_focus
  char (*accept_focus)(struct _WidgetRec *, unsigned long int *);
  // version
  unsigned long int version;
  // callback_private
  void *callback_private;
  // tm_table
  char *tm_table;
  // query_geometry
  enum anonymous_14 (*query_geometry)(struct _WidgetRec *, struct anonymous_6 *, struct anonymous_6 *);
  // display_accelerator
  void (*display_accelerator)(struct _WidgetRec *, char *);
  // extension
  void *extension;
};

struct _XtTMRec
{
  // translations
  struct _TranslationData *translations;
  // proc_table
  void (**proc_table)(struct _WidgetRec *, union _XEvent *, char **, unsigned int *);
  // current_state
  struct _XtStateRec *current_state;
  // lastEventTime
  unsigned long int lastEventTime;
};

struct _CorePart
{
  // self
  struct _WidgetRec *self;
  // widget_class
  struct _WidgetClassRec *widget_class;
  // parent
  struct _WidgetRec *parent;
  // xrm_name
  signed int xrm_name;
  // being_destroyed
  char being_destroyed;
  // destroy_callbacks
  struct _XtCallbackRec *destroy_callbacks;
  // constraints
  void *constraints;
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // border_width
  unsigned short int border_width;
  // managed
  char managed;
  // sensitive
  char sensitive;
  // ancestor_sensitive
  char ancestor_sensitive;
  // event_table
  struct _XtEventRec *event_table;
  // tm
  struct _XtTMRec tm;
  // accelerators
  struct _TranslationData *accelerators;
  // border_pixel
  unsigned long int border_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // popup_list
  struct _WidgetRec **popup_list;
  // num_popups
  unsigned int num_popups;
  // name
  char *name;
  // screen
  struct anonymous_58 *screen;
  // colormap
  unsigned long int colormap;
  // window
  unsigned long int window;
  // depth
  unsigned int depth;
  // background_pixel
  unsigned long int background_pixel;
  // background_pixmap
  unsigned long int background_pixmap;
  // visible
  char visible;
  // mapped_when_managed
  char mapped_when_managed;
};

struct _GError
{
  // domain
  unsigned int domain;
  // code
  signed int code;
  // message
  char *message;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _WidgetClassRec
{
  // core_class
  struct _CoreClassPart core_class;
};

struct _WidgetRec
{
  // core
  struct _CorePart core;
};

struct _XComposeStatus
{
  // compose_ptr
  char *compose_ptr;
  // chars_matched
  signed int chars_matched;
};

union _XEvent
{
  // type
  signed int type;
  // xany
  struct anonymous_53 xany;
  // xkey
  struct anonymous_8 xkey;
  // xbutton
  struct anonymous_12 xbutton;
  // xmotion
  struct anonymous_17 xmotion;
  // xcrossing
  struct anonymous_19 xcrossing;
  // xfocus
  struct anonymous_20 xfocus;
  // xexpose
  struct anonymous_22 xexpose;
  // xgraphicsexpose
  struct anonymous_23 xgraphicsexpose;
  // xnoexpose
  struct anonymous_25 xnoexpose;
  // xvisibility
  struct anonymous_26 xvisibility;
  // xcreatewindow
  struct anonymous_28 xcreatewindow;
  // xdestroywindow
  struct anonymous_29 xdestroywindow;
  // xunmap
  struct anonymous_30 xunmap;
  // xmap
  struct anonymous_32 xmap;
  // xmaprequest
  struct anonymous_33 xmaprequest;
  // xreparent
  struct anonymous_35 xreparent;
  // xconfigure
  struct anonymous_37 xconfigure;
  // xgravity
  struct anonymous_38 xgravity;
  // xresizerequest
  struct anonymous_39 xresizerequest;
  // xconfigurerequest
  struct anonymous_40 xconfigurerequest;
  // xcirculate
  struct anonymous_41 xcirculate;
  // xcirculaterequest
  struct anonymous_42 xcirculaterequest;
  // xproperty
  struct anonymous_43 xproperty;
  // xselectionclear
  struct anonymous_44 xselectionclear;
  // xselectionrequest
  struct anonymous_45 xselectionrequest;
  // xselection
  struct anonymous_46 xselection;
  // xcolormap
  struct anonymous_48 xcolormap;
  // xclient
  struct anonymous_50 xclient;
  // xmapping
  struct anonymous_52 xmapping;
  // xerror
  struct anonymous_64 xerror;
  // xkeymap
  struct anonymous_21 xkeymap;
  // xgeneric
  struct anonymous_54 xgeneric;
  // xcookie
  struct anonymous_55 xcookie;
  // pad
  signed long int pad[24l];
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct _XGlyphInfo
{
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // x
  signed short int x;
  // y
  signed short int y;
  // xOff
  signed short int xOff;
  // yOff
  signed short int yOff;
};

struct funcs
{
  // create_image
  struct _XImage * (*create_image)(struct _XDisplay *, struct anonymous_59 *, unsigned int, signed int, signed int, char *, unsigned int, unsigned int, signed int, signed int);
  // destroy_image
  signed int (*destroy_image)(struct _XImage *);
  // get_pixel
  unsigned long int (*get_pixel)(struct _XImage *, signed int, signed int);
  // put_pixel
  signed int (*put_pixel)(struct _XImage *, signed int, signed int, unsigned long int);
  // sub_image
  struct _XImage * (*sub_image)(struct _XImage *, signed int, signed int, unsigned int, unsigned int);
  // add_pixel
  signed int (*add_pixel)(struct _XImage *, signed long int);
};

struct _XImage
{
  // width
  signed int width;
  // height
  signed int height;
  // xoffset
  signed int xoffset;
  // format
  signed int format;
  // data
  char *data;
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // bitmap_pad
  signed int bitmap_pad;
  // depth
  signed int depth;
  // bytes_per_line
  signed int bytes_per_line;
  // bits_per_pixel
  signed int bits_per_pixel;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // obdata
  char *obdata;
  // f
  struct funcs f;
};

struct _XftColor
{
  // pixel
  unsigned long int pixel;
  // color
  struct anonymous_66 color;
};

struct _XftFont
{
  // ascent
  signed int ascent;
  // descent
  signed int descent;
  // height
  signed int height;
  // max_advance_width
  signed int max_advance_width;
  // charset
  struct _FcCharSet *charset;
  // pattern
  struct _FcPattern *pattern;
};

struct _XtActionsRec
{
  // string
  char *string;
  // proc
  void (*proc)(struct _WidgetRec *, union _XEvent *, char **, unsigned int *);
};

struct _XtCallbackRec
{
  // callback
  void (*callback)(struct _WidgetRec *, void *, void *);
  // closure
  void *closure;
};

struct _XtResource
{
  // resource_name
  char *resource_name;
  // resource_class
  char *resource_class;
  // resource_type
  char *resource_type;
  // resource_size
  unsigned int resource_size;
  // resource_offset
  unsigned int resource_offset;
  // default_type
  char *default_type;
  // default_addr
  void *default_addr;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct _async_name_from_addr_param
{
  // addrlen
  unsigned int addrlen;
  // addr
  struct sockaddr_storage addr;
};

struct _parallel_startup_type
{
  // parent
  struct threadpool *parent;
  // thread_create
  signed int (*thread_create)(void *, struct threadpool *, unsigned int);
  // last_errno
  signed int last_errno;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct io_thread
{
  // status
  enum _io_thread_status status;
  // thread
  unsigned long int thread;
};

struct async_addr_from_name
{
  // io
  struct io_thread io;
  // gai_error
  signed int gai_error;
  // errno_error
  signed int errno_error;
  // res
  struct addrinfo *res;
};

struct async_name_from_addr
{
  // param
  struct _async_name_from_addr_param param;
  // io
  struct io_thread io;
  // host
  char host[1025l];
  // gai_error
  signed int gai_error;
  // errno_error
  signed int errno_error;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct fps_state
{
  // dpy
  struct _XDisplay *dpy;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // font
  struct anonymous_13 *font;
  // clear_p
  signed int clear_p;
  // string
  char string[1024l];
  // gl_fps_data
  void *gl_fps_data;
  // draw_gc
  struct _XGC *draw_gc;
  // erase_gc
  struct _XGC *erase_gc;
  // last_ifps
  signed int last_ifps;
  // last_fps
  double last_fps;
  // frame_count
  signed int frame_count;
  // slept
  unsigned long int slept;
  // prev_frame_end
  struct timeval prev_frame_end;
  // this_frame_end
  struct timeval this_frame_end;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct in6_addr
{
  // __in6_u
  union anonymous_63 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct texfont_cache
{
  // string
  char *string;
  // texid
  unsigned int texid;
  // extents
  struct anonymous_11 extents;
  // tex_width
  signed int tex_width;
  // tex_height
  signed int tex_height;
  // next
  struct texfont_cache *next;
};

struct texture_font_data
{
  // dpy
  struct _XDisplay *dpy;
  // xftfont
  struct _XftFont *xftfont;
  // cache_size
  signed int cache_size;
  // cache
  struct texfont_cache *cache;
};

struct threadpool
{
  // count
  unsigned int count;
  // thread_size
  unsigned long int thread_size;
  // thread_run
  void (*thread_run)(void *);
  // thread_destroy
  void (*thread_destroy)(void *);
  // serial_threads
  void *serial_threads;
  // mutex
  union anonymous_67 mutex;
  // cond
  union anonymous_69 cond;
  // parallel_pending
  unsigned int parallel_pending;
  // parallel_unfinished
  unsigned int parallel_unfinished;
  // parallel_threads
  unsigned long int *parallel_threads;
};

struct threadpool_class
{
  // size
  unsigned long int size;
  // create
  signed int (*create)(void *, struct threadpool *, unsigned int);
  // destroy
  void (*destroy)(void *);
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct xlockmore_function_table
{
  // progclass
  const char *progclass;
  // defaults
  const char *defaults;
  // want_writable_colors
  signed int want_writable_colors;
  // desired_color_scheme
  enum anonymous_1 desired_color_scheme;
  // hack_init
  void (*hack_init)(struct ModeInfo *);
  // hack_draw
  void (*hack_draw)(struct ModeInfo *);
  // hack_reshape
  void (*hack_reshape)(struct ModeInfo *, signed int, signed int);
  // hack_refresh
  void (*hack_refresh)(struct ModeInfo *);
  // hack_free
  void (*hack_free)(struct ModeInfo *);
  // hack_handle_events
  signed int (*hack_handle_events)(struct ModeInfo *, union _XEvent *);
  // opts
  struct anonymous_16 *opts;
  // screen_count
  unsigned int screen_count;
};

struct xscreensaver_function_table
{
  // progclass
  const char *progclass;
  // defaults
  const char * const *defaults;
  // options
  const struct anonymous_51 *options;
  // setup_cb
  void (*setup_cb)(struct xscreensaver_function_table *, void *);
  // setup_arg
  void *setup_arg;
  // init_cb
  void * (*init_cb)(struct _XDisplay *, unsigned long int);
  // draw_cb
  unsigned long int (*draw_cb)(struct _XDisplay *, unsigned long int, void *);
  // reshape_cb
  void (*reshape_cb)(struct _XDisplay *, unsigned long int, void *, unsigned int, unsigned int);
  // event_cb
  signed int (*event_cb)(struct _XDisplay *, unsigned long int, void *, union _XEvent *);
  // free_cb
  void (*free_cb)(struct _XDisplay *, unsigned long int, void *);
  // fps_cb
  void (*fps_cb)(struct _XDisplay *, unsigned long int, struct fps_state *, void *);
  // pick_visual_hook
  struct anonymous_59 * (*pick_visual_hook)(struct anonymous_58 *);
  // validate_visual_hook
  signed int (*validate_visual_hook)(struct anonymous_58 *, const char *, struct anonymous_59 *);
};


// N001
// file dolphin.c line 80
static const float N001[3l] = { (const float)-0.005937, (const float)-0.101998, (const float)-0.994767 };
// N001_link1
// file whale.c line 80
static const float N001_link1[3l] = { (const float)0.019249, (const float)0.01134, (const float)-0.99975 };
// N002
// file dolphin.c line 81
static const float N002[3l] = { (const float)0.93678, (const float)-0.200803, (const float)0.286569 };
// N002_link1
// file shark.c line 83
static const float N002_link1[3l] = { (const float)0.000077, (const float)-0.020611, (const float)0.999788 };
// N002_link2
// file whale.c line 81
static const float N002_link2[3l] = { (const float)-0.132579, (const float)0.954547, (const float)0.266952 };
// N003
// file dolphin.c line 82
static const float N003[3l] = { (const float)-0.233062, (const float)0.972058, (const float)0.028007 };
// N003_link1
// file shark.c line 84
static const float N003_link1[3l] = { (const float)0.961425, (const float)0.258729, (const float)-0.09339 };
// N003_link2
// file whale.c line 82
static const float N003_link2[3l] = { (const float)-0.196061, (const float)0.980392, (const float)-0.019778 };
// N004
// file shark.c line 85
static const float N004[3l] = { (const float)0.510811, (const float)-0.769633, (const float)-0.383063 };
// N004_link1
// file whale.c line 83
static const float N004_link1[3l] = { (const float)0.695461, (const float)0.604704, (const float)0.388158 };
// N005
// file dolphin.c line 86
static const float N005[3l] = { (const float)0.898117, (const float)0.360171, (const float)0.252315 };
// N005_link1
// file shark.c line 86
static const float N005_link1[3l] = { (const float)0.400123, (const float)0.855734, (const float)-0.328055 };
// N005_link2
// file whale.c line 84
static const float N005_link2[3l] = { (const float)0.8706, (const float)0.425754, (const float)0.246557 };
// N006
// file dolphin.c line 87
static const float N006[3l] = { (const float)-0.915437, (const float)0.348456, (const float)0.201378 };
// N006_link1
// file shark.c line 87
static const float N006_link1[3l] = { (const float)-0.770715, (const float)0.610204, (const float)-0.18344 };
// N006_link2
// file whale.c line 85
static const float N006_link2[3l] = { (const float)-0.881191, (const float)0.392012, (const float)0.264251 };
// N007
// file dolphin.c line 88
static const float N007[3l] = { (const float)0.602263, (const float)-0.777527, (const float)0.18092 };
// N007_link1
// file shark.c line 88
static const float N007_link1[3l] = { (const float)-0.915597, (const float)-0.373345, (const float)-0.149316 };
// N008
// file dolphin.c line 89
static const float N008[3l] = { (const float)-0.906912, (const float)-0.412015, (const float)0.088061 };
// N008_link1
// file shark.c line 89
static const float N008_link1[3l] = { (const float)-0.972788, (const float)0.208921, (const float)-0.100179 };
// N008_link2
// file whale.c line 89
static const float N008_link2[3l] = { (const float)-0.341437, (const float)0.887477, (const float)0.309523 };
// N009
// file shark.c line 90
static const float N009[3l] = { (const float)-0.939713, (const float)-0.312268, (const float)-0.139383 };
// N009_link1
// file whale.c line 90
static const float N009_link1[3l] = { (const float)0.124035, (const float)-0.992278, (const float)0 };
// N010
// file shark.c line 91
static const float N010[3l] = { (const float)-0.624138, (const float)-0.741047, (const float)-0.247589 };
// N010_link1
// file whale.c line 91
static const float N010_link1[3l] = { (const float)0.242536, (const float)0, (const float)-0.970143 };
// N011
// file shark.c line 92
static const float N011[3l] = { (const float)0.591434, (const float)-0.768401, (const float)-0.244471 };
// N011_link1
// file whale.c line 92
static const float N011_link1[3l] = { (const float)0.588172, (const float)0, (const float)0.808736 };
// N012
// file dolphin.c line 95
static const float N012[3l] = { (const float)0.884408, (const float)-0.429417, (const float)-0.182821 };
// N012_link1
// file shark.c line 93
static const float N012_link1[3l] = { (const float)0.935152, (const float)-0.328495, (const float)-0.132598 };
// N012_link2
// file whale.c line 93
static const float N012_link2[3l] = { (const float)0.929824, (const float)-0.340623, (const float)-0.139298 };
// N013
// file dolphin.c line 96
static const float N013[3l] = { (const float)0.921121, (const float)0.311084, (const float)-0.234016 };
// N013_link1
// file shark.c line 94
static const float N013_link1[3l] = { (const float)0.997102, (const float)0.074243, (const float)-0.016593 };
// N013_link2
// file whale.c line 94
static const float N013_link2[3l] = { (const float)0.954183, (const float)0.267108, (const float)-0.134865 };
// N014
// file dolphin.c line 97
static const float N014[3l] = { (const float)0.382635, (const float)0.877882, (const float)-0.287948 };
// N014_link1
// file shark.c line 95
static const float N014_link1[3l] = { (const float)0.969995, (const float)0.241712, (const float)-0.026186 };
// N014_link2
// file whale.c line 95
static const float N014_link2[3l] = { (const float)0.495127, (const float)0.855436, (const float)-0.151914 };
// N015
// file dolphin.c line 98
static const float N015[3l] = { (const float)-0.380046, (const float)0.888166, (const float)-0.258316 };
// N015_link1
// file shark.c line 96
static const float N015_link1[3l] = { (const float)0.844539, (const float)0.502628, (const float)-0.184714 };
// N015_link2
// file whale.c line 96
static const float N015_link2[3l] = { (const float)-0.390199, (const float)0.906569, (const float)-0.160867 };
// N016
// file dolphin.c line 99
static const float N016[3l] = { (const float)-0.891515, (const float)0.392238, (const float)-0.226607 };
// N016_link1
// file shark.c line 97
static const float N016_link1[3l] = { (const float)-0.906608, (const float)0.386308, (const float)-0.169787 };
// N016_link2
// file whale.c line 97
static const float N016_link2[3l] = { (const float)-0.923605, (const float)0.354581, (const float)-0.145692 };
// N017
// file dolphin.c line 100
static const float N017[3l] = { (const float)-0.901419, (const float)-0.382002, (const float)-0.203763 };
// N017_link1
// file shark.c line 98
static const float N017_link1[3l] = { (const float)-0.970016, (const float)0.241698, (const float)-0.025516 };
// N017_link2
// file whale.c line 98
static const float N017_link2[3l] = { (const float)-0.955796, (const float)-0.260667, (const float)-0.136036 };
// N018
// file dolphin.c line 101
static const float N018[3l] = { (const float)-0.367225, (const float)-0.911091, (const float)-0.187243 };
// N018_link1
// file shark.c line 99
static const float N018_link1[3l] = { (const float)-0.998652, (const float)0.050493, (const float)-0.012045 };
// N018_link2
// file whale.c line 99
static const float N018_link2[3l] = { (const float)-0.501283, (const float)-0.853462, (const float)-0.14254 };
// N019
// file dolphin.c line 102
static const float N019[3l] = { (const float)0.339539, (const float)-0.924846, (const float)-0.171388 };
// N019_link1
// file shark.c line 100
static const float N019_link1[3l] = { (const float)-0.942685, (const float)-0.333051, (const float)-0.020556 };
// N019_link2
// file whale.c line 100
static const float N019_link2[3l] = { (const float)0.4053, (const float)-0.901974, (const float)-0.148913 };
// N020
// file dolphin.c line 103
static const float N020[3l] = { (const float)0.914706, (const float)-0.378617, (const float)-0.14129 };
// N020_link1
// file shark.c line 101
static const float N020_link1[3l] = { (const float)-0.660944, (const float)-0.750276, (const float)0.01548 };
// N020_link2
// file whale.c line 101
static const float N020_link2[3l] = { (const float)0.909913, (const float)-0.392746, (const float)-0.133451 };
// N021
// file dolphin.c line 104
static const float N021[3l] = { (const float)0.950662, (const float)0.262713, (const float)-0.164994 };
// N021_link1
// file shark.c line 102
static const float N021_link1[3l] = { (const float)0.503549, (const float)-0.862908, (const float)-0.042749 };
// N021_link2
// file whale.c line 102
static const float N021_link2[3l] = { (const float)0.936494, (const float)0.331147, (const float)-0.115414 };
// N022
// file dolphin.c line 105
static const float N022[3l] = { (const float)0.546359, (const float)0.80146, (const float)-0.243218 };
// N022_link1
// file shark.c line 103
static const float N022_link1[3l] = { (const float)0.953202, (const float)-0.302092, (const float)-0.012089 };
// N022_link2
// file whale.c line 103
static const float N022_link2[3l] = { (const float)0.600131, (const float)0.793724, (const float)-0.099222 };
// N023
// file dolphin.c line 106
static const float N023[3l] = { (const float)-0.315796, (const float)0.917068, (const float)-0.243431 };
// N023_link1
// file shark.c line 104
static const float N023_link1[3l] = { (const float)0.998738, (const float)0.023574, (const float)0.044344 };
// N023_link2
// file whale.c line 104
static const float N023_link2[3l] = { (const float)-0.231556, (const float)0.968361, (const float)-0.093053 };
// N024
// file dolphin.c line 107
static const float N024[3l] = { (const float)-0.825687, (const float)0.532277, (const float)-0.186875 };
// N024_link1
// file shark.c line 105
static const float N024_link1[3l] = { (const float)0.979297, (const float)0.193272, (const float)0.060202 };
// N024_link2
// file whale.c line 105
static const float N024_link2[3l] = { (const float)-0.844369, (const float)0.52533, (const float)-0.105211 };
// N025
// file dolphin.c line 108
static const float N025[3l] = { (const float)-0.974763, (const float)-0.155232, (const float)-0.160435 };
// N025_link1
// file shark.c line 106
static const float N025_link1[3l] = { (const float)0.7983, (const float)0.464885, (const float)0.382883 };
// N025_link2
// file whale.c line 106
static const float N025_link2[3l] = { (const float)-0.982725, (const float)-0.136329, (const float)-0.125164 };
// N026
// file dolphin.c line 109
static const float N026[3l] = { (const float)-0.560596, (const float)-0.816658, (const float)-0.137119 };
// N026_link1
// file shark.c line 107
static const float N026_link1[3l] = { (const float)-0.75659, (const float)0.452403, (const float)0.472126 };
// N026_link2
// file whale.c line 107
static const float N026_link2[3l] = { (const float)-0.560844, (const float)-0.822654, (const float)-0.093241 };
// N027
// file dolphin.c line 110
static const float N027[3l] = { (const float)0.38021, (const float)-0.910817, (const float)-0.160786 };
// N027_link1
// file shark.c line 108
static const float N027_link1[3l] = { (const float)-0.953855, (const float)0.293003, (const float)0.065651 };
// N027_link2
// file whale.c line 108
static const float N027_link2[3l] = { (const float)0.263884, (const float)-0.959981, (const float)-0.093817 };
// N028
// file dolphin.c line 111
static const float N028[3l] = { (const float)0.923772, (const float)-0.358322, (const float)-0.135093 };
// N028_link1
// file shark.c line 109
static const float N028_link1[3l] = { (const float)-0.998033, (const float)0.040292, (const float)0.048028 };
// N028_link2
// file whale.c line 109
static const float N028_link2[3l] = { (const float)0.842057, (const float)-0.525192, (const float)-0.122938 };
// N029
// file dolphin.c line 112
static const float N029[3l] = { (const float)0.951202, (const float)0.275053, (const float)-0.139859 };
// N029_link1
// file shark.c line 110
static const float N029_link1[3l] = { (const float)-0.977079, (const float)-0.204288, (const float)0.059858 };
// N029_link2
// file whale.c line 110
static const float N029_link2[3l] = { (const float)0.92162, (const float)0.367565, (const float)-0.124546 };
// N030
// file dolphin.c line 113
static const float N030[3l] = { (const float)0.686099, (const float)0.702548, (const float)-0.188932 };
// N030_link1
// file shark.c line 111
static const float N030_link1[3l] = { (const float)-0.729117, (const float)-0.675304, (const float)0.11114 };
// N030_link2
// file whale.c line 111
static const float N030_link2[3l] = { (const float)0.613927, (const float)0.784109, (const float)-0.090918 };
// N031
// file dolphin.c line 114
static const float N031[3l] = { (const float)-0.521865, (const float)0.826719, (const float)-0.21022 };
// N031_link1
// file shark.c line 112
static const float N031_link1[3l] = { (const float)0.598361, (const float)-0.792753, (const float)0.116221 };
// N031_link2
// file whale.c line 112
static const float N031_link2[3l] = { (const float)-0.448754, (const float)0.888261, (const float)-0.098037 };
// N032
// file dolphin.c line 115
static const float N032[3l] = { (const float)-0.92382, (const float)0.346739, (const float)-0.162258 };
// N032_link1
// file shark.c line 113
static const float N032_link1[3l] = { (const float)0.965192, (const float)-0.252991, (const float)0.066332 };
// N032_link2
// file whale.c line 113
static const float N032_link2[3l] = { (const float)-0.891865, (const float)0.434376, (const float)-0.126077 };
// N033
// file dolphin.c line 116
static const float N033[3l] = { (const float)-0.902095, (const float)-0.409995, (const float)-0.134646 };
// N033_link1
// file shark.c line 114
static const float N033_link1[3l] = { (const float)0.998201, (const float)-0.00279, (const float)0.059892 };
// N033_link2
// file whale.c line 114
static const float N033_link2[3l] = { (const float)-0.881447, (const float)-0.448017, (const float)-0.149437 };
// N034
// file dolphin.c line 117
static const float N034[3l] = { (const float)-0.509115, (const float)-0.848498, (const float)-0.144404 };
// N034_link1
// file shark.c line 115
static const float N034_link1[3l] = { (const float)0.978657, (const float)0.193135, (const float)0.070207 };
// N034_link2
// file whale.c line 115
static const float N034_link2[3l] = { (const float)-0.345647, (const float)-0.922057, (const float)-0.174183 };
// N035
// file dolphin.c line 118
static const float N035[3l] = { (const float)0.456469, (const float)-0.880293, (const float)-0.129305 };
// N035_link1
// file shark.c line 116
static const float N035_link1[3l] = { (const float)0.718815, (const float)0.680392, (const float)0.142733 };
// N035_link2
// file whale.c line 116
static const float N035_link2[3l] = { (const float)0.307998, (const float)-0.941371, (const float)-0.137688 };
// N036
// file dolphin.c line 119
static const float N036[3l] = { (const float)0.873401, (const float)-0.475489, (const float)-0.105266 };
// N036_link1
// file shark.c line 117
static const float N036_link1[3l] = { (const float)-0.383096, (const float)0.906212, (const float)0.178936 };
// N036_link2
// file whale.c line 117
static const float N036_link2[3l] = { (const float)0.806316, (const float)-0.574647, (const float)-0.140124 };
// N037
// file dolphin.c line 120
static const float N037[3l] = { (const float)0.970825, (const float)0.179861, (const float)-0.158584 };
// N037_link1
// file shark.c line 118
static const float N037_link1[3l] = { (const float)-0.952831, (const float)0.29259, (const float)0.080647 };
// N037_link2
// file whale.c line 118
static const float N037_link2[3l] = { (const float)0.961346, (const float)0.233646, (const float)-0.145681 };
// N038
// file dolphin.c line 121
static const float N038[3l] = { (const float)0.675609, (const float)0.714187, (const float)-0.183004 };
// N038_link1
// file shark.c line 119
static const float N038_link1[3l] = { (const float)-0.99768, (const float)0.032417, (const float)0.059861 };
// N038_link2
// file whale.c line 119
static const float N038_link2[3l] = { (const float)0.488451, (const float)0.865586, (const float)-0.110351 };
// N039
// file dolphin.c line 122
static const float N039[3l] = { (const float)-0.523574, (const float)0.830212, (const float)-0.19136 };
// N039_link1
// file shark.c line 120
static const float N039_link1[3l] = { (const float)-0.982629, (const float)-0.169881, (const float)0.0747 };
// N039_link2
// file whale.c line 120
static const float N039_link2[3l] = { (const float)-0.37429, (const float)0.921953, (const float)-0.099553 };
// N040
// file dolphin.c line 123
static const float N040[3l] = { (const float)-0.958895, (const float)0.230808, (const float)-0.165071 };
// N040_link1
// file shark.c line 121
static const float N040_link1[3l] = { (const float)-0.695424, (const float)-0.703466, (const float)0.1467 };
// N040_link2
// file whale.c line 121
static const float N040_link2[3l] = { (const float)-0.928504, (const float)0.344533, (const float)-0.138485 };
// N041
// file dolphin.c line 124
static const float N041[3l] = { (const float)-0.918285, (const float)-0.376803, (const float)-0.121542 };
// N041_link1
// file shark.c line 122
static const float N041_link1[3l] = { (const float)0.359323, (const float)-0.915531, (const float)0.180805 };
// N041_link2
// file whale.c line 122
static const float N041_link2[3l] = { (const float)-0.918419, (const float)-0.371792, (const float)-0.135189 };
// N042
// file dolphin.c line 125
static const float N042[3l] = { (const float)-0.622467, (const float)-0.774167, (const float)-0.114888 };
// N042_link1
// file shark.c line 123
static const float N042_link1[3l] = { (const float)0.943356, (const float)-0.319387, (const float)0.089842 };
// N042_link2
// file whale.c line 123
static const float N042_link2[3l] = { (const float)-0.520666, (const float)-0.833704, (const float)-0.183968 };
// N043
// file dolphin.c line 126
static const float N043[3l] = { (const float)0.404497, (const float)-0.908807, (const float)-0.102231 };
// N043_link1
// file shark.c line 124
static const float N043_link1[3l] = { (const float)0.998272, (const float)-0.032435, (const float)0.048993 };
// N043_link2
// file whale.c line 124
static const float N043_link2[3l] = { (const float)0.339204, (const float)-0.920273, (const float)-0.195036 };
// N044
// file dolphin.c line 127
static const float N044[3l] = { (const float)0.930538, (const float)-0.365155, (const float)-0.027588 };
// N044_link1
// file shark.c line 125
static const float N044_link1[3l] = { (const float)0.978997, (const float)0.193205, (const float)0.065084 };
// N044_link2
// file whale.c line 125
static const float N044_link2[3l] = { (const float)0.921475, (const float)-0.387382, (const float)-0.028636 };
// N045
// file dolphin.c line 128
static const float N045[3l] = { (const float)0.92192, (const float)0.374157, (const float)-0.100345 };
// N045_link1
// file shark.c line 126
static const float N045_link1[3l] = { (const float)0.872144, (const float)0.470094, (const float)-0.135565 };
// N045_link2
// file whale.c line 126
static const float N045_link2[3l] = { (const float)0.842465, (const float)0.533335, (const float)-0.076204 };
// N046
// file dolphin.c line 129
static const float N046[3l] = { (const float)0.507346, (const float)0.860739, (const float)0.041562 };
// N046_link1
// file shark.c line 127
static const float N046_link1[3l] = { (const float)-0.664282, (const float)0.737945, (const float)-0.119027 };
// N046_link2
// file whale.c line 127
static const float N046_link2[3l] = { (const float)0.38011, (const float)0.924939, (const float)0.002073 };
// N047
// file dolphin.c line 130
static const float N047[3l] = { (const float)-0.394646, (const float)0.918815, (const float)-0.00573 };
// N047_link1
// file shark.c line 128
static const float N047_link1[3l] = { (const float)-0.954508, (const float)0.28857, (const float)0.075107 };
// N047_link2
// file whale.c line 128
static const float N047_link2[3l] = { (const float)-0.276128, (const float)0.961073, (const float)-0.009579 };
// N048
// file dolphin.c line 131
static const float N048[3l] = { (const float)-0.925411, (const float)0.373024, (const float)-0.066837 };
// N048_link1
// file shark.c line 129
static const float N048_link1[3l] = { (const float)-0.998273, (const float)0.032406, (const float)0.048993 };
// N048_link2
// file whale.c line 129
static const float N048_link2[3l] = { (const float)-0.879684, (const float)0.473001, (const float)-0.04925 };
// N049
// file dolphin.c line 132
static const float N049[3l] = { (const float)-0.945337, (const float)-0.322309, (const float)-0.049551 };
// N049_link1
// file shark.c line 130
static const float N049_link1[3l] = { (const float)-0.979908, (const float)-0.193579, (const float)0.048038 };
// N049_link2
// file whale.c line 130
static const float N049_link2[3l] = { (const float)-0.947184, (const float)-0.317614, (const float)-0.044321 };
// N050
// file dolphin.c line 133
static const float N050[3l] = { (const float)-0.660437, (const float)-0.750557, (const float)-0.022072 };
// N050_link1
// file shark.c line 131
static const float N050_link1[3l] = { (const float)-0.858736, (const float)-0.507202, (const float)-0.072938 };
// N050_link2
// file whale.c line 131
static const float N050_link2[3l] = { (const float)-0.642059, (const float)-0.764933, (const float)-0.051363 };
// N051
// file dolphin.c line 134
static const float N051[3l] = { (const float)0.488835, (const float)-0.87195, (const float)-0.027261 };
// N051_link1
// file shark.c line 132
static const float N051_link1[3l] = { (const float)0.643545, (const float)-0.763887, (const float)-0.048237 };
// N051_link2
// file whale.c line 132
static const float N051_link2[3l] = { (const float)0.466794, (const float)-0.880921, (const float)-0.07799 };
// N052
// file dolphin.c line 135
static const float N052[3l] = { (const float)0.902599, (const float)-0.421397, (const float)0.087969 };
// N052_link1
// file shark.c line 133
static const float N052_link1[3l] = { (const float)0.95558, (const float)-0.288954, (const float)0.058068 };
// N052_link2
// file whale.c line 133
static const float N052_link2[3l] = { (const float)0.898509, (const float)-0.432277, (const float)0.076279 };
// N053
// file dolphin.c line 136
static const float N053[3l] = { (const float)0.938636, (const float)0.322606, (const float)0.12202 };
// N053_link1
// file whale.c line 134
static const float N053_link1[3l] = { (const float)0.938985, (const float)0.328141, (const float)0.103109 };
// N054
// file dolphin.c line 137
static const float N054[3l] = { (const float)0.484605, (const float)0.871078, (const float)0.079878 };
// N054_link1
// file whale.c line 135
static const float N054_link1[3l] = { (const float)0.44242, (const float)0.895745, (const float)0.043647 };
// N055
// file dolphin.c line 138
static const float N055[3l] = { (const float)-0.353607, (const float)0.931559, (const float)0.084619 };
// N055_link1
// file whale.c line 136
static const float N055_link1[3l] = { (const float)-0.255163, (const float)0.966723, (const float)0.018407 };
// N056
// file dolphin.c line 139
static const float N056[3l] = { (const float)-0.867759, (const float)0.478564, (const float)0.134054 };
// N056_link1
// file whale.c line 137
static const float N056_link1[3l] = { (const float)-0.833769, (const float)0.54065, (const float)0.111924 };
// N057
// file dolphin.c line 140
static const float N057[3l] = { (const float)-0.951583, (const float)-0.29603, (const float)0.082794 };
// N057_link1
// file whale.c line 138
static const float N057_link1[3l] = { (const float)-0.953653, (const float)-0.289939, (const float)0.080507 };
// N058
// file dolphin.c line 141
static const float N058[3l] = { (const float)-0.672355, (const float)-0.730209, (const float)0.121384 };
// N058_link1
// file shark.c line 141
static const float N058_link1[3l] = { (const float)0.00005, (const float)0.793007, (const float)-0.609213 };
// N058_link2
// file whale.c line 139
static const float N058_link2[3l] = { (const float)-0.672357, (const float)-0.730524, (const float)0.119461 };
// N059
// file dolphin.c line 142
static const float N059[3l] = { (const float)0.528336, (const float)-0.842452, (const float)0.105525 };
// N059_link1
// file shark.c line 142
static const float N059_link1[3l] = { (const float)0.91351, (const float)0.235418, (const float)-0.331779 };
// N059_link2
// file whale.c line 140
static const float N059_link2[3l] = { (const float)0.522249, (const float)-0.846652, (const float)0.102157 };
// N060
// file dolphin.c line 143
static const float N060[3l] = { (const float)0.786913, (const float)-0.56476, (const float)0.248627 };
// N060_link1
// file shark.c line 143
static const float N060_link1[3l] = { (const float)-0.80797, (const float)0.495, (const float)-0.319625 };
// N060_link2
// file whale.c line 141
static const float N060_link2[3l] = { (const float)0.885868, (const float)-0.427631, (const float)0.179914 };
// N061
// file shark.c line 144
static const float N061[3l] = { (const float)0, (const float)0.784687, (const float)-0.619892 };
// N062
// file dolphin.c line 147
static const float N062[3l] = { (const float)0.622098, (const float)0.76523, (const float)0.165584 };
// N062_link1
// file shark.c line 145
static const float N062_link1[3l] = { (const float)0, (const float)-1, (const float)0 };
// N062_link2
// file whale.c line 145
static const float N062_link2[3l] = { (const float)0.648942, (const float)0.743116, (const float)0.163255 };
// N063
// file dolphin.c line 148
static const float N063[3l] = { (const float)-0.631711, (const float)0.767816, (const float)0.106773 };
// N063_link1
// file shark.c line 146
static const float N063_link1[3l] = { (const float)0, (const float)1, (const float)0 };
// N063_link2
// file whale.c line 146
static const float N063_link2[3l] = { (const float)-0.578967, (const float)0.80773, (const float)0.111219 };
// N064
// file dolphin.c line 149
static const float N064[3l] = { (const float)-0.687886, (const float)0.606351, (const float)0.398938 };
// N064_link1
// file shark.c line 147
static const float N064_link1[3l] = { (const float)0, (const float)1, (const float)0 };
// N065
// file dolphin.c line 150
static const float N065[3l] = { (const float)-0.946327, (const float)-0.281623, (const float)0.158598 };
// N065_link1
// file shark.c line 148
static const float N065_link1[3l] = { (const float)0, (const float)1, (const float)0 };
// N065_link2
// file whale.c line 150
static const float N065_link2[3l] = { (const float)-0.909864, (const float)-0.352202, (const float)0.219321 };
// N066
// file dolphin.c line 151
static const float N066[3l] = { (const float)-0.509549, (const float)-0.860437, (const float)0.002776 };
// N066_link1
// file shark.c line 149
static const float N066_link1[3l] = { (const float)-0.055784, (const float)0.257059, (const float)0.964784 };
// N066_link2
// file whale.c line 151
static const float N066_link2[3l] = { (const float)-0.502541, (const float)-0.81809, (const float)0.27961 };
// N067
// file dolphin.c line 152
static const float N067[3l] = { (const float)0.462594, (const float)-0.876692, (const float)0.131977 };
// N067_link1
// file whale.c line 152
static const float N067_link1[3l] = { (const float)0.322919, (const float)-0.915358, (const float)0.240504 };
// N068
// file whale.c line 153
static const float N068[3l] = { (const float)0.242536, (const float)0, (const float)-0.970143 };
// N069
// file shark.c line 154
static const float N069[3l] = { (const float)-0.000505, (const float)-0.929775, (const float)-0.368127 };
// N069_link1
// file whale.c line 154
static const float N069_link1[3l] = { (const float)0, (const float)1, (const float)0 };
// N070
// file shark.c line 155
static const float N070[3l] = { (const float)0, (const float)1, (const float)0 };
// N070_link1
// file whale.c line 155
static const float N070_link1[3l] = { (const float)0, (const float)1, (const float)0 };
// N071
// file dolphin.c line 158
static const float N071[3l] = { (const float)0, (const float)1, (const float)0 };
// N071_link1
// file whale.c line 156
static const float N071_link1[3l] = { (const float)0, (const float)1, (const float)0 };
// N072
// file whale.c line 157
static const float N072[3l] = { (const float)0, (const float)1, (const float)0 };
// N073
// file whale.c line 158
static const float N073[3l] = { (const float)0, (const float)1, (const float)0 };
// N074
// file whale.c line 159
static const float N074[3l] = { (const float)0, (const float)1, (const float)0 };
// N075
// file whale.c line 160
static const float N075[3l] = { (const float)0.03122, (const float)0.999025, (const float)-0.03122 };
// N076
// file whale.c line 161
static const float N076[3l] = { (const float)0, (const float)1, (const float)0 };
// N077
// file dolphin.c line 166
static const float N077[3l] = { (const float)-0.88077, (const float)0.461448, (const float)0.106351 };
// N077_link1
// file whale.c line 162
static const float N077_link1[3l] = { (const float)0.446821, (const float)0.893642, (const float)0.041889 };
// N078
// file dolphin.c line 167
static const float N078[3l] = { (const float)-0.88077, (const float)0.461448, (const float)0.106351 };
// N078_link1
// file whale.c line 163
static const float N078_link1[3l] = { (const float)0.863035, (const float)-0.10098, (const float)0.494949 };
// N079
// file dolphin.c line 168
static const float N079[3l] = { (const float)-0.88077, (const float)0.461448, (const float)0.106351 };
// N079_link1
// file whale.c line 164
static const float N079_link1[3l] = { (const float)0.585597, (const float)-0.808215, (const float)0.062174 };
// N080
// file dolphin.c line 169
static const float N080[3l] = { (const float)-0.88077, (const float)0.461448, (const float)0.106351 };
// N080_link1
// file whale.c line 165
static const float N080_link1[3l] = { (const float)0, (const float)1, (const float)0 };
// N081
// file dolphin.c line 170
static const float N081[3l] = { (const float)-0.571197, (const float)0.816173, (const float)0.087152 };
// N081_link1
// file whale.c line 166
static const float N081_link1[3l] = { (const float)1, (const float)0, (const float)0 };
// N082
// file dolphin.c line 171
static const float N082[3l] = { (const float)-0.88077, (const float)0.461448, (const float)0.106351 };
// N082_link1
// file whale.c line 167
static const float N082_link1[3l] = { (const float)0, (const float)1, (const float)0 };
// N083
// file dolphin.c line 172
static const float N083[3l] = { (const float)-0.571197, (const float)0.816173, (const float)0.087152 };
// N083_link1
// file whale.c line 168
static const float N083_link1[3l] = { (const float)-1, (const float)0, (const float)0 };
// N084
// file dolphin.c line 173
static const float N084[3l] = { (const float)-0.571197, (const float)0.816173, (const float)0.087152 };
// N084_link1
// file whale.c line 169
static const float N084_link1[3l] = { (const float)-0.478893, (const float)0.837129, (const float)-0.264343 };
// N085
// file dolphin.c line 174
static const float N085[3l] = { (const float)-0.88077, (const float)0.461448, (const float)0.106351 };
// N085_link1
// file whale.c line 170
static const float N085_link1[3l] = { (const float)0, (const float)1, (const float)0 };
// N086
// file dolphin.c line 175
static const float N086[3l] = { (const float)-0.571197, (const float)0.816173, (const float)0.087152 };
// N086_link1
// file whale.c line 171
static const float N086_link1[3l] = { (const float)0.763909, (const float)0.539455, (const float)-0.354163 };
// N087
// file dolphin.c line 176
static const float N087[3l] = { (const float)-0.88077, (const float)0.461448, (const float)0.106351 };
// N087_link1
// file whale.c line 172
static const float N087_link1[3l] = { (const float)0.446821, (const float)0.893642, (const float)0.041889 };
// N088
// file dolphin.c line 177
static const float N088[3l] = { (const float)-0.88077, (const float)0.461448, (const float)0.106351 };
// N088_link1
// file whale.c line 173
static const float N088_link1[3l] = { (const float)0.385134, (const float)-0.908288, (const float)0.163352 };
// N089
// file dolphin.c line 178
static const float N089[3l] = { (const float)-0.88077, (const float)0.461448, (const float)0.106351 };
// N089_link1
// file whale.c line 174
static const float N089_link1[3l] = { (const float)-0.605952, (const float)0.779253, (const float)-0.159961 };
// N090
// file dolphin.c line 179
static const float N090[3l] = { (const float)-0.88077, (const float)0.461448, (const float)0.106351 };
// N090_link1
// file whale.c line 175
static const float N090_link1[3l] = { (const float)0, (const float)1, (const float)0 };
// N091
// file dolphin.c line 180
static const float N091[3l] = { (const float)0, (const float)1, (const float)0 };
// N091_link1
// file whale.c line 176
static const float N091_link1[3l] = { (const float)0, (const float)1, (const float)0 };
// N092
// file dolphin.c line 181
static const float N092[3l] = { (const float)0, (const float)1, (const float)0 };
// N092_link1
// file whale.c line 177
static const float N092_link1[3l] = { (const float)0, (const float)1, (const float)0 };
// N093
// file dolphin.c line 182
static const float N093[3l] = { (const float)0, (const float)1, (const float)0 };
// N093_link1
// file whale.c line 178
static const float N093_link1[3l] = { (const float)0, (const float)1, (const float)0 };
// N094
// file dolphin.c line 183
static const float N094[3l] = { (const float)1, (const float)0, (const float)0 };
// N094_link1
// file whale.c line 179
static const float N094_link1[3l] = { (const float)1, (const float)0, (const float)0 };
// N095
// file dolphin.c line 184
static const float N095[3l] = { (const float)-1, (const float)0, (const float)0 };
// N095_link1
// file whale.c line 180
static const float N095_link1[3l] = { (const float)-1, (const float)0, (const float)0 };
// N096
// file whale.c line 181
static const float N096[3l] = { (const float)0.644444, (const float)-0.621516, (const float)0.445433 };
// N097
// file dolphin.c line 188
static const float N097[3l] = { (const float)-0.697296, (const float)0.702881, (const float)0.140491 };
// N097_link1
// file whale.c line 182
static const float N097_link1[3l] = { (const float)-0.760896, (const float)-0.474416, (const float)0.442681 };
// N098
// file dolphin.c line 189
static const float N098[3l] = { (const float)0.918864, (const float)0.340821, (const float)0.198819 };
// N098_link1
// file whale.c line 183
static const float N098_link1[3l] = { (const float)0.636888, (const float)-0.464314, (const float)0.615456 };
// N099
// file dolphin.c line 190
static const float N099[3l] = { (const float)-0.932737, (const float)0.201195, (const float)0.299202 };
// N099_link1
// file whale.c line 184
static const float N099_link1[3l] = { (const float)-0.710295, (const float)0.647038, (const float)0.277168 };
// N100
// file dolphin.c line 191
static const float N100[3l] = { (const float)0.029517, (const float)0.981679, (const float)0.188244 };
// N100_link1
// file whale.c line 185
static const float N100_link1[3l] = { (const float)0.009604, (const float)0.993655, (const float)0.112063 };
// N102
// file dolphin.c line 195
static const float N102[3l] = { (const float)0.813521, (const float)-0.204936, (const float)0.544229 };
// N110
// file dolphin.c line 205
static const float N110[3l] = { (const float)-0.78148, (const float)-0.384779, (const float)0.491155 };
// N111
// file dolphin.c line 206
static const float N111[3l] = { (const float)-0.722243, (const float)0.384927, (const float)0.574627 };
// N112
// file dolphin.c line 207
static const float N112[3l] = { (const float)-0.752278, (const float)0.502679, (const float)0.425901 };
// N113
// file dolphin.c line 208
static const float N113[3l] = { (const float)0.547257, (const float)0.36791, (const float)0.751766 };
// N114
// file dolphin.c line 209
static const float N114[3l] = { (const float)0.725949, (const float)-0.232568, (const float)0.647233 };
// N115
// file dolphin.c line 210
static const float N115[3l] = { (const float)-0.747182, (const float)-0.660786, (const float)0.07128 };
// N116
// file dolphin.c line 211
static const float N116[3l] = { (const float)0.931519, (const float)0.200748, (const float)0.30327 };
// N117
// file dolphin.c line 212
static const float N117[3l] = { (const float)-0.828928, (const float)0.313757, (const float)0.463071 };
// N118
// file dolphin.c line 213
static const float N118[3l] = { (const float)0.902554, (const float)-0.370967, (const float)0.218587 };
// N119
// file dolphin.c line 214
static const float N119[3l] = { (const float)-0.879257, (const float)-0.441851, (const float)0.177973 };
// N120
// file dolphin.c line 215
static const float N120[3l] = { (const float)0.642327, (const float)0.611901, (const float)0.461512 };
// N121
// file dolphin.c line 216
static const float N121[3l] = { (const float)0.964817, (const float)-0.202322, (const float)0.16791 };
// N122
// file dolphin.c line 217
static const float N122[3l] = { (const float)0, (const float)1, (const float)0 };
// P001
// file dolphin.c line 232
static float P001[3l] = { (float)5.68, (float)-300.95, (float)1324.7 };
// P001_link1
// file whale.c line 210
static float P001_link1[3l] = { (float)18.74, (float)13.19, (float)3.76 };
// P002
// file dolphin.c line 233
static const float P002[3l] = { (const float)338.69, (const float)-219.63, (const float)9677.03 };
// P002_link1
// file shark.c line 171
static float P002_link1[3l] = { (float)0, (float)-36.59, (float)5687.72 };
// P002_link2
// file whale.c line 211
static const float P002_link2[3l] = { (const float)0, (const float)390.42, (const float)10292.57 };
// P003
// file dolphin.c line 234
static const float P003[3l] = { (const float)12.18, (const float)474.59, (const float)9138.14 };
// P003_link1
// file shark.c line 172
static const float P003_link1[3l] = { (const float)90, (const float)114.73, (const float)724.38 };
// P003_link2
// file whale.c line 212
static const float P003_link2[3l] = { (const float)55.8, (const float)622.31, (const float)8254.35 };
// P004
// file shark.c line 173
static float P004[3l] = { (float)58.24, (float)-146.84, (float)262.35 };
// P004_link1
// file whale.c line 213
static const float P004_link1[3l] = { (const float)20.8, (const float)247.66, (const float)10652.13 };
// P005
// file dolphin.c line 238
static const float P005[3l] = { (const float)487.51, (const float)198.05, (const float)9350.78 };
// P005_link1
// file shark.c line 174
static const float P005_link1[3l] = { (const float)27.81, (const float)231.52, (const float)510.43 };
// P005_link2
// file whale.c line 214
static const float P005_link2[3l] = { (const float)487.51, (const float)198.05, (const float)9350.78 };
// P006
// file dolphin.c line 239
static const float P006[3l] = { (const float)-457.61, (const float)68.74, (const float)9427.85 };
// P006_link1
// file shark.c line 175
static const float P006_link1[3l] = { (const float)-27.81, (const float)230.43, (const float)509.76 };
// P006_link2
// file whale.c line 215
static const float P006_link2[3l] = { (const float)-457.61, (const float)199.04, (const float)9353.01 };
// P007
// file dolphin.c line 240
static const float P007[3l] = { (const float)156.52, (const float)-266.72, (const float)10311.68 };
// P007_link1
// file shark.c line 176
static float P007_link1[3l] = { (float)-46.09, (float)-146.83, (float)265.84 };
// P008
// file dolphin.c line 241
static const float P008[3l] = { (const float)-185.56, (const float)-266.51, (const float)10310.47 };
// P008_link1
// file shark.c line 177
static const float P008_link1[3l] = { (const float)-90, (const float)103.84, (const float)718.53 };
// P008_link2
// file whale.c line 219
static const float P008_link2[3l] = { (const float)-34.67, (const float)247.64, (const float)10663.71 };
// P009
// file dolphin.c line 242
static float P009[3l] = { (float)124.39, (float)-261.46, (float)1942.34 };
// P009_link1
// file shark.c line 178
static const float P009_link1[3l] = { (const float)-131.1, (const float)-165.92, (const float)834.85 };
// P009_link2
// file whale.c line 223
static float P009_link2[3l] = { (float)97.46, (float)67.63, (float)593.82 };
// P010
// file dolphin.c line 243
static float P010[3l] = { (float)-130.05, (float)-261.46, (float)1946.03 };
// P010_link1
// file shark.c line 179
static float P010_link1[3l] = { (float)-27.81, (float)-285.31, (float)500 };
// P010_link2
// file whale.c line 224
static float P010_link2[3l] = { (float)-84.33, (float)67.63, (float)588.18 };
// P011
// file dolphin.c line 244
static float P011[3l] = { (float)141.07, (float)-320.11, (float)1239.38 };
// P011_link1
// file shark.c line 180
static float P011_link1[3l] = { (float)27.81, (float)-285.32, (float)500 };
// P011_link2
// file whale.c line 225
static float P011_link2[3l] = { (float)118.69, (float)8.98, (float)-66.91 };
// P012
// file dolphin.c line 245
static float P012[3l] = { (float)156.48, (float)-360.12, (float)2073.41 };
// P012_link1
// file shark.c line 181
static const float P012_link1[3l] = { (const float)147.96, (const float)-170.89, (const float)845.5 };
// P012_link2
// file whale.c line 266
static float P012_link2[3l] = { (float)156.48, (float)-31.95, (float)924.54 };
// P013
// file dolphin.c line 246
static float P013[3l] = { (float)162, (float)-175.88, (float)2064.44 };
// P013_link1
// file shark.c line 182
static const float P013_link1[3l] = { (const float)180, (const float)0, (const float)2000 };
// P013_link2
// file whale.c line 267
static float P013_link2[3l] = { (float)162, (float)110.22, (float)924.54 };
// P014
// file dolphin.c line 247
static float P014[3l] = { (float)88.16, (float)-87.72, (float)2064.02 };
// P014_link1
// file shark.c line 183
static const float P014_link1[3l] = { (const float)145.62, (const float)352.67, (const float)2000 };
// P014_link2
// file whale.c line 268
static float P014_link2[3l] = { (float)88.16, (float)221.65, (float)924.54 };
// P015
// file dolphin.c line 248
static float P015[3l] = { (float)-65.21, (float)-96.13, (float)2064.02 };
// P015_link1
// file shark.c line 184
static const float P015_link1[3l] = { (const float)55.62, (const float)570.63, (const float)2000 };
// P015_link2
// file whale.c line 269
static float P015_link2[3l] = { (float)-65.21, (float)231.16, (float)924.54 };
// P016
// file dolphin.c line 249
static float P016[3l] = { (float)-156.48, (float)-180.96, (float)2064.44 };
// P016_link1
// file shark.c line 185
static const float P016_link1[3l] = { (const float)-55.62, (const float)570.64, (const float)2000 };
// P016_link2
// file whale.c line 270
static float P016_link2[3l] = { (float)-156.48, (float)121.97, (float)924.54 };
// P017
// file dolphin.c line 250
static float P017[3l] = { (float)-162, (float)-368.93, (float)2082.39 };
// P017_link1
// file shark.c line 186
static const float P017_link1[3l] = { (const float)-145.62, (const float)352.68, (const float)2000 };
// P017_link2
// file whale.c line 271
static float P017_link2[3l] = { (float)-162, (float)-23.93, (float)924.54 };
// P018
// file dolphin.c line 251
static float P018[3l] = { (float)-88.16, (float)-439.22, (float)2082.39 };
// P018_link1
// file shark.c line 187
static const float P018_link1[3l] = { (const float)-180, (const float)0.01, (const float)2000 };
// P018_link2
// file whale.c line 272
static float P018_link2[3l] = { (float)-88.16, (float)-139.1, (float)924.54 };
// P019
// file dolphin.c line 252
static float P019[3l] = { (float)65.21, (float)-440.32, (float)2083.39 };
// P019_link1
// file shark.c line 188
static const float P019_link1[3l] = { (const float)-178.2, (const float)-352.66, (const float)2001.61 };
// P019_link2
// file whale.c line 273
static float P019_link2[3l] = { (float)65.21, (float)-148.61, (float)924.54 };
// P020
// file dolphin.c line 253
static float P020[3l] = { (float)246.87, (float)-356.02, (float)2576.95 };
// P020_link1
// file shark.c line 189
static const float P020_link1[3l] = { (const float)-55.63, (const float)-570.63, (const float)2000 };
// P020_link2
// file whale.c line 274
static float P020_link2[3l] = { (float)246.87, (float)-98.73, (float)1783.04 };
// P021
// file dolphin.c line 254
static float P021[3l] = { (float)253.17, (float)-111.15, (float)2567.15 };
// P021_link1
// file shark.c line 190
static const float P021_link1[3l] = { (const float)55.62, (const float)-570.64, (const float)2000 };
// P021_link2
// file whale.c line 275
static float P021_link2[3l] = { (float)253.17, (float)127.76, (float)1783.04 };
// P022
// file dolphin.c line 255
static float P022[3l] = { (float)132.34, (float)51.41, (float)2559.84 };
// P022_link1
// file shark.c line 191
static const float P022_link1[3l] = { (const float)179.91, (const float)-352.69, (const float)1998.39 };
// P022_link2
// file whale.c line 276
static float P022_link2[3l] = { (float)132.34, (float)270.77, (float)1783.04 };
// P023
// file dolphin.c line 256
static float P023[3l] = { (float)-97.88, (float)40.44, (float)2567.15 };
// P023_link1
// file shark.c line 192
static float P023_link1[3l] = { (float)150, (float)0, (float)3000 };
// P023_link2
// file whale.c line 277
static float P023_link2[3l] = { (float)-97.88, (float)285.04, (float)1783.04 };
// P024
// file dolphin.c line 257
static float P024[3l] = { (float)-222.97, (float)-117.49, (float)2567.15 };
// P024_link1
// file shark.c line 193
static float P024_link1[3l] = { (float)121.35, (float)293.89, (float)3000 };
// P024_link2
// file whale.c line 278
static float P024_link2[3l] = { (float)-222.97, (float)139.8, (float)1783.04 };
// P025
// file dolphin.c line 258
static float P025[3l] = { (float)-252.22, (float)-371.53, (float)2569.92 };
// P025_link1
// file shark.c line 194
static float P025_link1[3l] = { (float)46.35, (float)502.93, (float)2883.09 };
// P025_link2
// file whale.c line 279
static float P025_link2[3l] = { (float)-225.29, (float)-86.68, (float)1783.04 };
// P026
// file dolphin.c line 259
static float P026[3l] = { (float)-108.44, (float)-518.19, (float)2586.75 };
// P026_link1
// file shark.c line 195
static float P026_link1[3l] = { (float)-46.35, (float)497.45, (float)2877.24 };
// P026_link2
// file whale.c line 280
static float P026_link2[3l] = { (float)-108.44, (float)-224.15, (float)1783.04 };
// P027
// file dolphin.c line 260
static float P027[3l] = { (float)97.88, (float)-524.79, (float)2586.75 };
// P027_link1
// file shark.c line 196
static float P027_link1[3l] = { (float)-121.35, (float)293.9, (float)3000 };
// P027_link2
// file whale.c line 281
static float P027_link2[3l] = { (float)97.88, (float)-221.56, (float)1783.04 };
// P028
// file dolphin.c line 261
static float P028[3l] = { (float)370.03, (float)-421.19, (float)3419.7 };
// P028_link1
// file shark.c line 197
static float P028_link1[3l] = { (float)-150, (float)0, (float)3000 };
// P028_link2
// file whale.c line 282
static float P028_link2[3l] = { (float)410.55, (float)-200.66, (float)3213.87 };
// P029
// file dolphin.c line 262
static float P029[3l] = { (float)351.15, (float)-16.98, (float)3423.17 };
// P029_link1
// file shark.c line 198
static float P029_link1[3l] = { (float)-152.21, (float)-304.84, (float)2858.68 };
// P029_link2
// file whale.c line 283
static float P029_link2[3l] = { (float)432.19, (float)148.42, (float)3213.87 };
// P030
// file dolphin.c line 263
static float P030[3l] = { (float)200.66, (float)248.46, (float)3430.37 };
// P030_link1
// file shark.c line 199
static float P030_link1[3l] = { (float)-46.36, (float)-475.52, (float)3000 };
// P030_link2
// file whale.c line 284
static float P030_link2[3l] = { (float)200.66, (float)410.55, (float)3213.87 };
// P031
// file dolphin.c line 264
static float P031[3l] = { (float)-148.42, (float)235.02, (float)3417.91 };
// P031_link1
// file shark.c line 200
static float P031_link1[3l] = { (float)46.35, (float)-475.53, (float)3000 };
// P031_link2
// file whale.c line 285
static float P031_link2[3l] = { (float)-148.42, (float)432.19, (float)3213.87 };
// P032
// file dolphin.c line 265
static float P032[3l] = { (float)-360.21, (float)-30.27, (float)3416.84 };
// P032_link1
// file shark.c line 201
static float P032_link1[3l] = { (float)155.64, (float)-304.87, (float)2863.5 };
// P032_link2
// file whale.c line 286
static float P032_link2[3l] = { (float)-407.48, (float)171.88, (float)3213.87 };
// P033
// file dolphin.c line 266
static float P033[3l] = { (float)-357.9, (float)-414.89, (float)3407.04 };
// P033_link1
// file shark.c line 202
static float P033_link1[3l] = { (float)90, (float)0, (float)4000 };
// P033_link2
// file whale.c line 287
static float P033_link2[3l] = { (float)-432.19, (float)-148.42, (float)3213.87 };
// P034
// file dolphin.c line 267
static float P034[3l] = { (float)-148.88, (float)-631.35, (float)3409.9 };
// P034_link1
// file shark.c line 203
static float P034_link1[3l] = { (float)72.81, (float)176.33, (float)4000 };
// P034_link2
// file whale.c line 288
static float P034_link2[3l] = { (float)-148.88, (float)-309.74, (float)3213.87 };
// P035
// file dolphin.c line 268
static float P035[3l] = { (float)156.38, (float)-632.59, (float)3419.7 };
// P035_link1
// file shark.c line 204
static float P035_link1[3l] = { (float)27.81, (float)285.32, (float)4000 };
// P035_link2
// file whale.c line 289
static float P035_link2[3l] = { (float)156.38, (float)-320.17, (float)3213.87 };
// P036
// file dolphin.c line 269
static float P036[3l] = { (float)462.61, (float)-469.21, (float)4431.51 };
// P036_link1
// file shark.c line 205
static float P036_link1[3l] = { (float)-27.81, (float)285.32, (float)4000 };
// P036_link2
// file whale.c line 290
static float P036_link2[3l] = { (float)523.39, (float)-303.81, (float)4424.57 };
// P037
// file dolphin.c line 270
static float P037[3l] = { (float)466.6, (float)102.25, (float)4434.98 };
// P037_link1
// file shark.c line 206
static float P037_link1[3l] = { (float)-72.81, (float)176.34, (float)4000 };
// P037_link2
// file whale.c line 291
static float P037_link2[3l] = { (float)574.66, (float)276.84, (float)4424.57 };
// P038
// file dolphin.c line 271
static float P038[3l] = { (float)243.05, (float)474.34, (float)4562.02 };
// P038_link1
// file shark.c line 207
static float P038_link1[3l] = { (float)-90, (float)0, (float)4000 };
// P038_link2
// file whale.c line 292
static float P038_link2[3l] = { (float)243.05, (float)492.5, (float)4424.57 };
// P039
// file dolphin.c line 272
static float P039[3l] = { (float)-191.23, (float)474.4, (float)4554.42 };
// P039_link1
// file shark.c line 208
static float P039_link1[3l] = { (float)-72.81, (float)-176.33, (float)4000 };
// P039_link2
// file whale.c line 293
static float P039_link2[3l] = { (float)-191.23, (float)520.13, (float)4424.57 };
// P040
// file dolphin.c line 273
static float P040[3l] = { (float)-476.12, (float)111.05, (float)4451.11 };
// P040_link1
// file shark.c line 209
static float P040_link1[3l] = { (float)-27.81, (float)-285.31, (float)4000 };
// P040_link2
// file whale.c line 294
static float P040_link2[3l] = { (float)-523.39, (float)304.01, (float)4424.57 };
// P041
// file dolphin.c line 274
static float P041[3l] = { (float)-473.36, (float)-470.74, (float)4444.78 };
// P041_link1
// file shark.c line 210
static float P041_link1[3l] = { (float)27.81, (float)-285.32, (float)4000 };
// P041_link2
// file whale.c line 295
static float P041_link2[3l] = { (float)-574.66, (float)-231.83, (float)4424.57 };
// P042
// file dolphin.c line 275
static float P042[3l] = { (float)-266.95, (float)-748.41, (float)4447.78 };
// P042_link1
// file shark.c line 211
static float P042_link1[3l] = { (float)72.81, (float)-176.34, (float)4000 };
// P042_link2
// file whale.c line 296
static float P042_link2[3l] = { (float)-266.95, (float)-578.17, (float)4424.57 };
// P043
// file dolphin.c line 276
static float P043[3l] = { (float)211.14, (float)-749.91, (float)4429.73 };
// P043_link1
// file shark.c line 212
static float P043_link1[3l] = { (float)30, (float)0, (float)5000 };
// P043_link2
// file whale.c line 297
static float P043_link2[3l] = { (float)211.14, (float)-579.67, (float)4424.57 };
// P044
// file dolphin.c line 277
static float P044[3l] = { (float)680.57, (float)-370.27, (float)5943.46 };
// P044_link1
// file shark.c line 213
static float P044_link1[3l] = { (float)24.27, (float)58.78, (float)5000 };
// P044_link2
// file whale.c line 298
static float P044_link2[3l] = { (float)680.57, (float)-370.27, (float)5943.46 };
// P045
// file dolphin.c line 278
static float P045[3l] = { (float)834.01, (float)363.09, (float)6360.63 };
// P045_link1
// file shark.c line 214
static float P045_link1[3l] = { (float)9.27, (float)95.11, (float)5000 };
// P045_link2
// file whale.c line 299
static float P045_link2[3l] = { (float)834.01, (float)363.09, (float)5943.46 };
// P046
// file dolphin.c line 279
static float P046[3l] = { (float)371.29, (float)804.51, (float)6486.26 };
// P046_link1
// file shark.c line 215
static float P046_link1[3l] = { (float)-9.27, (float)95.11, (float)5000 };
// P046_link2
// file whale.c line 300
static float P046_link2[3l] = { (float)371.29, (float)614.13, (float)5943.46 };
// P047
// file dolphin.c line 280
static float P047[3l] = { (float)-291.43, (float)797.22, (float)6494.28 };
// P047_link1
// file shark.c line 216
static float P047_link1[3l] = { (float)-24.27, (float)58.78, (float)5000 };
// P047_link2
// file whale.c line 301
static float P047_link2[3l] = { (float)-291.43, (float)621.86, (float)5943.46 };
// P048
// file dolphin.c line 281
static float P048[3l] = { (float)-784.13, (float)370.75, (float)6378.01 };
// P048_link1
// file shark.c line 217
static float P048_link1[3l] = { (float)-30, (float)0, (float)5000 };
// P048_link2
// file whale.c line 302
static float P048_link2[3l] = { (float)-784.13, (float)362.6, (float)5943.46 };
// P049
// file dolphin.c line 282
static float P049[3l] = { (float)-743.29, (float)-325.82, (float)5943.46 };
// P049_link1
// file shark.c line 218
static float P049_link1[3l] = { (float)-24.27, (float)-58.78, (float)5000 };
// P049_link2
// file whale.c line 303
static float P049_link2[3l] = { (float)-743.29, (float)-325.82, (float)5943.46 };
// P050
// file dolphin.c line 283
static float P050[3l] = { (float)-383.24, (float)-804.77, (float)5943.46 };
// P050_link1
// file shark.c line 219
static float P050_link1[3l] = { (float)-9.27, (float)-95.1, (float)5000 };
// P050_link2
// file whale.c line 304
static float P050_link2[3l] = { (float)-383.24, (float)-804.77, (float)5943.46 };
// P051
// file dolphin.c line 284
static float P051[3l] = { (float)283.47, (float)-846.09, (float)5943.46 };
// P051_link1
// file shark.c line 220
static float P051_link1[3l] = { (float)9.27, (float)-95.11, (float)5000 };
// P051_link2
// file whale.c line 305
static float P051_link2[3l] = { (float)283.47, (float)-846.09, (float)5943.46 };
// P052
// file dolphin.c line 338
static const float P052[3l] = { (const float)599.09, (const float)-300.15, (const float)7894.03 };
// P052_link1
// file shark.c line 221
static float P052_link1[3l] = { (float)24.27, (float)-58.78, (float)5000 };
// P052_link2
// file whale.c line 306
static const float P052_link2[3l] = { (const float)599.09, (const float)-332.24, (const float)7902.59 };
// P053
// file dolphin.c line 339
static const float P053[3l] = { (const float)735.48, (const float)306.26, (const float)7911.92 };
// P053_link1
// file whale.c line 307
static const float P053_link1[3l] = { (const float)735.48, (const float)306.26, (const float)7911.92 };
// P054
// file dolphin.c line 340
static const float P054[3l] = { (const float)246.22, (const float)558.53, (const float)8460.5 };
// P054_link1
// file whale.c line 308
static const float P054_link1[3l] = { (const float)321.55, (const float)558.53, (const float)7902.59 };
// P055
// file dolphin.c line 341
static const float P055[3l] = { (const float)-230.41, (const float)559.84, (const float)8473.23 };
// P055_link1
// file whale.c line 309
static const float P055_link1[3l] = { (const float)-260.54, (const float)559.84, (const float)7902.59 };
// P056
// file dolphin.c line 342
static const float P056[3l] = { (const float)-698.66, (const float)320.83, (const float)7902.59 };
// P056_link1
// file whale.c line 310
static const float P056_link1[3l] = { (const float)-698.66, (const float)320.83, (const float)7902.59 };
// P057
// file dolphin.c line 343
static const float P057[3l] = { (const float)-643.29, (const float)-299.16, (const float)7902.59 };
// P057_link1
// file whale.c line 311
static const float P057_link1[3l] = { (const float)-643.29, (const float)-299.16, (const float)7902.59 };
// P058
// file dolphin.c line 344
static const float P058[3l] = { (const float)-341.47, (const float)-719.3, (const float)7902.59 };
// P058_link1
// file shark.c line 229
static const float P058_link1[3l] = { (const float)0, (const float)1212.72, (const float)2703.08 };
// P058_link2
// file whale.c line 312
static const float P058_link2[3l] = { (const float)-341.47, (const float)-719.3, (const float)7902.59 };
// P059
// file dolphin.c line 345
static const float P059[3l] = { (const float)252.57, (const float)-756.12, (const float)7902.59 };
// P059_link1
// file shark.c line 230
static const float P059_link1[3l] = { (const float)50.36, (const float)0, (const float)108.14 };
// P059_link2
// file whale.c line 313
static const float P059_link2[3l] = { (const float)252.57, (const float)-756.12, (const float)7902.59 };
// P060
// file dolphin.c line 346
static const float P060[3l] = { (const float)458.39, (const float)-265.31, (const float)9355.44 };
// P060_link1
// file shark.c line 231
static const float P060_link1[3l] = { (const float)-22.18, (const float)0, (const float)108.14 };
// P060_link2
// file whale.c line 314
static const float P060_link2[3l] = { (const float)458.39, (const float)-265.31, (const float)9355.44 };
// P061
// file shark.c line 232
static float P061[3l] = { (float)0, (float)1181.61, (float)6344.65 };
// P061_link1
// file whale.c line 316
static float P061_link1[3l] = { (float)353.63, (float)138.7, (float)10214.2 };
// P062
// file dolphin.c line 350
static const float P062[3l] = { (const float)224.04, (const float)338.75, (const float)9450.3 };
// P062_link1
// file shark.c line 233
static const float P062_link1[3l] = { (const float)516.45, (const float)-887.08, (const float)2535.45 };
// P062_link2
// file whale.c line 317
static const float P062_link2[3l] = { (const float)224.04, (const float)438.98, (const float)9364.77 };
// P063
// file dolphin.c line 351
static const float P063[3l] = { (const float)-165.71, (const float)341.04, (const float)9462.35 };
// P063_link1
// file shark.c line 234
static const float P063_link1[3l] = { (const float)-545.69, (const float)-879.31, (const float)2555.63 };
// P063_link2
// file whale.c line 318
static const float P063_link2[3l] = { (const float)-165.71, (const float)441.27, (const float)9355.44 };
// P064
// file dolphin.c line 352
static const float P064[3l] = { (const float)-298.11, (const float)110.13, (const float)10180.37 };
// P064_link1
// file shark.c line 235
static const float P064_link1[3l] = { (const float)618.89, (const float)-1005.64, (const float)2988.32 };
// P064_link2
// file whale.c line 320
static float P064_link2[3l] = { (float)-326.4, (float)162.04, (float)10209.54 };
// P065
// file dolphin.c line 353
static const float P065[3l] = { (const float)-473.99, (const float)-219.71, (const float)9355.44 };
// P065_link1
// file shark.c line 236
static const float P065_link1[3l] = { (const float)-635.37, (const float)-1014.79, (const float)2938.68 };
// P065_link2
// file whale.c line 321
static const float P065_link2[3l] = { (const float)-473.99, (const float)-219.71, (const float)9355.44 };
// P066
// file dolphin.c line 354
static const float P066[3l] = { (const float)-211.97, (const float)-479.87, (const float)9355.44 };
// P066_link1
// file shark.c line 237
static const float P066_link1[3l] = { (const float)0, (const float)1374.43, (const float)3064.18 };
// P066_link2
// file whale.c line 322
static const float P066_link2[3l] = { (const float)-211.97, (const float)-479.87, (const float)9355.44 };
// P067
// file dolphin.c line 355
static const float P067[3l] = { (const float)192.86, (const float)-491.45, (const float)9348.73 };
// P067_link1
// file whale.c line 323
static const float P067_link1[3l] = { (const float)192.86, (const float)-504.03, (const float)9355.44 };
// P068
// file dolphin.c line 356
static float P068[3l] = { (float)-136.29, (float)-319.84, (float)1228.73 };
// P068_link1
// file whale.c line 333
static float P068_link1[3l] = { (float)-112.44, (float)9.25, (float)-64.42 };
// P069
// file dolphin.c line 357
static float P069[3l] = { (float)1111.17, (float)-314.14, (float)1314.19 };
// P069_link1
// file shark.c line 242
static float P069_link1[3l] = { (float)0, (float)-418.25, (float)5765.04 };
// P069_link2
// file whale.c line 334
static float P069_link2[3l] = { (float)1155.63, (float)0, (float)-182.46 };
// P070
// file dolphin.c line 358
static float P070[3l] = { (float)-1167.34, (float)-321.61, (float)1319.45 };
// P070_link1
// file shark.c line 243
static float P070_link1[3l] = { (float)0, (float)1266.91, (float)6629.6 };
// P070_link2
// file whale.c line 335
static float P070_link2[3l] = { (float)-1143.13, (float)0, (float)-181.54 };
// P071
// file dolphin.c line 359
static float P071[3l] = { (float)1404.86, (float)-306.66, (float)1235.45 };
// P071_link1
// file shark.c line 244
static const float P071_link1[3l] = { (const float)-139.12, (const float)-124.96, (const float)997.98 };
// P071_link2
// file whale.c line 336
static float P071_link2[3l] = { (float)1424.23, (float)0, (float)-322.09 };
// P072
// file dolphin.c line 360
static float P072[3l] = { (float)-1409.73, (float)-314.14, (float)1247.66 };
// P072_link1
// file shark.c line 245
static const float P072_link1[3l] = { (const float)-139.24, (const float)-110.18, (const float)1020.68 };
// P072_link2
// file whale.c line 337
static float P072_link2[3l] = { (float)-1368.01, (float)0, (float)-310.38 };
// P073
// file dolphin.c line 361
static float P073[3l] = { (float)1254.01, (float)-296.87, (float)1544.58 };
// P073_link1
// file shark.c line 246
static const float P073_link1[3l] = { (const float)-137.33, (const float)-94.52, (const float)1022.63 };
// P073_link2
// file whale.c line 338
static float P073_link2[3l] = { (float)1255.57, (float)2.31, (float)114.05 };
// P074
// file dolphin.c line 362
static float P074[3l] = { (float)-1262.09, (float)-291.7, (float)1504.26 };
// P074_link1
// file shark.c line 247
static const float P074_link1[3l] = { (const float)-137.03, (const float)-79.91, (const float)996.89 };
// P074_link2
// file whale.c line 339
static float P074_link2[3l] = { (float)-1149.38, (float)0, (float)117.12 };
// P075
// file dolphin.c line 363
static float P075[3l] = { (float)965.71, (float)-269.26, (float)1742.65 };
// P075_link1
// file shark.c line 248
static const float P075_link1[3l] = { (const float)-135.21, (const float)-91.48, (const float)969.14 };
// P075_link2
// file whale.c line 340
static float P075_link2[3l] = { (float)718.36, (float)0, (float)433.36 };
// P076
// file dolphin.c line 364
static float P076[3l] = { (float)-900.97, (float)-276.74, (float)1726.07 };
// P076_link1
// file shark.c line 249
static const float P076_link1[3l] = { (const float)-135.39, (const float)-110.87, (const float)968.76 };
// P076_link2
// file whale.c line 341
static float P076_link2[3l] = { (float)-655.9, (float)0, (float)433.36 };
// P077
// file dolphin.c line 374
static const float P077[3l] = { (const float)1058, (const float)-448.81, (const float)8194.66 };
// P077_link1
// file shark.c line 250
static const float P077_link1[3l] = { (const float)150.23, (const float)-78.44, (const float)995.53 };
// P077_link2
// file whale.c line 342
static const float P077_link2[3l] = { (const float)1058, (const float)-2.66, (const float)7923.51 };
// P078
// file dolphin.c line 375
static const float P078[3l] = { (const float)-1016.51, (const float)-456.43, (const float)8190.62 };
// P078_link1
// file shark.c line 251
static const float P078_link1[3l] = { (const float)152.79, (const float)-92.76, (const float)1018.46 };
// P078_link2
// file whale.c line 343
static const float P078_link2[3l] = { (const float)-1016.51, (const float)-15.47, (const float)7902.87 };
// P079
// file dolphin.c line 376
static const float P079[3l] = { (const float)-1515.96, (const float)-676.45, (const float)7754.93 };
// P079_link1
// file shark.c line 252
static const float P079_link1[3l] = { (const float)154.19, (const float)-110.2, (const float)1020.55 };
// P079_link2
// file whale.c line 344
static const float P079_link2[3l] = { (const float)-1363.99, (const float)-484.5, (const float)7593.38 };
// P080
// file dolphin.c line 377
static const float P080[3l] = { (const float)1856.75, (const float)-830.34, (const float)7296.56 };
// P080_link1
// file shark.c line 253
static const float P080_link1[3l] = { (const float)151.33, (const float)-124.15, (const float)993.77 };
// P080_link2
// file whale.c line 345
static const float P080_link2[3l] = { (const float)1478.09, (const float)-861.47, (const float)7098.12 };
// P081
// file dolphin.c line 378
static const float P081[3l] = { (const float)1472.16, (const float)-497.38, (const float)7399.68 };
// P081_link1
// file shark.c line 254
static const float P081_link1[3l] = { (const float)150.49, (const float)-111.19, (const float)969.86 };
// P081_link2
// file whale.c line 346
static const float P081_link2[3l] = { (const float)1338.06, (const float)-284.68, (const float)7024.15 };
// P082
// file dolphin.c line 379
static const float P082[3l] = { (const float)-1775.26, (const float)-829.51, (const float)7298.46 };
// P082_link1
// file shark.c line 255
static const float P082_link1[3l] = { (const float)150.79, (const float)-92.41, (const float)969.7 };
// P082_link2
// file whale.c line 347
static const float P082_link2[3l] = { (const float)-1545.51, (const float)-860.64, (const float)7106.6 };
// P083
// file dolphin.c line 380
static const float P083[3l] = { (const float)911.09, (const float)-252.51, (const float)7510.99 };
// P083_link1
// file whale.c line 348
static const float P083_link1[3l] = { (const float)1063.19, (const float)-70.46, (const float)7466.6 };
// P084
// file dolphin.c line 381
static const float P084[3l] = { (const float)-1451.94, (const float)-495.62, (const float)7384.3 };
// P084_link1
// file whale.c line 349
static const float P084_link1[3l] = { (const float)-1369.18, (const float)-288.11, (const float)7015.34 };
// P085
// file dolphin.c line 382
static const float P085[3l] = { (const float)1598.75, (const float)-669.26, (const float)7769.9 };
// P085_link1
// file whale.c line 350
static const float P085_link1[3l] = { (const float)1348.44, (const float)-482.5, (const float)7591.41 };
// P086
// file dolphin.c line 383
static const float P086[3l] = { (const float)-836.53, (const float)-250.08, (const float)7463.25 };
// P086_link1
// file whale.c line 351
static const float P086_link1[3l] = { (const float)-1015.45, (const float)-96.8, (const float)7474.86 };
// P087
// file dolphin.c line 384
static const float P087[3l] = { (const float)722.87, (const float)-158.18, (const float)8006.41 };
// P087_link1
// file whale.c line 352
static const float P087_link1[3l] = { (const float)731.04, (const float)148.38, (const float)7682.58 };
// P088
// file dolphin.c line 385
static const float P088[3l] = { (const float)-688.86, (const float)-162.28, (const float)7993.89 };
// P088_link1
// file whale.c line 353
static const float P088_link1[3l] = { (const float)-697.03, (const float)151.82, (const float)7668.81 };
// P089
// file dolphin.c line 386
static const float P089[3l] = { (const float)-626.92, (const float)-185.3, (const float)8364.98 };
// P089_link1
// file whale.c line 354
static const float P089_link1[3l] = { (const float)-686.82, (const float)157.09, (const float)7922.29 };
// P090
// file dolphin.c line 387
static const float P090[3l] = { (const float)647.72, (const float)-189.46, (const float)8354.99 };
// P090_link1
// file whale.c line 355
static const float P090_link1[3l] = { (const float)724.73, (const float)147.75, (const float)7931.39 };
// P091
// file dolphin.c line 388
static float P091[3l] = { (float)0, (float)835.01, (float)5555.62 };
// P091_link1
// file whale.c line 361
static float P091_link1[3l] = { (float)0, (float)327.1, (float)2346.55 };
// P092
// file dolphin.c line 389
static float P092[3l] = { (float)0, (float)1350.18, (float)5220.86 };
// P092_link1
// file whale.c line 362
static float P092_link1[3l] = { (float)0, (float)552.28, (float)2311.31 };
// P093
// file dolphin.c line 390
static float P093[3l] = { (float)0, (float)1422.94, (float)5285.27 };
// P093_link1
// file whale.c line 363
static float P093_link1[3l] = { (float)0, (float)721.16, (float)2166.41 };
// P094
// file dolphin.c line 391
static float P094[3l] = { (float)0, (float)1296.75, (float)5650.19 };
// P094_link1
// file whale.c line 364
static float P094_link1[3l] = { (float)0, (float)693.42, (float)2388.8 };
// P095
// file dolphin.c line 392
static float P095[3l] = { (float)0, (float)795.63, (float)6493.88 };
// P095_link1
// file whale.c line 365
static float P095_link1[3l] = { (float)0, (float)389.44, (float)2859.97 };
// P096
// file whale.c line 370
static float P096[3l] = { (float)222.02, (float)-183.67, (float)10266.89 };
// P097
// file dolphin.c line 401
static float P097[3l] = { (float)-194.91, (float)-357.14, (float)10313.32 };
// P097_link1
// file whale.c line 371
static float P097_link1[3l] = { (float)-128.9, (float)-182.7, (float)10266.89 };
// P098
// file dolphin.c line 402
static float P098[3l] = { (float)135.35, (float)-357.66, (float)10307.94 };
// P098_link1
// file whale.c line 372
static float P098_link1[3l] = { (float)41.04, (float)88.31, (float)10659.36 };
// P099
// file dolphin.c line 405
static const float P099[3l] = { (const float)-380.53, (const float)-221.14, (const float)9677.98 };
// P099_link1
// file whale.c line 373
static float P099_link1[3l] = { (float)-48.73, (float)88.3, (float)10659.36 };
// P100
// file dolphin.c line 406
static const float P100[3l] = { (const float)0, (const float)412.99, (const float)9629.33 };
// P100_link1
// file whale.c line 374
static const float P100_link1[3l] = { (const float)0, (const float)603.42, (const float)9340.68 };
// P102
// file dolphin.c line 410
static float P102[3l] = { (float)59.51, (float)-412.55, (float)10677.58 };
// P103
// file dolphin.c line 412
static const float P103[3l] = { (const float)6.5, (const float)484.74, (const float)9009.94 };
// P104
// file whale.c line 380
static const float P104[3l] = { (const float)-9.86, (const float)567.62, (const float)7858.65 };
// P105
// file dolphin.c line 416
static const float P105[3l] = { (const float)-41.86, (const float)476.51, (const float)9078.17 };
// P105_link1
// file whale.c line 381
static const float P105_link1[3l] = { (const float)31.96, (const float)565.27, (const float)7908.46 };
// P106
// file whale.c line 382
static const float P106[3l] = { (const float)22.75, (const float)568.13, (const float)7782.83 };
// P107
// file whale.c line 383
static const float P107[3l] = { (const float)58.93, (const float)568.42, (const float)7775.94 };
// P108
// file dolphin.c line 421
static const float P108[3l] = { (const float)49.2, (const float)476.83, (const float)9078.24 };
// P108_link1
// file whale.c line 384
static const float P108_link1[3l] = { (const float)55.91, (const float)565.59, (const float)7905.86 };
// P109
// file whale.c line 385
static const float P109[3l] = { (const float)99.21, (const float)566, (const float)7858.65 };
// P110
// file dolphin.c line 425
static float P110[3l] = { (float)-187.62, (float)-410.04, (float)10674.12 };
// P110_link1
// file whale.c line 386
static const float P110_link1[3l] = { (const float)-498.83, (const float)148.14, (const float)9135.1 };
// P111
// file dolphin.c line 427
static float P111[3l] = { (float)-184.25, (float)-318.7, (float)10723.88 };
// P111_link1
// file whale.c line 387
static const float P111_link1[3l] = { (const float)-495.46, (const float)133.24, (const float)9158.48 };
// P112
// file dolphin.c line 429
static const float P112[3l] = { (const float)-179.61, (const float)-142.81, (const float)10670.26 };
// P112_link1
// file whale.c line 388
static const float P112_link1[3l] = { (const float)-490.82, (const float)146.23, (const float)9182.76 };
// P113
// file dolphin.c line 430
static const float P113[3l] = { (const float)57.43, (const float)-147.94, (const float)10675.26 };
// P113_link1
// file whale.c line 389
static const float P113_link1[3l] = { (const float)-489.55, (const float)174.11, (const float)9183.66 };
// P114
// file dolphin.c line 431
static const float P114[3l] = { (const float)54.06, (const float)-218.9, (const float)10712.44 };
// P114_link1
// file whale.c line 390
static const float P114_link1[3l] = { (const float)-492.92, (const float)189, (const float)9160.28 };
// P115
// file dolphin.c line 432
static const float P115[3l] = { (const float)-186.35, (const float)-212.09, (const float)10713.76 };
// P115_link1
// file whale.c line 391
static const float P115_link1[3l] = { (const float)-497.56, (const float)176.02, (const float)9136 };
// P116
// file dolphin.c line 433
static const float P116[3l] = { (const float)205.9, (const float)-84.61, (const float)10275.97 };
// P116_link1
// file whale.c line 392
static const float P116_link1[3l] = { (const float)526.54, (const float)169.68, (const float)9137.7 };
// P117
// file dolphin.c line 434
static const float P117[3l] = { (const float)-230.96, (const float)-83.26, (const float)10280.09 };
// P117_link1
// file whale.c line 393
static const float P117_link1[3l] = { (const float)523.49, (const float)184.85, (const float)9161.42 };
// P118
// file dolphin.c line 437
static float P118[3l] = { (float)216.78, (float)-509.17, (float)10098.94 };
// P118_link1
// file whale.c line 394
static const float P118_link1[3l] = { (const float)518.56, (const float)171.78, (const float)9186.06 };
// P119
// file dolphin.c line 438
static float P119[3l] = { (float)-313.21, (float)-510.79, (float)10102.62 };
// P119_link1
// file whale.c line 395
static const float P119_link1[3l] = { (const float)516.68, (const float)143.53, (const float)9186.98 };
// P120
// file dolphin.c line 439
static const float P120[3l] = { (const float)217.95, (const float)96.34, (const float)10161.62 };
// P120_link1
// file whale.c line 396
static const float P120_link1[3l] = { (const float)519.73, (const float)128.36, (const float)9163.26 };
// P121
// file dolphin.c line 440
static float P121[3l] = { (float)71.99, (float)-319.74, (float)10717.7 };
// P121_link1
// file whale.c line 397
static const float P121_link1[3l] = { (const float)524.66, (const float)141.43, (const float)9138.62 };
// P122
// file dolphin.c line 442
static float P122[3l] = { (float)0, (float)602.74, (float)5375.84 };
// P123
// file dolphin.c line 444
static const float P123[3l] = { (const float)-448.94, (const float)-203.14, (const float)9499.6 };
// P124
// file dolphin.c line 445
static const float P124[3l] = { (const float)-442.64, (const float)-185.2, (const float)9528.07 };
// P125
// file dolphin.c line 446
static const float P125[3l] = { (const float)-441.07, (const float)-148.05, (const float)9528.07 };
// P126
// file dolphin.c line 447
static const float P126[3l] = { (const float)-443.43, (const float)-128.84, (const float)9499.6 };
// P127
// file dolphin.c line 448
static const float P127[3l] = { (const float)-456.87, (const float)-146.78, (const float)9466.67 };
// P128
// file dolphin.c line 449
static const float P128[3l] = { (const float)-453.68, (const float)-183.93, (const float)9466.67 };
// P129
// file dolphin.c line 450
static const float P129[3l] = { (const float)428.43, (const float)-124.08, (const float)9503.03 };
// P130
// file dolphin.c line 451
static const float P130[3l] = { (const float)419.73, (const float)-142.14, (const float)9534.56 };
// P131
// file dolphin.c line 452
static const float P131[3l] = { (const float)419.92, (const float)-179.96, (const float)9534.56 };
// P132
// file dolphin.c line 453
static const float P132[3l] = { (const float)431.2, (const float)-199.73, (const float)9505.26 };
// P133
// file dolphin.c line 454
static const float P133[3l] = { (const float)442.28, (const float)-181.67, (const float)9475.96 };
// P134
// file dolphin.c line 455
static const float P134[3l] = { (const float)442.08, (const float)-143.84, (const float)9475.96 };
// XA_WM_DELETE_WINDOW
// file screenhack.c line 263
static unsigned long int XA_WM_DELETE_WINDOW;
// XA_WM_PROTOCOLS
// file screenhack.c line 263
static unsigned long int XA_WM_PROTOCOLS;
// XtShellStrings
// file /usr/include/X11/Shell.h line 189
extern const char XtShellStrings[];
// XtStrings
// file /usr/include/X11/StringDefs.h line 316
extern const char XtStrings[];
// _cache_line_size
// file thread_util.c line 288
static signed int _cache_line_size = (signed int)sizeof(void *) /*8ul*/ ;
// _has_pthread
// file thread_util.c line 287
static signed int _has_pthread = 0;
// _has_threads
// file async_netdb.c line 37
static signed int _has_threads;
// a
// file yarandom.c line 73
static unsigned int a[55l] = { 035340171546, (unsigned int)010401501101, 022364657325, 024130436022, (unsigned int)002167303062, 037570375137, 037210607110, (unsigned int)016272055420, 023011770546, (unsigned int)017143426366, (unsigned int)014753657433, 021657231332, 023553406142, (unsigned int)004236526362, (unsigned int)010365611275, (unsigned int)007117336710, (unsigned int)011051276551, (unsigned int)002362132524, (unsigned int)001011540233, (unsigned int)012162531646, (unsigned int)007056762337, (unsigned int)006631245521, (unsigned int)014164542224, 032633236305, 023342700176, (unsigned int)002433062234, (unsigned int)015257225043, 026762051606, (unsigned int)000742573230, (unsigned int)005366042132, (unsigned int)012126416411, (unsigned int)000520471171, (unsigned int)000725646277, 020116577576, 025765742604, (unsigned int)007633473735, (unsigned int)015674255275, (unsigned int)017555634041, (unsigned int)006503154145, 021576344247, (unsigned int)014577627653, (unsigned int)002707523333, 034146376720, 030060227734, (unsigned int)013765414060, 036072251540, (unsigned int)007255221037, 024364674123, (unsigned int)006200353166, (unsigned int)010126373326, (unsigned int)015664104320, (unsigned int)016401041535, (unsigned int)016215305520, 033115351014, (unsigned int)017411670323 };
// atlantis
// file atlantis.c line 165
static struct anonymous *atlantis = (struct anonymous *)(void *)0;
// atlantis_opts
// file atlantis.c line 153
static struct anonymous_16 atlantis_opts;
// desc
// file atlantis.c line 146
static struct anonymous_56 desc[3l] = { { .opt="-whalespeed num", .desc="speed of whales and the dolphin" },
    { .opt="-texture", .desc="whether to introduce water-like distortion" },
    { .opt="-gradient", .desc="whether to introduce gradient-filled background" } };
// opts
// file atlantis.c line 130
static struct anonymous_51 opts[5l] = { { .option="-whalespeed", .specifier=".atlantis.whalespeed", .argKind=(enum anonymous_57)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-texture", .specifier=".atlantis.texture", .argKind=(enum anonymous_57)XrmoptionNoArg,
    .value="true" },
    { .option="+texture", .specifier=".atlantis.texture", .argKind=(enum anonymous_57)XrmoptionNoArg,
    .value="false" },
    { .option="-gradient", .specifier=".atlantis.gradient", .argKind=(enum anonymous_57)XrmoptionNoArg,
    .value="true" },
    { .option="+gradient", .specifier=".atlantis.gradient", .argKind=(enum anonymous_57)XrmoptionNoArg,
    .value="false" } };
// vars
// file atlantis.c line 139
static struct anonymous_18 vars[3l];
// do_gradient
// file atlantis.c line 129
static signed int do_gradient;
// do_texture
// file atlantis.c line 128
static signed int do_texture;
// whalespeed
// file atlantis.c line 127
static signed int whalespeed;
// vars
// file atlantis.c line 139
static struct anonymous_18 vars[3l] = { { .var=(void *)&whalespeed, .name="whalespeed", .classname="WhaleSpeed",
    .def="250", .type=(enum anonymous_60)t_Int },
    { .var=(void *)&do_texture, .name="texture", .classname="Texture",
    .def="True", .type=(enum anonymous_60)t_Bool },
    { .var=(void *)&do_gradient, .name="gradient", .classname="Gradient",
    .def="True", .type=(enum anonymous_60)t_Bool } };
// atlantis_opts
// file atlantis.c line 153
static struct anonymous_16 atlantis_opts = { .numopts=(signed int)(sizeof(struct anonymous_51 [5l]) /*160ul*/  / sizeof(struct anonymous_51) /*32ul*/ ), .opts=opts,
    .numvarsdesc=(signed int)(sizeof(struct anonymous_18 [3l]) /*120ul*/  / sizeof(struct anonymous_18) /*40ul*/ ), .vars=vars,
    .desc=desc };
// atlantis_xlockmore_function_table
// file atlantis.c line 578
static struct xlockmore_function_table atlantis_xlockmore_function_table;
// atlantis_xlockmore_function_table
// file atlantis.c line 578
static struct xlockmore_function_table atlantis_xlockmore_function_table = { .progclass="Atlantis", .defaults="*delay:       25000 \n*count:          4 \n*showFPS:    False \n*cycles:       100 \n*size:        6000 \n*wireframe:  False \n", .want_writable_colors=0,
    .desired_color_scheme=(enum anonymous_1)color_scheme_default, .hack_init=init_atlantis,
    .hack_draw=draw_atlantis, .hack_reshape=reshape_atlantis,
    .hack_refresh=refresh_atlantis, .hack_free=release_atlantis,
    .hack_handle_events=((signed int (*)(struct ModeInfo *, union _XEvent *))NULL), .opts=&atlantis_opts,
    .screen_count=(unsigned int)0 };
// atlantis_xscreensaver_function_table
// file atlantis.c line 578
struct xscreensaver_function_table atlantis_xscreensaver_function_table;
// atlantis_xscreensaver_function_table
// file atlantis.c line 578
struct xscreensaver_function_table atlantis_xscreensaver_function_table = { .progclass=((const char *)NULL), .defaults=((const char * const *)NULL), .options=((const struct anonymous_51 *)NULL),
    .setup_cb=xlockmore_setup,
    .setup_arg=(void *)&atlantis_xlockmore_function_table, .init_cb=((void * (*)(struct _XDisplay *, unsigned long int))NULL),
    .draw_cb=((unsigned long int (*)(struct _XDisplay *, unsigned long int, void *))NULL),
    .reshape_cb=((void (*)(struct _XDisplay *, unsigned long int, void *, unsigned int, unsigned int))NULL),
    .event_cb=((signed int (*)(struct _XDisplay *, unsigned long int, void *, union _XEvent *))NULL),
    .free_cb=((void (*)(struct _XDisplay *, unsigned long int, void *))NULL),
    .fps_cb=xlockmore_gl_compute_fps,
    .pick_visual_hook=xlockmore_pick_gl_visual, .validate_visual_hook=xlockmore_validate_gl_visual };
// cond_initializer
// file thread_util.c line 285
const union anonymous_69 cond_initializer = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// default_defaults
// file screenhack.c line 163
static char *default_defaults[10l] = { ".root:\t\tfalse", "*geometry:\t\t1280x720", "*mono:\t\tfalse", "*installColormap:\tfalse", "*doFPS:\t\tfalse", "*multiSample:\tfalse", "*visualID:\t\tdefault", "*windowID:\t\t", "*desktopGrabber:\txscreensaver-getimage %s",
    ((char *)NULL) };
// default_options
// file screenhack.c line 141
static struct anonymous_51 default_options[11l] = { { .option="-root", .specifier=".root", .argKind=(enum anonymous_57)XrmoptionNoArg, .value="True" },
    { .option="-window", .specifier=".root", .argKind=(enum anonymous_57)XrmoptionNoArg,
    .value="False" },
    { .option="-mono", .specifier=".mono", .argKind=(enum anonymous_57)XrmoptionNoArg, .value="True" },
    { .option="-install", .specifier=".installColormap", .argKind=(enum anonymous_57)XrmoptionNoArg,
    .value="True" },
    { .option="-noinstall", .specifier=".installColormap", .argKind=(enum anonymous_57)XrmoptionNoArg,
    .value="False" },
    { .option="-visual", .specifier=".visualID", .argKind=(enum anonymous_57)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-window-id", .specifier=".windowID", .argKind=(enum anonymous_57)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-fps", .specifier=".doFPS", .argKind=(enum anonymous_57)XrmoptionNoArg, .value="True" },
    { .option="-no-fps", .specifier=".doFPS", .argKind=(enum anonymous_57)XrmoptionNoArg,
    .value="False" },
    { .option="-pair", .specifier=".pair", .argKind=(enum anonymous_57)XrmoptionNoArg, .value="True" },
    { .option=((char *)NULL), .specifier=((char *)NULL), .argKind=(enum anonymous_57)0,
    .value=((char *)NULL) } };
// got_error
// file xlock-gl-utils.c line 33
static signed int got_error = 0;
// i1
// file yarandom.c line 87
static signed int i1;
// i2
// file yarandom.c line 87
static signed int i2;
// iP001
// file dolphin.c line 285
static const float iP001[3l] = { (const float)5.68, (const float)-300.95, (const float)1324.7 };
// iP001_link1
// file whale.c line 209
static const float iP001_link1[3l] = { (const float)18.74, (const float)13.19, (const float)3.76 };
// iP002
// file shark.c line 256
static const float iP002[3l] = { (const float)0, (const float)-36.59, (const float)5687.72 };
// iP004
// file shark.c line 257
static const float iP004[3l] = { (const float)58.24, (const float)-146.84, (const float)262.35 };
// iP007
// file shark.c line 258
static const float iP007[3l] = { (const float)-46.09, (const float)-146.83, (const float)265.84 };
// iP009
// file dolphin.c line 295
static const float iP009[3l] = { (const float)124.39, (const float)-261.46, (const float)1942.34 };
// iP009_link1
// file whale.c line 220
static const float iP009_link1[3l] = { (const float)97.46, (const float)67.63, (const float)593.82 };
// iP010
// file dolphin.c line 296
static const float iP010[3l] = { (const float)-130.05, (const float)-261.46, (const float)1946.03 };
// iP010_link1
// file shark.c line 259
static const float iP010_link1[3l] = { (const float)-27.81, (const float)-285.31, (const float)500 };
// iP010_link2
// file whale.c line 221
static const float iP010_link2[3l] = { (const float)-84.33, (const float)67.63, (const float)588.18 };
// iP011
// file dolphin.c line 297
static const float iP011[3l] = { (const float)141.07, (const float)-320.11, (const float)1239.38 };
// iP011_link1
// file shark.c line 260
static const float iP011_link1[3l] = { (const float)27.81, (const float)-285.32, (const float)500 };
// iP011_link2
// file whale.c line 222
static const float iP011_link2[3l] = { (const float)118.69, (const float)8.98, (const float)-66.91 };
// iP012
// file dolphin.c line 298
static const float iP012[3l] = { (const float)156.48, (const float)-360.12, (const float)2073.41 };
// iP012_link1
// file whale.c line 226
static const float iP012_link1[3l] = { (const float)156.48, (const float)-31.95, (const float)924.54 };
// iP013
// file dolphin.c line 299
static const float iP013[3l] = { (const float)162, (const float)-175.88, (const float)2064.44 };
// iP013_link1
// file whale.c line 227
static const float iP013_link1[3l] = { (const float)162, (const float)110.22, (const float)924.54 };
// iP014
// file dolphin.c line 300
static const float iP014[3l] = { (const float)88.16, (const float)-87.72, (const float)2064.02 };
// iP014_link1
// file whale.c line 228
static const float iP014_link1[3l] = { (const float)88.16, (const float)221.65, (const float)924.54 };
// iP015
// file dolphin.c line 301
static const float iP015[3l] = { (const float)-65.21, (const float)-96.13, (const float)2064.02 };
// iP015_link1
// file whale.c line 229
static const float iP015_link1[3l] = { (const float)-65.21, (const float)231.16, (const float)924.54 };
// iP016
// file dolphin.c line 302
static const float iP016[3l] = { (const float)-156.48, (const float)-180.96, (const float)2064.44 };
// iP016_link1
// file whale.c line 230
static const float iP016_link1[3l] = { (const float)-156.48, (const float)121.97, (const float)924.54 };
// iP017
// file dolphin.c line 303
static const float iP017[3l] = { (const float)-162, (const float)-368.93, (const float)2082.39 };
// iP017_link1
// file whale.c line 231
static const float iP017_link1[3l] = { (const float)-162, (const float)-23.93, (const float)924.54 };
// iP018
// file dolphin.c line 304
static const float iP018[3l] = { (const float)-88.16, (const float)-439.22, (const float)2082.39 };
// iP018_link1
// file whale.c line 232
static const float iP018_link1[3l] = { (const float)-88.16, (const float)-139.1, (const float)924.54 };
// iP019
// file dolphin.c line 305
static const float iP019[3l] = { (const float)65.21, (const float)-440.32, (const float)2083.39 };
// iP019_link1
// file whale.c line 233
static const float iP019_link1[3l] = { (const float)65.21, (const float)-148.61, (const float)924.54 };
// iP020
// file dolphin.c line 306
static const float iP020[3l] = { (const float)246.87, (const float)-356.02, (const float)2576.95 };
// iP020_link1
// file whale.c line 234
static const float iP020_link1[3l] = { (const float)246.87, (const float)-98.73, (const float)1783.04 };
// iP021
// file dolphin.c line 307
static const float iP021[3l] = { (const float)253.17, (const float)-111.15, (const float)2567.15 };
// iP021_link1
// file whale.c line 235
static const float iP021_link1[3l] = { (const float)253.17, (const float)127.76, (const float)1783.04 };
// iP022
// file dolphin.c line 308
static const float iP022[3l] = { (const float)132.34, (const float)51.41, (const float)2559.84 };
// iP022_link1
// file whale.c line 236
static const float iP022_link1[3l] = { (const float)132.34, (const float)270.77, (const float)1783.04 };
// iP023
// file dolphin.c line 309
static const float iP023[3l] = { (const float)-97.88, (const float)40.44, (const float)2567.15 };
// iP023_link1
// file shark.c line 261
static const float iP023_link1[3l] = { (const float)150, (const float)0, (const float)3000 };
// iP023_link2
// file whale.c line 237
static const float iP023_link2[3l] = { (const float)-97.88, (const float)285.04, (const float)1783.04 };
// iP024
// file dolphin.c line 310
static const float iP024[3l] = { (const float)-222.97, (const float)-117.49, (const float)2567.15 };
// iP024_link1
// file shark.c line 262
static const float iP024_link1[3l] = { (const float)121.35, (const float)293.89, (const float)3000 };
// iP024_link2
// file whale.c line 238
static const float iP024_link2[3l] = { (const float)-222.97, (const float)139.8, (const float)1783.04 };
// iP025
// file dolphin.c line 311
static const float iP025[3l] = { (const float)-252.22, (const float)-371.53, (const float)2569.92 };
// iP025_link1
// file shark.c line 263
static const float iP025_link1[3l] = { (const float)46.35, (const float)502.93, (const float)2883.09 };
// iP025_link2
// file whale.c line 239
static const float iP025_link2[3l] = { (const float)-225.29, (const float)-86.68, (const float)1783.04 };
// iP026
// file dolphin.c line 312
static const float iP026[3l] = { (const float)-108.44, (const float)-518.19, (const float)2586.75 };
// iP026_link1
// file shark.c line 264
static const float iP026_link1[3l] = { (const float)-46.35, (const float)497.45, (const float)2877.24 };
// iP026_link2
// file whale.c line 240
static const float iP026_link2[3l] = { (const float)-108.44, (const float)-224.15, (const float)1783.04 };
// iP027
// file dolphin.c line 313
static const float iP027[3l] = { (const float)97.88, (const float)-524.79, (const float)2586.75 };
// iP027_link1
// file shark.c line 265
static const float iP027_link1[3l] = { (const float)-121.35, (const float)293.9, (const float)3000 };
// iP027_link2
// file whale.c line 241
static const float iP027_link2[3l] = { (const float)97.88, (const float)-221.56, (const float)1783.04 };
// iP028
// file dolphin.c line 314
static const float iP028[3l] = { (const float)370.03, (const float)-421.19, (const float)3419.7 };
// iP028_link1
// file shark.c line 266
static const float iP028_link1[3l] = { (const float)-150, (const float)0, (const float)3000 };
// iP028_link2
// file whale.c line 242
static const float iP028_link2[3l] = { (const float)410.55, (const float)-200.66, (const float)3213.87 };
// iP029
// file dolphin.c line 315
static const float iP029[3l] = { (const float)351.15, (const float)-16.98, (const float)3423.17 };
// iP029_link1
// file shark.c line 267
static const float iP029_link1[3l] = { (const float)-121.35, (const float)-304.84, (const float)2853.86 };
// iP029_link2
// file whale.c line 243
static const float iP029_link2[3l] = { (const float)432.19, (const float)148.42, (const float)3213.87 };
// iP030
// file dolphin.c line 316
static const float iP030[3l] = { (const float)200.66, (const float)248.46, (const float)3430.37 };
// iP030_link1
// file shark.c line 268
static const float iP030_link1[3l] = { (const float)-46.36, (const float)-475.52, (const float)3000 };
// iP030_link2
// file whale.c line 244
static const float iP030_link2[3l] = { (const float)200.66, (const float)410.55, (const float)3213.87 };
// iP031
// file dolphin.c line 317
static const float iP031[3l] = { (const float)-148.42, (const float)235.02, (const float)3417.91 };
// iP031_link1
// file shark.c line 269
static const float iP031_link1[3l] = { (const float)46.35, (const float)-475.53, (const float)3000 };
// iP031_link2
// file whale.c line 245
static const float iP031_link2[3l] = { (const float)-148.42, (const float)432.19, (const float)3213.87 };
// iP032
// file dolphin.c line 318
static const float iP032[3l] = { (const float)-360.21, (const float)-30.27, (const float)3416.84 };
// iP032_link1
// file shark.c line 270
static const float iP032_link1[3l] = { (const float)121.35, (const float)-304.87, (const float)2853.86 };
// iP032_link2
// file whale.c line 246
static const float iP032_link2[3l] = { (const float)-407.48, (const float)171.88, (const float)3213.87 };
// iP033
// file dolphin.c line 319
static const float iP033[3l] = { (const float)-357.9, (const float)-414.89, (const float)3407.04 };
// iP033_link1
// file shark.c line 271
static const float iP033_link1[3l] = { (const float)90, (const float)0, (const float)4000 };
// iP033_link2
// file whale.c line 247
static const float iP033_link2[3l] = { (const float)-432.19, (const float)-148.42, (const float)3213.87 };
// iP034
// file dolphin.c line 320
static const float iP034[3l] = { (const float)-148.88, (const float)-631.35, (const float)3409.9 };
// iP034_link1
// file shark.c line 272
static const float iP034_link1[3l] = { (const float)72.81, (const float)176.33, (const float)4000 };
// iP034_link2
// file whale.c line 248
static const float iP034_link2[3l] = { (const float)-148.88, (const float)-309.74, (const float)3213.87 };
// iP035
// file dolphin.c line 321
static const float iP035[3l] = { (const float)156.38, (const float)-632.59, (const float)3419.7 };
// iP035_link1
// file shark.c line 273
static const float iP035_link1[3l] = { (const float)27.81, (const float)285.32, (const float)4000 };
// iP035_link2
// file whale.c line 249
static const float iP035_link2[3l] = { (const float)156.38, (const float)-320.17, (const float)3213.87 };
// iP036
// file dolphin.c line 322
static const float iP036[3l] = { (const float)462.61, (const float)-469.21, (const float)4431.51 };
// iP036_link1
// file shark.c line 274
static const float iP036_link1[3l] = { (const float)-27.81, (const float)285.32, (const float)4000 };
// iP036_link2
// file whale.c line 250
static const float iP036_link2[3l] = { (const float)523.39, (const float)-303.81, (const float)4424.57 };
// iP037
// file dolphin.c line 323
static const float iP037[3l] = { (const float)466.6, (const float)102.25, (const float)4434.98 };
// iP037_link1
// file shark.c line 275
static const float iP037_link1[3l] = { (const float)-72.81, (const float)176.34, (const float)4000 };
// iP037_link2
// file whale.c line 251
static const float iP037_link2[3l] = { (const float)574.66, (const float)276.84, (const float)4424.57 };
// iP038
// file dolphin.c line 324
static const float iP038[3l] = { (const float)243.05, (const float)474.34, (const float)4562.02 };
// iP038_link1
// file shark.c line 276
static const float iP038_link1[3l] = { (const float)-90, (const float)0, (const float)4000 };
// iP038_link2
// file whale.c line 252
static const float iP038_link2[3l] = { (const float)243.05, (const float)492.5, (const float)4424.57 };
// iP039
// file dolphin.c line 325
static const float iP039[3l] = { (const float)-191.23, (const float)474.4, (const float)4554.42 };
// iP039_link1
// file shark.c line 277
static const float iP039_link1[3l] = { (const float)-72.81, (const float)-176.33, (const float)4000 };
// iP039_link2
// file whale.c line 253
static const float iP039_link2[3l] = { (const float)-191.23, (const float)520.13, (const float)4424.57 };
// iP040
// file dolphin.c line 326
static const float iP040[3l] = { (const float)-476.12, (const float)111.05, (const float)4451.11 };
// iP040_link1
// file shark.c line 278
static const float iP040_link1[3l] = { (const float)-27.81, (const float)-285.31, (const float)4000 };
// iP040_link2
// file whale.c line 254
static const float iP040_link2[3l] = { (const float)-523.39, (const float)304.01, (const float)4424.57 };
// iP041
// file dolphin.c line 327
static const float iP041[3l] = { (const float)-473.36, (const float)-470.74, (const float)4444.78 };
// iP041_link1
// file shark.c line 279
static const float iP041_link1[3l] = { (const float)27.81, (const float)-285.32, (const float)4000 };
// iP041_link2
// file whale.c line 255
static const float iP041_link2[3l] = { (const float)-574.66, (const float)-231.83, (const float)4424.57 };
// iP042
// file dolphin.c line 328
static const float iP042[3l] = { (const float)-266.95, (const float)-748.41, (const float)4447.78 };
// iP042_link1
// file shark.c line 280
static const float iP042_link1[3l] = { (const float)72.81, (const float)-176.34, (const float)4000 };
// iP042_link2
// file whale.c line 256
static const float iP042_link2[3l] = { (const float)-266.95, (const float)-578.17, (const float)4424.57 };
// iP043
// file dolphin.c line 329
static const float iP043[3l] = { (const float)211.14, (const float)-749.91, (const float)4429.73 };
// iP043_link1
// file shark.c line 281
static const float iP043_link1[3l] = { (const float)30, (const float)0, (const float)5000 };
// iP043_link2
// file whale.c line 257
static const float iP043_link2[3l] = { (const float)211.14, (const float)-579.67, (const float)4424.57 };
// iP044
// file dolphin.c line 330
static const float iP044[3l] = { (const float)680.57, (const float)-370.27, (const float)5943.46 };
// iP044_link1
// file shark.c line 282
static const float iP044_link1[3l] = { (const float)24.27, (const float)58.78, (const float)5000 };
// iP044_link2
// file whale.c line 258
static const float iP044_link2[3l] = { (const float)680.57, (const float)-370.27, (const float)5943.46 };
// iP045
// file dolphin.c line 331
static const float iP045[3l] = { (const float)834.01, (const float)363.09, (const float)6360.63 };
// iP045_link1
// file shark.c line 283
static const float iP045_link1[3l] = { (const float)9.27, (const float)95.11, (const float)5000 };
// iP045_link2
// file whale.c line 259
static const float iP045_link2[3l] = { (const float)834.01, (const float)363.09, (const float)5943.46 };
// iP046
// file dolphin.c line 332
static const float iP046[3l] = { (const float)371.29, (const float)804.51, (const float)6486.26 };
// iP046_link1
// file shark.c line 284
static const float iP046_link1[3l] = { (const float)-9.27, (const float)95.11, (const float)5000 };
// iP046_link2
// file whale.c line 260
static const float iP046_link2[3l] = { (const float)371.29, (const float)614.13, (const float)5943.46 };
// iP047
// file dolphin.c line 333
static const float iP047[3l] = { (const float)-291.43, (const float)797.22, (const float)6494.28 };
// iP047_link1
// file shark.c line 285
static const float iP047_link1[3l] = { (const float)-24.27, (const float)58.78, (const float)5000 };
// iP047_link2
// file whale.c line 261
static const float iP047_link2[3l] = { (const float)-291.43, (const float)621.86, (const float)5943.46 };
// iP048
// file dolphin.c line 334
static const float iP048[3l] = { (const float)-784.13, (const float)370.75, (const float)6378.01 };
// iP048_link1
// file shark.c line 286
static const float iP048_link1[3l] = { (const float)-30, (const float)0, (const float)5000 };
// iP048_link2
// file whale.c line 262
static const float iP048_link2[3l] = { (const float)-784.13, (const float)362.6, (const float)5943.46 };
// iP049
// file dolphin.c line 335
static const float iP049[3l] = { (const float)-743.29, (const float)-325.82, (const float)5943.46 };
// iP049_link1
// file shark.c line 287
static const float iP049_link1[3l] = { (const float)-24.27, (const float)-58.78, (const float)5000 };
// iP049_link2
// file whale.c line 263
static const float iP049_link2[3l] = { (const float)-743.29, (const float)-325.82, (const float)5943.46 };
// iP050
// file dolphin.c line 336
static const float iP050[3l] = { (const float)-383.24, (const float)-804.77, (const float)5943.46 };
// iP050_link1
// file shark.c line 288
static const float iP050_link1[3l] = { (const float)-9.27, (const float)-95.1, (const float)5000 };
// iP050_link2
// file whale.c line 264
static const float iP050_link2[3l] = { (const float)-383.24, (const float)-804.77, (const float)5943.46 };
// iP051
// file dolphin.c line 337
static const float iP051[3l] = { (const float)283.47, (const float)-846.09, (const float)5943.46 };
// iP051_link1
// file shark.c line 289
static const float iP051_link1[3l] = { (const float)9.27, (const float)-95.11, (const float)5000 };
// iP051_link2
// file whale.c line 265
static const float iP051_link2[3l] = { (const float)283.47, (const float)-846.09, (const float)5943.46 };
// iP052
// file shark.c line 290
static const float iP052[3l] = { (const float)24.27, (const float)-58.78, (const float)5000 };
// iP061
// file shark.c line 294
static const float iP061[3l] = { (const float)0, (const float)1181.61, (const float)6344.65 };
// iP061_link1
// file whale.c line 315
static const float iP061_link1[3l] = { (const float)353.63, (const float)138.7, (const float)10214.2 };
// iP064
// file whale.c line 319
static const float iP064[3l] = { (const float)-326.4, (const float)162.04, (const float)10209.54 };
// iP068
// file dolphin.c line 365
static const float iP068[3l] = { (const float)-136.29, (const float)-319.84, (const float)1228.73 };
// iP068_link1
// file whale.c line 324
static const float iP068_link1[3l] = { (const float)-112.44, (const float)9.25, (const float)-64.42 };
// iP069
// file dolphin.c line 366
static const float iP069[3l] = { (const float)1111.17, (const float)-314.14, (const float)1314.19 };
// iP069_link1
// file shark.c line 295
static const float iP069_link1[3l] = { (const float)0, (const float)-418.25, (const float)5765.04 };
// iP069_link2
// file whale.c line 325
static const float iP069_link2[3l] = { (const float)1155.63, (const float)0, (const float)-182.46 };
// iP070
// file dolphin.c line 367
static const float iP070[3l] = { (const float)-1167.34, (const float)-321.61, (const float)1319.45 };
// iP070_link1
// file shark.c line 296
static const float iP070_link1[3l] = { (const float)0, (const float)1266.91, (const float)6629.6 };
// iP070_link2
// file whale.c line 326
static const float iP070_link2[3l] = { (const float)-1143.13, (const float)0, (const float)-181.54 };
// iP071
// file dolphin.c line 368
static const float iP071[3l] = { (const float)1404.86, (const float)-306.66, (const float)1235.45 };
// iP071_link1
// file whale.c line 327
static const float iP071_link1[3l] = { (const float)1424.23, (const float)0, (const float)-322.09 };
// iP072
// file dolphin.c line 369
static const float iP072[3l] = { (const float)-1409.73, (const float)-314.14, (const float)1247.66 };
// iP072_link1
// file whale.c line 328
static const float iP072_link1[3l] = { (const float)-1368.01, (const float)0, (const float)-310.38 };
// iP073
// file dolphin.c line 370
static const float iP073[3l] = { (const float)1254.01, (const float)-296.87, (const float)1544.58 };
// iP073_link1
// file whale.c line 329
static const float iP073_link1[3l] = { (const float)1255.57, (const float)2.31, (const float)114.05 };
// iP074
// file dolphin.c line 371
static const float iP074[3l] = { (const float)-1262.09, (const float)-291.7, (const float)1504.26 };
// iP074_link1
// file whale.c line 330
static const float iP074_link1[3l] = { (const float)-1149.38, (const float)0, (const float)117.12 };
// iP075
// file dolphin.c line 372
static const float iP075[3l] = { (const float)965.71, (const float)-269.26, (const float)1742.65 };
// iP075_link1
// file whale.c line 331
static const float iP075_link1[3l] = { (const float)718.36, (const float)0, (const float)433.36 };
// iP076
// file dolphin.c line 373
static const float iP076[3l] = { (const float)-900.97, (const float)-276.74, (const float)1726.07 };
// iP076_link1
// file whale.c line 332
static const float iP076_link1[3l] = { (const float)-655.9, (const float)0, (const float)433.36 };
// iP091
// file dolphin.c line 393
static const float iP091[3l] = { (const float)0, (const float)835.01, (const float)5555.62 };
// iP091_link1
// file whale.c line 356
static const float iP091_link1[3l] = { (const float)0, (const float)327.1, (const float)2346.55 };
// iP092
// file dolphin.c line 394
static const float iP092[3l] = { (const float)0, (const float)1350.18, (const float)5220.86 };
// iP092_link1
// file whale.c line 357
static const float iP092_link1[3l] = { (const float)0, (const float)552.28, (const float)2311.31 };
// iP093
// file dolphin.c line 395
static const float iP093[3l] = { (const float)0, (const float)1422.94, (const float)5285.27 };
// iP093_link1
// file whale.c line 358
static const float iP093_link1[3l] = { (const float)0, (const float)721.16, (const float)2166.41 };
// iP094
// file dolphin.c line 396
static const float iP094[3l] = { (const float)0, (const float)1296.75, (const float)5650.19 };
// iP094_link1
// file whale.c line 359
static const float iP094_link1[3l] = { (const float)0, (const float)693.42, (const float)2388.8 };
// iP095
// file dolphin.c line 397
static const float iP095[3l] = { (const float)0, (const float)795.63, (const float)6493.88 };
// iP095_link1
// file whale.c line 360
static const float iP095_link1[3l] = { (const float)0, (const float)389.44, (const float)2859.97 };
// iP096
// file whale.c line 366
static const float iP096[3l] = { (const float)222.02, (const float)-183.67, (const float)10266.89 };
// iP097
// file dolphin.c line 403
static const float iP097[3l] = { (const float)-194.91, (const float)-357.14, (const float)10313.32 };
// iP097_link1
// file whale.c line 367
static const float iP097_link1[3l] = { (const float)-128.9, (const float)-182.7, (const float)10266.89 };
// iP098
// file dolphin.c line 404
static const float iP098[3l] = { (const float)135.35, (const float)-357.66, (const float)10307.94 };
// iP098_link1
// file whale.c line 368
static const float iP098_link1[3l] = { (const float)41.04, (const float)88.31, (const float)10659.36 };
// iP099
// file whale.c line 369
static const float iP099[3l] = { (const float)-48.73, (const float)88.3, (const float)10659.36 };
// iP102
// file dolphin.c line 411
static const float iP102[3l] = { (const float)59.51, (const float)-412.55, (const float)10677.58 };
// iP110
// file dolphin.c line 426
static const float iP110[3l] = { (const float)-187.62, (const float)-410.04, (const float)10674.12 };
// iP111
// file dolphin.c line 428
static const float iP111[3l] = { (const float)-184.25, (const float)-318.7, (const float)10723.88 };
// iP118
// file dolphin.c line 435
static const float iP118[3l] = { (const float)216.78, (const float)-509.17, (const float)10098.94 };
// iP119
// file dolphin.c line 436
static const float iP119[3l] = { (const float)-313.21, (const float)-510.79, (const float)10102.62 };
// iP121
// file dolphin.c line 441
static const float iP121[3l] = { (const float)71.99, (const float)-319.74, (const float)10717.7 };
// iP122
// file dolphin.c line 443
static const float iP122[3l] = { (const float)0, (const float)602.74, (const float)5375.84 };
// merged_defaults
// file screenhack.c line 178
static char **merged_defaults;
// merged_options
// file screenhack.c line 176
static struct anonymous_51 *merged_options;
// merged_options_size
// file screenhack.c line 177
static signed int merged_options_size;
// mono_p
// file screenhack.c line 138
signed int mono_p;
// mutex_initializer
// file thread_util.c line 277
const union anonymous_67 mutex_initializer = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// orig_ehandler
// file xlock-gl-utils.c line 32
static signed int (*orig_ehandler)(struct _XDisplay *, struct anonymous_64 *) = ((signed int (*)(struct _XDisplay *, struct anonymous_64 *))NULL);
// progclass
// file screenhack.c line 137
const char *progclass;
// progname
// file screenhack.c line 136
const char *progname;
// screensaver_id
// file ./../utils/version.h line 1
static const char screensaver_id[69l] = { '@', '(', '#', ')', 'x', 's', 'c', 'r', 'e', 'e', 'n', 's', 'a', 'v', 'e', 'r', ' ', '5', '.', '3', '4', ' ', '(', '2', '4', '-', 'O', 'c', 't', '-', '2', '0', '1', '5', ')', ',', ' ', 'b', 'y', ' ', 'J', 'a', 'm', 'i', 'e', ' ', 'Z', 'a', 'w', 'i', 'n', 's', 'k', 'i', ' ', '(', 'j', 'w', 'z', '@', 'j', 'w', 'z', '.', 'o', 'r', 'g', ')', 0 };
// sea_texture
// file ../images/sea-texture.xpm line 2
static char *sea_texture[193l] = { "   128   128       64            1", ". c #b1b1b1", "# c #afafaf", "a c #adadad", "b c #ababab", "c c #a7a7a7", "d c #a5a5a5", "e c #a3a3a3", "f c #f0f0f0", "g c #e0e0e0", "h c #dedede", "i c #dadada", "j c #d8d8d8", "k c #d6d6d6", "l c #d4d4d4", "m c #d2d2d2", "n c #d0d0d0", "o c #cecece", "p c #cccccc", "q c #cacaca", "r c #c8c8c8", "s c #c6c6c6", "t c #c4c4c4", "u c #c2c2c2", "v c #c0c0c0", "w c #bebebe", "x c #bcbcbc", "y c #bababa", "z c #b8b8b8", "A c #b6b6b6", "B c #b4b4b4", "C c #b2b2b2", "D c #b0b0b0", "E c #aeaeae", "F c #acacac", "G c #aaaaaa", "H c #a8a8a8", "I c #a0a0a0", "J c #9c9c9c", "K c #929292", "L c #e9e9e9", "M c #e5e5e5", "N c #e3e3e3", "O c #dddddd", "P c #dbdbdb", "Q c #d9d9d9", "R c #d7d7d7", "S c #d5d5d5", "T c #d3d3d3", "U c #d1d1d1", "V c #cfcfcf", "W c #cdcdcd", "X c #cbcbcb", "Y c #c9c9c9", "Z c #c7c7c7", "0 c #c5c5c5", "1 c #c3c3c3", "2 c #c1c1c1", "3 c #bfbfbf", "4 c #bdbdbd", "5 c #bbbbbb", "6 c #b9b9b9", "7 c #b7b7b7", "8 c #b5b5b5", "9 c #b3b3b3", "PPilW0w65w2tZYpoUTlkRQQQjRRjPhNMLMMNNOTY38B7y42sWlPgPUZ4B.#abGGGbbFaE#D.A5v0qVljOhQTWZsoSONLMMNghOPQRkkkkkkjQPPPPiQQjRRkSWt5.HHH",
    "PPilW0w65w2tZYpoUTlkRQQQjRRjPhNMLMMNNOTY38B7y42sWlPgPUZ4B.#abGGGbbFaE#D.A5v0qVljOhQTWZsoSONLMMNghOPQRkkkkkkjQPPPPiQQjRRkSWt5.HHH",
    "PPQTp0w6y4v1srXWnmTSkjjjRkkRihgMMMNNNPmrwB97y42sWlihinsx9DEabGGGbbFaE#D.A5v0YoTRPhjmps0WlPNLMNNghPijkSSSSlSRjiPPiQQQjRRkSWt5.HHH",
    "iijmp0w6yxwvutZYponTlRkSmnooUSjPhhhggPUZ499z4uZXnljPkW1yC#EaFbaED.9BB88Ay420YWmkPOkVYuvZoSPhhOPiQklmnooWpppVUlkRjjQiQQQjRVsxCGHH",
    "jjRUX0w6yy5x4vu0rqpVmSlUWY00rpVTSRiPhQV05.9y2rVmTSkRUYvzDEEaaaD9A6xxxxx5wv10rpnlQPTp0452ZWTkkSllmnWqrs0t1u1sqWUTSRQPPPPPPmrwBbGG",
    "RRSnX03y66z665wv1sYpVTmWZu45wu0YpnlRPRW1yDCxtokjRklmWt48EaaEE#97xvtt11u2u1t0ZqVTjQnYv685v0qWWoWopYs123456z6wusXomSQOOOhhhSXvAFbb",
    "SSlVq03y67A8B76x3u0YpUnYu5B.Bz531roTjkpuzEC4rlhhiRmorv6CaFaE#.7xurWpXYrZsss0sYWUkRo0xBDB64ut0ssZsuvx67BCDaD8yv0qVlQhhggggjou7aFF",
    "TTmWYt3y6A9CD98z5wusqVo04BFHb#CA52YVklqv7aC3XQNNORnY1xADbba#D9yvrVlTUVopqrZt0rpnSSXuzDbECAyxww32vx68C#aGcdca96vspTjhgNNNNPnt6Eaa",
    "YYr01v4y678B9A6xv10ZYpqu59bHbE.86vZWlmr3Aa.wYkghQmq1w6B#bF#.9Ax2rWmnWqZ0t1uv2tZXVVZ3AEGECA54w3v2vxzB.EFGHdH#8y20qVlQPOhgNin0yDDD",
    "xx5555y6y6zzzxvtZqYYYYsvyBabaD9AyvspmnZwAE.xsUijUXt468C#aE.B7yw2sYpY024yy55543u0YYu58EbD86w2uuu12468.#EaaF#B6w1sYpoUlkiPhjo0x9CC",
    "###D9876yy54wusXVUoprs246BDED98z5vsXVWs4AE.6uXTUqt47BC.#EDB7y43210su4z9#DCBAzy4vu14z9EF.7xu000001wy8.DDD..B642sZZrrYpnljPSW04888",
    "eeedbDBz5xw21rWmRQTor14yz8C.9876xv0YWXt4A#.7wspY147.#####CAy422222v58EHdcGaDBAzyx468CEa963srrrZZtvyA.DC9A7yw2trZstu2tYVTjTp0w777",
    "KKKJeG.z5wu0YoTQhgjnrv6778BBA7654v0rXY1x8#D85v0uxA.bGFa#DB64vt1v34yBadIJIecbD.9B8ABCDEE8xuYpXqqYs25A..BAy4v10ZXrt2x641YVSUX03yyy",
    "KKKJebBxvtrXVlQhNNPTqu5y67887765xwutst3z9aEC75347CEHHbFEDB6xvt2w57BEHeIJJedGE#DDD.D##E#AxurXYrs0uw68..9A6xw2u1s1v4y752ZWmVY14zzz",
    "KKKJdD61ZXVmkQOgNMhkVZ2wx6A877zyyxw3vw6B#GbE97568DaHHbFED9z5w2wyA.aGcdIIedHbEEEaFFFaEEDA5v0stuvw5z8C#DCBAzy55x4x5y6zx2ZpnWs2y888",
    "KKKJHB3qomkQOhNNLLgQTps135zA777zz66yyzB#GdcGECA8CEbHHbFE#CA6x358DbcddddddHGaEFbHccHba#CA642u3x67B9.#EED.9B888BBBA7zy4usqoqtw7CCC",
    "KKKIbz0UkQOgNMLLLLNORUpZ146A7777AA88BCEGdeecGEC.#FGHHbFE#C8zyx7.bdIIedcHGFFEEbHdeedHFD9Az54wy79#aaaFFaE#D..DEFFa.Bz5wu0Ypr25B#EE",
    "KKKIE4XjOgNLLLLLLLMgPkUpsvyAA7AAB9.DEFHdeIIedHaaFGHHHbFE#.BAzyBadIJJIdGE####EGceIJIdbDBA7zy68.FHdHHGbFFaaaFGcdedF.7x3u0rq03z.Fbb",
    "KKJdC3WQhNMLLLLLLLNgPjlWswz99999.DEaFGcdeIIecGEEaFbbFaED.9876y8#HeIIdFDB9CD#aGHdeIdHECAA77z7CEGddcGFE#EEaFbHdIIeHD74v10rqt48EHHH",
    "IIebA2pkPhNLLLLMNghPijlp159EEEEEaaFFFGHddIedGEC9.D##D.C9BAzy5x68.Eba.B7y78.#FbbbbbaD9Az7777ACEGcdGE.8ABCDEbHdIJIHD7w2tsrqtxBFddd",
    "GGbCy1qmRPgMLMNghPiQjRlq27EHHHHHHGGbFbHcdddGEC77A8B9B8A7zy54w34xy676543vx7CEGa#.B8A7z6y6z7AB.EbHHaC7xx6AC#FHeIJIHDzv10ZYq1yCHeII",
    "BBB6wtYVlihNLNgPjSkkRRlYw9HedddddcHGFFGHcdHaCA5xy6z77z65x4w3v22u1ttt0ss0vy9aHE9z4v3w4x5yz789DEbHGDAxu1w68DFHeIJIHD62tsZYqu6DcIII",
    "44wvusrpURONMgPRTVUmSRlrx#dJIIIIedcHFFbGHHbDAy3vw4x55x43v22uu10rpVUnVVoXtxBaH#7wsqr01v45z7BCDEbHF9yuYY147CFHeIJIHD6u0ZrYquzEdJJJ",
    "222uuttZpmQhNOjToqWVmSmZyEeJJJIIedHF#D#EEF#9z42uv3w443vu1t1tt0rpmkijkSmVZwAEH.y1XnWY02w5zA9.D#EaD7wsWp03zCaHeIJIH.y1srrYY27EdJJJ",
    "333wwww30pmQOjTVqZqpoUV06EdIIIedcb#97z78B9B7y4vvww4x43utsss0t0YoSihOiRlUY2z.FBx0omoY0vx6AB.D.9BA6w1rWp03zCaHdIJIb9xtZrrrZv7EdJJJ",
    "xxxy6z77w0pljlVqs1srXop16#dIeddHFD8y3vwx5665x4ww4x554v1ZqYrZ00qnjhNgOikmX15BD73ZnlVY035z8C#D97yw2tZqWX03zCaHdeIda8wsZrZZ03AEdIJJ",
    "yy67BCD#A3somVXs1v10ZqY2zDcedHGFDA52Zrstuv3www4x55y6x20YWpqrs0XmPNLMgOjlW0w79yuqmknqtw6A9Da#ByvZqXXWoqtwzCaGHdecD7vZrrs0148EdIII",
    "77A9DFHH#zvrWqsu34vutZs37DHdHbE.8x2roVWXYstuvw55y6zzx2spnVpqs0plhMfLNgiSoZ2yA40plRUqt4z8C#FEAwZVmUnVoqtwzCabHcdGC62YYrstux8EcIII",
    "88B.aGdda84sXZtv45wvu0t3zCFGa#C8yvspmTUopYs13xz7777z52ZpUVWqs0WkgLfLMgiSorux63ZokQmXt47BC#F#72XSjkTUVqtw69#abHcFB51qqrstu4ADHddd",
    "99C.#abbCy2YWqsuwx321ss2xzC.98zy4usXnnopqZ1w68##.B8z5v0YWpXYZsoRgLfLNhknX02xy2YnjPlWs367BC#Cy1pSjRlTUpZ2xAC#EbHa8xtXXqrZ0vy8#GGG",
    "......DCz3sWnprtv4vu0rrt246z654w2tZqWWXYZt369acHFD9z53usYYrrZZVjNLfLNPmXZ1vxx1XmiOkVr2x678984sokQRSlTVYt368CDab#A4tXpXXYrt3yBDDD",
    "DD#.CB8zwtqnTVq02w21sYqZ0u3w3vu10sZYqYrst2xBadIIdFCz5wv10ssZZrnQNLfLgjos12344tplPhjUq1wxyzA6vrVkQjkklUXZu468C#FD7w0pWWWpXZ13yAAA",
    "EEE.Bz5wtYolkmpZuvu0ZqpqYZ00ssZrYrrrrs0123z#cIKJIHDz5xwvu1t0ZYUiNffLhSqv3ww4wsokhgiTp0v345yxuqnRiQjRkToY0vxz8.E.6vsWVoVVoXZt3xxx",
    "###C7xv0YWmRQloYtutZqWVWWpXqqqXXXYrZst123w7adJKKIH.y4w3v21tsrqmiNLfLOms444wwvrnjgNPlp0v3w4xwtXUkQjRRkToXZuwyA9D9y2ZonnUUnWqZ1vvv",
    "777ywu0qomkPPRmWrsrXoUTUnopXXXXXXYrZstt1u25CGIJJdD6u0sZrYqXppolPNLfNQn04w32utXmQgNiUrvyyyyyxurWmSlTmUVXr0uw579D9y2ZonnUUUWqs2444",
    "33320rXVmkihhiSUpqpVTkjSTnWXXXXqqYrZs0000037DHIdEz2qWVnUmmmmUmkPhNLhkWt43v10roSPNNjotyB8A7z530qoUVoWXqZ012w579.B5urVUUUUUWYt3555",
    "ZZZYpVUlRiOgNhQlnonljPOjSmopXXqqYrZss0sZZrtxA#HaAvYmkRQiPiQjkSjPOggimX14vusYpmRONNRpv8EDC9A642sqpqYrs0t12vw57B.B5urVUUmmUWru4zzz",
    "VVVUmSkQPhgMMgPjlmSjPggPjlVpXXqYrrZsssZYqprux8D8wrUihgNNNNghPQiPPPPkVYu42trpnSQhNNkYx#HbED975w1srstuvvvv33w57BC8x1YnmmmmUWZ25AAA",
    "kkkRjiPOhNNLLNhPRSjPgNMhikUWpXXqYYrZZrYXWVps25Ax0VjgMLLLLLMNhPiijRkUpZ2wusXnljPhNNls6becbECA6xv1tuv455x443w5z8B74tqnmTTTmWZvyBBB",
    "QQQQQiiPOgNMMNhiRSjPhNNhPRTnnUUUUUnVVoVVVUWr1w6wZnjgNMLLLLNhQkSlTTmVqs23troTRQPhghUt7bdHFDBz5wut02wy7765xw34x5yx2ZXUmTTlTVYuxAAA",
    "PPPiiiQQPhgNNgOQklRiOgNhPjSTSkRjQQjRRklTmmoYtv5vrnjhNNMLLMhilVVVVVVpYsu2sXUkiPPPhiouAbdHEC75wvtss2xz99A65wvvvvv1sqWUmTlSSUXtw666",
    "hhOPiQjRQPhgNhPjSTkQPhghPQRkQPOgggghhOiRlToqsuwuYnRhgNMMLNPkVYYqqXXqZ011rWlQOPPPikXv8bdG#B64v1srZ258##97yw2ut0ZYqWoUmlSkRTWZ2555",
    "gghOPQRSRiOhghPRlmSjiOhOPiQQOgNLLLLLLNgPRlVXZtvtqnROggNMMgjUY11t0ZZZs0t0qnRPghPQRmrwBbcb.Axv10rqr26CbbD86wu0rXoVVnnUmlkRQSVY1www",
    "gggOPjSTSjPhgOikTUlRQPOPPPPPgMLffffffLNhQlVpr0u0qnkPhhgNNhSW0wwv21t0000ZpmQhNhPjlo04BbHa963u0ZqpY26.HHEBy3trpUlSTTmUmSRQPRUps222",
    "iiQklUoWnljPhPjSmnTSRiPPPQQQOgNLLLLLLMgPRTVprt21sXVmkjPhgPSoZ2v22uu1t0sYVlPgMgOikUYuyC#9z4u0rqpopsvy9B6wtrpnTRiijkSTlRQPOikmWYYY",
    "mmUopYZsqnSQPiRlUVmlkQiQQRkkQPhgNNggghPjlmoXZ1vvu0ZYWUkihiSnqst1u2vutsrXUkONMNhPQlWZv67y420rXponVprtv2sqVlRQPhggPijkRiPhghPjSUmm",
    "YYrstuv30XURPjSmnoUTSjQjRSlTSkRQiiQQQRSlmnWqsu3www3vtYVkPQSmoXr01vw2tZqWTjhNLNghPRUps2wv1srXWonmmUnoWVTRPhgNNMMMghPQiOhgNNghPiPP",
    "vv3wxy6z3ZoSQRlUVWnmlRjkSTUnnUUUmmUUUnnnVVpY02w5yz7AxuYURRSTUnprt34vtrXnSigMLMNghPkUprsZrqpWnUTSkRjQiPgNMLLLLLLLMNhPPhgNMMMNNNNN",
    "zz7A89CCy1qTjkTnopVUTkRSTUVWWpXqqqqqqqXpWoprtv46A9Da95tplkSSllVqtw531rWmRPgMLLMNgOQkmVWWWVVnmTSRjPgNMLLfffffffffLMghhNNMLLLLLLLL",
    "666z7A88xtqmkSTUnVmlkQijklmnWXr00ssZrYXoVUVq024z8.EbD62qmTTmUnX0vy7xuroljOgMLMNhPikTVpqpWVnUmUmmlQhNLLfffffffffLMNhPPhhNNNMMMMLL",
    "44xxx5y5vsXUlllTTTkjiOhOPQRlVXs2vutsrqWnTSTWZu4zBDaG#zvYUUVWXYtvy8CzvZoSQOgNMNhPRlnWqZ0rXoUmUoWXWlPgLLfffffffLLNgOQkkjQPPOhhhhgg",
    "vvvvv3vvtrpnmllSkRiPhgNghOPjUXt4x3u0rXVTkQRnY147BDFHE73rnVpY01wy8.E8wsVkiOgNNgPRTVXrt220YomTnpY0ZnRhLfffffffLLNhPRlUUmTSSkRRjjQQ",
    "111ttt0srXWVUTSRQPhgNMMMNNgPTXu67x3trpnSQOPTXt479#bHaAwZopYtvxzB#FGCx0VjPOgNNhQToY0u3xxuZWTlVYt32XlhLfffffffLNOjSmVppWWooVnnUUmm",
    "ZZZZrYqXpWWoVTSQPhgNMLLLLMNhSqv89z4uZWmRPghkW0479#bcF84sWq0vy8.EGcdEy0VQPOgggPSVYtv4y77w0WTlosvzysUPLffffffLMhRmnWqZZZZZZZrrYYqq",
    "XXqXppWWWpXqXVmkQPhgNMMNghOjotyDF.8ywtqnkPPlWZvyACEGEAxtqs2yB#bHddeFztVQiPOhhjmXt3x67BBxuqnUXtw7ysUPLffffffLNPknWY02vvvv3v2utt00",
    "VVoooooopqrssqWUSRQiPhOPRlnX1yCHdHbE.A40pllnprt357CE.7xusux8EHddeIIb7uoRQiPPiloZv5zABCC63spWr1w6xZmhLfffffLMgPknXsv5y6zz765x3v22",
    "TTmmUnVoXr0u20rpnTllSkSUWYt3z.GeIIIedH.yuXWpXqrtv579Bz5vu47DHeIIIIIGA2WkRjjjRnq1x789CD.7xurY0uwy4YThLfLLLLMghiknqux89C.D#.BAyx44",
    "RRkSlmUVXs1wxv1ZpooVVVWr1wz9aceJJJKKKJd#zuZrqXWY0v577y5436CGeJJJJJIHBvpSkSSSTWs3z9..#E#By3101vw53qSgLfLLMNghPQknr37#FGHHcGa.87zz",
    "PPijklmVqtvy7ywuZYYYrZ03z9FceIJKKKKKKKJdEyvtYWUVq0vxy5555BadJKKKJJJc93XllTTmnYu5B#EEFFa.7532v3wx2pkgLfLMNhPiQjknsxCHdeIIIedbD9BB",
    "PPiRSUVXs2x78z42srZs01v58#HdIJJKKKKKKKKea6v0XnklVq0u3wx5y9FdIJJJJJIHB3qmmnVWXtw7.FbbGbFDAy3233wx2pSgLLLgORSlSlTWty.HdeIIJIdGD8AA",
    "jjRTnprtvx68Bz4uZqZs1v468.FHdIJJKKKKKKJd.4tYVSiQSnpr0u34y8#HeIIIeedE7vYnopqr0369aHHHHHbDA5212vwxvqlhLLNORUoooooY2yCbcdIIJecEB655",
    "SSlnXZuw5zA9C741rXr02w5z8C#FHdIJJKKKKKIG8vrolihhikmoqsu35ACaHddcHGF9yurWXr0u3y8#GcccccH#741012w53YmPMMhjUqrrrrr036BEGceIIeG.zwvv",
    "TTUpZ2x789C..741Yprtv5z789.#FHdIJJJKKJeE6tpmjhNNgPjSnq0v57B.EFaE#.9741rXrt246BDbcdddddH#7w0Zt2w5wrniNNPTX122uu12xz8.aHdeIdFBx100",
    "nnoruxAD####D74tqortw6A888B9DFHdIIJJJJcC4rnkPNLLMNhPkoru5678B9B8A76xvtZY0vx79#Fcdeeeedc#73ZYsuw54sojghRo04y5xx44yzABDbceIdE7vrqq",
    "ppX0369aE#D.963sXor1xA9B8A77BDaHddIIJeb83qUjhMLLLMghjnYuxy6666y5x43v10ssu47CEGHdeIeeddG.6vZqs1vxwsokhPmYvz8Az6556z7ACaHdIH.y1XWW",
    "rrZu469#.987y31rpWZ2y9D98z55zB.aGHdeIdE7vqURPNLLMNghjnYux55x4w3vu1tt000t369aHddeIIedHFD85v0rstuvuroliRo0xBCBA6556z7A9#bHdbBx0WVV",
    "tt1vxzB.B75w2tZqpWs3zDEC8y3vxz8.EFHHdG.62qnkPgMLNNgOjnYux54321tsZYqrZst2x8#HeeIIIIdHaCA64vtss00tsqomkmq2zD#C8z55y6z7B.EbH#73Zonn",
    "vv34y7897xvtrqqpWpt48abDAxut2468CDEFGEB5uqVlihNMNghPRnYuxx3u0rYXWoVpYZ136CGeIJIIIIdbC7xwv21t0sZrYponmo04BFF#B75x5y6zA9DEFCy2YVUU",
    "xx5yz7885v0qVVoooX159GH#AwsY0246ABC.#Cz41qVTjhNNghhPRnYux420YponmllnXZux8EdIJJJJJIcEA4uuu2210ZqpWWoooY26DHHaC75x5y6z7B9CD84tXUTT",
    "66z6z77zwtqVlTnVWY26.Hc#A3rXr02w5yz78zxv0qomRPhghhhPRUq1431sXonmlkkUpr14A#cIJJJJIIHDz3t1122u0ZXoVoWWpZvz#cHEB6w3w4x5yz7A8yvZWmll",
    "zzz666652ZpmkTVpY0w7DHH#73ZXYrs01u22v21srXoUljPPPOhhilWZuutsrqXWVUUVpqZ1wzCbddddedGDA53vvv2u0ZqpWWWWWYu5Cba9630s0t1u23w4xv0Xnlkk",
    "zz76y5xwtYVSjTVqsv58#HH#7wsqqqXXXqqqqqqXXXWVUlkQiPhgPkUXs000ssZrqpppppXqsvx7CDEFHHFDBzyxw3210ZYqXpWoVX04A#.z3spopXqYrs01u0qoTkRR",
    "7776543uZpmRQlorux79EHHD7w0qXWnmTTlllTUnopWoVUmSjPhghQlVXrs0tuutsZrqpWVnWYsuwy79#aEDCBA6xwu10srYqXWonWZv69A40pTSTmUnVWpqYXomSRQQ",
    "AAA6x320qVliPlW0wzB.aHGD741YWnSQPPOOhPjSUWpWpWoUSihNgPjTVXrt2ww32u1ZpVTRSmnoX0vyB.DDDD.864ut0ssZrqWVUVq147y1qTiPiQjRSlmUnUTkjQii",
    "zzzywu0YWUkiPTptxA9.EFaCz41roTQhgNNMMNhQlopXqqqomjhNgPQSUpr1v5x432urWmjPPQjRlWZ2y89CD##B6wtsZZZrrXWVmVqtw6x0WSOhOPPiQjklTlkjQiPP",
    "www2tZqWVmlkknXtwyz78997531roligNNMMLNhQlopXqYrXVTRPQkmVpYs1v43u0rqVljOghPijSnX0vx6z8BBz4uZqXpWooVVVnpZ258zvZVkjRkSlTmUnnUlkQPPP",
    "000rqWVUmmmmUWY02w4x5yy4321ZoSPNMMLLLMgiSVpXYrZrXonTUVpYZ0tu2v1ZXVTRPhNNNhPiRmoqs1vw5664usXonmTSSTUVWY147.952rVUnVooWWpXpoUSjPPP",
    "ppponmlSlmnoXYZ01u2u2u2u111ZokONLLLLLMgPSVpqrZ0sZrqXqrs1u2uuuuZpURPhgNMLMghPjSmVpYstvw4usqVmSRQPPRTVXs369a#85urYYrrrZZZZrXVTRPPP",
    "TTTSkjQikmoYssss0ssrrYrrs01soRhLLLLLLLNPknpqZs111111u23w4w321tqURhNMLLLLLNgPQRSTUnpYs1usXVTRQOhNgPSVYuxA#HGDA52uu22222uutZWUkPPP",
    "QQQiPPOOQTWZ1tsZrqqpWoWXr0utWkOMLLLLLLgPSoqZtu3ww4xx55yyyx3u0rokONLLffffLLNhPiQjRkmVqZsqoTRPhgNLMhkos3zCbdcF.A5555555x4wvtqVSiPP",
    "PPPPOOhOQSUXrYqXpWppXXYs13x40WlPggNNNhjmp0246A999BB87654v1sYpoligLLffffffLLNghhOPiSUprsXnlQOgNMLMOlXu58#HddG#9z66zz77z6yxvZWTjii",
    "hhOOhOhOiRlnooVnnnWpYrt2468A4tXmkRjQiRnYux7CEGdcHGF#9z4uZqWnTSihNLffffffffLLMNNNghjTWrsXUkPgNNMLMPUZ4A.aHedHaCAAA8BBB88A741qURjj",
    "gghhhhhOPQjSlllllTVXZtv579##852ZXWonUoZv6CaceIJJIIdH#AwsWUlRiPhNLLfffffffffLLLLMMNPSor0XmRONNMLLMiVt6CEGdeeHFDBBBC.DD..C96vrVSRR",
    "NNggghhOPPPPiQQjjknX0v5A.aHHaC742u0ZYsw7DHeJKKKKKJJeb8vqljPhgNMLLfffffffffffffLLLMhRVr0XTQhNMMLLNjW28EbcdIecGECC.#EaaaaE#840WTSS",
    "NNNNghOPPPOOOPPiQknYuxA.Fceedb#Bzy4vu37DHIJKKKKKKKKJcB2oihgNLLLLffffffffffffffffLLhRVs1qmQgMMMLLNkqw.GHdeIedHaDD#abGGGbbF95tpmll",
    "MMMNghPijRSlTmnVopsvyBDFHdeecFD86x310uyCHIJKKKKKKKKJcBuVPgNMLLLffffffffffffLLMNNhPSWs3xuYVkiOhgNhmZ5DHcdeIedGECC.#abFa#DC6vYnRQQ",
    "LLLMNhiRTnpYs01u23yA.FHccdddG#97531ZqZw8FeJKKKKKKKKJcBuVPgNMLLfffffffffffLMgOiRlUWruxAB63tqomSjPjW16#HcdeIecbD88B.#a#.BA6vZVkOhh",
    "LLLLNOQloY1wyz7A8C#bHdeeddcHa.8ywuZXVpu6#dJKKKKKKKKJH8uVPgNMLLfffffffffLLNPkUWqZtv5ACaFD86w1ZXnlmYv7EHdeIIecaCzzAB.#.86xvZoSPNNN",
    "fffLNORUquy9abGHHdeIIJJIedHFDBzxv0qVlnsx.cIKKKKKKKKJH8uVPgNLLfffffffffLLNiTp0246ACEbHddcb#C7xurWptx8aHdeIIeHEByy6A9.B6w1rolPNLLL",
    "fffLNPSW05CHeIIJJJJJKKKJIdG#9AywuroTjlq3BHIJKKKKKKKJH82oigNLLffffffffLLNPTXuy8.aHdeIIJJIIdcbC6vZZv69FHdeIIeH#A445zA9741YoligLfff",
    "fffLgjVswAEdIIJJJJJKKKJJeHaCA6420YWUkmr38FeJKKKKKKKIGA2WQhgNMLLffffffLNhRoswA.FceIJJJJJJIIdH#7wssv6CbcdeIIeHD7w3wx56xuZpUkPgMLLL",
    "fffMPmrwz.GdIIJJJJJJJJJIdb#BzxvtZqpVUoswAEdJKKKKKKJIbA2pRPPOhgNLLfffLNhjUqu59EHeIJJJJKKJJIIdEAwsZv6CbcdeIIeG.z3222vvuZXomkihNLLL",
    "fffNjW2A.FceIIJJJJJJJJIdHaCA5w1ZYqXpWqt47.GIJKKKKKJeFAvXSRRjjQONLffLMhQTp0w7.bdIJKKKKKKJJJIda8wZZv6CGddeIIebC6v1t0sZYpoUTkQOgNNN",
    "fffglZ6EGcdIIIJJJJJIIIdHFDB642sqpXqqYs2xz9adJKKKKJJeaAvqTlTmmmRONLfLgilWZvyBEHeJKKKKKKKKJJJebBwZrv6CGddeIIdF9y2tZYpoVUmTSkjPOhgg",
    "ffLhnuCdeeIIIIJJJJIIedHFD975vtYWoXYZ0u3x6ADcIKKKKJIdEAvYUUoWXqnjhMLMOkVZuxA.bdIJKKKKKKKKKJJIGBwZrv6CGddeIIdF9y2sqWUSSSkkkkjQiPPP",
    "LLLQX4EeIIIIIIeeddcHHbaD9A6xvtrpWqrstv4y79adJKKKKJId#Aw0pXr0uvZVkhNhjUXt3y8DbdIJKKKKKKKJJIIdE7vYq26CGddeeIdF96v0qoTRRkkSSSRjQiPP",
    "NNhT0zGIIIIeedHFED...C987zy4v1ZqXYZ0tvxzB#GeJKKKKJeH#B52Z0246Ax0pSPRmpru4zB#bdeJJKJJJJIeddHaBxtpX1yCGddeeedFCzw1rWTjjkSlTTSRQiPP",
    "iiRpv9cJIIeedb#B6x55yy6y55x4vusrYZs0t35ADbdIJKKKKJeH#9z4u36B#FC51XmVpZtvx79EbcdIIJIIedcGFEDBy2ZoWt5CGdddeedb.AxuZWTQjklmUmlkjiPP",
    "mmn0y#eJJIedH#A41Zstu2333w4wvutsss0tt369aceJJKKKJIdG#CA64zCFdIH.6uYrs12wyACEbHddeIdcHFE.9875v0Xno05CGddddedbD8yvspTQQklUonTkjiPP",
    "qqr3BGIJJIecFB40omnWXr0tu23wv21tttttt3z.GeIJKKKKJIdb#.987CbeJKIcD6vvvwwxz8.abHHcccGaD9A6543usqoTnsx9Gddddddb#9zw0pTiQkTVpomSjiPP",
    "tt15CHIJJedG#72qmRlUVprs1v4x4321tt00026CHeJJJKKKJeH#CBA769beJKJd#62uuuu2468.EaFGHHa#C87yxwv1Zqomnrv7DbGHHHHbE.ByuYUjjlmopWnTSRjj",
    "vvwz.HeJIdHaCy1XTjSTnWqs2467yxvut0sZrt59GeIJJKKJIdaB76x43z#dIKIHBwZYYYqY02x7B.#abHa#.9Azyx4vtrpnVqtwy89.#FFFaED840WSSTUopWVnUmTT",
    "55y8#GdIdHFD840WSQRlmVXsvy89Ayw2tsrqXZw8FeIJJJKJeG.64321049HIJIaztWVnUmUWr1wyA9#FGaEDCBA7654u0qoopYstvxz8.#EFFb.62qmTUnoWpWWWWWW",
    "AA8CEGddcFDB6vZokijkTUWsw7DE97x2tZYpoqv7adIIJJJId#AwutZYquzaeJdDxYTkRjiiSnqt35ACEbaa#DCB87zy31rpoooWWq0v5AC#FHdF84sonVVoWpXqrrrr",
    "CC.#aGHcb#97xuqnRPQRSTos48FG#8yvtrXoUWu6EdIIIIJeG9y1ZYpVnZxDdJdB2oiPhgNNORUX03yB#baaE#D.98Az420YWnmlRlWZ2y8DbcecD6uXoWooWpYZt111",
    "EEaFbHHHFDBz4urWlRSlmnp1y.HdF9y2sqomSmZx.ceeIIIdEAwsqWnTSp28beb71ViPhhggOjToY14zCE#E#DDC98Az42sqoUlkQSVr2yBEHeJebB40rrYYYrstu222",
    "bbGGHccdG#9753trpVoWXqsw8adeG9y1YomRPRpu7FHHccdbC6vZXVmkQUZxCG.y1WSkRRjRkTUoXs2x7B9CCCCBAzyx20qonUmmTVYux8#GdIJJdE84vv22uuuuu111",
    "HHHccdddHECAy4vu0Zss0t26DHIIHC5tpUkPgOmZx.aaFFFD852ZpnSQPkp1yC74tXnnnVVoVVVoWY0vx67A8BBAz54v0YWUTmUVoqt47DbdIJKJIcE87z66yxwvut00",
    "ddddddedHFD86y5xw333ww5BbdJJc.xsVSPgMNjp2ACCCCC86w1rWmROgPmq25420rXqYZs0rqponpY02wxyzAAz5w2tYWUSSTnpYtwzCbdIJKKKJIcF##D.9Aywu0ZZ",
    "eeeeeeeedb#B7777777z7zAEdIJJd.xrmjhMLLOUsxz7777y420YoligNgjUY11t0sstu34x20qomVpYs1v45z7yw2tZpnljjTortw69FdIJKKKKKJIddcHHbDAxuZrr",
    "eeeeeIIedb#B77AA88A77zA#cIJJdC4qTQgMLLhTYw5555542trXnkPgMgPlors0t1u3x6A8yvsXnopqZs1vw5542trqoUlRknXt368#HdIJKKKKKKJIedddHaByvsZZ",
    "ddddddedHa.Ayy555x4w3vwzDGeea7vqmRPgMNinZw5xxx4v1ZXVmRPhNhQTorstuv4yz8C.Ay31rZs0001u2vvu0ZqXWooVWYt3yACEHdIJKKKKKJIeddHHb#Bz42uu",
    "HHHHcdddG#9zxw3vu1tsZrZv69Fb95uqnlQPgOkWsw5x4wwusqVmSjiOhPRmoYs13x6AB.#E.Bzx3322u111tt0ZYXWppqYZ024yACDFHdIJJKKKKJIdcHba#.B76x44",
    "aaFbGHcHF.8y321srqXoVUVYuxABy30qVmSRiRUqtwx4w3vtrWmkjQQPPjSUoqs24z8C#abGFE.B7z543u10ZYqpWoVoqs13x67BC#abHdeIJKKKJIecGbEDC9B8A7zz",
    "DD#EabHHaC7x2trXoUmSRQjmX034vtZqWVUmlmWr1wxw322sXVSiPiQQjkTnoqsvy8DabHcdcHGFE.8zxv1sYWVnUUmVY1479CD#aFbHHcdIJJKJJIdHFED988BB9999",
    "AA89.#FFDB64usYWnTSQPOPknqt2utsZYqXXXqs13x5w3u1rWURPPijRSTmnoXsv69abHcddddcHGECA5vtZXnUTTTTVr2yCEaFbGHHHHHdeIJJJIecbE#CBA89.#EEE",
    "vv3x6AC.97y4v10rXWnlRiiTWsvxxx44wwwwwwxyzA75w1sqWnljjRkSlTmnVWZv6CabGHHcHHGba.8642tZqWVnUUmVr2y9#abGHHHHHGHcdeeedHGE##D..DEFGHHH",
    "qqYs24zA76543vu10sqVTkRnYu5AA89CCCC.....DD96wtrponmllllllTmUnor26CFbGGGGbFE#.Bz53utsrXpoVnUVr2y9#abHccHHGFbbbGGbFaED#EEaFGHcdddd",
    "SSTVqtw555x444ww3vtqoTlW0w7.#aGHdddddddHHG#A40XooVnnUUmmTTmUUnY26CFbbFFaE#.CB754210sZrYXWonor25BDabHddHGbaEDD.CCCCCCDEbHcdeeIIII",
    "hhOjmX0vww44x5yyz6w0qVUYuyCFHdIJJJJJKJJIedbBxsWnVoWWWVnUmTmmmUqu6CbbFa#D.98Azy4v1000sssYXWVor258.abcddHGa#.BAzy6z788.aHdeIIJJJJJ",
    "LLMhjnruvwx56zA8996vspos37DHdIJKKKKKKKKJJIHCxZVUVWXYqponmTTTTTXt59FFEDCB876yxw210ss0011sYXWpsvyBDaGcddHF#C8z54v34yzA.aHeIJJJJKKK",
    "LLMhkW0wxyzAB9..#DA41YXsvyBEHeJKKKKKKKKJIda8wZVnWXr0ZqonlSSkkkVrv6998765432100ZZYrZ0t1ut0sYZ258#FGHcdHaDBzyxw3v3xy78.aHdIIIJJJJJ",
    "LLMOlX2y78C.#EaaFa9630Y02469adIJKKKKKKJIdb.6vrVVpr0u0YWUSRjjQQTW036yxw210ZqpWWWppXYstuv2uu12xADGHHHHHF.Ay3vvvvvw56AB.EbHdeeIIIII",
    "LLMPmrw89DaFGHHHHGDAxustuvw6CGeJKKKKKJIdGDAxuYVoqsuwuZWmRQiPPPRUX0v210rqpVmlklTUnWqZt23wwww5ADbdedcHb#85vss01234yz89.EFGHcddeeee",
    "LLMPn0y.EbHdddddddF96311111wAadJJJJJJJeH#8y3tqVWrt3530pTQPPhhgPknpZYXWnmlRPOhPQkTVprtv4x5y6A.bdIIedGa96vsppYsu3x67BC.#EFbGHHcddd",
    "LLMPV17aGcdeIIIIedGDAx2110Z1yDcJJJJJJIda96wusqVWZu4z4tpTiOhggNhiSUWVUTkjPhNMMNhikUWrtvxyzA8.FdIJJIdG#A4tXmUpr13x67BC.##EEaFbGHHH",
    "LLMPV17aGcdeIIIIedGDAx21tsrt5.HIJJJJJIcEBy31ZXVWZu4z4tplPhhgNNhPkmonmlRQPhNMLNhPRmoYtvxyzA8.FdIJJIdbD7w0pTmWYt3x67BC.DD##EaFbGGG",
    "LLMPV17aGcdeIIIIedGDAx21tsrt5.HIJJJJJIcEBy31ZXVWZu4z4tplPhhgNNhPkmonmlRQPhNMLNhPRmoYtvxyzA8.FdIJJIdbD7w0pTmWYt3x67BC.DD##EaFbGGG" };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// topLevelShellWidgetClass
// file /usr/include/X11/Shell.h line 556
extern struct _WidgetClassRec *topLevelShellWidgetClass;
// xscreensaver_function_table
// file atlantis.c line 578
struct xscreensaver_function_table *xscreensaver_function_table;
// xscreensaver_function_table
// file atlantis.c line 578
struct xscreensaver_function_table *xscreensaver_function_table = &atlantis_xscreensaver_function_table;

// AllDisplay
// file atlantis.c line 399
static void AllDisplay(struct anonymous *ap)
{
  signed int i;
  clear_tank(ap);
  i = 0;
  for( ; !(i >= ap->num_sharks); i = i + 1)
  {
    glPushMatrix();
    FishTransform(&ap->sharks[(signed long int)i]);
    DrawShark(&ap->sharks[(signed long int)i], ap->wire);
    glPopMatrix();
  }
  glPushMatrix();
  FishTransform(&ap->dolph);
  DrawDolphin(&ap->dolph, ap->wire);
  glPopMatrix();
  glPushMatrix();
  FishTransform(&ap->momWhale);
  DrawWhale(&ap->momWhale, ap->wire);
  glPopMatrix();
  glPushMatrix();
  FishTransform(&ap->babyWhale);
  glScalef((float)0.45, (float)0.45, (float)0.3);
  DrawWhale(&ap->babyWhale, ap->wire);
  glPopMatrix();
}

// Animate
// file atlantis.c line 382
static void Animate(struct anonymous *ap)
{
  signed int i = 0;
  for( ; !(i >= ap->num_sharks); i = i + 1)
  {
    SharkPilot(&ap->sharks[(signed long int)i], ap->sharkspeed);
    SharkMiss(ap, i);
  }
  WhalePilot(&ap->dolph, ap->whalespeed, ap->whaledir);
  ap->dolph.phi = ap->dolph.phi + 1.000000f;
  WhalePilot(&ap->momWhale, ap->whalespeed, ap->whaledir);
  ap->momWhale.phi = ap->momWhale.phi + 1.000000f;
  WhalePilot(&ap->babyWhale, ap->whalespeed, ap->whaledir);
  ap->babyWhale.phi = ap->babyWhale.phi + 1.000000f;
}

// BadValue_ehandler
// file xlock-gl-utils.c line 36
static signed int BadValue_ehandler(struct _XDisplay *dpy, struct anonymous_64 *error)
{
  signed int return_value;
  if((signed int)error->error_code == 2)
  {
    got_error = 1;
    return 0;
  }

  else
  {
    return_value=orig_ehandler(dpy, error);
    return return_value;
  }
}

// Dolphin001
// file dolphin.c line 461
static void Dolphin001(unsigned int cap)
{
  glNormal3fv(N071);
  glBegin(cap);
  glVertex3fv(P001);
  glVertex3fv(P068);
  glVertex3fv(P010);
  glEnd();
  glBegin(cap);
  glVertex3fv(P068);
  glVertex3fv(P076);
  glVertex3fv(P010);
  glEnd();
  glBegin(cap);
  glVertex3fv(P068);
  glVertex3fv(P070);
  glVertex3fv(P076);
  glEnd();
  glBegin(cap);
  glVertex3fv(P076);
  glVertex3fv(P070);
  glVertex3fv(P074);
  glEnd();
  glBegin(cap);
  glVertex3fv(P070);
  glVertex3fv(P072);
  glVertex3fv(P074);
  glEnd();
  glNormal3fv(N119);
  glBegin(cap);
  glVertex3fv(P072);
  glVertex3fv(P070);
  glVertex3fv(P074);
  glEnd();
  glBegin(cap);
  glVertex3fv(P074);
  glVertex3fv(P070);
  glVertex3fv(P076);
  glEnd();
  glBegin(cap);
  glVertex3fv(P070);
  glVertex3fv(P068);
  glVertex3fv(P076);
  glEnd();
  glBegin(cap);
  glVertex3fv(P076);
  glVertex3fv(P068);
  glVertex3fv(P010);
  glEnd();
  glBegin(cap);
  glVertex3fv(P068);
  glVertex3fv(P001);
  glVertex3fv(P010);
  glEnd();
}

// Dolphin002
// file dolphin.c line 518
static void Dolphin002(unsigned int cap)
{
  glNormal3fv(N071);
  glBegin(cap);
  glVertex3fv(P011);
  glVertex3fv(P001);
  glVertex3fv(P009);
  glEnd();
  glBegin(cap);
  glVertex3fv(P075);
  glVertex3fv(P011);
  glVertex3fv(P009);
  glEnd();
  glBegin(cap);
  glVertex3fv(P069);
  glVertex3fv(P011);
  glVertex3fv(P075);
  glEnd();
  glBegin(cap);
  glVertex3fv(P069);
  glVertex3fv(P075);
  glVertex3fv(P073);
  glEnd();
  glBegin(cap);
  glVertex3fv(P071);
  glVertex3fv(P069);
  glVertex3fv(P073);
  glEnd();
  glNormal3fv(N119);
  glBegin(cap);
  glVertex3fv(P001);
  glVertex3fv(P011);
  glVertex3fv(P009);
  glEnd();
  glBegin(cap);
  glVertex3fv(P009);
  glVertex3fv(P011);
  glVertex3fv(P075);
  glEnd();
  glBegin(cap);
  glVertex3fv(P011);
  glVertex3fv(P069);
  glVertex3fv(P075);
  glEnd();
  glBegin(cap);
  glVertex3fv(P069);
  glVertex3fv(P073);
  glVertex3fv(P075);
  glEnd();
  glBegin(cap);
  glVertex3fv(P069);
  glVertex3fv(P071);
  glVertex3fv(P073);
  glEnd();
}

// Dolphin003
// file dolphin.c line 575
static void Dolphin003(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N018);
  glVertex3fv(P018);
  glNormal3fv(N001);
  glVertex3fv(P001);
  glNormal3fv(N019);
  glVertex3fv(P019);
  glEnd();
  glBegin(cap);
  glNormal3fv(N019);
  glVertex3fv(P019);
  glNormal3fv(N001);
  glVertex3fv(P001);
  glNormal3fv(N012);
  glVertex3fv(P012);
  glEnd();
  glBegin(cap);
  glNormal3fv(N017);
  glVertex3fv(P017);
  glNormal3fv(N001);
  glVertex3fv(P001);
  glNormal3fv(N018);
  glVertex3fv(P018);
  glEnd();
  glBegin(cap);
  glNormal3fv(N001);
  glVertex3fv(P001);
  glNormal3fv(N017);
  glVertex3fv(P017);
  glNormal3fv(N016);
  glVertex3fv(P016);
  glEnd();
  glBegin(cap);
  glNormal3fv(N001);
  glVertex3fv(P001);
  glNormal3fv(N013);
  glVertex3fv(P013);
  glNormal3fv(N012);
  glVertex3fv(P012);
  glEnd();
  glBegin(cap);
  glNormal3fv(N001);
  glVertex3fv(P001);
  glNormal3fv(N016);
  glVertex3fv(P016);
  glNormal3fv(N015);
  glVertex3fv(P015);
  glEnd();
  glBegin(cap);
  glNormal3fv(N001);
  glVertex3fv(P001);
  glNormal3fv(N014);
  glVertex3fv(P014);
  glNormal3fv(N013);
  glVertex3fv(P013);
  glEnd();
  glBegin(cap);
  glNormal3fv(N001);
  glVertex3fv(P001);
  glNormal3fv(N015);
  glVertex3fv(P015);
  glNormal3fv(N014);
  glVertex3fv(P014);
  glEnd();
}

// Dolphin004
// file dolphin.c line 644
static void Dolphin004(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N014);
  glVertex3fv(P014);
  glNormal3fv(N015);
  glVertex3fv(P015);
  glNormal3fv(N023);
  glVertex3fv(P023);
  glNormal3fv(N022);
  glVertex3fv(P022);
  glEnd();
  glBegin(cap);
  glNormal3fv(N015);
  glVertex3fv(P015);
  glNormal3fv(N016);
  glVertex3fv(P016);
  glNormal3fv(N024);
  glVertex3fv(P024);
  glNormal3fv(N023);
  glVertex3fv(P023);
  glEnd();
  glBegin(cap);
  glNormal3fv(N016);
  glVertex3fv(P016);
  glNormal3fv(N017);
  glVertex3fv(P017);
  glNormal3fv(N025);
  glVertex3fv(P025);
  glNormal3fv(N024);
  glVertex3fv(P024);
  glEnd();
  glBegin(cap);
  glNormal3fv(N017);
  glVertex3fv(P017);
  glNormal3fv(N018);
  glVertex3fv(P018);
  glNormal3fv(N026);
  glVertex3fv(P026);
  glNormal3fv(N025);
  glVertex3fv(P025);
  glEnd();
  glBegin(cap);
  glNormal3fv(N013);
  glVertex3fv(P013);
  glNormal3fv(N014);
  glVertex3fv(P014);
  glNormal3fv(N022);
  glVertex3fv(P022);
  glNormal3fv(N021);
  glVertex3fv(P021);
  glEnd();
  glBegin(cap);
  glNormal3fv(N012);
  glVertex3fv(P012);
  glNormal3fv(N013);
  glVertex3fv(P013);
  glNormal3fv(N021);
  glVertex3fv(P021);
  glNormal3fv(N020);
  glVertex3fv(P020);
  glEnd();
  glBegin(cap);
  glNormal3fv(N018);
  glVertex3fv(P018);
  glNormal3fv(N019);
  glVertex3fv(P019);
  glNormal3fv(N027);
  glVertex3fv(P027);
  glNormal3fv(N026);
  glVertex3fv(P026);
  glEnd();
  glBegin(cap);
  glNormal3fv(N019);
  glVertex3fv(P019);
  glNormal3fv(N012);
  glVertex3fv(P012);
  glNormal3fv(N020);
  glVertex3fv(P020);
  glNormal3fv(N027);
  glVertex3fv(P027);
  glEnd();
}

// Dolphin005
// file dolphin.c line 729
static void Dolphin005(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N022);
  glVertex3fv(P022);
  glNormal3fv(N023);
  glVertex3fv(P023);
  glNormal3fv(N031);
  glVertex3fv(P031);
  glNormal3fv(N030);
  glVertex3fv(P030);
  glEnd();
  glBegin(cap);
  glNormal3fv(N021);
  glVertex3fv(P021);
  glNormal3fv(N022);
  glVertex3fv(P022);
  glNormal3fv(N030);
  glVertex3fv(P030);
  glEnd();
  glBegin(cap);
  glNormal3fv(N021);
  glVertex3fv(P021);
  glNormal3fv(N030);
  glVertex3fv(P030);
  glNormal3fv(N029);
  glVertex3fv(P029);
  glEnd();
  glBegin(cap);
  glNormal3fv(N023);
  glVertex3fv(P023);
  glNormal3fv(N024);
  glVertex3fv(P024);
  glNormal3fv(N031);
  glVertex3fv(P031);
  glEnd();
  glBegin(cap);
  glNormal3fv(N024);
  glVertex3fv(P024);
  glNormal3fv(N032);
  glVertex3fv(P032);
  glNormal3fv(N031);
  glVertex3fv(P031);
  glEnd();
  glBegin(cap);
  glNormal3fv(N024);
  glVertex3fv(P024);
  glNormal3fv(N025);
  glVertex3fv(P025);
  glNormal3fv(N032);
  glVertex3fv(P032);
  glEnd();
  glBegin(cap);
  glNormal3fv(N025);
  glVertex3fv(P025);
  glNormal3fv(N033);
  glVertex3fv(P033);
  glNormal3fv(N032);
  glVertex3fv(P032);
  glEnd();
  glBegin(cap);
  glNormal3fv(N020);
  glVertex3fv(P020);
  glNormal3fv(N021);
  glVertex3fv(P021);
  glNormal3fv(N029);
  glVertex3fv(P029);
  glEnd();
  glBegin(cap);
  glNormal3fv(N020);
  glVertex3fv(P020);
  glNormal3fv(N029);
  glVertex3fv(P029);
  glNormal3fv(N028);
  glVertex3fv(P028);
  glEnd();
  glBegin(cap);
  glNormal3fv(N027);
  glVertex3fv(P027);
  glNormal3fv(N020);
  glVertex3fv(P020);
  glNormal3fv(N028);
  glVertex3fv(P028);
  glEnd();
  glBegin(cap);
  glNormal3fv(N027);
  glVertex3fv(P027);
  glNormal3fv(N028);
  glVertex3fv(P028);
  glNormal3fv(N035);
  glVertex3fv(P035);
  glEnd();
  glBegin(cap);
  glNormal3fv(N025);
  glVertex3fv(P025);
  glNormal3fv(N026);
  glVertex3fv(P026);
  glNormal3fv(N033);
  glVertex3fv(P033);
  glEnd();
  glBegin(cap);
  glNormal3fv(N033);
  glVertex3fv(P033);
  glNormal3fv(N026);
  glVertex3fv(P026);
  glNormal3fv(N034);
  glVertex3fv(P034);
  glEnd();
  glBegin(cap);
  glNormal3fv(N026);
  glVertex3fv(P026);
  glNormal3fv(N027);
  glVertex3fv(P027);
  glNormal3fv(N035);
  glVertex3fv(P035);
  glNormal3fv(N034);
  glVertex3fv(P034);
  glEnd();
}

// Dolphin006
// file dolphin.c line 850
static void Dolphin006(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N092);
  glVertex3fv(P092);
  glNormal3fv(N093);
  glVertex3fv(P093);
  glNormal3fv(N094);
  glVertex3fv(P094);
  glEnd();
  glBegin(cap);
  glNormal3fv(N093);
  glVertex3fv(P093);
  glNormal3fv(N092);
  glVertex3fv(P092);
  glNormal3fv(N094);
  glVertex3fv(P094);
  glEnd();
  glBegin(cap);
  glNormal3fv(N092);
  glVertex3fv(P092);
  glNormal3fv(N091);
  glVertex3fv(P091);
  glNormal3fv(N095);
  glVertex3fv(P095);
  glNormal3fv(N094);
  glVertex3fv(P094);
  glEnd();
  glBegin(cap);
  glNormal3fv(N091);
  glVertex3fv(P091);
  glNormal3fv(N092);
  glVertex3fv(P092);
  glNormal3fv(N094);
  glVertex3fv(P094);
  glNormal3fv(N095);
  glVertex3fv(P095);
  glEnd();
  glBegin(cap);
  glNormal3fv(N122);
  glVertex3fv(P122);
  glNormal3fv(N095);
  glVertex3fv(P095);
  glNormal3fv(N091);
  glVertex3fv(P091);
  glEnd();
  glBegin(cap);
  glNormal3fv(N122);
  glVertex3fv(P122);
  glNormal3fv(N091);
  glVertex3fv(P091);
  glNormal3fv(N095);
  glVertex3fv(P095);
  glEnd();
}

// Dolphin007
// file dolphin.c line 907
static void Dolphin007(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N030);
  glVertex3fv(P030);
  glNormal3fv(N031);
  glVertex3fv(P031);
  glNormal3fv(N039);
  glVertex3fv(P039);
  glNormal3fv(N038);
  glVertex3fv(P038);
  glEnd();
  glBegin(cap);
  glNormal3fv(N029);
  glVertex3fv(P029);
  glNormal3fv(N030);
  glVertex3fv(P030);
  glNormal3fv(N038);
  glVertex3fv(P038);
  glEnd();
  glBegin(cap);
  glNormal3fv(N029);
  glVertex3fv(P029);
  glNormal3fv(N038);
  glVertex3fv(P038);
  glNormal3fv(N037);
  glVertex3fv(P037);
  glEnd();
  glBegin(cap);
  glNormal3fv(N028);
  glVertex3fv(P028);
  glNormal3fv(N029);
  glVertex3fv(P029);
  glNormal3fv(N037);
  glVertex3fv(P037);
  glEnd();
  glBegin(cap);
  glNormal3fv(N028);
  glVertex3fv(P028);
  glNormal3fv(N037);
  glVertex3fv(P037);
  glNormal3fv(N036);
  glVertex3fv(P036);
  glEnd();
  glBegin(cap);
  glNormal3fv(N035);
  glVertex3fv(P035);
  glNormal3fv(N028);
  glVertex3fv(P028);
  glNormal3fv(N036);
  glVertex3fv(P036);
  glEnd();
  glBegin(cap);
  glNormal3fv(N035);
  glVertex3fv(P035);
  glNormal3fv(N036);
  glVertex3fv(P036);
  glNormal3fv(N043);
  glVertex3fv(P043);
  glEnd();
  glBegin(cap);
  glNormal3fv(N034);
  glVertex3fv(P034);
  glNormal3fv(N035);
  glVertex3fv(P035);
  glNormal3fv(N043);
  glVertex3fv(P043);
  glNormal3fv(N042);
  glVertex3fv(P042);
  glEnd();
  glBegin(cap);
  glNormal3fv(N033);
  glVertex3fv(P033);
  glNormal3fv(N034);
  glVertex3fv(P034);
  glNormal3fv(N042);
  glVertex3fv(P042);
  glEnd();
  glBegin(cap);
  glNormal3fv(N033);
  glVertex3fv(P033);
  glNormal3fv(N042);
  glVertex3fv(P042);
  glNormal3fv(N041);
  glVertex3fv(P041);
  glEnd();
  glBegin(cap);
  glNormal3fv(N031);
  glVertex3fv(P031);
  glNormal3fv(N032);
  glVertex3fv(P032);
  glNormal3fv(N039);
  glVertex3fv(P039);
  glEnd();
  glBegin(cap);
  glNormal3fv(N039);
  glVertex3fv(P039);
  glNormal3fv(N032);
  glVertex3fv(P032);
  glNormal3fv(N040);
  glVertex3fv(P040);
  glEnd();
  glBegin(cap);
  glNormal3fv(N032);
  glVertex3fv(P032);
  glNormal3fv(N033);
  glVertex3fv(P033);
  glNormal3fv(N040);
  glVertex3fv(P040);
  glEnd();
  glBegin(cap);
  glNormal3fv(N040);
  glVertex3fv(P040);
  glNormal3fv(N033);
  glVertex3fv(P033);
  glNormal3fv(N041);
  glVertex3fv(P041);
  glEnd();
}

// Dolphin008
// file dolphin.c line 1028
static void Dolphin008(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N042);
  glVertex3fv(P042);
  glNormal3fv(N043);
  glVertex3fv(P043);
  glNormal3fv(N051);
  glVertex3fv(P051);
  glNormal3fv(N050);
  glVertex3fv(P050);
  glEnd();
  glBegin(cap);
  glNormal3fv(N043);
  glVertex3fv(P043);
  glNormal3fv(N036);
  glVertex3fv(P036);
  glNormal3fv(N051);
  glVertex3fv(P051);
  glEnd();
  glBegin(cap);
  glNormal3fv(N051);
  glVertex3fv(P051);
  glNormal3fv(N036);
  glVertex3fv(P036);
  glNormal3fv(N044);
  glVertex3fv(P044);
  glEnd();
  glBegin(cap);
  glNormal3fv(N041);
  glVertex3fv(P041);
  glNormal3fv(N042);
  glVertex3fv(P042);
  glNormal3fv(N050);
  glVertex3fv(P050);
  glEnd();
  glBegin(cap);
  glNormal3fv(N041);
  glVertex3fv(P041);
  glNormal3fv(N050);
  glVertex3fv(P050);
  glNormal3fv(N049);
  glVertex3fv(P049);
  glEnd();
  glBegin(cap);
  glNormal3fv(N036);
  glVertex3fv(P036);
  glNormal3fv(N037);
  glVertex3fv(P037);
  glNormal3fv(N044);
  glVertex3fv(P044);
  glEnd();
  glBegin(cap);
  glNormal3fv(N044);
  glVertex3fv(P044);
  glNormal3fv(N037);
  glVertex3fv(P037);
  glNormal3fv(N045);
  glVertex3fv(P045);
  glEnd();
  glBegin(cap);
  glNormal3fv(N040);
  glVertex3fv(P040);
  glNormal3fv(N041);
  glVertex3fv(P041);
  glNormal3fv(N049);
  glVertex3fv(P049);
  glEnd();
  glBegin(cap);
  glNormal3fv(N040);
  glVertex3fv(P040);
  glNormal3fv(N049);
  glVertex3fv(P049);
  glNormal3fv(N048);
  glVertex3fv(P048);
  glEnd();
  glBegin(cap);
  glNormal3fv(N039);
  glVertex3fv(P039);
  glNormal3fv(N040);
  glVertex3fv(P040);
  glNormal3fv(N048);
  glVertex3fv(P048);
  glEnd();
  glBegin(cap);
  glNormal3fv(N039);
  glVertex3fv(P039);
  glNormal3fv(N048);
  glVertex3fv(P048);
  glNormal3fv(N047);
  glVertex3fv(P047);
  glEnd();
  glBegin(cap);
  glNormal3fv(N037);
  glVertex3fv(P037);
  glNormal3fv(N038);
  glVertex3fv(P038);
  glNormal3fv(N045);
  glVertex3fv(P045);
  glEnd();
  glBegin(cap);
  glNormal3fv(N038);
  glVertex3fv(P038);
  glNormal3fv(N046);
  glVertex3fv(P046);
  glNormal3fv(N045);
  glVertex3fv(P045);
  glEnd();
  glBegin(cap);
  glNormal3fv(N038);
  glVertex3fv(P038);
  glNormal3fv(N039);
  glVertex3fv(P039);
  glNormal3fv(N047);
  glVertex3fv(P047);
  glNormal3fv(N046);
  glVertex3fv(P046);
  glEnd();
}

// Dolphin009
// file dolphin.c line 1149
static void Dolphin009(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N050);
  glVertex3fv(P050);
  glNormal3fv(N051);
  glVertex3fv(P051);
  glNormal3fv(N059);
  glVertex3fv(P059);
  glNormal3fv(N058);
  glVertex3fv(P058);
  glEnd();
  glBegin(cap);
  glNormal3fv(N051);
  glVertex3fv(P051);
  glNormal3fv(N044);
  glVertex3fv(P044);
  glNormal3fv(N059);
  glVertex3fv(P059);
  glEnd();
  glBegin(cap);
  glNormal3fv(N059);
  glVertex3fv(P059);
  glNormal3fv(N044);
  glVertex3fv(P044);
  glNormal3fv(N052);
  glVertex3fv(P052);
  glEnd();
  glBegin(cap);
  glNormal3fv(N044);
  glVertex3fv(P044);
  glNormal3fv(N045);
  glVertex3fv(P045);
  glNormal3fv(N053);
  glVertex3fv(P053);
  glEnd();
  glBegin(cap);
  glNormal3fv(N044);
  glVertex3fv(P044);
  glNormal3fv(N053);
  glVertex3fv(P053);
  glNormal3fv(N052);
  glVertex3fv(P052);
  glEnd();
  glBegin(cap);
  glNormal3fv(N049);
  glVertex3fv(P049);
  glNormal3fv(N050);
  glVertex3fv(P050);
  glNormal3fv(N058);
  glVertex3fv(P058);
  glEnd();
  glBegin(cap);
  glNormal3fv(N049);
  glVertex3fv(P049);
  glNormal3fv(N058);
  glVertex3fv(P058);
  glNormal3fv(N057);
  glVertex3fv(P057);
  glEnd();
  glBegin(cap);
  glNormal3fv(N048);
  glVertex3fv(P048);
  glNormal3fv(N049);
  glVertex3fv(P049);
  glNormal3fv(N057);
  glVertex3fv(P057);
  glEnd();
  glBegin(cap);
  glNormal3fv(N048);
  glVertex3fv(P048);
  glNormal3fv(N057);
  glVertex3fv(P057);
  glNormal3fv(N056);
  glVertex3fv(P056);
  glEnd();
  glBegin(cap);
  glNormal3fv(N047);
  glVertex3fv(P047);
  glNormal3fv(N048);
  glVertex3fv(P048);
  glNormal3fv(N056);
  glVertex3fv(P056);
  glEnd();
  glBegin(cap);
  glNormal3fv(N047);
  glVertex3fv(P047);
  glNormal3fv(N056);
  glVertex3fv(P056);
  glNormal3fv(N055);
  glVertex3fv(P055);
  glEnd();
  glBegin(cap);
  glNormal3fv(N045);
  glVertex3fv(P045);
  glNormal3fv(N046);
  glVertex3fv(P046);
  glNormal3fv(N053);
  glVertex3fv(P053);
  glEnd();
  glBegin(cap);
  glNormal3fv(N046);
  glVertex3fv(P046);
  glNormal3fv(N054);
  glVertex3fv(P054);
  glNormal3fv(N053);
  glVertex3fv(P053);
  glEnd();
  glBegin(cap);
  glNormal3fv(N046);
  glVertex3fv(P046);
  glNormal3fv(N047);
  glVertex3fv(P047);
  glNormal3fv(N055);
  glVertex3fv(P055);
  glNormal3fv(N054);
  glVertex3fv(P054);
  glEnd();
}

// Dolphin010
// file dolphin.c line 1270
static void Dolphin010(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N080);
  glVertex3fv(P080);
  glNormal3fv(N081);
  glVertex3fv(P081);
  glNormal3fv(N085);
  glVertex3fv(P085);
  glEnd();
  glBegin(cap);
  glNormal3fv(N081);
  glVertex3fv(P081);
  glNormal3fv(N083);
  glVertex3fv(P083);
  glNormal3fv(N085);
  glVertex3fv(P085);
  glEnd();
  glBegin(cap);
  glNormal3fv(N085);
  glVertex3fv(P085);
  glNormal3fv(N083);
  glVertex3fv(P083);
  glNormal3fv(N077);
  glVertex3fv(P077);
  glEnd();
  glBegin(cap);
  glNormal3fv(N083);
  glVertex3fv(P083);
  glNormal3fv(N087);
  glVertex3fv(P087);
  glNormal3fv(N077);
  glVertex3fv(P077);
  glEnd();
  glBegin(cap);
  glNormal3fv(N077);
  glVertex3fv(P077);
  glNormal3fv(N087);
  glVertex3fv(P087);
  glNormal3fv(N090);
  glVertex3fv(P090);
  glEnd();
  glBegin(cap);
  glNormal3fv(N081);
  glVertex3fv(P081);
  glNormal3fv(N080);
  glVertex3fv(P080);
  glNormal3fv(N085);
  glVertex3fv(P085);
  glEnd();
  glBegin(cap);
  glNormal3fv(N083);
  glVertex3fv(P083);
  glNormal3fv(N081);
  glVertex3fv(P081);
  glNormal3fv(N085);
  glVertex3fv(P085);
  glEnd();
  glBegin(cap);
  glNormal3fv(N083);
  glVertex3fv(P083);
  glNormal3fv(N085);
  glVertex3fv(P085);
  glNormal3fv(N077);
  glVertex3fv(P077);
  glEnd();
  glBegin(cap);
  glNormal3fv(N087);
  glVertex3fv(P087);
  glNormal3fv(N083);
  glVertex3fv(P083);
  glNormal3fv(N077);
  glVertex3fv(P077);
  glEnd();
  glBegin(cap);
  glNormal3fv(N087);
  glVertex3fv(P087);
  glNormal3fv(N077);
  glVertex3fv(P077);
  glNormal3fv(N090);
  glVertex3fv(P090);
  glEnd();
}

// Dolphin011
// file dolphin.c line 1355
static void Dolphin011(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N082);
  glVertex3fv(P082);
  glNormal3fv(N084);
  glVertex3fv(P084);
  glNormal3fv(N079);
  glVertex3fv(P079);
  glEnd();
  glBegin(cap);
  glNormal3fv(N084);
  glVertex3fv(P084);
  glNormal3fv(N086);
  glVertex3fv(P086);
  glNormal3fv(N079);
  glVertex3fv(P079);
  glEnd();
  glBegin(cap);
  glNormal3fv(N079);
  glVertex3fv(P079);
  glNormal3fv(N086);
  glVertex3fv(P086);
  glNormal3fv(N078);
  glVertex3fv(P078);
  glEnd();
  glBegin(cap);
  glNormal3fv(N086);
  glVertex3fv(P086);
  glNormal3fv(N088);
  glVertex3fv(P088);
  glNormal3fv(N078);
  glVertex3fv(P078);
  glEnd();
  glBegin(cap);
  glNormal3fv(N078);
  glVertex3fv(P078);
  glNormal3fv(N088);
  glVertex3fv(P088);
  glNormal3fv(N089);
  glVertex3fv(P089);
  glEnd();
  glBegin(cap);
  glNormal3fv(N088);
  glVertex3fv(P088);
  glNormal3fv(N086);
  glVertex3fv(P086);
  glNormal3fv(N089);
  glVertex3fv(P089);
  glEnd();
  glBegin(cap);
  glNormal3fv(N089);
  glVertex3fv(P089);
  glNormal3fv(N086);
  glVertex3fv(P086);
  glNormal3fv(N078);
  glVertex3fv(P078);
  glEnd();
  glBegin(cap);
  glNormal3fv(N086);
  glVertex3fv(P086);
  glNormal3fv(N084);
  glVertex3fv(P084);
  glNormal3fv(N078);
  glVertex3fv(P078);
  glEnd();
  glBegin(cap);
  glNormal3fv(N078);
  glVertex3fv(P078);
  glNormal3fv(N084);
  glVertex3fv(P084);
  glNormal3fv(N079);
  glVertex3fv(P079);
  glEnd();
  glBegin(cap);
  glNormal3fv(N084);
  glVertex3fv(P084);
  glNormal3fv(N082);
  glVertex3fv(P082);
  glNormal3fv(N079);
  glVertex3fv(P079);
  glEnd();
}

// Dolphin012
// file dolphin.c line 1440
static void Dolphin012(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N058);
  glVertex3fv(P058);
  glNormal3fv(N059);
  glVertex3fv(P059);
  glNormal3fv(N067);
  glVertex3fv(P067);
  glNormal3fv(N066);
  glVertex3fv(P066);
  glEnd();
  glBegin(cap);
  glNormal3fv(N059);
  glVertex3fv(P059);
  glNormal3fv(N052);
  glVertex3fv(P052);
  glNormal3fv(N060);
  glVertex3fv(P060);
  glEnd();
  glBegin(cap);
  glNormal3fv(N059);
  glVertex3fv(P059);
  glNormal3fv(N060);
  glVertex3fv(P060);
  glNormal3fv(N067);
  glVertex3fv(P067);
  glEnd();
  glBegin(cap);
  glNormal3fv(N058);
  glVertex3fv(P058);
  glNormal3fv(N066);
  glVertex3fv(P066);
  glNormal3fv(N065);
  glVertex3fv(P065);
  glEnd();
  glBegin(cap);
  glNormal3fv(N058);
  glVertex3fv(P058);
  glNormal3fv(N065);
  glVertex3fv(P065);
  glNormal3fv(N057);
  glVertex3fv(P057);
  glEnd();
  glBegin(cap);
  glNormal3fv(N056);
  glVertex3fv(P056);
  glNormal3fv(N057);
  glVertex3fv(P057);
  glNormal3fv(N065);
  glVertex3fv(P065);
  glEnd();
  glBegin(cap);
  glNormal3fv(N056);
  glVertex3fv(P056);
  glNormal3fv(N065);
  glVertex3fv(P065);
  glNormal3fv(N006);
  glVertex3fv(P006);
  glEnd();
  glBegin(cap);
  glNormal3fv(N056);
  glVertex3fv(P056);
  glNormal3fv(N006);
  glVertex3fv(P006);
  glNormal3fv(N063);
  glVertex3fv(P063);
  glEnd();
  glBegin(cap);
  glNormal3fv(N056);
  glVertex3fv(P056);
  glNormal3fv(N063);
  glVertex3fv(P063);
  glNormal3fv(N055);
  glVertex3fv(P055);
  glEnd();
  glBegin(cap);
  glNormal3fv(N054);
  glVertex3fv(P054);
  glNormal3fv(N062);
  glVertex3fv(P062);
  glNormal3fv(N005);
  glVertex3fv(P005);
  glEnd();
  glBegin(cap);
  glNormal3fv(N054);
  glVertex3fv(P054);
  glNormal3fv(N005);
  glVertex3fv(P005);
  glNormal3fv(N053);
  glVertex3fv(P053);
  glEnd();
  glBegin(cap);
  glNormal3fv(N052);
  glVertex3fv(P052);
  glNormal3fv(N053);
  glVertex3fv(P053);
  glNormal3fv(N005);
  glVertex3fv(P005);
  glNormal3fv(N060);
  glVertex3fv(P060);
  glEnd();
}

// Dolphin013
// file dolphin.c line 1545
static void Dolphin013(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N116);
  glVertex3fv(P116);
  glNormal3fv(N117);
  glVertex3fv(P117);
  glNormal3fv(N112);
  glVertex3fv(P112);
  glNormal3fv(N113);
  glVertex3fv(P113);
  glEnd();
  glBegin(cap);
  glNormal3fv(N114);
  glVertex3fv(P114);
  glNormal3fv(N113);
  glVertex3fv(P113);
  glNormal3fv(N112);
  glVertex3fv(P112);
  glNormal3fv(N115);
  glVertex3fv(P115);
  glEnd();
  glBegin(cap);
  glNormal3fv(N114);
  glVertex3fv(P114);
  glNormal3fv(N116);
  glVertex3fv(P116);
  glNormal3fv(N113);
  glVertex3fv(P113);
  glEnd();
  glBegin(cap);
  glNormal3fv(N114);
  glVertex3fv(P114);
  glNormal3fv(N007);
  glVertex3fv(P007);
  glNormal3fv(N116);
  glVertex3fv(P116);
  glEnd();
  glBegin(cap);
  glNormal3fv(N007);
  glVertex3fv(P007);
  glNormal3fv(N002);
  glVertex3fv(P002);
  glNormal3fv(N116);
  glVertex3fv(P116);
  glEnd();
  glBegin(cap);
  glVertex3fv(P002);
  glVertex3fv(P007);
  glVertex3fv(P008);
  glVertex3fv(P099);
  glEnd();
  glBegin(cap);
  glVertex3fv(P007);
  glVertex3fv(P114);
  glVertex3fv(P115);
  glVertex3fv(P008);
  glEnd();
  glBegin(cap);
  glNormal3fv(N117);
  glVertex3fv(P117);
  glNormal3fv(N099);
  glVertex3fv(P099);
  glNormal3fv(N008);
  glVertex3fv(P008);
  glEnd();
  glBegin(cap);
  glNormal3fv(N117);
  glVertex3fv(P117);
  glNormal3fv(N008);
  glVertex3fv(P008);
  glNormal3fv(N112);
  glVertex3fv(P112);
  glEnd();
  glBegin(cap);
  glNormal3fv(N112);
  glVertex3fv(P112);
  glNormal3fv(N008);
  glVertex3fv(P008);
  glNormal3fv(N115);
  glVertex3fv(P115);
  glEnd();
}

// Dolphin014
// file dolphin.c line 1630
static void Dolphin014(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N111);
  glVertex3fv(P111);
  glNormal3fv(N110);
  glVertex3fv(P110);
  glNormal3fv(N102);
  glVertex3fv(P102);
  glNormal3fv(N121);
  glVertex3fv(P121);
  glEnd();
  glBegin(cap);
  glNormal3fv(N111);
  glVertex3fv(P111);
  glNormal3fv(N097);
  glVertex3fv(P097);
  glNormal3fv(N110);
  glVertex3fv(P110);
  glEnd();
  glBegin(cap);
  glNormal3fv(N097);
  glVertex3fv(P097);
  glNormal3fv(N119);
  glVertex3fv(P119);
  glNormal3fv(N110);
  glVertex3fv(P110);
  glEnd();
  glBegin(cap);
  glNormal3fv(N097);
  glVertex3fv(P097);
  glNormal3fv(N099);
  glVertex3fv(P099);
  glNormal3fv(N119);
  glVertex3fv(P119);
  glEnd();
  glBegin(cap);
  glNormal3fv(N099);
  glVertex3fv(P099);
  glNormal3fv(N065);
  glVertex3fv(P065);
  glNormal3fv(N119);
  glVertex3fv(P119);
  glEnd();
  glBegin(cap);
  glNormal3fv(N065);
  glVertex3fv(P065);
  glNormal3fv(N066);
  glVertex3fv(P066);
  glNormal3fv(N119);
  glVertex3fv(P119);
  glEnd();
  glBegin(cap);
  glVertex3fv(P098);
  glVertex3fv(P097);
  glVertex3fv(P111);
  glVertex3fv(P121);
  glEnd();
  glBegin(cap);
  glVertex3fv(P002);
  glVertex3fv(P099);
  glVertex3fv(P097);
  glVertex3fv(P098);
  glEnd();
  glBegin(cap);
  glNormal3fv(N110);
  glVertex3fv(P110);
  glNormal3fv(N119);
  glVertex3fv(P119);
  glNormal3fv(N118);
  glVertex3fv(P118);
  glNormal3fv(N102);
  glVertex3fv(P102);
  glEnd();
  glBegin(cap);
  glNormal3fv(N119);
  glVertex3fv(P119);
  glNormal3fv(N066);
  glVertex3fv(P066);
  glNormal3fv(N067);
  glVertex3fv(P067);
  glNormal3fv(N118);
  glVertex3fv(P118);
  glEnd();
  glBegin(cap);
  glNormal3fv(N067);
  glVertex3fv(P067);
  glNormal3fv(N060);
  glVertex3fv(P060);
  glNormal3fv(N002);
  glVertex3fv(P002);
  glEnd();
  glBegin(cap);
  glNormal3fv(N067);
  glVertex3fv(P067);
  glNormal3fv(N002);
  glVertex3fv(P002);
  glNormal3fv(N118);
  glVertex3fv(P118);
  glEnd();
  glBegin(cap);
  glNormal3fv(N118);
  glVertex3fv(P118);
  glNormal3fv(N002);
  glVertex3fv(P002);
  glNormal3fv(N098);
  glVertex3fv(P098);
  glEnd();
  glBegin(cap);
  glNormal3fv(N118);
  glVertex3fv(P118);
  glNormal3fv(N098);
  glVertex3fv(P098);
  glNormal3fv(N102);
  glVertex3fv(P102);
  glEnd();
  glBegin(cap);
  glNormal3fv(N102);
  glVertex3fv(P102);
  glNormal3fv(N098);
  glVertex3fv(P098);
  glNormal3fv(N121);
  glVertex3fv(P121);
  glEnd();
}

// Dolphin015
// file dolphin.c line 1757
static void Dolphin015(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N055);
  glVertex3fv(P055);
  glNormal3fv(N003);
  glVertex3fv(P003);
  glNormal3fv(N054);
  glVertex3fv(P054);
  glEnd();
  glBegin(cap);
  glNormal3fv(N003);
  glVertex3fv(P003);
  glNormal3fv(N055);
  glVertex3fv(P055);
  glNormal3fv(N063);
  glVertex3fv(P063);
  glEnd();
  glBegin(cap);
  glNormal3fv(N003);
  glVertex3fv(P003);
  glNormal3fv(N063);
  glVertex3fv(P063);
  glNormal3fv(N100);
  glVertex3fv(P100);
  glEnd();
  glBegin(cap);
  glNormal3fv(N003);
  glVertex3fv(P003);
  glNormal3fv(N100);
  glVertex3fv(P100);
  glNormal3fv(N054);
  glVertex3fv(P054);
  glEnd();
  glBegin(cap);
  glNormal3fv(N054);
  glVertex3fv(P054);
  glNormal3fv(N100);
  glVertex3fv(P100);
  glNormal3fv(N062);
  glVertex3fv(P062);
  glEnd();
  glBegin(cap);
  glNormal3fv(N100);
  glVertex3fv(P100);
  glNormal3fv(N064);
  glVertex3fv(P064);
  glNormal3fv(N120);
  glVertex3fv(P120);
  glEnd();
  glBegin(cap);
  glNormal3fv(N100);
  glVertex3fv(P100);
  glNormal3fv(N063);
  glVertex3fv(P063);
  glNormal3fv(N064);
  glVertex3fv(P064);
  glEnd();
  glBegin(cap);
  glNormal3fv(N063);
  glVertex3fv(P063);
  glNormal3fv(N006);
  glVertex3fv(P006);
  glNormal3fv(N064);
  glVertex3fv(P064);
  glEnd();
  glBegin(cap);
  glNormal3fv(N064);
  glVertex3fv(P064);
  glNormal3fv(N006);
  glVertex3fv(P006);
  glNormal3fv(N099);
  glVertex3fv(P099);
  glEnd();
  glBegin(cap);
  glNormal3fv(N064);
  glVertex3fv(P064);
  glNormal3fv(N099);
  glVertex3fv(P099);
  glNormal3fv(N117);
  glVertex3fv(P117);
  glEnd();
  glBegin(cap);
  glNormal3fv(N120);
  glVertex3fv(P120);
  glNormal3fv(N064);
  glVertex3fv(P064);
  glNormal3fv(N117);
  glVertex3fv(P117);
  glNormal3fv(N116);
  glVertex3fv(P116);
  glEnd();
  glBegin(cap);
  glNormal3fv(N006);
  glVertex3fv(P006);
  glNormal3fv(N065);
  glVertex3fv(P065);
  glNormal3fv(N099);
  glVertex3fv(P099);
  glEnd();
  glBegin(cap);
  glNormal3fv(N062);
  glVertex3fv(P062);
  glNormal3fv(N100);
  glVertex3fv(P100);
  glNormal3fv(N120);
  glVertex3fv(P120);
  glEnd();
  glBegin(cap);
  glNormal3fv(N005);
  glVertex3fv(P005);
  glNormal3fv(N062);
  glVertex3fv(P062);
  glNormal3fv(N120);
  glVertex3fv(P120);
  glEnd();
  glBegin(cap);
  glNormal3fv(N005);
  glVertex3fv(P005);
  glNormal3fv(N120);
  glVertex3fv(P120);
  glNormal3fv(N002);
  glVertex3fv(P002);
  glEnd();
  glBegin(cap);
  glNormal3fv(N002);
  glVertex3fv(P002);
  glNormal3fv(N120);
  glVertex3fv(P120);
  glNormal3fv(N116);
  glVertex3fv(P116);
  glEnd();
  glBegin(cap);
  glNormal3fv(N060);
  glVertex3fv(P060);
  glNormal3fv(N005);
  glVertex3fv(P005);
  glNormal3fv(N002);
  glVertex3fv(P002);
  glEnd();
}

// Dolphin016
// file dolphin.c line 1900
static void Dolphin016(unsigned int cap)
{
  glDisable((unsigned int)0x0B71);
  glBegin(cap);
  glVertex3fv(P123);
  glVertex3fv(P124);
  glVertex3fv(P125);
  glVertex3fv(P126);
  glVertex3fv(P127);
  glVertex3fv(P128);
  glEnd();
  glBegin(cap);
  glVertex3fv(P129);
  glVertex3fv(P130);
  glVertex3fv(P131);
  glVertex3fv(P132);
  glVertex3fv(P133);
  glVertex3fv(P134);
  glEnd();
  glBegin(cap);
  glVertex3fv(P103);
  glVertex3fv(P105);
  glVertex3fv(P108);
  glEnd();
  glEnable((unsigned int)0x0B71);
}

// DrawDolphin
// file atlantis.h line 129
extern void DrawDolphin(struct _fishRec *fish, signed int wire)
{
  float seg0;
  float seg1;
  float seg2;
  float seg3;
  float seg4;
  float seg5;
  float seg6;
  float seg7;
  float pitch;
  float thrash;
  float chomp;
  unsigned int cap;
  fish->htail = (float)((signed int)(fish->htail - (float)(signed int)((float)10 * fish->v)) % 360);
  thrash = (float)70 * fish->v;
  double return_value_sin_1;
  return_value_sin_1=sin((double)fish->htail * 0.01745);
  seg0 = (float)((double)((float)1 * thrash) * return_value_sin_1);
  double return_value_sin_2;
  return_value_sin_2=sin((double)fish->htail * 0.01745);
  seg3 = (float)((double)((float)1 * thrash) * return_value_sin_2);
  double return_value_sin_3;
  return_value_sin_3=sin((double)(fish->htail + (float)4) * 0.01745);
  seg1 = (float)((double)((float)2 * thrash) * return_value_sin_3);
  double return_value_sin_4;
  return_value_sin_4=sin((double)(fish->htail + (float)6) * 0.01745);
  seg2 = (float)((double)((float)3 * thrash) * return_value_sin_4);
  double return_value_sin_5;
  return_value_sin_5=sin((double)(fish->htail + (float)10) * 0.01745);
  seg4 = (float)((double)((float)4 * thrash) * return_value_sin_5);
  double return_value_sin_6;
  return_value_sin_6=sin((double)(fish->htail + (float)15) * 0.01745);
  seg5 = (float)(4.5 * (double)thrash * return_value_sin_6);
  double return_value_sin_7;
  return_value_sin_7=sin((double)(fish->htail + (float)20) * 0.01745);
  seg6 = (float)((double)((float)5 * thrash) * return_value_sin_7);
  double return_value_sin_8;
  return_value_sin_8=sin((double)(fish->htail + (float)30) * 0.01745);
  seg7 = (float)((double)((float)6 * thrash) * return_value_sin_8);
  double return_value_sin_9;
  return_value_sin_9=sin((double)(fish->htail + (float)180) * 0.01745);
  pitch = (float)((double)fish->v * return_value_sin_9);
  chomp = (float)100;
  P012[(signed long int)1] = iP012[(signed long int)1] + seg5;
  P013[(signed long int)1] = iP013[(signed long int)1] + seg5;
  P014[(signed long int)1] = iP014[(signed long int)1] + seg5;
  P015[(signed long int)1] = iP015[(signed long int)1] + seg5;
  P016[(signed long int)1] = iP016[(signed long int)1] + seg5;
  P017[(signed long int)1] = iP017[(signed long int)1] + seg5;
  P018[(signed long int)1] = iP018[(signed long int)1] + seg5;
  P019[(signed long int)1] = iP019[(signed long int)1] + seg5;
  P020[(signed long int)1] = iP020[(signed long int)1] + seg4;
  P021[(signed long int)1] = iP021[(signed long int)1] + seg4;
  P022[(signed long int)1] = iP022[(signed long int)1] + seg4;
  P023[(signed long int)1] = iP023[(signed long int)1] + seg4;
  P024[(signed long int)1] = iP024[(signed long int)1] + seg4;
  P025[(signed long int)1] = iP025[(signed long int)1] + seg4;
  P026[(signed long int)1] = iP026[(signed long int)1] + seg4;
  P027[(signed long int)1] = iP027[(signed long int)1] + seg4;
  P028[(signed long int)1] = iP028[(signed long int)1] + seg2;
  P029[(signed long int)1] = iP029[(signed long int)1] + seg2;
  P030[(signed long int)1] = iP030[(signed long int)1] + seg2;
  P031[(signed long int)1] = iP031[(signed long int)1] + seg2;
  P032[(signed long int)1] = iP032[(signed long int)1] + seg2;
  P033[(signed long int)1] = iP033[(signed long int)1] + seg2;
  P034[(signed long int)1] = iP034[(signed long int)1] + seg2;
  P035[(signed long int)1] = iP035[(signed long int)1] + seg2;
  P036[(signed long int)1] = iP036[(signed long int)1] + seg1;
  P037[(signed long int)1] = iP037[(signed long int)1] + seg1;
  P038[(signed long int)1] = iP038[(signed long int)1] + seg1;
  P039[(signed long int)1] = iP039[(signed long int)1] + seg1;
  P040[(signed long int)1] = iP040[(signed long int)1] + seg1;
  P041[(signed long int)1] = iP041[(signed long int)1] + seg1;
  P042[(signed long int)1] = iP042[(signed long int)1] + seg1;
  P043[(signed long int)1] = iP043[(signed long int)1] + seg1;
  P044[(signed long int)1] = iP044[(signed long int)1] + seg0;
  P045[(signed long int)1] = iP045[(signed long int)1] + seg0;
  P046[(signed long int)1] = iP046[(signed long int)1] + seg0;
  P047[(signed long int)1] = iP047[(signed long int)1] + seg0;
  P048[(signed long int)1] = iP048[(signed long int)1] + seg0;
  P049[(signed long int)1] = iP049[(signed long int)1] + seg0;
  P050[(signed long int)1] = iP050[(signed long int)1] + seg0;
  P051[(signed long int)1] = iP051[(signed long int)1] + seg0;
  P009[(signed long int)1] = iP009[(signed long int)1] + seg6;
  P010[(signed long int)1] = iP010[(signed long int)1] + seg6;
  P075[(signed long int)1] = iP075[(signed long int)1] + seg6;
  P076[(signed long int)1] = iP076[(signed long int)1] + seg6;
  P001[(signed long int)1] = iP001[(signed long int)1] + seg7;
  P011[(signed long int)1] = iP011[(signed long int)1] + seg7;
  P068[(signed long int)1] = iP068[(signed long int)1] + seg7;
  P069[(signed long int)1] = iP069[(signed long int)1] + seg7;
  P070[(signed long int)1] = iP070[(signed long int)1] + seg7;
  P071[(signed long int)1] = iP071[(signed long int)1] + seg7;
  P072[(signed long int)1] = iP072[(signed long int)1] + seg7;
  P073[(signed long int)1] = iP073[(signed long int)1] + seg7;
  P074[(signed long int)1] = iP074[(signed long int)1] + seg7;
  P091[(signed long int)1] = iP091[(signed long int)1] + seg3;
  P092[(signed long int)1] = iP092[(signed long int)1] + seg3;
  P093[(signed long int)1] = iP093[(signed long int)1] + seg3;
  P094[(signed long int)1] = iP094[(signed long int)1] + seg3;
  P095[(signed long int)1] = iP095[(signed long int)1] + seg3;
  P122[(signed long int)1] = (float)((double)iP122[(signed long int)1] + (double)seg3 * 1.5);
  P097[(signed long int)1] = iP097[(signed long int)1] + chomp;
  P098[(signed long int)1] = iP098[(signed long int)1] + chomp;
  P102[(signed long int)1] = iP102[(signed long int)1] + chomp;
  P110[(signed long int)1] = iP110[(signed long int)1] + chomp;
  P111[(signed long int)1] = iP111[(signed long int)1] + chomp;
  P121[(signed long int)1] = iP121[(signed long int)1] + chomp;
  P118[(signed long int)1] = iP118[(signed long int)1] + chomp;
  P119[(signed long int)1] = iP119[(signed long int)1] + chomp;
  glPushMatrix();
  glRotatef(pitch, (float)1, (float)0, (float)0);
  glTranslatef((float)0, (float)0, (float)7000);
  glRotatef((float)180, (float)0, (float)1, (float)0);
  glEnable((unsigned int)0x0B44);
  cap = (unsigned int)(wire != 0 ? 0x0002 : 0x0009);
  Dolphin014(cap);
  Dolphin010(cap);
  Dolphin009(cap);
  Dolphin012(cap);
  Dolphin013(cap);
  Dolphin006(cap);
  Dolphin002(cap);
  Dolphin001(cap);
  Dolphin003(cap);
  Dolphin015(cap);
  Dolphin004(cap);
  Dolphin005(cap);
  Dolphin007(cap);
  Dolphin008(cap);
  Dolphin011(cap);
  Dolphin016(cap);
  glDisable((unsigned int)0x0B44);
  glPopMatrix();
}

// DrawShark
// file atlantis.h line 128
extern void DrawShark(struct _fishRec *fish, signed int wire)
{
  float mat[4l][4l];
  signed int n;
  float seg1;
  float seg2;
  float seg3;
  float seg4;
  float segup;
  float thrash;
  float chomp;
  unsigned int cap;
  fish->htail = (float)((signed int)(fish->htail - (float)(signed int)((float)5 * fish->v)) % 360);
  thrash = (float)50 * fish->v;
  double return_value_sin_1;
  return_value_sin_1=sin((double)fish->htail * 0.01745);
  seg1 = (float)(0.6 * (double)thrash * return_value_sin_1);
  double return_value_sin_2;
  return_value_sin_2=sin((double)(fish->htail + (float)45) * 0.01745);
  seg2 = (float)(1.8 * (double)thrash * return_value_sin_2);
  double return_value_sin_3;
  return_value_sin_3=sin((double)(fish->htail + (float)90) * 0.01745);
  seg3 = (float)((double)((float)3 * thrash) * return_value_sin_3);
  double return_value_sin_4;
  return_value_sin_4=sin((double)(fish->htail + (float)110) * 0.01745);
  seg4 = (float)((double)((float)4 * thrash) * return_value_sin_4);
  chomp = (float)0;
  if(fish->v > 2.000000f)
    chomp = -(fish->v - (float)2) * (float)200;

  P004[(signed long int)1] = iP004[(signed long int)1] + chomp;
  P007_link1[(signed long int)1] = iP007[(signed long int)1] + chomp;
  P010_link1[(signed long int)1] = iP010_link1[(signed long int)1] + chomp;
  P011_link1[(signed long int)1] = iP011_link1[(signed long int)1] + chomp;
  P023_link1[(signed long int)0] = iP023_link1[(signed long int)0] + seg1;
  P024_link1[(signed long int)0] = iP024_link1[(signed long int)0] + seg1;
  P025_link1[(signed long int)0] = iP025_link1[(signed long int)0] + seg1;
  P026_link1[(signed long int)0] = iP026_link1[(signed long int)0] + seg1;
  P027_link1[(signed long int)0] = iP027_link1[(signed long int)0] + seg1;
  P028_link1[(signed long int)0] = iP028_link1[(signed long int)0] + seg1;
  P029_link1[(signed long int)0] = iP029_link1[(signed long int)0] + seg1;
  P030_link1[(signed long int)0] = iP030_link1[(signed long int)0] + seg1;
  P031_link1[(signed long int)0] = iP031_link1[(signed long int)0] + seg1;
  P032_link1[(signed long int)0] = iP032_link1[(signed long int)0] + seg1;
  P033_link1[(signed long int)0] = iP033_link1[(signed long int)0] + seg2;
  P034_link1[(signed long int)0] = iP034_link1[(signed long int)0] + seg2;
  P035_link1[(signed long int)0] = iP035_link1[(signed long int)0] + seg2;
  P036_link1[(signed long int)0] = iP036_link1[(signed long int)0] + seg2;
  P037_link1[(signed long int)0] = iP037_link1[(signed long int)0] + seg2;
  P038_link1[(signed long int)0] = iP038_link1[(signed long int)0] + seg2;
  P039_link1[(signed long int)0] = iP039_link1[(signed long int)0] + seg2;
  P040_link1[(signed long int)0] = iP040_link1[(signed long int)0] + seg2;
  P041_link1[(signed long int)0] = iP041_link1[(signed long int)0] + seg2;
  P042_link1[(signed long int)0] = iP042_link1[(signed long int)0] + seg2;
  P043_link1[(signed long int)0] = iP043_link1[(signed long int)0] + seg3;
  P044_link1[(signed long int)0] = iP044_link1[(signed long int)0] + seg3;
  P045_link1[(signed long int)0] = iP045_link1[(signed long int)0] + seg3;
  P046_link1[(signed long int)0] = iP046_link1[(signed long int)0] + seg3;
  P047_link1[(signed long int)0] = iP047_link1[(signed long int)0] + seg3;
  P048_link1[(signed long int)0] = iP048_link1[(signed long int)0] + seg3;
  P049_link1[(signed long int)0] = iP049_link1[(signed long int)0] + seg3;
  P050_link1[(signed long int)0] = iP050_link1[(signed long int)0] + seg3;
  P051_link1[(signed long int)0] = iP051_link1[(signed long int)0] + seg3;
  P052_link1[(signed long int)0] = iP052[(signed long int)0] + seg3;
  P002_link1[(signed long int)0] = iP002[(signed long int)0] + seg4;
  P061[(signed long int)0] = iP061[(signed long int)0] + seg4;
  P069_link1[(signed long int)0] = iP069_link1[(signed long int)0] + seg4;
  P070_link1[(signed long int)0] = iP070_link1[(signed long int)0] + seg4;
  fish->vtail = fish->vtail + (float)((double)(fish->dtheta - fish->vtail) * 0.1);
  if(fish->vtail > 5.000000e-1f)
    fish->vtail = (float)0.5;

  else
    if(fish->vtail < -5.000000e-1f)
      fish->vtail = (float)-0.5;

  segup = thrash * fish->vtail;
  P023_link1[(signed long int)1] = iP023_link1[(signed long int)1] + segup;
  P024_link1[(signed long int)1] = iP024_link1[(signed long int)1] + segup;
  P025_link1[(signed long int)1] = iP025_link1[(signed long int)1] + segup;
  P026_link1[(signed long int)1] = iP026_link1[(signed long int)1] + segup;
  P027_link1[(signed long int)1] = iP027_link1[(signed long int)1] + segup;
  P028_link1[(signed long int)1] = iP028_link1[(signed long int)1] + segup;
  P029_link1[(signed long int)1] = iP029_link1[(signed long int)1] + segup;
  P030_link1[(signed long int)1] = iP030_link1[(signed long int)1] + segup;
  P031_link1[(signed long int)1] = iP031_link1[(signed long int)1] + segup;
  P032_link1[(signed long int)1] = iP032_link1[(signed long int)1] + segup;
  P033_link1[(signed long int)1] = iP033_link1[(signed long int)1] + segup * (float)5;
  P034_link1[(signed long int)1] = iP034_link1[(signed long int)1] + segup * (float)5;
  P035_link1[(signed long int)1] = iP035_link1[(signed long int)1] + segup * (float)5;
  P036_link1[(signed long int)1] = iP036_link1[(signed long int)1] + segup * (float)5;
  P037_link1[(signed long int)1] = iP037_link1[(signed long int)1] + segup * (float)5;
  P038_link1[(signed long int)1] = iP038_link1[(signed long int)1] + segup * (float)5;
  P039_link1[(signed long int)1] = iP039_link1[(signed long int)1] + segup * (float)5;
  P040_link1[(signed long int)1] = iP040_link1[(signed long int)1] + segup * (float)5;
  P041_link1[(signed long int)1] = iP041_link1[(signed long int)1] + segup * (float)5;
  P042_link1[(signed long int)1] = iP042_link1[(signed long int)1] + segup * (float)5;
  P043_link1[(signed long int)1] = iP043_link1[(signed long int)1] + segup * (float)12;
  P044_link1[(signed long int)1] = iP044_link1[(signed long int)1] + segup * (float)12;
  P045_link1[(signed long int)1] = iP045_link1[(signed long int)1] + segup * (float)12;
  P046_link1[(signed long int)1] = iP046_link1[(signed long int)1] + segup * (float)12;
  P047_link1[(signed long int)1] = iP047_link1[(signed long int)1] + segup * (float)12;
  P048_link1[(signed long int)1] = iP048_link1[(signed long int)1] + segup * (float)12;
  P049_link1[(signed long int)1] = iP049_link1[(signed long int)1] + segup * (float)12;
  P050_link1[(signed long int)1] = iP050_link1[(signed long int)1] + segup * (float)12;
  P051_link1[(signed long int)1] = iP051_link1[(signed long int)1] + segup * (float)12;
  P052_link1[(signed long int)1] = iP052[(signed long int)1] + segup * (float)12;
  P002_link1[(signed long int)1] = iP002[(signed long int)1] + segup * (float)17;
  P061[(signed long int)1] = iP061[(signed long int)1] + segup * (float)17;
  P069_link1[(signed long int)1] = iP069_link1[(signed long int)1] + segup * (float)17;
  P070_link1[(signed long int)1] = iP070_link1[(signed long int)1] + segup * (float)17;
  glPushMatrix();
  glTranslatef((float)0, (float)0, (float)-3000);
  glGetFloatv((unsigned int)0x0BA6, &mat[(signed long int)0][(signed long int)0]);
  n = 0;
  if(mat[0l][2l] >= 0.000000f)
    n = n + 1;

  if(mat[1l][2l] >= 0.000000f)
    n = n + 2;

  if(mat[2l][2l] >= 0.000000f)
    n = n + 4;

  glScalef((float)2, (float)1, (float)1);
  glEnable((unsigned int)0x0B44);
  cap = (unsigned int)(wire != 0 ? 0x0002 : 0x0009);
  switch(n)
  {
    case 0:
    {
      Fish_1(cap);
      break;
    }
    case 1:
    {
      Fish_2(cap);
      break;
    }
    case 2:
    {
      Fish_3(cap);
      break;
    }
    case 3:
    {
      Fish_4(cap);
      break;
    }
    case 4:
    {
      Fish_5(cap);
      break;
    }
    case 5:
    {
      Fish_6(cap);
      break;
    }
    case 6:
    {
      Fish_7(cap);
      break;
    }
    case 7:
      Fish_8(cap);
  }
  glDisable((unsigned int)0x0B44);
  glPopMatrix();
}

// DrawWhale
// file atlantis.h line 127
extern void DrawWhale(struct _fishRec *fish, signed int wire)
{
  float seg0;
  float seg1;
  float seg2;
  float seg3;
  float seg4;
  float seg5;
  float seg6;
  float seg7;
  float pitch;
  float thrash;
  float chomp;
  unsigned int cap;
  fish->htail = (float)((signed int)(fish->htail - (float)(signed int)((float)5 * fish->v)) % 360);
  thrash = (float)70 * fish->v;
  double return_value_sin_1;
  return_value_sin_1=sin((double)fish->htail * 0.01745);
  seg0 = (float)(1.5 * (double)thrash * return_value_sin_1);
  double return_value_sin_2;
  return_value_sin_2=sin((double)(fish->htail + (float)10) * 0.01745);
  seg1 = (float)(2.5 * (double)thrash * return_value_sin_2);
  double return_value_sin_3;
  return_value_sin_3=sin((double)(fish->htail + (float)15) * 0.01745);
  seg2 = (float)(3.7 * (double)thrash * return_value_sin_3);
  double return_value_sin_4;
  return_value_sin_4=sin((double)(fish->htail + (float)23) * 0.01745);
  seg3 = (float)(4.8 * (double)thrash * return_value_sin_4);
  double return_value_sin_5;
  return_value_sin_5=sin((double)(fish->htail + (float)28) * 0.01745);
  seg4 = (float)((double)((float)6 * thrash) * return_value_sin_5);
  double return_value_sin_6;
  return_value_sin_6=sin((double)(fish->htail + (float)35) * 0.01745);
  seg5 = (float)(6.5 * (double)thrash * return_value_sin_6);
  double return_value_sin_7;
  return_value_sin_7=sin((double)(fish->htail + (float)40) * 0.01745);
  seg6 = (float)(6.5 * (double)thrash * return_value_sin_7);
  double return_value_sin_8;
  return_value_sin_8=sin((double)(fish->htail + (float)55) * 0.01745);
  seg7 = (float)(6.5 * (double)thrash * return_value_sin_8);
  double return_value_sin_9;
  return_value_sin_9=sin((double)(fish->htail - (float)160) * 0.01745);
  pitch = (float)((double)fish->v * return_value_sin_9);
  chomp = (float)0;
  if(fish->v > 2.000000f)
    chomp = -(fish->v - (float)2) * (float)200;

  P012_link2[(signed long int)1] = iP012_link1[(signed long int)1] + seg5;
  P013_link2[(signed long int)1] = iP013_link1[(signed long int)1] + seg5;
  P014_link2[(signed long int)1] = iP014_link1[(signed long int)1] + seg5;
  P015_link2[(signed long int)1] = iP015_link1[(signed long int)1] + seg5;
  P016_link2[(signed long int)1] = iP016_link1[(signed long int)1] + seg5;
  P017_link2[(signed long int)1] = iP017_link1[(signed long int)1] + seg5;
  P018_link2[(signed long int)1] = iP018_link1[(signed long int)1] + seg5;
  P019_link2[(signed long int)1] = iP019_link1[(signed long int)1] + seg5;
  P020_link2[(signed long int)1] = iP020_link1[(signed long int)1] + seg4;
  P021_link2[(signed long int)1] = iP021_link1[(signed long int)1] + seg4;
  P022_link2[(signed long int)1] = iP022_link1[(signed long int)1] + seg4;
  P023_link2[(signed long int)1] = iP023_link2[(signed long int)1] + seg4;
  P024_link2[(signed long int)1] = iP024_link2[(signed long int)1] + seg4;
  P025_link2[(signed long int)1] = iP025_link2[(signed long int)1] + seg4;
  P026_link2[(signed long int)1] = iP026_link2[(signed long int)1] + seg4;
  P027_link2[(signed long int)1] = iP027_link2[(signed long int)1] + seg4;
  P028_link2[(signed long int)1] = iP028_link2[(signed long int)1] + seg2;
  P029_link2[(signed long int)1] = iP029_link2[(signed long int)1] + seg2;
  P030_link2[(signed long int)1] = iP030_link2[(signed long int)1] + seg2;
  P031_link2[(signed long int)1] = iP031_link2[(signed long int)1] + seg2;
  P032_link2[(signed long int)1] = iP032_link2[(signed long int)1] + seg2;
  P033_link2[(signed long int)1] = iP033_link2[(signed long int)1] + seg2;
  P034_link2[(signed long int)1] = iP034_link2[(signed long int)1] + seg2;
  P035_link2[(signed long int)1] = iP035_link2[(signed long int)1] + seg2;
  P036_link2[(signed long int)1] = iP036_link2[(signed long int)1] + seg1;
  P037_link2[(signed long int)1] = iP037_link2[(signed long int)1] + seg1;
  P038_link2[(signed long int)1] = iP038_link2[(signed long int)1] + seg1;
  P039_link2[(signed long int)1] = iP039_link2[(signed long int)1] + seg1;
  P040_link2[(signed long int)1] = iP040_link2[(signed long int)1] + seg1;
  P041_link2[(signed long int)1] = iP041_link2[(signed long int)1] + seg1;
  P042_link2[(signed long int)1] = iP042_link2[(signed long int)1] + seg1;
  P043_link2[(signed long int)1] = iP043_link2[(signed long int)1] + seg1;
  P044_link2[(signed long int)1] = iP044_link2[(signed long int)1] + seg0;
  P045_link2[(signed long int)1] = iP045_link2[(signed long int)1] + seg0;
  P046_link2[(signed long int)1] = iP046_link2[(signed long int)1] + seg0;
  P047_link2[(signed long int)1] = iP047_link2[(signed long int)1] + seg0;
  P048_link2[(signed long int)1] = iP048_link2[(signed long int)1] + seg0;
  P049_link2[(signed long int)1] = iP049_link2[(signed long int)1] + seg0;
  P050_link2[(signed long int)1] = iP050_link2[(signed long int)1] + seg0;
  P051_link2[(signed long int)1] = iP051_link2[(signed long int)1] + seg0;
  P009_link2[(signed long int)1] = iP009_link1[(signed long int)1] + seg6;
  P010_link2[(signed long int)1] = iP010_link2[(signed long int)1] + seg6;
  P075_link2[(signed long int)1] = iP075_link1[(signed long int)1] + seg6;
  P076_link2[(signed long int)1] = iP076_link1[(signed long int)1] + seg6;
  P001_link1[(signed long int)1] = iP001_link1[(signed long int)1] + seg7;
  P011_link2[(signed long int)1] = iP011_link2[(signed long int)1] + seg7;
  P068_link1[(signed long int)1] = iP068_link1[(signed long int)1] + seg7;
  P069_link2[(signed long int)1] = iP069_link2[(signed long int)1] + seg7;
  P070_link2[(signed long int)1] = iP070_link2[(signed long int)1] + seg7;
  P071_link2[(signed long int)1] = iP071_link1[(signed long int)1] + seg7;
  P072_link2[(signed long int)1] = iP072_link1[(signed long int)1] + seg7;
  P073_link2[(signed long int)1] = iP073_link1[(signed long int)1] + seg7;
  P074_link2[(signed long int)1] = iP074_link1[(signed long int)1] + seg7;
  P091_link1[(signed long int)1] = (float)((double)iP091_link1[(signed long int)1] + (double)seg3 * 1.1);
  P092_link1[(signed long int)1] = iP092_link1[(signed long int)1] + seg3;
  P093_link1[(signed long int)1] = iP093_link1[(signed long int)1] + seg3;
  P094_link1[(signed long int)1] = iP094_link1[(signed long int)1] + seg3;
  P095_link1[(signed long int)1] = (float)((double)iP095_link1[(signed long int)1] + (double)seg3 * 0.9);
  P099_link1[(signed long int)1] = iP099[(signed long int)1] + chomp;
  P098_link1[(signed long int)1] = iP098_link1[(signed long int)1] + chomp;
  P064_link2[(signed long int)1] = iP064[(signed long int)1] + chomp;
  P061_link1[(signed long int)1] = iP061_link1[(signed long int)1] + chomp;
  P097_link1[(signed long int)1] = iP097_link1[(signed long int)1] + chomp;
  P096[(signed long int)1] = iP096[(signed long int)1] + chomp;
  glPushMatrix();
  glRotatef(pitch, (float)1, (float)0, (float)0);
  glTranslatef((float)0, (float)0, (float)8000);
  glRotatef((float)180, (float)0, (float)1, (float)0);
  glScalef((float)3, (float)3, (float)3);
  glEnable((unsigned int)0x0B44);
  cap = (unsigned int)(wire != 0 ? 0x0002 : 0x0009);
  Whale001(cap);
  Whale002(cap);
  Whale003(cap);
  Whale004(cap);
  Whale005(cap);
  Whale006(cap);
  Whale007(cap);
  Whale008(cap);
  Whale009(cap);
  Whale010(cap);
  Whale011(cap);
  Whale012(cap);
  Whale013(cap);
  Whale014(cap);
  Whale015(cap);
  Whale016(cap);
  glDisable((unsigned int)0x0B44);
  glPopMatrix();
}

// Fish001
// file shark.c line 302
static void Fish001(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N005_link1);
  glVertex3fv(P005_link1);
  glNormal3fv(N059_link1);
  glVertex3fv(P059_link1);
  glNormal3fv(N060_link1);
  glVertex3fv(P060_link1);
  glNormal3fv(N006_link1);
  glVertex3fv(P006_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N015_link1);
  glVertex3fv(P015_link1);
  glNormal3fv(N005_link1);
  glVertex3fv(P005_link1);
  glNormal3fv(N006_link1);
  glVertex3fv(P006_link1);
  glNormal3fv(N016_link1);
  glVertex3fv(P016_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N006_link1);
  glVertex3fv(P006_link1);
  glNormal3fv(N060_link1);
  glVertex3fv(P060_link1);
  glNormal3fv(N008_link1);
  glVertex3fv(P008_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N016_link1);
  glVertex3fv(P016_link1);
  glNormal3fv(N006_link1);
  glVertex3fv(P006_link1);
  glNormal3fv(N008_link1);
  glVertex3fv(P008_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N016_link1);
  glVertex3fv(P016_link1);
  glNormal3fv(N008_link1);
  glVertex3fv(P008_link1);
  glNormal3fv(N017_link1);
  glVertex3fv(P017_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N017_link1);
  glVertex3fv(P017_link1);
  glNormal3fv(N008_link1);
  glVertex3fv(P008_link1);
  glNormal3fv(N018_link1);
  glVertex3fv(P018_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N008_link1);
  glVertex3fv(P008_link1);
  glNormal3fv(N009);
  glVertex3fv(P009_link1);
  glNormal3fv(N018_link1);
  glVertex3fv(P018_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N008_link1);
  glVertex3fv(P008_link1);
  glNormal3fv(N060_link1);
  glVertex3fv(P060_link1);
  glNormal3fv(N009);
  glVertex3fv(P009_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N007_link1);
  glVertex3fv(P007_link1);
  glNormal3fv(N010);
  glVertex3fv(P010_link1);
  glNormal3fv(N009);
  glVertex3fv(P009_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N009);
  glVertex3fv(P009_link1);
  glNormal3fv(N019_link1);
  glVertex3fv(P019_link1);
  glNormal3fv(N018_link1);
  glVertex3fv(P018_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N009);
  glVertex3fv(P009_link1);
  glNormal3fv(N010);
  glVertex3fv(P010_link1);
  glNormal3fv(N019_link1);
  glVertex3fv(P019_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N010);
  glVertex3fv(P010_link1);
  glNormal3fv(N020_link1);
  glVertex3fv(P020_link1);
  glNormal3fv(N019_link1);
  glVertex3fv(P019_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N010);
  glVertex3fv(P010_link1);
  glNormal3fv(N011);
  glVertex3fv(P011_link1);
  glNormal3fv(N021_link1);
  glVertex3fv(P021_link1);
  glNormal3fv(N020_link1);
  glVertex3fv(P020_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N004);
  glVertex3fv(P004);
  glNormal3fv(N011);
  glVertex3fv(P011_link1);
  glNormal3fv(N010);
  glVertex3fv(P010_link1);
  glNormal3fv(N007_link1);
  glVertex3fv(P007_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N004);
  glVertex3fv(P004);
  glNormal3fv(N012_link1);
  glVertex3fv(P012_link1);
  glNormal3fv(N011);
  glVertex3fv(P011_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N012_link1);
  glVertex3fv(P012_link1);
  glNormal3fv(N022_link1);
  glVertex3fv(P022_link1);
  glNormal3fv(N011);
  glVertex3fv(P011_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N011);
  glVertex3fv(P011_link1);
  glNormal3fv(N022_link1);
  glVertex3fv(P022_link1);
  glNormal3fv(N021_link1);
  glVertex3fv(P021_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N059_link1);
  glVertex3fv(P059_link1);
  glNormal3fv(N005_link1);
  glVertex3fv(P005_link1);
  glNormal3fv(N015_link1);
  glVertex3fv(P015_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N015_link1);
  glVertex3fv(P015_link1);
  glNormal3fv(N014_link1);
  glVertex3fv(P014_link1);
  glNormal3fv(N003_link1);
  glVertex3fv(P003_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N015_link1);
  glVertex3fv(P015_link1);
  glNormal3fv(N003_link1);
  glVertex3fv(P003_link1);
  glNormal3fv(N059_link1);
  glVertex3fv(P059_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N014_link1);
  glVertex3fv(P014_link1);
  glNormal3fv(N013_link1);
  glVertex3fv(P013_link1);
  glNormal3fv(N003_link1);
  glVertex3fv(P003_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N003_link1);
  glVertex3fv(P003_link1);
  glNormal3fv(N012_link1);
  glVertex3fv(P012_link1);
  glNormal3fv(N059_link1);
  glVertex3fv(P059_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N013_link1);
  glVertex3fv(P013_link1);
  glNormal3fv(N012_link1);
  glVertex3fv(P012_link1);
  glNormal3fv(N003_link1);
  glVertex3fv(P003_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N013_link1);
  glVertex3fv(P013_link1);
  glNormal3fv(N022_link1);
  glVertex3fv(P022_link1);
  glNormal3fv(N012_link1);
  glVertex3fv(P012_link1);
  glEnd();
  glBegin(cap);
  glVertex3fv(P071_link1);
  glVertex3fv(P072_link1);
  glVertex3fv(P073_link1);
  glVertex3fv(P074_link1);
  glVertex3fv(P075_link1);
  glVertex3fv(P076_link1);
  glEnd();
  glBegin(cap);
  glVertex3fv(P077_link1);
  glVertex3fv(P078_link1);
  glVertex3fv(P079_link1);
  glVertex3fv(P080_link1);
  glVertex3fv(P081_link1);
  glVertex3fv(P082_link1);
  glEnd();
}

// Fish002
// file shark.c line 523
static void Fish002(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N013_link1);
  glVertex3fv(P013_link1);
  glNormal3fv(N014_link1);
  glVertex3fv(P014_link1);
  glNormal3fv(N024_link1);
  glVertex3fv(P024_link1);
  glNormal3fv(N023_link1);
  glVertex3fv(P023_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N014_link1);
  glVertex3fv(P014_link1);
  glNormal3fv(N015_link1);
  glVertex3fv(P015_link1);
  glNormal3fv(N025_link1);
  glVertex3fv(P025_link1);
  glNormal3fv(N024_link1);
  glVertex3fv(P024_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N016_link1);
  glVertex3fv(P016_link1);
  glNormal3fv(N017_link1);
  glVertex3fv(P017_link1);
  glNormal3fv(N027_link1);
  glVertex3fv(P027_link1);
  glNormal3fv(N026_link1);
  glVertex3fv(P026_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N017_link1);
  glVertex3fv(P017_link1);
  glNormal3fv(N018_link1);
  glVertex3fv(P018_link1);
  glNormal3fv(N028_link1);
  glVertex3fv(P028_link1);
  glNormal3fv(N027_link1);
  glVertex3fv(P027_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N020_link1);
  glVertex3fv(P020_link1);
  glNormal3fv(N021_link1);
  glVertex3fv(P021_link1);
  glNormal3fv(N031_link1);
  glVertex3fv(P031_link1);
  glNormal3fv(N030_link1);
  glVertex3fv(P030_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N013_link1);
  glVertex3fv(P013_link1);
  glNormal3fv(N023_link1);
  glVertex3fv(P023_link1);
  glNormal3fv(N022_link1);
  glVertex3fv(P022_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N022_link1);
  glVertex3fv(P022_link1);
  glNormal3fv(N023_link1);
  glVertex3fv(P023_link1);
  glNormal3fv(N032_link1);
  glVertex3fv(P032_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N022_link1);
  glVertex3fv(P022_link1);
  glNormal3fv(N032_link1);
  glVertex3fv(P032_link1);
  glNormal3fv(N031_link1);
  glVertex3fv(P031_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N022_link1);
  glVertex3fv(P022_link1);
  glNormal3fv(N031_link1);
  glVertex3fv(P031_link1);
  glNormal3fv(N021_link1);
  glVertex3fv(P021_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N018_link1);
  glVertex3fv(P018_link1);
  glNormal3fv(N019_link1);
  glVertex3fv(P019_link1);
  glNormal3fv(N029_link1);
  glVertex3fv(P029_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N018_link1);
  glVertex3fv(P018_link1);
  glNormal3fv(N029_link1);
  glVertex3fv(P029_link1);
  glNormal3fv(N028_link1);
  glVertex3fv(P028_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N019_link1);
  glVertex3fv(P019_link1);
  glNormal3fv(N020_link1);
  glVertex3fv(P020_link1);
  glNormal3fv(N030_link1);
  glVertex3fv(P030_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N019_link1);
  glVertex3fv(P019_link1);
  glNormal3fv(N030_link1);
  glVertex3fv(P030_link1);
  glNormal3fv(N029_link1);
  glVertex3fv(P029_link1);
  glEnd();
}

// Fish003
// file shark.c line 642
static void Fish003(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N032_link1);
  glVertex3fv(P032_link1);
  glNormal3fv(N023_link1);
  glVertex3fv(P023_link1);
  glNormal3fv(N033_link1);
  glVertex3fv(P033_link1);
  glNormal3fv(N042_link1);
  glVertex3fv(P042_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N031_link1);
  glVertex3fv(P031_link1);
  glNormal3fv(N032_link1);
  glVertex3fv(P032_link1);
  glNormal3fv(N042_link1);
  glVertex3fv(P042_link1);
  glNormal3fv(N041_link1);
  glVertex3fv(P041_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N023_link1);
  glVertex3fv(P023_link1);
  glNormal3fv(N024_link1);
  glVertex3fv(P024_link1);
  glNormal3fv(N034_link1);
  glVertex3fv(P034_link1);
  glNormal3fv(N033_link1);
  glVertex3fv(P033_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N024_link1);
  glVertex3fv(P024_link1);
  glNormal3fv(N025_link1);
  glVertex3fv(P025_link1);
  glNormal3fv(N035_link1);
  glVertex3fv(P035_link1);
  glNormal3fv(N034_link1);
  glVertex3fv(P034_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N030_link1);
  glVertex3fv(P030_link1);
  glNormal3fv(N031_link1);
  glVertex3fv(P031_link1);
  glNormal3fv(N041_link1);
  glVertex3fv(P041_link1);
  glNormal3fv(N040_link1);
  glVertex3fv(P040_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N025_link1);
  glVertex3fv(P025_link1);
  glNormal3fv(N026_link1);
  glVertex3fv(P026_link1);
  glNormal3fv(N036_link1);
  glVertex3fv(P036_link1);
  glNormal3fv(N035_link1);
  glVertex3fv(P035_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N026_link1);
  glVertex3fv(P026_link1);
  glNormal3fv(N027_link1);
  glVertex3fv(P027_link1);
  glNormal3fv(N037_link1);
  glVertex3fv(P037_link1);
  glNormal3fv(N036_link1);
  glVertex3fv(P036_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N027_link1);
  glVertex3fv(P027_link1);
  glNormal3fv(N028_link1);
  glVertex3fv(P028_link1);
  glNormal3fv(N038_link1);
  glVertex3fv(P038_link1);
  glNormal3fv(N037_link1);
  glVertex3fv(P037_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N028_link1);
  glVertex3fv(P028_link1);
  glNormal3fv(N029_link1);
  glVertex3fv(P029_link1);
  glNormal3fv(N039_link1);
  glVertex3fv(P039_link1);
  glNormal3fv(N038_link1);
  glVertex3fv(P038_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N029_link1);
  glVertex3fv(P029_link1);
  glNormal3fv(N030_link1);
  glVertex3fv(P030_link1);
  glNormal3fv(N040_link1);
  glVertex3fv(P040_link1);
  glNormal3fv(N039_link1);
  glVertex3fv(P039_link1);
  glEnd();
}

// Fish004
// file shark.c line 747
static void Fish004(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N040_link1);
  glVertex3fv(P040_link1);
  glNormal3fv(N041_link1);
  glVertex3fv(P041_link1);
  glNormal3fv(N051_link1);
  glVertex3fv(P051_link1);
  glNormal3fv(N050_link1);
  glVertex3fv(P050_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N041_link1);
  glVertex3fv(P041_link1);
  glNormal3fv(N042_link1);
  glVertex3fv(P042_link1);
  glNormal3fv(N052_link1);
  glVertex3fv(P052_link1);
  glNormal3fv(N051_link1);
  glVertex3fv(P051_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N042_link1);
  glVertex3fv(P042_link1);
  glNormal3fv(N033_link1);
  glVertex3fv(P033_link1);
  glNormal3fv(N043_link1);
  glVertex3fv(P043_link1);
  glNormal3fv(N052_link1);
  glVertex3fv(P052_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N033_link1);
  glVertex3fv(P033_link1);
  glNormal3fv(N034_link1);
  glVertex3fv(P034_link1);
  glNormal3fv(N044_link1);
  glVertex3fv(P044_link1);
  glNormal3fv(N043_link1);
  glVertex3fv(P043_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N034_link1);
  glVertex3fv(P034_link1);
  glNormal3fv(N035_link1);
  glVertex3fv(P035_link1);
  glNormal3fv(N045_link1);
  glVertex3fv(P045_link1);
  glNormal3fv(N044_link1);
  glVertex3fv(P044_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N035_link1);
  glVertex3fv(P035_link1);
  glNormal3fv(N036_link1);
  glVertex3fv(P036_link1);
  glNormal3fv(N046_link1);
  glVertex3fv(P046_link1);
  glNormal3fv(N045_link1);
  glVertex3fv(P045_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N036_link1);
  glVertex3fv(P036_link1);
  glNormal3fv(N037_link1);
  glVertex3fv(P037_link1);
  glNormal3fv(N047_link1);
  glVertex3fv(P047_link1);
  glNormal3fv(N046_link1);
  glVertex3fv(P046_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N037_link1);
  glVertex3fv(P037_link1);
  glNormal3fv(N038_link1);
  glVertex3fv(P038_link1);
  glNormal3fv(N048_link1);
  glVertex3fv(P048_link1);
  glNormal3fv(N047_link1);
  glVertex3fv(P047_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N038_link1);
  glVertex3fv(P038_link1);
  glNormal3fv(N039_link1);
  glVertex3fv(P039_link1);
  glNormal3fv(N049_link1);
  glVertex3fv(P049_link1);
  glNormal3fv(N048_link1);
  glVertex3fv(P048_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N039_link1);
  glVertex3fv(P039_link1);
  glNormal3fv(N040_link1);
  glVertex3fv(P040_link1);
  glNormal3fv(N050_link1);
  glVertex3fv(P050_link1);
  glNormal3fv(N049_link1);
  glVertex3fv(P049_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N070);
  glVertex3fv(P070_link1);
  glNormal3fv(N061);
  glVertex3fv(P061);
  glNormal3fv(N002_link1);
  glVertex3fv(P002_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N061);
  glVertex3fv(P061);
  glNormal3fv(N046_link1);
  glVertex3fv(P046_link1);
  glNormal3fv(N002_link1);
  glVertex3fv(P002_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N045_link1);
  glVertex3fv(P045_link1);
  glNormal3fv(N046_link1);
  glVertex3fv(P046_link1);
  glNormal3fv(N061);
  glVertex3fv(P061);
  glEnd();
  glBegin(cap);
  glNormal3fv(N002_link1);
  glVertex3fv(P002_link1);
  glNormal3fv(N061);
  glVertex3fv(P061);
  glNormal3fv(N070);
  glVertex3fv(P070_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N002_link1);
  glVertex3fv(P002_link1);
  glNormal3fv(N045_link1);
  glVertex3fv(P045_link1);
  glNormal3fv(N061);
  glVertex3fv(P061);
  glEnd();
}

// Fish005
// file shark.c line 892
static void Fish005(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N002_link1);
  glVertex3fv(P002_link1);
  glNormal3fv(N044_link1);
  glVertex3fv(P044_link1);
  glNormal3fv(N045_link1);
  glVertex3fv(P045_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N002_link1);
  glVertex3fv(P002_link1);
  glNormal3fv(N043_link1);
  glVertex3fv(P043_link1);
  glNormal3fv(N044_link1);
  glVertex3fv(P044_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N002_link1);
  glVertex3fv(P002_link1);
  glNormal3fv(N052_link1);
  glVertex3fv(P052_link1);
  glNormal3fv(N043_link1);
  glVertex3fv(P043_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N002_link1);
  glVertex3fv(P002_link1);
  glNormal3fv(N051_link1);
  glVertex3fv(P051_link1);
  glNormal3fv(N052_link1);
  glVertex3fv(P052_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N002_link1);
  glVertex3fv(P002_link1);
  glNormal3fv(N046_link1);
  glVertex3fv(P046_link1);
  glNormal3fv(N047_link1);
  glVertex3fv(P047_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N002_link1);
  glVertex3fv(P002_link1);
  glNormal3fv(N047_link1);
  glVertex3fv(P047_link1);
  glNormal3fv(N048_link1);
  glVertex3fv(P048_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N002_link1);
  glVertex3fv(P002_link1);
  glNormal3fv(N048_link1);
  glVertex3fv(P048_link1);
  glNormal3fv(N049_link1);
  glVertex3fv(P049_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N002_link1);
  glVertex3fv(P002_link1);
  glNormal3fv(N049_link1);
  glVertex3fv(P049_link1);
  glNormal3fv(N050_link1);
  glVertex3fv(P050_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N050_link1);
  glVertex3fv(P050_link1);
  glNormal3fv(N051_link1);
  glVertex3fv(P051_link1);
  glNormal3fv(N069);
  glVertex3fv(P069_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N051_link1);
  glVertex3fv(P051_link1);
  glNormal3fv(N002_link1);
  glVertex3fv(P002_link1);
  glNormal3fv(N069);
  glVertex3fv(P069_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N050_link1);
  glVertex3fv(P050_link1);
  glNormal3fv(N069);
  glVertex3fv(P069_link1);
  glNormal3fv(N002_link1);
  glVertex3fv(P002_link1);
  glEnd();
}

// Fish006
// file shark.c line 985
static void Fish006(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N066_link1);
  glVertex3fv(P066_link1);
  glNormal3fv(N016_link1);
  glVertex3fv(P016_link1);
  glNormal3fv(N026_link1);
  glVertex3fv(P026_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N015_link1);
  glVertex3fv(P015_link1);
  glNormal3fv(N066_link1);
  glVertex3fv(P066_link1);
  glNormal3fv(N025_link1);
  glVertex3fv(P025_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N025_link1);
  glVertex3fv(P025_link1);
  glNormal3fv(N066_link1);
  glVertex3fv(P066_link1);
  glNormal3fv(N026_link1);
  glVertex3fv(P026_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N066_link1);
  glVertex3fv(P066_link1);
  glNormal3fv(N058_link1);
  glVertex3fv(P058_link1);
  glNormal3fv(N016_link1);
  glVertex3fv(P016_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N015_link1);
  glVertex3fv(P015_link1);
  glNormal3fv(N058_link1);
  glVertex3fv(P058_link1);
  glNormal3fv(N066_link1);
  glVertex3fv(P066_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N058_link1);
  glVertex3fv(P058_link1);
  glNormal3fv(N015_link1);
  glVertex3fv(P015_link1);
  glNormal3fv(N016_link1);
  glVertex3fv(P016_link1);
  glEnd();
}

// Fish007
// file shark.c line 1038
static void Fish007(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N062_link1);
  glVertex3fv(P062_link1);
  glNormal3fv(N022_link1);
  glVertex3fv(P022_link1);
  glNormal3fv(N032_link1);
  glVertex3fv(P032_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N062_link1);
  glVertex3fv(P062_link1);
  glNormal3fv(N032_link1);
  glVertex3fv(P032_link1);
  glNormal3fv(N064_link1);
  glVertex3fv(P064_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N022_link1);
  glVertex3fv(P022_link1);
  glNormal3fv(N062_link1);
  glVertex3fv(P062_link1);
  glNormal3fv(N032_link1);
  glVertex3fv(P032_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N062_link1);
  glVertex3fv(P062_link1);
  glNormal3fv(N064_link1);
  glVertex3fv(P064_link1);
  glNormal3fv(N032_link1);
  glVertex3fv(P032_link1);
  glEnd();
}

// Fish008
// file shark.c line 1075
static void Fish008(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N063_link1);
  glVertex3fv(P063_link1);
  glNormal3fv(N019_link1);
  glVertex3fv(P019_link1);
  glNormal3fv(N029_link1);
  glVertex3fv(P029_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N019_link1);
  glVertex3fv(P019_link1);
  glNormal3fv(N063_link1);
  glVertex3fv(P063_link1);
  glNormal3fv(N029_link1);
  glVertex3fv(P029_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N063_link1);
  glVertex3fv(P063_link1);
  glNormal3fv(N029_link1);
  glVertex3fv(P029_link1);
  glNormal3fv(N065_link1);
  glVertex3fv(P065_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N063_link1);
  glVertex3fv(P063_link1);
  glNormal3fv(N065_link1);
  glVertex3fv(P065_link1);
  glNormal3fv(N029_link1);
  glVertex3fv(P029_link1);
  glEnd();
}

// Fish009
// file shark.c line 1112
static void Fish009(unsigned int cap)
{
  glBegin(cap);
  glVertex3fv(P059_link1);
  glVertex3fv(P012_link1);
  glVertex3fv(P009_link1);
  glVertex3fv(P060_link1);
  glEnd();
  glBegin(cap);
  glVertex3fv(P012_link1);
  glVertex3fv(P004);
  glVertex3fv(P007_link1);
  glVertex3fv(P009_link1);
  glEnd();
}

// FishTransform
// file atlantis.h line 123
extern void FishTransform(struct _fishRec *fish)
{
  glTranslatef(fish->y, fish->z, -fish->x);
  glRotatef(-fish->psi, (float)0.0, (float)1.0, (float)0.0);
  glRotatef(fish->theta, (float)1.0, (float)0.0, (float)0.0);
  glRotatef(-fish->phi, (float)0.0, (float)0.0, (float)1.0);
}

// Fish_1
// file shark.c line 1129
static void Fish_1(unsigned int cap)
{
  Fish004(cap);
  Fish005(cap);
  Fish003(cap);
  Fish007(cap);
  Fish006(cap);
  Fish002(cap);
  Fish008(cap);
  Fish009(cap);
  Fish001(cap);
}

// Fish_2
// file shark.c line 1143
static void Fish_2(unsigned int cap)
{
  Fish005(cap);
  Fish004(cap);
  Fish003(cap);
  Fish008(cap);
  Fish006(cap);
  Fish002(cap);
  Fish007(cap);
  Fish009(cap);
  Fish001(cap);
}

// Fish_3
// file shark.c line 1157
static void Fish_3(unsigned int cap)
{
  Fish005(cap);
  Fish004(cap);
  Fish007(cap);
  Fish003(cap);
  Fish002(cap);
  Fish008(cap);
  Fish009(cap);
  Fish001(cap);
  Fish006(cap);
}

// Fish_4
// file shark.c line 1171
static void Fish_4(unsigned int cap)
{
  Fish005(cap);
  Fish004(cap);
  Fish008(cap);
  Fish003(cap);
  Fish002(cap);
  Fish007(cap);
  Fish009(cap);
  Fish001(cap);
  Fish006(cap);
}

// Fish_5
// file shark.c line 1185
static void Fish_5(unsigned int cap)
{
  Fish009(cap);
  Fish006(cap);
  Fish007(cap);
  Fish001(cap);
  Fish002(cap);
  Fish003(cap);
  Fish008(cap);
  Fish004(cap);
  Fish005(cap);
}

// Fish_6
// file shark.c line 1199
static void Fish_6(unsigned int cap)
{
  Fish009(cap);
  Fish006(cap);
  Fish008(cap);
  Fish001(cap);
  Fish002(cap);
  Fish007(cap);
  Fish003(cap);
  Fish004(cap);
  Fish005(cap);
}

// Fish_7
// file shark.c line 1213
static void Fish_7(unsigned int cap)
{
  Fish009(cap);
  Fish001(cap);
  Fish007(cap);
  Fish005(cap);
  Fish002(cap);
  Fish008(cap);
  Fish003(cap);
  Fish004(cap);
  Fish006(cap);
}

// Fish_8
// file shark.c line 1227
static void Fish_8(unsigned int cap)
{
  Fish009(cap);
  Fish008(cap);
  Fish001(cap);
  Fish002(cap);
  Fish007(cap);
  Fish003(cap);
  Fish005(cap);
  Fish004(cap);
  Fish006(cap);
}

// Init
// file atlantis.c line 221
static void Init(struct ModeInfo *mi)
{
  struct anonymous *ap = &atlantis[(signed long int)mi->screen_number];
  float fblue = (float)0.0;
  float fgreen;
  glFrontFace((unsigned int)0x0901);
  if(!(ap->wire == 0))
  {
    glDisable((unsigned int)0x0B71);
    glDisable((unsigned int)0x0B44);
    glDisable((unsigned int)0x0B50);
    glDisable((unsigned int)0x0BA1);
  }

  else
  {
    glDepthFunc((unsigned int)0x0203);
    glEnable((unsigned int)0x0B71);
    glEnable((unsigned int)0x0B44);
    glEnable((unsigned int)0x0BA1);
    glShadeModel((unsigned int)0x1D01);
    static const float ambient[4l] = { (const float)0.1, (const float)0.1, (const float)0.1, (const float)1.0 };
    glLightfv((unsigned int)0x4000, (unsigned int)0x1200, ambient);
    static const float diffuse[4l] = { (const float)1.0, (const float)1.0, (const float)1.0, (const float)1.0 };
    glLightfv((unsigned int)0x4000, (unsigned int)0x1201, diffuse);
    static const float position[4l] = { (const float)0.0, (const float)1.0, (const float)0.0, (const float)0.0 };
    glLightfv((unsigned int)0x4000, (unsigned int)0x1203, position);
    static const float lmodel_ambient[4l] = { (const float)0.4, (const float)0.4, (const float)0.4, (const float)1.0 };
    glLightModelfv((unsigned int)0x0B53, lmodel_ambient);
    static const float lmodel_localviewer[1l] = { (const float)0.0 };
    glLightModelfv((unsigned int)0x0B51, lmodel_localviewer);
    glEnable((unsigned int)0x0B50);
    glEnable((unsigned int)0x4000);
    static const float mat_shininess[1l] = { (const float)90.0 };
    glMaterialfv((unsigned int)0x0408, (unsigned int)0x1601, mat_shininess);
    static const float mat_specular[4l] = { (const float)0.8, (const float)0.8, (const float)0.8, (const float)1.0 };
    glMaterialfv((unsigned int)0x0408, (unsigned int)0x1202, mat_specular);
    static const float mat_diffuse[4l] = { (const float)0.46, (const float)0.66, (const float)0.795, (const float)1.0 };
    glMaterialfv((unsigned int)0x0408, (unsigned int)0x1201, mat_diffuse);
    static const float mat_ambient[4l] = { (const float)0.0, (const float)0.1, (const float)0.2, (const float)1.0 };
    glMaterialfv((unsigned int)0x0408, (unsigned int)0x1200, mat_ambient);
  }
  if(do_texture == 0 || !(ap->wire == 0))
    glDisable((unsigned int)0x0DE1);

  else
  {
    float scale = (float)0.0005;
    if(ap->texture == ((struct _XImage *)NULL))
      parse_image_data(mi);

    clear_gl_error();
    glTexImage2D((unsigned int)0x0DE1, 0, 0x1908, ap->texture->width, ap->texture->height, 0, (unsigned int)0x1908, (unsigned int)0x1401, (const void *)ap->texture->data);
    check_gl_error("texture");
    glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2802, 0x2901);
    glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2803, 0x2901);
    glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2800, 0x2601);
    glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2801, 0x2601);
    glTexEnvf((unsigned int)0x2300, (unsigned int)0x2200, (float)0x2100);
    float s_plane[4l] = { (float)1, (float)0, (float)0, (float)0 };
    float t_plane[4l] = { (float)0, (float)0, (float)1, (float)0 };
    glTexGeni((unsigned int)0x2000, (unsigned int)0x2500, 0x2400);
    glTexGeni((unsigned int)0x2001, (unsigned int)0x2500, 0x2400);
    glTexGenfv((unsigned int)0x2000, (unsigned int)0x2502, s_plane);
    glTexGenfv((unsigned int)0x2001, (unsigned int)0x2502, t_plane);
    glEnable((unsigned int)0x0C60);
    glEnable((unsigned int)0x0C61);
    glEnable((unsigned int)0x0DE1);
    glMatrixMode((unsigned int)0x1702);
    glLoadIdentity();
    glScalef(scale, scale, (float)1);
    glMatrixMode((unsigned int)0x1700);
  }
  InitFishs(ap);
  unsigned int return_value_ya_random_1;
  return_value_ya_random_1=ya_random();
  fblue = (float)((double)(float)(signed int)(((unsigned long int)return_value_ya_random_1 * (unsigned long int)(unsigned int)30) / ((unsigned long int)0xFFFFFFFF + (unsigned long int)1)) / 100.0 + 0.70);
  fgreen = (float)((double)fblue * 0.56);
  glClearColor((float)0.0, fgreen, fblue, (float)1.0);
}

// InitFishs
// file atlantis.c line 183
static void InitFishs(struct anonymous *ap)
{
  signed int i = 0;
  for( ; !(i >= ap->num_sharks); i = i + 1)
  {
    unsigned int return_value_ya_random_1;
    return_value_ya_random_1=ya_random();
    (ap->sharks + (signed long int)i)->x = (float)(70000.0 + (double)(signed int)(((unsigned long int)return_value_ya_random_1 * (unsigned long int)(unsigned int)ap->sharksize) / ((unsigned long int)0xFFFFFFFF + (unsigned long int)1)));
    unsigned int return_value_ya_random_2;
    return_value_ya_random_2=ya_random();
    (ap->sharks + (signed long int)i)->y = (float)(signed int)(((unsigned long int)return_value_ya_random_2 * (unsigned long int)(unsigned int)ap->sharksize) / ((unsigned long int)0xFFFFFFFF + (unsigned long int)1));
    unsigned int return_value_ya_random_3;
    return_value_ya_random_3=ya_random();
    (ap->sharks + (signed long int)i)->z = (float)(signed int)(((unsigned long int)return_value_ya_random_3 * (unsigned long int)(unsigned int)ap->sharksize) / ((unsigned long int)0xFFFFFFFF + (unsigned long int)1));
    unsigned int return_value_ya_random_4;
    return_value_ya_random_4=ya_random();
    (ap->sharks + (signed long int)i)->psi = (float)((double)(signed int)(((unsigned long int)return_value_ya_random_4 * (unsigned long int)(unsigned int)360) / ((unsigned long int)0xFFFFFFFF + (unsigned long int)1)) - 180.0);
    (ap->sharks + (signed long int)i)->v = (float)1.0;
  }
  unsigned int return_value_ya_random_5;
  return_value_ya_random_5=ya_random();
  ap->whaledir = (signed int)((signed long int)(return_value_ya_random_5 & (unsigned int)0x7fffffff) & (signed long int)1);
  ap->dolph.x = (float)30000.0;
  ap->dolph.y = (float)0.0;
  ap->dolph.z = (float)ap->sharksize;
  ap->dolph.psi = (float)(ap->whaledir != 0 ? 90.0 : -90.0);
  ap->dolph.theta = (float)0.0;
  ap->dolph.v = (float)6.0;
  ap->momWhale.x = (float)70000.0;
  ap->momWhale.y = (float)0.0;
  ap->momWhale.z = (float)0.0;
  ap->momWhale.psi = (float)(ap->whaledir != 0 ? 90.0 : -90.0);
  ap->momWhale.theta = (float)0.0;
  ap->momWhale.v = (float)3.0;
  ap->babyWhale.x = (float)60000.0;
  ap->babyWhale.y = (float)-2000.0;
  ap->babyWhale.z = (float)-2000.0;
  ap->babyWhale.psi = (float)(ap->whaledir != 0 ? 90.0 : -90.0);
  ap->babyWhale.theta = (float)0.0;
  ap->babyWhale.v = (float)3.0;
}

// MapNotify_event_p
// file screenhack.c line 256
static signed int MapNotify_event_p(struct _XDisplay *dpy, union _XEvent *event, char *window)
{
  _Bool tmp_if_expr_1;
  if(event->xany.type == 19)
    tmp_if_expr_1 = event->xvisibility.window == (unsigned long int)window ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  return (signed int)tmp_if_expr_1;
}

// SharkMiss
// file atlantis.h line 126
extern void SharkMiss(struct anonymous *ap, signed int i)
{
  signed int j;
  float avoid;
  float thetal;
  float X;
  float Y;
  float Z;
  float R;
  j = 0;
  for( ; !(j >= ap->num_sharks); j = j + 1)
    if(!(j == i))
    {
      X = (ap->sharks + (signed long int)j)->x - (ap->sharks + (signed long int)i)->x;
      Y = (ap->sharks + (signed long int)j)->y - (ap->sharks + (signed long int)i)->y;
      Z = (ap->sharks + (signed long int)j)->z - (ap->sharks + (signed long int)i)->z;
      double return_value_sqrt_1;
      return_value_sqrt_1=sqrt((double)(X * X + Y * Y + Z * Z));
      R = (float)return_value_sqrt_1;
      avoid = (float)1.0;
      thetal = (ap->sharks + (signed long int)i)->theta;
      if(R < (float)ap->sharksize)
      {
        if(Z > 0.000000f)
          (ap->sharks + (signed long int)i)->theta = (ap->sharks + (signed long int)i)->theta - avoid;

        else
          (ap->sharks + (signed long int)i)->theta = (ap->sharks + (signed long int)i)->theta + avoid;
      }

      (ap->sharks + (signed long int)i)->dtheta = (ap->sharks + (signed long int)i)->dtheta + ((ap->sharks + (signed long int)i)->theta - thetal);
    }

}

// SharkPilot
// file atlantis.h line 125
extern void SharkPilot(struct _fishRec *fish, float sharkspeed)
{
  float X;
  float Y;
  float Z;
  float tpsi;
  float ttheta;
  float thetal;
  fish->xt = (float)60000.0;
  fish->yt = (float)0.0;
  fish->zt = (float)0.0;
  X = fish->xt - fish->x;
  Y = fish->yt - fish->y;
  Z = fish->zt - fish->z;
  thetal = fish->theta;
  double return_value_sqrt_1;
  return_value_sqrt_1=sqrt((double)(X * X + Y * Y));
  double return_value_atan_2;
  return_value_atan_2=atan((double)Z / return_value_sqrt_1);
  ttheta = (float)(57.295 * return_value_atan_2);
  if((double)ttheta > (double)fish->theta + 0.25)
    fish->theta = fish->theta + (float)0.5;

  else
    if((double)ttheta < (double)fish->theta + -2.500000e-1)
      fish->theta = fish->theta - (float)0.5;

  if(fish->theta > 90.000000f)
    fish->theta = (float)90.0;

  if(fish->theta < -90.000000f)
    fish->theta = (float)-90.0;

  fish->dtheta = fish->theta - thetal;
  double return_value_atan2_3;
  return_value_atan2_3=atan2((double)Y, (double)X);
  tpsi = (float)(57.295 * return_value_atan2_3);
  fish->attack = 0;
  double return_value_fabs_6;
  return_value_fabs_6=fabs((double)(tpsi - fish->psi));
  double return_value_fabs_5;
  if(return_value_fabs_6 < 10.0)
    fish->attack = 1;

  else
  {
    return_value_fabs_5=fabs((double)(tpsi - fish->psi));
    if(return_value_fabs_5 < 45.0)
    {
      if(fish->psi > tpsi)
      {
        fish->psi = fish->psi - (float)0.5;
        if(fish->psi < -180.000000f)
          fish->psi = fish->psi + (float)360.0;

      }

      else
        if(fish->psi < tpsi)
        {
          fish->psi = fish->psi + (float)0.5;
          if(fish->psi > 180.000000f)
            fish->psi = fish->psi - (float)360.0;

        }

    }

    else
    {
      unsigned int return_value_ya_random_4;
      return_value_ya_random_4=ya_random();
      if((signed int)((100ul * (unsigned long int)return_value_ya_random_4) / 4294967296ul) >= 99)
        fish->sign = fish->sign < 0 ? 1 : -1;

      fish->psi = fish->psi + (float)(fish->sign != 0 ? 1 : -1);
      if(fish->psi > 180.000000f)
        fish->psi = fish->psi - (float)360.0;

      if(fish->psi < -180.000000f)
        fish->psi = fish->psi + (float)360.0;

    }
  }
  if(!(fish->attack == 0))
  {
    if((double)fish->v < 1.1)
      fish->spurt = 1;

    if(!(fish->spurt == 0))
      fish->v = fish->v + (float)0.2;

    if(fish->v > 5.000000f)
      fish->spurt = 0;

    if(fish->v > 1.000000f)
    {
      if(fish->spurt == 0)
        fish->v = fish->v - (float)0.2;

    }

  }

  else
  {
    unsigned int return_value_ya_random_7;
    return_value_ya_random_7=ya_random();
    if((signed int)((400ul * (unsigned long int)return_value_ya_random_7) / 4294967296ul) == 0)
    {
      if(fish->spurt == 0)
        fish->spurt = 1;

    }

    if(!(fish->spurt == 0))
      fish->v = fish->v + (float)0.05;

    if(fish->v > 3.000000f)
      fish->spurt = 0;

    if(fish->v > 1.000000f)
    {
      if(fish->spurt == 0)
        fish->v = fish->v - (float)0.05;

    }

  }
  double return_value_cos_8;
  return_value_cos_8=cos((double)fish->psi / 57.295);
  double return_value_cos_9;
  return_value_cos_9=cos((double)fish->theta / 57.295);
  fish->x = fish->x + (float)((double)(sharkspeed * fish->v) * return_value_cos_8 * return_value_cos_9);
  double return_value_sin_10;
  return_value_sin_10=sin((double)fish->psi / 57.295);
  double return_value_cos_11;
  return_value_cos_11=cos((double)fish->theta / 57.295);
  fish->y = fish->y + (float)((double)(sharkspeed * fish->v) * return_value_sin_10 * return_value_cos_11);
  double return_value_sin_12;
  return_value_sin_12=sin((double)fish->theta / 57.295);
  fish->z = fish->z + (float)((double)(sharkspeed * fish->v) * return_value_sin_12);
}

// VirtualRootWindowOfScreen
// file ./../utils/vroot.h line 87
static unsigned long int VirtualRootWindowOfScreen(struct anonymous_58 *screen)
{
  signed int return_value___isoc99_sscanf_2;
  static unsigned long int root = (unsigned long int)0;
  static struct anonymous_58 *save_screen = (struct anonymous_58 *)0;
  if(!(screen == save_screen))
  {
    struct _XDisplay *dpy = screen->display;
    unsigned long int __SWM_VROOT = (unsigned long int)0L;
    signed int i;
    unsigned long int rootReturn;
    unsigned long int parentReturn;
    unsigned long int *children;
    unsigned int numChildren;
    const char *xss_id;
    xss_id=getenv("XSCREENSAVER_WINDOW");
    if(!(xss_id == ((const char *)NULL)))
    {
      if(!(*xss_id == 0))
      {
        unsigned long int id = (unsigned long int)0;
        char c;
        signed int return_value___isoc99_sscanf_1;
        return_value___isoc99_sscanf_1=__isoc99_sscanf(xss_id, " 0x%lx %c", &id, &c);
        _Bool tmp_if_expr_3;
        if(return_value___isoc99_sscanf_1 == 1)
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value___isoc99_sscanf_2=__isoc99_sscanf(xss_id, " %lu %c", &id, &c);
          tmp_if_expr_3 = 1 == return_value___isoc99_sscanf_2 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
        {
          root = (unsigned long int)id;
          save_screen = screen;
          return root;
        }

      }

    }

    root = screen->root;
    __SWM_VROOT=XInternAtom(dpy, "__SWM_VROOT", 0);
    signed int return_value_XQueryTree_5;
    return_value_XQueryTree_5=XQueryTree(dpy, root, &rootReturn, &parentReturn, &children, &numChildren);
    if(!(return_value_XQueryTree_5 == 0))
    {
      i = 0;
      for( ; !((unsigned int)i >= numChildren); i = i + 1)
      {
        unsigned long int actual_type;
        signed int actual_format;
        unsigned long int nitems;
        unsigned long int bytesafter;
        unsigned char *newRoot = ((unsigned char *)NULL);
        signed int return_value_XGetWindowProperty_4;
        return_value_XGetWindowProperty_4=XGetWindowProperty(dpy, children[(signed long int)i], __SWM_VROOT, (signed long int)0, (signed long int)1, 0, (unsigned long int)33, &actual_type, &actual_format, &nitems, &bytesafter, &newRoot);
        if(return_value_XGetWindowProperty_4 == 0)
        {
          if(!(newRoot == ((unsigned char *)NULL)))
          {
            root = *((unsigned long int *)newRoot);
            break;
          }

        }

      }
      if(!(children == ((unsigned long int *)NULL)))
        XFree((void *)(char *)children);

    }

    save_screen = screen;
  }

  return root;
}

// Whale001
// file whale.c line 403
static void Whale001(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N001_link1);
  glVertex3fv(P001_link1);
  glNormal3fv(N068);
  glVertex3fv(P068_link1);
  glNormal3fv(N010_link1);
  glVertex3fv(P010_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N068);
  glVertex3fv(P068_link1);
  glNormal3fv(N076);
  glVertex3fv(P076_link2);
  glNormal3fv(N010_link1);
  glVertex3fv(P010_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N068);
  glVertex3fv(P068_link1);
  glNormal3fv(N070_link1);
  glVertex3fv(P070_link2);
  glNormal3fv(N076);
  glVertex3fv(P076_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N076);
  glVertex3fv(P076_link2);
  glNormal3fv(N070_link1);
  glVertex3fv(P070_link2);
  glNormal3fv(N074);
  glVertex3fv(P074_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N070_link1);
  glVertex3fv(P070_link2);
  glNormal3fv(N072);
  glVertex3fv(P072_link2);
  glNormal3fv(N074);
  glVertex3fv(P074_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N072);
  glVertex3fv(P072_link2);
  glNormal3fv(N070_link1);
  glVertex3fv(P070_link2);
  glNormal3fv(N074);
  glVertex3fv(P074_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N074);
  glVertex3fv(P074_link2);
  glNormal3fv(N070_link1);
  glVertex3fv(P070_link2);
  glNormal3fv(N076);
  glVertex3fv(P076_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N070_link1);
  glVertex3fv(P070_link2);
  glNormal3fv(N068);
  glVertex3fv(P068_link1);
  glNormal3fv(N076);
  glVertex3fv(P076_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N076);
  glVertex3fv(P076_link2);
  glNormal3fv(N068);
  glVertex3fv(P068_link1);
  glNormal3fv(N010_link1);
  glVertex3fv(P010_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N068);
  glVertex3fv(P068_link1);
  glNormal3fv(N001_link1);
  glVertex3fv(P001_link1);
  glNormal3fv(N010_link1);
  glVertex3fv(P010_link2);
  glEnd();
}

// Whale002
// file whale.c line 488
static void Whale002(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N011_link1);
  glVertex3fv(P011_link2);
  glNormal3fv(N001_link1);
  glVertex3fv(P001_link1);
  glNormal3fv(N009_link1);
  glVertex3fv(P009_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N075);
  glVertex3fv(P075_link2);
  glNormal3fv(N011_link1);
  glVertex3fv(P011_link2);
  glNormal3fv(N009_link1);
  glVertex3fv(P009_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N069_link1);
  glVertex3fv(P069_link2);
  glNormal3fv(N011_link1);
  glVertex3fv(P011_link2);
  glNormal3fv(N075);
  glVertex3fv(P075_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N069_link1);
  glVertex3fv(P069_link2);
  glNormal3fv(N075);
  glVertex3fv(P075_link2);
  glNormal3fv(N073);
  glVertex3fv(P073_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N071_link1);
  glVertex3fv(P071_link2);
  glNormal3fv(N069_link1);
  glVertex3fv(P069_link2);
  glNormal3fv(N073);
  glVertex3fv(P073_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N001_link1);
  glVertex3fv(P001_link1);
  glNormal3fv(N011_link1);
  glVertex3fv(P011_link2);
  glNormal3fv(N009_link1);
  glVertex3fv(P009_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N009_link1);
  glVertex3fv(P009_link2);
  glNormal3fv(N011_link1);
  glVertex3fv(P011_link2);
  glNormal3fv(N075);
  glVertex3fv(P075_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N011_link1);
  glVertex3fv(P011_link2);
  glNormal3fv(N069_link1);
  glVertex3fv(P069_link2);
  glNormal3fv(N075);
  glVertex3fv(P075_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N069_link1);
  glVertex3fv(P069_link2);
  glNormal3fv(N073);
  glVertex3fv(P073_link2);
  glNormal3fv(N075);
  glVertex3fv(P075_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N069_link1);
  glVertex3fv(P069_link2);
  glNormal3fv(N071_link1);
  glVertex3fv(P071_link2);
  glNormal3fv(N073);
  glVertex3fv(P073_link2);
  glEnd();
}

// Whale003
// file whale.c line 573
static void Whale003(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N018_link2);
  glVertex3fv(P018_link2);
  glNormal3fv(N001_link1);
  glVertex3fv(P001_link1);
  glNormal3fv(N019_link2);
  glVertex3fv(P019_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N019_link2);
  glVertex3fv(P019_link2);
  glNormal3fv(N001_link1);
  glVertex3fv(P001_link1);
  glNormal3fv(N012_link2);
  glVertex3fv(P012_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N017_link2);
  glVertex3fv(P017_link2);
  glNormal3fv(N001_link1);
  glVertex3fv(P001_link1);
  glNormal3fv(N018_link2);
  glVertex3fv(P018_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N001_link1);
  glVertex3fv(P001_link1);
  glNormal3fv(N017_link2);
  glVertex3fv(P017_link2);
  glNormal3fv(N016_link2);
  glVertex3fv(P016_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N001_link1);
  glVertex3fv(P001_link1);
  glNormal3fv(N013_link2);
  glVertex3fv(P013_link2);
  glNormal3fv(N012_link2);
  glVertex3fv(P012_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N001_link1);
  glVertex3fv(P001_link1);
  glNormal3fv(N016_link2);
  glVertex3fv(P016_link2);
  glNormal3fv(N015_link2);
  glVertex3fv(P015_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N001_link1);
  glVertex3fv(P001_link1);
  glNormal3fv(N014_link2);
  glVertex3fv(P014_link2);
  glNormal3fv(N013_link2);
  glVertex3fv(P013_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N001_link1);
  glVertex3fv(P001_link1);
  glNormal3fv(N015_link2);
  glVertex3fv(P015_link2);
  glNormal3fv(N014_link2);
  glVertex3fv(P014_link2);
  glEnd();
}

// Whale004
// file whale.c line 642
static void Whale004(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N014_link2);
  glVertex3fv(P014_link2);
  glNormal3fv(N015_link2);
  glVertex3fv(P015_link2);
  glNormal3fv(N023_link2);
  glVertex3fv(P023_link2);
  glNormal3fv(N022_link2);
  glVertex3fv(P022_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N015_link2);
  glVertex3fv(P015_link2);
  glNormal3fv(N016_link2);
  glVertex3fv(P016_link2);
  glNormal3fv(N024_link2);
  glVertex3fv(P024_link2);
  glNormal3fv(N023_link2);
  glVertex3fv(P023_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N016_link2);
  glVertex3fv(P016_link2);
  glNormal3fv(N017_link2);
  glVertex3fv(P017_link2);
  glNormal3fv(N025_link2);
  glVertex3fv(P025_link2);
  glNormal3fv(N024_link2);
  glVertex3fv(P024_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N017_link2);
  glVertex3fv(P017_link2);
  glNormal3fv(N018_link2);
  glVertex3fv(P018_link2);
  glNormal3fv(N026_link2);
  glVertex3fv(P026_link2);
  glNormal3fv(N025_link2);
  glVertex3fv(P025_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N013_link2);
  glVertex3fv(P013_link2);
  glNormal3fv(N014_link2);
  glVertex3fv(P014_link2);
  glNormal3fv(N022_link2);
  glVertex3fv(P022_link2);
  glNormal3fv(N021_link2);
  glVertex3fv(P021_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N012_link2);
  glVertex3fv(P012_link2);
  glNormal3fv(N013_link2);
  glVertex3fv(P013_link2);
  glNormal3fv(N021_link2);
  glVertex3fv(P021_link2);
  glNormal3fv(N020_link2);
  glVertex3fv(P020_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N018_link2);
  glVertex3fv(P018_link2);
  glNormal3fv(N019_link2);
  glVertex3fv(P019_link2);
  glNormal3fv(N027_link2);
  glVertex3fv(P027_link2);
  glNormal3fv(N026_link2);
  glVertex3fv(P026_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N019_link2);
  glVertex3fv(P019_link2);
  glNormal3fv(N012_link2);
  glVertex3fv(P012_link2);
  glNormal3fv(N020_link2);
  glVertex3fv(P020_link2);
  glNormal3fv(N027_link2);
  glVertex3fv(P027_link2);
  glEnd();
}

// Whale005
// file whale.c line 727
static void Whale005(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N022_link2);
  glVertex3fv(P022_link2);
  glNormal3fv(N023_link2);
  glVertex3fv(P023_link2);
  glNormal3fv(N031_link2);
  glVertex3fv(P031_link2);
  glNormal3fv(N030_link2);
  glVertex3fv(P030_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N021_link2);
  glVertex3fv(P021_link2);
  glNormal3fv(N022_link2);
  glVertex3fv(P022_link2);
  glNormal3fv(N030_link2);
  glVertex3fv(P030_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N021_link2);
  glVertex3fv(P021_link2);
  glNormal3fv(N030_link2);
  glVertex3fv(P030_link2);
  glNormal3fv(N029_link2);
  glVertex3fv(P029_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N023_link2);
  glVertex3fv(P023_link2);
  glNormal3fv(N024_link2);
  glVertex3fv(P024_link2);
  glNormal3fv(N031_link2);
  glVertex3fv(P031_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N024_link2);
  glVertex3fv(P024_link2);
  glNormal3fv(N032_link2);
  glVertex3fv(P032_link2);
  glNormal3fv(N031_link2);
  glVertex3fv(P031_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N024_link2);
  glVertex3fv(P024_link2);
  glNormal3fv(N025_link2);
  glVertex3fv(P025_link2);
  glNormal3fv(N032_link2);
  glVertex3fv(P032_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N025_link2);
  glVertex3fv(P025_link2);
  glNormal3fv(N033_link2);
  glVertex3fv(P033_link2);
  glNormal3fv(N032_link2);
  glVertex3fv(P032_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N020_link2);
  glVertex3fv(P020_link2);
  glNormal3fv(N021_link2);
  glVertex3fv(P021_link2);
  glNormal3fv(N029_link2);
  glVertex3fv(P029_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N020_link2);
  glVertex3fv(P020_link2);
  glNormal3fv(N029_link2);
  glVertex3fv(P029_link2);
  glNormal3fv(N028_link2);
  glVertex3fv(P028_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N027_link2);
  glVertex3fv(P027_link2);
  glNormal3fv(N020_link2);
  glVertex3fv(P020_link2);
  glNormal3fv(N028_link2);
  glVertex3fv(P028_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N027_link2);
  glVertex3fv(P027_link2);
  glNormal3fv(N028_link2);
  glVertex3fv(P028_link2);
  glNormal3fv(N035_link2);
  glVertex3fv(P035_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N025_link2);
  glVertex3fv(P025_link2);
  glNormal3fv(N026_link2);
  glVertex3fv(P026_link2);
  glNormal3fv(N033_link2);
  glVertex3fv(P033_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N033_link2);
  glVertex3fv(P033_link2);
  glNormal3fv(N026_link2);
  glVertex3fv(P026_link2);
  glNormal3fv(N034_link2);
  glVertex3fv(P034_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N026_link2);
  glVertex3fv(P026_link2);
  glNormal3fv(N027_link2);
  glVertex3fv(P027_link2);
  glNormal3fv(N035_link2);
  glVertex3fv(P035_link2);
  glNormal3fv(N034_link2);
  glVertex3fv(P034_link2);
  glEnd();
}

// Whale006
// file whale.c line 848
static void Whale006(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N092_link1);
  glVertex3fv(P092_link1);
  glNormal3fv(N093_link1);
  glVertex3fv(P093_link1);
  glNormal3fv(N094_link1);
  glVertex3fv(P094_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N093_link1);
  glVertex3fv(P093_link1);
  glNormal3fv(N092_link1);
  glVertex3fv(P092_link1);
  glNormal3fv(N094_link1);
  glVertex3fv(P094_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N092_link1);
  glVertex3fv(P092_link1);
  glNormal3fv(N091_link1);
  glVertex3fv(P091_link1);
  glNormal3fv(N095_link1);
  glVertex3fv(P095_link1);
  glNormal3fv(N094_link1);
  glVertex3fv(P094_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N091_link1);
  glVertex3fv(P091_link1);
  glNormal3fv(N092_link1);
  glVertex3fv(P092_link1);
  glNormal3fv(N094_link1);
  glVertex3fv(P094_link1);
  glNormal3fv(N095_link1);
  glVertex3fv(P095_link1);
  glEnd();
}

// Whale007
// file whale.c line 889
static void Whale007(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N030_link2);
  glVertex3fv(P030_link2);
  glNormal3fv(N031_link2);
  glVertex3fv(P031_link2);
  glNormal3fv(N039_link2);
  glVertex3fv(P039_link2);
  glNormal3fv(N038_link2);
  glVertex3fv(P038_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N029_link2);
  glVertex3fv(P029_link2);
  glNormal3fv(N030_link2);
  glVertex3fv(P030_link2);
  glNormal3fv(N038_link2);
  glVertex3fv(P038_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N029_link2);
  glVertex3fv(P029_link2);
  glNormal3fv(N038_link2);
  glVertex3fv(P038_link2);
  glNormal3fv(N037_link2);
  glVertex3fv(P037_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N028_link2);
  glVertex3fv(P028_link2);
  glNormal3fv(N029_link2);
  glVertex3fv(P029_link2);
  glNormal3fv(N037_link2);
  glVertex3fv(P037_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N028_link2);
  glVertex3fv(P028_link2);
  glNormal3fv(N037_link2);
  glVertex3fv(P037_link2);
  glNormal3fv(N036_link2);
  glVertex3fv(P036_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N035_link2);
  glVertex3fv(P035_link2);
  glNormal3fv(N028_link2);
  glVertex3fv(P028_link2);
  glNormal3fv(N036_link2);
  glVertex3fv(P036_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N035_link2);
  glVertex3fv(P035_link2);
  glNormal3fv(N036_link2);
  glVertex3fv(P036_link2);
  glNormal3fv(N043_link2);
  glVertex3fv(P043_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N034_link2);
  glVertex3fv(P034_link2);
  glNormal3fv(N035_link2);
  glVertex3fv(P035_link2);
  glNormal3fv(N043_link2);
  glVertex3fv(P043_link2);
  glNormal3fv(N042_link2);
  glVertex3fv(P042_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N033_link2);
  glVertex3fv(P033_link2);
  glNormal3fv(N034_link2);
  glVertex3fv(P034_link2);
  glNormal3fv(N042_link2);
  glVertex3fv(P042_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N033_link2);
  glVertex3fv(P033_link2);
  glNormal3fv(N042_link2);
  glVertex3fv(P042_link2);
  glNormal3fv(N041_link2);
  glVertex3fv(P041_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N031_link2);
  glVertex3fv(P031_link2);
  glNormal3fv(N032_link2);
  glVertex3fv(P032_link2);
  glNormal3fv(N039_link2);
  glVertex3fv(P039_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N039_link2);
  glVertex3fv(P039_link2);
  glNormal3fv(N032_link2);
  glVertex3fv(P032_link2);
  glNormal3fv(N040_link2);
  glVertex3fv(P040_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N032_link2);
  glVertex3fv(P032_link2);
  glNormal3fv(N033_link2);
  glVertex3fv(P033_link2);
  glNormal3fv(N040_link2);
  glVertex3fv(P040_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N040_link2);
  glVertex3fv(P040_link2);
  glNormal3fv(N033_link2);
  glVertex3fv(P033_link2);
  glNormal3fv(N041_link2);
  glVertex3fv(P041_link2);
  glEnd();
}

// Whale008
// file whale.c line 1010
static void Whale008(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N042_link2);
  glVertex3fv(P042_link2);
  glNormal3fv(N043_link2);
  glVertex3fv(P043_link2);
  glNormal3fv(N051_link2);
  glVertex3fv(P051_link2);
  glNormal3fv(N050_link2);
  glVertex3fv(P050_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N043_link2);
  glVertex3fv(P043_link2);
  glNormal3fv(N036_link2);
  glVertex3fv(P036_link2);
  glNormal3fv(N051_link2);
  glVertex3fv(P051_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N051_link2);
  glVertex3fv(P051_link2);
  glNormal3fv(N036_link2);
  glVertex3fv(P036_link2);
  glNormal3fv(N044_link2);
  glVertex3fv(P044_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N041_link2);
  glVertex3fv(P041_link2);
  glNormal3fv(N042_link2);
  glVertex3fv(P042_link2);
  glNormal3fv(N050_link2);
  glVertex3fv(P050_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N041_link2);
  glVertex3fv(P041_link2);
  glNormal3fv(N050_link2);
  glVertex3fv(P050_link2);
  glNormal3fv(N049_link2);
  glVertex3fv(P049_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N036_link2);
  glVertex3fv(P036_link2);
  glNormal3fv(N037_link2);
  glVertex3fv(P037_link2);
  glNormal3fv(N044_link2);
  glVertex3fv(P044_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N044_link2);
  glVertex3fv(P044_link2);
  glNormal3fv(N037_link2);
  glVertex3fv(P037_link2);
  glNormal3fv(N045_link2);
  glVertex3fv(P045_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N040_link2);
  glVertex3fv(P040_link2);
  glNormal3fv(N041_link2);
  glVertex3fv(P041_link2);
  glNormal3fv(N049_link2);
  glVertex3fv(P049_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N040_link2);
  glVertex3fv(P040_link2);
  glNormal3fv(N049_link2);
  glVertex3fv(P049_link2);
  glNormal3fv(N048_link2);
  glVertex3fv(P048_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N039_link2);
  glVertex3fv(P039_link2);
  glNormal3fv(N040_link2);
  glVertex3fv(P040_link2);
  glNormal3fv(N048_link2);
  glVertex3fv(P048_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N039_link2);
  glVertex3fv(P039_link2);
  glNormal3fv(N048_link2);
  glVertex3fv(P048_link2);
  glNormal3fv(N047_link2);
  glVertex3fv(P047_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N037_link2);
  glVertex3fv(P037_link2);
  glNormal3fv(N038_link2);
  glVertex3fv(P038_link2);
  glNormal3fv(N045_link2);
  glVertex3fv(P045_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N038_link2);
  glVertex3fv(P038_link2);
  glNormal3fv(N046_link2);
  glVertex3fv(P046_link2);
  glNormal3fv(N045_link2);
  glVertex3fv(P045_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N038_link2);
  glVertex3fv(P038_link2);
  glNormal3fv(N039_link2);
  glVertex3fv(P039_link2);
  glNormal3fv(N047_link2);
  glVertex3fv(P047_link2);
  glNormal3fv(N046_link2);
  glVertex3fv(P046_link2);
  glEnd();
}

// Whale009
// file whale.c line 1131
static void Whale009(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N050_link2);
  glVertex3fv(P050_link2);
  glNormal3fv(N051_link2);
  glVertex3fv(P051_link2);
  glNormal3fv(N059_link2);
  glVertex3fv(P059_link2);
  glNormal3fv(N058_link2);
  glVertex3fv(P058_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N051_link2);
  glVertex3fv(P051_link2);
  glNormal3fv(N044_link2);
  glVertex3fv(P044_link2);
  glNormal3fv(N059_link2);
  glVertex3fv(P059_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N059_link2);
  glVertex3fv(P059_link2);
  glNormal3fv(N044_link2);
  glVertex3fv(P044_link2);
  glNormal3fv(N052_link2);
  glVertex3fv(P052_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N044_link2);
  glVertex3fv(P044_link2);
  glNormal3fv(N045_link2);
  glVertex3fv(P045_link2);
  glNormal3fv(N053_link1);
  glVertex3fv(P053_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N044_link2);
  glVertex3fv(P044_link2);
  glNormal3fv(N053_link1);
  glVertex3fv(P053_link1);
  glNormal3fv(N052_link2);
  glVertex3fv(P052_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N049_link2);
  glVertex3fv(P049_link2);
  glNormal3fv(N050_link2);
  glVertex3fv(P050_link2);
  glNormal3fv(N058_link2);
  glVertex3fv(P058_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N049_link2);
  glVertex3fv(P049_link2);
  glNormal3fv(N058_link2);
  glVertex3fv(P058_link2);
  glNormal3fv(N057_link1);
  glVertex3fv(P057_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N048_link2);
  glVertex3fv(P048_link2);
  glNormal3fv(N049_link2);
  glVertex3fv(P049_link2);
  glNormal3fv(N057_link1);
  glVertex3fv(P057_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N048_link2);
  glVertex3fv(P048_link2);
  glNormal3fv(N057_link1);
  glVertex3fv(P057_link1);
  glNormal3fv(N056_link1);
  glVertex3fv(P056_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N047_link2);
  glVertex3fv(P047_link2);
  glNormal3fv(N048_link2);
  glVertex3fv(P048_link2);
  glNormal3fv(N056_link1);
  glVertex3fv(P056_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N047_link2);
  glVertex3fv(P047_link2);
  glNormal3fv(N056_link1);
  glVertex3fv(P056_link1);
  glNormal3fv(N055_link1);
  glVertex3fv(P055_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N045_link2);
  glVertex3fv(P045_link2);
  glNormal3fv(N046_link2);
  glVertex3fv(P046_link2);
  glNormal3fv(N053_link1);
  glVertex3fv(P053_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N046_link2);
  glVertex3fv(P046_link2);
  glNormal3fv(N054_link1);
  glVertex3fv(P054_link1);
  glNormal3fv(N053_link1);
  glVertex3fv(P053_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N046_link2);
  glVertex3fv(P046_link2);
  glNormal3fv(N047_link2);
  glVertex3fv(P047_link2);
  glNormal3fv(N055_link1);
  glVertex3fv(P055_link1);
  glNormal3fv(N054_link1);
  glVertex3fv(P054_link1);
  glEnd();
}

// Whale010
// file whale.c line 1252
static void Whale010(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N080_link1);
  glVertex3fv(P080_link2);
  glNormal3fv(N081_link1);
  glVertex3fv(P081_link2);
  glNormal3fv(N085_link1);
  glVertex3fv(P085_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N081_link1);
  glVertex3fv(P081_link2);
  glNormal3fv(N083_link1);
  glVertex3fv(P083_link1);
  glNormal3fv(N085_link1);
  glVertex3fv(P085_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N085_link1);
  glVertex3fv(P085_link1);
  glNormal3fv(N083_link1);
  glVertex3fv(P083_link1);
  glNormal3fv(N077_link1);
  glVertex3fv(P077_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N083_link1);
  glVertex3fv(P083_link1);
  glNormal3fv(N087_link1);
  glVertex3fv(P087_link1);
  glNormal3fv(N077_link1);
  glVertex3fv(P077_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N077_link1);
  glVertex3fv(P077_link2);
  glNormal3fv(N087_link1);
  glVertex3fv(P087_link1);
  glNormal3fv(N090_link1);
  glVertex3fv(P090_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N081_link1);
  glVertex3fv(P081_link2);
  glNormal3fv(N080_link1);
  glVertex3fv(P080_link2);
  glNormal3fv(N085_link1);
  glVertex3fv(P085_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N083_link1);
  glVertex3fv(P083_link1);
  glNormal3fv(N081_link1);
  glVertex3fv(P081_link2);
  glNormal3fv(N085_link1);
  glVertex3fv(P085_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N083_link1);
  glVertex3fv(P083_link1);
  glNormal3fv(N085_link1);
  glVertex3fv(P085_link1);
  glNormal3fv(N077_link1);
  glVertex3fv(P077_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N087_link1);
  glVertex3fv(P087_link1);
  glNormal3fv(N083_link1);
  glVertex3fv(P083_link1);
  glNormal3fv(N077_link1);
  glVertex3fv(P077_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N087_link1);
  glVertex3fv(P087_link1);
  glNormal3fv(N077_link1);
  glVertex3fv(P077_link2);
  glNormal3fv(N090_link1);
  glVertex3fv(P090_link1);
  glEnd();
}

// Whale011
// file whale.c line 1337
static void Whale011(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N082_link1);
  glVertex3fv(P082_link2);
  glNormal3fv(N084_link1);
  glVertex3fv(P084_link1);
  glNormal3fv(N079_link1);
  glVertex3fv(P079_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N084_link1);
  glVertex3fv(P084_link1);
  glNormal3fv(N086_link1);
  glVertex3fv(P086_link1);
  glNormal3fv(N079_link1);
  glVertex3fv(P079_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N079_link1);
  glVertex3fv(P079_link2);
  glNormal3fv(N086_link1);
  glVertex3fv(P086_link1);
  glNormal3fv(N078_link1);
  glVertex3fv(P078_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N086_link1);
  glVertex3fv(P086_link1);
  glNormal3fv(N088_link1);
  glVertex3fv(P088_link1);
  glNormal3fv(N078_link1);
  glVertex3fv(P078_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N078_link1);
  glVertex3fv(P078_link2);
  glNormal3fv(N088_link1);
  glVertex3fv(P088_link1);
  glNormal3fv(N089_link1);
  glVertex3fv(P089_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N088_link1);
  glVertex3fv(P088_link1);
  glNormal3fv(N086_link1);
  glVertex3fv(P086_link1);
  glNormal3fv(N089_link1);
  glVertex3fv(P089_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N089_link1);
  glVertex3fv(P089_link1);
  glNormal3fv(N086_link1);
  glVertex3fv(P086_link1);
  glNormal3fv(N078_link1);
  glVertex3fv(P078_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N086_link1);
  glVertex3fv(P086_link1);
  glNormal3fv(N084_link1);
  glVertex3fv(P084_link1);
  glNormal3fv(N078_link1);
  glVertex3fv(P078_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N078_link1);
  glVertex3fv(P078_link2);
  glNormal3fv(N084_link1);
  glVertex3fv(P084_link1);
  glNormal3fv(N079_link1);
  glVertex3fv(P079_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N084_link1);
  glVertex3fv(P084_link1);
  glNormal3fv(N082_link1);
  glVertex3fv(P082_link2);
  glNormal3fv(N079_link1);
  glVertex3fv(P079_link2);
  glEnd();
}

// Whale012
// file whale.c line 1422
static void Whale012(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N058_link2);
  glVertex3fv(P058_link2);
  glNormal3fv(N059_link2);
  glVertex3fv(P059_link2);
  glNormal3fv(N067_link1);
  glVertex3fv(P067_link1);
  glNormal3fv(N066_link2);
  glVertex3fv(P066_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N059_link2);
  glVertex3fv(P059_link2);
  glNormal3fv(N052_link2);
  glVertex3fv(P052_link2);
  glNormal3fv(N060_link2);
  glVertex3fv(P060_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N059_link2);
  glVertex3fv(P059_link2);
  glNormal3fv(N060_link2);
  glVertex3fv(P060_link2);
  glNormal3fv(N067_link1);
  glVertex3fv(P067_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N058_link2);
  glVertex3fv(P058_link2);
  glNormal3fv(N066_link2);
  glVertex3fv(P066_link2);
  glNormal3fv(N065_link2);
  glVertex3fv(P065_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N058_link2);
  glVertex3fv(P058_link2);
  glNormal3fv(N065_link2);
  glVertex3fv(P065_link2);
  glNormal3fv(N057_link1);
  glVertex3fv(P057_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N056_link1);
  glVertex3fv(P056_link1);
  glNormal3fv(N057_link1);
  glVertex3fv(P057_link1);
  glNormal3fv(N065_link2);
  glVertex3fv(P065_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N056_link1);
  glVertex3fv(P056_link1);
  glNormal3fv(N065_link2);
  glVertex3fv(P065_link2);
  glNormal3fv(N006_link2);
  glVertex3fv(P006_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N056_link1);
  glVertex3fv(P056_link1);
  glNormal3fv(N006_link2);
  glVertex3fv(P006_link2);
  glNormal3fv(N063_link2);
  glVertex3fv(P063_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N056_link1);
  glVertex3fv(P056_link1);
  glNormal3fv(N063_link2);
  glVertex3fv(P063_link2);
  glNormal3fv(N055_link1);
  glVertex3fv(P055_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N054_link1);
  glVertex3fv(P054_link1);
  glNormal3fv(N062_link2);
  glVertex3fv(P062_link2);
  glNormal3fv(N005_link2);
  glVertex3fv(P005_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N054_link1);
  glVertex3fv(P054_link1);
  glNormal3fv(N005_link2);
  glVertex3fv(P005_link2);
  glNormal3fv(N053_link1);
  glVertex3fv(P053_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N053_link1);
  glVertex3fv(P053_link1);
  glNormal3fv(N005_link2);
  glVertex3fv(P005_link2);
  glNormal3fv(N060_link2);
  glVertex3fv(P060_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N053_link1);
  glVertex3fv(P053_link1);
  glNormal3fv(N060_link2);
  glVertex3fv(P060_link2);
  glNormal3fv(N052_link2);
  glVertex3fv(P052_link2);
  glEnd();
}

// Whale013
// file whale.c line 1533
static void Whale013(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N066_link2);
  glVertex3fv(P066_link2);
  glNormal3fv(N067_link1);
  glVertex3fv(P067_link1);
  glNormal3fv(N096);
  glVertex3fv(P096);
  glNormal3fv(N097_link1);
  glVertex3fv(P097_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N097_link1);
  glVertex3fv(P097_link1);
  glNormal3fv(N096);
  glVertex3fv(P096);
  glNormal3fv(N098_link1);
  glVertex3fv(P098_link1);
  glNormal3fv(N099_link1);
  glVertex3fv(P099_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N065_link2);
  glVertex3fv(P065_link2);
  glNormal3fv(N066_link2);
  glVertex3fv(P066_link2);
  glNormal3fv(N097_link1);
  glVertex3fv(P097_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N067_link1);
  glVertex3fv(P067_link1);
  glNormal3fv(N060_link2);
  glVertex3fv(P060_link2);
  glNormal3fv(N096);
  glVertex3fv(P096);
  glEnd();
  glBegin(cap);
  glNormal3fv(N060_link2);
  glVertex3fv(P060_link2);
  glNormal3fv(N005_link2);
  glVertex3fv(P005_link2);
  glNormal3fv(N096);
  glVertex3fv(P096);
  glEnd();
  glBegin(cap);
  glNormal3fv(N096);
  glVertex3fv(P096);
  glNormal3fv(N005_link2);
  glVertex3fv(P005_link2);
  glNormal3fv(N098_link1);
  glVertex3fv(P098_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N006_link2);
  glVertex3fv(P006_link2);
  glNormal3fv(N065_link2);
  glVertex3fv(P065_link2);
  glNormal3fv(N097_link1);
  glVertex3fv(P097_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N006_link2);
  glVertex3fv(P006_link2);
  glNormal3fv(N097_link1);
  glVertex3fv(P097_link1);
  glNormal3fv(N099_link1);
  glVertex3fv(P099_link1);
  glEnd();
  glBegin(cap);
  glVertex3fv(P005_link2);
  glVertex3fv(P006_link2);
  glVertex3fv(P099_link1);
  glVertex3fv(P098_link1);
  glEnd();
}

// Whale014
// file whale.c line 1612
static void Whale014(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N062_link2);
  glVertex3fv(P062_link2);
  glNormal3fv(N004_link1);
  glVertex3fv(P004_link1);
  glNormal3fv(N005_link2);
  glVertex3fv(P005_link2);
  glEnd();
  glBegin(cap);
  glVertex3fv(P006_link2);
  glVertex3fv(P005_link2);
  glVertex3fv(P004_link1);
  glVertex3fv(P008_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N063_link2);
  glVertex3fv(P063_link2);
  glNormal3fv(N006_link2);
  glVertex3fv(P006_link2);
  glNormal3fv(N002_link2);
  glVertex3fv(P002_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N002_link2);
  glVertex3fv(P002_link2);
  glNormal3fv(N006_link2);
  glVertex3fv(P006_link2);
  glNormal3fv(N008_link2);
  glVertex3fv(P008_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N002_link2);
  glVertex3fv(P002_link2);
  glNormal3fv(N008_link2);
  glVertex3fv(P008_link2);
  glNormal3fv(N004_link1);
  glVertex3fv(P004_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N062_link2);
  glVertex3fv(P062_link2);
  glNormal3fv(N002_link2);
  glVertex3fv(P002_link2);
  glNormal3fv(N004_link1);
  glVertex3fv(P004_link1);
  glEnd();
}

// Whale015
// file whale.c line 1663
static void Whale015(unsigned int cap)
{
  glBegin(cap);
  glNormal3fv(N055_link1);
  glVertex3fv(P055_link1);
  glNormal3fv(N003_link2);
  glVertex3fv(P003_link2);
  glNormal3fv(N054_link1);
  glVertex3fv(P054_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N003_link2);
  glVertex3fv(P003_link2);
  glNormal3fv(N055_link1);
  glVertex3fv(P055_link1);
  glNormal3fv(N063_link2);
  glVertex3fv(P063_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N003_link2);
  glVertex3fv(P003_link2);
  glNormal3fv(N063_link2);
  glVertex3fv(P063_link2);
  glNormal3fv(N100_link1);
  glVertex3fv(P100_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N003_link2);
  glVertex3fv(P003_link2);
  glNormal3fv(N100_link1);
  glVertex3fv(P100_link1);
  glNormal3fv(N054_link1);
  glVertex3fv(P054_link1);
  glEnd();
  glBegin(cap);
  glNormal3fv(N054_link1);
  glVertex3fv(P054_link1);
  glNormal3fv(N100_link1);
  glVertex3fv(P100_link1);
  glNormal3fv(N062_link2);
  glVertex3fv(P062_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N100_link1);
  glVertex3fv(P100_link1);
  glNormal3fv(N063_link2);
  glVertex3fv(P063_link2);
  glNormal3fv(N002_link2);
  glVertex3fv(P002_link2);
  glEnd();
  glBegin(cap);
  glNormal3fv(N100_link1);
  glVertex3fv(P100_link1);
  glNormal3fv(N002_link2);
  glVertex3fv(P002_link2);
  glNormal3fv(N062_link2);
  glVertex3fv(P062_link2);
  glEnd();
}

// Whale016
// file whale.c line 1724
static void Whale016(unsigned int cap)
{
  glBegin(cap);
  glVertex3fv(P104);
  glVertex3fv(P105_link1);
  glVertex3fv(P106);
  glEnd();
  glBegin(cap);
  glVertex3fv(P107);
  glVertex3fv(P108_link1);
  glVertex3fv(P109);
  glEnd();
  glBegin(cap);
  glVertex3fv(P110_link1);
  glVertex3fv(P111_link1);
  glVertex3fv(P112_link1);
  glVertex3fv(P113_link1);
  glVertex3fv(P114_link1);
  glVertex3fv(P115_link1);
  glEnd();
  glBegin(cap);
  glVertex3fv(P116_link1);
  glVertex3fv(P117_link1);
  glVertex3fv(P118_link1);
  glVertex3fv(P119_link1);
  glVertex3fv(P120_link1);
  glVertex3fv(P121_link1);
  glEnd();
}

// WhalePilot
// file atlantis.h line 124
extern void WhalePilot(struct _fishRec *fish, float whalespeed, signed int whaledir)
{
  fish->phi = (float)-20.0;
  fish->theta = (float)0.0;
  fish->psi = fish->psi + (float)(whaledir != 0 ? -0.5 : 0.5);
  double return_value_cos_1;
  return_value_cos_1=cos((double)fish->psi / 57.295);
  double return_value_cos_2;
  return_value_cos_2=cos((double)fish->theta / 57.295);
  fish->x = fish->x + (float)((double)(whalespeed * fish->v) * return_value_cos_1 * return_value_cos_2);
  double return_value_sin_3;
  return_value_sin_3=sin((double)fish->psi / 57.295);
  double return_value_cos_4;
  return_value_cos_4=cos((double)fish->theta / 57.295);
  fish->y = fish->y + (float)((double)(whalespeed * fish->v) * return_value_sin_3 * return_value_cos_4);
  double return_value_sin_5;
  return_value_sin_5=sin((double)fish->theta / 57.295);
  fish->z = fish->z + (float)((double)(whalespeed * fish->v) * return_value_sin_5);
}

// XChar2b_to_utf8
// file utf8wc.c line 306
extern char * XChar2b_to_utf8(const struct anonymous_4 *in, signed int *length_ret)
{
  signed int in_len = 0;
  const struct anonymous_4 *in_end;
  signed int out_len;
  char *utf8;
  char *out;
  const char *out_end;
  in_end = in;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(in_end->byte1 == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = in_end->byte2 != 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    in_end = in_end + 1l;
    in_len = in_len + 1;
  }
  while((_Bool)1);
  out_len = (in_len + 1) * 3;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(out_len + 1));
  out = (char *)return_value_malloc_2;
  utf8 = out;
  if(out == ((char *)NULL))
    return ((char *)NULL);

  else
  {
    out_end = out + (signed long int)out_len;
    while(!(in >= in_end))
    {
      unsigned long int uc = (unsigned long int)((signed int)in->byte1 << 8 | (signed int)in->byte2);
      signed int wrote;
      wrote=utf8_encode(uc, out, out_end - out);
      if(wrote >= 4)
        abort();

      out = out + (signed long int)wrote;
      in = in + 1l;
    }
    *out = (char)0;
    out_len = (signed int)((out - utf8) + (signed long int)1);
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)utf8, (unsigned long int)out_len);
    utf8 = (char *)return_value_realloc_3;
    if(!(length_ret == ((signed int *)NULL)))
      *length_ret = out_len;

    return utf8;
  }
}

// _add_next_thread
// file thread_util.c line 551
static void _add_next_thread(struct _parallel_startup_type *self)
{
  /* assertion !self->last_errno */
  assert(!(self->last_errno != 0));
  unsigned int return_value__threadpool_count_parallel_2;
  return_value__threadpool_count_parallel_2=_threadpool_count_parallel(self->parent);
  if(self->parent->parallel_unfinished == return_value__threadpool_count_parallel_2)
  {
    signed int return_value_pthread_cond_broadcast_1;
    return_value_pthread_cond_broadcast_1=pthread_cond_broadcast(&self->parent->cond);
    /* assertion !(pthread_cond_broadcast(&self->parent->cond)) */
    assert(!(return_value_pthread_cond_broadcast_1 != 0));
  }

  else
  {
    unsigned long int *thread = self->parent->parallel_threads + (signed long int)self->parent->parallel_unfinished;
    self->last_errno=pthread_create(thread, (const union pthread_attr_t *)(void *)0, _start_routine, (void *)self);
    if(!(self->last_errno == 0))
      _parallel_abort(self->parent);

  }
}

// _async_addr_from_name_free
// file async_netdb.c line 283
static void _async_addr_from_name_free(struct async_addr_from_name *self)
{
  if(!(self->res == ((struct addrinfo *)NULL)))
    freeaddrinfo(self->res);

  aligned_free((void *)self);
}

// _async_addr_from_name_hostname
// file async_netdb.c line 277
static char * _async_addr_from_name_hostname(struct async_addr_from_name *self)
{
  return (char *)(self + (signed long int)1);
}

// _async_addr_from_name_thread
// file async_netdb.c line 295
static void * _async_addr_from_name_thread(void *self_raw)
{
  struct async_addr_from_name *self = (struct async_addr_from_name *)self_raw;
  char *return_value__async_addr_from_name_hostname_1;
  return_value__async_addr_from_name_hostname_1=_async_addr_from_name_hostname(self);
  self->gai_error=getaddrinfo(return_value__async_addr_from_name_hostname_1, (const char *)(void *)0, (struct addrinfo *)(void *)0, &self->res);
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  self->errno_error = *return_value___errno_location_2;
  signed int return_value_io_thread_return_3;
  return_value_io_thread_return_3=io_thread_return(&self->io);
  if(!(return_value_io_thread_return_3 == 0))
    _async_addr_from_name_free(self);

  return (void *)0;
}

// _async_name_from_addr_set_param
// file async_netdb.c line 128
static void _async_name_from_addr_set_param(struct _async_name_from_addr_param *self, struct sockaddr *addr, unsigned int addrlen)
{
  self->addrlen = addrlen;
  memcpy((void *)&self->addr, (const void *)addr, (unsigned long int)addrlen);
}

// _async_name_from_addr_thread
// file async_netdb.c line 102
static void * _async_name_from_addr_thread(void *self_raw)
{
  struct async_name_from_addr *self = (struct async_name_from_addr *)self_raw;
  self->gai_error=getnameinfo((struct sockaddr *)(void *)&self->param.addr, self->param.addrlen, self->host, (unsigned int)sizeof(char [1025l]) /*1025ul*/ , (char *)(void *)0, (unsigned int)0, 8);
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  self->errno_error = *return_value___errno_location_1;
  signed int return_value_io_thread_return_2;
  return_value_io_thread_return_2=io_thread_return(&self->io);
  if(!(return_value_io_thread_return_2 == 0))
    aligned_free((void *)self);

  return (void *)0;
}

// _async_netdb_is_done
// file async_netdb.c line 39
signed int _async_netdb_is_done(struct io_thread *io)
{
  signed int return_value_io_thread_is_done_1;
  if(_has_threads >= 0)
  {
    return_value_io_thread_is_done_1=io_thread_is_done(io);
    return return_value_io_thread_is_done_1;
  }

  return 1;
}

// _get_cache_line_size
// file thread_util.c line 184
static unsigned int _get_cache_line_size(void)
{
  const signed int *name;
  signed long int result = (signed long int)0;
  static const signed int names[4l] = { 190, 193, 196, 199 };
  name = names;
  for( ; !(name == names + 4l); name = name + 1l)
  {
    signed long int sysconf_result;
    sysconf_result=sysconf(*name);
    if(!(result >= sysconf_result))
      result = sysconf_result;

  }
  if(!(result == 0l))
    return (unsigned int)result;

  else
    return (unsigned int)(1 << 7);
}

// _hardware_concurrency
// file thread_util.c line 462
static unsigned int _hardware_concurrency(void)
{
  signed long int count;
  count=sysconf(84);
  return (unsigned int)(count > (signed long int)0 ? count : (signed long int)1);
}

// _parallel_abort
// file thread_util.c line 527
static void _parallel_abort(struct threadpool *self)
{
  /* assertion self->count > 1 */
  assert(self->count > (unsigned int)1);
  self->count = self->parallel_unfinished + (unsigned int)1;
  signed int return_value_pthread_cond_broadcast_1;
  return_value_pthread_cond_broadcast_1=pthread_cond_broadcast(&self->cond);
  /* assertion !(pthread_cond_broadcast(&self->cond)) */
  assert(!(return_value_pthread_cond_broadcast_1 != 0));
}

// _serial_destroy
// file thread_util.c line 511
static void _serial_destroy(struct threadpool *self)
{
  void *thread = self->serial_threads;
  unsigned int i;
  unsigned int count;
  count=_threadpool_count_serial(self);
  i = (unsigned int)0;
  if(!(i == count))
  {
    self->thread_destroy(thread);
    thread = (void *)((char *)thread + (signed long int)self->thread_size);
    i = i + 1u;
  }

  free(self->serial_threads);
}

// _start_routine
// file thread_util.c line 585
static void * _start_routine(void *startup_raw)
{
  struct _parallel_startup_type *startup = (struct _parallel_startup_type *)startup_raw;
  struct threadpool *parent = startup->parent;
  void *thread;
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&parent->mutex);
  /* assertion !(pthread_mutex_lock(&parent->mutex)) */
  assert(!(return_value_pthread_mutex_lock_1 != 0));
  parent->parallel_unfinished = parent->parallel_unfinished + 1u;
  unsigned int return_value_thread_memory_alignment_2;
  return_value_thread_memory_alignment_2=thread_memory_alignment((struct _XDisplay *)(void *)0);
  startup->last_errno=aligned_malloc(&thread, return_value_thread_memory_alignment_2, parent->thread_size);
  if(!(startup->last_errno == 0))
  {
    _parallel_abort(parent);
    signed int return_value_pthread_mutex_unlock_3;
    return_value_pthread_mutex_unlock_3=pthread_mutex_unlock(&parent->mutex);
    /* assertion !(pthread_mutex_unlock(&parent->mutex)) */
    assert(!(return_value_pthread_mutex_unlock_3 != 0));
    return (void *)0;
  }

  startup->last_errno=startup->thread_create(thread, parent, parent->parallel_unfinished);
  if(!(startup->last_errno == 0))
  {
    _parallel_abort(parent);
    void *return_value__thread_free_and_unlock_4;
    return_value__thread_free_and_unlock_4=_thread_free_and_unlock(parent, thread);
    return return_value__thread_free_and_unlock_4;
  }

  /* assertion !startup->last_errno */
  assert(!(startup->last_errno != 0));
  _add_next_thread(startup);
  void *return_value__thread_destroy_and_unlock_5;
  if(!(startup->last_errno == 0))
  {
    return_value__thread_destroy_and_unlock_5=_thread_destroy_and_unlock(parent, thread);
    return return_value__thread_destroy_and_unlock_5;
  }

  void *return_value__thread_destroy_and_unlock_6;
  if(parent->parallel_pending == 0u)
  {
    if(parent->parallel_threads == ((unsigned long int *)NULL))
    {
      return_value__thread_destroy_and_unlock_6=_thread_destroy_and_unlock(parent, thread);
      return return_value__thread_destroy_and_unlock_6;
    }

    signed int return_value_pthread_cond_wait_7;
    return_value_pthread_cond_wait_7=pthread_cond_wait(&parent->cond, &parent->mutex);
    /* assertion !(pthread_cond_wait(&parent->cond, &parent->mutex)) */
    assert(!(return_value_pthread_cond_wait_7 != 0));
  }

  parent->parallel_pending = parent->parallel_pending - 1u;
  signed int return_value_pthread_cond_broadcast_8;
  if(parent->parallel_pending == 0u)
  {
    return_value_pthread_cond_broadcast_8=pthread_cond_broadcast(&parent->cond);
    /* assertion !(pthread_cond_broadcast(&parent->cond)) */
    assert(!(return_value_pthread_cond_broadcast_8 != 0));
  }

  signed int return_value_pthread_mutex_unlock_9;
  return_value_pthread_mutex_unlock_9=pthread_mutex_unlock(&parent->mutex);
  /* assertion !(pthread_mutex_unlock(&parent->mutex)) */
  assert(!(return_value_pthread_mutex_unlock_9 != 0));
  parent->thread_run(thread);
  signed int return_value_pthread_mutex_lock_10;
  return_value_pthread_mutex_lock_10=pthread_mutex_lock(&parent->mutex);
  /* assertion !(pthread_mutex_lock(&parent->mutex)) */
  assert(!(return_value_pthread_mutex_lock_10 != 0));
  signed int return_value_pthread_cond_wait_11;
  if(!(parent->parallel_pending == 0u))
  {
    return_value_pthread_cond_wait_11=pthread_cond_wait(&parent->cond, &parent->mutex);
    /* assertion !(pthread_cond_wait(&parent->cond, &parent->mutex)) */
    assert(!(return_value_pthread_cond_wait_11 != 0));
  }

  parent->parallel_unfinished = parent->parallel_unfinished - 1u;
  signed int return_value_pthread_cond_broadcast_12;
  if(parent->parallel_unfinished == 0u)
  {
    return_value_pthread_cond_broadcast_12=pthread_cond_broadcast(&parent->cond);
    /* assertion !(pthread_cond_broadcast(&parent->cond)) */
    assert(!(return_value_pthread_cond_broadcast_12 != 0));
  }

}

// _thread_destroy_and_unlock
// file thread_util.c line 577
static void * _thread_destroy_and_unlock(struct threadpool *self, void *thread)
{
  self->thread_destroy(thread);
  void *return_value__thread_free_and_unlock_1;
  return_value__thread_free_and_unlock_1=_thread_free_and_unlock(self, thread);
  return return_value__thread_free_and_unlock_1;
}

// _thread_free_and_unlock
// file thread_util.c line 568
static void * _thread_free_and_unlock(struct threadpool *self, void *thread)
{
  signed int return_value_pthread_mutex_unlock_1;
  return_value_pthread_mutex_unlock_1=pthread_mutex_unlock(&self->mutex);
  /* assertion !(pthread_mutex_unlock(&self->mutex)) */
  assert(!(return_value_pthread_mutex_unlock_1 != 0));
  aligned_free(thread);
  return (void *)0;
}

// _threadpool_count_parallel
// file thread_util.c line 541
static unsigned int _threadpool_count_parallel(struct threadpool *self)
{
  /* assertion _has_pthread */
  assert(_has_pthread != 0);
  /* assertion self->count >= 1 */
  assert(self->count >= (unsigned int)1);
  return self->count - (unsigned int)1;
}

// _threadpool_count_serial
// file thread_util.c line 501
static unsigned int _threadpool_count_serial(struct threadpool *self)
{
  /* assertion _has_pthread */
  assert(_has_pthread != 0);
  if(_has_pthread >= 0)
    return (unsigned int)(self->count != 0u ? 1 : 0);

  else
    return self->count;
}

// _translate_h_errno
// file async_netdb.c line 82
static signed int _translate_h_errno(signed int error)
{
  switch(error)
  {
    case 1:

    case 4:
      return -2;
    case 2:
      return -3;
    default:
      return -4;
  }
}

// _unlock_and_destroy
// file thread_util.c line 685
static void _unlock_and_destroy(struct threadpool *self)
{
  unsigned long int *threads = self->parallel_threads;
  self->parallel_threads = (unsigned long int *)(void *)0;
  signed int return_value_pthread_cond_broadcast_1;
  if(!(threads == ((unsigned long int *)NULL)))
  {
    return_value_pthread_cond_broadcast_1=pthread_cond_broadcast(&self->cond);
    /* assertion !(pthread_cond_broadcast(&self->cond)) */
    assert(!(return_value_pthread_cond_broadcast_1 != 0));
  }

  signed int return_value_pthread_mutex_unlock_2;
  return_value_pthread_mutex_unlock_2=pthread_mutex_unlock(&self->mutex);
  /* assertion !(pthread_mutex_unlock(&self->mutex)) */
  assert(!(return_value_pthread_mutex_unlock_2 != 0));
  signed int return_value_pthread_join_3;
  if(!(threads == ((unsigned long int *)NULL)))
  {
    unsigned int i;
    unsigned int count;
    count=_threadpool_count_parallel(self);
    i = (unsigned int)0;
    for( ; !(i == count); i = i + 1u)
    {
      return_value_pthread_join_3=pthread_join(threads[(signed long int)i], (void **)(void *)0);
      /* assertion !(pthread_join(threads[i], ((void *)0))) */
      assert(!(return_value_pthread_join_3 != 0));
    }
    free((void *)threads);
    signed int return_value_pthread_cond_destroy_4;
    return_value_pthread_cond_destroy_4=pthread_cond_destroy(&self->cond);
    /* assertion !(pthread_cond_destroy(&self->cond)) */
    assert(!(return_value_pthread_cond_destroy_4 != 0));
    signed int return_value_pthread_mutex_destroy_5;
    return_value_pthread_mutex_destroy_5=pthread_mutex_destroy(&self->mutex);
    /* assertion !(pthread_mutex_destroy(&self->mutex)) */
    assert(!(return_value_pthread_mutex_destroy_5 != 0));
  }

  _serial_destroy(self);
}

// aligned_free
// file aligned_malloc.h line 35
void aligned_free(void *ptr)
{
  free(((void **)ptr)[(signed long int)-1]);
}

// aligned_malloc
// file aligned_malloc.h line 34
signed int aligned_malloc(void **ptr, unsigned int alignment, unsigned long int size)
{
  void *block_start;
  signed long int align1 = (signed long int)(alignment - (unsigned int)1);
  /* assertion alignment && !(alignment & (alignment - 1)) */
  assert(alignment != 0u && !((alignment & alignment - (unsigned int)1) != 0u));
  size = size + sizeof(void *) /*8ul*/  + (unsigned long int)align1;
  block_start=malloc(size);
  if(block_start == NULL)
    return 12;

  else
  {
    *ptr = (void *)((unsigned long int)(signed long int)block_start + sizeof(void *) /*8ul*/  + (unsigned long int)align1 & (unsigned long int)~align1);
    ((void **)*ptr)[(signed long int)-1] = block_start;
    return 0;
  }
}

// allocate_writable_colors
// file colors.c line 42
extern void allocate_writable_colors(struct anonymous_58 *screen, unsigned long int cmap, unsigned long int *pixels, signed int *ncolorsP)
{
  struct _XDisplay *dpy;
  struct _XDisplay *tmp_if_expr_1;
  if(!(screen == ((struct anonymous_58 *)NULL)))
    tmp_if_expr_1 = screen->display;

  else
    tmp_if_expr_1 = ((struct _XDisplay *)NULL);
  dpy = tmp_if_expr_1;
  signed int desired = *ncolorsP;
  signed int got = 0;
  signed int requested = desired;
  unsigned long int *new_pixels = pixels;
  *ncolorsP = 0;
  while(requested >= 1 && !(got >= desired))
  {
    if(!(desired + -got >= requested))
      requested = desired - got;

    signed int return_value_XAllocColorCells_2;
    return_value_XAllocColorCells_2=XAllocColorCells(dpy, cmap, 0, ((unsigned long int *)NULL), (unsigned int)0, new_pixels, (unsigned int)requested);
    if(!(return_value_XAllocColorCells_2 == 0))
    {
      new_pixels = new_pixels + (signed long int)requested;
      got = got + requested;
    }

    else
      requested = requested / 2;
  }
  *ncolorsP = *ncolorsP + got;
}

// async_addr_from_name_cancel
// file async_netdb.c line 344
void async_addr_from_name_cancel(struct async_addr_from_name *self)
{
  if(_has_threads >= 0)
  {
    signed int return_value_io_thread_cancel_1;
    return_value_io_thread_cancel_1=io_thread_cancel(&self->io);
    if(!(return_value_io_thread_cancel_1 == 0))
      _async_addr_from_name_free(self);

  }

  else
    aligned_free((void *)self);
}

// async_addr_from_name_finish
// file async_netdb.c line 361
signed int async_addr_from_name_finish(struct async_addr_from_name *self, void *addr, unsigned int *addrlen, signed int *errno_error)
{
  if(_has_threads >= 0)
  {
    signed int gai_error;
    io_thread_finish(&self->io);
    gai_error = self->gai_error;
    if(!(errno_error == ((signed int *)NULL)))
      *errno_error = self->errno_error;

    if(gai_error == 0)
    {
      struct addrinfo *ai = self->res;
      if(ai == ((struct addrinfo *)NULL))
        gai_error = -2;

      else
      {
        /* assertion ai->ai_addrlen <= sizeof (async_netdb_sockaddr_storage_t) */
        assert((unsigned long int)ai->ai_addrlen <= sizeof(struct sockaddr_storage) /*128ul*/ );
        memcpy(addr, (const void *)ai->ai_addr, (unsigned long int)ai->ai_addrlen);
        *addrlen = ai->ai_addrlen;
      }
    }

    _async_addr_from_name_free(self);
    return gai_error;
  }

  struct hostent *he;
  char *return_value__async_addr_from_name_hostname_1;
  return_value__async_addr_from_name_hostname_1=_async_addr_from_name_hostname(self);
  he=gethostbyname(return_value__async_addr_from_name_hostname_1);
  signed int error;
  signed int *return_value___h_errno_location_2;
  return_value___h_errno_location_2=__h_errno_location();
  error = *return_value___h_errno_location_2;
  void *raw_addr;
  struct sockaddr_storage *addr_storage = (struct sockaddr_storage *)addr;
  _async_addr_from_name_free(self);
  signed int return_value__translate_h_errno_3;
  if(he == ((struct hostent *)NULL))
  {
    return_value__translate_h_errno_3=_translate_h_errno(error);
    return return_value__translate_h_errno_3;
  }

  switch(he->h_addrtype)
  {
    case 2:
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;
      addr_in->sin_port = (unsigned short int)0;
      raw_addr = (void *)&addr_in->sin_addr;
      *addrlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
      /* assertion he->h_length == 4 */
      assert(he->h_length == 4);
      break;
    }
    case 10:
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      addr_in6->sin6_port = (unsigned short int)0;
      addr_in6->sin6_flowinfo = (unsigned int)0;
      raw_addr = (void *)&addr_in6->sin6_addr;
      *addrlen = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
      /* assertion he->h_length == 16 */
      assert(he->h_length == 16);
      break;
    }
    default:
      return -2;
  }
  addr_storage->ss_family = (unsigned short int)he->h_addrtype;
  memcpy(raw_addr, (const void *)he->h_addr_list[(signed long int)0], (unsigned long int)he->h_length);
  return 0;
}

// async_addr_from_name_start
// file async_netdb.c line 315
struct async_addr_from_name * async_addr_from_name_start(struct _XDisplay *dpy, const char *hostname)
{
  struct async_addr_from_name *self;
  unsigned int return_value_thread_memory_alignment_1;
  return_value_thread_memory_alignment_1=thread_memory_alignment(dpy);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(hostname);
  signed int return_value_aligned_malloc_3;
  return_value_aligned_malloc_3=aligned_malloc((void **)&self, return_value_thread_memory_alignment_1, sizeof(struct async_addr_from_name) /*32ul*/  + return_value_strlen_2 + (unsigned long int)1);
  if(!(return_value_aligned_malloc_3 == 0))
    return (struct async_addr_from_name *)(void *)0;

  else
  {
    char *return_value__async_addr_from_name_hostname_4;
    return_value__async_addr_from_name_hostname_4=_async_addr_from_name_hostname(self);
    strcpy(return_value__async_addr_from_name_hostname_4, hostname);
    _has_threads=threads_available(dpy);
    self->res = (struct addrinfo *)(void *)0;
    if(_has_threads >= 0)
    {
      struct async_addr_from_name *result;
      void *return_value_io_thread_create_5;
      return_value_io_thread_create_5=io_thread_create(&self->io, (void *)self, _async_addr_from_name_thread, dpy, (unsigned int)65536);
      result = (struct async_addr_from_name *)return_value_io_thread_create_5;
      if(result == ((struct async_addr_from_name *)NULL))
        aligned_free((void *)result);

      self = result;
    }

    return self;
  }
}

// async_name_from_addr_cancel
// file async_netdb.c line 182
void async_name_from_addr_cancel(struct async_name_from_addr *self)
{
  if(_has_threads >= 0)
  {
    signed int return_value_io_thread_cancel_1;
    return_value_io_thread_cancel_1=io_thread_cancel(&self->io);
    if(!(return_value_io_thread_cancel_1 == 0))
      aligned_free((void *)self);

  }

  else
    free((void *)self);
}

// async_name_from_addr_finish
// file async_netdb.c line 197
signed int async_name_from_addr_finish(struct async_name_from_addr *self_raw, char **host, signed int *errno_error)
{
  if(_has_threads >= 0)
  {
    struct async_name_from_addr *self = self_raw;
    signed int gai_error;
    io_thread_finish(&self->io);
    gai_error = self->gai_error;
    if(!(gai_error == 0))
    {
      if(!(errno_error == ((signed int *)NULL)))
        *errno_error = self->errno_error;

      *host = (char *)(void *)0;
    }

    else
    {
      *host=strdup(self->host);
      if(*host == ((char *)NULL))
        gai_error = -10;

    }
    aligned_free((void *)self);
    return gai_error;
  }

  struct _async_name_from_addr_param *async_name_from_addr_finish__1__2__self = (struct _async_name_from_addr_param *)self_raw;
  struct hostent *he;
  signed int error;
  const void *raw_addr;
  unsigned int addrlen;
  switch((signed int)(&async_name_from_addr_finish__1__2__self->addr)->ss_family)
  {
    case 2:
    {
      raw_addr = (const void *)&((struct sockaddr_in *)&async_name_from_addr_finish__1__2__self->addr)->sin_addr;
      addrlen = (unsigned int)4;
      break;
    }
    case 10:
    {
      raw_addr = (const void *)&((struct sockaddr_in6 *)&async_name_from_addr_finish__1__2__self->addr)->sin6_addr;
      addrlen = (unsigned int)16;
      break;
    }
    default:
      return -2;
  }
  he=gethostbyaddr(raw_addr, addrlen, (signed int)(&async_name_from_addr_finish__1__2__self->addr)->ss_family);
  signed int *return_value___h_errno_location_1;
  return_value___h_errno_location_1=__h_errno_location();
  error = *return_value___h_errno_location_1;
  free((void *)async_name_from_addr_finish__1__2__self);
  if(he == ((struct hostent *)NULL))
  {
    *host = (char *)(void *)0;
    signed int return_value__translate_h_errno_2;
    return_value__translate_h_errno_2=_translate_h_errno(error);
    return return_value__translate_h_errno_2;
  }

  if(he->h_name == ((char *)NULL))
    return -2;

  else
  {
    *host=strdup(he->h_name);
    if(*host == ((char *)NULL))
      return -10;

    else
      return 0;
  }
}

// async_name_from_addr_start
// file async_netdb.c line 141
struct async_name_from_addr * async_name_from_addr_start(struct _XDisplay *dpy, struct sockaddr *addr, unsigned int addrlen)
{
  /* assertion addrlen */
  assert(addrlen != 0u);
  /* assertion addrlen <= sizeof (async_netdb_sockaddr_storage_t) */
  assert((unsigned long int)addrlen <= sizeof(struct sockaddr_storage) /*128ul*/ );
  _has_threads=threads_available(dpy);
  if(_has_threads >= 0)
  {
    struct async_name_from_addr *self;
    struct async_name_from_addr *result;
    unsigned int return_value_thread_memory_alignment_1;
    return_value_thread_memory_alignment_1=thread_memory_alignment(dpy);
    signed int return_value_aligned_malloc_2;
    return_value_aligned_malloc_2=aligned_malloc((void **)&self, return_value_thread_memory_alignment_1, sizeof(struct async_name_from_addr) /*1192ul*/ );
    if(!(return_value_aligned_malloc_2 == 0))
      return (struct async_name_from_addr *)(void *)0;

    _async_name_from_addr_set_param(&self->param, addr, addrlen);
    void *return_value_io_thread_create_3;
    return_value_io_thread_create_3=io_thread_create(&self->io, (void *)self, _async_name_from_addr_thread, dpy, (unsigned int)65536);
    result = (struct async_name_from_addr *)return_value_io_thread_create_3;
    if(result == ((struct async_name_from_addr *)NULL))
      aligned_free((void *)self);

    return result;
  }

  struct _async_name_from_addr_param *async_name_from_addr_start__1__2__result;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(sizeof(struct _async_name_from_addr_param) /*136ul*/ );
  async_name_from_addr_start__1__2__result = (struct _async_name_from_addr_param *)return_value_malloc_4;
  if(!(async_name_from_addr_start__1__2__result == ((struct _async_name_from_addr_param *)NULL)))
    _async_name_from_addr_set_param(async_name_from_addr_start__1__2__result, addr, addrlen);

  return (struct async_name_from_addr *)async_name_from_addr_start__1__2__result;
}

// bigendian
// file xpm-ximage.c line 35
static signed int bigendian(void)
{
  /* tag-#anon#lUN[S32'i'|lARR4{S8}_S8_'c'] */
union anonymous_61
{
  // i
  signed int i;
  // c
  char c[(signed long int)sizeof(signed int) /*4l*/ ];
};

/* */
  ;
  union anonymous_61 u;
  u.i = 1;
  return (signed int)!(u.c[(signed long int)0] != 0);
}

// bitmap_to_texture
// file texfont.c line 108
static void bitmap_to_texture(struct _XDisplay *dpy, unsigned long int p, struct anonymous_59 *visual, signed int depth, signed int *wP, signed int *hP)
{
  signed int mipmap_p = 1;
  signed int ow = *wP;
  signed int oh = *hP;
  signed int w2;
  w2=to_pow2(ow);
  signed int h2;
  h2=to_pow2(oh);
  signed int x;
  signed int y;
  signed int max;
  signed int scale;
  struct _XImage *image = ((struct _XImage *)NULL);
  unsigned char *data;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)(w2 * 2), (unsigned long int)(h2 + 1));
  data = (unsigned char *)return_value_calloc_1;
  unsigned char *out = data;
  glGetIntegerv((unsigned int)0x0D33, &max);
  scale = 1;
  for( ; !(max >= h2) || !(max >= w2); scale = scale * 2)
  {
    w2 = w2 / 2;
    h2 = h2 / 2;
  }
  unsigned int iformat = (unsigned int)0x8049;
  unsigned int format = (unsigned int)0x1909;
  unsigned int type = (unsigned int)0x1401;
  if(image == ((struct _XImage *)NULL))
    image=XGetImage(dpy, p, 0, 0, (unsigned int)ow, (unsigned int)oh, (unsigned long int)~0L, 2);

  y = 0;
  unsigned long int return_value;
  for( ; !(y >= h2); y = y + 1)
  {
    x = 0;
    for( ; !(x >= w2); x = x + 1)
    {
      signed int sx = x * scale;
      signed int sy = y * scale;
      unsigned long int pixel;
      unsigned long int tmp_if_expr_2;
      if(sx >= ow || sy >= oh)
        tmp_if_expr_2 = (unsigned long int)0;

      else
      {
        return_value=image->f.get_pixel(image, sx, sy);
        tmp_if_expr_2 = return_value;
      }
      pixel = tmp_if_expr_2;
      unsigned long int r = pixel & visual->red_mask;
      pixel = (r >> 24 | r >> 16 | r >> 8 | r) & (unsigned long int)0xFF;
      unsigned char *tmp_post_3 = out;
      out = out + 1l;
      *tmp_post_3 = (unsigned char)pixel;
    }
  }
  image->f.destroy_image(image);
  image = ((struct _XImage *)NULL);
  if(!(mipmap_p == 0))
    gluBuild2DMipmaps((unsigned int)0x0DE1, (signed int)iformat, w2, h2, format, type, (const void *)data);

  else
    glTexImage2D((unsigned int)0x0DE1, 0, (signed int)iformat, w2, h2, 0, format, type, (const void *)data);
  char msg[100l];
  sprintf(msg, "texture font %s (%d x %d)", mipmap_p != 0 ? "gluBuild2DMipmaps" : "glTexImage2D", w2, h2);
  check_gl_error(msg);
  free((void *)data);
  *wP = w2 * scale;
  *hP = h2 * scale;
}

// check_gl_error
// file ./../xlockmoreI.h line 64
extern void check_gl_error(const char *type)
{
  char buf[100l];
  unsigned int i;
  const char *e;
  i=glGetError();
  switch(i)
  {
    case (unsigned int)0:
      goto __CPROVER_DUMP_L13;
    case (unsigned int)0x0500:
    {
      e = "invalid enum";
      break;
    }
    case (unsigned int)0x0501:
    {
      e = "invalid value";
      break;
    }
    case (unsigned int)0x0502:
    {
      e = "invalid operation";
      break;
    }
    case (unsigned int)0x0503:
    {
      e = "stack overflow";
      break;
    }
    case (unsigned int)0x0504:
    {
      e = "stack underflow";
      break;
    }
    case (unsigned int)0x0505:
    {
      e = "out of memory";
      break;
    }
    case (unsigned int)0x0506:
    {
      e = "invalid framebuffer operation";
      break;
    }
    case (unsigned int)0x8031:
    {
      e = "table too large";
      break;
    }
    case (unsigned int)0x8065:
    {
      e = "texture too large";
      break;
    }
    default:
    {
      e = buf;
      sprintf(buf, "unknown error %d", (signed int)i);
    }
  }
  fprintf(stderr, "%s: %s error: %s\n", progname, type, e);
  exit(1);

__CPROVER_DUMP_L13:
  ;
}

// clear_gl_error
// file ./../xlockmoreI.h line 63
extern void clear_gl_error(void)
{
  unsigned int return_value_glGetError_1;
  do
  {
    return_value_glGetError_1=glGetError();
    if(return_value_glGetError_1 == 0u)
      break;

  }
  while((_Bool)1);
}

// clear_tank
// file atlantis.c line 340
static void clear_tank(struct anonymous *ap)
{
  glClear((unsigned int)(0x00004000 | 0x00000100));
  if(!(do_gradient == 0))
  {
    if(ap->wire == 0)
    {
      float top[4l] = { (float)0.00, (float)0.40, (float)0.70, 0.000000f };
      float bot[4l] = { (float)0.00, (float)0.05, (float)0.18, 0.000000f };
      glMatrixMode((unsigned int)0x1701);
      glPushMatrix();
      glLoadIdentity();
      glMatrixMode((unsigned int)0x1700);
      glPushMatrix();
      glLoadIdentity();
      glRotatef((float)0, (float)0, (float)0, (float)1);
      glShadeModel((unsigned int)0x1D01);
      glDisable((unsigned int)0x0B50);
      glBegin((unsigned int)0x0007);
      glColor3fv(bot);
      glVertex3f((float)-1, (float)-1, (float)1);
      glVertex3f((float)1, (float)-1, (float)1);
      glColor3fv(top);
      glVertex3f((float)1, (float)1, (float)1);
      glVertex3f((float)-1, (float)1, (float)1);
      glEnd();
      glEnable((unsigned int)0x0B50);
      glPopMatrix();
      glMatrixMode((unsigned int)0x1701);
      glPopMatrix();
      glMatrixMode((unsigned int)0x1700);
    }

  }

}

// complain
// file colors.c line 79
static void complain(signed int wanted_colors, signed int got_colors, signed int wanted_writable, signed int got_writable)
{
  if(wanted_colors + -10 >= got_colors)
  {
    if(got_writable == 0 && !(wanted_writable == 0))
      fprintf(stderr, "%s: wanted %d writable colors; got %d read-only colors.\n", progname, wanted_colors, got_colors);

    else
      fprintf(stderr, "%s: wanted %d%s colors; got %d.\n", progname, wanted_colors, got_writable != 0 ? " writable" : "", got_colors);
  }

}

// describe_gl_visual
// file visual-gl.c line 116
extern void describe_gl_visual(struct _IO_FILE *f, struct anonymous_58 *screen, struct anonymous_59 *visual, signed int private_cmap_p)
{
  describe_visual(f, screen, visual, private_cmap_p);
  signed int status;
  signed int value = 0;
  struct _XDisplay *dpy = screen->display;
  struct anonymous_62 vi_in;
  struct anonymous_62 *vi_out;
  signed int out_count;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_62 *)NULL))
    abort();

  status=glXGetConfig(dpy, vi_out, 1, &value);
  if(!(status == 3))
  {
    if(!(status == 4) && !(value == 0))
    {
      signed int return_value_glXGetConfig_1;
      return_value_glXGetConfig_1=glXGetConfig(dpy, vi_out, 3, &value);
      if(return_value_glXGetConfig_1 == 0)
      {
        if(!(value == 0))
          printf("    GLX level:         %d\n", value);

      }

      signed int return_value_glXGetConfig_2;
      return_value_glXGetConfig_2=glXGetConfig(dpy, vi_out, 4, &value);
      if(return_value_glXGetConfig_2 == 0 && !(value == 0))
      {
        signed int r = 0;
        signed int g = 0;
        signed int b = 0;
        signed int describe_gl_visual__1__1__1__a = 0;
        glXGetConfig(dpy, vi_out, 8, &r);
        glXGetConfig(dpy, vi_out, 9, &g);
        glXGetConfig(dpy, vi_out, 10, &b);
        glXGetConfig(dpy, vi_out, 11, &describe_gl_visual__1__1__1__a);
        printf("    GLX type:          RGBA (%2d, %2d, %2d, %2d)\n", r, g, b, describe_gl_visual__1__1__1__a);
        r = 0;
        g = 0;
        b = 0;
        describe_gl_visual__1__1__1__a = 0;
        glXGetConfig(dpy, vi_out, 14, &r);
        glXGetConfig(dpy, vi_out, 15, &g);
        glXGetConfig(dpy, vi_out, 16, &b);
        glXGetConfig(dpy, vi_out, 17, &describe_gl_visual__1__1__1__a);
        printf("    GLX accum:         RGBA (%2d, %2d, %2d, %2d)\n", r, g, b, describe_gl_visual__1__1__1__a);
      }

      else
      {
        value = 0;
        glXGetConfig(dpy, vi_out, 2, &value);
        printf("    GLX type:          indexed (%d)\n", value);
      }
      signed int return_value_glXGetConfig_3;
      return_value_glXGetConfig_3=glXGetConfig(dpy, vi_out, 0x20, &value);
      if(return_value_glXGetConfig_3 == 0)
      {
        if(!(value == 0x8000))
          printf("    GLX rating:        %s\n", value == 0x8000 ? "none" : (value == 0x8001 ? "slow" : "???"));

      }

      signed int return_value_glXGetConfig_4;
      return_value_glXGetConfig_4=glXGetConfig(dpy, vi_out, 5, &value);
      if(return_value_glXGetConfig_4 == 0)
        printf("    GLX double-buffer: %s\n", value != 0 ? "yes" : "no");

      signed int return_value_glXGetConfig_5;
      return_value_glXGetConfig_5=glXGetConfig(dpy, vi_out, 6, &value);
      if(return_value_glXGetConfig_5 == 0)
      {
        if(!(value == 0))
          printf("    GLX stereo:        %s\n", value != 0 ? "yes" : "no");

      }

      signed int return_value_glXGetConfig_6;
      return_value_glXGetConfig_6=glXGetConfig(dpy, vi_out, 7, &value);
      if(return_value_glXGetConfig_6 == 0)
      {
        if(!(value == 0))
          printf("    GLX aux buffers:   %d\n", value);

      }

      signed int return_value_glXGetConfig_7;
      return_value_glXGetConfig_7=glXGetConfig(dpy, vi_out, 12, &value);
      if(return_value_glXGetConfig_7 == 0)
        printf("    GLX depth size:    %d\n", value);

      signed int return_value_glXGetConfig_8;
      return_value_glXGetConfig_8=glXGetConfig(dpy, vi_out, 13, &value);
      if(return_value_glXGetConfig_8 == 0)
      {
        if(!(value == 0))
          printf("    GLX stencil size:  %d\n", value);

      }

      signed int return_value_glXGetConfig_10;
      return_value_glXGetConfig_10=glXGetConfig(dpy, vi_out, 0x80A8, &value);
      if(return_value_glXGetConfig_10 == 0)
      {
        if(!(value == 0))
        {
          signed int bufs = value;
          signed int return_value_glXGetConfig_9;
          return_value_glXGetConfig_9=glXGetConfig(dpy, vi_out, 0x80A9, &value);
          if(return_value_glXGetConfig_9 == 0)
            printf("    GLX multisample:   %d, %d\n", bufs, value);

        }

      }

      signed int return_value_glXGetConfig_12;
      return_value_glXGetConfig_12=glXGetConfig(dpy, vi_out, 0x23, &value);
      if(return_value_glXGetConfig_12 == 0)
      {
        if(!(value == 0x8000))
        {
          if(value == 0x8000)
            printf("    GLX transparency:  none\n");

          else
            if(value == 0x8009)
            {
              signed int return_value_glXGetConfig_11;
              return_value_glXGetConfig_11=glXGetConfig(dpy, vi_out, 0x24, &value);
              if(return_value_glXGetConfig_11 == 0)
                printf("    GLX transparency:  indexed (%d)\n", value);

            }

            else
              if(value == 0x8008)
              {
                signed int describe_gl_visual__1__1__4__2__r = 0;
                signed int describe_gl_visual__1__1__4__2__g = 0;
                signed int describe_gl_visual__1__1__4__2__b = 0;
                signed int describe_gl_visual__1__1__4__2__a = 0;
                glXGetConfig(dpy, vi_out, 0x25, &describe_gl_visual__1__1__4__2__r);
                glXGetConfig(dpy, vi_out, 0x26, &describe_gl_visual__1__1__4__2__g);
                glXGetConfig(dpy, vi_out, 0x27, &describe_gl_visual__1__1__4__2__b);
                glXGetConfig(dpy, vi_out, 0x28, &describe_gl_visual__1__1__4__2__a);
                printf("    GLX transparency:  RGBA (%2d, %2d, %2d, %2d)\n", describe_gl_visual__1__1__4__2__r, describe_gl_visual__1__1__4__2__g, describe_gl_visual__1__1__4__2__b, describe_gl_visual__1__1__4__2__a);
              }

        }

      }

    }

  }

}

// describe_visual
// file visual.c line 445
extern void describe_visual(struct _IO_FILE *f, struct anonymous_58 *screen, struct anonymous_59 *visual, signed int private_cmap_p)
{
  char n[10l];
  struct _XDisplay *dpy = screen->display;
  struct anonymous_62 vi_in;
  struct anonymous_62 *vi_out;
  signed int out_count;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_62 *)NULL))
    abort();

  if(!(private_cmap_p == 0))
    sprintf(n, "%3d", vi_out->colormap_size);

  else
    strcpy(n, "default");
  char *tmp_if_expr_5;
  char *tmp_if_expr_4;
  char *tmp_if_expr_3;
  char *tmp_if_expr_2;
  char *tmp_if_expr_1;
  if(vi_out->class == 0)
    tmp_if_expr_5 = "StaticGray, ";

  else
  {
    if(vi_out->class == 2)
      tmp_if_expr_4 = "StaticColor,";

    else
    {
      if(vi_out->class == 4)
        tmp_if_expr_3 = "TrueColor,  ";

      else
      {
        if(vi_out->class == 1)
          tmp_if_expr_2 = "GrayScale,  ";

        else
        {
          if(vi_out->class == 3)
            tmp_if_expr_1 = "PseudoColor,";

          else
            tmp_if_expr_1 = vi_out->class == 5 ? "DirectColor," : "UNKNOWN:    ";
          tmp_if_expr_2 = tmp_if_expr_1;
        }
        tmp_if_expr_3 = tmp_if_expr_2;
      }
      tmp_if_expr_4 = tmp_if_expr_3;
    }
    tmp_if_expr_5 = tmp_if_expr_4;
  }
  fprintf(f, "0x%02x (%s depth: %2d, cmap: %s)\n", (unsigned int)vi_out->visualid, tmp_if_expr_5, vi_out->depth, (const void *)n);
  XFree((void *)(char *)vi_out);
}

// draw_atlantis
// file atlantis.c line 504
static void draw_atlantis(struct ModeInfo *mi)
{
  struct anonymous *ap = &atlantis[(signed long int)mi->screen_number];
  struct _XDisplay *display = mi->dpy;
  unsigned long int window = mi->window;
  mi->is_drawn = 1;
  if(!(ap->glx_context == ((struct __GLXcontextRec **)NULL)))
  {
    glXMakeCurrent(display, window, *ap->glx_context);
    glClear((unsigned int)(0x00004000 | 0x00000100));
    glPushMatrix();
    glRotatef((float)0, (float)0, (float)0, (float)1);
    AllDisplay(ap);
    Animate(ap);
    glPopMatrix();
    if(!(mi->fps_p == 0))
      xlockmore_gl_draw_fps(mi);

    glXSwapBuffers(display, window);
  }

}

// enable_texture_string_parameters
// file texfont.c line 576
void enable_texture_string_parameters(void)
{
  glEnable((unsigned int)0x0DE1);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2800, 0x2601);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2801, 0x2703);
  glTexParameterf((unsigned int)0x0DE1, (unsigned int)0x8501, (float)0.25);
  clear_gl_error();
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2802, 0x2901);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2803, 0x2901);
  glAlphaFunc((unsigned int)0x0204, (float)0.01);
  glEnable((unsigned int)0x0BC0);
  glEnable((unsigned int)0x0BE2);
  glDisable((unsigned int)0x0B50);
  glDisable((unsigned int)0x0C60);
  glDisable((unsigned int)0x0C61);
  glBlendFunc((unsigned int)0x0302, (unsigned int)0x0303);
}

// find_similar_visual
// file visual.c line 503
extern struct anonymous_59 * find_similar_visual(struct anonymous_58 *screen, struct anonymous_59 *old_visual)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_62 vi_in;
  struct anonymous_62 *vi_out;
  struct anonymous_59 *result = ((struct anonymous_59 *)NULL);
  signed int out_count;
  vi_in.screen=screen_number(screen);
  vi_in.class=visual_class(screen, old_visual);
  vi_in.depth=visual_depth(screen, old_visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x8 | 0x4), &vi_in, &out_count);
  if(out_count >= 1 && !(vi_out == ((struct anonymous_62 *)NULL)))
    result = (vi_out + (signed long int)0)->visual;

  if(!(vi_out == ((struct anonymous_62 *)NULL)))
    XFree((void *)vi_out);

  vi_out = ((struct anonymous_62 *)NULL);
  if(result == ((struct anonymous_59 *)NULL))
  {
    vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x8), &vi_in, &out_count);
    if(out_count >= 1 && !(vi_out == ((struct anonymous_62 *)NULL)))
      result = (vi_out + (signed long int)0)->visual;

    if(!(vi_out == ((struct anonymous_62 *)NULL)))
      XFree((void *)vi_out);

    vi_out = ((struct anonymous_62 *)NULL);
  }

  if(result == ((struct anonymous_59 *)NULL))
    result = screen->root_visual;

  return result;
}

// fix_fds
// file screenhack.c line 403
static void fix_fds(void)
{
  signed int fd0;
  fd0=open("/dev/null", 02);
  signed int fd1;
  fd1=open("/dev/null", 02);
  signed int fd2;
  fd2=open("/dev/null", 02);
  if(fd0 >= 3)
    close(fd0);

  if(fd1 >= 3)
    close(fd1);

  if(fd2 >= 3)
    close(fd2);

}

// fps_compute
// file fps.h line 25
extern double fps_compute(struct fps_state *st, unsigned long int polys, double depth)
{
  unsigned long int return_value_strlen_2;
  unsigned long int return_value_strlen_3;
  unsigned long int return_value_strlen_4;
  if(st == ((struct fps_state *)NULL))
    return (double)0;

  else
  {
    signed int tmp_post_1 = st->frame_count;
    st->frame_count = st->frame_count + 1;
    if(tmp_post_1 >= st->last_ifps)
    {
      struct timezone tzp;
      gettimeofday(&st->this_frame_end, &tzp);
      if(st->prev_frame_end.tv_sec == 0l)
        st->prev_frame_end = st->this_frame_end;

    }

    if(!(st->this_frame_end.tv_sec == st->prev_frame_end.tv_sec))
    {
      double uprev_frame_end = (double)st->prev_frame_end.tv_sec + (double)st->prev_frame_end.tv_usec * 0.000001;
      double uthis_frame_end = (double)st->this_frame_end.tv_sec + (double)st->this_frame_end.tv_usec * 0.000001;
      double fps = (double)st->frame_count / (uthis_frame_end - uprev_frame_end);
      double idle = ((double)st->slept * 0.000001) / (uthis_frame_end - uprev_frame_end);
      double load = (double)100 * ((double)1 - idle);
      if(load < 0.000000)
        load = (double)0;

      st->prev_frame_end = st->this_frame_end;
      st->frame_count = 0;
      st->slept = (unsigned long int)0;
      st->last_ifps = (signed int)fps;
      st->last_fps = fps;
      sprintf(st->string, polys != 0ul ? "FPS:   %.1f \nLoad:  %.1f%% " : "FPS:  %.1f \nLoad: %.1f%% ", fps, load);
      if(polys >= 1ul)
      {
        const char *s = "";
        strcat(st->string, "\nPolys: ");
        if(polys >= 1000000ul)
        {
          return_value_strlen_2=strlen(st->string);
          sprintf(st->string + (signed long int)return_value_strlen_2, "%lu,%03lu,%03lu%s ", polys / (unsigned long int)1000000, (polys / (unsigned long int)1000) % (unsigned long int)1000, polys % (unsigned long int)1000, s);
        }

        else
          if(polys >= 1000ul)
          {
            return_value_strlen_3=strlen(st->string);
            sprintf(st->string + (signed long int)return_value_strlen_3, "%lu,%03lu%s ", polys / (unsigned long int)1000, polys % (unsigned long int)1000, s);
          }

          else
          {
            return_value_strlen_4=strlen(st->string);
            sprintf(st->string + (signed long int)return_value_strlen_4, "%lu%s ", polys, s);
          }
      }

      if(depth >= 0.0)
      {
        unsigned long int L;
        L=strlen(st->string);
        char *fps_compute__1__2__2__s = st->string + (signed long int)L;
        strcat(fps_compute__1__2__2__s, "\nDepth: ");
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(fps_compute__1__2__2__s);
        sprintf(fps_compute__1__2__2__s + (signed long int)return_value_strlen_5, "%.1f", depth);
        L=strlen(fps_compute__1__2__2__s);
        if((signed int)fps_compute__1__2__2__s[-2l + (signed long int)L] == 46)
        {
          if((signed int)fps_compute__1__2__2__s[-1l + (signed long int)L] == 48)
            fps_compute__1__2__2__s[(signed long int)(L - (unsigned long int)2)] = (char)0;

        }

      }

    }

    return st->last_fps;
  }
}

// fps_draw
// file fps.h line 26
extern void fps_draw(struct fps_state *st)
{
  struct anonymous_65 xgwa;
  const char *string = st->string;
  const char *s;
  signed int x = st->x;
  signed int y = st->y;
  signed int lines = 1;
  signed int lh = st->font->ascent + st->font->descent;
  XGetWindowAttributes(st->dpy, st->window, &xgwa);
  s = string;
  for( ; !(*s == 0); s = s + 1l)
    if((signed int)*s == 10)
      lines = lines + 1;

  if(!(y >= 0))
    y = -y + (lines - 1) * lh;

  else
    y = xgwa.height - y;
  y = y - (lh * (lines - 1) + st->font->descent);
  if(!(st->clear_p == 0))
  {
    signed int w;
    signed int h;
    w=string_width(st->font, string, &h);
    XFillRectangle(st->dpy, st->window, st->erase_gc, x - st->font->descent, y - lh, (unsigned int)(w + 2 * st->font->descent), (unsigned int)(h + 2 * st->font->descent));
  }

  unsigned long int return_value_strlen_1;
  while(!(lines == 0))
  {
    s=strchr(string, 10);
    if(s == ((const char *)NULL))
    {
      return_value_strlen_1=strlen(string);
      s = string + (signed long int)return_value_strlen_1;
    }

    XDrawString(st->dpy, st->window, st->draw_gc, x, y, string, (signed int)(s - string));
    string = s;
    string = string + 1l;
    lines = lines - 1;
    y = y + lh;
  }
}

// fps_free
// file fps.h line 23
extern void fps_free(struct fps_state *st)
{
  if(!(st->draw_gc == ((struct _XGC *)NULL)))
    XFreeGC(st->dpy, st->draw_gc);

  if(!(st->erase_gc == ((struct _XGC *)NULL)))
    XFreeGC(st->dpy, st->erase_gc);

  if(!(st->font == ((struct anonymous_13 *)NULL)))
    XFreeFont(st->dpy, st->font);

  free((void *)st);
}

// fps_init
// file fps.h line 22
extern struct fps_state * fps_init(struct _XDisplay *dpy, unsigned long int window)
{
  struct fps_state *st;
  const char *font;
  struct anonymous_13 *f;
  signed int return_value_get_boolean_resource_1;
  return_value_get_boolean_resource_1=get_boolean_resource(dpy, "doFPS", "DoFPS");
  if(return_value_get_boolean_resource_1 == 0)
    return ((struct fps_state *)NULL);

  else
  {
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct fps_state) /*1152ul*/ );
    st = (struct fps_state *)return_value_calloc_2;
    st->dpy = dpy;
    st->window = window;
    st->clear_p=get_boolean_resource(dpy, "fpsSolid", "FPSSolid");
    font=get_string_resource(dpy, "fpsFont", "Font");
    if(font == ((const char *)NULL))
      font = "-*-courier-bold-r-normal-*-180-*";

    f=XLoadQueryFont(dpy, font);
    if(f == ((struct anonymous_13 *)NULL))
      f=XLoadQueryFont(dpy, "fixed");

    struct anonymous_65 xgwa;
    struct anonymous_34 gcv;
    XGetWindowAttributes(dpy, window, &xgwa);
    gcv.font = f->fid;
    unsigned int return_value_get_pixel_resource_3;
    return_value_get_pixel_resource_3=get_pixel_resource(st->dpy, xgwa.colormap, "foreground", "Foreground");
    gcv.foreground = (unsigned long int)return_value_get_pixel_resource_3;
    st->draw_gc=XCreateGC(dpy, window, (unsigned long int)(1L << 14 | 1L << 2), &gcv);
    unsigned int return_value_get_pixel_resource_4;
    return_value_get_pixel_resource_4=get_pixel_resource(st->dpy, xgwa.colormap, "background", "Background");
    gcv.foreground = (unsigned long int)return_value_get_pixel_resource_4;
    st->erase_gc=XCreateGC(dpy, window, (unsigned long int)(1L << 14 | 1L << 2), &gcv);
    st->font = f;
    st->x = 10;
    st->y = 10;
    signed int return_value_get_boolean_resource_5;
    return_value_get_boolean_resource_5=get_boolean_resource(dpy, "fpsTop", "FPSTop");
    if(!(return_value_get_boolean_resource_5 == 0))
      st->y = -(st->font->ascent + st->font->descent + 10);

    strcpy(st->string, "FPS: ... ");
    return st;
  }
}

// fps_slept
// file fps.h line 24
extern void fps_slept(struct fps_state *st, unsigned long int usecs)
{
  st->slept = st->slept + usecs;
}

// free_colors
// file colors.c line 25
extern void free_colors(struct anonymous_58 *screen, unsigned long int cmap, struct anonymous_36 *colors, signed int ncolors)
{
  struct _XDisplay *dpy;
  struct _XDisplay *tmp_if_expr_1;
  if(!(screen == ((struct anonymous_58 *)NULL)))
    tmp_if_expr_1 = screen->display;

  else
    tmp_if_expr_1 = ((struct _XDisplay *)NULL);
  dpy = tmp_if_expr_1;
  signed int i;
  if(ncolors >= 1)
  {
    unsigned long int *pixels;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)ncolors);
    pixels = (unsigned long int *)return_value_malloc_2;
    i = 0;
    for( ; !(i >= ncolors); i = i + 1)
      pixels[(signed long int)i] = (colors + (signed long int)i)->pixel;
    XFreeColors(dpy, cmap, pixels, ncolors, (unsigned long int)0L);
    free((void *)pixels);
  }

}

// free_texture_font
// file texfont.c line 925
extern void free_texture_font(struct texture_font_data *data)
{
  while(!(data->cache == ((struct texfont_cache *)NULL)))
  {
    struct texfont_cache *next = data->cache->next;
    glDeleteTextures(1, &data->cache->texid);
    free((void *)data->cache);
    data->cache = next;
  }
  if(!(data->xftfont == ((struct _XftFont *)NULL)))
    XftFontClose(data->dpy, data->xftfont);

  free((void *)data);
}

// get_bits_per_pixel
// file visual.c line 545
extern signed int get_bits_per_pixel(struct _XDisplay *dpy, signed int depth)
{
  unsigned int i = (unsigned int)0;
  signed int count;
  signed int result;
  struct anonymous_31 *formats;
  formats=XListPixmapFormats(dpy, &count);
  if(formats == ((struct anonymous_31 *)NULL))
    return 0;

  else
  {
    for( ; (_Bool)1; i = i + 1u)
    {
      if(i == (unsigned int)count)
      {
        result = 0;
        goto __CPROVER_DUMP_L4;
      }

      if((formats + (signed long int)i)->depth == depth)
      {
        result = (formats + (signed long int)i)->bits_per_pixel;
        break;
      }

    }

  __CPROVER_DUMP_L4:
    ;
    XFree((void *)formats);
    return result;
  }
}

// get_boolean_resource
// file ./../utils/resources.h line 16
extern signed int get_boolean_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  char *tmp;
  char buf[100l];
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  char *os = s;
  unsigned long int return_value_strlen_4;
  unsigned long int return_value_strlen_5;
  unsigned long int return_value_strlen_6;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_13;
  signed int return_value_strcmp_15;
  if(s == ((char *)NULL))
    return 0;

  else
  {
    tmp = buf;
    for( ; !(*s == 0); s = s + 1l)
    {
      char *tmp_post_1 = tmp;
      tmp = tmp + 1l;
      _Bool tmp_if_expr_2;
      if((signed int)*s >= 65)
        tmp_if_expr_2 = (signed int)*s <= 90 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      signed int tmp_if_expr_3;
      if(tmp_if_expr_2)
        tmp_if_expr_3 = ((signed int)*s - 65) + 97;

      else
        tmp_if_expr_3 = (signed int)*s;
      *tmp_post_1 = (char)tmp_if_expr_3;
    }
    *tmp = (char)0;
    free((void *)os);
    while(!(buf[0l] == 0))
    {
      return_value_strlen_4=strlen(buf);
      if(!((signed int)buf[-1l + (signed long int)return_value_strlen_4] == 32))
      {
        return_value_strlen_5=strlen(buf);
        if(!((signed int)buf[-1l + (signed long int)return_value_strlen_5] == 9))
          break;

      }

      return_value_strlen_6=strlen(buf);
      buf[(signed long int)(return_value_strlen_6 - (unsigned long int)1)] = (char)0;
    }
    signed int return_value_strcmp_7;
    return_value_strcmp_7=strcmp(buf, "on");
    _Bool tmp_if_expr_9;
    if(return_value_strcmp_7 == 0)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_strcmp_8=strcmp(buf, "true");
      tmp_if_expr_9 = !(return_value_strcmp_8 != 0) ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_11;
    if(tmp_if_expr_9)
      tmp_if_expr_11 = (_Bool)1;

    else
    {
      return_value_strcmp_10=strcmp(buf, "yes");
      tmp_if_expr_11 = !(return_value_strcmp_10 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_11)
      return 1;

    else
    {
      signed int return_value_strcmp_12;
      return_value_strcmp_12=strcmp(buf, "off");
      _Bool tmp_if_expr_14;
      if(return_value_strcmp_12 == 0)
        tmp_if_expr_14 = (_Bool)1;

      else
      {
        return_value_strcmp_13=strcmp(buf, "false");
        tmp_if_expr_14 = !(return_value_strcmp_13 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_16;
      if(tmp_if_expr_14)
        tmp_if_expr_16 = (_Bool)1;

      else
      {
        return_value_strcmp_15=strcmp(buf, "no");
        tmp_if_expr_16 = !(return_value_strcmp_15 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_16)
        return 0;

      else
      {
        fprintf(stderr, "%s: %s must be boolean, not %s.\n", progname, res_name, (const void *)buf);
        return 0;
      }
    }
  }
}

// get_cache
// file texfont.c line 458
static struct texfont_cache * get_cache(struct texture_font_data *data, const char *string)
{
  signed int count = 0;
  struct texfont_cache *prev = ((struct texfont_cache *)NULL);
  struct texfont_cache *prev2 = ((struct texfont_cache *)NULL);
  struct texfont_cache *curr = ((struct texfont_cache *)NULL);
  struct texfont_cache *next = ((struct texfont_cache *)NULL);
  struct texfont_cache *tmp_if_expr_1;
  if(!(data->cache == ((struct texfont_cache *)NULL)))
  {
    prev2 = ((struct texfont_cache *)NULL);
    prev = ((struct texfont_cache *)NULL);
    curr = data->cache;
    next = curr->next;
    for( ; !(curr == ((struct texfont_cache *)NULL)); count = count + 1)
    {
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(string, curr->string);
      if(return_value_strcmp_2 == 0)
      {
        if(!(prev == ((struct texfont_cache *)NULL)))
          prev->next = next;

        if(!(curr == data->cache))
        {
          curr->next = data->cache;
          data->cache = curr;
        }

        return curr;
      }

      prev2 = prev;
      prev = curr;
      curr = next;
      if(!(curr == ((struct texfont_cache *)NULL)))
        tmp_if_expr_1 = curr->next;

      else
        tmp_if_expr_1 = ((struct texfont_cache *)NULL);
      next = tmp_if_expr_1;
    }
  }

  if(!(data->cache_size >= count))
  {
    free((void *)prev->string);
    prev->string = ((char *)NULL);
    prev->tex_width = 0;
    prev->tex_height = 0;
    memset((void *)&prev->extents, 0, sizeof(struct anonymous_11) /*12ul*/ );
    if(!(prev2 == ((struct texfont_cache *)NULL)))
      prev2->next = ((struct texfont_cache *)NULL);

    if(!(prev == data->cache))
      prev->next = data->cache;

    data->cache = prev;
    return prev;
  }

  else
  {
    void *return_value_calloc_3;
    return_value_calloc_3=calloc((unsigned long int)1, sizeof(struct texfont_cache) /*40ul*/ );
    curr = (struct texfont_cache *)return_value_calloc_3;
    glGenTextures(1, &curr->texid);
    curr->string = ((char *)NULL);
    curr->next = data->cache;
    data->cache = curr;
    return curr;
  }
}

// get_float_resource
// file ./../../utils/resources.h line 18
extern double get_float_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  double val;
  char c;
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  if(s == ((char *)NULL))
    return 0.0;

  else
  {
    signed int return_value___isoc99_sscanf_1;
    return_value___isoc99_sscanf_1=__isoc99_sscanf(s, " %lf %c", &val, &c);
    if(return_value___isoc99_sscanf_1 == 1)
    {
      free((void *)s);
      return val;
    }

    else
    {
      fprintf(stderr, "%s: %s must be a float, not %s.\n", progname, res_name, s);
      free((void *)s);
      return 0.0;
    }
  }
}

// get_gl_visual
// file ./../../utils/visual.h line 29
extern struct anonymous_59 * get_gl_visual(struct anonymous_58 *screen)
{
  struct _XDisplay *dpy = screen->display;
  signed int screen_num;
  screen_num=screen_number(screen);
  signed int attrs[21l][40l] = { { 4, 8, 8, 9, 8, 10, 8, 11, 8, 12, 8, 5, 13, 1, 0x80A8, 1, 0x80A9, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 11, 8, 12, 8, 5, 13, 1, 0x80A8, 1, 0x80A9, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 11, 8, 12, 8, 5, 13, 1, 0x80A8, 1, 0x80A9, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 11, 8, 12, 8, 5, 13, 1, 0x80A8, 1, 0x80A9, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 11, 8, 12, 8, 5, 13, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 12, 8, 5, 13, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 4, 9, 4, 10, 4, 12, 4, 5, 13, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 2, 9, 2, 10, 2, 12, 2, 5, 13, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 11, 8, 12, 8, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 12, 8, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 4, 9, 4, 10, 4, 12, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 2, 9, 2, 10, 2, 12, 2, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 11, 8, 12, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 8, 9, 8, 10, 8, 12, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 4, 9, 4, 10, 4, 12, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 2, 9, 2, 10, 2, 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 2, 8, 12, 8, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 2, 4, 12, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 2, 8, 12, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 2, 4, 12, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 4, 8, 1, 9, 1, 10, 1, 12, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
  signed int i = 0;
  signed int return_value_get_boolean_resource_1;
  return_value_get_boolean_resource_1=get_boolean_resource(dpy, "multiSample", "MultiSample");
  if(return_value_get_boolean_resource_1 == 0)
    i = 4;

  for( ; !((unsigned long int)i >= 21ul); i = i + 1)
  {
    struct anonymous_62 *vi;
    vi=glXChooseVisual(dpy, screen_num, attrs[(signed long int)i]);
    if(!(vi == ((struct anonymous_62 *)NULL)))
    {
      struct anonymous_59 *v = vi->visual;
      XFree((void *)vi);
      return v;
    }

  }
  return ((struct anonymous_59 *)NULL);
}

// get_integer_resource
// file ./../utils/resources.h line 17
extern signed int get_integer_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  signed int val;
  char c;
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  char *ss = s;
  _Bool tmp_if_expr_3;
  if(s == ((char *)NULL))
    return 0;

  else
  {
    for( ; !(*ss == 0); ss = ss + 1l)
      if((signed int)*ss >= 33)
        break;

    _Bool tmp_if_expr_4;
    if((signed int)*ss == 48)
    {
      if((signed int)ss[1l] == 120)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)ss[(signed long int)1] == 88 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      signed int return_value___isoc99_sscanf_1;
      return_value___isoc99_sscanf_1=__isoc99_sscanf(ss + (signed long int)2, "%x %c", (unsigned int *)&val, &c);
      if(return_value___isoc99_sscanf_1 == 1)
      {
        free((void *)s);
        return val;
      }

    }

    else
    {
      signed int return_value___isoc99_sscanf_2;
      return_value___isoc99_sscanf_2=__isoc99_sscanf(ss, "%d %c", &val, &c);
      if(return_value___isoc99_sscanf_2 == 1)
      {
        free((void *)s);
        return val;
      }

    }
    fprintf(stderr, "%s: %s must be an integer, not %s.\n", progname, res_name, s);
    free((void *)s);
    return 0;
  }
}

// get_minutes_resource
// file resources.c line 261
extern unsigned int get_minutes_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  unsigned int return_value_get_time_resource_1;
  return_value_get_time_resource_1=get_time_resource(dpy, res_name, res_class, 0);
  return return_value_get_time_resource_1;
}

// get_pixel_resource
// file ./../utils/resources.h line 19
extern unsigned int get_pixel_resource(struct _XDisplay *dpy, unsigned long int cmap, char *res_name, char *res_class)
{
  struct anonymous_36 color;
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  char *s2;
  signed int ok = 1;
  unsigned long int return_value_strlen_1;
  signed int return_value_XParseColor_3;
  signed int return_value_XAllocColor_4;
  unsigned long int return_value_strlen_6;
  signed int return_value_strcasecmp_7;
  if(!(s == ((char *)NULL)))
  {
    return_value_strlen_1=strlen(s);
    s2 = (s + (signed long int)return_value_strlen_1) - (signed long int)1;
    for( ; !(s >= s2); s2 = s2 - 1l)
    {
      _Bool tmp_if_expr_2;
      if((signed int)*s2 == 32)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)*s2 == 9 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        *s2 = (char)0;

      else
        break;
    }
    return_value_XParseColor_3=XParseColor(dpy, cmap, s, &color);
    if(return_value_XParseColor_3 == 0)
    {
      fprintf(stderr, "%s: can't parse color %s", progname, s);
      ok = 0;
      goto DEFAULT;
    }

    return_value_XAllocColor_4=XAllocColor(dpy, cmap, &color);
    if(return_value_XAllocColor_4 == 0)
    {
      fprintf(stderr, "%s: couldn't allocate color %s", progname, s);
      ok = 0;
      goto DEFAULT;
    }

    free((void *)s);
    return (unsigned int)color.pixel;
  }

  else
  {

  DEFAULT:
    ;
    if(!(s == ((char *)NULL)))
      free((void *)s);

    signed int black_p;
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen(res_class);
    _Bool tmp_if_expr_8;
    if(return_value_strlen_5 >= 10ul)
    {
      return_value_strlen_6=strlen(res_class);
      return_value_strcasecmp_7=strcasecmp("Background", (res_class + (signed long int)return_value_strlen_6) - (signed long int)10);
      tmp_if_expr_8 = !(return_value_strcasecmp_7 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    black_p = (signed int)tmp_if_expr_8;
    if(ok == 0)
      fprintf(stderr, ": using %s.\n", black_p != 0 ? "black" : "white");

    color.flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
    color.blue = (unsigned short int)(black_p != 0 ? 0 : 0xFFFF);
    color.green = color.blue;
    color.red = color.green;
    signed int return_value_XAllocColor_9;
    return_value_XAllocColor_9=XAllocColor(dpy, cmap, &color);
    if(!(return_value_XAllocColor_9 == 0))
      return (unsigned int)color.pixel;

    else
    {
      fprintf(stderr, "%s: couldn't allocate %s either!\n", progname, black_p != 0 ? "black" : "white");
      return (unsigned int)0;
    }
  }
}

// get_seconds_resource
// file resources.c line 255
extern unsigned int get_seconds_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  unsigned int return_value_get_time_resource_1;
  return_value_get_time_resource_1=get_time_resource(dpy, res_name, res_class, 1);
  return return_value_get_time_resource_1;
}

// get_string_resource
// file ./../utils/resources.h line 15
extern char * get_string_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  struct anonymous_9 value;
  char *type;
  char full_name[1024l];
  char full_class[1024l];
  strcpy(full_name, progname);
  strcat(full_name, ".");
  strcat(full_name, res_name);
  strcpy(full_class, progclass);
  strcat(full_class, ".");
  strcat(full_class, res_class);
  struct _XrmHashBucketRec *return_value_XtDatabase_2;
  return_value_XtDatabase_2=XtDatabase(dpy);
  signed int return_value_XrmGetResource_3;
  return_value_XrmGetResource_3=XrmGetResource(return_value_XtDatabase_2, full_name, full_class, &type, &value);
  if(!(return_value_XrmGetResource_3 == 0))
  {
    char *str;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(value.size + (unsigned int)1));
    str = (char *)return_value_malloc_1;
    strncpy(str, (char *)value.addr, (unsigned long int)value.size);
    str[(signed long int)value.size] = (char)0;
    return str;
  }

  return ((char *)NULL);
}

// get_time_resource
// file resources.c line 244
static unsigned int get_time_resource(struct _XDisplay *dpy, char *res_name, char *res_class, signed int sec_p)
{
  signed int val;
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  if(s == ((char *)NULL))
    return (unsigned int)0;

  else
  {
    val=parse_time(s, sec_p, 0);
    free((void *)s);
    return (unsigned int)(val < 0 ? 0 : val);
  }
}

// get_visual
// file visual.c line 50
extern struct anonymous_59 * get_visual(struct anonymous_58 *screen, const char *string, signed int prefer_writable_cells, signed int verbose_p)
{
  char *v;
  char *tmp_if_expr_2;
  char *return_value_strdup_1;
  if(!(string == ((const char *)NULL)))
  {
    return_value_strdup_1=strdup(string);
    tmp_if_expr_2 = return_value_strdup_1;
  }

  else
    tmp_if_expr_2 = ((char *)NULL);
  v = tmp_if_expr_2;
  char c;
  char *tmp;
  signed int vclass;
  unsigned long int id;
  struct anonymous_59 *result = ((struct anonymous_59 *)NULL);
  if(!(v == ((char *)NULL)))
  {
    tmp = v;
    for( ; !(*tmp == 0); tmp = tmp + 1l)
      if((signed int)*tmp >= 65)
      {
        if(!((signed int)*tmp >= 91))
          *tmp = (char)(((signed int)*tmp - 65) + 97);

      }

  }

  _Bool tmp_if_expr_20;
  if(v == ((char *)NULL))
    tmp_if_expr_20 = (_Bool)1;

  else
    tmp_if_expr_20 = !(*v != 0) ? (_Bool)1 : (_Bool)0;
  signed int return_value_strcmp_19;
  signed int return_value_strcmp_18;
  signed int return_value_strcmp_17;
  signed int return_value_strcmp_16;
  signed int return_value_strcmp_15;
  signed int return_value_strcmp_14;
  signed int return_value_strcmp_13;
  signed int return_value_strcmp_12;
  signed int return_value_strcmp_11;
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value___isoc99_sscanf_4;
  signed int return_value___isoc99_sscanf_3;
  if(tmp_if_expr_20)
    vclass = -2;

  else
  {
    return_value_strcmp_19=strcmp(v, "default");
    if(return_value_strcmp_19 == 0)
      vclass = -1;

    else
    {
      return_value_strcmp_18=strcmp(v, "best");
      if(return_value_strcmp_18 == 0)
        vclass = -2;

      else
      {
        return_value_strcmp_17=strcmp(v, "mono");
        if(return_value_strcmp_17 == 0)
          vclass = -3;

        else
        {
          return_value_strcmp_16=strcmp(v, "monochrome");
          if(return_value_strcmp_16 == 0)
            vclass = -3;

          else
          {
            return_value_strcmp_15=strcmp(v, "gray");
            if(return_value_strcmp_15 == 0)
              vclass = -4;

            else
            {
              return_value_strcmp_14=strcmp(v, "grey");
              if(return_value_strcmp_14 == 0)
                vclass = -4;

              else
              {
                return_value_strcmp_13=strcmp(v, "color");
                if(return_value_strcmp_13 == 0)
                  vclass = -5;

                else
                {
                  return_value_strcmp_12=strcmp(v, "gl");
                  if(return_value_strcmp_12 == 0)
                    vclass = -6;

                  else
                  {
                    return_value_strcmp_11=strcmp(v, "staticgray");
                    if(return_value_strcmp_11 == 0)
                      vclass = 0;

                    else
                    {
                      return_value_strcmp_10=strcmp(v, "staticcolor");
                      if(return_value_strcmp_10 == 0)
                        vclass = 2;

                      else
                      {
                        return_value_strcmp_9=strcmp(v, "truecolor");
                        if(return_value_strcmp_9 == 0)
                          vclass = 4;

                        else
                        {
                          return_value_strcmp_8=strcmp(v, "grayscale");
                          if(return_value_strcmp_8 == 0)
                            vclass = 1;

                          else
                          {
                            return_value_strcmp_7=strcmp(v, "greyscale");
                            if(return_value_strcmp_7 == 0)
                              vclass = 1;

                            else
                            {
                              return_value_strcmp_6=strcmp(v, "pseudocolor");
                              if(return_value_strcmp_6 == 0)
                                vclass = 3;

                              else
                              {
                                return_value_strcmp_5=strcmp(v, "directcolor");
                                if(return_value_strcmp_5 == 0)
                                  vclass = 5;

                                else
                                {
                                  return_value___isoc99_sscanf_4=__isoc99_sscanf(v, " %lu %c", &id, &c);
                                  if(return_value___isoc99_sscanf_4 == 1)
                                    vclass = -7;

                                  else
                                  {
                                    return_value___isoc99_sscanf_3=__isoc99_sscanf(v, " 0x%lx %c", &id, &c);
                                    if(return_value___isoc99_sscanf_3 == 1)
                                      vclass = -7;

                                    else
                                    {
                                      fprintf(stderr, "%s: unrecognized visual \"%s\".\n", progname, v);
                                      vclass = -1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  signed int return_value_visual_depth_21;
  if(vclass == -1)
    result = screen->root_visual;

  else
    if(vclass == -2)
      result=pick_best_visual(screen, prefer_writable_cells, 0);

    else
      if(vclass == -3)
      {
        result=pick_mono_visual(screen);
        if(result == ((struct anonymous_59 *)NULL) && !(verbose_p == 0))
          fprintf(stderr, "%s: no monochrome visuals.\n", progname);

      }

      else
        if(vclass == -4)
        {
          if(!(prefer_writable_cells == 0))
            result=pick_best_visual_of_class(screen, 1);

          if(result == ((struct anonymous_59 *)NULL))
            result=pick_best_visual_of_class(screen, 0);

          if(result == ((struct anonymous_59 *)NULL))
            result=pick_best_visual_of_class(screen, 1);

          if(result == ((struct anonymous_59 *)NULL) && !(verbose_p == 0))
            fprintf(stderr, "%s: no GrayScale or StaticGray visuals.\n", progname);

        }

        else
          if(vclass == -5)
          {
            signed int class;
            result = screen->root_visual;
            class=visual_class(screen, result);
            if(!(class == 2) && !(class == 3) && !(class == 4) && !(class == 5))
              result = ((struct anonymous_59 *)NULL);

            if(!(result == ((struct anonymous_59 *)NULL)))
            {
              return_value_visual_depth_21=visual_depth(screen, result);
              if(!(return_value_visual_depth_21 >= 2))
                result = ((struct anonymous_59 *)NULL);

            }

            if(result == ((struct anonymous_59 *)NULL))
              result=pick_best_visual(screen, prefer_writable_cells, 1);

            if(result == ((struct anonymous_59 *)NULL) && !(verbose_p == 0))
              fprintf(stderr, "%s: no color visuals.\n", progname);

          }

          else
            if(vclass == -6)
            {
              struct anonymous_59 *visual;
              visual=pick_best_gl_visual(screen);
              if(!(visual == ((struct anonymous_59 *)NULL)))
                result = visual;

              else
                if(!(verbose_p == 0))
                  fprintf(stderr, "%s: no visual suitable for GL.\n", progname);

            }

            else
              if(vclass == -7)
              {
                result=id_to_visual(screen, (signed int)id);
                if(result == ((struct anonymous_59 *)NULL) && !(verbose_p == 0))
                  fprintf(stderr, "%s: no visual with id 0x%x.\n", progname, (unsigned int)id);

              }

              else
              {
                struct anonymous_59 *get_visual__1__7__visual;
                get_visual__1__7__visual=pick_best_visual_of_class(screen, vclass);
                if(!(get_visual__1__7__visual == ((struct anonymous_59 *)NULL)))
                  result = get_visual__1__7__visual;

                else
                  if(!(verbose_p == 0))
                    fprintf(stderr, "%s: no visual of class %s.\n", progname, v);

              }
  if(!(v == ((char *)NULL)))
    free((void *)v);

  return result;
}

// get_visual_resource
// file ./../utils/visual.h line 16
extern struct anonymous_59 * get_visual_resource(struct anonymous_58 *screen, char *name, char *class, signed int prefer_writable_cells)
{
  char *string;
  string=get_string_resource(screen->display, name, class);
  struct anonymous_59 *v;
  v=get_visual(screen, string, prefer_writable_cells, 1);
  if(!(string == ((char *)NULL)))
    free((void *)string);

  if(!(v == ((struct anonymous_59 *)NULL)))
    return v;

  else
    return screen->root_visual;
}

// hardware_concurrency
// file thread_util.c line 478
unsigned int hardware_concurrency(struct _XDisplay *dpy)
{
  signed int return_value_threads_available_2;
  return_value_threads_available_2=threads_available(dpy);
  unsigned int return_value__hardware_concurrency_1;
  if(return_value_threads_available_2 >= 0)
  {
    return_value__hardware_concurrency_1=_hardware_concurrency();
    return return_value__hardware_concurrency_1;
  }

  return (unsigned int)1;
}

// has_writable_cells
// file ./../utils/visual.h line 25
extern signed int has_writable_cells(struct anonymous_58 *screen, struct anonymous_59 *visual)
{
  signed int return_value_visual_class_1;
  return_value_visual_class_1=visual_class(screen, visual);
  switch(return_value_visual_class_1)
  {
    case 1:

    case 3:

    case 5:
      return 1;
    case 0:

    case 4:

    case 2:
      return 0;
    default:
    {
      abort();
      return 0;
    }
  }
}

// hsv_to_rgb
// file hsv.c line 20
extern void hsv_to_rgb(signed int h, double s, double v, unsigned short int *r, unsigned short int *g, unsigned short int *b)
{
  double H;
  double S;
  double V;
  double R;
  double G;
  double B;
  double p1;
  double p2;
  double p3;
  double f;
  signed int i;
  if(s < 0.000000)
    s = (double)0;

  if(v < 0.000000)
    v = (double)0;

  if(s > 1.000000)
    s = (double)1;

  if(v > 1.000000)
    v = (double)1;

  S = s;
  V = v;
  H = (double)(h % 360) / 60.0;
  i = (signed int)H;
  f = H - (double)i;
  p1 = V * ((double)1 - S);
  p2 = V * ((double)1 - S * f);
  p3 = V * ((double)1 - S * ((double)1 - f));
  if(i == 0)
  {
    R = V;
    G = p3;
    B = p1;
  }

  else
    if(i == 1)
    {
      R = p2;
      G = V;
      B = p1;
    }

    else
      if(i == 2)
      {
        R = p1;
        G = V;
        B = p3;
      }

      else
        if(i == 3)
        {
          R = p1;
          G = p2;
          B = V;
        }

        else
          if(i == 4)
          {
            R = p3;
            G = p1;
            B = V;
          }

          else
          {
            R = V;
            G = p1;
            B = p2;
          }
  *r = (unsigned short int)(R * (double)65535);
  *g = (unsigned short int)(G * (double)65535);
  *b = (unsigned short int)(B * (double)65535);
}

// id_to_visual
// file visual.c line 340
extern struct anonymous_59 * id_to_visual(struct anonymous_58 *screen, signed int id)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_62 vi_in;
  struct anonymous_62 *vi_out;
  signed int out_count;
  vi_in.screen=screen_number(screen);
  vi_in.visualid = (unsigned long int)id;
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(!(vi_out == ((struct anonymous_62 *)NULL)))
  {
    struct anonymous_59 *v = (vi_out + (signed long int)0)->visual;
    XFree((void *)(char *)vi_out);
    return v;
  }

  return ((struct anonymous_59 *)NULL);
}

// init_GL
// file ./../xlockmoreI.h line 61
extern struct __GLXcontextRec ** init_GL(struct ModeInfo *mi)
{
  struct _XDisplay *dpy = mi->dpy;
  unsigned long int window = mi->window;
  struct anonymous_58 *screen = mi->xgwa.screen;
  struct anonymous_59 *visual = mi->xgwa.visual;
  struct __GLXcontextRec *glx_context = ((struct __GLXcontextRec *)NULL);
  struct anonymous_62 vi_in;
  struct anonymous_62 *vi_out;
  signed int out_count;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_62 *)NULL))
    abort();

  XSync(dpy, 0);
  orig_ehandler=XSetErrorHandler(BadValue_ehandler);
  glx_context=glXCreateContext(dpy, vi_out, ((struct __GLXcontextRec *)NULL), 1);
  XSync(dpy, 0);
  XSetErrorHandler(orig_ehandler);
  if(!(got_error == 0))
    glx_context = ((struct __GLXcontextRec *)NULL);

  XFree((void *)(char *)vi_out);
  if(glx_context == ((struct __GLXcontextRec *)NULL))
  {
    unsigned long int return_value_XVisualIDFromVisual_1;
    return_value_XVisualIDFromVisual_1=XVisualIDFromVisual(visual);
    fprintf(stderr, "%s: couldn't create GL context for visual 0x%x.\n", progname, (unsigned int)return_value_XVisualIDFromVisual_1);
    exit(1);
  }

  glXMakeCurrent(dpy, window, glx_context);
  unsigned char rgba_mode = (unsigned char)0;
  glGetBooleanv((unsigned int)0x0C31, &rgba_mode);
  if(rgba_mode == 0)
  {
    glIndexi((signed int)screen->white_pixel);
    glClearIndex((float)screen->black_pixel);
  }

  unsigned char d = (unsigned char)0;
  glGetBooleanv((unsigned int)0x0C32, &d);
  if(!(d == 0))
    glDrawBuffer((unsigned int)0x0405);

  else
    glDrawBuffer((unsigned int)0x0404);
  clear_gl_error();
  char *s;
  s=get_string_resource(mi->dpy, "background", "Background");
  struct anonymous_36 c = { .pixel=(unsigned long int)0, .red=0, .green=0, .blue=0,
    .flags=0, .pad=0 };
  signed int return_value_XParseColor_2;
  return_value_XParseColor_2=XParseColor(dpy, mi->xgwa.colormap, s, &c);
  if(return_value_XParseColor_2 == 0)
    fprintf(stderr, "%s: can't parse color %s; using black.\n", progname, s);

  glClearColor((float)((double)c.red / 65535.0), (float)((double)c.green / 65535.0), (float)((double)c.blue / 65535.0), (float)1.0);
  glClear((unsigned int)(0x00004000 | 0x00000100));
  struct __GLXcontextRec **ptr;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(sizeof(struct __GLXcontextRec *) /*8ul*/ );
  ptr = (struct __GLXcontextRec **)return_value_malloc_3;
  *ptr = glx_context;
  return ptr;
}

// init_atlantis
// file atlantis.c line 444
static void init_atlantis(struct ModeInfo *mi)
{
  signed int screen = mi->screen_number;
  struct anonymous *ap;
  struct _XDisplay *display = mi->dpy;
  unsigned long int window = mi->window;
  if(atlantis == ((struct anonymous *)NULL))
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)mi->num_screens, sizeof(struct anonymous) /*248ul*/ );
    atlantis = (struct anonymous *)return_value_calloc_1;
    if(atlantis == ((struct anonymous *)NULL))
      goto __CPROVER_DUMP_L8;

  }

  ap = &atlantis[(signed long int)screen];
  ap->num_sharks = (signed int)mi->batchcount;
  if(ap->sharks == ((struct _fishRec *)NULL))
  {
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)ap->num_sharks, sizeof(struct _fishRec) /*64ul*/ );
    ap->sharks = (struct _fishRec *)return_value_calloc_2;
    if(ap->sharks == ((struct _fishRec *)NULL))
    {
      free((void *)atlantis);
      atlantis = (struct anonymous *)(void *)0;
      goto __CPROVER_DUMP_L8;
    }

  }

  ap->sharkspeed = (float)mi->cycles;
  ap->sharksize = (signed int)mi->size;
  ap->whalespeed = (float)whalespeed;
  ap->wire = mi->wireframe_p;
  ap->glx_context=init_GL(mi);
  if(!(ap->glx_context == ((struct __GLXcontextRec **)NULL)))
  {
    reshape_atlantis(mi, mi->xgwa.width, mi->xgwa.height);
    glDrawBuffer((unsigned int)0x0405);
    Init(mi);
    AllDisplay(ap);
    glXSwapBuffers(display, window);
  }

  else
    XClearWindow(mi->dpy, mi->window);

__CPROVER_DUMP_L8:
  ;
}

// init_window
// file screenhack.c line 675
static void init_window(struct _XDisplay *dpy, struct _WidgetRec *toplevel, const char *title)
{
  unsigned long int window;
  struct anonymous_65 xgwa;
  XtPopup(toplevel, (enum anonymous_15)XtGrabNone);
  XtVaSetValues(toplevel, (char *)&XtShellStrings[(signed long int)356], title, (void *)0);
  window = toplevel->core.window;
  XGetWindowAttributes(dpy, window, &xgwa);
  XSelectInput(dpy, window, xgwa.your_event_mask | 1L << 0 | 1L << 1 | 1L << 2 | 1L << 3);
  XChangeProperty(dpy, window, XA_WM_PROTOCOLS, (unsigned long int)4, 32, 0, (unsigned char *)&XA_WM_DELETE_WINDOW, 1);
}

// io_thread_cancel
// file thread_util.h line 406
signed int io_thread_cancel(struct io_thread *self)
{
  if(_has_pthread >= 0)
  {
    enum _io_thread_status old_status;
    signed int return_value___atomic_exchange_n_1;
    return_value___atomic_exchange_n_1=__atomic_exchange_n(&self->status, _io_thread_cancelled, 5);
    old_status = (enum _io_thread_status)return_value___atomic_exchange_n_1;
    /* assertion old_status == _io_thread_working || old_status == _io_thread_done */
    assert((signed int)old_status == _io_thread_working || (signed int)old_status == _io_thread_done);
    signed int return_value_pthread_detach_2;
    return_value_pthread_detach_2=pthread_detach(self->thread);
    /* assertion !(pthread_detach(self->thread)) */
    assert(!(return_value_pthread_detach_2 != 0));
    return (signed int)((signed int)old_status != _io_thread_working);
  }

  return 0;
}

// io_thread_create
// file thread_util.h line 380
void * io_thread_create(struct io_thread *self, void *parent, void * (*start_routine)(void *), struct _XDisplay *dpy, unsigned int stacksize)
{
  signed int return_value_threads_available_4;
  return_value_threads_available_4=threads_available(dpy);
  signed int return_value_pthread_attr_destroy_3;
  if(return_value_threads_available_4 >= 0)
  {
    signed int error;
    union pthread_attr_t attr;
    union pthread_attr_t *attr_ptr = (union pthread_attr_t *)(void *)0;
    if(!(stacksize == 0u))
    {
      attr_ptr = &attr;
      signed int return_value_pthread_attr_init_1;
      return_value_pthread_attr_init_1=pthread_attr_init(&attr);
      if(!(return_value_pthread_attr_init_1 == 0))
        return (void *)0;

      /* assertion stacksize >= 16384 */
      assert(stacksize >= (unsigned int)16384);
      signed int return_value_pthread_attr_setstacksize_2;
      return_value_pthread_attr_setstacksize_2=pthread_attr_setstacksize(&attr, (unsigned long int)stacksize);
      /* assertion !(pthread_attr_setstacksize(&attr, stacksize)) */
      assert(!(return_value_pthread_attr_setstacksize_2 != 0));
    }

    self->status = (enum _io_thread_status)_io_thread_working;
    error=pthread_create(&self->thread, attr_ptr, start_routine, parent);
    /* assertion !error || error == 11 */
    assert(!(error != 0) || error == 11);
    if(!(error == 0))
      parent = (void *)0;

    if(!(attr_ptr == ((union pthread_attr_t *)NULL)))
    {
      return_value_pthread_attr_destroy_3=pthread_attr_destroy(attr_ptr);
      /* assertion !(pthread_attr_destroy(attr_ptr)) */
      assert(!(return_value_pthread_attr_destroy_3 != 0));
    }

    return parent;
  }

  return (void *)0;
}

// io_thread_finish
// file thread_util.h line 411
void io_thread_finish(struct io_thread *self)
{
  if(_has_pthread >= 0)
  {
    enum _io_thread_status status;
    signed int return_value___atomic_load_n_1;
    return_value___atomic_load_n_1=__atomic_load_n(&self->status, 5);
    status = (enum _io_thread_status)return_value___atomic_load_n_1;
    /* assertion status == _io_thread_working || status == _io_thread_done */
    assert((signed int)status == _io_thread_working || (signed int)status == _io_thread_done);
    signed int return_value_pthread_join_2;
    return_value_pthread_join_2=pthread_join(self->thread, (void **)(void *)0);
    /* assertion !(pthread_join(self->thread, ((void *)0))) */
    assert(!(return_value_pthread_join_2 != 0));
    signed int return_value___atomic_load_n_3;
    return_value___atomic_load_n_3=__atomic_load_n(&self->status, 5);
    /* assertion (__atomic_load_n((&self->status), 5)) == _io_thread_done */
    assert(return_value___atomic_load_n_3 == _io_thread_done);
  }

}

// io_thread_is_done
// file thread_util.h line 403
signed int io_thread_is_done(struct io_thread *self)
{
  if(_has_pthread >= 0)
  {
    signed int result;
    result=__atomic_load_n(&self->status, 5);
    /* assertion result != _io_thread_cancelled */
    assert(result != _io_thread_cancelled);
    return result;
  }

  return 1;
}

// io_thread_return
// file thread_util.h line 399
signed int io_thread_return(struct io_thread *self)
{
  if(_has_pthread >= 0)
  {
    enum _io_thread_status old_status;
    signed int return_value___atomic_exchange_n_1;
    return_value___atomic_exchange_n_1=__atomic_exchange_n(&self->status, _io_thread_done, 5);
    old_status = (enum _io_thread_status)return_value___atomic_exchange_n_1;
    /* assertion old_status == _io_thread_working || old_status == _io_thread_cancelled */
    assert((signed int)old_status == _io_thread_working || (signed int)old_status == _io_thread_cancelled);
    return (signed int)((signed int)old_status != _io_thread_working);
  }

  return 0;
}

// iterate_texture_string
// file texfont.c line 340
static void iterate_texture_string(struct texture_font_data *data, const char *s, signed int draw_x, signed int draw_y, struct _XftDraw *xftdraw, struct _XftColor *xftcolor, struct anonymous_11 *metrics_ret)
{
  signed int line_height = data->xftfont->ascent + data->xftfont->descent;
  signed int subscript_offset = (signed int)((double)line_height * 0.3);
  const char *os = s;
  signed int sub_p = 0;
  signed int osub_p = 0;
  signed int cw = 0;
  signed int tabs = 0;
  struct anonymous_11 overall = { .lbearing=(signed short int)0, .rbearing=0, .width=0,
    .ascent=0, .descent=0, .attributes=0 };
  signed int x = 0;
  signed int y = 0;
  signed int ox = x;
  signed int oy = y;
  _Bool tmp_if_expr_6;
  const unsigned short int **return_value___ctype_b_loc_5;
  const unsigned short int **return_value___ctype_b_loc_1;
  while((_Bool)1)
  {
    _Bool tmp_if_expr_3;
    if((signed int)*s == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)*s == 10 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_4;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)*s == 9 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_7;
    if(tmp_if_expr_4)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      if((signed int)*s == 91)
      {
        return_value___ctype_b_loc_5=__ctype_b_loc();
        tmp_if_expr_6 = ((signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)s[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_6 = (_Bool)0;
      tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_8;
    if(tmp_if_expr_7)
      tmp_if_expr_8 = (_Bool)1;

    else
      tmp_if_expr_8 = ((signed int)*s == 93 ? (sub_p != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_8)
    {
      if(!(s == os))
      {
        struct _XGlyphInfo iterate_texture_string__1__1__1__1__e;
        struct anonymous_11 c;
        signed int y2 = y;
        if(!(sub_p == 0))
          y2 = y2 + subscript_offset;

        XftTextExtentsUtf8(data->dpy, data->xftfont, (unsigned char *)os, (signed int)(s - os), &iterate_texture_string__1__1__1__1__e);
        c.lbearing = (signed short int)-((signed int)iterate_texture_string__1__1__1__1__e.x);
        c.rbearing = (signed short int)((signed int)iterate_texture_string__1__1__1__1__e.width - (signed int)iterate_texture_string__1__1__1__1__e.x);
        c.ascent = iterate_texture_string__1__1__1__1__e.y;
        c.descent = (signed short int)((signed int)iterate_texture_string__1__1__1__1__e.height - (signed int)iterate_texture_string__1__1__1__1__e.y);
        c.width = iterate_texture_string__1__1__1__1__e.xOff;
        overall.ascent = (signed short int)((signed int)overall.ascent > -y2 + (signed int)c.ascent ? (signed int)overall.ascent : -y2 + (signed int)c.ascent);
        overall.descent = (signed short int)((signed int)overall.descent > y2 + (signed int)c.descent ? (signed int)overall.descent : y2 + (signed int)c.descent);
        overall.lbearing = (signed short int)((signed int)overall.lbearing < x + (signed int)c.lbearing ? (signed int)overall.lbearing : x + (signed int)c.lbearing);
        overall.rbearing = (signed short int)((signed int)overall.rbearing > x + (signed int)c.rbearing ? (signed int)overall.rbearing : x + (signed int)c.rbearing);
        overall.width = (signed short int)((signed int)overall.width > x + (signed int)c.width ? (signed int)overall.width : x + (signed int)c.width);
        x = x + (signed int)c.width;
      }

      if((signed int)*s == 10)
      {
        x = 0;
        y = y + line_height;
        sub_p = 0;
      }

      else
        if((signed int)*s == 9)
        {
          if(cw == 0)
          {
            struct _XGlyphInfo e;
            XftTextExtentsUtf8(data->dpy, data->xftfont, (unsigned char *)"m", 1, &e);
            cw = (signed int)e.xOff;
            if(!(cw >= 1))
              cw = 1;

            tabs = cw * 7;
          }

          x = ((x + tabs) / tabs) * tabs;
        }

        else
        {
          _Bool tmp_if_expr_2;
          if((signed int)*s == 91)
          {
            return_value___ctype_b_loc_1=__ctype_b_loc();
            tmp_if_expr_2 = ((signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)s[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_2 = (_Bool)0;
          if(tmp_if_expr_2)
            sub_p = 1;

          else
            if((signed int)*s == 93)
            {
              if(!(sub_p == 0))
                sub_p = 0;

            }

        }
      if(!(s == os) && !(xftdraw == ((struct _XftDraw *)NULL)))
        XftDrawStringUtf8(xftdraw, xftcolor, data->xftfont, draw_x + ox, draw_y + oy + (osub_p != 0 ? subscript_offset : 0), (unsigned char *)os, (signed int)(s - os));

      if(*s == 0)
        break;

      os = s + (signed long int)1;
      ox = x;
      oy = y;
      osub_p = sub_p;
    }

    s = s + 1l;
  }
  if(!(metrics_ret == ((struct anonymous_11 *)NULL)))
    *metrics_ret = overall;

}

// load_texture_font
// file texfont.c line 257
extern struct texture_font_data * load_texture_font(struct _XDisplay *dpy, char *res)
{
  signed int screen = ((struct anonymous_0 *)dpy)->default_screen;
  char *font;
  font=get_string_resource(dpy, res, "Font");
  const char *def1 = "-*-helvetica-medium-r-normal-*-*-180-*-*-*-*-*-*";
  const char *def2 = "-*-helvetica-medium-r-normal-*-*-140-*-*-*-*-*-*";
  const char *def3 = "fixed";
  struct _XftFont *f = ((struct _XftFont *)NULL);
  struct texture_font_data *data;
  signed int cache_size;
  cache_size=get_integer_resource(dpy, "texFontCacheSize", "Integer");
  if(!(cache_size >= 1))
    cache_size = 30;

  _Bool tmp_if_expr_1;
  if(res == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*res != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    abort();

  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp(res, "fpsFont");
  if(return_value_strcmp_2 == 0)
  {
    def1 = "-*-courier-bold-r-normal-*-*-140-*-*-*-*-*-*";
    cache_size = 0;
  }

  if(font == ((char *)NULL))
    font=strdup(def1);

  f=XftFontOpenXlfd(dpy, screen, font);
  signed int return_value_strcmp_3;
  if(f == ((struct _XftFont *)NULL))
  {
    return_value_strcmp_3=strcmp(font, def1);
    if(!(return_value_strcmp_3 == 0))
    {
      fprintf(stderr, "%s: unable to load font \"%s\", using \"%s\"\n", progname, font, def1);
      free((void *)font);
      font=strdup(def1);
      f=XftFontOpenXlfd(dpy, screen, font);
    }

  }

  signed int return_value_strcmp_4;
  if(f == ((struct _XftFont *)NULL))
  {
    return_value_strcmp_4=strcmp(font, def2);
    if(!(return_value_strcmp_4 == 0))
    {
      fprintf(stderr, "%s: unable to load font \"%s\", using \"%s\"\n", progname, font, def2);
      free((void *)font);
      font=strdup(def2);
      f=XftFontOpenXlfd(dpy, screen, font);
    }

  }

  signed int return_value_strcmp_5;
  if(f == ((struct _XftFont *)NULL))
  {
    return_value_strcmp_5=strcmp(font, def3);
    if(!(return_value_strcmp_5 == 0))
    {
      fprintf(stderr, "%s: unable to load font \"%s\", using \"%s\"\n", progname, font, def3);
      free((void *)font);
      font=strdup(def3);
      f=XftFontOpenXlfd(dpy, screen, font);
    }

  }

  if(f == ((struct _XftFont *)NULL))
  {
    fprintf(stderr, "%s: unable to load fallback font \"%s\" either!\n", progname, font);
    abort();
  }

  free((void *)font);
  font = ((char *)NULL);
  void *return_value_calloc_6;
  return_value_calloc_6=calloc((unsigned long int)1, sizeof(struct texture_font_data) /*32ul*/ );
  data = (struct texture_font_data *)return_value_calloc_6;
  data->dpy = dpy;
  data->xftfont = f;
  data->cache_size = cache_size;
  return data;
}

// main
// file screenhack.c line 696
signed int main(signed int argc, char **argv)
{
  struct xscreensaver_function_table *ft = xscreensaver_function_table;
  struct anonymous_65 xgwa;
  struct _WidgetRec *toplevel;
  struct _XDisplay *dpy;
  unsigned long int window;
  unsigned long int window2 = (unsigned long int)0;
  struct _WidgetRec *toplevel2 = ((struct _WidgetRec *)NULL);
  struct _XtAppStruct *app;
  signed int root_p;
  unsigned long int on_window = (unsigned long int)0;
  union _XEvent event;
  char dont_clear;
  char version[255l];
  fix_fds();
  progname = argv[(signed long int)0];
  progclass = ft->progclass;
  if(!(ft->setup_cb == ((void (*)(struct xscreensaver_function_table *, void *))NULL)))
    ft->setup_cb(ft, ft->setup_arg);

  merge_options();
  toplevel=XtAppInitialize(&app, progclass, merged_options, (unsigned int)merged_options_size, &argc, argv, merged_defaults, ((struct anonymous_7 *)NULL), (unsigned int)0);
  dpy = toplevel->core.screen->display;
  XtGetApplicationNameAndClass(dpy, (char **)&progname, (char **)&progclass);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(progname);
  if(return_value_strlen_1 >= 100ul)
    ((char *)progname)[(signed long int)100] = (char)0;

  XSetErrorHandler(screenhack_ehandler);
  XA_WM_PROTOCOLS=XInternAtom(dpy, "WM_PROTOCOLS", 0);
  XA_WM_DELETE_WINDOW=XInternAtom(dpy, "WM_DELETE_WINDOW", 0);
  char *v;
  char *return_value_strchr_2;
  return_value_strchr_2=strchr(screensaver_id, 32);
  char *return_value_strdup_3;
  return_value_strdup_3=strdup(return_value_strchr_2);
  v = (char *)return_value_strdup_3;
  char *s1;
  char *s2;
  char *s3;
  char *s4;
  const char *ot;
  ot=get_string_resource(dpy, "title", "Title");
  char *return_value_strchr_4;
  return_value_strchr_4=strchr(v, 32);
  s1 = (char *)return_value_strchr_4;
  s1 = s1 + 1l;
  char *return_value_strchr_5;
  return_value_strchr_5=strchr(s1, 32);
  s2 = (char *)return_value_strchr_5;
  char *return_value_strchr_6;
  return_value_strchr_6=strchr(v, 40);
  s3 = (char *)return_value_strchr_6;
  s3 = s3 + 1l;
  char *return_value_strchr_7;
  return_value_strchr_7=strchr(s3, 41);
  s4 = (char *)return_value_strchr_7;
  *s2 = (char)0;
  *s4 = (char)0;
  if(!(ot == ((const char *)NULL)))
  {
    if(*ot == 0)
      ot = ((const char *)NULL);

  }

  sprintf(version, "%.50s%s%s: from the XScreenSaver %s distribution (%s)", ot != ((const char *)NULL) ? ot : "", ot != ((const char *)NULL) ? ": " : "", progclass, s1, s3);
  free((void *)v);
  signed int return_value_strcmp_9;
  if(argc >= 2)
  {
    const char *main__1__2__s;
    signed int i;
    signed int x = 18;
    signed int end = 78;
    signed int help_p;
    signed int return_value_strcmp_8;
    return_value_strcmp_8=strcmp(argv[(signed long int)1], "-help");
    _Bool tmp_if_expr_10;
    if(return_value_strcmp_8 == 0)
      tmp_if_expr_10 = (_Bool)1;

    else
    {
      return_value_strcmp_9=strcmp(argv[(signed long int)1], "--help");
      tmp_if_expr_10 = !(return_value_strcmp_9 != 0) ? (_Bool)1 : (_Bool)0;
    }
    help_p = (signed int)tmp_if_expr_10;
    fprintf(stderr, "%s\n", (const void *)version);
    main__1__2__s = progclass;
    for( ; !(*main__1__2__s == 0); main__1__2__s = main__1__2__s + 1l)
      fprintf(stderr, " ");
    fprintf(stderr, "  http://www.jwz.org/xscreensaver/\n\n");
    if(help_p == 0)
      fprintf(stderr, "Unrecognised option: %s\n", argv[(signed long int)1]);

    fprintf(stderr, "Options include: ");
    i = 0;
    for( ; !(i >= merged_options_size); i = i + 1)
    {
      char *sw = (merged_options + (signed long int)i)->option;
      signed int argp = (signed int)((signed int)(merged_options + (signed long int)i)->argKind == XrmoptionSepArg);
      signed int size;
      unsigned long int return_value_strlen_11;
      return_value_strlen_11=strlen(sw);
      size = (signed int)(return_value_strlen_11 + (unsigned long int)(argp != 0 ? 6 : 0) + (unsigned long int)2);
      if(size + x >= end)
      {
        fprintf(stderr, "\n\t\t ");
        x = 18;
      }

      x = x + size;
      fprintf(stderr, "%s", sw);
      if(!(argp == 0))
        fprintf(stderr, " <arg>");

      if(!(i == merged_options_size + -1))
        fprintf(stderr, ", ");

    }
    fprintf(stderr, ".\n");
    exit(help_p != 0 ? 0 : 1);
  }

  char **s = merged_defaults;
  for( ; !(*s == ((char *)NULL)); s = s + 1l)
    free((void *)*s);
  free((void *)merged_options);
  free((void *)merged_defaults);
  merged_options = ((struct anonymous_51 *)NULL);
  merged_defaults = ((char **)NULL);
  signed int return_value_get_boolean_resource_12;
  return_value_get_boolean_resource_12=get_boolean_resource(dpy, "dontClearRoot", "Boolean");
  dont_clear = (char)return_value_get_boolean_resource_12;
  mono_p=get_boolean_resource(dpy, "mono", "Boolean");
  if(!((((struct anonymous_0 *)dpy)->screens + (signed long int)((struct anonymous_0 *)dpy)->default_screen)->root_visual->map_entries >= 3))
    mono_p = 1;

  root_p=get_boolean_resource(dpy, "root", "Boolean");
  char *main__1__4__s;
  main__1__4__s=get_string_resource(dpy, "windowID", "WindowID");
  signed int return_value_get_integer_resource_13;
  if(!(main__1__4__s == ((char *)NULL)))
  {
    if(!(*main__1__4__s == 0))
    {
      return_value_get_integer_resource_13=get_integer_resource(dpy, "windowID", "WindowID");
      on_window = (unsigned long int)return_value_get_integer_resource_13;
    }

  }

  if(!(main__1__4__s == ((char *)NULL)))
    free((void *)main__1__4__s);

  if(!(on_window == 0ul))
  {
    window = (unsigned long int)on_window;
    XtDestroyWidget(toplevel);
    XGetWindowAttributes(dpy, window, &xgwa);
    visual_warning(xgwa.screen, window, xgwa.visual, xgwa.colormap, 1);
    xgwa.your_event_mask = xgwa.your_event_mask | 1L << 0 | 1L << 17;
    XSelectInput(dpy, window, xgwa.your_event_mask);
    if((12l & xgwa.all_event_masks) == 0l)
      XSelectInput(dpy, window, xgwa.your_event_mask | 1L << 2 | 1L << 3);

  }

  else
    if(!(root_p == 0))
    {
      window=VirtualRootWindowOfScreen(toplevel->core.screen);
      XtDestroyWidget(toplevel);
      XGetWindowAttributes(dpy, window, &xgwa);
      XSelectInput(dpy, window, xgwa.your_event_mask | 1L << 17);
      visual_warning(xgwa.screen, window, xgwa.visual, xgwa.colormap, 0);
    }

    else
    {
      struct _WidgetRec *new;
      new=make_shell(toplevel->core.screen, toplevel, (signed int)toplevel->core.width, (signed int)toplevel->core.height);
      if(!(new == toplevel))
      {
        XtDestroyWidget(toplevel);
        toplevel = new;
      }

      init_window(dpy, toplevel, version);
      window = toplevel->core.window;
      XGetWindowAttributes(dpy, window, &xgwa);
      signed int return_value_get_boolean_resource_14;
      return_value_get_boolean_resource_14=get_boolean_resource(dpy, "pair", "Boolean");
      if(!(return_value_get_boolean_resource_14 == 0))
      {
        toplevel2=make_shell(xgwa.screen, ((struct _WidgetRec *)NULL), (signed int)toplevel->core.width, (signed int)toplevel->core.height);
        init_window(dpy, toplevel2, version);
        window2 = toplevel2->core.window;
      }

    }
  if(dont_clear == 0)
  {
    unsigned int bg;
    bg=get_pixel_resource(dpy, xgwa.colormap, "background", "Background");
    XSetWindowBackground(dpy, window, (unsigned long int)bg);
    XClearWindow(dpy, window);
    if(!(window2 == 0ul))
    {
      XSetWindowBackground(dpy, window2, (unsigned long int)bg);
      XClearWindow(dpy, window2);
    }

  }

  if(root_p == 0 && on_window == 0ul)
    XIfEvent(dpy, &event, MapNotify_event_p, (char *)window);

  XSync(dpy, 0);
  ya_rand_init((unsigned int)0);
  run_screenhack_table(dpy, window, window2, ft);
  XtDestroyWidget(toplevel);
  XtDestroyApplicationContext(app);
  return 0;
}

// make_color_loop
// file colors.c line 451
extern void make_color_loop(struct anonymous_58 *screen, struct anonymous_59 *visual, unsigned long int cmap, signed int h0, double s0, double v0, signed int h1, double s1, double v1, signed int h2, double s2, double v2, struct anonymous_36 *colors, signed int *ncolorsP, signed int allocate_p, signed int *writable_pP)
{
  signed int wanted_writable;
  _Bool tmp_if_expr_1;
  if(!(writable_pP == ((signed int *)NULL)) && !(allocate_p == 0))
    tmp_if_expr_1 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  wanted_writable = (signed int)tmp_if_expr_1;
  signed int h[3l];
  double s[3l];
  double v[3l];
  h[(signed long int)0] = h0;
  h[(signed long int)1] = h1;
  h[(signed long int)2] = h2;
  s[(signed long int)0] = s0;
  s[(signed long int)1] = s1;
  s[(signed long int)2] = s2;
  v[(signed long int)0] = v0;
  v[(signed long int)1] = v1;
  v[(signed long int)2] = v2;
  signed int return_value_has_writable_cells_2;
  if(!(wanted_writable == 0))
  {
    return_value_has_writable_cells_2=has_writable_cells(screen, visual);
    if(return_value_has_writable_cells_2 == 0)
      *writable_pP = 0;

  }

  make_color_path(screen, visual, cmap, 3, h, s, v, colors, ncolorsP, allocate_p, writable_pP);
}

// make_color_path
// file colors.c line 224
static void make_color_path(struct anonymous_58 *screen, struct anonymous_59 *visual, unsigned long int cmap, signed int npoints, signed int *h, double *s, double *v, struct anonymous_36 *colors, signed int *ncolorsP, signed int allocate_p, signed int *writable_pP)
{
  struct _XDisplay *dpy;
  struct _XDisplay *tmp_if_expr_1;
  if(!(screen == ((struct anonymous_58 *)NULL)))
    tmp_if_expr_1 = screen->display;

  else
    tmp_if_expr_1 = ((struct _XDisplay *)NULL);
  dpy = tmp_if_expr_1;
  signed int i;
  signed int make_color_path__1__j;
  signed int k;
  signed int total_ncolors = *ncolorsP;
  signed int ncolors[50l];
  double dh[50l];
  double ds[50l];
  double dv[50l];
  if(npoints == 0)
  {
    *ncolorsP = 0;
    goto __CPROVER_DUMP_L40;
  }

  else
    if(npoints == 2)
    {
      make_color_ramp(screen, visual, cmap, h[(signed long int)0], s[(signed long int)0], v[(signed long int)0], h[(signed long int)1], s[(signed long int)1], v[(signed long int)1], colors, ncolorsP, 1, allocate_p, writable_pP);
      goto __CPROVER_DUMP_L40;
    }

    else
      if(npoints >= 50)
        npoints = 50 - 1;

  do
  {

  AGAIN:
    ;
    double DH[50l];
    double edge[50l];
    double ratio[50l];
    double circum = (double)0;
    double one_point_oh = (double)0;
    i = 0;
    for( ; !(i >= npoints); i = i + 1)
    {
      signed int make_color_path__1__4__1__j = (i + 1) % npoints;
      double d = (double)(h[(signed long int)i] - h[(signed long int)make_color_path__1__4__1__j]) / (double)360;
      if(d < 0.000000)
        d = -d;

      if(d > 0.5)
        d = 0.5 - (d - 0.5);

      DH[(signed long int)i] = d;
    }
    i = 0;
    for( ; !(i >= npoints); i = i + 1)
    {
      signed int j = (i + 1) % npoints;
      edge[(signed long int)i]=sqrt(DH[(signed long int)i] * DH[(signed long int)j] + (s[(signed long int)j] - s[(signed long int)i]) * (s[(signed long int)j] - s[(signed long int)i]) + (v[(signed long int)j] - v[(signed long int)i]) * (v[(signed long int)j] - v[(signed long int)i]));
      circum = circum + edge[(signed long int)i];
    }
    if(!(circum < 0.0001))
    {
      i = 0;
      for( ; !(i >= npoints); i = i + 1)
      {
        ratio[(signed long int)i] = edge[(signed long int)i] / circum;
        one_point_oh = one_point_oh + ratio[(signed long int)i];
      }
      if(one_point_oh < 0.99999 || one_point_oh > 1.00001)
        abort();

      i = 0;
      for( ; !(i >= npoints); i = i + 1)
        ncolors[(signed long int)i] = (signed int)((double)total_ncolors * ratio[(signed long int)i]);
      i = 0;
      for( ; !(i >= npoints); i = i + 1)
      {
        signed int make_color_path__1__4__4__j = (i + 1) % npoints;
        if(ncolors[(signed long int)i] >= 1)
        {
          dh[(signed long int)i] = (double)360 * (DH[(signed long int)i] / (double)ncolors[(signed long int)i]);
          ds[(signed long int)i] = (s[(signed long int)make_color_path__1__4__4__j] - s[(signed long int)i]) / (double)ncolors[(signed long int)i];
          dv[(signed long int)i] = (v[(signed long int)make_color_path__1__4__4__j] - v[(signed long int)i]) / (double)ncolors[(signed long int)i];
        }

      }
      memset((void *)colors, 0, (unsigned long int)*ncolorsP * sizeof(struct anonymous_36) /*16ul*/ );
      k = 0;
      i = 0;
      for( ; !(i >= npoints); i = i + 1)
      {
        signed int distance = h[(signed long int)((i + 1) % npoints)] - h[(signed long int)i];
        signed int direction = distance >= 0 ? -1 : 1;
        if(distance >= -180 && !(distance >= 181))
          direction = -direction;

        make_color_path__1__j = 0;
        for( ; !(make_color_path__1__j >= ncolors[(signed long int)i]); k = k + 1)
        {
          double hh = (double)h[(signed long int)i] + (double)make_color_path__1__j * dh[(signed long int)i] * (double)direction;
          if(hh < 0.000000)
            hh = hh + (double)360;

          else
            if(hh > 360.000000)
              hh = hh - (double)0;

          (colors + (signed long int)k)->flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
          hsv_to_rgb((signed int)hh, s[(signed long int)i] + (double)make_color_path__1__j * ds[(signed long int)i], v[(signed long int)i] + (double)make_color_path__1__j * dv[(signed long int)i], &(colors + (signed long int)k)->red, &(colors + (signed long int)k)->green, &(colors + (signed long int)k)->blue);
          make_color_path__1__j = make_color_path__1__j + 1;
        }
      }
      if(!(k >= *ncolorsP))
      {
        *ncolorsP = k;
        if(!(k >= 1))
          goto __CPROVER_DUMP_L40;

      }

      if(allocate_p == 0)
        goto __CPROVER_DUMP_L40;

      _Bool tmp_if_expr_5;
      if(!(writable_pP == ((signed int *)NULL)))
        tmp_if_expr_5 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
      {
        unsigned long int *pixels;
        void *return_value_malloc_2;
        return_value_malloc_2=malloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)(*ncolorsP + 1));
        pixels = (unsigned long int *)return_value_malloc_2;
        signed int return_value_XAllocColorCells_3;
        return_value_XAllocColorCells_3=XAllocColorCells(dpy, cmap, 0, ((unsigned long int *)NULL), (unsigned int)0, pixels, (unsigned int)*ncolorsP);
        if(return_value_XAllocColorCells_3 == 0)
        {
          free((void *)pixels);
          goto FAIL;
        }

        i = 0;
        for( ; !(i >= *ncolorsP); i = i + 1)
          (colors + (signed long int)i)->pixel = pixels[(signed long int)i];
        free((void *)pixels);
        XStoreColors(dpy, cmap, colors, *ncolorsP);
      }

      else
      {
        i = 0;
        for( ; !(i >= *ncolorsP); i = i + 1)
        {
          struct anonymous_36 color = colors[(signed long int)i];
          signed int return_value_XAllocColor_4;
          return_value_XAllocColor_4=XAllocColor(dpy, cmap, &color);
          if(!(return_value_XAllocColor_4 == 0))
            (colors + (signed long int)i)->pixel = color.pixel;

          else
          {
            free_colors(screen, cmap, colors, i);
            goto FAIL;
          }
        }
      }
      goto __CPROVER_DUMP_L40;
    }


  FAIL:
    ;
    total_ncolors = total_ncolors > 170 ? total_ncolors - 20 : (total_ncolors > 100 ? total_ncolors - 10 : (total_ncolors > 75 ? total_ncolors - 5 : (total_ncolors > 25 ? total_ncolors - 3 : (total_ncolors > 10 ? total_ncolors - 2 : (total_ncolors > 2 ? total_ncolors - 1 : 0)))));
    *ncolorsP = total_ncolors;
  }
  while(total_ncolors >= 1);

__CPROVER_DUMP_L40:
  ;
}

// make_color_ramp
// file colors.c line 99
extern void make_color_ramp(struct anonymous_58 *screen, struct anonymous_59 *visual, unsigned long int cmap, signed int h1, double s1, double v1, signed int h2, double s2, double v2, struct anonymous_36 *colors, signed int *ncolorsP, signed int closed_p, signed int allocate_p, signed int *writable_pP)
{
  struct _XDisplay *dpy;
  struct _XDisplay *tmp_if_expr_1;
  if(!(screen == ((struct anonymous_58 *)NULL)))
    tmp_if_expr_1 = screen->display;

  else
    tmp_if_expr_1 = ((struct _XDisplay *)NULL);
  dpy = tmp_if_expr_1;
  signed int verbose_p = 1;
  signed int i;
  signed int total_ncolors = *ncolorsP;
  signed int ncolors;
  signed int wanted;
  signed int wanted_writable;
  _Bool tmp_if_expr_2;
  if(!(writable_pP == ((signed int *)NULL)) && !(allocate_p == 0))
    tmp_if_expr_2 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  wanted_writable = (signed int)tmp_if_expr_2;
  double dh;
  double ds;
  double dv;
  wanted = total_ncolors;
  if(!(closed_p == 0))
    wanted = wanted / 2 + 1;

  signed int return_value_has_writable_cells_3;
  if(!(wanted_writable == 0))
  {
    return_value_has_writable_cells_3=has_writable_cells(screen, visual);
    if(return_value_has_writable_cells_3 == 0)
      *writable_pP = 0;

  }

  do
  {

  AGAIN:
    ;
    ncolors = total_ncolors;
    memset((void *)colors, 0, (unsigned long int)*ncolorsP * sizeof(struct anonymous_36) /*16ul*/ );
    if(!(closed_p == 0))
      ncolors = ncolors / 2 + 1;

    dh = ((double)h2 - (double)h1) / (double)ncolors;
    ds = (s2 - s1) / (double)ncolors;
    dv = (v2 - v1) / (double)ncolors;
    i = 0;
    for( ; !(i >= ncolors); i = i + 1)
    {
      (colors + (signed long int)i)->flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
      hsv_to_rgb((signed int)((double)h1 + (double)i * dh), s1 + (double)i * ds, v1 + (double)i * dv, &(colors + (signed long int)i)->red, &(colors + (signed long int)i)->green, &(colors + (signed long int)i)->blue);
    }
    if(!(closed_p == 0))
    {
      i = ncolors;
      for( ; !(i >= *ncolorsP); i = i + 1)
        colors[(signed long int)i] = colors[(signed long int)(*ncolorsP - i)];
    }

    if(allocate_p == 0)
      goto __CPROVER_DUMP_L29;

    _Bool tmp_if_expr_7;
    if(!(writable_pP == ((signed int *)NULL)))
      tmp_if_expr_7 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_7 = (_Bool)0;
    if(tmp_if_expr_7)
    {
      unsigned long int *pixels;
      void *return_value_malloc_4;
      return_value_malloc_4=malloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)(*ncolorsP + 1));
      pixels = (unsigned long int *)return_value_malloc_4;
      signed int return_value_XAllocColorCells_5;
      return_value_XAllocColorCells_5=XAllocColorCells(dpy, cmap, 0, ((unsigned long int *)NULL), (unsigned int)0, pixels, (unsigned int)*ncolorsP);
      if(return_value_XAllocColorCells_5 == 0)
      {
        free((void *)pixels);
        goto FAIL;
      }

      i = 0;
      for( ; !(i >= *ncolorsP); i = i + 1)
        (colors + (signed long int)i)->pixel = pixels[(signed long int)i];
      free((void *)pixels);
      XStoreColors(dpy, cmap, colors, *ncolorsP);
    }

    else
    {
      i = 0;
      for( ; !(i >= *ncolorsP); i = i + 1)
      {
        struct anonymous_36 color = colors[(signed long int)i];
        signed int return_value_XAllocColor_6;
        return_value_XAllocColor_6=XAllocColor(dpy, cmap, &color);
        if(!(return_value_XAllocColor_6 == 0))
          (colors + (signed long int)i)->pixel = color.pixel;

        else
        {
          free_colors(screen, cmap, colors, i);
          goto FAIL;
        }
      }
    }
    break;

  FAIL:
    ;
    total_ncolors = total_ncolors > 170 ? total_ncolors - 20 : (total_ncolors > 100 ? total_ncolors - 10 : (total_ncolors > 75 ? total_ncolors - 5 : (total_ncolors > 25 ? total_ncolors - 3 : (total_ncolors > 10 ? total_ncolors - 2 : (total_ncolors > 2 ? total_ncolors - 1 : 0)))));
    *ncolorsP = total_ncolors;
    ncolors = total_ncolors;
  }
  while(total_ncolors >= 1);

WARN:
  ;
  if(!(verbose_p == 0) && (wanted_writable == 0 || !(ncolors == 0)))
  {
    _Bool tmp_if_expr_8;
    if(!(writable_pP == ((signed int *)NULL)) && !(wanted_writable == 0))
      tmp_if_expr_8 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_8 = (_Bool)0;
    complain(wanted, ncolors, wanted_writable, (signed int)tmp_if_expr_8);
  }


__CPROVER_DUMP_L29:
  ;
}

// make_random_colormap
// file ./../../utils/colors.h line 132
extern void make_random_colormap(struct anonymous_58 *screen, struct anonymous_59 *visual, unsigned long int cmap, struct anonymous_36 *colors, signed int *ncolorsP, signed int bright_p, signed int allocate_p, signed int *writable_pP, signed int verbose_p)
{
  struct _XDisplay *dpy;
  struct _XDisplay *tmp_if_expr_1;
  if(!(screen == ((struct anonymous_58 *)NULL)))
    tmp_if_expr_1 = screen->display;

  else
    tmp_if_expr_1 = ((struct _XDisplay *)NULL);
  dpy = tmp_if_expr_1;
  signed int wanted_writable;
  _Bool tmp_if_expr_2;
  if(!(writable_pP == ((signed int *)NULL)) && !(allocate_p == 0))
    tmp_if_expr_2 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  wanted_writable = (signed int)tmp_if_expr_2;
  signed int ncolors = *ncolorsP;
  signed int i;
  signed int return_value_has_writable_cells_3;
  signed int h0;
  signed int h1;
  double s0;
  double s1;
  double v0;
  double v1;
  double return_value_fabs_10;
  if(*ncolorsP >= 1)
  {
    if(!(wanted_writable == 0))
    {
      return_value_has_writable_cells_3=has_writable_cells(screen, visual);
      if(return_value_has_writable_cells_3 == 0)
        *writable_pP = 0;

    }

    do
    {

    RETRY_ALL:
      ;
      i = 0;
      for( ; !(i >= ncolors); i = i + 1)
      {
        (colors + (signed long int)i)->flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
        if(!(bright_p == 0))
        {
          signed int H;
          unsigned int return_value_ya_random_4;
          return_value_ya_random_4=ya_random();
          H = (signed int)(return_value_ya_random_4 % (unsigned int)360);
          double S;
          unsigned int return_value_ya_random_5;
          return_value_ya_random_5=ya_random();
          S = ((double)(return_value_ya_random_5 % (unsigned int)70) + (double)30) / 100.0;
          double V;
          unsigned int return_value_ya_random_6;
          return_value_ya_random_6=ya_random();
          V = ((double)(return_value_ya_random_6 % (unsigned int)34) + (double)66) / 100.0;
          hsv_to_rgb(H, S, V, &(colors + (signed long int)i)->red, &(colors + (signed long int)i)->green, &(colors + (signed long int)i)->blue);
        }

        else
        {
          unsigned int return_value_ya_random_7;
          return_value_ya_random_7=ya_random();
          (colors + (signed long int)i)->red = (unsigned short int)(return_value_ya_random_7 % (unsigned int)0xFFFF);
          unsigned int return_value_ya_random_8;
          return_value_ya_random_8=ya_random();
          (colors + (signed long int)i)->green = (unsigned short int)(return_value_ya_random_8 % (unsigned int)0xFFFF);
          unsigned int return_value_ya_random_9;
          return_value_ya_random_9=ya_random();
          (colors + (signed long int)i)->blue = (unsigned short int)(return_value_ya_random_9 % (unsigned int)0xFFFF);
        }
      }
      if(!(bright_p == 0) || ncolors >= 5)
        goto __CPROVER_DUMP_L12;

      rgb_to_hsv((colors + (signed long int)0)->red, (colors + (signed long int)0)->green, (colors + (signed long int)0)->blue, &h0, &s0, &v0);
      rgb_to_hsv((colors + (signed long int)1)->red, (colors + (signed long int)1)->green, (colors + (signed long int)1)->blue, &h1, &s1, &v1);
      return_value_fabs_10=fabs(v1 - v0);
    }
    while(return_value_fabs_10 < 0.5);

  __CPROVER_DUMP_L12:
    ;
    if(!(allocate_p == 0))
    {
      do
      {

      RETRY_NON_WRITABLE:
        ;
        _Bool tmp_if_expr_13;
        if(!(writable_pP == ((signed int *)NULL)))
          tmp_if_expr_13 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_13 = (_Bool)0;
        if(tmp_if_expr_13)
        {
          unsigned long int *pixels;
          void *return_value_malloc_11;
          return_value_malloc_11=malloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)(ncolors + 1));
          pixels = (unsigned long int *)return_value_malloc_11;
          allocate_writable_colors(screen, cmap, pixels, &ncolors);
          if(ncolors >= 1)
          {
            i = 0;
            for( ; !(i >= ncolors); i = i + 1)
              (colors + (signed long int)i)->pixel = pixels[(signed long int)i];
          }

          free((void *)pixels);
          if(ncolors >= 1)
            XStoreColors(dpy, cmap, colors, ncolors);

        }

        else
        {
          i = 0;
          for( ; !(i >= ncolors); i = i + 1)
          {
            struct anonymous_36 color = colors[(signed long int)i];
            signed int return_value_XAllocColor_12;
            return_value_XAllocColor_12=XAllocColor(dpy, cmap, &color);
            if(return_value_XAllocColor_12 == 0)
              break;

            (colors + (signed long int)i)->pixel = color.pixel;
          }
          ncolors = i;
        }
        if(!(ncolors == 0) || writable_pP == ((signed int *)NULL) || allocate_p == 0)
          break;

        if(*writable_pP == 0)
          break;

        ncolors = *ncolorsP;
        *writable_pP = 0;
      }
      while((_Bool)1);
      if(!(verbose_p == 0))
      {
        _Bool tmp_if_expr_14;
        if(!(wanted_writable == 0))
          tmp_if_expr_14 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_14 = (_Bool)0;
        complain(*ncolorsP, ncolors, wanted_writable, (signed int)tmp_if_expr_14);
      }

      *ncolorsP = ncolors;
    }

  }

}

// make_shell
// file screenhack.c line 612
static struct _WidgetRec * make_shell(struct anonymous_58 *screen, struct _WidgetRec *toplevel, signed int width, signed int height)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_59 *visual;
  visual=pick_visual(screen);
  char def_visual_p;
  _Bool tmp_if_expr_1;
  if(!(toplevel == ((struct _WidgetRec *)NULL)))
    tmp_if_expr_1 = visual == screen->root_visual ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  def_visual_p = (char)tmp_if_expr_1;
  if(!(width >= 1))
    width = 600;

  if(!(height >= 1))
    height = 480;

  if(!(def_visual_p == 0))
  {
    unsigned long int window;
    XtVaSetValues(toplevel, (char *)&XtStrings[(signed long int)453], 0, (char *)&XtStrings[(signed long int)872], width, (char *)&XtStrings[(signed long int)234], height, (char *)&XtShellStrings[(signed long int)417], 1, (void *)0);
    XtRealizeWidget(toplevel);
    window = toplevel->core.window;
    signed int return_value_get_boolean_resource_2;
    return_value_get_boolean_resource_2=get_boolean_resource(dpy, "installColormap", "InstallColormap");
    if(!(return_value_get_boolean_resource_2 == 0))
    {
      unsigned long int make_shell__1__1__1__cmap;
      make_shell__1__1__1__cmap=XCreateColormap(dpy, window, screen->root_visual, 0);
      XSetWindowColormap(dpy, window, make_shell__1__1__1__cmap);
    }

  }

  else
  {
    unsigned int bg;
    unsigned int bd;
    struct _WidgetRec *new;
    unsigned long int cmap;
    unsigned long int return_value_VirtualRootWindowOfScreen_3;
    return_value_VirtualRootWindowOfScreen_3=VirtualRootWindowOfScreen(screen);
    cmap=XCreateColormap(dpy, return_value_VirtualRootWindowOfScreen_3, visual, 0);
    bg=get_pixel_resource(dpy, cmap, "background", "Background");
    bd=get_pixel_resource(dpy, cmap, "borderColor", "Foreground");
    signed int return_value_visual_depth_4;
    return_value_visual_depth_4=visual_depth(screen, visual);
    new=XtVaAppCreateShell(progname, progclass, topLevelShellWidgetClass, dpy, (char *)&XtStrings[(signed long int)453], 0, (char *)&XtShellStrings[(signed long int)104], visual, (char *)&XtStrings[(signed long int)163], return_value_visual_depth_4, (char *)&XtStrings[(signed long int)872], width, (char *)&XtStrings[(signed long int)234], height, (char *)&XtStrings[(signed long int)154], cmap, (char *)&XtStrings[(signed long int)52], (unsigned long int)bg, (char *)&XtStrings[(signed long int)87], (unsigned long int)bd, (char *)&XtShellStrings[(signed long int)417], 1, (void *)0);
    if(toplevel == ((struct _WidgetRec *)NULL))
      XtVaSetValues(new, (char *)&XtStrings[(signed long int)885], 0, (char *)&XtStrings[(signed long int)887], 550, (void *)0);

    XtRealizeWidget(new);
    toplevel = new;
  }
  return toplevel;
}

// make_smooth_colormap
// file ./../../utils/colors.h line 88
extern void make_smooth_colormap(struct anonymous_58 *screen, struct anonymous_59 *visual, unsigned long int cmap, struct anonymous_36 *colors, signed int *ncolorsP, signed int allocate_p, signed int *writable_pP, signed int verbose_p)
{
  signed int npoints;
  signed int ncolors = *ncolorsP;
  signed int wanted_writable;
  _Bool tmp_if_expr_1;
  if(!(writable_pP == ((signed int *)NULL)) && !(allocate_p == 0))
    tmp_if_expr_1 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  wanted_writable = (signed int)tmp_if_expr_1;
  signed int i;
  signed int h[50l];
  double s[50l];
  double v[50l];
  double total_s = (double)0;
  double total_v = (double)0;
  signed int loop = 0;
  unsigned int return_value_ya_random_3;
  signed int j;
  double hi;
  double hj;
  double dh;
  double distance;
  signed int return_value_has_writable_cells_8;
  if(*ncolorsP >= 1)
  {
    signed int n;
    unsigned int return_value_ya_random_2;
    return_value_ya_random_2=ya_random();
    n = (signed int)(return_value_ya_random_2 % (unsigned int)20);
    if(!(n >= 6))
      npoints = 2;

    else
      if(!(n >= 16))
        npoints = 3;

      else
        if(!(n >= 19))
          npoints = 4;

        else
          npoints = 5;
    do
    {

    REPICK_ALL_COLORS:
      ;
      i = 0;
      for( ; !(i >= npoints); i = i + 1)
      {
        do
        {

        REPICK_THIS_COLOR:
          ;
          loop = loop + 1;
          if(loop >= 10001)
            abort();

          return_value_ya_random_3=ya_random();
          h[(signed long int)i] = (signed int)(return_value_ya_random_3 % (unsigned int)360);
          double tmp_statement_expression_4;
          double tmp;
          unsigned int return_value_ya_random_5;
          return_value_ya_random_5=ya_random();
          tmp = ((double)return_value_ya_random_5 * (double)1.0) / (double)(unsigned int)~0;
          tmp_statement_expression_4 = tmp < (double)0 ? -tmp : tmp;
          s[(signed long int)i] = tmp_statement_expression_4;
          double tmp_statement_expression_6;
          double make_smooth_colormap__1__2__2__tmp;
          unsigned int return_value_ya_random_7;
          return_value_ya_random_7=ya_random();
          make_smooth_colormap__1__2__2__tmp = ((double)return_value_ya_random_7 * (double)0.8) / (double)(unsigned int)~0;
          tmp_statement_expression_6 = make_smooth_colormap__1__2__2__tmp < (double)0 ? -make_smooth_colormap__1__2__2__tmp : make_smooth_colormap__1__2__2__tmp;
          v[(signed long int)i] = tmp_statement_expression_6 + 0.2;
          if(!(i >= 1))
            goto __CPROVER_DUMP_L14;

          j = i + 1 == npoints ? 0 : i - 1;
          hi = (double)h[(signed long int)i] / (double)360;
          hj = (double)h[(signed long int)j] / (double)360;
          dh = hj - hi;
          if(dh < 0.000000)
            dh = -dh;

          if(dh > 0.5)
            dh = 0.5 - (dh - 0.5);

          distance=sqrt(dh * dh + (s[(signed long int)j] - s[(signed long int)i]) * (s[(signed long int)j] - s[(signed long int)i]) + (v[(signed long int)j] - v[(signed long int)i]) * (v[(signed long int)j] - v[(signed long int)i]));
        }
        while(distance < 0.2);

      __CPROVER_DUMP_L14:
        ;
        total_s = total_s + s[(signed long int)i];
        total_v = total_v + v[(signed long int)i];
      }
      if(total_s / (double)npoints < 0.2)
        goto REPICK_ALL_COLORS;

    }
    while(total_v / (double)npoints < 0.3);
    if(!(wanted_writable == 0))
    {
      return_value_has_writable_cells_8=has_writable_cells(screen, visual);
      if(return_value_has_writable_cells_8 == 0)
        *writable_pP = 0;

    }

    do
    {

    RETRY_NON_WRITABLE:
      ;
      make_color_path(screen, visual, cmap, npoints, h, s, v, colors, &ncolors, allocate_p, writable_pP);
      if(allocate_p == 0)
        break;

      if(!(*ncolorsP == 0))
        break;

      if(writable_pP == ((signed int *)NULL))
        break;

      if(*writable_pP == 0)
        break;

      *writable_pP = 0;
    }
    while((_Bool)1);
    if(!(verbose_p == 0))
    {
      _Bool tmp_if_expr_9;
      if(!(wanted_writable == 0))
        tmp_if_expr_9 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_9 = (_Bool)0;
      complain(*ncolorsP, ncolors, wanted_writable, (signed int)tmp_if_expr_9);
    }

    *ncolorsP = ncolors;
  }

}

// make_uniform_colormap
// file ./../../utils/colors.h line 110
extern void make_uniform_colormap(struct anonymous_58 *screen, struct anonymous_59 *visual, unsigned long int cmap, struct anonymous_36 *colors, signed int *ncolorsP, signed int allocate_p, signed int *writable_pP, signed int verbose_p)
{
  signed int ncolors = *ncolorsP;
  signed int wanted_writable;
  _Bool tmp_if_expr_1;
  if(!(writable_pP == ((signed int *)NULL)) && !(allocate_p == 0))
    tmp_if_expr_1 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  wanted_writable = (signed int)tmp_if_expr_1;
  double S;
  unsigned int return_value_ya_random_2;
  return_value_ya_random_2=ya_random();
  S = ((double)(return_value_ya_random_2 % (unsigned int)34) + (double)66) / 100.0;
  double V;
  unsigned int return_value_ya_random_3;
  return_value_ya_random_3=ya_random();
  V = ((double)(return_value_ya_random_3 % (unsigned int)34) + (double)66) / 100.0;
  signed int return_value_has_writable_cells_4;
  if(*ncolorsP >= 1)
  {
    if(!(wanted_writable == 0))
    {
      return_value_has_writable_cells_4=has_writable_cells(screen, visual);
      if(return_value_has_writable_cells_4 == 0)
        *writable_pP = 0;

    }

    do
    {

    RETRY_NON_WRITABLE:
      ;
      make_color_ramp(screen, visual, cmap, 0, S, V, 359, S, V, colors, &ncolors, 0, allocate_p, writable_pP);
      if(allocate_p == 0)
        break;

      if(!(*ncolorsP == 0))
        break;

      if(writable_pP == ((signed int *)NULL))
        break;

      if(*writable_pP == 0)
        break;

      ncolors = *ncolorsP;
      *writable_pP = 0;
    }
    while((_Bool)1);
    if(!(verbose_p == 0))
    {
      _Bool tmp_if_expr_5;
      if(!(wanted_writable == 0))
        tmp_if_expr_5 = *writable_pP != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      complain(*ncolorsP, ncolors, wanted_writable, (signed int)tmp_if_expr_5);
    }

    *ncolorsP = ncolors;
  }

}

// merge_options
// file screenhack.c line 182
static void merge_options(void)
{
  struct xscreensaver_function_table *ft = xscreensaver_function_table;
  const struct anonymous_51 *options = ft->options;
  const char * const *defaults = ft->defaults;
  const char *merge_options__1__progclass = ft->progclass;
  signed int def_opts_size;
  signed int opts_size;
  signed int def_defaults_size;
  signed int defaults_size;
  def_opts_size = 0;
  for( ; !(default_options[(signed long int)def_opts_size].option == ((char *)NULL)); def_opts_size = def_opts_size + 1)
    ;
  opts_size = 0;
  for( ; !((options + (signed long int)opts_size)->option == ((char *)NULL)); opts_size = opts_size + 1)
    ;
  merged_options_size = def_opts_size + opts_size;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(merged_options_size + 1) * sizeof(struct anonymous_51) /*32ul*/ );
  merged_options = (struct anonymous_51 *)return_value_malloc_1;
  memcpy((void *)merged_options, (const void *)default_options, (unsigned long int)def_opts_size * sizeof(struct anonymous_51) /*32ul*/ );
  memcpy((void *)(merged_options + (signed long int)def_opts_size), (const void *)options, (unsigned long int)(opts_size + 1) * sizeof(struct anonymous_51) /*32ul*/ );
  def_defaults_size = 0;
  for( ; !(default_defaults[(signed long int)def_defaults_size] == ((char *)NULL)); def_defaults_size = def_defaults_size + 1)
    ;
  defaults_size = 0;
  for( ; !(defaults[(signed long int)defaults_size] == ((const char *)NULL)); defaults_size = defaults_size + 1)
    ;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(def_defaults_size + defaults_size + 1) * sizeof(const char *) /*8ul*/ );
  merged_defaults = (char **)return_value_malloc_2;
  memcpy((void *)merged_defaults, (const void *)default_defaults, (unsigned long int)def_defaults_size * sizeof(const char *) /*8ul*/ );
  memcpy((void *)(merged_defaults + (signed long int)def_defaults_size), (const void *)defaults, (unsigned long int)(defaults_size + 1) * sizeof(const char *) /*8ul*/ );
  char **s = merged_defaults;
  for( ; !(*s == ((char *)NULL)); s = s + 1l)
    if((signed int)*(*s) == 46)
    {
      const char *oldr = *s;
      char *newr;
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(oldr);
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(merge_options__1__progclass);
      void *return_value_malloc_5;
      return_value_malloc_5=malloc(return_value_strlen_3 + return_value_strlen_4 + (unsigned long int)3);
      newr = (char *)return_value_malloc_5;
      strcpy(newr, merge_options__1__progclass);
      strcat(newr, oldr);
      *s = newr;
    }

    else
      *s=strdup(*s);
}

// parse_image_data
// file atlantis.c line 173
static void parse_image_data(struct ModeInfo *mi)
{
  struct anonymous *ap = &atlantis[(signed long int)mi->screen_number];
  ap->texture=xpm_to_ximage(mi->dpy, mi->xgwa.visual, mi->xgwa.colormap, sea_texture);
}

// parse_time
// file resources.c line 203
extern signed int parse_time(const char *string, signed int seconds_default_p, signed int silent_p)
{
  unsigned int h;
  unsigned int m;
  unsigned int s;
  char c;
  signed int return_value___isoc99_sscanf_6;
  return_value___isoc99_sscanf_6=__isoc99_sscanf(string, " %u : %2u : %2u %c", &h, &m, &s, &c);
  signed int return_value___isoc99_sscanf_3;
  signed int return_value___isoc99_sscanf_4;
  signed int return_value___isoc99_sscanf_2;
  signed int return_value___isoc99_sscanf_1;
  if(!(return_value___isoc99_sscanf_6 == 3))
  {
    return_value___isoc99_sscanf_3=__isoc99_sscanf(string, " : %2u : %2u %c", &m, &s, &c);
    _Bool tmp_if_expr_5;
    if(return_value___isoc99_sscanf_3 == 2)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value___isoc99_sscanf_4=__isoc99_sscanf(string, " %u : %2u %c", &m, &s, &c);
      tmp_if_expr_5 = 2 == return_value___isoc99_sscanf_4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      h = (unsigned int)0;

    else
    {
      return_value___isoc99_sscanf_2=__isoc99_sscanf(string, " : %2u %c", &s, &c);
      if(return_value___isoc99_sscanf_2 == 1)
      {
        m = (unsigned int)0;
        h = m;
      }

      else
      {
        return_value___isoc99_sscanf_1=__isoc99_sscanf(string, " %u %c", seconds_default_p != 0 ? &s : &m, &c);
        if(return_value___isoc99_sscanf_1 == 1)
        {
          h = (unsigned int)0;
          if(!(seconds_default_p == 0))
            m = (unsigned int)0;

          else
            s = (unsigned int)0;
        }

        else
        {
          if(silent_p == 0)
            fprintf(stderr, "%s: invalid time interval specification \"%s\".\n", progname, string);

          return -1;
        }
      }
    }
  }

  if(s >= 60u && (!(h == 0u) || !(m == 0u)))
  {
    if(silent_p == 0)
      fprintf(stderr, "%s: seconds > 59 in \"%s\".\n", progname, string);

    return -1;
  }

  else
    if(h >= 1u && m >= 60u)
    {
      if(silent_p == 0)
        fprintf(stderr, "%s: minutes > 59 in \"%s\".\n", progname, string);

      return -1;
    }

    else
      return (signed int)(h * (unsigned int)60 * (unsigned int)60 + m * (unsigned int)60 + s);
}

// pick_best_gl_visual
// file visual.c line 281
static struct anonymous_59 * pick_best_gl_visual(struct anonymous_58 *screen)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_62 vi_in;
  struct anonymous_62 *vi_out;
  signed int out_count;
  struct anonymous_59 *result = ((struct anonymous_59 *)NULL);
  signed int ndepths = 0;
  signed int *depths;
  signed int return_value_screen_number_1;
  return_value_screen_number_1=screen_number(screen);
  depths=XListDepths(dpy, return_value_screen_number_1, &ndepths);
  signed int screen_depth;
  signed int tmp_if_expr_2;
  if(!(depths == ((signed int *)NULL)) && !(ndepths == 0))
    tmp_if_expr_2 = depths[(signed long int)(ndepths - 1)];

  else
    tmp_if_expr_2 = 0;
  screen_depth = tmp_if_expr_2;
  XFree((void *)depths);
  vi_in.class = 4;
  vi_in.screen=screen_number(screen);
  vi_in.depth = screen_depth / 2;
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x8 | 0x2 | 0x4), &vi_in, &out_count);
  if(out_count >= 1)
    result = (vi_out + (signed long int)0)->visual;

  if(!(vi_out == ((struct anonymous_62 *)NULL)))
    XFree((void *)(char *)vi_out);

  if(result == ((struct anonymous_59 *)NULL) && screen_depth >= 25)
  {
    vi_in.class = 4;
    vi_in.screen=screen_number(screen);
    vi_in.depth = 12;
    vi_out=XGetVisualInfo(dpy, (signed long int)(0x8 | 0x2 | 0x4), &vi_in, &out_count);
    if(out_count >= 1)
      result = (vi_out + (signed long int)0)->visual;

  }

  if(result == ((struct anonymous_59 *)NULL))
    result=pick_best_visual_of_class(screen, 4);

  if(result == ((struct anonymous_59 *)NULL))
    result=pick_best_visual(screen, 0, 0);

  return result;
}

// pick_best_visual
// file visual.c line 174
static struct anonymous_59 * pick_best_visual(struct anonymous_58 *screen, signed int prefer_writable_cells, signed int color_only)
{
  struct anonymous_59 *visual;
  signed int return_value_visual_depth_1;
  if(prefer_writable_cells == 0)
  {
    visual=pick_best_visual_of_class(screen, 4);
    if(!(visual == ((struct anonymous_59 *)NULL)))
    {
      return_value_visual_depth_1=visual_depth(screen, visual);
      if(return_value_visual_depth_1 >= 16)
        return visual;

    }

  }

  visual=pick_best_visual_of_class(screen, 3);
  signed int return_value_visual_depth_2;
  if(!(visual == ((struct anonymous_59 *)NULL)))
  {
    _Bool tmp_if_expr_3;
    if(color_only == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_visual_depth_2=visual_depth(screen, visual);
      tmp_if_expr_3 = return_value_visual_depth_2 > 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      return visual;

  }

  visual=pick_best_visual_of_class(screen, 4);
  signed int return_value_visual_depth_4;
  if(!(visual == ((struct anonymous_59 *)NULL)))
  {
    _Bool tmp_if_expr_5;
    if(color_only == 0)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_visual_depth_4=visual_depth(screen, visual);
      tmp_if_expr_5 = return_value_visual_depth_4 > 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      return visual;

  }

  visual=pick_best_visual_of_class(screen, 5);
  signed int return_value_visual_depth_6;
  if(!(visual == ((struct anonymous_59 *)NULL)))
  {
    _Bool tmp_if_expr_7;
    if(color_only == 0)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_visual_depth_6=visual_depth(screen, visual);
      tmp_if_expr_7 = return_value_visual_depth_6 > 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      return visual;

  }

  visual=pick_best_visual_of_class(screen, 2);
  signed int return_value_visual_depth_8;
  if(!(visual == ((struct anonymous_59 *)NULL)))
  {
    _Bool tmp_if_expr_9;
    if(color_only == 0)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_visual_depth_8=visual_depth(screen, visual);
      tmp_if_expr_9 = return_value_visual_depth_8 > 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_9)
      return visual;

  }

  signed int return_value_visual_depth_10;
  signed int return_value_visual_depth_12;
  if(color_only == 0)
  {
    visual=pick_best_visual_of_class(screen, 1);
    if(!(visual == ((struct anonymous_59 *)NULL)))
    {
      _Bool tmp_if_expr_11;
      if(color_only == 0)
        tmp_if_expr_11 = (_Bool)1;

      else
      {
        return_value_visual_depth_10=visual_depth(screen, visual);
        tmp_if_expr_11 = return_value_visual_depth_10 > 1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_11)
        return visual;

    }

    visual=pick_best_visual_of_class(screen, 0);
    if(!(visual == ((struct anonymous_59 *)NULL)))
    {
      _Bool tmp_if_expr_13;
      if(color_only == 0)
        tmp_if_expr_13 = (_Bool)1;

      else
      {
        return_value_visual_depth_12=visual_depth(screen, visual);
        tmp_if_expr_13 = return_value_visual_depth_12 > 1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_13)
        return visual;

    }

  }

  visual = screen->root_visual;
  _Bool tmp_if_expr_15;
  signed int return_value_visual_depth_14;
  if(color_only == 0)
    tmp_if_expr_15 = (_Bool)1;

  else
  {
    return_value_visual_depth_14=visual_depth(screen, visual);
    tmp_if_expr_15 = return_value_visual_depth_14 > 1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_15)
    return visual;

  else
    return ((struct anonymous_59 *)NULL);
}

// pick_best_visual_of_class
// file visual.c line 242
static struct anonymous_59 * pick_best_visual_of_class(struct anonymous_58 *screen, signed int visual_class)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_62 vi_in;
  struct anonymous_62 *vi_out;
  signed int out_count;
  vi_in.class = visual_class;
  vi_in.screen=screen_number(screen);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x8 | 0x2), &vi_in, &out_count);
  _Bool tmp_if_expr_1;
  if(!(vi_out == ((struct anonymous_62 *)NULL)))
  {
    signed int i;
    signed int best;
    struct anonymous_59 *visual;
    i = out_count - 1;
    best = i;
    for( ; i >= 0; i = i - 1)
    {
      _Bool tmp_if_expr_2;
      if(!((vi_out + (signed long int)best)->depth >= (vi_out + (signed long int)i)->depth))
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        if((vi_out + (signed long int)i)->depth == (vi_out + (signed long int)best)->depth)
          tmp_if_expr_1 = (vi_out + (signed long int)i)->colormap_size > (vi_out + (signed long int)best)->colormap_size ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
        best = i;

    }
    struct anonymous_59 *tmp_if_expr_3;
    if(!(best >= out_count))
      tmp_if_expr_3 = (vi_out + (signed long int)best)->visual;

    else
      tmp_if_expr_3 = ((struct anonymous_59 *)NULL);
    visual = tmp_if_expr_3;
    XFree((void *)(char *)vi_out);
    return visual;
  }

  else
    return ((struct anonymous_59 *)NULL);
}

// pick_mono_visual
// file visual.c line 218
static struct anonymous_59 * pick_mono_visual(struct anonymous_58 *screen)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_62 vi_in;
  struct anonymous_62 *vi_out;
  signed int out_count;
  vi_in.depth = 1;
  vi_in.screen=screen_number(screen);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x4 | 0x2), &vi_in, &out_count);
  if(!(vi_out == ((struct anonymous_62 *)NULL)))
  {
    struct anonymous_59 *v;
    struct anonymous_59 *tmp_if_expr_1;
    if(out_count >= 1)
      tmp_if_expr_1 = (vi_out + (signed long int)0)->visual;

    else
      tmp_if_expr_1 = ((struct anonymous_59 *)NULL);
    v = tmp_if_expr_1;
    if(!(v == ((struct anonymous_59 *)NULL)))
    {
      if(!(vi_out->depth == 1))
        v = ((struct anonymous_59 *)NULL);

    }

    XFree((void *)(char *)vi_out);
    return v;
  }

  else
    return ((struct anonymous_59 *)NULL);
}

// pick_visual
// file screenhack.c line 321
static struct anonymous_59 * pick_visual(struct anonymous_58 *screen)
{
  struct xscreensaver_function_table *ft = xscreensaver_function_table;
  if(!(ft->pick_visual_hook == ((struct anonymous_59 * (*)(struct anonymous_58 *))NULL)))
  {
    struct anonymous_59 *v;
    v=ft->pick_visual_hook(screen);
    if(!(v == ((struct anonymous_59 *)NULL)))
      return v;

  }

  struct anonymous_59 *return_value_get_visual_resource_1;
  return_value_get_visual_resource_1=get_visual_resource(screen, "visualID", "VisualID", 0);
  return return_value_get_visual_resource_1;
}

// print_texture_label
// file texfont.c line 758
void print_texture_label(struct _XDisplay *dpy, struct texture_font_data *data, signed int window_width, signed int window_height, signed int position, const char *string)
{
  float color[4l];
  signed int tex_p;
  unsigned char return_value_glIsEnabled_1;
  return_value_glIsEnabled_1=glIsEnabled((unsigned int)0x0DE1);
  tex_p = (signed int)return_value_glIsEnabled_1;
  signed int texs_p;
  unsigned char return_value_glIsEnabled_2;
  return_value_glIsEnabled_2=glIsEnabled((unsigned int)0x0C60);
  texs_p = (signed int)return_value_glIsEnabled_2;
  signed int text_p;
  unsigned char return_value_glIsEnabled_3;
  return_value_glIsEnabled_3=glIsEnabled((unsigned int)0x0C61);
  text_p = (signed int)return_value_glIsEnabled_3;
  signed int depth_p;
  unsigned char return_value_glIsEnabled_4;
  return_value_glIsEnabled_4=glIsEnabled((unsigned int)0x0B71);
  depth_p = (signed int)return_value_glIsEnabled_4;
  signed int cull_p;
  unsigned char return_value_glIsEnabled_5;
  return_value_glIsEnabled_5=glIsEnabled((unsigned int)0x0B44);
  cull_p = (signed int)return_value_glIsEnabled_5;
  signed int fog_p;
  unsigned char return_value_glIsEnabled_6;
  return_value_glIsEnabled_6=glIsEnabled((unsigned int)0x0B60);
  fog_p = (signed int)return_value_glIsEnabled_6;
  signed int ovp[4l];
  signed int opoly[2l];
  glGetIntegerv((unsigned int)0x0B40, opoly);
  glGetIntegerv((unsigned int)0x0BA2, ovp);
  glGetFloatv((unsigned int)0x0B00, color);
  glEnable((unsigned int)0x0DE1);
  glBlendFunc((unsigned int)0x0302, (unsigned int)0x0303);
  glPolygonMode((unsigned int)0x0404, (unsigned int)0x1B02);
  glDisable((unsigned int)0x0C60);
  glDisable((unsigned int)0x0C61);
  glDisable((unsigned int)0x0B44);
  glDisable((unsigned int)0x0B60);
  glDisable((unsigned int)0x0B71);
  glMatrixMode((unsigned int)0x1701);
  glPushMatrix();
  glLoadIdentity();
  glMatrixMode((unsigned int)0x1700);
  glPushMatrix();
  struct anonymous_11 cs;
  signed int ascent;
  signed int descent;
  signed int x;
  signed int y;
  signed int w;
  signed int h;
  signed int swap;
  signed int rot = (signed int)0;
  glLoadIdentity();
  glViewport(0, 0, window_width, window_height);
  glOrtho((double)0, (double)window_width, (double)0, (double)window_height, (double)-1, (double)1);
  for( ; !(rot >= -179); rot = rot + 360)
    ;
  for( ; rot >= 181; rot = rot - 360)
    ;
  texture_string_metrics(data, string, &cs, &ascent, &descent);
  h = (signed int)cs.ascent + (signed int)cs.descent;
  w = (signed int)cs.width;
  if(rot >= 136 || !(rot >= -135))
  {
    glTranslatef((float)window_width, (float)window_height, (float)0);
    glRotatef((float)180, (float)0, (float)0, (float)1);
  }

  else
    if(rot >= 46)
    {
      glTranslatef((float)window_width, (float)0, (float)0);
      glRotatef((float)90, (float)0, (float)0, (float)1);
      swap = window_width;
      window_width = window_height;
      window_height = swap;
    }

    else
      if(!(rot >= -45))
      {
        glTranslatef((float)0, (float)window_height, (float)0);
        glRotatef((float)-90, (float)0, (float)0, (float)1);
        swap = window_width;
        window_width = window_height;
        window_height = swap;
      }

  switch(position)
  {
    case 0:
    {
      x = (window_width - w) / 2;
      y = (window_height + h) / 2 - ascent;
      break;
    }
    case 1:
    {
      x = ascent;
      y = window_height - ascent * 2;
      break;
    }
    case 2:
    {
      x = ascent;
      y = h;
      break;
    }
    default:
      abort();
  }
  glTranslatef((float)x, (float)y, (float)0);
  const struct anonymous_70 offsets[5l] = { { .x=(signed short int)-1, .y=(signed short int)-1 },
    { .x=(signed short int)-1, .y=(signed short int)1 },
    { .x=(signed short int)1, .y=(signed short int)1 },
    { .x=(signed short int)1, .y=(signed short int)-1 },
    { .x=(signed short int)0, .y=(signed short int)0 } };
  signed int i;
  glColor3f((float)0, (float)0, (float)0);
  i = 0;
  for( ; !((unsigned long int)i >= 5ul); i = i + 1)
  {
    if((signed int)offsets[(signed long int)i].x == 0)
      glColor4fv(color);

    glPushMatrix();
    glTranslatef((float)offsets[(signed long int)i].x, (float)offsets[(signed long int)i].y, (float)0);
    print_texture_string(data, string);
    glPopMatrix();
  }
  glPopMatrix();
  glMatrixMode((unsigned int)0x1701);
  glPopMatrix();
  if(!(tex_p == 0))
    glEnable((unsigned int)0x0DE1);

  else
    glDisable((unsigned int)0x0DE1);
  if(!(texs_p == 0))
    glEnable((unsigned int)0x0C60);

  if(!(text_p == 0))
    glEnable((unsigned int)0x0C61);

  if(!(depth_p == 0))
    glEnable((unsigned int)0x0B71);

  else
    glDisable((unsigned int)0x0B71);
  if(!(cull_p == 0))
    glEnable((unsigned int)0x0B44);

  if(!(fog_p == 0))
    glEnable((unsigned int)0x0B60);

  glViewport(ovp[(signed long int)0], ovp[(signed long int)1], ovp[(signed long int)2], ovp[(signed long int)3]);
  glPolygonMode((unsigned int)0x0404, (unsigned int)opoly[(signed long int)0]);
  glMatrixMode((unsigned int)0x1700);
}

// print_texture_string
// file texfont.c line 620
extern void print_texture_string(struct texture_font_data *data, const char *string)
{
  struct anonymous_11 overall;
  signed int tex_width;
  signed int tex_height;
  struct texfont_cache *cache;
  signed int old_texture;
  if(!(*string == 0))
  {
    clear_gl_error();
    glGetIntegerv((unsigned int)0x8069, &old_texture);
    cache=get_cache(data, string);
    glBindTexture((unsigned int)0x0DE1, cache->texid);
    check_gl_error("texture font binding");
    if(!(cache->string == ((char *)NULL)))
    {
      overall = data->cache->extents;
      tex_width = data->cache->tex_width;
      tex_height = data->cache->tex_height;
    }

    else
      string_to_texture(data, string, &overall, &tex_width, &tex_height);
    signed int ofront;
    signed int oblend;
    signed int alpha_p;
    signed int blend_p;
    signed int light_p;
    signed int gen_s_p;
    signed int gen_t_p;
    float omatrix[16l];
    float qx0;
    float qy0;
    float qx1;
    float qy1;
    float tx0;
    float ty0;
    float tx1;
    float ty1;
    signed int draw_back_face_p;
    unsigned char return_value_glIsEnabled_1;
    return_value_glIsEnabled_1=glIsEnabled((unsigned int)0x0B44);
    draw_back_face_p = (signed int)!(return_value_glIsEnabled_1 != 0);
    glGetIntegerv((unsigned int)0x0B46, &ofront);
    glGetIntegerv((unsigned int)0x0BE0, &oblend);
    glGetFloatv((unsigned int)0x0BA8, omatrix);
    unsigned char return_value_glIsEnabled_2;
    return_value_glIsEnabled_2=glIsEnabled((unsigned int)0x0BE2);
    blend_p = (signed int)return_value_glIsEnabled_2;
    unsigned char return_value_glIsEnabled_3;
    return_value_glIsEnabled_3=glIsEnabled((unsigned int)0x0BC0);
    alpha_p = (signed int)return_value_glIsEnabled_3;
    unsigned char return_value_glIsEnabled_4;
    return_value_glIsEnabled_4=glIsEnabled((unsigned int)0x0B50);
    light_p = (signed int)return_value_glIsEnabled_4;
    unsigned char return_value_glIsEnabled_5;
    return_value_glIsEnabled_5=glIsEnabled((unsigned int)0x0C60);
    gen_s_p = (signed int)return_value_glIsEnabled_5;
    unsigned char return_value_glIsEnabled_6;
    return_value_glIsEnabled_6=glIsEnabled((unsigned int)0x0C61);
    gen_t_p = (signed int)return_value_glIsEnabled_6;
    glPushMatrix();
    glNormal3f((float)0, (float)0, (float)1);
    glFrontFace((unsigned int)0x0900);
    glMatrixMode((unsigned int)0x1702);
    glLoadIdentity();
    glMatrixMode((unsigned int)0x1700);
    enable_texture_string_parameters();
    qx0 = (float)overall.lbearing;
    qy0 = (float)-((signed int)overall.descent);
    qx1 = (float)overall.rbearing;
    qy1 = (float)overall.ascent;
    tx0 = (float)0;
    ty1 = (float)0;
    tx1 = (float)((signed int)overall.rbearing - (signed int)overall.lbearing) / (float)tex_width;
    ty0 = (float)((signed int)overall.ascent + (signed int)overall.descent) / (float)tex_height;
    glEnable((unsigned int)0x0B44);
    glFrontFace((unsigned int)0x0901);
    glBegin((unsigned int)0x0007);
    glTexCoord2f(tx0, ty0);
    glVertex3f(qx0, qy0, (float)0);
    glTexCoord2f(tx1, ty0);
    glVertex3f(qx1, qy0, (float)0);
    glTexCoord2f(tx1, ty1);
    glVertex3f(qx1, qy1, (float)0);
    glTexCoord2f(tx0, ty1);
    glVertex3f(qx0, qy1, (float)0);
    glEnd();
    if(!(draw_back_face_p == 0))
    {
      glFrontFace((unsigned int)0x0900);
      glBegin((unsigned int)0x0007);
      glTexCoord2f(tx0, ty0);
      glVertex3f(qx0, qy0, (float)0);
      glTexCoord2f(tx1, ty0);
      glVertex3f(qx1, qy0, (float)0);
      glTexCoord2f(tx1, ty1);
      glVertex3f(qx1, qy1, (float)0);
      glTexCoord2f(tx0, ty1);
      glVertex3f(qx0, qy1, (float)0);
      glEnd();
      glDisable((unsigned int)0x0B44);
    }

    glPopMatrix();
    glBindTexture((unsigned int)0x0DE1, (unsigned int)old_texture);
    glFrontFace((unsigned int)ofront);
    if(alpha_p == 0)
      glDisable((unsigned int)0x0BC0);

    if(blend_p == 0)
      glDisable((unsigned int)0x0BE2);

    if(!(light_p == 0))
      glEnable((unsigned int)0x0B50);

    if(!(gen_s_p == 0))
      glEnable((unsigned int)0x0C60);

    if(!(gen_t_p == 0))
      glEnable((unsigned int)0x0C61);

    glBlendFunc((unsigned int)0x0302, (unsigned int)oblend);
    glMatrixMode((unsigned int)0x1702);
    glMultMatrixf(omatrix);
    glMatrixMode((unsigned int)0x1700);
    check_gl_error("texture font print");
    if(cache->string == ((char *)NULL))
    {
      cache->string=strdup(string);
      cache->extents = overall;
      cache->tex_width = tex_width;
      cache->tex_height = tex_height;
    }

  }

}

// refresh_atlantis
// file atlantis.c line 560
static void refresh_atlantis(struct ModeInfo *mi)
{
  ;
}

// release_atlantis
// file atlantis.c line 540
static void release_atlantis(struct ModeInfo *mi)
{
  ;
}

// reshape_atlantis
// file atlantis.c line 322
static void reshape_atlantis(struct ModeInfo *mi, signed int width, signed int height)
{
  struct anonymous *ap = &atlantis[(signed long int)mi->screen_number];
  ap->WinW = (signed int)width;
  ap->WinH = (signed int)height;
  glViewport(0, 0, ap->WinW, ap->WinH);
  glMatrixMode((unsigned int)0x1701);
  glLoadIdentity();
  gluPerspective(400.0, (double)width / (double)height, 1.0, 2000000.0);
  glMatrixMode((unsigned int)0x1700);
}

// rgb_to_hsv
// file hsv.c line 52
extern void rgb_to_hsv(unsigned short int r, unsigned short int g, unsigned short int b, signed int *h, double *s, double *v)
{
  double R;
  double G;
  double B;
  double H;
  double S;
  double V;
  double cmax;
  double cmin;
  double cmm;
  signed int imax;
  R = (double)r / 65535.0;
  G = (double)g / 65535.0;
  B = (double)b / 65535.0;
  cmax = R;
  cmin = G;
  imax = 1;
  if(cmax < G)
  {
    cmax = G;
    cmin = R;
    imax = 2;
  }

  if(cmax < B)
  {
    cmax = B;
    imax = 3;
  }

  if(cmin > B)
    cmin = B;

  cmm = cmax - cmin;
  V = cmax;
  if(IEEE_FLOAT_EQUAL(cmm, 0.000000))
  {
    H = (double)0;
    S = H;
  }

  else
  {
    S = cmm / cmax;
    if(imax == 1)
      H = (G - B) / cmm;

    else
      if(imax == 2)
        H = 2.0 + (B - R) / cmm;

      else
        H = 4.0 + (R - G) / cmm;
    if(H < 0.000000)
      H = H + 6.0;

  }
  *h = (signed int)(H * 60.0);
  *s = S;
  *v = V;
}

// rotate_colors
// file colors.c line 711
extern void rotate_colors(struct anonymous_58 *screen, unsigned long int cmap, struct anonymous_36 *colors, signed int ncolors, signed int distance)
{
  struct _XDisplay *dpy;
  struct _XDisplay *tmp_if_expr_1;
  if(!(screen == ((struct anonymous_58 *)NULL)))
    tmp_if_expr_1 = screen->display;

  else
    tmp_if_expr_1 = ((struct _XDisplay *)NULL);
  dpy = tmp_if_expr_1;
  signed int i;
  struct anonymous_36 *colors2;
  if(ncolors >= 2)
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct anonymous_36) /*16ul*/  * (unsigned long int)ncolors);
    colors2 = (struct anonymous_36 *)return_value_malloc_2;
    distance = distance % ncolors;
    i = 0;
    for( ; !(i >= ncolors); i = i + 1)
    {
      signed int j = i - distance;
      if(j >= ncolors)
        j = j - ncolors;

      if(!(j >= 0))
        j = j + ncolors;

      colors2[(signed long int)i] = colors[(signed long int)j];
      (colors2 + (signed long int)i)->pixel = (colors + (signed long int)i)->pixel;
    }
    XStoreColors(dpy, cmap, colors2, ncolors);
    XFlush(dpy);
    memcpy((void *)colors, (const void *)colors2, sizeof(struct anonymous_36) /*16ul*/  * (unsigned long int)ncolors);
    free((void *)colors2);
  }

}

// run_screenhack_table
// file screenhack.c line 536
static void run_screenhack_table(struct _XDisplay *dpy, unsigned long int window, unsigned long int window2, struct xscreensaver_function_table *ft)
{
  void * (*init_cb)(struct _XDisplay *, unsigned long int, void *) = (void * (*)(struct _XDisplay *, unsigned long int, void *))ft->init_cb;
  void (*fps_cb)(struct _XDisplay *, unsigned long int, struct fps_state *, void *) = ft->fps_cb;
  void *closure;
  closure=init_cb(dpy, window, ft->setup_arg);
  struct fps_state *fpst;
  fpst=fps_init(dpy, window);
  void *closure2 = NULL;
  struct fps_state *fpst2 = ((struct fps_state *)NULL);
  if(!(window2 == 0ul))
    closure2=init_cb(dpy, window2, ft->setup_arg);

  if(!(window2 == 0ul))
    fpst2=fps_init(dpy, window2);

  if(closure == NULL)
    abort();

  if(fps_cb == ((void (*)(struct _XDisplay *, unsigned long int, struct fps_state *, void *))NULL))
    fps_cb = screenhack_do_fps;

  {
    unsigned long int delay;
    delay=ft->draw_cb(dpy, window, closure);
    unsigned long int delay2 = (unsigned long int)0;
    if(!(window2 == 0ul))
      delay2=ft->draw_cb(dpy, window2, closure2);

    if(!(fpst == ((struct fps_state *)NULL)))
      fps_cb(dpy, window, fpst, closure);

    if(!(fpst2 == ((struct fps_state *)NULL)))
      fps_cb(dpy, window, fpst2, closure);

    char return_value_usleep_and_process_events_1;
    return_value_usleep_and_process_events_1=usleep_and_process_events(dpy, ft, window, fpst, closure, delay, window2, fpst2, closure2, delay2);
  }
  ft->free_cb(dpy, window, closure);
  if(!(fpst == ((struct fps_state *)NULL)))
    fps_free(fpst);

  if(!(window2 == 0ul))
    ft->free_cb(dpy, window2, closure2);

  if(!(fpst2 == ((struct fps_state *)NULL)))
    fps_free(fpst2);

}

// screen_number
// file ./../../utils/visual.h line 21
extern signed int screen_number(struct anonymous_58 *screen)
{
  struct _XDisplay *dpy = screen->display;
  signed int i = 0;
  for( ; !(i >= ((struct anonymous_0 *)dpy)->nscreens); i = i + 1)
    if(((struct anonymous_0 *)dpy)->screens + (signed long int)i == screen)
      return i;

  abort();
  return 0;
}

// screenhack_do_fps
// file screenhack.c line 528
static void screenhack_do_fps(struct _XDisplay *dpy, unsigned long int w, struct fps_state *fpst, void *closure)
{
  fps_compute(fpst, (unsigned long int)0, (double)-1);
  fps_draw(fpst);
}

// screenhack_ehandler
// file screenhack.c line 245
static signed int screenhack_ehandler(struct _XDisplay *dpy, struct anonymous_64 *error)
{
  fprintf(stderr, "\nX error in %s:\n", progname);
  signed int return_value_XmuPrintDefaultErrorMessage_1;
  return_value_XmuPrintDefaultErrorMessage_1=XmuPrintDefaultErrorMessage(dpy, error, stderr);
  if(!(return_value_XmuPrintDefaultErrorMessage_1 == 0))
    exit(-1);

  else
    fprintf(stderr, " (nonfatal.)\n");
  return 0;
}

// screenhack_event_helper
// file resources.c line 276
extern signed int screenhack_event_helper(struct _XDisplay *dpy, unsigned long int window, union _XEvent *event)
{
  if(event->xany.type == 2)
  {
    unsigned long int keysym;
    char c = (char)0;
    XLookupString(&event->xkey, &c, 1, &keysym, ((struct _XComposeStatus *)NULL));
    if(keysym == 65361ul || keysym == 65362ul || keysym == 65363ul || keysym == 65364ul || keysym == 65365ul || keysym == 65366ul || (signed int)c == 9 || (signed int)c == 10 || (signed int)c == 13 || (signed int)c == 32)
      return 1;

  }

  else
    if(event->xany.type == 4)
    {
      if(event->xbutton.button == 1u)
        return 1;

    }

  return 0;
}

// screenhack_handle_event_1
// file screenhack.c line 270
static signed int screenhack_handle_event_1(struct _XDisplay *dpy, union _XEvent *event)
{
  switch(event->xany.type)
  {
    case 2:
    {
      unsigned long int keysym;
      char c = (char)0;
      XLookupString(&event->xkey, &c, 1, &keysym, ((struct _XComposeStatus *)NULL));
      if((signed int)c == 3 || (signed int)c == 27 || (signed int)c == 81 || (signed int)c == 113)
        return 0;

      else
        if(!(keysym >= 65505ul) || keysym >= 65519ul)
          XBell(dpy, 0);

      goto __CPROVER_DUMP_L11;
    }
    case 4:
    {
      XBell(dpy, 0);
      goto __CPROVER_DUMP_L11;
    }
    case 33:
      if(!(event->xclient.message_type == XA_WM_PROTOCOLS))
      {
        char *s;
        s=XGetAtomName(dpy, event->xclient.message_type);
        if(s == ((char *)NULL))
          s = "(null)";

        fprintf(stderr, "%s: unknown ClientMessage %s received!\n", progname, s);
      }

      else
        if(!((unsigned long int)event->xclient.data.l[0l] == XA_WM_DELETE_WINDOW))
        {
          char *s1;
          s1=XGetAtomName(dpy, event->xclient.message_type);
          char *s2;
          s2=XGetAtomName(dpy, (unsigned long int)event->xclient.data.l[(signed long int)0]);
          if(s1 == ((char *)NULL))
            s1 = "(null)";

          if(s2 == ((char *)NULL))
            s2 = "(null)";

          fprintf(stderr, "%s: unknown ClientMessage %s[%s] received!\n", progname, s1, s2);
        }

        else
          return 0;
    default:
    {

    __CPROVER_DUMP_L11:
      ;
      return 1;
    }
  }
}

// screenhack_table_handle_events
// file screenhack.c line 433
static char screenhack_table_handle_events(struct _XDisplay *dpy, struct xscreensaver_function_table *ft, unsigned long int window, void *closure, unsigned long int window2, void *closure2)
{
  struct _XtAppStruct *app;
  app=XtDisplayToApplicationContext(dpy);
  unsigned long int return_value_XtAppPending_1;
  return_value_XtAppPending_1=XtAppPending(app);
  if(!((6ul & return_value_XtAppPending_1) == 0ul))
    XtAppProcessEvent(app, (unsigned long int)(2 | 4));

  signed int return_value_XPending_2;
  signed int tmp_if_expr_5;
  signed int return_value;
  signed int tmp_if_expr_4;
  signed int return_value_1;
  signed int return_value_screenhack_handle_event_1_3;
  do
  {
    return_value_XPending_2=XPending(dpy);
    if(return_value_XPending_2 == 0)
      break;

    union _XEvent event;
    XNextEvent(dpy, &event);
    if(event.xany.type == 22)
    {
      if(event.xany.window == window)
        ft->reshape_cb(dpy, window, closure, (unsigned int)event.xconfigure.width, (unsigned int)event.xconfigure.height);

      if(event.xany.window == window2 && !(window2 == 0ul))
        ft->reshape_cb(dpy, window2, closure2, (unsigned int)event.xconfigure.width, (unsigned int)event.xconfigure.height);

    }

    else
    {
      _Bool tmp_if_expr_6;
      if(event.xany.type == 33)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        if(event.xany.window == window)
        {
          return_value=ft->event_cb(dpy, window, closure, &event);
          tmp_if_expr_5 = return_value;
        }

        else
        {
          if(event.xany.window == window2 && !(window2 == 0ul))
          {
            return_value_1=ft->event_cb(dpy, window2, closure2, &event);
            tmp_if_expr_4 = return_value_1;
          }

          else
            tmp_if_expr_4 = 0;
          tmp_if_expr_5 = tmp_if_expr_4;
        }
        tmp_if_expr_6 = !(tmp_if_expr_5 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
      {
        return_value_screenhack_handle_event_1_3=screenhack_handle_event_1(dpy, &event);
        if(return_value_screenhack_handle_event_1_3 == 0)
          return (char)0;

      }

    }
    unsigned long int return_value_XtAppPending_7;
    return_value_XtAppPending_7=XtAppPending(app);
    if(!((6ul & return_value_XtAppPending_7) == 0ul))
      XtAppProcessEvent(app, (unsigned long int)(2 | 4));

  }
  while((_Bool)1);
  return (char)1;
}

// screenhack_usleep
// file ./../utils/usleep.h line 23
extern void screenhack_usleep(unsigned long int usecs)
{
  struct timeval tv;
  tv.tv_sec = (signed long int)(usecs / (unsigned long int)1000000L);
  tv.tv_usec = (signed long int)(usecs % (unsigned long int)1000000L);
  select(0, ((struct anonymous_47 *)NULL), ((struct anonymous_47 *)NULL), ((struct anonymous_47 *)NULL), &tv);
}

// string_to_texture
// file texfont.c line 518
void string_to_texture(struct texture_font_data *data, const char *string, struct anonymous_11 *extents_ret, signed int *tex_width_ret, signed int *tex_height_ret)
{
  unsigned long int window = (&((struct anonymous_0 *)data->dpy)->screens[(signed long int)0])->root;
  unsigned long int p;
  struct anonymous_34 gcv;
  struct _XGC *gc;
  struct anonymous_65 xgwa;
  struct anonymous_66 rcolor;
  struct _XftColor xftcolor;
  struct _XftDraw *xftdraw;
  signed int width;
  signed int height;
  struct anonymous_11 overall;
  XGetWindowAttributes(data->dpy, window, &xgwa);
  iterate_texture_string(data, string, 0, 0, ((struct _XftDraw *)NULL), ((struct _XftColor *)NULL), &overall);
  width = (signed int)overall.rbearing - (signed int)overall.lbearing;
  height = (signed int)overall.ascent + (signed int)overall.descent;
  if(!(width >= 1))
    width = 1;

  if(!(height >= 1))
    height = 1;

  p=XCreatePixmap(data->dpy, window, (unsigned int)width, (unsigned int)height, (unsigned int)xgwa.depth);
  gcv.foreground = xgwa.screen->black_pixel;
  gc=XCreateGC(data->dpy, p, (unsigned long int)(1L << 2), &gcv);
  XFillRectangle(data->dpy, p, gc, 0, 0, (unsigned int)width, (unsigned int)height);
  XFreeGC(data->dpy, gc);
  rcolor.alpha = (unsigned short int)0xFFFF;
  rcolor.blue = rcolor.alpha;
  rcolor.green = rcolor.blue;
  rcolor.red = rcolor.green;
  XftColorAllocValue(data->dpy, xgwa.visual, xgwa.colormap, &rcolor, &xftcolor);
  xftdraw=XftDrawCreate(data->dpy, p, xgwa.visual, xgwa.colormap);
  iterate_texture_string(data, string, -((signed int)overall.lbearing), (signed int)overall.ascent, xftdraw, &xftcolor, ((struct anonymous_11 *)NULL));
  XftDrawDestroy(xftdraw);
  XftColorFree(data->dpy, xgwa.visual, xgwa.colormap, &xftcolor);
  bitmap_to_texture(data->dpy, p, xgwa.visual, xgwa.depth, &width, &height);
  XFreePixmap(data->dpy, p);
  if(!(extents_ret == ((struct anonymous_11 *)NULL)))
    *extents_ret = overall;

  if(!(tex_width_ret == ((signed int *)NULL)))
    *tex_width_ret = width;

  if(!(tex_height_ret == ((signed int *)NULL)))
    *tex_height_ret = height;

}

// string_width
// file fps.c line 175
static signed int string_width(struct anonymous_13 *f, const char *c, signed int *height_ret)
{
  signed int x = 0;
  signed int max_w = 0;
  signed int h = f->ascent + f->descent;
  while(!(*c == 0))
  {
    signed int cc = (signed int)*((unsigned char *)c);
    if((signed int)*c == 10)
    {
      if(!(max_w >= x))
        max_w = x;

      x = 0;
      h = h + f->ascent + f->descent;
    }

    else
    {
      signed int tmp_if_expr_1;
      if(!(f->per_char == ((struct anonymous_11 *)NULL)))
        tmp_if_expr_1 = (signed int)(f->per_char + (signed long int)((unsigned int)cc - f->min_char_or_byte2))->width;

      else
        tmp_if_expr_1 = (signed int)f->min_bounds.rbearing;
      x = x + tmp_if_expr_1;
    }
    c = c + 1l;
  }
  if(!(max_w >= x))
    max_w = x;

  if(!(height_ret == ((signed int *)NULL)))
    *height_ret = h;

  return max_w;
}

// texture_string_metrics
// file texfont.c line 442
extern void texture_string_metrics(struct texture_font_data *data, const char *s, struct anonymous_11 *metrics_ret, signed int *ascent_ret, signed int *descent_ret)
{
  if(!(metrics_ret == ((struct anonymous_11 *)NULL)))
    iterate_texture_string(data, s, 0, 0, ((struct _XftDraw *)NULL), ((struct _XftColor *)NULL), metrics_ret);

  if(!(ascent_ret == ((signed int *)NULL)))
    *ascent_ret = data->xftfont->ascent;

  if(!(descent_ret == ((signed int *)NULL)))
    *descent_ret = data->xftfont->descent;

}

// thread_memory_alignment
// file thread_util.h line 112
unsigned int thread_memory_alignment(struct _XDisplay *dpy)
{
  threads_available(dpy);
  return (unsigned int)_cache_line_size;
}

// threadpool_create
// file thread_util.c line 713
signed int threadpool_create(struct threadpool *self, struct threadpool_class *cls, struct _XDisplay *dpy, unsigned int count)
{
  threads_available(dpy);
  self->count = count;
  /* assertion cls */
  assert(cls != ((struct threadpool_class *)NULL));
  self->thread_size = cls->size;
  self->thread_destroy = cls->destroy;
  void *thread;
  unsigned int i;
  unsigned int count_serial;
  count_serial=_threadpool_count_serial(self);
  if(!(count_serial == 0u))
  {
    thread=malloc(cls->size * (unsigned long int)count_serial);
    if(thread == NULL)
      return 12;

  }

  else
    thread = (void *)0;
  self->serial_threads = thread;
  i = (unsigned int)0;
  if(!(i == count_serial))
  {
    signed int error;
    error=cls->create(thread, self, i);
    if(!(error == 0))
    {
      self->count = i;
      _serial_destroy(self);
      return error;
    }

    thread = (void *)((char *)thread + (signed long int)self->thread_size);
    i = i + 1u;
  }

  /* assertion _has_pthread */
  assert(_has_pthread != 0);
  signed int return_value_pthread_cond_wait_3;
  if(_has_pthread >= 0)
  {
    unsigned int count_parallel;
    count_parallel=_threadpool_count_parallel(self);
    self->mutex = mutex_initializer;
    self->cond = cond_initializer;
    self->parallel_pending = (unsigned int)0;
    self->parallel_unfinished = (unsigned int)0;
    if(count_parallel == 0u)
    {
      self->parallel_threads = (unsigned long int *)(void *)0;
      return 0;
    }

    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)count_parallel);
    self->parallel_threads = (unsigned long int *)return_value_malloc_1;
    if(self->parallel_threads == ((unsigned long int *)NULL))
      return 12;

    struct _parallel_startup_type startup;
    startup.parent = self;
    startup.thread_create = cls->create;
    startup.last_errno = 0;
    signed int return_value_pthread_mutex_lock_2;
    return_value_pthread_mutex_lock_2=pthread_mutex_lock(&self->mutex);
    /* assertion !(pthread_mutex_lock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_lock_2 != 0));
    _add_next_thread(&startup);
    if(startup.last_errno == 0)
      while(!(self->parallel_unfinished == count_parallel))
      {
        if(self->parallel_threads == ((unsigned long int *)NULL))
          break;

        return_value_pthread_cond_wait_3=pthread_cond_wait(&self->cond, &self->mutex);
        /* assertion !(pthread_cond_wait(&self->cond, &self->mutex)) */
        assert(!(return_value_pthread_cond_wait_3 != 0));
      }

    if(!(startup.last_errno == 0))
      _unlock_and_destroy(self);

    else
    {
      self->parallel_unfinished = (unsigned int)0;
      signed int return_value_pthread_mutex_unlock_4;
      return_value_pthread_mutex_unlock_4=pthread_mutex_unlock(&self->mutex);
      /* assertion !(pthread_mutex_unlock(&self->mutex)) */
      assert(!(return_value_pthread_mutex_unlock_4 != 0));
    }
    return startup.last_errno;
  }

  return 0;
}

// threadpool_destroy
// file thread_util.c line 812
void threadpool_destroy(struct threadpool *self)
{
  if(_has_pthread >= 0)
  {
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&self->mutex);
    /* assertion !(pthread_mutex_lock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_lock_1 != 0));
    _unlock_and_destroy(self);
    goto __CPROVER_DUMP_L2;
  }

  _serial_destroy(self);

__CPROVER_DUMP_L2:
  ;
}

// threadpool_run
// file thread_util.c line 826
void threadpool_run(struct threadpool *self, void (*func)(void *))
{
  if(_has_pthread >= 0)
  {
    unsigned int count;
    count=_threadpool_count_parallel(self);
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&self->mutex);
    /* assertion !(pthread_mutex_lock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_lock_1 != 0));
    /* assertion !self->parallel_pending */
    assert(!(self->parallel_pending != 0u));
    /* assertion !self->parallel_unfinished */
    assert(!(self->parallel_unfinished != 0u));
    self->parallel_pending = count;
    self->parallel_unfinished = count;
    self->thread_run = func;
    signed int return_value_pthread_cond_broadcast_2;
    return_value_pthread_cond_broadcast_2=pthread_cond_broadcast(&self->cond);
    /* assertion !(pthread_cond_broadcast(&self->cond)) */
    assert(!(return_value_pthread_cond_broadcast_2 != 0));
    signed int return_value_pthread_mutex_unlock_3;
    return_value_pthread_mutex_unlock_3=pthread_mutex_unlock(&self->mutex);
    /* assertion !(pthread_mutex_unlock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_unlock_3 != 0));
  }

  void *thread = self->serial_threads;
  unsigned int i;
  unsigned int threadpool_run__1__2__count;
  threadpool_run__1__2__count=_threadpool_count_serial(self);
  i = (unsigned int)0;
  if(!(i == threadpool_run__1__2__count))
  {
    func(thread);
    thread = (void *)((char *)thread + (signed long int)self->thread_size);
    i = i + 1u;
  }

}

// threadpool_wait
// file thread_util.c line 858
void threadpool_wait(struct threadpool *self)
{
  signed int return_value_pthread_cond_wait_2;
  if(_has_pthread >= 0)
  {
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&self->mutex);
    /* assertion !(pthread_mutex_lock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_lock_1 != 0));
    while(!(self->parallel_unfinished == 0u))
    {
      return_value_pthread_cond_wait_2=pthread_cond_wait(&self->cond, &self->mutex);
      /* assertion !(pthread_cond_wait(&self->cond, &self->mutex)) */
      assert(!(return_value_pthread_cond_wait_2 != 0));
    }
    signed int return_value_pthread_mutex_unlock_3;
    return_value_pthread_mutex_unlock_3=pthread_mutex_unlock(&self->mutex);
    /* assertion !(pthread_mutex_unlock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_unlock_3 != 0));
  }

}

// threads_available
// file thread_util.h line 93
signed int threads_available(struct _XDisplay *dpy)
{
  if(_has_pthread == 0)
  {
    _has_pthread = (signed int)200809L;
    if(_has_pthread >= 0)
    {
      signed int return_value_get_boolean_resource_2;
      return_value_get_boolean_resource_2=get_boolean_resource(dpy, "useThreads", "Boolean");
      if(!(return_value_get_boolean_resource_2 == 0))
      {
        unsigned int return_value__get_cache_line_size_1;
        return_value__get_cache_line_size_1=_get_cache_line_size();
        _cache_line_size = (signed int)return_value__get_cache_line_size_1;
        /* assertion _cache_line_size >= sizeof(void *) */
        assert((unsigned long int)_cache_line_size >= sizeof(void *) /*8ul*/ );
        /* assertion ((_cache_line_size) > 0 && !((_cache_line_size) & ((_cache_line_size) - 1))) */
        assert(_cache_line_size > 0 && !((_cache_line_size & _cache_line_size - 1) != 0));
      }

      else
        _has_pthread = -1;
    }

  }

  return _has_pthread;
}

// to_pow2
// file texfont.c line 87
static signed int to_pow2(signed int i)
{
  signed int j = 0;
  static const unsigned int pow2[17l] = { (const unsigned int)1, (const unsigned int)2, (const unsigned int)4, (const unsigned int)8, (const unsigned int)16, (const unsigned int)32, (const unsigned int)64, (const unsigned int)128, (const unsigned int)256, (const unsigned int)512, (const unsigned int)1024, (const unsigned int)2048, (const unsigned int)4096, (const unsigned int)8192, (const unsigned int)16384, (const unsigned int)32768, (const unsigned int)65536 };
  for( ; !((unsigned long int)j >= 17ul); j = j + 1)
    if(pow2[(signed long int)j] >= (unsigned int)i)
      return (signed int)pow2[(signed long int)j];

  abort();
}

// uc_truncate
// file utf8wc.c line 38
static unsigned long int uc_truncate(unsigned long int uc)
{
  uc = uc & (unsigned long int)0x7FFFFFFFL;
  if(uc >= 1114112ul)
    uc = (unsigned long int)0xFFFD;

  if(uc == 0ul)
    uc = (unsigned long int)0xFFFD;

  if(uc >= 55296ul && !(uc >= 57344ul))
    uc = (unsigned long int)0xFFFD;

  return uc;
}

// usleep_and_process_events
// file screenhack.c line 481
static char usleep_and_process_events(struct _XDisplay *dpy, struct xscreensaver_function_table *ft, unsigned long int window, struct fps_state *fpst, void *closure, unsigned long int delay, unsigned long int window2, struct fps_state *fpst2, void *closure2, unsigned long int delay2)
{
  do
  {
    unsigned long int quantum = (unsigned long int)33333;
    if(!(delay >= quantum))
      quantum = delay;

    delay = delay - quantum;
    XSync(dpy, 0);
    if(quantum >= 1ul)
    {
      screenhack_usleep(quantum);
      if(!(fpst == ((struct fps_state *)NULL)))
        fps_slept(fpst, quantum);

      if(!(fpst2 == ((struct fps_state *)NULL)))
        fps_slept(fpst2, quantum);

    }

    char return_value_screenhack_table_handle_events_1;
    return_value_screenhack_table_handle_events_1=screenhack_table_handle_events(dpy, ft, window, closure, window2, closure2);
    if(return_value_screenhack_table_handle_events_1 == 0)
      return (char)0;

  }
  while(delay >= 1ul);
  return (char)1;
}

// utf8_decode
// file utf8wc.c line 56
extern signed long int utf8_decode(const unsigned char *in, signed long int length, unsigned long int *unicode_ret)
{
  const unsigned char *start = in;
  const unsigned char *end = in + length;
  unsigned long int uc = (unsigned long int)0xFFFD;
  unsigned long int min = (unsigned long int)0;
  unsigned char c;
  if(length >= 1l)
  {
    const unsigned char *tmp_post_1 = in;
    in = in + 1l;
    c = *tmp_post_1;
    if((0xC0 & (signed int)c) == 0x80)
      uc = (unsigned long int)0xFFFD;

    else
      if((0x80 & (signed int)c) == 0)
        uc = (unsigned long int)((signed int)c & 0x7F);

      else
        if((0xE0 & (signed int)c) == 0xC0)
        {
          if(!(end >= in + 1l))
          {
            in = end;
            goto DONE;
          }

          min = (unsigned long int)(1 << 7);
          uc = (unsigned long int)(((signed int)c & 0x1F) << 6 | (signed int)in[(signed long int)0] & 0x3F);
          in = in + (signed long int)1;
        }

        else
          if((0xF0 & (signed int)c) == 0xE0)
          {
            if(!(end >= in + 2l))
            {
              in = end;
              goto DONE;
            }

            min = (unsigned long int)(1 << 11);
            uc = (unsigned long int)(((signed int)c & 0x0F) << 12 | ((signed int)in[(signed long int)0] & 0x3F) << 6 | (signed int)in[(signed long int)1] & 0x3F);
            in = in + (signed long int)2;
          }

          else
            if((0xF8 & (signed int)c) == 0xF0)
            {
              if(!(end >= in + 3l))
              {
                in = end;
                goto DONE;
              }

              min = (unsigned long int)(1 << 16);
              uc = (unsigned long int)(((signed int)c & 0x07) << 18 | ((signed int)in[(signed long int)0] & 0x3F) << 12 | ((signed int)in[(signed long int)1] & 0x3F) << 6 | (signed int)in[(signed long int)2] & 0x3F);
              in = in + (signed long int)3;
            }

            else
              if((0xFC & (signed int)c) == 0xF8)
              {
                if(!(end >= in + 4l))
                {
                  in = end;
                  goto DONE;
                }

                min = (unsigned long int)(1 << 21);
                uc = (unsigned long int)(((signed int)c & 0x03) << 24 | ((signed int)in[(signed long int)0] & 0x3F) << 18 | ((signed int)in[(signed long int)1] & 0x3F) << 12 | ((signed int)in[(signed long int)2] & 0x3F) << 6 | (signed int)in[(signed long int)3] & 0x3F);
                in = in + (signed long int)4;
              }

              else
                if((0xFE & (signed int)c) == 0xFC)
                {
                  if(!(end >= in + 5l))
                  {
                    in = end;
                    goto DONE;
                  }

                  min = (unsigned long int)(1 << 26);
                  uc = (unsigned long int)(((signed int)c & 0x01) << 30 | ((signed int)in[(signed long int)0] & 0x3F) << 24 | ((signed int)in[(signed long int)1] & 0x3F) << 18 | ((signed int)in[(signed long int)2] & 0x3F) << 12 | ((signed int)in[(signed long int)3] & 0x3F) << 6 | (signed int)in[(signed long int)4] & 0x3F);
                  in = in + (signed long int)5;
                }

                else
                  uc = (unsigned long int)0xFFFD;
  }


DONE:
  ;
  length = in - start;
  signed int i = 1;
  for( ; !((signed long int)i >= length); i = i + 1)
    if(!((0xC0 & (signed int)start[(signed long int)i]) == 0x80))
    {
      uc = (unsigned long int)0xFFFD;
      length = (signed long int)(i + 1);
      break;
    }

  if(!(uc >= min))
    uc = (unsigned long int)0xFFFD;

  uc=uc_truncate(uc);
  if(!(unicode_ret == ((unsigned long int *)NULL)))
    *unicode_ret = uc;

  return length;
}

// utf8_encode
// file utf8wc.c line 160
extern signed int utf8_encode(unsigned long int uc, char *out, signed long int length)
{
  const char *old = out;
  uc=uc_truncate(uc);
  if(length >= 1l && !(uc >= 128ul))
  {
    char *tmp_post_1 = out;
    out = out + 1l;
    *tmp_post_1 = (char)uc;
  }

  else
    if(length >= 2l && !(uc >= 2048ul))
    {
      char *tmp_post_2 = out;
      out = out + 1l;
      *tmp_post_2 = (char)((unsigned long int)0xC0 | uc >> 6 & (unsigned long int)0x1F);
      char *tmp_post_3 = out;
      out = out + 1l;
      *tmp_post_3 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
    }

    else
      if(length >= 3l && !(uc >= 65536ul))
      {
        char *tmp_post_4 = out;
        out = out + 1l;
        *tmp_post_4 = (char)((unsigned long int)0xE0 | uc >> 12 & (unsigned long int)0x0F);
        char *tmp_post_5 = out;
        out = out + 1l;
        *tmp_post_5 = (char)((unsigned long int)0x80 | uc >> 6 & (unsigned long int)0x3F);
        char *tmp_post_6 = out;
        out = out + 1l;
        *tmp_post_6 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
      }

      else
        if(length >= 4l && !(uc >= 2097152ul))
        {
          char *tmp_post_7 = out;
          out = out + 1l;
          *tmp_post_7 = (char)((unsigned long int)0xF0 | uc >> 18 & (unsigned long int)0x07);
          char *tmp_post_8 = out;
          out = out + 1l;
          *tmp_post_8 = (char)((unsigned long int)0x80 | uc >> 12 & (unsigned long int)0x3F);
          char *tmp_post_9 = out;
          out = out + 1l;
          *tmp_post_9 = (char)((unsigned long int)0x80 | uc >> 6 & (unsigned long int)0x3F);
          char *tmp_post_10 = out;
          out = out + 1l;
          *tmp_post_10 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
        }

        else
          if(length >= 5l && !(uc >= 67108864ul))
          {
            char *tmp_post_11 = out;
            out = out + 1l;
            *tmp_post_11 = (char)((unsigned long int)0xF8 | uc >> 24 & (unsigned long int)0x03);
            char *tmp_post_12 = out;
            out = out + 1l;
            *tmp_post_12 = (char)((unsigned long int)0x80 | uc >> 18 & (unsigned long int)0x3F);
            char *tmp_post_13 = out;
            out = out + 1l;
            *tmp_post_13 = (char)((unsigned long int)0x80 | uc >> 12 & (unsigned long int)0x3F);
            char *tmp_post_14 = out;
            out = out + 1l;
            *tmp_post_14 = (char)((unsigned long int)0x80 | uc >> 6 & (unsigned long int)0x3F);
            char *tmp_post_15 = out;
            out = out + 1l;
            *tmp_post_15 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
          }

          else
            if(length >= 6l)
            {
              char *tmp_post_16 = out;
              out = out + 1l;
              *tmp_post_16 = (char)((unsigned long int)0xFC | uc >> 30 & (unsigned long int)0x01);
              char *tmp_post_17 = out;
              out = out + 1l;
              *tmp_post_17 = (char)((unsigned long int)0x80 | uc >> 24 & (unsigned long int)0x3F);
              char *tmp_post_18 = out;
              out = out + 1l;
              *tmp_post_18 = (char)((unsigned long int)0x80 | uc >> 18 & (unsigned long int)0x3F);
              char *tmp_post_19 = out;
              out = out + 1l;
              *tmp_post_19 = (char)((unsigned long int)0x80 | uc >> 12 & (unsigned long int)0x3F);
              char *tmp_post_20 = out;
              out = out + 1l;
              *tmp_post_20 = (char)((unsigned long int)0x80 | uc >> 6 & (unsigned long int)0x3F);
              char *tmp_post_21 = out;
              out = out + 1l;
              *tmp_post_21 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
            }

  return (signed int)(out - old);
}

// utf8_split
// file utf8wc.c line 256
extern char ** utf8_split(const char *string, signed int *length_ret)
{
  const unsigned char *in = (const unsigned char *)string;
  signed long int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  len = (signed long int)return_value_strlen_1;
  const unsigned char *end = in + len;
  char **ret;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(len + (signed long int)1) * sizeof(char *) /*8ul*/ );
  ret = (char **)return_value_malloc_2;
  signed int i = 0;
  if(ret == ((char **)NULL))
    return ((char **)NULL);

  else
  {
    while(!(in >= end))
    {
      unsigned long int uc;
      signed long int len2;
      len2=utf8_decode(in, len, &uc);
      char tmp[10l];
      strncpy(tmp, (char *)in, (unsigned long int)len2);
      tmp[len2] = (char)0;
      signed int tmp_post_3 = i;
      i = i + 1;
      ret[(signed long int)tmp_post_3]=strdup(tmp);
      in = in + len2;
      if(i >= 2 && uc >= 768ul && !(uc >= 880ul))
      {
        signed long int L1;
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(ret[(signed long int)(i - 2)]);
        L1 = (signed long int)return_value_strlen_4;
        signed long int L2;
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(ret[(signed long int)(i - 1)]);
        L2 = (signed long int)return_value_strlen_5;
        char *s2;
        void *return_value_malloc_6;
        return_value_malloc_6=malloc((unsigned long int)(L1 + L2 + (signed long int)1));
        s2 = (char *)return_value_malloc_6;
        strncpy(s2, ret[(signed long int)(i - 2)], (unsigned long int)L1);
        strncpy(s2 + L1, ret[(signed long int)(i - 1)], (unsigned long int)L2);
        s2[L1 + L2] = (char)0;
        free((void *)ret[(signed long int)(i - 2)]);
        ret[(signed long int)(i - 2)] = s2;
        i = i - 1;
      }

    }
    ret[(signed long int)i] = ((char *)NULL);
    void *return_value_realloc_7;
    return_value_realloc_7=realloc((void *)ret, (unsigned long int)(i + 1) * sizeof(char *) /*8ul*/ );
    ret = (char **)return_value_realloc_7;
    if(!(length_ret == ((signed int *)NULL)))
      *length_ret = i;

    return ret;
  }
}

// utf8_to_XChar2b
// file utf8wc.c line 215
extern struct anonymous_4 * utf8_to_XChar2b(const char *string, signed int *length_ret)
{
  signed long int in_len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  in_len = (signed long int)return_value_strlen_1;
  const unsigned char *in = (const unsigned char *)string;
  const unsigned char *in_end = in + in_len;
  struct anonymous_4 *c2b;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(in_len + (signed long int)1) * sizeof(struct anonymous_4) /*2ul*/ );
  c2b = (struct anonymous_4 *)return_value_malloc_2;
  struct anonymous_4 *out = c2b;
  if(out == ((struct anonymous_4 *)NULL))
    return ((struct anonymous_4 *)NULL);

  else
  {
    while(!(in >= in_end))
    {
      unsigned long int uc = (unsigned long int)0;
      signed long int L;
      L=utf8_decode(in, in_end - in, &uc);
      in = in + L;
      if(uc >= 65536ul)
        uc = (unsigned long int)0xFFFD;

      out->byte1 = (unsigned char)(uc >> 8 & (unsigned long int)0xFF);
      out->byte2 = (unsigned char)(uc & (unsigned long int)0xFF);
      out = out + 1l;
    }
    out->byte1 = (unsigned char)0;
    out->byte2 = (unsigned char)0;
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)c2b, (unsigned long int)((out - c2b) + (signed long int)1) * sizeof(struct anonymous_4) /*2ul*/ );
    c2b = (struct anonymous_4 *)return_value_realloc_3;
    if(!(length_ret == ((signed int *)NULL)))
      *length_ret = (signed int)(out - c2b);

    return c2b;
  }
}

// utf8_to_latin1
// file utf8wc.c line 347
extern char * utf8_to_latin1(const char *string, signed int ascii_p)
{
  signed long int in_len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  in_len = (signed long int)return_value_strlen_1;
  const unsigned char *in = (const unsigned char *)string;
  const unsigned char *in_end = in + in_len;
  unsigned char *ret;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(in_len + (signed long int)1));
  ret = (unsigned char *)return_value_malloc_2;
  unsigned char *out = ret;
  if(ret == ((unsigned char *)NULL))
    return ((char *)NULL);

  else
  {
    while(!(in >= in_end))
    {
      unsigned long int uc = (unsigned long int)0;
      signed long int len2;
      len2=utf8_decode(in, in_end - in, &uc);
      in = in + len2;
      if(uc == 18446744073709551520ul)
        uc = (unsigned long int)32;

      else
        if(uc >= 768ul && !(uc >= 880ul))
          uc = (unsigned long int)0;

        else
          if(uc >= 256ul)
            switch(uc)
            {
              case (unsigned long int)0x2000:

              case (unsigned long int)0x2001:

              case (unsigned long int)0x2002:

              case (unsigned long int)0x2003:

              case (unsigned long int)0x2004:

              case (unsigned long int)0x2005:

              case (unsigned long int)0x2006:

              case (unsigned long int)0x2007:

              case (unsigned long int)0x2008:

              case (unsigned long int)0x2009:

              case (unsigned long int)0x200A:
              {
                uc = (unsigned long int)32;
                break;
              }
              case (unsigned long int)0x2010:

              case (unsigned long int)0x2011:

              case (unsigned long int)0x2012:

              case (unsigned long int)0x2013:

              case (unsigned long int)0x2014:

              case (unsigned long int)0x2015:
              {
                uc = (unsigned long int)45;
                break;
              }
              case (unsigned long int)0x2018:

              case (unsigned long int)0x2019:

              case (unsigned long int)0x201A:

              case (unsigned long int)0x201B:
              {
                uc = (unsigned long int)39;
                break;
              }
              case (unsigned long int)0x201C:

              case (unsigned long int)0x201D:

              case (unsigned long int)0x201E:

              case (unsigned long int)0x201F:
              {
                uc = (unsigned long int)34;
                break;
              }
              case (unsigned long int)0x2022:
              {
                uc = (unsigned long int)-73;
                break;
              }
              case (unsigned long int)0x2023:
              {
                uc = (unsigned long int)-69;
                break;
              }
              case (unsigned long int)0x2027:
              {
                uc = (unsigned long int)-73;
                break;
              }
              case (unsigned long int)0x202F:
              {
                uc = (unsigned long int)32;
                break;
              }
              case (unsigned long int)0x2038:
              {
                uc = (unsigned long int)94;
                break;
              }
              case (unsigned long int)0x2039:
              {
                uc = (unsigned long int)-85;
                break;
              }
              case (unsigned long int)0x203A:
              {
                uc = (unsigned long int)-69;
                break;
              }
              case (unsigned long int)0x2041:
              {
                uc = (unsigned long int)94;
                break;
              }
              case (unsigned long int)0x2042:
              {
                uc = (unsigned long int)42;
                break;
              }
              case (unsigned long int)0x2043:
              {
                uc = (unsigned long int)61;
                break;
              }
              case (unsigned long int)0x2044:
              {
                uc = (unsigned long int)47;
                break;
              }
              case (unsigned long int)0x204B:
              {
                uc = (unsigned long int)-74;
                break;
              }
              case (unsigned long int)0x204C:
              {
                uc = (unsigned long int)-73;
                break;
              }
              case (unsigned long int)0x204D:
              {
                uc = (unsigned long int)-73;
                break;
              }
              case (unsigned long int)0x204E:
              {
                uc = (unsigned long int)42;
                break;
              }
              case (unsigned long int)0x204F:
                uc = (unsigned long int)59;
            }

      if(uc >= 256ul)
        uc = (unsigned long int)(ascii_p != 0 ? 35 : -65);

      if(!(ascii_p == 0))
      {
        const unsigned char latin1_to_ascii[96l] = { ' ', '!', 'C', '#', '#', 'Y', '|', 'S', '_', 'C', '#', '<', '=', '-', 'R', '_', '#', '#', '2', '3', '\'', 'u', 'P', '.', ',', '1', 'o', '>', '#', '#', '#', '?', 'A', 'A', 'A', 'A', 'A', 'A', 'E', 'C', 'E', 'E', 'E', 'E', 'I', 'I', 'I', 'I', 'D', 'N', 'O', 'O', 'O', 'O', 'O', 'x', '0', 'U', 'U', 'U', 'U', 'Y', 'p', 'S', 'a', 'a', 'a', 'a', 'a', 'a', 'e', 'c', 'e', 'e', 'e', 'e', 'i', 'i', 'i', 'i', 'o', 'n', 'o', 'o', 'o', 'o', 'o', '/', 'o', 'u', 'u', 'u', 'u', 'y', 'p', 'y' };
        if(uc >= 160ul)
          uc = (unsigned long int)latin1_to_ascii[(signed long int)(uc - (unsigned long int)0xA0)];

      }

      if(uc >= 1ul)
      {
        unsigned char *tmp_post_3 = out;
        out = out + 1l;
        *tmp_post_3 = (unsigned char)uc;
      }

    }
    *out = (unsigned char)0;
    void *return_value_realloc_4;
    return_value_realloc_4=realloc((void *)ret, (unsigned long int)((out - ret) + (signed long int)1) * sizeof(unsigned char) /*1ul*/ );
    ret = (unsigned char *)return_value_realloc_4;
    return (char *)ret;
  }
}

// validate_gl_visual
// file ./../../utils/visual.h line 31
extern signed int validate_gl_visual(struct _IO_FILE *out, struct anonymous_58 *screen, const char *window_desc, struct anonymous_59 *visual)
{
  signed int status;
  signed int value = 0;
  struct _XDisplay *dpy = screen->display;
  struct anonymous_62 vi_in;
  struct anonymous_62 *vi_out;
  signed int out_count;
  unsigned int id;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_62 *)NULL))
    abort();

  status=glXGetConfig(dpy, vi_out, 1, &value);
  id = (unsigned int)vi_out->visualid;
  XFree((void *)(char *)vi_out);
  if(status == 3)
  {
    fprintf(out, "%s: display \"%s\" does not support the GLX extension.\n", progname, ((struct anonymous_0 *)dpy)->display_name);
    return 0;
  }

  else
    if(status == 4 || value == 0)
    {
      fprintf(out, "%s: %s's visual 0x%x does not support the GLX extension.\n", progname, window_desc, id);
      return 0;
    }

    else
      return 1;
}

// visual_cells
// file visual.c line 487
extern signed int visual_cells(struct anonymous_58 *screen, struct anonymous_59 *visual)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_62 vi_in;
  struct anonymous_62 *vi_out;
  signed int out_count;
  signed int c;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_62 *)NULL))
    abort();

  c = (vi_out + (signed long int)0)->colormap_size;
  XFree((void *)(char *)vi_out);
  return c;
}

// visual_class
// file visual.c line 409
extern signed int visual_class(struct anonymous_58 *screen, struct anonymous_59 *visual)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_62 vi_in;
  struct anonymous_62 *vi_out;
  signed int out_count;
  signed int c;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_62 *)NULL))
    abort();

  c = (vi_out + (signed long int)0)->class;
  XFree((void *)(char *)vi_out);
  return c;
}

// visual_depth
// file ./../utils/visual.h line 17
extern signed int visual_depth(struct anonymous_58 *screen, struct anonymous_59 *visual)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_62 vi_in;
  struct anonymous_62 *vi_out;
  signed int out_count;
  signed int d;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_62 *)NULL))
    abort();

  d = (vi_out + (signed long int)0)->depth;
  XFree((void *)(char *)vi_out);
  return d;
}

// visual_warning
// file screenhack.c line 341
static void visual_warning(struct anonymous_58 *screen, unsigned long int window, struct anonymous_59 *visual, unsigned long int cmap, signed int window_p)
{
  struct xscreensaver_function_table *ft = xscreensaver_function_table;
  char *visual_string;
  visual_string=get_string_resource(screen->display, "visualID", "VisualID");
  struct anonymous_59 *desired_visual;
  desired_visual=pick_visual(screen);
  char win[100l];
  char why[100l];
  unsigned long int return_value_VirtualRootWindowOfScreen_1;
  return_value_VirtualRootWindowOfScreen_1=VirtualRootWindowOfScreen(screen);
  if(window == return_value_VirtualRootWindowOfScreen_1)
    strcpy(win, "root window");

  else
    sprintf(win, "window 0x%lx", (unsigned long int)window);
  if(!(window_p == 0))
    sprintf(why, "-window-id 0x%lx", (unsigned long int)window);

  else
    strcpy(why, "-root");
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_6;
  if(!(visual_string == ((char *)NULL)))
  {
    if(!(*visual_string == 0))
    {
      char *s = visual_string;
      for( ; !(*s == 0); s = s + 1l)
        if((signed int)*s >= 65)
        {
          if(!((signed int)*s >= 91))
            *s = (char)(((signed int)*s - 65) + 97);

        }

      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(visual_string, "default");
      _Bool tmp_if_expr_5;
      if(return_value_strcmp_3 == 0)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_strcmp_4=strcmp(visual_string, "default");
        tmp_if_expr_5 = !(return_value_strcmp_4 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_7;
      if(tmp_if_expr_5)
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_strcmp_6=strcmp(visual_string, "best");
        tmp_if_expr_7 = !(return_value_strcmp_6 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_7)
      {
        if(!(visual == desired_visual))
        {
          fprintf(stderr, "%s: ignoring `-visual %s' because of `%s'.\n", progname, visual_string, (const void *)why);
          unsigned long int return_value_XVisualIDFromVisual_2;
          return_value_XVisualIDFromVisual_2=XVisualIDFromVisual(visual);
          fprintf(stderr, "%s: using %s's visual 0x%lx.\n", progname, (const void *)win, return_value_XVisualIDFromVisual_2);
        }

      }

      free((void *)visual_string);
    }

  }

  signed int return_value_has_writable_cells_9;
  signed int return_value_get_boolean_resource_8;
  if(visual == screen->root_visual)
  {
    return_value_has_writable_cells_9=has_writable_cells(screen, visual);
    if(!(return_value_has_writable_cells_9 == 0))
    {
      return_value_get_boolean_resource_8=get_boolean_resource(screen->display, "installColormap", "InstallColormap");
      if(!(return_value_get_boolean_resource_8 == 0))
      {
        fprintf(stderr, "%s: ignoring `-install' because of `%s'.\n", progname, (const void *)why);
        fprintf(stderr, "%s: using %s's colormap 0x%lx.\n", progname, (const void *)win, (unsigned long int)cmap);
      }

    }

  }

  if(!(ft->validate_visual_hook == ((signed int (*)(struct anonymous_58 *, const char *, struct anonymous_59 *))NULL)))
  {
    signed int return_value;
    return_value=ft->validate_visual_hook(screen, win, visual);
    if(return_value == 0)
      exit(1);

  }

}

// xlockmore_do_fps
// file ./../xlockmore.c line 533
extern void xlockmore_do_fps(struct _XDisplay *dpy, unsigned long int w, struct fps_state *fpst, void *closure)
{
  struct ModeInfo *mi = (struct ModeInfo *)closure;
  double tmp_if_expr_1;
  if(!(mi == ((struct ModeInfo *)NULL)))
    tmp_if_expr_1 = mi->recursion_depth;

  else
    tmp_if_expr_1 = (double)-1;
  fps_compute(fpst, (unsigned long int)0, tmp_if_expr_1);
  fps_draw(fpst);
}

// xlockmore_draw
// file ./../xlockmore.c line 495
static unsigned long int xlockmore_draw(struct _XDisplay *dpy, unsigned long int window, void *closure)
{
  struct ModeInfo *mi = (struct ModeInfo *)closure;
  unsigned long int orig_pause = (unsigned long int)mi->pause;
  unsigned long int this_pause;
  mi->xlmft->hack_draw(mi);
  this_pause = (unsigned long int)mi->pause;
  mi->pause = (signed long int)orig_pause;
  return this_pause;
}

// xlockmore_event
// file ./../xlockmore.c line 523
static signed int xlockmore_event(struct _XDisplay *dpy, unsigned long int window, void *closure, union _XEvent *event)
{
  struct ModeInfo *mi = (struct ModeInfo *)closure;
  _Bool tmp_if_expr_1;
  if(!(mi == ((struct ModeInfo *)NULL)))
    tmp_if_expr_1 = mi->xlmft->hack_handle_events != ((signed int (*)(struct ModeInfo *, union _XEvent *))NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  signed int return_value;
  if(tmp_if_expr_1)
  {
    return_value=mi->xlmft->hack_handle_events(mi, event);
    return return_value;
  }

  else
    return 0;
}

// xlockmore_free
// file ./../xlockmore.c line 542
static void xlockmore_free(struct _XDisplay *dpy, unsigned long int window, void *closure)
{
  ;
}

// xlockmore_gl_compute_fps
// file ./../xlockmoreI.h line 74
extern void xlockmore_gl_compute_fps(struct _XDisplay *dpy, unsigned long int w, struct fps_state *fpst, void *closure)
{
  struct ModeInfo *mi = (struct ModeInfo *)closure;
  if(mi->fpst == ((struct fps_state *)NULL))
  {
    mi->fpst = fpst;
    xlockmore_gl_fps_init(fpst);
  }

  fps_compute(fpst, mi->polygon_count, mi->recursion_depth);
}

// xlockmore_gl_draw_fps
// file ./../xlockmoreI.h line 75
extern void xlockmore_gl_draw_fps(struct ModeInfo *mi)
{
  struct fps_state *st = mi->fpst;
  if(!(st == ((struct fps_state *)NULL)))
  {
    struct anonymous_5 *data = (struct anonymous_5 *)st->gl_fps_data;
    struct anonymous_65 xgwa;
    signed int lines = 1;
    const char *s;
    signed int y = st->y;
    XGetWindowAttributes(st->dpy, st->window, &xgwa);
    s = st->string;
    for( ; !(*s == 0); s = s + 1l)
      if((signed int)*s == 10)
        lines = lines + 1;

    if(!(y >= 0))
      y = (xgwa.height + y) - lines * data->line_height;

    y = y + lines * data->line_height;
    glColor3f((float)1, (float)1, (float)1);
    print_texture_label(st->dpy, data->texfont, xgwa.width, xgwa.height, data->top_p != 0 ? 1 : 2, st->string);
  }

}

// xlockmore_gl_fps_init
// file fps-gl.c line 46
static void xlockmore_gl_fps_init(struct fps_state *st)
{
  struct anonymous_5 *data;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_5) /*16ul*/ );
  data = (struct anonymous_5 *)return_value_calloc_1;
  signed int ascent;
  signed int descent;
  data->top_p=get_boolean_resource(st->dpy, "fpsTop", "FPSTop");
  data->texfont=load_texture_font(st->dpy, "fpsFont");
  texture_string_metrics(data->texfont, "M", ((struct anonymous_11 *)NULL), &ascent, &descent);
  data->line_height = ascent + descent;
  st->gl_fps_data = (void *)data;
}

// xlockmore_init
// file ./../xlockmore.c line 278
static void * xlockmore_init(struct _XDisplay *dpy, unsigned long int window, struct xlockmore_function_table *xlmft)
{
  struct ModeInfo *mi;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ModeInfo) /*392ul*/ );
  mi = (struct ModeInfo *)return_value_calloc_1;
  struct anonymous_34 gcv;
  struct anonymous_36 color;
  signed int i;
  signed int root_p;
  if(xlmft == ((struct xlockmore_function_table *)NULL))
    abort();

  mi->xlmft = xlmft;
  mi->dpy = dpy;
  mi->window = window;
  XGetWindowAttributes(dpy, window, &mi->xgwa);
  mi->num_screens = 1;
  mi->screen_number = 0;
  mi->num_screens = mi->num_screens + 1;
  static signed int screen_tick = 0;
  if(!(screen_tick == 0))
    mi->screen_number = mi->screen_number + 1;

  screen_tick = screen_tick + 1;
  root_p = (signed int)(window == mi->xgwa.screen->root);
  XSelectInput(dpy, window, mi->xgwa.your_event_mask | 1L << 6);
  color.flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
  color.blue = (unsigned short int)0;
  color.green = color.blue;
  color.red = color.green;
  signed int return_value_XAllocColor_2;
  return_value_XAllocColor_2=XAllocColor(dpy, mi->xgwa.colormap, &color);
  if(return_value_XAllocColor_2 == 0)
    abort();

  mi->black = color.pixel;
  color.blue = (unsigned short int)0xFFFF;
  color.green = color.blue;
  color.red = color.green;
  signed int return_value_XAllocColor_3;
  return_value_XAllocColor_3=XAllocColor(dpy, mi->xgwa.colormap, &color);
  if(return_value_XAllocColor_3 == 0)
    abort();

  mi->white = color.pixel;
  void *return_value_calloc_4;
  void *return_value_calloc_5;
  if(!(mono_p == 0))
  {

  MONO:
    ;
    mi->npixels = 2;
    if(mi->pixels == ((unsigned long int *)NULL))
    {
      return_value_calloc_4=calloc((unsigned long int)mi->npixels, sizeof(unsigned long int) /*8ul*/ );
      mi->pixels = (unsigned long int *)return_value_calloc_4;
    }

    if(mi->colors == ((struct anonymous_36 *)NULL))
    {
      return_value_calloc_5=calloc((unsigned long int)mi->npixels, sizeof(struct anonymous_36) /*16ul*/ );
      mi->colors = (struct anonymous_36 *)return_value_calloc_5;
    }

    static unsigned long int pixels[2l];
    pixels[(signed long int)0] = mi->black;
    pixels[(signed long int)1] = mi->white;
    static struct anonymous_36 colors[2l];
    colors[(signed long int)0].flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
    colors[(signed long int)1].flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
    colors[(signed long int)0].blue = (unsigned short int)0;
    colors[(signed long int)0].green = colors[(signed long int)0].blue;
    colors[(signed long int)0].red = colors[(signed long int)0].green;
    colors[(signed long int)1].blue = (unsigned short int)0xFFFF;
    colors[(signed long int)1].green = colors[(signed long int)1].blue;
    colors[(signed long int)1].red = colors[(signed long int)1].green;
    mi->writable_p = 0;
  }

  else
  {
    mi->npixels=get_integer_resource(dpy, "ncolors", "Integer");
    if(!(mi->npixels >= 1))
      mi->npixels = 64;

    else
      if((signed long int)mi->npixels >= 8193l)
        mi->npixels = (signed int)(1L << 13);

    void *return_value_calloc_6;
    return_value_calloc_6=calloc((unsigned long int)mi->npixels, sizeof(struct anonymous_36) /*16ul*/ );
    mi->colors = (struct anonymous_36 *)return_value_calloc_6;
    mi->writable_p = mi->xlmft->want_writable_colors;
    switch((signed int)mi->xlmft->desired_color_scheme)
    {
      case color_scheme_uniform:
      {
        make_uniform_colormap(mi->xgwa.screen, mi->xgwa.visual, mi->xgwa.colormap, mi->colors, &mi->npixels, 1, &mi->writable_p, 1);
        break;
      }
      case color_scheme_smooth:
      {
        make_smooth_colormap(mi->xgwa.screen, mi->xgwa.visual, mi->xgwa.colormap, mi->colors, &mi->npixels, 1, &mi->writable_p, 1);
        break;
      }
      case color_scheme_bright:

      case color_scheme_default:
      {
        make_random_colormap(mi->xgwa.screen, mi->xgwa.visual, mi->xgwa.colormap, mi->colors, &mi->npixels, (signed int)((signed int)mi->xlmft->desired_color_scheme == color_scheme_bright), 1, &mi->writable_p, 1);
        break;
      }
      default:
        abort();
    }
    if(!(mi->npixels >= 3))
      goto MONO;

    else
    {
      void *return_value_calloc_7;
      return_value_calloc_7=calloc((unsigned long int)mi->npixels, sizeof(unsigned long int) /*8ul*/ );
      mi->pixels = (unsigned long int *)return_value_calloc_7;
      i = 0;
      for( ; !(i >= mi->npixels); i = i + 1)
        mi->pixels[(signed long int)i] = (mi->colors + (signed long int)i)->pixel;
    }
  }
  gcv.foreground = mi->white;
  gcv.background = mi->black;
  mi->gc=XCreateGC(dpy, window, (unsigned long int)(1L << 2 | 1L << 3), &gcv);
  mi->fullrandom = 1;
  signed int return_value_get_integer_resource_8;
  return_value_get_integer_resource_8=get_integer_resource(dpy, "delay", "Usecs");
  mi->pause = (signed long int)return_value_get_integer_resource_8;
  signed int return_value_get_integer_resource_9;
  return_value_get_integer_resource_9=get_integer_resource(dpy, "cycles", "Int");
  mi->cycles = (signed long int)return_value_get_integer_resource_9;
  signed int return_value_get_integer_resource_10;
  return_value_get_integer_resource_10=get_integer_resource(dpy, "count", "Int");
  mi->batchcount = (signed long int)return_value_get_integer_resource_10;
  signed int return_value_get_integer_resource_11;
  return_value_get_integer_resource_11=get_integer_resource(dpy, "size", "Int");
  mi->size = (signed long int)return_value_get_integer_resource_11;
  mi->threed=get_boolean_resource(dpy, "use3d", "Boolean");
  double return_value_get_float_resource_12;
  return_value_get_float_resource_12=get_float_resource(dpy, "delta3d", "Float");
  mi->threed_delta = (signed long int)return_value_get_float_resource_12;
  unsigned int return_value_get_pixel_resource_13;
  return_value_get_pixel_resource_13=get_pixel_resource(dpy, mi->xgwa.colormap, "right3d", "Color");
  mi->threed_right_color = (signed long int)return_value_get_pixel_resource_13;
  unsigned int return_value_get_pixel_resource_14;
  return_value_get_pixel_resource_14=get_pixel_resource(dpy, mi->xgwa.colormap, "left3d", "Color");
  mi->threed_left_color = (signed long int)return_value_get_pixel_resource_14;
  unsigned int return_value_get_pixel_resource_15;
  return_value_get_pixel_resource_15=get_pixel_resource(dpy, mi->xgwa.colormap, "both3d", "Color");
  mi->threed_both_color = (signed long int)return_value_get_pixel_resource_15;
  unsigned int return_value_get_pixel_resource_16;
  return_value_get_pixel_resource_16=get_pixel_resource(dpy, mi->xgwa.colormap, "none3d", "Color");
  mi->threed_none_color = (signed long int)return_value_get_pixel_resource_16;
  mi->wireframe_p=get_boolean_resource(dpy, "wireframe", "Boolean");
  mi->root_p = root_p;
  mi->use_shm=get_boolean_resource(dpy, "useSHM", "Boolean");
  mi->fps_p=get_boolean_resource(dpy, "doFPS", "DoFPS");
  mi->recursion_depth = (double)-1;
  if(!(mi->pause >= 0l))
    mi->pause = (signed long int)0;

  else
    if(mi->pause >= 100000001l)
      mi->pause = (signed long int)100000000;

  char *name;
  name=get_string_resource(dpy, "font", "Font");
  if(!(name == ((char *)NULL)))
  {
    struct anonymous_13 *f;
    f=XLoadQueryFont(dpy, name);
    const char *def1 = "-*-helvetica-bold-r-normal-*-180-*";
    const char *def2 = "fixed";
    if(f == ((struct anonymous_13 *)NULL))
    {
      fprintf(stderr, "%s: font %s does not exist, using %s\n", progname, name, def1);
      f=XLoadQueryFont(dpy, def1);
    }

    if(f == ((struct anonymous_13 *)NULL))
    {
      fprintf(stderr, "%s: font %s does not exist, using %s\n", progname, def1, def2);
      f=XLoadQueryFont(dpy, def2);
    }

    if(!(f == ((struct anonymous_13 *)NULL)))
      XSetFont(dpy, mi->gc, f->fid);

    if(!(f == ((struct anonymous_13 *)NULL)))
      XFreeFont(dpy, f);

    free((void *)name);
  }

  xlockmore_read_resources(mi);
  XClearWindow(dpy, window);
  mi->xlmft->hack_init(mi);
  return (void *)mi;
}

// xlockmore_pick_gl_visual
// file ./../xlockmoreI.h line 66
extern struct anonymous_59 * xlockmore_pick_gl_visual(struct anonymous_58 *screen)
{
  struct anonymous_59 *v = ((struct anonymous_59 *)NULL);
  struct _XDisplay *dpy = screen->display;
  char *string;
  string=get_string_resource(dpy, "visualID", "VisualID");
  char *s;
  if(!(string == ((char *)NULL)))
  {
    s = string;
    for( ; !(*s == 0); s = s + 1l)
      if((signed int)*s >= 65)
      {
        if(!((signed int)*s >= 91))
          *s = (char)(((signed int)*s - 65) + 97);

      }

  }

  _Bool tmp_if_expr_1;
  if(string == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*string != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(tmp_if_expr_1)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strcmp_2=strcmp(string, "gl");
    tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  signed int return_value_strcmp_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_strcmp_4=strcmp(string, "best");
    tmp_if_expr_5 = !(return_value_strcmp_4 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_7;
  signed int return_value_strcmp_6;
  if(tmp_if_expr_5)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_strcmp_6=strcmp(string, "color");
    tmp_if_expr_7 = !(return_value_strcmp_6 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_9;
  signed int return_value_strcmp_8;
  if(tmp_if_expr_7)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    return_value_strcmp_8=strcmp(string, "default");
    tmp_if_expr_9 = !(return_value_strcmp_8 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_9)
    v=get_gl_visual(screen);

  if(!(string == ((char *)NULL)))
    free((void *)string);

  return v;
}

// xlockmore_read_resources
// file ./../xlockmore.c line 239
static void xlockmore_read_resources(struct ModeInfo *mi)
{
  struct _XDisplay *dpy = mi->dpy;
  struct anonymous_16 *xlockmore_opts = mi->xlmft->opts;
  signed int i = 0;
  double return_value_get_float_resource_1;
  for( ; !(i >= xlockmore_opts->numvarsdesc); i = i + 1)
  {
    void *var = (xlockmore_opts->vars + (signed long int)i)->var;
    signed int *var_b = (signed int *)var;
    char **var_c = (char **)var;
    signed int *var_i = (signed int *)var;
    float *var_f = (float *)var;
    switch((signed int)(xlockmore_opts->vars + (signed long int)i)->type)
    {
      case t_String:
      {
        *var_c=get_string_resource(dpy, (xlockmore_opts->vars + (signed long int)i)->name, (xlockmore_opts->vars + (signed long int)i)->classname);
        break;
      }
      case t_Float:
      {
        return_value_get_float_resource_1=get_float_resource(dpy, (xlockmore_opts->vars + (signed long int)i)->name, (xlockmore_opts->vars + (signed long int)i)->classname);
        *var_f = (float)return_value_get_float_resource_1;
        break;
      }
      case t_Int:
      {
        *var_i=get_integer_resource(dpy, (xlockmore_opts->vars + (signed long int)i)->name, (xlockmore_opts->vars + (signed long int)i)->classname);
        break;
      }
      case t_Bool:
      {
        *var_b=get_boolean_resource(dpy, (xlockmore_opts->vars + (signed long int)i)->name, (xlockmore_opts->vars + (signed long int)i)->classname);
        break;
      }
      default:
        abort();
    }
  }
}

// xlockmore_reshape
// file ./../xlockmore.c line 511
static void xlockmore_reshape(struct _XDisplay *dpy, unsigned long int window, void *closure, unsigned int w, unsigned int h)
{
  struct ModeInfo *mi = (struct ModeInfo *)closure;
  if(!(mi == ((struct ModeInfo *)NULL)))
  {
    if(!(mi->xlmft->hack_reshape == ((void (*)(struct ModeInfo *, signed int, signed int))NULL)))
    {
      XGetWindowAttributes(dpy, window, &mi->xgwa);
      mi->xlmft->hack_reshape(mi, mi->xgwa.width, mi->xgwa.height);
    }

  }

}

// xlockmore_setup
// file ./../xlockmoreI.h line 79
extern void xlockmore_setup(struct xscreensaver_function_table *xsft, void *arg)
{
  struct xlockmore_function_table *xlmft = (struct xlockmore_function_table *)arg;
  signed int i;
  signed int j;
  char *s;
  struct anonymous_51 *new_options;
  char **new_defaults;
  const char *xlockmore_defaults;
  struct anonymous_16 *xlockmore_opts = xlmft->opts;
  ya_rand_init((unsigned int)0);
  xsft->init_cb = (void * (*)(struct _XDisplay *, unsigned long int))xlockmore_init;
  xsft->draw_cb = xlockmore_draw;
  xsft->reshape_cb = xlockmore_reshape;
  xsft->event_cb = xlockmore_event;
  xsft->free_cb = xlockmore_free;
  progclass = xlmft->progclass;
  xlockmore_defaults = xlmft->defaults;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)(xlockmore_opts->numopts * 3 + 100), sizeof(struct anonymous_51) /*32ul*/ );
  new_options = (struct anonymous_51 *)return_value_calloc_1;
  i = 0;
  for( ; !(i >= xlockmore_opts->numopts); i = i + 1)
  {
    struct anonymous_51 *xlockmore_setup__1__1__old = &xlockmore_opts->opts[(signed long int)i];
    struct anonymous_51 *xlockmore_setup__1__1__new = &new_options[(signed long int)i];
    if((signed int)*xlockmore_setup__1__1__old->option == 45)
      xlockmore_setup__1__1__new->option = xlockmore_setup__1__1__old->option;

    else
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(xlockmore_setup__1__1__old->option);
      void *return_value_malloc_3;
      return_value_malloc_3=malloc(return_value_strlen_2 + (unsigned long int)5);
      xlockmore_setup__1__1__new->option = (char *)return_value_malloc_3;
      strcpy(xlockmore_setup__1__1__new->option, "-no-");
      strcat(xlockmore_setup__1__1__new->option, xlockmore_setup__1__1__old->option + (signed long int)1);
    }
    xlockmore_setup__1__1__new->specifier=strrchr(xlockmore_setup__1__1__old->specifier, 46);
    if(xlockmore_setup__1__1__new->specifier == ((char *)NULL))
      abort();

    xlockmore_setup__1__1__new->argKind = xlockmore_setup__1__1__old->argKind;
    xlockmore_setup__1__1__new->value = xlockmore_setup__1__1__old->value;
  }
  char *args[9l] = { "-count", "-cycles", "-delay", "-ncolors", "-size", "-font", "-wireframe", "-use3d", "-useSHM" };
  j = 0;
  char *return_value_strstr_11;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_8;
  for( ; !((unsigned long int)j >= 9ul); j = j + 1)
  {
    return_value_strstr_11=strstr(xlockmore_defaults, args[(signed long int)j] + (signed long int)1);
    if(!(return_value_strstr_11 == ((char *)NULL)))
    {
      struct anonymous_51 *new;
      signed int tmp_post_4 = i;
      i = i + 1;
      new = &new_options[(signed long int)tmp_post_4];
      new->option = args[(signed long int)j];
      new->specifier=strdup(args[(signed long int)j]);
      new->specifier[(signed long int)0] = (char)46;
      signed int return_value_strcmp_10;
      return_value_strcmp_10=strcmp(new->option, "-wireframe");
      if(return_value_strcmp_10 == 0)
      {
        new->argKind = (enum anonymous_57)XrmoptionNoArg;
        new->value = "True";
        signed int tmp_post_5 = i;
        i = i + 1;
        new = &new_options[(signed long int)tmp_post_5];
        new->option = "-no-wireframe";
        new->specifier = (new_options + (signed long int)(i - 2))->specifier;
        new->argKind = (enum anonymous_57)XrmoptionNoArg;
        new->value = "False";
      }

      else
      {
        return_value_strcmp_9=strcmp(new->option, "-use3d");
        if(return_value_strcmp_9 == 0)
        {
          new->option = "-3d";
          new->argKind = (enum anonymous_57)XrmoptionNoArg;
          new->value = "True";
          signed int tmp_post_6 = i;
          i = i + 1;
          new = &new_options[(signed long int)tmp_post_6];
          new->option = "-no-3d";
          new->specifier = (new_options + (signed long int)(i - 2))->specifier;
          new->argKind = (enum anonymous_57)XrmoptionNoArg;
          new->value = "False";
        }

        else
        {
          return_value_strcmp_8=strcmp(new->option, "-useSHM");
          if(return_value_strcmp_8 == 0)
          {
            new->option = "-shm";
            new->argKind = (enum anonymous_57)XrmoptionNoArg;
            new->value = "True";
            signed int tmp_post_7 = i;
            i = i + 1;
            new = &new_options[(signed long int)tmp_post_7];
            new->option = "-no-shm";
            new->specifier = (new_options + (signed long int)(i - 2))->specifier;
            new->argKind = (enum anonymous_57)XrmoptionNoArg;
            new->value = "False";
          }

          else
          {
            new->argKind = (enum anonymous_57)XrmoptionSepArg;
            new->value = ((char *)NULL);
          }
        }
      }
    }

  }
  i = 0;
  void *return_value_calloc_12;
  return_value_calloc_12=calloc((unsigned long int)1, (unsigned long int)(xlockmore_opts->numvarsdesc * 10 + 1000));
  new_defaults = (char **)return_value_calloc_12;
  void *return_value_malloc_13;
  return_value_malloc_13=malloc((unsigned long int)50);
  s = (char *)return_value_malloc_13;
  *s = (char)0;
  strcpy(s, progclass);
  strcat(s, ".background: black");
  signed int tmp_post_14 = i;
  i = i + 1;
  new_defaults[(signed long int)tmp_post_14] = s;
  void *return_value_malloc_15;
  return_value_malloc_15=malloc((unsigned long int)50);
  s = (char *)return_value_malloc_15;
  *s = (char)0;
  strcpy(s, progclass);
  strcat(s, ".foreground: white");
  signed int tmp_post_16 = i;
  i = i + 1;
  new_defaults[(signed long int)tmp_post_16] = s;
  s=strdup(xlockmore_defaults);
  while(!(s == ((char *)NULL)))
  {
    if(*s == 0)
      break;

    signed int tmp_post_17 = i;
    i = i + 1;
    new_defaults[(signed long int)tmp_post_17] = s;
    s=strchr(s, 10);
    if(!(s == ((char *)NULL)))
    {
      char *tmp_post_18 = s;
      s = s + 1l;
      *tmp_post_18 = (char)0;
    }

  }
  j = 0;
  for( ; !(j >= xlockmore_opts->numvarsdesc); j = j + 1)
  {
    const char *def = (xlockmore_opts->vars + (signed long int)j)->def;
    if(def == ((const char *)NULL))
      abort();

    if(*def == 0)
      abort();

    unsigned long int return_value_strlen_19;
    return_value_strlen_19=strlen(def);
    if(return_value_strlen_19 >= 1001ul)
      abort();

    unsigned long int return_value_strlen_20;
    return_value_strlen_20=strlen((xlockmore_opts->vars + (signed long int)j)->name);
    unsigned long int return_value_strlen_21;
    return_value_strlen_21=strlen(def);
    void *return_value_malloc_22;
    return_value_malloc_22=malloc(return_value_strlen_20 + return_value_strlen_21 + (unsigned long int)10);
    s = (char *)return_value_malloc_22;
    strcpy(s, "*");
    strcat(s, (xlockmore_opts->vars + (signed long int)j)->name);
    strcat(s, ": ");
    strcat(s, def);
    signed int tmp_post_23 = i;
    i = i + 1;
    new_defaults[(signed long int)tmp_post_23] = s;
    char *onew;
    onew=strdup((xlockmore_opts->vars + (signed long int)j)->name);
    const char *xlockmore_setup__1__4__1__new = onew;
    signed int k;
    s=strrchr(xlockmore_setup__1__4__1__new, 46);
    if(!(s == ((char *)NULL)))
      xlockmore_setup__1__4__1__new = s + (signed long int)1;

    s=strrchr(xlockmore_setup__1__4__1__new, 42);
    if(!(s == ((char *)NULL)))
      xlockmore_setup__1__4__1__new = s + (signed long int)1;

    k = 0;
    for( ; !(k >= i + -1); k = k + 1)
    {
      char *oold;
      oold=strdup(new_defaults[(signed long int)k]);
      const char *old = oold;
      s=strchr(oold, 58);
      if(!(s == ((char *)NULL)))
        *s = (char)0;

      s=strrchr(old, 46);
      if(!(s == ((char *)NULL)))
        old = s + (signed long int)1;

      s=strrchr(old, 42);
      if(!(s == ((char *)NULL)))
        old = s + (signed long int)1;

      signed int return_value_strcasecmp_24;
      return_value_strcasecmp_24=strcasecmp(old, xlockmore_setup__1__4__1__new);
      if(return_value_strcasecmp_24 == 0)
        fprintf(stderr, "%s: duplicate resource \"%s\": set in both DEFAULTS and vars[]\n", progname, old);

      free((void *)oold);
    }
    free((void *)onew);
  }
  new_defaults[(signed long int)i] = ((char *)NULL);
  xsft->progclass = progclass;
  xsft->options = new_options;
  xsft->defaults = (const char * const *)new_defaults;
}

// xlockmore_validate_gl_visual
// file ./../xlockmoreI.h line 67
extern signed int xlockmore_validate_gl_visual(struct anonymous_58 *screen, const char *name, struct anonymous_59 *visual)
{
  signed int return_value_validate_gl_visual_1;
  return_value_validate_gl_visual_1=validate_gl_visual(stderr, screen, name, visual);
  return return_value_validate_gl_visual_1;
}

// xpm_file_to_ximage
// file xpm-ximage.c line 463
extern struct _XImage * xpm_file_to_ximage(struct _XDisplay *dpy, struct anonymous_59 *visual, unsigned long int cmap, const char *filename)
{
  struct _XImage *return_value_xpm_to_ximage_1_1;
  return_value_xpm_to_ximage_1_1=xpm_to_ximage_1(dpy, visual, cmap, filename, ((char **)NULL));
  return return_value_xpm_to_ximage_1_1;
}

// xpm_to_ximage
// file xpm-ximage.h line 26
extern struct _XImage * xpm_to_ximage(struct _XDisplay *dpy, struct anonymous_59 *visual, unsigned long int cmap, char **xpm_data)
{
  struct _XImage *return_value_xpm_to_ximage_1_1;
  return_value_xpm_to_ximage_1_1=xpm_to_ximage_1(dpy, visual, cmap, ((const char *)NULL), xpm_data);
  return return_value_xpm_to_ximage_1_1;
}

// xpm_to_ximage_1
// file xpm-ximage.c line 68
static struct _XImage * xpm_to_ximage_1(struct _XDisplay *dpy, struct anonymous_59 *visual, unsigned long int cmap, const char *filename, char **xpm_data)
{
  struct _GdkPixbuf *pb;
  struct _GError *gerr = (struct _GError *)(void *)0;
  static signed int initted = 0;
  if(initted == 0)
  {
    gdk_pixbuf_xlib_init(dpy, ((struct anonymous_0 *)dpy)->default_screen);
    xlib_rgb_init(dpy, &((struct anonymous_0 *)dpy)->screens[(signed long int)((struct anonymous_0 *)dpy)->default_screen]);
    initted = 1;
  }

  struct _GdkPixbuf *tmp_if_expr_3;
  struct _GdkPixbuf *return_value_gdk_pixbuf_new_from_file_1;
  struct _GdkPixbuf *return_value_gdk_pixbuf_new_from_xpm_data_2;
  if(!(filename == ((const char *)NULL)))
  {
    return_value_gdk_pixbuf_new_from_file_1=gdk_pixbuf_new_from_file(filename, &gerr);
    tmp_if_expr_3 = return_value_gdk_pixbuf_new_from_file_1;
  }

  else
  {
    return_value_gdk_pixbuf_new_from_xpm_data_2=gdk_pixbuf_new_from_xpm_data((const char **)xpm_data);
    tmp_if_expr_3 = return_value_gdk_pixbuf_new_from_xpm_data_2;
  }
  pb = tmp_if_expr_3;
  if(!(pb == ((struct _GdkPixbuf *)NULL)))
  {
    struct _XImage *image;
    signed int w;
    w=gdk_pixbuf_get_width(pb);
    signed int h;
    h=gdk_pixbuf_get_height(pb);
    unsigned char *row;
    row=gdk_pixbuf_get_pixels(pb);
    signed int stride;
    stride=gdk_pixbuf_get_rowstride(pb);
    signed int chan;
    chan=gdk_pixbuf_get_n_channels(pb);
    signed int x;
    signed int y;
    image=XCreateImage(dpy, visual, (unsigned int)32, 2, 0, ((char *)NULL), (unsigned int)w, (unsigned int)h, 32, 0);
    void *return_value_malloc_4;
    return_value_malloc_4=malloc((unsigned long int)(h * image->bytes_per_line));
    image->data = (char *)return_value_malloc_4;
    signed int return_value_bigendian_5;
    return_value_bigendian_5=bigendian();
    image->byte_order = return_value_bigendian_5 != 0 ? 1 : 0;
    image->bitmap_bit_order = image->byte_order;
    if(image->data == ((char *)NULL))
    {
      fprintf(stderr, "%s: out of memory (%d x %d)\n", progname, w, h);
      exit(1);
    }

    y = 0;
    for( ; !(y >= h); y = y + 1)
    {
      signed int y2 = (h - 1) - y;
      unsigned char *i = row;
      x = 0;
      if(!(x >= w))
      {
        unsigned long int rgba = (unsigned long int)0;
        switch(chan)
        {
          case 1:
          {
            rgba = (unsigned long int)(0xFF << 24 | (signed int)*i << 16 | (signed int)*i << 8 | (signed int)*i);
            i = i + 1l;
            break;
          }
          case 3:
          {
            rgba = (unsigned long int)(0xFF << 24 | (signed int)i[(signed long int)2] << 16 | (signed int)i[(signed long int)1] << 8 | (signed int)i[(signed long int)0]);
            i = i + (signed long int)3;
            break;
          }
          case 4:
          {
            rgba = (unsigned long int)((signed int)i[(signed long int)3] << 24 | (signed int)i[(signed long int)2] << 16 | (signed int)i[(signed long int)1] << 8 | (signed int)i[(signed long int)0]);
            i = i + (signed long int)4;
            break;
          }
          default:
            abort();
        }
        image->f.put_pixel(image, x, y2, rgba);
        x = x + 1;
      }

      row = row + (signed long int)stride;
    }
    g_object_unref((void *)pb);
    return image;
  }

  else
    if(!(filename == ((const char *)NULL)))
    {
      fprintf(stderr, "%s: %s\n", progname, gerr->message);
      g_error_free(gerr);
      exit(1);
    }

    else
    {
      fprintf(stderr, "%s: unable to initialize builtin texture\n", progname);
      exit(1);
    }
}

// ya_rand_init
// file ./../utils/yarandom.h line 37
extern void ya_rand_init(unsigned int seed)
{
  signed int i;
  if(seed == 0u)
  {
    struct timeval tp;
    struct timezone tzp;
    gettimeofday(&tp, &tzp);
    seed = 999U * (unsigned int)tp.tv_sec;
    seed = seed << 11 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)11;
    seed = seed + (unsigned int)((signed long int)1001 * tp.tv_usec);
    seed = seed << 7 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)7;
    signed int return_value_getpid_1;
    return_value_getpid_1=getpid();
    seed = seed + (unsigned int)(1003 * return_value_getpid_1);
    seed = seed << 13 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)13;
  }

  a[(signed long int)0] = a[(signed long int)0] + seed;
  i = 1;
  for( ; !(i >= 55); i = i + 1)
  {
    seed = seed * (unsigned int)999;
    seed = seed << 9 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)9;
    seed = seed + a[(signed long int)(i - 1)] * (unsigned int)1001;
    seed = seed << 15 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)15;
    a[(signed long int)i] = a[(signed long int)i] + seed;
  }
  i1 = (signed int)(a[(signed long int)0] % (unsigned int)55);
  i2 = (i1 + 24) % 55;
}

// ya_random
// file ./../../utils/yarandom.h line 36
extern unsigned int ya_random(void)
{
  signed int ret = (signed int)(a[(signed long int)i1] + a[(signed long int)i2]);
  a[(signed long int)i1] = (unsigned int)ret;
  i1 = i1 + 1;
  if(i1 >= 55)
    i1 = 0;

  i2 = i2 + 1;
  if(i2 >= 55)
    i2 = 0;

  return (unsigned int)ret;
}

