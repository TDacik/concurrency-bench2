// #anon_enum$TYPE_NONE=0$TYPE_SCHAR=1$TYPE_UCHAR=2$TYPE_SHORT=3$TYPE_USHORT=4$TYPE_INT=5$TYPE_UINT=6$TYPE_LONGINT=7$TYPE_ULONGINT=8$TYPE_LONGLONGINT=9$TYPE_ULONGLONGINT=10$TYPE_DOUBLE=11$TYPE_LONGDOUBLE=12$TYPE_CHAR=13$TYPE_WIDE_CHAR=14$TYPE_STRING=15$TYPE_WIDE_STRING=16$TYPE_POINTER=17$TYPE_COUNT_SCHAR_POINTER=18$TYPE_COUNT_SHORT_POINTER=19$TYPE_COUNT_INT_POINTER=20$TYPE_COUNT_LONGINT_POINTER=21$TYPE_COUNT_LONGLONGINT_POINTER=22
// file printf-args.h line 49
enum anonymous$4 { TYPE_NONE=0, TYPE_SCHAR=1, TYPE_UCHAR=2, TYPE_SHORT=3, TYPE_USHORT=4, TYPE_INT=5, TYPE_UINT=6, TYPE_LONGINT=7, TYPE_ULONGINT=8, TYPE_LONGLONGINT=9, TYPE_ULONGLONGINT=10, TYPE_DOUBLE=11, TYPE_LONGDOUBLE=12, TYPE_CHAR=13, TYPE_WIDE_CHAR=14, TYPE_STRING=15, TYPE_WIDE_STRING=16, TYPE_POINTER=17, TYPE_COUNT_SCHAR_POINTER=18, TYPE_COUNT_SHORT_POINTER=19, TYPE_COUNT_INT_POINTER=20, TYPE_COUNT_LONGINT_POINTER=21, TYPE_COUNT_LONGLONGINT_POINTER=22 };

// tag-#anon#ST[*{cS8}$cS8$'dir_start'||*{cS8}$cS8$'dir_end'||S32'flags'||U32'$pad0'||*{cS8}$cS8$'width_start'||*{cS8}$cS8$'width_end'||U64'width_arg_index'||*{cS8}$cS8$'precision_start'||*{cS8}$cS8$'precision_end'||U64'precision_arg_index'||S8'conversion'||U56'$pad1'||U64'arg_index'|]
// file printf-parse.h line 53
struct anonymous;

// tag-#anon#ST[EN#anon_enum$TYPE_NONE=0$TYPE_SCHAR=1$TYPE_UCHAR=2$TYPE_SHORT=3$TYPE_USHORT=4$TYPE_INT=5$TYPE_UINT=6$TYPE_LONGINT=7$TYPE_ULONGINT=8$TYPE_LONGLONGINT=9$TYPE_ULONGLONGINT=10$TYPE_DOUBLE=11$TYPE_LONGDOUBLE=12$TYPE_CHAR=13$TYPE_WIDE_CHAR=14$TYPE_STRING=15$TYPE_WIDE_STRING=16$TYPE_POINTER=17$TYPE_COUNT_SCHAR_POINTER=18$TYPE_COUNT_SHORT_POINTER=19$TYPE_COUNT_INT_POINTER=20$TYPE_COUNT_LONGINT_POINTER=21$TYPE_COUNT_LONGLONGINT_POINTER=22#{U32}$U32$'type'||U96'$pad0'||SYM#tag-#anon#UN[S8'a_schar'||U8'a_uchar'||S16'a_short'||U16'a_ushort'||S32'a_int'||U32'a_uint'||S64'a_longint'||U64'a_ulongint'||S64'a_longlongint'||U64'a_ulonglongint'||F32'a_float'||F64'a_double'||F128'a_longdouble'||S32'a_char'||U32'a_wide_char'||*{cS8}$cS8$'a_string'||*{cS32}$cS32$'a_wide_string'||*{V}$V$'a_pointer'||*{S8}$S8$'a_count_schar_pointer'||*{S16}$S16$'a_count_short_pointer'||*{S32}$S32$'a_count_int_pointer'||*{S64}$S64$'a_count_longint_pointer'||*{S64}$S64$'a_count_longlongint_pointer'|]#'a'|]
// file printf-args.h line 91
struct anonymous$2;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$8;

// tag-#anon#ST[U64'count'||*{SYM#tag-#anon#ST[*{cS8}$cS8$'dir_start'||*{cS8}$cS8$'dir_end'||S32'flags'||U32'$pad0'||*{cS8}$cS8$'width_start'||*{cS8}$cS8$'width_end'||U64'width_arg_index'||*{cS8}$cS8$'precision_start'||*{cS8}$cS8$'precision_end'||U64'precision_arg_index'||S8'conversion'||U56'$pad1'||U64'arg_index'|]#}$SYM#tag-#anon#ST[*{cS8}$cS8$'dir_start'||*{cS8}$cS8$'dir_end'||S32'flags'||U32'$pad0'||*{cS8}$cS8$'width_start'||*{cS8}$cS8$'width_end'||U64'width_arg_index'||*{cS8}$cS8$'precision_start'||*{cS8}$cS8$'precision_end'||U64'precision_arg_index'||S8'conversion'||U56'$pad1'||U64'arg_index'|]#$'dir'||U64'max_width_length'||U64'max_precision_length'||ARR7{SYM#tag-#anon#ST[*{cS8}$cS8$'dir_start'||*{cS8}$cS8$'dir_end'||S32'flags'||U32'$pad0'||*{cS8}$cS8$'width_start'||*{cS8}$cS8$'width_end'||U64'width_arg_index'||*{cS8}$cS8$'precision_start'||*{cS8}$cS8$'precision_end'||U64'precision_arg_index'||S8'conversion'||U56'$pad1'||U64'arg_index'|]#}$SYM#tag-#anon#ST[*{cS8}$cS8$'dir_start'||*{cS8}$cS8$'dir_end'||S32'flags'||U32'$pad0'||*{cS8}$cS8$'width_start'||*{cS8}$cS8$'width_end'||U64'width_arg_index'||*{cS8}$cS8$'precision_start'||*{cS8}$cS8$'precision_end'||U64'precision_arg_index'||S8'conversion'||U56'$pad1'||U64'arg_index'|]#$'direct_alloc_dir'|]
// file printf-parse.h line 70
struct anonymous$5;

// tag-#anon#ST[U64'count'||*{SYM#tag-#anon#ST[EN#anon_enum$TYPE_NONE=0$TYPE_SCHAR=1$TYPE_UCHAR=2$TYPE_SHORT=3$TYPE_USHORT=4$TYPE_INT=5$TYPE_UINT=6$TYPE_LONGINT=7$TYPE_ULONGINT=8$TYPE_LONGLONGINT=9$TYPE_ULONGLONGINT=10$TYPE_DOUBLE=11$TYPE_LONGDOUBLE=12$TYPE_CHAR=13$TYPE_WIDE_CHAR=14$TYPE_STRING=15$TYPE_WIDE_STRING=16$TYPE_POINTER=17$TYPE_COUNT_SCHAR_POINTER=18$TYPE_COUNT_SHORT_POINTER=19$TYPE_COUNT_INT_POINTER=20$TYPE_COUNT_LONGINT_POINTER=21$TYPE_COUNT_LONGLONGINT_POINTER=22#{U32}$U32$'type'||U96'$pad0'||SYM#tag-#anon#UN[S8'a_schar'||U8'a_uchar'||S16'a_short'||U16'a_ushort'||S32'a_int'||U32'a_uint'||S64'a_longint'||U64'a_ulongint'||S64'a_longlongint'||U64'a_ulonglongint'||F32'a_float'||F64'a_double'||F128'a_longdouble'||S32'a_char'||U32'a_wide_char'||*{cS8}$cS8$'a_string'||*{cS32}$cS32$'a_wide_string'||*{V}$V$'a_pointer'||*{S8}$S8$'a_count_schar_pointer'||*{S16}$S16$'a_count_short_pointer'||*{S32}$S32$'a_count_int_pointer'||*{S64}$S64$'a_count_longint_pointer'||*{S64}$S64$'a_count_longlongint_pointer'|]#'a'|]#}$SYM#tag-#anon#ST[EN#anon_enum$TYPE_NONE=0$TYPE_SCHAR=1$TYPE_UCHAR=2$TYPE_SHORT=3$TYPE_USHORT=4$TYPE_INT=5$TYPE_UINT=6$TYPE_LONGINT=7$TYPE_ULONGINT=8$TYPE_LONGLONGINT=9$TYPE_ULONGLONGINT=10$TYPE_DOUBLE=11$TYPE_LONGDOUBLE=12$TYPE_CHAR=13$TYPE_WIDE_CHAR=14$TYPE_STRING=15$TYPE_WIDE_STRING=16$TYPE_POINTER=17$TYPE_COUNT_SCHAR_POINTER=18$TYPE_COUNT_SHORT_POINTER=19$TYPE_COUNT_INT_POINTER=20$TYPE_COUNT_LONGINT_POINTER=21$TYPE_COUNT_LONGLONGINT_POINTER=22#{U32}$U32$'type'||U96'$pad0'||SYM#tag-#anon#UN[S8'a_schar'||U8'a_uchar'||S16'a_short'||U16'a_ushort'||S32'a_int'||U32'a_uint'||S64'a_longint'||U64'a_ulongint'||S64'a_longlongint'||U64'a_ulonglongint'||F32'a_float'||F64'a_double'||F128'a_longdouble'||S32'a_char'||U32'a_wide_char'||*{cS8}$cS8$'a_string'||*{cS32}$cS32$'a_wide_string'||*{V}$V$'a_pointer'||*{S8}$S8$'a_count_schar_pointer'||*{S16}$S16$'a_count_short_pointer'||*{S32}$S32$'a_count_int_pointer'||*{S64}$S64$'a_count_longint_pointer'||*{S64}$S64$'a_count_longlongint_pointer'|]#'a'|]#$'arg'||ARR7{SYM#tag-#anon#ST[EN#anon_enum$TYPE_NONE=0$TYPE_SCHAR=1$TYPE_UCHAR=2$TYPE_SHORT=3$TYPE_USHORT=4$TYPE_INT=5$TYPE_UINT=6$TYPE_LONGINT=7$TYPE_ULONGINT=8$TYPE_LONGLONGINT=9$TYPE_ULONGLONGINT=10$TYPE_DOUBLE=11$TYPE_LONGDOUBLE=12$TYPE_CHAR=13$TYPE_WIDE_CHAR=14$TYPE_STRING=15$TYPE_WIDE_STRING=16$TYPE_POINTER=17$TYPE_COUNT_SCHAR_POINTER=18$TYPE_COUNT_SHORT_POINTER=19$TYPE_COUNT_INT_POINTER=20$TYPE_COUNT_LONGINT_POINTER=21$TYPE_COUNT_LONGLONGINT_POINTER=22#{U32}$U32$'type'||U96'$pad0'||SYM#tag-#anon#UN[S8'a_schar'||U8'a_uchar'||S16'a_short'||U16'a_ushort'||S32'a_int'||U32'a_uint'||S64'a_longint'||U64'a_ulongint'||S64'a_longlongint'||U64'a_ulonglongint'||F32'a_float'||F64'a_double'||F128'a_longdouble'||S32'a_char'||U32'a_wide_char'||*{cS8}$cS8$'a_string'||*{cS32}$cS32$'a_wide_string'||*{V}$V$'a_pointer'||*{S8}$S8$'a_count_schar_pointer'||*{S16}$S16$'a_count_short_pointer'||*{S32}$S32$'a_count_int_pointer'||*{S64}$S64$'a_count_longint_pointer'||*{S64}$S64$'a_count_longlongint_pointer'|]#'a'|]#}$SYM#tag-#anon#ST[EN#anon_enum$TYPE_NONE=0$TYPE_SCHAR=1$TYPE_UCHAR=2$TYPE_SHORT=3$TYPE_USHORT=4$TYPE_INT=5$TYPE_UINT=6$TYPE_LONGINT=7$TYPE_ULONGINT=8$TYPE_LONGLONGINT=9$TYPE_ULONGLONGINT=10$TYPE_DOUBLE=11$TYPE_LONGDOUBLE=12$TYPE_CHAR=13$TYPE_WIDE_CHAR=14$TYPE_STRING=15$TYPE_WIDE_STRING=16$TYPE_POINTER=17$TYPE_COUNT_SCHAR_POINTER=18$TYPE_COUNT_SHORT_POINTER=19$TYPE_COUNT_INT_POINTER=20$TYPE_COUNT_LONGINT_POINTER=21$TYPE_COUNT_LONGLONGINT_POINTER=22#{U32}$U32$'type'||U96'$pad0'||SYM#tag-#anon#UN[S8'a_schar'||U8'a_uchar'||S16'a_short'||U16'a_ushort'||S32'a_int'||U32'a_uint'||S64'a_longint'||U64'a_ulongint'||S64'a_longlongint'||U64'a_ulonglongint'||F32'a_float'||F64'a_double'||F128'a_longdouble'||S32'a_char'||U32'a_wide_char'||*{cS8}$cS8$'a_string'||*{cS32}$cS32$'a_wide_string'||*{V}$V$'a_pointer'||*{S8}$S8$'a_count_schar_pointer'||*{S16}$S16$'a_count_short_pointer'||*{S32}$S32$'a_count_int_pointer'||*{S64}$S64$'a_count_longint_pointer'||*{S64}$S64$'a_count_longlongint_pointer'|]#'a'|]#$'direct_alloc_arg'|]
// file printf-args.h line 141
struct anonymous$1;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$9;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$6;

// tag-#anon#UN[S8'a_schar'||U8'a_uchar'||S16'a_short'||U16'a_ushort'||S32'a_int'||U32'a_uint'||S64'a_longint'||U64'a_ulongint'||S64'a_longlongint'||U64'a_ulonglongint'||F32'a_float'||F64'a_double'||F128'a_longdouble'||S32'a_char'||U32'a_wide_char'||*{cS8}$cS8$'a_string'||*{cS32}$cS32$'a_wide_string'||*{V}$V$'a_pointer'||*{S8}$S8$'a_count_schar_pointer'||*{S16}$S16$'a_count_short_pointer'||*{S32}$S32$'a_count_int_pointer'||*{S64}$S64$'a_count_longint_pointer'||*{S64}$S64$'a_count_longlongint_pointer'|]
// file printf-args.h line 94
union anonymous$3;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$7;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$0;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$10;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$11;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-array_config
// file coreinternals.h line 67
struct array_config;

// tag-cfdata
// file conffile.h line 24
struct cfdata;

// tag-cfldata
// file confline.h line 24
struct cfldata;

// tag-conf
// file opendev.c line 36
struct conf;

// tag-core_interface
// file eegdev-pluginapi.h line 70
struct core_interface;

// tag-data_hdr
// file tia-server.c line 116
struct data_hdr;

// tag-devmodule
// file eegdev-pluginapi.h line 68
struct devmodule;

// tag-eegdev
// file eegdev.h line 63
struct eegdev;

// tag-eegdev_operations
// file coreinternals.h line 76
struct eegdev_operations;

// tag-egd_chinfo
// file eegdev-pluginapi.h line 54
struct egd_chinfo;

// tag-egdi_config
// file configuration.h line 27
struct egdi_config;

// tag-egdi_optname
// file eegdev-pluginapi.h line 118
struct egdi_optname;

// tag-egdi_plugin_info
// file eegdev-pluginapi.h line 122
struct egdi_plugin_info;

// tag-grpconf
// file ../src/core/eegdev.h line 65
struct grpconf;

// tag-gval
// file eegdev-pluginapi.h line 34
union gval;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-input_buffer_group
// file coreinternals.h line 56
struct input_buffer_group;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-selected_channels
// file eegdev-pluginapi.h line 43
struct selected_channels;

// tag-sensor_type
// file sensortypes.c line 31
struct sensor_type;

// tag-setting
// file configuration.h line 22
struct setting;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-systemcap
// file eegdev-pluginapi.h line 61
struct systemcap;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-value
// file conffile.tab.h line 56
union value;

// tag-yy_buffer_state
// file conffile.lex.c line 179
struct yy_buffer_state;

// tag-yyalloc
// file conffile.tab.c line 340
union yyalloc;

// tag-yyguts_t
// file conffile.lex.c line 517
struct yyguts_t;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// _IO_getc
// file /usr/include/libio.h line 434
extern signed int _IO_getc(struct _IO_FILE *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous$11, unsigned int *);
// add_sensor_type
// file sensortypes.c line 42
static signed int add_sensor_type(const char *sname, struct sensor_type *start);
// addtime
// file time-utils.h line 26
static inline signed int addtime(struct timespec *ts, signed long int sec, signed long int nsec);
// asnprintf
// file asnprintf.c line 25
extern char * asnprintf(char *resultbuf, unsigned long int *lengthp, const char *format, ...);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$11, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// cast_data
// file core.c line 111
static unsigned int cast_data(struct eegdev * restrict dev, const void * restrict in, unsigned long int length);
// cast_double_double
// file typecast.c line 92
static void cast_double_double(void * restrict d, const void * restrict s, union gval sc, unsigned long int len);
// cast_double_float
// file typecast.c line 90
static void cast_double_float(void * restrict d, const void * restrict s, union gval sc, unsigned long int len);
// cast_double_int32_t
// file typecast.c line 86
static void cast_double_int32_t(void * restrict d, const void * restrict s, union gval sc, unsigned long int len);
// cast_float_double
// file typecast.c line 89
static void cast_float_double(void * restrict d, const void * restrict s, union gval sc, unsigned long int len);
// cast_float_float
// file typecast.c line 91
static void cast_float_float(void * restrict d, const void * restrict s, union gval sc, unsigned long int len);
// cast_float_int32_t
// file typecast.c line 88
static void cast_float_int32_t(void * restrict d, const void * restrict s, union gval sc, unsigned long int len);
// cast_int32_t_double
// file typecast.c line 85
static void cast_int32_t_double(void * restrict d, const void * restrict s, union gval sc, unsigned long int len);
// cast_int32_t_float
// file typecast.c line 87
static void cast_int32_t_float(void * restrict d, const void * restrict s, union gval sc, unsigned long int len);
// cast_int32_t_int32_t
// file typecast.c line 84
static void cast_int32_t_int32_t(void * restrict d, const void * restrict s, union gval sc, unsigned long int len);
// castnosc_double_float
// file typecast.c line 102
static void castnosc_double_float(void * restrict d, const void * restrict s, union gval sc, unsigned long int len);
// castnosc_double_int32_t
// file typecast.c line 101
static void castnosc_double_int32_t(void * restrict d, const void * restrict s, union gval sc, unsigned long int len);
// castnosc_float_double
// file typecast.c line 100
static void castnosc_float_double(void * restrict d, const void * restrict s, union gval sc, unsigned long int len);
// castnosc_float_int32_t
// file typecast.c line 98
static void castnosc_float_int32_t(void * restrict d, const void * restrict s, union gval sc, unsigned long int len);
// castnosc_int32_t_double
// file typecast.c line 97
static void castnosc_int32_t_double(void * restrict d, const void * restrict s, union gval sc, unsigned long int len);
// castnosc_int32_t_float
// file typecast.c line 96
static void castnosc_int32_t_float(void * restrict d, const void * restrict s, union gval sc, unsigned long int len);
// cff__create_buffer
// file conffile.lex.c line 1367
struct yy_buffer_state * cff__create_buffer(struct _IO_FILE *file, signed int size, void *yyscanner);
// cff__delete_buffer
// file conffile.lex.c line 1395
void cff__delete_buffer(struct yy_buffer_state *b, void *yyscanner);
// cff__flush_buffer
// file conffile.lex.c line 1444
void cff__flush_buffer(struct yy_buffer_state *b, void *yyscanner);
// cff__init_buffer
// file conffile.lex.c line 1415
static void cff__init_buffer(struct yy_buffer_state *b, struct _IO_FILE *file, void *yyscanner);
// cff__load_buffer_state
// file conffile.lex.c line 1352
static void cff__load_buffer_state(void *yyscanner);
// cff__scan_buffer
// file conffile.lex.c line 1575
struct yy_buffer_state * cff__scan_buffer(char *base, unsigned long int size, void *yyscanner);
// cff__scan_bytes
// file conffile.lex.c line 1625
struct yy_buffer_state * cff__scan_bytes(const char *yybytes, unsigned long int _yybytes_len, void *yyscanner);
// cff__scan_string
// file conffile.lex.c line 1612
struct yy_buffer_state * cff__scan_string(const char *yystr, void *yyscanner);
// cff__switch_to_buffer
// file conffile.lex.c line 1320
void cff__switch_to_buffer(struct yy_buffer_state *new_buffer, void *yyscanner);
// cff_alloc
// file conffile.l line 62
void * cff_alloc(unsigned long int size, void *yyscanner);
// cff_ensure_buffer_stack
// file conffile.lex.c line 1525
static void cff_ensure_buffer_stack(void *yyscanner);
// cff_error
// file conffile.tab.c line 1463
static signed int cff_error(struct cfdata *pp, const char *s);
// cff_free
// file conffile.l line 78
void cff_free(void *ptr, void *yyscanner);
// cff_get_column
// file conffile.lex.c line 1709
signed int cff_get_column(void *yyscanner);
// cff_get_debug
// file conffile.lex.c line 1814
signed int cff_get_debug(void *yyscanner);
// cff_get_extra
// file conffile.lex.c line 1687
void * cff_get_extra(void *yyscanner);
// cff_get_in
// file conffile.lex.c line 1722
struct _IO_FILE * cff_get_in(void *yyscanner);
// cff_get_leng
// file conffile.lex.c line 1740
unsigned long int cff_get_leng(void *yyscanner);
// cff_get_lineno
// file conffile.lex.c line 1696
signed int cff_get_lineno(void *yyscanner);
// cff_get_lval
// file conffile.lex.c line 1828
union value * cff_get_lval(void *yyscanner);
// cff_get_out
// file conffile.lex.c line 1731
struct _IO_FILE * cff_get_out(void *yyscanner);
// cff_get_text
// file conffile.lex.c line 1750
char * cff_get_text(void *yyscanner);
// cff_lex
// file conffile.lex.c line 733
extern signed int cff_lex(union value *yylval_param, void *yyscanner);
// cff_lex_destroy
// file conffile.lex.c line 1938
signed int cff_lex_destroy(void *yyscanner);
// cff_lex_init
// file conffile.lex.c line 1847
signed int cff_lex_init(void **ptr_yy_globals);
// cff_lex_init_extra
// file conffile.lex.c line 1876
signed int cff_lex_init_extra(void *yy_user_defined, void **ptr_yy_globals);
// cff_parse
// file conffile.tab.c line 977
signed int cff_parse(struct cfdata *pp);
// cff_pop_buffer_state
// file conffile.lex.c line 1505
void cff_pop_buffer_state(void *yyscanner);
// cff_push_buffer_state
// file conffile.lex.c line 1474
void cff_push_buffer_state(struct yy_buffer_state *new_buffer, void *yyscanner);
// cff_realloc
// file conffile.l line 70
void * cff_realloc(void *ptr, unsigned long int size, void *yyscanner);
// cff_restart
// file conffile.lex.c line 1302
void cff_restart(struct _IO_FILE *input_file, void *yyscanner);
// cff_set_column
// file conffile.lex.c line 1785
void cff_set_column(signed int column_no, void *yyscanner);
// cff_set_debug
// file conffile.lex.c line 1820
void cff_set_debug(signed int bdebug, void *yyscanner);
// cff_set_extra
// file conffile.lex.c line 1760
void cff_set_extra(void *user_defined, void *yyscanner);
// cff_set_in
// file conffile.lex.c line 1802
void cff_set_in(struct _IO_FILE *in_str, void *yyscanner);
// cff_set_lineno
// file conffile.lex.c line 1770
void cff_set_lineno(signed int line_number, void *yyscanner);
// cff_set_lval
// file conffile.lex.c line 1834
void cff_set_lval(union value *yylval_param, void *yyscanner);
// cff_set_out
// file conffile.lex.c line 1808
void cff_set_out(struct _IO_FILE *out_str, void *yyscanner);
// cfl__create_buffer
// file confline.lex.c line 1353
struct yy_buffer_state * cfl__create_buffer(struct _IO_FILE *file, signed int size, void *yyscanner);
// cfl__delete_buffer
// file confline.lex.c line 1381
void cfl__delete_buffer(struct yy_buffer_state *b, void *yyscanner);
// cfl__flush_buffer
// file confline.lex.c line 1430
void cfl__flush_buffer(struct yy_buffer_state *b, void *yyscanner);
// cfl__init_buffer
// file confline.lex.c line 1401
static void cfl__init_buffer(struct yy_buffer_state *b, struct _IO_FILE *file, void *yyscanner);
// cfl__load_buffer_state
// file confline.lex.c line 1338
static void cfl__load_buffer_state(void *yyscanner);
// cfl__scan_buffer
// file confline.lex.c line 1561
struct yy_buffer_state * cfl__scan_buffer(char *base, unsigned long int size, void *yyscanner);
// cfl__scan_bytes
// file confline.lex.c line 1611
struct yy_buffer_state * cfl__scan_bytes(const char *yybytes, unsigned long int _yybytes_len, void *yyscanner);
// cfl__scan_string
// file confline.lex.c line 1598
struct yy_buffer_state * cfl__scan_string(const char *yystr, void *yyscanner);
// cfl__switch_to_buffer
// file confline.lex.c line 1306
void cfl__switch_to_buffer(struct yy_buffer_state *new_buffer, void *yyscanner);
// cfl_alloc
// file confline.l line 60
void * cfl_alloc(unsigned long int size, void *yyscanner);
// cfl_ensure_buffer_stack
// file confline.lex.c line 1511
static void cfl_ensure_buffer_stack(void *yyscanner);
// cfl_error
// file confline.tab.c line 1471
static signed int cfl_error(struct cfldata *pp, const char *s);
// cfl_free
// file confline.l line 76
void cfl_free(void *ptr, void *yyscanner);
// cfl_get_column
// file confline.lex.c line 1695
signed int cfl_get_column(void *yyscanner);
// cfl_get_debug
// file confline.lex.c line 1800
signed int cfl_get_debug(void *yyscanner);
// cfl_get_extra
// file confline.lex.c line 1673
void * cfl_get_extra(void *yyscanner);
// cfl_get_in
// file confline.lex.c line 1708
struct _IO_FILE * cfl_get_in(void *yyscanner);
// cfl_get_leng
// file confline.lex.c line 1726
unsigned long int cfl_get_leng(void *yyscanner);
// cfl_get_lineno
// file confline.lex.c line 1682
signed int cfl_get_lineno(void *yyscanner);
// cfl_get_lval
// file confline.lex.c line 1814
union value * cfl_get_lval(void *yyscanner);
// cfl_get_out
// file confline.lex.c line 1717
struct _IO_FILE * cfl_get_out(void *yyscanner);
// cfl_get_text
// file confline.lex.c line 1736
char * cfl_get_text(void *yyscanner);
// cfl_lex
// file confline.lex.c line 730
extern signed int cfl_lex(union value *yylval_param, void *yyscanner);
// cfl_lex_destroy
// file confline.lex.c line 1924
signed int cfl_lex_destroy(void *yyscanner);
// cfl_lex_init
// file confline.lex.c line 1833
signed int cfl_lex_init(void **ptr_yy_globals);
// cfl_lex_init_extra
// file confline.lex.c line 1862
signed int cfl_lex_init_extra(void *yy_user_defined, void **ptr_yy_globals);
// cfl_parse
// file confline.tab.c line 979
signed int cfl_parse(struct cfldata *pp);
// cfl_pop_buffer_state
// file confline.lex.c line 1491
void cfl_pop_buffer_state(void *yyscanner);
// cfl_push_buffer_state
// file confline.lex.c line 1460
void cfl_push_buffer_state(struct yy_buffer_state *new_buffer, void *yyscanner);
// cfl_realloc
// file confline.l line 68
void * cfl_realloc(void *ptr, unsigned long int size, void *yyscanner);
// cfl_restart
// file confline.lex.c line 1288
void cfl_restart(struct _IO_FILE *input_file, void *yyscanner);
// cfl_set_column
// file confline.lex.c line 1771
void cfl_set_column(signed int column_no, void *yyscanner);
// cfl_set_debug
// file confline.lex.c line 1806
void cfl_set_debug(signed int bdebug, void *yyscanner);
// cfl_set_extra
// file confline.lex.c line 1746
void cfl_set_extra(void *user_defined, void *yyscanner);
// cfl_set_in
// file confline.lex.c line 1788
void cfl_set_in(struct _IO_FILE *in_str, void *yyscanner);
// cfl_set_lineno
// file confline.lex.c line 1756
void cfl_set_lineno(signed int line_number, void *yyscanner);
// cfl_set_lval
// file confline.lex.c line 1820
void cfl_set_lval(union value *yylval_param, void *yyscanner);
// cfl_set_out
// file confline.lex.c line 1794
void cfl_set_out(struct _IO_FILE *out_str, void *yyscanner);
// check_signals_f
// file systobiia.c line 69
signed int check_signals_f(unsigned long int ns, const float *sig, const float *exg, const signed int *tri);
// clearerr
// file /usr/include/stdio.h line 826
extern void clearerr(struct _IO_FILE *);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// clock_nanosleep
// file /usr/include/time.h line 353
extern signed int clock_nanosleep(signed int, signed int, struct timespec *, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// create_listening_socket
// file tia-server.c line 87
static signed int create_listening_socket(unsigned short int port);
// create_tia_server
// file fakelibs/tia-server.h line 34
signed int create_tia_server(unsigned short int port);
// ctrl_socket_fn
// file tia-server.c line 419
static void * ctrl_socket_fn(void *data);
// data_socket_fn
// file tia-server.c line 170
static void * data_socket_fn(void *data);
// destroy_dataloop
// file tia-server.c line 323
static void destroy_dataloop(void);
// destroy_tia_server
// file fakelibs/tia-server.h line 35
void destroy_tia_server(void);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// egd_acq_setup
// file ../src/core/eegdev.h line 83
signed int egd_acq_setup(struct eegdev *dev, unsigned int narr, const unsigned long int *strides, unsigned int ngrp, struct grpconf *grp);
// egd_channel_info
// file core.c line 512
signed int egd_channel_info(struct eegdev *dev, signed int stype, unsigned int index, signed int fieldtype, ...);
// egd_close
// file ../src/core/eegdev.h line 82
signed int egd_close(struct eegdev *dev);
// egd_destroy_eegdev
// file core.c line 321
void egd_destroy_eegdev(struct eegdev *dev);
// egd_get_available
// file core.c line 679
signed long int egd_get_available(struct eegdev *dev);
// egd_get_cap
// file ../src/core/eegdev.h line 78
signed int egd_get_cap(struct eegdev *dev, signed int cap, void *val);
// egd_get_cast_fn
// file coreinternals.h line 52
void (*egd_get_cast_fn(unsigned int itype, unsigned int otype, unsigned int scaling))(void *, const void *, union gval, unsigned long int);
// egd_get_data
// file ../src/core/eegdev.h line 87
signed long int egd_get_data(struct eegdev *dev, unsigned long int ns, ...);
// egd_get_data_size
// file eegdev-pluginapi.h line 143
static inline unsigned int egd_get_data_size(unsigned int type);
// egd_get_numch
// file ../src/core/eegdev.h line 79
signed int egd_get_numch(struct eegdev *dev, signed int stype);
// egd_get_string
// file core.c line 750
const char * egd_get_string(void);
// egd_open
// file ../src/core/eegdev.h line 77
struct eegdev * egd_open(const char *confstring);
// egd_sensor_name
// file sensortypes.c line 129
const char * egd_sensor_name(signed int stype);
// egd_sensor_type
// file ../src/core/eegdev.h line 74
signed int egd_sensor_type(const char *name);
// egd_start
// file ../src/core/eegdev.h line 86
signed int egd_start(struct eegdev *dev);
// egd_stop
// file ../src/core/eegdev.h line 89
signed int egd_stop(struct eegdev *dev);
// egd_update_capabilities
// file core.c line 418
void egd_update_capabilities(struct eegdev *dev);
// egdi_add_setting
// file configuration.c line 62
signed int egdi_add_setting(struct egdi_config *cf, const char *name, const char *value);
// egdi_alloc_input_groups
// file core.c line 432
struct selected_channels * egdi_alloc_input_groups(struct devmodule *mdev, unsigned int ngrp);
// egdi_create_eegdev
// file core.c line 277
struct eegdev * egdi_create_eegdev(struct egdi_plugin_info *info);
// egdi_create_eegdev::$tmp::tmp_if_expr$10$object
//
signed int tmp_if_expr$10$object(struct devmodule *);
// egdi_create_eegdev::$tmp::tmp_if_expr$11$object
//
signed int tmp_if_expr$11$object(struct devmodule *);
// egdi_free_config
// file configuration.h line 35
void egdi_free_config(struct egdi_config *cf);
// egdi_get_setting_value
// file configuration.h line 40
const char * egdi_get_setting_value(struct egdi_config *cf, const char *name);
// egdi_init_config
// file configuration.h line 36
void egdi_init_config(struct egdi_config *cf);
// egdi_parse_conffile
// file configuration.h line 43
signed int egdi_parse_conffile(struct egdi_config *cf, const char *filename);
// egdi_parse_confline
// file configuration.h line 44
signed int egdi_parse_confline(struct egdi_config *cf, const char *confstr);
// egdi_reinit_config
// file configuration.h line 37
void egdi_reinit_config(struct egdi_config *cf);
// egdi_report_error
// file core.c line 402
void egdi_report_error(struct devmodule *mdev, signed int error);
// egdi_set_cap
// file core.c line 250
static signed int egdi_set_cap(struct devmodule *mdev, struct systemcap *cap);
// egdi_set_input_samlen
// file core.c line 454
void egdi_set_input_samlen(struct devmodule *mdev, unsigned int samlen);
// egdi_update_ringbuffer
// file core.c line 343
signed int egdi_update_ringbuffer(struct devmodule *mdev, const void *in, unsigned long int length);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_configuration
// file opendev.c line 62
static void free_configuration(struct conf *cf);
// fscanf
// file /usr/include/stdio.h line 425
extern signed int fscanf(struct _IO_FILE *, const char *, ...);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// get_analog_val
// file fakelibs/tia-server.h line 22
static inline float get_analog_val(unsigned long int sam, unsigned int ich);
// get_analog_val$link1
// file tia-server.h line 22
static inline float get_analog_val$link1(unsigned long int sam$link1, unsigned int ich$link1);
// get_charset_aliases
// file localcharset.c line 123
static const char * get_charset_aliases(void);
// get_charset_aliases$link1
// file localcharset.c line 123
static const char * get_charset_aliases$link1(void);
// get_conf_setting
// file opendev.c line 85
static const char * get_conf_setting(struct conf *cf, const char *name, const char *defvalue);
// get_field_info
// file core.c line 214
static signed int get_field_info(struct egd_chinfo *info, signed int field, void *arg);
// get_trigger_val
// file fakelibs/tia-server.h line 28
static inline signed int get_trigger_val(unsigned long int sam, unsigned int ich);
// get_trigger_val$link1
// file tia-server.h line 28
static inline signed int get_trigger_val$link1(unsigned long int sam$link1, unsigned int ich$link1);
// getc_unlocked
// file /usr/include/stdio.h line 550
extern signed int getc_unlocked(struct _IO_FILE *);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// gl_sockets_cleanup
// file sockets.c line 139
signed int gl_sockets_cleanup(void);
// gl_sockets_startup
// file sockets.c line 112
signed int gl_sockets_startup(signed int version);
// glthread_once_singlethreaded
// file glthread/lock.c line 457
extern signed int glthread_once_singlethreaded(signed int *once_control);
// glthread_recursive_lock_init_multithreaded
// file glthread/lock.c line 284
extern signed int glthread_recursive_lock_init_multithreaded(union anonymous$0 *lock);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// identity
// file typecast.c line 77
static void identity(void * restrict d, const void * restrict s, union gval sc, unsigned long int len);
// init_configuration
// file opendev.c line 43
static signed int init_configuration(struct conf *cf, const char *str);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// load_configuration_file
// file opendev.c line 72
static signed int load_configuration_file(struct conf *cf, const char *file, signed int global);
// locale_charset
// file localcharset.c line 362
extern const char * locale_charset(void);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// nl_langinfo
// file /usr/include/langinfo.h line 583
extern char * nl_langinfo(signed int);
// noaction
// file core.c line 242
static signed int noaction(struct devmodule *dev);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// open_any
// file opendev.c line 188
static struct eegdev * open_any(struct conf *cf);
// open_device
// file systobiia.c line 121
static struct eegdev * open_device(struct grpconf *group);
// open_init_device
// file opendev.c line 112
static struct eegdev * open_init_device(struct egdi_plugin_info *info, unsigned int nopt, struct conf *cf);
// open_plugin_device
// file opendev.c line 141
static struct eegdev * open_plugin_device(const char *dname, struct conf *cf);
// optimize_inbufgrp
// file core.c line 46
static void optimize_inbufgrp(struct input_buffer_group *ibgrp, unsigned int *ngrp);
// print_cap
// file systobiia.c line 144
static signed int print_cap(struct eegdev *dev);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// printf_fetchargs
// file printf-args.c line 36
extern signed int printf_fetchargs(__builtin_va_list args, struct anonymous$1 *a);
// printf_parse
// file printf-parse.c line 83
extern signed int printf_parse(const char *format, struct anonymous$5 *d, struct anonymous$1 *a);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$7 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$7 *, const union anonymous$6 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$7 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$7 *, union anonymous$0 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$0 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$0 *, const union anonymous$6 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$0 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$0 *);
// pthread_mutexattr_destroy
// file /usr/include/pthread.h line 812
extern signed int pthread_mutexattr_destroy(union anonymous$6 *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 808
extern signed int pthread_mutexattr_init(union anonymous$6 *);
// pthread_mutexattr_settype
// file /usr/include/pthread.h line 835
extern signed int pthread_mutexattr_settype(union anonymous$6 *, signed int);
// pthread_once
// file /usr/include/pthread.h line 496
extern signed int pthread_once(signed int *, void (*)(void));
// read_ctrl_msg
// file tia-server.c line 382
static signed int read_ctrl_msg(struct _IO_FILE *fp);
// read_eegsignal
// file systobiia.c line 175
signed int read_eegsignal(signed int bsigcheck);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reply_dataconnection
// file tia-server.c line 337
static signed int reply_dataconnection(signed int fd);
// reply_metainfo
// file tia-server.c line 284
static signed int reply_metainfo(signed int fd);
// reply_msg
// file tia-server.c line 239
static signed int reply_msg(signed int fd, const char *answer, signed int contentlen, const char *content);
// reply_startdata
// file tia-server.c line 355
static signed int reply_startdata(signed int fd);
// reply_stopdata
// file tia-server.c line 367
static signed int reply_stopdata(signed int fd);
// reterrno
// file core.c line 39
static signed int reterrno(signed int err);
// safe_strncpy
// file core.c line 201
static void safe_strncpy(char *dst, const char *src, unsigned long int n);
// sensor_type_exit
// file sensortypes.c line 73
static void sensor_type_exit(void);
// sensor_type_init
// file sensortypes.c line 88
static void sensor_type_init(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setup_ringbuffer_mapping
// file core.c line 72
static signed int setup_ringbuffer_mapping(struct eegdev *dev);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// ungetc
// file /usr/include/stdio.h line 702
extern signed int ungetc(signed int, struct _IO_FILE *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// validate_groups_settings
// file core.c line 158
static signed int validate_groups_settings(struct eegdev *dev, unsigned int ngrp, struct grpconf *grp);
// vasnprintf
// file vasnprintf.h line 72
extern char * vasnprintf(char *resultbuf, unsigned long int *lengthp, const char *format, void **args);
// wait_for_data
// file core.c line 177
static signed int wait_for_data(struct eegdev *dev, unsigned long int *reqns);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_data_packet
// file tia-server.c line 131
static signed int write_data_packet(char *buffer);
// write_metainfo
// file tia-server.c line 211
static signed int write_metainfo(struct _IO_FILE *fp);
// xmax
// file xsize.h line 94
inline unsigned long int xmax(unsigned long int size1, unsigned long int size2);
// xsum
// file xsize.h line 63
inline unsigned long int xsum(unsigned long int size1, unsigned long int size2);
// xsum3
// file xsize.h line 74
inline unsigned long int xsum3(unsigned long int size1, unsigned long int size2, unsigned long int size3);
// xsum4
// file xsize.h line 84
inline unsigned long int xsum4(unsigned long int size1, unsigned long int size2, unsigned long int size3, unsigned long int size4);
// yy_fatal_error
// file conffile.lex.c line 1659
static void yy_fatal_error(const char *msg, void *yyscanner);
// yy_fatal_error$link1
// file confline.lex.c line 1645
static void yy_fatal_error$link1(const char *msg$link1, void *yyscanner$link1);
// yy_get_next_buffer
// file conffile.lex.c line 1022
static signed int yy_get_next_buffer(void *yyscanner);
// yy_get_next_buffer$link1
// file confline.lex.c line 1008
static signed int yy_get_next_buffer$link1(void *yyscanner$link1);
// yy_get_previous_state
// file conffile.lex.c line 1157
static signed int yy_get_previous_state(void *yyscanner);
// yy_get_previous_state$link1
// file confline.lex.c line 1143
static signed int yy_get_previous_state$link1(void *yyscanner$link1);
// yy_init_globals
// file conffile.lex.c line 1904
static signed int yy_init_globals(void *yyscanner);
// yy_init_globals$link1
// file confline.lex.c line 1890
static signed int yy_init_globals$link1(void *yyscanner$link1);
// yy_try_NUL_trans
// file conffile.lex.c line 1190
static signed int yy_try_NUL_trans(signed int yy_current_state, void *yyscanner);
// yy_try_NUL_trans$link1
// file confline.lex.c line 1176
static signed int yy_try_NUL_trans$link1(signed int yy_current_state$link1, void *yyscanner$link1);
// yydestruct
// file conffile.tab.c line 956
static void yydestruct(const char *yymsg, signed int yytype, union value *yyvaluep, struct cfdata *pp);
// yydestruct$link1
// file confline.tab.c line 958
static void yydestruct$link1(const char *yymsg$link1, signed int yytype$link1, union value *yyvaluep$link1, struct cfldata *pp$link1);

struct anonymous
{
  // dir_start
  const char *dir_start;
  // dir_end
  const char *dir_end;
  // flags
  signed int flags;
  // width_start
  const char *width_start;
  // width_end
  const char *width_end;
  // width_arg_index
  unsigned long int width_arg_index;
  // precision_start
  const char *precision_start;
  // precision_end
  const char *precision_end;
  // precision_arg_index
  unsigned long int precision_arg_index;
  // conversion
  char conversion;
  // arg_index
  unsigned long int arg_index;
};

union anonymous$3
{
  // a_schar
  signed char a_schar;
  // a_uchar
  unsigned char a_uchar;
  // a_short
  signed short int a_short;
  // a_ushort
  unsigned short int a_ushort;
  // a_int
  signed int a_int;
  // a_uint
  unsigned int a_uint;
  // a_longint
  signed long int a_longint;
  // a_ulongint
  unsigned long int a_ulongint;
  // a_longlongint
  signed long long int a_longlongint;
  // a_ulonglongint
  unsigned long long int a_ulonglongint;
  // a_float
  float a_float;
  // a_double
  double a_double;
  // a_longdouble
  long double a_longdouble;
  // a_char
  signed int a_char;
  // a_wide_char
  unsigned int a_wide_char;
  // a_string
  const char *a_string;
  // a_wide_string
  const signed int *a_wide_string;
  // a_pointer
  void *a_pointer;
  // a_count_schar_pointer
  signed char *a_count_schar_pointer;
  // a_count_short_pointer
  signed short int *a_count_short_pointer;
  // a_count_int_pointer
  signed int *a_count_int_pointer;
  // a_count_longint_pointer
  signed long int *a_count_longint_pointer;
  // a_count_longlongint_pointer
  signed long long int *a_count_longlongint_pointer;
};

struct anonymous$2
{
  // type
  enum anonymous$4 type;
  // a
  union anonymous$3 a;
};

struct anonymous$8
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$5
{
  // count
  unsigned long int count;
  // dir
  struct anonymous *dir;
  // max_width_length
  unsigned long int max_width_length;
  // max_precision_length
  unsigned long int max_precision_length;
  // direct_alloc_dir
  struct anonymous direct_alloc_dir[7l];
};

struct anonymous$1
{
  // count
  unsigned long int count;
  // arg
  struct anonymous$2 *arg;
  // direct_alloc_arg
  struct anonymous$2 direct_alloc_arg[7l];
};

union anonymous$9
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$6
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$7
{
  // __data
  struct anonymous$8 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$0
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$10
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$11
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct array_config
{
  // iarray
  unsigned int iarray;
  // arr_offset
  unsigned int arr_offset;
  // buff_offset
  unsigned int buff_offset;
  // len
  unsigned int len;
};

struct cfdata
{
  // cf
  struct egdi_config *cf;
  // fpath
  const char *fpath;
  // tokbuff
  char tokbuff[2l][64l];
  // itok
  signed int itok;
  // scaninfo
  void *scaninfo;
};

struct cfldata
{
  // cf
  struct egdi_config *cf;
  // tokbuff
  char tokbuff[2l][64l];
  // itok
  signed int itok;
  // scaninfo
  void *scaninfo;
};

struct egdi_config
{
  // numsettings
  signed int numsettings;
  // nmaxsettings
  signed int nmaxsettings;
  // settings
  struct setting *settings;
  // buffer
  char *buffer;
  // cursize
  unsigned long int cursize;
  // maxsize
  unsigned long int maxsize;
};

struct conf
{
  // confpath
  const char *confpath;
  // config
  struct egdi_config config[3l];
};

struct core_interface
{
  // update_ringbuffer
  signed int (*update_ringbuffer)(struct devmodule *, const void *, unsigned long int);
  // alloc_input_groups
  struct selected_channels * (*alloc_input_groups)(struct devmodule *, unsigned int);
  // report_error
  void (*report_error)(struct devmodule *, signed int);
  // get_stype
  signed int (*get_stype)(const char *);
  // set_input_samlen
  void (*set_input_samlen)(struct devmodule *, unsigned int);
  // set_cap
  signed int (*set_cap)(struct devmodule *, struct systemcap *);
};

struct data_hdr
{
  // padding
  unsigned char padding[7l];
  // version
  unsigned char version;
  // size
  unsigned int size;
  // type_flags
  unsigned int type_flags;
  // id
  unsigned long int id;
  // number
  unsigned long int number;
  // ts
  unsigned long int ts;
};

struct devmodule
{
  // ci
  struct core_interface ci;
};

struct eegdev_operations
{
  // close_device
  signed int (*close_device)(struct devmodule *);
  // set_channel_groups
  signed int (*set_channel_groups)(struct devmodule *, unsigned int, struct grpconf *);
  // start_acq
  signed int (*start_acq)(struct devmodule *);
  // stop_acq
  signed int (*stop_acq)(struct devmodule *);
  // fill_chinfo
  void (*fill_chinfo)(struct devmodule *, signed int, unsigned int, struct egd_chinfo *);
};

struct systemcap
{
  // sampling_freq
  unsigned int sampling_freq;
  // type_nch
  unsigned int type_nch[3l];
  // device_type
  const char *device_type;
  // device_id
  const char *device_id;
};

struct eegdev
{
  // ops
  struct eegdev_operations ops;
  // cap
  struct systemcap cap;
  // provided_stypes
  signed int provided_stypes[4l];
  // num_stypes
  unsigned int num_stypes;
  // buffer
  char *buffer;
  // buffsize
  unsigned long int buffsize;
  // in_samlen
  unsigned long int in_samlen;
  // buff_samlen
  unsigned long int buff_samlen;
  // in_offset
  unsigned long int in_offset;
  // buff_ns
  unsigned long int buff_ns;
  // ind
  unsigned int ind;
  // last_read
  unsigned int last_read;
  // nreadwait
  unsigned int nreadwait;
  // ns_written
  unsigned long int ns_written;
  // ns_read
  unsigned long int ns_read;
  // synclock
  union anonymous$0 synclock;
  // apilock
  union anonymous$0 apilock;
  // available
  union anonymous$7 available;
  // acq_order
  signed int acq_order;
  // acquiring
  signed int acquiring;
  // error
  signed int error;
  // narr
  unsigned int narr;
  // strides
  unsigned long int *strides;
  // ngrp
  unsigned int ngrp;
  // nsel
  unsigned int nsel;
  // nconf
  unsigned int nconf;
  // inbuffgrp
  struct input_buffer_group *inbuffgrp;
  // selch
  struct selected_channels *selch;
  // arrconf
  struct array_config *arrconf;
  // handle
  void *handle;
  // module
  struct devmodule module;
};

union gval
{
  // valfloat
  float valfloat;
  // valdouble
  double valdouble;
  // valint32_t
  signed int valint32_t;
};

struct egd_chinfo
{
  // label
  const char *label;
  // unit
  const char *unit;
  // transducter
  const char *transducter;
  // prefiltering
  const char *prefiltering;
  // isint
  _Bool isint;
  // dtype
  signed int dtype;
  // min
  union gval min;
  // max
  union gval max;
};

struct egdi_optname
{
  // name
  const char *name;
  // defvalue
  const char *defvalue;
};

struct egdi_plugin_info
{
  // plugin_abi
  unsigned int plugin_abi;
  // struct_size
  unsigned int struct_size;
  // open_device
  signed int (*open_device)(struct devmodule *, const char **);
  // close_device
  signed int (*close_device)(struct devmodule *);
  // set_channel_groups
  signed int (*set_channel_groups)(struct devmodule *, unsigned int, struct grpconf *);
  // start_acq
  signed int (*start_acq)(struct devmodule *);
  // stop_acq
  signed int (*stop_acq)(struct devmodule *);
  // fill_chinfo
  void (*fill_chinfo)(struct devmodule *, signed int, unsigned int, struct egd_chinfo *);
  // supported_opts
  struct egdi_optname *supported_opts;
};

struct grpconf
{
  // sensortype
  signed int sensortype;
  // index
  unsigned int index;
  // nch
  unsigned int nch;
  // iarray
  unsigned int iarray;
  // arr_offset
  unsigned int arr_offset;
  // datatype
  signed int datatype;
};

struct in6_addr
{
  // __in6_u
  union anonymous$9 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct input_buffer_group
{
  // in_offset
  unsigned int in_offset;
  // inlen
  unsigned int inlen;
  // buff_offset
  unsigned int buff_offset;
  // in_tsize
  signed int in_tsize;
  // buff_tsize
  signed int buff_tsize;
  // sc
  union gval sc;
  // cast_fn
  void (*cast_fn)(void *, const void *, union gval, unsigned long int);
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct selected_channels
{
  // sc
  union gval sc;
  // in_offset
  unsigned int in_offset;
  // inlen
  unsigned int inlen;
  // typein
  unsigned int typein;
  // typeout
  unsigned int typeout;
  // iarray
  unsigned int iarray;
  // arr_offset
  unsigned int arr_offset;
  // bsc
  signed int bsc;
  // padding
  signed int padding;
};

struct sensor_type
{
  // next
  struct sensor_type *next;
  // stype
  signed int stype;
  // name
  char name[0l];
};

struct setting
{
  // c_offset
  unsigned int c_offset;
  // v_offset
  unsigned int v_offset;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

union value
{
  // str
  const char *str;
};

struct yy_buffer_state
{
  // yy_input_file
  struct _IO_FILE *yy_input_file;
  // yy_ch_buf
  char *yy_ch_buf;
  // yy_buf_pos
  char *yy_buf_pos;
  // yy_buf_size
  unsigned long int yy_buf_size;
  // yy_n_chars
  unsigned long int yy_n_chars;
  // yy_is_our_buffer
  signed int yy_is_our_buffer;
  // yy_is_interactive
  signed int yy_is_interactive;
  // yy_at_bol
  signed int yy_at_bol;
  // yy_bs_lineno
  signed int yy_bs_lineno;
  // yy_bs_column
  signed int yy_bs_column;
  // yy_fill_buffer
  signed int yy_fill_buffer;
  // yy_buffer_status
  signed int yy_buffer_status;
};

union yyalloc
{
  // yyss_alloc
  signed short int yyss_alloc;
  // yyvs_alloc
  union value yyvs_alloc;
};

struct yyguts_t
{
  // yyextra_r
  void *yyextra_r;
  // yyin_r
  struct _IO_FILE *yyin_r;
  // yyout_r
  struct _IO_FILE *yyout_r;
  // yy_buffer_stack_top
  unsigned long int yy_buffer_stack_top;
  // yy_buffer_stack_max
  unsigned long int yy_buffer_stack_max;
  // yy_buffer_stack
  struct yy_buffer_state **yy_buffer_stack;
  // yy_hold_char
  char yy_hold_char;
  // yy_n_chars
  unsigned long int yy_n_chars;
  // yyleng_r
  unsigned long int yyleng_r;
  // yy_c_buf_p
  char *yy_c_buf_p;
  // yy_init
  signed int yy_init;
  // yy_start
  signed int yy_start;
  // yy_did_buffer_switch_on_eof
  signed int yy_did_buffer_switch_on_eof;
  // yy_start_stack_ptr
  signed int yy_start_stack_ptr;
  // yy_start_stack_depth
  signed int yy_start_stack_depth;
  // yy_start_stack
  signed int *yy_start_stack;
  // yy_last_accepting_state
  signed int yy_last_accepting_state;
  // yy_last_accepting_cpos
  char *yy_last_accepting_cpos;
  // yylineno_r
  signed int yylineno_r;
  // yy_flex_debug_r
  signed int yy_flex_debug_r;
  // yytext_r
  char *yytext_r;
  // yy_more_flag
  signed int yy_more_flag;
  // yy_more_len
  signed int yy_more_len;
  // yylval_r
  union value *yylval_r;
};


// acq_run
// file tia-server.c line 75
static signed int acq_run = -1;
// acq_ts
// file tia-server.c line 76
static struct timespec acq_ts;
// blocksize
// file tia-server.c line 82
static unsigned int blocksize = (unsigned int)10;
// charset_aliases
// file localcharset.c line 119
static const char * volatile charset_aliases;
// charset_aliases$link1
// file localcharset.c line 119
static const char * volatile charset_aliases$link1;
// chtype
// file tia-server.c line 80
static const char *chtype[3l] = { "eeg", "emg", "event" };
// cond
// file tia-server.c line 74
static union anonymous$7 cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// convtable
// file typecast.c line 114
static void (*convtable[3l][2l][3l])(void *, const void *, union gval, unsigned long int);
// convtable
// file typecast.c line 114
static void (*convtable[3l][2l][3l])(void *, const void *, union gval, unsigned long int) = { { { identity, castnosc_int32_t_float, castnosc_int32_t_double },
    { cast_int32_t_int32_t, cast_int32_t_float, cast_int32_t_double } },
    { { castnosc_float_int32_t, identity, castnosc_float_double },
    { cast_float_int32_t, cast_float_float, cast_float_double } },
    { { castnosc_double_int32_t, castnosc_double_float, identity },
    { cast_double_int32_t, cast_double_float, cast_double_double } } };
// ctrl_thid
// file tia-server.c line 70
static unsigned long int ctrl_thid;
// data_thid
// file tia-server.c line 70
static unsigned long int data_thid;
// datafd
// file tia-server.c line 71
static signed int datafd = -1;
// default_confpath
// file opendev.c line 33
const char default_confpath[12l] = { '/', 'e', 't', 'c', '/', 'e', 'e', 'g', 'd', 'e', 'v', 0 };
// devhost
// file systobiia.c line 41
static const char *devhost = (const char *)(void *)0;
// eegdev_string
// file core.c line 747
static char eegdev_string[11l] = { 'e', 'e', 'g', 'd', 'e', 'v', ' ', '0', '.', '2', 0 };
// first
// file sensortypes.c line 39
static struct sensor_type first = { .next=(struct sensor_type *)(void *)0, .stype=-1,
    .name={  } };
// fresh_once
// file glthread/lock.c line 454
static const signed int fresh_once = 0;
// fresh_once$link1
// file glthread/lock.c line 454
static const signed int fresh_once$link1 = 0;
// grp
// file systobiia.c line 44
static struct grpconf grp[3l] = { { .sensortype=0, .index=(unsigned int)0, .nch=(unsigned int)64,
    .iarray=(unsigned int)0, .arr_offset=(unsigned int)0,
    .datatype=1 },
    { .sensortype=0, .index=(unsigned int)0, .nch=(unsigned int)0,
    .iarray=(unsigned int)1, .arr_offset=(unsigned int)0,
    .datatype=1 },
    { .sensortype=0, .index=(unsigned int)0, .nch=(unsigned int)1,
    .iarray=(unsigned int)2, .arr_offset=(unsigned int)0,
    .datatype=0 } };
// listenfd
// file tia-server.c line 71
static signed int listenfd = -1;
// lock
// file tia-server.c line 73
static union anonymous$0 lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// num_sig_ch
// file tia-server.c line 79
static const unsigned int num_sig_ch[3l] = { (const unsigned int)16, (const unsigned int)4, (const unsigned int)1 };
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// prefered_devices
// file opendev.c line 106
static const char *prefered_devices[4l] = { "biosemi", "gtec", "datafile", (const char *)(void *)0 };
// prot_request
// file tia-server.c line 53
static const char * const prot_request[6l] = { "CheckProtocolVersion", "GetMetaInfo", "GetDataConnection: TCP", "StartDataTransmission", "StopDataTransmission", "GetServerStateConnection" };
// samplingrate
// file tia-server.c line 81
static unsigned int samplingrate = (unsigned int)128;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// stype_lock
// file sensortypes.c line 38
static union anonymous$0 stype_lock;
// stype_once
// file sensortypes.c line 37
static signed int stype_once = 0;
// type_flags
// file tia-server.c line 78
static const unsigned int type_flags = (const unsigned int)(0x00000001 | 0x00000002 | 0x00200000);
// verbose
// file systobiia.c line 42
static signed int verbose = 0;
// yy_accept
// file conffile.lex.c line 390
static const signed short int yy_accept[16l] = { (const signed short int)0, (const signed short int)1, (const signed short int)1, (const signed short int)7, (const signed short int)6, (const signed short int)5, (const signed short int)3, (const signed short int)6, (const signed short int)4, (const signed short int)1, (const signed short int)2, (const signed short int)5, (const signed short int)3, (const signed short int)4, (const signed short int)1, (const signed short int)0 };
// yy_accept$link1
// file confline.lex.c line 390
static const signed short int yy_accept$link1[11l] = { (const signed short int)0, (const signed short int)1, (const signed short int)1, (const signed short int)5, (const signed short int)4, (const signed short int)3, (const signed short int)1, (const signed short int)2, (const signed short int)3, (const signed short int)1, (const signed short int)0 };
// yy_base
// file conffile.lex.c line 433
static const signed short int yy_base[17l] = { (const signed short int)0, (const signed short int)0, (const signed short int)0, (const signed short int)14, (const signed short int)15, (const signed short int)11, (const signed short int)15, (const signed short int)9, (const signed short int)0, (const signed short int)5, (const signed short int)15, (const signed short int)8, (const signed short int)15, (const signed short int)0, (const signed short int)3, (const signed short int)15, (const signed short int)7 };
// yy_base$link1
// file confline.lex.c line 432
static const signed short int yy_base$link1[13l] = { (const signed short int)0, (const signed short int)0, (const signed short int)0, (const signed short int)7, (const signed short int)8, (const signed short int)0, (const signed short int)0, (const signed short int)8, (const signed short int)0, (const signed short int)0, (const signed short int)8, (const signed short int)4, (const signed short int)2 };
// yy_chk
// file conffile.lex.c line 452
static const signed short int yy_chk[23l] = { (const signed short int)0, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)16, (const signed short int)14, (const signed short int)11, (const signed short int)9, (const signed short int)7, (const signed short int)5, (const signed short int)3, (const signed short int)15, (const signed short int)15, (const signed short int)15, (const signed short int)15, (const signed short int)15, (const signed short int)15, (const signed short int)15, (const signed short int)15 };
// yy_chk$link1
// file confline.lex.c line 450
static const signed short int yy_chk$link1[13l] = { (const signed short int)0, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)12, (const signed short int)11, (const signed short int)3, (const signed short int)10, (const signed short int)10, (const signed short int)10, (const signed short int)10, (const signed short int)10 };
// yy_def
// file conffile.lex.c line 439
static const signed short int yy_def[17l] = { (const signed short int)0, (const signed short int)15, (const signed short int)1, (const signed short int)15, (const signed short int)15, (const signed short int)15, (const signed short int)15, (const signed short int)15, (const signed short int)16, (const signed short int)15, (const signed short int)15, (const signed short int)15, (const signed short int)15, (const signed short int)16, (const signed short int)15, (const signed short int)0, (const signed short int)15 };
// yy_def$link1
// file confline.lex.c line 438
static const signed short int yy_def$link1[13l] = { (const signed short int)0, (const signed short int)10, (const signed short int)1, (const signed short int)10, (const signed short int)10, (const signed short int)11, (const signed short int)12, (const signed short int)10, (const signed short int)11, (const signed short int)12, (const signed short int)0, (const signed short int)10, (const signed short int)10 };
// yy_ec
// file conffile.lex.c line 396
static const signed int yy_ec[256l] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1, 1, 1, 7, 1, 1, 1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1, 1, 1, 1, 6, 1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
// yy_ec$link1
// file confline.lex.c line 395
static const signed int yy_ec$link1[256l] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
// yy_meta
// file conffile.lex.c line 428
static const signed int yy_meta[8l] = { 0, 1, 1, 2, 1, 1, 1, 1 };
// yy_meta$link1
// file confline.lex.c line 427
static const signed int yy_meta$link1[5l] = { 0, 1, 2, 3, 1 };
// yy_nxt
// file conffile.lex.c line 445
static const signed short int yy_nxt[23l] = { (const signed short int)0, (const signed short int)4, (const signed short int)5, (const signed short int)6, (const signed short int)7, (const signed short int)8, (const signed short int)9, (const signed short int)10, (const signed short int)13, (const signed short int)14, (const signed short int)11, (const signed short int)14, (const signed short int)12, (const signed short int)11, (const signed short int)15, (const signed short int)3, (const signed short int)15, (const signed short int)15, (const signed short int)15, (const signed short int)15, (const signed short int)15, (const signed short int)15, (const signed short int)15 };
// yy_nxt$link1
// file confline.lex.c line 444
static const signed short int yy_nxt$link1[13l] = { (const signed short int)0, (const signed short int)4, (const signed short int)5, (const signed short int)6, (const signed short int)7, (const signed short int)9, (const signed short int)8, (const signed short int)10, (const signed short int)3, (const signed short int)10, (const signed short int)10, (const signed short int)10, (const signed short int)10 };
// yy_rule_can_match_eol
// file conffile.lex.c line 460
static const signed int yy_rule_can_match_eol[7l] = { 0, 0, 0, 1, 0, 0, 0 };
// yy_rule_can_match_eol$link1
// file confline.lex.c line 457
static const signed int yy_rule_can_match_eol$link1[5l] = { 0, 0, 0, 0, 0 };
// yycheck
// file conffile.tab.c line 521
static const unsigned char yycheck[6l] = { (const unsigned char)0, (const unsigned char)5, (const unsigned char)3, (const unsigned char)3, (const unsigned char)4, (const unsigned char)4 };
// yycheck$link1
// file confline.tab.c line 522
static const signed char yycheck$link1[9l] = { (const signed char)3, (const signed char)0, (const signed char)4, (const signed char)3, (const signed char)10, (const signed char)-1, (const signed char)4, (const signed char)4, (const signed char)3 };
// yydefact
// file conffile.tab.c line 496
static const unsigned char yydefact[9l] = { (const unsigned char)2, (const unsigned char)0, (const unsigned char)1, (const unsigned char)0, (const unsigned char)4, (const unsigned char)3, (const unsigned char)0, (const unsigned char)0, (const unsigned char)5 };
// yydefact$link1
// file confline.tab.c line 496
static const unsigned char yydefact$link1[13l] = { (const unsigned char)2, (const unsigned char)5, (const unsigned char)0, (const unsigned char)3, (const unsigned char)1, (const unsigned char)0, (const unsigned char)0, (const unsigned char)4, (const unsigned char)6, (const unsigned char)0, (const unsigned char)0, (const unsigned char)8, (const unsigned char)7 };
// yydefgoto
// file conffile.tab.c line 508
static const signed char yydefgoto[3l] = { (const signed char)-1, (const signed char)1, (const signed char)5 };
// yydefgoto$link1
// file confline.tab.c line 509
static const signed char yydefgoto$link1[5l] = { (const signed char)-1, (const signed char)2, (const signed char)3, (const signed char)7, (const signed char)8 };
// yypact
// file conffile.tab.c line 488
static const signed char yypact[9l] = { (const signed char)-5, (const signed char)0, (const signed char)-5, (const signed char)-4, (const signed char)-5, (const signed char)-5, (const signed char)-1, (const signed char)1, (const signed char)-5 };
// yypact$link1
// file confline.tab.c line 487
static const signed char yypact$link1[13l] = { (const signed char)-3, (const signed char)-7, (const signed char)1, (const signed char)-2, (const signed char)-7, (const signed char)0, (const signed char)2, (const signed char)3, (const signed char)-7, (const signed char)5, (const signed char)0, (const signed char)-7, (const signed char)-7 };
// yypgoto
// file conffile.tab.c line 502
static const signed char yypgoto[3l] = { (const signed char)-5, (const signed char)-5, (const signed char)-5 };
// yypgoto$link1
// file confline.tab.c line 503
static const signed char yypgoto$link1[5l] = { (const signed char)-7, (const signed char)-7, (const signed char)-7, (const signed char)-7, (const signed char)-6 };
// yyr1
// file conffile.tab.c line 534
static const unsigned char yyr1[6l] = { (const unsigned char)0, (const unsigned char)6, (const unsigned char)7, (const unsigned char)7, (const unsigned char)7, (const unsigned char)8 };
// yyr1$link1
// file confline.tab.c line 536
static const unsigned char yyr1$link1[9l] = { (const unsigned char)0, (const unsigned char)5, (const unsigned char)6, (const unsigned char)6, (const unsigned char)6, (const unsigned char)7, (const unsigned char)8, (const unsigned char)8, (const unsigned char)9 };
// yyr2
// file conffile.tab.c line 540
static const unsigned char yyr2[6l] = { (const unsigned char)0, (const unsigned char)2, (const unsigned char)0, (const unsigned char)2, (const unsigned char)2, (const unsigned char)4 };
// yyr2$link1
// file confline.tab.c line 542
static const unsigned char yyr2$link1[9l] = { (const unsigned char)0, (const unsigned char)2, (const unsigned char)0, (const unsigned char)1, (const unsigned char)3, (const unsigned char)1, (const unsigned char)1, (const unsigned char)3, (const unsigned char)3 };
// yystos
// file conffile.tab.c line 528
static const unsigned char yystos[9l] = { (const unsigned char)0, (const unsigned char)7, (const unsigned char)0, (const unsigned char)3, (const unsigned char)4, (const unsigned char)8, (const unsigned char)5, (const unsigned char)3, (const unsigned char)4 };
// yystos$link1
// file confline.tab.c line 529
static const unsigned char yystos$link1[13l] = { (const unsigned char)0, (const unsigned char)3, (const unsigned char)6, (const unsigned char)7, (const unsigned char)0, (const unsigned char)4, (const unsigned char)3, (const unsigned char)8, (const unsigned char)9, (const unsigned char)4, (const unsigned char)4, (const unsigned char)3, (const unsigned char)9 };
// yytable
// file conffile.tab.c line 516
static const unsigned char yytable[6l] = { (const unsigned char)2, (const unsigned char)6, (const unsigned char)7, (const unsigned char)3, (const unsigned char)4, (const unsigned char)8 };
// yytable$link1
// file confline.tab.c line 517
static const unsigned char yytable$link1[9l] = { (const unsigned char)1, (const unsigned char)4, (const unsigned char)5, (const unsigned char)6, (const unsigned char)12, (const unsigned char)0, (const unsigned char)9, (const unsigned char)10, (const unsigned char)11 };
// yytranslate
// file conffile.tab.c line 419
static const unsigned char yytranslate[260l] = { (const unsigned char)0, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)5, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)1, (const unsigned char)2, (const unsigned char)3, (const unsigned char)4 };
// yytranslate$link1
// file confline.tab.c line 418
static const unsigned char yytranslate$link1[259l] = { (const unsigned char)0, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)4, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)1, (const unsigned char)2, (const unsigned char)3 };

// add_sensor_type
// file sensortypes.c line 42
static signed int add_sensor_type(const char *sname, struct sensor_type *start)
{
  unsigned int len;
  struct sensor_type *newtype;
  struct sensor_type *curr = start != ((struct sensor_type *)NULL) ? start : &first;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(sname);
  len = (unsigned int)return_value_strlen$1;
  if(len == 0u)
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 22;
    return -1;
  }

  while(!(curr->next == ((struct sensor_type *)NULL)))
  {
    curr = curr->next;
    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp(sname, curr->name);
    if(return_value_strcmp$3 == 0)
      return curr->stype;

  }
  void *return_value_malloc$4;
  return_value_malloc$4=malloc(sizeof(struct sensor_type) /*16ul*/  + (unsigned long int)len + (unsigned long int)1);
  newtype = (struct sensor_type *)return_value_malloc$4;
  if(newtype == ((struct sensor_type *)NULL))
    return -1;

  else
  {
    memcpy((void *)newtype->name, (const void *)sname, (unsigned long int)(len + (unsigned int)1));
    newtype->stype = curr->stype + 1;
    newtype->next = (struct sensor_type *)(void *)0;
    curr->next = newtype;
    return newtype->stype;
  }
}

// addtime
// file time-utils.h line 26
static inline signed int addtime(struct timespec *ts, signed long int sec, signed long int nsec)
{
  if(nsec >= 1000000000l || !(nsec >= -999999999l))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }

  ts->tv_sec = ts->tv_sec + sec;
  ts->tv_nsec = ts->tv_nsec + nsec;
  if(ts->tv_nsec >= 1000000000l)
  {
    ts->tv_nsec = ts->tv_nsec - (signed long int)1000000000;
    ts->tv_sec = ts->tv_sec + (signed long int)1;
  }

  else
    if(!(ts->tv_nsec >= 0l))
    {
      ts->tv_nsec = ts->tv_nsec + (signed long int)1000000000;
      ts->tv_sec = ts->tv_sec - (signed long int)1;
    }

  return 0;
}

// asnprintf
// file asnprintf.c line 25
extern char * asnprintf(char *resultbuf, unsigned long int *lengthp, const char *format, ...)
{
  void **args;
  char *result;
  args = (void **)&format;
  result=vasnprintf(resultbuf, lengthp, format, args);
  args = ((void **)NULL);
  return result;
}

// cast_data
// file core.c line 111
static unsigned int cast_data(struct eegdev * restrict dev, const void * restrict in, unsigned long int length)
{
  unsigned int i;
  unsigned int ns = (unsigned int)0;
  const char *pi = (const char *)in;
  char * restrict ringbuffer = dev->buffer;
  struct input_buffer_group *ibgrp = dev->inbuffgrp;
  unsigned long int offset = dev->in_offset;
  unsigned long int ind = (unsigned long int)dev->ind;
  signed long int len;
  signed long int inoff;
  signed long int buffoff;
  signed long int rest;
  signed long int inlen = (signed long int)length;
  for( ; !(inlen == 0l); ind = (ind + dev->buff_samlen) % dev->buffsize)
  {
    i = (unsigned int)0;
    for( ; !(i >= dev->ngrp); i = i + 1u)
    {
      len = (signed long int)(ibgrp + (signed long int)i)->inlen;
      inoff = (signed long int)((unsigned long int)(ibgrp + (signed long int)i)->in_offset - offset);
      buffoff = (signed long int)(ibgrp + (signed long int)i)->buff_offset;
      if(!(inoff >= 0l))
      {
        len = len + inoff;
        if(!(len >= 1l))
          goto __CPROVER_DUMP_L4;

        buffoff = buffoff - ((signed long int)(ibgrp + (signed long int)i)->buff_tsize * inoff) / (signed long int)(ibgrp + (signed long int)i)->in_tsize;
        inoff = (signed long int)0;
      }

      rest = inlen - inoff;
      if(rest >= 1l)
      {
        len = len <= rest ? len : rest;
        (ibgrp + (signed long int)i)->cast_fn((void *)(ringbuffer + (signed long int)ind + buffoff), (const void *)(pi + inoff), (ibgrp + (signed long int)i)->sc, (unsigned long int)len);
      }


    __CPROVER_DUMP_L4:
      ;
    }
    rest = (signed long int)(dev->in_samlen - offset);
    if(!(inlen >= rest))
      break;

    inlen = inlen - rest;
    pi = pi + rest;
    offset = (unsigned long int)0;
    ns = ns + 1u;
  }
  dev->ind = (unsigned int)ind;
  return ns;
}

// cast_double_double
// file typecast.c line 92
static void cast_double_double(void * restrict d, const void * restrict s, union gval sc, unsigned long int len)
{
  const double *src = (const double *)s;
  double *dst = (double *)d;
  double scale = sc.valdouble;
  for( ; !(len == 0ul); len = len - sizeof(const double) /*8ul*/ )
  {
    *dst = scale * (double)*src;
    src = src + 1l;
    dst = dst + 1l;
  }
}

// cast_double_float
// file typecast.c line 90
static void cast_double_float(void * restrict d, const void * restrict s, union gval sc, unsigned long int len)
{
  const double *src = (const double *)s;
  float *dst = (float *)d;
  float scale = sc.valfloat;
  for( ; !(len == 0ul); len = len - sizeof(const double) /*8ul*/ )
  {
    *dst = scale * (float)*src;
    src = src + 1l;
    dst = dst + 1l;
  }
}

// cast_double_int32_t
// file typecast.c line 86
static void cast_double_int32_t(void * restrict d, const void * restrict s, union gval sc, unsigned long int len)
{
  const double *src = (const double *)s;
  signed int *dst = (signed int *)d;
  signed int scale = sc.valint32_t;
  for( ; !(len == 0ul); len = len - sizeof(const double) /*8ul*/ )
  {
    *dst = scale * (signed int)*src;
    src = src + 1l;
    dst = dst + 1l;
  }
}

// cast_float_double
// file typecast.c line 89
static void cast_float_double(void * restrict d, const void * restrict s, union gval sc, unsigned long int len)
{
  const float *src = (const float *)s;
  double *dst = (double *)d;
  double scale = sc.valdouble;
  for( ; !(len == 0ul); len = len - sizeof(const float) /*4ul*/ )
  {
    *dst = scale * (double)*src;
    src = src + 1l;
    dst = dst + 1l;
  }
}

// cast_float_float
// file typecast.c line 91
static void cast_float_float(void * restrict d, const void * restrict s, union gval sc, unsigned long int len)
{
  const float *src = (const float *)s;
  float *dst = (float *)d;
  float scale = sc.valfloat;
  for( ; !(len == 0ul); len = len - sizeof(const float) /*4ul*/ )
  {
    *dst = scale * (float)*src;
    src = src + 1l;
    dst = dst + 1l;
  }
}

// cast_float_int32_t
// file typecast.c line 88
static void cast_float_int32_t(void * restrict d, const void * restrict s, union gval sc, unsigned long int len)
{
  const float *src = (const float *)s;
  signed int *dst = (signed int *)d;
  signed int scale = sc.valint32_t;
  for( ; !(len == 0ul); len = len - sizeof(const float) /*4ul*/ )
  {
    *dst = scale * (signed int)*src;
    src = src + 1l;
    dst = dst + 1l;
  }
}

// cast_int32_t_double
// file typecast.c line 85
static void cast_int32_t_double(void * restrict d, const void * restrict s, union gval sc, unsigned long int len)
{
  const signed int *src = (const signed int *)s;
  /* cast_int32_t_double::1::tag-dstdata */
union dstdata
{
  // Data
  double Data;
  // intData
  unsigned int intData[2l];
};

/* */
  ;
  union dstdata *dst = (union dstdata *)d;
  double scale = sc.valdouble;
  while(!(len == 0ul))
  {
    union dstdata dst_tmp;
    dst_tmp.Data = scale * (double)*src;
    dst->intData[(signed long int)0] = dst_tmp.intData[(signed long int)0];
    dst->intData[(signed long int)1] = dst_tmp.intData[(signed long int)1];
    src = src + 1l;
    dst = dst + 1l;
    len = len - sizeof(const signed int) /*4ul*/ ;
  }
}

// cast_int32_t_float
// file typecast.c line 87
static void cast_int32_t_float(void * restrict d, const void * restrict s, union gval sc, unsigned long int len)
{
  const signed int *src = (const signed int *)s;
  float *dst = (float *)d;
  float scale = sc.valfloat;
  for( ; !(len == 0ul); len = len - sizeof(const signed int) /*4ul*/ )
  {
    *dst = scale * (float)*src;
    src = src + 1l;
    dst = dst + 1l;
  }
}

// cast_int32_t_int32_t
// file typecast.c line 84
static void cast_int32_t_int32_t(void * restrict d, const void * restrict s, union gval sc, unsigned long int len)
{
  const signed int *src = (const signed int *)s;
  signed int *dst = (signed int *)d;
  signed int scale = sc.valint32_t;
  for( ; !(len == 0ul); len = len - sizeof(const signed int) /*4ul*/ )
  {
    *dst = scale * (signed int)*src;
    src = src + 1l;
    dst = dst + 1l;
  }
}

// castnosc_double_float
// file typecast.c line 102
static void castnosc_double_float(void * restrict d, const void * restrict s, union gval sc, unsigned long int len)
{
  (void)sc;
  const double *src = (const double *)s;
  float *dst = (float *)d;
  for( ; !(len == 0ul); len = len - sizeof(const double) /*8ul*/ )
  {
    *dst = (float)*src;
    src = src + 1l;
    dst = dst + 1l;
  }
}

// castnosc_double_int32_t
// file typecast.c line 101
static void castnosc_double_int32_t(void * restrict d, const void * restrict s, union gval sc, unsigned long int len)
{
  (void)sc;
  const double *src = (const double *)s;
  signed int *dst = (signed int *)d;
  for( ; !(len == 0ul); len = len - sizeof(const double) /*8ul*/ )
  {
    *dst = (signed int)*src;
    src = src + 1l;
    dst = dst + 1l;
  }
}

// castnosc_float_double
// file typecast.c line 100
static void castnosc_float_double(void * restrict d, const void * restrict s, union gval sc, unsigned long int len)
{
  (void)sc;
  const float *src = (const float *)s;
  double *dst = (double *)d;
  for( ; !(len == 0ul); len = len - sizeof(const float) /*4ul*/ )
  {
    *dst = (double)*src;
    src = src + 1l;
    dst = dst + 1l;
  }
}

// castnosc_float_int32_t
// file typecast.c line 98
static void castnosc_float_int32_t(void * restrict d, const void * restrict s, union gval sc, unsigned long int len)
{
  (void)sc;
  const float *src = (const float *)s;
  signed int *dst = (signed int *)d;
  for( ; !(len == 0ul); len = len - sizeof(const float) /*4ul*/ )
  {
    *dst = (signed int)*src;
    src = src + 1l;
    dst = dst + 1l;
  }
}

// castnosc_int32_t_double
// file typecast.c line 97
static void castnosc_int32_t_double(void * restrict d, const void * restrict s, union gval sc, unsigned long int len)
{
  (void)sc;
  const signed int *src = (const signed int *)s;
  double *dst = (double *)d;
  for( ; !(len == 0ul); len = len - sizeof(const signed int) /*4ul*/ )
  {
    *dst = (double)*src;
    src = src + 1l;
    dst = dst + 1l;
  }
}

// castnosc_int32_t_float
// file typecast.c line 96
static void castnosc_int32_t_float(void * restrict d, const void * restrict s, union gval sc, unsigned long int len)
{
  (void)sc;
  const signed int *src = (const signed int *)s;
  float *dst = (float *)d;
  for( ; !(len == 0ul); len = len - sizeof(const signed int) /*4ul*/ )
  {
    *dst = (float)*src;
    src = src + 1l;
    dst = dst + 1l;
  }
}

// cff__create_buffer
// file conffile.lex.c line 1367
struct yy_buffer_state * cff__create_buffer(struct _IO_FILE *file, signed int size, void *yyscanner)
{
  struct yy_buffer_state *b;
  void *return_value_cff_alloc$1;
  return_value_cff_alloc$1=cff_alloc(sizeof(struct yy_buffer_state) /*72ul*/ , yyscanner);
  b = (struct yy_buffer_state *)return_value_cff_alloc$1;
  if(b == ((struct yy_buffer_state *)NULL))
    yy_fatal_error("out of dynamic memory in cff__create_buffer()", yyscanner);

  b->yy_buf_size = (unsigned long int)size;
  void *return_value_cff_alloc$2;
  return_value_cff_alloc$2=cff_alloc(b->yy_buf_size + (unsigned long int)2, yyscanner);
  b->yy_ch_buf = (char *)return_value_cff_alloc$2;
  if(b->yy_ch_buf == ((char *)NULL))
    yy_fatal_error("out of dynamic memory in cff__create_buffer()", yyscanner);

  b->yy_is_our_buffer = 1;
  cff__init_buffer(b, file, yyscanner);
  return b;
}

// cff__delete_buffer
// file conffile.lex.c line 1395
void cff__delete_buffer(struct yy_buffer_state *b, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(b == ((struct yy_buffer_state *)NULL)))
  {
    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
    if(b == tmp_if_expr$1)
      yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top] = (struct yy_buffer_state *)0;

    if(!(b->yy_is_our_buffer == 0))
      cff_free((void *)b->yy_ch_buf, yyscanner);

    cff_free((void *)b, yyscanner);
  }

}

// cff__flush_buffer
// file conffile.lex.c line 1444
void cff__flush_buffer(struct yy_buffer_state *b, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(b == ((struct yy_buffer_state *)NULL)))
  {
    b->yy_n_chars = (unsigned long int)0;
    b->yy_ch_buf[(signed long int)0] = (char)0;
    b->yy_ch_buf[(signed long int)1] = (char)0;
    b->yy_buf_pos = &b->yy_ch_buf[(signed long int)0];
    b->yy_at_bol = 1;
    b->yy_buffer_status = 0;
    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
    if(b == tmp_if_expr$1)
      cff__load_buffer_state(yyscanner);

  }

}

// cff__init_buffer
// file conffile.lex.c line 1415
static void cff__init_buffer(struct yy_buffer_state *b, struct _IO_FILE *file, void *yyscanner)
{
  signed int oerrno;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  oerrno = *return_value___errno_location$1;
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  cff__flush_buffer(b, yyscanner);
  b->yy_input_file = file;
  b->yy_fill_buffer = 1;
  struct yy_buffer_state *tmp_if_expr$2;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$2 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$2 = (struct yy_buffer_state *)(void *)0;
  if(!(b == tmp_if_expr$2))
  {
    b->yy_bs_lineno = 1;
    b->yy_bs_column = 0;
  }

  b->yy_is_interactive = 0;
  signed int *return_value___errno_location$3;
  return_value___errno_location$3=__errno_location();
  *return_value___errno_location$3 = oerrno;
}

// cff__load_buffer_state
// file conffile.lex.c line 1352
static void cff__load_buffer_state(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  yyg->yy_n_chars = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_n_chars;
  yyg->yy_c_buf_p = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_buf_pos;
  yyg->yytext_r = yyg->yy_c_buf_p;
  yyg->yyin_r = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_input_file;
  yyg->yy_hold_char = *yyg->yy_c_buf_p;
}

// cff__scan_buffer
// file conffile.lex.c line 1575
struct yy_buffer_state * cff__scan_buffer(char *base, unsigned long int size, void *yyscanner)
{
  struct yy_buffer_state *b;
  _Bool tmp_if_expr$1;
  if(!(size >= 2ul))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)base[(signed long int)(size - (unsigned long int)2)] != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)base[(signed long int)(size - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    return ((struct yy_buffer_state *)NULL);

  else
  {
    void *return_value_cff_alloc$3;
    return_value_cff_alloc$3=cff_alloc(sizeof(struct yy_buffer_state) /*72ul*/ , yyscanner);
    b = (struct yy_buffer_state *)return_value_cff_alloc$3;
    if(b == ((struct yy_buffer_state *)NULL))
      yy_fatal_error("out of dynamic memory in cff__scan_buffer()", yyscanner);

    b->yy_buf_size = size - (unsigned long int)2;
    b->yy_ch_buf = base;
    b->yy_buf_pos = b->yy_ch_buf;
    b->yy_is_our_buffer = 0;
    b->yy_input_file = ((struct _IO_FILE *)NULL);
    b->yy_n_chars = b->yy_buf_size;
    b->yy_is_interactive = 0;
    b->yy_at_bol = 1;
    b->yy_fill_buffer = 0;
    b->yy_buffer_status = 0;
    cff__switch_to_buffer(b, yyscanner);
    return b;
  }
}

// cff__scan_bytes
// file conffile.lex.c line 1625
struct yy_buffer_state * cff__scan_bytes(const char *yybytes, unsigned long int _yybytes_len, void *yyscanner)
{
  struct yy_buffer_state *b;
  char *buf;
  unsigned long int n;
  unsigned long int i;
  n = _yybytes_len + (unsigned long int)2;
  void *return_value_cff_alloc$1;
  return_value_cff_alloc$1=cff_alloc(n, yyscanner);
  buf = (char *)return_value_cff_alloc$1;
  if(buf == ((char *)NULL))
    yy_fatal_error("out of dynamic memory in cff__scan_bytes()", yyscanner);

  i = (unsigned long int)0;
  for( ; !(i >= _yybytes_len); i = i + 1ul)
    buf[(signed long int)i] = yybytes[(signed long int)i];
  buf[(signed long int)(_yybytes_len + (unsigned long int)1)] = (char)0;
  buf[(signed long int)_yybytes_len] = buf[(signed long int)(_yybytes_len + (unsigned long int)1)];
  b=cff__scan_buffer(buf, n, yyscanner);
  if(b == ((struct yy_buffer_state *)NULL))
    yy_fatal_error("bad buffer in cff__scan_bytes()", yyscanner);

  b->yy_is_our_buffer = 1;
  return b;
}

// cff__scan_string
// file conffile.lex.c line 1612
struct yy_buffer_state * cff__scan_string(const char *yystr, void *yyscanner)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(yystr);
  struct yy_buffer_state *return_value_cff__scan_bytes$2;
  return_value_cff__scan_bytes$2=cff__scan_bytes(yystr, return_value_strlen$1, yyscanner);
  return return_value_cff__scan_bytes$2;
}

// cff__switch_to_buffer
// file conffile.lex.c line 1320
void cff__switch_to_buffer(struct yy_buffer_state *new_buffer, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  cff_ensure_buffer_stack(yyscanner);
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
  struct yy_buffer_state *tmp_if_expr$2;
  if(!(tmp_if_expr$1 == new_buffer))
  {
    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$2 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$2 = (struct yy_buffer_state *)(void *)0;
    if(!(tmp_if_expr$2 == ((struct yy_buffer_state *)NULL)))
    {
      *yyg->yy_c_buf_p = yyg->yy_hold_char;
      yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_buf_pos = yyg->yy_c_buf_p;
      yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_n_chars = yyg->yy_n_chars;
    }

    yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top] = new_buffer;
    cff__load_buffer_state(yyscanner);
    yyg->yy_did_buffer_switch_on_eof = 1;
  }

}

// cff_alloc
// file conffile.l line 62
void * cff_alloc(unsigned long int size, void *yyscanner)
{
  (void)yyscanner;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(size);
  return return_value_malloc$1;
}

// cff_ensure_buffer_stack
// file conffile.lex.c line 1525
static void cff_ensure_buffer_stack(void *yyscanner)
{
  unsigned long int num_to_alloc;
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  if(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL))
  {
    num_to_alloc = (unsigned long int)1;
    void *return_value_cff_alloc$1;
    return_value_cff_alloc$1=cff_alloc(num_to_alloc * sizeof(struct yy_buffer_state *) /*8ul*/ , yyscanner);
    yyg->yy_buffer_stack = (struct yy_buffer_state **)return_value_cff_alloc$1;
    if(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL))
      yy_fatal_error("out of dynamic memory in cff_ensure_buffer_stack()", yyscanner);

    memset((void *)yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state *) /*8ul*/ );
    yyg->yy_buffer_stack_max = num_to_alloc;
    yyg->yy_buffer_stack_top = (unsigned long int)0;
    goto __CPROVER_DUMP_L5;
  }

  if(yyg->yy_buffer_stack_top >= yyg->yy_buffer_stack_max + 18446744073709551615ul)
  {
    signed int grow_size = 8;
    num_to_alloc = yyg->yy_buffer_stack_max + (unsigned long int)grow_size;
    void *return_value_cff_realloc$2;
    return_value_cff_realloc$2=cff_realloc((void *)yyg->yy_buffer_stack, num_to_alloc * sizeof(struct yy_buffer_state *) /*8ul*/ , yyscanner);
    yyg->yy_buffer_stack = (struct yy_buffer_state **)return_value_cff_realloc$2;
    if(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL))
      yy_fatal_error("out of dynamic memory in cff_ensure_buffer_stack()", yyscanner);

    memset((void *)(yyg->yy_buffer_stack + (signed long int)yyg->yy_buffer_stack_max), 0, (unsigned long int)grow_size * sizeof(struct yy_buffer_state *) /*8ul*/ );
    yyg->yy_buffer_stack_max = num_to_alloc;
  }


__CPROVER_DUMP_L5:
  ;
}

// cff_error
// file conffile.tab.c line 1463
static signed int cff_error(struct cfdata *pp, const char *s)
{
  fprintf(stderr, "error while parsing (%s): %s\n", pp->fpath, s);
  return 0;
}

// cff_free
// file conffile.l line 78
void cff_free(void *ptr, void *yyscanner)
{
  (void)yyscanner;
  free(ptr);
}

// cff_get_column
// file conffile.lex.c line 1709
signed int cff_get_column(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
  if(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL))
    return 0;

  else
    return yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_bs_column;
}

// cff_get_debug
// file conffile.lex.c line 1814
signed int cff_get_debug(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  return yyg->yy_flex_debug_r;
}

// cff_get_extra
// file conffile.lex.c line 1687
void * cff_get_extra(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  return yyg->yyextra_r;
}

// cff_get_in
// file conffile.lex.c line 1722
struct _IO_FILE * cff_get_in(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  return yyg->yyin_r;
}

// cff_get_leng
// file conffile.lex.c line 1740
unsigned long int cff_get_leng(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  return yyg->yyleng_r;
}

// cff_get_lineno
// file conffile.lex.c line 1696
signed int cff_get_lineno(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
  if(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL))
    return 0;

  else
    return yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_bs_lineno;
}

// cff_get_lval
// file conffile.lex.c line 1828
union value * cff_get_lval(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  return yyg->yylval_r;
}

// cff_get_out
// file conffile.lex.c line 1731
struct _IO_FILE * cff_get_out(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  return yyg->yyout_r;
}

// cff_get_text
// file conffile.lex.c line 1750
char * cff_get_text(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  return yyg->yytext_r;
}

// cff_lex
// file conffile.lex.c line 733
extern signed int cff_lex(union value *yylval_param, void *yyscanner)
{
  signed int yy_current_state;
  char *yy_cp;
  char *yy_bp;
  signed int yy_act;
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  yyg->yylval_r = yylval_param;
  struct yy_buffer_state *tmp_if_expr$1;
  if(yyg->yy_init == 0)
  {
    yyg->yy_init = 1;
    if(yyg->yy_start == 0)
      yyg->yy_start = 1;

    if(yyg->yyin_r == ((struct _IO_FILE *)NULL))
      yyg->yyin_r = stdin;

    if(yyg->yyout_r == ((struct _IO_FILE *)NULL))
      yyg->yyout_r = stdout;

    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
    if(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL))
    {
      cff_ensure_buffer_stack(yyscanner);
      yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]=cff__create_buffer(yyg->yyin_r, 16384, yyscanner);
    }

    cff__load_buffer_state(yyscanner);
  }

  struct cfdata *pp = (struct cfdata *)yyg->yyextra_r;
  signed int yy_amount_of_matched_text;
  signed int return_value_yy_get_next_buffer$4;
  while((_Bool)1)
  {
    yy_cp = yyg->yy_c_buf_p;
    *yy_cp = yyg->yy_hold_char;
    yy_bp = yy_cp;
    yy_current_state = yyg->yy_start;
    do
    {

    yy_match:
      ;
      unsigned char yy_c = (unsigned char)yy_ec[(signed long int)(unsigned int)(unsigned char)*yy_cp];
      if(!(yy_accept[(signed long int)yy_current_state] == 0))
      {
        yyg->yy_last_accepting_state = yy_current_state;
        yyg->yy_last_accepting_cpos = yy_cp;
      }

      while(!((signed int)yy_chk[(signed long int)((signed int)yy_base[(signed long int)yy_current_state] + (signed int)yy_c)] == yy_current_state))
      {
        yy_current_state = (signed int)yy_def[(signed long int)yy_current_state];
        if(yy_current_state >= 16)
          yy_c = (unsigned char)yy_meta[(signed long int)(unsigned int)yy_c];

      }
      yy_current_state = (signed int)yy_nxt[(signed long int)((unsigned int)yy_base[(signed long int)yy_current_state] + (unsigned int)yy_c)];
      yy_cp = yy_cp + 1l;
      if(!(yy_current_state == 15))
        goto yy_match;

      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;

    yy_find_action:
      ;
      yy_act = (signed int)yy_accept[(signed long int)yy_current_state];
      yyg->yytext_r = yy_bp;
      yyg->yyleng_r = (unsigned long int)(yy_cp - yy_bp);
      yyg->yy_hold_char = *yy_cp;
      *yy_cp = (char)0;
      yyg->yy_c_buf_p = yy_cp;
      if(!(yy_act == 7))
      {
        if(!(yy_rule_can_match_eol[(signed long int)yy_act] == 0))
        {
          unsigned long int yyl = (unsigned long int)0;
          for( ; !(yyl >= yyg->yyleng_r); yyl = yyl + 1ul)
            if((signed int)yyg->yytext_r[(signed long int)yyl] == 10)
              do
              {
                yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_bs_lineno = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_bs_lineno + 1;
                yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_bs_column = 0;
              }
              while((_Bool)0);

        }

      }


    do_action:
      ;
      for( ; (_Bool)1; yy_act = 7 + (yyg->yy_start - 1) / 2 + 1)
      {
        if(!(yy_act == 0))
        {
          if(yy_act == 1)
            goto __CPROVER_DUMP_L20;

          if(yy_act == 2)
            goto __CPROVER_DUMP_L22;

          if(yy_act == 3)
            goto __CPROVER_DUMP_L23;

          if(yy_act == 4)
            goto __CPROVER_DUMP_L24;

          if(yy_act == 5)
            goto __CPROVER_DUMP_L25;

          if(yy_act == 6)
            goto __CPROVER_DUMP_L26;

          if(yy_act == 1)
            goto __CPROVER_DUMP_L27;

          if(yy_act == 7)
            goto __CPROVER_DUMP_L28;

          goto __CPROVER_DUMP_L39;
        }

        *yy_cp = yyg->yy_hold_char;
        yy_cp = yyg->yy_last_accepting_cpos;
        yy_current_state = yyg->yy_last_accepting_state;
        goto yy_find_action;

      __CPROVER_DUMP_L20:
        ;
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(yyg->yytext_r);
        if(return_value_strlen$2 >= 64ul)
          return -1;

        strcpy(pp->tokbuff[(signed long int)pp->itok], yyg->yytext_r);
        yyg->yylval_r->str = pp->tokbuff[(signed long int)pp->itok];
        pp->itok = (pp->itok + 1) % 2;
        return 258;

      __CPROVER_DUMP_L22:
        ;
        return (signed int)yyg->yytext_r[(signed long int)0];

      __CPROVER_DUMP_L23:
        ;
        return 259;

      __CPROVER_DUMP_L24:
        ;
        goto __CPROVER_DUMP_L40;

      __CPROVER_DUMP_L25:
        ;
        goto __CPROVER_DUMP_L40;
        do
        {

        __CPROVER_DUMP_L26:
          ;
          unsigned long int return_value_fwrite$3;
          return_value_fwrite$3=fwrite((const void *)yyg->yytext_r, yyg->yyleng_r, (unsigned long int)1, yyg->yyout_r);
        }
        while((_Bool)0);
        goto __CPROVER_DUMP_L40;

      __CPROVER_DUMP_L27:
        ;
        return 0;

      __CPROVER_DUMP_L28:
        ;
        yy_amount_of_matched_text = (signed int)(yy_cp - yyg->yytext_r) - 1;
        *yy_cp = yyg->yy_hold_char;
        if(yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_buffer_status == 0)
        {
          yyg->yy_n_chars = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_n_chars;
          yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_input_file = yyg->yyin_r;
          yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_buffer_status = 1;
        }

        if(yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_ch_buf + (signed long int)yyg->yy_n_chars >= yyg->yy_c_buf_p)
        {
          signed int yy_next_state;
          yyg->yy_c_buf_p = yyg->yytext_r + (signed long int)yy_amount_of_matched_text;
          yy_current_state=yy_get_previous_state(yyscanner);
          yy_next_state=yy_try_NUL_trans(yy_current_state, yyscanner);
          yy_bp = yyg->yytext_r + (signed long int)0;
          if(!(yy_next_state == 0))
          {
            yyg->yy_c_buf_p = yyg->yy_c_buf_p + 1l;
            yy_cp = yyg->yy_c_buf_p;
            yy_current_state = yy_next_state;
            goto yy_match;
          }

          else
          {
            yy_cp = yyg->yy_last_accepting_cpos;
            yy_current_state = yyg->yy_last_accepting_state;
            goto yy_find_action;
          }
        }

        return_value_yy_get_next_buffer$4=yy_get_next_buffer(yyscanner);
        if(!(return_value_yy_get_next_buffer$4 == 1))
        {
          if(return_value_yy_get_next_buffer$4 == 0)
            goto __CPROVER_DUMP_L36;

          if(return_value_yy_get_next_buffer$4 == 2)
            goto __CPROVER_DUMP_L37;

          goto __CPROVER_DUMP_L38;
        }

        yyg->yy_did_buffer_switch_on_eof = 0;
        yyg->yy_c_buf_p = yyg->yytext_r + (signed long int)0;
      }
      if(yyg->yy_did_buffer_switch_on_eof == 0)
        cff_restart(yyg->yyin_r, yyscanner);

      goto __CPROVER_DUMP_L38;

    __CPROVER_DUMP_L36:
      ;
      yyg->yy_c_buf_p = yyg->yytext_r + (signed long int)yy_amount_of_matched_text;
      yy_current_state=yy_get_previous_state(yyscanner);
      yy_cp = yyg->yy_c_buf_p;
      yy_bp = yyg->yytext_r + (signed long int)0;
    }
    while((_Bool)1);

  __CPROVER_DUMP_L37:
    ;
    yyg->yy_c_buf_p = &yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_ch_buf[(signed long int)yyg->yy_n_chars];
    yy_current_state=yy_get_previous_state(yyscanner);
    yy_cp = yyg->yy_c_buf_p;
    yy_bp = yyg->yytext_r + (signed long int)0;
    goto yy_find_action;

  __CPROVER_DUMP_L38:
    ;
    continue;

  __CPROVER_DUMP_L39:
    ;
    yy_fatal_error("fatal flex scanner internal error--no action found", yyscanner);

  __CPROVER_DUMP_L40:
    ;
  }
}

// cff_lex_destroy
// file conffile.lex.c line 1938
signed int cff_lex_destroy(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  struct yy_buffer_state *tmp_if_expr$2;
  do
  {
    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
    if(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL))
      break;

    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$2 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$2 = (struct yy_buffer_state *)(void *)0;
    cff__delete_buffer(tmp_if_expr$2, yyscanner);
    yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top] = (struct yy_buffer_state *)(void *)0;
    cff_pop_buffer_state(yyscanner);
  }
  while((_Bool)1);
  cff_free((void *)yyg->yy_buffer_stack, yyscanner);
  yyg->yy_buffer_stack = (struct yy_buffer_state **)(void *)0;
  cff_free((void *)yyg->yy_start_stack, yyscanner);
  yyg->yy_start_stack = (signed int *)(void *)0;
  yy_init_globals(yyscanner);
  cff_free(yyscanner, yyscanner);
  yyscanner = (void *)0;
  return 0;
}

// cff_lex_init
// file conffile.lex.c line 1847
signed int cff_lex_init(void **ptr_yy_globals)
{
  if(ptr_yy_globals == ((void **)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return 1;
  }

  void *return_value_cff_alloc$2;
  return_value_cff_alloc$2=cff_alloc(sizeof(struct yyguts_t) /*160ul*/ , (void *)0);
  *ptr_yy_globals = (void *)return_value_cff_alloc$2;
  if(*ptr_yy_globals == NULL)
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 12;
    return 1;
  }

  memset(*ptr_yy_globals, 0x00, sizeof(struct yyguts_t) /*160ul*/ );
  signed int return_value_yy_init_globals$4;
  return_value_yy_init_globals$4=yy_init_globals(*ptr_yy_globals);
  return return_value_yy_init_globals$4;
}

// cff_lex_init_extra
// file conffile.lex.c line 1876
signed int cff_lex_init_extra(void *yy_user_defined, void **ptr_yy_globals)
{
  struct yyguts_t dummy_yyguts;
  cff_set_extra(yy_user_defined, (void *)&dummy_yyguts);
  if(ptr_yy_globals == ((void **)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return 1;
  }

  void *return_value_cff_alloc$2;
  return_value_cff_alloc$2=cff_alloc(sizeof(struct yyguts_t) /*160ul*/ , (void *)&dummy_yyguts);
  *ptr_yy_globals = (void *)return_value_cff_alloc$2;
  if(*ptr_yy_globals == NULL)
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 12;
    return 1;
  }

  memset(*ptr_yy_globals, 0x00, sizeof(struct yyguts_t) /*160ul*/ );
  cff_set_extra(yy_user_defined, *ptr_yy_globals);
  signed int return_value_yy_init_globals$4;
  return_value_yy_init_globals$4=yy_init_globals(*ptr_yy_globals);
  return return_value_yy_init_globals$4;
}

// cff_parse
// file conffile.tab.c line 977
signed int cff_parse(struct cfdata *pp)
{
  signed int yychar;
  union value yylval;
  signed int cff_nerrs;
  signed int yystate;
  signed int yyerrstatus;
  signed short int yyssa[200l];
  signed short int *yyss;
  signed short int *yyssp;
  union value yyvsa[200l];
  union value *yyvs;
  union value *yyvsp;
  unsigned long int yystacksize;
  signed int yyn;
  signed int yyresult;
  signed int yytoken = 0;
  union value yyval;
  signed int yylen = 0;
  yyss = yyssa;
  yyssp = yyss;
  yyvs = yyvsa;
  yyvsp = yyvs;
  yystacksize = (unsigned long int)200;
  yystate = 0;
  yyerrstatus = 0;
  cff_nerrs = 0;
  yychar = -2;
  goto yysetstate;

yynewstate:
  ;
  yyssp = yyssp + 1l;

yysetstate:
  ;
  *yyssp = (signed short int)yystate;
  if(yyssp >= yyss + (signed long int)yystacksize + -1l)
  {
    unsigned long int yysize = (unsigned long int)((yyssp - yyss) + (signed long int)1);
    if(yystacksize >= 10000ul)
      goto yyexhaustedlab;

    yystacksize = yystacksize * (unsigned long int)2;
    if(yystacksize >= 10001ul)
      yystacksize = (unsigned long int)10000;

    signed short int *yyss1 = yyss;
    union yyalloc *yyptr;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(yystacksize * (sizeof(signed short int) /*2ul*/  + sizeof(union value) /*8ul*/ ) + (sizeof(union yyalloc) /*8ul*/  - (unsigned long int)1));
    yyptr = (union yyalloc *)return_value_malloc$1;
    if(yyptr == ((union yyalloc *)NULL))
      goto yyexhaustedlab;

    do
    {
      unsigned long int yynewbytes;
      __builtin_memcpy((void *)&yyptr->yyss_alloc, (const void *)yyss, yysize * sizeof(signed short int) /*2ul*/ );
      yyss = &yyptr->yyss_alloc;
      yynewbytes = yystacksize * sizeof(signed short int) /*2ul*/  + (sizeof(union yyalloc) /*8ul*/  - (unsigned long int)1);
      yyptr = yyptr + (signed long int)(yynewbytes / sizeof(union yyalloc) /*8ul*/ );
    }
    while((_Bool)0);
    do
    {
      unsigned long int cff_parse$$1$$1$$1$$2$$yynewbytes;
      __builtin_memcpy((void *)&yyptr->yyvs_alloc, (const void *)yyvs, yysize * sizeof(union value) /*8ul*/ );
      yyvs = &yyptr->yyvs_alloc;
      cff_parse$$1$$1$$1$$2$$yynewbytes = yystacksize * sizeof(union value) /*8ul*/  + (sizeof(union yyalloc) /*8ul*/  - (unsigned long int)1);
      yyptr = yyptr + (signed long int)(cff_parse$$1$$1$$1$$2$$yynewbytes / sizeof(union yyalloc) /*8ul*/ );
    }
    while((_Bool)0);
    if(!(yyss1 == yyssa))
      free((void *)yyss1);

    yyssp = (yyss + (signed long int)yysize) - (signed long int)1;
    yyvsp = (yyvs + (signed long int)yysize) - (signed long int)1;
    if(yyssp >= yyss + (signed long int)yystacksize + -1l)
      goto yyabortlab;

  }

  signed int tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  signed int tmp_if_expr$6;
  signed int tmp_if_expr$5;
  if(!(yystate == 2))
  {

  yybackup:
    ;
    yyn = (signed int)yypact[(signed long int)yystate];
    if(!(yyn == -5))
    {
      if(yychar == -2)
        yychar=cff_lex(&yylval, pp->scaninfo);

      if(!(yychar >= 1))
      {
        yytoken = 0;
        yychar = yytoken;
      }

      else
      {
        if(!((unsigned int)yychar >= 260u))
          tmp_if_expr$2 = (signed int)yytranslate[(signed long int)yychar];

        else
          tmp_if_expr$2 = 2;
        yytoken = tmp_if_expr$2;
      }
      yyn = yyn + yytoken;
      if(yyn >= 6 || !(yyn >= 0))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)yycheck[(signed long int)yyn] != yytoken ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$3)
      {
        yyn = (signed int)yytable[(signed long int)yyn];
        if(!(yyn >= 1))
        {
          yyn = -yyn;
          goto yyreduce;
        }

        if(!(yyerrstatus == 0))
          yyerrstatus = yyerrstatus - 1;

        yychar = -2;
        yystate = yyn;
        yyvsp = yyvsp + 1l;
        *yyvsp = yylval;
        goto yynewstate;
      }

    }


  yydefault:
    ;
    yyn = (signed int)yydefact[(signed long int)yystate];
    if(!(yyn == 0))
    {

    yyreduce:
      ;
      yylen = (signed int)yyr2[(signed long int)yyn];
      yyval = yyvsp[(signed long int)(1 - yylen)];
      if(yyn == 5)
        egdi_add_setting(pp->cf, (yyvsp + (signed long int)-3)->str, (yyvsp + (signed long int)-1)->str);

      yyvsp = yyvsp - (signed long int)yylen;
      yyssp = yyssp - (signed long int)yylen;
      yylen = 0;
      yyvsp = yyvsp + 1l;
      *yyvsp = yyval;
      yyn = (signed int)yyr1[(signed long int)yyn];
      yystate = (signed int)yypgoto[(signed long int)(yyn - 6)] + (signed int)*yyssp;
      if(yystate >= 0 && !(yystate >= 6))
        tmp_if_expr$4 = (signed int)yycheck[(signed long int)yystate] == (signed int)*yyssp ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        yystate = (signed int)yytable[(signed long int)yystate];

      else
        yystate = (signed int)yydefgoto[(signed long int)(yyn - 6)];
      goto yynewstate;
    }


  yyerrlab:
    ;
    if(yychar == -2)
      tmp_if_expr$6 = -2;

    else
    {
      if(!((unsigned int)yychar >= 260u))
        tmp_if_expr$5 = (signed int)yytranslate[(signed long int)yychar];

      else
        tmp_if_expr$5 = 2;
      tmp_if_expr$6 = tmp_if_expr$5;
    }
    yytoken = tmp_if_expr$6;
    if(yyerrstatus == 0)
    {
      cff_nerrs = cff_nerrs + 1;
      cff_error(pp, "syntax error");
    }

    if(yyerrstatus == 3)
    {
      if(!(yychar >= 1))
      {
        if(yychar == 0)
          goto yyabortlab;

      }

      else
      {
        yydestruct("Error: discarding", yytoken, &yylval, pp);
        yychar = -2;
      }
    }

    goto yyerrlab1;

  yyerrorlab:
    ;
    yyvsp = yyvsp - (signed long int)yylen;
    yyssp = yyssp - (signed long int)yylen;
    yylen = 0;
    yystate = (signed int)*yyssp;

  yyerrlab1:
    ;
    yyerrstatus = 3;
    do
    {
      yyn = (signed int)yypact[(signed long int)yystate];
      if(!(yyn == -5))
      {
        yyn = yyn + 1;
        if(yyn >= 0 && !(yyn >= 6))
        {
          if((signed int)yycheck[(signed long int)yyn] == 1)
          {
            yyn = (signed int)yytable[(signed long int)yyn];
            if(yyn >= 1)
              break;

          }

        }

      }

      if(yyssp == yyss)
        goto yyabortlab;

      yydestruct("Error: popping", (signed int)yystos[(signed long int)yystate], yyvsp, pp);
      yyvsp = yyvsp - (signed long int)1;
      yyssp = yyssp - (signed long int)1;
      yystate = (signed int)*yyssp;
    }
    while((_Bool)1);
    yyvsp = yyvsp + 1l;
    *yyvsp = yylval;
    yystate = yyn;
    goto yynewstate;
  }


yyacceptlab:
  ;
  yyresult = 0;
  goto yyreturn;

yyabortlab:
  ;
  yyresult = 1;
  goto yyreturn;

yyexhaustedlab:
  ;
  cff_error(pp, "memory exhausted");
  yyresult = 2;

yyreturn:
  ;
  signed int tmp_if_expr$7;
  if(!(yychar == -2))
  {
    if(!((unsigned int)yychar >= 260u))
      tmp_if_expr$7 = (signed int)yytranslate[(signed long int)yychar];

    else
      tmp_if_expr$7 = 2;
    yytoken = tmp_if_expr$7;
    yydestruct("Cleanup: discarding lookahead", yytoken, &yylval, pp);
  }

  yyvsp = yyvsp - (signed long int)yylen;
  yyssp = yyssp - (signed long int)yylen;
  for( ; !(yyssp == yyss); yyssp = yyssp - (signed long int)1)
  {
    yydestruct("Cleanup: popping", (signed int)yystos[(signed long int)*yyssp], yyvsp, pp);
    yyvsp = yyvsp - (signed long int)1;
  }
  if(!(yyss == yyssa))
    free((void *)yyss);

  return yyresult;
}

// cff_pop_buffer_state
// file conffile.lex.c line 1505
void cff_pop_buffer_state(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
  struct yy_buffer_state *tmp_if_expr$2;
  struct yy_buffer_state *tmp_if_expr$3;
  if(!(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL)))
  {
    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$2 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$2 = (struct yy_buffer_state *)(void *)0;
    cff__delete_buffer(tmp_if_expr$2, yyscanner);
    yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top] = (struct yy_buffer_state *)(void *)0;
    if(yyg->yy_buffer_stack_top >= 1ul)
      yyg->yy_buffer_stack_top = yyg->yy_buffer_stack_top - 1ul;

    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$3 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$3 = (struct yy_buffer_state *)(void *)0;
    if(!(tmp_if_expr$3 == ((struct yy_buffer_state *)NULL)))
    {
      cff__load_buffer_state(yyscanner);
      yyg->yy_did_buffer_switch_on_eof = 1;
    }

  }

}

// cff_push_buffer_state
// file conffile.lex.c line 1474
void cff_push_buffer_state(struct yy_buffer_state *new_buffer, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  struct yy_buffer_state *tmp_if_expr$2;
  if(!(new_buffer == ((struct yy_buffer_state *)NULL)))
  {
    cff_ensure_buffer_stack(yyscanner);
    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
    if(!(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL)))
    {
      *yyg->yy_c_buf_p = yyg->yy_hold_char;
      yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_buf_pos = yyg->yy_c_buf_p;
      yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_n_chars = yyg->yy_n_chars;
    }

    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$2 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$2 = (struct yy_buffer_state *)(void *)0;
    if(!(tmp_if_expr$2 == ((struct yy_buffer_state *)NULL)))
      yyg->yy_buffer_stack_top = yyg->yy_buffer_stack_top + 1ul;

    yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top] = new_buffer;
    cff__load_buffer_state(yyscanner);
    yyg->yy_did_buffer_switch_on_eof = 1;
  }

}

// cff_realloc
// file conffile.l line 70
void * cff_realloc(void *ptr, unsigned long int size, void *yyscanner)
{
  (void)yyscanner;
  void *return_value_realloc$1;
  return_value_realloc$1=realloc(ptr, size);
  return return_value_realloc$1;
}

// cff_restart
// file conffile.lex.c line 1302
void cff_restart(struct _IO_FILE *input_file, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
  if(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL))
  {
    cff_ensure_buffer_stack(yyscanner);
    yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]=cff__create_buffer(yyg->yyin_r, 16384, yyscanner);
  }

  struct yy_buffer_state *tmp_if_expr$2;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$2 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$2 = (struct yy_buffer_state *)(void *)0;
  cff__init_buffer(tmp_if_expr$2, input_file, yyscanner);
  cff__load_buffer_state(yyscanner);
}

// cff_set_column
// file conffile.lex.c line 1785
void cff_set_column(signed int column_no, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
  if(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL))
    yy_fatal_error("cff_set_column called with no buffer", yyscanner);

  yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_bs_column = column_no;
}

// cff_set_debug
// file conffile.lex.c line 1820
void cff_set_debug(signed int bdebug, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  yyg->yy_flex_debug_r = bdebug;
}

// cff_set_extra
// file conffile.lex.c line 1760
void cff_set_extra(void *user_defined, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  yyg->yyextra_r = user_defined;
}

// cff_set_in
// file conffile.lex.c line 1802
void cff_set_in(struct _IO_FILE *in_str, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  yyg->yyin_r = in_str;
}

// cff_set_lineno
// file conffile.lex.c line 1770
void cff_set_lineno(signed int line_number, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
  if(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL))
    yy_fatal_error("cff_set_lineno called with no buffer", yyscanner);

  yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_bs_lineno = line_number;
}

// cff_set_lval
// file conffile.lex.c line 1834
void cff_set_lval(union value *yylval_param, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  yyg->yylval_r = yylval_param;
}

// cff_set_out
// file conffile.lex.c line 1808
void cff_set_out(struct _IO_FILE *out_str, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  yyg->yyout_r = out_str;
}

// cfl__create_buffer
// file confline.lex.c line 1353
struct yy_buffer_state * cfl__create_buffer(struct _IO_FILE *file, signed int size, void *yyscanner)
{
  struct yy_buffer_state *b;
  void *return_value_cfl_alloc$1;
  return_value_cfl_alloc$1=cfl_alloc(sizeof(struct yy_buffer_state) /*72ul*/ , yyscanner);
  b = (struct yy_buffer_state *)return_value_cfl_alloc$1;
  if(b == ((struct yy_buffer_state *)NULL))
    yy_fatal_error$link1("out of dynamic memory in cfl__create_buffer()", yyscanner);

  b->yy_buf_size = (unsigned long int)size;
  void *return_value_cfl_alloc$2;
  return_value_cfl_alloc$2=cfl_alloc(b->yy_buf_size + (unsigned long int)2, yyscanner);
  b->yy_ch_buf = (char *)return_value_cfl_alloc$2;
  if(b->yy_ch_buf == ((char *)NULL))
    yy_fatal_error$link1("out of dynamic memory in cfl__create_buffer()", yyscanner);

  b->yy_is_our_buffer = 1;
  cfl__init_buffer(b, file, yyscanner);
  return b;
}

// cfl__delete_buffer
// file confline.lex.c line 1381
void cfl__delete_buffer(struct yy_buffer_state *b, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(b == ((struct yy_buffer_state *)NULL)))
  {
    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
    if(b == tmp_if_expr$1)
      yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top] = (struct yy_buffer_state *)0;

    if(!(b->yy_is_our_buffer == 0))
      cfl_free((void *)b->yy_ch_buf, yyscanner);

    cfl_free((void *)b, yyscanner);
  }

}

// cfl__flush_buffer
// file confline.lex.c line 1430
void cfl__flush_buffer(struct yy_buffer_state *b, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(b == ((struct yy_buffer_state *)NULL)))
  {
    b->yy_n_chars = (unsigned long int)0;
    b->yy_ch_buf[(signed long int)0] = (char)0;
    b->yy_ch_buf[(signed long int)1] = (char)0;
    b->yy_buf_pos = &b->yy_ch_buf[(signed long int)0];
    b->yy_at_bol = 1;
    b->yy_buffer_status = 0;
    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
    if(b == tmp_if_expr$1)
      cfl__load_buffer_state(yyscanner);

  }

}

// cfl__init_buffer
// file confline.lex.c line 1401
static void cfl__init_buffer(struct yy_buffer_state *b, struct _IO_FILE *file, void *yyscanner)
{
  signed int oerrno;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  oerrno = *return_value___errno_location$1;
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  cfl__flush_buffer(b, yyscanner);
  b->yy_input_file = file;
  b->yy_fill_buffer = 1;
  struct yy_buffer_state *tmp_if_expr$2;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$2 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$2 = (struct yy_buffer_state *)(void *)0;
  if(!(b == tmp_if_expr$2))
  {
    b->yy_bs_lineno = 1;
    b->yy_bs_column = 0;
  }

  b->yy_is_interactive = 0;
  signed int *return_value___errno_location$3;
  return_value___errno_location$3=__errno_location();
  *return_value___errno_location$3 = oerrno;
}

// cfl__load_buffer_state
// file confline.lex.c line 1338
static void cfl__load_buffer_state(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  yyg->yy_n_chars = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_n_chars;
  yyg->yy_c_buf_p = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_buf_pos;
  yyg->yytext_r = yyg->yy_c_buf_p;
  yyg->yyin_r = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_input_file;
  yyg->yy_hold_char = *yyg->yy_c_buf_p;
}

// cfl__scan_buffer
// file confline.lex.c line 1561
struct yy_buffer_state * cfl__scan_buffer(char *base, unsigned long int size, void *yyscanner)
{
  struct yy_buffer_state *b;
  _Bool tmp_if_expr$1;
  if(!(size >= 2ul))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)base[(signed long int)(size - (unsigned long int)2)] != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)base[(signed long int)(size - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    return ((struct yy_buffer_state *)NULL);

  else
  {
    void *return_value_cfl_alloc$3;
    return_value_cfl_alloc$3=cfl_alloc(sizeof(struct yy_buffer_state) /*72ul*/ , yyscanner);
    b = (struct yy_buffer_state *)return_value_cfl_alloc$3;
    if(b == ((struct yy_buffer_state *)NULL))
      yy_fatal_error$link1("out of dynamic memory in cfl__scan_buffer()", yyscanner);

    b->yy_buf_size = size - (unsigned long int)2;
    b->yy_ch_buf = base;
    b->yy_buf_pos = b->yy_ch_buf;
    b->yy_is_our_buffer = 0;
    b->yy_input_file = ((struct _IO_FILE *)NULL);
    b->yy_n_chars = b->yy_buf_size;
    b->yy_is_interactive = 0;
    b->yy_at_bol = 1;
    b->yy_fill_buffer = 0;
    b->yy_buffer_status = 0;
    cfl__switch_to_buffer(b, yyscanner);
    return b;
  }
}

// cfl__scan_bytes
// file confline.lex.c line 1611
struct yy_buffer_state * cfl__scan_bytes(const char *yybytes, unsigned long int _yybytes_len, void *yyscanner)
{
  struct yy_buffer_state *b;
  char *buf;
  unsigned long int n;
  unsigned long int i;
  n = _yybytes_len + (unsigned long int)2;
  void *return_value_cfl_alloc$1;
  return_value_cfl_alloc$1=cfl_alloc(n, yyscanner);
  buf = (char *)return_value_cfl_alloc$1;
  if(buf == ((char *)NULL))
    yy_fatal_error$link1("out of dynamic memory in cfl__scan_bytes()", yyscanner);

  i = (unsigned long int)0;
  for( ; !(i >= _yybytes_len); i = i + 1ul)
    buf[(signed long int)i] = yybytes[(signed long int)i];
  buf[(signed long int)(_yybytes_len + (unsigned long int)1)] = (char)0;
  buf[(signed long int)_yybytes_len] = buf[(signed long int)(_yybytes_len + (unsigned long int)1)];
  b=cfl__scan_buffer(buf, n, yyscanner);
  if(b == ((struct yy_buffer_state *)NULL))
    yy_fatal_error$link1("bad buffer in cfl__scan_bytes()", yyscanner);

  b->yy_is_our_buffer = 1;
  return b;
}

// cfl__scan_string
// file confline.lex.c line 1598
struct yy_buffer_state * cfl__scan_string(const char *yystr, void *yyscanner)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(yystr);
  struct yy_buffer_state *return_value_cfl__scan_bytes$2;
  return_value_cfl__scan_bytes$2=cfl__scan_bytes(yystr, return_value_strlen$1, yyscanner);
  return return_value_cfl__scan_bytes$2;
}

// cfl__switch_to_buffer
// file confline.lex.c line 1306
void cfl__switch_to_buffer(struct yy_buffer_state *new_buffer, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  cfl_ensure_buffer_stack(yyscanner);
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
  struct yy_buffer_state *tmp_if_expr$2;
  if(!(tmp_if_expr$1 == new_buffer))
  {
    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$2 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$2 = (struct yy_buffer_state *)(void *)0;
    if(!(tmp_if_expr$2 == ((struct yy_buffer_state *)NULL)))
    {
      *yyg->yy_c_buf_p = yyg->yy_hold_char;
      yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_buf_pos = yyg->yy_c_buf_p;
      yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_n_chars = yyg->yy_n_chars;
    }

    yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top] = new_buffer;
    cfl__load_buffer_state(yyscanner);
    yyg->yy_did_buffer_switch_on_eof = 1;
  }

}

// cfl_alloc
// file confline.l line 60
void * cfl_alloc(unsigned long int size, void *yyscanner)
{
  (void)yyscanner;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(size);
  return return_value_malloc$1;
}

// cfl_ensure_buffer_stack
// file confline.lex.c line 1511
static void cfl_ensure_buffer_stack(void *yyscanner)
{
  unsigned long int num_to_alloc;
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  if(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL))
  {
    num_to_alloc = (unsigned long int)1;
    void *return_value_cfl_alloc$1;
    return_value_cfl_alloc$1=cfl_alloc(num_to_alloc * sizeof(struct yy_buffer_state *) /*8ul*/ , yyscanner);
    yyg->yy_buffer_stack = (struct yy_buffer_state **)return_value_cfl_alloc$1;
    if(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL))
      yy_fatal_error$link1("out of dynamic memory in cfl_ensure_buffer_stack()", yyscanner);

    memset((void *)yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state *) /*8ul*/ );
    yyg->yy_buffer_stack_max = num_to_alloc;
    yyg->yy_buffer_stack_top = (unsigned long int)0;
    goto __CPROVER_DUMP_L5;
  }

  if(yyg->yy_buffer_stack_top >= yyg->yy_buffer_stack_max + 18446744073709551615ul)
  {
    signed int grow_size = 8;
    num_to_alloc = yyg->yy_buffer_stack_max + (unsigned long int)grow_size;
    void *return_value_cfl_realloc$2;
    return_value_cfl_realloc$2=cfl_realloc((void *)yyg->yy_buffer_stack, num_to_alloc * sizeof(struct yy_buffer_state *) /*8ul*/ , yyscanner);
    yyg->yy_buffer_stack = (struct yy_buffer_state **)return_value_cfl_realloc$2;
    if(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL))
      yy_fatal_error$link1("out of dynamic memory in cfl_ensure_buffer_stack()", yyscanner);

    memset((void *)(yyg->yy_buffer_stack + (signed long int)yyg->yy_buffer_stack_max), 0, (unsigned long int)grow_size * sizeof(struct yy_buffer_state *) /*8ul*/ );
    yyg->yy_buffer_stack_max = num_to_alloc;
  }


__CPROVER_DUMP_L5:
  ;
}

// cfl_error
// file confline.tab.c line 1471
static signed int cfl_error(struct cfldata *pp, const char *s)
{
  (void)pp;
  fprintf(stderr, "error: %s\n", s);
  return 0;
}

// cfl_free
// file confline.l line 76
void cfl_free(void *ptr, void *yyscanner)
{
  (void)yyscanner;
  free(ptr);
}

// cfl_get_column
// file confline.lex.c line 1695
signed int cfl_get_column(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
  if(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL))
    return 0;

  else
    return yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_bs_column;
}

// cfl_get_debug
// file confline.lex.c line 1800
signed int cfl_get_debug(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  return yyg->yy_flex_debug_r;
}

// cfl_get_extra
// file confline.lex.c line 1673
void * cfl_get_extra(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  return yyg->yyextra_r;
}

// cfl_get_in
// file confline.lex.c line 1708
struct _IO_FILE * cfl_get_in(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  return yyg->yyin_r;
}

// cfl_get_leng
// file confline.lex.c line 1726
unsigned long int cfl_get_leng(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  return yyg->yyleng_r;
}

// cfl_get_lineno
// file confline.lex.c line 1682
signed int cfl_get_lineno(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
  if(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL))
    return 0;

  else
    return yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_bs_lineno;
}

// cfl_get_lval
// file confline.lex.c line 1814
union value * cfl_get_lval(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  return yyg->yylval_r;
}

// cfl_get_out
// file confline.lex.c line 1717
struct _IO_FILE * cfl_get_out(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  return yyg->yyout_r;
}

// cfl_get_text
// file confline.lex.c line 1736
char * cfl_get_text(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  return yyg->yytext_r;
}

// cfl_lex
// file confline.lex.c line 730
extern signed int cfl_lex(union value *yylval_param, void *yyscanner)
{
  signed int yy_current_state;
  char *yy_cp;
  char *yy_bp;
  signed int yy_act;
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  yyg->yylval_r = yylval_param;
  struct yy_buffer_state *tmp_if_expr$1;
  if(yyg->yy_init == 0)
  {
    yyg->yy_init = 1;
    if(yyg->yy_start == 0)
      yyg->yy_start = 1;

    if(yyg->yyin_r == ((struct _IO_FILE *)NULL))
      yyg->yyin_r = stdin;

    if(yyg->yyout_r == ((struct _IO_FILE *)NULL))
      yyg->yyout_r = stdout;

    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
    if(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL))
    {
      cfl_ensure_buffer_stack(yyscanner);
      yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]=cfl__create_buffer(yyg->yyin_r, 16384, yyscanner);
    }

    cfl__load_buffer_state(yyscanner);
  }

  struct cfldata *pp = (struct cfldata *)yyg->yyextra_r;
  signed int yy_amount_of_matched_text;
  signed int return_value_yy_get_next_buffer$4;
  while((_Bool)1)
  {
    yy_cp = yyg->yy_c_buf_p;
    *yy_cp = yyg->yy_hold_char;
    yy_bp = yy_cp;
    yy_current_state = yyg->yy_start;
    do
    {

    yy_match:
      ;
      unsigned char yy_c = (unsigned char)yy_ec$link1[(signed long int)(unsigned int)(unsigned char)*yy_cp];
      if(!(yy_accept$link1[(signed long int)yy_current_state] == 0))
      {
        yyg->yy_last_accepting_state = yy_current_state;
        yyg->yy_last_accepting_cpos = yy_cp;
      }

      while(!((signed int)yy_chk$link1[(signed long int)((signed int)yy_base$link1[(signed long int)yy_current_state] + (signed int)yy_c)] == yy_current_state))
      {
        yy_current_state = (signed int)yy_def$link1[(signed long int)yy_current_state];
        if(yy_current_state >= 11)
          yy_c = (unsigned char)yy_meta$link1[(signed long int)(unsigned int)yy_c];

      }
      yy_current_state = (signed int)yy_nxt$link1[(signed long int)((unsigned int)yy_base$link1[(signed long int)yy_current_state] + (unsigned int)yy_c)];
      yy_cp = yy_cp + 1l;
      if(!(yy_current_state == 10))
        goto yy_match;

      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;

    yy_find_action:
      ;
      yy_act = (signed int)yy_accept$link1[(signed long int)yy_current_state];
      yyg->yytext_r = yy_bp;
      yyg->yyleng_r = (unsigned long int)(yy_cp - yy_bp);
      yyg->yy_hold_char = *yy_cp;
      *yy_cp = (char)0;
      yyg->yy_c_buf_p = yy_cp;
      if(!(yy_act == 5))
      {
        if(!(yy_rule_can_match_eol$link1[(signed long int)yy_act] == 0))
        {
          unsigned long int yyl = (unsigned long int)0;
          for( ; !(yyl >= yyg->yyleng_r); yyl = yyl + 1ul)
            if((signed int)yyg->yytext_r[(signed long int)yyl] == 10)
              do
              {
                yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_bs_lineno = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_bs_lineno + 1;
                yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_bs_column = 0;
              }
              while((_Bool)0);

        }

      }


    do_action:
      ;
      for( ; (_Bool)1; yy_act = 5 + (yyg->yy_start - 1) / 2 + 1)
      {
        if(!(yy_act == 0))
        {
          if(yy_act == 1)
            goto __CPROVER_DUMP_L20;

          if(yy_act == 2)
            goto __CPROVER_DUMP_L22;

          if(yy_act == 3)
            goto __CPROVER_DUMP_L23;

          if(yy_act == 4)
            goto __CPROVER_DUMP_L24;

          if(yy_act == 1)
            goto __CPROVER_DUMP_L25;

          if(yy_act == 5)
            goto __CPROVER_DUMP_L26;

          goto __CPROVER_DUMP_L37;
        }

        *yy_cp = yyg->yy_hold_char;
        yy_cp = yyg->yy_last_accepting_cpos;
        yy_current_state = yyg->yy_last_accepting_state;
        goto yy_find_action;

      __CPROVER_DUMP_L20:
        ;
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(yyg->yytext_r);
        if(return_value_strlen$2 >= 64ul)
          return -1;

        strcpy(pp->tokbuff[(signed long int)pp->itok], yyg->yytext_r);
        yyg->yylval_r->str = pp->tokbuff[(signed long int)pp->itok];
        pp->itok = (pp->itok + 1) % 2;
        return 258;

      __CPROVER_DUMP_L22:
        ;
        return (signed int)yyg->yytext_r[(signed long int)0];

      __CPROVER_DUMP_L23:
        ;
        goto __CPROVER_DUMP_L38;
        do
        {

        __CPROVER_DUMP_L24:
          ;
          unsigned long int return_value_fwrite$3;
          return_value_fwrite$3=fwrite((const void *)yyg->yytext_r, yyg->yyleng_r, (unsigned long int)1, yyg->yyout_r);
        }
        while((_Bool)0);
        goto __CPROVER_DUMP_L38;

      __CPROVER_DUMP_L25:
        ;
        return 0;

      __CPROVER_DUMP_L26:
        ;
        yy_amount_of_matched_text = (signed int)(yy_cp - yyg->yytext_r) - 1;
        *yy_cp = yyg->yy_hold_char;
        if(yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_buffer_status == 0)
        {
          yyg->yy_n_chars = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_n_chars;
          yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_input_file = yyg->yyin_r;
          yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_buffer_status = 1;
        }

        if(yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_ch_buf + (signed long int)yyg->yy_n_chars >= yyg->yy_c_buf_p)
        {
          signed int yy_next_state;
          yyg->yy_c_buf_p = yyg->yytext_r + (signed long int)yy_amount_of_matched_text;
          yy_current_state=yy_get_previous_state$link1(yyscanner);
          yy_next_state=yy_try_NUL_trans$link1(yy_current_state, yyscanner);
          yy_bp = yyg->yytext_r + (signed long int)0;
          if(!(yy_next_state == 0))
          {
            yyg->yy_c_buf_p = yyg->yy_c_buf_p + 1l;
            yy_cp = yyg->yy_c_buf_p;
            yy_current_state = yy_next_state;
            goto yy_match;
          }

          else
          {
            yy_cp = yyg->yy_last_accepting_cpos;
            yy_current_state = yyg->yy_last_accepting_state;
            goto yy_find_action;
          }
        }

        return_value_yy_get_next_buffer$4=yy_get_next_buffer$link1(yyscanner);
        if(!(return_value_yy_get_next_buffer$4 == 1))
        {
          if(return_value_yy_get_next_buffer$4 == 0)
            goto __CPROVER_DUMP_L34;

          if(return_value_yy_get_next_buffer$4 == 2)
            goto __CPROVER_DUMP_L35;

          goto __CPROVER_DUMP_L36;
        }

        yyg->yy_did_buffer_switch_on_eof = 0;
        yyg->yy_c_buf_p = yyg->yytext_r + (signed long int)0;
      }
      if(yyg->yy_did_buffer_switch_on_eof == 0)
        cfl_restart(yyg->yyin_r, yyscanner);

      goto __CPROVER_DUMP_L36;

    __CPROVER_DUMP_L34:
      ;
      yyg->yy_c_buf_p = yyg->yytext_r + (signed long int)yy_amount_of_matched_text;
      yy_current_state=yy_get_previous_state$link1(yyscanner);
      yy_cp = yyg->yy_c_buf_p;
      yy_bp = yyg->yytext_r + (signed long int)0;
    }
    while((_Bool)1);

  __CPROVER_DUMP_L35:
    ;
    yyg->yy_c_buf_p = &yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_ch_buf[(signed long int)yyg->yy_n_chars];
    yy_current_state=yy_get_previous_state$link1(yyscanner);
    yy_cp = yyg->yy_c_buf_p;
    yy_bp = yyg->yytext_r + (signed long int)0;
    goto yy_find_action;

  __CPROVER_DUMP_L36:
    ;
    continue;

  __CPROVER_DUMP_L37:
    ;
    yy_fatal_error$link1("fatal flex scanner internal error--no action found", yyscanner);

  __CPROVER_DUMP_L38:
    ;
  }
}

// cfl_lex_destroy
// file confline.lex.c line 1924
signed int cfl_lex_destroy(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  struct yy_buffer_state *tmp_if_expr$2;
  do
  {
    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
    if(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL))
      break;

    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$2 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$2 = (struct yy_buffer_state *)(void *)0;
    cfl__delete_buffer(tmp_if_expr$2, yyscanner);
    yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top] = (struct yy_buffer_state *)(void *)0;
    cfl_pop_buffer_state(yyscanner);
  }
  while((_Bool)1);
  cfl_free((void *)yyg->yy_buffer_stack, yyscanner);
  yyg->yy_buffer_stack = (struct yy_buffer_state **)(void *)0;
  cfl_free((void *)yyg->yy_start_stack, yyscanner);
  yyg->yy_start_stack = (signed int *)(void *)0;
  yy_init_globals$link1(yyscanner);
  cfl_free(yyscanner, yyscanner);
  yyscanner = (void *)0;
  return 0;
}

// cfl_lex_init
// file confline.lex.c line 1833
signed int cfl_lex_init(void **ptr_yy_globals)
{
  if(ptr_yy_globals == ((void **)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return 1;
  }

  void *return_value_cfl_alloc$2;
  return_value_cfl_alloc$2=cfl_alloc(sizeof(struct yyguts_t) /*160ul*/ , (void *)0);
  *ptr_yy_globals = (void *)return_value_cfl_alloc$2;
  if(*ptr_yy_globals == NULL)
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 12;
    return 1;
  }

  memset(*ptr_yy_globals, 0x00, sizeof(struct yyguts_t) /*160ul*/ );
  signed int return_value_yy_init_globals$4;
  return_value_yy_init_globals$4=yy_init_globals$link1(*ptr_yy_globals);
  return return_value_yy_init_globals$4;
}

// cfl_lex_init_extra
// file confline.lex.c line 1862
signed int cfl_lex_init_extra(void *yy_user_defined, void **ptr_yy_globals)
{
  struct yyguts_t dummy_yyguts;
  cfl_set_extra(yy_user_defined, (void *)&dummy_yyguts);
  if(ptr_yy_globals == ((void **)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return 1;
  }

  void *return_value_cfl_alloc$2;
  return_value_cfl_alloc$2=cfl_alloc(sizeof(struct yyguts_t) /*160ul*/ , (void *)&dummy_yyguts);
  *ptr_yy_globals = (void *)return_value_cfl_alloc$2;
  if(*ptr_yy_globals == NULL)
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 12;
    return 1;
  }

  memset(*ptr_yy_globals, 0x00, sizeof(struct yyguts_t) /*160ul*/ );
  cfl_set_extra(yy_user_defined, *ptr_yy_globals);
  signed int return_value_yy_init_globals$4;
  return_value_yy_init_globals$4=yy_init_globals$link1(*ptr_yy_globals);
  return return_value_yy_init_globals$4;
}

// cfl_parse
// file confline.tab.c line 979
signed int cfl_parse(struct cfldata *pp)
{
  signed int yychar;
  union value yylval;
  signed int cfl_nerrs;
  signed int yystate;
  signed int yyerrstatus;
  signed short int yyssa[200l];
  signed short int *yyss;
  signed short int *yyssp;
  union value yyvsa[200l];
  union value *yyvs;
  union value *yyvsp;
  unsigned long int yystacksize;
  signed int yyn;
  signed int yyresult;
  signed int yytoken = 0;
  union value yyval;
  signed int yylen = 0;
  yyss = yyssa;
  yyssp = yyss;
  yyvs = yyvsa;
  yyvsp = yyvs;
  yystacksize = (unsigned long int)200;
  yystate = 0;
  yyerrstatus = 0;
  cfl_nerrs = 0;
  yychar = -2;
  goto yysetstate;

yynewstate:
  ;
  yyssp = yyssp + 1l;

yysetstate:
  ;
  *yyssp = (signed short int)yystate;
  if(yyssp >= yyss + (signed long int)yystacksize + -1l)
  {
    unsigned long int yysize = (unsigned long int)((yyssp - yyss) + (signed long int)1);
    if(yystacksize >= 10000ul)
      goto yyexhaustedlab;

    yystacksize = yystacksize * (unsigned long int)2;
    if(yystacksize >= 10001ul)
      yystacksize = (unsigned long int)10000;

    signed short int *yyss1 = yyss;
    union yyalloc *yyptr;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(yystacksize * (sizeof(signed short int) /*2ul*/  + sizeof(union value) /*8ul*/ ) + (sizeof(union yyalloc) /*8ul*/  - (unsigned long int)1));
    yyptr = (union yyalloc *)return_value_malloc$1;
    if(yyptr == ((union yyalloc *)NULL))
      goto yyexhaustedlab;

    do
    {
      unsigned long int yynewbytes;
      __builtin_memcpy((void *)&yyptr->yyss_alloc, (const void *)yyss, yysize * sizeof(signed short int) /*2ul*/ );
      yyss = &yyptr->yyss_alloc;
      yynewbytes = yystacksize * sizeof(signed short int) /*2ul*/  + (sizeof(union yyalloc) /*8ul*/  - (unsigned long int)1);
      yyptr = yyptr + (signed long int)(yynewbytes / sizeof(union yyalloc) /*8ul*/ );
    }
    while((_Bool)0);
    do
    {
      unsigned long int cfl_parse$$1$$1$$1$$2$$yynewbytes;
      __builtin_memcpy((void *)&yyptr->yyvs_alloc, (const void *)yyvs, yysize * sizeof(union value) /*8ul*/ );
      yyvs = &yyptr->yyvs_alloc;
      cfl_parse$$1$$1$$1$$2$$yynewbytes = yystacksize * sizeof(union value) /*8ul*/  + (sizeof(union yyalloc) /*8ul*/  - (unsigned long int)1);
      yyptr = yyptr + (signed long int)(cfl_parse$$1$$1$$1$$2$$yynewbytes / sizeof(union yyalloc) /*8ul*/ );
    }
    while((_Bool)0);
    if(!(yyss1 == yyssa))
      free((void *)yyss1);

    yyssp = (yyss + (signed long int)yysize) - (signed long int)1;
    yyvsp = (yyvs + (signed long int)yysize) - (signed long int)1;
    if(yyssp >= yyss + (signed long int)yystacksize + -1l)
      goto yyabortlab;

  }

  signed int tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  signed int tmp_if_expr$6;
  signed int tmp_if_expr$5;
  if(!(yystate == 4))
  {

  yybackup:
    ;
    yyn = (signed int)yypact$link1[(signed long int)yystate];
    if(!(yyn == -7))
    {
      if(yychar == -2)
        yychar=cfl_lex(&yylval, pp->scaninfo);

      if(!(yychar >= 1))
      {
        yytoken = 0;
        yychar = yytoken;
      }

      else
      {
        if(!((unsigned int)yychar >= 259u))
          tmp_if_expr$2 = (signed int)yytranslate$link1[(signed long int)yychar];

        else
          tmp_if_expr$2 = 2;
        yytoken = tmp_if_expr$2;
      }
      yyn = yyn + yytoken;
      if(yyn >= 9 || !(yyn >= 0))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)yycheck$link1[(signed long int)yyn] != yytoken ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$3)
      {
        yyn = (signed int)yytable$link1[(signed long int)yyn];
        if(!(yyn >= 1))
        {
          yyn = -yyn;
          goto yyreduce;
        }

        if(!(yyerrstatus == 0))
          yyerrstatus = yyerrstatus - 1;

        yychar = -2;
        yystate = yyn;
        yyvsp = yyvsp + 1l;
        *yyvsp = yylval;
        goto yynewstate;
      }

    }


  yydefault:
    ;
    yyn = (signed int)yydefact$link1[(signed long int)yystate];
    if(!(yyn == 0))
    {

    yyreduce:
      ;
      yylen = (signed int)yyr2$link1[(signed long int)yyn];
      yyval = yyvsp[(signed long int)(1 - yylen)];
      switch(yyn)
      {
        case 5:
        {
          egdi_add_setting(pp->cf, "device", (yyvsp + (signed long int)0)->str);
          break;
        }
        case 8:
          egdi_add_setting(pp->cf, (yyvsp + (signed long int)-2)->str, (yyvsp + (signed long int)0)->str);
      }
      yyvsp = yyvsp - (signed long int)yylen;
      yyssp = yyssp - (signed long int)yylen;
      yylen = 0;
      yyvsp = yyvsp + 1l;
      *yyvsp = yyval;
      yyn = (signed int)yyr1$link1[(signed long int)yyn];
      yystate = (signed int)yypgoto$link1[(signed long int)(yyn - 5)] + (signed int)*yyssp;
      if(yystate >= 0 && !(yystate >= 9))
        tmp_if_expr$4 = (signed int)yycheck$link1[(signed long int)yystate] == (signed int)*yyssp ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        yystate = (signed int)yytable$link1[(signed long int)yystate];

      else
        yystate = (signed int)yydefgoto$link1[(signed long int)(yyn - 5)];
      goto yynewstate;
    }


  yyerrlab:
    ;
    if(yychar == -2)
      tmp_if_expr$6 = -2;

    else
    {
      if(!((unsigned int)yychar >= 259u))
        tmp_if_expr$5 = (signed int)yytranslate$link1[(signed long int)yychar];

      else
        tmp_if_expr$5 = 2;
      tmp_if_expr$6 = tmp_if_expr$5;
    }
    yytoken = tmp_if_expr$6;
    if(yyerrstatus == 0)
    {
      cfl_nerrs = cfl_nerrs + 1;
      cfl_error(pp, "syntax error");
    }

    if(yyerrstatus == 3)
    {
      if(!(yychar >= 1))
      {
        if(yychar == 0)
          goto yyabortlab;

      }

      else
      {
        yydestruct$link1("Error: discarding", yytoken, &yylval, pp);
        yychar = -2;
      }
    }

    goto yyerrlab1;

  yyerrorlab:
    ;
    yyvsp = yyvsp - (signed long int)yylen;
    yyssp = yyssp - (signed long int)yylen;
    yylen = 0;
    yystate = (signed int)*yyssp;

  yyerrlab1:
    ;
    yyerrstatus = 3;
    do
    {
      yyn = (signed int)yypact$link1[(signed long int)yystate];
      if(!(yyn == -7))
      {
        yyn = yyn + 1;
        if(yyn >= 0 && !(yyn >= 9))
        {
          if((signed int)yycheck$link1[(signed long int)yyn] == 1)
          {
            yyn = (signed int)yytable$link1[(signed long int)yyn];
            if(yyn >= 1)
              break;

          }

        }

      }

      if(yyssp == yyss)
        goto yyabortlab;

      yydestruct$link1("Error: popping", (signed int)yystos$link1[(signed long int)yystate], yyvsp, pp);
      yyvsp = yyvsp - (signed long int)1;
      yyssp = yyssp - (signed long int)1;
      yystate = (signed int)*yyssp;
    }
    while((_Bool)1);
    yyvsp = yyvsp + 1l;
    *yyvsp = yylval;
    yystate = yyn;
    goto yynewstate;
  }


yyacceptlab:
  ;
  yyresult = 0;
  goto yyreturn;

yyabortlab:
  ;
  yyresult = 1;
  goto yyreturn;

yyexhaustedlab:
  ;
  cfl_error(pp, "memory exhausted");
  yyresult = 2;

yyreturn:
  ;
  signed int tmp_if_expr$7;
  if(!(yychar == -2))
  {
    if(!((unsigned int)yychar >= 259u))
      tmp_if_expr$7 = (signed int)yytranslate$link1[(signed long int)yychar];

    else
      tmp_if_expr$7 = 2;
    yytoken = tmp_if_expr$7;
    yydestruct$link1("Cleanup: discarding lookahead", yytoken, &yylval, pp);
  }

  yyvsp = yyvsp - (signed long int)yylen;
  yyssp = yyssp - (signed long int)yylen;
  for( ; !(yyssp == yyss); yyssp = yyssp - (signed long int)1)
  {
    yydestruct$link1("Cleanup: popping", (signed int)yystos$link1[(signed long int)*yyssp], yyvsp, pp);
    yyvsp = yyvsp - (signed long int)1;
  }
  if(!(yyss == yyssa))
    free((void *)yyss);

  return yyresult;
}

// cfl_pop_buffer_state
// file confline.lex.c line 1491
void cfl_pop_buffer_state(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
  struct yy_buffer_state *tmp_if_expr$2;
  struct yy_buffer_state *tmp_if_expr$3;
  if(!(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL)))
  {
    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$2 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$2 = (struct yy_buffer_state *)(void *)0;
    cfl__delete_buffer(tmp_if_expr$2, yyscanner);
    yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top] = (struct yy_buffer_state *)(void *)0;
    if(yyg->yy_buffer_stack_top >= 1ul)
      yyg->yy_buffer_stack_top = yyg->yy_buffer_stack_top - 1ul;

    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$3 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$3 = (struct yy_buffer_state *)(void *)0;
    if(!(tmp_if_expr$3 == ((struct yy_buffer_state *)NULL)))
    {
      cfl__load_buffer_state(yyscanner);
      yyg->yy_did_buffer_switch_on_eof = 1;
    }

  }

}

// cfl_push_buffer_state
// file confline.lex.c line 1460
void cfl_push_buffer_state(struct yy_buffer_state *new_buffer, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  struct yy_buffer_state *tmp_if_expr$2;
  if(!(new_buffer == ((struct yy_buffer_state *)NULL)))
  {
    cfl_ensure_buffer_stack(yyscanner);
    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
    if(!(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL)))
    {
      *yyg->yy_c_buf_p = yyg->yy_hold_char;
      yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_buf_pos = yyg->yy_c_buf_p;
      yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_n_chars = yyg->yy_n_chars;
    }

    if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
      tmp_if_expr$2 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

    else
      tmp_if_expr$2 = (struct yy_buffer_state *)(void *)0;
    if(!(tmp_if_expr$2 == ((struct yy_buffer_state *)NULL)))
      yyg->yy_buffer_stack_top = yyg->yy_buffer_stack_top + 1ul;

    yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top] = new_buffer;
    cfl__load_buffer_state(yyscanner);
    yyg->yy_did_buffer_switch_on_eof = 1;
  }

}

// cfl_realloc
// file confline.l line 68
void * cfl_realloc(void *ptr, unsigned long int size, void *yyscanner)
{
  (void)yyscanner;
  void *return_value_realloc$1;
  return_value_realloc$1=realloc(ptr, size);
  return return_value_realloc$1;
}

// cfl_restart
// file confline.lex.c line 1288
void cfl_restart(struct _IO_FILE *input_file, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
  if(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL))
  {
    cfl_ensure_buffer_stack(yyscanner);
    yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]=cfl__create_buffer(yyg->yyin_r, 16384, yyscanner);
  }

  struct yy_buffer_state *tmp_if_expr$2;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$2 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$2 = (struct yy_buffer_state *)(void *)0;
  cfl__init_buffer(tmp_if_expr$2, input_file, yyscanner);
  cfl__load_buffer_state(yyscanner);
}

// cfl_set_column
// file confline.lex.c line 1771
void cfl_set_column(signed int column_no, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
  if(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL))
    yy_fatal_error$link1("cfl_set_column called with no buffer", yyscanner);

  yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_bs_column = column_no;
}

// cfl_set_debug
// file confline.lex.c line 1806
void cfl_set_debug(signed int bdebug, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  yyg->yy_flex_debug_r = bdebug;
}

// cfl_set_extra
// file confline.lex.c line 1746
void cfl_set_extra(void *user_defined, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  yyg->yyextra_r = user_defined;
}

// cfl_set_in
// file confline.lex.c line 1788
void cfl_set_in(struct _IO_FILE *in_str, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  yyg->yyin_r = in_str;
}

// cfl_set_lineno
// file confline.lex.c line 1756
void cfl_set_lineno(signed int line_number, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  struct yy_buffer_state *tmp_if_expr$1;
  if(!(yyg->yy_buffer_stack == ((struct yy_buffer_state **)NULL)))
    tmp_if_expr$1 = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];

  else
    tmp_if_expr$1 = (struct yy_buffer_state *)(void *)0;
  if(tmp_if_expr$1 == ((struct yy_buffer_state *)NULL))
    yy_fatal_error$link1("cfl_set_lineno called with no buffer", yyscanner);

  yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_bs_lineno = line_number;
}

// cfl_set_lval
// file confline.lex.c line 1820
void cfl_set_lval(union value *yylval_param, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  yyg->yylval_r = yylval_param;
}

// cfl_set_out
// file confline.lex.c line 1794
void cfl_set_out(struct _IO_FILE *out_str, void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  yyg->yyout_r = out_str;
}

// check_signals_f
// file systobiia.c line 69
signed int check_signals_f(unsigned long int ns, const float *sig, const float *exg, const signed int *tri)
{
  unsigned long int i = (unsigned long int)0;
  signed int neeg = (signed int)grp[(signed long int)0].nch;
  signed int nexg = (signed int)grp[(signed long int)1].nch;
  signed int ntri = (signed int)grp[(signed long int)2].nch;
  signed int ich;
  float expval;
  signed int exptri;
  signed int retval = 0;
  static signed int nsread = 0;
  for( ; retval == 0 && !(i >= ns); i = i + 1ul)
  {
    ich = 0;
    static signed int nstot = 0;
    for( ; retval == 0 && !(ich >= neeg); ich = ich + 1)
    {
      expval=get_analog_val((unsigned long int)nstot, (unsigned int)ich);
      if(IEEE_FLOAT_NOTEQUAL(sig[(signed long int)i * (signed long int)(unsigned long int)neeg + (signed long int)(unsigned long int)ich], expval))
      {
        fprintf(stderr, "\tEEG value (%f) different from the one expected (%f) at sample %zu ch:%u\n", sig[(signed long int)(i * (unsigned long int)neeg + (unsigned long int)ich)], expval, i + (unsigned long int)nsread, ich);
        retval = -1;
      }

    }
    ich = 0;
    for( ; retval == 0 && !(ich >= nexg); ich = ich + 1)
    {
      expval=get_analog_val((unsigned long int)nstot, (unsigned int)ich);
      if(IEEE_FLOAT_NOTEQUAL(exg[(signed long int)i * (signed long int)(unsigned long int)nexg + (signed long int)(unsigned long int)ich], expval))
      {
        fprintf(stderr, "\tEXG value (%f) different from the one expected (%f) at sample %zu ch:%u\n", exg[(signed long int)(i * (unsigned long int)nexg + (unsigned long int)ich)], expval, i + (unsigned long int)nsread, ich);
        retval = -1;
      }

    }
    ich = 0;
    for( ; retval == 0 && !(ich >= ntri); ich = ich + 1)
    {
      exptri=get_trigger_val((unsigned long int)nstot, (unsigned int)ich);
      if(!(tri[(signed long int)i * (signed long int)(unsigned long int)ntri + (signed long int)(unsigned long int)ich] == exptri))
      {
        fprintf(stderr, "\tTrigger value (0x%08x) different from the one expected (0x%08x) at sample %zu ch:%u\n", tri[(signed long int)i], exptri, i + (unsigned long int)nsread, ich);
        retval = -1;
      }

    }
    nstot = nstot + 1;
  }
  nsread = nsread + (signed int)ns;
  return retval;
}

// create_listening_socket
// file tia-server.c line 87
static signed int create_listening_socket(unsigned short int port)
{
  signed int fd = -1;
  signed int reuse = 1;
  signed int v6only = 0;
  struct sockaddr_in6 saddr;
  unsigned short int return_value_htons$1;
  return_value_htons$1=htons(port);
  saddr = (struct sockaddr_in6){ .sin6_family=(unsigned short int)10, .sin6_port=return_value_htons$1, .sin6_flowinfo=0u,
    .sin6_addr={ .__in6_u={ .__u6_addr8={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } }, .sin6_scope_id=0u };
  fd=socket(10, 1, 0);
  _Bool tmp_if_expr$3;
  signed int return_value_setsockopt$2;
  if(fd == -1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_setsockopt$2=setsockopt(fd, 1, 2, (const void *)&reuse, (unsigned int)sizeof(signed int) /*4ul*/ );
    tmp_if_expr$3 = return_value_setsockopt$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  signed int return_value_setsockopt$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_setsockopt$4=setsockopt(fd, 41, 26, (const void *)&v6only, (unsigned int)sizeof(signed int) /*4ul*/ );
    tmp_if_expr$5 = return_value_setsockopt$4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  signed int return_value_bind$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_bind$6=bind(fd, (struct sockaddr *)&saddr, (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ );
    tmp_if_expr$7 = return_value_bind$6 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$9;
  signed int return_value_listen$8;
  if(tmp_if_expr$7)
    tmp_if_expr$9 = (_Bool)1;

  else
  {
    return_value_listen$8=listen(fd, 32);
    tmp_if_expr$9 = return_value_listen$8 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$9)
  {
    close(fd);
    fd = -1;
  }

  return fd;
}

// create_tia_server
// file fakelibs/tia-server.h line 34
signed int create_tia_server(unsigned short int port)
{
  listenfd=create_listening_socket(port);
  if(listenfd == -1)
    return -1;

  else
  {
    pthread_create(&ctrl_thid, (const union pthread_attr_t *)(void *)0, ctrl_socket_fn, (void *)0);
    return 0;
  }
}

// ctrl_socket_fn
// file tia-server.c line 419
static void * ctrl_socket_fn(void *data)
{
  (void)data;
  signed int ret = 0;
  signed int fd;
  signed int req;
  struct _IO_FILE *ctrl_in;
  struct sockaddr_in caddr;
  unsigned int clilen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  fd=accept(listenfd, (struct sockaddr *)&caddr, &clilen);
  if(fd == -1)
    return (void *)0;

  else
  {
    ctrl_in=fdopen(fd, "rb");
    while(ret == 0)
    {
      req=read_ctrl_msg(ctrl_in);
      if(req == 0)
        ret=reply_msg(fd, "OK", 0, (const char *)(void *)0);

      else
        if(req == 1)
          ret=reply_metainfo(fd);

        else
          if(req == 2)
            ret=reply_dataconnection(fd);

          else
            if(req == 3)
              ret=reply_startdata(fd);

            else
              if(req == 4)
                ret=reply_stopdata(fd);

              else
                if(req == -1)
                  break;

    }
    fclose(ctrl_in);
    destroy_dataloop();
    return (void *)0;
  }
}

// data_socket_fn
// file tia-server.c line 170
static void * data_socket_fn(void *data)
{
  (void)data;
  signed int ret = 0;
  signed int fd;
  signed int len;
  struct sockaddr_in cliaddr;
  unsigned int clilen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  char buffer[8192l];
  fd=accept(datafd, (struct sockaddr *)&cliaddr, &clilen);
  while(ret == 0)
  {
    pthread_mutex_lock(&lock);
    while(acq_run == 0)
      pthread_cond_wait(&cond, &lock);
    ret = (signed int)(acq_run < 0);
    pthread_mutex_unlock(&lock);
    len=write_data_packet(buffer);
    signed long int return_value_write$1;
    return_value_write$1=write(fd, (const void *)(buffer + (signed long int)7ul), (unsigned long int)len);
    if(!(return_value_write$1 >= (signed long int)len))
      break;

    addtime(&acq_ts, (signed long int)0, (signed long int)(((unsigned int)1000000000 / samplingrate) * blocksize));
    clock_nanosleep(0, 1, &acq_ts, (struct timespec *)(void *)0);
  }
  close(fd);
  return (void *)0;
}

// destroy_dataloop
// file tia-server.c line 323
static void destroy_dataloop(void)
{
  if(acq_run >= -1)
  {
    pthread_mutex_lock(&lock);
    acq_run = -1;
    pthread_cond_signal(&cond);
    pthread_mutex_unlock(&lock);
    pthread_join(data_thid, (void **)(void *)0);
  }

}

// destroy_tia_server
// file fakelibs/tia-server.h line 35
void destroy_tia_server(void)
{
  if(!(listenfd == -1))
  {
    shutdown(listenfd, 0);
    pthread_join(ctrl_thid, (void **)(void *)0);
    close(listenfd);
  }

  unlink("metainfoxml.tmp");
}

// egd_acq_setup
// file ../src/core/eegdev.h line 83
signed int egd_acq_setup(struct eegdev *dev, unsigned int narr, const unsigned long int *strides, unsigned int ngrp, struct grpconf *grp)
{
  signed int acquiring;
  signed int retval = -1;
  signed int return_value_reterrno$1;
  signed int return_value_reterrno$2;
  void *return_value_malloc$4;
  signed int return_value;
  void *return_value_malloc$5;
  if(dev == ((struct eegdev *)NULL) || grp == ((struct grpconf *)NULL) && !(ngrp == 0u) || strides == ((const unsigned long int *)NULL) && !(narr == 0u))
  {
    return_value_reterrno$1=reterrno(22);
    return return_value_reterrno$1;
  }

  else
  {
    pthread_mutex_lock(&dev->synclock);
    acquiring = dev->acquiring;
    pthread_mutex_unlock(&dev->synclock);
    if(!(acquiring == 0))
    {
      return_value_reterrno$2=reterrno(1);
      return return_value_reterrno$2;
    }

    else
    {
      pthread_mutex_lock(&dev->apilock);
      signed int return_value_validate_groups_settings$3;
      return_value_validate_groups_settings$3=validate_groups_settings(dev, ngrp, grp);
      if(return_value_validate_groups_settings$3 == 0)
      {
        free((void *)dev->strides);
        return_value_malloc$4=malloc((unsigned long int)narr * sizeof(const unsigned long int) /*8ul*/ );
        dev->strides = (unsigned long int *)return_value_malloc$4;
        if(!(dev->strides == ((unsigned long int *)NULL)))
        {
          dev->narr = narr;
          memcpy((void *)dev->strides, (const void *)strides, (unsigned long int)narr * sizeof(const unsigned long int) /*8ul*/ );
          return_value=dev->ops.set_channel_groups(&dev->module, ngrp, grp);
          if(return_value == 0)
          {
            setup_ringbuffer_mapping(dev);
            free((void *)dev->buffer);
            dev->buff_ns = (unsigned long int)((unsigned int)10 * dev->cap.sampling_freq);
            dev->buffsize = (unsigned long int)((unsigned int)10 * dev->cap.sampling_freq) * dev->buff_samlen;
            return_value_malloc$5=malloc(dev->buffsize);
            dev->buffer = (char *)return_value_malloc$5;
            if(!(dev->buffer == ((char *)NULL)))
              retval = 0;

          }

        }

      }


    out:
      ;
      pthread_mutex_unlock(&dev->apilock);
      return retval;
    }
  }
}

// egd_channel_info
// file core.c line 512
signed int egd_channel_info(struct eegdev *dev, signed int stype, unsigned int index, signed int fieldtype, ...)
{
  __builtin_va_list ap;
  const unsigned int *nmax;
  signed int field;
  signed int retval = 0;
  void *arg;
  struct egd_chinfo chinfo = { .label=(const char *)(void *)0, .unit=((const char *)NULL), .transducter=((const char *)NULL),
    .prefiltering=((const char *)NULL), .isint=(_Bool)0,
    .dtype=0, .min={ .valdouble=0.000000 }, .max={ .valdouble=0.000000 } };
  union anonymous$0 *apilock = (union anonymous$0 *)&dev->apilock;
  signed int return_value_reterrno$1;
  _Bool tmp_if_expr$3;
  signed int return_value_reterrno$2;
  _Bool tmp_if_expr$4;
  if(dev == ((struct eegdev *)NULL))
  {
    return_value_reterrno$1=reterrno(22);
    return return_value_reterrno$1;
  }

  else
  {
    nmax = dev->cap.type_nch;
    if(stype >= 3 || !(stype >= 0))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = index >= nmax[(signed long int)stype] ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      return_value_reterrno$2=reterrno(22);
      return return_value_reterrno$2;
    }

    else
    {
      pthread_mutex_lock(apilock);
      /* assertion dev->ops.fill_chinfo */
      assert(dev->ops.fill_chinfo != ((void (*)(struct devmodule *, signed int, unsigned int, struct egd_chinfo *))NULL));
      dev->ops.fill_chinfo(&dev->module, stype, index, &chinfo);
      va_start(ap, fieldtype);
      field = fieldtype;
      if(retval == 0 && !(field == 0))
      {
        if(field >= 9 || !(field >= 0))
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          arg=va_arg(ap, __typeof__(arg));
          tmp_if_expr$4 = arg == (void *)0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
          retval=reterrno(22);

        else
        {
          retval=get_field_info(&chinfo, field, arg);
          field=va_arg(ap, __typeof__(field));
        }
      }

      va_end(ap);
      pthread_mutex_unlock(apilock);
      return retval;
    }
  }
}

// egd_close
// file ../src/core/eegdev.h line 82
signed int egd_close(struct eegdev *dev)
{
  signed int acquiring;
  if(dev == ((struct eegdev *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }

  pthread_mutex_lock(&dev->synclock);
  acquiring = dev->acquiring;
  pthread_mutex_unlock(&dev->synclock);
  if(!(acquiring == 0))
    egd_stop(dev);

  dev->ops.close_device(&dev->module);
  dlclose(dev->handle);
  egd_destroy_eegdev(dev);
  return 0;
}

// egd_destroy_eegdev
// file core.c line 321
void egd_destroy_eegdev(struct eegdev *dev)
{
  if(!(dev == ((struct eegdev *)NULL)))
  {
    free((void *)dev->cap.device_type);
    pthread_cond_destroy(&dev->available);
    pthread_mutex_destroy(&dev->synclock);
    pthread_mutex_destroy(&dev->apilock);
    free((void *)dev->selch);
    free((void *)dev->inbuffgrp);
    free((void *)dev->arrconf);
    free((void *)dev->strides);
    free((void *)dev->buffer);
    free((void *)dev);
  }

}

// egd_get_available
// file core.c line 679
signed long int egd_get_available(struct eegdev *dev)
{
  signed int ns;
  signed int error;
  signed int return_value_reterrno$1;
  signed int return_value_reterrno$2;
  if(dev == ((struct eegdev *)NULL))
  {
    return_value_reterrno$1=reterrno(22);
    return (signed long int)return_value_reterrno$1;
  }

  else
  {
    pthread_mutex_lock(&dev->synclock);
    ns = (signed int)(dev->ns_written - dev->ns_read);
    error = dev->error;
    pthread_mutex_unlock(&dev->synclock);
    if(ns == 0 && !(error == 0))
    {
      return_value_reterrno$2=reterrno(error);
      return (signed long int)return_value_reterrno$2;
    }

    else
      return (signed long int)ns;
  }
}

// egd_get_cap
// file ../src/core/eegdev.h line 78
signed int egd_get_cap(struct eegdev *dev, signed int cap, void *val)
{
  signed int retval = 0;
  signed int return_value_reterrno$1;
  unsigned long int return_value_strlen$2;
  unsigned long int return_value_strlen$3;
  if(dev == ((struct eegdev *)NULL) || val == NULL && !(cap == 0))
  {
    return_value_reterrno$1=reterrno(22);
    return return_value_reterrno$1;
  }

  else
  {
    switch(cap)
    {
      case 0:
      {
        if(!(val == NULL))
          *((unsigned int *)val) = dev->cap.sampling_freq;

        retval = (signed int)dev->cap.sampling_freq;
        break;
      }
      case 1:
      {
        *((const signed int **)val) = dev->provided_stypes;
        retval = (signed int)dev->num_stypes;
        break;
      }
      case 2:
      {
        *((const char **)val) = dev->cap.device_type;
        return_value_strlen$2=strlen(dev->cap.device_type);
        retval = (signed int)return_value_strlen$2;
        break;
      }
      case 3:
      {
        *((const char **)val) = dev->cap.device_id;
        return_value_strlen$3=strlen(dev->cap.device_id);
        retval = (signed int)return_value_strlen$3;
        break;
      }
      default:
      {
        retval = -1;
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        *return_value___errno_location$4 = 22;
      }
    }
    return retval;
  }
}

// egd_get_cast_fn
// file coreinternals.h line 52
void (*egd_get_cast_fn(unsigned int itype, unsigned int otype, unsigned int scaling))(void *, const void *, union gval, unsigned long int)
{
  if(itype >= 3u || otype >= 3u)
    return (void (*)(void *, const void *, union gval, unsigned long int))(void *)0;

  else
  {
    scaling = (unsigned int)(scaling != 0u ? 1 : 0);
    return convtable[(signed long int)itype][(signed long int)scaling][(signed long int)otype];
  }
}

// egd_get_data
// file ../src/core/eegdev.h line 87
signed long int egd_get_data(struct eegdev *dev, unsigned long int ns, ...)
{
  signed int return_value_reterrno$1;
  signed int return_value_reterrno$2;
  if(dev == ((struct eegdev *)NULL))
  {
    return_value_reterrno$1=reterrno(22);
    return (signed long int)return_value_reterrno$1;
  }

  else
  {
    unsigned int i;
    unsigned int s;
    unsigned int iarr;
    unsigned int curr_s = dev->last_read;
    struct array_config * restrict ac = dev->arrconf;
    char * restrict ringbuffer = dev->buffer;
    const signed long int ringbuffer$array_size0 = (signed long int)dev->narr;
    char * restrict buffout[ringbuffer$array_size0];
    __builtin_va_list ap;
    signed int error;
    va_start(ap, ns);
    i = (unsigned int)0;
    for( ; !(i >= dev->narr); i = i + 1u)
      buffout[(signed long int)i]=va_arg(ap, __typeof__(buffout[(signed long int)i]));
    va_end(ap);
    error=wait_for_data(dev, &ns);
    if(ns == 0ul && !(error == 0))
    {
      return_value_reterrno$2=reterrno(error);
      return (signed long int)return_value_reterrno$2;
    }

    else
    {
      s = (unsigned int)0;
      for( ; !((unsigned long int)s >= ns); s = s + 1u)
      {
        i = (unsigned int)0;
        for( ; !(i >= dev->nconf); i = i + 1u)
        {
          iarr = (ac + (signed long int)i)->iarray;
          memcpy((void *)(buffout[(signed long int)iarr] + (signed long int)(ac + (signed long int)i)->arr_offset), (const void *)(ringbuffer + (signed long int)curr_s + (signed long int)(ac + (signed long int)i)->buff_offset), (unsigned long int)(ac + (signed long int)i)->len);
        }
        curr_s = (unsigned int)(((unsigned long int)curr_s + dev->buff_samlen) % dev->buffsize);
        i = (unsigned int)0;
        for( ; !(i >= dev->narr); i = i + 1u)
          buffout[(signed long int)i] = buffout[(signed long int)i] + (signed long int)dev->strides[(signed long int)i];
      }
      pthread_mutex_lock(&dev->synclock);
      dev->ns_read = dev->ns_read + ns;
      pthread_mutex_unlock(&dev->synclock);
      dev->last_read = curr_s;
      return (signed long int)ns;
    }
  }
}

// egd_get_data_size
// file eegdev-pluginapi.h line 143
static inline unsigned int egd_get_data_size(unsigned int type)
{
  unsigned int size = (unsigned int)0;
  if(type == 0u)
    size = (unsigned int)sizeof(signed int) /*4ul*/ ;

  else
    if(type == 1u)
      size = (unsigned int)sizeof(float) /*4ul*/ ;

    else
      if(type == 2u)
        size = (unsigned int)sizeof(double) /*8ul*/ ;

  return size;
}

// egd_get_numch
// file ../src/core/eegdev.h line 79
signed int egd_get_numch(struct eegdev *dev, signed int stype)
{
  signed int return_value_reterrno$1;
  if(dev == ((struct eegdev *)NULL) || stype >= 3 || !(stype >= 0))
  {
    return_value_reterrno$1=reterrno(22);
    return return_value_reterrno$1;
  }

  else
    return (signed int)dev->cap.type_nch[(signed long int)stype];
}

// egd_get_string
// file core.c line 750
const char * egd_get_string(void)
{
  return eegdev_string;
}

// egd_open
// file ../src/core/eegdev.h line 77
struct eegdev * egd_open(const char *confstring)
{
  struct conf cf;
  struct eegdev *dev = (struct eegdev *)(void *)0;
  const char *device;
  signed int return_value_init_configuration$1;
  return_value_init_configuration$1=init_configuration(&cf, confstring);
  _Bool tmp_if_expr$3;
  signed int return_value_load_configuration_file$2;
  if(!(return_value_init_configuration$1 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_load_configuration_file$2=load_configuration_file(&cf, "eegdev.conf", 1);
    tmp_if_expr$3 = return_value_load_configuration_file$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
  {
    free_configuration(&cf);
    return (struct eegdev *)(void *)0;
  }

  else
  {
    device=get_conf_setting(&cf, "device", "any");
    signed int return_value_strcmp$4;
    return_value_strcmp$4=strcmp(device, "any");
    if(return_value_strcmp$4 == 0)
      dev=open_any(&cf);

    else
      dev=open_plugin_device(device, &cf);
    free_configuration(&cf);
    return dev;
  }
}

// egd_sensor_name
// file sensortypes.c line 129
const char * egd_sensor_name(signed int stype)
{
  struct sensor_type *curr = first.next;
  for( ; !(curr == ((struct sensor_type *)NULL)); curr = curr->next)
    if(curr->stype == stype)
      return curr->name;

  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 22;
  return (const char *)(void *)0;
}

// egd_sensor_type
// file ../src/core/eegdev.h line 74
signed int egd_sensor_type(const char *name)
{
  signed int stype = 0;
  struct sensor_type *curr = &first;
  if(name == ((const char *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }

  pthread_once(&stype_once, sensor_type_init);
  while(!(curr->next == ((struct sensor_type *)NULL)))
  {
    curr = curr->next;
    signed int return_value_strcmp$2;
    return_value_strcmp$2=strcmp(name, curr->name);
    if(return_value_strcmp$2 == 0)
      return curr->stype;

  }
  pthread_mutex_lock(&stype_lock);
  stype=add_sensor_type(name, curr);
  pthread_mutex_unlock(&stype_lock);
  return stype;
}

// egd_start
// file ../src/core/eegdev.h line 86
signed int egd_start(struct eegdev *dev)
{
  signed int acquiring;
  signed int return_value_reterrno$1;
  signed int return_value_reterrno$2;
  if(dev == ((struct eegdev *)NULL))
  {
    return_value_reterrno$1=reterrno(22);
    return return_value_reterrno$1;
  }

  else
  {
    pthread_mutex_lock(&dev->synclock);
    acquiring = dev->acquiring;
    pthread_mutex_unlock(&dev->synclock);
    if(!(acquiring == 0))
    {
      return_value_reterrno$2=reterrno(1);
      return return_value_reterrno$2;
    }

    else
    {
      pthread_mutex_lock(&dev->synclock);
      dev->ns_written = (unsigned long int)0;
      dev->ns_read = dev->ns_written;
      dev->ops.start_acq(&dev->module);
      dev->acq_order = 1;
      dev->acquiring = 1;
      pthread_mutex_unlock(&dev->synclock);
      return 0;
    }
  }
}

// egd_stop
// file ../src/core/eegdev.h line 89
signed int egd_stop(struct eegdev *dev)
{
  signed int acquiring;
  signed int return_value_reterrno$1;
  signed int return_value_reterrno$2;
  if(dev == ((struct eegdev *)NULL))
  {
    return_value_reterrno$1=reterrno(22);
    return return_value_reterrno$1;
  }

  else
  {
    pthread_mutex_lock(&dev->synclock);
    acquiring = dev->acquiring;
    pthread_mutex_unlock(&dev->synclock);
    if(acquiring == 0)
    {
      return_value_reterrno$2=reterrno(1);
      return return_value_reterrno$2;
    }

    else
    {
      pthread_mutex_lock(&dev->synclock);
      dev->acq_order = 2;
      pthread_mutex_unlock(&dev->synclock);
      dev->ops.stop_acq(&dev->module);
      return 0;
    }
  }
}

// egd_update_capabilities
// file core.c line 418
void egd_update_capabilities(struct eegdev *dev)
{
  signed int stype;
  unsigned int num_stypes = (unsigned int)0;
  stype = 0;
  unsigned int tmp_post$1;
  for( ; !(stype >= 3); stype = stype + 1)
    if(dev->cap.type_nch[(signed long int)stype] >= 1u)
    {
      tmp_post$1 = num_stypes;
      num_stypes = num_stypes + 1u;
      dev->provided_stypes[(signed long int)tmp_post$1] = stype;
    }

  dev->provided_stypes[(signed long int)num_stypes] = -1;
  dev->num_stypes = num_stypes;
}

// egdi_add_setting
// file configuration.c line 62
signed int egdi_add_setting(struct egdi_config *cf, const char *name, const char *value)
{
  unsigned long int nlen;
  unsigned long int vlen;
  unsigned int nmax;
  void *newbuff;
  struct setting *set;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(name);
  nlen = return_value_strlen$1 + (unsigned long int)1;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(value);
  vlen = return_value_strlen$2 + (unsigned long int)1;
  for( ; !(cf->maxsize >= cf->cursize + nlen + vlen); cf->buffer = (char *)newbuff)
  {
    newbuff=realloc((void *)cf->buffer, cf->maxsize + (unsigned long int)1024);
    if(newbuff == NULL)
      return -1;

    cf->maxsize = cf->maxsize + (unsigned long int)1024;
  }
  if(cf->numsettings == cf->nmaxsettings)
  {
    nmax = (unsigned int)(cf->nmaxsettings + 32);
    newbuff=realloc((void *)cf->settings, (unsigned long int)nmax * sizeof(struct setting) /*8ul*/ );
    if(newbuff == NULL)
      return -1;

    cf->nmaxsettings = cf->nmaxsettings + 32;
    cf->settings = (struct setting *)newbuff;
  }

  set = cf->settings + (signed long int)cf->numsettings;
  set->c_offset = (unsigned int)cf->cursize;
  set->v_offset = (unsigned int)(cf->cursize + nlen);
  strcpy(cf->buffer + (signed long int)set->c_offset, name);
  strcpy(cf->buffer + (signed long int)set->v_offset, value);
  cf->cursize = cf->cursize + nlen + vlen;
  cf->numsettings = cf->numsettings + 1;
  return 0;
}

// egdi_alloc_input_groups
// file core.c line 432
struct selected_channels * egdi_alloc_input_groups(struct devmodule *mdev, unsigned int ngrp)
{
  struct eegdev *dev = (struct eegdev *)((unsigned long int)(signed long int)mdev - 376ul);
  free((void *)dev->selch);
  free((void *)dev->inbuffgrp);
  free((void *)dev->arrconf);
  dev->ngrp = ngrp;
  dev->nconf = dev->ngrp;
  dev->nsel = dev->nconf;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)ngrp, sizeof(struct selected_channels) /*40ul*/ );
  dev->selch = (struct selected_channels *)return_value_calloc$1;
  void *return_value_calloc$2;
  return_value_calloc$2=calloc((unsigned long int)ngrp, sizeof(struct input_buffer_group) /*40ul*/ );
  dev->inbuffgrp = (struct input_buffer_group *)return_value_calloc$2;
  void *return_value_calloc$3;
  return_value_calloc$3=calloc((unsigned long int)ngrp, sizeof(struct array_config) /*16ul*/ );
  dev->arrconf = (struct array_config *)return_value_calloc$3;
  _Bool tmp_if_expr$4;
  if(dev->selch == ((struct selected_channels *)NULL))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = !(dev->inbuffgrp != ((struct input_buffer_group *)NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = !(dev->arrconf != ((struct array_config *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$5)
    return (struct selected_channels *)(void *)0;

  else
    return dev->selch;
}

// egdi_create_eegdev
// file core.c line 277
struct eegdev * egdi_create_eegdev(struct egdi_plugin_info *info)
{
  signed int stinit = 0;
  struct eegdev *dev;
  struct eegdev_operations ops;
  struct core_interface *ci;
  unsigned long int dsize = ((unsigned long int)info->struct_size + sizeof(struct eegdev) /*424ul*/ ) - sizeof(struct devmodule) /*48ul*/ ;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, dsize);
  dev = (struct eegdev *)return_value_calloc$1;
  _Bool tmp_if_expr$3;
  signed int return_value_pthread_cond_init$2;
  if(dev == ((struct eegdev *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_pthread_cond_init$2=pthread_cond_init(&dev->available, (const union anonymous$6 *)(void *)0);
    tmp_if_expr$3 = return_value_pthread_cond_init$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    stinit = stinit + 1;
    tmp_if_expr$4 = !(stinit != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$6;
  signed int return_value_pthread_mutex_init$5;
  if(tmp_if_expr$4)
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    return_value_pthread_mutex_init$5=pthread_mutex_init(&dev->synclock, (const union anonymous$6 *)(void *)0);
    tmp_if_expr$6 = return_value_pthread_mutex_init$5 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  if(tmp_if_expr$6)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    stinit = stinit + 1;
    tmp_if_expr$7 = !(stinit != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$9;
  signed int return_value_pthread_mutex_init$8;
  if(tmp_if_expr$7)
    tmp_if_expr$9 = (_Bool)1;

  else
  {
    return_value_pthread_mutex_init$8=pthread_mutex_init(&dev->apilock, (const union anonymous$6 *)(void *)0);
    tmp_if_expr$9 = return_value_pthread_mutex_init$8 != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int (*tmp_if_expr$10)(struct devmodule *);
  signed int (*tmp_if_expr$11)(struct devmodule *);
  signed int tmp_post$12;
  signed int tmp_post$13;
  if(!tmp_if_expr$9)
  {
    ops.close_device = info->close_device;
    ops.set_channel_groups = info->set_channel_groups;
    ops.fill_chinfo = info->fill_chinfo;
    if(!(info->start_acq == ((signed int (*)(struct devmodule *))NULL)))
      tmp_if_expr$10 = info->start_acq;

    else
      tmp_if_expr$10 = noaction;
    ops.start_acq = tmp_if_expr$10;
    if(!(info->stop_acq == ((signed int (*)(struct devmodule *))NULL)))
      tmp_if_expr$11 = info->stop_acq;

    else
      tmp_if_expr$11 = noaction;
    ops.stop_acq = tmp_if_expr$11;
    memcpy((void *)&dev->ops, (const void *)&ops, sizeof(struct eegdev_operations) /*40ul*/ );
    ci = (struct core_interface *)&dev->module.ci;
    ci->update_ringbuffer = egdi_update_ringbuffer;
    ci->report_error = egdi_report_error;
    ci->alloc_input_groups = egdi_alloc_input_groups;
    ci->set_input_samlen = egdi_set_input_samlen;
    ci->set_cap = egdi_set_cap;
    ci->get_stype = egd_sensor_type;
    return dev;
  }

  else
  {

  fail:
    ;
    tmp_post$12 = stinit;
    stinit = stinit - 1;
    if(!(tmp_post$12 == 0))
      pthread_mutex_destroy(&dev->synclock);

    tmp_post$13 = stinit;
    stinit = stinit - 1;
    if(!(tmp_post$13 == 0))
      pthread_cond_destroy(&dev->available);

    free((void *)dev);
    return (struct eegdev *)(void *)0;
  }
}

// egdi_free_config
// file configuration.h line 35
void egdi_free_config(struct egdi_config *cf)
{
  free((void *)cf->settings);
  free((void *)cf->buffer);
  cf->nmaxsettings = 0;
  cf->numsettings = cf->nmaxsettings;
  cf->maxsize = (unsigned long int)0;
  cf->cursize = cf->maxsize;
}

// egdi_get_setting_value
// file configuration.h line 40
const char * egdi_get_setting_value(struct egdi_config *cf, const char *name)
{
  unsigned int i = (unsigned int)cf->numsettings;
  const char *buff = cf->buffer;
  while(!(i == 0u))
  {
    i = i - 1u;
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(buff + (signed long int)(cf->settings + (signed long int)i)->c_offset, name);
    if(return_value_strcmp$1 == 0)
      return buff + (signed long int)(cf->settings + (signed long int)i)->v_offset;

  }
  return (const char *)(void *)0;
}

// egdi_init_config
// file configuration.h line 36
void egdi_init_config(struct egdi_config *cf)
{
  cf->settings = (struct setting *)(void *)0;
  cf->buffer = (char *)(void *)0;
  cf->numsettings = 0;
  cf->nmaxsettings = 0;
  cf->maxsize = (unsigned long int)0;
  cf->cursize = cf->maxsize;
}

// egdi_parse_conffile
// file configuration.h line 43
signed int egdi_parse_conffile(struct egdi_config *cf, const char *filename)
{
  struct cfdata p = { .cf=cf, .fpath=filename, .tokbuff={ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, .itok=0,
    .scaninfo=(void *)0 };
  struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  signed int ret;
  fp=fopen(filename, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(*return_value___errno_location$2 == 2)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 0;
      return 0;
    }

    return -1;
  }

  signed int return_value_cff_lex_init_extra$3;
  return_value_cff_lex_init_extra$3=cff_lex_init_extra((void *)&p, &p.scaninfo);
  if(!(return_value_cff_lex_init_extra$3 == 0))
  {
    fclose(fp);
    return -1;
  }

  else
  {
    cff_set_in(fp, p.scaninfo);
    ret=cff_parse(&p);
    cff_lex_destroy(p.scaninfo);
    fclose(fp);
    return ret;
  }
}

// egdi_parse_confline
// file configuration.h line 44
signed int egdi_parse_confline(struct egdi_config *cf, const char *confstr)
{
  struct cfldata p = { .cf=cf, .tokbuff={ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, .itok=0,
    .scaninfo=(void *)0 };
  struct yy_buffer_state *buf;
  signed int ret;
  if(confstr == ((const char *)NULL))
    return 0;

  else
  {
    signed int return_value_cfl_lex_init_extra$1;
    return_value_cfl_lex_init_extra$1=cfl_lex_init_extra((void *)&p, &p.scaninfo);
    if(!(return_value_cfl_lex_init_extra$1 == 0))
      return -1;

    else
    {
      buf=cfl__scan_string(confstr, p.scaninfo);
      if(buf == ((struct yy_buffer_state *)NULL))
      {
        cfl_lex_destroy(p.scaninfo);
        return -1;
      }

      else
      {
        ret=cfl_parse(&p);
        cfl__delete_buffer(buf, p.scaninfo);
        cfl_lex_destroy(p.scaninfo);
        return ret;
      }
    }
  }
}

// egdi_reinit_config
// file configuration.h line 37
void egdi_reinit_config(struct egdi_config *cf)
{
  cf->numsettings = 0;
  cf->cursize = (unsigned long int)0;
}

// egdi_report_error
// file core.c line 402
void egdi_report_error(struct devmodule *mdev, signed int error)
{
  struct eegdev *dev = (struct eegdev *)((unsigned long int)(signed long int)mdev - 376ul);
  pthread_mutex_lock(&dev->synclock);
  if(dev->error == 0)
    dev->error = error;

  if(!(dev->nreadwait == 0u))
    pthread_cond_signal(&dev->available);

  pthread_mutex_unlock(&dev->synclock);
}

// egdi_set_cap
// file core.c line 250
static signed int egdi_set_cap(struct devmodule *mdev, struct systemcap *cap)
{
  char *strbuff;
  unsigned long int lentype;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(cap->device_type);
  lentype = return_value_strlen$1 + (unsigned long int)1;
  unsigned long int lenid;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(cap->device_id);
  lenid = return_value_strlen$2 + (unsigned long int)1;
  struct eegdev *dev = (struct eegdev *)((unsigned long int)(signed long int)mdev - 376ul);
  void *return_value_malloc$3;
  return_value_malloc$3=malloc(lenid + lentype);
  strbuff = (char *)return_value_malloc$3;
  if(strbuff == ((char *)NULL))
    return -1;

  else
  {
    dev->cap.sampling_freq = cap->sampling_freq;
    strcpy(strbuff, cap->device_type);
    dev->cap.device_type = strbuff;
    strbuff = strbuff + (signed long int)lentype;
    strcpy(strbuff, cap->device_id);
    dev->cap.device_id = strbuff;
    memcpy((void *)dev->cap.type_nch, (const void *)cap->type_nch, sizeof(unsigned int [3l]) /*12ul*/ );
    return 0;
  }
}

// egdi_set_input_samlen
// file core.c line 454
void egdi_set_input_samlen(struct devmodule *mdev, unsigned int samlen)
{
  ((struct eegdev *)((unsigned long int)(signed long int)mdev - 376ul))->in_samlen = (unsigned long int)samlen;
}

// egdi_update_ringbuffer
// file core.c line 343
signed int egdi_update_ringbuffer(struct devmodule *mdev, const void *in, unsigned long int length)
{
  unsigned int ns;
  unsigned int rest;
  signed int acquiring;
  unsigned long int nsread;
  unsigned long int ns_be_written;
  struct eegdev *dev = (struct eegdev *)((unsigned long int)(signed long int)mdev - 376ul);
  union anonymous$0 *synclock = &dev->synclock;
  pthread_mutex_lock(synclock);
  nsread = dev->ns_read;
  acquiring = dev->acquiring;
  if(dev->acq_order == 1)
  {
    rest = (unsigned int)((dev->in_samlen - dev->in_offset) % dev->in_samlen);
    if(length >= (unsigned long int)rest)
    {
      dev->acq_order = 0;
      in = (const void *)((char *)in + (signed long int)rest);
      length = length - (unsigned long int)rest;
      dev->in_offset = (unsigned long int)0;
    }

  }

  else
    if(dev->acq_order == 2)
    {
      dev->acq_order = 0;
      dev->acquiring = 0;
      acquiring = dev->acquiring;
    }

  pthread_mutex_unlock(synclock);
  if(!(acquiring == 0))
  {
    ns_be_written = length / dev->in_samlen + (unsigned long int)2 + dev->ns_written;
    if(ns_be_written + -nsread >= dev->buff_ns)
    {
      egdi_report_error(mdev, 12);
      return -1;
    }

    ns=cast_data(dev, in, length);
    pthread_mutex_lock(synclock);
    dev->ns_written = dev->ns_written + (unsigned long int)ns;
    if(!(dev->nreadwait == 0u))
    {
      if(dev->ns_written >= dev->ns_read + (unsigned long int)dev->nreadwait)
        pthread_cond_signal(&dev->available);

    }

    pthread_mutex_unlock(synclock);
  }

  dev->in_offset = (length + dev->in_offset) % dev->in_samlen;
  return 0;
}

// free_configuration
// file opendev.c line 62
static void free_configuration(struct conf *cf)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= 3u); i = i + 1u)
    egdi_free_config(&cf->config[(signed long int)i]);
}

// get_analog_val
// file fakelibs/tia-server.h line 22
static inline float get_analog_val(unsigned long int sam, unsigned int ich)
{
  return (float)(1.0e-1 * (double)(ich + (unsigned int)1) * (double)((float)(sam % (unsigned long int)113) - 50.0f));
}

// get_analog_val$link1
// file tia-server.h line 22
static inline float get_analog_val$link1(unsigned long int sam$link1, unsigned int ich$link1)
{
  return (float)(1.0e-1 * (double)(ich$link1 + (unsigned int)1) * (double)((float)(sam$link1 % (unsigned long int)113) - 50.0f));
}

// get_charset_aliases
// file localcharset.c line 123
static const char * get_charset_aliases(void)
{
  const char *cp = charset_aliases;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(cp == ((const char *)NULL))
  {
    const char *dir;
    const char *base = "charset.alias";
    char *file_name;
    dir=getenv("CHARSETALIASDIR");
    if(dir == ((const char *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)dir[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      dir = "/usr/lib/x86_64-linux-gnu";

    unsigned long int dir_len;
    dir_len=strlen(dir);
    unsigned long int base_len;
    base_len=strlen(base);
    signed int add_slash;
    if(dir_len >= 1ul)
      tmp_if_expr$2 = !((signed int)dir[(signed long int)(dir_len - (unsigned long int)1)] == 47) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    add_slash = (signed int)tmp_if_expr$2;
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(dir_len + (unsigned long int)add_slash + base_len + (unsigned long int)1);
    file_name = (char *)return_value_malloc$3;
    if(!(file_name == ((char *)NULL)))
    {
      memcpy((void *)file_name, (const void *)dir, dir_len);
      if(!(add_slash == 0))
        file_name[(signed long int)dir_len] = (char)47;

      memcpy((void *)(file_name + (signed long int)dir_len + (signed long int)add_slash), (const void *)base, base_len + (unsigned long int)1);
    }

    if(file_name == ((char *)NULL))
      cp = "";

    else
    {
      signed int fd;
      fd=open(file_name, 00 | (1 != 0 ? 0400000 : 0));
      if(!(fd >= 0))
        cp = "";

      else
      {
        struct _IO_FILE *fp;
        fp=fdopen(fd, "r");
        if(fp == ((struct _IO_FILE *)NULL))
        {
          close(fd);
          cp = "";
        }

        else
        {
          char *res_ptr = (char *)(void *)0;
          unsigned long int res_size = (unsigned long int)0;
          do
          {
            signed int c;
            char buf1[51l];
            char buf2[51l];
            unsigned long int l1;
            unsigned long int l2;
            char *old_res_ptr;
            c=getc_unlocked(fp);
            if(c == -1)
              break;

            if(!(c == 9) && !(c == 10) && !(c == 32))
            {
              if(c == 35)
              {
                do
                  c=getc_unlocked(fp);
                while(!(c == 10) && !(c == -1));
                if(c == -1)
                  break;

              }

              else
              {
                ungetc(c, fp);
                signed int return_value_fscanf$4;
                return_value_fscanf$4=fscanf(fp, "%50s %50s", (const void *)buf1, (const void *)buf2);
                if(!(return_value_fscanf$4 >= 2))
                  break;

                l1=strlen(buf1);
                l2=strlen(buf2);
                old_res_ptr = res_ptr;
                if(res_size == 0ul)
                {
                  res_size = l1 + (unsigned long int)1 + l2 + (unsigned long int)1;
                  void *return_value_malloc$5;
                  return_value_malloc$5=malloc(res_size + (unsigned long int)1);
                  res_ptr = (char *)return_value_malloc$5;
                }

                else
                {
                  res_size = res_size + l1 + (unsigned long int)1 + l2 + (unsigned long int)1;
                  void *return_value_realloc$6;
                  return_value_realloc$6=realloc((void *)res_ptr, res_size + (unsigned long int)1);
                  res_ptr = (char *)return_value_realloc$6;
                }
                if(res_ptr == ((char *)NULL))
                {
                  res_size = (unsigned long int)0;
                  free((void *)old_res_ptr);
                  break;
                }

                strcpy(((res_ptr + (signed long int)res_size) - (signed long int)(l2 + (unsigned long int)1)) - (signed long int)(l1 + (unsigned long int)1), buf1);
                strcpy((res_ptr + (signed long int)res_size) - (signed long int)(l2 + (unsigned long int)1), buf2);
              }
            }

          }
          while((_Bool)1);
          fclose(fp);
          if(res_size == 0ul)
            cp = "";

          else
          {
            res_ptr[(signed long int)res_size] = (char)0;
            cp = res_ptr;
          }
        }
      }
      free((void *)file_name);
    }
    charset_aliases = cp;
  }

  return cp;
}

// get_charset_aliases$link1
// file localcharset.c line 123
static const char * get_charset_aliases$link1(void)
{
  const char *cp$link1 = charset_aliases$link1;
  _Bool tmp_if_expr$1$link1;
  _Bool tmp_if_expr$2$link1;
  if(cp$link1 == ((const char *)NULL))
  {
    const char *dir$link1;
    const char *base$link1 = "charset.alias";
    char *file_name$link1;
    dir$link1=getenv("CHARSETALIASDIR");
    if(dir$link1 == ((const char *)NULL))
      tmp_if_expr$1$link1 = (_Bool)1;

    else
      tmp_if_expr$1$link1 = (signed int)dir$link1[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1$link1)
      dir$link1 = "/usr/lib/x86_64-linux-gnu";

    unsigned long int dir_len$link1;
    dir_len$link1=strlen(dir$link1);
    unsigned long int base_len$link1;
    base_len$link1=strlen(base$link1);
    signed int add_slash$link1;
    if(dir_len$link1 >= 1ul)
      tmp_if_expr$2$link1 = !((signed int)dir$link1[(signed long int)(dir_len$link1 - (unsigned long int)1)] == 47) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2$link1 = (_Bool)0;
    add_slash$link1 = (signed int)tmp_if_expr$2$link1;
    void *return_value_malloc$3$link1;
    return_value_malloc$3$link1=malloc(dir_len$link1 + (unsigned long int)add_slash$link1 + base_len$link1 + (unsigned long int)1);
    file_name$link1 = (char *)return_value_malloc$3$link1;
    if(!(file_name$link1 == ((char *)NULL)))
    {
      memcpy((void *)file_name$link1, (const void *)dir$link1, dir_len$link1);
      if(!(add_slash$link1 == 0))
        file_name$link1[(signed long int)dir_len$link1] = (char)47;

      memcpy((void *)(file_name$link1 + (signed long int)dir_len$link1 + (signed long int)add_slash$link1), (const void *)base$link1, base_len$link1 + (unsigned long int)1);
    }

    if(file_name$link1 == ((char *)NULL))
      cp$link1 = "";

    else
    {
      signed int fd$link1;
      fd$link1=open(file_name$link1, 00 | (1 != 0 ? 0400000 : 0));
      if(!(fd$link1 >= 0))
        cp$link1 = "";

      else
      {
        struct _IO_FILE *fp$link1;
        fp$link1=fdopen(fd$link1, "r");
        if(fp$link1 == ((struct _IO_FILE *)NULL))
        {
          close(fd$link1);
          cp$link1 = "";
        }

        else
        {
          char *res_ptr$link1 = (char *)(void *)0;
          unsigned long int res_size$link1 = (unsigned long int)0;
          do
          {
            signed int c$link1;
            char buf1$link1[51l];
            char buf2$link1[51l];
            unsigned long int l1$link1;
            unsigned long int l2$link1;
            char *old_res_ptr$link1;
            c$link1=getc_unlocked(fp$link1);
            if(c$link1 == -1)
              break;

            if(!(c$link1 == 9) && !(c$link1 == 10) && !(c$link1 == 32))
            {
              if(c$link1 == 35)
              {
                do
                  c$link1=getc_unlocked(fp$link1);
                while(!(c$link1 == 10) && !(c$link1 == -1));
                if(c$link1 == -1)
                  break;

              }

              else
              {
                ungetc(c$link1, fp$link1);
                signed int return_value_fscanf$4$link1;
                return_value_fscanf$4$link1=fscanf(fp$link1, "%50s %50s", (const void *)buf1$link1, (const void *)buf2$link1);
                if(!(return_value_fscanf$4$link1 >= 2))
                  break;

                l1$link1=strlen(buf1$link1);
                l2$link1=strlen(buf2$link1);
                old_res_ptr$link1 = res_ptr$link1;
                if(res_size$link1 == 0ul)
                {
                  res_size$link1 = l1$link1 + (unsigned long int)1 + l2$link1 + (unsigned long int)1;
                  void *return_value_malloc$5$link1;
                  return_value_malloc$5$link1=malloc(res_size$link1 + (unsigned long int)1);
                  res_ptr$link1 = (char *)return_value_malloc$5$link1;
                }

                else
                {
                  res_size$link1 = res_size$link1 + l1$link1 + (unsigned long int)1 + l2$link1 + (unsigned long int)1;
                  void *return_value_realloc$6$link1;
                  return_value_realloc$6$link1=realloc((void *)res_ptr$link1, res_size$link1 + (unsigned long int)1);
                  res_ptr$link1 = (char *)return_value_realloc$6$link1;
                }
                if(res_ptr$link1 == ((char *)NULL))
                {
                  res_size$link1 = (unsigned long int)0;
                  free((void *)old_res_ptr$link1);
                  break;
                }

                strcpy(((res_ptr$link1 + (signed long int)res_size$link1) - (signed long int)(l2$link1 + (unsigned long int)1)) - (signed long int)(l1$link1 + (unsigned long int)1), buf1$link1);
                strcpy((res_ptr$link1 + (signed long int)res_size$link1) - (signed long int)(l2$link1 + (unsigned long int)1), buf2$link1);
              }
            }

          }
          while((_Bool)1);
          fclose(fp$link1);
          if(res_size$link1 == 0ul)
            cp$link1 = "";

          else
          {
            res_ptr$link1[(signed long int)res_size$link1] = (char)0;
            cp$link1 = res_ptr$link1;
          }
        }
      }
      free((void *)file_name$link1);
    }
    charset_aliases$link1 = cp$link1;
  }

  return cp$link1;
}

// get_conf_setting
// file opendev.c line 85
static const char * get_conf_setting(struct conf *cf, const char *name, const char *defvalue)
{
  signed int i;
  const char *val;
  i = 2;
  for( ; i >= 0; i = i - 1)
  {
    val=egdi_get_setting_value(&cf->config[(signed long int)i], name);
    if(!(val == ((const char *)NULL)))
      return val;

  }
  return defvalue;
}

// get_field_info
// file core.c line 214
static signed int get_field_info(struct egd_chinfo *info, signed int field, void *arg)
{
  double tmp_if_expr$2;
  double tmp_if_expr$1;
  double tmp_if_expr$4;
  double tmp_if_expr$3;
  double tmp_if_expr$6;
  double tmp_if_expr$5;
  double tmp_if_expr$8;
  double tmp_if_expr$7;
  double tmp_if_expr$10;
  double tmp_if_expr$9;
  double tmp_if_expr$12;
  double tmp_if_expr$11;
  if(field == 1)
    safe_strncpy((char *)arg, info->label, (unsigned long int)32);

  else
    if(field == 5)
      *((signed int *)arg) = (signed int)info->isint;

    else
      if(field == 2)
      {
        if(info->dtype == 0)
          tmp_if_expr$2 = (double)info->min.valint32_t;

        else
        {
          if(info->dtype == 1)
            tmp_if_expr$1 = (double)info->min.valfloat;

          else
            tmp_if_expr$1 = info->min.valdouble;
          tmp_if_expr$2 = tmp_if_expr$1;
        }
        *((signed int *)arg) = (signed int)tmp_if_expr$2;
        if(info->dtype == 0)
          tmp_if_expr$4 = (double)info->max.valint32_t;

        else
        {
          if(info->dtype == 1)
            tmp_if_expr$3 = (double)info->max.valfloat;

          else
            tmp_if_expr$3 = info->max.valdouble;
          tmp_if_expr$4 = tmp_if_expr$3;
        }
        ((signed int *)arg)[(signed long int)1] = (signed int)tmp_if_expr$4;
      }

      else
        if(field == 3)
        {
          if(info->dtype == 0)
            tmp_if_expr$6 = (double)info->min.valint32_t;

          else
          {
            if(info->dtype == 1)
              tmp_if_expr$5 = (double)info->min.valfloat;

            else
              tmp_if_expr$5 = info->min.valdouble;
            tmp_if_expr$6 = tmp_if_expr$5;
          }
          *((float *)arg) = (float)tmp_if_expr$6;
          if(info->dtype == 0)
            tmp_if_expr$8 = (double)info->max.valint32_t;

          else
          {
            if(info->dtype == 1)
              tmp_if_expr$7 = (double)info->max.valfloat;

            else
              tmp_if_expr$7 = info->max.valdouble;
            tmp_if_expr$8 = tmp_if_expr$7;
          }
          ((float *)arg)[(signed long int)1] = (float)tmp_if_expr$8;
        }

        else
          if(field == 4)
          {
            if(info->dtype == 0)
              tmp_if_expr$10 = (double)info->min.valint32_t;

            else
            {
              if(info->dtype == 1)
                tmp_if_expr$9 = (double)info->min.valfloat;

              else
                tmp_if_expr$9 = info->min.valdouble;
              tmp_if_expr$10 = tmp_if_expr$9;
            }
            *((double *)arg) = tmp_if_expr$10;
            if(info->dtype == 0)
              tmp_if_expr$12 = (double)info->max.valint32_t;

            else
            {
              if(info->dtype == 1)
                tmp_if_expr$11 = (double)info->max.valfloat;

              else
                tmp_if_expr$11 = info->max.valdouble;
              tmp_if_expr$12 = tmp_if_expr$11;
            }
            ((double *)arg)[(signed long int)1] = tmp_if_expr$12;
          }

          else
            if(field == 6)
              safe_strncpy((char *)arg, info->unit, (unsigned long int)16);

            else
              if(field == 7)
                safe_strncpy((char *)arg, info->transducter, (unsigned long int)128);

              else
                if(field == 8)
                  safe_strncpy((char *)arg, info->prefiltering, (unsigned long int)128);

  return 0;
}

// get_trigger_val
// file fakelibs/tia-server.h line 28
static inline signed int get_trigger_val(unsigned long int sam, unsigned int ich)
{
  return (signed int)((unsigned long int)(ich + (unsigned int)1) * (sam % (unsigned long int)113));
}

// get_trigger_val$link1
// file tia-server.h line 28
static inline signed int get_trigger_val$link1(unsigned long int sam$link1, unsigned int ich$link1)
{
  return (signed int)((unsigned long int)(ich$link1 + (unsigned int)1) * (sam$link1 % (unsigned long int)113));
}

// gl_sockets_cleanup
// file sockets.c line 139
signed int gl_sockets_cleanup(void)
{
  return 0;
}

// gl_sockets_startup
// file sockets.c line 112
signed int gl_sockets_startup(signed int version)
{
  return 0;
}

// glthread_once_singlethreaded
// file glthread/lock.c line 457
extern signed int glthread_once_singlethreaded(signed int *once_control)
{
  char *firstbyte = (char *)once_control;
  if(*firstbyte == *((const char *)&fresh_once))
  {
    *firstbyte = (char)~((signed int)*((const char *)&fresh_once));
    return 1;
  }

  else
    return 0;
}

// glthread_recursive_lock_init_multithreaded
// file glthread/lock.c line 284
extern signed int glthread_recursive_lock_init_multithreaded(union anonymous$0 *lock)
{
  union anonymous$6 attributes;
  signed int err;
  err=pthread_mutexattr_init(&attributes);
  if(!(err == 0))
    return err;

  else
  {
    err=pthread_mutexattr_settype(&attributes, 1);
    if(!(err == 0))
    {
      pthread_mutexattr_destroy(&attributes);
      return err;
    }

    else
    {
      err=pthread_mutex_init(lock, &attributes);
      if(!(err == 0))
      {
        pthread_mutexattr_destroy(&attributes);
        return err;
      }

      else
      {
        err=pthread_mutexattr_destroy(&attributes);
        if(!(err == 0))
          return err;

        else
          return 0;
      }
    }
  }
}

// identity
// file typecast.c line 77
static void identity(void * restrict d, const void * restrict s, union gval sc, unsigned long int len)
{
  (void)sc;
  memcpy(d, s, len);
}

// init_configuration
// file opendev.c line 43
static signed int init_configuration(struct conf *cf, const char *str)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= 3u); i = i + 1u)
    egdi_init_config(&cf->config[(signed long int)i]);
  cf->confpath=getenv("EEGDEV_CONF_DIR");
  if(cf->confpath == ((const char *)NULL))
    cf->confpath = default_confpath;

  signed int return_value_egdi_parse_confline$1;
  return_value_egdi_parse_confline$1=egdi_parse_confline(&cf->config[(signed long int)2], str);
  return return_value_egdi_parse_confline$1;
}

// load_configuration_file
// file opendev.c line 72
static signed int load_configuration_file(struct conf *cf, const char *file, signed int global)
{
  unsigned long int pathlen;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(cf->confpath);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(file);
  pathlen = return_value_strlen$1 + return_value_strlen$2 + (unsigned long int)2;
  signed int index = global != 0 ? 0 : 1;
  const signed long int index$array_size0 = (signed long int)pathlen;
  char filepath[index$array_size0];
  sprintf(filepath, "%s/%s", cf->confpath, file);
  egdi_reinit_config(&cf->config[(signed long int)index]);
  signed int return_value_egdi_parse_conffile$3;
  return_value_egdi_parse_conffile$3=egdi_parse_conffile(&cf->config[(signed long int)index], filepath);
  return return_value_egdi_parse_conffile$3;
}

// locale_charset
// file localcharset.c line 362
extern const char * locale_charset(void)
{
  const char *codeset;
  const char *aliases;
  codeset=nl_langinfo(14);
  if(codeset == ((const char *)NULL))
    codeset = "";

  aliases=get_charset_aliases();
  signed int return_value_strcmp$4;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  unsigned long int return_value_strlen$1;
  unsigned long int return_value_strlen$2;
  for( ; !((signed int)*aliases == 0); aliases = aliases + (signed long int)(return_value_strlen$2 + (unsigned long int)1))
  {
    return_value_strcmp$4=strcmp(codeset, aliases);
    if(return_value_strcmp$4 == 0)
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      if((signed int)*aliases == 42)
        tmp_if_expr$5 = (signed int)aliases[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
    {
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(aliases);
      codeset = aliases + (signed long int)return_value_strlen$3 + (signed long int)1;
      break;
    }

    return_value_strlen$1=strlen(aliases);
    aliases = aliases + (signed long int)(return_value_strlen$1 + (unsigned long int)1);
    return_value_strlen$2=strlen(aliases);
  }
  if((signed int)*codeset == 0)
    codeset = "ASCII";

  return codeset;
}

// main
// file systobiia.c line 241
signed int main(signed int argc, char **argv)
{
  signed int opt;
  signed int retcode = 0;
  signed int bsigcheck = 0;
  do
  {
    opt=getopt(argc, argv, "c:v:s:");
    if(opt == -1)
      break;

    switch(opt)
    {
      case 99:
      {
        bsigcheck=atoi(optarg);
        break;
      }
      case 115:
      {
        devhost = optarg;
        break;
      }
      case 118:
      {
        verbose=atoi(optarg);
        break;
      }
      default:
      {
        fprintf(stderr, "Usage: %s [-c checking_expected_signals] [-s server] [-v verbosity]\n", argv[(signed long int)0]);
        return 1;
      }
    }
  }
  while((_Bool)1);
  printf("\tTesting tobiia\n");
  signed int return_value_create_tia_server$4;
  if(!(bsigcheck == 0))
  {
    return_value_create_tia_server$4=create_tia_server((unsigned short int)38500);
    if(!(return_value_create_tia_server$4 == 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      fprintf(stderr, "server creation failed: (%i) %s\n", *return_value___errno_location$1, return_value_strerror$3);
      return 1;
    }

  }

  retcode=read_eegsignal(bsigcheck);
  if(!(bsigcheck == 0))
    destroy_tia_server();

  return retcode;
}

// noaction
// file core.c line 242
static signed int noaction(struct devmodule *dev)
{
  (void)dev;
  return 0;
}

// open_any
// file opendev.c line 188
static struct eegdev * open_any(struct conf *cf)
{
  signed int i;
  struct eegdev *dev = (struct eegdev *)(void *)0;
  i = 0;
  for( ; !(prefered_devices[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    dev=open_plugin_device(prefered_devices[(signed long int)i], cf);
    if(!(dev == ((struct eegdev *)NULL)))
      break;

  }
  signed int *return_value___errno_location$1;
  if(dev == ((struct eegdev *)NULL))
  {
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 19;
  }

  return dev;
}

// open_device
// file systobiia.c line 121
static struct eegdev * open_device(struct grpconf *group)
{
  struct eegdev *dev;
  signed int i;
  char devstring[256l] = { 't', 'o', 'b', 'i', 'i', 'a', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  const char * const sname[3l] = { "eeg", "undefined", "trigger" };
  unsigned long int return_value_strlen$1;
  if(!(devhost == ((const char *)NULL)))
  {
    return_value_strlen$1=strlen(devstring);
    sprintf(devstring + (signed long int)return_value_strlen$1, "|host|%s", devhost);
  }

  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(devstring);
  sprintf(devstring + (signed long int)return_value_strlen$2, "|port|%i", 38500);
  dev=egd_open(devstring);
  if(dev == ((struct eegdev *)NULL))
    return (struct eegdev *)(void *)0;

  else
  {
    i = 0;
    for( ; !(i >= 3); i = i + 1)
    {
      (group + (signed long int)i)->sensortype=egd_sensor_type(sname[(signed long int)i]);
      signed int return_value_egd_get_numch$3;
      return_value_egd_get_numch$3=egd_get_numch(dev, (group + (signed long int)i)->sensortype);
      (group + (signed long int)i)->nch = (unsigned int)return_value_egd_get_numch$3;
    }
    return dev;
  }
}

// open_init_device
// file opendev.c line 112
static struct eegdev * open_init_device(struct egdi_plugin_info *info, unsigned int nopt, struct conf *cf)
{
  struct eegdev *dev;
  unsigned int i;
  const signed long int i$array_size0 = (signed long int)(nopt + (unsigned int)1);
  const char *optval[i$array_size0];
  const char *name;
  const char *defvalue;
  i = (unsigned int)0;
  for( ; !(i >= nopt); i = i + 1u)
  {
    name = (info->supported_opts + (signed long int)i)->name;
    defvalue = (info->supported_opts + (signed long int)i)->defvalue;
    optval[(signed long int)i]=get_conf_setting(cf, name, defvalue);
  }
  optval[(signed long int)nopt] = (const char *)(void *)0;
  dev=egdi_create_eegdev(info);
  _Bool tmp_if_expr$1;
  signed int return_value;
  if(dev == ((struct eegdev *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
  {
    return_value=info->open_device(&dev->module, optval);
    tmp_if_expr$1 = return_value != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$1)
  {
    egd_destroy_eegdev(dev);
    return (struct eegdev *)(void *)0;
  }

  else
  {
    egd_update_capabilities(dev);
    return dev;
  }
}

// open_plugin_device
// file opendev.c line 141
static struct eegdev * open_plugin_device(const char *dname, struct conf *cf)
{
  struct eegdev *dev = (struct eegdev *)(void *)0;
  void *handle;
  struct egdi_plugin_info *info;
  const char *dir;
  dir=getenv("EEGDEV_PLUGINS_DIR");
  char path[128l];
  char confname[64l];
  unsigned int nopt;
  snprintf(path, sizeof(char [128l]) /*128ul*/ , "%s/%s.so", dir != ((const char *)NULL) ? dir : "/usr/lib/x86_64-linux-gnu/eegdev", dname);
  handle=dlopen(path, 0x00001 | 0);
  _Bool tmp_if_expr$3;
  void *return_value_dlsym$2;
  if(handle == NULL)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_dlsym$2=dlsym(handle, "eegdev_plugin_info");
    info = (struct egdi_plugin_info *)return_value_dlsym$2;
    tmp_if_expr$3 = !(info != ((struct egdi_plugin_info *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = info->plugin_abi != (unsigned int)5 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$4)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 38;
    goto fail;
  }

  nopt = (unsigned int)0;
  if(!(info->supported_opts == ((struct egdi_optname *)NULL)))
    for( ; !((info->supported_opts + (signed long int)nopt)->name == ((const char *)NULL)); nopt = nopt + 1u)
      ;

  snprintf(confname, sizeof(char [64l]) /*64ul*/ , "%s.conf", dname);
  signed int return_value_load_configuration_file$5;
  return_value_load_configuration_file$5=load_configuration_file(cf, confname, 0);
  if(return_value_load_configuration_file$5 == 0)
  {
    dev=open_init_device(info, nopt, cf);
    if(dev == ((struct eegdev *)NULL))
      goto fail;

    dev->handle = handle;
    return dev;
  }

  else
  {

  fail:
    ;
    if(!(handle == NULL))
      dlclose(handle);

    return (struct eegdev *)(void *)0;
  }
}

// optimize_inbufgrp
// file core.c line 46
static void optimize_inbufgrp(struct input_buffer_group *ibgrp, unsigned int *ngrp)
{
  unsigned int i;
  unsigned int j;
  unsigned int num = *ngrp;
  i = (unsigned int)0;
  for( ; !(i >= num); i = i + 1u)
  {
    j = i + (unsigned int)1;
    for( ; !(j >= num); j = j + 1u)
      if((ibgrp + (signed long int)j)->in_offset == (ibgrp + (signed long int)i)->in_offset + (ibgrp + (signed long int)i)->inlen)
      {
        if((ibgrp + (signed long int)j)->buff_offset == (ibgrp + (signed long int)i)->buff_offset + (ibgrp + (signed long int)i)->inlen)
        {
          if(IEEE_FLOAT_EQUAL((ibgrp + (signed long int)j)->sc.valdouble, (ibgrp + (signed long int)i)->sc.valdouble))
          {
            if((ibgrp + (signed long int)j)->cast_fn == (ibgrp + (signed long int)i)->cast_fn)
            {
              (ibgrp + (signed long int)i)->inlen = (ibgrp + (signed long int)i)->inlen + (ibgrp + (signed long int)j)->inlen;
              memmove((void *)(ibgrp + (signed long int)j), (const void *)(ibgrp + (signed long int)j + (signed long int)1), (unsigned long int)((num - j) - (unsigned int)1) * sizeof(struct input_buffer_group) /*40ul*/ );
              num = num - 1u;
              j = j - 1u;
            }

          }

        }

      }

  }
  *ngrp = num;
}

// print_cap
// file systobiia.c line 144
static signed int print_cap(struct eegdev *dev)
{
  unsigned int sampling_freq;
  unsigned int eeg_nmax;
  unsigned int sensor_nmax;
  unsigned int trigger_nmax;
  char *device_type;
  char *device_id;
  signed int retval;
  egd_get_cap(dev, 2, (void *)&device_type);
  egd_get_cap(dev, 2, (void *)&device_id);
  egd_get_cap(dev, 0, (void *)&sampling_freq);
  signed int return_value_egd_sensor_type$1;
  return_value_egd_sensor_type$1=egd_sensor_type("eeg");
  signed int return_value_egd_get_numch$2;
  return_value_egd_get_numch$2=egd_get_numch(dev, return_value_egd_sensor_type$1);
  eeg_nmax = (unsigned int)return_value_egd_get_numch$2;
  signed int return_value_egd_sensor_type$3;
  return_value_egd_sensor_type$3=egd_sensor_type("undefined");
  signed int return_value_egd_get_numch$4;
  return_value_egd_get_numch$4=egd_get_numch(dev, return_value_egd_sensor_type$3);
  sensor_nmax = (unsigned int)return_value_egd_get_numch$4;
  signed int return_value_egd_sensor_type$5;
  return_value_egd_sensor_type$5=egd_sensor_type("trigger");
  signed int return_value_egd_get_numch$6;
  return_value_egd_get_numch$6=egd_get_numch(dev, return_value_egd_sensor_type$5);
  trigger_nmax = (unsigned int)return_value_egd_get_numch$6;
  retval = (signed int)sampling_freq;
  if(verbose == 0)
    return retval;

  else
  {
    printf("\tsystem capabilities:\n\t\tdevice type: %s\n\t\tdevice model: %s\n\t\tsampling frequency: %u Hz\n\t\tnum EEG channels: %u\n\t\tnum sensor channels: %u\n\t\tnum trigger channels: %u\n", device_type, device_type, sampling_freq, eeg_nmax, sensor_nmax, trigger_nmax);
    return retval;
  }
}

// printf_fetchargs
// file printf-args.c line 36
extern signed int printf_fetchargs(__builtin_va_list args, struct anonymous$1 *a)
{
  unsigned long int i;
  struct anonymous$2 *ap;
  i = (unsigned long int)0;
  ap = &a->arg[(signed long int)0];
  signed int return_value_gcc_builtin_va_arg$1;
  signed int return_value_gcc_builtin_va_arg$2;
  signed int return_value_gcc_builtin_va_arg$3;
  signed int return_value_gcc_builtin_va_arg$4;
  unsigned int return_value_gcc_builtin_va_arg$5;
  for( ; !(i >= a->count); ap = ap + 1l)
  {
    switch((signed int)ap->type)
    {
      case TYPE_SCHAR:
      {
        return_value_gcc_builtin_va_arg$1=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$1));
        ap->a.a_schar = (signed char)return_value_gcc_builtin_va_arg$1;
        break;
      }
      case TYPE_UCHAR:
      {
        return_value_gcc_builtin_va_arg$2=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$2));
        ap->a.a_uchar = (unsigned char)return_value_gcc_builtin_va_arg$2;
        break;
      }
      case TYPE_SHORT:
      {
        return_value_gcc_builtin_va_arg$3=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$3));
        ap->a.a_short = (signed short int)return_value_gcc_builtin_va_arg$3;
        break;
      }
      case TYPE_USHORT:
      {
        return_value_gcc_builtin_va_arg$4=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$4));
        ap->a.a_ushort = (unsigned short int)return_value_gcc_builtin_va_arg$4;
        break;
      }
      case TYPE_INT:
      {
        ap->a.a_int=va_arg(args, __typeof__(ap->a.a_int));
        break;
      }
      case TYPE_UINT:
      {
        ap->a.a_uint=va_arg(args, __typeof__(ap->a.a_uint));
        break;
      }
      case TYPE_LONGINT:
      {
        ap->a.a_longint=va_arg(args, __typeof__(ap->a.a_longint));
        break;
      }
      case TYPE_ULONGINT:
      {
        ap->a.a_ulongint=va_arg(args, __typeof__(ap->a.a_ulongint));
        break;
      }
      case TYPE_LONGLONGINT:
      {
        ap->a.a_longlongint=va_arg(args, __typeof__(ap->a.a_longlongint));
        break;
      }
      case TYPE_ULONGLONGINT:
      {
        ap->a.a_ulonglongint=va_arg(args, __typeof__(ap->a.a_ulonglongint));
        break;
      }
      case TYPE_DOUBLE:
      {
        ap->a.a_double=va_arg(args, __typeof__(ap->a.a_double));
        break;
      }
      case TYPE_LONGDOUBLE:
      {
        ap->a.a_longdouble=va_arg(args, __typeof__(ap->a.a_longdouble));
        break;
      }
      case TYPE_CHAR:
      {
        ap->a.a_char=va_arg(args, __typeof__(ap->a.a_char));
        break;
      }
      case TYPE_WIDE_CHAR:
      {
        return_value_gcc_builtin_va_arg$5=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$5));
        ap->a.a_wide_char = return_value_gcc_builtin_va_arg$5;
        break;
      }
      case TYPE_STRING:
      {
        ap->a.a_string=va_arg(args, __typeof__(ap->a.a_string));
        if(ap->a.a_string == ((const char *)NULL))
          ap->a.a_string = "(NULL)";

        break;
      }
      case TYPE_WIDE_STRING:
      {
        ap->a.a_wide_string=va_arg(args, __typeof__(ap->a.a_wide_string));
        static const signed int wide_null_string[7l] = { (signed int)40, (signed int)78, (signed int)85, (signed int)76, (signed int)76, (signed int)41, (signed int)0 };
        if(ap->a.a_wide_string == ((const signed int *)NULL))
          ap->a.a_wide_string = wide_null_string;

        break;
      }
      case TYPE_POINTER:
      {
        ap->a.a_pointer=va_arg(args, __typeof__(ap->a.a_pointer));
        break;
      }
      case TYPE_COUNT_SCHAR_POINTER:
      {
        ap->a.a_count_schar_pointer=va_arg(args, __typeof__(ap->a.a_count_schar_pointer));
        break;
      }
      case TYPE_COUNT_SHORT_POINTER:
      {
        ap->a.a_count_short_pointer=va_arg(args, __typeof__(ap->a.a_count_short_pointer));
        break;
      }
      case TYPE_COUNT_INT_POINTER:
      {
        ap->a.a_count_int_pointer=va_arg(args, __typeof__(ap->a.a_count_int_pointer));
        break;
      }
      case TYPE_COUNT_LONGINT_POINTER:
      {
        ap->a.a_count_longint_pointer=va_arg(args, __typeof__(ap->a.a_count_longint_pointer));
        break;
      }
      case TYPE_COUNT_LONGLONGINT_POINTER:
      {
        ap->a.a_count_longlongint_pointer=va_arg(args, __typeof__(ap->a.a_count_longlongint_pointer));
        break;
      }
      default:
        return -1;
    }
    i = i + 1ul;
  }
  return 0;
}

// printf_parse
// file printf-parse.c line 83
extern signed int printf_parse(const char *format, struct anonymous$5 *d, struct anonymous$1 *a)
{
  const char *cp = format;
  unsigned long int arg_posn = (unsigned long int)0;
  unsigned long int d_allocated;
  unsigned long int a_allocated;
  unsigned long int max_width_length = (unsigned long int)0;
  unsigned long int max_precision_length = (unsigned long int)0;
  d->count = (unsigned long int)0;
  d_allocated = (unsigned long int)7;
  d->dir = d->direct_alloc_dir;
  a->count = (unsigned long int)0;
  a_allocated = (unsigned long int)7;
  a->arg = a->direct_alloc_arg;
  const char *tmp_post$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  unsigned long int tmp_post$6;
  void *tmp_if_expr$9;
  void *return_value_realloc$7;
  void *return_value_malloc$8;
  unsigned long int tmp_post$10;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$13;
  unsigned long int tmp_post$14;
  void *tmp_if_expr$17;
  void *return_value_realloc$15;
  void *return_value_malloc$16;
  unsigned long int tmp_post$18;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$20;
  const char *tmp_post$21;
  unsigned long int tmp_post$22;
  void *tmp_if_expr$25;
  void *return_value_realloc$23;
  void *return_value_malloc$24;
  unsigned long int tmp_post$26;
  void *tmp_if_expr$29;
  void *return_value_realloc$27;
  void *return_value_malloc$28;
  while(!((signed int)*cp == 0))
  {
    char c;
    tmp_post$1 = cp;
    cp = cp + 1l;
    c = *tmp_post$1;
    if((signed int)c == 37)
    {
      unsigned long int arg_index = ~((unsigned long int)0);
      struct anonymous *dp = &d->dir[(signed long int)d->count];
      dp->dir_start = cp - (signed long int)1;
      dp->flags = 0;
      dp->width_start = (const char *)(void *)0;
      dp->width_end = (const char *)(void *)0;
      dp->width_arg_index = ~((unsigned long int)0);
      dp->precision_start = (const char *)(void *)0;
      dp->precision_end = (const char *)(void *)0;
      dp->precision_arg_index = ~((unsigned long int)0);
      dp->arg_index = ~((unsigned long int)0);
      if((signed int)*cp >= 48)
      {
        if(!((signed int)*cp >= 58))
        {
          const char *printf_parse$$1$$1$$1$$1$$np = cp;
          do
          {
            if((signed int)*printf_parse$$1$$1$$1$$1$$np >= 48)
              tmp_if_expr$2 = (signed int)*printf_parse$$1$$1$$1$$1$$np <= 57 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$2 = (_Bool)0;
            if(!tmp_if_expr$2)
              break;

            printf_parse$$1$$1$$1$$1$$np = printf_parse$$1$$1$$1$$1$$np + 1l;
          }
          while((_Bool)1);
          if((signed int)*printf_parse$$1$$1$$1$$1$$np == 36)
          {
            unsigned long int printf_parse$$1$$1$$1$$1$$2$$n = (unsigned long int)0;
            printf_parse$$1$$1$$1$$1$$np = cp;
            do
            {
              if((signed int)*printf_parse$$1$$1$$1$$1$$np >= 48)
                tmp_if_expr$3 = (signed int)*printf_parse$$1$$1$$1$$1$$np <= 57 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$3 = (_Bool)0;
              if(!tmp_if_expr$3)
                break;

              printf_parse$$1$$1$$1$$1$$2$$n=xsum(printf_parse$$1$$1$$1$$1$$2$$n <= 18446744073709551615UL / (unsigned long int)10 ? (unsigned long int)printf_parse$$1$$1$$1$$1$$2$$n * (unsigned long int)10 : 18446744073709551615UL, (unsigned long int)((signed int)*printf_parse$$1$$1$$1$$1$$np - 48));
              printf_parse$$1$$1$$1$$1$$np = printf_parse$$1$$1$$1$$1$$np + 1l;
            }
            while((_Bool)1);
            if(printf_parse$$1$$1$$1$$1$$2$$n == 0ul)
              goto error;

            if(printf_parse$$1$$1$$1$$1$$2$$n == 18446744073709551615UL)
              goto error;

            arg_index = printf_parse$$1$$1$$1$$1$$2$$n - (unsigned long int)1;
            cp = printf_parse$$1$$1$$1$$1$$np + (signed long int)1;
          }

        }

      }

      while((_Bool)1)
        if((signed int)*cp == 39)
        {
          dp->flags = dp->flags | 1;
          cp = cp + 1l;
        }

        else
          if((signed int)*cp == 45)
          {
            dp->flags = dp->flags | 2;
            cp = cp + 1l;
          }

          else
            if((signed int)*cp == 43)
            {
              dp->flags = dp->flags | 4;
              cp = cp + 1l;
            }

            else
              if((signed int)*cp == 32)
              {
                dp->flags = dp->flags | 8;
                cp = cp + 1l;
              }

              else
                if((signed int)*cp == 35)
                {
                  dp->flags = dp->flags | 16;
                  cp = cp + 1l;
                }

                else
                  if((signed int)*cp == 48)
                  {
                    dp->flags = dp->flags | 32;
                    cp = cp + 1l;
                  }

                  else
                    if((signed int)*cp == 73)
                    {
                      dp->flags = dp->flags | 64;
                      cp = cp + 1l;
                    }

                    else
                      goto __CPROVER_DUMP_L20;

    __CPROVER_DUMP_L20:
      ;
      if((signed int)*cp == 42)
      {
        dp->width_start = cp;
        cp = cp + 1l;
        dp->width_end = cp;
        if(!(max_width_length >= 1ul))
          max_width_length = (unsigned long int)1;

        if((signed int)*cp >= 48)
        {
          if(!((signed int)*cp >= 58))
          {
            const char *np = cp;
            do
            {
              if((signed int)*np >= 48)
                tmp_if_expr$4 = (signed int)*np <= 57 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$4 = (_Bool)0;
              if(!tmp_if_expr$4)
                break;

              np = np + 1l;
            }
            while((_Bool)1);
            if((signed int)*np == 36)
            {
              unsigned long int n = (unsigned long int)0;
              np = cp;
              do
              {
                if((signed int)*np >= 48)
                  tmp_if_expr$5 = (signed int)*np <= 57 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$5 = (_Bool)0;
                if(!tmp_if_expr$5)
                  break;

                n=xsum(n <= 18446744073709551615UL / (unsigned long int)10 ? (unsigned long int)n * (unsigned long int)10 : 18446744073709551615UL, (unsigned long int)((signed int)*np - 48));
                np = np + 1l;
              }
              while((_Bool)1);
              if(n == 0ul)
                goto error;

              if(n == 18446744073709551615UL)
                goto error;

              dp->width_arg_index = n - (unsigned long int)1;
              cp = np + (signed long int)1;
            }

          }

        }

        if(dp->width_arg_index == 18446744073709551615ul)
        {
          tmp_post$6 = arg_posn;
          arg_posn = arg_posn + 1ul;
          dp->width_arg_index = tmp_post$6;
          if(dp->width_arg_index == 18446744073709551615ul)
            goto error;

        }

        unsigned long int printf_parse$$1$$1$$1$$3$$3$$n = dp->width_arg_index;
        if(printf_parse$$1$$1$$1$$3$$3$$n >= a_allocated)
        {
          unsigned long int printf_parse$$1$$1$$1$$3$$3$$1$$memory_size;
          struct anonymous$2 *printf_parse$$1$$1$$1$$3$$3$$1$$memory;
          a_allocated = a_allocated <= 18446744073709551615UL / (unsigned long int)2 ? (unsigned long int)a_allocated * (unsigned long int)2 : 18446744073709551615UL;
          if(printf_parse$$1$$1$$1$$3$$3$$n >= a_allocated)
            a_allocated=xsum(printf_parse$$1$$1$$1$$3$$3$$n, (unsigned long int)1);

          printf_parse$$1$$1$$1$$3$$3$$1$$memory_size = a_allocated <= 18446744073709551615UL / sizeof(struct anonymous$2) /*32ul*/  ? (unsigned long int)a_allocated * sizeof(struct anonymous$2) /*32ul*/  : 18446744073709551615UL;
          if(printf_parse$$1$$1$$1$$3$$3$$1$$memory_size == 18446744073709551615UL)
            goto out_of_memory;

          if(!(a->arg == a->direct_alloc_arg))
          {
            return_value_realloc$7=realloc((void *)a->arg, printf_parse$$1$$1$$1$$3$$3$$1$$memory_size);
            tmp_if_expr$9 = return_value_realloc$7;
          }

          else
          {
            return_value_malloc$8=malloc(printf_parse$$1$$1$$1$$3$$3$$1$$memory_size);
            tmp_if_expr$9 = return_value_malloc$8;
          }
          printf_parse$$1$$1$$1$$3$$3$$1$$memory = (struct anonymous$2 *)tmp_if_expr$9;
          if(printf_parse$$1$$1$$1$$3$$3$$1$$memory == ((struct anonymous$2 *)NULL))
            goto out_of_memory;

          if(a->arg == a->direct_alloc_arg)
            memcpy((void *)printf_parse$$1$$1$$1$$3$$3$$1$$memory, (const void *)a->arg, a->count * sizeof(struct anonymous$2) /*32ul*/ );

          a->arg = printf_parse$$1$$1$$1$$3$$3$$1$$memory;
        }

        for( ; printf_parse$$1$$1$$1$$3$$3$$n >= a->count; (a->arg + (signed long int)tmp_post$10)->type = (enum anonymous$4)TYPE_NONE)
        {
          tmp_post$10 = a->count;
          a->count = a->count + 1ul;
        }
        if((signed int)(a->arg + (signed long int)printf_parse$$1$$1$$1$$3$$3$$n)->type == TYPE_NONE)
          (a->arg + (signed long int)printf_parse$$1$$1$$1$$3$$3$$n)->type = (enum anonymous$4)TYPE_INT;

        else
          if(!((signed int)(a->arg + (signed long int)printf_parse$$1$$1$$1$$3$$3$$n)->type == TYPE_INT))
            goto error;

      }

      else
        if((signed int)*cp >= 48)
        {
          if(!((signed int)*cp >= 58))
          {
            unsigned long int width_length;
            dp->width_start = cp;
            do
            {
              if((signed int)*cp >= 48)
                tmp_if_expr$11 = (signed int)*cp <= 57 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$11 = (_Bool)0;
              if(!tmp_if_expr$11)
                break;

              cp = cp + 1l;
            }
            while((_Bool)1);
            dp->width_end = cp;
            width_length = (unsigned long int)(dp->width_end - dp->width_start);
            if(!(max_width_length >= width_length))
              max_width_length = width_length;

          }

        }

      if((signed int)*cp == 46)
      {
        cp = cp + 1l;
        if((signed int)*cp == 42)
        {
          dp->precision_start = cp - (signed long int)1;
          cp = cp + 1l;
          dp->precision_end = cp;
          if(!(max_precision_length >= 2ul))
            max_precision_length = (unsigned long int)2;

          if((signed int)*cp >= 48)
          {
            if(!((signed int)*cp >= 58))
            {
              const char *printf_parse$$1$$1$$1$$5$$1$$1$$np = cp;
              do
              {
                if((signed int)*printf_parse$$1$$1$$1$$5$$1$$1$$np >= 48)
                  tmp_if_expr$12 = (signed int)*printf_parse$$1$$1$$1$$5$$1$$1$$np <= 57 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$12 = (_Bool)0;
                if(!tmp_if_expr$12)
                  break;

                printf_parse$$1$$1$$1$$5$$1$$1$$np = printf_parse$$1$$1$$1$$5$$1$$1$$np + 1l;
              }
              while((_Bool)1);
              if((signed int)*printf_parse$$1$$1$$1$$5$$1$$1$$np == 36)
              {
                unsigned long int printf_parse$$1$$1$$1$$5$$1$$1$$2$$n = (unsigned long int)0;
                printf_parse$$1$$1$$1$$5$$1$$1$$np = cp;
                do
                {
                  if((signed int)*printf_parse$$1$$1$$1$$5$$1$$1$$np >= 48)
                    tmp_if_expr$13 = (signed int)*printf_parse$$1$$1$$1$$5$$1$$1$$np <= 57 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$13 = (_Bool)0;
                  if(!tmp_if_expr$13)
                    break;

                  printf_parse$$1$$1$$1$$5$$1$$1$$2$$n=xsum(printf_parse$$1$$1$$1$$5$$1$$1$$2$$n <= 18446744073709551615UL / (unsigned long int)10 ? (unsigned long int)printf_parse$$1$$1$$1$$5$$1$$1$$2$$n * (unsigned long int)10 : 18446744073709551615UL, (unsigned long int)((signed int)*printf_parse$$1$$1$$1$$5$$1$$1$$np - 48));
                  printf_parse$$1$$1$$1$$5$$1$$1$$np = printf_parse$$1$$1$$1$$5$$1$$1$$np + 1l;
                }
                while((_Bool)1);
                if(printf_parse$$1$$1$$1$$5$$1$$1$$2$$n == 0ul)
                  goto error;

                if(printf_parse$$1$$1$$1$$5$$1$$1$$2$$n == 18446744073709551615UL)
                  goto error;

                dp->precision_arg_index = printf_parse$$1$$1$$1$$5$$1$$1$$2$$n - (unsigned long int)1;
                cp = printf_parse$$1$$1$$1$$5$$1$$1$$np + (signed long int)1;
              }

            }

          }

          if(dp->precision_arg_index == 18446744073709551615ul)
          {
            tmp_post$14 = arg_posn;
            arg_posn = arg_posn + 1ul;
            dp->precision_arg_index = tmp_post$14;
            if(dp->precision_arg_index == 18446744073709551615ul)
              goto error;

          }

          unsigned long int printf_parse$$1$$1$$1$$5$$1$$3$$n = dp->precision_arg_index;
          if(printf_parse$$1$$1$$1$$5$$1$$3$$n >= a_allocated)
          {
            unsigned long int printf_parse$$1$$1$$1$$5$$1$$3$$1$$memory_size;
            struct anonymous$2 *printf_parse$$1$$1$$1$$5$$1$$3$$1$$memory;
            a_allocated = a_allocated <= 18446744073709551615UL / (unsigned long int)2 ? (unsigned long int)a_allocated * (unsigned long int)2 : 18446744073709551615UL;
            if(printf_parse$$1$$1$$1$$5$$1$$3$$n >= a_allocated)
              a_allocated=xsum(printf_parse$$1$$1$$1$$5$$1$$3$$n, (unsigned long int)1);

            printf_parse$$1$$1$$1$$5$$1$$3$$1$$memory_size = a_allocated <= 18446744073709551615UL / sizeof(struct anonymous$2) /*32ul*/  ? (unsigned long int)a_allocated * sizeof(struct anonymous$2) /*32ul*/  : 18446744073709551615UL;
            if(printf_parse$$1$$1$$1$$5$$1$$3$$1$$memory_size == 18446744073709551615UL)
              goto out_of_memory;

            if(!(a->arg == a->direct_alloc_arg))
            {
              return_value_realloc$15=realloc((void *)a->arg, printf_parse$$1$$1$$1$$5$$1$$3$$1$$memory_size);
              tmp_if_expr$17 = return_value_realloc$15;
            }

            else
            {
              return_value_malloc$16=malloc(printf_parse$$1$$1$$1$$5$$1$$3$$1$$memory_size);
              tmp_if_expr$17 = return_value_malloc$16;
            }
            printf_parse$$1$$1$$1$$5$$1$$3$$1$$memory = (struct anonymous$2 *)tmp_if_expr$17;
            if(printf_parse$$1$$1$$1$$5$$1$$3$$1$$memory == ((struct anonymous$2 *)NULL))
              goto out_of_memory;

            if(a->arg == a->direct_alloc_arg)
              memcpy((void *)printf_parse$$1$$1$$1$$5$$1$$3$$1$$memory, (const void *)a->arg, a->count * sizeof(struct anonymous$2) /*32ul*/ );

            a->arg = printf_parse$$1$$1$$1$$5$$1$$3$$1$$memory;
          }

          for( ; printf_parse$$1$$1$$1$$5$$1$$3$$n >= a->count; (a->arg + (signed long int)tmp_post$18)->type = (enum anonymous$4)TYPE_NONE)
          {
            tmp_post$18 = a->count;
            a->count = a->count + 1ul;
          }
          if((signed int)(a->arg + (signed long int)printf_parse$$1$$1$$1$$5$$1$$3$$n)->type == TYPE_NONE)
            (a->arg + (signed long int)printf_parse$$1$$1$$1$$5$$1$$3$$n)->type = (enum anonymous$4)TYPE_INT;

          else
            if(!((signed int)(a->arg + (signed long int)printf_parse$$1$$1$$1$$5$$1$$3$$n)->type == TYPE_INT))
              goto error;

        }

        else
        {
          unsigned long int precision_length;
          dp->precision_start = cp - (signed long int)1;
          do
          {
            if((signed int)*cp >= 48)
              tmp_if_expr$19 = (signed int)*cp <= 57 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$19 = (_Bool)0;
            if(!tmp_if_expr$19)
              break;

            cp = cp + 1l;
          }
          while((_Bool)1);
          dp->precision_end = cp;
          precision_length = (unsigned long int)(dp->precision_end - dp->precision_start);
          if(!(max_precision_length >= precision_length))
            max_precision_length = precision_length;

        }
      }

      enum anonymous$4 type;
      signed int flags = 0;
      while((_Bool)1)
        if((signed int)*cp == 104)
        {
          flags = flags | 1 << (flags & 1);
          cp = cp + 1l;
        }

        else
          if((signed int)*cp == 76)
          {
            flags = flags | 4;
            cp = cp + 1l;
          }

          else
            if((signed int)*cp == 108)
            {
              flags = flags + 8;
              cp = cp + 1l;
            }

            else
              if((signed int)*cp == 106)
              {
                flags = flags + 8;
                cp = cp + 1l;
              }

              else
              {
                if((signed int)*cp == 122)
                  tmp_if_expr$20 = (_Bool)1;

                else
                  tmp_if_expr$20 = (signed int)*cp == 90 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$20)
                {
                  flags = flags + 8;
                  cp = cp + 1l;
                }

                else
                  if((signed int)*cp == 116)
                  {
                    flags = flags + 8;
                    cp = cp + 1l;
                  }

                  else
                    goto __CPROVER_DUMP_L91;
              }

    __CPROVER_DUMP_L91:
      ;
      tmp_post$21 = cp;
      cp = cp + 1l;
      c = *tmp_post$21;
      switch((signed int)c)
      {
        case 100:

        case 105:
        {
          if(flags >= 16 || !((4 & flags) == 0))
            type = (enum anonymous$4)TYPE_LONGLONGINT;

          else
            if(flags >= 8)
              type = (enum anonymous$4)TYPE_LONGINT;

            else
              if(!((2 & flags) == 0))
                type = (enum anonymous$4)TYPE_SCHAR;

              else
                if(!((1 & flags) == 0))
                  type = (enum anonymous$4)TYPE_SHORT;

                else
                  type = (enum anonymous$4)TYPE_INT;
          break;
        }
        case 111:

        case 117:

        case 120:

        case 88:
        {
          if(flags >= 16 || !((4 & flags) == 0))
            type = (enum anonymous$4)TYPE_ULONGLONGINT;

          else
            if(flags >= 8)
              type = (enum anonymous$4)TYPE_ULONGINT;

            else
              if(!((2 & flags) == 0))
                type = (enum anonymous$4)TYPE_UCHAR;

              else
                if(!((1 & flags) == 0))
                  type = (enum anonymous$4)TYPE_USHORT;

                else
                  type = (enum anonymous$4)TYPE_UINT;
          break;
        }
        case 102:

        case 70:

        case 101:

        case 69:

        case 103:

        case 71:

        case 97:

        case 65:
        {
          if(flags >= 16 || !((4 & flags) == 0))
            type = (enum anonymous$4)TYPE_LONGDOUBLE;

          else
            type = (enum anonymous$4)TYPE_DOUBLE;
          break;
        }
        case 99:
        {
          if(flags >= 8)
            type = (enum anonymous$4)TYPE_WIDE_CHAR;

          else
            type = (enum anonymous$4)TYPE_CHAR;
          break;
        }
        case 67:
        {
          type = (enum anonymous$4)TYPE_WIDE_CHAR;
          c = (char)99;
          break;
        }
        case 115:
        {
          if(flags >= 8)
            type = (enum anonymous$4)TYPE_WIDE_STRING;

          else
            type = (enum anonymous$4)TYPE_STRING;
          break;
        }
        case 83:
        {
          type = (enum anonymous$4)TYPE_WIDE_STRING;
          c = (char)115;
          break;
        }
        case 112:
        {
          type = (enum anonymous$4)TYPE_POINTER;
          break;
        }
        case 110:
        {
          if(flags >= 16 || !((4 & flags) == 0))
            type = (enum anonymous$4)TYPE_COUNT_LONGLONGINT_POINTER;

          else
            if(flags >= 8)
              type = (enum anonymous$4)TYPE_COUNT_LONGINT_POINTER;

            else
              if(!((2 & flags) == 0))
                type = (enum anonymous$4)TYPE_COUNT_SCHAR_POINTER;

              else
                if(!((1 & flags) == 0))
                  type = (enum anonymous$4)TYPE_COUNT_SHORT_POINTER;

                else
                  type = (enum anonymous$4)TYPE_COUNT_INT_POINTER;
          break;
        }
        case 37:
        {
          type = (enum anonymous$4)TYPE_NONE;
          break;
        }
        default:
          goto error;
      }
      if(!((signed int)type == TYPE_NONE))
      {
        dp->arg_index = arg_index;
        if(dp->arg_index == 18446744073709551615ul)
        {
          tmp_post$22 = arg_posn;
          arg_posn = arg_posn + 1ul;
          dp->arg_index = tmp_post$22;
          if(dp->arg_index == 18446744073709551615ul)
            goto error;

        }

        unsigned long int printf_parse$$1$$1$$1$$6$$2$$2$$n = dp->arg_index;
        if(printf_parse$$1$$1$$1$$6$$2$$2$$n >= a_allocated)
        {
          unsigned long int memory_size;
          struct anonymous$2 *memory;
          a_allocated = a_allocated <= 18446744073709551615UL / (unsigned long int)2 ? (unsigned long int)a_allocated * (unsigned long int)2 : 18446744073709551615UL;
          if(printf_parse$$1$$1$$1$$6$$2$$2$$n >= a_allocated)
            a_allocated=xsum(printf_parse$$1$$1$$1$$6$$2$$2$$n, (unsigned long int)1);

          memory_size = a_allocated <= 18446744073709551615UL / sizeof(struct anonymous$2) /*32ul*/  ? (unsigned long int)a_allocated * sizeof(struct anonymous$2) /*32ul*/  : 18446744073709551615UL;
          if(memory_size == 18446744073709551615UL)
            goto out_of_memory;

          if(!(a->arg == a->direct_alloc_arg))
          {
            return_value_realloc$23=realloc((void *)a->arg, memory_size);
            tmp_if_expr$25 = return_value_realloc$23;
          }

          else
          {
            return_value_malloc$24=malloc(memory_size);
            tmp_if_expr$25 = return_value_malloc$24;
          }
          memory = (struct anonymous$2 *)tmp_if_expr$25;
          if(memory == ((struct anonymous$2 *)NULL))
            goto out_of_memory;

          if(a->arg == a->direct_alloc_arg)
            memcpy((void *)memory, (const void *)a->arg, a->count * sizeof(struct anonymous$2) /*32ul*/ );

          a->arg = memory;
        }

        for( ; printf_parse$$1$$1$$1$$6$$2$$2$$n >= a->count; (a->arg + (signed long int)tmp_post$26)->type = (enum anonymous$4)TYPE_NONE)
        {
          tmp_post$26 = a->count;
          a->count = a->count + 1ul;
        }
        if((signed int)(a->arg + (signed long int)printf_parse$$1$$1$$1$$6$$2$$2$$n)->type == TYPE_NONE)
          (a->arg + (signed long int)printf_parse$$1$$1$$1$$6$$2$$2$$n)->type = type;

        else
          if(!((a->arg + (signed long int)printf_parse$$1$$1$$1$$6$$2$$2$$n)->type == type))
            goto error;

      }

      dp->conversion = c;
      dp->dir_end = cp;
      d->count = d->count + 1ul;
      if(d->count >= d_allocated)
      {
        unsigned long int printf_parse$$1$$1$$1$$7$$memory_size;
        struct anonymous *printf_parse$$1$$1$$1$$7$$memory;
        d_allocated = d_allocated <= 18446744073709551615UL / (unsigned long int)2 ? (unsigned long int)d_allocated * (unsigned long int)2 : 18446744073709551615UL;
        printf_parse$$1$$1$$1$$7$$memory_size = d_allocated <= 18446744073709551615UL / sizeof(struct anonymous) /*88ul*/  ? (unsigned long int)d_allocated * sizeof(struct anonymous) /*88ul*/  : 18446744073709551615UL;
        if(printf_parse$$1$$1$$1$$7$$memory_size == 18446744073709551615UL)
          goto out_of_memory;

        if(!(d->dir == d->direct_alloc_dir))
        {
          return_value_realloc$27=realloc((void *)d->dir, printf_parse$$1$$1$$1$$7$$memory_size);
          tmp_if_expr$29 = return_value_realloc$27;
        }

        else
        {
          return_value_malloc$28=malloc(printf_parse$$1$$1$$1$$7$$memory_size);
          tmp_if_expr$29 = return_value_malloc$28;
        }
        printf_parse$$1$$1$$1$$7$$memory = (struct anonymous *)tmp_if_expr$29;
        if(printf_parse$$1$$1$$1$$7$$memory == ((struct anonymous *)NULL))
          goto out_of_memory;

        if(d->dir == d->direct_alloc_dir)
          memcpy((void *)printf_parse$$1$$1$$1$$7$$memory, (const void *)d->dir, d->count * sizeof(struct anonymous) /*88ul*/ );

        d->dir = printf_parse$$1$$1$$1$$7$$memory;
      }

    }

  }
  (d->dir + (signed long int)d->count)->dir_start = cp;
  d->max_width_length = max_width_length;
  d->max_precision_length = max_precision_length;
  return 0;

error:
  ;
  if(!(a->arg == a->direct_alloc_arg))
    free((void *)a->arg);

  if(!(d->dir == d->direct_alloc_dir))
    free((void *)d->dir);

  signed int *return_value___errno_location$30;
  return_value___errno_location$30=__errno_location();
  *return_value___errno_location$30 = 22;
  return -1;

out_of_memory:
  ;
  if(!(a->arg == a->direct_alloc_arg))
    free((void *)a->arg);

  if(!(d->dir == d->direct_alloc_dir))
    free((void *)d->dir);

  signed int *return_value___errno_location$31;
  return_value___errno_location$31=__errno_location();
  *return_value___errno_location$31 = 12;
  return -1;
}

// read_ctrl_msg
// file tia-server.c line 382
static signed int read_ctrl_msg(struct _IO_FILE *fp)
{
  char buffer[64l];
  char msg[32l];
  unsigned int vers[2l];
  unsigned int clen = (unsigned int)0;
  unsigned long int rlen;
  signed int i;
  char *return_value_fgets$1;
  return_value_fgets$1=fgets(buffer, (signed int)sizeof(char [64l]) /*64ul*/ , fp);
  _Bool tmp_if_expr$3;
  signed int return_value_sscanf$2;
  if(return_value_fgets$1 == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_sscanf$2=sscanf(buffer, " TiA %u.%u", (const void *)vers, vers + (signed long int)1);
    tmp_if_expr$3 = return_value_sscanf$2 < 2 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  char *return_value_fgets$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_fgets$4=fgets(buffer, (signed int)sizeof(char [64l]) /*64ul*/ , fp);
    tmp_if_expr$5 = !(return_value_fgets$4 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  signed int return_value_sscanf$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_sscanf$6=sscanf(buffer, " %31[^\n]", (const void *)msg);
    tmp_if_expr$7 = return_value_sscanf$6 < 1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$9;
  char *return_value_fgets$8;
  if(tmp_if_expr$7)
    tmp_if_expr$9 = (_Bool)1;

  else
  {
    return_value_fgets$8=fgets(buffer, (signed int)sizeof(char [64l]) /*64ul*/ , fp);
    tmp_if_expr$9 = !(return_value_fgets$8 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  char *return_value_fgets$10;
  signed int return_value_strcmp$12;
  if(tmp_if_expr$9)
    return -1;

  else
  {
    sscanf(buffer, " Content-Length: %u\n", &clen);
    if(!(clen == 0u))
    {
      return_value_fgets$10=fgets(buffer, (signed int)sizeof(char [64l]) /*64ul*/ , fp);
      if(!(return_value_fgets$10 == ((char *)NULL)))
        goto __CPROVER_DUMP_L10;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L10:
      ;
      while(!(clen == 0u))
      {
        rlen = sizeof(char [64l]) /*64ul*/  > (unsigned long int)clen ? sizeof(char [64l]) /*64ul*/  : (unsigned long int)clen;
        unsigned long int return_value_fread$11;
        return_value_fread$11=fread((void *)buffer, rlen, (unsigned long int)1, fp);
        if(!(return_value_fread$11 >= 1ul))
          return -1;

        clen = clen - (unsigned int)rlen;
      }
      i = 0;
      for( ; !(i >= 6); i = i + 1)
      {
        return_value_strcmp$12=strcmp(msg, prot_request[(signed long int)i]);
        if(return_value_strcmp$12 == 0)
          return i;

      }
      return -1;
    }
  }
}

// read_eegsignal
// file systobiia.c line 175
signed int read_eegsignal(signed int bsigcheck)
{
  struct eegdev *dev;
  unsigned long int strides[3l];
  unsigned long int tsize = sizeof(float) /*4ul*/ ;
  void *eeg_t = (void *)0;
  void *exg_t = (void *)0;
  signed int *tri_t = (signed int *)(void *)0;
  signed int i;
  signed int fs;
  signed int retcode = 1;
  dev=open_device(grp);
  void *return_value_calloc$1;
  signed int return_value_egd_acq_setup$2;
  signed int return_value_egd_start$3;
  signed int return_value_check_signals_f$5;
  signed int return_value_egd_stop$6;
  signed int return_value_egd_close$7;
  if(!(dev == ((struct eegdev *)NULL)))
  {
    strides[(signed long int)0] = (unsigned long int)grp[(signed long int)0].nch * tsize;
    strides[(signed long int)1] = (unsigned long int)grp[(signed long int)1].nch * tsize;
    strides[(signed long int)2] = (unsigned long int)grp[(signed long int)2].nch * sizeof(signed int) /*4ul*/ ;
    eeg_t=calloc(strides[(signed long int)0], (unsigned long int)4);
    exg_t=calloc(strides[(signed long int)1], (unsigned long int)4);
    return_value_calloc$1=calloc(strides[(signed long int)2], (unsigned long int)4);
    tri_t = (signed int *)return_value_calloc$1;
    fs=print_cap(dev);
    return_value_egd_acq_setup$2=egd_acq_setup(dev, (unsigned int)3, strides, (unsigned int)3, grp);
    if(return_value_egd_acq_setup$2 == 0)
    {
      return_value_egd_start$3=egd_start(dev);
      if(return_value_egd_start$3 == 0)
      {
        i = 0;
        for( ; !(i >= 5 * fs); i = i + 4)
        {
          signed long int return_value_egd_get_data$4;
          return_value_egd_get_data$4=egd_get_data(dev, (unsigned long int)4, eeg_t, exg_t, tri_t);
          if(!(return_value_egd_get_data$4 >= 0l))
          {
            fprintf(stderr, "\tAcq failed at sample %i\n", i);
            goto exit;
          }

          if(!(bsigcheck == 0))
          {
            return_value_check_signals_f$5=check_signals_f((unsigned long int)4, (const float *)eeg_t, (const float *)exg_t, tri_t);
            if(!(return_value_check_signals_f$5 == 0))
            {
              retcode = 2;
              break;
            }

          }

        }
        return_value_egd_stop$6=egd_stop(dev);
        if(return_value_egd_stop$6 == 0)
        {
          return_value_egd_close$7=egd_close(dev);
          if(return_value_egd_close$7 == 0)
          {
            dev = (struct eegdev *)(void *)0;
            if(retcode == 1)
              retcode = 0;

          }

        }

      }

    }

  }


exit:
  ;
  signed int *return_value___errno_location$8;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  if(retcode == 1)
  {
    return_value___errno_location$8=__errno_location();
    return_value___errno_location$9=__errno_location();
    return_value_strerror$10=strerror(*return_value___errno_location$9);
    fprintf(stderr, "\terror caught (%i) %s\n", *return_value___errno_location$8, return_value_strerror$10);
  }

  egd_close(dev);
  free(eeg_t);
  free(exg_t);
  free((void *)tri_t);
  return retcode;
}

// reply_dataconnection
// file tia-server.c line 337
static signed int reply_dataconnection(signed int fd)
{
  char buffer[32l];
  datafd=create_listening_socket((unsigned short int)38501);
  pthread_mutex_lock(&lock);
  acq_run = 0;
  pthread_mutex_unlock(&lock);
  pthread_create(&data_thid, (const union pthread_attr_t *)(void *)0, data_socket_fn, (void *)0);
  sprintf(buffer, "DataConnectionPort: %i", 38501);
  signed int return_value_reply_msg$1;
  return_value_reply_msg$1=reply_msg(fd, buffer, 0, (const char *)(void *)0);
  return return_value_reply_msg$1;
}

// reply_metainfo
// file tia-server.c line 284
static signed int reply_metainfo(signed int fd)
{
  void *buffer;
  unsigned long int clen;
  signed int ret = 0;
  struct _IO_FILE *metafp;
  metafp=fopen("metainfoxml.tmp", "w+b");
  if(metafp == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    write_metainfo(metafp);
    fseek(metafp, (signed long int)0, 2);
    signed long int return_value_ftell$1;
    return_value_ftell$1=ftell(metafp);
    clen = (unsigned long int)return_value_ftell$1;
    fseek(metafp, (signed long int)0, 0);
    buffer=malloc(clen);
    unsigned long int return_value_fread$2;
    return_value_fread$2=fread(buffer, clen, (unsigned long int)1, metafp);
    if(!(return_value_fread$2 >= 1ul))
      ret = -1;

    fclose(metafp);
    if(ret == 0)
      ret=reply_msg(fd, "MetaInfo", (signed int)clen, (const char *)buffer);

    free(buffer);
    return ret;
  }
}

// reply_msg
// file tia-server.c line 239
static signed int reply_msg(signed int fd, const char *answer, signed int contentlen, const char *content)
{
  char buffer[256l];
  unsigned long int count;
  sprintf(buffer, "TiA 1.0\n%s\n", answer);
  count=strlen(buffer);
  if(!(content == ((const char *)NULL)) && !(contentlen == 0))
  {
    sprintf(buffer + (signed long int)count, "Content-Length: %i\n", contentlen);
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(buffer + (signed long int)count);
    count = count + return_value_strlen$1;
  }

  unsigned long int tmp_post$2 = count;
  count = count + 1ul;
  buffer[(signed long int)tmp_post$2] = (char)10;
  signed long int return_value_write$3;
  return_value_write$3=write(fd, (const void *)buffer, count);
  signed long int return_value_write$4;
  if(return_value_write$3 >= (signed long int)count)
  {
    if(!(content == ((const char *)NULL)) && !(contentlen == 0))
    {
      return_value_write$4=write(fd, (const void *)content, (unsigned long int)contentlen);
      if(!(return_value_write$4 >= (signed long int)contentlen))
        goto error;

    }

    return 0;
  }

  else
  {

  error:
    ;
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    fprintf(stderr, "Error in sending reply: %s (%i)\n", return_value_strerror$6, *return_value___errno_location$7);
    return -1;
  }
}

// reply_startdata
// file tia-server.c line 355
static signed int reply_startdata(signed int fd)
{
  pthread_mutex_lock(&lock);
  clock_gettime(0, &acq_ts);
  acq_run = 1;
  pthread_cond_signal(&cond);
  pthread_mutex_unlock(&lock);
  signed int return_value_reply_msg$1;
  return_value_reply_msg$1=reply_msg(fd, "OK", 0, (const char *)(void *)0);
  return return_value_reply_msg$1;
}

// reply_stopdata
// file tia-server.c line 367
static signed int reply_stopdata(signed int fd)
{
  pthread_mutex_lock(&lock);
  acq_run = 0;
  pthread_cond_signal(&cond);
  pthread_mutex_unlock(&lock);
  signed int return_value_reply_msg$1;
  return_value_reply_msg$1=reply_msg(fd, "OK", 0, (const char *)(void *)0);
  return return_value_reply_msg$1;
}

// reterrno
// file core.c line 39
static signed int reterrno(signed int err)
{
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = err;
  return -1;
}

// safe_strncpy
// file core.c line 201
static void safe_strncpy(char *dst, const char *src, unsigned long int n)
{
  const char *strsrc = src != (const char *)(void *)0 ? src : "";
  unsigned long int eos;
  eos=strlen(strsrc);
  if(eos >= n)
    eos = n - (unsigned long int)1;

  memcpy((void *)dst, (const void *)src, eos);
  dst[(signed long int)eos] = (char)0;
}

// sensor_type_exit
// file sensortypes.c line 73
static void sensor_type_exit(void)
{
  struct sensor_type *next;
  struct sensor_type *curr = first.next;
  for( ; !(curr == ((struct sensor_type *)NULL)); curr = next)
  {
    next = curr->next;
    free((void *)curr);
  }
  pthread_mutex_destroy(&stype_lock);
}

// sensor_type_init
// file sensortypes.c line 88
static void sensor_type_init(void)
{
  pthread_mutex_init(&stype_lock, (const union anonymous$6 *)(void *)0);
  add_sensor_type("eeg", (struct sensor_type *)(void *)0);
  add_sensor_type("trigger", (struct sensor_type *)(void *)0);
  add_sensor_type("undefined", (struct sensor_type *)(void *)0);
  atexit(sensor_type_exit);
}

// setup_ringbuffer_mapping
// file core.c line 72
static signed int setup_ringbuffer_mapping(struct eegdev *dev)
{
  unsigned int i;
  unsigned int offset = (unsigned int)0;
  unsigned int isiz;
  unsigned int bsiz;
  unsigned int ti;
  unsigned int tb;
  struct selected_channels *selch = dev->selch;
  struct input_buffer_group *ibgrp = dev->inbuffgrp;
  i = (unsigned int)0;
  for( ; !(i >= dev->nsel); i = i + 1u)
  {
    ti = (selch + (signed long int)i)->typein;
    tb = (selch + (signed long int)i)->typeout;
    isiz=egd_get_data_size(ti);
    bsiz=egd_get_data_size(tb);
    (ibgrp + (signed long int)i)->in_offset = (selch + (signed long int)i)->in_offset;
    (ibgrp + (signed long int)i)->inlen = (selch + (signed long int)i)->inlen;
    (ibgrp + (signed long int)i)->buff_offset = offset;
    (ibgrp + (signed long int)i)->in_tsize = (signed int)isiz;
    (ibgrp + (signed long int)i)->buff_tsize = (signed int)bsiz;
    (ibgrp + (signed long int)i)->sc = (selch + (signed long int)i)->sc;
    (ibgrp + (signed long int)i)->cast_fn=egd_get_cast_fn(ti, tb, (unsigned int)(selch + (signed long int)i)->bsc);
    (dev->arrconf + (signed long int)i)->len = (bsiz * (selch + (signed long int)i)->inlen) / isiz;
    (dev->arrconf + (signed long int)i)->iarray = (selch + (signed long int)i)->iarray;
    (dev->arrconf + (signed long int)i)->arr_offset = (selch + (signed long int)i)->arr_offset;
    (dev->arrconf + (signed long int)i)->buff_offset = offset;
    offset = offset + (dev->arrconf + (signed long int)i)->len;
  }
  dev->buff_samlen = (unsigned long int)offset;
  optimize_inbufgrp(dev->inbuffgrp, &dev->ngrp);
  return 0;
}

// validate_groups_settings
// file core.c line 158
static signed int validate_groups_settings(struct eegdev *dev, unsigned int ngrp, struct grpconf *grp)
{
  unsigned int i;
  unsigned int stype;
  i = (unsigned int)0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  signed int return_value_reterrno$1;
  for( ; !(i >= ngrp); i = i + 1u)
  {
    stype = (unsigned int)(grp + (signed long int)i)->sensortype;
    if(stype >= 3u)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (grp + (signed long int)i)->index + (grp + (signed long int)i)->nch > dev->cap.type_nch[(signed long int)stype] ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (grp + (signed long int)i)->datatype >= 3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      return_value_reterrno$1=reterrno(22);
      return return_value_reterrno$1;
    }

  }
  return 0;
}

// vasnprintf
// file vasnprintf.h line 72
extern char * vasnprintf(char *resultbuf, unsigned long int *lengthp, const char *format, void **args)
{
  struct anonymous$5 d;
  struct anonymous$1 a;
  signed int return_value_printf_parse$1;
  return_value_printf_parse$1=printf_parse(format, &d, &a);
  void *return_value_malloc$6;
  void *return_value_realloc$7;
  unsigned long int tmp_post$8;
  const char *tmp_post$9;
  void *return_value_malloc$10;
  void *return_value_realloc$11;
  char *tmp_post$12;
  char *tmp_post$13;
  char *tmp_post$14;
  char *tmp_post$15;
  char *tmp_post$16;
  char *tmp_post$17;
  char *tmp_post$18;
  char *tmp_post$19;
  char *tmp_post$20;
  const char *tmp_post$21;
  char *tmp_post$22;
  const char *tmp_post$23;
  char *tmp_post$24;
  char *tmp_post$25;
  char *tmp_post$26;
  unsigned int tmp_post$27;
  unsigned int tmp_post$28;
  void *return_value_malloc$30;
  void *return_value_realloc$31;
  signed int tmp_if_expr$38;
  _Bool tmp_if_expr$37;
  void *return_value_malloc$40;
  void *return_value_realloc$41;
  void *return_value_malloc$44;
  void *return_value_realloc$45;
  if(!(return_value_printf_parse$1 >= 0))
    return (char *)(void *)0;

  else
  {
    signed int return_value_printf_fetchargs$3;
    return_value_printf_fetchargs$3=printf_fetchargs(args, &a);
    if(!(return_value_printf_fetchargs$3 >= 0))
    {
      if(!(d.dir == d.direct_alloc_dir))
        free((void *)d.dir);

      if(!(a.arg == a.direct_alloc_arg))
        free((void *)a.arg);

      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 22;
      return (char *)(void *)0;
    }

    unsigned long int buf_neededlength;
    char *buf;
    char *buf_malloced;
    const char *cp;
    unsigned long int i;
    struct anonymous *dp;
    char *result;
    unsigned long int allocated;
    unsigned long int length;
    buf_neededlength=xsum4((unsigned long int)7, d.max_width_length, d.max_precision_length, (unsigned long int)6);
    if(!(buf_neededlength >= 4000ul))
    {
      void *return_value___builtin_alloca$4;
      return_value___builtin_alloca$4=__builtin_alloca(buf_neededlength * sizeof(char) /*1ul*/ );
      buf = (char *)return_value___builtin_alloca$4;
      buf_malloced = (char *)(void *)0;
    }

    else
    {
      unsigned long int buf_memsize = buf_neededlength <= 18446744073709551615UL / sizeof(char) /*1ul*/  ? (unsigned long int)buf_neededlength * sizeof(char) /*1ul*/  : 18446744073709551615UL;
      if(buf_memsize == 18446744073709551615UL)
        goto out_of_memory_1;

      void *return_value_malloc$5;
      return_value_malloc$5=malloc(buf_memsize);
      buf = (char *)return_value_malloc$5;
      if(buf == ((char *)NULL))
        goto out_of_memory_1;

      buf_malloced = buf;
    }
    if(!(resultbuf == ((char *)NULL)))
    {
      result = resultbuf;
      allocated = *lengthp;
    }

    else
    {
      result = (char *)(void *)0;
      allocated = (unsigned long int)0;
    }
    length = (unsigned long int)0;
    cp = format;
    i = (unsigned long int)0;
    dp = &d.dir[(signed long int)0];
    for( ; (_Bool)1; dp = dp + 1l)
    {
      if(!(cp == dp->dir_start))
      {
        unsigned long int n = (unsigned long int)(dp->dir_start - cp);
        unsigned long int augmented_length;
        augmented_length=xsum(length, n);
        if(!(allocated >= augmented_length))
        {
          unsigned long int vasnprintf$$1$$2$$5$$1$$1$$1$$memory_size;
          char *vasnprintf$$1$$2$$5$$1$$1$$1$$memory;
          allocated = allocated > (unsigned long int)0 ? (allocated <= 18446744073709551615UL / (unsigned long int)2 ? (unsigned long int)allocated * (unsigned long int)2 : 18446744073709551615UL) : (unsigned long int)12;
          if(!(allocated >= augmented_length))
            allocated = augmented_length;

          vasnprintf$$1$$2$$5$$1$$1$$1$$memory_size = allocated <= 18446744073709551615UL / sizeof(char) /*1ul*/  ? (unsigned long int)allocated * sizeof(char) /*1ul*/  : 18446744073709551615UL;
          if(vasnprintf$$1$$2$$5$$1$$1$$1$$memory_size == 18446744073709551615UL)
            goto out_of_memory;

          if(result == ((char *)NULL) || result == resultbuf)
          {
            return_value_malloc$6=malloc(vasnprintf$$1$$2$$5$$1$$1$$1$$memory_size);
            vasnprintf$$1$$2$$5$$1$$1$$1$$memory = (char *)return_value_malloc$6;
          }

          else
          {
            return_value_realloc$7=realloc((void *)result, vasnprintf$$1$$2$$5$$1$$1$$1$$memory_size);
            vasnprintf$$1$$2$$5$$1$$1$$1$$memory = (char *)return_value_realloc$7;
          }
          if(vasnprintf$$1$$2$$5$$1$$1$$1$$memory == ((char *)NULL))
            goto out_of_memory;

          if(result == resultbuf && length >= 1ul)
            memcpy((void *)vasnprintf$$1$$2$$5$$1$$1$$1$$memory, (const void *)result, length);

          result = vasnprintf$$1$$2$$5$$1$$1$$1$$memory;
        }

        memcpy((void *)(result + (signed long int)length), (const void *)(const char *)cp, n);
        length = augmented_length;
      }

      if(i == d.count)
        break;

      if((signed int)dp->conversion == 37)
      {
        unsigned long int vasnprintf$$1$$2$$5$$1$$2$$augmented_length;
        if(!(dp->arg_index == 18446744073709551615ul))
          abort();

        vasnprintf$$1$$2$$5$$1$$2$$augmented_length=xsum(length, (unsigned long int)1);
        if(!(allocated >= vasnprintf$$1$$2$$5$$1$$2$$augmented_length))
        {
          unsigned long int vasnprintf$$1$$2$$5$$1$$2$$1$$memory_size;
          char *vasnprintf$$1$$2$$5$$1$$2$$1$$memory;
          allocated = allocated > (unsigned long int)0 ? (allocated <= 18446744073709551615UL / (unsigned long int)2 ? (unsigned long int)allocated * (unsigned long int)2 : 18446744073709551615UL) : (unsigned long int)12;
          if(!(allocated >= vasnprintf$$1$$2$$5$$1$$2$$augmented_length))
            allocated = vasnprintf$$1$$2$$5$$1$$2$$augmented_length;

          vasnprintf$$1$$2$$5$$1$$2$$1$$memory_size = allocated <= 18446744073709551615UL / sizeof(char) /*1ul*/  ? (unsigned long int)allocated * sizeof(char) /*1ul*/  : 18446744073709551615UL;
          if(vasnprintf$$1$$2$$5$$1$$2$$1$$memory_size == 18446744073709551615UL)
            goto out_of_memory;

          if(result == ((char *)NULL) || result == resultbuf)
          {
            return_value_malloc$10=malloc(vasnprintf$$1$$2$$5$$1$$2$$1$$memory_size);
            vasnprintf$$1$$2$$5$$1$$2$$1$$memory = (char *)return_value_malloc$10;
          }

          else
          {
            return_value_realloc$11=realloc((void *)result, vasnprintf$$1$$2$$5$$1$$2$$1$$memory_size);
            vasnprintf$$1$$2$$5$$1$$2$$1$$memory = (char *)return_value_realloc$11;
          }
          if(vasnprintf$$1$$2$$5$$1$$2$$1$$memory == ((char *)NULL))
            goto out_of_memory;

          if(result == resultbuf && length >= 1ul)
            memcpy((void *)vasnprintf$$1$$2$$5$$1$$2$$1$$memory, (const void *)result, length);

          result = vasnprintf$$1$$2$$5$$1$$2$$1$$memory;
        }

        result[(signed long int)length] = (char)37;
        length = vasnprintf$$1$$2$$5$$1$$2$$augmented_length;
      }

      else
      {
        if(dp->arg_index == 18446744073709551615ul)
          abort();

        if((signed int)dp->conversion == 110)
          switch((signed int)(a.arg + (signed long int)dp->arg_index)->type)
          {
            case TYPE_COUNT_SCHAR_POINTER:
            {
              *(a.arg + (signed long int)dp->arg_index)->a.a_count_schar_pointer = (signed char)length;
              break;
            }
            case TYPE_COUNT_SHORT_POINTER:
            {
              *(a.arg + (signed long int)dp->arg_index)->a.a_count_short_pointer = (signed short int)length;
              break;
            }
            case TYPE_COUNT_INT_POINTER:
            {
              *(a.arg + (signed long int)dp->arg_index)->a.a_count_int_pointer = (signed int)length;
              break;
            }
            case TYPE_COUNT_LONGINT_POINTER:
            {
              *(a.arg + (signed long int)dp->arg_index)->a.a_count_longint_pointer = (signed long int)length;
              break;
            }
            case TYPE_COUNT_LONGLONGINT_POINTER:
            {
              *(a.arg + (signed long int)dp->arg_index)->a.a_count_longlongint_pointer = (signed long long int)length;
              break;
            }
            default:
              abort();
          }

        else
        {
          enum anonymous$4 type = (a.arg + (signed long int)dp->arg_index)->type;
          signed int flags = dp->flags;
          char *fbp;
          unsigned int prefix_count;
          signed int prefixes[2l];
          signed int orig_errno;
          fbp = buf;
          tmp_post$12 = fbp;
          fbp = fbp + 1l;
          *tmp_post$12 = (char)37;
          if(!((1 & flags) == 0))
          {
            tmp_post$13 = fbp;
            fbp = fbp + 1l;
            *tmp_post$13 = (char)39;
          }

          if(!((2 & flags) == 0))
          {
            tmp_post$14 = fbp;
            fbp = fbp + 1l;
            *tmp_post$14 = (char)45;
          }

          if(!((4 & flags) == 0))
          {
            tmp_post$15 = fbp;
            fbp = fbp + 1l;
            *tmp_post$15 = (char)43;
          }

          if(!((8 & flags) == 0))
          {
            tmp_post$16 = fbp;
            fbp = fbp + 1l;
            *tmp_post$16 = (char)32;
          }

          if(!((16 & flags) == 0))
          {
            tmp_post$17 = fbp;
            fbp = fbp + 1l;
            *tmp_post$17 = (char)35;
          }

          if(!((64 & flags) == 0))
          {
            tmp_post$18 = fbp;
            fbp = fbp + 1l;
            *tmp_post$18 = (char)73;
          }

          if(!((32 & flags) == 0))
          {
            tmp_post$19 = fbp;
            fbp = fbp + 1l;
            *tmp_post$19 = (char)48;
          }

          if(!(dp->width_start == dp->width_end))
          {
            unsigned long int vasnprintf$$1$$2$$5$$1$$3$$2$$1$$1$$n = (unsigned long int)(dp->width_end - dp->width_start);
            memcpy((void *)fbp, (const void *)dp->width_start, vasnprintf$$1$$2$$5$$1$$3$$2$$1$$1$$n * sizeof(char) /*1ul*/ );
            fbp = fbp + (signed long int)vasnprintf$$1$$2$$5$$1$$3$$2$$1$$1$$n;
          }

          if(!(dp->precision_start == dp->precision_end))
          {
            unsigned long int vasnprintf$$1$$2$$5$$1$$3$$2$$2$$1$$n = (unsigned long int)(dp->precision_end - dp->precision_start);
            memcpy((void *)fbp, (const void *)dp->precision_start, vasnprintf$$1$$2$$5$$1$$3$$2$$2$$1$$n * sizeof(char) /*1ul*/ );
            fbp = fbp + (signed long int)vasnprintf$$1$$2$$5$$1$$3$$2$$2$$1$$n;
          }

          switch((signed int)type)
          {
            case TYPE_LONGLONGINT:

            case TYPE_ULONGLONGINT:
            {
              tmp_post$24 = fbp;
              fbp = fbp + 1l;
              *tmp_post$24 = (char)108;
            }
            case TYPE_LONGINT:

            case TYPE_ULONGINT:

            case TYPE_WIDE_CHAR:

            case TYPE_WIDE_STRING:
            {
              tmp_post$25 = fbp;
              fbp = fbp + 1l;
              *tmp_post$25 = (char)108;
              break;
            }
            case TYPE_LONGDOUBLE:
            {
              tmp_post$26 = fbp;
              fbp = fbp + 1l;
              *tmp_post$26 = (char)76;
            }
          }
          *fbp = dp->conversion;
          fbp[(signed long int)1] = (char)0;
          prefix_count = (unsigned int)0;
          if(!(dp->width_arg_index == 18446744073709551615ul))
          {
            if(!((signed int)(a.arg + (signed long int)dp->width_arg_index)->type == TYPE_INT))
              abort();

            tmp_post$27 = prefix_count;
            prefix_count = prefix_count + 1u;
            prefixes[(signed long int)tmp_post$27] = (a.arg + (signed long int)dp->width_arg_index)->a.a_int;
          }

          if(!(dp->precision_arg_index == 18446744073709551615ul))
          {
            if(!((signed int)(a.arg + (signed long int)dp->precision_arg_index)->type == TYPE_INT))
              abort();

            tmp_post$28 = prefix_count;
            prefix_count = prefix_count + 1u;
            prefixes[(signed long int)tmp_post$28] = (a.arg + (signed long int)dp->precision_arg_index)->a.a_int;
          }

          unsigned long int return_value_xsum$32;
          return_value_xsum$32=xsum(length, (((unsigned long int)2 + sizeof(char) /*1ul*/  / sizeof(char) /*1ul*/ ) - (unsigned long int)1) / (sizeof(char) /*1ul*/  / sizeof(char) /*1ul*/ ));
          if(!(allocated >= return_value_xsum$32))
          {
            unsigned long int vasnprintf$$1$$2$$5$$1$$3$$2$$6$$memory_size;
            char *vasnprintf$$1$$2$$5$$1$$3$$2$$6$$memory;
            allocated = allocated > (unsigned long int)0 ? (allocated <= 18446744073709551615UL / (unsigned long int)2 ? (unsigned long int)allocated * (unsigned long int)2 : 18446744073709551615UL) : (unsigned long int)12;
            unsigned long int return_value_xsum$29;
            return_value_xsum$29=xsum(length, (((unsigned long int)2 + sizeof(char) /*1ul*/  / sizeof(char) /*1ul*/ ) - (unsigned long int)1) / (sizeof(char) /*1ul*/  / sizeof(char) /*1ul*/ ));
            if(!(allocated >= return_value_xsum$29))
              allocated=xsum(length, (((unsigned long int)2 + sizeof(char) /*1ul*/  / sizeof(char) /*1ul*/ ) - (unsigned long int)1) / (sizeof(char) /*1ul*/  / sizeof(char) /*1ul*/ ));

            vasnprintf$$1$$2$$5$$1$$3$$2$$6$$memory_size = allocated <= 18446744073709551615UL / sizeof(char) /*1ul*/  ? (unsigned long int)allocated * sizeof(char) /*1ul*/  : 18446744073709551615UL;
            if(vasnprintf$$1$$2$$5$$1$$3$$2$$6$$memory_size == 18446744073709551615UL)
              goto out_of_memory;

            if(result == ((char *)NULL) || result == resultbuf)
            {
              return_value_malloc$30=malloc(vasnprintf$$1$$2$$5$$1$$3$$2$$6$$memory_size);
              vasnprintf$$1$$2$$5$$1$$3$$2$$6$$memory = (char *)return_value_malloc$30;
            }

            else
            {
              return_value_realloc$31=realloc((void *)result, vasnprintf$$1$$2$$5$$1$$3$$2$$6$$memory_size);
              vasnprintf$$1$$2$$5$$1$$3$$2$$6$$memory = (char *)return_value_realloc$31;
            }
            if(vasnprintf$$1$$2$$5$$1$$3$$2$$6$$memory == ((char *)NULL))
              goto out_of_memory;

            if(result == resultbuf && length >= 1ul)
              memcpy((void *)vasnprintf$$1$$2$$5$$1$$3$$2$$6$$memory, (const void *)result, length);

            result = vasnprintf$$1$$2$$5$$1$$3$$2$$6$$memory;
          }

          *((char *)(result + (signed long int)length)) = (char)0;
          signed int *return_value___errno_location$33;
          return_value___errno_location$33=__errno_location();
          orig_errno = *return_value___errno_location$33;
          do
          {
            signed int count = -1;
            signed int retcount = 0;
            unsigned long int maxlen = allocated - length;
            if(maxlen >= 2147483648ul)
              maxlen = (unsigned long int)0x7fffffff / (sizeof(char) /*1ul*/  / sizeof(char) /*1ul*/ );

            maxlen = maxlen * (sizeof(char) /*1ul*/  / sizeof(char) /*1ul*/ );
            signed int *return_value___errno_location$34;
            return_value___errno_location$34=__errno_location();
            *return_value___errno_location$34 = 0;
            switch((signed int)type)
            {
              case TYPE_SCHAR:
              {
                signed int vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$1$$arg = (signed int)(a.arg + (signed long int)dp->arg_index)->a.a_schar;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$1$$arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$1$$arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$1$$arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              case TYPE_UCHAR:
              {
                unsigned int vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$2$$arg = (unsigned int)(a.arg + (signed long int)dp->arg_index)->a.a_uchar;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$2$$arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$2$$arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$2$$arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              case TYPE_SHORT:
              {
                signed int vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$3$$arg = (signed int)(a.arg + (signed long int)dp->arg_index)->a.a_short;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$3$$arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$3$$arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$3$$arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              case TYPE_USHORT:
              {
                unsigned int vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$4$$arg = (unsigned int)(a.arg + (signed long int)dp->arg_index)->a.a_ushort;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$4$$arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$4$$arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$4$$arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              case TYPE_INT:
              {
                signed int vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$5$$arg = (a.arg + (signed long int)dp->arg_index)->a.a_int;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$5$$arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$5$$arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$5$$arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              case TYPE_UINT:
              {
                unsigned int vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$6$$arg = (a.arg + (signed long int)dp->arg_index)->a.a_uint;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$6$$arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$6$$arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$6$$arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              case TYPE_LONGINT:
              {
                signed long int vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$7$$arg = (a.arg + (signed long int)dp->arg_index)->a.a_longint;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$7$$arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$7$$arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$7$$arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              case TYPE_ULONGINT:
              {
                unsigned long int arg = (a.arg + (signed long int)dp->arg_index)->a.a_ulongint;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              case TYPE_LONGLONGINT:
              {
                signed long long int vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$9$$arg = (a.arg + (signed long int)dp->arg_index)->a.a_longlongint;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$9$$arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$9$$arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$9$$arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              case TYPE_ULONGLONGINT:
              {
                unsigned long long int vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$10$$arg = (a.arg + (signed long int)dp->arg_index)->a.a_ulonglongint;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$10$$arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$10$$arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$10$$arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              case TYPE_DOUBLE:
              {
                double vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$11$$arg = (a.arg + (signed long int)dp->arg_index)->a.a_double;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$11$$arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$11$$arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$11$$arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              case TYPE_LONGDOUBLE:
              {
                long double vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$12$$arg = (a.arg + (signed long int)dp->arg_index)->a.a_longdouble;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$12$$arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$12$$arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$12$$arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              case TYPE_CHAR:
              {
                signed int vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$13$$arg = (a.arg + (signed long int)dp->arg_index)->a.a_char;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$13$$arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$13$$arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$13$$arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              case TYPE_WIDE_CHAR:
              {
                unsigned int vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$14$$arg = (a.arg + (signed long int)dp->arg_index)->a.a_wide_char;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$14$$arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$14$$arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$14$$arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              case TYPE_STRING:
              {
                const char *vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$15$$arg = (a.arg + (signed long int)dp->arg_index)->a.a_string;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$15$$arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$15$$arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$15$$arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              case TYPE_WIDE_STRING:
              {
                const signed int *vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$16$$arg = (a.arg + (signed long int)dp->arg_index)->a.a_wide_string;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$16$$arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$16$$arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$16$$arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              case TYPE_POINTER:
              {
                void *vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$17$$arg = (a.arg + (signed long int)dp->arg_index)->a.a_pointer;
                switch(prefix_count)
                {
                  case (unsigned int)0:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$17$$arg, &count);
                    break;
                  }
                  case (unsigned int)1:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$17$$arg, &count);
                    break;
                  }
                  case (unsigned int)2:
                  {
                    retcount=snprintf((char *)(result + (signed long int)length), maxlen, buf, prefixes[(signed long int)0], prefixes[(signed long int)1], vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$1$$17$$arg, &count);
                    break;
                  }
                  default:
                    abort();
                }
                break;
              }
              default:
                abort();
            }
            if(count >= 0)
            {
              if(!((unsigned long int)count >= maxlen))
              {
                if(!((signed int)result[(signed long int)length + (signed long int)count] == 0))
                  abort();

              }

              if(!(count >= retcount))
                count = retcount;

            }

            else
              if(!((signed int)fbp[1l] == 0))
              {
                fbp[(signed long int)1] = (char)0;
                continue;
              }

              else
                if(retcount >= 0)
                  count = retcount;

            if(!(count >= 0))
            {
              signed int saved_errno;
              signed int *return_value___errno_location$35;
              return_value___errno_location$35=__errno_location();
              saved_errno = *return_value___errno_location$35;
              if(!(result == ((char *)NULL)) && !(result == resultbuf))
                free((void *)result);

              if(!(buf_malloced == ((char *)NULL)))
                free((void *)buf_malloced);

              if(!(d.dir == d.direct_alloc_dir))
                free((void *)d.dir);

              if(!(a.arg == a.direct_alloc_arg))
                free((void *)a.arg);

              signed int *return_value___errno_location$36;
              return_value___errno_location$36=__errno_location();
              if(!(saved_errno == 0))
                tmp_if_expr$38 = saved_errno;

              else
              {
                if((signed int)dp->conversion == 99)
                  tmp_if_expr$37 = (_Bool)1;

                else
                  tmp_if_expr$37 = (signed int)dp->conversion == 115 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr$38 = tmp_if_expr$37 ? 84 : 22;
              }
              *return_value___errno_location$36 = tmp_if_expr$38;
              return (char *)(void *)0;
            }

            if((unsigned long int)(1u + (unsigned int)count) >= maxlen)
            {
              if(maxlen == 2147483647ul)
                goto overflow;

              else
              {
                unsigned long int vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$5$$1$$n;
                unsigned long int return_value_xsum$39;
                return_value_xsum$39=xsum(length, (((unsigned long int)((unsigned int)count + (unsigned int)2) + sizeof(char) /*1ul*/  / sizeof(char) /*1ul*/ ) - (unsigned long int)1) / (sizeof(char) /*1ul*/  / sizeof(char) /*1ul*/ ));
                vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$5$$1$$n=xmax(return_value_xsum$39, allocated <= 18446744073709551615UL / (unsigned long int)2 ? (unsigned long int)allocated * (unsigned long int)2 : 18446744073709551615UL);
                if(!(allocated >= vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$5$$1$$n))
                {
                  unsigned long int vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$5$$1$$1$$memory_size;
                  char *vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$5$$1$$1$$memory;
                  allocated = allocated > (unsigned long int)0 ? (allocated <= 18446744073709551615UL / (unsigned long int)2 ? (unsigned long int)allocated * (unsigned long int)2 : 18446744073709551615UL) : (unsigned long int)12;
                  if(!(allocated >= vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$5$$1$$n))
                    allocated = vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$5$$1$$n;

                  vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$5$$1$$1$$memory_size = allocated <= 18446744073709551615UL / sizeof(char) /*1ul*/  ? (unsigned long int)allocated * sizeof(char) /*1ul*/  : 18446744073709551615UL;
                  if(vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$5$$1$$1$$memory_size == 18446744073709551615UL)
                    goto out_of_memory;

                  if(result == ((char *)NULL) || result == resultbuf)
                  {
                    return_value_malloc$40=malloc(vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$5$$1$$1$$memory_size);
                    vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$5$$1$$1$$memory = (char *)return_value_malloc$40;
                  }

                  else
                  {
                    return_value_realloc$41=realloc((void *)result, vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$5$$1$$1$$memory_size);
                    vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$5$$1$$1$$memory = (char *)return_value_realloc$41;
                  }
                  if(vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$5$$1$$1$$memory == ((char *)NULL))
                    goto out_of_memory;

                  if(result == resultbuf && length >= 1ul)
                    memcpy((void *)vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$5$$1$$1$$memory, (const void *)result, length);

                  result = vasnprintf$$1$$2$$5$$1$$3$$2$$7$$1$$5$$1$$1$$memory;
                }

                continue;
              }
            }

            length = length + (unsigned long int)count;
            break;
          }
          while((_Bool)1);
          signed int *return_value___errno_location$42;
          return_value___errno_location$42=__errno_location();
          *return_value___errno_location$42 = orig_errno;
        }
      }
      cp = dp->dir_end;
      i = i + 1ul;
    }
    unsigned long int return_value_xsum$46;
    return_value_xsum$46=xsum(length, (unsigned long int)1);
    if(!(allocated >= return_value_xsum$46))
    {
      unsigned long int memory_size;
      char *memory;
      allocated = allocated > (unsigned long int)0 ? (allocated <= 18446744073709551615UL / (unsigned long int)2 ? (unsigned long int)allocated * (unsigned long int)2 : 18446744073709551615UL) : (unsigned long int)12;
      unsigned long int return_value_xsum$43;
      return_value_xsum$43=xsum(length, (unsigned long int)1);
      if(!(allocated >= return_value_xsum$43))
        allocated=xsum(length, (unsigned long int)1);

      memory_size = allocated <= 18446744073709551615UL / sizeof(char) /*1ul*/  ? (unsigned long int)allocated * sizeof(char) /*1ul*/  : 18446744073709551615UL;
      if(memory_size == 18446744073709551615UL)
        goto out_of_memory;

      if(result == ((char *)NULL) || result == resultbuf)
      {
        return_value_malloc$44=malloc(memory_size);
        memory = (char *)return_value_malloc$44;
      }

      else
      {
        return_value_realloc$45=realloc((void *)result, memory_size);
        memory = (char *)return_value_realloc$45;
      }
      if(memory == ((char *)NULL))
        goto out_of_memory;

      if(result == resultbuf && length >= 1ul)
        memcpy((void *)memory, (const void *)result, length);

      result = memory;
    }

    result[(signed long int)length] = (char)0;
    if(!(result == resultbuf) && !(1ul + length >= allocated))
    {
      char *vasnprintf$$1$$2$$7$$memory;
      void *return_value_realloc$47;
      return_value_realloc$47=realloc((void *)result, (length + (unsigned long int)1) * sizeof(char) /*1ul*/ );
      vasnprintf$$1$$2$$7$$memory = (char *)return_value_realloc$47;
      if(!(vasnprintf$$1$$2$$7$$memory == ((char *)NULL)))
        result = vasnprintf$$1$$2$$7$$memory;

    }

    if(!(buf_malloced == ((char *)NULL)))
      free((void *)buf_malloced);

    if(!(d.dir == d.direct_alloc_dir))
      free((void *)d.dir);

    if(!(a.arg == a.direct_alloc_arg))
      free((void *)a.arg);

    *lengthp = length;
    return result;

  overflow:
    ;
    if(!(result == ((char *)NULL)) && !(result == resultbuf))
      free((void *)result);

    if(!(buf_malloced == ((char *)NULL)))
      free((void *)buf_malloced);

    if(!(d.dir == d.direct_alloc_dir))
      free((void *)d.dir);

    if(!(a.arg == a.direct_alloc_arg))
      free((void *)a.arg);

    signed int *return_value___errno_location$48;
    return_value___errno_location$48=__errno_location();
    *return_value___errno_location$48 = 75;
    return (char *)(void *)0;

  out_of_memory:
    ;
    if(!(result == ((char *)NULL)) && !(result == resultbuf))
      free((void *)result);

    if(!(buf_malloced == ((char *)NULL)))
      free((void *)buf_malloced);


  out_of_memory_1:
    ;
    if(!(d.dir == d.direct_alloc_dir))
      free((void *)d.dir);

    if(!(a.arg == a.direct_alloc_arg))
      free((void *)a.arg);

    signed int *return_value___errno_location$49;
    return_value___errno_location$49=__errno_location();
    *return_value___errno_location$49 = 12;
    return (char *)(void *)0;
  }
}

// wait_for_data
// file core.c line 177
static signed int wait_for_data(struct eegdev *dev, unsigned long int *reqns)
{
  signed int error;
  unsigned long int ns = *reqns;
  pthread_mutex_lock(&dev->synclock);
  dev->nreadwait = (unsigned int)ns;
  do
  {
    error = dev->error;
    if(!(error == 0))
      break;

    if(dev->acquiring == 0)
      break;

    if(dev->ns_written >= dev->ns_read + ns)
      break;

    pthread_cond_wait(&dev->available, &dev->synclock);
  }
  while((_Bool)1);
  _Bool tmp_if_expr$1;
  if(!(error == 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(dev->acquiring != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(!(dev->ns_written >= *reqns + dev->ns_read))
      *reqns = dev->ns_written - dev->ns_read;

  }

  dev->nreadwait = (unsigned int)0;
  pthread_mutex_unlock(&dev->synclock);
  return error;
}

// write_data_packet
// file tia-server.c line 131
static signed int write_data_packet(char *buffer)
{
  unsigned int i;
  unsigned int j;
  unsigned int k;
  unsigned int nchtot = (unsigned int)0;
  struct data_hdr *hdr = (struct data_hdr *)buffer;
  unsigned short int *varhdr = (unsigned short int *)(buffer + (signed long int)sizeof(struct data_hdr) /*40ul*/ );
  float *data;
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= 3ul); i = i + 1u)
    nchtot = nchtot + num_sig_ch[(signed long int)i];
  data = (float *)(buffer + (signed long int)sizeof(struct data_hdr) /*40ul*/  + (signed long int)((unsigned long int)2 * sizeof(unsigned short int) /*2ul*/  * (sizeof(const unsigned int [3l]) /*12ul*/  / sizeof(const unsigned int) /*4ul*/ )));
  hdr->version = (unsigned char)3;
  hdr->id = (unsigned long int)0;
  hdr->ts = (unsigned long int)0;
  static unsigned long int packet_num = (unsigned long int)0;
  unsigned long int tmp_post$1 = packet_num;
  packet_num = packet_num + 1ul;
  hdr->number = tmp_post$1;
  hdr->type_flags = type_flags;
  hdr->size = (unsigned int)(sizeof(struct data_hdr) /*40ul*/  + (unsigned long int)2 * sizeof(unsigned short int) /*2ul*/  * (sizeof(const unsigned int [3l]) /*12ul*/  / sizeof(const unsigned int) /*4ul*/ ) + sizeof(float) /*4ul*/  * (unsigned long int)nchtot * (unsigned long int)blocksize);
  i = (unsigned int)0;
  float tmp_if_expr$4;
  float return_value_get_analog_val$2;
  signed int return_value_get_trigger_val$3;
  static unsigned long int sam = (unsigned long int)0;
  for( ; !((unsigned long int)i >= 3ul); i = i + 1u)
  {
    varhdr[(signed long int)i] = (unsigned short int)num_sig_ch[(signed long int)i];
    varhdr[(signed long int)((unsigned long int)i + sizeof(const unsigned int [3l]) /*12ul*/  / sizeof(const unsigned int) /*4ul*/ )] = (unsigned short int)blocksize;
    j = (unsigned int)0;
    for( ; !(j >= blocksize); j = j + 1u)
    {
      k = (unsigned int)0;
      for( ; !(k >= num_sig_ch[(signed long int)i]); k = k + 1u)
      {
        if(!((unsigned long int)i >= 2ul))
        {
          return_value_get_analog_val$2=get_analog_val$link1(sam + (unsigned long int)j, k);
          tmp_if_expr$4 = return_value_get_analog_val$2;
        }

        else
        {
          return_value_get_trigger_val$3=get_trigger_val$link1(sam + (unsigned long int)j, k);
          tmp_if_expr$4 = (float)return_value_get_trigger_val$3;
        }
        data[(signed long int)k] = tmp_if_expr$4;
      }
      data = data + (signed long int)num_sig_ch[(signed long int)i];
    }
  }
  sam = sam + (unsigned long int)blocksize;
  return (signed int)hdr->size;
}

// write_metainfo
// file tia-server.c line 211
static signed int write_metainfo(struct _IO_FILE *fp)
{
  unsigned int i;
  unsigned int j;
  fprintf(fp, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<tiaMetaInfo version=\"1.0\">\n<subject id=\"FAKEID\" firstName=\"John\" lastName=\"Smith\" handedness=\"r\" />\n<masterSignal samplingRate=\"%u\" blockSize=\"%u\" />\n", samplingrate, blocksize);
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= 3ul); i = i + 1u)
  {
    fprintf(fp, "<signal type=\"%s\" blockSize=\"%u\" samplingRate=\"%u\" numChannels=\"%u\">\n", chtype[(signed long int)i], blocksize, samplingrate, num_sig_ch[(signed long int)i]);
    j = (unsigned int)0;
    for( ; !(j >= num_sig_ch[(signed long int)i]); j = j + 1u)
      fprintf(fp, "  <channel label=\"tobi%s:%u\" nr=\"%u\" />\n", chtype[(signed long int)i], j + (unsigned int)1, j + (unsigned int)1);
    fprintf(fp, "</signal>\n");
  }
  fprintf(fp, "</tiaMetaInfo>\n");
  return 0;
}

// xmax
// file xsize.h line 94
inline unsigned long int xmax(unsigned long int size1, unsigned long int size2)
{
  return size1 >= size2 ? size1 : size2;
}

// xsum
// file xsize.h line 63
inline unsigned long int xsum(unsigned long int size1, unsigned long int size2)
{
  unsigned long int sum = size1 + size2;
  return sum >= size1 ? sum : 18446744073709551615UL;
}

// xsum3
// file xsize.h line 74
inline unsigned long int xsum3(unsigned long int size1, unsigned long int size2, unsigned long int size3)
{
  unsigned long int return_value_xsum$1;
  return_value_xsum$1=xsum(size1, size2);
  unsigned long int return_value_xsum$2;
  return_value_xsum$2=xsum(return_value_xsum$1, size3);
  return return_value_xsum$2;
}

// xsum4
// file xsize.h line 84
inline unsigned long int xsum4(unsigned long int size1, unsigned long int size2, unsigned long int size3, unsigned long int size4)
{
  unsigned long int return_value_xsum$1;
  return_value_xsum$1=xsum(size1, size2);
  unsigned long int return_value_xsum$2;
  return_value_xsum$2=xsum(return_value_xsum$1, size3);
  unsigned long int return_value_xsum$3;
  return_value_xsum$3=xsum(return_value_xsum$2, size4);
  return return_value_xsum$3;
}

// yy_fatal_error
// file conffile.lex.c line 1659
static void yy_fatal_error(const char *msg, void *yyscanner)
{
  fprintf(stderr, "%s\n", msg);
  exit(2);
}

// yy_fatal_error$link1
// file confline.lex.c line 1645
static void yy_fatal_error$link1(const char *msg$link1, void *yyscanner$link1)
{
  fprintf(stderr, "%s\n", msg$link1);
  exit(2);
}

// yy_get_next_buffer
// file conffile.lex.c line 1022
static signed int yy_get_next_buffer(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  char *dest = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_ch_buf;
  char *source = yyg->yytext_r;
  signed int number_to_move;
  signed int i;
  signed int ret_val;
  if(!(yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_ch_buf + 1l + (signed long int)yyg->yy_n_chars >= yyg->yy_c_buf_p))
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed", yyscanner);

  char *tmp_post$1;
  char *tmp_post$2;
  _Bool tmp_if_expr$4;
  unsigned long int tmp_post$5;
  signed int return_value_ferror$6;
  signed int return_value_ferror$8;
  if(yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_fill_buffer == 0)
  {
    if(yyg->yy_c_buf_p - yyg->yytext_r == 1l)
      return 1;

    return 2;
  }

  else
  {
    number_to_move = (signed int)(yyg->yy_c_buf_p - yyg->yytext_r) - 1;
    i = 0;
    for( ; !(i >= number_to_move); i = i + 1)
    {
      tmp_post$1 = dest;
      dest = dest + 1l;
      tmp_post$2 = source;
      source = source + 1l;
      *tmp_post$1 = *tmp_post$2;
    }
    if(yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_buffer_status == 2)
    {
      yyg->yy_n_chars = (unsigned long int)0;
      yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_n_chars = yyg->yy_n_chars;
    }

    else
    {
      unsigned long int num_to_read = (yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_buf_size - (unsigned long int)number_to_move) - (unsigned long int)1;
      while(!(num_to_read >= 1ul))
      {
        struct yy_buffer_state *b = yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top];
        signed int yy_c_buf_p_offset = (signed int)(yyg->yy_c_buf_p - b->yy_ch_buf);
        if(!(b->yy_is_our_buffer == 0))
        {
          unsigned long int yy_get_next_buffer$$1$$3$$1$$1$$new_size = b->yy_buf_size * (unsigned long int)2;
          if(!(yy_get_next_buffer$$1$$3$$1$$1$$new_size >= 1ul))
            b->yy_buf_size = b->yy_buf_size + b->yy_buf_size / (unsigned long int)8;

          else
            b->yy_buf_size = b->yy_buf_size * (unsigned long int)2;
          void *return_value_cff_realloc$3;
          return_value_cff_realloc$3=cff_realloc((void *)b->yy_ch_buf, b->yy_buf_size + (unsigned long int)2, yyscanner);
          b->yy_ch_buf = (char *)return_value_cff_realloc$3;
        }

        else
          b->yy_ch_buf = ((char *)NULL);
        if(b->yy_ch_buf == ((char *)NULL))
          yy_fatal_error("fatal error - scanner input buffer overflow", yyscanner);

        yyg->yy_c_buf_p = &b->yy_ch_buf[(signed long int)yy_c_buf_p_offset];
        num_to_read = (yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_buf_size - (unsigned long int)number_to_move) - (unsigned long int)1;
      }
      if(num_to_read >= 8193ul)
        num_to_read = (unsigned long int)8192;

      if(!(yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_is_interactive == 0))
      {
        signed int c = 42;
        unsigned long int n = (unsigned long int)0;
        do
        {
          if(!(n >= num_to_read))
          {
            c=_IO_getc(yyg->yyin_r);
            tmp_if_expr$4 = c != -1 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$4 = (_Bool)0;
          if(c == 10 || !tmp_if_expr$4)
            break;

          (&yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_ch_buf[(signed long int)number_to_move])[(signed long int)n] = (char)c;
          n = n + 1ul;
        }
        while((_Bool)1);
        if(c == 10)
        {
          tmp_post$5 = n;
          n = n + 1ul;
          (&yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_ch_buf[(signed long int)number_to_move])[(signed long int)tmp_post$5] = (char)c;
        }

        if(c == -1)
        {
          return_value_ferror$6=ferror(yyg->yyin_r);
          if(!(return_value_ferror$6 == 0))
            yy_fatal_error("input in flex scanner failed", yyscanner);

        }

        yyg->yy_n_chars = n;
      }

      else
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        *return_value___errno_location$7 = 0;
        do
        {
          yyg->yy_n_chars=fread((void *)&yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_ch_buf[(signed long int)number_to_move], (unsigned long int)1, num_to_read, yyg->yyin_r);
          if(!(yyg->yy_n_chars == 0ul))
            break;

          return_value_ferror$8=ferror(yyg->yyin_r);
          if(return_value_ferror$8 == 0)
            break;

          signed int *return_value___errno_location$9;
          return_value___errno_location$9=__errno_location();
          if(!(*return_value___errno_location$9 == 4))
          {
            yy_fatal_error("input in flex scanner failed", yyscanner);
            break;
          }

          signed int *return_value___errno_location$10;
          return_value___errno_location$10=__errno_location();
          *return_value___errno_location$10 = 0;
          clearerr(yyg->yyin_r);
        }
        while((_Bool)1);
      }
      yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_n_chars = yyg->yy_n_chars;
    }
    if(yyg->yy_n_chars == 0ul)
    {
      if(number_to_move == 0)
      {
        ret_val = 1;
        cff_restart(yyg->yyin_r, yyscanner);
      }

      else
      {
        ret_val = 2;
        yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_buffer_status = 2;
      }
    }

    else
      ret_val = 0;
    if(!(yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_buf_size >= yyg->yy_n_chars + (unsigned long int)number_to_move))
    {
      unsigned long int new_size = yyg->yy_n_chars + (unsigned long int)number_to_move + (yyg->yy_n_chars >> 1);
      void *return_value_cff_realloc$11;
      return_value_cff_realloc$11=cff_realloc((void *)yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_ch_buf, new_size, yyscanner);
      yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_ch_buf = (char *)return_value_cff_realloc$11;
      if(yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_ch_buf == ((char *)NULL))
        yy_fatal_error("out of dynamic memory in yy_get_next_buffer()", yyscanner);

    }

    yyg->yy_n_chars = yyg->yy_n_chars + (unsigned long int)number_to_move;
    yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_ch_buf[(signed long int)yyg->yy_n_chars] = (char)0;
    yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_ch_buf[(signed long int)(yyg->yy_n_chars + (unsigned long int)1)] = (char)0;
    yyg->yytext_r = &yyg->yy_buffer_stack[(signed long int)yyg->yy_buffer_stack_top]->yy_ch_buf[(signed long int)0];
    return ret_val;
  }
}

// yy_get_next_buffer$link1
// file confline.lex.c line 1008
static signed int yy_get_next_buffer$link1(void *yyscanner$link1)
{
  struct yyguts_t *yyg$link1 = (struct yyguts_t *)yyscanner$link1;
  char *dest$link1 = yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_ch_buf;
  char *source$link1 = yyg$link1->yytext_r;
  signed int number_to_move$link1;
  signed int i$link1;
  signed int ret_val$link1;
  if(!(yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_ch_buf + 1l + (signed long int)yyg$link1->yy_n_chars >= yyg$link1->yy_c_buf_p))
    yy_fatal_error$link1("fatal flex scanner internal error--end of buffer missed", yyscanner$link1);

  char *tmp_post$1$link1;
  char *tmp_post$2$link1;
  _Bool tmp_if_expr$4$link1;
  unsigned long int tmp_post$5$link1;
  signed int return_value_ferror$6$link1;
  signed int return_value_ferror$8$link1;
  if(yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_fill_buffer == 0)
  {
    if(yyg$link1->yy_c_buf_p - yyg$link1->yytext_r == 1l)
      return 1;

    return 2;
  }

  else
  {
    number_to_move$link1 = (signed int)(yyg$link1->yy_c_buf_p - yyg$link1->yytext_r) - 1;
    i$link1 = 0;
    for( ; !(i$link1 >= number_to_move$link1); i$link1 = i$link1 + 1)
    {
      tmp_post$1$link1 = dest$link1;
      dest$link1 = dest$link1 + 1l;
      tmp_post$2$link1 = source$link1;
      source$link1 = source$link1 + 1l;
      *tmp_post$1$link1 = *tmp_post$2$link1;
    }
    if(yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_buffer_status == 2)
    {
      yyg$link1->yy_n_chars = (unsigned long int)0;
      yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_n_chars = yyg$link1->yy_n_chars;
    }

    else
    {
      unsigned long int num_to_read$link1 = (yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_buf_size - (unsigned long int)number_to_move$link1) - (unsigned long int)1;
      while(!(num_to_read$link1 >= 1ul))
      {
        struct yy_buffer_state *b$link1 = yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top];
        signed int yy_c_buf_p_offset$link1 = (signed int)(yyg$link1->yy_c_buf_p - b$link1->yy_ch_buf);
        if(!(b$link1->yy_is_our_buffer == 0))
        {
          unsigned long int yy_get_next_buffer$$1$$3$$1$$1$$new_size$link1 = b$link1->yy_buf_size * (unsigned long int)2;
          if(!(yy_get_next_buffer$$1$$3$$1$$1$$new_size$link1 >= 1ul))
            b$link1->yy_buf_size = b$link1->yy_buf_size + b$link1->yy_buf_size / (unsigned long int)8;

          else
            b$link1->yy_buf_size = b$link1->yy_buf_size * (unsigned long int)2;
          void *return_value_cfl_realloc$3;
          return_value_cfl_realloc$3=cfl_realloc((void *)b$link1->yy_ch_buf, b$link1->yy_buf_size + (unsigned long int)2, yyscanner$link1);
          b$link1->yy_ch_buf = (char *)return_value_cfl_realloc$3;
        }

        else
          b$link1->yy_ch_buf = ((char *)NULL);
        if(b$link1->yy_ch_buf == ((char *)NULL))
          yy_fatal_error$link1("fatal error - scanner input buffer overflow", yyscanner$link1);

        yyg$link1->yy_c_buf_p = &b$link1->yy_ch_buf[(signed long int)yy_c_buf_p_offset$link1];
        num_to_read$link1 = (yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_buf_size - (unsigned long int)number_to_move$link1) - (unsigned long int)1;
      }
      if(num_to_read$link1 >= 8193ul)
        num_to_read$link1 = (unsigned long int)8192;

      if(!(yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_is_interactive == 0))
      {
        signed int c$link1 = 42;
        unsigned long int n$link1 = (unsigned long int)0;
        do
        {
          if(!(n$link1 >= num_to_read$link1))
          {
            c$link1=_IO_getc(yyg$link1->yyin_r);
            tmp_if_expr$4$link1 = c$link1 != -1 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$4$link1 = (_Bool)0;
          if(c$link1 == 10 || !tmp_if_expr$4$link1)
            break;

          (&yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_ch_buf[(signed long int)number_to_move$link1])[(signed long int)n$link1] = (char)c$link1;
          n$link1 = n$link1 + 1ul;
        }
        while((_Bool)1);
        if(c$link1 == 10)
        {
          tmp_post$5$link1 = n$link1;
          n$link1 = n$link1 + 1ul;
          (&yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_ch_buf[(signed long int)number_to_move$link1])[(signed long int)tmp_post$5$link1] = (char)c$link1;
        }

        if(c$link1 == -1)
        {
          return_value_ferror$6$link1=ferror(yyg$link1->yyin_r);
          if(!(return_value_ferror$6$link1 == 0))
            yy_fatal_error$link1("input in flex scanner failed", yyscanner$link1);

        }

        yyg$link1->yy_n_chars = n$link1;
      }

      else
      {
        signed int *return_value___errno_location$7$link1;
        return_value___errno_location$7$link1=__errno_location();
        *return_value___errno_location$7$link1 = 0;
        do
        {
          yyg$link1->yy_n_chars=fread((void *)&yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_ch_buf[(signed long int)number_to_move$link1], (unsigned long int)1, num_to_read$link1, yyg$link1->yyin_r);
          if(!(yyg$link1->yy_n_chars == 0ul))
            break;

          return_value_ferror$8$link1=ferror(yyg$link1->yyin_r);
          if(return_value_ferror$8$link1 == 0)
            break;

          signed int *return_value___errno_location$9$link1;
          return_value___errno_location$9$link1=__errno_location();
          if(!(*return_value___errno_location$9$link1 == 4))
          {
            yy_fatal_error$link1("input in flex scanner failed", yyscanner$link1);
            break;
          }

          signed int *return_value___errno_location$10$link1;
          return_value___errno_location$10$link1=__errno_location();
          *return_value___errno_location$10$link1 = 0;
          clearerr(yyg$link1->yyin_r);
        }
        while((_Bool)1);
      }
      yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_n_chars = yyg$link1->yy_n_chars;
    }
    if(yyg$link1->yy_n_chars == 0ul)
    {
      if(number_to_move$link1 == 0)
      {
        ret_val$link1 = 1;
        cfl_restart(yyg$link1->yyin_r, yyscanner$link1);
      }

      else
      {
        ret_val$link1 = 2;
        yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_buffer_status = 2;
      }
    }

    else
      ret_val$link1 = 0;
    if(!(yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_buf_size >= yyg$link1->yy_n_chars + (unsigned long int)number_to_move$link1))
    {
      unsigned long int new_size$link1 = yyg$link1->yy_n_chars + (unsigned long int)number_to_move$link1 + (yyg$link1->yy_n_chars >> 1);
      void *return_value_cfl_realloc$11;
      return_value_cfl_realloc$11=cfl_realloc((void *)yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_ch_buf, new_size$link1, yyscanner$link1);
      yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_ch_buf = (char *)return_value_cfl_realloc$11;
      if(yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_ch_buf == ((char *)NULL))
        yy_fatal_error$link1("out of dynamic memory in yy_get_next_buffer()", yyscanner$link1);

    }

    yyg$link1->yy_n_chars = yyg$link1->yy_n_chars + (unsigned long int)number_to_move$link1;
    yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_ch_buf[(signed long int)yyg$link1->yy_n_chars] = (char)0;
    yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_ch_buf[(signed long int)(yyg$link1->yy_n_chars + (unsigned long int)1)] = (char)0;
    yyg$link1->yytext_r = &yyg$link1->yy_buffer_stack[(signed long int)yyg$link1->yy_buffer_stack_top]->yy_ch_buf[(signed long int)0];
    return ret_val$link1;
  }
}

// yy_get_previous_state
// file conffile.lex.c line 1157
static signed int yy_get_previous_state(void *yyscanner)
{
  signed int yy_current_state;
  char *yy_cp;
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  yy_current_state = yyg->yy_start;
  yy_cp = yyg->yytext_r + (signed long int)0;
  signed int tmp_if_expr$1;
  for( ; !(yy_cp >= yyg->yy_c_buf_p); yy_cp = yy_cp + 1l)
  {
    unsigned char yy_c;
    if(!(*yy_cp == 0))
      tmp_if_expr$1 = yy_ec[(signed long int)(unsigned int)(unsigned char)*yy_cp];

    else
      tmp_if_expr$1 = 1;
    yy_c = (unsigned char)tmp_if_expr$1;
    if(!(yy_accept[(signed long int)yy_current_state] == 0))
    {
      yyg->yy_last_accepting_state = yy_current_state;
      yyg->yy_last_accepting_cpos = yy_cp;
    }

    while(!((signed int)yy_chk[(signed long int)((signed int)yy_base[(signed long int)yy_current_state] + (signed int)yy_c)] == yy_current_state))
    {
      yy_current_state = (signed int)yy_def[(signed long int)yy_current_state];
      if(yy_current_state >= 16)
        yy_c = (unsigned char)yy_meta[(signed long int)(unsigned int)yy_c];

    }
    yy_current_state = (signed int)yy_nxt[(signed long int)((unsigned int)yy_base[(signed long int)yy_current_state] + (unsigned int)yy_c)];
  }
  return yy_current_state;
}

// yy_get_previous_state$link1
// file confline.lex.c line 1143
static signed int yy_get_previous_state$link1(void *yyscanner$link1)
{
  signed int yy_current_state$link1;
  char *yy_cp$link1;
  struct yyguts_t *yyg$link1 = (struct yyguts_t *)yyscanner$link1;
  yy_current_state$link1 = yyg$link1->yy_start;
  yy_cp$link1 = yyg$link1->yytext_r + (signed long int)0;
  signed int tmp_if_expr$1$link1;
  for( ; !(yy_cp$link1 >= yyg$link1->yy_c_buf_p); yy_cp$link1 = yy_cp$link1 + 1l)
  {
    unsigned char yy_c$link1;
    if(!(*yy_cp$link1 == 0))
      tmp_if_expr$1$link1 = yy_ec$link1[(signed long int)(unsigned int)(unsigned char)*yy_cp$link1];

    else
      tmp_if_expr$1$link1 = 1;
    yy_c$link1 = (unsigned char)tmp_if_expr$1$link1;
    if(!(yy_accept$link1[(signed long int)yy_current_state$link1] == 0))
    {
      yyg$link1->yy_last_accepting_state = yy_current_state$link1;
      yyg$link1->yy_last_accepting_cpos = yy_cp$link1;
    }

    while(!((signed int)yy_chk$link1[(signed long int)((signed int)yy_base$link1[(signed long int)yy_current_state$link1] + (signed int)yy_c$link1)] == yy_current_state$link1))
    {
      yy_current_state$link1 = (signed int)yy_def$link1[(signed long int)yy_current_state$link1];
      if(yy_current_state$link1 >= 11)
        yy_c$link1 = (unsigned char)yy_meta$link1[(signed long int)(unsigned int)yy_c$link1];

    }
    yy_current_state$link1 = (signed int)yy_nxt$link1[(signed long int)((unsigned int)yy_base$link1[(signed long int)yy_current_state$link1] + (unsigned int)yy_c$link1)];
  }
  return yy_current_state$link1;
}

// yy_init_globals
// file conffile.lex.c line 1904
static signed int yy_init_globals(void *yyscanner)
{
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  yyg->yy_buffer_stack = ((struct yy_buffer_state **)NULL);
  yyg->yy_buffer_stack_top = (unsigned long int)0;
  yyg->yy_buffer_stack_max = (unsigned long int)0;
  yyg->yy_c_buf_p = (char *)0;
  yyg->yy_init = 0;
  yyg->yy_start = 0;
  yyg->yy_start_stack_ptr = 0;
  yyg->yy_start_stack_depth = 0;
  yyg->yy_start_stack = (signed int *)(void *)0;
  yyg->yyin_r = (struct _IO_FILE *)0;
  yyg->yyout_r = (struct _IO_FILE *)0;
  return 0;
}

// yy_init_globals$link1
// file confline.lex.c line 1890
static signed int yy_init_globals$link1(void *yyscanner$link1)
{
  struct yyguts_t *yyg$link1 = (struct yyguts_t *)yyscanner$link1;
  yyg$link1->yy_buffer_stack = ((struct yy_buffer_state **)NULL);
  yyg$link1->yy_buffer_stack_top = (unsigned long int)0;
  yyg$link1->yy_buffer_stack_max = (unsigned long int)0;
  yyg$link1->yy_c_buf_p = (char *)0;
  yyg$link1->yy_init = 0;
  yyg$link1->yy_start = 0;
  yyg$link1->yy_start_stack_ptr = 0;
  yyg$link1->yy_start_stack_depth = 0;
  yyg$link1->yy_start_stack = (signed int *)(void *)0;
  yyg$link1->yyin_r = (struct _IO_FILE *)0;
  yyg$link1->yyout_r = (struct _IO_FILE *)0;
  return 0;
}

// yy_try_NUL_trans
// file conffile.lex.c line 1190
static signed int yy_try_NUL_trans(signed int yy_current_state, void *yyscanner)
{
  signed int yy_is_jam;
  struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
  char *yy_cp = yyg->yy_c_buf_p;
  unsigned char yy_c = (unsigned char)1;
  if(!(yy_accept[(signed long int)yy_current_state] == 0))
  {
    yyg->yy_last_accepting_state = yy_current_state;
    yyg->yy_last_accepting_cpos = yy_cp;
  }

  while(!((signed int)yy_chk[(signed long int)((signed int)yy_base[(signed long int)yy_current_state] + (signed int)yy_c)] == yy_current_state))
  {
    yy_current_state = (signed int)yy_def[(signed long int)yy_current_state];
    if(yy_current_state >= 16)
      yy_c = (unsigned char)yy_meta[(signed long int)(unsigned int)yy_c];

  }
  yy_current_state = (signed int)yy_nxt[(signed long int)((unsigned int)yy_base[(signed long int)yy_current_state] + (unsigned int)yy_c)];
  yy_is_jam = (signed int)(yy_current_state == 15);
  (void)yyg;
  return yy_is_jam != 0 ? 0 : yy_current_state;
}

// yy_try_NUL_trans$link1
// file confline.lex.c line 1176
static signed int yy_try_NUL_trans$link1(signed int yy_current_state$link1, void *yyscanner$link1)
{
  signed int yy_is_jam$link1;
  struct yyguts_t *yyg$link1 = (struct yyguts_t *)yyscanner$link1;
  char *yy_cp$link1 = yyg$link1->yy_c_buf_p;
  unsigned char yy_c$link1 = (unsigned char)1;
  if(!(yy_accept$link1[(signed long int)yy_current_state$link1] == 0))
  {
    yyg$link1->yy_last_accepting_state = yy_current_state$link1;
    yyg$link1->yy_last_accepting_cpos = yy_cp$link1;
  }

  while(!((signed int)yy_chk$link1[(signed long int)((signed int)yy_base$link1[(signed long int)yy_current_state$link1] + (signed int)yy_c$link1)] == yy_current_state$link1))
  {
    yy_current_state$link1 = (signed int)yy_def$link1[(signed long int)yy_current_state$link1];
    if(yy_current_state$link1 >= 11)
      yy_c$link1 = (unsigned char)yy_meta$link1[(signed long int)(unsigned int)yy_c$link1];

  }
  yy_current_state$link1 = (signed int)yy_nxt$link1[(signed long int)((unsigned int)yy_base$link1[(signed long int)yy_current_state$link1] + (unsigned int)yy_c$link1)];
  yy_is_jam$link1 = (signed int)(yy_current_state$link1 == 10);
  (void)yyg$link1;
  return yy_is_jam$link1 != 0 ? 0 : yy_current_state$link1;
}

// yydestruct
// file conffile.tab.c line 956
static void yydestruct(const char *yymsg, signed int yytype, union value *yyvaluep, struct cfdata *pp)
{
  (void)yyvaluep;
  (void)pp;
  if(yymsg == ((const char *)NULL))
    yymsg = "Deleting";

  (void)yytype;
}

// yydestruct$link1
// file confline.tab.c line 958
static void yydestruct$link1(const char *yymsg$link1, signed int yytype$link1, union value *yyvaluep$link1, struct cfldata *pp$link1)
{
  (void)yyvaluep$link1;
  (void)pp$link1;
  if(yymsg$link1 == ((const char *)NULL))
    yymsg$link1 = "Deleting";

  (void)yytype$link1;
}

