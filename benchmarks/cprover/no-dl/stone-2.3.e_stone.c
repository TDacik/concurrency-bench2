// tag-#anon#ST[*{SYM#tag-X509_sig_st#}$SYM#tag-X509_sig_st#$'dinfo'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'salt'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'iter'|]
// file /usr/include/openssl/pkcs12.h line 102
struct anonymous;

// tag-#anon#ST[*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'version'||*{SYM#tag-#anon#ST[*{SYM#tag-X509_sig_st#}$SYM#tag-X509_sig_st#$'dinfo'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'salt'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'iter'|]#}$SYM#tag-#anon#ST[*{SYM#tag-X509_sig_st#}$SYM#tag-X509_sig_st#$'dinfo'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'salt'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'iter'|]#$'mac'||*{SYM#tag-pkcs7_st#}$SYM#tag-pkcs7_st#$'authsafes'|]
// file /usr/include/openssl/pkcs12.h line 108
struct anonymous$24;

// tag-#anon#ST[ARR128{U8}$U8$'cert_verify_md'||ARR128{U8}$U8$'finish_md'||S32'finish_md_len'||ARR128{U8}$U8$'peer_finish_md'||S32'peer_finish_md_len'||U64'message_size'||S32'message_type'||U32'$pad0'||*{cSYM#tag-ssl_cipher_st#}$cSYM#tag-ssl_cipher_st#$'new_cipher'||*{SYM#tag-dh_st#}$SYM#tag-dh_st#$'dh'||*{SYM#tag-ec_key_st#}$SYM#tag-ec_key_st#$'ecdh'||S32'next_state'||S32'reuse_message'||S32'cert_req'||S32'ctype_num'||ARR9{S8}$S8$'ctype'||U56'$pad1'||*{SYM#tag-stack_st_X509_NAME#}$SYM#tag-stack_st_X509_NAME#$'ca_names'||S32'use_rsa_tmp'||S32'key_block_length'||*{U8}$U8$'key_block'||*{cSYM#tag-evp_cipher_st#}$cSYM#tag-evp_cipher_st#$'new_sym_enc'||*{cSYM#tag-env_md_st#}$cSYM#tag-env_md_st#$'new_hash'||S32'new_mac_pkey_type'||S32'new_mac_secret_size'||*{cSYM#tag-ssl_comp_st#}$cSYM#tag-ssl_comp_st#$'new_compression'||S32'cert_request'||U32'$pad2'|]
// file /usr/include/openssl/ssl3.h line 553
struct anonymous$16;

// tag-#anon#ST[BF{U32}$U32$'__w_stopval'||BF{U32}$U32$'__w_stopsig'||BF{U32}$U32$'$anon0'|]
// file /usr/include/x86_64-linux-gnu/bits/waitstatus.h line 84
struct anonymous$14;

// tag-#anon#ST[BF{U32}$U32$'__w_termsig'||BF{U32}$U32$'__w_coredump'||BF{U32}$U32$'__w_retcode'||BF{U32}$U32$'$anon0'|]
// file /usr/include/x86_64-linux-gnu/bits/waitstatus.h line 69
struct anonymous$13;

// tag-#anon#ST[S32'rm_so'||S32'rm_eo'|]
// file /usr/include/regex.h line 452
struct anonymous$19;

// tag-#anon#ST[S32'sess_connect'||S32'sess_connect_renegotiate'||S32'sess_connect_good'||S32'sess_accept'||S32'sess_accept_renegotiate'||S32'sess_accept_good'||S32'sess_miss'||S32'sess_timeout'||S32'sess_cache_full'||S32'sess_hit'||S32'sess_cb_hit'|]
// file /usr/include/openssl/ssl.h line 964
struct anonymous$23;

// tag-#anon#ST[S32'verbose'||S32'shutdown_mode'||S32'depth'||U32'$pad0'||S64'serial'||*{SYM#tag-ssl_ctx_st#}$SYM#tag-ssl_ctx_st#$'ctx'||ARR10{*{SYM#tag-re_pattern_buffer#}$SYM#tag-re_pattern_buffer#$}$*{SYM#tag-re_pattern_buffer#}$SYM#tag-re_pattern_buffer#$$'re'||*{S8}$S8$'name'||U8'lbmod'||U8'lbparm'||U8'sslparm'||U40'$pad1'|]
// file stone.c line 327
struct anonymous$12;

// tag-#anon#ST[S32'verbose'||S32'shutdown_mode'||S32'mode'||S32'depth'||S32'vflags'||U32'$pad0'||S64'off'||S64'serial'||*{SYM#tag-ssl_method_st#}$SYM#tag-ssl_method_st#$'meth'||*{S32(S32|*{SYM#tag-x509_store_ctx_st#}$SYM#tag-x509_store_ctx_st#$)->S32}$S32(S32|*{SYM#tag-x509_store_ctx_st#}$SYM#tag-x509_store_ctx_st#$)->S32$'callback'||*{U8}$U8$'sid_ctx'||S32'useSNI'||U32'$pad1'||*{S8}$S8$'keyFile'||*{S8}$S8$'certFile'||*{S8}$S8$'keyFilePat'||*{S8}$S8$'certFilePat'||*{S8}$S8$'caFile'||*{S8}$S8$'caPath'||*{S8}$S8$'pfxFile'||*{S8}$S8$'pfxFilePat'||*{S8}$S8$'passFile'||*{S8}$S8$'passFilePat'||*{S8}$S8$'passwd'||*{S8}$S8$'servername'||S32'certIgnore'||U32'$pad2'||*{S8}$S8$'cipherList'||ARR10{*{S8}$S8$}$*{S8}$S8$$'regexp'||U8'lbmod'||U8'lbparm'||U48'$pad3'|]
// file stone.c line 344
struct anonymous$8;

// tag-#anon#ST[U32'conn_id_length'||U32'cert_type'||U32'cert_length'||U32'csl'||U32'clear'||U32'enc'||ARR32{U8}$U8$'ccl'||U32'cipher_spec_length'||U32'session_id_length'||U32'clen'||U32'rlen'|]
// file /usr/include/openssl/ssl2.h line 203
struct anonymous$15;

// tag-#anon#ST[U32'len'||SYM#tag-sockaddr#'addr'|]
// file stone.c line 422
struct anonymous$0;

// tag-#anon#UN[*{S32}$S32$'inherit'||*{SYM#tag-stack_st_ASIdOrRange#}$SYM#tag-stack_st_ASIdOrRange#$'asIdsOrRanges'|]
// file /usr/include/openssl/x509v3.h line 783
union anonymous$4;

// tag-#anon#UN[*{S8}$S8$'ptr'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'data'||*{SYM#tag-pkcs7_signed_st#}$SYM#tag-pkcs7_signed_st#$'sign'||*{SYM#tag-pkcs7_enveloped_st#}$SYM#tag-pkcs7_enveloped_st#$'enveloped'||*{SYM#tag-pkcs7_signedandenveloped_st#}$SYM#tag-pkcs7_signedandenveloped_st#$'signed_and_enveloped'||*{SYM#tag-pkcs7_digest_st#}$SYM#tag-pkcs7_digest_st#$'digest'||*{SYM#tag-pkcs7_encrypted_st#}$SYM#tag-pkcs7_encrypted_st#$'encrypted'||*{SYM#tag-asn1_type_st#}$SYM#tag-asn1_type_st#$'other'|]
// file /usr/include/openssl/pkcs7.h line 183
union anonymous$11;

// tag-#anon#UN[*{S8}$S8$'ptr'||*{SYM#tag-otherName_st#}$SYM#tag-otherName_st#$'otherName'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'rfc822Name'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'dNSName'||*{SYM#tag-asn1_type_st#}$SYM#tag-asn1_type_st#$'x400Address'||*{SYM#tag-X509_name_st#}$SYM#tag-X509_name_st#$'directoryName'||*{SYM#tag-EDIPartyName_st#}$SYM#tag-EDIPartyName_st#$'ediPartyName'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'uniformResourceIdentifier'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'iPAddress'||*{SYM#tag-asn1_object_st#}$SYM#tag-asn1_object_st#$'registeredID'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'ip'||*{SYM#tag-X509_name_st#}$SYM#tag-X509_name_st#$'dirn'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'ia5'||*{SYM#tag-asn1_object_st#}$SYM#tag-asn1_object_st#$'rid'||*{SYM#tag-asn1_type_st#}$SYM#tag-asn1_type_st#$'other'|]
// file /usr/include/openssl/x509v3.h line 188
union anonymous$20;

// tag-#anon#UN[*{S8}$S8$'ptr'||*{SYM#tag-rsa_st#}$SYM#tag-rsa_st#$'rsa'||*{SYM#tag-dsa_st#}$SYM#tag-dsa_st#$'dsa'||*{SYM#tag-dh_st#}$SYM#tag-dh_st#$'dh'||*{SYM#tag-ec_key_st#}$SYM#tag-ec_key_st#$'ec'|]
// file /usr/include/openssl/evp.h line 135
union anonymous$22;

// tag-#anon#UN[*{S8}$S8$'ptr'||S32'boolean'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'asn1_string'||*{SYM#tag-asn1_object_st#}$SYM#tag-asn1_object_st#$'object'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'integer'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'enumerated'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'bit_string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'octet_string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'printablestring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'t61string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'ia5string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'generalstring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'bmpstring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'universalstring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'utctime'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'generalizedtime'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'visiblestring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'utf8string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'set'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'sequence'||*{SYM#tag-ASN1_VALUE_st#}$SYM#tag-ASN1_VALUE_st#$'asn1_value'|]
// file /usr/include/openssl/asn1.h line 526
union anonymous$7;

// tag-#anon#UN[*{SYM#tag-stack_st_GENERAL_NAME#}$SYM#tag-stack_st_GENERAL_NAME#$'fullname'||*{SYM#tag-stack_st_X509_NAME_ENTRY#}$SYM#tag-stack_st_X509_NAME_ENTRY#$'relativename'|]
// file /usr/include/openssl/x509v3.h line 228
union anonymous$25;

// tag-#anon#UN[*{SYM#tag-wait#}$SYM#tag-wait#$'__uptr'||*{S32}$S32$'__iptr'|]
// file /usr/include/stdlib.h line 67
union anonymous$10;

// tag-#anon#UN[*{SYM#tag-wait#}$SYM#tag-wait#$'__uptr'||*{S32}$S32$'__iptr'|]$transparent
// file /usr/include/stdlib.h line 67
union anonymous$1;

// tag-#anon#UN[*{V(S32|S32|*{V}$V$)->V}$V(S32|S32|*{V}$V$)->V$'cb_1'||*{S32(S32|S32|*{SYM#tag-bn_gencb_st#}$SYM#tag-bn_gencb_st#$)->S32}$S32(S32|S32|*{SYM#tag-bn_gencb_st#}$SYM#tag-bn_gencb_st#$)->S32$'cb_2'|]
// file /usr/include/openssl/bn.h line 351
union anonymous$21;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$9;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$17;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$3;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$5;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$2;

// tag-ASIdentifierChoice_st
// file /usr/include/openssl/x509v3.h line 781
struct ASIdentifierChoice_st;

// tag-ASIdentifiers_st
// file /usr/include/openssl/x509.h line 293
struct ASIdentifiers_st;

// tag-ASN1_ENCODING_st
// file /usr/include/openssl/asn1.h line 257
struct ASN1_ENCODING_st;

// tag-ASN1_VALUE_st
// file /usr/include/openssl/asn1.h line 299
struct ASN1_VALUE_st;

// tag-AUTHORITY_KEYID_st
// file /usr/include/openssl/ossl_typ.h line 186
struct AUTHORITY_KEYID_st;

// tag-DIST_POINT_NAME_st
// file /usr/include/openssl/x509v3.h line 226
struct DIST_POINT_NAME_st;

// tag-DSA_SIG_st
// file /usr/include/openssl/dsa.h line 124
struct DSA_SIG_st;

// tag-EDIPartyName_st
// file /usr/include/openssl/x509v3.h line 172
struct EDIPartyName_st;

// tag-GENERAL_NAME_st
// file /usr/include/openssl/x509v3.h line 177
struct GENERAL_NAME_st;

// tag-ISSUING_DIST_POINT_st
// file /usr/include/openssl/ossl_typ.h line 188
struct ISSUING_DIST_POINT_st;

// tag-NAME_CONSTRAINTS_st
// file /usr/include/openssl/ossl_typ.h line 189
struct NAME_CONSTRAINTS_st;

// tag-X509_POLICY_CACHE_st
// file /usr/include/openssl/ossl_typ.h line 184
struct X509_POLICY_CACHE_st;

// tag-X509_POLICY_TREE_st
// file /usr/include/openssl/ossl_typ.h line 183
struct X509_POLICY_TREE_st;

// tag-X509_VERIFY_PARAM_ID_st
// file /usr/include/openssl/x509_vfy.h line 159
struct X509_VERIFY_PARAM_ID_st;

// tag-X509_VERIFY_PARAM_st
// file /usr/include/openssl/x509_vfy.h line 167
struct X509_VERIFY_PARAM_st;

// tag-X509_algor_st
// file /usr/include/openssl/ossl_typ.h line 155
struct X509_algor_st;

// tag-X509_crl_info_st
// file /usr/include/openssl/x509.h line 441
struct X509_crl_info_st;

// tag-X509_crl_st
// file /usr/include/openssl/ossl_typ.h line 156
struct X509_crl_st;

// tag-X509_extension_st
// file /usr/include/openssl/x509.h line 196
struct X509_extension_st;

// tag-X509_name_st
// file /usr/include/openssl/ossl_typ.h line 159
struct X509_name_st;

// tag-X509_pubkey_st
// file /usr/include/openssl/ossl_typ.h line 160
struct X509_pubkey_st;

// tag-X509_sig_st
// file /usr/include/openssl/x509.h line 163
struct X509_sig_st;

// tag-X509_val_st
// file /usr/include/openssl/x509.h line 152
struct X509_val_st;

// tag-_Backup
// file stone.c line 449
struct _Backup;

// tag-_Chat
// file stone.c line 415
struct _Chat;

// tag-_Comm
// file stone.c line 576
struct _Comm;

// tag-_Conn
// file stone.c line 548
struct _Conn;

// tag-_ExBuf
// file stone.c line 514
struct _ExBuf;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_LBSet
// file stone.c line 463
struct _LBSet;

// tag-_Origin
// file stone.c line 555
struct _Origin;

// tag-_Pair
// file stone.c line 486
struct _Pair;

// tag-_PktBuf
// file stone.c line 566
struct _PktBuf;

// tag-_PortXHosts
// file stone.c line 443
struct _PortXHosts;

// tag-_Stone
// file stone.c line 476
struct _Stone;

// tag-_TimeLog
// file stone.c line 500
struct _TimeLog;

// tag-_XHosts
// file stone.c line 428
struct _XHosts;

// tag-_XPorts
// file stone.c line 437
struct _XPorts;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_pqueue
// file /usr/include/openssl/pqueue.h line 70
struct _pqueue;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-asn1_object_st
// file /usr/include/openssl/ossl_typ.h line 103
struct asn1_object_st;

// tag-asn1_string_st
// file /usr/include/openssl/ossl_typ.h line 83
struct asn1_string_st;

// tag-asn1_type_st
// file /usr/include/openssl/asn1.h line 524
struct asn1_type_st;

// tag-bignum_ctx
// file /usr/include/openssl/ossl_typ.h line 121
struct bignum_ctx;

// tag-bignum_st
// file /usr/include/openssl/ossl_typ.h line 120
struct bignum_st;

// tag-bio_method_st
// file /usr/include/openssl/bio.h line 312
struct bio_method_st;

// tag-bio_st
// file /usr/include/openssl/crypto.h line 290
struct bio_st;

// tag-bn_blinding_st
// file /usr/include/openssl/ossl_typ.h line 122
struct bn_blinding_st;

// tag-bn_gencb_st
// file /usr/include/openssl/ossl_typ.h line 125
struct bn_gencb_st;

// tag-bn_mont_ctx_st
// file /usr/include/openssl/ossl_typ.h line 123
struct bn_mont_ctx_st;

// tag-buf_mem_st
// file /usr/include/openssl/ossl_typ.h line 127
struct buf_mem_st;

// tag-cert_st
// file /usr/include/openssl/ssl.h line 1035
struct cert_st;

// tag-comp_ctx_st
// file /usr/include/openssl/comp.h line 11
struct comp_ctx_st;

// tag-comp_method_st
// file /usr/include/openssl/comp.h line 13
struct comp_method_st;

// tag-crypto_ex_data_st
// file /usr/include/openssl/ossl_typ.h line 195
struct crypto_ex_data_st;

// tag-dh_method
// file /usr/include/openssl/ossl_typ.h line 141
struct dh_method;

// tag-dh_st
// file /usr/include/openssl/ossl_typ.h line 140
struct dh_st;

// tag-dsa_method
// file /usr/include/openssl/ossl_typ.h line 144
struct dsa_method;

// tag-dsa_st
// file /usr/include/openssl/ossl_typ.h line 143
struct dsa_st;

// tag-dtls1_bitmap_st
// file /usr/include/openssl/dtls1.h line 128
struct dtls1_bitmap_st;

// tag-dtls1_retransmit_state
// file /usr/include/openssl/dtls1.h line 135
struct dtls1_retransmit_state;

// tag-dtls1_state_st
// file /usr/include/openssl/ssl.h line 1493
struct dtls1_state_st;

// tag-dtls1_timeout_st
// file /usr/include/openssl/dtls1.h line 162
struct dtls1_timeout_st;

// tag-ec_key_st
// file /usr/include/openssl/evp.h line 147
struct ec_key_st;

// tag-engine_st
// file /usr/include/openssl/ossl_typ.h line 177
struct engine_st;

// tag-env_md_ctx_st
// file /usr/include/openssl/ossl_typ.h line 132
struct env_md_ctx_st;

// tag-env_md_st
// file /usr/include/openssl/ossl_typ.h line 131
struct env_md_st;

// tag-epoll_data
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 79
union epoll_data;

// tag-epoll_event
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 87
struct epoll_event;

// tag-evp_cipher_ctx_st
// file /usr/include/openssl/ossl_typ.h line 130
struct evp_cipher_ctx_st;

// tag-evp_cipher_st
// file /usr/include/openssl/ossl_typ.h line 129
struct evp_cipher_st;

// tag-evp_pkey_asn1_method_st
// file /usr/include/openssl/ossl_typ.h line 135
struct evp_pkey_asn1_method_st;

// tag-evp_pkey_ctx_st
// file /usr/include/openssl/ossl_typ.h line 138
struct evp_pkey_ctx_st;

// tag-evp_pkey_st
// file /usr/include/openssl/ossl_typ.h line 133
struct evp_pkey_st;

// tag-group
// file /usr/include/grp.h line 42
struct group;

// tag-hm_header_st
// file /usr/include/openssl/dtls1.h line 147
struct hm_header_st;

// tag-hmac_ctx_st
// file /usr/include/openssl/hmac.h line 75
struct hmac_ctx_st;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-lhash_st_SSL_SESSION
// file /usr/include/openssl/ssl.h line 923
struct lhash_st_SSL_SESSION;

// tag-otherName_st
// file /usr/include/openssl/x509v3.h line 167
struct otherName_st;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pkcs7_digest_st
// file /usr/include/openssl/pkcs7.h line 153
struct pkcs7_digest_st;

// tag-pkcs7_enc_content_st
// file /usr/include/openssl/pkcs7.h line 130
struct pkcs7_enc_content_st;

// tag-pkcs7_encrypted_st
// file /usr/include/openssl/pkcs7.h line 160
struct pkcs7_encrypted_st;

// tag-pkcs7_enveloped_st
// file /usr/include/openssl/pkcs7.h line 137
struct pkcs7_enveloped_st;

// tag-pkcs7_signed_st
// file /usr/include/openssl/pkcs7.h line 117
struct pkcs7_signed_st;

// tag-pkcs7_signedandenveloped_st
// file /usr/include/openssl/pkcs7.h line 143
struct pkcs7_signedandenveloped_st;

// tag-pkcs7_st
// file /usr/include/openssl/pkcs7.h line 123
struct pkcs7_st;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-record_pqueue_st
// file /usr/include/openssl/dtls1.h line 171
struct record_pqueue_st;

// tag-rsa_meth_st
// file /usr/include/openssl/ossl_typ.h line 147
struct rsa_meth_st;

// tag-rsa_st
// file /usr/include/openssl/ossl_typ.h line 146
struct rsa_st;

// tag-sess_cert_st
// file /usr/include/openssl/ssl.h line 531
struct sess_cert_st;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-srp_ctx_st
// file /usr/include/openssl/ssl.h line 849
struct srp_ctx_st;

// tag-srtp_protection_profile_st
// file /usr/include/openssl/ssl.h line 383
struct srtp_protection_profile_st;

// tag-ssl2_state_st
// file /usr/include/openssl/ssl.h line 1491
struct ssl2_state_st;

// tag-ssl3_buf_freelist_st
// file /usr/include/openssl/ssl.h line 1114
struct ssl3_buf_freelist_st;

// tag-ssl3_buffer_st
// file /usr/include/openssl/ssl3.h line 438
struct ssl3_buffer_st;

// tag-ssl3_enc_method
// file /usr/include/openssl/ssl.h line 466
struct ssl3_enc_method;

// tag-ssl3_record_st
// file /usr/include/openssl/ssl3.h line 403
struct ssl3_record_st;

// tag-ssl3_state_st
// file /usr/include/openssl/ssl.h line 1492
struct ssl3_state_st;

// tag-ssl_cipher_st
// file /usr/include/openssl/ssl.h line 375
struct ssl_cipher_st;

// tag-ssl_comp_st
// file /usr/include/openssl/ssl.h line 908
struct ssl_comp_st;

// tag-ssl_ctx_st
// file /usr/include/openssl/ossl_typ.h line 179
struct ssl_ctx_st;

// tag-ssl_method_st
// file /usr/include/openssl/ssl.h line 374
struct ssl_method_st;

// tag-ssl_session_st
// file /usr/include/openssl/ssl.h line 376
struct ssl_session_st;

// tag-ssl_st
// file /usr/include/openssl/ossl_typ.h line 178
struct ssl_st;

// tag-stack_st
// file /usr/include/openssl/stack.h line 66
struct stack_st;

// tag-stack_st_ASIdOrRange
// file /usr/include/openssl/x509v3.h line 775
struct stack_st_ASIdOrRange;

// tag-stack_st_ASN1_OBJECT
// file /usr/include/openssl/asn1.h line 793
struct stack_st_ASN1_OBJECT;

// tag-stack_st_DIST_POINT
// file /usr/include/openssl/x509.h line 288
struct stack_st_DIST_POINT;

// tag-stack_st_GENERAL_NAME
// file /usr/include/openssl/x509.h line 289
struct stack_st_GENERAL_NAME;

// tag-stack_st_GENERAL_NAMES
// file /usr/include/openssl/x509.h line 471
struct stack_st_GENERAL_NAMES;

// tag-stack_st_GENERAL_SUBTREE
// file /usr/include/openssl/x509v3.h line 330
struct stack_st_GENERAL_SUBTREE;

// tag-stack_st_IPAddressFamily
// file /usr/include/openssl/x509.h line 292
struct stack_st_IPAddressFamily;

// tag-stack_st_OCSP_RESPID
// file /usr/include/openssl/ssl.h line 1610
struct stack_st_OCSP_RESPID;

// tag-stack_st_PKCS7_RECIP_INFO
// file /usr/include/openssl/pkcs7.h line 114
struct stack_st_PKCS7_RECIP_INFO;

// tag-stack_st_PKCS7_SIGNER_INFO
// file /usr/include/openssl/pkcs7.h line 103
struct stack_st_PKCS7_SIGNER_INFO;

// tag-stack_st_SRTP_PROTECTION_PROFILE
// file /usr/include/openssl/ssl.h line 388
struct stack_st_SRTP_PROTECTION_PROFILE;

// tag-stack_st_SSL_CIPHER
// file /usr/include/openssl/ssl.h line 380
struct stack_st_SSL_CIPHER;

// tag-stack_st_SSL_COMP
// file /usr/include/openssl/ssl.h line 922
struct stack_st_SSL_COMP;

// tag-stack_st_X509
// file /usr/include/openssl/x509.h line 301
struct stack_st_X509;

// tag-stack_st_X509_ALGOR
// file /usr/include/openssl/asn1.h line 162
struct stack_st_X509_ALGOR;

// tag-stack_st_X509_ATTRIBUTE
// file /usr/include/openssl/evp.h line 151
struct stack_st_X509_ATTRIBUTE;

// tag-stack_st_X509_CRL
// file /usr/include/openssl/x509.h line 476
struct stack_st_X509_CRL;

// tag-stack_st_X509_EXTENSION
// file /usr/include/openssl/x509.h line 202
struct stack_st_X509_EXTENSION;

// tag-stack_st_X509_LOOKUP
// file /usr/include/openssl/x509_vfy.h line 136
struct stack_st_X509_LOOKUP;

// tag-stack_st_X509_NAME
// file /usr/include/openssl/x509.h line 192
struct stack_st_X509_NAME;

// tag-stack_st_X509_NAME_ENTRY
// file /usr/include/openssl/x509.h line 175
struct stack_st_X509_NAME_ENTRY;

// tag-stack_st_X509_OBJECT
// file /usr/include/openssl/x509_vfy.h line 137
struct stack_st_X509_OBJECT;

// tag-stack_st_X509_REVOKED
// file /usr/include/openssl/x509.h line 438
struct stack_st_X509_REVOKED;

// tag-stack_st_void
// file /usr/include/openssl/crypto.h line 293
struct stack_st_void;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tls_session_ticket_ext_st
// file /usr/include/openssl/ssl.h line 373
struct tls_session_ticket_ext_st;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-ucred
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 311
struct ucred;

// tag-wait
// file /usr/include/x86_64-linux-gnu/bits/waitstatus.h line 66
union wait;

// tag-x509_cert_aux_st
// file /usr/include/openssl/x509.h line 262
struct x509_cert_aux_st;

// tag-x509_cinf_st
// file /usr/include/openssl/x509.h line 242
struct x509_cinf_st;

// tag-x509_crl_method_st
// file /usr/include/openssl/ossl_typ.h line 157
struct x509_crl_method_st;

// tag-x509_st
// file /usr/include/openssl/ossl_typ.h line 154
struct x509_st;

// tag-x509_store_ctx_st
// file /usr/include/openssl/ossl_typ.h line 162
struct x509_store_ctx_st;

// tag-x509_store_st
// file /usr/include/openssl/ossl_typ.h line 161
struct x509_store_st;

#ifndef NULL
#define NULL ((void*)0)
#endif

// ASN1_INTEGER_get
// file /usr/include/openssl/asn1.h line 928
signed long int ASN1_INTEGER_get(const struct asn1_string_st *);
// CRYPTO_num_locks
// file /usr/include/openssl/crypto.h line 435
signed int CRYPTO_num_locks(void);
// CRYPTO_set_ex_data
// file /usr/include/openssl/crypto.h line 425
signed int CRYPTO_set_ex_data(struct crypto_ex_data_st *, signed int, void *);
// CRYPTO_set_id_callback
// file /usr/include/openssl/crypto.h line 462
void CRYPTO_set_id_callback(unsigned long int (*)(void));
// CRYPTO_set_locking_callback
// file /usr/include/openssl/crypto.h line 437
void CRYPTO_set_locking_callback(void (*)(signed int, signed int, const char *, signed int));
// ERR_error_string
// file /usr/include/openssl/err.h line 334
char * ERR_error_string(unsigned long int, char *);
// ERR_get_error
// file /usr/include/openssl/err.h line 321
unsigned long int ERR_get_error(void);
// ERR_remove_state
// file /usr/include/openssl/err.h line 357
void ERR_remove_state(unsigned long int);
// EVP_PKEY_free
// file /usr/include/openssl/evp.h line 981
void EVP_PKEY_free(struct evp_pkey_st *);
// GENERAL_NAME_free
// file /usr/include/openssl/x509v3.h line 525
void GENERAL_NAME_free(struct GENERAL_NAME_st *);
// OPENSSL_add_all_algorithms_noconf
// file /usr/include/openssl/evp.h line 905
void OPENSSL_add_all_algorithms_noconf(void);
// PKCS12_free
// file /usr/include/openssl/pkcs12.h line 246
void PKCS12_free(struct anonymous$24 *);
// PKCS12_parse
// file /usr/include/openssl/pkcs12.h line 255
signed int PKCS12_parse(struct anonymous$24 *, const char *, struct evp_pkey_st **, struct x509_st **, struct stack_st_X509 **);
// RAND_poll
// file /usr/include/openssl/rand.h line 112
signed int RAND_poll(void);
// RAND_seed
// file /usr/include/openssl/rand.h line 103
void RAND_seed(const void *, signed int);
// RAND_status
// file /usr/include/openssl/rand.h line 108
signed int RAND_status(void);
// SSL_CIPHER_get_name
// file /usr/include/openssl/ssl.h line 2145
const char * SSL_CIPHER_get_name(const struct ssl_cipher_st *);
// SSL_CTX_callback_ctrl
// file /usr/include/openssl/ssl.h line 2340
signed long int SSL_CTX_callback_ctrl(struct ssl_ctx_st *, signed int, void (*)(void));
// SSL_CTX_ctrl
// file /usr/include/openssl/ssl.h line 2339
signed long int SSL_CTX_ctrl(struct ssl_ctx_st *, signed int, signed long int, void *);
// SSL_CTX_flush_sessions
// file /usr/include/openssl/ssl.h line 2140
void SSL_CTX_flush_sessions(struct ssl_ctx_st *, signed long int);
// SSL_CTX_free
// file /usr/include/openssl/ssl.h line 2132
void SSL_CTX_free(struct ssl_ctx_st *);
// SSL_CTX_get_cert_store
// file /usr/include/openssl/ssl.h line 2135
struct x509_store_st * SSL_CTX_get_cert_store(const struct ssl_ctx_st *);
// SSL_CTX_load_verify_locations
// file /usr/include/openssl/ssl.h line 2442
signed int SSL_CTX_load_verify_locations(struct ssl_ctx_st *, const char *, const char *);
// SSL_CTX_new
// file /usr/include/openssl/ssl.h line 2131
struct ssl_ctx_st * SSL_CTX_new(const struct ssl_method_st *);
// SSL_CTX_set_cipher_list
// file /usr/include/openssl/ssl.h line 2130
signed int SSL_CTX_set_cipher_list(struct ssl_ctx_st *, const char *);
// SSL_CTX_set_default_passwd_cb
// file /usr/include/openssl/ssl.h line 2282
void SSL_CTX_set_default_passwd_cb(struct ssl_ctx_st *, signed int (*)(char *, signed int, signed int, void *));
// SSL_CTX_set_default_passwd_cb_userdata
// file /usr/include/openssl/ssl.h line 2283
void SSL_CTX_set_default_passwd_cb_userdata(struct ssl_ctx_st *, void *);
// SSL_CTX_set_session_id_context
// file /usr/include/openssl/ssl.h line 2288
signed int SSL_CTX_set_session_id_context(struct ssl_ctx_st *, const unsigned char *, unsigned int);
// SSL_CTX_set_verify
// file /usr/include/openssl/ssl.h line 2262
void SSL_CTX_set_verify(struct ssl_ctx_st *, signed int, signed int (*)(signed int, struct x509_store_ctx_st *));
// SSL_CTX_set_verify_depth
// file /usr/include/openssl/ssl.h line 2264
void SSL_CTX_set_verify_depth(struct ssl_ctx_st *, signed int);
// SSL_CTX_use_PrivateKey
// file /usr/include/openssl/ssl.h line 2275
signed int SSL_CTX_use_PrivateKey(struct ssl_ctx_st *, struct evp_pkey_st *);
// SSL_CTX_use_PrivateKey_file
// file /usr/include/openssl/ssl.h line 2199
signed int SSL_CTX_use_PrivateKey_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_CTX_use_certificate
// file /usr/include/openssl/ssl.h line 2278
signed int SSL_CTX_use_certificate(struct ssl_ctx_st *, struct x509_st *);
// SSL_CTX_use_certificate_file
// file /usr/include/openssl/ssl.h line 2200
signed int SSL_CTX_use_certificate_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_SESSION_free
// file /usr/include/openssl/ssl.h line 2240
void SSL_SESSION_free(struct ssl_session_st *);
// SSL_SESSION_get_ex_data
// file /usr/include/openssl/ssl.h line 2465
void * SSL_SESSION_get_ex_data(const struct ssl_session_st *, signed int);
// SSL_SESSION_get_ex_new_index
// file /usr/include/openssl/ssl.h line 2466
signed int SSL_SESSION_get_ex_new_index(signed long int, void *, signed int (*)(void *, void *, struct crypto_ex_data_st *, signed int, signed long int, void *), signed int (*)(struct crypto_ex_data_st *, struct crypto_ex_data_st *, void *, signed int, signed long int, void *), void (*)(void *, void *, struct crypto_ex_data_st *, signed int, signed long int, void *));
// SSL_accept
// file /usr/include/openssl/ssl.h line 2332
signed int SSL_accept(struct ssl_st *);
// SSL_connect
// file /usr/include/openssl/ssl.h line 2333
signed int SSL_connect(struct ssl_st *);
// SSL_ctrl
// file /usr/include/openssl/ssl.h line 2337
signed long int SSL_ctrl(struct ssl_st *, signed int, signed long int, void *);
// SSL_free
// file /usr/include/openssl/ssl.h line 2331
void SSL_free(struct ssl_st *);
// SSL_get1_session
// file /usr/include/openssl/ssl.h line 2446
struct ssl_session_st * SSL_get1_session(struct ssl_st *);
// SSL_get_current_cipher
// file /usr/include/openssl/ssl.h line 2142
const struct ssl_cipher_st * SSL_get_current_cipher(const struct ssl_st *);
// SSL_get_error
// file /usr/include/openssl/ssl.h line 2342
signed int SSL_get_error(const struct ssl_st *, signed int);
// SSL_get_ex_data
// file /usr/include/openssl/ssl.h line 2460
void * SSL_get_ex_data(const struct ssl_st *, signed int);
// SSL_get_ex_data_X509_STORE_CTX_idx
// file /usr/include/openssl/ssl.h line 2477
signed int SSL_get_ex_data_X509_STORE_CTX_idx(void);
// SSL_get_ex_new_index
// file /usr/include/openssl/ssl.h line 2461
signed int SSL_get_ex_new_index(signed long int, void *, signed int (*)(void *, void *, struct crypto_ex_data_st *, signed int, signed long int, void *), signed int (*)(struct crypto_ex_data_st *, struct crypto_ex_data_st *, void *, signed int, signed long int, void *), void (*)(void *, void *, struct crypto_ex_data_st *, signed int, signed long int, void *));
// SSL_get_peer_certificate
// file /usr/include/openssl/ssl.h line 2253
struct x509_st * SSL_get_peer_certificate(const struct ssl_st *);
// SSL_get_servername
// file /usr/include/openssl/tls1.h line 309
const char * SSL_get_servername(const struct ssl_st *, const signed int);
// SSL_get_shutdown
// file /usr/include/openssl/ssl.h line 2439
signed int SSL_get_shutdown(const struct ssl_st *);
// SSL_library_init
// file /usr/include/openssl/ssl.h line 2419
signed int SSL_library_init(void);
// SSL_load_error_strings
// file /usr/include/openssl/ssl.h line 2216
void SSL_load_error_strings(void);
// SSL_new
// file /usr/include/openssl/ssl.h line 2291
struct ssl_st * SSL_new(struct ssl_ctx_st *);
// SSL_pending
// file /usr/include/openssl/ssl.h line 2154
signed int SSL_pending(const struct ssl_st *);
// SSL_read
// file /usr/include/openssl/ssl.h line 2334
signed int SSL_read(struct ssl_st *, void *, signed int);
// SSL_set_SSL_CTX
// file /usr/include/openssl/ssl.h line 2448
struct ssl_ctx_st * SSL_set_SSL_CTX(struct ssl_st *, struct ssl_ctx_st *);
// SSL_set_ex_data
// file /usr/include/openssl/ssl.h line 2459
signed int SSL_set_ex_data(struct ssl_st *, signed int, void *);
// SSL_set_fd
// file /usr/include/openssl/ssl.h line 2156
signed int SSL_set_fd(struct ssl_st *, signed int);
// SSL_set_shutdown
// file /usr/include/openssl/ssl.h line 2438
void SSL_set_shutdown(struct ssl_st *, signed int);
// SSL_shutdown
// file /usr/include/openssl/ssl.h line 2397
signed int SSL_shutdown(struct ssl_st *);
// SSL_state
// file /usr/include/openssl/ssl.h line 2453
signed int SSL_state(const struct ssl_st *);
// SSL_write
// file /usr/include/openssl/ssl.h line 2336
signed int SSL_write(struct ssl_st *, const void *, signed int);
// TLSv1_client_method
// file /usr/include/openssl/ssl.h line 2369
const struct ssl_method_st * TLSv1_client_method(void);
// TLSv1_server_method
// file /usr/include/openssl/ssl.h line 2368
const struct ssl_method_st * TLSv1_server_method(void);
// X509V3_EXT_d2i
// file /usr/include/openssl/x509v3.h line 674
void * X509V3_EXT_d2i(struct X509_extension_st *);
// X509_NAME_get_text_by_NID
// file /usr/include/openssl/x509.h line 1011
signed int X509_NAME_get_text_by_NID(struct X509_name_st *, signed int, char *, signed int);
// X509_NAME_oneline
// file /usr/include/openssl/x509.h line 875
char * X509_NAME_oneline(struct X509_name_st *, char *, signed int);
// X509_STORE_CTX_get_current_cert
// file /usr/include/openssl/x509_vfy.h line 541
struct x509_st * X509_STORE_CTX_get_current_cert(struct x509_store_ctx_st *);
// X509_STORE_CTX_get_error
// file /usr/include/openssl/x509_vfy.h line 538
signed int X509_STORE_CTX_get_error(struct x509_store_ctx_st *);
// X509_STORE_CTX_get_error_depth
// file /usr/include/openssl/x509_vfy.h line 540
signed int X509_STORE_CTX_get_error_depth(struct x509_store_ctx_st *);
// X509_STORE_CTX_get_ex_data
// file /usr/include/openssl/x509_vfy.h line 537
void * X509_STORE_CTX_get_ex_data(struct x509_store_ctx_st *, signed int);
// X509_STORE_CTX_set_error
// file /usr/include/openssl/x509_vfy.h line 539
void X509_STORE_CTX_set_error(struct x509_store_ctx_st *, signed int);
// X509_STORE_set_flags
// file /usr/include/openssl/x509_vfy.h line 467
signed int X509_STORE_set_flags(struct x509_store_st *, unsigned long int);
// X509_free
// file /usr/include/openssl/x509.h line 823
void X509_free(struct x509_st *);
// X509_get_default_cert_dir
// file /usr/include/openssl/x509.h line 772
const char * X509_get_default_cert_dir(void);
// X509_get_ext
// file /usr/include/openssl/x509.h line 1068
struct X509_extension_st * X509_get_ext(struct x509_st *, signed int);
// X509_get_ext_by_NID
// file /usr/include/openssl/x509.h line 1065
signed int X509_get_ext_by_NID(struct x509_st *, signed int, signed int);
// X509_get_issuer_name
// file /usr/include/openssl/x509.h line 905
struct X509_name_st * X509_get_issuer_name(struct x509_st *);
// X509_get_serialNumber
// file /usr/include/openssl/x509.h line 903
struct asn1_string_st * X509_get_serialNumber(struct x509_st *);
// X509_get_subject_name
// file /usr/include/openssl/x509.h line 907
struct X509_name_st * X509_get_subject_name(struct x509_st *);
// X509_verify_cert_error_string
// file /usr/include/openssl/x509.h line 628
const char * X509_verify_cert_error_string(signed long int);
// _IO_getc
// file /usr/include/libio.h line 434
extern signed int _IO_getc(struct _IO_FILE *);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __ctype_toupper_loc
// file /usr/include/ctype.h line 83
extern const signed int ** __ctype_toupper_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 400
extern signed int __xstat(signed int, const char *, struct stat *);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous$2, unsigned int *);
// acceptCheck
// file stone.c line 4279
signed int acceptCheck(struct _Pair *pair1);
// acceptPair
// file stone.c line 4021
struct _Pair * acceptPair(struct _Stone *stone);
// addr2ip
// file stone.c line 1062
char * addr2ip(struct in_addr *addr, char *str, signed int len);
// addr2ip6
// file stone.c line 1076
char * addr2ip6(struct in6_addr *addr, char *str, signed int len);
// addr2numeric
// file stone.c line 1089
char * addr2numeric(struct sockaddr *sa, char *str, signed int len);
// addr2str
// file stone.c line 1270
char * addr2str(struct sockaddr *sa, unsigned int salen, char *str, signed int len, signed int flags);
// addrport2str
// file stone.c line 1287
char * addrport2str(struct sockaddr *sa, unsigned int salen, signed int proto, char *str, signed int len, signed int flags);
// addrport2strOnce
// file stone.c line 1359
char * addrport2strOnce(struct sockaddr *sa, unsigned int salen, signed int proto, char *str, signed int len, signed int flags);
// asyncAcceptConnect
// file stone.c line 6791
void asyncAcceptConnect(struct _Pair *pair);
// asyncConn
// file stone.c line 3946
void asyncConn(struct _Conn *conn);
// asyncHealthCheck
// file stone.c line 1955
void asyncHealthCheck(struct _Backup *b);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// baseDecode
// file stone.c line 4998
signed int baseDecode(unsigned char *buf, signed int len, char *rest);
// baseEncode
// file stone.c line 4940
signed int baseEncode(unsigned char *buf, signed int len, signed int max);
// bcopy
// file /usr/include/string.h line 454
extern void bcopy(const void *, void *, unsigned long int);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$2, unsigned int);
// bzero
// file /usr/include/string.h line 458
extern void bzero(void *, unsigned long int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// checkXhost
// file stone.c line 1609
struct _XHosts * checkXhost(struct _XHosts *xhosts, struct sockaddr *sa, unsigned int salen);
// chroot
// file /usr/include/unistd.h line 944
extern signed int chroot(const char *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// commOutput
// file stone.c line 5215
signed int commOutput(struct _Pair *pair, char *fmt, ...);
// comm_match
// file stone.c line 5250
static char * comm_match(char *buf, char *str);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous$2, unsigned int);
// connected
// file stone.c line 3699
void connected(struct _Pair *pair);
// d2i_PKCS12_fp
// file /usr/include/openssl/pkcs12.h line 272
struct anonymous$24 * d2i_PKCS12_fp(struct _IO_FILE *, struct anonymous$24 **);
// daemonize
// file stone.c line 9898
void daemonize(void);
// dispatch
// file stone.c line 6904
void dispatch(signed int epfd, struct epoll_event *evs, signed int nevs);
// doAcceptConnect
// file stone.c line 6740
signed int doAcceptConnect(struct _Pair *p1);
// doReadWritePair
// file stone.c line 6312
signed int doReadWritePair(struct _Pair *pair, struct _Pair *opposite, signed int ready_r, signed int ready_w, signed int ready_e, signed int hangup, signed int error);
// doSSL_accept
// file stone.c line 3244
signed int doSSL_accept(struct _Pair *pair);
// doSSL_connect
// file stone.c line 3340
signed int doSSL_connect(struct _Pair *pair);
// doSSL_shutdown
// file stone.c line 3424
signed int doSSL_shutdown(struct _Pair *pair, signed int how);
// doargs
// file stone.c line 9598
void doargs(signed int argc, signed int i, char **argv);
// docloseUDP
// file stone.c line 2841
void docloseUDP(struct _Origin *origin);
// docomm
// file stone.c line 5936
signed int docomm(struct _Pair *pair, struct _Comm *comm);
// doconnect
// file stone.c line 3780
signed int doconnect(struct _Pair *p1, struct sockaddr *sa, unsigned int salen);
// dohyphen
// file stone.c line 9133
signed int dohyphen(char opt, signed int argc, char **argv, signed int argi);
// doopts
// file stone.c line 9519
signed int doopts(signed int argc, char **argv);
// doproxy
// file stone.c line 5330
signed int doproxy(struct _Pair *pair, char *host, char *serv);
// doread
// file stone.c line 5022
signed int doread(struct _Pair *pair);
// doshutdown
// file stone.c line 3517
signed int doshutdown(struct _Pair *pair, signed int how);
// dowrite
// file stone.c line 4799
signed int dowrite(struct _Pair *pair);
// dup
// file /usr/include/unistd.h line 531
extern signed int dup(signed int);
// epoll_create
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 100
extern signed int epoll_create(signed int);
// epoll_ctl
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 113
extern signed int epoll_ctl(signed int, signed int, signed int, struct epoll_event *);
// epoll_wait
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 127
extern signed int epoll_wait(signed int, struct epoll_event *, signed int, signed int);
// exPatFile
// file stone.c line 7516
char * exPatFile(char *pat, char *name, char *src, char *dst);
// exPatOpts
// file stone.c line 7552
void exPatOpts(struct anonymous$8 *opts, char *src, char *dst);
// execv
// file /usr/include/unistd.h line 563
extern signed int execv(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// ext2str
// file stone.c line 1102
char * ext2str(signed int ext, char *str, signed int len);
// fchown
// file /usr/include/unistd.h line 478
extern signed int fchown(signed int, unsigned int, unsigned int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// findBackup
// file stone.c line 1998
struct _Backup * findBackup(struct sockaddr *sa);
// findLBSet
// file stone.c line 2246
struct _LBSet * findLBSet(struct sockaddr *sa);
// first_read
// file stone.c line 6040
signed int first_read(struct _Pair *pair);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeConn
// file stone.c line 3892
void freeConn(struct _Conn *conn);
// freeMatch
// file stone.c line 7076
static void freeMatch(void *parent, void *ptr, struct crypto_ex_data_st *ad, signed int idx, signed long int argl, void *argp);
// freeMutex
// file stone.c line 1743
void freeMutex(signed int h);
// freeOrigin
// file stone.c line 2622
void freeOrigin(struct _Origin *origin);
// freePair
// file stone.c line 3578
void freePair(struct _Pair *pair);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// gcd
// file stone.c line 2020
signed int gcd(signed int a, signed int b);
// getExBuf
// file stone.c line 2377
struct _ExBuf * getExBuf(void);
// getExData
// file stone.c line 2410
struct _ExBuf * getExData(struct _Pair *pair, signed int type, signed int rmflag);
// getOrigins
// file stone.c line 2627
struct _Origin * getOrigins(struct sockaddr *from, unsigned int fromlen, struct _Stone *stone);
// getPairUDP
// file stone.c line 6797
struct _Pair * getPairUDP(struct sockaddr *from, unsigned int fromlen, struct _Stone *stone);
// getPktBuf
// file stone.c line 2591
struct _PktBuf * getPktBuf(void);
// getStone
// file stone.c line 8040
struct _Stone * getStone(struct sockaddr *sa, unsigned int salen, signed int proto);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getconfig
// file stone.c line 8695
void getconfig(void);
// getcwd
// file /usr/include/unistd.h line 511
extern char * getcwd(char *, unsigned long int);
// getdist
// file stone.c line 8739
signed int getdist(char *p, signed int *protop);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getgrgid_r
// file /usr/include/grp.h line 143
extern signed int getgrgid_r(unsigned int, struct group *, char *, unsigned long int, struct group ** restrict );
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// getident
// file stone.c line 4081
signed int getident(char *str, struct sockaddr *sa, unsigned int salen, signed int cport, struct sockaddr *csa, unsigned int csalen);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getpeername
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 141
extern signed int getpeername(signed int, union anonymous$2, unsigned int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getport
// file stone.c line 1410
signed int getport(struct sockaddr *sa);
// getpwuid_r
// file /usr/include/pwd.h line 144
extern signed int getpwuid_r(unsigned int, struct passwd *, char *, unsigned long int, struct passwd ** restrict );
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, union anonymous$2, unsigned int *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// gettoken
// file stone.c line 8563
static signed int gettoken(struct _IO_FILE *fp, char *buf);
// getvar
// file stone.c line 8530
static signed int getvar(struct _IO_FILE *fp, char *buf, signed int bufmax);
// handler
// file stone.c line 9775
static void handler(signed int sig);
// healthCLOCK
// file stone.c line 5852
signed int healthCLOCK(struct _Pair *pair, char *parm, signed int start);
// healthCONFIG
// file stone.c line 5871
signed int healthCONFIG(struct _Pair *pair, char *parm, signed int start);
// healthCVS_ID
// file stone.c line 5866
signed int healthCVS_ID(struct _Pair *pair, char *parm, signed int start);
// healthCheck
// file stone.c line 1767
signed int healthCheck(struct sockaddr *sa, unsigned int salen, signed int proto, signed int timeout, struct _Chat *chat);
// healthErr
// file stone.c line 5908
signed int healthErr(struct _Pair *pair, char *parm, signed int start);
// healthFREE
// file stone.c line 5840
signed int healthFREE(struct _Pair *pair, char *parm, signed int start);
// healthHELO
// file stone.c line 5813
signed int healthHELO(struct _Pair *pair, char *parm, signed int start);
// healthLIMIT
// file stone.c line 5892
signed int healthLIMIT(struct _Pair *pair, char *parm, signed int start);
// healthQUIT
// file stone.c line 5903
signed int healthQUIT(struct _Pair *pair, char *parm, signed int start);
// healthSTAT
// file stone.c line 5826
signed int healthSTAT(struct _Pair *pair, char *parm, signed int start);
// healthSTONE
// file stone.c line 5879
signed int healthSTONE(struct _Pair *pair, char *parm, signed int start);
// help
// file stone.c line 8334
void help(char *com, char *sub);
// host2sa
// file stone.c line 1500
signed int host2sa(char *name, char *serv, struct sockaddr *sa, unsigned int *salenp, signed int *socktypep, signed int *protocolp, signed int flags);
// hostPort2sa
// file stone.c line 1546
signed int hostPort2sa(char *str, struct sockaddr *sa, unsigned int *salenp, signed int flags);
// hostPortExt
// file stone.c line 1421
signed int hostPortExt(char *str, char *host, char *port);
// hostcheck
// file stone.c line 7107
static signed int hostcheck(struct _Pair *pair, struct x509_st *cert, char *host);
// hostcmp
// file stone.c line 7088
static signed int hostcmp(char *pat, char *host);
// identd
// file stone.c line 5656
struct _Pair * identd(signed int cport, struct sockaddr *ssa, unsigned int ssalen);
// identdQUERY
// file stone.c line 5680
signed int identdQUERY(struct _Pair *pair, char *parm, signed int start);
// identdQUIT
// file stone.c line 5720
signed int identdQUIT(struct _Pair *pair, char *parm, signed int start);
// initialize
// file stone.c line 9925
void initialize(signed int argc, char **argv);
// insertPairs
// file stone.c line 3662
void insertPairs(struct _Pair *p1);
// insheader
// file stone.c line 5974
signed int insheader(struct _Pair *pair);
// isdigitaddr
// file stone.c line 1376
signed int isdigitaddr(char *name);
// isdigitstr
// file stone.c line 1368
signed int isdigitstr(char *str);
// islocalhost
// file stone.c line 1186
signed int islocalhost(struct sockaddr *sa);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// lbsopts
// file stone.c line 2272
signed int lbsopts(signed int argc, signed int i, char **argv);
// limitAsync
// file stone.c line 5794
signed int limitAsync(struct _Pair *pair, char *parm, signed int start);
// limitCommon
// file stone.c line 5761
signed int limitCommon(struct _Pair *pair, signed int var, signed int limit, char *str);
// limitConn
// file stone.c line 5776
signed int limitConn(struct _Pair *pair, char *parm, signed int start);
// limitErr
// file stone.c line 5798
signed int limitErr(struct _Pair *pair, char *parm, signed int start);
// limitEstablished
// file stone.c line 5780
signed int limitEstablished(struct _Pair *pair, char *parm, signed int start);
// limitPair
// file stone.c line 5772
signed int limitPair(struct _Pair *pair, char *parm, signed int start);
// limitReadWrite
// file stone.c line 5787
signed int limitReadWrite(struct _Pair *pair, char *parm, signed int start);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memCheck
// file stone.c line 5926
signed int memCheck(void);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// message
// file stone.c line 913
void message(signed int pri, char *fmt, ...);
// message_buf
// file stone.c line 1047
void message_buf(struct _Pair *pair, signed int len, char *str);
// message_conn
// file stone.c line 3757
void message_conn(signed int pri, struct _Conn *conn);
// message_conns
// file stone.c line 4773
void message_conns(signed int pri);
// message_origin
// file stone.c line 2543
void message_origin(signed int pri, struct _Origin *origin);
// message_origins
// file stone.c line 4761
void message_origins(signed int pri);
// message_pair
// file stone.c line 3176
void message_pair(signed int pri, struct _Pair *pair);
// message_pairs
// file stone.c line 4750
void message_pairs(signed int pri);
// message_time
// file stone.c line 962
void message_time(struct _Pair *pair, signed int pri, char *fmt, ...);
// message_time_log
// file stone.c line 3680
void message_time_log(struct _Pair *pair);
// mkBackup
// file stone.c line 2033
signed int mkBackup(signed int argc, signed int argi, char **argv);
// mkChat
// file stone.c line 2208
signed int mkChat(signed int argc, signed int i, char **argv);
// mkPortXhosts
// file stone.c line 7947
signed int mkPortXhosts(signed int argc, signed int i, char **argv);
// mkStoneSSL
// file stone.c line 7334
struct anonymous$12 * mkStoneSSL(struct anonymous$8 *opts, signed int isserver);
// mkXhosts
// file stone.c line 7869
struct _XHosts * mkXhosts(signed int nhosts, char **hosts, unsigned short int family, char *mesg);
// mkXhostsExt
// file stone.c line 7767
void mkXhostsExt(char *host, char *str, struct _XHosts *ext);
// mkstone
// file stone.c line 8053
struct _Stone * mkstone(char *dhost, char *dserv, char *host, char *serv, signed int nhosts, char **hosts, signed int proto);
// modPairDest
// file stone.c line 2438
signed int modPairDest(struct _Pair *p1, struct sockaddr *dst, unsigned int dstlenmax);
// nConns
// file stone.c line 5746
signed int nConns(void);
// nOrigins
// file stone.c line 5753
signed int nOrigins(void);
// nPairs
// file stone.c line 5738
signed int nPairs(struct _Pair *top);
// nStones
// file stone.c line 5731
signed int nStones(void);
// newExData
// file stone.c line 2428
struct _ExBuf * newExData(struct _Pair *pair, signed int type);
// newMatch
// file stone.c line 7063
static signed int newMatch(void *parent, void *ptr, struct crypto_ex_data_st *ad, signed int idx, signed long int argl, void *argp);
// newPair
// file stone.c line 3536
struct _Pair * newPair(void);
// openconfig
// file stone.c line 8624
struct _IO_FILE * openconfig(void);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// packet_dump
// file stone.c line 993
void packet_dump(char *head, char *buf, signed int len, struct _XHosts *xhost);
// passwd_callback
// file stone.c line 7298
static signed int passwd_callback(char *buf, signed int size, signed int rwflag, void *passwd);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// prctl
// file /usr/include/x86_64-linux-gnu/sys/prctl.h line 27
extern signed int prctl(signed int, ...);
// printSSLinfo
// file stone.c line 3225
static void printSSLinfo(signed int pri, struct ssl_st *ssl);
// priority
// file stone.c line 984
signed int priority(struct _Pair *pair);
// proto2fdset
// file stone.c line 6159
void proto2fdset(struct _Pair *pair);
// proxyCONNECT
// file stone.c line 5446
signed int proxyCONNECT(struct _Pair *pair, char *parm, signed int start);
// proxyCommon
// file stone.c line 5471
signed int proxyCommon(struct _Pair *pair, char *parm, signed int start);
// proxyErr
// file stone.c line 5536
signed int proxyErr(struct _Pair *pair, char *parm, signed int start);
// proxyGET
// file stone.c line 5521
signed int proxyGET(struct _Pair *pair, char *parm, signed int start);
// proxyHEAD
// file stone.c line 5526
signed int proxyHEAD(struct _Pair *pair, char *parm, signed int start);
// proxyPOST
// file stone.c line 5531
signed int proxyPOST(struct _Pair *pair, char *parm, signed int start);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$3 *, const union anonymous$17 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$3 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$3 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// recvPairUDP
// file stone.c line 2931
signed int recvPairUDP(struct _Pair *pair);
// recvStoneUDP
// file stone.c line 6830
void recvStoneUDP(struct _Stone *stone);
// recvUDP
// file stone.c line 2705
struct _PktBuf * recvUDP(struct _Stone *stone);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, union anonymous$2, unsigned int *);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous$19 *, signed int);
// regfree
// file /usr/include/regex.h line 574
extern void regfree(struct re_pattern_buffer *);
// repeater
// file stone.c line 7635
void repeater(void);
// reqconn
// file stone.c line 3897
signed int reqconn(struct _Pair *pair, struct sockaddr *dst, unsigned int dstlen);
// reusestone
// file stone.c line 7748
signed int reusestone(struct _Stone *stone);
// rindex
// file /usr/include/string.h line 516
extern char * rindex(const char *, signed int);
// rmStoneSSL
// file stone.c line 7504
void rmStoneSSL(struct anonymous$12 *ss);
// rmheader
// file stone.c line 6011
signed int rmheader(struct _Pair *pair);
// rmoldconfig
// file stone.c line 7625
void rmoldconfig(void);
// rmoldstone
// file stone.c line 7598
void rmoldstone(void);
// saComp
// file stone.c line 1566
signed int saComp(struct sockaddr *a, struct sockaddr *b);
// saDup
// file stone.c line 1557
struct anonymous$0 * saDup(struct sockaddr *sa, unsigned int salen);
// saPort
// file stone.c line 1395
void saPort(struct sockaddr *sa, unsigned short int port);
// scanBackups
// file stone.c line 1987
void scanBackups(void);
// scanClose
// file stone.c line 4671
signed int scanClose(struct _Pair *pairs);
// scanConns
// file stone.c line 3983
signed int scanConns(void);
// scanPairs
// file stone.c line 6972
signed int scanPairs(struct _Pair *pairs);
// scanUDP
// file stone.c line 2858
signed int scanUDP(struct _Origin *origins);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// sendPairUDP
// file stone.c line 3057
signed int sendPairUDP(struct _Pair *pair);
// sendPairUDPbuf
// file stone.c line 3005
static signed int sendPairUDPbuf(struct _Stone *stone, struct _Pair *pair, char *buf, signed int len);
// sendUDP
// file stone.c line 2789
signed int sendUDP(struct _PktBuf *pb);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int, union anonymous$2, unsigned int);
// setbuf
// file /usr/include/stdio.h line 332
extern void setbuf(struct _IO_FILE *, char *);
// setclose
// file stone.c line 4782
void setclose(struct _Pair *pair, signed int flag);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// setgroups
// file /usr/include/grp.h line 179
extern signed int setgroups(unsigned long int, const unsigned int *);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sk_free
// file /usr/include/openssl/stack.h line 84
void sk_free(struct stack_st *);
// sk_num
// file /usr/include/openssl/stack.h line 77
signed int sk_num(const struct stack_st *);
// sk_value
// file /usr/include/openssl/stack.h line 78
void * sk_value(const struct stack_st *, signed int);
// skipcomment
// file stone.c line 8523
static void skipcomment(struct _IO_FILE *fp);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// ssl_servername_callback
// file stone.c line 7305
static signed int ssl_servername_callback(struct ssl_st *ssl, signed int *ad, void *arg);
// sslopts
// file stone.c line 8911
signed int sslopts(signed int argc, signed int argi, char **argv, struct anonymous$8 *opts, signed int isserver);
// sslopts_default
// file stone.c line 8857
void sslopts_default(struct anonymous$8 *opts, signed int isserver);
// sslthread_id_callback
// file stone.c line 9067
unsigned long int sslthread_id_callback(void);
// sslthread_initialize
// file stone.c line 9106
signed int sslthread_initialize(void);
// sslthread_lock_callback
// file stone.c line 9080
void sslthread_lock_callback(signed int mode, signed int n, const char *file, signed int line);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf);
// stone2str
// file stone.c line 2313
char * stone2str(struct _Stone *stone, char *str, signed int strlen);
// str2bin
// file stone.c line 2178
char * str2bin(char *p, signed int *lenp);
// str2num
// file stone.c line 2155
signed int str2num(char **pp, signed int rad);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strnAddr
// file stone.c line 4449
signed int strnAddr(char *buf, signed int limit, signed int sd, signed int which, signed int isport);
// strnUser
// file stone.c line 4489
signed int strnUser(char *buf, signed int limit, struct _Pair *pair, signed int which);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strnparse
// file stone.c line 4568
signed int strnparse(char *buf, signed int limit, char **pp, struct _Pair *pair, char term);
// strntime
// file stone.c line 868
char * strntime(char *str, signed int len, signed long int *clock, signed long int micro);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// toupper
// file /usr/include/ctype.h line 221
static inline signed int toupper(signed int __c);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// ungetExBuf
// file stone.c line 2337
void ungetExBuf(struct _ExBuf *ex);
// ungetPktBuf
// file stone.c line 2579
void ungetPktBuf(struct _PktBuf *pb);
// ungetc
// file /usr/include/stdio.h line 702
extern signed int ungetc(signed int, struct _IO_FILE *);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// verify_callback
// file stone.c line 7150
static signed int verify_callback(signed int preverify_ok, struct x509_store_ctx_st *ctx);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// wait
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 102
extern signed int wait(union anonymous$1);
// waitMutex
// file stone.c line 1722
void waitMutex(signed int h);

struct anonymous
{
  // dinfo
  struct X509_sig_st *dinfo;
  // salt
  struct asn1_string_st *salt;
  // iter
  struct asn1_string_st *iter;
};

struct anonymous$24
{
  // version
  struct asn1_string_st *version;
  // mac
  struct anonymous *mac;
  // authsafes
  struct pkcs7_st *authsafes;
};

struct anonymous$16
{
  // cert_verify_md
  unsigned char cert_verify_md[128l];
  // finish_md
  unsigned char finish_md[128l];
  // finish_md_len
  signed int finish_md_len;
  // peer_finish_md
  unsigned char peer_finish_md[128l];
  // peer_finish_md_len
  signed int peer_finish_md_len;
  // message_size
  unsigned long int message_size;
  // message_type
  signed int message_type;
  // new_cipher
  const struct ssl_cipher_st *new_cipher;
  // dh
  struct dh_st *dh;
  // ecdh
  struct ec_key_st *ecdh;
  // next_state
  signed int next_state;
  // reuse_message
  signed int reuse_message;
  // cert_req
  signed int cert_req;
  // ctype_num
  signed int ctype_num;
  // ctype
  char ctype[9l];
  // ca_names
  struct stack_st_X509_NAME *ca_names;
  // use_rsa_tmp
  signed int use_rsa_tmp;
  // key_block_length
  signed int key_block_length;
  // key_block
  unsigned char *key_block;
  // new_sym_enc
  const struct evp_cipher_st *new_sym_enc;
  // new_hash
  const struct env_md_st *new_hash;
  // new_mac_pkey_type
  signed int new_mac_pkey_type;
  // new_mac_secret_size
  signed int new_mac_secret_size;
  // new_compression
  const struct ssl_comp_st *new_compression;
  // cert_request
  signed int cert_request;
};

struct anonymous$14
{
  // __w_stopval
  unsigned int __w_stopval : 8;
  // __w_stopsig
  unsigned int __w_stopsig : 8;
  // $anon0
  unsigned int $anon0 : 16;
};

struct anonymous$13
{
  // __w_termsig
  unsigned int __w_termsig : 7;
  // __w_coredump
  unsigned int __w_coredump : 1;
  // __w_retcode
  unsigned int __w_retcode : 8;
  // $anon0
  unsigned int $anon0 : 16;
};

struct anonymous$19
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous$23
{
  // sess_connect
  signed int sess_connect;
  // sess_connect_renegotiate
  signed int sess_connect_renegotiate;
  // sess_connect_good
  signed int sess_connect_good;
  // sess_accept
  signed int sess_accept;
  // sess_accept_renegotiate
  signed int sess_accept_renegotiate;
  // sess_accept_good
  signed int sess_accept_good;
  // sess_miss
  signed int sess_miss;
  // sess_timeout
  signed int sess_timeout;
  // sess_cache_full
  signed int sess_cache_full;
  // sess_hit
  signed int sess_hit;
  // sess_cb_hit
  signed int sess_cb_hit;
};

struct re_pattern_buffer
{
  // buffer
  unsigned char *buffer;
  // allocated
  unsigned long int allocated;
  // used
  unsigned long int used;
  // syntax
  unsigned long int syntax;
  // fastmap
  char *fastmap;
  // translate
  unsigned char *translate;
  // re_nsub
  unsigned long int re_nsub;
  // can_be_null
  unsigned int can_be_null : 1;
  // regs_allocated
  unsigned int regs_allocated : 2;
  // fastmap_accurate
  unsigned int fastmap_accurate : 1;
  // no_sub
  unsigned int no_sub : 1;
  // not_bol
  unsigned int not_bol : 1;
  // not_eol
  unsigned int not_eol : 1;
  // newline_anchor
  unsigned int newline_anchor : 1;
};

struct anonymous$12
{
  // verbose
  signed int verbose;
  // shutdown_mode
  signed int shutdown_mode;
  // depth
  signed int depth;
  // serial
  signed long int serial;
  // ctx
  struct ssl_ctx_st *ctx;
  // re
  struct re_pattern_buffer *re[10l];
  // name
  char *name;
  // lbmod
  unsigned char lbmod;
  // lbparm
  unsigned char lbparm;
  // sslparm
  unsigned char sslparm;
};

struct anonymous$8
{
  // verbose
  signed int verbose;
  // shutdown_mode
  signed int shutdown_mode;
  // mode
  signed int mode;
  // depth
  signed int depth;
  // vflags
  signed int vflags;
  // off
  signed long int off;
  // serial
  signed long int serial;
  // meth
  struct ssl_method_st *meth;
  // callback
  signed int (*callback)(signed int, struct x509_store_ctx_st *);
  // sid_ctx
  unsigned char *sid_ctx;
  // useSNI
  signed int useSNI;
  // keyFile
  char *keyFile;
  // certFile
  char *certFile;
  // keyFilePat
  char *keyFilePat;
  // certFilePat
  char *certFilePat;
  // caFile
  char *caFile;
  // caPath
  char *caPath;
  // pfxFile
  char *pfxFile;
  // pfxFilePat
  char *pfxFilePat;
  // passFile
  char *passFile;
  // passFilePat
  char *passFilePat;
  // passwd
  char *passwd;
  // servername
  char *servername;
  // certIgnore
  signed int certIgnore;
  // cipherList
  char *cipherList;
  // regexp
  char *regexp[10l];
  // lbmod
  unsigned char lbmod;
  // lbparm
  unsigned char lbparm;
};

struct anonymous$15
{
  // conn_id_length
  unsigned int conn_id_length;
  // cert_type
  unsigned int cert_type;
  // cert_length
  unsigned int cert_length;
  // csl
  unsigned int csl;
  // clear
  unsigned int clear;
  // enc
  unsigned int enc;
  // ccl
  unsigned char ccl[32l];
  // cipher_spec_length
  unsigned int cipher_spec_length;
  // session_id_length
  unsigned int session_id_length;
  // clen
  unsigned int clen;
  // rlen
  unsigned int rlen;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct anonymous$0
{
  // len
  unsigned int len;
  // addr
  struct sockaddr addr;
};

union anonymous$4
{
  // inherit
  signed int *inherit;
  // asIdsOrRanges
  struct stack_st_ASIdOrRange *asIdsOrRanges;
};

union anonymous$11
{
  // ptr
  char *ptr;
  // data
  struct asn1_string_st *data;
  // sign
  struct pkcs7_signed_st *sign;
  // enveloped
  struct pkcs7_enveloped_st *enveloped;
  // signed_and_enveloped
  struct pkcs7_signedandenveloped_st *signed_and_enveloped;
  // digest
  struct pkcs7_digest_st *digest;
  // encrypted
  struct pkcs7_encrypted_st *encrypted;
  // other
  struct asn1_type_st *other;
};

union anonymous$20
{
  // ptr
  char *ptr;
  // otherName
  struct otherName_st *otherName;
  // rfc822Name
  struct asn1_string_st *rfc822Name;
  // dNSName
  struct asn1_string_st *dNSName;
  // x400Address
  struct asn1_type_st *x400Address;
  // directoryName
  struct X509_name_st *directoryName;
  // ediPartyName
  struct EDIPartyName_st *ediPartyName;
  // uniformResourceIdentifier
  struct asn1_string_st *uniformResourceIdentifier;
  // iPAddress
  struct asn1_string_st *iPAddress;
  // registeredID
  struct asn1_object_st *registeredID;
  // ip
  struct asn1_string_st *ip;
  // dirn
  struct X509_name_st *dirn;
  // ia5
  struct asn1_string_st *ia5;
  // rid
  struct asn1_object_st *rid;
  // other
  struct asn1_type_st *other;
};

union anonymous$22
{
  // ptr
  char *ptr;
  // rsa
  struct rsa_st *rsa;
  // dsa
  struct dsa_st *dsa;
  // dh
  struct dh_st *dh;
  // ec
  struct ec_key_st *ec;
};

union anonymous$7
{
  // ptr
  char *ptr;
  // boolean
  signed int boolean;
  // asn1_string
  struct asn1_string_st *asn1_string;
  // object
  struct asn1_object_st *object;
  // integer
  struct asn1_string_st *integer;
  // enumerated
  struct asn1_string_st *enumerated;
  // bit_string
  struct asn1_string_st *bit_string;
  // octet_string
  struct asn1_string_st *octet_string;
  // printablestring
  struct asn1_string_st *printablestring;
  // t61string
  struct asn1_string_st *t61string;
  // ia5string
  struct asn1_string_st *ia5string;
  // generalstring
  struct asn1_string_st *generalstring;
  // bmpstring
  struct asn1_string_st *bmpstring;
  // universalstring
  struct asn1_string_st *universalstring;
  // utctime
  struct asn1_string_st *utctime;
  // generalizedtime
  struct asn1_string_st *generalizedtime;
  // visiblestring
  struct asn1_string_st *visiblestring;
  // utf8string
  struct asn1_string_st *utf8string;
  // set
  struct asn1_string_st *set;
  // sequence
  struct asn1_string_st *sequence;
  // asn1_value
  struct ASN1_VALUE_st *asn1_value;
};

union anonymous$25
{
  // fullname
  struct stack_st_GENERAL_NAME *fullname;
  // relativename
  struct stack_st_X509_NAME_ENTRY *relativename;
};

union anonymous$10
{
  // __uptr
  union wait *__uptr;
  // __iptr
  signed int *__iptr;
};

union anonymous$1
{
  // __uptr
  union wait *__uptr;
  // __iptr
  signed int *__iptr;
} __attribute__ ((__transparent_union__));

union anonymous$21
{
  // cb_1
  void (*cb_1)(signed int, signed int, void *);
  // cb_2
  signed int (*cb_2)(signed int, signed int, struct bn_gencb_st *);
};

union anonymous$9
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$17
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$3
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$5
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$2
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct ASIdentifierChoice_st
{
  // type
  signed int type;
  // u
  union anonymous$4 u;
};

struct ASIdentifiers_st
{
  // asnum
  struct ASIdentifierChoice_st *asnum;
  // rdi
  struct ASIdentifierChoice_st *rdi;
};

struct ASN1_ENCODING_st
{
  // enc
  unsigned char *enc;
  // len
  signed long int len;
  // modified
  signed int modified;
};

struct AUTHORITY_KEYID_st
{
  // keyid
  struct asn1_string_st *keyid;
  // issuer
  struct stack_st_GENERAL_NAME *issuer;
  // serial
  struct asn1_string_st *serial;
};

struct DIST_POINT_NAME_st
{
  // type
  signed int type;
  // name
  union anonymous$25 name;
  // dpname
  struct X509_name_st *dpname;
};

struct DSA_SIG_st
{
  // r
  struct bignum_st *r;
  // s
  struct bignum_st *s;
};

struct EDIPartyName_st
{
  // nameAssigner
  struct asn1_string_st *nameAssigner;
  // partyName
  struct asn1_string_st *partyName;
};

struct GENERAL_NAME_st
{
  // type
  signed int type;
  // d
  union anonymous$20 d;
};

struct ISSUING_DIST_POINT_st
{
  // distpoint
  struct DIST_POINT_NAME_st *distpoint;
  // onlyuser
  signed int onlyuser;
  // onlyCA
  signed int onlyCA;
  // onlysomereasons
  struct asn1_string_st *onlysomereasons;
  // indirectCRL
  signed int indirectCRL;
  // onlyattr
  signed int onlyattr;
};

struct NAME_CONSTRAINTS_st
{
  // permittedSubtrees
  struct stack_st_GENERAL_SUBTREE *permittedSubtrees;
  // excludedSubtrees
  struct stack_st_GENERAL_SUBTREE *excludedSubtrees;
};

struct X509_VERIFY_PARAM_st
{
  // name
  char *name;
  // check_time
  signed long int check_time;
  // inh_flags
  unsigned long int inh_flags;
  // flags
  unsigned long int flags;
  // purpose
  signed int purpose;
  // trust
  signed int trust;
  // depth
  signed int depth;
  // policies
  struct stack_st_ASN1_OBJECT *policies;
  // id
  struct X509_VERIFY_PARAM_ID_st *id;
};

struct X509_algor_st
{
  // algorithm
  struct asn1_object_st *algorithm;
  // parameter
  struct asn1_type_st *parameter;
};

struct X509_crl_info_st
{
  // version
  struct asn1_string_st *version;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // issuer
  struct X509_name_st *issuer;
  // lastUpdate
  struct asn1_string_st *lastUpdate;
  // nextUpdate
  struct asn1_string_st *nextUpdate;
  // revoked
  struct stack_st_X509_REVOKED *revoked;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct X509_crl_st
{
  // crl
  struct X509_crl_info_st *crl;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
  // flags
  signed int flags;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // idp
  struct ISSUING_DIST_POINT_st *idp;
  // idp_flags
  signed int idp_flags;
  // idp_reasons
  signed int idp_reasons;
  // crl_number
  struct asn1_string_st *crl_number;
  // base_crl_number
  struct asn1_string_st *base_crl_number;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // issuers
  struct stack_st_GENERAL_NAMES *issuers;
  // meth
  const struct x509_crl_method_st *meth;
  // meth_data
  void *meth_data;
};

struct X509_extension_st
{
  // object
  struct asn1_object_st *object;
  // critical
  signed int critical;
  // value
  struct asn1_string_st *value;
};

struct X509_name_st
{
  // entries
  struct stack_st_X509_NAME_ENTRY *entries;
  // modified
  signed int modified;
  // bytes
  struct buf_mem_st *bytes;
  // canon_enc
  unsigned char *canon_enc;
  // canon_enclen
  signed int canon_enclen;
};

struct X509_pubkey_st
{
  // algor
  struct X509_algor_st *algor;
  // public_key
  struct asn1_string_st *public_key;
  // pkey
  struct evp_pkey_st *pkey;
};

struct X509_sig_st
{
  // algor
  struct X509_algor_st *algor;
  // digest
  struct asn1_string_st *digest;
};

struct X509_val_st
{
  // notBefore
  struct asn1_string_st *notBefore;
  // notAfter
  struct asn1_string_st *notAfter;
};

struct _Backup
{
  // next
  struct _Backup *next;
  // check
  struct anonymous$0 *check;
  // master
  struct anonymous$0 *master;
  // backup
  struct anonymous$0 *backup;
  // proto
  signed int proto;
  // chat
  struct _Chat *chat;
  // interval
  signed short int interval;
  // bn
  signed short int bn;
  // used
  signed short int used;
  // last
  signed long int last;
};

struct _Chat
{
  // next
  struct _Chat *next;
  // send
  char *send;
  // len
  signed int len;
  // expect
  struct re_pattern_buffer expect;
};

struct _Comm
{
  // str
  char *str;
  // func
  signed int (*func)(struct _Pair *, char *, signed int);
};

struct _Conn
{
  // dst
  struct anonymous$0 *dst;
  // pair
  struct _Pair *pair;
  // lock
  signed int lock;
  // next
  struct _Conn *next;
};

struct _ExBuf
{
  // next
  struct _ExBuf *next;
  // start
  signed int start;
  // len
  signed int len;
  // bufmax
  signed int bufmax;
  // buf
  char buf[2048l];
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _LBSet
{
  // next
  struct _LBSet *next;
  // proto
  signed int proto;
  // ndsts
  signed short int ndsts;
  // dsts
  struct anonymous$0 *dsts[0l];
};

struct _Origin
{
  // common
  signed int common;
  // sd
  signed int sd;
  // stone
  struct _Stone *stone;
  // from
  struct anonymous$0 *from;
  // lock
  signed int lock;
  // xhost
  struct _XHosts *xhost;
  // clock
  signed long int clock;
  // next
  struct _Origin *next;
};

struct _Pair
{
  // common
  signed int common;
  // pair
  struct _Pair *pair;
  // prev
  struct _Pair *prev;
  // next
  struct _Pair *next;
  // stone
  struct _Stone *stone;
  // ssl
  struct ssl_st *ssl;
  // ssl_flag
  signed int ssl_flag;
  // xhost
  struct _XHosts *xhost;
  // clock
  signed long int clock;
  // timeout
  signed int timeout;
  // sd
  signed int sd;
  // proto
  signed int proto;
  // count
  signed int count;
  // d
  struct _ExBuf *d;
  // log
  struct _TimeLog *log;
  // tx
  signed int tx;
  // rx
  signed int rx;
  // loop
  signed int loop;
  // nbuf
  signed int nbuf;
  // t
  struct _ExBuf *t;
  // b
  struct _ExBuf *b;
};

struct _PktBuf
{
  // common
  signed int common;
  // next
  struct _PktBuf *next;
  // type
  signed int type;
  // origin
  struct _Origin *origin;
  // len
  signed int len;
  // bufmax
  signed int bufmax;
  // buf
  char buf[2048l];
};

struct _PortXHosts
{
  // next
  struct _PortXHosts *next;
  // ports
  struct _XPorts *ports;
  // xhosts
  struct _XHosts *xhosts;
};

struct _Stone
{
  // common
  signed int common;
  // sd
  signed int sd;
  // port
  signed int port;
  // listen
  struct anonymous$0 *listen;
  // ndsts
  signed short int ndsts;
  // dsts
  struct anonymous$0 **dsts;
  // from
  struct anonymous$0 *from;
  // proto
  signed int proto;
  // backups
  struct _Backup **backups;
  // pairs
  struct _Pair *pairs;
  // p
  char *p;
  // timeout
  signed int timeout;
  // next
  struct _Stone *next;
  // children
  struct _Stone *children;
  // parent
  struct _Stone *parent;
  // ssl_server
  struct anonymous$12 *ssl_server;
  // ssl_client
  struct anonymous$12 *ssl_client;
  // nhosts
  signed int nhosts;
  // xhosts
  struct _XHosts *xhosts;
};

struct _TimeLog
{
  // clock
  signed long int clock;
  // pri
  signed int pri;
  // str
  char str[0l];
};

struct _XHosts
{
  // next
  struct _XHosts *next;
  // mbits
  signed short int mbits;
  // mode
  signed short int mode;
  // xhost
  struct anonymous$0 xhost;
};

struct _XPorts
{
  // next
  struct _XPorts *next;
  // from
  signed short int from;
  // end
  signed short int end;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct asn1_object_st
{
  // sn
  const char *sn;
  // ln
  const char *ln;
  // nid
  signed int nid;
  // length
  signed int length;
  // data
  const unsigned char *data;
  // flags
  signed int flags;
};

struct asn1_string_st
{
  // length
  signed int length;
  // type
  signed int type;
  // data
  unsigned char *data;
  // flags
  signed long int flags;
};

struct asn1_type_st
{
  // type
  signed int type;
  // value
  union anonymous$7 value;
};

struct bignum_st
{
  // d
  unsigned long int *d;
  // top
  signed int top;
  // dmax
  signed int dmax;
  // neg
  signed int neg;
  // flags
  signed int flags;
};

struct bio_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // bwrite
  signed int (*bwrite)(struct bio_st *, const char *, signed int);
  // bread
  signed int (*bread)(struct bio_st *, char *, signed int);
  // bputs
  signed int (*bputs)(struct bio_st *, const char *);
  // bgets
  signed int (*bgets)(struct bio_st *, char *, signed int);
  // ctrl
  signed long int (*ctrl)(struct bio_st *, signed int, signed long int, void *);
  // create
  signed int (*create)(struct bio_st *);
  // destroy
  signed int (*destroy)(struct bio_st *);
  // callback_ctrl
  signed long int (*callback_ctrl)(struct bio_st *, signed int, void (*)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int));
};

struct crypto_ex_data_st
{
  // sk
  struct stack_st_void *sk;
  // dummy
  signed int dummy;
};

struct bio_st
{
  // method
  struct bio_method_st *method;
  // callback
  signed long int (*callback)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int);
  // cb_arg
  char *cb_arg;
  // init
  signed int init;
  // shutdown
  signed int shutdown;
  // flags
  signed int flags;
  // retry_reason
  signed int retry_reason;
  // num
  signed int num;
  // ptr
  void *ptr;
  // next_bio
  struct bio_st *next_bio;
  // prev_bio
  struct bio_st *prev_bio;
  // references
  signed int references;
  // num_read
  unsigned long int num_read;
  // num_write
  unsigned long int num_write;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct bn_gencb_st
{
  // ver
  unsigned int ver;
  // arg
  void *arg;
  // cb
  union anonymous$21 cb;
};

struct bn_mont_ctx_st
{
  // ri
  signed int ri;
  // RR
  struct bignum_st RR;
  // N
  struct bignum_st N;
  // Ni
  struct bignum_st Ni;
  // n0
  unsigned long int n0[2l];
  // flags
  signed int flags;
};

struct buf_mem_st
{
  // length
  unsigned long int length;
  // data
  char *data;
  // max
  unsigned long int max;
};

struct comp_ctx_st
{
  // meth
  struct comp_method_st *meth;
  // compress_in
  unsigned long int compress_in;
  // compress_out
  unsigned long int compress_out;
  // expand_in
  unsigned long int expand_in;
  // expand_out
  unsigned long int expand_out;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct comp_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // init
  signed int (*init)(struct comp_ctx_st *);
  // finish
  void (*finish)(struct comp_ctx_st *);
  // compress
  signed int (*compress)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // expand
  signed int (*expand)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // ctrl
  signed long int (*ctrl)(void);
  // callback_ctrl
  signed long int (*callback_ctrl)(void);
};

struct dh_method
{
  // name
  const char *name;
  // generate_key
  signed int (*generate_key)(struct dh_st *);
  // compute_key
  signed int (*compute_key)(unsigned char *, const struct bignum_st *, struct dh_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(const struct dh_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dh_st *);
  // finish
  signed int (*finish)(struct dh_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // generate_params
  signed int (*generate_params)(struct dh_st *, signed int, signed int, struct bn_gencb_st *);
};

struct dh_st
{
  // pad
  signed int pad;
  // version
  signed int version;
  // p
  struct bignum_st *p;
  // g
  struct bignum_st *g;
  // length
  signed long int length;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // q
  struct bignum_st *q;
  // j
  struct bignum_st *j;
  // seed
  unsigned char *seed;
  // seedlen
  signed int seedlen;
  // counter
  struct bignum_st *counter;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dh_method *meth;
  // engine
  struct engine_st *engine;
};

struct dsa_method
{
  // name
  const char *name;
  // dsa_do_sign
  struct DSA_SIG_st * (*dsa_do_sign)(const unsigned char *, signed int, struct dsa_st *);
  // dsa_sign_setup
  signed int (*dsa_sign_setup)(struct dsa_st *, struct bignum_ctx *, struct bignum_st **, struct bignum_st **);
  // dsa_do_verify
  signed int (*dsa_do_verify)(const unsigned char *, signed int, struct DSA_SIG_st *, struct dsa_st *);
  // dsa_mod_exp
  signed int (*dsa_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dsa_st *);
  // finish
  signed int (*finish)(struct dsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // dsa_paramgen
  signed int (*dsa_paramgen)(struct dsa_st *, signed int, const unsigned char *, signed int, signed int *, unsigned long int *, struct bn_gencb_st *);
  // dsa_keygen
  signed int (*dsa_keygen)(struct dsa_st *);
};

struct dsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // write_params
  signed int write_params;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // g
  struct bignum_st *g;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // kinv
  struct bignum_st *kinv;
  // r
  struct bignum_st *r;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dsa_method *meth;
  // engine
  struct engine_st *engine;
};

struct dtls1_bitmap_st
{
  // map
  unsigned long int map;
  // max_seq_num
  unsigned char max_seq_num[8l];
};

struct dtls1_retransmit_state
{
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // session
  struct ssl_session_st *session;
  // epoch
  unsigned short int epoch;
};

struct record_pqueue_st
{
  // epoch
  unsigned short int epoch;
  // q
  struct _pqueue *q;
};

struct hm_header_st
{
  // type
  unsigned char type;
  // msg_len
  unsigned long int msg_len;
  // seq
  unsigned short int seq;
  // frag_off
  unsigned long int frag_off;
  // frag_len
  unsigned long int frag_len;
  // is_ccs
  unsigned int is_ccs;
  // saved_retransmit_state
  struct dtls1_retransmit_state saved_retransmit_state;
};

struct dtls1_timeout_st
{
  // read_timeouts
  unsigned int read_timeouts;
  // write_timeouts
  unsigned int write_timeouts;
  // num_alerts
  unsigned int num_alerts;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct dtls1_state_st
{
  // send_cookie
  unsigned int send_cookie;
  // cookie
  unsigned char cookie[256l];
  // rcvd_cookie
  unsigned char rcvd_cookie[256l];
  // cookie_len
  unsigned int cookie_len;
  // r_epoch
  unsigned short int r_epoch;
  // w_epoch
  unsigned short int w_epoch;
  // bitmap
  struct dtls1_bitmap_st bitmap;
  // next_bitmap
  struct dtls1_bitmap_st next_bitmap;
  // handshake_write_seq
  unsigned short int handshake_write_seq;
  // next_handshake_write_seq
  unsigned short int next_handshake_write_seq;
  // handshake_read_seq
  unsigned short int handshake_read_seq;
  // last_write_sequence
  unsigned char last_write_sequence[8l];
  // unprocessed_rcds
  struct record_pqueue_st unprocessed_rcds;
  // processed_rcds
  struct record_pqueue_st processed_rcds;
  // buffered_messages
  struct _pqueue *buffered_messages;
  // sent_messages
  struct _pqueue *sent_messages;
  // buffered_app_data
  struct record_pqueue_st buffered_app_data;
  // listen
  unsigned int listen;
  // link_mtu
  unsigned int link_mtu;
  // mtu
  unsigned int mtu;
  // w_msg_hdr
  struct hm_header_st w_msg_hdr;
  // r_msg_hdr
  struct hm_header_st r_msg_hdr;
  // timeout
  struct dtls1_timeout_st timeout;
  // next_timeout
  struct timeval next_timeout;
  // timeout_duration
  unsigned short int timeout_duration;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[12l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // retransmitting
  unsigned int retransmitting;
  // change_cipher_spec_ok
  unsigned int change_cipher_spec_ok;
};

struct env_md_ctx_st
{
  // digest
  const struct env_md_st *digest;
  // engine
  struct engine_st *engine;
  // flags
  unsigned long int flags;
  // md_data
  void *md_data;
  // pctx
  struct evp_pkey_ctx_st *pctx;
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
};

struct env_md_st
{
  // type
  signed int type;
  // pkey_type
  signed int pkey_type;
  // md_size
  signed int md_size;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct env_md_ctx_st *);
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
  // final
  signed int (*final)(struct env_md_ctx_st *, unsigned char *);
  // copy
  signed int (*copy)(struct env_md_ctx_st *, const struct env_md_ctx_st *);
  // cleanup
  signed int (*cleanup)(struct env_md_ctx_st *);
  // sign
  signed int (*sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, void *);
  // verify
  signed int (*verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, void *);
  // required_pkey_type
  signed int required_pkey_type[5l];
  // block_size
  signed int block_size;
  // ctx_size
  signed int ctx_size;
  // md_ctrl
  signed int (*md_ctrl)(struct env_md_ctx_st *, signed int, signed int, void *);
};

union epoll_data
{
  // ptr
  void *ptr;
  // fd
  signed int fd;
  // u32
  unsigned int u32;
  // u64
  unsigned long int u64;
};

struct epoll_event
{
  // events
  unsigned int events;
  // data
  union epoll_data data;
} __attribute__ ((__packed__));

struct evp_cipher_ctx_st
{
  // cipher
  const struct evp_cipher_st *cipher;
  // engine
  struct engine_st *engine;
  // encrypt
  signed int encrypt;
  // buf_len
  signed int buf_len;
  // oiv
  unsigned char oiv[16l];
  // iv
  unsigned char iv[16l];
  // buf
  unsigned char buf[32l];
  // num
  signed int num;
  // app_data
  void *app_data;
  // key_len
  signed int key_len;
  // flags
  unsigned long int flags;
  // cipher_data
  void *cipher_data;
  // final_used
  signed int final_used;
  // block_mask
  signed int block_mask;
  // final
  unsigned char final[32l];
};

struct evp_cipher_st
{
  // nid
  signed int nid;
  // block_size
  signed int block_size;
  // key_len
  signed int key_len;
  // iv_len
  signed int iv_len;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct evp_cipher_ctx_st *, const unsigned char *, const unsigned char *, signed int);
  // do_cipher
  signed int (*do_cipher)(struct evp_cipher_ctx_st *, unsigned char *, const unsigned char *, unsigned long int);
  // cleanup
  signed int (*cleanup)(struct evp_cipher_ctx_st *);
  // ctx_size
  signed int ctx_size;
  // set_asn1_parameters
  signed int (*set_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // get_asn1_parameters
  signed int (*get_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // ctrl
  signed int (*ctrl)(struct evp_cipher_ctx_st *, signed int, signed int, void *);
  // app_data
  void *app_data;
};

struct evp_pkey_st
{
  // type
  signed int type;
  // save_type
  signed int save_type;
  // references
  signed int references;
  // ameth
  const struct evp_pkey_asn1_method_st *ameth;
  // engine
  struct engine_st *engine;
  // pkey
  union anonymous$22 pkey;
  // save_parameters
  signed int save_parameters;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct group
{
  // gr_name
  char *gr_name;
  // gr_passwd
  char *gr_passwd;
  // gr_gid
  unsigned int gr_gid;
  // gr_mem
  char **gr_mem;
};

struct hmac_ctx_st
{
  // md
  const struct env_md_st *md;
  // md_ctx
  struct env_md_ctx_st md_ctx;
  // i_ctx
  struct env_md_ctx_st i_ctx;
  // o_ctx
  struct env_md_ctx_st o_ctx;
  // key_length
  unsigned int key_length;
  // key
  unsigned char key[128l];
};

struct in6_addr
{
  // __in6_u
  union anonymous$9 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct lhash_st_SSL_SESSION
{
  // dummy
  signed int dummy;
};

struct otherName_st
{
  // type_id
  struct asn1_object_st *type_id;
  // value
  struct asn1_type_st *value;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pkcs7_digest_st
{
  // version
  struct asn1_string_st *version;
  // md
  struct X509_algor_st *md;
  // contents
  struct pkcs7_st *contents;
  // digest
  struct asn1_string_st *digest;
};

struct pkcs7_enc_content_st
{
  // content_type
  struct asn1_object_st *content_type;
  // algorithm
  struct X509_algor_st *algorithm;
  // enc_data
  struct asn1_string_st *enc_data;
  // cipher
  const struct evp_cipher_st *cipher;
};

struct pkcs7_encrypted_st
{
  // version
  struct asn1_string_st *version;
  // enc_data
  struct pkcs7_enc_content_st *enc_data;
};

struct pkcs7_enveloped_st
{
  // version
  struct asn1_string_st *version;
  // recipientinfo
  struct stack_st_PKCS7_RECIP_INFO *recipientinfo;
  // enc_data
  struct pkcs7_enc_content_st *enc_data;
};

struct pkcs7_signed_st
{
  // version
  struct asn1_string_st *version;
  // md_algs
  struct stack_st_X509_ALGOR *md_algs;
  // cert
  struct stack_st_X509 *cert;
  // crl
  struct stack_st_X509_CRL *crl;
  // signer_info
  struct stack_st_PKCS7_SIGNER_INFO *signer_info;
  // contents
  struct pkcs7_st *contents;
};

struct pkcs7_signedandenveloped_st
{
  // version
  struct asn1_string_st *version;
  // md_algs
  struct stack_st_X509_ALGOR *md_algs;
  // cert
  struct stack_st_X509 *cert;
  // crl
  struct stack_st_X509_CRL *crl;
  // signer_info
  struct stack_st_PKCS7_SIGNER_INFO *signer_info;
  // enc_data
  struct pkcs7_enc_content_st *enc_data;
  // recipientinfo
  struct stack_st_PKCS7_RECIP_INFO *recipientinfo;
};

struct pkcs7_st
{
  // asn1
  unsigned char *asn1;
  // length
  signed long int length;
  // state
  signed int state;
  // detached
  signed int detached;
  // type
  struct asn1_object_st *type;
  // d
  union anonymous$11 d;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rsa_meth_st
{
  // name
  const char *name;
  // rsa_pub_enc
  signed int (*rsa_pub_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_pub_dec
  signed int (*rsa_pub_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_enc
  signed int (*rsa_priv_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_dec
  signed int (*rsa_priv_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_mod_exp
  signed int (*rsa_mod_exp)(struct bignum_st *, const struct bignum_st *, struct rsa_st *, struct bignum_ctx *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct rsa_st *);
  // finish
  signed int (*finish)(struct rsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // rsa_sign
  signed int (*rsa_sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, const struct rsa_st *);
  // rsa_verify
  signed int (*rsa_verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, const struct rsa_st *);
  // rsa_keygen
  signed int (*rsa_keygen)(struct rsa_st *, signed int, struct bignum_st *, struct bn_gencb_st *);
};

struct rsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // meth
  const struct rsa_meth_st *meth;
  // engine
  struct engine_st *engine;
  // n
  struct bignum_st *n;
  // e
  struct bignum_st *e;
  // d
  struct bignum_st *d;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // dmp1
  struct bignum_st *dmp1;
  // dmq1
  struct bignum_st *dmq1;
  // iqmp
  struct bignum_st *iqmp;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
  // flags
  signed int flags;
  // _method_mod_n
  struct bn_mont_ctx_st *_method_mod_n;
  // _method_mod_p
  struct bn_mont_ctx_st *_method_mod_p;
  // _method_mod_q
  struct bn_mont_ctx_st *_method_mod_q;
  // bignum_data
  char *bignum_data;
  // blinding
  struct bn_blinding_st *blinding;
  // mt_blinding
  struct bn_blinding_st *mt_blinding;
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct srp_ctx_st
{
  // SRP_cb_arg
  void *SRP_cb_arg;
  // TLS_ext_srp_username_callback
  signed int (*TLS_ext_srp_username_callback)(struct ssl_st *, signed int *, void *);
  // SRP_verify_param_callback
  signed int (*SRP_verify_param_callback)(struct ssl_st *, void *);
  // SRP_give_srp_client_pwd_callback
  char * (*SRP_give_srp_client_pwd_callback)(struct ssl_st *, void *);
  // login
  char *login;
  // N
  struct bignum_st *N;
  // g
  struct bignum_st *g;
  // s
  struct bignum_st *s;
  // B
  struct bignum_st *B;
  // A
  struct bignum_st *A;
  // a
  struct bignum_st *a;
  // b
  struct bignum_st *b;
  // v
  struct bignum_st *v;
  // info
  char *info;
  // strength
  signed int strength;
  // srp_Mask
  unsigned long int srp_Mask;
};

struct srtp_protection_profile_st
{
  // name
  const char *name;
  // id
  unsigned long int id;
};

struct ssl2_state_st
{
  // three_byte_header
  signed int three_byte_header;
  // clear_text
  signed int clear_text;
  // escape
  signed int escape;
  // ssl2_rollback
  signed int ssl2_rollback;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_buf
  const unsigned char *wpend_buf;
  // wpend_off
  signed int wpend_off;
  // wpend_len
  signed int wpend_len;
  // wpend_ret
  signed int wpend_ret;
  // rbuf_left
  signed int rbuf_left;
  // rbuf_offs
  signed int rbuf_offs;
  // rbuf
  unsigned char *rbuf;
  // wbuf
  unsigned char *wbuf;
  // write_ptr
  unsigned char *write_ptr;
  // padding
  unsigned int padding;
  // rlength
  unsigned int rlength;
  // ract_data_length
  signed int ract_data_length;
  // wlength
  unsigned int wlength;
  // wact_data_length
  signed int wact_data_length;
  // ract_data
  unsigned char *ract_data;
  // wact_data
  unsigned char *wact_data;
  // mac_data
  unsigned char *mac_data;
  // read_key
  unsigned char *read_key;
  // write_key
  unsigned char *write_key;
  // challenge_length
  unsigned int challenge_length;
  // challenge
  unsigned char challenge[32l];
  // conn_id_length
  unsigned int conn_id_length;
  // conn_id
  unsigned char conn_id[16l];
  // key_material_length
  unsigned int key_material_length;
  // key_material
  unsigned char key_material[48l];
  // read_sequence
  unsigned long int read_sequence;
  // write_sequence
  unsigned long int write_sequence;
  // tmp
  struct anonymous$15 tmp;
};

struct ssl3_buffer_st
{
  // buf
  unsigned char *buf;
  // len
  unsigned long int len;
  // offset
  signed int offset;
  // left
  signed int left;
};

struct ssl3_record_st
{
  // type
  signed int type;
  // length
  unsigned int length;
  // off
  unsigned int off;
  // data
  unsigned char *data;
  // input
  unsigned char *input;
  // comp
  unsigned char *comp;
  // epoch
  unsigned long int epoch;
  // seq_num
  unsigned char seq_num[8l];
};

struct ssl3_state_st
{
  // flags
  signed long int flags;
  // delay_buf_pop_ret
  signed int delay_buf_pop_ret;
  // read_sequence
  unsigned char read_sequence[8l];
  // read_mac_secret_size
  signed int read_mac_secret_size;
  // read_mac_secret
  unsigned char read_mac_secret[64l];
  // write_sequence
  unsigned char write_sequence[8l];
  // write_mac_secret_size
  signed int write_mac_secret_size;
  // write_mac_secret
  unsigned char write_mac_secret[64l];
  // server_random
  unsigned char server_random[32l];
  // client_random
  unsigned char client_random[32l];
  // need_empty_fragments
  signed int need_empty_fragments;
  // empty_fragment_done
  signed int empty_fragment_done;
  // init_extra
  signed int init_extra;
  // rbuf
  struct ssl3_buffer_st rbuf;
  // wbuf
  struct ssl3_buffer_st wbuf;
  // rrec
  struct ssl3_record_st rrec;
  // wrec
  struct ssl3_record_st wrec;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[4l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_type
  signed int wpend_type;
  // wpend_ret
  signed int wpend_ret;
  // wpend_buf
  const unsigned char *wpend_buf;
  // handshake_buffer
  struct bio_st *handshake_buffer;
  // handshake_dgst
  struct env_md_ctx_st **handshake_dgst;
  // change_cipher_spec
  signed int change_cipher_spec;
  // warn_alert
  signed int warn_alert;
  // fatal_alert
  signed int fatal_alert;
  // alert_dispatch
  signed int alert_dispatch;
  // send_alert
  unsigned char send_alert[2l];
  // renegotiate
  signed int renegotiate;
  // total_renegotiations
  signed int total_renegotiations;
  // num_renegotiations
  signed int num_renegotiations;
  // in_read_app_data
  signed int in_read_app_data;
  // client_opaque_prf_input
  void *client_opaque_prf_input;
  // client_opaque_prf_input_len
  unsigned long int client_opaque_prf_input_len;
  // server_opaque_prf_input
  void *server_opaque_prf_input;
  // server_opaque_prf_input_len
  unsigned long int server_opaque_prf_input_len;
  // tmp
  struct anonymous$16 tmp;
  // previous_client_finished
  unsigned char previous_client_finished[64l];
  // previous_client_finished_len
  unsigned char previous_client_finished_len;
  // previous_server_finished
  unsigned char previous_server_finished[64l];
  // previous_server_finished_len
  unsigned char previous_server_finished_len;
  // send_connection_binding
  signed int send_connection_binding;
  // next_proto_neg_seen
  signed int next_proto_neg_seen;
  // is_probably_safari
  char is_probably_safari;
  // alpn_selected
  unsigned char *alpn_selected;
  // alpn_selected_len
  unsigned int alpn_selected_len;
};

struct ssl_cipher_st
{
  // valid
  signed int valid;
  // name
  const char *name;
  // id
  unsigned long int id;
  // algorithm_mkey
  unsigned long int algorithm_mkey;
  // algorithm_auth
  unsigned long int algorithm_auth;
  // algorithm_enc
  unsigned long int algorithm_enc;
  // algorithm_mac
  unsigned long int algorithm_mac;
  // algorithm_ssl
  unsigned long int algorithm_ssl;
  // algo_strength
  unsigned long int algo_strength;
  // algorithm2
  unsigned long int algorithm2;
  // strength_bits
  signed int strength_bits;
  // alg_bits
  signed int alg_bits;
};

struct ssl_comp_st
{
  // id
  signed int id;
  // name
  const char *name;
  // method
  struct comp_method_st *method;
};

struct ssl_ctx_st
{
  // method
  const struct ssl_method_st *method;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // cert_store
  struct x509_store_st *cert_store;
  // sessions
  struct lhash_st_SSL_SESSION *sessions;
  // session_cache_size
  unsigned long int session_cache_size;
  // session_cache_head
  struct ssl_session_st *session_cache_head;
  // session_cache_tail
  struct ssl_session_st *session_cache_tail;
  // session_cache_mode
  signed int session_cache_mode;
  // session_timeout
  signed long int session_timeout;
  // new_session_cb
  signed int (*new_session_cb)(struct ssl_st *, struct ssl_session_st *);
  // remove_session_cb
  void (*remove_session_cb)(struct ssl_ctx_st *, struct ssl_session_st *);
  // get_session_cb
  struct ssl_session_st * (*get_session_cb)(struct ssl_st *, unsigned char *, signed int, signed int *);
  // stats
  struct anonymous$23 stats;
  // references
  signed int references;
  // app_verify_callback
  signed int (*app_verify_callback)(struct x509_store_ctx_st *, void *);
  // app_verify_arg
  void *app_verify_arg;
  // default_passwd_callback
  signed int (*default_passwd_callback)(char *, signed int, signed int, void *);
  // default_passwd_callback_userdata
  void *default_passwd_callback_userdata;
  // client_cert_cb
  signed int (*client_cert_cb)(struct ssl_st *, struct x509_st **, struct evp_pkey_st **);
  // app_gen_cookie_cb
  signed int (*app_gen_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int *);
  // app_verify_cookie_cb
  signed int (*app_verify_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // rsa_md5
  const struct env_md_st *rsa_md5;
  // md5
  const struct env_md_st *md5;
  // sha1
  const struct env_md_st *sha1;
  // extra_certs
  struct stack_st_X509 *extra_certs;
  // comp_methods
  struct stack_st_SSL_COMP *comp_methods;
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // cert
  struct cert_st *cert;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // verify_mode
  signed int verify_mode;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // default_verify_callback
  signed int (*default_verify_callback)(signed int, struct x509_store_ctx_st *);
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // param
  struct X509_VERIFY_PARAM_st *param;
  // quiet_shutdown
  signed int quiet_shutdown;
  // max_send_fragment
  unsigned int max_send_fragment;
  // client_cert_engine
  struct engine_st *client_cert_engine;
  // tlsext_servername_callback
  signed int (*tlsext_servername_callback)(struct ssl_st *, signed int *, void *);
  // tlsext_servername_arg
  void *tlsext_servername_arg;
  // tlsext_tick_key_name
  unsigned char tlsext_tick_key_name[16l];
  // tlsext_tick_hmac_key
  unsigned char tlsext_tick_hmac_key[16l];
  // tlsext_tick_aes_key
  unsigned char tlsext_tick_aes_key[16l];
  // tlsext_ticket_key_cb
  signed int (*tlsext_ticket_key_cb)(struct ssl_st *, unsigned char *, unsigned char *, struct evp_cipher_ctx_st *, struct hmac_ctx_st *, signed int);
  // tlsext_status_cb
  signed int (*tlsext_status_cb)(struct ssl_st *, void *);
  // tlsext_status_arg
  void *tlsext_status_arg;
  // tlsext_opaque_prf_input_callback
  signed int (*tlsext_opaque_prf_input_callback)(struct ssl_st *, void *, unsigned long int, void *);
  // tlsext_opaque_prf_input_callback_arg
  void *tlsext_opaque_prf_input_callback_arg;
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // freelist_max_len
  unsigned int freelist_max_len;
  // wbuf_freelist
  struct ssl3_buf_freelist_st *wbuf_freelist;
  // rbuf_freelist
  struct ssl3_buf_freelist_st *rbuf_freelist;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // next_protos_advertised_cb
  signed int (*next_protos_advertised_cb)(struct ssl_st *, const unsigned char **, unsigned int *, void *);
  // next_protos_advertised_cb_arg
  void *next_protos_advertised_cb_arg;
  // next_proto_select_cb
  signed int (*next_proto_select_cb)(struct ssl_st *, unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // next_proto_select_cb_arg
  void *next_proto_select_cb_arg;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // alpn_select_cb
  signed int (*alpn_select_cb)(struct ssl_st *, const unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // alpn_select_cb_arg
  void *alpn_select_cb_arg;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
};

struct ssl_method_st
{
  // version
  signed int version;
  // ssl_new
  signed int (*ssl_new)(struct ssl_st *);
  // ssl_clear
  void (*ssl_clear)(struct ssl_st *);
  // ssl_free
  void (*ssl_free)(struct ssl_st *);
  // ssl_accept
  signed int (*ssl_accept)(struct ssl_st *);
  // ssl_connect
  signed int (*ssl_connect)(struct ssl_st *);
  // ssl_read
  signed int (*ssl_read)(struct ssl_st *, void *, signed int);
  // ssl_peek
  signed int (*ssl_peek)(struct ssl_st *, void *, signed int);
  // ssl_write
  signed int (*ssl_write)(struct ssl_st *, const void *, signed int);
  // ssl_shutdown
  signed int (*ssl_shutdown)(struct ssl_st *);
  // ssl_renegotiate
  signed int (*ssl_renegotiate)(struct ssl_st *);
  // ssl_renegotiate_check
  signed int (*ssl_renegotiate_check)(struct ssl_st *);
  // ssl_get_message
  signed long int (*ssl_get_message)(struct ssl_st *, signed int, signed int, signed int, signed long int, signed int *);
  // ssl_read_bytes
  signed int (*ssl_read_bytes)(struct ssl_st *, signed int, unsigned char *, signed int, signed int);
  // ssl_write_bytes
  signed int (*ssl_write_bytes)(struct ssl_st *, signed int, const void *, signed int);
  // ssl_dispatch_alert
  signed int (*ssl_dispatch_alert)(struct ssl_st *);
  // ssl_ctrl
  signed long int (*ssl_ctrl)(struct ssl_st *, signed int, signed long int, void *);
  // ssl_ctx_ctrl
  signed long int (*ssl_ctx_ctrl)(struct ssl_ctx_st *, signed int, signed long int, void *);
  // get_cipher_by_char
  const struct ssl_cipher_st * (*get_cipher_by_char)(const unsigned char *);
  // put_cipher_by_char
  signed int (*put_cipher_by_char)(const struct ssl_cipher_st *, unsigned char *);
  // ssl_pending
  signed int (*ssl_pending)(const struct ssl_st *);
  // num_ciphers
  signed int (*num_ciphers)(void);
  // get_cipher
  const struct ssl_cipher_st * (*get_cipher)(unsigned int);
  // get_ssl_method
  struct ssl_method_st * (*get_ssl_method)(signed int);
  // get_timeout
  signed long int (*get_timeout)(void);
  // ssl3_enc
  struct ssl3_enc_method *ssl3_enc;
  // ssl_version
  signed int (*ssl_version)(void);
  // ssl_callback_ctrl
  signed long int (*ssl_callback_ctrl)(struct ssl_st *, signed int, void (*)(void));
  // ssl_ctx_callback_ctrl
  signed long int (*ssl_ctx_callback_ctrl)(struct ssl_ctx_st *, signed int, void (*)(void));
};

struct ssl_session_st
{
  // ssl_version
  signed int ssl_version;
  // key_arg_length
  unsigned int key_arg_length;
  // key_arg
  unsigned char key_arg[8l];
  // master_key_length
  signed int master_key_length;
  // master_key
  unsigned char master_key[48l];
  // session_id_length
  unsigned int session_id_length;
  // session_id
  unsigned char session_id[32l];
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_identity
  char *psk_identity;
  // not_resumable
  signed int not_resumable;
  // sess_cert
  struct sess_cert_st *sess_cert;
  // peer
  struct x509_st *peer;
  // verify_result
  signed long int verify_result;
  // references
  signed int references;
  // timeout
  signed long int timeout;
  // time
  signed long int time;
  // compress_meth
  unsigned int compress_meth;
  // cipher
  const struct ssl_cipher_st *cipher;
  // cipher_id
  unsigned long int cipher_id;
  // ciphers
  struct stack_st_SSL_CIPHER *ciphers;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // prev
  struct ssl_session_st *prev;
  // next
  struct ssl_session_st *next;
  // tlsext_hostname
  char *tlsext_hostname;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_tick
  unsigned char *tlsext_tick;
  // tlsext_ticklen
  unsigned long int tlsext_ticklen;
  // tlsext_tick_lifetime_hint
  signed long int tlsext_tick_lifetime_hint;
  // srp_username
  char *srp_username;
};

struct ssl_st
{
  // version
  signed int version;
  // type
  signed int type;
  // method
  const struct ssl_method_st *method;
  // rbio
  struct bio_st *rbio;
  // wbio
  struct bio_st *wbio;
  // bbio
  struct bio_st *bbio;
  // rwstate
  signed int rwstate;
  // in_handshake
  signed int in_handshake;
  // handshake_func
  signed int (*handshake_func)(struct ssl_st *);
  // server
  signed int server;
  // new_session
  signed int new_session;
  // quiet_shutdown
  signed int quiet_shutdown;
  // shutdown
  signed int shutdown;
  // state
  signed int state;
  // rstate
  signed int rstate;
  // init_buf
  struct buf_mem_st *init_buf;
  // init_msg
  void *init_msg;
  // init_num
  signed int init_num;
  // init_off
  signed int init_off;
  // packet
  unsigned char *packet;
  // packet_length
  unsigned int packet_length;
  // s2
  struct ssl2_state_st *s2;
  // s3
  struct ssl3_state_st *s3;
  // d1
  struct dtls1_state_st *d1;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // hit
  signed int hit;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // mac_flags
  signed int mac_flags;
  // enc_read_ctx
  struct evp_cipher_ctx_st *enc_read_ctx;
  // read_hash
  struct env_md_ctx_st *read_hash;
  // expand
  struct comp_ctx_st *expand;
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // cert
  struct cert_st *cert;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // session
  struct ssl_session_st *session;
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // verify_mode
  signed int verify_mode;
  // verify_callback
  signed int (*verify_callback)(signed int, struct x509_store_ctx_st *);
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // error
  signed int error;
  // error_code
  signed int error_code;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // ctx
  struct ssl_ctx_st *ctx;
  // debug
  signed int debug;
  // verify_result
  signed long int verify_result;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // references
  signed int references;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // first_packet
  signed int first_packet;
  // client_version
  signed int client_version;
  // max_send_fragment
  unsigned int max_send_fragment;
  // tlsext_debug_cb
  void (*tlsext_debug_cb)(struct ssl_st *, signed int, signed int, unsigned char *, signed int, void *);
  // tlsext_debug_arg
  void *tlsext_debug_arg;
  // tlsext_hostname
  char *tlsext_hostname;
  // servername_done
  signed int servername_done;
  // tlsext_status_type
  signed int tlsext_status_type;
  // tlsext_status_expected
  signed int tlsext_status_expected;
  // tlsext_ocsp_ids
  struct stack_st_OCSP_RESPID *tlsext_ocsp_ids;
  // tlsext_ocsp_exts
  struct stack_st_X509_EXTENSION *tlsext_ocsp_exts;
  // tlsext_ocsp_resp
  unsigned char *tlsext_ocsp_resp;
  // tlsext_ocsp_resplen
  signed int tlsext_ocsp_resplen;
  // tlsext_ticket_expected
  signed int tlsext_ticket_expected;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_opaque_prf_input
  void *tlsext_opaque_prf_input;
  // tlsext_opaque_prf_input_len
  unsigned long int tlsext_opaque_prf_input_len;
  // tlsext_session_ticket
  struct tls_session_ticket_ext_st *tlsext_session_ticket;
  // tls_session_ticket_ext_cb
  signed int (*tls_session_ticket_ext_cb)(struct ssl_st *, const unsigned char *, signed int, void *);
  // tls_session_ticket_ext_cb_arg
  void *tls_session_ticket_ext_cb_arg;
  // tls_session_secret_cb
  signed int (*tls_session_secret_cb)(struct ssl_st *, void *, signed int *, struct stack_st_SSL_CIPHER *, struct ssl_cipher_st **, void *);
  // tls_session_secret_cb_arg
  void *tls_session_secret_cb_arg;
  // initial_ctx
  struct ssl_ctx_st *initial_ctx;
  // next_proto_negotiated
  unsigned char *next_proto_negotiated;
  // next_proto_negotiated_len
  unsigned char next_proto_negotiated_len;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // srtp_profile
  struct srtp_protection_profile_st *srtp_profile;
  // tlsext_heartbeat
  unsigned int tlsext_heartbeat;
  // tlsext_hb_pending
  unsigned int tlsext_hb_pending;
  // tlsext_hb_seq
  unsigned int tlsext_hb_seq;
  // renegotiate
  signed int renegotiate;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
};

struct stack_st
{
  // num
  signed int num;
  // data
  char **data;
  // sorted
  signed int sorted;
  // num_alloc
  signed int num_alloc;
  // comp
  signed int (*comp)(const void *, const void *);
};

struct stack_st_ASIdOrRange
{
  // stack
  struct stack_st stack;
};

struct stack_st_ASN1_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_DIST_POINT
{
  // stack
  struct stack_st stack;
};

struct stack_st_GENERAL_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_GENERAL_SUBTREE
{
  // stack
  struct stack_st stack;
};

struct stack_st_IPAddressFamily
{
  // stack
  struct stack_st stack;
};

struct stack_st_PKCS7_RECIP_INFO
{
  // stack
  struct stack_st stack;
};

struct stack_st_PKCS7_SIGNER_INFO
{
  // stack
  struct stack_st stack;
};

struct stack_st_SRTP_PROTECTION_PROFILE
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_CIPHER
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_COMP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ALGOR
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ATTRIBUTE
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_CRL
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_EXTENSION
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_LOOKUP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME_ENTRY
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_REVOKED
{
  // stack
  struct stack_st stack;
};

struct stack_st_void
{
  // stack
  struct stack_st stack;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tls_session_ticket_ext_st
{
  // length
  unsigned short int length;
  // data
  void *data;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct ucred
{
  // pid
  signed int pid;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
};

union wait
{
  // w_status
  signed int w_status;
  // __wait_terminated
  struct anonymous$13 __wait_terminated;
  // __wait_stopped
  struct anonymous$14 __wait_stopped;
};

struct x509_cert_aux_st
{
  // trust
  struct stack_st_ASN1_OBJECT *trust;
  // reject
  struct stack_st_ASN1_OBJECT *reject;
  // alias
  struct asn1_string_st *alias;
  // keyid
  struct asn1_string_st *keyid;
  // other
  struct stack_st_X509_ALGOR *other;
};

struct x509_cinf_st
{
  // version
  struct asn1_string_st *version;
  // serialNumber
  struct asn1_string_st *serialNumber;
  // signature
  struct X509_algor_st *signature;
  // issuer
  struct X509_name_st *issuer;
  // validity
  struct X509_val_st *validity;
  // subject
  struct X509_name_st *subject;
  // key
  struct X509_pubkey_st *key;
  // issuerUID
  struct asn1_string_st *issuerUID;
  // subjectUID
  struct asn1_string_st *subjectUID;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct x509_st
{
  // cert_info
  struct x509_cinf_st *cert_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // valid
  signed int valid;
  // references
  signed int references;
  // name
  char *name;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // ex_pathlen
  signed long int ex_pathlen;
  // ex_pcpathlen
  signed long int ex_pcpathlen;
  // ex_flags
  unsigned long int ex_flags;
  // ex_kusage
  unsigned long int ex_kusage;
  // ex_xkusage
  unsigned long int ex_xkusage;
  // ex_nscert
  unsigned long int ex_nscert;
  // skid
  struct asn1_string_st *skid;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // policy_cache
  struct X509_POLICY_CACHE_st *policy_cache;
  // crldp
  struct stack_st_DIST_POINT *crldp;
  // altname
  struct stack_st_GENERAL_NAME *altname;
  // nc
  struct NAME_CONSTRAINTS_st *nc;
  // rfc3779_addr
  struct stack_st_IPAddressFamily *rfc3779_addr;
  // rfc3779_asid
  struct ASIdentifiers_st *rfc3779_asid;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // aux
  struct x509_cert_aux_st *aux;
};

struct x509_store_ctx_st
{
  // ctx
  struct x509_store_st *ctx;
  // current_method
  signed int current_method;
  // cert
  struct x509_st *cert;
  // untrusted
  struct stack_st_X509 *untrusted;
  // crls
  struct stack_st_X509_CRL *crls;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // other_ctx
  void *other_ctx;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // check_policy
  signed int (*check_policy)(struct x509_store_ctx_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // valid
  signed int valid;
  // last_untrusted
  signed int last_untrusted;
  // chain
  struct stack_st_X509 *chain;
  // tree
  struct X509_POLICY_TREE_st *tree;
  // explicit_policy
  signed int explicit_policy;
  // error_depth
  signed int error_depth;
  // error
  signed int error;
  // current_cert
  struct x509_st *current_cert;
  // current_issuer
  struct x509_st *current_issuer;
  // current_crl
  struct X509_crl_st *current_crl;
  // current_crl_score
  signed int current_crl_score;
  // current_reasons
  unsigned int current_reasons;
  // parent
  struct x509_store_ctx_st *parent;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct x509_store_st
{
  // cache
  signed int cache;
  // objs
  struct stack_st_X509_OBJECT *objs;
  // get_cert_methods
  struct stack_st_X509_LOOKUP *get_cert_methods;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
};


// AccFileName
// file stone.c line 707
char *AccFileName = (char *)(void *)0;
// AccFp
// file stone.c line 706
struct _IO_FILE *AccFp = (struct _IO_FILE *)(void *)0;
// AddrFlag
// file stone.c line 699
signed int AddrFlag = 0;
// AsyncCount
// file stone.c line 613
signed int AsyncCount = 0;
// BacklogMax
// file stone.c line 695
signed int BacklogMax = 50;
// CVS_ID
// file stone.c line 95
static char *CVS_ID = "@(#) $Id: stone.c,v 2.3.2.7 2008/02/24 23:03:16 hiroaki_sengoku Exp $";
// ClientOpts
// file stone.c line 380
struct anonymous$8 ClientOpts;
// ConfigArgc
// file stone.c line 713
signed int ConfigArgc = 0;
// ConfigArgv
// file stone.c line 715
char **ConfigArgv = (char **)(void *)0;
// ConfigFile
// file stone.c line 708
char *ConfigFile = (char *)(void *)0;
// ConnectFrom
// file stone.c line 710
struct anonymous$0 *ConnectFrom = (struct anonymous$0 *)(void *)0;
// CoreDumpDir
// file stone.c line 727
char *CoreDumpDir = (char *)(void *)0;
// CppCommand
// file stone.c line 404
char *CppCommand = "/usr/bin/cpp -traditional";
// CppOptions
// file stone.c line 405
char *CppOptions = (char *)(void *)0;
// DaemonMode
// file stone.c line 718
signed int DaemonMode = 0;
// Debug
// file stone.c line 736
signed int Debug = 0;
// DryRun
// file stone.c line 712
signed int DryRun = 0;
// FastMutex
// file stone.c line 743
union anonymous$3 FastMutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// FastMutexs
// file stone.c line 744
char FastMutexs[11l];
// LogFileName
// file stone.c line 705
char *LogFileName = (char *)(void *)0;
// LogFp
// file stone.c line 704
struct _IO_FILE *LogFp = (struct _IO_FILE *)(void *)0;
// MatchIndex
// file stone.c line 382
signed int MatchIndex;
// MinInterval
// file stone.c line 589
signed int MinInterval = 0;
// Month
// file stone.c line 865
static char Month[12l][4l] = { { 'J', 'a', 'n', 0 }, { 'F', 'e', 'b', 0 }, { 'M', 'a', 'r', 0 }, { 'A', 'p', 'r', 0 }, { 'M', 'a', 'y', 0 }, { 'J', 'u', 'n', 0 }, { 'J', 'u', 'l', 0 }, { 'A', 'u', 'g', 0 }, { 'S', 'e', 'p', 0 }, { 'O', 'c', 't', 0 }, { 'N', 'o', 'v', 0 }, { 'D', 'e', 'c', 0 } };
// MutexConflict
// file stone.c line 614
signed int MutexConflict = 0;
// MyPid
// file stone.c line 731
signed int MyPid;
// NForks
// file stone.c line 733
signed int NForks = 0;
// NSSLMutexs
// file stone.c line 391
signed int NSSLMutexs = 0;
// NewMatchCount
// file stone.c line 383
signed int NewMatchCount = 0;
// OldConfigArgc
// file stone.c line 714
signed int OldConfigArgc = 0;
// OldConfigArgv
// file stone.c line 716
char **OldConfigArgv = (char **)(void *)0;
// OriginMax
// file stone.c line 604
signed int OriginMax = 100;
// OriginTop
// file stone.c line 603
struct _Origin *OriginTop = (struct _Origin *)(void *)0;
// PairIndex
// file stone.c line 381
signed int PairIndex;
// PairTimeOut
// file stone.c line 612
signed int PairTimeOut = 10 * 60;
// PairTop
// file stone.c line 593
struct _Pair *PairTop = (struct _Pair *)(void *)0;
// Pid
// file stone.c line 734
signed int *Pid;
// PidFile
// file stone.c line 709
char *PidFile = (char *)(void *)0;
// ReuseAddr
// file stone.c line 583
signed int ReuseAddr = 0;
// RootDir
// file stone.c line 721
char *RootDir = (char *)(void *)0;
// SSLMutex
// file stone.c line 388
union anonymous$3 *SSLMutex = (union anonymous$3 *)(void *)0;
// ServerOpts
// file stone.c line 379
struct anonymous$8 ServerOpts;
// SetGID
// file stone.c line 725
unsigned int SetGID = (unsigned int)0;
// SetUID
// file stone.c line 724
unsigned int SetUID = (unsigned int)0;
// Syslog
// file stone.c line 701
signed int Syslog = 0;
// SyslogName
// file stone.c line 702
char SyslogName[128l];
// XHostsTrue
// file stone.c line 585
struct _XHosts *XHostsTrue = (struct _XHosts *)(void *)0;
// XferBufMax
// file stone.c line 696
signed int XferBufMax = 1000;
// backups
// file stone.c line 587
struct _Backup *backups = (struct _Backup *)(void *)0;
// basis_64
// file stone.c line 4937
static unsigned char basis_64[65l] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/', 0 };
// conns
// file stone.c line 602
struct _Conn conns;
// data_apop
// file stone.c line 507
const signed int data_apop = 0x0100;
// data_identuser
// file stone.c line 508
const signed int data_identuser = 0x0200;
// data_parm_mask
// file stone.c line 506
const signed int data_parm_mask = 0x00ff;
// data_peeraddr
// file stone.c line 510
const signed int data_peeraddr = 0x0400;
// data_ucred
// file stone.c line 509
const signed int data_ucred = 0x0300;
// ePollFd
// file stone.c line 608
signed int ePollFd;
// freeExBot
// file stone.c line 599
struct _ExBuf *freeExBot = (struct _ExBuf *)(void *)0;
// freeExBotClock
// file stone.c line 601
signed long int freeExBotClock = (signed long int)0;
// freeExBuf
// file stone.c line 597
struct _ExBuf *freeExBuf = (struct _ExBuf *)(void *)0;
// freePairs
// file stone.c line 595
struct _Pair *freePairs = (struct _Pair *)(void *)0;
// freePktBuf
// file stone.c line 605
struct _PktBuf *freePktBuf = (struct _PktBuf *)(void *)0;
// healthChat
// file stone.c line 586
struct _Chat *healthChat = (struct _Chat *)(void *)0;
// healthComm
// file stone.c line 5913
struct _Comm healthComm[10l];
// healthComm
// file stone.c line 5913
struct _Comm healthComm[10l] = { { .str="HELO", .func=healthHELO }, { .str="STAT", .func=healthSTAT }, { .str="FREE", .func=healthFREE }, { .str="CLOCK", .func=healthCLOCK }, { .str="CVS_ID", .func=healthCVS_ID }, { .str="CONFIG", .func=healthCONFIG }, { .str="STONE", .func=healthSTONE }, { .str="LIMIT", .func=healthLIMIT }, { .str="QUIT", .func=healthQUIT }, { .str=(char *)(void *)0, .func=healthErr } };
// identdComm
// file stone.c line 5725
struct _Comm identdComm[3l];
// identdComm
// file stone.c line 5725
struct _Comm identdComm[3l] = { { .str="QUIT", .func=identdQUIT }, { .str="", .func=identdQUERY }, { .str=(char *)(void *)0, .func=identdQUERY } };
// index_64
// file stone.c line 4978
static unsigned char index_64[256l] = { (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)62, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)63, (unsigned char)52, (unsigned char)53, (unsigned char)54, (unsigned char)55, (unsigned char)56, (unsigned char)57, (unsigned char)58, (unsigned char)59, (unsigned char)60, (unsigned char)61, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)254, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)3, (unsigned char)4, (unsigned char)5, (unsigned char)6, (unsigned char)7, (unsigned char)8, (unsigned char)9, (unsigned char)10, (unsigned char)11, (unsigned char)12, (unsigned char)13, (unsigned char)14, (unsigned char)15, (unsigned char)16, (unsigned char)17, (unsigned char)18, (unsigned char)19, (unsigned char)20, (unsigned char)21, (unsigned char)22, (unsigned char)23, (unsigned char)24, (unsigned char)25, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)26, (unsigned char)27, (unsigned char)28, (unsigned char)29, (unsigned char)30, (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34, (unsigned char)35, (unsigned char)36, (unsigned char)37, (unsigned char)38, (unsigned char)39, (unsigned char)40, (unsigned char)41, (unsigned char)42, (unsigned char)43, (unsigned char)44, (unsigned char)45, (unsigned char)46, (unsigned char)47, (unsigned char)48, (unsigned char)49, (unsigned char)50, (unsigned char)51, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255 };
// lastEstablished
// file stone.c line 591
signed long int lastEstablished = (signed long int)0;
// lastReadWrite
// file stone.c line 592
signed long int lastReadWrite = (signed long int)0;
// lastScanBackups
// file stone.c line 590
signed long int lastScanBackups = (signed long int)0;
// lbsets
// file stone.c line 588
struct _LBSet *lbsets = (struct _LBSet *)(void *)0;
// limitComm
// file stone.c line 5804
struct _Comm limitComm[6l];
// limitComm
// file stone.c line 5804
struct _Comm limitComm[6l] = { { .str="PAIR", .func=limitPair }, { .str="CONN", .func=limitConn }, { .str="ESTABLISHED", .func=limitEstablished },
    { .str="READWRITE", .func=limitReadWrite },
    { .str="ASYNC", .func=limitAsync }, { .str=(char *)(void *)0, .func=limitErr } };
// nFreeExBot
// file stone.c line 600
signed int nFreeExBot = 0;
// nFreeExBuf
// file stone.c line 598
signed int nFreeExBuf = 0;
// nFreePairs
// file stone.c line 596
signed int nFreePairs = 0;
// nFreePktBuf
// file stone.c line 606
signed int nFreePktBuf = 0;
// oldstones
// file stone.c line 582
struct _Stone *oldstones = (struct _Stone *)(void *)0;
// pkt_len_max
// file stone.c line 698
signed int pkt_len_max = 2048;
// portXHosts
// file stone.c line 584
struct _PortXHosts *portXHosts = (struct _PortXHosts *)(void *)0;
// proto_base_d
// file stone.c line 653
const signed int proto_base_d = 0x20000000;
// proto_base_s
// file stone.c line 652
const signed int proto_base_s = 0x10000000;
// proto_block_d
// file stone.c line 630
const signed int proto_block_d = 0x800000;
// proto_block_s
// file stone.c line 629
const signed int proto_block_s = 0x400000;
// proto_close
// file stone.c line 643
const signed int proto_close = 0x200000;
// proto_command
// file stone.c line 617
const signed int proto_command = 0x0f00;
// proto_connect
// file stone.c line 636
const signed int proto_connect = 0x4000;
// proto_conninprog
// file stone.c line 649
const signed int proto_conninprog = 0x2000000;
// proto_dgram
// file stone.c line 637
const signed int proto_dgram = 0x8000;
// proto_dirty
// file stone.c line 634
const signed int proto_dirty = 0x1000;
// proto_eof
// file stone.c line 644
const signed int proto_eof = 0x400000;
// proto_error
// file stone.c line 645
const signed int proto_error = 0x800000;
// proto_first_r
// file stone.c line 638
const signed int proto_first_r = 0x10000;
// proto_first_w
// file stone.c line 639
const signed int proto_first_w = 0x20000;
// proto_ident
// file stone.c line 619
const signed int proto_ident = 0x1000;
// proto_ip_only_d
// file stone.c line 626
const signed int proto_ip_only_d = 0x80000;
// proto_ip_only_s
// file stone.c line 625
const signed int proto_ip_only_s = 0x40000;
// proto_nobackup
// file stone.c line 620
const signed int proto_nobackup = 0x2000;
// proto_noconnect
// file stone.c line 635
const signed int proto_noconnect = 0x2000;
// proto_ohttp_d
// file stone.c line 651
const signed int proto_ohttp_d = 0x8000000;
// proto_ohttp_s
// file stone.c line 650
const signed int proto_ohttp_s = 0x4000000;
// proto_select_r
// file stone.c line 640
const signed int proto_select_r = 0x40000;
// proto_select_w
// file stone.c line 641
const signed int proto_select_w = 0x80000;
// proto_shutdown
// file stone.c line 642
const signed int proto_shutdown = 0x100000;
// proto_ssl_d
// file stone.c line 632
const signed int proto_ssl_d = 0x2000000;
// proto_ssl_s
// file stone.c line 631
const signed int proto_ssl_s = 0x1000000;
// proto_udp_d
// file stone.c line 622
const signed int proto_udp_d = 0x8000;
// proto_udp_s
// file stone.c line 621
const signed int proto_udp_s = 0x4000;
// proto_unix_d
// file stone.c line 628
const signed int proto_unix_d = 0x200000;
// proto_unix_s
// file stone.c line 627
const signed int proto_unix_s = 0x100000;
// proto_v6_d
// file stone.c line 624
const signed int proto_v6_d = 0x20000;
// proto_v6_s
// file stone.c line 623
const signed int proto_v6_s = 0x10000;
// proxyComm
// file stone.c line 5541
struct _Comm proxyComm[5l];
// proxyComm
// file stone.c line 5541
struct _Comm proxyComm[5l] = { { .str="CONNECT", .func=proxyCONNECT }, { .str="POST", .func=proxyPOST }, { .str="GET", .func=proxyGET }, { .str="HEAD", .func=proxyHEAD }, { .str=(char *)(void *)0, .func=proxyErr } };
// sf_ab_on_r
// file stone.c line 691
const signed int sf_ab_on_r = 0x04000;
// sf_ab_on_w
// file stone.c line 692
const signed int sf_ab_on_w = 0x08000;
// sf_cb_on_r
// file stone.c line 689
const signed int sf_cb_on_r = 0x01000;
// sf_cb_on_w
// file stone.c line 690
const signed int sf_cb_on_w = 0x02000;
// sf_depth
// file stone.c line 683
const signed int sf_depth = 0x000f0;
// sf_depth_bit
// file stone.c line 684
const signed int sf_depth_bit = 4;
// sf_mask
// file stone.c line 682
const signed int sf_mask = 0x0000f;
// sf_rb_on_w
// file stone.c line 688
const signed int sf_rb_on_w = 0x00800;
// sf_sb_on_r
// file stone.c line 685
const signed int sf_sb_on_r = 0x00100;
// sf_sb_on_w
// file stone.c line 686
const signed int sf_sb_on_w = 0x00200;
// sf_wb_on_r
// file stone.c line 687
const signed int sf_wb_on_r = 0x00400;
// sslparm_ignore
// file stone.c line 340
const signed int sslparm_ignore = 0x01;
// sslparm_sni
// file stone.c line 342
const signed int sslparm_sni = 0x04;
// sslparm_storeca
// file stone.c line 341
const signed int sslparm_storeca = 0x02;
// state_mask
// file stone.c line 616
const signed int state_mask = 0x00ff;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// stones
// file stone.c line 581
struct _Stone *stones = (struct _Stone *)(void *)0;
// thread_attr
// file stone.c line 189
union pthread_attr_t thread_attr;
// trash
// file stone.c line 594
struct _Pair trash;

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32$1;
  return_value___builtin_bswap32$1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32$1;
}

// acceptCheck
// file stone.c line 4279
signed int acceptCheck(struct _Pair *pair1)
{
  struct sockaddr_storage ss;
  struct sockaddr *from = (struct sockaddr *)&ss;
  unsigned int fromlen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  struct _Stone *stone = pair1->stone;
  struct _Pair *pair2 = (struct _Pair *)(void *)0;
  signed int satype;
  signed int saproto = 0;
  struct _XHosts *xhost;
  char ident[128l];
  char fromstr[255l];
  signed int fslen = 0;
  ident[(signed long int)0] = (char)0;
  bcopy((const void *)pair1->t->buf, (void *)&fromlen, sizeof(unsigned int) /*4ul*/ );
  if(fromlen >= 1u && !((unsigned long int)fromlen >= 129ul))
    bcopy((const void *)(pair1->t->buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), (void *)from, (unsigned long int)fromlen);

  else
  {
    message(3, "%d TCP %d: acceptCheck Can't happen fromlen=%d", stone->sd, pair1->sd, fromlen);
    signed int return_value_getpeername$2;
    return_value_getpeername$2=getpeername(pair1->sd, from, &fromlen);
    if(!(return_value_getpeername$2 >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      message(3, "%d TCP %d: acceptCheck Can't get peer's name err=%d", stone->sd, pair1->sd, *return_value___errno_location$1);
      return 0;
    }

  }
  signed int tmp_post$4;
  if(!((stone->proto & proto_ident) == 0))
  {
    signed int return_value_getident$5;
    return_value_getident$5=getident(ident, from, fromlen, stone->port, &stone->listen->addr, stone->listen->len);
    if(!(return_value_getident$5 == 0))
    {
      struct _ExBuf *t;
      t=newExData(pair1, data_identuser);
      __builtin_strncpy(fromstr, ident, (unsigned long int)127);
      fromstr[(signed long int)127] = (char)0;
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(fromstr);
      fslen = (signed int)return_value_strlen$3;
      if(!(t == ((struct _ExBuf *)NULL)))
      {
        strcpy(t->buf + (signed long int)sizeof(signed int) /*4ul*/ , fromstr);
        t->len = (signed int)(sizeof(signed int) /*4ul*/  + (unsigned long int)fslen);
      }

      tmp_post$4 = fslen;
      fslen = fslen + 1;
      fromstr[(signed long int)tmp_post$4] = (char)64;
    }

  }

  fromstr[(signed long int)fslen] = (char)0;
  xhost=checkXhost(stone->xhosts, from, fromlen);
  unsigned short int tmp_statement_expression$6;
  unsigned short int tmp_statement_expression$7;
  if(xhost == ((struct _XHosts *)NULL))
  {
    addrport2strOnce(from, fromlen, stone->proto & (proto_udp_s | proto_command | proto_ohttp_s | proto_base_s | proto_v6_s | proto_ip_only_s | proto_ssl_s | proto_ident), fromstr + (signed long int)fslen, 127 * 2 - fslen, 0);
    message(4, "stone %d: access denied: from %s", stone->sd, (const void *)fromstr);
    shutdown(pair1->sd, 2);
    return 0;
  }

  else
  {
    if(!(AccFp == ((struct _IO_FILE *)NULL)))
    {
      char str[128l];
      char tstr[128l];
      signed short int port = (signed short int)0;
      signed long int clock;
      time(&clock);
      if((signed int)from->sa_family == 2)
      {
        unsigned short int __v;
        unsigned short int __x = (unsigned short int)((struct sockaddr_in *)from)->sin_port;
        asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
        tmp_statement_expression$6 = __v;
        port = (signed short int)tmp_statement_expression$6;
      }

      else
        if((signed int)from->sa_family == 10)
        {
          unsigned short int acceptCheck$$1$$5$$2$$1$$__v;
          unsigned short int acceptCheck$$1$$5$$2$$1$$__x = (unsigned short int)((struct sockaddr_in6 *)from)->sin6_port;
          asm("rorw $8, %w0" : "=r"(acceptCheck$$1$$5$$2$$1$$__v) : "0"(acceptCheck$$1$$5$$2$$1$$__x) : "cc");
          tmp_statement_expression$7 = acceptCheck$$1$$5$$2$$1$$__v;
          port = (signed short int)tmp_statement_expression$7;
        }

      addr2str(from, fromlen, str, 127, 1);
      str[(signed long int)127] = (char)0;
      strntime(tstr, 127, &clock, (signed long int)-1);
      tstr[(signed long int)127] = (char)0;
      addrport2strOnce(from, fromlen, stone->proto & (proto_udp_s | proto_command | proto_ohttp_s | proto_base_s | proto_v6_s | proto_ip_only_s | proto_ssl_s | proto_ident), fromstr + (signed long int)fslen, 127 * 2 - fslen, 0);
      fprintf(AccFp, "%s%d[%d] %s[%s]%d\n", (const void *)tstr, stone->port, stone->sd, (const void *)fromstr, (const void *)str, port);
    }

    if((0xF & (signed int)xhost->mode) >= 1 || Debug >= 2)
    {
      addrport2strOnce(from, fromlen, stone->proto & (proto_udp_s | proto_command | proto_ohttp_s | proto_base_s | proto_v6_s | proto_ip_only_s | proto_ssl_s | proto_ident), fromstr + (signed long int)fslen, 127 * 2 - fslen, 0);
      message(7, "stone %d: accepted TCP %d from %s mode=%d", stone->sd, pair1->sd, (const void *)fromstr, xhost->mode);
    }

    pair2=newPair();
    if(pair2 == ((struct _Pair *)NULL))
    {
      message(2, "stone %d: out of memory, closing TCP %d", stone->sd, pair1->sd);
      if(!(pair2 == ((struct _Pair *)NULL)))
        freePair(pair2);

      return 0;
    }

    else
    {
      pair2->stone = stone;
      pair2->xhost = xhost;
      pair1->xhost = pair2->xhost;
      pair2->proto = stone->proto & (proto_ohttp_d | proto_base_d | proto_command) | proto_first_r | proto_first_w;
      pair2->timeout = stone->timeout;
      if((stone->proto & proto_block_d) == 0)
        fcntl(pair1->sd, 4, 04000);

      if(!((stone->proto & proto_ssl_s) == 0))
      {
        signed int return_value_doSSL_accept$8;
        return_value_doSSL_accept$8=doSSL_accept(pair1);
        if(!(return_value_doSSL_accept$8 >= 0))
          goto error;

      }

      else
        pair1->proto = pair1->proto | proto_connect | proto_dirty;
      if(!((stone->proto & proto_udp_d) == 0))
      {
        pair2->proto = pair2->proto | proto_dgram;
        satype = 2;
        saproto = 17;
      }

      else
      {
        satype = 1;
        saproto = 6;
      }
      if(!((stone->proto & proto_unix_d) == 0))
      {
        saproto = 0;
        pair2->sd=socket(1, satype, saproto);
      }

      else
        if(!((stone->proto & proto_v6_d) == 0))
          pair2->sd=socket(10, satype, saproto);

        else
          pair2->sd=socket(2, satype, saproto);
      if(!(pair2->sd >= 0))
      {
        signed int return_value_priority$9;
        return_value_priority$9=priority(pair1);
        signed int *return_value___errno_location$10;
        return_value___errno_location$10=__errno_location();
        message(return_value_priority$9, "%d TCP %d: can't create socket err=%d", stone->sd, pair1->sd, *return_value___errno_location$10);

      error:
        ;
        freePair(pair2);
        return 0;
      }

      if(!(stone->from == ((struct anonymous$0 *)NULL)))
      {
        signed int return_value_bind$12;
        return_value_bind$12=bind(pair2->sd, &stone->from->addr, stone->from->len);
        if(!(return_value_bind$12 >= 0))
        {
          char acceptCheck$$1$$14$$1$$str[128l];
          addrport2str(&stone->from->addr, stone->from->len, 0, acceptCheck$$1$$14$$1$$str, 127, 0);
          acceptCheck$$1$$14$$1$$str[(signed long int)127] = (char)0;
          signed int *return_value___errno_location$11;
          return_value___errno_location$11=__errno_location();
          message(3, "stone %d: can't bind %s err=%d", stone->sd, (const void *)acceptCheck$$1$$14$$1$$str, *return_value___errno_location$11);
        }

      }

      pair2->pair = pair1;
      pair1->pair = pair2;
      return 1;
    }
  }
}

// acceptPair
// file stone.c line 4021
struct _Pair * acceptPair(struct _Stone *stone)
{
  struct sockaddr_storage ss;
  struct sockaddr *from = (struct sockaddr *)&ss;
  unsigned int fromlen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  struct _Pair *pair;
  struct epoll_event ev;
  signed int nsd;
  nsd=accept(stone->sd, from, &fromlen);
  signed int *return_value___errno_location$2;
  signed int *return_value___errno_location$1;
  if(!(nsd >= 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    if(*return_value___errno_location$3 == 4)
    {
      if(Debug >= 5)
        message(7, "stone %d: accept interrupted", stone->sd);

      return (struct _Pair *)(void *)0;
    }

    else
    {
      return_value___errno_location$2=__errno_location();
      if(*return_value___errno_location$2 == 11)
      {
        if(Debug >= 5)
          message(7, "stone %d: accept no connection", stone->sd);

        return (struct _Pair *)(void *)0;
      }

      else
      {
        return_value___errno_location$1=__errno_location();
        if(*return_value___errno_location$1 == 9)
        {
          if(!(Debug >= 5))
            return (struct _Pair *)(void *)0;

        }

      }
    }
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    message(3, "stone %d: accept error err=%d", stone->sd, *return_value___errno_location$4);
    return (struct _Pair *)(void *)0;
  }

  pair=newPair();
  if(pair == ((struct _Pair *)NULL))
  {
    message(2, "stone %d: out of memory, closing TCP %d", stone->sd, nsd);
    close(nsd);
    freePair(pair);
    return (struct _Pair *)(void *)0;
  }

  else
  {
    bcopy((const void *)&fromlen, (void *)pair->t->buf, sizeof(unsigned int) /*4ul*/ );
    bcopy((const void *)from, (void *)(pair->t->buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), (unsigned long int)fromlen);
    pair->sd = nsd;
    pair->stone = stone;
    pair->proto = stone->proto & (proto_ohttp_s | proto_base_s) & ~proto_command | proto_first_r | proto_first_w | 0x0f00;
    pair->timeout = stone->timeout;
    ev.events = (unsigned int)1073741824;
    ev.data.ptr = (void *)pair;
    if(Debug >= 7)
      message(7, "%d TCP %d: acceptPair epoll_ctl %d ADD %x", stone->sd, pair->sd, ePollFd, (signed int)ev.data.ptr);

    signed int return_value_epoll_ctl$6;
    return_value_epoll_ctl$6=epoll_ctl(ePollFd, 1, pair->sd, &ev);
    if(!(return_value_epoll_ctl$6 >= 0))
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      message(3, "%d TCP %d: acceptPair epoll_ctl %d ADD err=%d", stone->sd, pair->sd, ePollFd, *return_value___errno_location$5);
    }

    return pair;
  }
}

// addr2ip
// file stone.c line 1062
char * addr2ip(struct in_addr *addr, char *str, signed int len)
{
  /* tag-#anon#lUN[U64'l'||lARR4{U8}$U8$'c'|] */
union anonymous$6
{
  // l
  unsigned long int l;
  // c
  unsigned char c[4l];
};

/* */
  ;
  union anonymous$6 u;
  if(len >= 1)
  {
    u.l = (unsigned long int)addr->s_addr;
    snprintf(str, (unsigned long int)(len - 1), "%d.%d.%d.%d", u.c[(signed long int)0], u.c[(signed long int)1], u.c[(signed long int)2], u.c[(signed long int)3]);
    str[(signed long int)(len - 1)] = (char)0;
  }

  return str;
}

// addr2ip6
// file stone.c line 1076
char * addr2ip6(struct in6_addr *addr, char *str, signed int len)
{
  unsigned short int *s;
  unsigned short int tmp_statement_expression$1;
  unsigned short int tmp_statement_expression$2;
  unsigned short int tmp_statement_expression$3;
  unsigned short int tmp_statement_expression$4;
  unsigned short int tmp_statement_expression$5;
  unsigned short int tmp_statement_expression$6;
  unsigned short int tmp_statement_expression$7;
  unsigned short int tmp_statement_expression$8;
  if(len >= 1)
  {
    s = (unsigned short int *)addr;
    unsigned short int addr2ip6$$1$$1$$1$$__v;
    unsigned short int addr2ip6$$1$$1$$1$$__x = (unsigned short int)s[(signed long int)0];
    asm("rorw $8, %w0" : "=r"(addr2ip6$$1$$1$$1$$__v) : "0"(addr2ip6$$1$$1$$1$$__x) : "cc");
    tmp_statement_expression$1 = addr2ip6$$1$$1$$1$$__v;
    unsigned short int addr2ip6$$1$$1$$2$$__v;
    unsigned short int addr2ip6$$1$$1$$2$$__x = (unsigned short int)s[(signed long int)1];
    asm("rorw $8, %w0" : "=r"(addr2ip6$$1$$1$$2$$__v) : "0"(addr2ip6$$1$$1$$2$$__x) : "cc");
    tmp_statement_expression$2 = addr2ip6$$1$$1$$2$$__v;
    unsigned short int addr2ip6$$1$$1$$3$$__v;
    unsigned short int addr2ip6$$1$$1$$3$$__x = (unsigned short int)s[(signed long int)2];
    asm("rorw $8, %w0" : "=r"(addr2ip6$$1$$1$$3$$__v) : "0"(addr2ip6$$1$$1$$3$$__x) : "cc");
    tmp_statement_expression$3 = addr2ip6$$1$$1$$3$$__v;
    unsigned short int addr2ip6$$1$$1$$4$$__v;
    unsigned short int __x = (unsigned short int)s[(signed long int)3];
    asm("rorw $8, %w0" : "=r"(addr2ip6$$1$$1$$4$$__v) : "0"(__x) : "cc");
    tmp_statement_expression$4 = addr2ip6$$1$$1$$4$$__v;
    unsigned short int __v;
    unsigned short int addr2ip6$$1$$1$$5$$__x = (unsigned short int)s[(signed long int)4];
    asm("rorw $8, %w0" : "=r"(__v) : "0"(addr2ip6$$1$$1$$5$$__x) : "cc");
    tmp_statement_expression$5 = __v;
    unsigned short int addr2ip6$$1$$1$$6$$__v;
    unsigned short int addr2ip6$$1$$1$$6$$__x = (unsigned short int)s[(signed long int)5];
    asm("rorw $8, %w0" : "=r"(addr2ip6$$1$$1$$6$$__v) : "0"(addr2ip6$$1$$1$$6$$__x) : "cc");
    tmp_statement_expression$6 = addr2ip6$$1$$1$$6$$__v;
    unsigned short int addr2ip6$$1$$1$$7$$__v;
    unsigned short int addr2ip6$$1$$1$$7$$__x = (unsigned short int)s[(signed long int)6];
    asm("rorw $8, %w0" : "=r"(addr2ip6$$1$$1$$7$$__v) : "0"(addr2ip6$$1$$1$$7$$__x) : "cc");
    tmp_statement_expression$7 = addr2ip6$$1$$1$$7$$__v;
    unsigned short int addr2ip6$$1$$1$$8$$__v;
    unsigned short int addr2ip6$$1$$1$$8$$__x = (unsigned short int)s[(signed long int)7];
    asm("rorw $8, %w0" : "=r"(addr2ip6$$1$$1$$8$$__v) : "0"(addr2ip6$$1$$1$$8$$__x) : "cc");
    tmp_statement_expression$8 = addr2ip6$$1$$1$$8$$__v;
    snprintf(str, (unsigned long int)(len - 1), "%x:%x:%x:%x:%x:%x:%x:%x", tmp_statement_expression$1, tmp_statement_expression$2, tmp_statement_expression$3, tmp_statement_expression$4, tmp_statement_expression$5, tmp_statement_expression$6, tmp_statement_expression$7, tmp_statement_expression$8);
    str[(signed long int)(len - 1)] = (char)0;
  }

  return str;
}

// addr2numeric
// file stone.c line 1089
char * addr2numeric(struct sockaddr *sa, char *str, signed int len)
{
  if((signed int)sa->sa_family == 2)
    addr2ip(&((struct sockaddr_in *)sa)->sin_addr, str, len);

  else
    if((signed int)sa->sa_family == 10)
      addr2ip6(&((struct sockaddr_in6 *)sa)->sin6_addr, str, len);

    else
      snprintf(str, (unsigned long int)len, "%s", (const void *)"???");
  return str;
}

// addr2str
// file stone.c line 1270
char * addr2str(struct sockaddr *sa, unsigned int salen, char *str, signed int len, signed int flags)
{
  signed int err;
  if(!(AddrFlag == 0))
    flags = flags | 1;

  err=getnameinfo(sa, salen, str, (unsigned int)len, (char *)(void *)0, (unsigned int)0, flags);
  if(!(err == 0))
  {
    addr2numeric(sa, str, len);
    if(len >= 1)
      str[(signed long int)(len - 1)] = (char)0;

    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    message(3, "Unknown address: %s err=%d errno=%d", str, err, *return_value___errno_location$1);
  }

  return str;
}

// addrport2str
// file stone.c line 1287
char * addrport2str(struct sockaddr *sa, unsigned int salen, signed int proto, char *str, signed int len, signed int flags)
{
  char serv[128l];
  signed int err;
  signed int i;
  signed int return_value_islocalhost$1;
  unsigned short int tmp_statement_expression$3;
  unsigned short int tmp_statement_expression$5;
  if(str == ((char *)NULL) || !(len >= 2))
    return "";

  else
  {
    str[(signed long int)(len - 1)] = (char)0;
    serv[(signed long int)0] = (char)0;
    if(!(AddrFlag == 0))
      flags = flags | 1 | 2;

    else
      if(!(((proto_udp_d | proto_udp_s) & proto) == 0))
        flags = flags | 16;

    if((1 & flags) == 0)
    {
      return_value_islocalhost$1=islocalhost(sa);
      if(!(return_value_islocalhost$1 == 0))
        flags = flags | 1;

    }

    if(Debug >= 11)
    {
      addr2numeric(sa, serv, 127);
      serv[(signed long int)127] = (char)0;
      message(7, "getnameinfo: %s family=%d len=%d flags=%d", (const void *)serv, sa->sa_family, salen, flags);
    }

    if((signed int)sa->sa_family == 1)
    {
      signed int j = (signed int)((signed long int)salen - (((struct sockaddr_un *)sa)->sun_path - (char *)sa));
      __builtin_strncpy(serv, ((struct sockaddr_un *)sa)->sun_path, (unsigned long int)j);
      serv[(signed long int)j] = (char)0;
      snprintf(str, (unsigned long int)len, "%s", (const void *)"unix");
      err = 0;
    }

    else
      err=getnameinfo(sa, salen, str, (unsigned int)len, serv, (unsigned int)127, flags);
    if(!(err == 0))
    {
      if((signed int)sa->sa_family == 2)
      {
        addr2ip(&((struct sockaddr_in *)sa)->sin_addr, str, len);
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(str);
        i = (signed int)return_value_strlen$2;
        unsigned short int __v;
        unsigned short int addrport2str$$1$$3$$1$$1$$__x = (unsigned short int)((struct sockaddr_in *)sa)->sin_port;
        asm("rorw $8, %w0" : "=r"(__v) : "0"(addrport2str$$1$$3$$1$$1$$__x) : "cc");
        tmp_statement_expression$3 = __v;
        snprintf(str + (signed long int)i, (unsigned long int)((len - i) - 5), ":%d", tmp_statement_expression$3);
      }

      else
        if((signed int)sa->sa_family == 10)
        {
          addr2ip6(&((struct sockaddr_in6 *)sa)->sin6_addr, str, len);
          unsigned long int return_value_strlen$4;
          return_value_strlen$4=strlen(str);
          i = (signed int)return_value_strlen$4;
          unsigned short int addrport2str$$1$$3$$2$$1$$__v;
          unsigned short int __x = (unsigned short int)((struct sockaddr_in6 *)sa)->sin6_port;
          asm("rorw $8, %w0" : "=r"(addrport2str$$1$$3$$2$$1$$__v) : "0"(__x) : "cc");
          tmp_statement_expression$5 = addrport2str$$1$$3$$2$$1$$__v;
          snprintf(str + (signed long int)i, (unsigned long int)((len - i) - 5), ":%d", tmp_statement_expression$5);
        }

        else
          snprintf(str, (unsigned long int)len, "%s:?", (const void *)"???");
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      message(3, "Unknown node:serv %s len=%d err=%d errno=%d", str, salen, err, *return_value___errno_location$6);
    }

    else
    {
      unsigned long int return_value_strlen$7;
      return_value_strlen$7=strlen(str);
      i = (signed int)return_value_strlen$7;
      snprintf(str + (signed long int)i, (unsigned long int)(len - i), ":%s", (const void *)serv);
    }
    unsigned long int return_value_strlen$8;
    return_value_strlen$8=strlen(str);
    i = (signed int)return_value_strlen$8;
    ext2str(proto, str + (signed long int)i, len - i);
    return str;
  }
}

// addrport2strOnce
// file stone.c line 1359
char * addrport2strOnce(struct sockaddr *sa, unsigned int salen, signed int proto, char *str, signed int len, signed int flags)
{
  if(*str == 0)
  {
    addrport2str(sa, salen, proto, str, len, flags);
    str[(signed long int)len] = (char)0;
  }

  return str;
}

// asyncAcceptConnect
// file stone.c line 6791
void asyncAcceptConnect(struct _Pair *pair)
{
  if(Debug >= 8)
    message(7, "ASYNC_BEGIN: %d", AsyncCount);

  doAcceptConnect(pair);
  if(Debug >= 8)
    message(7, "ASYNC_END: %d", AsyncCount);

  waitMutex(3);
  AsyncCount = AsyncCount - 1;
  freeMutex(3);
  ERR_remove_state((unsigned long int)0);
}

// asyncConn
// file stone.c line 3946
void asyncConn(struct _Conn *conn)
{
  struct _Pair *p1;
  struct _Pair *p2;
  if(Debug >= 8)
    message(7, "ASYNC_BEGIN: %d", AsyncCount);

  if(Debug >= 9)
    message(7, "asyncConn");

  p1 = conn->pair;
  if(p1 == ((struct _Pair *)NULL))
  {
    conn->pair = (struct _Pair *)(void *)0;
    conn->lock = -1;
  }

  else
  {
    signed int ret;
    ret=doconnect(p1, &conn->dst->addr, conn->dst->len);
    if(ret == 0 || ret == -2)
      conn->lock = 0;

    else
    {
      if(!(p1 == ((struct _Pair *)NULL)))
        p1->count = p1->count - 10;

      conn->pair = (struct _Pair *)(void *)0;
      conn->lock = -1;
    }
  }
  if(!(p1 == ((struct _Pair *)NULL)))
  {
    p1->proto = p1->proto | proto_dirty;
    p2 = p1->pair;
  }

  else
    p2 = (struct _Pair *)(void *)0;
  if(!(p2 == ((struct _Pair *)NULL)))
    p2->proto = p2->proto | proto_dirty;

  if(Debug >= 8)
    message(7, "ASYNC_END: %d", AsyncCount);

  waitMutex(3);
  AsyncCount = AsyncCount - 1;
  freeMutex(3);
  ERR_remove_state((unsigned long int)0);
}

// asyncHealthCheck
// file stone.c line 1955
void asyncHealthCheck(struct _Backup *b)
{
  signed long int now;
  char addrport[128l];
  if(Debug >= 8)
    message(7, "ASYNC_BEGIN: %d", AsyncCount);

  time(&now);
  b->last = now + (signed long int)(60 * 60);
  addrport[(signed long int)0] = (char)0;
  if(Debug >= 9)
  {
    addrport2strOnce(&b->check->addr, b->check->len, b->proto & (proto_ohttp_d | proto_base_d | proto_command), addrport, 127, 0);
    message(7, "asyncHealthCheck %s", (const void *)addrport);
  }

  signed int return_value_healthCheck$3;
  return_value_healthCheck$3=healthCheck(&b->check->addr, b->check->len, b->proto, (signed int)b->interval, b->chat);
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(!(return_value_healthCheck$3 == 0))
  {
    if(Debug >= 4)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (b->bn != 0 ? (Debug > 1 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      addrport2strOnce(&b->check->addr, b->check->len, b->proto & (proto_ohttp_d | proto_base_d | proto_command), addrport, 127, 0);
      message(7, "health check %s success", (const void *)addrport);
    }

    if(!(b->bn == 0))
      b->bn = (signed short int)0;

  }

  else
  {
    if(Debug >= 4)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = ((signed int)b->bn == 0 ? (Debug > 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      addrport2strOnce(&b->check->addr, b->check->len, b->proto & (proto_ohttp_d | proto_base_d | proto_command), addrport, 127, 0);
      message(7, "health check %s fail", (const void *)addrport);
    }

    if((signed int)b->bn == 0)
      b->bn = b->bn + 1;

  }
  b->last = now;
  if(Debug >= 8)
    message(7, "ASYNC_END: %d", AsyncCount);

  waitMutex(3);
  AsyncCount = AsyncCount - 1;
  freeMutex(3);
  ERR_remove_state((unsigned long int)0);
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1;
}

// baseDecode
// file stone.c line 4998
signed int baseDecode(unsigned char *buf, signed int len, char *rest)
{
  signed int blen = 0;
  unsigned char c[4l];
  unsigned char o[4l];
  signed int i;
  signed int j = 0;
  i = 0;
  signed int tmp_post$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  for( ; !(i >= len); i = i + 1)
  {
    c[(signed long int)j] = index_64[(signed long int)buf[(signed long int)i]];
    if(!((signed int)c[(signed long int)j] == 255))
    {
      if(j == 0)
      {
        if((signed int)c[(signed long int)j] == 254)
          goto __CPROVER_DUMP_L3;

      }

      tmp_post$1 = j;
      j = j + 1;
      o[(signed long int)tmp_post$1] = buf[(signed long int)i];
      if(j == 4)
      {
        j = 0;
        tmp_post$2 = blen;
        blen = blen + 1;
        buf[(signed long int)tmp_post$2] = (unsigned char)((signed int)c[(signed long int)0] << 2 | ((signed int)c[(signed long int)1] & 0x30) >> 4);
        if(!((signed int)c[2l] == 254))
        {
          tmp_post$3 = blen;
          blen = blen + 1;
          buf[(signed long int)tmp_post$3] = (unsigned char)(((signed int)c[(signed long int)1] & 0x0F) << 4 | ((signed int)c[(signed long int)2] & 0x3C) >> 2);
          if(!((signed int)c[3l] == 254))
          {
            tmp_post$4 = blen;
            blen = blen + 1;
            buf[(signed long int)tmp_post$4] = (unsigned char)(((signed int)c[(signed long int)2] & 0x03) << 6 | (signed int)c[(signed long int)3]);
          }

        }

      }

    }


  __CPROVER_DUMP_L3:
    ;
  }
  *rest = (char)j;
  i = 0;
  for( ; !(i >= j); i = i + 1)
    *((rest - (signed long int)1) - (signed long int)i) = (char)o[(signed long int)i];
  return blen;
}

// baseEncode
// file stone.c line 4940
signed int baseEncode(unsigned char *buf, signed int len, signed int max)
{
  unsigned char *org = (buf + (signed long int)max) - (signed long int)len;
  unsigned char c1;
  unsigned char c2 = (unsigned char)0;
  unsigned char c3 = (unsigned char)0;
  signed int blen = 0;
  signed int i;
  bcopy((const void *)buf, (void *)org, (unsigned long int)len);
  i = 0;
  for( ; !(i >= len); i = i + 3)
  {
    switch(len - i)
    {
      case 1:
      {
        c2 = (unsigned char)0;
        buf[(signed long int)(blen + 2)] = (unsigned char)61;
      }
      case 2:
      {
        c3 = (unsigned char)0;
        buf[(signed long int)(blen + 3)] = (unsigned char)61;
      }
    }
    if(!(len + -i == 2))
    {
      if(len + -i == 1)
        goto __CPROVER_DUMP_L6;

      c3 = org[(signed long int)(i + 2)];
      buf[(signed long int)(blen + 3)] = basis_64[(signed long int)((signed int)c3 & 0x3F)];
    }

    c2 = org[(signed long int)(i + 1)];
    buf[(signed long int)(blen + 2)] = basis_64[(signed long int)(((signed int)c2 & 0xF) << 2 | ((signed int)c3 & 0xC0) >> 6)];

  __CPROVER_DUMP_L6:
    ;
    c1 = org[(signed long int)i];
    buf[(signed long int)(blen + 1)] = basis_64[(signed long int)(((signed int)c1 & 0x3) << 4 | ((signed int)c2 & 0xF0) >> 4)];
    buf[(signed long int)blen] = basis_64[(signed long int)((signed int)c1 >> 2)];
    blen = blen + 4;
  }
  signed int tmp_post$1;
  if(!((signed int)buf[(signed long int)(blen + -1)] == 61))
  {
    tmp_post$1 = blen;
    blen = blen + 1;
    buf[(signed long int)tmp_post$1] = (unsigned char)61;
  }

  return blen;
}

// checkXhost
// file stone.c line 1609
struct _XHosts * checkXhost(struct _XHosts *xhosts, struct sockaddr *sa, unsigned int salen)
{
  signed int match = 1;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$7;
  unsigned int return_value___bswap_32$6;
  if(xhosts == ((struct _XHosts *)NULL))
    return XHostsTrue;

  else
  {
    for( ; !(xhosts == ((struct _XHosts *)NULL)); xhosts = xhosts->next)
    {
      if(!((signed int)xhosts->mbits >= 0))
        match = (signed int)!(match != 0);

      else
      {
        if((signed int)sa->sa_family == 2)
          tmp_if_expr$11 = (signed int)xhosts->xhost.addr.sa_family == 2 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$11 = (_Bool)0;
        if(tmp_if_expr$11)
        {
          if((signed int)xhosts->mbits >= 1)
          {
            unsigned long int checkXhost$$1$$1$$1$$2$$1$$addr;
            unsigned int return_value___bswap_32$1;
            return_value___bswap_32$1=__bswap_32(((struct sockaddr_in *)sa)->sin_addr.s_addr);
            checkXhost$$1$$1$$1$$2$$1$$addr = (unsigned long int)return_value___bswap_32$1;
            unsigned long int checkXhost$$1$$1$$1$$2$$1$$xadr;
            unsigned int return_value___bswap_32$2;
            return_value___bswap_32$2=__bswap_32(((struct sockaddr_in *)&xhosts->xhost.addr)->sin_addr.s_addr);
            checkXhost$$1$$1$$1$$2$$1$$xadr = (unsigned long int)return_value___bswap_32$2;
            unsigned long int checkXhost$$1$$1$$1$$2$$1$$bits = (unsigned long int)~0 << 32 - (signed int)xhosts->mbits;
            if(!((checkXhost$$1$$1$$1$$2$$1$$addr & checkXhost$$1$$1$$1$$2$$1$$bits) == (checkXhost$$1$$1$$1$$2$$1$$bits & checkXhost$$1$$1$$1$$2$$1$$xadr)))
              goto __CPROVER_DUMP_L27;

          }

          if(!(match == 0))
            return xhosts;

          return (struct _XHosts *)(void *)0;
        }

        else
        {
          if((signed int)sa->sa_family == 10)
            tmp_if_expr$10 = (signed int)xhosts->xhost.addr.sa_family == 10 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$10 = (_Bool)0;
          if(tmp_if_expr$10)
          {
            struct in6_addr *checkXhost$$1$$1$$1$$3$$adrp = &((struct sockaddr_in6 *)sa)->sin6_addr;
            struct in6_addr *xadp = &((struct sockaddr_in6 *)&xhosts->xhost.addr)->sin6_addr;
            signed int j;
            signed int k;
            j = 0;
            k = (signed int)xhosts->mbits;
            for( ; k >= 1; k = k - 32)
            {
              unsigned long int addr;
              unsigned long int checkXhost$$1$$1$$1$$3$$1$$1$$xadr;
              unsigned long int mask;
              unsigned int return_value___bswap_32$3;
              return_value___bswap_32$3=__bswap_32((unsigned int)*((unsigned long int *)&checkXhost$$1$$1$$1$$3$$adrp->__in6_u.__u6_addr8[(signed long int)j]));
              addr = (unsigned long int)return_value___bswap_32$3;
              unsigned int return_value___bswap_32$4;
              return_value___bswap_32$4=__bswap_32((unsigned int)*((unsigned long int *)&xadp->__in6_u.__u6_addr8[(signed long int)j]));
              checkXhost$$1$$1$$1$$3$$1$$1$$xadr = (unsigned long int)return_value___bswap_32$4;
              if(k >= 32)
                mask = (unsigned long int)~0;

              else
                mask = (unsigned long int)~0 << 32 - k;
              if(Debug >= 13)
                message(7, "compare addr=%lx x=%lx m=%lx", addr, checkXhost$$1$$1$$1$$3$$1$$1$$xadr, mask);

              if(!((addr & mask) == (mask & checkXhost$$1$$1$$1$$3$$1$$1$$xadr)))
                break;

              j = j + 4;
            }
            if(!(k >= 1))
            {
              if(!(match == 0))
                return xhosts;

              return (struct _XHosts *)(void *)0;
            }

          }

          else
            if((signed int)sa->sa_family == 10)
            {
              if((signed int)xhosts->xhost.addr.sa_family == 2)
              {
                struct in6_addr *adrp = &((struct sockaddr_in6 *)sa)->sin6_addr;
                if(!(*((unsigned long int *)adrp->__in6_u.__u6_addr8) == 0ul))
                  tmp_if_expr$5 = (_Bool)1;

                else
                  tmp_if_expr$5 = *((unsigned long int *)&adrp->__in6_u.__u6_addr8[(signed long int)4]) != (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$5)
                  tmp_if_expr$7 = (_Bool)1;

                else
                {
                  return_value___bswap_32$6=__bswap_32((unsigned int)*((unsigned long int *)&adrp->__in6_u.__u6_addr8[(signed long int)8]));
                  tmp_if_expr$7 = return_value___bswap_32$6 != (unsigned int)0xFFFF ? (_Bool)1 : (_Bool)0;
                }
                if(!tmp_if_expr$7)
                {
                  if((signed int)xhosts->mbits >= 1)
                  {
                    unsigned long int checkXhost$$1$$1$$1$$4$$1$$addr;
                    unsigned int return_value___bswap_32$8;
                    return_value___bswap_32$8=__bswap_32((unsigned int)*((unsigned long int *)&adrp->__in6_u.__u6_addr8[(signed long int)12]));
                    checkXhost$$1$$1$$1$$4$$1$$addr = (unsigned long int)return_value___bswap_32$8;
                    unsigned long int xadr;
                    unsigned int return_value___bswap_32$9;
                    return_value___bswap_32$9=__bswap_32(((struct sockaddr_in *)&xhosts->xhost.addr)->sin_addr.s_addr);
                    xadr = (unsigned long int)return_value___bswap_32$9;
                    unsigned long int bits = (unsigned long int)~0 << 32 - (signed int)xhosts->mbits;
                    if(!((checkXhost$$1$$1$$1$$4$$1$$addr & bits) == (bits & xadr)))
                      goto __CPROVER_DUMP_L27;

                  }

                  if(!(match == 0))
                    return xhosts;

                  return (struct _XHosts *)(void *)0;
                }

              }

            }

        }
      }

    __CPROVER_DUMP_L27:
      ;
    }
    if(match == 0)
      return XHostsTrue;

    else
      return (struct _XHosts *)(void *)0;
  }
}

// commOutput
// file stone.c line 5215
signed int commOutput(struct _Pair *pair, char *fmt, ...)
{
  struct _Pair *p = pair->pair;
  struct _ExBuf *ex;
  signed int psd;
  char *str;
  void **ap;
  unsigned long int return_value_strlen$1;
  signed int return_value_baseEncode$2;
  unsigned long int return_value_strlen$3;
  if(p == ((struct _Pair *)NULL))
    return -1;

  else
  {
    psd = p->sd;
    if(!(((proto_close | proto_shutdown) & p->proto) == 0) || !(psd >= 0))
      return -1;

    else
    {
      ex = p->b;
      if(!(ex->bufmax + -(ex->len + ex->start) >= 1))
      {
        struct _ExBuf *new;
        new=getExBuf();
        if(!(new == ((struct _ExBuf *)NULL)))
        {
          ex = new;
          p->b->next = ex;
          p->b = ex;
          p->nbuf = p->nbuf + 1;
          if(Debug >= 5)
            message(7, "%d TCP %d: get ExBuf nbuf=%d", pair->stone->sd, p->sd, p->nbuf);

        }

      }

      str = &ex->buf[(signed long int)(ex->start + ex->len)];
      ex->buf[(signed long int)(ex->bufmax - 1)] = (char)0;
      ap = (void **)&fmt;
      vsnprintf(str, (unsigned long int)((ex->bufmax - 1) - (ex->start + ex->len)), fmt, ap);
      ap = ((void **)NULL);
      if(!(((proto_base_d | proto_base_s) & p->proto) == 0))
      {
        return_value_strlen$1=strlen(str);
        return_value_baseEncode$2=baseEncode((unsigned char *)str, (signed int)return_value_strlen$1, (ex->bufmax - 1) - (ex->start + ex->len));
        ex->len = ex->len + return_value_baseEncode$2;
      }

      else
      {
        return_value_strlen$3=strlen(str);
        ex->len = ex->len + (signed int)return_value_strlen$3;
      }
      p->proto = p->proto | proto_select_w | proto_dirty;
      return ex->len;
    }
  }
}

// comm_match
// file stone.c line 5250
static char * comm_match(char *buf, char *str)
{
  signed int tmp_statement_expression$1;
  char *tmp_post$2;
  signed int tmp_if_expr$4;
  const signed int **return_value___ctype_toupper_loc$3;
  char *tmp_post$5;
  const signed int **return_value___ctype_toupper_loc$6;
  char *tmp_post$7;
  char *tmp_post$8;
  while(!(*str == 0))
  {
    signed int __res;
    return_value___ctype_toupper_loc$6=__ctype_toupper_loc();
    tmp_post$7 = buf;
    buf = buf + 1l;
    __res = (*return_value___ctype_toupper_loc$6)[(signed long int)(signed int)*tmp_post$7];
    tmp_statement_expression$1 = __res;
    tmp_post$8 = str;
    str = str + 1l;
    if(!(tmp_statement_expression$1 == (signed int)*tmp_post$8))
      return (char *)(void *)0;

  }
  if(!(*buf == 0))
  {
    const unsigned short int **return_value___ctype_b_loc$9;
    return_value___ctype_b_loc$9=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$9)[(signed long int)(signed int)*buf]) == 0)
      return (char *)(void *)0;

    if((signed int)*buf == 32)
      buf = buf + 1l;

  }

  return buf;
}

// connected
// file stone.c line 3699
void connected(struct _Pair *pair)
{
  struct _Pair *p = pair->pair;
  if(Debug >= 3)
    message(7, "%d TCP %d: established to %d %08x %08x", pair->stone->sd, p->sd, pair->sd, p->proto, pair->proto);

  time(&lastEstablished);
  signed int return_value_doshutdown$1;
  if(!((pair->stone->proto & proto_ssl_d) == 0))
  {
    signed int return_value_doSSL_connect$2;
    return_value_doSSL_connect$2=doSSL_connect(pair);
    if(!(return_value_doSSL_connect$2 >= 0))
    {
      if((p->proto & proto_shutdown) == 0)
      {
        return_value_doshutdown$1=doshutdown(p, 2);
        if(return_value_doshutdown$1 >= 0)
          p->proto = p->proto | proto_shutdown | proto_dirty;

      }

      p->proto = p->proto | proto_close | proto_dirty;
      pair->proto = pair->proto | proto_close | proto_dirty;
      goto __CPROVER_DUMP_L16;
    }

  }

  else
  {
    pair->proto = pair->proto | proto_connect | proto_dirty;
    p->proto = p->proto | proto_dirty;
  }
  if(pair->t->len >= 1)
  {
    if(Debug >= 9)
      message(7, "%d TCP %d: waiting %d bytes to write", pair->stone->sd, pair->sd, pair->t->len);

    if((pair->proto & proto_shutdown) == 0)
      pair->proto = pair->proto | proto_select_w | proto_dirty;

  }

  else
    if((pair->proto & proto_ohttp_d) == 0)
    {
      if(Debug >= 9)
        message(7, "%d TCP %d: request to read 1st", pair->stone->sd, p->sd);

      if((p->proto & proto_eof) == 0)
        p->proto = p->proto | proto_select_r | proto_dirty;

    }

  if((p->proto & proto_ohttp_s) == 0)
  {
    if(p->t->len >= 1)
    {
      if(Debug >= 9)
        message(7, "%d TCP %d: waiting %d bytes to write", pair->stone->sd, p->sd, p->t->len);

      if((p->proto & proto_shutdown) == 0)
        p->proto = p->proto | proto_select_w | proto_dirty;

    }

    else
    {
      if(Debug >= 9)
        message(7, "%d TCP %d: request to read", pair->stone->sd, pair->sd);

      if((pair->proto & proto_eof) == 0)
        pair->proto = pair->proto | proto_select_r | proto_dirty;

    }
  }


__CPROVER_DUMP_L16:
  ;
}

// daemonize
// file stone.c line 9898
void daemonize(void)
{
  signed int pid;
  pid=fork();
  if(!(pid >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    message(3, "Can't create daemon err=%d", *return_value___errno_location$1);
    exit(1);
  }

  if(pid >= 1)
    _exit(0);

  MyPid=getpid();
  signed int return_value_setsid$3;
  return_value_setsid$3=setsid();
  signed int *return_value___errno_location$2;
  if(!(return_value_setsid$3 >= 0))
  {
    return_value___errno_location$2=__errno_location();
    message(4, "Can't create new session err=%d", *return_value___errno_location$2);
  }

  signed int return_value_chdir$5;
  return_value_chdir$5=chdir("/");
  signed int *return_value___errno_location$4;
  if(!(return_value_chdir$5 >= 0))
  {
    return_value___errno_location$4=__errno_location();
    message(4, "Can't change directory to / err=%d", *return_value___errno_location$4);
  }

  umask((unsigned int)0022);
  signed int return_value_close$7;
  return_value_close$7=close(0);
  signed int *return_value___errno_location$6;
  if(!(return_value_close$7 == 0))
  {
    return_value___errno_location$6=__errno_location();
    message(4, "Can't close stdin err=%d", *return_value___errno_location$6);
  }

  signed int return_value_close$9;
  return_value_close$9=close(1);
  signed int *return_value___errno_location$8;
  if(!(return_value_close$9 == 0))
  {
    return_value___errno_location$8=__errno_location();
    message(4, "Can't close stdout err=%d", *return_value___errno_location$8);
  }

  if(Syslog >= 2)
    Syslog = 1;

  if(LogFileName == ((char *)NULL))
    LogFp = (struct _IO_FILE *)(void *)0;

  signed int return_value_close$11;
  return_value_close$11=close(2);
  signed int *return_value___errno_location$10;
  if(!(return_value_close$11 == 0))
  {
    return_value___errno_location$10=__errno_location();
    message(4, "Can't close stderr err=%d", *return_value___errno_location$10);
  }

}

// dispatch
// file stone.c line 6904
void dispatch(signed int epfd, struct epoll_event *evs, signed int nevs)
{
  signed int i = 0;
  for( ; !(i >= nevs); i = i + 1)
  {
    signed int common;
    signed int other;
    struct epoll_event ev = evs[(signed long int)i];
    /* tag-#anon#lUN[SYM#tag-_Stone#'stone'||SYM#tag-_Pair#'pair'||SYM#tag-_Origin#'origin'|] */
union anonymous$18
{
  // stone
  struct _Stone stone;
  // pair
  struct _Pair pair;
  // origin
  struct _Origin origin;
};

/* */
    ;
    union anonymous$18 *p;
    if(Debug >= 9)
      message(7, "epoll %d: evs[%d].data=%x", epfd, i, (signed int)ev.data.ptr);

    common = *((signed int *)ev.data.ptr);
    other = (signed int)(ev.events & (unsigned int)~(1 | 2 | 4));
    p = (union anonymous$18 *)ev.data.ptr;
    switch(common & 0x000f)
    {
      case 0x0003:
      {
        if(Debug >= 11 || Debug >= 3 && !(other == 0))
          message(7, "stone %d: epoll %d events=%x type=%d", p->stone.sd, epfd, ev.events, common);

        if(!((p->stone.proto & proto_udp_s) == 0))
          recvStoneUDP(&p->stone);

        else
        {
          struct _Pair *pair;
          pair=acceptPair(&p->stone);
          if(!(pair == ((struct _Pair *)NULL)))
          {
            if(!((p->stone.proto & proto_ident) == 0))
            {
              unsigned long int thread;
              signed int err;
              if(Debug >= 8)
                message(7, "ASYNC: %d", AsyncCount);

              waitMutex(3);
              AsyncCount = AsyncCount + 1;
              freeMutex(3);
              err=pthread_create(&thread, &thread_attr, (void * (*)(void *))asyncAcceptConnect, (void *)pair);
              if(!(err == 0))
              {
                message(3, "pthread_create error err=%d", err);
                asyncAcceptConnect(pair);
              }

              else
                if(Debug >= 8)
                  message(7, "pthread ID=%lu", thread);

            }

            else
              doAcceptConnect(pair);
          }

        }
        break;
      }
      case 0x0001:
      {
        if(Debug >= 11 || Debug >= 3 && !(other == 0))
          message(7, "TCP %d: epoll %d events=%x type=%d", p->pair.sd, epfd, ev.events, common);

        doReadWritePair(&p->pair, p->pair.pair, (signed int)((ev.events & (unsigned int)1) != (unsigned int)0), (signed int)((ev.events & (unsigned int)4) != (unsigned int)0), (signed int)((ev.events & (unsigned int)2) != (unsigned int)0), (signed int)((ev.events & (unsigned int)16) != (unsigned int)0), (signed int)((ev.events & (unsigned int)8) != (unsigned int)0));
        break;
      }
      case 0x0002:
      {
        struct _Origin *origin = &p->origin;
        struct _PktBuf *pb;
        if(Debug >= 11 || Debug >= 3 && !(other == 0))
          message(7, "%d UDP %d: epoll %d events=%x type=%d", origin->stone->sd, origin->sd, epfd, ev.events, common);

        pb=recvUDP((struct _Stone *)origin);
        if(!(pb == ((struct _PktBuf *)NULL)))
        {
          sendUDP(pb);
          ungetPktBuf(pb);
        }

        break;
      }
      default:
        message(3, "Irregular event events=%x type=%d", ev.events, common);
    }
  }
}

// doAcceptConnect
// file stone.c line 6740
signed int doAcceptConnect(struct _Pair *p1)
{
  struct _Stone *stone = p1->stone;
  struct _Pair *p2;
  signed int ret;
  if(Debug >= 9)
    message(7, "%d TCP %d: doAcceptConnect", stone->sd, p1->sd);

  signed int return_value_acceptCheck$1;
  return_value_acceptCheck$1=acceptCheck(p1);
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  _Bool tmp_if_expr$6;
  if(return_value_acceptCheck$1 == 0)
  {
    freePair(p1);
    return 0;
  }

  else
  {
    p2 = p1->pair;
    if(!((p2->proto & proto_ohttp_d) == 0))
    {
      signed int i;
      char *p = stone->p;
      struct _ExBuf *ex = p2->b;
      i=strnparse(ex->buf, ex->bufmax - 5, &p, p1, (char)0xFF);
      tmp_post$2 = i;
      i = i + 1;
      ex->buf[(signed long int)tmp_post$2] = (char)13;
      tmp_post$3 = i;
      i = i + 1;
      ex->buf[(signed long int)tmp_post$3] = (char)10;
      tmp_post$4 = i;
      i = i + 1;
      ex->buf[(signed long int)tmp_post$4] = (char)13;
      tmp_post$5 = i;
      i = i + 1;
      ex->buf[(signed long int)tmp_post$5] = (char)10;
      ex->len = i;
    }

    ret = -1;
    if(!((p1->proto & proto_connect) == 0))
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = (p1->proto & proto_dgram) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
    {
      ret=reqconn(p2, &stone->dsts[(signed long int)0]->addr, stone->dsts[(signed long int)0]->len);
      if(ret >= 0)
        goto __CPROVER_DUMP_L6;

      freePair(p2);
      freePair(p1);
      return 0;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      if((p1->proto & proto_close) == 0)
      {
        p1->proto = p1->proto | proto_dirty;
        p2->proto = p2->proto | proto_dirty;
        insertPairs(p1);
        return 1;
      }

      else
      {
        freePair(p2);
        freePair(p1);
        return 0;
      }
    }
  }
}

// doReadWritePair
// file stone.c line 6312
signed int doReadWritePair(struct _Pair *pair, struct _Pair *opposite, signed int ready_r, signed int ready_w, signed int ready_e, signed int hangup, signed int error)
{
  struct _Pair *rPair;
  struct _Pair *wPair;
  struct _Stone *stone;
  signed int stsd;
  signed int sd;
  signed int rsd;
  signed int wsd;
  signed int len;
  signed int ret = 1;
  sd = pair->sd;
  _Bool tmp_if_expr$36;
  _Bool tmp_if_expr$35;
  signed int return_value_doshutdown$7;
  _Bool tmp_if_expr$34;
  _Bool tmp_if_expr$32;
  _Bool tmp_if_expr$33;
  _Bool tmp_if_expr$21;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$15;
  signed int return_value_doshutdown$10;
  signed int return_value_doshutdown$11;
  signed int return_value_doshutdown$12;
  signed int return_value_doshutdown$16;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$31;
  _Bool tmp_if_expr$23;
  _Bool tmp_if_expr$30;
  signed int return_value_doshutdown$24;
  signed int return_value_doshutdown$25;
  _Bool tmp_if_expr$27;
  _Bool tmp_if_expr$28;
  _Bool tmp_if_expr$29;
  signed int return_value_SSL_pending$26;
  if(!(sd >= 0))
    return ret;

  else
  {
    stone = pair->stone;
    stsd = stone->sd;
    pair->loop = pair->loop + 1;
    if(!(hangup == 0))
    {
      if(!((pair->proto & proto_connect) == 0))
        ready_r = 1;

    }

    if(!((pair->proto & proto_conninprog) == 0) && (!(hangup == 0) || !(ready_e == 0) || !(ready_w == 0)))
    {
      signed int optval;
      unsigned int optlen = (unsigned int)sizeof(signed int) /*4ul*/ ;
      pair->proto = pair->proto & ~proto_conninprog;
      pair->proto = pair->proto | proto_dirty;
      signed int return_value_getsockopt$2;
      return_value_getsockopt$2=getsockopt(sd, 1, 4, (void *)(char *)&optval, &optlen);
      if(!(return_value_getsockopt$2 >= 0))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        message(3, "%d TCP %d: getsockopt err=%d", stsd, sd, *return_value___errno_location$1);
        pair->proto = pair->proto | proto_close | proto_dirty;
        if(!(opposite == ((struct _Pair *)NULL)))
          opposite->proto = opposite->proto | proto_close | proto_dirty;

        return 0;
      }

      if(!(optval == 0))
      {
        message(3, "%d TCP %d: connect getsockopt err=%d", stsd, sd, optval);
        pair->proto = pair->proto | proto_close | proto_dirty;
        if(!(opposite == ((struct _Pair *)NULL)))
          opposite->proto = opposite->proto | proto_close | proto_dirty;

        return 0;
      }

      else
      {
        if(Debug >= 5)
          message(7, "%d TCP %d: connecting completed", stsd, sd);

        connected(pair);
      }
      goto __CPROVER_DUMP_L107;
    }

    if(!(ready_e == 0))
    {
      char buf[1l];
      signed long int return_value_recv$3;
      return_value_recv$3=recv(sd, (void *)buf, (unsigned long int)1, 1);
      len = (signed int)return_value_recv$3;
      if(len == 1)
      {
        if(!(opposite == ((struct _Pair *)NULL)))
          wsd = opposite->sd;

        else
          wsd = -1;
        if(Debug >= 4)
          message(7, "%d TCP %d: MSG_OOB 0x%02x to %d", stsd, sd, buf[(signed long int)0], wsd);

        if(wsd >= 0)
        {
          signed long int return_value_send$4;
          return_value_send$4=send(wsd, (const void *)buf, (unsigned long int)1, 1);
          len = (signed int)return_value_send$4;
          if(!(len == 1))
          {
            signed int *return_value___errno_location$5;
            return_value___errno_location$5=__errno_location();
            message(3, "%d TCP %d: send MSG_OOB ret=%d, err=%d", stsd, sd, len, *return_value___errno_location$5);
          }

        }

      }

      else
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        message(3, "%d TCP %d: recv MSG_OOB ret=%d, err=%d", stsd, sd, len, *return_value___errno_location$6);
      }
    }

    else
    {
      if(!((pair->ssl_flag & sf_sb_on_r) == 0) && !(ready_r == 0))
        tmp_if_expr$36 = (_Bool)1;

      else
        tmp_if_expr$36 = ((pair->ssl_flag & sf_sb_on_w) != 0 ? (ready_w != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$36)
      {
        pair->ssl_flag = pair->ssl_flag & ~(sf_sb_on_r | sf_sb_on_w);
        pair->proto = pair->proto | proto_dirty;
        doSSL_shutdown(pair, -1);
      }

      else
      {
        if(!((pair->ssl_flag & sf_cb_on_r) == 0) && !(ready_r == 0))
          tmp_if_expr$35 = (_Bool)1;

        else
          tmp_if_expr$35 = ((pair->ssl_flag & sf_cb_on_w) != 0 ? (ready_w != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$35)
        {
          pair->ssl_flag = pair->ssl_flag & ~(sf_cb_on_r | sf_cb_on_w);
          pair->proto = pair->proto | proto_dirty;
          signed int return_value_doSSL_connect$8;
          return_value_doSSL_connect$8=doSSL_connect(pair);
          if(!(return_value_doSSL_connect$8 >= 0))
          {
            if(!(opposite == ((struct _Pair *)NULL)))
            {
              if((opposite->proto & proto_shutdown) == 0)
              {
                return_value_doshutdown$7=doshutdown(opposite, 2);
                if(return_value_doshutdown$7 >= 0)
                  opposite->proto = opposite->proto | proto_shutdown | proto_dirty;

              }

              opposite->proto = opposite->proto | proto_close | proto_dirty;
            }

            pair->proto = pair->proto | proto_close | proto_dirty;
          }

        }

        else
        {
          if(!((pair->ssl_flag & sf_ab_on_r) == 0) && !(ready_r == 0))
            tmp_if_expr$34 = (_Bool)1;

          else
            tmp_if_expr$34 = ((pair->ssl_flag & sf_ab_on_w) != 0 ? (ready_w != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$34)
          {
            pair->ssl_flag = pair->ssl_flag & ~(sf_ab_on_r | sf_ab_on_w);
            pair->proto = pair->proto | proto_dirty;
            signed int return_value_doSSL_accept$9;
            return_value_doSSL_accept$9=doSSL_accept(pair);
            if(!(return_value_doSSL_accept$9 >= 0))
            {
              pair->proto = pair->proto | proto_close | proto_dirty;
              if(!(opposite == ((struct _Pair *)NULL)))
                opposite->proto = opposite->proto | proto_close | proto_dirty;

              return 0;
            }

            if(!((pair->proto & proto_connect) == 0))
            {
              if(!(opposite == ((struct _Pair *)NULL)))
                reqconn(opposite, &stone->dsts[(signed long int)0]->addr, stone->dsts[(signed long int)0]->len);

            }

          }

          else
          {
            if(!((pair->proto & proto_select_r) == 0) && !(ready_r == 0))
              tmp_if_expr$32 = !((pair->ssl_flag & sf_wb_on_r) != 0) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$32 = (_Bool)0;
            if(tmp_if_expr$32)
              tmp_if_expr$33 = (_Bool)1;

            else
              tmp_if_expr$33 = ((pair->ssl_flag & sf_rb_on_w) != 0 ? (ready_w != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$33)
            {
              pair->ssl_flag = pair->ssl_flag & ~sf_rb_on_w;
              pair->proto = pair->proto | proto_dirty;
              rPair = pair;
              wPair = opposite;
              rsd = sd;
              if(!(wPair == ((struct _Pair *)NULL)))
                wsd = wPair->sd;

              else
                wsd = -1;

            read_pending:
              ;
              rPair->proto = rPair->proto & ~proto_select_r;
              rPair->proto = rPair->proto | proto_dirty;
              if(!((rPair->proto & proto_dgram) == 0))
                len=recvPairUDP(rPair);

              else
              {
                rPair->count = rPair->count + 10;
                len=doread(rPair);
                rPair->count = rPair->count - 10;
              }
              if(!(len >= 0))
                tmp_if_expr$21 = (_Bool)1;

              else
                tmp_if_expr$21 = (rPair->proto & proto_close) != 0 ? (_Bool)1 : (_Bool)0;
              if(wPair == ((struct _Pair *)NULL) || tmp_if_expr$21)
              {
                if(len == -2)
                  tmp_if_expr$13 = !((rPair->proto & proto_shutdown) != 0) ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$13 = (_Bool)0;
                if(!(wPair == ((struct _Pair *)NULL)) && tmp_if_expr$13)
                  tmp_if_expr$14 = !((wPair->proto & (proto_eof | proto_shutdown | proto_close)) != 0) ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$14 = (_Bool)0;
                if(tmp_if_expr$14)
                  tmp_if_expr$15 = (wPair->proto & proto_connect) != 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$15 = (_Bool)0;
                if(wsd >= 0 && tmp_if_expr$15)
                {
                  rPair->proto = rPair->proto | proto_eof | proto_dirty;
                  if((wPair->proto & proto_shutdown) == 0)
                  {
                    return_value_doshutdown$10=doshutdown(wPair, 1);
                    if(return_value_doshutdown$10 >= 0)
                      wPair->proto = wPair->proto | proto_shutdown | proto_dirty;

                  }

                  wPair->proto = wPair->proto & ~proto_select_w;
                  wPair->proto = wPair->proto | proto_dirty;
                }

                else
                {
                  signed int flag = 0;
                  if((rPair->proto & proto_shutdown) == 0)
                  {
                    return_value_doshutdown$11=doshutdown(rPair, 2);
                    if(return_value_doshutdown$11 >= 0)
                      flag = proto_shutdown;

                  }

                  rPair->proto = rPair->proto & ~proto_select_w;
                  rPair->proto = rPair->proto | proto_dirty;
                  setclose(rPair, proto_eof | flag);
                  flag = 0;
                  if(!(wPair == ((struct _Pair *)NULL)))
                  {
                    if((wPair->proto & proto_shutdown) == 0)
                    {
                      return_value_doshutdown$12=doshutdown(wPair, 2);
                      if(return_value_doshutdown$12 >= 0)
                        flag = proto_shutdown;

                    }

                    wPair->proto = wPair->proto & ~proto_select_w;
                    wPair->proto = wPair->proto | proto_dirty;
                    setclose(wPair, flag);
                  }

                }
              }

              else
                if(len >= 1)
                {
                  signed int first_flag = rPair->proto & proto_first_r;
                  if(!(first_flag == 0))
                    len=first_read(rPair);

                  if(!((wPair->proto & proto_dgram) == 0))
                  {
                    rPair->proto = rPair->proto | proto_select_r | proto_dirty;
                    signed int return_value_sendPairUDP$17;
                    return_value_sendPairUDP$17=sendPairUDP(wPair);
                    if(!(return_value_sendPairUDP$17 >= 0))
                    {
                      signed int doReadWritePair$$1$$6$$4$$1$$1$$1$$flag = 0;
                      if((rPair->proto & proto_shutdown) == 0)
                      {
                        return_value_doshutdown$16=doshutdown(rPair, 2);
                        if(return_value_doshutdown$16 >= 0)
                          doReadWritePair$$1$$6$$4$$1$$1$$1$$flag = proto_shutdown;

                      }

                      rPair->proto = rPair->proto & ~proto_select_w;
                      rPair->proto = rPair->proto | proto_dirty;
                      setclose(rPair, proto_eof | doReadWritePair$$1$$6$$4$$1$$1$$1$$flag);
                    }

                  }

                  else
                  {
                    if(len >= 1 && wsd >= 0)
                      tmp_if_expr$18 = (wPair->proto & proto_connect) != 0 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$18 = (_Bool)0;
                    if(tmp_if_expr$18)
                      tmp_if_expr$19 = !((wPair->proto & (proto_shutdown | proto_close)) != 0) ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$19 = (_Bool)0;
                    if(tmp_if_expr$19)
                      tmp_if_expr$20 = !((rPair->proto & proto_close) != 0) ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$20 = (_Bool)0;
                    if(tmp_if_expr$20)
                      wPair->proto = wPair->proto | proto_select_w | proto_dirty;

                    else
                      return 0;
                  }
                }

                else
                {
                  rPair->proto = rPair->proto | proto_select_r | proto_dirty;
                  ret = 2;
                }
            }

            else
            {
              if(!((pair->proto & proto_select_w) == 0) && !(ready_w == 0))
                tmp_if_expr$31 = (_Bool)1;

              else
                tmp_if_expr$31 = ((pair->ssl_flag & sf_wb_on_r) != 0 ? (ready_r != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$31)
              {
                pair->ssl_flag = pair->ssl_flag & ~sf_wb_on_r;
                pair->proto = pair->proto | proto_dirty;
                wPair = pair;
                rPair = opposite;
                wsd = sd;
                if(!(rPair == ((struct _Pair *)NULL)))
                  rsd = rPair->sd;

                else
                  rsd = -1;
                wPair->proto = wPair->proto & ~proto_select_w;
                wPair->proto = wPair->proto | proto_dirty;
                if((wPair->proto & proto_command) == 0x0100)
                  tmp_if_expr$23 = (_Bool)1;

                else
                  tmp_if_expr$23 = (wPair->proto & proto_command) == 0x0200 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$23)
                {
                  signed int state = wPair->proto & state_mask;
                  if(state == 0)
                  {
                    signed int return_value_insheader$22;
                    return_value_insheader$22=insheader(wPair);
                    if(return_value_insheader$22 >= 0)
                    {
                      state = state + 1;
                      wPair->proto = wPair->proto | state;
                    }

                  }

                }

                wPair->count = wPair->count + 10;
                len=dowrite(wPair);
                wPair->count = wPair->count - 10;
                if(!(len >= 0))
                  tmp_if_expr$30 = (_Bool)1;

                else
                  tmp_if_expr$30 = (wPair->proto & proto_close) != 0 ? (_Bool)1 : (_Bool)0;
                if(rPair == ((struct _Pair *)NULL) || tmp_if_expr$30)
                {
                  signed int doReadWritePair$$1$$7$$2$$flag = 0;
                  if(!(rPair == ((struct _Pair *)NULL)))
                  {
                    if(rsd >= 0)
                    {
                      if((rPair->proto & proto_shutdown) == 0)
                      {
                        return_value_doshutdown$24=doshutdown(rPair, 2);
                        if(return_value_doshutdown$24 >= 0)
                          doReadWritePair$$1$$7$$2$$flag = proto_shutdown;

                      }

                    }

                    rPair->proto = rPair->proto & ~proto_select_w;
                    rPair->proto = rPair->proto | proto_dirty;
                    setclose(rPair, doReadWritePair$$1$$7$$2$$flag);
                  }

                  doReadWritePair$$1$$7$$2$$flag = 0;
                  if((wPair->proto & proto_shutdown) == 0)
                  {
                    return_value_doshutdown$25=doshutdown(wPair, 2);
                    if(return_value_doshutdown$25 >= 0)
                      doReadWritePair$$1$$7$$2$$flag = proto_shutdown;

                  }

                  setclose(wPair, doReadWritePair$$1$$7$$2$$flag);
                }

                else
                {
                  struct _ExBuf *ex = wPair->t;
                  if(!(ex->len >= 1))
                  {
                    if(!((wPair->proto & proto_first_w) == 0))
                    {
                      wPair->proto = wPair->proto & ~proto_first_w;
                      wPair->proto = wPair->proto | proto_dirty;
                      if(rsd >= 0 && !(rPair == ((struct _Pair *)NULL)))
                      {
                        if((rPair->proto & proto_command) == 0x0600)
                        {
                          if((rPair->proto & state_mask) == 1)
                          {
                            message_time_log(rPair);
                            if(Debug >= 8)
                              message(7, "%d TCP %d: reconnect proxy", stsd, wPair->sd);

                            wPair->proto = wPair->proto | proto_first_r | proto_dirty;
                          }

                        }

                      }

                    }

                    if(rsd >= 0 && !(rPair == ((struct _Pair *)NULL)))
                    {
                      if((rPair->proto & proto_command) == 0x0200)
                      {
                        if(Debug >= 8)
                          message(7, "%d TCP %d: insheader again", stsd, wPair->sd);

                        rPair->proto = rPair->proto & ~state_mask;
                      }

                    }

                    if(rsd >= 0 && !(rPair == ((struct _Pair *)NULL)))
                      tmp_if_expr$27 = (rPair->proto & proto_connect) != 0 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$27 = (_Bool)0;
                    if(tmp_if_expr$27)
                      tmp_if_expr$28 = !((rPair->proto & (proto_eof | proto_close)) != 0) ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$28 = (_Bool)0;
                    if(tmp_if_expr$28)
                      tmp_if_expr$29 = !((wPair->proto & (proto_shutdown | proto_close)) != 0) ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$29 = (_Bool)0;
                    if(tmp_if_expr$29)
                    {
                      if(!(rPair->ssl == ((struct ssl_st *)NULL)))
                      {
                        return_value_SSL_pending$26=SSL_pending(rPair->ssl);
                        if(!(return_value_SSL_pending$26 == 0))
                        {
                          if(Debug >= 5)
                            message(7, "%d TCP %d: SSL_pending, read again", stsd, rPair->sd);

                          ret = 3;
                          goto read_pending;
                        }

                      }

                      rPair->proto = rPair->proto | proto_select_r | proto_dirty;
                    }

                    else
                      return 0;
                  }

                  else
                  {
                    wPair->proto = wPair->proto | proto_select_w | proto_dirty;
                    ret = 2;
                  }
                }
              }

              else
                if(!(error == 0))
                {
                  if(Debug >= 4)
                    message(7, "%d TCP %d: error", stsd, sd);

                  pair->proto = pair->proto | proto_close | proto_dirty;
                  if(!(opposite == ((struct _Pair *)NULL)))
                    opposite->proto = opposite->proto | proto_close | proto_dirty;

                  return 0;
                }

            }
          }
        }
      }
    }

  __CPROVER_DUMP_L107:
    ;
    return ret;
  }
}

// doSSL_accept
// file stone.c line 3244
signed int doSSL_accept(struct _Pair *pair)
{
  signed int err;
  signed int ret;
  signed int sd;
  struct ssl_st *ssl;
  signed int return_value_SSL_state$1;
  signed int return_value_SSL_state$2;
  signed int return_value_SSL_state$3;
  signed int return_value_SSL_state$4;
  _Bool tmp_if_expr$11;
  signed int *return_value___errno_location$10;
  signed int *return_value___errno_location$12;
  if(pair == ((struct _Pair *)NULL))
    return -1;

  else
  {
    sd = pair->sd;
    if(!(sd >= 0))
      return -1;

    else
    {
      ssl = pair->ssl;
      if(ssl == ((struct ssl_st *)NULL))
      {
        ssl=SSL_new(pair->stone->ssl_server->ctx);
        if(ssl == ((struct ssl_st *)NULL))
        {
          message(3, "%d TCP %d: SSL_new failed", pair->stone->sd, sd);
          return -1;
        }

        SSL_set_ex_data(ssl, PairIndex, (void *)pair);
        SSL_set_fd(ssl, sd);
        pair->ssl = ssl;
      }

      pair->ssl_flag = pair->ssl_flag & ~(sf_ab_on_r | sf_ab_on_w);
      pair->proto = pair->proto | proto_dirty;
      ret=SSL_accept(ssl);
      if(Debug >= 8)
      {
        return_value_SSL_state$1=SSL_state(ssl);
        return_value_SSL_state$2=SSL_state(ssl);
        return_value_SSL_state$3=SSL_state(ssl);
        return_value_SSL_state$4=SSL_state(ssl);
        message(7, "%d TCP %d: SSL_accept ret=%d, state=%x, finished=%x, in_init=%x/%x", pair->stone->sd, sd, ret, return_value_SSL_state$1, return_value_SSL_state$2 == 0x03, return_value_SSL_state$3 & (0x1000 | 0x2000), return_value_SSL_state$4 & 0x2000);
      }

      if(ret >= 1)
      {
        signed int return_value_SSL_state$5;
        return_value_SSL_state$5=SSL_state(ssl);
        if(!((0x2000 & return_value_SSL_state$5) == 0))
        {
          if(!(pair->stone->ssl_server->verbose == 0))
          {
            message(5, "%d TCP %d: SSL_accept unexpected EOF", pair->stone->sd, sd);
            message_pair(5, pair);
          }

          return -1;
        }

        pair->proto = pair->proto | proto_connect | proto_dirty;
        if(Debug >= 4)
        {
          struct ssl_ctx_st *ctx = pair->stone->ssl_server->ctx;
          signed long int return_value_SSL_CTX_ctrl$6;
          return_value_SSL_CTX_ctrl$6=SSL_CTX_ctrl(ctx, 20, (signed long int)0, (void *)0);
          signed long int return_value_SSL_CTX_ctrl$7;
          return_value_SSL_CTX_ctrl$7=SSL_CTX_ctrl(ctx, 24, (signed long int)0, (void *)0);
          signed long int return_value_SSL_CTX_ctrl$8;
          return_value_SSL_CTX_ctrl$8=SSL_CTX_ctrl(ctx, 27, (signed long int)0, (void *)0);
          message(7, "%d TCP %d: SSL_accept succeeded sess=%ld accept=%ld hits=%ld", pair->stone->sd, sd, return_value_SSL_CTX_ctrl$6, return_value_SSL_CTX_ctrl$7, return_value_SSL_CTX_ctrl$8);
        }

        if(!(pair->stone->ssl_server->verbose == 0))
          printSSLinfo(7, ssl);

        return ret;
      }

      err=SSL_get_error(ssl, ret);
      if(err == 2)
      {
        pair->ssl_flag = pair->ssl_flag | sf_ab_on_r;
        ret = 0;
      }

      else
        if(err == 3)
        {
          pair->ssl_flag = pair->ssl_flag | sf_ab_on_w;
          ret = 0;
        }

        else
          if(err == 5)
          {
            unsigned long int doSSL_accept$$1$$5$$e;
            doSSL_accept$$1$$5$$e=ERR_get_error();
            if(doSSL_accept$$1$$5$$e == 0ul)
            {
              signed int *return_value___errno_location$9;
              return_value___errno_location$9=__errno_location();
              if(*return_value___errno_location$9 == 4)
                tmp_if_expr$11 = (_Bool)1;

              else
              {
                return_value___errno_location$10=__errno_location();
                tmp_if_expr$11 = *return_value___errno_location$10 == 11 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$11)
              {
                pair->ssl_flag = pair->ssl_flag | sf_ab_on_r | sf_ab_on_r;
                if(Debug >= 9)
                  message(7, "%d TCP %d: SSL_accept interrupted sf=%x", pair->stone->sd, sd, pair->ssl_flag);

                return 0;
              }

              signed int *return_value___errno_location$13;
              return_value___errno_location$13=__errno_location();
              if(*return_value___errno_location$13 == 0)
              {
                if(Debug >= 1)
                {
                  return_value___errno_location$12=__errno_location();
                  message(7, "%d TCP %d: SSL_accept shutdowned by peer sf=%x errno=%d", pair->stone->sd, sd, pair->ssl_flag, *return_value___errno_location$12);
                }

                return -1;
              }

              signed int return_value_priority$14;
              return_value_priority$14=priority(pair);
              signed int *return_value___errno_location$15;
              return_value___errno_location$15=__errno_location();
              message(return_value_priority$14, "%d TCP %d: SSL_accept I/O error sf=%x errno=%d", pair->stone->sd, sd, pair->ssl_flag, *return_value___errno_location$15);
            }

            else
            {
              signed int return_value_priority$16;
              return_value_priority$16=priority(pair);
              char *return_value_ERR_error_string$17;
              return_value_ERR_error_string$17=ERR_error_string(doSSL_accept$$1$$5$$e, (char *)(void *)0);
              message(return_value_priority$16, "%d TCP %d: SSL_accept sf=%x %s", pair->stone->sd, sd, pair->ssl_flag, return_value_ERR_error_string$17);
            }
            return ret;
          }

          else
            if(err == 1)
            {
              unsigned long int e;
              e=ERR_get_error();
              signed int return_value_priority$18;
              return_value_priority$18=priority(pair);
              char *return_value_ERR_error_string$19;
              return_value_ERR_error_string$19=ERR_error_string(e, (char *)(void *)0);
              message(return_value_priority$18, "%d TCP %d: SSL_accept lib %s", pair->stone->sd, sd, return_value_ERR_error_string$19);
              return -1;
            }

      if(Debug >= 5)
        message(7, "%d TCP %d: SSL_accept interrupted sf=%x err=%d", pair->stone->sd, sd, pair->ssl_flag, err);

      return ret;
    }
  }
}

// doSSL_connect
// file stone.c line 3340
signed int doSSL_connect(struct _Pair *pair)
{
  signed int ret;
  signed int err;
  signed int sd;
  struct ssl_st *ssl;
  signed int *return_value___errno_location$5;
  _Bool tmp_if_expr$7;
  signed int *return_value___errno_location$6;
  if(pair == ((struct _Pair *)NULL))
    return -1;

  else
  {
    sd = pair->sd;
    if(!(sd >= 0))
      return -1;

    else
    {
      ssl = pair->ssl;
      if(ssl == ((struct ssl_st *)NULL))
      {
        ssl=SSL_new(pair->stone->ssl_client->ctx);
        if(ssl == ((struct ssl_st *)NULL))
        {
          message(3, "%d TCP %d: SSL_new failed", pair->stone->sd, sd);
          return -1;
        }

        SSL_set_ex_data(ssl, PairIndex, (void *)pair);
        SSL_set_fd(ssl, sd);
        pair->ssl = ssl;
      }

      if(!((sslparm_sni & (signed int)pair->stone->ssl_client->sslparm) == 0))
      {
        signed long int return_value_SSL_ctrl$1;
        return_value_SSL_ctrl$1=SSL_ctrl(ssl, 55, (signed long int)0, (void *)(char *)pair->stone->ssl_client->name);
        if(return_value_SSL_ctrl$1 == 0l)
          message(3, "%d TCP %d: Can't set TLS servername: %s", pair->stone->sd, sd, pair->stone->ssl_client->name);

      }

      pair->ssl_flag = pair->ssl_flag & ~(sf_cb_on_r | sf_cb_on_w);
      pair->proto = pair->proto | proto_dirty;
      ret=SSL_connect(ssl);
      if(ret >= 1)
      {
        struct _Pair *p = pair->pair;
        pair->proto = pair->proto | proto_connect | proto_dirty;
        if(!(p == ((struct _Pair *)NULL)))
          p->proto = p->proto | proto_dirty;

        if(Debug >= 4)
        {
          struct ssl_ctx_st *ctx = pair->stone->ssl_client->ctx;
          signed long int return_value_SSL_CTX_ctrl$2;
          return_value_SSL_CTX_ctrl$2=SSL_CTX_ctrl(ctx, 20, (signed long int)0, (void *)0);
          signed long int return_value_SSL_CTX_ctrl$3;
          return_value_SSL_CTX_ctrl$3=SSL_CTX_ctrl(ctx, 21, (signed long int)0, (void *)0);
          signed long int return_value_SSL_CTX_ctrl$4;
          return_value_SSL_CTX_ctrl$4=SSL_CTX_ctrl(ctx, 27, (signed long int)0, (void *)0);
          message(7, "%d TCP %d: SSL_connect succeeded sess=%ld connect=%ld hits=%ld", pair->stone->sd, sd, return_value_SSL_CTX_ctrl$2, return_value_SSL_CTX_ctrl$3, return_value_SSL_CTX_ctrl$4);
          message_pair(7, pair);
        }

        if(!(pair->stone->ssl_client->verbose == 0))
          printSSLinfo(7, ssl);

        return ret;
      }

      err=SSL_get_error(ssl, ret);
      if(err == 2)
      {
        pair->ssl_flag = pair->ssl_flag | sf_cb_on_r;
        ret = 0;
      }

      else
        if(err == 3)
        {
          pair->ssl_flag = pair->ssl_flag | sf_cb_on_w;
          ret = 0;
        }

        else
          if(err == 5)
          {
            unsigned long int e;
            e=ERR_get_error();
            if(e == 0ul)
            {
              signed int *return_value___errno_location$8;
              return_value___errno_location$8=__errno_location();
              if(*return_value___errno_location$8 == 0)
                return 1;

              else
              {
                return_value___errno_location$5=__errno_location();
                if(*return_value___errno_location$5 == 4)
                  tmp_if_expr$7 = (_Bool)1;

                else
                {
                  return_value___errno_location$6=__errno_location();
                  tmp_if_expr$7 = *return_value___errno_location$6 == 11 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$7)
                {
                  pair->ssl_flag = pair->ssl_flag | sf_cb_on_r | sf_cb_on_r;
                  if(Debug >= 9)
                    message(7, "%d TCP %d: SSL_connect interrupted sf=%x", pair->stone->sd, sd, pair->ssl_flag);

                  return 0;
                }

              }
              signed int return_value_priority$9;
              return_value_priority$9=priority(pair);
              signed int *return_value___errno_location$10;
              return_value___errno_location$10=__errno_location();
              message(return_value_priority$9, "%d TCP %d: SSL_connect I/O error sf=%x errno=%d", pair->stone->sd, sd, pair->ssl_flag, *return_value___errno_location$10);
            }

            else
            {
              signed int return_value_priority$11;
              return_value_priority$11=priority(pair);
              char *return_value_ERR_error_string$12;
              return_value_ERR_error_string$12=ERR_error_string(e, (char *)(void *)0);
              message(return_value_priority$11, "%d TCP %d: SSL_connect sf=%x %s", pair->stone->sd, sd, pair->ssl_flag, return_value_ERR_error_string$12);
            }
            return ret;
          }

      if(Debug >= 5)
        message(7, "%d TCP %d: SSL_connect interrupted sf=%x err=%d", pair->stone->sd, sd, pair->ssl_flag, err);

      return ret;
    }
  }
}

// doSSL_shutdown
// file stone.c line 3424
signed int doSSL_shutdown(struct _Pair *pair, signed int how)
{
  signed int ret;
  signed int err;
  signed int i;
  signed int sd;
  struct ssl_st *ssl;
  struct anonymous$12 *ss;
  signed int *return_value___errno_location$3;
  _Bool tmp_if_expr$5;
  signed int *return_value___errno_location$4;
  signed int return_value_priority$9;
  if(pair == ((struct _Pair *)NULL))
    return -1;

  else
  {
    sd = pair->sd;
    if(!(sd >= 0))
      return -1;

    else
    {
      ssl = pair->ssl;
      if(ssl == ((struct ssl_st *)NULL))
        return -1;

      else
      {
        if(how >= 0)
          pair->ssl_flag = how & sf_mask;

        else
          pair->ssl_flag = sf_mask;
        if((pair->proto & proto_command) == 0x0f00)
          ss = pair->stone->ssl_server;

        else
          ss = pair->stone->ssl_client;
        if(!(ss->shutdown_mode == 0))
        {
          signed int state;
          state=SSL_get_shutdown(ssl);
          SSL_set_shutdown(ssl, state | ss->shutdown_mode);
        }

        i = 0;
        for( ; !(i >= 4); i = i + 1)
        {
          ret=SSL_shutdown(ssl);
          if(!(ret == 0))
            break;

        }
        if(ret == 0)
        {
          if(ss->shutdown_mode == 0)
          {
            if(Debug >= 5)
              message(7, "%d TCP %d: SSL_shutdown ret=%d sf=%x, so don't wait peer's notify", pair->stone->sd, sd, ret, pair->ssl_flag);

            SSL_set_shutdown(ssl, 2);
            ret=SSL_shutdown(ssl);
          }

        }

        if(!(ret >= 0))
        {
          err=SSL_get_error(ssl, ret);
          if(Debug >= 5)
            message(7, "%d TCP %d: SSL_shutdown ret=%d err=%d sf=%x", pair->stone->sd, sd, ret, err, pair->ssl_flag);

          if(err == 2)
            pair->ssl_flag = pair->ssl_flag | sf_sb_on_r;

          else
            if(err == 3)
              pair->ssl_flag = pair->ssl_flag | sf_sb_on_w;

            else
              if(err == 5)
              {
                unsigned long int e;
                e=ERR_get_error();
                if(e == 0ul)
                {
                  signed int *return_value___errno_location$6;
                  return_value___errno_location$6=__errno_location();
                  if(*return_value___errno_location$6 == 0)
                    ret = 1;

                  else
                  {
                    return_value___errno_location$3=__errno_location();
                    if(*return_value___errno_location$3 == 4)
                      tmp_if_expr$5 = (_Bool)1;

                    else
                    {
                      return_value___errno_location$4=__errno_location();
                      tmp_if_expr$5 = *return_value___errno_location$4 == 11 ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr$5)
                    {
                      pair->ssl_flag = pair->ssl_flag | sf_sb_on_r | sf_sb_on_r;
                      if(Debug >= 9)
                        message(7, "%d TCP %d: SSL_shutdown interrupted sf=%x", pair->stone->sd, sd, pair->ssl_flag);

                    }

                    else
                    {
                      signed int return_value_priority$1;
                      return_value_priority$1=priority(pair);
                      signed int *return_value___errno_location$2;
                      return_value___errno_location$2=__errno_location();
                      message(return_value_priority$1, "%d TCP %d: SSL_shutdown I/O error sf=%x errno=%d", pair->stone->sd, sd, pair->ssl_flag, *return_value___errno_location$2);
                    }
                  }
                }

                else
                {
                  signed int return_value_priority$7;
                  return_value_priority$7=priority(pair);
                  char *return_value_ERR_error_string$8;
                  return_value_ERR_error_string$8=ERR_error_string(e, (char *)(void *)0);
                  message(return_value_priority$7, "%d TCP %d: SSL_shutdown sf=%x %s", pair->stone->sd, sd, pair->ssl_flag, return_value_ERR_error_string$8);
                }
              }

              else
                if(Debug >= 5)
                  message(7, "%d TCP %d: SSL_shutdown interrupted sf=%x err=%d", pair->stone->sd, sd, pair->ssl_flag, err);

        }

        else
          if(ret == 0)
          {
            if(Debug >= 5)
            {
              return_value_priority$9=priority(pair);
              message(return_value_priority$9, "%d TCP %d: SSL_shutdown error ret=%d sf=%x, reset connection", pair->stone->sd, sd, ret, pair->ssl_flag);
            }

            shutdown(sd, 2);
            ret = 0;
          }

        if(ret >= 1)
        {
          if(Debug >= 5)
            message(7, "%d TCP %d: SSL_shutdown sf=%x", pair->stone->sd, sd, pair->ssl_flag);

          if(!((pair->ssl_flag & sf_mask) == sf_mask))
            shutdown(sd, pair->ssl_flag & sf_mask);

        }

        return ret;
      }
    }
  }
}

// doargs
// file stone.c line 9598
void doargs(signed int argc, signed int i, char **argv)
{
  struct _Stone *stone;
  char *host;
  char *shost;
  char *serv;
  char *sserv;
  signed int proto;
  signed int sproto;
  signed int dproto;
  char *p;
  signed int j;
  signed int k;
  dproto = 0;
  sproto = dproto;
  proto = sproto;
  if(!(argc + -i >= 1))
  {
    help(argv[(signed long int)0], (char *)(void *)0);
    exit(1);
  }

  signed int tmp_statement_expression$3;
  signed int tmp_post$5;
  for( ; !(i >= argc); i = i + 1)
  {
    p = argv[(signed long int)i];
    if((signed int)*p == 45)
    {
      p = p + 1l;
      while(!(*p == 0))
      {
        signed int ret;
        ret=dohyphen(*p, argc, argv, i);
        if(ret >= 0)
          i = ret;

        else
        {
          message(3, "Invalid Option: %s", argv[(signed long int)i]);
          help(argv[(signed long int)0], "opt");
          exit(1);
        }
        p = p + 1l;
      }
    }

    else
    {
      char *return_value___strdup$1;
      return_value___strdup$1=__strdup(argv[(signed long int)i]);
      host = return_value___strdup$1;
      j=getdist(host, &dproto);
      if(j >= 1)
      {
        i = i + 1;
        if(j >= 2)
          serv = host + (signed long int)j;

        else
          serv = (char *)(void *)0;
        if(i >= argc)
        {
          help(argv[(signed long int)0], (char *)(void *)0);
          exit(1);
        }

        char *return_value___strdup$2;
        return_value___strdup$2=__strdup(argv[(signed long int)i]);
        shost = return_value___strdup$2;
        j=getdist(shost, &sproto);
        if(j >= 1)
        {
          if(j >= 2)
            sserv = shost + (signed long int)j;

          else
            sserv = (char *)(void *)0;
        }

        else
          if(j == 0)
          {
            sserv = shost;
            shost = (char *)(void *)0;
          }

          else
          {
            message(3, "Invalid <sport>: %s", argv[(signed long int)i]);
            exit(1);
          }
      }

      else
      {
        message(3, "Invalid <host>:<port>: %s", argv[(signed long int)i]);
        exit(1);
      }
      i = i + 1;
      j = 0;
      k = i;
      for( ; !(i >= argc); j = j + 1)
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp$4;
        return_value___builtin_strcmp$4=__builtin_strcmp(argv[(signed long int)i], "--");
        tmp_statement_expression$3 = return_value___builtin_strcmp$4;
        if(tmp_statement_expression$3 == 0)
          break;

        i = i + 1;
      }
      if(!(((proto_udp_d | proto_udp_s) & sproto) == 0))
      {
        proto = proto | proto_udp_s;
        if(!(((proto_v6_d | proto_v6_s) & sproto) == 0))
          proto = proto | proto_v6_s;

        if(!(((proto_ip_only_d | proto_ip_only_s) & sproto) == 0))
          proto = proto | proto_ip_only_s;

      }

      else
      {
        if(!(((proto_ohttp_d | proto_ohttp_s) & sproto) == 0))
          proto = proto | proto_ohttp_s;

        if(!(((proto_ssl_d | proto_ssl_s) & sproto) == 0))
          proto = proto | proto_ssl_s;

        if(!(((proto_v6_d | proto_v6_s) & sproto) == 0))
          proto = proto | proto_v6_s;

        if(!(((proto_ip_only_d | proto_ip_only_s) & sproto) == 0))
          proto = proto | proto_ip_only_s;

        if(!(((proto_unix_d | proto_unix_s) & sproto) == 0))
          proto = proto | proto_unix_s;

        if(!(((proto_block_d | proto_block_s) & sproto) == 0))
          proto = proto | proto_block_s;

        if(!(((proto_base_d | proto_base_s) & sproto) == 0))
          proto = proto | proto_base_s;

        if(!((sproto & proto_ident) == 0))
          proto = proto | proto_ident;

      }
      if(!(((proto_udp_d | proto_udp_s) & dproto) == 0))
      {
        proto = proto | proto_udp_d;
        if(!(((proto_v6_d | proto_v6_s) & dproto) == 0))
          proto = proto | proto_v6_d;

        if(!(((proto_ip_only_d | proto_ip_only_s) & dproto) == 0))
          proto = proto | proto_ip_only_d;

      }

      else
      {
        if((dproto & proto_command) == 0x0600)
        {
          proto = proto & ~proto_command;
          proto = proto | 0x0600;
        }

        else
          if(!(((proto_ohttp_d | proto_ohttp_s) & dproto) == 0))
          {
            proto = proto | proto_ohttp_d;
            goto extra_arg;
          }

          else
            if((dproto & proto_command) == 0x0100)
            {
              proto = proto & ~proto_command;
              proto = proto | 0x0100;

            extra_arg:
              ;
              tmp_post$5 = k;
              k = k + 1;
              p = argv[(signed long int)tmp_post$5];
              j = j - 1;
              if(!(j >= 0) || !(argc >= k))
              {
                help(argv[(signed long int)0], (char *)(void *)0);
                exit(1);
              }

            }

            else
              if((dproto & proto_command) == 0x0200)
              {
                proto = proto & ~proto_command;
                proto = proto | 0x0200;
                goto extra_arg;
              }

              else
                if((dproto & proto_command) == 0x0400)
                {
                  proto = proto & ~proto_command;
                  proto = proto | 0x0400;
                }

                else
                  if((dproto & proto_command) == 0x0500)
                  {
                    proto = proto & ~proto_command;
                    proto = proto | 0x0500;
                  }

        if(!(((proto_ssl_d | proto_ssl_s) & dproto) == 0))
          proto = proto | proto_ssl_d;

        if(!(((proto_v6_d | proto_v6_s) & dproto) == 0))
          proto = proto | proto_v6_d;

        if(!(((proto_ip_only_d | proto_ip_only_s) & dproto) == 0))
          proto = proto | proto_ip_only_d;

        if(!(((proto_unix_d | proto_unix_s) & dproto) == 0))
          proto = proto | proto_unix_d;

        if(!(((proto_block_d | proto_block_s) & dproto) == 0))
          proto = proto | proto_block_d;

        if(!(((proto_base_d | proto_base_s) & dproto) == 0))
          proto = proto | proto_base_d;

        if(!((dproto & proto_nobackup) == 0))
          proto = proto | proto_nobackup;

      }
      stone=mkstone(host, serv, shost, sserv, j, &argv[(signed long int)k], proto);
      if(!((proto & proto_udp_d) == 0) && !((proto & proto_udp_s) == 0))
      {
        struct _Origin *origin;
        void *return_value_malloc$6;
        return_value_malloc$6=malloc(sizeof(struct _Origin) /*56ul*/ );
        origin = (struct _Origin *)return_value_malloc$6;
        if(origin == ((struct _Origin *)NULL))
        {

        memerr:
          ;
          message(2, "Out of memory");
          exit(1);
        }

        bzero((void *)origin, sizeof(struct _Origin) /*56ul*/ );
        origin->stone = stone;
        origin->common = 0x0002;
        origin->sd = -1;
        origin->from = (struct anonymous$0 *)(void *)0;
        origin->next = OriginTop;
        OriginTop = origin;
        stone->p = (char *)origin;
      }

      else
        if(!((proto & proto_ohttp_d) == 0))
        {
          char *return_value___strdup$7;
          return_value___strdup$7=__strdup(p);
          stone->p = return_value___strdup$7;
        }

        else
          if((proto & proto_command) == 0x0100 || (proto & proto_command) == 0x0200)
          {
            char *return_value___strdup$8;
            return_value___strdup$8=__strdup(p);
            stone->p = return_value___strdup$8;
          }

      if((proto & proto_udp_d) == 0 || (proto & proto_udp_s) == 0)
      {
        stone->pairs=newPair();
        if(stone->pairs == ((struct _Pair *)NULL))
          goto memerr;

        stone->pairs->clock = (signed long int)-1;
        stone->pairs->stone = stone;
        stone->pairs->next = PairTop;
        if(!(PairTop == ((struct _Pair *)NULL)))
          PairTop->prev = stone->pairs;

        PairTop = stone->pairs;
      }

      if(stone->parent == ((struct _Stone *)NULL))
      {
        stone->next = stones;
        stones = stone;
      }

      dproto = 0;
      sproto = dproto;
      proto = sproto;
    }
  }
}

// docloseUDP
// file stone.c line 2841
void docloseUDP(struct _Origin *origin)
{
  signed int sd = origin->sd;
  if(Debug >= 3)
    message(7, "%d UDP %d: close", origin->stone->sd, origin->sd);

  origin->lock = -1;
  origin->sd = -1;
  close(sd);
}

// docomm
// file stone.c line 5936
signed int docomm(struct _Pair *pair, struct _Comm *comm)
{
  struct _ExBuf *ex = pair->b;
  char buf[2048l];
  char *p;
  char *q = &ex->buf[(signed long int)(ex->start + ex->len)];
  signed int start;
  signed int i;
  p = &ex->buf[(signed long int)ex->start];
  _Bool tmp_if_expr$1;
  for( ; !(p >= q); p = p + 1l)
  {
    if((signed int)*p == 13)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)*p == 10 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      break;

  }
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  char *tmp_post$4;
  if(p >= q)
  {
    if(p >= ex->buf + (signed long int)ex->bufmax)
      goto __CPROVER_DUMP_L5;

    ex->start = ex->start + ex->len;
    ex->len = 0;
    return -2;
  }

  else
  {

  __CPROVER_DUMP_L5:
    ;
    start = (signed int)((p - ex->buf) - (signed long int)1);
    for( ; start >= 0; start = start - 1)
    {
      if((signed int)ex->buf[(signed long int)start] == 13)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)ex->buf[(signed long int)start] == 10 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        break;

    }
    start = start + 1;
    for( ; (_Bool)1; p = p + 1l)
    {
      if(!((signed int)*p == 13))
      {
        if(!((signed int)*p == 10))
          goto __CPROVER_DUMP_L12;

      }

      if(p >= q)
        break;

    }

  __CPROVER_DUMP_L12:
    ;
    ex->start = (signed int)(p - ex->buf);
    if(!(p >= q))
      ex->len = (signed int)(q - p);

    else
      ex->len = 0;
    for( ; !(comm->str == ((char *)NULL)); comm = comm + 1l)
    {
      q=comm_match(&ex->buf[(signed long int)start], comm->str);
      if(!(q == ((char *)NULL)))
        break;

    }
    if(q == ((char *)NULL))
      q = &ex->buf[(signed long int)start];

    i = 0;
    for( ; !(q >= p) && !(i >= 2048); i = i + 1)
    {
      if((signed int)*q == 13)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)*q == 10 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        break;

      tmp_post$4 = q;
      q = q + 1l;
      buf[(signed long int)i] = *tmp_post$4;
    }
    buf[(signed long int)i] = (char)0;
    signed int return_value;
    return_value=comm->func(pair, buf, start);
    return return_value;
  }
}

// doconnect
// file stone.c line 3780
signed int doconnect(struct _Pair *p1, struct sockaddr *sa, unsigned int salen)
{
  struct sockaddr_storage ss;
  struct sockaddr *dst = (struct sockaddr *)&ss;
  unsigned int dstlen;
  signed int ret;
  struct _Pair *p2;
  signed long int clock;
  char addrport[128l];
  struct epoll_event ev;
  signed int *return_value___errno_location$10;
  signed int *return_value___errno_location$5;
  _Bool tmp_if_expr$7;
  signed int *return_value___errno_location$6;
  _Bool tmp_if_expr$9;
  signed int *return_value___errno_location$8;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  signed int return_value_doshutdown$12;
  if(p1 == ((struct _Pair *)NULL))
    return -1;

  else
  {
    p2 = p1->pair;
    if(p2 == ((struct _Pair *)NULL))
      return -1;

    else
      if((p2->proto & proto_connect) == 0)
        return 0;

      else
      {
        bcopy((const void *)sa, (void *)dst, (unsigned long int)salen);
        dstlen = salen;
        time(&clock);
        if(Debug >= 9)
          message(7, "%d TCP %d: doconnect", p1->stone->sd, p1->sd);

        ret=modPairDest(p1, dst, (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ );
        if(ret >= 1)
          dstlen = (unsigned int)ret;

        else
          if(ret == -2)
            return ret;

        if((p1->stone->proto & proto_block_d) == 0)
          fcntl(p1->sd, 4, 04000);

        addrport[(signed long int)0] = (char)0;
        if(Debug >= 3)
        {
          addrport2strOnce(dst, dstlen, p1->proto & (proto_ohttp_d | proto_base_d | proto_command), addrport, 127, 0);
          message(7, "%d TCP %d: connecting to TCP %d %s", p1->stone->sd, p2->sd, p1->sd, (const void *)addrport);
        }

        if(!((p1->proto & proto_dgram) == 0))
          ret = 0;

        else
          ret=connect(p1->sd, dst, dstlen);
        if(!(ret >= 0))
        {
          signed int *return_value___errno_location$11;
          return_value___errno_location$11=__errno_location();
          if(*return_value___errno_location$11 == 115)
          {
            p1->proto = p1->proto | proto_conninprog | proto_dirty;
            if(Debug >= 4)
              message(7, "%d TCP %d: connection in progress", p1->stone->sd, p1->sd);

            goto done;
          }

          else
          {
            return_value___errno_location$10=__errno_location();
            if(*return_value___errno_location$10 == 4)
            {
              if(Debug >= 5)
                message(7, "%d TCP %d: connect interrupted", p1->stone->sd, p1->sd);

              if(!(clock + -p1->clock >= 60l))
                return 0;

              addrport2strOnce(dst, dstlen, p1->proto & (proto_ohttp_d | proto_base_d | proto_command), addrport, 127, 0);
              signed int return_value_priority$1;
              return_value_priority$1=priority(p2);
              message(return_value_priority$1, "%d TCP %d: connect timeout to %s", p2->stone->sd, p2->sd, (const void *)addrport);
            }

            else
            {
              return_value___errno_location$5=__errno_location();
              if(*return_value___errno_location$5 == 106)
                tmp_if_expr$7 = (_Bool)1;

              else
              {
                return_value___errno_location$6=__errno_location();
                tmp_if_expr$7 = *return_value___errno_location$6 == 98 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$7)
                tmp_if_expr$9 = (_Bool)1;

              else
              {
                return_value___errno_location$8=__errno_location();
                tmp_if_expr$9 = *return_value___errno_location$8 == 114 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$9)
              {
                if(Debug >= 5)
                {
                  signed int *return_value___errno_location$2;
                  return_value___errno_location$2=__errno_location();
                  message(7, "%d TCP %d: connect bug err=%d", p1->stone->sd, p1->sd, *return_value___errno_location$2);
                  message_pair(7, p1);
                }

              }

              else
              {
                addrport2strOnce(dst, dstlen, p1->proto & (proto_ohttp_d | proto_base_d | proto_command), addrport, 127, 0);
                signed int return_value_priority$3;
                return_value_priority$3=priority(p1);
                signed int *return_value___errno_location$4;
                return_value___errno_location$4=__errno_location();
                message(return_value_priority$3, "%d TCP %d: can't connect err=%d: to %s", p1->stone->sd, p1->sd, *return_value___errno_location$4, (const void *)addrport);
              }
            }
          }
        }

        if(!(ret >= 0))
          tmp_if_expr$13 = (_Bool)1;

        else
          tmp_if_expr$13 = (p1->proto & proto_close) != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$13)
          tmp_if_expr$14 = (_Bool)1;

        else
          tmp_if_expr$14 = (p2->proto & proto_close) != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$14)
        {
          if((p2->proto & proto_shutdown) == 0)
          {
            return_value_doshutdown$12=doshutdown(p2, 2);
            if(return_value_doshutdown$12 >= 0)
              p2->proto = p2->proto | proto_shutdown | proto_dirty;

          }

          p2->proto = p2->proto | proto_close | proto_dirty;
          p1->proto = p1->proto | proto_close | proto_dirty;
          return -1;
        }

        connected(p1);

      done:
        ;
        ev.events = (unsigned int)1073741824;
        ev.data.ptr = (void *)p1;
        if(Debug >= 7)
          message(7, "%d TCP %d: doconnect epoll_ctl %d ADD %x", p1->stone->sd, p1->sd, ePollFd, (signed int)ev.data.ptr);

        signed int return_value_epoll_ctl$16;
        return_value_epoll_ctl$16=epoll_ctl(ePollFd, 1, p1->sd, &ev);
        if(!(return_value_epoll_ctl$16 >= 0))
        {
          signed int *return_value___errno_location$15;
          return_value___errno_location$15=__errno_location();
          message(3, "%d TCP %d: doconnect epoll_ctl %d ADD err=%d", p1->stone->sd, p1->sd, ePollFd, *return_value___errno_location$15);
        }

        return 1;
      }
  }
}

// dohyphen
// file stone.c line 9133
signed int dohyphen(char opt, signed int argc, char **argv, signed int argi)
{
  signed int tmp_statement_expression$3;
  signed int tmp_statement_expression$7;
  char *return_value___strdup$9;
  char *return_value___strdup$10;
  signed int return_value_atoi$11;
  signed int return_value_atoi$12;
  char *return_value___strdup$13;
  _Bool tmp_if_expr$18;
  signed int tmp_statement_expression$15;
  char *return_value___strdup$19;
  char *return_value___strdup$20;
  switch((signed int)opt)
  {
    case 100:
    {
      Debug = Debug + 1;
      break;
    }
    case 112:
    {
      XHostsTrue->mode = (signed short int)((signed int)XHostsTrue->mode & ~0xF | ((signed int)XHostsTrue->mode & 0xF) + 1 & 0xF);
      break;
    }
    case 108:
    {
      Syslog = Syslog + 1;
      break;
    }
    case 76:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "option -%c requires log <file>", opt);
        exit(1);
      }

      if(!(DryRun == 0))
        break;

      unsigned long int dohyphen$$1$$1$$2$$__s1_len;
      unsigned long int dohyphen$$1$$1$$2$$__s2_len;
      signed int return_value___builtin_strcmp$4;
      return_value___builtin_strcmp$4=__builtin_strcmp(argv[(signed long int)argi], "-");
      tmp_statement_expression$3 = return_value___builtin_strcmp$4;
      if(tmp_statement_expression$3 == 0)
        LogFp = stdout;

      else
      {
        if(!(LogFp == ((struct _IO_FILE *)NULL)) && !(LogFp == stderr))
          fclose(LogFp);

        LogFp=fopen(argv[(signed long int)argi], "a");
        if(LogFp == ((struct _IO_FILE *)NULL))
        {
          LogFp = stderr;
          signed int *return_value___errno_location$1;
          return_value___errno_location$1=__errno_location();
          message(3, "Can't create log file: %s err=%d", argv[(signed long int)argi], *return_value___errno_location$1);
          exit(1);
        }

        char *return_value___strdup$2;
        return_value___strdup$2=__strdup(argv[(signed long int)argi]);
        LogFileName = return_value___strdup$2;
      }
      setbuf(LogFp, (char *)(void *)0);
      break;
    }
    case 97:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "option -%c requires accounting <file>", opt);
        exit(1);
      }

      if(!(DryRun == 0))
        break;

      unsigned long int dohyphen$$1$$1$$6$$__s1_len;
      unsigned long int dohyphen$$1$$1$$6$$__s2_len;
      signed int return_value___builtin_strcmp$8;
      return_value___builtin_strcmp$8=__builtin_strcmp(argv[(signed long int)argi], "-");
      tmp_statement_expression$7 = return_value___builtin_strcmp$8;
      if(tmp_statement_expression$7 == 0)
        AccFp = stdout;

      else
      {
        if(!(AccFp == ((struct _IO_FILE *)NULL)) && !(AccFp == stdout))
          fclose(AccFp);

        AccFp=fopen(argv[(signed long int)argi], "a");
        if(AccFp == ((struct _IO_FILE *)NULL))
        {
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          message(3, "Can't create account log file: %s err=%d", argv[(signed long int)argi], *return_value___errno_location$5);
          exit(1);
        }

        char *return_value___strdup$6;
        return_value___strdup$6=__strdup(argv[(signed long int)argi]);
        AccFileName = return_value___strdup$6;
      }
      setbuf(AccFp, (char *)(void *)0);
      break;
    }
    case 105:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "option -%c requires pid <file>", opt);
        exit(1);
      }

      return_value___strdup$9=__strdup(argv[(signed long int)argi]);
      PidFile = return_value___strdup$9;
      break;
    }
    case 116:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "option -%c requires <dir>", opt);
        exit(1);
      }

      return_value___strdup$10=__strdup(argv[(signed long int)argi]);
      RootDir = return_value___strdup$10;
      break;
    }
    case 110:
    {
      AddrFlag = 1;
      break;
    }
    case 117:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "option -%c requires # of <max> UDP sessions", opt);
        exit(1);
      }

      OriginMax=atoi(argv[(signed long int)argi]);
      break;
    }
    case 88:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "option -%c requires size of Xfer buffer <n>", opt);
        exit(1);
      }

      XferBufMax=atoi(argv[(signed long int)argi]);
      break;
    }
    case 84:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "option -%c requires timeout <n>", opt);
        exit(1);
      }

      PairTimeOut=atoi(argv[(signed long int)argi]);
      break;
    }
    case 65:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "option -%c requires length of backlog <n>", opt);
        exit(1);
      }

      BacklogMax=atoi(argv[(signed long int)argi]);
      break;
    }
    case 111:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "option -%c requires <uid>", opt);
        exit(1);
      }

      return_value_atoi$11=atoi(argv[(signed long int)argi]);
      SetUID = (unsigned int)return_value_atoi$11;
      break;
    }
    case 103:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "option -%c requires <gid>", opt);
        exit(1);
      }

      return_value_atoi$12=atoi(argv[(signed long int)argi]);
      SetGID = (unsigned int)return_value_atoi$12;
      break;
    }
    case 99:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "option -%c requires <dir> for core dump", opt);
        exit(1);
      }

      return_value___strdup$13=__strdup(argv[(signed long int)argi]);
      CoreDumpDir = return_value___strdup$13;
      break;
    }
    case 102:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "option -%c requires # of child processes <n>", opt);
        exit(1);
      }

      NForks=atoi(argv[(signed long int)argi]);
      break;
    }
    case 68:
    {
      DaemonMode = 1;
      break;
    }
    case 114:
    {
      ReuseAddr = 1;
      break;
    }
    case 120:
    {
      argi=mkPortXhosts(argc, argi, argv);
      break;
    }
    case 115:
    {
      argi=mkChat(argc, argi, argv);
      break;
    }
    case 98:
    {
      argi=mkBackup(argc, argi, argv);
      break;
    }
    case 66:
    {
      argi=lbsopts(argc, argi, argv);
      break;
    }
    case 73:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "option -%c requires local interface <host>", opt);
        exit(1);
      }

      if(argv[(signed long int)argi] == ((char *)NULL))
        tmp_if_expr$18 = (_Bool)1;

      else
        tmp_if_expr$18 = (signed int)argv[(signed long int)argi][(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$18)
        ConnectFrom = (struct anonymous$0 *)(void *)0;

      else
      {
        char host[128l];
        char port[128l];
        struct sockaddr_storage ss;
        struct sockaddr *sa = (struct sockaddr *)&ss;
        unsigned int salen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
        signed int pos;
        pos=hostPortExt(argv[(signed long int)argi], host, port);
        if(!(pos >= 0))
        {
          sa->sa_family = (unsigned short int)0;
          signed int return_value_host2sa$14;
          return_value_host2sa$14=host2sa(argv[(signed long int)argi], (char *)(void *)0, sa, &salen, (signed int *)(void *)0, (signed int *)(void *)0, 0);
          if(return_value_host2sa$14 == 0)
            return -1;

        }

        else
        {
          sa->sa_family = (unsigned short int)0;
          if(!(pos == 0))
          {
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp$16;
            return_value___builtin_strcmp$16=__builtin_strcmp(argv[(signed long int)argi] + (signed long int)pos, "v6");
            tmp_statement_expression$15 = return_value___builtin_strcmp$16;
            if(tmp_statement_expression$15 == 0)
              sa->sa_family = (unsigned short int)10;

          }

          signed int return_value_host2sa$17;
          return_value_host2sa$17=host2sa(host, port, sa, &salen, (signed int *)(void *)0, (signed int *)(void *)0, 0);
          if(return_value_host2sa$17 == 0)
            return -1;

        }
        ConnectFrom=saDup(sa, salen);
        if(ConnectFrom == ((struct anonymous$0 *)NULL))
        {
          message(2, "Out of memory");
          exit(1);
        }

      }
      break;
    }
    case 113:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "Illegal Option: -q without <SSL>");
        exit(1);
      }

      argi=sslopts(argc, argi, argv, &ClientOpts, 0);
      break;
    }
    case 122:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "Illegal Option: -z without <SSL>");
        exit(1);
      }

      argi=sslopts(argc, argi, argv, &ServerOpts, 1);
      break;
    }
    case 80:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "option -%c requires preprocessor <command>", opt);
        exit(1);
      }

      return_value___strdup$19=__strdup(argv[(signed long int)argi]);
      CppCommand = return_value___strdup$19;
      break;
    }
    case 81:
    {
      argi = argi + 1;
      if(argi >= argc)
      {
        message(3, "option -%c requires <options> for preprocessor", opt);
        exit(1);
      }

      return_value___strdup$20=__strdup(argv[(signed long int)argi]);
      CppOptions = return_value___strdup$20;
      break;
    }
    default:
      return -1;
  }
  return argi;
}

// doopts
// file stone.c line 9519
signed int doopts(signed int argc, char **argv)
{
  signed int i;
  char *p;
  i = 1;
  unsigned long int return_value_strlen$1;
  void *return_value_malloc$2;
  for( ; !(i >= argc); i = i + 1)
  {
    p = argv[(signed long int)i];
    if((signed int)*p == 45)
    {
      p = p + 1l;
      while(!(*p == 0))
      {
        signed int ret;
        ret=dohyphen(*p, argc, argv, i);
        if(ret >= 0)
          i = ret;

        else
          switch((signed int)*p)
          {
            case 45:
              return i + 1;
            case 104:
            {
              help(argv[(signed long int)0], argv[(signed long int)(i + 1)]);
              exit(1);
              break;
            }
            case 78:
            {
              DryRun = 1;
              break;
            }
            case 67:
            {
              if(!(ConfigFile == ((char *)NULL)))
                goto __CPROVER_DUMP_L9;

              i = i + 1;
              return_value_strlen$1=strlen(argv[(signed long int)i]);
              return_value_malloc$2=malloc(return_value_strlen$1 + (unsigned long int)1);
              ConfigFile = (char *)return_value_malloc$2;
              if(ConfigFile == ((char *)NULL))
              {
                message(2, "Out of memory");
                exit(1);
              }

              strcpy(ConfigFile, argv[(signed long int)i]);
              break;
            }
            default:
            {

            __CPROVER_DUMP_L9:
              ;
              message(3, "Invalid Option: %s", argv[(signed long int)i]);
              help(argv[(signed long int)0], "opt");
              exit(1);
            }
          }
        p = p + 1l;
      }
    }

    else
      break;
  }
  return i;
}

// doproxy
// file stone.c line 5330
signed int doproxy(struct _Pair *pair, char *host, char *serv)
{
  signed int sd = pair->sd;
  signed int reconnect = 0;
  struct _PortXHosts *pxh;
  struct sockaddr_storage name_s;
  struct sockaddr *name = (struct sockaddr *)&name_s;
  struct sockaddr_storage ss;
  struct sockaddr *sa = (struct sockaddr *)&ss;
  unsigned int namelen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  unsigned int salen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  if(!((pair->stone->proto & proto_ip_only_d) == 0))
  {
    if(!((pair->stone->proto & proto_v6_d) == 0))
      sa->sa_family = (unsigned short int)10;

    else
      sa->sa_family = (unsigned short int)2;
  }

  else
    sa->sa_family = (unsigned short int)0;
  signed int return_value_host2sa$1;
  return_value_host2sa$1=host2sa(host, serv, sa, &salen, (signed int *)(void *)0, (signed int *)(void *)0, 0);
  signed int return_value_getpeername$5;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  signed int tmp_if_expr$6;
  if(return_value_host2sa$1 == 0)
    return -1;

  else
  {
    signed int return_value_islocalhost$2;
    return_value_islocalhost$2=islocalhost(sa);
    if(!(return_value_islocalhost$2 == 0))
    {
      struct _TimeLog *log = pair->log;
      pair->log = (struct _TimeLog *)(void *)0;
      if(!(log == ((struct _TimeLog *)NULL)))
        free((void *)log);

    }

    if((pair->stone->proto & proto_nobackup) == 0)
    {
      struct _Backup *backup;
      backup=findBackup(sa);
      if(!(backup == ((struct _Backup *)NULL)))
      {
        if(!(backup->bn == 0))
        {
          sa = &backup->backup->addr;
          salen = backup->backup->len;
        }

      }

    }

    pxh = (struct _PortXHosts *)pair->stone->dsts[(signed long int)1];
    if(!(pxh == ((struct _PortXHosts *)NULL)))
    {
      for( ; !(pxh == ((struct _PortXHosts *)NULL)); pxh = pxh->next)
      {
        struct _XPorts *ports;
        struct _XHosts *xhost;
        signed int isok = 0;
        signed int port;
        port=getport(sa);
        ports = pxh->ports;
        for( ; !(ports == ((struct _XPorts *)NULL)); ports = ports->next)
          if(port >= (signed int)ports->from)
          {
            if((signed int)ports->end >= port)
              isok = 1;

          }

        if(!(isok == 0))
        {
          xhost=checkXhost(pxh->xhosts, sa, salen);
          if(!(xhost == ((struct _XHosts *)NULL)))
          {
            if(!(xhost->mode == 0))
            {
              struct _Pair *p = pair->pair;
              pair->xhost = xhost;
              if(!(p == ((struct _Pair *)NULL)))
                p->xhost = xhost;

            }

            if(Debug >= 8)
              message(7, "stone %d: proxy can connect to %s:%s mode=%d", pair->stone->sd, host, serv, xhost->mode);

            break;
          }

          else
          {
            message(4, "stone %d: proxy may not connect to %s", pair->stone->sd, host);
            return -1;
          }
        }

      }
      if(!(pxh == ((struct _PortXHosts *)NULL)))
        goto __CPROVER_DUMP_L21;

      message(4, "stone %d: proxy may not connect to port %s", pair->stone->sd, serv);
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L21:
      ;
      if(!((pair->proto & proto_connect) == 0))
      {
        if((pair->proto & proto_close) == 0)
        {
          return_value_getpeername$5=getpeername(sd, name, &namelen);
          if(return_value_getpeername$5 >= 0)
          {
            struct _Pair *doproxy$$1$$6$$p = pair->pair;
            if(Debug >= 8)
            {
              char str[128l];
              char *return_value_addrport2str$3;
              return_value_addrport2str$3=addrport2str(name, namelen, 0, str, 127, 0);
              message(7, "%d TCP %d: old proxy connection: %s", pair->stone->sd, sd, return_value_addrport2str$3);
            }

            if(!(doproxy$$1$$6$$p == ((struct _Pair *)NULL)))
              doproxy$$1$$6$$p->proto = doproxy$$1$$6$$p->proto | proto_first_w | proto_dirty;

            signed int return_value_saComp$4;
            return_value_saComp$4=saComp(sa, name);
            if(!(return_value_saComp$4 == 0))
              return 0;

            reconnect = 1;
          }

        }

      }

      if(!(reconnect == 0))
        tmp_if_expr$8 = (_Bool)1;

      else
      {
        if(!((pair->stone->proto & proto_v6_d) == 0))
          tmp_if_expr$7 = (signed int)sa->sa_family == 2 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$7 = (_Bool)0;
        tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$8)
        tmp_if_expr$10 = (_Bool)1;

      else
      {
        if((pair->stone->proto & proto_v6_d) == 0)
          tmp_if_expr$9 = (signed int)sa->sa_family == 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$9 = (_Bool)0;
        tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$10)
      {
        signed int nsd;
        nsd=socket((signed int)sa->sa_family, 1, 6);
        if(nsd >= 0)
        {
          struct _Pair *doproxy$$1$$7$$1$$p = pair->pair;
          pair->sd = nsd;
          if(!(doproxy$$1$$7$$1$$p == ((struct _Pair *)NULL)))
            tmp_if_expr$6 = doproxy$$1$$7$$1$$p->sd;

          else
            tmp_if_expr$6 = -1;
          message(6, "%d TCP %d: close %d %08x, reopen %d as family=%d", pair->stone->sd, tmp_if_expr$6, sd, pair->proto, nsd, sa->sa_family);
          close(sd);
        }

      }

      pair->proto = pair->proto & ~(proto_connect | proto_command);
      signed int return_value_reqconn$11;
      return_value_reqconn$11=reqconn(pair, sa, salen);
      if(!(return_value_reqconn$11 >= 0))
        return -1;

      else
      {
        if((pair->proto & state_mask) == 1)
        {
          if(Debug >= 8)
            message(7, "%d TCP %d: command_proxy again", pair->stone->sd, pair->sd);

          pair->proto = pair->proto | 0x0600;
        }

        return 0;
      }
    }
  }
}

// doread
// file stone.c line 5022
signed int doread(struct _Pair *pair)
{
  signed int sd = pair->sd;
  struct _Pair *p;
  signed int len;
  signed int i;
  struct _ExBuf *ex;
  signed int bufmax;
  signed int start;
  signed long int return_value_recv$1;
  signed int tmp_post$3;
  _Bool tmp_if_expr$4;
  if(!(sd >= 0))
    return -1;

  else
  {
    if(Debug >= 6)
      message(7, "%d TCP %d: read", pair->stone->sd, sd);

    p = pair->pair;
    if(p == ((struct _Pair *)NULL))
    {
      char _buf[2048l];
      if(!(pair->ssl == ((struct ssl_st *)NULL)))
        len=SSL_read(pair->ssl, (void *)_buf, 2048);

      else
      {
        return_value_recv$1=recv(sd, (void *)_buf, (unsigned long int)2048, 0);
        len = (signed int)return_value_recv$1;
      }
      if(!((pair->proto & proto_close) == 0))
        return -1;

      if(Debug >= 5)
        message(7, "%d TCP %d: read %d bytes", pair->stone->sd, sd, len);

      if(len == 0)
        return -1;

      if(len >= 1)
      {
        signed int return_value_priority$2;
        return_value_priority$2=priority(pair);
        message(return_value_priority$2, "%d TCP %d: no pair, closing", pair->stone->sd, sd);
        message_pair(3, pair);
        len = -1;
      }

      return len;
    }

    ex = p->b;
    if(ex->len >= 1)
    {
      ex=getExBuf();
      if(ex == ((struct _ExBuf *)NULL))
        return -1;

      p->b->next = ex;
      p->b = ex;
      p->nbuf = p->nbuf + 1;
      if(Debug >= 5)
        message(7, "%d TCP %d: get ExBuf nbuf=%d", pair->stone->sd, p->sd, p->nbuf);

    }

    bufmax = (ex->bufmax - ex->start) - ex->len;
    start = ex->start + ex->len;
    if(!(((proto_base_d | proto_base_s) & p->proto) == 0))
      bufmax = ((bufmax - 1) / 4) * 3;

    else
      if(!(((proto_base_d | proto_base_s) & pair->proto) == 0))
      {
        if((pair->proto & proto_first_r) == 0)
        {
          len = (signed int)*((ex->buf + (signed long int)ex->bufmax) - (signed long int)1);
          i = 0;
          for( ; !(i >= len); i = i + 1)
          {
            tmp_post$3 = start;
            start = start + 1;
            ex->buf[(signed long int)tmp_post$3] = ex->buf[(signed long int)((ex->bufmax - 2) - i)];
          }
          bufmax = bufmax - len;
        }

        *((ex->buf + (signed long int)ex->bufmax) - (signed long int)1) = (char)0;
        bufmax = bufmax - 5;
      }

    if((p->proto & proto_command) == 0x0100)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (p->proto & proto_command) == 0x0200 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      bufmax = bufmax / 2;

    if(!(pair->ssl == ((struct ssl_st *)NULL)))
    {
      len=SSL_read(pair->ssl, (void *)&ex->buf[(signed long int)start], bufmax);
      if(!((pair->proto & proto_close) == 0))
        return -1;

      if(!(len >= 0))
      {
        signed int err;
        err=SSL_get_error(pair->ssl, len);
        if(err == 0 || err == 2)
        {
          if(Debug >= 5)
            message(7, "%d TCP %d: SSL_read interrupted err=%d", pair->stone->sd, sd, err);

          return 0;
        }

        else
          if(err == 3)
          {
            if(Debug >= 5)
              message(7, "%d TCP %d: SSL_read blocked on write err=%d", pair->stone->sd, sd, err);

            pair->ssl_flag = pair->ssl_flag | sf_rb_on_w;
            return 0;
          }

        if(err == 5)
        {
          unsigned long int e;
          e=ERR_get_error();
          if(e == 0ul)
          {
            signed int *return_value___errno_location$5;
            return_value___errno_location$5=__errno_location();
            if(*return_value___errno_location$5 == 4)
            {
              if(Debug >= 5)
                message(7, "%d TCP %d: SSL_read I/O interrupted", pair->stone->sd, sd);

              return 0;
            }

            signed int return_value_priority$6;
            return_value_priority$6=priority(pair);
            signed int *return_value___errno_location$7;
            return_value___errno_location$7=__errno_location();
            message(return_value_priority$6, "%d TCP %d: SSL_read I/O error err=%d, closing", pair->stone->sd, sd, *return_value___errno_location$7);
            message_pair(3, pair);
          }

          else
          {
            signed int return_value_priority$8;
            return_value_priority$8=priority(pair);
            char *return_value_ERR_error_string$9;
            return_value_ERR_error_string$9=ERR_error_string(e, (char *)(void *)0);
            message(return_value_priority$8, "%d TCP %d: SSL_read I/O %s, closing", pair->stone->sd, sd, return_value_ERR_error_string$9);
            message_pair(3, pair);
          }
          return -1;
        }

        else
          if(!(err == 6))
          {
            signed int return_value_priority$10;
            return_value_priority$10=priority(pair);
            unsigned long int return_value_ERR_get_error$11;
            return_value_ERR_get_error$11=ERR_get_error();
            char *return_value_ERR_error_string$12;
            return_value_ERR_error_string$12=ERR_error_string(return_value_ERR_get_error$11, (char *)(void *)0);
            message(return_value_priority$10, "%d TCP %d: SSL_read err=%d %s, closing", pair->stone->sd, sd, err, return_value_ERR_error_string$12);
            message_pair(3, pair);
            return -1;
          }

      }

    }

    else
    {
      signed long int return_value_recv$13;
      return_value_recv$13=recv(sd, (void *)&ex->buf[(signed long int)start], (unsigned long int)bufmax, 0);
      len = (signed int)return_value_recv$13;
      if(!((pair->proto & proto_close) == 0))
        return -1;

      if(!(len >= 0))
      {
        signed int *return_value___errno_location$14;
        return_value___errno_location$14=__errno_location();
        if(*return_value___errno_location$14 == 4)
        {
          if(Debug >= 5)
            message(7, "%d TCP %d: read interrupted", pair->stone->sd, sd);

          return 0;
        }

        signed int *return_value___errno_location$15;
        return_value___errno_location$15=__errno_location();
        if(*return_value___errno_location$15 == 104)
        {
          if(Debug >= 4)
            message(7, "%d TCP %d: read but reset by peer", pair->stone->sd, sd);

          return -1;
        }

        signed int return_value_priority$16;
        return_value_priority$16=priority(pair);
        signed int *return_value___errno_location$17;
        return_value___errno_location$17=__errno_location();
        message(return_value_priority$16, "%d TCP %d: read error err=%d, closing", pair->stone->sd, sd, *return_value___errno_location$17);
        message_pair(3, pair);
        return len;
      }

    }
    if(len >= 1)
    {
      pair->rx = pair->rx + len;
      ex->len = (start + len) - ex->start;
      if(Debug >= 5)
      {
        signed int psd = p->sd;
        if(!(ex->start >= start))
          message(7, "%d TCP %d: read %d+%d bytes to %d", pair->stone->sd, sd, len, start - ex->start, psd);

        else
          message(7, "%d TCP %d: read %d bytes to %d", pair->stone->sd, sd, ex->len, psd);
      }

      time(&pair->clock);
      p->clock = pair->clock;
      if(!(((proto_base_d | proto_base_s) & p->proto) == 0))
        ex->len=baseEncode((unsigned char *)&ex->buf[(signed long int)ex->start], ex->len, ex->bufmax - ex->start);

      else
        if(!(((proto_base_d | proto_base_s) & pair->proto) == 0))
        {
          ex->len=baseDecode((unsigned char *)&ex->buf[(signed long int)ex->start], ex->len, (ex->buf + (signed long int)ex->bufmax) - (signed long int)1);
          len = (signed int)*((ex->buf + (signed long int)ex->bufmax) - (signed long int)1);
          if(Debug >= 5 && len >= 1)
          {
            char str[128l];
            i = 0;
            for( ; !(i >= len); i = i + 1)
              sprintf(&str[(signed long int)(i * 3)], " %02x", ex->buf[(signed long int)((ex->bufmax - 2) - i)]);
            str[(signed long int)0] = (char)40;
            message(7, "%d TCP %d: save %d bytes \"%s\")", pair->stone->sd, sd, len, (const void *)str);
          }

        }

      if(!((p->proto & proto_command) == 0x0400))
        lastReadWrite = pair->clock;

    }

    if(!(p->t->len >= 1))
    {
      message_time_log(pair);
      if(Debug >= 3)
        message(7, "%d TCP %d: EOF", pair->stone->sd, sd);

      return -2;
    }

    else
      return p->t->len;
  }
}

// doshutdown
// file stone.c line 3517
signed int doshutdown(struct _Pair *pair, signed int how)
{
  struct ssl_st *ssl;
  signed int return_value_doSSL_shutdown$1;
  if(pair == ((struct _Pair *)NULL))
    return -1;

  else
  {
    ssl = pair->ssl;
    if(!(ssl == ((struct ssl_st *)NULL)))
    {
      return_value_doSSL_shutdown$1=doSSL_shutdown(pair, how);
      return return_value_doSSL_shutdown$1;
    }

    else
    {
      if(Debug >= 5)
        message(7, "%d TCP %d: shutdown how=%d", pair->stone->sd, pair->sd, how);

      signed int return_value_shutdown$2;
      return_value_shutdown$2=shutdown(pair->sd, how);
      return return_value_shutdown$2;
    }
  }
}

// dowrite
// file stone.c line 4799
signed int dowrite(struct _Pair *pair)
{
  signed int sd = pair->sd;
  struct _Pair *p;
  signed int len;
  struct _ExBuf *ex = pair->t;
  _Bool tmp_if_expr$14;
  if(ex == ((struct _ExBuf *)NULL))
    return 0;

  else
  {
    while(!(ex->len >= 1))
    {
      if(ex->next == ((struct _ExBuf *)NULL))
        break;

      pair->t = ex->next;
      ex->next = (struct _ExBuf *)(void *)0;
      pair->nbuf = pair->nbuf - 1;
      if(Debug >= 5)
        message(7, "%d TCP %d: before dowrite unget ExBuf nbuf=%d nfex=%d", pair->stone->sd, pair->sd, pair->nbuf, nFreeExBuf);

      ungetExBuf(ex);
    }
    if(!(ex->len >= 1))
      return 0;

    else
    {
      if(Debug >= 6)
        message(7, "%d TCP %d: write %d bytes", pair->stone->sd, sd, ex->len);

      if(!(sd >= 0))
        return -1;

      else
      {
        if(!(pair->ssl == ((struct ssl_st *)NULL)))
        {
          len=SSL_write(pair->ssl, (const void *)&ex->buf[(signed long int)ex->start], ex->len);
          if(!((pair->proto & proto_close) == 0))
            return -1;

          if(!(len >= 1))
          {
            signed int err;
            err=SSL_get_error(pair->ssl, len);
            if(err == 0 || err == 3)
            {
              if(Debug >= 5)
                message(7, "%d TCP %d: SSL_write interrupted err=%d", pair->stone->sd, sd, err);

              return 0;
            }

            else
              if(err == 2)
              {
                if(Debug >= 5)
                  message(7, "%d TCP %d: SSL_write blocked on read err=%d", pair->stone->sd, sd, err);

                pair->ssl_flag = pair->ssl_flag | sf_wb_on_r;
                return 0;
              }

            if(err == 5)
            {
              unsigned long int e;
              e=ERR_get_error();
              if(e == 0ul)
              {
                signed int *return_value___errno_location$1;
                return_value___errno_location$1=__errno_location();
                if(*return_value___errno_location$1 == 4)
                {
                  if(Debug >= 5)
                    message(7, "%d TCP %d: SSL_write I/O interrupted", pair->stone->sd, sd);

                  return 0;
                }

                signed int return_value_priority$2;
                return_value_priority$2=priority(pair);
                signed int *return_value___errno_location$3;
                return_value___errno_location$3=__errno_location();
                message(return_value_priority$2, "%d TCP %d: SSL_write I/O error err=%d, closing", pair->stone->sd, sd, *return_value___errno_location$3);
                message_pair(3, pair);
              }

              else
              {
                signed int return_value_priority$4;
                return_value_priority$4=priority(pair);
                char *return_value_ERR_error_string$5;
                return_value_ERR_error_string$5=ERR_error_string(e, (char *)(void *)0);
                message(return_value_priority$4, "%d TCP %d: SSL_write I/O %s, closing", pair->stone->sd, sd, return_value_ERR_error_string$5);
                message_pair(3, pair);
              }
              return -1;
            }

            else
              if(!(err == 6))
              {
                signed int return_value_priority$6;
                return_value_priority$6=priority(pair);
                unsigned long int return_value_ERR_get_error$7;
                return_value_ERR_get_error$7=ERR_get_error();
                char *return_value_ERR_error_string$8;
                return_value_ERR_error_string$8=ERR_error_string(return_value_ERR_get_error$7, (char *)(void *)0);
                message(return_value_priority$6, "%d TCP %d: SSL_write err=%d %s, closing", pair->stone->sd, sd, err, return_value_ERR_error_string$8);
                message_pair(3, pair);
                return len;
              }

          }

        }

        else
        {
          signed long int return_value_send$9;
          return_value_send$9=send(sd, (const void *)&ex->buf[(signed long int)ex->start], (unsigned long int)ex->len, 0);
          len = (signed int)return_value_send$9;
          if(!((pair->proto & proto_close) == 0))
            return -1;

          if(!(len >= 0))
          {
            signed int *return_value___errno_location$10;
            return_value___errno_location$10=__errno_location();
            if(*return_value___errno_location$10 == 4)
            {
              if(Debug >= 5)
                message(7, "%d TCP %d: write interrupted", pair->stone->sd, sd);

              return 0;
            }

            signed int *return_value___errno_location$11;
            return_value___errno_location$11=__errno_location();
            if(*return_value___errno_location$11 == 103)
            {
              if(Debug >= 4)
                message(7, "%d TCP %d: write aborted", pair->stone->sd, sd);

              return -1;
            }

            signed int return_value_priority$12;
            return_value_priority$12=priority(pair);
            signed int *return_value___errno_location$13;
            return_value___errno_location$13=__errno_location();
            message(return_value_priority$12, "%d TCP %d: write error err=%d, closing", pair->stone->sd, sd, *return_value___errno_location$13);
            message_pair(3, pair);
            return len;
          }

        }
        if(Debug >= 5)
          message(7, "%d TCP %d: %d bytes written", pair->stone->sd, sd, len);

        if((0xF & (signed int)pair->xhost->mode) >= 1)
          tmp_if_expr$14 = (_Bool)1;

        else
          tmp_if_expr$14 = ((pair->proto & proto_first_w) != 0 ? (Debug > 3 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$14)
          message_buf(pair, len, "");

        time(&pair->clock);
        p = pair->pair;
        if(!(p == ((struct _Pair *)NULL)))
          p->clock = pair->clock;

        if(len >= ex->len)
          ex->start = 0;

        else
        {
          ex->start = ex->start + len;
          message(5, "%d TCP %d: write %d bytes, but only %d bytes written", pair->stone->sd, sd, ex->len, len);
          message_pair(5, pair);
        }
        ex->len = ex->len - len;
        if(!(ex->len >= 1))
        {
          if(!(ex->next == ((struct _ExBuf *)NULL)))
          {
            pair->t = ex->next;
            ex->next = (struct _ExBuf *)(void *)0;
            pair->nbuf = pair->nbuf - 1;
            if(Debug >= 5)
              message(7, "%d TCP %d: after dowrite unget ExBuf nbuf=%d nfex=%d", pair->stone->sd, pair->sd, pair->nbuf, nFreeExBuf);

            ungetExBuf(ex);
          }

        }

        pair->tx = pair->tx + len;
        if(!((p->proto & proto_command) == 0x0400))
          lastReadWrite = pair->clock;

        return len;
      }
    }
  }
}

// exPatFile
// file stone.c line 7516
char * exPatFile(char *pat, char *name, char *src, char *dst)
{
  char str[128l];
  char *p;
  signed int pos;
  signed int len;
  signed int nlen;
  signed int slen;
  signed int dlen;
  signed int l;
  if(name == ((char *)NULL))
    name = "";

  if(src == ((char *)NULL))
    src = "";

  if(dst == ((char *)NULL))
    dst = "";

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(name);
  nlen = (signed int)return_value_strlen$1;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(src);
  slen = (signed int)return_value_strlen$2;
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(dst);
  dlen = (signed int)return_value_strlen$3;
  len = 0;
  pos = 0;
  signed int tmp_post$4;
  for( ; !(pos >= 127); pos = pos + 1)
    if((signed int)pat[(signed long int)pos] == 0)
    {
      str[(signed long int)len] = (char)0;
      break;
    }

    else
      if((signed int)pat[(signed long int)pos] == 37)
      {
        pos = pos + 1;
        switch((signed int)pat[(signed long int)pos])
        {
          case 110:
          {
            l = nlen;
            p = name;
            break;
          }
          case 115:
          {
            l = slen;
            p = src;
            break;
          }
          case 116:
          {
            l = dlen;
            p = dst;
            break;
          }
          default:
          {
            l = 1;
            p = &pat[(signed long int)pos];
          }
        }
        if(l + len >= 127)
          l = 127 - len;

        __builtin_strncpy(str + (signed long int)len, p, (unsigned long int)l);
        len = len + l;
      }

      else
      {
        tmp_post$4 = len;
        len = len + 1;
        str[(signed long int)tmp_post$4] = pat[(signed long int)pos];
      }
  str[(signed long int)127] = (char)0;
  char *return_value___strdup$5;
  return_value___strdup$5=__strdup(str);
  return return_value___strdup$5;
}

// exPatOpts
// file stone.c line 7552
void exPatOpts(struct anonymous$8 *opts, char *src, char *dst)
{
  if(!(opts->pfxFilePat == ((char *)NULL)))
  {
    opts->pfxFile=exPatFile(opts->pfxFilePat, opts->servername, src, dst);
    if(Debug >= 4)
      message(7, "exPatPfx: %s => %s", opts->pfxFilePat, opts->pfxFile);

  }

  else
  {
    if(!(opts->certFilePat == ((char *)NULL)))
    {
      opts->certFile=exPatFile(opts->certFilePat, opts->servername, src, dst);
      if(Debug >= 4)
        message(7, "exPatCert: %s => %s", opts->certFilePat, opts->certFile);

    }

    if(!(opts->keyFilePat == ((char *)NULL)))
    {
      opts->keyFile=exPatFile(opts->keyFilePat, opts->servername, src, dst);
      if(Debug >= 4)
        message(7, "exPatKey: %s => %s", opts->keyFilePat, opts->keyFile);

    }

  }
  if(!(opts->passFilePat == ((char *)NULL)))
  {
    opts->passFile=exPatFile(opts->passFilePat, opts->servername, src, dst);
    if(Debug >= 4)
      message(7, "exPatPass: %s => %s", opts->passFilePat, opts->passFile);

  }

  if(!(opts->passFile == ((char *)NULL)))
  {
    struct _IO_FILE *fp;
    fp=fopen(opts->passFile, "r");
    char str[128l];
    signed int i;
    if(fp == ((struct _IO_FILE *)NULL))
    {
      message(3, "Can't open passwd file: %s", opts->passFile);
      exit(1);
    }

    i = 0;
    for( ; !(i >= 127); i = i + 1)
    {
      signed int c;
      c=_IO_getc(fp);
      if(c == 10 || c == 13 || c == -1)
        break;

      str[(signed long int)i] = (char)c;
    }
    str[(signed long int)i] = (char)0;
    fclose(fp);
    char *return_value___strdup$1;
    return_value___strdup$1=__strdup(str);
    opts->passwd = return_value___strdup$1;
  }

}

// ext2str
// file stone.c line 1102
char * ext2str(signed int ext, char *str, signed int len)
{
  char sep = (char)47;
  signed int i = 0;
  signed int tmp_post$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  signed int tmp_post$6;
  signed int tmp_post$7;
  signed int tmp_post$8;
  signed int tmp_post$9;
  signed int tmp_post$10;
  signed int tmp_post$11;
  if(str == ((char *)NULL) || !(len >= 2))
    return "";

  else
  {
    if(!(((proto_udp_d | proto_udp_s) & ext) == 0))
    {
      if(!(i >= len))
      {
        tmp_post$1 = i;
        i = i + 1;
        str[(signed long int)tmp_post$1] = sep;
      }

      sep = (char)44;
      __builtin_strncpy(str + (signed long int)i, "udp", (unsigned long int)(len - i));
      i = i + 3;
    }

    if(!(((proto_ohttp_d | proto_ohttp_s) & ext) == 0))
    {
      if(!(i >= len))
      {
        tmp_post$2 = i;
        i = i + 1;
        str[(signed long int)tmp_post$2] = sep;
      }

      sep = (char)44;
      __builtin_strncpy(str + (signed long int)i, "http", (unsigned long int)(len - i));
      i = i + 4;
    }

    if(!(((proto_ssl_d | proto_ssl_s) & ext) == 0))
    {
      if(!(i >= len))
      {
        tmp_post$3 = i;
        i = i + 1;
        str[(signed long int)tmp_post$3] = sep;
      }

      sep = (char)44;
      __builtin_strncpy(str + (signed long int)i, "ssl", (unsigned long int)(len - i));
      i = i + 3;
    }

    if(!(((proto_v6_d | proto_v6_s) & ext) == 0))
    {
      if(!(i >= len))
      {
        tmp_post$4 = i;
        i = i + 1;
        str[(signed long int)tmp_post$4] = sep;
      }

      sep = (char)44;
      if(!(((proto_ip_only_d | proto_ip_only_s) & ext) == 0))
      {
        __builtin_strncpy(str + (signed long int)i, "v6only", (unsigned long int)(len - i));
        i = i + 6;
      }

      else
      {
        __builtin_strncpy(str + (signed long int)i, "v6", (unsigned long int)(len - i));
        i = i + 2;
      }
    }

    else
      if(!(((proto_ip_only_d | proto_ip_only_s) & ext) == 0))
      {
        sep = (char)44;
        __builtin_strncpy(str + (signed long int)i, "v4only", (unsigned long int)(len - i));
        i = i + 6;
      }

    if(!(((proto_base_d | proto_base_s) & ext) == 0))
    {
      if(!(i >= len))
      {
        tmp_post$5 = i;
        i = i + 1;
        str[(signed long int)tmp_post$5] = sep;
      }

      sep = (char)44;
      __builtin_strncpy(str + (signed long int)i, "base", (unsigned long int)(len - i));
      i = i + 4;
    }

    if(!(((proto_block_d | proto_block_s) & ext) == 0))
    {
      if(!(i >= len))
      {
        tmp_post$6 = i;
        i = i + 1;
        str[(signed long int)tmp_post$6] = sep;
      }

      sep = (char)44;
      __builtin_strncpy(str + (signed long int)i, "block", (unsigned long int)(len - i));
      i = i + 5;
    }

    if(!((ext & proto_ident) == 0))
    {
      if(!(i >= len))
      {
        tmp_post$7 = i;
        i = i + 1;
        str[(signed long int)tmp_post$7] = sep;
      }

      sep = (char)44;
      __builtin_strncpy(str + (signed long int)i, "ident", (unsigned long int)(len - i));
      i = i + 5;
    }

    if(!((ext & proto_nobackup) == 0))
    {
      if(!(i >= len))
      {
        tmp_post$8 = i;
        i = i + 1;
        str[(signed long int)tmp_post$8] = sep;
      }

      sep = (char)44;
      __builtin_strncpy(str + (signed long int)i, "nobackup", (unsigned long int)(len - i));
      i = i + 8;
    }

    switch(ext & proto_command)
    {
      case 0x0100:
      {
        if(!(i >= len))
        {
          tmp_post$9 = i;
          i = i + 1;
          str[(signed long int)tmp_post$9] = sep;
        }

        sep = (char)44;
        __builtin_strncpy(str + (signed long int)i, "proxy", (unsigned long int)(len - i));
        i = i + 5;
        break;
      }
      case 0x0200:
      {
        if(!(i >= len))
        {
          tmp_post$10 = i;
          i = i + 1;
          str[(signed long int)tmp_post$10] = sep;
        }

        sep = (char)44;
        __builtin_strncpy(str + (signed long int)i, "mproxy", (unsigned long int)(len - i));
        i = i + 6;
        break;
      }
      case 0x0300:
      {
        if(!(i >= len))
        {
          tmp_post$11 = i;
          i = i + 1;
          str[(signed long int)tmp_post$11] = sep;
        }

        sep = (char)44;
        __builtin_strncpy(str + (signed long int)i, "apop", (unsigned long int)(len - i));
        i = i + 4;
      }
    }
    return str;
  }
}

// findBackup
// file stone.c line 1998
struct _Backup * findBackup(struct sockaddr *sa)
{
  struct _Backup *b = backups;
  for( ; !(b == ((struct _Backup *)NULL)); b = b->next)
  {
    signed int return_value_saComp$1;
    return_value_saComp$1=saComp(sa, &b->master->addr);
    if(!(return_value_saComp$1 == 0))
    {
      if(Debug >= 2)
      {
        char mhostport[128l];
        char bhostport[128l];
        addrport2str(&b->master->addr, b->master->len, b->proto & (proto_ohttp_d | proto_base_d | proto_command), mhostport, 127, 0);
        mhostport[(signed long int)127] = (char)0;
        addrport2str(&b->backup->addr, b->backup->len, b->proto & (proto_ohttp_d | proto_base_d | proto_command), bhostport, 127, 0);
        bhostport[(signed long int)127] = (char)0;
        message(7, "master %s backup %s interval %d", (const void *)mhostport, (const void *)bhostport, b->interval);
      }

      return b;
    }

  }
  return (struct _Backup *)(void *)0;
}

// findLBSet
// file stone.c line 2246
struct _LBSet * findLBSet(struct sockaddr *sa)
{
  struct _LBSet *s = lbsets;
  signed int tmp_post$2;
  for( ; !(s == ((struct _LBSet *)NULL)); s = s->next)
  {
    signed int return_value_saComp$4;
    return_value_saComp$4=saComp(&s->dsts[(signed long int)0]->addr, sa);
    if(!(return_value_saComp$4 == 0))
    {
      if(Debug >= 2)
      {
        char buf[1025l];
        signed int len;
        signed int i;
        buf[(signed long int)1024] = (char)0;
        strcpy(buf, "LB set:");
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(buf);
        len = (signed int)return_value_strlen$1;
        i = 0;
        for( ; !(i >= (signed int)s->ndsts) && !(len >= 1024); i = i + 1)
        {
          tmp_post$2 = len;
          len = len + 1;
          buf[(signed long int)tmp_post$2] = (char)32;
          addrport2str(&s->dsts[(signed long int)i]->addr, s->dsts[(signed long int)i]->len, s->proto & (proto_ohttp_d | proto_base_d | proto_command), buf + (signed long int)len, (1024 - 1) - len, 0);
          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(buf + (signed long int)len);
          len = len + (signed int)return_value_strlen$3;
        }
        message(7, "%s", (const void *)buf);
      }

      return s;
    }

  }
  return (struct _LBSet *)(void *)0;
}

// first_read
// file stone.c line 6040
signed int first_read(struct _Pair *pair)
{
  signed int sd = pair->sd;
  signed int psd;
  struct _Pair *p = pair->pair;
  struct _ExBuf *ex;
  struct _Stone *stone = pair->stone;
  signed int len;
  _Bool tmp_if_expr$1;
  if(p == ((struct _Pair *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (p->proto & (proto_shutdown | proto_close)) != 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_memCheck$2;
  signed int return_value_doshutdown$3;
  signed int return_value_doshutdown$4;
  if(!(sd >= 0) || tmp_if_expr$1)
    return -1;

  else
  {
    ex = p->b;
    psd = p->sd;
    len = ex->len;
    pair->proto = pair->proto & ~proto_first_r;
    if(!((p->proto & proto_command) == 0))
    {
      switch(p->proto & proto_command)
      {
        case 0x0600:
        {
          len=docomm(p, proxyComm);
          break;
        }
        case 0x0400:
        {
          return_value_memCheck$2=memCheck();
          if(return_value_memCheck$2 == 0)
            len = -1;

          else
            len=docomm(p, healthComm);
          break;
        }
        case 0x0500:
        {
          len=docomm(p, identdComm);
          break;
        }
        default:
          ;
      }
      if(len == -2)
      {
        if(Debug >= 4)
          message(7, "%d TCP %d: read more from %d", stone->sd, psd, sd);

      }

      else
        if(!(len >= 0))
        {
          signed int flag = 0;
          if((pair->proto & proto_shutdown) == 0)
          {
            return_value_doshutdown$3=doshutdown(pair, 2);
            if(return_value_doshutdown$3 >= 0)
              flag = proto_shutdown;

          }

          setclose(pair, flag);
          if(psd >= 0)
          {
            flag = 0;
            if((p->proto & proto_shutdown) == 0)
            {
              return_value_doshutdown$4=doshutdown(p, 2);
              if(return_value_doshutdown$4 >= 0)
                flag = proto_shutdown;

            }

            setclose(p, flag);
          }

          return -1;
        }

        else
          len = ex->len;
    }

    if(!(((proto_ohttp_d | proto_ohttp_s) & pair->proto) == 0))
    {
      len=rmheader(p);
      if(len >= 0)
      {
        if(!((pair->proto & proto_ohttp_s) == 0))
        {
          commOutput(p, "HTTP/1.0 200 OK\r\n\r\n");
          pair->proto = pair->proto & ~proto_ohttp_s;
        }

        else
          if(!((pair->proto & proto_ohttp_d) == 0))
          {
            if(Debug >= 4)
              message(7, "%d TCP %d: request to read, because response header from %d finished", stone->sd, psd, sd);

            p->proto = p->proto | proto_select_r | proto_dirty;
          }

      }

    }

    if(!(len >= 1))
    {
      if(((proto_close | proto_eof) & pair->proto) == 0)
      {
        if(Debug >= 9)
          message(7, "%d TCP %d: read more", stone->sd, sd);

        pair->proto = pair->proto | proto_select_r | proto_dirty;
        if(!(len >= 0))
          pair->proto = pair->proto | proto_first_r | proto_dirty;

      }

    }

    return len;
  }
}

// freeConn
// file stone.c line 3892
void freeConn(struct _Conn *conn)
{
  if(!(conn->dst == ((struct anonymous$0 *)NULL)))
    free((void *)conn->dst);

  free((void *)conn);
}

// freeMatch
// file stone.c line 7076
static void freeMatch(void *parent, void *ptr, struct crypto_ex_data_st *ad, signed int idx, signed long int argl, void *argp)
{
  char **match = (char **)ptr;
  signed int i = 0;
  for( ; !(i >= 10); i = i + 1)
    if(!(match[(signed long int)i] == ((char *)NULL)))
      free((void *)match[(signed long int)i]);

  if(Debug >= 5)
  {
    NewMatchCount = NewMatchCount - 1;
    message(7, "freeMatch %d: %x", NewMatchCount, (signed int)match);
  }

  free((void *)match);
}

// freeMutex
// file stone.c line 1743
void freeMutex(signed int h)
{
  signed int err;
  err=pthread_mutex_lock(&FastMutex);
  if(!(err == 0))
    message(3, "Mutex %d err=%d", h, err);

  if((signed int)FastMutexs[(signed long int)h] >= 1)
  {
    if((signed int)FastMutexs[(signed long int)h] >= 2)
      message(3, "Mutex %d Locked Recursively (%d)", h, FastMutexs[(signed long int)h]);

    FastMutexs[(signed long int)h] = FastMutexs[(signed long int)h] - 1;
    if(Debug >= 21)
      message(7, "Unlock Mutex %d = %d", h, FastMutexs[(signed long int)h]);

  }

  pthread_mutex_unlock(&FastMutex);
}

// freeOrigin
// file stone.c line 2622
void freeOrigin(struct _Origin *origin)
{
  if(!(origin->from == ((struct anonymous$0 *)NULL)))
    free((void *)origin->from);

  free((void *)origin);
}

// freePair
// file stone.c line 3578
void freePair(struct _Pair *pair)
{
  signed int sd;
  struct _TimeLog *log;
  struct ssl_st *ssl;
  struct _ExBuf *ex;
  if(!(pair == ((struct _Pair *)NULL)))
  {
    sd = pair->sd;
    pair->sd = -1;
    if(Debug >= 9)
      message(7, "%d TCP %d: freePair", pair->stone->sd, sd);

    ex = pair->d;
    pair->d = (struct _ExBuf *)(void *)0;
    while(!(ex == ((struct _ExBuf *)NULL)))
    {
      struct _ExBuf *f = ex;
      ex = f->next;
      f->next = (struct _ExBuf *)(void *)0;
      ungetExBuf(f);
    }
    log = pair->log;
    if(!(log == ((struct _TimeLog *)NULL)))
    {
      pair->log = (struct _TimeLog *)(void *)0;
      free((void *)log);
    }

    ssl = pair->ssl;
    if(!(ssl == ((struct ssl_st *)NULL)))
    {
      struct ssl_ctx_st *ctx = (struct ssl_ctx_st *)(void *)0;
      signed int state;
      pair->ssl = (struct ssl_st *)(void *)0;
      state=SSL_get_shutdown(ssl);
      if((2 & state) == 0 && Debug >= 3)
        message(7, "%d TCP %d: SSL close notify was not received", pair->stone->sd, sd);

      if((1 & state) == 0 && Debug >= 3)
      {
        message(7, "%d TCP %d: SSL close notify was not sent", pair->stone->sd, sd);
        SSL_set_shutdown(ssl, state | 1);
      }

      SSL_free(ssl);
      if(!((pair->stone->proto & proto_ssl_s) == 0))
        ctx = pair->stone->ssl_server->ctx;

      if(!(ctx == ((struct ssl_ctx_st *)NULL)))
        SSL_CTX_flush_sessions(ctx, pair->clock);

    }

    pair->b = (struct _ExBuf *)(void *)0;
    ex = pair->t;
    pair->t = (struct _ExBuf *)(void *)0;
    while(!(ex == ((struct _ExBuf *)NULL)))
    {
      struct _ExBuf *freePair$$1$$4$$f = ex;
      ex = freePair$$1$$4$$f->next;
      freePair$$1$$4$$f->next = (struct _ExBuf *)(void *)0;
      pair->nbuf = pair->nbuf - 1;
      if(Debug >= 5)
        message(7, "%d TCP %d: freePair unget ExBuf nbuf=%d nfex=%d", pair->stone->sd, sd, pair->nbuf, nFreeExBuf);

      ungetExBuf(freePair$$1$$4$$f);
    }
    if(sd >= 0)
    {
      if(Debug >= 7)
        message(7, "%d TCP %d: freePair epoll_ctl %d DEL %x", pair->stone->sd, sd, ePollFd, (signed int)pair);

      epoll_ctl(ePollFd, 2, sd, (struct epoll_event *)(void *)0);
      close(sd);
    }

    waitMutex(8);
    if(pair->clock == 0l)
    {
      freeMutex(8);
      message(3, "freePair duplication. can't happen, ignore");
    }

    else
    {
      pair->clock = (signed long int)0;
      pair->next = freePairs;
      freePairs = pair;
      nFreePairs = nFreePairs + 1;
      freeMutex(8);
    }
  }

}

// gcd
// file stone.c line 2020
signed int gcd(signed int a, signed int b)
{
  signed int m;
  if(!(b >= a))
  {
    m = a % b;
    if(m == 0)
      return b;

    signed int return_value_gcd$1;
    return_value_gcd$1=gcd(m, b);
    return return_value_gcd$1;
  }

  else
  {
    m = b % a;
    if(m == 0)
      return a;

    signed int return_value_gcd$2;
    return_value_gcd$2=gcd(m, a);
    return return_value_gcd$2;
  }
}

// getExBuf
// file stone.c line 2377
struct _ExBuf * getExBuf(void)
{
  struct _ExBuf *ret = (struct _ExBuf *)(void *)0;
  signed long int now;
  time(&now);
  waitMutex(7);
  if(!(freeExBuf == ((struct _ExBuf *)NULL)))
  {
    ret = freeExBuf;
    freeExBuf = ret->next;
    nFreeExBuf = nFreeExBuf - 1;
    if(!(nFreeExBuf >= nFreeExBot))
    {
      nFreeExBot = nFreeExBuf;
      freeExBot = freeExBuf;
      freeExBotClock = now;
    }

  }

  freeMutex(7);
  _Bool tmp_if_expr$1;
  if(ret == ((struct _ExBuf *)NULL))
  {
    signed int size = XferBufMax;
    do
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc((sizeof(struct _ExBuf) /*2072ul*/  + (unsigned long int)size) - (unsigned long int)2048);
      ret = (struct _ExBuf *)return_value_malloc$2;
      if(ret == ((struct _ExBuf *)NULL) && XferBufMax >= 2049)
      {
        XferBufMax = XferBufMax / 2;
        tmp_if_expr$1 = XferBufMax != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$1 = (_Bool)0;
    }
    while(tmp_if_expr$1);
    if(ret == ((struct _ExBuf *)NULL))
    {
      message(2, "Out of memory, no ExBuf");
      return ret;
    }

    ret->bufmax = size;
  }

  ret->next = (struct _ExBuf *)(void *)0;
  ret->start = 0;
  ret->len = 0;
  return ret;
}

// getExData
// file stone.c line 2410
struct _ExBuf * getExData(struct _Pair *pair, signed int type, signed int rmflag)
{
  struct _ExBuf *ex = pair->d;
  struct _ExBuf *prev = (struct _ExBuf *)(void *)0;
  while(!(ex == ((struct _ExBuf *)NULL)))
  {
    signed int t = *((signed int *)ex->buf);
    if(t == type)
    {
      if(!(rmflag == 0))
      {
        if(!(prev == ((struct _ExBuf *)NULL)))
          prev->next = ex->next;

        else
          pair->d = ex->next;
      }

      return ex;
    }

    prev = ex;
    ex = ex->next;
  }
  return (struct _ExBuf *)(void *)0;
}

// getOrigins
// file stone.c line 2627
struct _Origin * getOrigins(struct sockaddr *from, unsigned int fromlen, struct _Stone *stone)
{
  struct _Origin *origin;
  struct _Origin *origins = (struct _Origin *)stone->p;
  signed int sd;
  struct epoll_event ev;
  origin = origins->next;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(origin == ((struct _Origin *)NULL)))
      tmp_if_expr$1 = origin->from != ((struct anonymous$0 *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    if(origin->sd >= 0)
    {
      signed int return_value_saComp$2;
      return_value_saComp$2=saComp(&origin->from->addr, from);
      if(!(return_value_saComp$2 == 0))
      {
        origin->lock = 1;
        return origin;
      }

    }

    origin = origin->next;
  }
  while((_Bool)1);
  sd=socket((signed int)from->sa_family, 2, 17);
  if(!(sd >= 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    message(3, "%d UDP: can't create datagram socket err=%d", stone->sd, *return_value___errno_location$3);
    return (struct _Origin *)(void *)0;
  }

  if(Debug >= 4)
  {
    char addrport[128l];
    char *return_value_addrport2str$4;
    return_value_addrport2str$4=addrport2str(from, fromlen, proto_udp_s | proto_udp_d, addrport, 127, 0);
    message(7, "%d UDP %d: New origin %s", stone->sd, sd, return_value_addrport2str$4);
  }

  if((stone->proto & proto_block_d) == 0)
    fcntl(sd, 4, 04000);

  void *return_value_malloc$5;
  return_value_malloc$5=malloc(sizeof(struct _Origin) /*56ul*/ );
  origin = (struct _Origin *)return_value_malloc$5;
  if(origin == ((struct _Origin *)NULL))
  {

  memerr:
    ;
    message(2, "%d UDP %d: Out of memory, closing socket", stone->sd, sd);
    return (struct _Origin *)(void *)0;
  }

  else
  {
    origin->common = 0x0002;
    origin->sd = sd;
    origin->stone = stone;
    origin->from=saDup(from, fromlen);
    if(origin->from == ((struct anonymous$0 *)NULL))
    {
      free((void *)origin);
      goto memerr;
    }

    origin->lock = 0;
    origin->xhost = (struct _XHosts *)(void *)0;
    ev.events = (unsigned int)1;
    ev.data.ptr = (void *)origin;
    signed int return_value_epoll_ctl$7;
    return_value_epoll_ctl$7=epoll_ctl(ePollFd, 1, sd, &ev);
    if(!(return_value_epoll_ctl$7 >= 0))
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      message(3, "%d UDP %d: epoll_ctl ADD err=%d", stone->sd, sd, *return_value___errno_location$6);
      freeOrigin(origin);
      return (struct _Origin *)(void *)0;
    }

    waitMutex(2);
    origin->next = origins->next;
    origins->next = origin;
    freeMutex(2);
    return origin;
  }
}

// getPairUDP
// file stone.c line 6797
struct _Pair * getPairUDP(struct sockaddr *from, unsigned int fromlen, struct _Stone *stone)
{
  struct _Pair *pair;
  struct _ExBuf *getPairUDP$$1$$t;
  struct anonymous$0 *peer;
  pair = stone->pairs->next;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(pair == ((struct _Pair *)NULL)))
      tmp_if_expr$1 = pair->clock != (signed long int)-1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    struct _Pair *p = pair->pair;
    if(!((pair->proto & proto_dgram) == 0))
    {
      if(!(p == ((struct _Pair *)NULL)))
      {
        if(!((p->proto & proto_connect) == 0))
        {
          struct _ExBuf *t;
          t=getExData(pair, data_peeraddr, 0);
          struct anonymous$0 *dst = (struct anonymous$0 *)(t->buf + (signed long int)sizeof(signed int) /*4ul*/ );
          signed int return_value_saComp$2;
          return_value_saComp$2=saComp(&dst->addr, from);
          if(!(return_value_saComp$2 == 0))
          {
            time(&pair->clock);
            return pair;
          }

        }

      }

    }

    pair = pair->next;
  }
  while((_Bool)1);
  pair=newPair();
  if(pair == ((struct _Pair *)NULL))
    return (struct _Pair *)(void *)0;

  else
  {
    bcopy((const void *)&fromlen, (void *)pair->t->buf, sizeof(signed int) /*4ul*/ );
    bcopy((const void *)from, (void *)(pair->t->buf + (signed long int)sizeof(signed int) /*4ul*/ ), (unsigned long int)fromlen);
    pair->stone = stone;
    pair->proto = proto_dgram | 0x0f00;
    pair->timeout = stone->timeout;
    getPairUDP$$1$$t=newExData(pair, data_peeraddr);
    peer = (struct anonymous$0 *)(getPairUDP$$1$$t->buf + (signed long int)sizeof(signed int) /*4ul*/ );
    peer->len = fromlen;
    bcopy((const void *)from, (void *)&peer->addr, (unsigned long int)fromlen);
    signed int return_value_doAcceptConnect$3;
    return_value_doAcceptConnect$3=doAcceptConnect(pair);
    if(!(return_value_doAcceptConnect$3 == 0))
      return pair;

    else
      return (struct _Pair *)(void *)0;
  }
}

// getPktBuf
// file stone.c line 2591
struct _PktBuf * getPktBuf(void)
{
  struct _PktBuf *ret = (struct _PktBuf *)(void *)0;
  waitMutex(9);
  if(!(freePktBuf == ((struct _PktBuf *)NULL)))
  {
    ret = freePktBuf;
    freePktBuf = ret->next;
    nFreePktBuf = nFreePktBuf - 1;
  }

  freeMutex(9);
  if(!(ret == ((struct _PktBuf *)NULL)))
  {
    if(!(ret->bufmax >= pkt_len_max))
    {
      free((void *)ret);
      ret = (struct _PktBuf *)(void *)0;
    }

  }

  _Bool tmp_if_expr$1;
  if(ret == ((struct _PktBuf *)NULL))
  {
    signed int size = pkt_len_max;
    do
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc((sizeof(struct _PktBuf) /*2088ul*/  + (unsigned long int)size) - (unsigned long int)2048);
      ret = (struct _PktBuf *)return_value_malloc$2;
      if(ret == ((struct _PktBuf *)NULL) && pkt_len_max >= 2049)
      {
        pkt_len_max = pkt_len_max / 2;
        tmp_if_expr$1 = pkt_len_max != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$1 = (_Bool)0;
    }
    while(tmp_if_expr$1);
    if(ret == ((struct _PktBuf *)NULL))
    {
      message(2, "Out of memory, no ExBuf");
      return ret;
    }

    ret->common = 0x0004;
    ret->bufmax = size;
  }

  ret->next = (struct _PktBuf *)(void *)0;
  ret->origin = (struct _Origin *)(void *)0;
  ret->len = 0;
  return ret;
}

// getStone
// file stone.c line 8040
struct _Stone * getStone(struct sockaddr *sa, unsigned int salen, signed int proto)
{
  struct _Stone *stone;
  proto = proto & proto_udp_s;
  stone = stones;
  signed int return_value_saComp$1;
  for( ; !(stone == ((struct _Stone *)NULL)); stone = stone->next)
    if((stone->proto & proto_udp_s) == proto)
    {
      return_value_saComp$1=saComp(&stone->listen->addr, sa);
      if(!(return_value_saComp$1 == 0))
        return stone;

    }

  return (struct _Stone *)(void *)0;
}

// getconfig
// file stone.c line 8695
void getconfig(void)
{
  struct _IO_FILE *fp;
  signed int nptr = 0;
  char **new;
  char buf[2048l];
  signed int len;
  if(!(ConfigFile == ((char *)NULL)))
  {
    ConfigArgc = 0;
    ConfigArgv = (char **)(void *)0;
    fp=openconfig();
    if(fp == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      message(3, "Can't open config file: %s err=%d", ConfigFile, *return_value___errno_location$1);
      exit(1);
    }

    strcpy(buf, ConfigFile);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(buf);
    len = (signed int)return_value_strlen$2;
    while((_Bool)1)
    {
      if(Debug >= 10)
        message(7, "token: \"%s\"", (const void *)buf);

      if(ConfigArgc >= nptr)
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc((unsigned long int)(nptr + 2048) * sizeof(char *) /*8ul*/ );
        new = (char **)return_value_malloc$3;
        if(new == ((char **)NULL))
        {
          message(2, "Out of memory");
          exit(1);
        }

        if(!(ConfigArgv == ((char **)NULL)))
        {
          bcopy((const void *)ConfigArgv, (void *)new, (unsigned long int)nptr * sizeof(char *) /*8ul*/ );
          free((void *)ConfigArgv);
        }

        ConfigArgv = new;
        nptr = nptr + 2048;
      }

      void *return_value_malloc$4;
      return_value_malloc$4=malloc((unsigned long int)(len + 1));
      ConfigArgv[(signed long int)ConfigArgc] = (char *)return_value_malloc$4;
      bcopy((const void *)buf, (void *)ConfigArgv[(signed long int)ConfigArgc], (unsigned long int)(len + 1));
      ConfigArgc = ConfigArgc + 1;
      len=gettoken(fp, buf);
      if(!(len >= 0))
        break;

    }
    fclose(fp);
    if(!(CppCommand == ((char *)NULL)))
    {
      if(!((signed int)*CppCommand == 0))
        wait((void *)0);

    }

  }

}

// getdist
// file stone.c line 8739
signed int getdist(char *p, signed int *protop)
{
  char *port_str;
  char *proto_str;
  char *top = p;
  proto_str = (char *)(void *)0;
  port_str = proto_str;
  *protop = 0;
  _Bool tmp_if_expr$2;
  if((signed int)*p == 46)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)p[(signed long int)0] == 47 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    struct stat st;
    p = p + 1l;
    while(!(*p == 0))
      if((signed int)*p == 47)
      {
        p = p + 1l;
        proto_str = p;
      }

      else
        p = p + 1l;
    if(!(proto_str == ((char *)NULL)))
    {
      *(proto_str - (signed long int)1) = (char)0;
      signed int return_value_stat$1;
      return_value_stat$1=stat(top, &st);
      if(return_value_stat$1 >= 0)
      {
        if((61440u & st.st_mode) == 16384u)
        {
          *(proto_str - (signed long int)1) = (char)47;
          proto_str = (char *)(void *)0;
        }

      }

    }

    *protop = *protop | proto_unix_s | proto_unix_d;
  }

  else
    while(!(*p == 0))
      if((signed int)*p == 58)
      {
        p = p + 1l;
        port_str = p;
      }

      else
        if((signed int)*p == 47)
        {
          p = p + 1l;
          proto_str = p;
        }

        else
          p = p + 1l;
  signed int return_value_strncmp$17;
  signed int return_value_strncmp$16;
  signed int return_value_strncmp$15;
  signed int return_value_strncmp$14;
  signed int return_value_strncmp$13;
  signed int return_value_strncmp$12;
  signed int return_value_strncmp$11;
  signed int return_value_strncmp$10;
  signed int return_value_strncmp$9;
  signed int return_value_strncmp$8;
  signed int return_value_strncmp$7;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  char *tmp_post$4;
  if(!(proto_str == ((char *)NULL)))
  {
    *(proto_str - (signed long int)1) = (char)0;
    p = proto_str;
    do
    {
      signed int return_value_strncmp$18;
      return_value_strncmp$18=strncmp(p, "tcp", (unsigned long int)3);
      if(return_value_strncmp$18 == 0)
      {
        p = p + (signed long int)3;
        *protop = *protop & ~(proto_udp_s | proto_udp_d);
      }

      else
      {
        return_value_strncmp$17=strncmp(p, "udp", (unsigned long int)3);
        if(return_value_strncmp$17 == 0)
        {
          p = p + (signed long int)3;
          *protop = *protop | proto_udp_s | proto_udp_d;
        }

        else
        {
          return_value_strncmp$16=strncmp(p, "http", (unsigned long int)4);
          if(return_value_strncmp$16 == 0)
          {
            p = p + (signed long int)4;
            *protop = *protop | proto_ohttp_s | proto_ohttp_d;
          }

          else
          {
            return_value_strncmp$15=strncmp(p, "base", (unsigned long int)4);
            if(return_value_strncmp$15 == 0)
            {
              p = p + (signed long int)4;
              *protop = *protop | proto_base_s | proto_base_d;
            }

            else
            {
              return_value_strncmp$14=strncmp(p, "ident", (unsigned long int)5);
              if(return_value_strncmp$14 == 0)
              {
                p = p + (signed long int)5;
                *protop = *protop | proto_ident;
              }

              else
              {
                return_value_strncmp$13=strncmp(p, "proxy", (unsigned long int)5);
                if(return_value_strncmp$13 == 0)
                {
                  p = p + (signed long int)5;
                  *protop = *protop & ~proto_command;
                  *protop = *protop | 0x0100;
                }

                else
                {
                  return_value_strncmp$12=strncmp(p, "mproxy", (unsigned long int)6);
                  if(return_value_strncmp$12 == 0)
                  {
                    p = p + (signed long int)6;
                    *protop = *protop & ~proto_command;
                    *protop = *protop | 0x0200;
                  }

                  else
                  {
                    return_value_strncmp$11=strncmp(p, "nobackup", (unsigned long int)8);
                    if(return_value_strncmp$11 == 0)
                    {
                      p = p + (signed long int)8;
                      *protop = *protop | proto_nobackup;
                    }

                    else
                    {
                      return_value_strncmp$10=strncmp(p, "ssl", (unsigned long int)3);
                      if(return_value_strncmp$10 == 0)
                      {
                        p = p + (signed long int)3;
                        *protop = *protop | proto_ssl_s | proto_ssl_d;
                      }

                      else
                      {
                        return_value_strncmp$9=strncmp(p, "v6", (unsigned long int)2);
                        if(return_value_strncmp$9 == 0)
                        {
                          p = p + (signed long int)2;
                          *protop = *protop | proto_v6_s | proto_v6_d;
                          signed int return_value_strncmp$6;
                          return_value_strncmp$6=strncmp(p, "only", (unsigned long int)4);
                          if(return_value_strncmp$6 == 0)
                          {
                            p = p + (signed long int)4;
                            *protop = *protop | proto_ip_only_s | proto_ip_only_d;
                          }

                        }

                        else
                        {
                          return_value_strncmp$8=strncmp(p, "v4only", (unsigned long int)6);
                          if(return_value_strncmp$8 == 0)
                          {
                            p = p + (signed long int)6;
                            *protop = *protop | proto_ip_only_s | proto_ip_only_d;
                          }

                          else
                          {
                            return_value_strncmp$7=strncmp(p, "block", (unsigned long int)5);
                            if(return_value_strncmp$7 == 0)
                            {
                              p = p + (signed long int)5;
                              *protop = *protop | proto_block_s | proto_block_d;
                            }

                            else
                              return -1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if((signed int)*p == 44)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)*p == 47 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        tmp_post$4 = p;
        p = p + 1l;
        tmp_if_expr$5 = tmp_post$4 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
    }
    while(tmp_if_expr$5);
  }

  signed int tmp_statement_expression$19;
  signed int tmp_statement_expression$21;
  signed int tmp_statement_expression$23;
  if(!(port_str == ((char *)NULL)))
  {
    *(port_str - (signed long int)1) = (char)0;
    return (signed int)(port_str - top);
  }

  else
  {
    if(!(((proto_unix_d | proto_unix_s) & *protop) == 0))
      return 1;

    unsigned long int getdist$$1$$5$$2$$__s1_len;
    unsigned long int getdist$$1$$5$$2$$__s2_len;
    signed int return_value___builtin_strcmp$20;
    return_value___builtin_strcmp$20=__builtin_strcmp(top, "proxy");
    tmp_statement_expression$19 = return_value___builtin_strcmp$20;
    if(tmp_statement_expression$19 == 0)
    {
      *protop = *protop & ~proto_command;
      *protop = *protop | 0x0600;
      return 1;
    }

    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$22;
    return_value___builtin_strcmp$22=__builtin_strcmp(top, "health");
    tmp_statement_expression$21 = return_value___builtin_strcmp$22;
    if(tmp_statement_expression$21 == 0)
    {
      *protop = *protop & ~proto_command;
      *protop = *protop | 0x0400;
      return 1;
    }

    unsigned long int getdist$$1$$5$$6$$__s1_len;
    unsigned long int getdist$$1$$5$$6$$__s2_len;
    signed int return_value___builtin_strcmp$24;
    return_value___builtin_strcmp$24=__builtin_strcmp(top, "identd");
    tmp_statement_expression$23 = return_value___builtin_strcmp$24;
    if(tmp_statement_expression$23 == 0)
    {
      *protop = *protop & ~proto_command;
      *protop = *protop | 0x0500;
      return 1;
    }

    return 0;
  }
}

// getident
// file stone.c line 4081
signed int getident(char *str, struct sockaddr *sa, unsigned int salen, signed int cport, struct sockaddr *csa, unsigned int csalen)
{
  signed int sd;
  struct sockaddr_storage ss;
  struct sockaddr *peer = (struct sockaddr *)&ss;
  unsigned int peerlen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  signed int sport;
  sport=getport(sa);
  char buf[1025l];
  char c;
  signed int len;
  signed int ret;
  char addr[128l];
  signed long int start;
  signed long int now;
  signed int epfd = -1;
  struct epoll_event ev;
  struct epoll_event evs[1l];
  time(&start);
  bcopy((const void *)sa, (void *)peer, (unsigned long int)salen);
  peerlen = salen;
  if(!(str == ((char *)NULL)))
    str[(signed long int)0] = (char)0;

  sd=socket((signed int)peer->sa_family, 1, 6);
  signed int *return_value___errno_location$1;
  if(!(sd >= 0))
  {
    if(Debug >= 1)
    {
      return_value___errno_location$1=__errno_location();
      message(7, "ident: can't create socket err=%d", *return_value___errno_location$1);
    }

    return 0;
  }

  saPort(csa, (unsigned short int)0);
  signed int return_value_bind$3;
  return_value_bind$3=bind(sd, csa, csalen);
  signed int *return_value___errno_location$2;
  if(!(return_value_bind$3 >= 0))
  {
    if(Debug >= 1)
    {
      return_value___errno_location$2=__errno_location();
      message(7, "ident: can't bind socket err=%d", *return_value___errno_location$2);
    }

  }

  saPort(peer, (unsigned short int)113);
  addr2str(peer, peerlen, addr, 127, 0);
  addr[(signed long int)127] = (char)0;
  fcntl(sd, 4, 04000);
  epfd=epoll_create(50);
  if(!(epfd >= 0))
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    message(3, "ident: can't create epoll err=%d", *return_value___errno_location$4);
    epfd = -1;
    goto noconnect;
  }

  ev.events = (unsigned int)(4 | 1073741824);
  signed int return_value_epoll_ctl$6;
  return_value_epoll_ctl$6=epoll_ctl(epfd, 1, sd, &ev);
  if(!(return_value_epoll_ctl$6 >= 0))
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    message(3, "ident: epoll_ctl ADD err=%d", *return_value___errno_location$5);
    goto noconnect;
  }

  ret=connect(sd, peer, peerlen);
  signed int return_value_epoll_wait$7;
  signed int *return_value___errno_location$8;
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location$9;
    return_value___errno_location$9=__errno_location();
    if(*return_value___errno_location$9 == 115)
      do
      {
        time(&now);
        if(now + -start >= 60l)
        {
          if(Debug >= 1)
            message(7, "ident: connect to %s, timeout", (const void *)addr);

          goto noconnect;
        }

        return_value_epoll_wait$7=epoll_wait(epfd, evs, 1, 1000);
      }
      while(return_value_epoll_wait$7 == 0);

    else
    {
      if(Debug >= 1)
      {
        return_value___errno_location$8=__errno_location();
        message(7, "ident: can't connect to %s, err=%d", (const void *)addr, *return_value___errno_location$8);
      }


    noconnect:
      ;
      if(epfd >= 0)
        close(epfd);

      close(sd);
      return 0;
    }
  }

  ev.events = (unsigned int)(1 | 1073741824);
  signed int return_value_epoll_ctl$11;
  return_value_epoll_ctl$11=epoll_ctl(epfd, 3, sd, &ev);
  if(!(return_value_epoll_ctl$11 >= 0))
  {
    signed int *return_value___errno_location$10;
    return_value___errno_location$10=__errno_location();
    message(3, "ident: epoll_ctl MOD err=%d", *return_value___errno_location$10);
    goto noconnect;
  }

  snprintf(buf, (unsigned long int)1024, "%d, %d%c%c", sport, cport, 13, 10);
  unsigned long int return_value_strlen$12;
  return_value_strlen$12=strlen(buf);
  len = (signed int)return_value_strlen$12;
  signed long int return_value_send$13;
  return_value_send$13=send(sd, (const void *)buf, (unsigned long int)len, 0);
  ret = (signed int)return_value_send$13;
  signed int *return_value___errno_location$14;
  signed int return_value_epoll_wait$15;
  if(!(ret == len))
  {
    if(Debug >= 1)
    {
      return_value___errno_location$14=__errno_location();
      message(7, "ident: can't send  to %s ret=%d err=%d buf=%s", (const void *)addr, ret, *return_value___errno_location$14, (const void *)buf);
    }


  error:
    ;
    shutdown(sd, 2);
    if(epfd >= 0)
      close(epfd);

    close(sd);
    return 0;
  }

  else
  {
    do
    {
      time(&now);
      if(now + -start >= 60l)
      {
        if(Debug >= 1)
          message(7, "ident: read from %s, timeout", (const void *)addr);

        goto error;
      }

      return_value_epoll_wait$15=epoll_wait(epfd, evs, 1, 1000);
    }
    while(return_value_epoll_wait$15 == 0);
    signed long int return_value_recv$16;
    return_value_recv$16=recv(sd, (void *)buf, (unsigned long int)1024, 0);
    ret = (signed int)return_value_recv$16;
    if(!(ret >= 1))
    {
      if(Debug >= 1)
        message(7, "ident: can't read from %s, ret=%d", (const void *)addr, ret);

      goto error;
    }

    shutdown(sd, 2);
    if(epfd >= 0)
      close(epfd);

    close(sd);
  }
  do
  {
    ret = ret - 1;
    c = buf[(signed long int)ret];
  }
  while(ret >= 1 && ((signed int)c == 10 || (signed int)c == 13));
  ret = ret + 1;
  buf[(signed long int)ret] = (char)0;
  if(Debug >= 3)
    message(7, "ident: sent %s:%d, %d got %s", (const void *)addr, sport, cport, (const void *)buf);

  _Bool tmp_if_expr$17;
  char *tmp_post$18;
  if(!(str == ((char *)NULL)))
  {
    char *p;
    p=rindex(buf, 58);
    if(!(p == ((char *)NULL)))
    {
      signed int i;
      do
        p = p + 1l;
      while((signed int)*p == 32);
      i = 0;
      do
      {
        if(!(i >= 127))
          tmp_if_expr$17 = *p != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$17 = (_Bool)0;
        if(!tmp_if_expr$17)
          break;

        tmp_post$18 = p;
        p = p + 1l;
        str[(signed long int)i] = *tmp_post$18;
        i = i + 1;
      }
      while((_Bool)1);
      str[(signed long int)i] = (char)0;
    }

  }

  return 1;
}

// getport
// file stone.c line 1410
signed int getport(struct sockaddr *sa)
{
  unsigned short int tmp_statement_expression$1;
  unsigned short int tmp_statement_expression$2;
  if((signed int)sa->sa_family == 2)
  {
    unsigned short int getport$$1$$1$$1$$__v;
    unsigned short int getport$$1$$1$$1$$__x = (unsigned short int)((struct sockaddr_in *)sa)->sin_port;
    asm("rorw $8, %w0" : "=r"(getport$$1$$1$$1$$__v) : "0"(getport$$1$$1$$1$$__x) : "cc");
    tmp_statement_expression$1 = getport$$1$$1$$1$$__v;
    return (signed int)tmp_statement_expression$1;
  }

  else
    if((signed int)sa->sa_family == 10)
    {
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)((struct sockaddr_in6 *)sa)->sin6_port;
      asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression$2 = __v;
      return (signed int)tmp_statement_expression$2;
    }

  return -1;
}

// gettoken
// file stone.c line 8563
static signed int gettoken(struct _IO_FILE *fp, char *buf)
{
  signed int i = 0;
  signed int quote = 0;
  signed int c;
  do
  {
    c=_IO_getc(fp);
    if(c == -1)
      return -1;

    if(c == 35)
      skipcomment(fp);

    else
    {
      const unsigned short int **return_value___ctype_b_loc$1;
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)c]) == 0)
      {
        ungetc(c, fp);
        break;
      }

    }
  }
  while((_Bool)1);
  const unsigned short int **return_value___ctype_b_loc$3;
  signed int tmp_post$4;
  while(!(i >= 2048))
  {
    c=_IO_getc(fp);
    if(c == -1)
    {
      if(i >= 1)
        break;

      return -1;
    }

    if(!(quote == 39))
    {
      if(c == 36)
      {
        signed int return_value_getvar$2;
        return_value_getvar$2=getvar(fp, &buf[(signed long int)i], (2048 - 1) - i);
        i = i + return_value_getvar$2;
        continue;
      }

      if(c == 92)
      {
        c=_IO_getc(fp);
        if(c == -1)
          break;

        switch(c)
        {
          case 110:
          {
            c = 10;
            break;
          }
          case 114:
          {
            c = 13;
            break;
          }
          case 116:
            c = 9;
        }
      }

    }

    if(!(quote == 0))
    {
      if(c == quote)
      {
        quote = 0;
        continue;
      }

    }

    else
      if(c == 34 || c == 39)
      {
        quote = c;
        continue;
      }

      else
      {
        return_value___ctype_b_loc$3=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)c]) == 0))
        {
          c=_IO_getc(fp);
          if(!(c == 58) && !(c == 61))
          {
            ungetc(c, fp);
            break;
          }

        }

        else
          if(c == 35)
          {
            skipcomment(fp);
            continue;
          }

      }
    tmp_post$4 = i;
    i = i + 1;
    buf[(signed long int)tmp_post$4] = (char)c;
  }
  buf[(signed long int)i] = (char)0;
  return i;
}

// getvar
// file stone.c line 8530
static signed int getvar(struct _IO_FILE *fp, char *buf, signed int bufmax)
{
  char var[128l];
  char *val;
  signed int i = 0;
  signed int paren = 0;
  signed int c;
  c=_IO_getc(fp);
  if(c == -1)
    return 0;

  else
    if(c == 123)
      paren = 1;

    else
      ungetc(c, fp);
  const unsigned short int **return_value___ctype_b_loc$2;
  signed int tmp_post$1;
  do
  {
    c=_IO_getc(fp);
    if(c == -1)
      break;

    if(i >= 127)
      break;

    if(c == 125 && !(paren == 0))
      break;

    else
    {
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if(c == 95 || !((8 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)c]) == 0))
      {
        tmp_post$1 = i;
        i = i + 1;
        var[(signed long int)tmp_post$1] = (char)c;
      }

      else
      {
        ungetc(c, fp);
        break;
      }
    }
  }
  while((_Bool)1);
  var[(signed long int)i] = (char)0;
  if((signed int)var[0l] == 0)
    return 0;

  else
  {
    val=getenv(var);
    if(val == ((char *)NULL))
      return 0;

    else
    {
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(val);
      i = (signed int)return_value_strlen$3;
      if(!(bufmax >= i))
        i = bufmax;

      __builtin_strncpy(buf, val, (unsigned long int)i);
      return i;
    }
  }
}

// handler
// file stone.c line 9775
static void handler(signed int sig)
{
  signed int i;
  switch(sig)
  {
    case 1:
    {
      if(Debug >= 5)
        message(7, "SIGHUP");

      if(!(NForks == 0))
      {
        if(oldstones == ((struct _Stone *)NULL) && !(ConfigFile == ((char *)NULL)))
        {
          oldstones = stones;
          stones = (struct _Stone *)(void *)0;
          OldConfigArgc = ConfigArgc;
          OldConfigArgv = ConfigArgv;
          Debug = 0;
          getconfig();
          i=doopts(ConfigArgc, ConfigArgv);
          doargs(ConfigArgc, i, ConfigArgv);
          i = 0;
          for( ; !(i >= NForks); i = i + 1)
          {
            kill(Pid[(signed long int)i], 1);
            kill(Pid[(signed long int)i], 2);
          }
        }

      }

      else
      {
        message_pairs(6);
        message_origins(6);
        message_conns(6);
      }
      if(!(LogFileName == ((char *)NULL)))
      {
        fclose(LogFp);
        LogFp=fopen(LogFileName, "a");
        if(LogFp == ((struct _IO_FILE *)NULL))
        {
          LogFp = stderr;
          signed int *return_value___errno_location$1;
          return_value___errno_location$1=__errno_location();
          message(3, "Can't re-create log file: %s err=%d", LogFileName, *return_value___errno_location$1);
          exit(1);
        }

        setbuf(LogFp, (char *)(void *)0);
      }

      if(!(AccFileName == ((char *)NULL)))
      {
        fclose(AccFp);
        AccFp=fopen(AccFileName, "a");
        if(AccFp == ((struct _IO_FILE *)NULL))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          message(3, "Can't re-create account log file: %s err=%d", AccFileName, *return_value___errno_location$2);
          exit(1);
        }

        setbuf(AccFp, (char *)(void *)0);
      }

      signal(1, handler);
      break;
    }
    case 15:

    case 2:
    {
      if(!(NForks == 0))
      {
        message(6, "SIGTERM/INT. killing children and exiting");
        i = 0;
        for( ; !(i >= NForks); i = i + 1)
          kill(Pid[(signed long int)i], sig);
      }

      else
        message(6, "SIGTERM/INT. exiting");
      exit(1);
    }
    case 10:
    {
      Debug = Debug + 1;
      message(6, "SIGUSR1. increase Debug level to %d", Debug);
      if(!(NForks == 0))
      {
        i = 0;
        for( ; !(i >= NForks); i = i + 1)
          kill(Pid[(signed long int)i], sig);
      }

      else
      {
        message_pairs(6);
        message_origins(6);
        message_conns(6);
      }
      signal(10, handler);
      break;
    }
    case 12:
    {
      if(Debug >= 1)
        Debug = Debug - 1;

      message(6, "SIGUSR2. decrease Debug level to %d", Debug);
      if(!(NForks == 0))
      {
        i = 0;
        for( ; !(i >= NForks); i = i + 1)
          kill(Pid[(signed long int)i], sig);
      }

      signal(12, handler);
      break;
    }
    case 13:
    {
      if(Debug >= 1)
        message(7, "SIGPIPE");

      signal(13, handler);
      break;
    }
    case 11:

    case 7:

    case 4:

    case 8:
    {
      if(!(CoreDumpDir == ((char *)NULL)))
      {
        message(3, "Signal %d, core dumping to %s", sig, CoreDumpDir);
        signed int return_value_chdir$4;
        return_value_chdir$4=chdir(CoreDumpDir);
        if(!(return_value_chdir$4 >= 0))
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          message(3, "Can't chdir to %s err=%d", CoreDumpDir, *return_value___errno_location$3);
        }

        else
          abort();
      }

      else
        message(3, "Signal %d, exiting", sig);
      exit(1);
      break;
    }
    default:
      message(6, "signal %d. Debug level: %d", sig, Debug);
  }
}

// healthCLOCK
// file stone.c line 5852
signed int healthCLOCK(struct _Pair *pair, char *parm, signed int start)
{
  char str[1025l];
  signed long int now;
  time(&now);
  snprintf(str, (unsigned long int)1024, "now=%ld established=%d readwrite=%d", (signed long int)now, (signed int)(now - lastEstablished), (signed int)(now - lastReadWrite));
  str[(signed long int)1024] = (char)0;
  if(!(Debug == 0))
    message(7, ": CLOCK %s: %s", parm, (const void *)str);

  commOutput(pair, "250 stone:%s debug=%d %s\r\n", (const void *)"2.3e", Debug, (const void *)str);
  return -2;
}

// healthCONFIG
// file stone.c line 5871
signed int healthCONFIG(struct _Pair *pair, char *parm, signed int start)
{
  signed int i = 1;
  for( ; !(i >= ConfigArgc); i = i + 1)
    commOutput(pair, "200%c%s\n", i < ConfigArgc - 1 ? 45 : 32, ConfigArgv[(signed long int)i]);
  return -2;
}

// healthCVS_ID
// file stone.c line 5866
signed int healthCVS_ID(struct _Pair *pair, char *parm, signed int start)
{
  commOutput(pair, "200 stone %s %s\r\n", (const void *)"2.3e", CVS_ID);
  return -2;
}

// healthCheck
// file stone.c line 1767
signed int healthCheck(struct sockaddr *sa, unsigned int salen, signed int proto, signed int timeout, struct _Chat *chat)
{
  signed int sd;
  signed int ret;
  char addrport[128l];
  signed int epfd;
  struct epoll_event ev;
  struct epoll_event evs[1l];
  signed long int start;
  signed long int now;
  time(&start);
  sd=socket((signed int)sa->sa_family, 1, 6);
  if(!(sd >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    message(3, "health check: can't create socket err=%d", *return_value___errno_location$1);
    return 1;
  }

  epfd=epoll_create(50);
  if(!(epfd >= 0))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    message(3, "health check: can't create epoll err=%d", *return_value___errno_location$2);
    return 1;
  }

  ev.events = (unsigned int)(4 | 1073741824);
  signed int return_value_epoll_ctl$4;
  return_value_epoll_ctl$4=epoll_ctl(epfd, 1, sd, &ev);
  if(!(return_value_epoll_ctl$4 >= 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    message(3, "health check: epoll_ctl ADD err=%d", *return_value___errno_location$3);
    close(epfd);
    return 1;
  }

  addrport[(signed long int)0] = (char)0;
  if((proto & proto_block_d) == 0)
    fcntl(sd, 4, 04000);

  ret=connect(sd, sa, salen);
  signed int return_value_epoll_wait$5;
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    if(*return_value___errno_location$7 == 115)
    {
      signed int optval;
      unsigned int optlen = (unsigned int)sizeof(signed int) /*4ul*/ ;
      do
      {
        time(&now);
        if(now + -start >= (signed long int)timeout)
          goto timeout;

        return_value_epoll_wait$5=epoll_wait(epfd, evs, 1, 1000);
      }
      while(return_value_epoll_wait$5 == 0);
      getsockopt(sd, 1, 4, (void *)(char *)&optval, &optlen);
      if(!(optval == 0))
      {
        addrport2strOnce(sa, salen, proto & (proto_ohttp_d | proto_base_d | proto_command), addrport, 127, 0);
        message(3, "health check: connect %s getsockopt err=%d", (const void *)addrport, optval);
        goto fail;
      }

    }

    else
    {
      addrport2strOnce(sa, salen, proto & (proto_ohttp_d | proto_base_d | proto_command), addrport, 127, 0);
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      message(3, "health check: connect %s err=%d", (const void *)addrport, *return_value___errno_location$6);
      goto fail;
    }
  }

  time(&now);
  _Bool tmp_if_expr$10;
  signed int return_value_epoll_wait$11;
  if(!(now + -start >= (signed long int)timeout))
  {
    while(!(chat == ((struct _Chat *)NULL)))
    {
      char buf[2048l];
      signed int len;
      signed int err;
      signed long int return_value_send$8;
      return_value_send$8=send(sd, (const void *)chat->send, (unsigned long int)chat->len, 0);
      ret = (signed int)return_value_send$8;
      if(!(ret >= 0))
        tmp_if_expr$10 = (_Bool)1;

      else
        tmp_if_expr$10 = ret != chat->len ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$10)
      {
        addrport2strOnce(sa, salen, proto & (proto_ohttp_d | proto_base_d | proto_command), addrport, 127, 0);
        signed int *return_value___errno_location$9;
        return_value___errno_location$9=__errno_location();
        message(3, "health check: send %s err=%d", (const void *)addrport, *return_value___errno_location$9);
        goto fail;
      }

      len = 0;
      do
      {
        ev.events = (unsigned int)(1 | 1073741824);
        epoll_ctl(epfd, 3, sd, &ev);
        do
        {
          time(&now);
          if(now + -start >= (signed long int)timeout)
            goto timeout;

          return_value_epoll_wait$11=epoll_wait(epfd, evs, 1, 1000);
        }
        while(return_value_epoll_wait$11 == 0);
        signed long int return_value_recv$12;
        return_value_recv$12=recv(sd, (void *)(buf + (signed long int)len), (unsigned long int)((2048 - 1) - len), 0);
        ret = (signed int)return_value_recv$12;
        if(!(ret >= 0))
        {
          addrport2strOnce(sa, salen, proto & (proto_ohttp_d | proto_base_d | proto_command), addrport, 127, 0);
          signed int *return_value___errno_location$13;
          return_value___errno_location$13=__errno_location();
          message(3, "health check: recv from %s err=%d", (const void *)addrport, *return_value___errno_location$13);
          goto fail;
        }

        len = len + ret;
        buf[(signed long int)len] = (char)0;
        err=regexec(&chat->expect, buf, (unsigned long int)0, (struct anonymous$19 *)(void *)0, 0);
        if(Debug >= 9)
        {
          addrport2strOnce(sa, salen, proto & (proto_ohttp_d | proto_base_d | proto_command), addrport, 127, 0);
          message(7, "health check: %s regexec=%d", (const void *)addrport, err);
        }

        if(len >= 1025)
        {
          bcopy((const void *)(buf + (signed long int)(len - 2048 / 2)), (void *)buf, (unsigned long int)(2048 / 2));
          len = 2048 / 2;
        }

      }
      while(err == 1 && ret >= 1);
      if(!(err == 0))
        goto fail;

      chat = chat->next;
    }
    shutdown(sd, 2);
    close(epfd);
    close(sd);
    return 1;
  }

  else
  {

  timeout:
    ;
    if(Debug >= 9)
    {
      addrport2strOnce(sa, salen, proto & (proto_ohttp_d | proto_base_d | proto_command), addrport, 127, 0);
      message(7, "health check: %s timeout", (const void *)addrport);
    }


  fail:
    ;
    shutdown(sd, 2);
    close(epfd);
    close(sd);
    return 0;
  }
}

// healthErr
// file stone.c line 5908
signed int healthErr(struct _Pair *pair, char *parm, signed int start)
{
  if(!(*parm == 0))
    message(3, "Unknown health command: %s", parm);

  return -1;
}

// healthFREE
// file stone.c line 5840
signed int healthFREE(struct _Pair *pair, char *parm, signed int start)
{
  char str[1025l];
  snprintf(str, (unsigned long int)1024, "fpair=%d nfexbuf=%d nfexbot=%d nfpktbuf=%d", nFreePairs, nFreeExBuf, nFreeExBot, nFreePktBuf);
  str[(signed long int)1024] = (char)0;
  if(!(Debug == 0))
    message(7, ": FREE %s: %s", parm, (const void *)str);

  commOutput(pair, "250 stone:%s debug=%d %s\r\n", (const void *)"2.3e", Debug, (const void *)str);
  return -2;
}

// healthHELO
// file stone.c line 5813
signed int healthHELO(struct _Pair *pair, char *parm, signed int start)
{
  char str[1025l];
  signed int return_value_nStones$1;
  return_value_nStones$1=nStones();
  signed int return_value_nPairs$2;
  return_value_nPairs$2=nPairs(PairTop);
  signed int return_value_nPairs$3;
  return_value_nPairs$3=nPairs(trash.next);
  signed int return_value_nConns$4;
  return_value_nConns$4=nConns();
  signed int return_value_nOrigins$5;
  return_value_nOrigins$5=nOrigins();
  snprintf(str, (unsigned long int)1024, "stone=%d pair=%d trash=%d conn=%d origin=%d", return_value_nStones$1, return_value_nPairs$2, return_value_nPairs$3, return_value_nConns$4, return_value_nOrigins$5);
  str[(signed long int)1024] = (char)0;
  if(!(Debug == 0))
    message(7, ": HELO %s: %s", parm, (const void *)str);

  commOutput(pair, "250 stone:%s debug=%d %s\r\n", (const void *)"2.3e", Debug, (const void *)str);
  return -2;
}

// healthLIMIT
// file stone.c line 5892
signed int healthLIMIT(struct _Pair *pair, char *parm, signed int start)
{
  struct _Comm *comm = limitComm;
  char *q = (char *)(void *)0;
  for( ; !(comm->str == ((char *)NULL)); comm = comm + 1l)
  {
    q=comm_match(parm, comm->str);
    if(!(q == ((char *)NULL)))
      break;

  }
  signed int return_value_limitErr$1;
  if(q == ((char *)NULL))
  {
    return_value_limitErr$1=limitErr(pair, parm, start);
    return return_value_limitErr$1;
  }

  else
  {
    signed int return_value;
    return_value=comm->func(pair, q, start);
    return return_value;
  }
}

// healthQUIT
// file stone.c line 5903
signed int healthQUIT(struct _Pair *pair, char *parm, signed int start)
{
  if(!(Debug == 0))
    message(7, ": QUIT %s", parm);

  return -1;
}

// healthSTAT
// file stone.c line 5826
signed int healthSTAT(struct _Pair *pair, char *parm, signed int start)
{
  char str[1025l];
  signed int mc = MutexConflict;
  MutexConflict = 0;
  snprintf(str, (unsigned long int)1024, "async=%d mutex=%d", AsyncCount, mc);
  str[(signed long int)1024] = (char)0;
  if(!(Debug == 0))
    message(7, ": STAT %s: %s", parm, (const void *)str);

  commOutput(pair, "250 stone:%s debug=%d %s\r\n", (const void *)"2.3e", Debug, (const void *)str);
  return -2;
}

// healthSTONE
// file stone.c line 5879
signed int healthSTONE(struct _Pair *pair, char *parm, signed int start)
{
  struct _Stone *stone;
  char str[128l];
  stone = stones;
  char *return_value_stone2str$1;
  for( ; !(stone == ((struct _Stone *)NULL)); stone = stone->next)
  {
    struct _Stone *child = stone->children;
    for( ; !(child == ((struct _Stone *)NULL)); child = child->children)
    {
      return_value_stone2str$1=stone2str(child, str, 127);
      commOutput(pair, "200-%s\n", return_value_stone2str$1);
    }
    char *return_value_stone2str$2;
    return_value_stone2str$2=stone2str(stone, str, 127);
    commOutput(pair, "200%c%s\n", stone->next != ((struct _Stone *)NULL) ? 45 : 32, return_value_stone2str$2);
  }
  return -2;
}

// help
// file stone.c line 8334
void help(char *com, char *sub)
{
  message(6, "stone %s  http://www.gcd.org/sengoku/stone/", (const void *)"2.3e");
  message(6, "%s", (const void *)"Copyright(C)2007 by Hiroaki Sengoku <sengoku@gcd.org>");
  message(6, "%s", (const void *)"using OpenSSL 1.0.2e 3 Dec 2015  http://www.openssl.org/");
  signed int tmp_statement_expression$5;
  signed int tmp_statement_expression$3;
  signed int tmp_statement_expression$1;
  if(sub == ((char *)NULL))
  {

  help:
    ;
    fprintf(stderr, "Usage: %s <opt>... <stone> [-- <stone>]...\nopt:  -h opt            ; help for <opt> more\n      -h stone          ; help for <stone>\n      -h ssl            ; help for <SSL>, see -q/-z opt\n", com);
  }

  else
  {
    unsigned long int help$$1$$2$$__s1_len;
    unsigned long int help$$1$$2$$__s2_len;
    signed int return_value___builtin_strcmp$6;
    return_value___builtin_strcmp$6=__builtin_strcmp(sub, "opt");
    tmp_statement_expression$5 = return_value___builtin_strcmp$6;
    if(tmp_statement_expression$5 == 0)
      fprintf(stderr, "Usage: %s <opt>... <stone> [-- <stone>]...\nopt:  -C <file>         ; configuration file\n      -P <command>      ; preprocessor for config. file\n      -Q <options>      ; options for preprocessor\n      -N                ; configuration check only\n      -d                ; increase debug level\n      -p                ; packet dump\n      -n                ; numerical address\n      -u <max>          ; # of UDP sessions\n      -f <n>            ; # of child processes\n      -l                ; use syslog\n      -ll               ; run under daemontools\n      -L <file>         ; write log to <file>\n      -a <file>         ; write accounting to <file>\n      -i <file>         ; write process ID to <file>\n      -X <n>            ; size [byte] of Xfer buffer\n      -T <n>            ; timeout [sec] of TCP sessions\n      -A <n>            ; length of backlog\n      -r                ; reuse socket\n      -x <port>[,<port>][-<port>]... <xhost> --\n                        ; permit connecting to <xhost>:<port>\n      -s <send> <expect>... --\n                        ; health check script\n      -b <n> <master>:<port> <backup>:<port>\n                        ; check <master>:<port> every <n> sec\n                        ; use <backup>:<port>, if check failed\n      -B <host>:<port>... --\n                        ; load balancing hosts\n      -I <host>         ; local end of its connections to\n      -o <n>            ; set uid to <n>\n      -g <n>            ; set gid to <n>\n      -t <dir>          ; chroot to <dir>\n      -D                ; become UNIX Daemon\n      -c <dir>          ; core dump to <dir>\n      -q <SSL>          ; SSL client option\n      -z <SSL>          ; SSL server option\n                        ; `-h ssl' for <SSL>\n", com);

    else
    {
      unsigned long int help$$1$$4$$__s1_len;
      unsigned long int help$$1$$4$$__s2_len;
      signed int return_value___builtin_strcmp$4;
      return_value___builtin_strcmp$4=__builtin_strcmp(sub, "stone");
      tmp_statement_expression$3 = return_value___builtin_strcmp$4;
      if(tmp_statement_expression$3 == 0)
        fprintf(stderr, "Usage: %s <opt>... <stone> [-- <stone>]...\nstone: <host>:<port> <sport> [<xhost>...]\n       proxy[/[v4only | v6only]] <sport> [<xhost>...]\n       health <sport> [<xhost>...]\n       identd <sport> [<xhost>...]\n       <host>:<port#>/http <sport> <Request-Line> [<xhost>...]\n       <host>:<port#>/proxy <sport> <header> [<xhost>...]\n       <host>:<port#>/mproxy <sport> <header> [<xhost>...]\nport:  <port#>[/<ext>[,<ext>]...]\next:   tcp | udp | ssl | v6 | base | block | nobackup\nsport: [<host>:]<port#>[/<exts>[,<exts>]...]\nexts:  tcp | udp | ssl | v6 | v6only | http | base | block | ident\nxhost: <host>[/<ex>[,<ex>]...]\nex:    <#bits> | p<mode#> | v6\n", com);

      else
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp$2;
        return_value___builtin_strcmp$2=__builtin_strcmp(sub, "ssl");
        tmp_statement_expression$1 = return_value___builtin_strcmp$2;
        if(tmp_statement_expression$1 == 0)
          fprintf(stderr, "opt:  -q <SSL>            ; SSL client option\n      -z <SSL>            ; SSL server option\nSSL:   default            ; reset to default\n       verbose            ; verbose mode\n       verify             ; require peer's certificate\n       verify,once        ; verify client's certificate only once\n       verify,ifany       ; verify client's certificate if any\n       verify,none        ; don't require peer's certificate\n       crl_check          ; lookup CRLs\n       crl_check_all      ; lookup CRLs for whole chain\n       uniq               ; check serial # of peer's certificate\n       re<n>=<regex>      ; verify depth <n> with <regex>\n       depth=<n>          ; set verification depth to <n>\n       tls1               ; just use TLSv1\n       no_tls1            ; turn off TLSv1\n       no_ssl3            ; turn off SSLv3\n       no_ssl2            ; turn off SSLv2\n       sni                ; Server Name Indication\n       servername=<str>   ; Server Name\n       bugs               ; SSL implementation bug workarounds\n       serverpref         ; use server's cipher preferences (SSLv2)\n       shutdown=<mode>    ; accurate, nowait, unclean\n       sid_ctx=<str>      ; set session ID context\n       passfile=<file>    ; password file\n       passfilepat=<file> ; password file pattern\n       key=<file>         ; key file\n       keypat=<file>      ; key file pattern\n       cert=<file>        ; certificate file\n       certpat=<file>     ; certificate file pattern\n       certkey=<file>     ; certificate & key file\n       certkeypat=<file>  ; certificate & key file pattern\n       CAfile=<file>      ; certificate file of CA\n       CApath=<dir>       ; dir of CAs\n       pfx=<file>         ; PKCS#12 file\n       pfxpat=<file>      ; PKCS#12 file pattern\n       cipher=<ciphers>   ; list of ciphers\n       lb<n>=<m>          ; load balancing based on CN\n");

        else
          goto help;
      }
    }
  }
}

// host2sa
// file stone.c line 1500
signed int host2sa(char *name, char *serv, struct sockaddr *sa, unsigned int *salenp, signed int *socktypep, signed int *protocolp, signed int flags)
{
  struct addrinfo *ai = (struct addrinfo *)(void *)0;
  struct addrinfo hint;
  signed int err;
  hint.ai_flags = flags;
  hint.ai_family = (signed int)sa->sa_family;
  if(!(socktypep == ((signed int *)NULL)))
    hint.ai_socktype = *socktypep;

  else
    hint.ai_socktype = 1;
  if(!(protocolp == ((signed int *)NULL)))
    hint.ai_protocol = *protocolp;

  else
    hint.ai_protocol = 0;
  hint.ai_addrlen = (unsigned int)0;
  hint.ai_addr = (struct sockaddr *)(void *)0;
  hint.ai_canonname = (char *)(void *)0;
  hint.ai_next = (struct addrinfo *)(void *)0;
  if(Debug >= 11)
    message(7, "getaddrinfo: %s:%s family=%d socktype=%d flags=%d", name != ((char *)NULL) ? name : "", serv != ((char *)NULL) ? serv : "", sa->sa_family, hint.ai_socktype, flags);

  err=getaddrinfo(name, serv, &hint, &ai);
  if(!(err == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    message(3, "getaddrinfo for %s:%s failed err=%d errno=%d", name != ((char *)NULL) ? name : "", serv != ((char *)NULL) ? serv : "", err, *return_value___errno_location$1);

  fail:
    ;
    if(!(ai == ((struct addrinfo *)NULL)))
      freeaddrinfo(ai);

    return 0;
  }

  if(!(*salenp >= ai->ai_addrlen))
  {
    message(3, "getaddrinfo for %s:%s returns unexpected addr size=%d", name != ((char *)NULL) ? name : "", serv != ((char *)NULL) ? serv : "", ai->ai_addrlen);
    goto fail;
  }

  *salenp = ai->ai_addrlen;
  if(!(socktypep == ((signed int *)NULL)))
    *socktypep = ai->ai_socktype;

  if(!(protocolp == ((signed int *)NULL)))
    *protocolp = ai->ai_protocol;

  bcopy((const void *)ai->ai_addr, (void *)sa, (unsigned long int)*salenp);
  freeaddrinfo(ai);
  return 1;
}

// hostPort2sa
// file stone.c line 1546
signed int hostPort2sa(char *str, struct sockaddr *sa, unsigned int *salenp, signed int flags)
{
  char host[128l];
  char port[128l];
  signed int pos;
  pos=hostPortExt(str, host, port);
  signed int tmp_statement_expression$1;
  if(!(pos >= 0))
    return 0;

  else
  {
    if(!(pos == 0))
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp$2;
      return_value___builtin_strcmp$2=__builtin_strcmp(str + (signed long int)pos, "v6");
      tmp_statement_expression$1 = return_value___builtin_strcmp$2;
      if(tmp_statement_expression$1 == 0)
        sa->sa_family = (unsigned short int)10;

    }

    signed int return_value_host2sa$3;
    return_value_host2sa$3=host2sa(host, port, sa, salenp, (signed int *)(void *)0, (signed int *)(void *)0, flags);
    return return_value_host2sa$3;
  }
}

// hostPortExt
// file stone.c line 1421
signed int hostPortExt(char *str, char *host, char *port)
{
  signed int port_pos = 0;
  signed int ext_pos = 0;
  signed int i = 0;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(i >= 127))
      tmp_if_expr$1 = str[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    host[(signed long int)i] = str[(signed long int)i];
    port[(signed long int)(i - port_pos)] = str[(signed long int)i];
    if((signed int)str[(signed long int)i] == 58)
      port_pos = i + 1;

    if((signed int)str[(signed long int)i] == 47)
      ext_pos = i + 1;

    i = i + 1;
  }
  while((_Bool)1);
  if(port_pos == 0)
    return -1;

  else
  {
    host[(signed long int)(port_pos - 1)] = (char)0;
    if(!(ext_pos == 0))
      port[(signed long int)((ext_pos - port_pos) - 1)] = (char)0;

    else
      port[(signed long int)(i - port_pos)] = (char)0;
    return ext_pos;
  }
}

// hostcheck
// file stone.c line 7107
static signed int hostcheck(struct _Pair *pair, struct x509_st *cert, char *host)
{
  struct X509_extension_st *ext;
  struct stack_st_GENERAL_NAME *ialt;
  char name[1025l];
  signed int i;
  i=X509_get_ext_by_NID(cert, 85, -1);
  void *return_value_X509V3_EXT_d2i$5;
  _Bool tmp_if_expr$2;
  signed int return_value_sk_num$1;
  if(i >= 0)
  {
    ext=X509_get_ext(cert, i);
    if(!(ext == ((struct X509_extension_st *)NULL)))
    {
      return_value_X509V3_EXT_d2i$5=X509V3_EXT_d2i(ext);
      ialt = (struct stack_st_GENERAL_NAME *)return_value_X509V3_EXT_d2i$5;
      if(!(ialt == ((struct stack_st_GENERAL_NAME *)NULL)))
      {
        signed int done = 0;
        i = 0;
        do
        {
          if(done == 0)
          {
            return_value_sk_num$1=sk_num((struct stack_st *)(1 != 0 ? ialt : (struct stack_st_GENERAL_NAME *)0));
            tmp_if_expr$2 = i < return_value_sk_num$1 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$2 = (_Bool)0;
          if(!tmp_if_expr$2)
            break;

          struct GENERAL_NAME_st *gen;
          void *return_value_sk_value$3;
          return_value_sk_value$3=sk_value((struct stack_st *)(1 != 0 ? ialt : (struct stack_st_GENERAL_NAME *)0), i);
          gen = (struct GENERAL_NAME_st *)return_value_sk_value$3;
          if(gen->type == 2)
          {
            if(!(gen->d.ia5 == ((struct asn1_string_st *)NULL)))
            {
              signed int len = gen->d.ia5->length;
              if(len >= 1025)
                len = 1024;

              __builtin_strncpy(name, (char *)gen->d.ia5->data, (unsigned long int)len);
              name[(signed long int)len] = (char)0;
              signed int return_value_hostcmp$4;
              return_value_hostcmp$4=hostcmp(name, host);
              if(return_value_hostcmp$4 == 0)
              {
                if(Debug >= 5)
                  message(7, "match %s dNSName=%s", host, (const void *)name);

                done = 1;
              }

              else
                if(Debug >= 6)
                  message(7, "dNSName: %s", (const void *)name);

            }

          }

          GENERAL_NAME_free(gen);
          i = i + 1;
        }
        while((_Bool)1);
        sk_free((struct stack_st *)(1 != 0 ? ialt : (struct stack_st_GENERAL_NAME *)0));
        if(!(done == 0))
          return 1;

      }

    }

  }

  struct X509_name_st *return_value_X509_get_subject_name$7;
  return_value_X509_get_subject_name$7=X509_get_subject_name(cert);
  signed int return_value_X509_NAME_get_text_by_NID$8;
  return_value_X509_NAME_get_text_by_NID$8=X509_NAME_get_text_by_NID(return_value_X509_get_subject_name$7, 13, name, (signed int)sizeof(char [1025l]) /*1025ul*/ );
  if(return_value_X509_NAME_get_text_by_NID$8 >= 0)
  {
    signed int return_value_hostcmp$6;
    return_value_hostcmp$6=hostcmp(name, host);
    if(return_value_hostcmp$6 == 0)
    {
      if(Debug >= 5)
        message(7, "match %s CN=%s", host, (const void *)name);

      return 1;
    }

    message(3, "%d TCP %d: connect to %s, but CN=%s", pair->stone->sd, pair->sd, host, (const void *)name);
    return 0;
  }

  message(3, "%d TCP %d: no dNSName nor CN", pair->stone->sd, pair->sd);
  return 0;
}

// hostcmp
// file stone.c line 7088
static signed int hostcmp(char *pat, char *host)
{
  char a;
  char b;
  signed int tmp_statement_expression$1;
  signed int tmp_if_expr$3;
  const signed int **return_value___ctype_toupper_loc$2;
  const signed int **return_value___ctype_toupper_loc$4;
  signed int tmp_statement_expression$5;
  signed int tmp_if_expr$7;
  const signed int **return_value___ctype_toupper_loc$6;
  const signed int **return_value___ctype_toupper_loc$8;
  for( ; !(*pat == 0); host = host + 1l)
  {
    if((signed int)*pat == 42)
    {
      pat = pat + 1l;
      for( ; !(*host == 0); host = host + 1l)
        if(*host == *pat)
          break;

    }

    signed int __res;
    return_value___ctype_toupper_loc$4=__ctype_toupper_loc();
    __res = (*return_value___ctype_toupper_loc$4)[(signed long int)(signed int)*pat];
    tmp_statement_expression$1 = __res;
    a = (char)tmp_statement_expression$1;
    signed int hostcmp$$1$$1$$3$$__res;
    return_value___ctype_toupper_loc$8=__ctype_toupper_loc();
    hostcmp$$1$$1$$3$$__res = (*return_value___ctype_toupper_loc$8)[(signed long int)(signed int)*host];
    tmp_statement_expression$5 = hostcmp$$1$$1$$3$$__res;
    b = (char)tmp_statement_expression$5;
    if(!(a == b))
      return (signed int)a - (signed int)b;

    pat = pat + 1l;
  }
  return (signed int)*host;
}

// identd
// file stone.c line 5656
struct _Pair * identd(signed int cport, struct sockaddr *ssa, unsigned int ssalen)
{
  struct sockaddr_storage ss;
  struct sockaddr *sa = (struct sockaddr *)&ss;
  unsigned int salen;
  struct _Pair *pair = PairTop;
  _Bool tmp_if_expr$2;
  signed int return_value_getsockname$1;
  for( ; !(pair == ((struct _Pair *)NULL)); pair = pair->next)
  {
    signed int sd;
    if(!((pair->proto & proto_command) == 0x0f00))
    {
      sd = pair->sd;
      salen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
      if(!(sd >= 0))
        tmp_if_expr$2 = (_Bool)1;

      else
      {
        return_value_getsockname$1=getsockname(sd, sa, &salen);
        tmp_if_expr$2 = return_value_getsockname$1 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$2)
      {
        signed int return_value_getport$3;
        return_value_getport$3=getport(sa);
        if(return_value_getport$3 == cport)
        {
          salen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
          signed int return_value_getpeername$4;
          return_value_getpeername$4=getpeername(sd, sa, &salen);
          if(return_value_getpeername$4 >= 0)
          {
            signed int return_value_saComp$5;
            return_value_saComp$5=saComp(sa, ssa);
            if(!(return_value_saComp$5 == 0))
              return pair;

          }

        }

      }

    }

  }
  return (struct _Pair *)(void *)0;
}

// identdQUERY
// file stone.c line 5680
signed int identdQUERY(struct _Pair *pair, char *parm, signed int start)
{
  signed int cport = 0;
  signed int sport = 0;
  char mesg[128l];
  struct sockaddr_storage ss;
  struct sockaddr *sa = (struct sockaddr *)&ss;
  unsigned int salen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  struct _Pair *p = pair->pair;
  strcpy(mesg, "ERROR : NO-USER");
  _Bool tmp_if_expr$3;
  signed int return_value_getpeername$2;
  if(!(p == ((struct _Pair *)NULL)))
  {
    signed int sd = p->sd;
    signed int return_value_sscanf$1;
    return_value_sscanf$1=sscanf(parm, "%d,%d", &cport, &sport);
    if(return_value_sscanf$1 == 2 && sd >= 0)
    {
      return_value_getpeername$2=getpeername(sd, sa, &salen);
      tmp_if_expr$3 = return_value_getpeername$2 >= 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
    {
      if(Debug >= 9)
      {
        char identdQUERY$$1$$1$$1$$1$$addrport[128l];
        addrport2str(sa, salen, 0, identdQUERY$$1$$1$$1$$1$$addrport, 127, 0);
        message(7, "%d TCP %d: identd query %d,%d from %s", pair->stone->sd, sd, cport, sport, (const void *)identdQUERY$$1$$1$$1$$1$$addrport);
      }

      saPort(sa, (unsigned short int)sport);
      p=identd(cport, sa, salen);
      if(!(p == ((struct _Pair *)NULL)))
      {
        signed int port = -1;
        struct _Stone *stone = p->stone;
        if(!(stone == ((struct _Stone *)NULL)))
          port = stone->port;

        snprintf(mesg, (unsigned long int)127, "USERID : STONE : %d", port);
      }

      if(Debug >= 3)
      {
        char addrport[128l];
        addrport2str(sa, salen, 0, addrport, 127, 0);
        message(7, "identd %d %s %s", cport, (const void *)addrport, (const void *)mesg);
      }

    }

    else
      return -1;
  }

  commOutput(pair, "%d , %d : %s\r\n", cport, sport, (const void *)mesg);
  return -2;
}

// identdQUIT
// file stone.c line 5720
signed int identdQUIT(struct _Pair *pair, char *parm, signed int start)
{
  if(!(Debug == 0))
    message(7, "identd QUIT %s", parm);

  return -1;
}

// initialize
// file stone.c line 9925
void initialize(signed int argc, char **argv)
{
  signed int i;
  signed int j = 0;
  MyPid=getpid();
  LogFp = stderr;
  setbuf(stderr, (char *)(void *)0);
  SSL_library_init();
  SSL_load_error_strings();
  OPENSSL_add_all_algorithms_noconf();
  PairIndex=SSL_get_ex_new_index((signed long int)0, (void *)"Pair index", (signed int (*)(void *, void *, struct crypto_ex_data_st *, signed int, signed long int, void *))(void *)0, (signed int (*)(struct crypto_ex_data_st *, struct crypto_ex_data_st *, void *, signed int, signed long int, void *))(void *)0, (void (*)(void *, void *, struct crypto_ex_data_st *, signed int, signed long int, void *))(void *)0);
  MatchIndex=SSL_SESSION_get_ex_new_index((signed long int)0, (void *)"Match index", newMatch, (signed int (*)(struct crypto_ex_data_st *, struct crypto_ex_data_st *, void *, signed int, signed long int, void *))(void *)0, freeMatch);
  RAND_poll();
  signed int return_value_RAND_status$4;
  return_value_RAND_status$4=RAND_status();
  signed int return_value_RAND_status$2;
  if(return_value_RAND_status$4 == 0)
  {
    message(4, "Can't collect enough random seeds");
    signed long int return_value_time$1;
    return_value_time$1=time((signed long int *)(void *)0);
    srand((unsigned int)return_value_time$1);
    do
    {
      unsigned short int rnd;
      signed int return_value_rand$3;
      return_value_rand$3=rand();
      rnd = (unsigned short int)return_value_rand$3;
      RAND_seed((const void *)&rnd, (signed int)sizeof(unsigned short int) /*2ul*/ );
      return_value_RAND_status$2=RAND_status();
    }
    while(return_value_RAND_status$2 == 0);
  }

  sslopts_default(&ServerOpts, 1);
  sslopts_default(&ClientOpts, 0);
  void *return_value_malloc$5;
  return_value_malloc$5=malloc((sizeof(struct _XHosts) /*32ul*/  - sizeof(struct sockaddr) /*16ul*/ ) + sizeof(struct sockaddr_storage) /*128ul*/ );
  XHostsTrue = (struct _XHosts *)return_value_malloc$5;
  if(XHostsTrue == ((struct _XHosts *)NULL))
  {
    message(2, "Out of memory");
    exit(1);
  }

  XHostsTrue->next = (struct _XHosts *)(void *)0;
  XHostsTrue->mbits = (signed short int)0;
  XHostsTrue->mode = (signed short int)0;
  XHostsTrue->xhost.len = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  bzero((void *)&XHostsTrue->xhost.addr, (unsigned long int)XHostsTrue->xhost.len);
  XHostsTrue->xhost.addr.sa_family = (unsigned short int)0;
  i=doopts(argc, argv);
  if(!(ConfigFile == ((char *)NULL)))
  {
    getconfig();
    j=doopts(ConfigArgc, ConfigArgv);
  }

  if(!(DaemonMode == 0))
    daemonize();

  if(DryRun == 0 && !(PidFile == ((char *)NULL)))
  {
    struct _IO_FILE *fp;
    fp=fopen(PidFile, "w");
    if(!(fp == ((struct _IO_FILE *)NULL)))
    {
      fprintf(fp, "%d\n", MyPid);
      fclose(fp);
    }

  }

  if(!(Syslog == 0))
  {
    snprintf(SyslogName, (unsigned long int)127, "stone[%d]", MyPid);
    SyslogName[(signed long int)127] = (char)0;
    openlog(SyslogName, 0, 3 << 3);
    if(Syslog >= 2)
      setbuf(stdout, (char *)(void *)0);

  }

  message(6, "start (%s) [%d]", (const void *)"2.3e", MyPid);
  if(Debug >= 1)
    message(7, "Debug level: %d", Debug);

  trash.next = (struct _Pair *)(void *)0;
  conns.next = (struct _Conn *)(void *)0;
  if(!(ConfigFile == ((char *)NULL)) && !(j >= ConfigArgc))
  {
    if(!(i >= argc))
      doargs(argc, i, argv);

    doargs(ConfigArgc, j, ConfigArgv);
  }

  else
    doargs(argc, i, argv);
  signal(1, handler);
  signal(15, handler);
  signal(2, handler);
  signal(13, handler);
  signal(10, handler);
  signal(12, handler);
  signal(11, handler);
  signal(7, handler);
  signal(4, handler);
  signal(8, handler);
  if(DryRun == 0 && !(NForks == 0))
  {
    void *return_value_malloc$6;
    return_value_malloc$6=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)NForks);
    Pid = (signed int *)return_value_malloc$6;
    if(Pid == ((signed int *)NULL))
    {
      message(2, "Out of memory");
      exit(1);
    }

    i = 0;
    for( ; !(i >= NForks); i = i + 1)
    {
      Pid[(signed long int)i]=fork();
      if(Pid[(signed long int)i] == 0)
        break;

    }
    if(i >= NForks)
    {
      signed int id;
      do
      {
        signed int status;
        id=wait(&status);
        if(id >= 0)
        {
          message(4, "Process died pid=%d, status=%x", id, status);
          i = 0;
          for( ; !(i >= NForks); i = i + 1)
            if(Pid[(signed long int)i] == id)
              break;

          if(!(i >= NForks))
          {
            id=fork();
            if(id == 0)
              break;

            else
              Pid[(signed long int)i] = id;
          }

          else
            message(3, "This can't happen pid=%d", id);
        }

      }
      while((_Bool)1);
    }

    free((void *)Pid);
    Pid = (signed int *)(void *)0;
    NForks = 0;
    MyPid=getpid();
    if(!(Syslog == 0))
    {
      closelog();
      snprintf(SyslogName, (unsigned long int)127, "stone[%d]", MyPid);
      SyslogName[(signed long int)127] = (char)0;
      openlog(SyslogName, 0, 3 << 3);
    }

    message(6, "child start (%s) [%d]", (const void *)"2.3e", MyPid);
  }

  pthread_attr_init(&thread_attr);
  pthread_attr_setdetachstate(&thread_attr, 1);
  signed int return_value_sslthread_initialize$7;
  return_value_sslthread_initialize$7=sslthread_initialize();
  if(!(return_value_sslthread_initialize$7 >= 0))
    message(3, "Fail to initialize SSL callback");

  if(!(RootDir == ((char *)NULL)))
  {
    char cwd[2048l];
    signed int len;
    unsigned long int return_value_strlen$8;
    return_value_strlen$8=strlen(RootDir);
    len = (signed int)return_value_strlen$8;
    getcwd(cwd, (unsigned long int)(2048 - 1));
    signed int return_value_strncmp$9;
    return_value_strncmp$9=strncmp(cwd, RootDir, (unsigned long int)len);
    if(!(return_value_strncmp$9 == 0))
      len = -1;

    signed int return_value_chroot$12;
    return_value_chroot$12=chroot(RootDir);
    if(!(return_value_chroot$12 >= 0))
      message(4, "Can't change root directory to %s", RootDir);

    else
      if(!(len >= 1))
      {
        if(Debug >= 1)
          message(7, "cwd=%s is outside chroot=%s, so chdir /", (const void *)cwd, RootDir);

        signed int return_value_chdir$11;
        return_value_chdir$11=chdir("/");
        if(!(return_value_chdir$11 >= 0))
        {
          signed int *return_value___errno_location$10;
          return_value___errno_location$10=__errno_location();
          message(4, "Can't change directory to chroot / err=%d", *return_value___errno_location$10);
        }

      }

  }

  signed int return_value_fileno$13;
  signed int return_value_fileno$14;
  if(!(SetGID == 0u) || !(SetUID == 0u))
  {
    if(!(AccFileName == ((char *)NULL)))
    {
      return_value_fileno$13=fileno(AccFp);
      fchown(return_value_fileno$13, SetUID, SetGID);
    }

    if(!(LogFileName == ((char *)NULL)))
    {
      return_value_fileno$14=fileno(LogFp);
      fchown(return_value_fileno$14, SetUID, SetGID);
    }

  }

  signed int return_value_setgid$16;
  _Bool tmp_if_expr$18;
  signed int return_value_setgroups$17;
  if(!(SetGID == 0u))
  {
    return_value_setgid$16=setgid(SetGID);
    if(!(return_value_setgid$16 >= 0))
      tmp_if_expr$18 = (_Bool)1;

    else
    {
      return_value_setgroups$17=setgroups((unsigned long int)1, &SetGID);
      tmp_if_expr$18 = return_value_setgroups$17 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$18)
    {
      signed int *return_value___errno_location$15;
      return_value___errno_location$15=__errno_location();
      message(4, "Can't set gid err=%d", *return_value___errno_location$15);
    }

  }

  signed int return_value_setuid$20;
  if(!(SetUID == 0u))
  {
    return_value_setuid$20=setuid(SetUID);
    if(!(return_value_setuid$20 >= 0))
    {
      signed int *return_value___errno_location$19;
      return_value___errno_location$19=__errno_location();
      message(4, "Can't set uid err=%d", *return_value___errno_location$19);
    }

  }

  if(!(CoreDumpDir == ((char *)NULL)) && (!(SetGID == 0u) || !(SetUID == 0u)))
  {
    signed int return_value_prctl$22;
    return_value_prctl$22=prctl(4, 1);
    if(!(return_value_prctl$22 >= 0))
    {
      signed int *return_value___errno_location$21;
      return_value___errno_location$21=__errno_location();
      message(3, "prctl err=%d", *return_value___errno_location$21);
    }

  }

  if(MinInterval >= 1)
  {
    if(Debug >= 2)
      message(7, "MinInterval: %d", MinInterval);

  }

  time(&lastEstablished);
  lastReadWrite = lastEstablished;
  ePollFd=epoll_create(50);
  if(!(ePollFd >= 0))
  {
    signed int *return_value___errno_location$23;
    return_value___errno_location$23=__errno_location();
    message(2, "Can't create epoll err=%d", *return_value___errno_location$23);
    exit(1);
  }

  else
  {
    struct _Stone *stone = stones;
    for( ; !(stone == ((struct _Stone *)NULL)); stone = stone->next)
    {
      struct epoll_event ev;
      ev.events = (unsigned int)(1 | 2);
      ev.data.ptr = (void *)stone;
      if(Debug >= 7)
        message(7, "stone %d: epoll_ctl %d ADD %x", stone->sd, ePollFd, (signed int)ev.data.ptr);

      signed int return_value_epoll_ctl$25;
      return_value_epoll_ctl$25=epoll_ctl(ePollFd, 1, stone->sd, &ev);
      if(!(return_value_epoll_ctl$25 >= 0))
      {
        signed int *return_value___errno_location$24;
        return_value___errno_location$24=__errno_location();
        message(2, "stone %d: epoll_ctl %d ADD err=%d", stone->sd, ePollFd, *return_value___errno_location$24);
        exit(1);
      }

    }
  }
}

// insertPairs
// file stone.c line 3662
void insertPairs(struct _Pair *p1)
{
  struct _Pair *p2 = p1->pair;
  struct _Stone *stone = p1->stone;
  p1->next = p2;
  p2->prev = p1;
  waitMutex(0);
  p2->next = stone->pairs->next;
  if(!(stone->pairs->next == ((struct _Pair *)NULL)))
    stone->pairs->next->prev = p2;

  p1->prev = stone->pairs;
  stone->pairs->next = p1;
  freeMutex(0);
  if(Debug >= 5)
  {
    message(7, "%d TCP %d: pair %d inserted", stone->sd, p1->sd, p2->sd);
    message_pair(7, p1);
  }

}

// insheader
// file stone.c line 5974
signed int insheader(struct _Pair *pair)
{
  struct _ExBuf *ex = pair->b;
  char *p;
  signed int bufmax = ex->bufmax;
  signed int len;
  signed int i;
  len = ex->start + ex->len;
  i = ex->start;
  for( ; !(i >= len); i = i + 1)
    if((signed int)ex->buf[(signed long int)i] == 10)
      break;

  signed int tmp_post$2;
  signed int tmp_post$3;
  if(i >= len)
  {
    if(Debug >= 4)
      message(7, "%d TCP %d: insheader needs more", pair->stone->sd, pair->sd);

    return -1;
  }

  else
  {
    i = i + 1;
    len = len - i;
    if(len >= 1)
    {
      bufmax = bufmax - len;
      bcopy((const void *)&ex->buf[(signed long int)i], (void *)&ex->buf[(signed long int)bufmax], (unsigned long int)len);
    }

    p = pair->stone->p;
    signed int return_value_strnparse$1;
    return_value_strnparse$1=strnparse(&ex->buf[(signed long int)i], bufmax - i, &p, pair->pair, (char)0xFF);
    i = i + return_value_strnparse$1;
    tmp_post$2 = i;
    i = i + 1;
    ex->buf[(signed long int)tmp_post$2] = (char)13;
    tmp_post$3 = i;
    i = i + 1;
    ex->buf[(signed long int)tmp_post$3] = (char)10;
    if(Debug >= 6)
      message(7, "%d TCP %d: insheader start=%d, ins=%d, rest=%d, max=%d", pair->stone->sd, pair->sd, ex->start, i - ex->start, len, ex->bufmax);

    if(len >= 1)
      bcopy((const void *)&ex->buf[(signed long int)bufmax], (void *)&ex->buf[(signed long int)i], (unsigned long int)len);

    ex->len = (i - ex->start) + len;
    return ex->len;
  }
}

// isdigitaddr
// file stone.c line 1376
signed int isdigitaddr(char *name)
{
  signed int ndigits = 0;
  signed int isdot = 1;
  const unsigned short int **return_value___ctype_b_loc$1;
  while(!(*name == 0))
  {
    if((signed int)*name == 46)
    {
      if(!(isdot == 0))
        return 0;

      isdot = 1;
    }

    else
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*name]) == 0))
      {
        if(!(isdot == 0))
          ndigits = ndigits + 1;

        isdot = 0;
      }

      else
        return 0;
    }
    name = name + 1l;
  }
  return ndigits;
}

// isdigitstr
// file stone.c line 1368
signed int isdigitstr(char *str)
{
  const unsigned short int **return_value___ctype_b_loc$1;
  while(!(*str == 0))
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*str]) == 0))
      break;

    const unsigned short int **return_value___ctype_b_loc$2;
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*str]) == 0)
      return 0;

    str = str + 1l;
  }
  return 1;
}

// islocalhost
// file stone.c line 1186
signed int islocalhost(struct sockaddr *sa)
{
  if((signed int)sa->sa_family == 2)
  {
    unsigned int return_value___bswap_32$1;
    return_value___bswap_32$1=__bswap_32(((struct sockaddr_in *)sa)->sin_addr.s_addr);
    if((signed long int)return_value___bswap_32$1 == 0x7F000001L)
      return 1;

    unsigned int return_value___bswap_32$2;
    return_value___bswap_32$2=__bswap_32(((struct sockaddr_in *)sa)->sin_addr.s_addr);
    if((signed long int)return_value___bswap_32$2 == 0L)
      return -1;

  }

  if((signed int)sa->sa_family == 10)
  {
    signed int i;
    struct in6_addr *addrp = &((struct sockaddr_in6 *)sa)->sin6_addr;
    i = 0;
    for( ; !(i >= 12); i = i + 4)
      if(!(*((unsigned long int *)(addrp->__in6_u.__u6_addr8 + (signed long int)i)) == 0ul))
        return 0;

    unsigned int return_value___bswap_32$3;
    return_value___bswap_32$3=__bswap_32((unsigned int)1);
    if(*((unsigned long int *)(addrp->__in6_u.__u6_addr8 + (signed long int)i)) == (unsigned long int)return_value___bswap_32$3)
      return 1;

    if(*((unsigned long int *)(addrp->__in6_u.__u6_addr8 + (signed long int)i)) == 0ul)
      return -1;

  }

  return 0;
}

// lbsopts
// file stone.c line 2272
signed int lbsopts(signed int argc, signed int i, char **argv)
{
  struct anonymous$0 *dsts[100l];
  signed int ndsts = 0;
  struct _LBSet *lbs;
  struct sockaddr_storage ss;
  struct sockaddr *sa = (struct sockaddr *)&ss;
  unsigned int salen;
  signed int proto = 0;
  i = i + 1;
  for( ; !(i >= argc); i = i + 1)
  {
    if((signed int)*argv[(signed long int)i] == 45)
    {
      if((signed int)argv[(signed long int)i][1l] == 45)
        break;

    }

    if(ndsts >= 100)
    {
      message(3, "Too many load balancing hosts");
      exit(1);
    }

    salen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
    sa->sa_family = (unsigned short int)0;
    signed int return_value_hostPort2sa$1;
    return_value_hostPort2sa$1=hostPort2sa(argv[(signed long int)i], sa, &salen, 0);
    if(return_value_hostPort2sa$1 == 0)
    {
      message(3, "Illegal load balancing host: %s", argv[(signed long int)i]);
      exit(1);
    }

    dsts[(signed long int)ndsts]=saDup(sa, salen);
    if(dsts[(signed long int)ndsts] == ((struct anonymous$0 *)NULL))
      goto memerr;

    ndsts = ndsts + 1;
  }
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct _LBSet) /*16ul*/  + sizeof(struct anonymous$0 *) /*8ul*/  * (unsigned long int)ndsts);
  lbs = (struct _LBSet *)return_value_malloc$2;
  if(!(lbs == ((struct _LBSet *)NULL)))
  {
    signed int j;
    lbs->next = lbsets;
    lbs->proto = proto;
    lbs->ndsts = (signed short int)ndsts;
    j = 0;
    for( ; !(j >= ndsts); j = j + 1)
      lbs->dsts[(signed long int)j] = dsts[(signed long int)j];
    lbsets = lbs;
  }

  else
  {

  memerr:
    ;
    message(2, "Out of memory, can't make LB set");
    exit(1);
  }
  return i;
}

// limitAsync
// file stone.c line 5794
signed int limitAsync(struct _Pair *pair, char *parm, signed int start)
{
  signed int return_value_atoi$1;
  return_value_atoi$1=atoi(parm);
  signed int return_value_limitCommon$2;
  return_value_limitCommon$2=limitCommon(pair, AsyncCount, return_value_atoi$1, "async");
  return return_value_limitCommon$2;
}

// limitCommon
// file stone.c line 5761
signed int limitCommon(struct _Pair *pair, signed int var, signed int limit, char *str)
{
  if(!(Debug == 0))
    message(7, ": LIMIT %s %d: %d", str, limit, var);

  if(!(var >= limit))
    commOutput(pair, "200 %s=%d is less than %d\r\n", str, var, limit);

  else
    commOutput(pair, "500 %s=%d is not less than %d\r\n", str, var, limit);
  return -2;
}

// limitConn
// file stone.c line 5776
signed int limitConn(struct _Pair *pair, char *parm, signed int start)
{
  signed int return_value_nConns$1;
  return_value_nConns$1=nConns();
  signed int return_value_atoi$2;
  return_value_atoi$2=atoi(parm);
  signed int return_value_limitCommon$3;
  return_value_limitCommon$3=limitCommon(pair, return_value_nConns$1, return_value_atoi$2, "conn");
  return return_value_limitCommon$3;
}

// limitErr
// file stone.c line 5798
signed int limitErr(struct _Pair *pair, char *parm, signed int start)
{
  if(!(Debug == 0))
    message(3, ": Illegal LIMIT %s", parm);

  commOutput(pair, "500 Illegal LIMIT\r\n");
  return -2;
}

// limitEstablished
// file stone.c line 5780
signed int limitEstablished(struct _Pair *pair, char *parm, signed int start)
{
  signed long int now;
  time(&now);
  signed int return_value_atoi$1;
  return_value_atoi$1=atoi(parm);
  signed int return_value_limitCommon$2;
  return_value_limitCommon$2=limitCommon(pair, (signed int)(now - lastEstablished), return_value_atoi$1, "established");
  return return_value_limitCommon$2;
}

// limitPair
// file stone.c line 5772
signed int limitPair(struct _Pair *pair, char *parm, signed int start)
{
  signed int return_value_nPairs$1;
  return_value_nPairs$1=nPairs(PairTop);
  signed int return_value_atoi$2;
  return_value_atoi$2=atoi(parm);
  signed int return_value_limitCommon$3;
  return_value_limitCommon$3=limitCommon(pair, return_value_nPairs$1, return_value_atoi$2, "pair");
  return return_value_limitCommon$3;
}

// limitReadWrite
// file stone.c line 5787
signed int limitReadWrite(struct _Pair *pair, char *parm, signed int start)
{
  signed long int now;
  time(&now);
  signed int return_value_atoi$1;
  return_value_atoi$1=atoi(parm);
  signed int return_value_limitCommon$2;
  return_value_limitCommon$2=limitCommon(pair, (signed int)(now - lastReadWrite), return_value_atoi$1, "readwrite");
  return return_value_limitCommon$2;
}

// main
// file stone.c line 10258
signed int main(signed int argc, char **argv)
{
  initialize(argc, argv);
  if(!(DryRun == 0))
    return 0;

  else
  {
    do
      repeater();
    while((_Bool)1);
    return 0;
  }
}

// memCheck
// file stone.c line 5926
signed int memCheck(void)
{
  char *buf;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(2048 * 10));
  buf = (char *)return_value_malloc$1;
  if(!(buf == ((char *)NULL)))
  {
    free((void *)buf);
    return 1;
  }

  else
  {
    message(2, "memCheck: out of memory");
    return 0;
  }
}

// message
// file stone.c line 913
void message(signed int pri, char *fmt, ...)
{
  char str[1025l];
  signed int pos = 0;
  unsigned long int thid = (unsigned long int)0;
  void **ap;
  if(Syslog == 0)
  {
    struct timeval tv;
    signed int return_value_gettimeofday$1;
    return_value_gettimeofday$1=gettimeofday(&tv, (struct timezone *)(void *)0);
    if(return_value_gettimeofday$1 >= 0)
      strntime(str + (signed long int)pos, 1024 - pos, &tv.tv_sec, tv.tv_usec);

    str[(signed long int)1024] = (char)0;
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(str);
    pos = (signed int)return_value_strlen$2;
  }

  unsigned long int return_value_pthread_self$3;
  return_value_pthread_self$3=pthread_self();
  thid = (unsigned long int)return_value_pthread_self$3;
  if(!(thid == 0ul))
  {
    snprintf(str + (signed long int)pos, (unsigned long int)(1024 - pos), "%lu ", thid);
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(str + (signed long int)pos);
    pos = pos + (signed int)return_value_strlen$4;
  }

  ap = (void **)&fmt;
  vsnprintf(str + (signed long int)pos, (unsigned long int)(1024 - pos), fmt, ap);
  ap = ((void **)NULL);
  str[(signed long int)1024] = (char)0;
  if(!(LogFp == ((struct _IO_FILE *)NULL)))
    fprintf(LogFp, "%s\n", (const void *)str);

  else
    if(!(Syslog == 0))
    {
      if(Syslog == 1 || !(pri == 7))
        syslog(pri, "%s", (const void *)str);

      if(Syslog >= 2)
        fprintf(stdout, "%s\n", (const void *)str);

    }

}

// message_buf
// file stone.c line 1047
void message_buf(struct _Pair *pair, signed int len, char *str)
{
  char head[128l];
  struct _Pair *p = pair->pair;
  if(!(p == ((struct _Pair *)NULL)))
  {
    head[(signed long int)127] = (char)0;
    if((pair->proto & proto_command) == 0x0f00)
      snprintf(head, (unsigned long int)127, "%d %s%d<%d", pair->stone->sd, str, pair->sd, p->sd);

    else
      snprintf(head, (unsigned long int)127, "%d %s%d>%d", pair->stone->sd, str, p->sd, pair->sd);
    packet_dump(head, pair->t->buf + (signed long int)pair->t->start, len, pair->xhost);
  }

}

// message_conn
// file stone.c line 3757
void message_conn(signed int pri, struct _Conn *conn)
{
  signed int sd = -1;
  struct _Pair *p1;
  struct _Pair *p2;
  signed int proto = 0;
  signed int i = 0;
  char str[1025l];
  str[(signed long int)1024] = (char)0;
  p1 = conn->pair;
  if(!(p1 == ((struct _Pair *)NULL)))
  {
    p2 = p1->pair;
    strntime(str, 1024, &p1->clock, (signed long int)-1);
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(str);
    i = (signed int)return_value_strlen$1;
    proto = p1->proto;
    if(!(p2 == ((struct _Pair *)NULL)))
      sd = p2->sd;

  }

  addrport2str(&conn->dst->addr, conn->dst->len, proto & (proto_ohttp_d | proto_base_d | proto_command), str + (signed long int)i, 1024 - i, 0);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(str);
  i = (signed int)return_value_strlen$2;
  if(i >= 1025)
    i = 1024;

  str[(signed long int)i] = (char)0;
  message(pri, "Conn %d: %08x %s", sd, proto, (const void *)str);
}

// message_conns
// file stone.c line 4773
void message_conns(signed int pri)
{
  struct _Conn *conn = conns.next;
  for( ; !(conn == ((struct _Conn *)NULL)); conn = conn->next)
    message_conn(pri, conn);
}

// message_origin
// file stone.c line 2543
void message_origin(signed int pri, struct _Origin *origin)
{
  struct sockaddr_storage ss;
  struct sockaddr *name = (struct sockaddr *)&ss;
  unsigned int namelen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  signed int sd;
  struct _Stone *stone;
  signed int i;
  char str[1025l];
  str[(signed long int)1024] = (char)0;
  strntime(str, 1024, &origin->clock, (signed long int)-1);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  i = (signed int)return_value_strlen$1;
  signed int *return_value___errno_location$2;
  signed int tmp_post$4;
  if(origin->sd >= 0)
  {
    signed int return_value_getsockname$5;
    return_value_getsockname$5=getsockname(origin->sd, name, &namelen);
    if(!(return_value_getsockname$5 >= 0))
    {
      if(Debug >= 4)
      {
        return_value___errno_location$2=__errno_location();
        message(7, "%d UDP %d: Can't get socket's name err=%d", origin->stone->sd, origin->sd, *return_value___errno_location$2);
      }

    }

    else
    {
      addrport2str(name, namelen, proto_udp_s | proto_udp_d, str + (signed long int)i, 1024 - i, 0);
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(str);
      i = (signed int)return_value_strlen$3;
      if(!(i >= 1024))
      {
        tmp_post$4 = i;
        i = i + 1;
        str[(signed long int)tmp_post$4] = (char)32;
      }

    }
  }

  if(i >= 1025)
    i = 1024;

  str[(signed long int)i] = (char)0;
  stone = origin->stone;
  if(!(stone == ((struct _Stone *)NULL)))
    sd = stone->sd;

  else
    sd = -1;
  addrport2str(&origin->from->addr, origin->from->len, proto_udp_s | proto_udp_d, str + (signed long int)i, 127 - i, 0);
  str[(signed long int)127] = (char)0;
  message(pri, "%d UDP%3d:%3d %s", origin->stone->sd, origin->sd, sd, (const void *)str);
}

// message_origins
// file stone.c line 4761
void message_origins(signed int pri)
{
  struct _Origin *origin = OriginTop;
  for( ; !(origin == ((struct _Origin *)NULL)); origin = origin->next)
    if(!(origin->from == ((struct anonymous$0 *)NULL)))
      message_origin(pri, origin);

    else
      if(Debug >= 3)
        message(7, "%d UDP %d: top", origin->stone->sd, origin->sd);

}

// message_pair
// file stone.c line 3176
void message_pair(signed int pri, struct _Pair *pair)
{
  struct sockaddr_storage ss;
  struct sockaddr *name = (struct sockaddr *)&ss;
  unsigned int namelen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  signed int sd;
  signed int psd;
  struct _Pair *p;
  signed int i;
  char str[1025l];
  str[(signed long int)1024] = (char)0;
  strntime(str, 1024, &pair->clock, (signed long int)-1);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  i = (signed int)return_value_strlen$1;
  sd = pair->sd;
  signed int *return_value___errno_location$2;
  signed int tmp_post$4;
  signed int *return_value___errno_location$6;
  if(sd >= 0)
  {
    signed int return_value_getsockname$5;
    return_value_getsockname$5=getsockname(sd, name, &namelen);
    if(!(return_value_getsockname$5 >= 0))
    {
      if(Debug >= 4)
      {
        return_value___errno_location$2=__errno_location();
        message(7, "%d TCP %d: Can't get socket's name err=%d", pair->stone->sd, sd, *return_value___errno_location$2);
      }

    }

    else
    {
      addrport2str(name, namelen, 0, str + (signed long int)i, 1024 - i, 0);
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(str);
      i = (signed int)return_value_strlen$3;
      if(!(i >= 1024))
      {
        tmp_post$4 = i;
        i = i + 1;
        str[(signed long int)tmp_post$4] = (char)32;
      }

    }
    namelen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
    signed int return_value_getpeername$8;
    return_value_getpeername$8=getpeername(sd, name, &namelen);
    if(!(return_value_getpeername$8 >= 0))
    {
      if(Debug >= 4)
      {
        return_value___errno_location$6=__errno_location();
        message(7, "%d TCP %d: Can't get peer's name err=%d", pair->stone->sd, sd, *return_value___errno_location$6);
      }

    }

    else
    {
      addrport2str(name, namelen, 0, str + (signed long int)i, 1024 - i, 0);
      unsigned long int return_value_strlen$7;
      return_value_strlen$7=strlen(str + (signed long int)i);
      i = i + (signed int)return_value_strlen$7;
    }
  }

  if(i >= 1025)
    i = 1024;

  str[(signed long int)i] = (char)0;
  p = pair->pair;
  if(!(p == ((struct _Pair *)NULL)))
    psd = p->sd;

  else
    psd = -1;
  message(pri, "%d TCP%3d:%3d %08x %d %s tx:%d rx:%d lp:%d", pair->stone->sd, sd, psd, pair->proto, pair->count, (const void *)str, pair->tx, pair->rx, pair->loop);
}

// message_pairs
// file stone.c line 4750
void message_pairs(signed int pri)
{
  struct _Pair *pair = PairTop;
  for( ; !(pair == ((struct _Pair *)NULL)); pair = pair->next)
    if(!(pair->clock == -1l))
      message_pair(pri, pair);

    else
      if(Debug >= 3)
        message(7, "%d TCP %d: top", pair->stone->sd, pair->sd);

}

// message_time
// file stone.c line 962
void message_time(struct _Pair *pair, signed int pri, char *fmt, ...)
{
  void **ap;
  char str[1025l];
  struct _TimeLog *log = pair->log;
  if(!(log == ((struct _TimeLog *)NULL)))
  {
    pair->log = (struct _TimeLog *)(void *)0;
    free((void *)log);
  }

  ap = (void **)&fmt;
  vsnprintf(str, (unsigned long int)1024, fmt, ap);
  ap = ((void **)NULL);
  str[(signed long int)1024] = (char)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct _TimeLog) /*16ul*/  + return_value_strlen$1 + (unsigned long int)1);
  log = (struct _TimeLog *)return_value_malloc$2;
  if(!(log == ((struct _TimeLog *)NULL)))
  {
    time(&log->clock);
    log->pri = pri;
    strcpy(log->str, str);
    pair->log = log;
  }

}

// message_time_log
// file stone.c line 3680
void message_time_log(struct _Pair *pair)
{
  struct _TimeLog *log = pair->log;
  if(!(log == ((struct _TimeLog *)NULL)))
  {
    if(!(log->clock == 0l))
    {
      struct tm tm;
      struct tm *t;
      t=localtime_r(&log->clock, &tm);
      signed long int now;
      time(&now);
      message(log->pri, "%02d:%02d:%02d %d %s", t->tm_hour, t->tm_min, t->tm_sec, (signed int)(now - log->clock), (const void *)log->str);
      log->clock = (signed long int)0;
    }

  }

}

// mkBackup
// file stone.c line 2033
signed int mkBackup(signed int argc, signed int argi, char **argv)
{
  char master_host[128l];
  char master_port[128l];
  char *master_ext = (char *)(void *)0;
  char backup_host[128l];
  char backup_port[128l];
  signed int pos;
  char *check_host = (char *)(void *)0;
  char *check_port = (char *)(void *)0;
  char *check_ext = (char *)(void *)0;
  struct sockaddr_storage ss;
  struct sockaddr *sa = (struct sockaddr *)&ss;
  unsigned int salen;
  struct _Backup *b;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _Backup) /*64ul*/ );
  b = (struct _Backup *)return_value_malloc$1;
  argi = argi + 1;
  signed int return_value_strncmp$3;
  signed int return_value_strncmp$2;
  for( ; !(argi >= argc); argi = argi + 1)
  {
    signed int return_value_strncmp$4;
    return_value_strncmp$4=strncmp(argv[(signed long int)argi], "host=", (unsigned long int)5);
    if(return_value_strncmp$4 == 0)
      check_host = argv[(signed long int)argi] + (signed long int)5;

    else
    {
      return_value_strncmp$3=strncmp(argv[(signed long int)argi], "port=", (unsigned long int)5);
      if(return_value_strncmp$3 == 0)
        check_port = argv[(signed long int)argi] + (signed long int)5;

      else
      {
        return_value_strncmp$2=strncmp(argv[(signed long int)argi], "ext=", (unsigned long int)4);
        if(return_value_strncmp$2 == 0)
          check_ext = argv[(signed long int)argi] + (signed long int)4;

        else
          break;
      }
    }
  }
  if(2 + argi >= argc)
  {
    message(3, "Irregular backup option");
    exit(1);
  }

  if(!(b == ((struct _Backup *)NULL)))
  {
    b->last = (signed long int)0;
    b->bn = (signed short int)0;
    b->used = (signed short int)0;
    signed int return_value_atoi$5;
    return_value_atoi$5=atoi(argv[(signed long int)argi]);
    b->interval = (signed short int)return_value_atoi$5;
  }

  else
  {

  memerr:
    ;
    message(2, "Out of memory, no backup for %s", argv[(signed long int)(argi + 1)]);
    return argi + 2;
  }
  if((signed int)b->interval >= 1)
  {
    if(MinInterval >= 1)
      MinInterval=gcd(MinInterval, (signed int)b->interval);

    else
      MinInterval = (signed int)b->interval;
  }

  else
    b->bn = (signed short int)1;
  b->proto = 0;
  pos=hostPortExt(argv[(signed long int)(argi + 1)], master_host, master_port);
  if(!(pos >= 0))
  {
    message(3, "Illegal master: %s", argv[(signed long int)(argi + 1)]);
    free((void *)b);
    return argi + 2;
  }

  else
    if(pos >= 1)
      master_ext = argv[(signed long int)(argi + 1)] + (signed long int)pos;

  salen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  sa->sa_family = (unsigned short int)0;
  signed int tmp_statement_expression$6;
  if(!(master_ext == ((char *)NULL)))
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$7;
    return_value___builtin_strcmp$7=__builtin_strcmp(master_ext, "v6");
    tmp_statement_expression$6 = return_value___builtin_strcmp$7;
    if(tmp_statement_expression$6 == 0)
      sa->sa_family = (unsigned short int)10;

  }

  signed int return_value_host2sa$8;
  return_value_host2sa$8=host2sa(master_host, master_port, sa, &salen, (signed int *)(void *)0, (signed int *)(void *)0, 0);
  if(!(return_value_host2sa$8 == 0))
  {
    b->master=saDup(sa, salen);
    if(b->master == ((struct anonymous$0 *)NULL))
    {
      free((void *)b);
      goto memerr;
    }

    b->check = b->master;
  }

  else
  {
    free((void *)b);
    return argi + 2;
  }
  pos=hostPortExt(argv[(signed long int)(argi + 2)], backup_host, backup_port);
  signed int tmp_statement_expression$9;
  signed int tmp_statement_expression$12;
  if(!(pos >= 0))
  {
    message(3, "Illegal backup: %s", argv[(signed long int)(argi + 2)]);
    free((void *)b);
    return argi + 2;
  }

  else
  {
    salen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
    sa->sa_family = (unsigned short int)0;
    if(!(pos == 0))
    {
      unsigned long int mkBackup$$1$$13$$__s1_len;
      unsigned long int mkBackup$$1$$13$$__s2_len;
      signed int return_value___builtin_strcmp$10;
      return_value___builtin_strcmp$10=__builtin_strcmp(argv[(signed long int)(argi + 2)] + (signed long int)pos, "v6");
      tmp_statement_expression$9 = return_value___builtin_strcmp$10;
      if(tmp_statement_expression$9 == 0)
        sa->sa_family = (unsigned short int)10;

    }

    signed int return_value_host2sa$11;
    return_value_host2sa$11=host2sa(backup_host, backup_port, sa, &salen, (signed int *)(void *)0, (signed int *)(void *)0, 0);
    if(!(return_value_host2sa$11 == 0))
    {
      b->backup=saDup(sa, salen);
      if(b->backup == ((struct anonymous$0 *)NULL))
      {
        free((void *)b->master);
        free((void *)b);
        goto memerr;
      }

    }

    else
    {
      free((void *)b->master);
      free((void *)b);
      return argi + 2;
    }
    if(!(check_ext == ((char *)NULL)) || !(check_host == ((char *)NULL)) || !(check_port == ((char *)NULL)))
    {
      if(check_host == ((char *)NULL))
        check_host = master_host;

      if(check_port == ((char *)NULL))
        check_port = master_port;

      if(check_ext == ((char *)NULL))
        check_ext = master_ext;

      salen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
      sa->sa_family = (unsigned short int)0;
      if(!(check_ext == ((char *)NULL)))
      {
        unsigned long int mkBackup$$1$$16$$1$$__s1_len;
        unsigned long int mkBackup$$1$$16$$1$$__s2_len;
        signed int return_value___builtin_strcmp$13;
        return_value___builtin_strcmp$13=__builtin_strcmp(check_ext, "v6");
        tmp_statement_expression$12 = return_value___builtin_strcmp$13;
        if(tmp_statement_expression$12 == 0)
          sa->sa_family = (unsigned short int)10;

      }

      signed int return_value_host2sa$14;
      return_value_host2sa$14=host2sa(check_host, check_port, sa, &salen, (signed int *)(void *)0, (signed int *)(void *)0, 0);
      if(!(return_value_host2sa$14 == 0))
      {
        b->check=saDup(sa, salen);
        if(b->check == ((struct anonymous$0 *)NULL))
        {
          free((void *)b->backup);
          free((void *)b->master);
          free((void *)b);
          goto memerr;
        }

      }

    }

    b->chat = healthChat;
    b->next = backups;
    backups = b;
    return argi + 2;
  }
}

// mkChat
// file stone.c line 2208
signed int mkChat(signed int argc, signed int i, char **argv)
{
  struct _Chat *top;
  struct _Chat *bot = (struct _Chat *)(void *)0;
  top = bot;
  i = i + 1;
  for( ; !(1 + i >= argc); i = i + 2)
  {
    struct _Chat *cur;
    signed int err;
    if((signed int)*argv[(signed long int)i] == 45)
    {
      if((signed int)argv[(signed long int)i][1l] == 45)
      {
        healthChat = top;
        return i;
      }

    }

    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct _Chat) /*88ul*/ );
    cur = (struct _Chat *)return_value_malloc$1;
    if(cur == ((struct _Chat *)NULL))
    {

    memerr:
      ;
      message(2, "Out of memory, can't make Chat");
      exit(1);
    }

    cur->send=str2bin(argv[(signed long int)i], &cur->len);
    if(cur->send == ((char *)NULL))
    {
      free((void *)cur);
      goto memerr;
    }

    err=regcomp(&cur->expect, argv[(signed long int)(i + 1)], 1);
    if(!(err == 0))
    {
      message(3, "RegEx compiling error: \"%s\" err=%d", argv[(signed long int)(i + 1)], err);
      exit(1);
    }

    cur->next = (struct _Chat *)(void *)0;
    if(top == ((struct _Chat *)NULL))
      top = cur;

    if(!(bot == ((struct _Chat *)NULL)))
      bot->next = cur;

    bot = cur;
  }
  message(3, "chat script ends unexpectedly");
  exit(1);
  return i;
}

// mkPortXhosts
// file stone.c line 7947
signed int mkPortXhosts(signed int argc, signed int i, char **argv)
{
  struct _PortXHosts *pxh;
  struct _XPorts *top = (struct _XPorts *)(void *)0;
  struct _XPorts *bot = (struct _XPorts *)(void *)0;
  char **hosts;
  char *p;
  char *q;
  char str[128l];
  signed int isnum;
  signed int from;
  signed int j;
  i = i + 1;
  signed int tmp_statement_expression$1;
  unsigned long int mkPortXhosts$$1$$1$$__s1_len;
  unsigned long int mkPortXhosts$$1$$1$$__s2_len;
  signed int return_value___builtin_strcmp$2;
  return_value___builtin_strcmp$2=__builtin_strcmp(argv[(signed long int)i], "--");
  tmp_statement_expression$1 = return_value___builtin_strcmp$2;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  const unsigned short int **return_value___ctype_b_loc$5;
  char *tmp_post$8;
  char *tmp_post$9;
  signed int tmp_post$10;
  signed int tmp_statement_expression$12;
  if(tmp_statement_expression$1 == 0)
  {
    portXHosts = (struct _PortXHosts *)(void *)0;
    return i;
  }

  else
  {
    p = argv[(signed long int)i];
    q = str;
    isnum = 1;
    from = -1;
    do
    {
      if((signed int)*p == 44)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = (signed int)*p == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = (signed int)*p == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
      {
        signed int port;
        *q = (char)0;
        if(!(str[0l] == 0))
        {
          if(!(isnum == 0))
            port=atoi(str);

          else
          {
            struct sockaddr_storage ss;
            struct sockaddr *sa = (struct sockaddr *)&ss;
            unsigned int salen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
            signed int return_value_host2sa$3;
            return_value_host2sa$3=host2sa((char *)(void *)0, str, sa, &salen, (signed int *)(void *)0, (signed int *)(void *)0, 0);
            if(return_value_host2sa$3 == 0)
              goto opterr;

            port=getport(sa);
          }
        }

        else
        {

        opterr:
          ;
          message(3, "Illegal option: -x requires port list: %s", argv[(signed long int)i]);
          exit(1);
        }
        if((signed int)*p == 45)
          from = port;

        else
        {
          struct _XPorts *new;
          void *return_value_malloc$4;
          return_value_malloc$4=malloc(sizeof(struct _XPorts) /*16ul*/ );
          new = (struct _XPorts *)return_value_malloc$4;
          if(new == ((struct _XPorts *)NULL))
            goto memerr;

          new->next = (struct _XPorts *)(void *)0;
          if(from >= 0)
            new->from = (signed short int)from;

          else
            new->from = (signed short int)port;
          new->end = (signed short int)port;
          from = -1;
          if(!(bot == ((struct _XPorts *)NULL)))
            bot->next = new;

          bot = new;
          if(top == ((struct _XPorts *)NULL))
            top = new;

          if((signed int)*p == 0)
            break;

        }
        p = p + 1l;
        q = str;
        isnum = 1;
        continue;
      }

      else
      {
        return_value___ctype_b_loc$5=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)*p]) == 0)
          isnum = 0;

      }
      tmp_post$8 = q;
      q = q + 1l;
      tmp_post$9 = p;
      p = p + 1l;
      *tmp_post$8 = *tmp_post$9;
    }
    while((_Bool)1);
    if(Debug >= 6)
    {
      char buf[2048l];
      struct _XPorts *cur;
      j = 0;
      cur = top;
      for( ; !(cur == ((struct _XPorts *)NULL)) && !(j >= 2048); cur = cur->next)
      {
        if(j >= 1)
        {
          tmp_post$10 = j;
          j = j + 1;
          buf[(signed long int)tmp_post$10] = (char)44;
        }

        snprintf(buf + (signed long int)j, (unsigned long int)((2048 - 1) - j), "%d-%d", cur->from, cur->end);
        unsigned long int return_value_strlen$11;
        return_value_strlen$11=strlen(buf + (signed long int)j);
        j = j + (signed int)return_value_strlen$11;
      }
      buf[(signed long int)j] = (char)0;
      message(7, "XPorts: %s", (const void *)buf);
    }

    i = i + 1;
    hosts = &argv[(signed long int)i];
    j = 0;
    for( ; !(i >= argc); j = j + 1)
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp$13;
      return_value___builtin_strcmp$13=__builtin_strcmp(argv[(signed long int)i], "--");
      tmp_statement_expression$12 = return_value___builtin_strcmp$13;
      if(tmp_statement_expression$12 == 0)
        break;

      i = i + 1;
    }
    void *return_value_malloc$14;
    return_value_malloc$14=malloc(sizeof(struct _PortXHosts) /*24ul*/ );
    pxh = (struct _PortXHosts *)return_value_malloc$14;
    if(!(pxh == ((struct _PortXHosts *)NULL)))
    {
      pxh->ports = top;
      if(Debug >= 6)
        p = "XHosts: ";

      else
        p = (char *)(void *)0;
      pxh->xhosts=mkXhosts(j, hosts, (unsigned short int)0, p);
      pxh->next = portXHosts;
      portXHosts = pxh;
      return i;
    }

    else
    {

    memerr:
      ;
      message(2, "Out of memory");
      exit(1);
    }
  }
}

// mkStoneSSL
// file stone.c line 7334
struct anonymous$12 * mkStoneSSL(struct anonymous$8 *opts, signed int isserver)
{
  struct anonymous$12 *ss;
  signed int err;
  signed int i;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$12) /*128ul*/ );
  ss = (struct anonymous$12 *)return_value_malloc$1;
  if(ss == ((struct anonymous$12 *)NULL))
  {

  memerr:
    ;
    message(2, "Out of memory");
    exit(1);
  }

  ss->verbose = opts->verbose;
  ss->shutdown_mode = opts->shutdown_mode;
  ss->name = opts->servername;
  ss->ctx=SSL_CTX_new(opts->meth);
  _Bool tmp_if_expr$4;
  struct x509_store_st *return_value_SSL_CTX_get_cert_store$3;
  signed int return_value_SSL_CTX_use_PrivateKey_file$16;
  signed int return_value_SSL_CTX_use_certificate_file$17;
  signed int return_value_SSL_CTX_set_cipher_list$18;
  if(ss->ctx == ((struct ssl_ctx_st *)NULL))
    message(3, "SSL_CTX_new error");

  else
  {
    SSL_CTX_ctrl(ss->ctx, 32, opts->off, (void *)0);
    SSL_CTX_ctrl(ss->ctx, 33, 0x00000001L, (void *)0);
    SSL_CTX_set_verify(ss->ctx, opts->mode, opts->callback);
    SSL_CTX_set_verify_depth(ss->ctx, opts->depth + 1);
    ss->depth = opts->depth;
    ss->serial = opts->serial;
    ss->lbmod = opts->lbmod;
    ss->lbparm = opts->lbparm;
    if(!(opts->caFile == ((char *)NULL)))
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = opts->caPath != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
    {
      signed int return_value_SSL_CTX_load_verify_locations$2;
      return_value_SSL_CTX_load_verify_locations$2=SSL_CTX_load_verify_locations(ss->ctx, opts->caFile, opts->caPath);
      if(return_value_SSL_CTX_load_verify_locations$2 == 0)
      {
        message(3, "SSL_CTX_load_verify_locations(%s,%s) error", opts->caFile, opts->caPath);
        goto error;
      }

      if(!(opts->vflags == 0))
      {
        return_value_SSL_CTX_get_cert_store$3=SSL_CTX_get_cert_store(ss->ctx);
        X509_STORE_set_flags(return_value_SSL_CTX_get_cert_store$3, (unsigned long int)opts->vflags);
      }

    }

    if(!(opts->pfxFile == ((char *)NULL)))
    {
      struct _IO_FILE *fp;
      fp=fopen(opts->pfxFile, "r");
      struct anonymous$24 *p12;
      struct evp_pkey_st *key;
      struct x509_st *cert;
      if(fp == ((struct _IO_FILE *)NULL))
      {
        message(3, "Can't open pfx file: %s", opts->pfxFile);
        goto error;
      }

      p12=d2i_PKCS12_fp(fp, (struct anonymous$24 **)(void *)0);
      if(p12 == ((struct anonymous$24 *)NULL))
      {
        message(3, "Can't read pfx file: %s", opts->pfxFile);
        fclose(fp);
        goto error;
      }

      fclose(fp);
      key = (struct evp_pkey_st *)(void *)0;
      cert = (struct x509_st *)(void *)0;
      signed int return_value_PKCS12_parse$7;
      return_value_PKCS12_parse$7=PKCS12_parse(p12, opts->passwd, &key, &cert, (struct stack_st_X509 **)(void *)0);
      if(return_value_PKCS12_parse$7 == 0)
      {
        unsigned long int return_value_ERR_get_error$5;
        return_value_ERR_get_error$5=ERR_get_error();
        char *return_value_ERR_error_string$6;
        return_value_ERR_error_string$6=ERR_error_string(return_value_ERR_get_error$5, (char *)(void *)0);
        message(3, "Can't parse PKCS12(%s) %s", opts->pfxFile, return_value_ERR_error_string$6);
        goto error;
      }

      if(!(cert == ((struct x509_st *)NULL)))
      {
        signed int return_value_SSL_CTX_use_certificate$10;
        return_value_SSL_CTX_use_certificate$10=SSL_CTX_use_certificate(ss->ctx, cert);
        if(return_value_SSL_CTX_use_certificate$10 == 0)
        {
          unsigned long int return_value_ERR_get_error$8;
          return_value_ERR_get_error$8=ERR_get_error();
          char *return_value_ERR_error_string$9;
          return_value_ERR_error_string$9=ERR_error_string(return_value_ERR_get_error$8, (char *)(void *)0);
          message(3, "SSL_CTX_use_certificate(%s) %s", opts->pfxFile, return_value_ERR_error_string$9);
          X509_free(cert);
          goto error;
        }

        X509_free(cert);
      }

      if(!(key == ((struct evp_pkey_st *)NULL)))
      {
        signed int return_value_SSL_CTX_use_PrivateKey$13;
        return_value_SSL_CTX_use_PrivateKey$13=SSL_CTX_use_PrivateKey(ss->ctx, key);
        if(return_value_SSL_CTX_use_PrivateKey$13 == 0)
        {
          unsigned long int return_value_ERR_get_error$11;
          return_value_ERR_get_error$11=ERR_get_error();
          char *return_value_ERR_error_string$12;
          return_value_ERR_error_string$12=ERR_error_string(return_value_ERR_get_error$11, (char *)(void *)0);
          message(3, "SSL_CTX_use_PrivateKey(%s) %s", opts->pfxFile, return_value_ERR_error_string$12);
          EVP_PKEY_free(key);
          goto error;
        }

        EVP_PKEY_free(key);
      }

      PKCS12_free(p12);
    }

    else
    {
      if(!(opts->passwd == ((char *)NULL)))
      {
        SSL_CTX_set_default_passwd_cb(ss->ctx, passwd_callback);
        SSL_CTX_set_default_passwd_cb_userdata(ss->ctx, (void *)opts->passwd);
      }

      if(!(opts->keyFile == ((char *)NULL)))
      {
        return_value_SSL_CTX_use_PrivateKey_file$16=SSL_CTX_use_PrivateKey_file(ss->ctx, opts->keyFile, 1);
        if(return_value_SSL_CTX_use_PrivateKey_file$16 == 0)
        {
          unsigned long int return_value_ERR_get_error$14;
          return_value_ERR_get_error$14=ERR_get_error();
          char *return_value_ERR_error_string$15;
          return_value_ERR_error_string$15=ERR_error_string(return_value_ERR_get_error$14, (char *)(void *)0);
          message(3, "SSL_CTX_use_PrivateKey_file(%s) %s", opts->keyFile, return_value_ERR_error_string$15);
          goto error;
        }

      }

      if(!(opts->certFile == ((char *)NULL)))
      {
        return_value_SSL_CTX_use_certificate_file$17=SSL_CTX_use_certificate_file(ss->ctx, opts->certFile, 1);
        if(return_value_SSL_CTX_use_certificate_file$17 == 0)
        {
          message(3, "SSL_CTX_use_certificate_file(%s) error", opts->certFile);
          goto error;
        }

      }

    }
    ss->sslparm = (unsigned char)0;
    if(!(opts->useSNI == 0))
      ss->sslparm = ss->sslparm | (unsigned char)sslparm_sni;

    if(!(opts->certIgnore == 0))
      ss->sslparm = ss->sslparm | (unsigned char)sslparm_ignore;

    if(!(opts->cipherList == ((char *)NULL)))
    {
      return_value_SSL_CTX_set_cipher_list$18=SSL_CTX_set_cipher_list(ss->ctx, opts->cipherList);
      if(!(return_value_SSL_CTX_set_cipher_list$18 == 0))
        goto __CPROVER_DUMP_L23;

      message(3, "SSL_CTX_set_cipher_list(%s) error", opts->cipherList);
    }

    else
    {

    __CPROVER_DUMP_L23:
      ;
      i = 0;
      for( ; !(i >= 10); i = i + 1)
        if(!(opts->regexp[(signed long int)i] == ((char *)NULL)))
        {
          void *return_value_malloc$19;
          return_value_malloc$19=malloc(sizeof(struct re_pattern_buffer) /*64ul*/ );
          ss->re[(signed long int)i] = (struct re_pattern_buffer *)return_value_malloc$19;
          err=regcomp(ss->re[(signed long int)i], opts->regexp[(signed long int)i], 1 | 1 << 1);
          if(!(err == 0))
          {
            message(3, "RegEx compiling error %d", err);
            goto error;
          }

          if(Debug >= 6)
            message(7, "regexp[%d]=%s", i, opts->regexp[(signed long int)i]);

        }

        else
          ss->re[(signed long int)i] = (struct re_pattern_buffer *)(void *)0;
      if(!(isserver == 0))
      {
        if(!((sslparm_sni & (signed int)ss->sslparm) == 0))
          SSL_CTX_callback_ctrl(ss->ctx, 53, (void (*)(void))ssl_servername_callback);

        if(!(opts->sid_ctx == ((unsigned char *)NULL)))
        {
          signed int ret;
          signed int len;
          unsigned long int return_value_strlen$20;
          return_value_strlen$20=strlen((char *)opts->sid_ctx);
          len = (signed int)return_value_strlen$20;
          ret=SSL_CTX_set_session_id_context(ss->ctx, opts->sid_ctx, (unsigned int)len);
          if(ret == 0)
          {
            len = 32;
            opts->sid_ctx[(signed long int)len] = (unsigned char)0;
            message(3, "Too long sid_ctx, truncated to '%s'", opts->sid_ctx);
            ret=SSL_CTX_set_session_id_context(ss->ctx, opts->sid_ctx, (unsigned int)len);
            if(ret == 0)
              message(3, "SSL_CTX_set_session_id_context error");

          }

        }

        SSL_CTX_ctrl(ss->ctx, 44, (signed long int)(0x0002 | 0x0080), (void *)0);
      }

      return ss;
    }
  }

error:
  ;
  unsigned long int return_value_ERR_get_error$21;
  char *return_value_ERR_error_string$22;
  if(!(opts->verbose == 0))
  {
    return_value_ERR_get_error$21=ERR_get_error();
    return_value_ERR_error_string$22=ERR_error_string(return_value_ERR_get_error$21, (char *)(void *)0);
    message(6, "%s", return_value_ERR_error_string$22);
  }

  exit(1);
}

// mkXhosts
// file stone.c line 7869
struct _XHosts * mkXhosts(signed int nhosts, char **hosts, unsigned short int family, char *mesg)
{
  struct _XHosts *top = (struct _XHosts *)(void *)0;
  struct _XHosts *bot = (struct _XHosts *)(void *)0;
  char xhost[128l];
  signed int allow = 1;
  signed int i;
  char *p;
  i = 0;
  signed int tmp_statement_expression$8;
  char *tmp_post$3;
  for( ; !(i >= nhosts); i = i + 1)
  {
    struct _XHosts *new;
    if(Debug >= 11)
      message(7, "xhost[%d]=\"%s\"", i, hosts[(signed long int)i]);

    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$9;
    return_value___builtin_strcmp$9=__builtin_strcmp(hosts[(signed long int)i], "!");
    tmp_statement_expression$8 = return_value___builtin_strcmp$9;
    if(tmp_statement_expression$8 == 0)
    {
      void *return_value_malloc$1;
      return_value_malloc$1=malloc(sizeof(struct _XHosts) /*32ul*/  - sizeof(struct sockaddr) /*16ul*/ );
      new = (struct _XHosts *)return_value_malloc$1;
      if(new == ((struct _XHosts *)NULL))
        goto memerr;

      new->mbits = (signed short int)-1;
      allow = (signed int)!(allow != 0);
    }

    else
    {
      signed short int mbits = (signed short int)-1;
      signed short int mode = (signed short int)0;
      struct sockaddr_storage ss;
      struct sockaddr *sa = (struct sockaddr *)&ss;
      unsigned int salen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
      strcpy(xhost, hosts[(signed long int)i]);
      char *return_value___builtin_strchr$2;
      return_value___builtin_strchr$2=__builtin_strchr(xhost, 47);
      p = return_value___builtin_strchr$2;
      if(!(p == ((char *)NULL)))
      {
        struct _XHosts ext;
        tmp_post$3 = p;
        p = p + 1l;
        *tmp_post$3 = (char)0;
        ext.mbits = mbits;
        ext.mode = mode;
        ext.xhost.addr.sa_family = family;
        mkXhostsExt(xhost, p, &ext);
        mbits = ext.mbits;
        mode = ext.mode;
        family = ext.xhost.addr.sa_family;
      }

      sa->sa_family = family;
      signed int return_value_host2sa$4;
      return_value_host2sa$4=host2sa(xhost, (char *)(void *)0, sa, &salen, (signed int *)(void *)0, (signed int *)(void *)0, 0);
      if(return_value_host2sa$4 == 0)
        exit(1);

      void *return_value_malloc$5;
      return_value_malloc$5=malloc((sizeof(struct _XHosts) /*32ul*/  - sizeof(struct sockaddr) /*16ul*/ ) + (unsigned long int)salen);
      new = (struct _XHosts *)return_value_malloc$5;
      if(new == ((struct _XHosts *)NULL))
        goto memerr;

      new->xhost.len = salen;
      bcopy((const void *)sa, (void *)&new->xhost.addr, (unsigned long int)salen);
      if(!((signed int)mbits >= 0))
      {
        if((signed int)sa->sa_family == 2)
          mbits = (signed short int)32;

        else
          if((signed int)sa->sa_family == 10)
            mbits = (signed short int)128;

          else
          {
            message(3, "mkXhosts: unknown family=%d", sa->sa_family);
            exit(1);
          }
      }

      new->mbits = mbits;
      new->mode = mode;
      if(!(mesg == ((char *)NULL)))
      {
        char str[128l];
        signed int pos = 0;
        addr2str(&new->xhost.addr, new->xhost.len, str, 127, 1);
        unsigned long int return_value_strlen$6;
        return_value_strlen$6=strlen(str);
        pos = (signed int)return_value_strlen$6;
        snprintf(str + (signed long int)pos, (unsigned long int)(127 - pos), "/%d", new->mbits);
        unsigned long int return_value_strlen$7;
        return_value_strlen$7=strlen(str + (signed long int)pos);
        pos = pos + (signed int)return_value_strlen$7;
        message(7, "%s%s is %s", mesg, (const void *)str, allow != 0 ? "permitted" : "denied");
      }

    }
    new->next = (struct _XHosts *)(void *)0;
    if(top == ((struct _XHosts *)NULL))
      top = new;

    if(!(bot == ((struct _XHosts *)NULL)))
      bot->next = new;

    bot = new;
  }
  return top;

memerr:
  ;
  message(2, "Out of memory");
  exit(1);
}

// mkXhostsExt
// file stone.c line 7767
void mkXhostsExt(char *host, char *str, struct _XHosts *ext)
{
  signed int kind = 0;
  char *top = (char *)(void *)0;
  unsigned long int num = (unsigned long int)0;
  signed int i = 0;
  const unsigned short int **return_value___ctype_b_loc$2;
  _Bool tmp_if_expr$3;
  const unsigned short int **return_value___ctype_b_loc$4;
  _Bool tmp_if_expr$7;
  const unsigned short int **return_value___ctype_b_loc$8;
  signed int tmp_post$1;
  while((_Bool)1)
  {
    if(!(kind == -3))
    {
      if(kind == -2)
        goto __CPROVER_DUMP_L3;

      if(kind == -1)
        goto __CPROVER_DUMP_L4;

      if(kind == 0)
        goto __CPROVER_DUMP_L8;

      if(kind == 1)
        goto __CPROVER_DUMP_L17;

      if(kind == 2 || kind == 3)
        goto __CPROVER_DUMP_L21;

      if(kind == 4)
        goto __CPROVER_DUMP_L22;

    }

    else
    {
      if((signed int)str[(signed long int)i] == 46)
        goto __CPROVER_DUMP_L28;


    __CPROVER_DUMP_L3:
      ;
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)str[(signed long int)i]]) == 0))
        goto __CPROVER_DUMP_L28;


    __CPROVER_DUMP_L4:
      ;
      if((signed int)str[(signed long int)i] == 44)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)str[(signed long int)i] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        kind = 0;
        goto __CPROVER_DUMP_L28;
      }


    error:
      ;
      message(3, "Unknown extension: \"%s\" in %s/%s", &str[(signed long int)i], host, str);
      exit(1);

    __CPROVER_DUMP_L8:
      ;
      top = &str[(signed long int)i];
      return_value___ctype_b_loc$4=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*top]) == 0))
      {
        num = (unsigned long int)((signed int)*top - 48);
        kind = 1;
        goto __CPROVER_DUMP_L28;
      }

      if((signed int)*top == 118)
      {
        i = i + 1;
        if((signed int)top[1l] == 52)
          ext->xhost.addr.sa_family = (unsigned short int)2;

        else
          if((signed int)top[1l] == 54)
            ext->xhost.addr.sa_family = (unsigned short int)10;

          else
            goto error;
        kind = -1;
        goto __CPROVER_DUMP_L28;
      }

      if((signed int)*top == 112)
      {
        const unsigned short int **return_value___ctype_b_loc$6;
        return_value___ctype_b_loc$6=__ctype_b_loc();
        if(!((2048 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)top[1l]]) == 0))
        {
          signed int return_value_atoi$5;
          return_value_atoi$5=atoi(top + (signed long int)1);
          ext->mode = (signed short int)return_value_atoi$5;
        }

        else
          ext->mode = (signed short int)1;
        kind = -2;
        goto __CPROVER_DUMP_L28;
      }

      goto error;

    __CPROVER_DUMP_L17:
      ;
      if((signed int)str[(signed long int)i] == 44)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = (signed int)str[(signed long int)i] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
      {
        ext->mbits = (signed short int)num;
        if((signed int)ext->mbits >= 33)
          ext->xhost.addr.sa_family = (unsigned short int)10;

        if((signed int)ext->mbits >= 129)
          goto error;

        kind = 0;
        goto __CPROVER_DUMP_L28;
      }


    __CPROVER_DUMP_L21:
      ;
      if((signed int)str[(signed long int)i] == 46)
      {
        i = i + 1;
        num = num << 8;
        kind = kind + 1;
      }


    __CPROVER_DUMP_L22:
      ;
      return_value___ctype_b_loc$8=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc$8)[(signed long int)(signed int)str[(signed long int)i]]) == 0))
      {
        num = num & (unsigned long int)0xFFFFFF00 | (num & (unsigned long int)0xFF) * (unsigned long int)10 + (unsigned long int)((signed int)str[(signed long int)i] - 48);
        goto __CPROVER_DUMP_L28;
      }

      ext->xhost.addr.sa_family = (unsigned short int)2;
      ext->mbits = (signed short int)0;
      for( ; !(num == 0ul) && !((signed int)ext->mbits >= 32); ext->mbits = ext->mbits + 1)
      {
        if((2147483648ul & num) == 0ul)
        {
          message(3, "netmask by bits pattern is deprecated: %s/%s", host, top);
          exit(1);
        }

        num = num << 1;
      }
      i = i - 1;
      kind = -1;
      goto __CPROVER_DUMP_L28;
    }
    message(3, "Can't happen: kind=%d in mkXhostsExt", kind);
    exit(1);

  __CPROVER_DUMP_L28:
    ;
    tmp_post$1 = i;
    i = i + 1;
    if(str[(signed long int)tmp_post$1] == 0)
      break;

  }
  if(Debug >= 10)
    message(7, "mkXhostsExt: host=%s ext=%s family=%d mbits=%d mode=%d", host, str, ext->xhost.addr.sa_family, ext->mbits, ext->mode);

}

// mkstone
// file stone.c line 8053
struct _Stone * mkstone(char *dhost, char *dserv, char *host, char *serv, signed int nhosts, char **hosts, signed int proto)
{
  struct _Stone *stone;
  struct _Stone *st;
  struct sockaddr_storage ss;
  struct sockaddr *sa = (struct sockaddr *)&ss;
  unsigned int salen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  signed int satype;
  signed int saproto = 0;
  unsigned short int family;
  char *mesg;
  char mkstone$$1$$str[128l];
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct _Stone) /*144ul*/ );
  stone = (struct _Stone *)return_value_calloc$1;
  if(stone == ((struct _Stone *)NULL))
  {
    message(2, "Out of memory");
    exit(1);
  }

  stone->next = (struct _Stone *)(void *)0;
  stone->children = (struct _Stone *)(void *)0;
  stone->parent = (struct _Stone *)(void *)0;
  stone->common = 0x0003;
  stone->p = (char *)(void *)0;
  stone->timeout = PairTimeOut;
  if(!((proto & proto_udp_s) == 0))
  {
    satype = 2;
    saproto = 17;
  }

  else
  {
    satype = 1;
    saproto = 6;
  }
  unsigned short int tmp_statement_expression$3;
  unsigned short int tmp_statement_expression$5;
  if(!((proto & proto_unix_s) == 0))
  {
    struct sockaddr_un *mkstone$$1$$4$$sun = (struct sockaddr_un *)sa;
    salen = (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ ;
    bzero((void *)sa, (unsigned long int)salen);
    mkstone$$1$$4$$sun->sun_family = (unsigned short int)1;
    snprintf(mkstone$$1$$4$$sun->sun_path, sizeof(char [108l]) /*108ul*/  - (unsigned long int)1, "%s", host);
    saproto = 0;
  }

  else
    if(!((proto & proto_v6_s) == 0))
    {
      struct sockaddr_in6 *sin6p = (struct sockaddr_in6 *)sa;
      sa->sa_family = (unsigned short int)10;
      signed int return_value_host2sa$2;
      return_value_host2sa$2=host2sa(host, serv, sa, &salen, &satype, &saproto, 0x0001);
      if(return_value_host2sa$2 == 0)
        exit(1);

      unsigned short int __v;
      unsigned short int mkstone$$1$$5$$1$$__x = (unsigned short int)sin6p->sin6_port;
      asm("rorw $8, %w0" : "=r"(__v) : "0"(mkstone$$1$$5$$1$$__x) : "cc");
      tmp_statement_expression$3 = __v;
      stone->port = (signed int)tmp_statement_expression$3;
    }

    else
    {
      struct sockaddr_in *sinp = (struct sockaddr_in *)sa;
      sa->sa_family = (unsigned short int)2;
      signed int return_value_host2sa$4;
      return_value_host2sa$4=host2sa(host, serv, sa, &salen, &satype, &saproto, 0x0001);
      if(return_value_host2sa$4 == 0)
        exit(1);

      unsigned short int mkstone$$1$$6$$1$$__v;
      unsigned short int __x = (unsigned short int)sinp->sin_port;
      asm("rorw $8, %w0" : "=r"(mkstone$$1$$6$$1$$__v) : "0"(__x) : "cc");
      tmp_statement_expression$5 = mkstone$$1$$6$$1$$__v;
      stone->port = (signed int)tmp_statement_expression$5;
    }
  if((proto & proto_command) == 0x0400 || (proto & proto_command) == 0x0500 || (proto & proto_command) == 0x0600)
  {
    stone->ndsts = (signed short int)1;
    if((proto & proto_command) == 0x0600)
    {
      void *return_value_malloc$6;
      return_value_malloc$6=malloc(sizeof(struct anonymous$0 *) /*8ul*/  + sizeof(struct _PortXHosts *) /*8ul*/ );
      stone->dsts = (struct anonymous$0 **)return_value_malloc$6;
      if(!(stone->dsts == ((struct anonymous$0 **)NULL)))
        ((struct _PortXHosts **)stone->dsts)[(signed long int)1] = portXHosts;

    }

    else
    {
      void *return_value_malloc$7;
      return_value_malloc$7=malloc(sizeof(struct anonymous$0 *) /*8ul*/ );
      stone->dsts = (struct anonymous$0 **)return_value_malloc$7;
    }
    if(stone->dsts == ((struct anonymous$0 **)NULL))
      goto memerr;

    stone->dsts[(signed long int)0]=saDup(sa, salen);
  }

  else
    if(!((proto & proto_unix_d) == 0))
    {
      struct sockaddr_storage dss;
      struct sockaddr_un *sun = (struct sockaddr_un *)&dss;
      stone->ndsts = (signed short int)1;
      void *return_value_malloc$8;
      return_value_malloc$8=malloc(sizeof(struct anonymous$0 *) /*8ul*/ );
      stone->dsts = (struct anonymous$0 **)return_value_malloc$8;
      if(stone->dsts == ((struct anonymous$0 **)NULL))
        goto memerr;

      bzero((void *)sun, sizeof(struct sockaddr_storage) /*128ul*/ );
      sun->sun_family = (unsigned short int)1;
      snprintf(sun->sun_path, sizeof(char [108l]) /*108ul*/  - (unsigned long int)1, "%s", dhost);
      stone->dsts[(signed long int)0]=saDup((struct sockaddr *)sun, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
      if(*stone->dsts == ((struct anonymous$0 *)NULL))
        goto memerr;

    }

    else
    {
      struct sockaddr_storage mkstone$$1$$9$$dss;
      struct sockaddr *dsa = (struct sockaddr *)&mkstone$$1$$9$$dss;
      unsigned int dsalen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
      signed int dsatype;
      signed int dsaproto;
      struct _LBSet *lbset;
      if(!((proto & proto_v6_d) == 0))
        dsa->sa_family = (unsigned short int)10;

      else
        dsa->sa_family = (unsigned short int)2;
      if(!((proto & proto_udp_d) == 0))
      {
        dsatype = 2;
        dsaproto = 17;
      }

      else
      {
        dsatype = 1;
        dsaproto = 6;
      }
      signed int return_value_host2sa$9;
      return_value_host2sa$9=host2sa(dhost, dserv, dsa, &dsalen, &dsatype, &dsaproto, 0);
      if(return_value_host2sa$9 == 0)
        exit(1);

      lbset=findLBSet(dsa);
      if(!(lbset == ((struct _LBSet *)NULL)))
      {
        stone->ndsts = lbset->ndsts;
        stone->dsts = lbset->dsts;
      }

      else
      {
        stone->ndsts = (signed short int)1;
        void *return_value_malloc$10;
        return_value_malloc$10=malloc(sizeof(struct anonymous$0 *) /*8ul*/ );
        stone->dsts = (struct anonymous$0 **)return_value_malloc$10;
        if(stone->dsts == ((struct anonymous$0 **)NULL))
        {

        memerr:
          ;
          message(2, "Out of memory");
          exit(1);
        }

        stone->dsts[(signed long int)0]=saDup(dsa, dsalen);
        if(*stone->dsts == ((struct anonymous$0 *)NULL))
          goto memerr;

      }
    }
  stone->proto = proto;
  stone->from = ConnectFrom;
  signed int return_value_reusestone$17;
  return_value_reusestone$17=reusestone(stone);
  if(return_value_reusestone$17 == 0)
  {
    stone->sd=socket((signed int)sa->sa_family, satype, saproto);
    if(!(stone->sd >= 0))
    {
      signed int *return_value___errno_location$11;
      return_value___errno_location$11=__errno_location();
      message(3, "stone %d: Can't get socket family=%d type=%d proto=%d err=%d", stone->sd, sa->sa_family, satype, saproto, *return_value___errno_location$11);
      exit(1);
    }

    if(!((proto & proto_ip_only_s) == 0) && !((proto & proto_v6_s) == 0))
    {
      signed int mkstone$$1$$10$$2$$i = 1;
      setsockopt(stone->sd, 41, 26, (const void *)(char *)&mkstone$$1$$10$$2$$i, (unsigned int)sizeof(signed int) /*4ul*/ );
    }

    if((proto & proto_udp_s) == 0 && !(ReuseAddr == 0))
    {
      signed int i = 1;
      setsockopt(stone->sd, 1, 2, (const void *)(char *)&i, (unsigned int)sizeof(signed int) /*4ul*/ );
    }

    st=getStone(sa, salen, proto);
    if(!(st == ((struct _Stone *)NULL)))
    {
      close(stone->sd);
      stone->parent = st;
      stone->children = st->children;
      st->children = stone;
      stone->sd = st->sd;
    }

    else
      if(DryRun == 0)
      {
        signed int return_value_bind$13;
        return_value_bind$13=bind(stone->sd, sa, salen);
        if(!(return_value_bind$13 >= 0))
        {
          char str[128l];
          addrport2str(sa, salen, 0, str, 127, 0);
          str[(signed long int)127] = (char)0;
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          message(3, "stone %d: Can't bind %s err=%d", stone->sd, (const void *)str, *return_value___errno_location$12);
          exit(1);
        }

        if((stone->proto & proto_block_s) == 0)
          fcntl(stone->sd, 4, 04000);

        if(stone->port == 0)
        {
          salen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
          signed int return_value_getsockname$14;
          return_value_getsockname$14=getsockname(stone->sd, sa, &salen);
          if(return_value_getsockname$14 >= 0)
            stone->port=getport(sa);

        }

        if((proto & proto_udp_s) == 0)
        {
          signed int return_value_listen$16;
          return_value_listen$16=listen(stone->sd, BacklogMax);
          if(!(return_value_listen$16 >= 0))
          {
            signed int *return_value___errno_location$15;
            return_value___errno_location$15=__errno_location();
            message(3, "stone %d: Can't listen err=%d", stone->sd, *return_value___errno_location$15);
            exit(1);
          }

        }

      }

  }

  stone->listen=saDup(sa, salen);
  if(!((proto & proto_ssl_s) == 0))
  {
    exPatOpts(&ServerOpts, host, dhost);
    stone->ssl_server=mkStoneSSL(&ServerOpts, 1);
    if(!(stone->ssl_server->lbmod == 0))
    {
      if(!((signed int)stone->ndsts >= (signed int)stone->ssl_server->lbmod))
      {
        message(4, "LB set (%d) < lbmod (%d)", stone->ndsts, stone->ssl_server->lbmod);
        stone->ssl_server->lbmod = (unsigned char)stone->ndsts;
      }

    }

  }

  else
    stone->ssl_server = (struct anonymous$12 *)(void *)0;
  _Bool tmp_if_expr$18;
  if(!((proto & proto_ssl_d) == 0))
  {
    exPatOpts(&ClientOpts, host, dhost);
    stone->ssl_client=mkStoneSSL(&ClientOpts, 0);
    if(!(stone->ssl_client->name == ((char *)NULL)))
      tmp_if_expr$18 = *stone->ssl_client->name != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$18 = (_Bool)0;
    if(!tmp_if_expr$18)
      stone->ssl_client->name = dhost;

  }

  else
    stone->ssl_client = (struct anonymous$12 *)(void *)0;
  mesg = (char *)(void *)0;
  if(Debug >= 2)
  {
    mesg = mkstone$$1$$str;
    if((proto & proto_command) == 0x0600)
      snprintf(mesg, (unsigned long int)127, "stone %d: using proxy by ", stone->sd);

    else
      if((proto & proto_command) == 0x0400)
        snprintf(mesg, (unsigned long int)127, "stone %d: health check by ", stone->sd);

      else
        if((proto & proto_command) == 0x0500)
          snprintf(mesg, (unsigned long int)127, "stone %d: ident query by ", stone->sd);

        else
        {
          char addrport[128l];
          addrport2str(&stone->dsts[(signed long int)0]->addr, stone->dsts[(signed long int)0]->len, stone->proto & (proto_udp_d | proto_command | proto_ohttp_d | proto_base_d | proto_v6_d | proto_ip_only_d | proto_ssl_d | proto_nobackup), addrport, 127, 0);
          addrport[(signed long int)127] = (char)0;
          snprintf(mesg, (unsigned long int)127, "stone %d: connecting to %s by ", stone->sd, (const void *)addrport);
        }
  }

  family = (unsigned short int)2;
  _Bool tmp_if_expr$19;
  if(!((stone->proto & proto_v6_s) == 0))
  {
    if(host == ((char *)NULL))
      tmp_if_expr$19 = !((stone->proto & proto_ip_only_s) != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$19 = (_Bool)0;
    if(tmp_if_expr$19)
      family = (unsigned short int)0;

    else
      family = (unsigned short int)10;
  }

  stone->xhosts=mkXhosts(nhosts, hosts, family, mesg);
  char *return_value_stone2str$20;
  return_value_stone2str$20=stone2str(stone, mkstone$$1$$str, 127);
  message(6, "%s", return_value_stone2str$20);
  stone->backups = (struct _Backup **)(void *)0;
  if((proto & proto_nobackup) == 0 && !((proto & proto_command) == 0x0400) && !((proto & proto_command) == 0x0500) && !((proto & proto_command) == 0x0600))
  {
    struct _Backup *bs[100l];
    signed int found = 0;
    signed int mkstone$$1$$17$$i = 0;
    for( ; !(mkstone$$1$$17$$i >= (signed int)stone->ndsts); mkstone$$1$$17$$i = mkstone$$1$$17$$i + 1)
    {
      bs[(signed long int)mkstone$$1$$17$$i]=findBackup(&stone->dsts[(signed long int)mkstone$$1$$17$$i]->addr);
      if(!(bs[(signed long int)mkstone$$1$$17$$i] == ((struct _Backup *)NULL)))
      {
        found = 1;
        bs[(signed long int)mkstone$$1$$17$$i]->used = (signed short int)1;
      }

    }
    if(!(found == 0))
    {
      void *return_value_malloc$21;
      return_value_malloc$21=malloc(sizeof(struct _Backup *) /*8ul*/  * (unsigned long int)stone->ndsts);
      stone->backups = (struct _Backup **)return_value_malloc$21;
      if(!(stone->backups == ((struct _Backup **)NULL)))
      {
        mkstone$$1$$17$$i = 0;
        for( ; !(mkstone$$1$$17$$i >= (signed int)stone->ndsts); mkstone$$1$$17$$i = mkstone$$1$$17$$i + 1)
          stone->backups[(signed long int)mkstone$$1$$17$$i] = bs[(signed long int)mkstone$$1$$17$$i];
      }

    }

  }

  return stone;
}

// modPairDest
// file stone.c line 2438
signed int modPairDest(struct _Pair *p1, struct sockaddr *dst, unsigned int dstlenmax)
{
  struct _Pair *p2;
  unsigned int dstlen = (unsigned int)0;
  signed int offset = -1;
  struct ssl_st *ssl;
  p2 = p1->pair;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  if(p2 == ((struct _Pair *)NULL))
    return -1;

  else
  {
    ssl = p2->ssl;
    if(!(ssl == ((struct ssl_st *)NULL)))
    {
      struct ssl_session_st *sess;
      sess=SSL_get1_session(ssl);
      if(!(sess == ((struct ssl_session_st *)NULL)))
      {
        unsigned char **match;
        if(Debug >= 3)
        {
          char str[65l];
          signed int len = (signed int)sess->session_id_length;
          signed int modPairDest$$1$$1$$1$$1$$i;
          if(len >= 33)
            len = 32;

          modPairDest$$1$$1$$1$$1$$i = 0;
          for( ; !(modPairDest$$1$$1$$1$$1$$i >= len); modPairDest$$1$$1$$1$$1$$i = modPairDest$$1$$1$$1$$1$$i + 1)
            sprintf(&str[(signed long int)(modPairDest$$1$$1$$1$$1$$i * 2)], "%02x", sess->session_id[(signed long int)modPairDest$$1$$1$$1$$1$$i]);
          str[(signed long int)(modPairDest$$1$$1$$1$$1$$i * 2)] = (char)0;
          message(7, "%d TCP %d: SSL session ID=%s len=%d", p2->stone->sd, p2->sd, (const void *)str, sess->session_id_length);
        }

        void *return_value_SSL_SESSION_get_ex_data$1;
        return_value_SSL_SESSION_get_ex_data$1=SSL_SESSION_get_ex_data(sess, MatchIndex);
        match = (unsigned char **)return_value_SSL_SESSION_get_ex_data$1;
        if(!(match == ((unsigned char **)NULL)))
        {
          if(!(p2->stone->ssl_server == ((struct anonymous$12 *)NULL)))
          {
            signed int lbparm = (signed int)p2->stone->ssl_server->lbparm;
            signed int lbmod = (signed int)p2->stone->ssl_server->lbmod;
            unsigned char *s;
            if(lbparm >= 0 && !(lbparm >= 10))
              s = match[(signed long int)lbparm];

            else
              s = match[(signed long int)1];
            if(s == ((unsigned char *)NULL))
              s = match[(signed long int)0];

            if(!(s == ((unsigned char *)NULL)) && !(lbmod == 0))
            {
              signed int offset2 = 0;
              offset = 0;
              for( ; !(*s == 0); s = s + 1l)
              {
                if(offset2 >= 0)
                {
                  if((signed int)*s >= 48)
                    tmp_if_expr$2 = (signed int)*s <= 57 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$2 = (_Bool)0;
                  if(tmp_if_expr$2)
                    offset2 = offset2 * 10 + ((signed int)*s - 48);

                  else
                    offset2 = -1;
                }

                offset = offset << 6;
                offset = offset + ((signed int)*s & 0x3f);
              }
              if(offset2 >= 1)
                offset = offset2;

              offset = offset % lbmod;
              if(Debug >= 3)
                message(7, "%d TCP %d: pair %d lb%d=%d", p1->stone->sd, p1->sd, p2->sd, lbparm, offset);

            }

          }

        }

        SSL_SESSION_free(sess);
      }

    }

    if(!(offset >= 0))
    {
      if((signed int)p1->stone->ndsts >= 2)
      {
        signed int n = (signed int)p1->stone->ndsts;
        offset = (p1->stone->proto & state_mask) % n;
        if(!(p1->stone->backups == ((struct _Backup **)NULL)))
        {
          signed int i = 0;
          for( ; !(i >= n); i = i + 1)
          {
            struct _Backup *b = p1->stone->backups[(signed long int)((offset + i) % n)];
            if(b == ((struct _Backup *)NULL))
              tmp_if_expr$3 = (_Bool)1;

            else
              tmp_if_expr$3 = (signed int)b->bn == 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$3)
            {
              offset = (offset + i) % n;
              break;
            }

            if(Debug >= 9)
              message(7, "%d TCP %d: ofs=%d is unhealthy, skipped", p1->stone->sd, p1->sd, (offset + i) % n);

          }
        }

        p1->stone->proto = p1->stone->proto & ~state_mask | offset + 1 & state_mask;
      }

    }

    if(offset >= 0)
    {
      dstlen = p1->stone->dsts[(signed long int)offset]->len;
      if(!(dstlen >= dstlenmax))
        bcopy((const void *)&p1->stone->dsts[(signed long int)offset]->addr, (void *)dst, (unsigned long int)dstlen);

    }

    if(!(p1->stone->backups == ((struct _Backup **)NULL)))
    {
      struct _Backup *backup;
      if(offset >= 0)
        backup = p1->stone->backups[(signed long int)offset];

      else
        backup = p1->stone->backups[(signed long int)0];
      if(!(backup == ((struct _Backup *)NULL)))
      {
        backup->used = (signed short int)2;
        if(!(backup->bn == 0))
        {
          dstlen = backup->backup->len;
          if(!(dstlen >= dstlenmax))
            bcopy((const void *)&backup->backup->addr, (void *)dst, (unsigned long int)dstlen);

        }

      }

    }

    return (signed int)dstlen;
  }
}

// nConns
// file stone.c line 5746
signed int nConns(void)
{
  signed int n = 0;
  struct _Conn *conn = conns.next;
  for( ; !(conn == ((struct _Conn *)NULL)); conn = conn->next)
    n = n + 1;
  return n;
}

// nOrigins
// file stone.c line 5753
signed int nOrigins(void)
{
  signed int n = 0;
  struct _Origin *origin = OriginTop;
  for( ; !(origin == ((struct _Origin *)NULL)); origin = origin->next)
    if(!(origin->from == ((struct anonymous$0 *)NULL)))
      n = n + 1;

  return n;
}

// nPairs
// file stone.c line 5738
signed int nPairs(struct _Pair *top)
{
  signed int n = 0;
  struct _Pair *pair = top;
  for( ; !(pair == ((struct _Pair *)NULL)); pair = pair->next)
    if(!(pair->clock == -1l))
      n = n + 1;

  return n;
}

// nStones
// file stone.c line 5731
signed int nStones(void)
{
  signed int n = 0;
  struct _Stone *stone = stones;
  for( ; !(stone == ((struct _Stone *)NULL)); stone = stone->next)
    n = n + 1;
  return n;
}

// newExData
// file stone.c line 2428
struct _ExBuf * newExData(struct _Pair *pair, signed int type)
{
  struct _ExBuf *ex;
  ex=getExBuf();
  if(ex == ((struct _ExBuf *)NULL))
    return (struct _ExBuf *)(void *)0;

  else
  {
    *((signed int *)ex->buf) = type;
    ex->next = pair->d;
    pair->d = ex;
    return ex;
  }
}

// newMatch
// file stone.c line 7063
static signed int newMatch(void *parent, void *ptr, struct crypto_ex_data_st *ad, signed int idx, signed long int argl, void *argp)
{
  char **match;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(char *) /*8ul*/  * (unsigned long int)(9 + 1));
  match = (char **)return_value_malloc$1;
  signed int tmp_post$2;
  if(!(match == ((char **)NULL)))
  {
    signed int i = 0;
    for( ; !(i >= 10); i = i + 1)
      match[(signed long int)i] = (char *)(void *)0;
    if(Debug >= 5)
    {
      tmp_post$2 = NewMatchCount;
      NewMatchCount = NewMatchCount + 1;
      message(7, "newMatch %d: %x", tmp_post$2, (signed int)match);
    }

    signed int return_value_CRYPTO_set_ex_data$3;
    return_value_CRYPTO_set_ex_data$3=CRYPTO_set_ex_data(ad, idx, (void *)match);
    return return_value_CRYPTO_set_ex_data$3;
  }

  return 0;
}

// newPair
// file stone.c line 3536
struct _Pair * newPair(void)
{
  struct _Pair *pair = (struct _Pair *)(void *)0;
  waitMutex(8);
  if(!(freePairs == ((struct _Pair *)NULL)))
  {
    pair = freePairs;
    freePairs = pair->next;
    nFreePairs = nFreePairs - 1;
  }

  freeMutex(8);
  void *return_value_malloc$1;
  if(pair == ((struct _Pair *)NULL))
  {
    return_value_malloc$1=malloc(sizeof(struct _Pair) /*136ul*/ );
    pair = (struct _Pair *)return_value_malloc$1;
  }

  if(!(pair == ((struct _Pair *)NULL)))
  {
    pair->common = 0x0001;
    pair->t=getExBuf();
    if(pair->t == ((struct _ExBuf *)NULL))
    {
      free((void *)pair);
      return (struct _Pair *)(void *)0;
    }

    pair->nbuf = 1;
    pair->sd = -1;
    pair->stone = (struct _Stone *)(void *)0;
    pair->proto = 0;
    pair->xhost = (struct _XHosts *)(void *)0;
    pair->timeout = PairTimeOut;
    pair->count = 0;
    pair->b = pair->t;
    pair->d = (struct _ExBuf *)(void *)0;
    pair->log = (struct _TimeLog *)(void *)0;
    pair->tx = 0;
    pair->rx = 0;
    pair->loop = 0;
    time(&pair->clock);
    pair->pair = (struct _Pair *)(void *)0;
    pair->next = (struct _Pair *)(void *)0;
    pair->prev = (struct _Pair *)(void *)0;
    pair->ssl = (struct ssl_st *)(void *)0;
    pair->ssl_flag = 0;
  }

  return pair;
}

// openconfig
// file stone.c line 8624
struct _IO_FILE * openconfig(void)
{
  signed int pfd[2l];
  char host[64l];
  _Bool tmp_if_expr$17;
  if(!(CppCommand == ((char *)NULL)))
    tmp_if_expr$17 = (signed int)*CppCommand != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$17 = (_Bool)0;
  signed int tmp_post$5;
  const unsigned short int **return_value___ctype_b_loc$6;
  struct _IO_FILE *return_value_fopen$16;
  if(tmp_if_expr$17)
  {
    signed int return_value_gethostname$2;
    return_value_gethostname$2=gethostname(host, (unsigned long int)(64 - 1));
    if(!(return_value_gethostname$2 >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      message(3, "gethostname err=%d", *return_value___errno_location$1);
      exit(1);
    }

    signed int return_value_pipe$4;
    return_value_pipe$4=pipe(pfd);
    if(!(return_value_pipe$4 >= 0))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      message(3, "Can't get pipe err=%d", *return_value___errno_location$3);
      exit(1);
    }

    signed int return_value_fork$14;
    return_value_fork$14=fork();
    if(return_value_fork$14 == 0)
    {
      char *argv[1024l];
      signed int i = 0;
      char buf[2048l];
      signed int len = 0;
      char *p;
      if(!(CppOptions == ((char *)NULL)))
        snprintf(buf, (unsigned long int)(2048 - 1), "%s %s", CppCommand, CppOptions);

      else
        __builtin_strncpy(buf, CppCommand, (unsigned long int)(2048 - 1));
      argv[(signed long int)i] = "cpp";
      while(!(buf[(signed long int)len] == 0))
      {
        const unsigned short int **return_value___ctype_b_loc$7;
        return_value___ctype_b_loc$7=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)buf[(signed long int)len]]) == 0))
        {
          tmp_post$5 = len;
          len = len + 1;
          buf[(signed long int)tmp_post$5] = (char)0;
          for( ; !(buf[(signed long int)len] == 0); len = len + 1)
          {
            return_value___ctype_b_loc$6=__ctype_b_loc();
            if((8192 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)buf[(signed long int)len]]) == 0)
              break;

          }
          if(!(buf[(signed long int)len] == 0))
          {
            i = i + 1;
            argv[(signed long int)i] = &buf[(signed long int)len];
          }

          else
            break;
        }

        len = len + 1;
      }
      len = len + 1;
      i = i + 1;
      argv[(signed long int)i] = buf + (signed long int)len;
      snprintf(argv[(signed long int)i], (unsigned long int)(2048 - len), "-DHOST=%s", (const void *)host);
      unsigned long int return_value_strlen$8;
      return_value_strlen$8=strlen(argv[(signed long int)i]);
      len = len + (signed int)(return_value_strlen$8 + (unsigned long int)1);
      i = i + 1;
      argv[(signed long int)i] = buf + (signed long int)len;
      p = host;
      for( ; !(*p == 0); p = p + 1l)
        if((signed int)*p == 46)
          *p = (char)95;

      snprintf(argv[(signed long int)i], (unsigned long int)(2048 - len), "-DHOST_%s", (const void *)host);
      unsigned long int return_value_strlen$9;
      return_value_strlen$9=strlen(argv[(signed long int)i]);
      len = len + (signed int)(return_value_strlen$9 + (unsigned long int)1);
      char *return_value_getenv$12;
      return_value_getenv$12=getenv("HOME");
      if(!(return_value_getenv$12 == ((char *)NULL)))
      {
        i = i + 1;
        argv[(signed long int)i] = buf + (signed long int)len;
        char *return_value_getenv$10;
        return_value_getenv$10=getenv("HOME");
        snprintf(argv[(signed long int)i], (unsigned long int)(2048 - len), "-DHOME=%s", return_value_getenv$10);
        unsigned long int return_value_strlen$11;
        return_value_strlen$11=strlen(argv[(signed long int)i]);
        len = len + (signed int)(return_value_strlen$11 + (unsigned long int)1);
      }

      i = i + 1;
      argv[(signed long int)i] = ConfigFile;
      i = i + 1;
      argv[(signed long int)i] = (char *)(void *)0;
      close(pfd[(signed long int)0]);
      close(1);
      dup(pfd[(signed long int)1]);
      close(pfd[(signed long int)1]);
      if(Debug >= 10)
      {
        char str[2048l];
        snprintf(str, (unsigned long int)2048, "%s: ", (const void *)buf);
        i = 0;
        for( ; !(argv[(signed long int)i] == ((char *)NULL)); i = i + 1)
        {
          unsigned long int return_value_strlen$13;
          return_value_strlen$13=strlen(str);
          len = (signed int)return_value_strlen$13;
          snprintf(&str[(signed long int)len], (unsigned long int)(2048 - len), " %s", argv[(signed long int)i]);
        }
        message(7, "%s", (const void *)str);
      }

      execv(buf, argv);
    }

    close(pfd[(signed long int)1]);
    struct _IO_FILE *return_value_fdopen$15;
    return_value_fdopen$15=fdopen(pfd[(signed long int)0], "r");
    return return_value_fdopen$15;
  }

  else
  {
    return_value_fopen$16=fopen(ConfigFile, "r");
    return return_value_fopen$16;
  }
}

// packet_dump
// file stone.c line 993
void packet_dump(char *head, char *buf, signed int len, struct _XHosts *xhost)
{
  char line[1025l];
  signed int mode = (signed int)xhost->mode & 0xF;
  signed int i;
  signed int j;
  signed int k;
  signed int l;
  signed int nb = 8;
  l = 0;
  k = l;
  j = k;
  i = 0;
  signed int tmp_post$1;
  _Bool tmp_if_expr$4;
  signed int tmp_post$2;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  signed int tmp_post$8;
  _Bool tmp_if_expr$11;
  signed int tmp_post$9;
  signed int tmp_post$10;
  for( ; !(i >= len); i = i + j)
  {
    if(!(mode >= 3))
    {
      nb = 16;
      l = 0;
      tmp_post$1 = l;
      l = l + 1;
      line[(signed long int)tmp_post$1] = (char)32;
      j = 0;
      for( ; j / 10 >= k && !(i + j >= len) && !(l >= 1024); j = j + 1)
      {
        if((signed int)buf[(signed long int)(i + j)] >= 32)
          tmp_if_expr$4 = (signed int)buf[(signed long int)(i + j)] <= 126 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(tmp_if_expr$4)
        {
          tmp_post$2 = l;
          l = l + 1;
          line[(signed long int)tmp_post$2] = buf[(signed long int)(i + j)];
        }

        else
        {
          sprintf(&line[(signed long int)l], "<%02x>", buf[(signed long int)(i + j)]);
          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(&line[(signed long int)l]);
          l = l + (signed int)return_value_strlen$3;
          if((signed int)buf[(signed long int)(i + j)] == 10)
          {
            k = 0;
            j = j + 1;
            break;
          }

          if(!((signed int)buf[(signed long int)(i + j)] == 9))
          {
            if(!((signed int)buf[(signed long int)(i + j)] == 13))
            {
              if(!((signed int)buf[(signed long int)(i + j)] == 27))
                k = k + 1;

            }

          }

        }
      }
    }

    if(!(j / 10 >= k) || !(nb >= 16))
    {
      l = 0;
      j = l;
      j = 0;
      for( ; !(i + j >= len) && !(j >= nb); j = j + 1)
      {
        if(mode == 1)
        {
          if((signed int)buf[(signed long int)(i + j)] >= 32)
            tmp_if_expr$5 = (signed int)buf[(signed long int)(i + j)] <= 126 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$5 = (_Bool)0;
          tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$6 = (_Bool)0;
        if(tmp_if_expr$6)
          sprintf(&line[(signed long int)l], " '%c", buf[(signed long int)(i + j)]);

        else
        {
          sprintf(&line[(signed long int)l], " %02x", (unsigned char)buf[(signed long int)(i + j)]);
          if((signed int)buf[(signed long int)(i + j)] == 10)
            k = 0;

          else
            k = k + 1;
        }
        unsigned long int return_value_strlen$7;
        return_value_strlen$7=strlen(&line[(signed long int)l]);
        l = l + (signed int)return_value_strlen$7;
      }
      if(!(nb >= 16))
      {
        for( ; !(l >= 3 * nb + 2); line[(signed long int)tmp_post$8] = (char)32)
        {
          tmp_post$8 = l;
          l = l + 1;
        }
        j = 0;
        for( ; !(i + j >= len) && !(j >= nb); j = j + 1)
        {
          if((signed int)buf[(signed long int)(i + j)] >= 32)
            tmp_if_expr$11 = (signed int)buf[(signed long int)(i + j)] <= 126 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$11 = (_Bool)0;
          if(tmp_if_expr$11)
          {
            tmp_post$9 = l;
            l = l + 1;
            line[(signed long int)tmp_post$9] = buf[(signed long int)(i + j)];
          }

          else
          {
            tmp_post$10 = l;
            l = l + 1;
            line[(signed long int)tmp_post$10] = (char)46;
          }
        }
      }

    }

    line[(signed long int)l] = (char)0;
    message(7, "%s%s", head, (const void *)line);
  }
}

// passwd_callback
// file stone.c line 7298
static signed int passwd_callback(char *buf, signed int size, signed int rwflag, void *passwd)
{
  __builtin_strncpy(buf, (char *)passwd, (unsigned long int)size);
  buf[(signed long int)(size - 1)] = (char)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(buf);
  return (signed int)return_value_strlen$1;
}

// printSSLinfo
// file stone.c line 3225
static void printSSLinfo(signed int pri, struct ssl_st *ssl)
{
  struct x509_st *peer;
  char *p;
  const struct ssl_cipher_st *return_value_SSL_get_current_cipher$1;
  return_value_SSL_get_current_cipher$1=SSL_get_current_cipher(ssl);
  const char *return_value_SSL_CIPHER_get_name$2;
  return_value_SSL_CIPHER_get_name$2=SSL_CIPHER_get_name(return_value_SSL_get_current_cipher$1);
  p = (char *)return_value_SSL_CIPHER_get_name$2;
  if(p == ((char *)NULL))
    p = "<NULL>";

  message(pri, "[SSL cipher=%s]", p);
  peer=SSL_get_peer_certificate(ssl);
  signed long int return_value_ASN1_INTEGER_get$3;
  if(!(peer == ((struct x509_st *)NULL)))
  {
    char buf[1025l];
    struct asn1_string_st *n;
    n=X509_get_serialNumber(peer);
    if(!(n == ((struct asn1_string_st *)NULL)))
    {
      return_value_ASN1_INTEGER_get$3=ASN1_INTEGER_get(n);
      message(pri, "[SSL serial=%lx]", return_value_ASN1_INTEGER_get$3);
    }

    buf[(signed long int)1024] = (char)0;
    struct X509_name_st *return_value_X509_get_subject_name$4;
    return_value_X509_get_subject_name$4=X509_get_subject_name(peer);
    char *return_value_X509_NAME_oneline$5;
    return_value_X509_NAME_oneline$5=X509_NAME_oneline(return_value_X509_get_subject_name$4, buf, 1024);
    if(!(return_value_X509_NAME_oneline$5 == ((char *)NULL)))
      message(pri, "[SSL subject=%s]", (const void *)buf);

    struct X509_name_st *return_value_X509_get_issuer_name$6;
    return_value_X509_get_issuer_name$6=X509_get_issuer_name(peer);
    char *return_value_X509_NAME_oneline$7;
    return_value_X509_NAME_oneline$7=X509_NAME_oneline(return_value_X509_get_issuer_name$6, buf, 1024);
    if(!(return_value_X509_NAME_oneline$7 == ((char *)NULL)))
      message(pri, "[SSL issuer=%s]", (const void *)buf);

    X509_free(peer);
  }

}

// priority
// file stone.c line 984
signed int priority(struct _Pair *pair)
{
  signed int pri = 3;
  if(!(pair == ((struct _Pair *)NULL)))
  {
    if(!((pair->proto & proto_error) == 0))
      pri = 7;

    else
      pair->proto = pair->proto | proto_error;
  }

  return pri;
}

// proto2fdset
// file stone.c line 6159
void proto2fdset(struct _Pair *pair)
{
  signed int sd;
  struct epoll_event ev;
  ev.events = (unsigned int)1073741824;
  ev.data.ptr = (void *)pair;
  if(!(pair == ((struct _Pair *)NULL)))
  {
    sd = pair->sd;
    if(sd >= 0)
    {
      if(!(((sf_sb_on_r | sf_sb_on_w) & pair->ssl_flag) == 0))
      {
        if(!((pair->ssl_flag & sf_sb_on_r) == 0))
          ev.events = ev.events | (unsigned int)1;

        if(!((pair->ssl_flag & sf_sb_on_w) == 0))
          ev.events = ev.events | (unsigned int)4;

        epoll_ctl(ePollFd, 3, sd, &ev);
      }

      else
        if(!((pair->proto & proto_close) == 0))
        {
          if(sd >= 0)
          {
            pair->sd = -1;
            close(sd);
          }

          goto __CPROVER_DUMP_L25;
        }

        else
          if(!((pair->proto & proto_conninprog) == 0))
          {
            ev.events = ev.events | (unsigned int)(4 | 2);
            epoll_ctl(ePollFd, 3, sd, &ev);
          }

          else
            if(!((pair->ssl_flag & sf_wb_on_r) == 0))
            {
              ev.events = ev.events | (unsigned int)1;
              epoll_ctl(ePollFd, 3, sd, &ev);
            }

            else
              if(!((pair->ssl_flag & sf_rb_on_w) == 0))
              {
                ev.events = ev.events | (unsigned int)4;
                epoll_ctl(ePollFd, 3, sd, &ev);
              }

              else
                if(!(((sf_cb_on_r | sf_cb_on_w) & pair->ssl_flag) == 0))
                {
                  struct _Pair *p = pair->pair;
                  if(!(p == ((struct _Pair *)NULL)))
                  {
                    signed int psd = p->sd;
                    if(psd >= 0)
                    {
                      struct epoll_event pev;
                      pev.events = (unsigned int)1073741824;
                      pev.data.ptr = (void *)p;
                      epoll_ctl(ePollFd, 3, psd, &pev);
                      if(Debug >= 8)
                        message(7, "%d TCP %d: proto2fdset2 epoll_ctl %d MOD %x events=%x", p->stone->sd, psd, ePollFd, (signed int)pev.data.ptr, pev.events);

                    }

                  }

                  if(!((pair->ssl_flag & sf_cb_on_r) == 0))
                    ev.events = ev.events | (unsigned int)1;

                  if(!((pair->ssl_flag & sf_cb_on_w) == 0))
                    ev.events = ev.events | (unsigned int)4;

                  epoll_ctl(ePollFd, 3, sd, &ev);
                }

                else
                  if(!(((sf_ab_on_r | sf_ab_on_w) & pair->ssl_flag) == 0))
                  {
                    if(!((pair->ssl_flag & sf_ab_on_r) == 0))
                      ev.events = ev.events | (unsigned int)1;

                    if(!((pair->ssl_flag & sf_ab_on_w) == 0))
                      ev.events = ev.events | (unsigned int)4;

                    epoll_ctl(ePollFd, 3, sd, &ev);
                  }

                  else
                    if(!((pair->proto & proto_connect) == 0))
                    {
                      signed int isset = 0;
                      if((pair->proto & proto_eof) == 0)
                      {
                        if(!((pair->proto & proto_select_r) == 0))
                        {
                          ev.events = ev.events | (unsigned int)1;
                          isset = 1;
                        }

                      }

                      if((pair->proto & proto_shutdown) == 0)
                      {
                        if(!((pair->proto & proto_select_w) == 0))
                        {
                          ev.events = ev.events | (unsigned int)4;
                          isset = 1;
                        }

                      }

                      if(!(isset == 0))
                        ev.events = ev.events | (unsigned int)2;

                      epoll_ctl(ePollFd, 3, sd, &ev);
                    }

      if(Debug >= 8)
        message(7, "%d TCP %d: proto2fdset epoll_ctl %d MOD %x events=%x", pair->stone->sd, sd, ePollFd, (signed int)ev.data.ptr, ev.events);

      pair->proto = pair->proto & ~proto_dirty;
    }

  }


__CPROVER_DUMP_L25:
  ;
}

// proxyCONNECT
// file stone.c line 5446
signed int proxyCONNECT(struct _Pair *pair, char *parm, signed int start)
{
  char *port = "443";
  char *r = parm;
  char *q = (char *)(void *)0;
  struct _Pair *p;
  message_time(pair, 6, "CONNECT %s", parm);
  while(!(*r == 0))
  {
    const unsigned short int **return_value___ctype_b_loc$1;
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*r]) == 0))
    {
      *r = (char)0;
      break;
    }

    if((signed int)*r == 58)
      q = r;

    r = r + 1l;
  }
  if(!(q == ((char *)NULL)))
  {
    port = q + (signed long int)1;
    *q = (char)0;
  }

  pair->b->len = pair->b->len + pair->b->start;
  pair->b->start = 0;
  p = pair->pair;
  if(!(p == ((struct _Pair *)NULL)))
    p->proto = p->proto | proto_ohttp_s;

  signed int return_value_doproxy$2;
  return_value_doproxy$2=doproxy(pair, parm, port);
  return return_value_doproxy$2;
}

// proxyCommon
// file stone.c line 5471
signed int proxyCommon(struct _Pair *pair, char *parm, signed int start)
{
  char *port = "80";
  char *host;
  struct _ExBuf *ex;
  char *top;
  char *p;
  char *q;
  signed int i;
  ex = pair->b;
  top = &ex->buf[(signed long int)start];
  i = 0;
  for( ; !(i >= 10); i = i + 1)
    if((signed int)parm[(signed long int)i] == 58)
      break;

  signed int return_value_strncmp$1;
  return_value_strncmp$1=strncmp(parm, "http", (unsigned long int)i);
  _Bool tmp_if_expr$2;
  if(!(return_value_strncmp$1 == 0))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)parm[(signed long int)(i + 1)] != 47 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = (signed int)parm[(signed long int)(i + 2)] != 47 ? (_Bool)1 : (_Bool)0;
  char *tmp_post$4;
  _Bool tmp_if_expr$6;
  const unsigned short int **return_value___ctype_b_loc$7;
  const unsigned short int **return_value___ctype_b_loc$8;
  signed int tmp_if_expr$9;
  if(tmp_if_expr$3)
  {
    message(3, "Unknown URL format: %s", parm);
    return -1;
  }

  else
  {
    host = &parm[(signed long int)(i + 3)];
    p = host;
    while(!(*p == 0))
      if((signed int)*p == 58)
      {
        port = p + (signed long int)1;
        tmp_post$4 = p;
        p = p + 1l;
        *tmp_post$4 = (char)0;
      }

      else
      {
        const unsigned short int **return_value___ctype_b_loc$5;
        return_value___ctype_b_loc$5=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)*p]) == 0))
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = (signed int)*p == 47 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
        {
          *p = (char)0;
          break;
        }

        p = p + 1l;
      }
    i = (signed int)(p - parm);
    p = top;
    do
    {
      return_value___ctype_b_loc$7=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)*p]) == 0))
        break;

      p = p + 1l;
    }
    while((_Bool)1);
    do
    {
      return_value___ctype_b_loc$8=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$8)[(signed long int)(signed int)*p]) == 0)
        break;

      p = p + 1l;
    }
    while((_Bool)1);
    q = p + (signed long int)i;
    if(!((signed int)*q == 47))
    {
      q = q - 1l;
      *q = (char)47;
    }

    bcopy((const void *)q, (void *)p, (unsigned long int)((signed long int)(ex->start + ex->len) - (q - top)));
    ex->len = (signed int)((signed long int)(ex->start + ex->len) - (q - p));
    ex->start = 0;
    if(Debug >= 2)
    {
      struct _Pair *r = pair->pair;
      if(!(r == ((struct _Pair *)NULL)))
        tmp_if_expr$9 = r->sd;

      else
        tmp_if_expr$9 = -1;
      message(7, "proxy %d -> http://%s:%s", tmp_if_expr$9, host, port);
    }

    pair->proto = pair->proto & ~(proto_noconnect | state_mask);
    pair->proto = pair->proto | proto_dirty | 1;
    signed int return_value_doproxy$10;
    return_value_doproxy$10=doproxy(pair, host, port);
    return return_value_doproxy$10;
  }
}

// proxyErr
// file stone.c line 5536
signed int proxyErr(struct _Pair *pair, char *parm, signed int start)
{
  message(3, "Unknown method: %s", parm);
  return -1;
}

// proxyGET
// file stone.c line 5521
signed int proxyGET(struct _Pair *pair, char *parm, signed int start)
{
  message_time(pair, 6, "GET %s", parm);
  signed int return_value_proxyCommon$1;
  return_value_proxyCommon$1=proxyCommon(pair, parm, start);
  return return_value_proxyCommon$1;
}

// proxyHEAD
// file stone.c line 5526
signed int proxyHEAD(struct _Pair *pair, char *parm, signed int start)
{
  message_time(pair, 6, "HEAD %s", parm);
  signed int return_value_proxyCommon$1;
  return_value_proxyCommon$1=proxyCommon(pair, parm, start);
  return return_value_proxyCommon$1;
}

// proxyPOST
// file stone.c line 5531
signed int proxyPOST(struct _Pair *pair, char *parm, signed int start)
{
  message_time(pair, 6, "POST %s", parm);
  signed int return_value_proxyCommon$1;
  return_value_proxyCommon$1=proxyCommon(pair, parm, start);
  return return_value_proxyCommon$1;
}

// recvPairUDP
// file stone.c line 2931
signed int recvPairUDP(struct _Pair *pair)
{
  struct _Stone *stone = pair->stone;
  signed int sd = pair->sd;
  struct _Pair *p;
  struct _ExBuf *ex;
  struct _ExBuf *t;
  signed int len;
  signed int flags = 0;
  struct sockaddr_storage ss;
  struct sockaddr *from = (struct sockaddr *)&ss;
  unsigned int fromlen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  p = pair->pair;
  if(p == ((struct _Pair *)NULL))
  {
    signed int return_value_priority$1;
    return_value_priority$1=priority(pair);
    message(return_value_priority$1, "%d UDP %d: no pair, closing", stone->sd, sd);
    return -1;
  }

  ex = p->b;
  if(ex->len >= 1)
  {
    ex=getExBuf();
    if(ex == ((struct _ExBuf *)NULL))
      return -1;

    if(Debug >= 5)
      message(7, "%d UDP %d: get ExBuf nbuf=%d", stone->sd, p->sd, p->nbuf);

  }

  ex->start = 0;
  if((stone->proto & proto_block_d) == 0)
    flags = 64;

  flags = flags | 32;
  signed long int return_value_recvfrom$2;
  return_value_recvfrom$2=recvfrom(sd, (void *)(ex->buf + (signed long int)2), (unsigned long int)(ex->bufmax - 2), flags, from, &fromlen);
  len = (signed int)return_value_recvfrom$2;
  if(!(len >= 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    message(3, "%d UDP %d: recvfrom err=%d", stone->sd, sd, *return_value___errno_location$3);
    if(!(ex == p->b))
      ungetExBuf(ex);

    return -1;
  }

  time(&pair->clock);
  p->clock = pair->clock;
  pair->rx = pair->rx + len;
  if(Debug >= 9)
    message(7, "%d UDP %d: recvfrom len=%d", stone->sd, sd, len);

  t=getExData(pair, data_peeraddr, 0);
  if(!(t == ((struct _ExBuf *)NULL)))
  {
    struct anonymous$0 *peer = (struct anonymous$0 *)(t->buf + (signed long int)sizeof(signed int) /*4ul*/ );
    signed int return_value_saComp$4;
    return_value_saComp$4=saComp(&peer->addr, from);
    if(return_value_saComp$4 == 0)
      goto unknown;

  }

  else
  {
    char addrport[128l];

  unknown:
    ;
    addrport2str(from, fromlen, proto_udp_s | proto_udp_d, addrport, 127, 0);
    addrport[(signed long int)127] = (char)0;
    message(3, "%d UDP %d: received from unknown %s", stone->sd, sd, (const void *)addrport);
    if(!(ex == p->b))
      ungetExBuf(ex);

    return -1;
  }
  if(!(ex == p->b))
  {
    p->b->next = ex;
    p->b = ex;
    p->nbuf = p->nbuf + 1;
  }

  ex->buf[(signed long int)0] = (char)((unsigned int)len >> 8);
  ex->buf[(signed long int)1] = (char)((unsigned int)len % (unsigned int)256);
  ex->len = ex->len + 2 + len;
  return ex->len;
}

// recvStoneUDP
// file stone.c line 6830
void recvStoneUDP(struct _Stone *stone)
{
  if(!((stone->proto & proto_udp_d) == 0))
  {
    struct _PktBuf *pb;
    pb=recvUDP(stone);
    if(!(pb == ((struct _PktBuf *)NULL)))
    {
      sendUDP(pb);
      ungetPktBuf(pb);
    }

  }

  else
  {
    struct sockaddr_storage ss;
    struct sockaddr *from = (struct sockaddr *)&ss;
    unsigned int fromlen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
    signed int flags = 0;
    signed int len;
    struct _Pair *rPair;
    struct _Pair *wPair;
    struct _ExBuf *ex;
    char addrport[128l];
    ex=getExBuf();
    if(ex == ((struct _ExBuf *)NULL))
      message(2, "%d UDP: out of memory", stone->sd);

    else
    {
      ex->start = 0;
      if((stone->proto & proto_block_s) == 0)
        flags = 64;

      flags = flags | 32;
      signed long int return_value_recvfrom$1;
      return_value_recvfrom$1=recvfrom(stone->sd, (void *)(ex->buf + (signed long int)2), (unsigned long int)(ex->bufmax - 2), flags, from, &fromlen);
      len = (signed int)return_value_recvfrom$1;
      addrport[(signed long int)0] = (char)0;
      if(!(len >= 0))
      {
        addrport2strOnce(from, fromlen, proto_udp_s | proto_udp_d, addrport, 127, 0);
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        message(3, "%d UDP: recvfrom err=%d %s", stone->sd, *return_value___errno_location$2, (const void *)addrport);
        ungetExBuf(ex);
        goto __CPROVER_DUMP_L10;
      }

      ex->buf[(signed long int)0] = (char)((unsigned int)len >> 8);
      ex->buf[(signed long int)1] = (char)((unsigned int)len % (unsigned int)256);
      ex->len = ex->len + 2 + len;
      if(Debug >= 9)
      {
        addrport2strOnce(from, fromlen, proto_udp_s | proto_udp_d, addrport, 127, 0);
        message(7, "%d UDP: recvfrom len=%d %s", stone->sd, len, (const void *)addrport);
      }

      rPair=getPairUDP(from, fromlen, stone);
      if(rPair == ((struct _Pair *)NULL))
      {
        message(3, "%d UDP: fail to get pair", stone->sd);
        ungetExBuf(ex);
      }

      else
      {
        rPair->rx = rPair->rx + len;
        wPair = rPair->pair;
        if(!(wPair == ((struct _Pair *)NULL)))
        {
          wPair->clock = rPair->clock;
          wPair->b->next = ex;
          wPair->b = ex;
          if(!(wPair->t->len >= 1))
          {
            struct _ExBuf *t = wPair->t;
            wPair->t = wPair->t->next;
            ungetExBuf(t);
          }

          wPair->proto = wPair->proto | proto_select_w | proto_dirty;
        }

      }
    }
  }

__CPROVER_DUMP_L10:
  ;
}

// recvUDP
// file stone.c line 2705
struct _PktBuf * recvUDP(struct _Stone *stone)
{
  struct sockaddr_storage ss;
  struct sockaddr *from = (struct sockaddr *)&ss;
  unsigned int fromlen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  struct _Origin *origin;
  signed int sd;
  signed int flags = 0;
  char *dirstr;
  struct _PktBuf *pb;
  pb=getPktBuf();
  pb->type = stone->common & 0x000f;
  if(pb->type == 0x0002)
  {
    origin = (struct _Origin *)stone;
    sd = origin->sd;
    stone = origin->stone;
    dirstr = "<";
    if((stone->proto & proto_block_d) == 0)
      flags = 64;

  }

  else
  {
    origin = (struct _Origin *)(void *)0;
    sd = stone->sd;
    dirstr = ">";
    if((stone->proto & proto_block_s) == 0)
      flags = 64;

  }
  flags = flags | 32;
  signed long int return_value_recvfrom$1;
  return_value_recvfrom$1=recvfrom(sd, (void *)pb->buf, (unsigned long int)pb->bufmax, flags, from, &fromlen);
  pb->len = (signed int)return_value_recvfrom$1;
  if(!(pb->len >= 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    if(*return_value___errno_location$3 == 90)
    {
      if(Debug >= 5)
        message(7, "%d UDP%s%d: recvfrom received larger msg", stone->sd, dirstr, sd);

      pb->len = pb->bufmax + 1;
    }

    else
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      message(3, "%d UDP%s%d: recvfrom failed err=%d", stone->sd, dirstr, sd, *return_value___errno_location$2);

    end:
      ;
      ungetPktBuf(pb);
      return (struct _PktBuf *)(void *)0;
    }
  }

  if(pb->type == 0x0003)
  {
    struct _XHosts *xhost;
    xhost=checkXhost(stone->xhosts, from, fromlen);
    if(xhost == ((struct _XHosts *)NULL))
    {
      if(Debug >= 5)
      {
        char addrport[128l];
        addrport2str(from, fromlen, proto_udp_s | proto_udp_d, addrport, 127, 0);
        addrport[(signed long int)127] = (char)0;
        message(7, "%d UDP%s%d: recvfrom denied %s", stone->sd, dirstr, sd, (const void *)addrport);
      }

      goto end;
    }

    origin=getOrigins(from, fromlen, stone);
    if(origin == ((struct _Origin *)NULL))
      goto end;

    origin->xhost = xhost;
    time(&origin->clock);
  }

  pb->origin = origin;
  if(Debug >= 5 || !(pb->bufmax >= pb->len))
  {
    char recvUDP$$1$$5$$addrport[128l];
    addrport2str(from, fromlen, proto_udp_s | proto_udp_d, recvUDP$$1$$5$$addrport, 127, 0);
    recvUDP$$1$$5$$addrport[(signed long int)127] = (char)0;
    if(Debug >= 5)
      message(7, "%d UDP%s%d: %d bytes received from %s", stone->sd, dirstr, origin->sd, pb->len, (const void *)recvUDP$$1$$5$$addrport);

    if(!(pb->bufmax >= pb->len))
    {
      message(5, "%d UDP%s%d: recvfrom failed: larger packet (%d bytes) arrived from %s", stone->sd, dirstr, origin->sd, pb->len, (const void *)recvUDP$$1$$5$$addrport);
      for( ; !(pkt_len_max >= pb->len); pkt_len_max = pkt_len_max << 1)
        ;
      ungetPktBuf(pb);
      return (struct _PktBuf *)(void *)0;
    }

  }

  return pb;
}

// repeater
// file stone.c line 7635
void repeater(void)
{
  signed int ret;
  signed long int now;
  struct _Pair *pair;
  signed int timeout;
  struct epoll_event evs[100l];
  pair = PairTop;
  for( ; !(pair == ((struct _Pair *)NULL)); pair = pair->next)
    if(!(pair->clock == -1l))
    {
      if(!((pair->proto & proto_dirty) == 0))
        proto2fdset(pair);

    }

  static signed int spin = 0;
  if(AsyncCount >= 1 || spin >= 1 || !(conns.next == ((struct _Conn *)NULL)) || !(trash.next == ((struct _Pair *)NULL)))
  {
    if(AsyncCount == 0 && spin >= 1)
      spin = spin - 1;

    timeout = 100000 / 1000;
  }

  else
    if(MinInterval >= 1)
      timeout = MinInterval * 1000;

    else
      timeout = -1;
  ret=epoll_wait(ePollFd, evs, 100, timeout);
  if(Debug >= 11)
    message(7, "epoll %d: %d", ePollFd, ret);

  static signed int nerrs = 0;
  if(ret >= 1)
  {
    nerrs = 0;
    spin = 10;
    dispatch(ePollFd, evs, ret);
  }

  else
    if(!(ret >= 0))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      if(!(*return_value___errno_location$2 == 4))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        message(3, "epoll %d error err=%d", ePollFd, *return_value___errno_location$1);
        nerrs = nerrs + 1;
        if(nerrs >= 10)
        {
          message(3, "epoll %d error %d times, exiting", ePollFd, nerrs);
          message_pairs(6);
          message_origins(6);
          message_conns(6);
          exit(1);
        }

      }

      usleep((unsigned int)100000);
    }

  if(!(conns.next == ((struct _Conn *)NULL)))
    scanConns();

  time(&now);
  static signed long int scantime = (signed long int)0;
  if(!(now == scantime))
  {
    scantime = now;
    if(scantime + -lastScanBackups >= (signed long int)MinInterval && !(backups == ((struct _Backup *)NULL)))
    {
      lastScanBackups = scantime;
      scanBackups();
    }

    if(!(PairTop == ((struct _Pair *)NULL)))
      scanPairs((struct _Pair *)(void *)0);

    if(!(OriginTop == ((struct _Origin *)NULL)))
      scanUDP((struct _Origin *)(void *)0);

    if(!(PairTop == ((struct _Pair *)NULL)))
      scanClose((struct _Pair *)(void *)0);

    if(!(oldstones == ((struct _Stone *)NULL)))
      rmoldstone();

    if(!(OldConfigArgc == 0))
      rmoldconfig();

    ERR_remove_state((unsigned long int)0);
  }

}

// reqconn
// file stone.c line 3897
signed int reqconn(struct _Pair *pair, struct sockaddr *dst, unsigned int dstlen)
{
  signed int ret;
  struct _Conn *conn;
  struct _Pair *p = pair->pair;
  _Bool tmp_if_expr$1;
  if((pair->proto & proto_command) == 0x0600)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (pair->proto & proto_command) == 0x0400 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (pair->proto & proto_command) == 0x0500 ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$5;
  if(tmp_if_expr$2)
  {
    pair->proto = pair->proto | proto_noconnect;
    if(!(p == ((struct _Pair *)NULL)))
    {
      if(((proto_close | proto_eof) & p->proto) == 0)
        p->proto = p->proto | proto_select_r | proto_dirty;

    }

    return 0;
  }

  else
  {
    ret=doconnect(pair, dst, dstlen);
    if(!(ret >= 0))
    {
      if(ret == -2)
      {
        p->proto = p->proto | proto_select_r | proto_dirty;
        return 0;
      }

      return -1;
    }

    else
      if(ret >= 1)
        return ret;

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct _Conn) /*32ul*/ );
        conn = (struct _Conn *)return_value_malloc$3;
        if(conn == ((struct _Conn *)NULL))
        {

        memerr:
          ;
          if(!(p == ((struct _Pair *)NULL)))
            tmp_if_expr$4 = p->stone->sd;

          else
            tmp_if_expr$4 = -1;
          if(!(p == ((struct _Pair *)NULL)))
            tmp_if_expr$5 = p->sd;

          else
            tmp_if_expr$5 = -1;
          message(2, "%d TCP %d: out of memory", tmp_if_expr$4, tmp_if_expr$5);
          return -1;
        }

        else
        {
          time(&pair->clock);
          p->clock = pair->clock;
          pair->count = pair->count + 10;
          conn->pair = pair;
          conn->dst=saDup(dst, dstlen);
          if(conn->dst == ((struct anonymous$0 *)NULL))
          {
            free((void *)conn);
            goto memerr;
          }

          conn->lock = 0;
          waitMutex(1);
          conn->next = conns.next;
          conns.next = conn;
          freeMutex(1);
          return 0;
        }
      }
  }
}

// reusestone
// file stone.c line 7748
signed int reusestone(struct _Stone *stone)
{
  struct _Stone *s;
  if(oldstones == ((struct _Stone *)NULL))
    return 0;

  else
  {
    s = oldstones;
    for( ; !(s == ((struct _Stone *)NULL)); s = s->next)
      if(s->port == stone->port)
      {
        if(s->proto == stone->proto)
        {
          if(Debug >= 6)
            message(7, "stone %d: reused port %d", s->sd, s->port);

          stone->sd = s->sd;
          s->port = 0;
          return 1;
        }

      }

    return 0;
  }
}

// rmStoneSSL
// file stone.c line 7504
void rmStoneSSL(struct anonymous$12 *ss)
{
  signed int i;
  SSL_CTX_free(ss->ctx);
  i = 0;
  for( ; !(i >= 10); i = i + 1)
    if(!(ss->re[(signed long int)i] == ((struct re_pattern_buffer *)NULL)))
    {
      regfree(ss->re[(signed long int)i]);
      free((void *)ss->re[(signed long int)i]);
    }

  free((void *)ss);
}

// rmheader
// file stone.c line 6011
signed int rmheader(struct _Pair *pair)
{
  struct _ExBuf *ex = pair->b;
  char *p;
  char *q = &ex->buf[(signed long int)(ex->start + ex->len)];
  signed int state = pair->proto & state_mask;
  if(Debug >= 4)
    message_buf(pair, ex->len, "rm");

  p = &ex->buf[(signed long int)ex->start];
  for( ; !(p >= q); p = p + 1l)
    if(!((signed int)*p == 13))
    {
      if((signed int)*p == 10)
      {
        state = state + 1;
        if(state >= 3)
        {
          p = p + 1l;
          break;
        }

      }

      else
        state = 1;
    }

  if(!(state >= 3))
  {
    ex->start = 0;
    ex->len = ex->start;
    pair->proto = pair->proto & ~state_mask | state;
    return -2;
  }

  else
  {
    ex->len = (signed int)(q - p);
    ex->start = (signed int)(p - ex->buf);
    pair->proto = pair->proto & ~state_mask;
    return ex->len;
  }
}

// rmoldconfig
// file stone.c line 7625
void rmoldconfig(void)
{
  signed int i = 0;
  for( ; !(i >= OldConfigArgc); i = i + 1)
    free((void *)OldConfigArgv[(signed long int)i]);
  OldConfigArgc = 0;
  free((void *)OldConfigArgv);
  OldConfigArgv = (char **)(void *)0;
}

// rmoldstone
// file stone.c line 7598
void rmoldstone(void)
{
  struct _Stone *stone;
  struct _Stone *next;
  stone = oldstones;
  oldstones = (struct _Stone *)(void *)0;
  for( ; !(stone == ((struct _Stone *)NULL)); stone = next)
  {
    next = stone->next;
    if(!(stone->port == 0))
    {
      epoll_ctl(ePollFd, 2, stone->sd, (struct epoll_event *)(void *)0);
      close(stone->sd);
    }

    if(!(stone->ssl_server == ((struct anonymous$12 *)NULL)))
      rmStoneSSL(stone->ssl_server);

    if(!(stone->ssl_client == ((struct anonymous$12 *)NULL)))
      rmStoneSSL(stone->ssl_client);

    free((void *)stone);
  }
}

// saComp
// file stone.c line 1566
signed int saComp(struct sockaddr *a, struct sockaddr *b)
{
  unsigned short int tmp_statement_expression$2;
  unsigned short int tmp_statement_expression$4;
  if(!(a->sa_family == b->sa_family))
  {
    if(Debug >= 11)
      message(7, "saComp: sa_family differ: %d, %d", a->sa_family, b->sa_family);

    return 0;
  }

  else
  {
    if((signed int)a->sa_family == 2)
    {
      struct in_addr *saComp$$1$$2$$an;
      struct in_addr *bn;
      signed short int saComp$$1$$2$$ap;
      signed short int saComp$$1$$2$$bp;
      saComp$$1$$2$$an = &((struct sockaddr_in *)a)->sin_addr;
      bn = &((struct sockaddr_in *)b)->sin_addr;
      saComp$$1$$2$$ap = (signed short int)((struct sockaddr_in *)a)->sin_port;
      saComp$$1$$2$$bp = (signed short int)((struct sockaddr_in *)b)->sin_port;
      if(Debug >= 11)
      {
        unsigned int return_value___bswap_32$1;
        return_value___bswap_32$1=__bswap_32(saComp$$1$$2$$an->s_addr);
        unsigned short int __v;
        unsigned short int __x = (unsigned short int)saComp$$1$$2$$ap;
        asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
        tmp_statement_expression$2 = __v;
        unsigned int return_value___bswap_32$3;
        return_value___bswap_32$3=__bswap_32(bn->s_addr);
        unsigned short int saComp$$1$$2$$1$$2$$__v;
        unsigned short int saComp$$1$$2$$1$$2$$__x = (unsigned short int)saComp$$1$$2$$bp;
        asm("rorw $8, %w0" : "=r"(saComp$$1$$2$$1$$2$$__v) : "0"(saComp$$1$$2$$1$$2$$__x) : "cc");
        tmp_statement_expression$4 = saComp$$1$$2$$1$$2$$__v;
        message(7, "saComp: %lx:%d, %lx:%d", (unsigned long int)return_value___bswap_32$1, tmp_statement_expression$2, (unsigned long int)return_value___bswap_32$3, tmp_statement_expression$4);
      }

      return (signed int)(saComp$$1$$2$$an->s_addr == bn->s_addr ? (saComp$$1$$2$$ap == saComp$$1$$2$$bp ? (_Bool)1 : (_Bool)0) : (_Bool)0);
    }

    if((signed int)a->sa_family == 10)
    {
      struct in6_addr *an;
      struct in6_addr *saComp$$1$$3$$bn;
      signed short int ap;
      signed short int bp;
      signed int i;
      an = &((struct sockaddr_in6 *)a)->sin6_addr;
      saComp$$1$$3$$bn = &((struct sockaddr_in6 *)b)->sin6_addr;
      ap = (signed short int)((struct sockaddr_in6 *)a)->sin6_port;
      bp = (signed short int)((struct sockaddr_in6 *)b)->sin6_port;
      if(!(ap == bp))
        return 0;

      i = 0;
      for( ; !(i >= 16); i = i + 4)
        if(!(*((unsigned long int *)(an->__in6_u.__u6_addr8 + (signed long int)i)) == *((unsigned long int *)(saComp$$1$$3$$bn->__in6_u.__u6_addr8 + (signed long int)i))))
          return 0;

      return 1;
    }

    message(3, "saComp: unknown family=%d", a->sa_family);
    return 0;
  }
}

// saDup
// file stone.c line 1557
struct anonymous$0 * saDup(struct sockaddr *sa, unsigned int salen)
{
  struct anonymous$0 *ret;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)((unsigned int)(signed int)&((struct anonymous$0 *)(void *)0)->addr + salen));
  ret = (struct anonymous$0 *)return_value_malloc$1;
  if(!(ret == ((struct anonymous$0 *)NULL)))
  {
    bcopy((const void *)sa, (void *)&ret->addr, (unsigned long int)salen);
    ret->len = salen;
  }

  return ret;
}

// saPort
// file stone.c line 1395
void saPort(struct sockaddr *sa, unsigned short int port)
{
  unsigned short int tmp_statement_expression$1;
  unsigned short int tmp_statement_expression$2;
  if((signed int)sa->sa_family == 2)
  {
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)port;
    asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression$1 = __v;
    ((struct sockaddr_in *)sa)->sin_port = tmp_statement_expression$1;
  }

  else
    if((signed int)sa->sa_family == 10)
    {
      unsigned short int saPort$$1$$2$$1$$__v;
      unsigned short int saPort$$1$$2$$1$$__x = (unsigned short int)port;
      asm("rorw $8, %w0" : "=r"(saPort$$1$$2$$1$$__v) : "0"(saPort$$1$$2$$1$$__x) : "cc");
      tmp_statement_expression$2 = saPort$$1$$2$$1$$__v;
      ((struct sockaddr_in6 *)sa)->sin6_port = tmp_statement_expression$2;
    }

    else
      message(3, "saPort: unknown family=%d", sa->sa_family);
}

// scanBackups
// file stone.c line 1987
void scanBackups(void)
{
  struct _Backup *b;
  signed long int now;
  time(&now);
  b = backups;
  _Bool tmp_if_expr$1;
  for( ; !(b == ((struct _Backup *)NULL)); b = b->next)
    if((signed int)b->used >= 2)
    {
      if(!((signed int)b->interval >= 1))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = now - b->last < (signed long int)b->interval ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$1)
      {
        unsigned long int thread;
        signed int err;
        if(Debug >= 8)
          message(7, "ASYNC: %d", AsyncCount);

        waitMutex(3);
        AsyncCount = AsyncCount + 1;
        freeMutex(3);
        err=pthread_create(&thread, &thread_attr, (void * (*)(void *))asyncHealthCheck, (void *)b);
        if(!(err == 0))
        {
          message(3, "pthread_create error err=%d", err);
          asyncHealthCheck(b);
        }

        else
          if(Debug >= 8)
            message(7, "pthread ID=%lu", thread);

      }

    }

}

// scanClose
// file stone.c line 4671
signed int scanClose(struct _Pair *pairs)
{
  struct _Pair *p1;
  struct _Pair *p2;
  struct _Pair *p;
  signed int n = 0;
  signed int m = 0;
  signed int all;
  if(!(pairs == ((struct _Pair *)NULL)))
    all = 0;

  else
  {
    pairs = PairTop;
    all = 1;
  }
  p1 = trash.next;
  while(!(p1 == ((struct _Pair *)NULL)))
  {
    signed int sd;
    p2 = p1;
    p1 = p1->next;
    if(p2->count >= 1)
    {
      p2->count = p2->count - 1;
      n = n + 1;
    }

    else
    {
      sd = p2->sd;
      if(!(((proto_select_r | proto_select_w) & p2->proto) == 0))
      {
        p2->proto = p2->proto & ~(proto_select_r | proto_select_w);
        p2->proto = p2->proto | proto_dirty;
        p2->count = 10;
      }

      if(!(p2->ssl_flag == 0))
      {
        p2->ssl_flag = 0;
        p2->count = 10;
      }

      p = p2->prev;
      if(!(p == ((struct _Pair *)NULL)))
        p->next = p1;

      if(!(p1 == ((struct _Pair *)NULL)))
        p1->prev = p;

      freePair(p2);
      m = m + 1;
    }
  }
  if(Debug >= 9 && (m >= 1 || n >= 1))
    message(7, "trash: queued=%d, removed=%d", n, m);

  p1 = pairs->next;
  while(!(p1 == ((struct _Pair *)NULL)))
  {
    if(p1->clock == -1l)
    {
      if(!(all == 0))
      {
        pairs = p1;
        p1 = pairs->next;
        continue;
      }

      else
        break;
    }

    p2 = p1;
    p1 = p1->next;
    if(!((p2->proto & proto_close) == 0))
    {
      if(p2->count >= 1)
        p2->count = p2->count - 1;

      else
      {
        waitMutex(0);
        p = p2->prev;
        if(!(p == ((struct _Pair *)NULL)))
          p->next = p1;

        if(!(p1 == ((struct _Pair *)NULL)))
          p1->prev = p;

        p = p2->pair;
        if(!(p == ((struct _Pair *)NULL)))
          p->pair = (struct _Pair *)(void *)0;

        freeMutex(0);
        if(!(trash.next == ((struct _Pair *)NULL)))
          trash.next->prev = p2;

        p2->prev = &trash;
        p2->pair = (struct _Pair *)(void *)0;
        p2->count = 10;
        p2->next = trash.next;
        trash.next = p2;
      }
    }

  }
  return 1;
}

// scanConns
// file stone.c line 3983
signed int scanConns(void)
{
  struct _Conn *conn;
  struct _Conn *pconn;
  struct _Pair *p1;
  struct _Pair *p2;
  if(Debug >= 9)
    message(7, "scanConns");

  pconn = &conns;
  conn = conns.next;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  for( ; !(conn == ((struct _Conn *)NULL)); conn = conn->next)
  {
    p1 = conn->pair;
    if(!(p1 == ((struct _Pair *)NULL)))
      p2 = p1->pair;

    if(!(p1 == ((struct _Pair *)NULL)))
      tmp_if_expr$1 = !((p1->proto & proto_close) != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!(p2 == ((struct _Pair *)NULL)) && tmp_if_expr$1)
      tmp_if_expr$2 = !((p2->proto & proto_close) != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
    {
      if(!((p2->proto & proto_connect) == 0))
      {
        if(conn->lock == 0)
        {
          conn->lock = 1;
          if(Debug >= 5)
            message_conn(7, conn);

          unsigned long int thread;
          signed int err;
          if(Debug >= 8)
            message(7, "ASYNC: %d", AsyncCount);

          waitMutex(3);
          AsyncCount = AsyncCount + 1;
          freeMutex(3);
          err=pthread_create(&thread, &thread_attr, (void * (*)(void *))asyncConn, (void *)conn);
          if(!(err == 0))
          {
            message(3, "pthread_create error err=%d", err);
            asyncConn(conn);
          }

          else
            if(Debug >= 8)
              message(7, "pthread ID=%lu", thread);

        }

      }

    }

    else
    {
      waitMutex(1);
      if(pconn->next == conn)
      {
        if(!(conn->lock >= 1))
        {
          pconn->next = conn->next;
          freeConn(conn);
          conn = pconn;
        }

      }

      freeMutex(1);
    }
    pconn = conn;
  }
  return 1;
}

// scanPairs
// file stone.c line 6972
signed int scanPairs(struct _Pair *pairs)
{
  struct _Pair *pair;
  signed int ret = 1;
  signed int all;
  if(Debug >= 9)
    message(7, "scanPairs");

  if(!(pairs == ((struct _Pair *)NULL)))
    all = 0;

  else
  {
    pairs = PairTop;
    all = 1;
  }
  pair = pairs->next;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(pair == ((struct _Pair *)NULL)))
    {
      if(!(all == 0))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = pair->clock != (signed long int)-1 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    signed int sd = pair->sd;
    if(!(all == 0))
    {
      if(!(pair->clock == -1l))
        goto __CPROVER_DUMP_L9;

      pairs = pair;
    }

    else
    {

    __CPROVER_DUMP_L9:
      ;
      if(sd >= 0)
      {
        signed long int clock;
        signed int idle = 1;
        if(!(idle == 0))
        {
          if(pair->timeout >= 1)
          {
            time(&clock);
            if(!((signed long int)pair->timeout >= clock + -pair->clock))
            {
              struct _Pair *p = pair->pair;
              if(Debug >= 3)
              {
                message(7, "%d TCP %d: idle time exceeds", pair->stone->sd, sd);
                message_pair(7, pair);
              }

              setclose(pair, proto_shutdown);
              if(!(p == ((struct _Pair *)NULL)))
                setclose(p, proto_shutdown);

            }

          }

        }

      }

    }
    pair = pair->next;
  }
  while((_Bool)1);
  if(Debug >= 9)
    message(7, "scanPairs done");

  return ret;
}

// scanUDP
// file stone.c line 2858
signed int scanUDP(struct _Origin *origins)
{
  struct _Origin *origin;
  struct _Origin *prev;
  signed int n = 0;
  signed int all;
  signed long int now;
  time(&now);
  if(!(origins == ((struct _Origin *)NULL)))
    all = 0;

  else
  {
    origins = OriginTop;
    all = 1;
  }
  prev = origins;
  origin = origins->next;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  do
  {
    if(!(origin == ((struct _Origin *)NULL)))
    {
      if(!(all == 0))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = origin->from != (struct anonymous$0 *)(void *)0 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    if(!(all == 0))
    {
      if(!(origin->from == ((struct anonymous$0 *)NULL)))
        goto __CPROVER_DUMP_L8;

      origins = origin;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      if(!(origin->sd >= 0))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = origin->lock > 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        struct _Origin *old = origin;
        waitMutex(2);
        if(prev->next == origin)
        {
          origin = prev;
          origin->next = old->next;
          if(!(old->sd >= 0))
            freeOrigin(old);

          else
          {
            old->lock = 0;
            old->next = origins->next;
            origins->next = old;
          }
        }

        freeMutex(2);
        goto next;
      }

      n = n + 1;
      if(n >= OriginMax)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = now - origin->clock > (signed long int)60 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        docloseUDP(origin);

    }

  next:
    ;
    prev = origin;
    origin = origin->next;
  }
  while((_Bool)1);
  return 1;
}

// sendPairUDP
// file stone.c line 3057
signed int sendPairUDP(struct _Pair *pair)
{
  struct _Stone *stone = pair->stone;
  struct _ExBuf *next = pair->t;
  struct _ExBuf *cur = (struct _ExBuf *)(void *)0;
  struct _ExBuf *ex = (struct _ExBuf *)(void *)0;
  unsigned char *buf = (unsigned char *)(void *)0;
  signed int pos = 0;
  signed int len = 0;
  signed int err = 0;
  char prefix[128l];
  signed int tmp_if_expr$1;
  signed int tmp_if_expr$2;
  if((pair->proto & proto_command) == 0x0f00)
  {
    struct _Pair *sendPairUDP$$1$$1$$p = pair->pair;
    if(!(sendPairUDP$$1$$1$$p == ((struct _Pair *)NULL)))
      tmp_if_expr$1 = sendPairUDP$$1$$1$$p->sd;

    else
      tmp_if_expr$1 = -1;
    snprintf(prefix, (unsigned long int)127, "%d UDP<TCP%d:", stone->sd, tmp_if_expr$1);
  }

  else
  {
    struct _Pair *p = pair->pair;
    if(!(p == ((struct _Pair *)NULL)))
      tmp_if_expr$2 = p->sd;

    else
      tmp_if_expr$2 = -1;
    snprintf(prefix, (unsigned long int)127, "%d TCP%d>UDP%d:", stone->sd, tmp_if_expr$2, pair->sd);
  }
  _Bool tmp_if_expr$3;
  while(!(next == ((struct _ExBuf *)NULL)))
  {
    ex = next;
    next = ex->next;
    signed int add;
    if(!(ex->len >= 1))
    {
      if(!(ex == pair->b))
        ungetExBuf(ex);

    }

    else
      if(cur == ((struct _ExBuf *)NULL))
      {
        cur = ex;
        buf = (unsigned char *)&cur->buf[(signed long int)cur->start];
        pos = cur->len;
        len = (signed int)buf[(signed long int)0] << 8;
        if(pos == 1)
        {
          struct _ExBuf *t = cur->next;
          for( ; !(t == ((struct _ExBuf *)NULL)); t = t->next)
            if(t->len >= 1)
            {
              len = len + (signed int)(unsigned int)t->buf[(signed long int)t->start];
              break;
            }

          if(t == ((struct _ExBuf *)NULL))
            break;

        }

        else
          len = len + (signed int)buf[(signed long int)1];
        if(Debug >= 9)
          message(7, "%s sendPairUDP len=%d (curbuf=%d)", (const void *)prefix, len, cur->len);

        len = len + 2;
        if(!(cur->bufmax >= len))
        {
          message(3, "%s sendPairUDP packet too large len=%d", (const void *)prefix, len);
          err = -1;
        }

        else
          if(!(cur->bufmax + -cur->start >= len))
          {
            if(Debug >= 7)
              message(7, "%s sendPairUDP len=%d is larger than (bufmax-start=%d)=%d, move", (const void *)prefix, len, cur->start, cur->bufmax - cur->start);

            bcopy((const void *)(cur->buf + (signed long int)cur->start), (void *)cur->buf, (unsigned long int)cur->len);
            buf = (unsigned char *)cur->buf;
            cur->start = 0;
          }

        if(!(len >= cur->len))
        {
          cur->start = cur->start + len;
          cur->len = cur->len - len;
          goto complete;
        }

        else
          if(len == cur->len)
          {
            cur->len = cur->bufmax;
            cur->start = 0;
            goto complete;
          }

          else
          {
            cur->len = cur->bufmax;
            cur->start = 0;
          }
      }

      else
      {
        add = len - pos;
        if(!(add >= ex->len))
        {
          ex->start = ex->start + add;
          ex->len = ex->len - add;
        }

        else
        {
          add = ex->len;
          ex->len = ex->bufmax;
          ex->start = 0;
        }
        if(err == 0)
          bcopy((const void *)(ex->buf + (signed long int)ex->start), (void *)(buf + (signed long int)pos), (unsigned long int)add);

        pos = pos + add;
        if(!(ex == pair->b))
          ungetExBuf(ex);

        if(pos >= len)
        {

        complete:
          ;
          if(err == 0)
          {
            err=sendPairUDPbuf(stone, pair, (char *)(buf + (signed long int)2), len - 2);
            if(err == 0)
            {
              if((0xF & (signed int)pair->xhost->mode) >= 1)
                tmp_if_expr$3 = (_Bool)1;

              else
                tmp_if_expr$3 = ((pair->proto & proto_first_w) != 0 ? (Debug > 3 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$3)
                message_buf(pair, len, "tu");

            }

          }

          if(!(cur == pair->b))
            ungetExBuf(cur);

          cur = (struct _ExBuf *)(void *)0;
        }

      }
  }
  _Bool tmp_if_expr$4;
  if(ex == pair->b)
  {
    if(ex->len == ex->bufmax)
      ex->len = 0;

    pair->t = ex;
  }

  else
  {
    if(ex->len >= 1)
      tmp_if_expr$4 = ex->len < ex->bufmax ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      pair->t = ex;

    else
    {
      pair->t = ex->next;
      ungetExBuf(ex);
    }
  }
  return err;
}

// sendPairUDPbuf
// file stone.c line 3005
static signed int sendPairUDPbuf(struct _Stone *stone, struct _Pair *pair, char *buf, signed int len)
{
  signed int flags = 0;
  struct _ExBuf *t;
  struct anonymous$0 *peer;
  signed int issrc = (signed int)((pair->proto & proto_command) == 0x0f00);
  signed int sd;
  struct _Pair *p = pair->pair;
  if((stone->proto & proto_block_d) == 0)
    flags = 64;

  t=getExData(pair, data_peeraddr, 0);
  signed int tmp_if_expr$1;
  if(!(t == ((struct _ExBuf *)NULL)))
    peer = (struct anonymous$0 *)(t->buf + (signed long int)sizeof(signed int) /*4ul*/ );

  else
    if(issrc == 0)
    {
      signed int lenmax;
      signed int dstlen;
      t=newExData(pair, data_peeraddr);
      peer = (struct anonymous$0 *)(t->buf + (signed long int)sizeof(signed int) /*4ul*/ );
      lenmax = (signed int)(((unsigned long int)t->bufmax - sizeof(signed int) /*4ul*/ ) - (unsigned long int)(signed int)&((struct anonymous$0 *)(void *)0)->addr);
      peer->len = stone->dsts[(signed long int)0]->len;
      bcopy((const void *)&stone->dsts[(signed long int)0]->addr, (void *)&peer->addr, (unsigned long int)peer->len);
      dstlen=modPairDest(pair, &peer->addr, (unsigned int)lenmax);
      if(dstlen >= 1)
        peer->len = (unsigned int)dstlen;

    }

    else
    {
      if(!(p == ((struct _Pair *)NULL)))
        tmp_if_expr$1 = p->sd;

      else
        tmp_if_expr$1 = -1;
      message(3, "%d UDP<TCP%d: can't happen: no peer", stone->sd, tmp_if_expr$1);
      return -1;
    }
  if(!(issrc == 0))
    sd = stone->sd;

  else
    sd = pair->sd;
  signed long int return_value_sendto$6;
  return_value_sendto$6=sendto(sd, (const void *)buf, (unsigned long int)len, flags, &peer->addr, peer->len);
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$4;
  if(!(return_value_sendto$6 == (signed long int)len))
  {
    char addrport[128l];
    addrport2str(&peer->addr, peer->len, proto_udp_s | proto_udp_d, addrport, 127, 0);
    addrport[(signed long int)127] = (char)0;
    if(!(issrc == 0))
    {
      if(!(p == ((struct _Pair *)NULL)))
        tmp_if_expr$2 = p->sd;

      else
        tmp_if_expr$2 = -1;
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      message(3, "%d UDP<TCP%d: sendto failed err=%d: to %s", stone->sd, tmp_if_expr$2, *return_value___errno_location$3, (const void *)addrport);
    }

    else
    {
      if(!(p == ((struct _Pair *)NULL)))
        tmp_if_expr$4 = p->sd;

      else
        tmp_if_expr$4 = -1;
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      message(3, "%d TCP%d>UDP%d: sendto failed err=%d: to %s", stone->sd, tmp_if_expr$4, pair->sd, *return_value___errno_location$5, (const void *)addrport);
    }
    return -1;
  }

  time(&pair->clock);
  if(!(p == ((struct _Pair *)NULL)))
    p->clock = pair->clock;

  pair->tx = pair->tx + len;
  return 0;
}

// sendUDP
// file stone.c line 2789
signed int sendUDP(struct _PktBuf *pb)
{
  struct _Origin *origin = pb->origin;
  struct _Stone *stone = origin->stone;
  signed int sd;
  signed int flags = 0;
  struct sockaddr *sa;
  unsigned int salen;
  char *dirstr;
  if(pb->type == 0x0003)
  {
    sd = origin->sd;
    sa = &stone->dsts[(signed long int)0]->addr;
    salen = stone->dsts[(signed long int)0]->len;
    dirstr = ">";
    if((stone->proto & proto_block_d) == 0)
      flags = 64;

  }

  else
  {
    sd = stone->sd;
    sa = &origin->from->addr;
    salen = origin->from->len;
    dirstr = "<";
    if((stone->proto & proto_block_s) == 0)
      flags = 64;

  }
  signed long int return_value_sendto$2;
  return_value_sendto$2=sendto(sd, (const void *)pb->buf, (unsigned long int)pb->len, flags, sa, salen);
  if(!(return_value_sendto$2 == (signed long int)pb->len))
  {
    char addrport[128l];
    addrport2str(sa, salen, proto_udp_s | proto_udp_d, addrport, 127, 0);
    addrport[(signed long int)127] = (char)0;
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    message(3, "%d UDP%s%d: sendto failed err=%d: to %s", stone->sd, dirstr, origin->sd, *return_value___errno_location$1, (const void *)addrport);
    return -1;
  }

  if(Debug >= 5)
  {
    char sendUDP$$1$$4$$addrport[128l];
    addrport2str(sa, salen, proto_udp_s | proto_udp_d, sendUDP$$1$$4$$addrport, 127, 0);
    sendUDP$$1$$4$$addrport[(signed long int)127] = (char)0;
    message(7, "%d UDP%s%d: %d bytes sent to %s", stone->sd, dirstr, origin->sd, pb->len, (const void *)sendUDP$$1$$4$$addrport);
  }

  if((0xF & (signed int)origin->xhost->mode) >= 1)
  {
    char head[128l];
    snprintf(head, (unsigned long int)127, "%d UDP%s%d:", stone->sd, dirstr, origin->sd);
    head[(signed long int)127] = (char)0;
    packet_dump(head, pb->buf, pb->len, origin->xhost);
  }

  return pb->len;
}

// setclose
// file stone.c line 4782
void setclose(struct _Pair *pair, signed int flag)
{
  signed int sd = pair->sd;
  message_time_log(pair);
  if((pair->proto & proto_close) == 0)
  {
    pair->proto = pair->proto | flag | proto_close;
    if(Debug >= 3 && sd >= 0)
      message(7, "%d TCP %d: close tx:%d rx:%d lp:%d", pair->stone->sd, sd, pair->tx, pair->rx, pair->loop);

  }

  if(sd >= 0)
  {
    pair->sd = -1;
    close(sd);
  }

}

// skipcomment
// file stone.c line 8523
static void skipcomment(struct _IO_FILE *fp)
{
  signed int c;
  do
  {
    c=_IO_getc(fp);
    if(c == -1)
      break;

    if(c == 13)
      break;

    if(c == 10)
      break;

  }
  while((_Bool)1);
  do
  {
    c=_IO_getc(fp);
    if(c == -1)
      break;

    if(!(c == 10) && !(c == 13))
      break;

  }
  while((_Bool)1);
  if(!(c == -1))
    ungetc(c, fp);

}

// ssl_servername_callback
// file stone.c line 7305
static signed int ssl_servername_callback(struct ssl_st *ssl, signed int *ad, void *arg)
{
  struct _Pair *pair;
  void *return_value_SSL_get_ex_data$1;
  return_value_SSL_get_ex_data$1=SSL_get_ex_data(ssl, PairIndex);
  pair = (struct _Pair *)return_value_SSL_get_ex_data$1;
  struct anonymous$12 *ss = pair->stone->ssl_server;
  struct _Stone *stone;
  const char *name;
  name=SSL_get_servername(ssl, 0);
  _Bool tmp_if_expr$2;
  if(ss == ((struct anonymous$12 *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(ss->name != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  signed int tmp_statement_expression$3;
  _Bool tmp_if_expr$5;
  signed int tmp_statement_expression$6;
  if(tmp_if_expr$2)
    return 3;

  else
    if(name == ((const char *)NULL))
    {
      if(!(ss == ((struct anonymous$12 *)NULL)))
      {
        if(!(ss->verbose == 0))
          message(7, "%d TCP %d: No servername, expects: %s", pair->stone->sd, pair->sd, ss->name);

      }

      return 0;
    }

    else
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp$4;
      return_value___builtin_strcmp$4=__builtin_strcmp(name, ss->name);
      tmp_statement_expression$3 = return_value___builtin_strcmp$4;
      if(tmp_statement_expression$3 == 0)
        return 0;

      else
      {
        stone = pair->stone->children;
        for( ; !(stone == ((struct _Stone *)NULL)); stone = stone->children)
        {
          struct anonymous$12 *sn = stone->ssl_server;
          if(sn == ((struct anonymous$12 *)NULL))
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = !(sn->name != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$5)
            return 3;

          unsigned long int ssl_servername_callback$$1$$3$$1$$1$$__s1_len;
          unsigned long int ssl_servername_callback$$1$$3$$1$$1$$__s2_len;
          signed int return_value___builtin_strcmp$7;
          return_value___builtin_strcmp$7=__builtin_strcmp(name, sn->name);
          tmp_statement_expression$6 = return_value___builtin_strcmp$7;
          if(tmp_statement_expression$6 == 0)
          {
            if(!(sn->verbose == 0))
              message(7, "%d TCP %d: Switching server context: %s", stone->sd, pair->sd, sn->name);

            SSL_set_SSL_CTX(ssl, sn->ctx);
            pair->stone = stone;
            return 0;
          }

        }
        return 2;
      }
    }
}

// sslopts
// file stone.c line 8911
signed int sslopts(signed int argc, signed int argi, char **argv, struct anonymous$8 *opts, signed int isserver)
{
  signed int tmp_statement_expression$84;
  unsigned long int sslopts$$1$$1$$__s1_len;
  unsigned long int sslopts$$1$$1$$__s2_len;
  signed int return_value___builtin_strcmp$85;
  return_value___builtin_strcmp$85=__builtin_strcmp(argv[(signed long int)argi], "default");
  tmp_statement_expression$84 = return_value___builtin_strcmp$85;
  signed int tmp_statement_expression$82;
  signed int return_value_strncmp$81;
  signed int tmp_statement_expression$5;
  signed int tmp_statement_expression$3;
  signed int tmp_statement_expression$1;
  signed int return_value_strncmp$78;
  _Bool tmp_if_expr$80;
  _Bool tmp_if_expr$79;
  signed int tmp_statement_expression$11;
  signed int tmp_statement_expression$9;
  signed int tmp_statement_expression$7;
  signed int return_value_strncmp$77;
  signed int return_value_strncmp$76;
  signed int return_value_strncmp$72;
  _Bool tmp_if_expr$74;
  const unsigned short int **return_value___ctype_b_loc$73;
  _Bool tmp_if_expr$75;
  signed int return_value_strncmp$68;
  _Bool tmp_if_expr$70;
  const unsigned short int **return_value___ctype_b_loc$69;
  _Bool tmp_if_expr$71;
  signed int return_value_strncmp$67;
  signed int tmp_statement_expression$65;
  signed int tmp_statement_expression$63;
  signed int tmp_statement_expression$61;
  signed int tmp_statement_expression$59;
  signed int tmp_statement_expression$57;
  signed int tmp_statement_expression$55;
  signed int tmp_statement_expression$53;
  signed int return_value_strncmp$52;
  signed int tmp_statement_expression$50;
  signed int return_value_strncmp$49;
  signed int return_value_strncmp$48;
  signed int return_value_strncmp$47;
  signed int return_value_strncmp$46;
  signed int return_value_strncmp$45;
  signed int return_value_strncmp$44;
  signed int return_value_strncmp$43;
  signed int return_value_strncmp$42;
  signed int return_value_strncmp$41;
  signed int return_value_strncmp$40;
  signed int return_value_strncmp$39;
  signed int return_value_strncmp$38;
  signed int return_value_strncmp$37;
  signed int return_value_strncmp$36;
  signed int return_value_strncmp$35;
  signed int return_value_strncmp$31;
  _Bool tmp_if_expr$33;
  const unsigned short int **return_value___ctype_b_loc$32;
  _Bool tmp_if_expr$34;
  if(tmp_statement_expression$84 == 0)
    sslopts_default(opts, isserver);

  else
  {
    unsigned long int sslopts$$1$$3$$__s1_len;
    unsigned long int sslopts$$1$$3$$__s2_len;
    signed int return_value___builtin_strcmp$83;
    return_value___builtin_strcmp$83=__builtin_strcmp(argv[(signed long int)argi], "verbose");
    tmp_statement_expression$82 = return_value___builtin_strcmp$83;
    if(tmp_statement_expression$82 == 0)
      opts->verbose = opts->verbose + 1;

    else
    {
      return_value_strncmp$81=strncmp(argv[(signed long int)argi], "shutdown=", (unsigned long int)9);
      if(return_value_strncmp$81 == 0)
      {
        unsigned long int sslopts$$1$$6$$1$$__s1_len;
        unsigned long int sslopts$$1$$6$$1$$__s2_len;
        signed int return_value___builtin_strcmp$6;
        return_value___builtin_strcmp$6=__builtin_strcmp(argv[(signed long int)argi] + (signed long int)9, "nowait");
        tmp_statement_expression$5 = return_value___builtin_strcmp$6;
        if(tmp_statement_expression$5 == 0)
          opts->shutdown_mode = 2;

        else
        {
          unsigned long int sslopts$$1$$6$$3$$__s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp$4;
          return_value___builtin_strcmp$4=__builtin_strcmp(argv[(signed long int)argi] + (signed long int)9, "accurate");
          tmp_statement_expression$3 = return_value___builtin_strcmp$4;
          if(tmp_statement_expression$3 == 0)
            opts->shutdown_mode = 0;

          else
          {
            unsigned long int sslopts$$1$$6$$5$$__s1_len;
            unsigned long int sslopts$$1$$6$$5$$__s2_len;
            signed int return_value___builtin_strcmp$2;
            return_value___builtin_strcmp$2=__builtin_strcmp(argv[(signed long int)argi] + (signed long int)9, "unclean");
            tmp_statement_expression$1 = return_value___builtin_strcmp$2;
            if(tmp_statement_expression$1 == 0)
              opts->shutdown_mode = 1 | 2;

          }
        }
      }

      else
      {
        return_value_strncmp$78=strncmp(argv[(signed long int)argi], "verify", (unsigned long int)6);
        if(return_value_strncmp$78 == 0)
        {
          if((signed int)argv[(signed long int)argi][6l] == 0)
            tmp_if_expr$79 = (_Bool)1;

          else
            tmp_if_expr$79 = (signed int)argv[(signed long int)argi][(signed long int)6] == 44 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$80 = tmp_if_expr$79 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$80 = (_Bool)0;
        if(tmp_if_expr$80)
        {
          unsigned long int sslopts$$1$$8$$1$$__s1_len;
          unsigned long int sslopts$$1$$8$$1$$__s2_len;
          signed int return_value___builtin_strcmp$12;
          return_value___builtin_strcmp$12=__builtin_strcmp(argv[(signed long int)argi] + (signed long int)6, ",none");
          tmp_statement_expression$11 = return_value___builtin_strcmp$12;
          if(tmp_statement_expression$11 == 0)
            opts->mode = 0x00;

          else
            if(!(isserver == 0))
            {
              opts->mode = 0x01 | 0x02;
              if((signed int)argv[(signed long int)argi][6l] == 44)
              {
                unsigned long int sslopts$$1$$8$$3$$1$$1$$__s1_len;
                unsigned long int sslopts$$1$$8$$3$$1$$1$$__s2_len;
                signed int return_value___builtin_strcmp$10;
                return_value___builtin_strcmp$10=__builtin_strcmp(argv[(signed long int)argi] + (signed long int)7, "ifany");
                tmp_statement_expression$9 = return_value___builtin_strcmp$10;
                if(tmp_statement_expression$9 == 0)
                  opts->mode = 0x01 | 0x04;

                else
                {
                  unsigned long int sslopts$$1$$8$$3$$1$$3$$__s1_len;
                  unsigned long int sslopts$$1$$8$$3$$1$$3$$__s2_len;
                  signed int return_value___builtin_strcmp$8;
                  return_value___builtin_strcmp$8=__builtin_strcmp(argv[(signed long int)argi] + (signed long int)7, "once");
                  tmp_statement_expression$7 = return_value___builtin_strcmp$8;
                  if(tmp_statement_expression$7 == 0)
                    opts->mode = opts->mode | 0x04;

                }
              }

            }

            else
              if((signed int)argv[(signed long int)argi][6l] == 0)
                opts->mode = 0x01;

              else
                goto error;
        }

        else
        {
          return_value_strncmp$77=strncmp(argv[(signed long int)argi], "crl_check", (unsigned long int)9);
          if(return_value_strncmp$77 == 0)
            opts->vflags = opts->vflags | 0x4;

          else
          {
            return_value_strncmp$76=strncmp(argv[(signed long int)argi], "crl_check_all", (unsigned long int)13);
            if(return_value_strncmp$76 == 0)
              opts->vflags = opts->vflags | 0x4 | 0x8;

            else
            {
              return_value_strncmp$72=strncmp(argv[(signed long int)argi], "re", (unsigned long int)2);
              if(return_value_strncmp$72 == 0)
              {
                return_value___ctype_b_loc$73=__ctype_b_loc();
                tmp_if_expr$74 = ((signed int)(*return_value___ctype_b_loc$73)[(signed long int)(signed int)argv[(signed long int)argi][(signed long int)2]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$74 = (_Bool)0;
              if(tmp_if_expr$74)
                tmp_if_expr$75 = (signed int)argv[(signed long int)argi][(signed long int)3] == 61 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$75 = (_Bool)0;
              if(tmp_if_expr$75)
              {
                signed int depth;
                depth=atoi(argv[(signed long int)argi] + (signed long int)2);
                if(depth >= 0 && !(depth >= 10))
                {
                  char *return_value___strdup$13;
                  return_value___strdup$13=__strdup(argv[(signed long int)argi] + (signed long int)4);
                  opts->regexp[(signed long int)depth] = return_value___strdup$13;
                }

                else
                  goto error;
              }

              else
              {
                return_value_strncmp$68=strncmp(argv[(signed long int)argi], "re-", (unsigned long int)3);
                if(return_value_strncmp$68 == 0)
                {
                  return_value___ctype_b_loc$69=__ctype_b_loc();
                  tmp_if_expr$70 = ((signed int)(*return_value___ctype_b_loc$69)[(signed long int)(signed int)argv[(signed long int)argi][(signed long int)3]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$70 = (_Bool)0;
                if(tmp_if_expr$70)
                  tmp_if_expr$71 = (signed int)argv[(signed long int)argi][(signed long int)4] == 61 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$71 = (_Bool)0;
                if(tmp_if_expr$71)
                {
                  signed int sslopts$$1$$16$$depth;
                  sslopts$$1$$16$$depth=atoi(argv[(signed long int)argi] + (signed long int)3);
                  if(sslopts$$1$$16$$depth >= 1 && !(sslopts$$1$$16$$depth >= 11))
                  {
                    char *return_value___strdup$14;
                    return_value___strdup$14=__strdup(argv[(signed long int)argi] + (signed long int)5);
                    opts->regexp[(signed long int)(10 - sslopts$$1$$16$$depth)] = return_value___strdup$14;
                  }

                  else
                    goto error;
                }

                else
                {
                  return_value_strncmp$67=strncmp(argv[(signed long int)argi], "depth=", (unsigned long int)6);
                  if(return_value_strncmp$67 == 0)
                  {
                    opts->depth=atoi(argv[(signed long int)argi] + (signed long int)6);
                    if(opts->depth >= 10)
                      opts->depth = 10 - 1;

                    else
                      if(!(opts->depth >= 0))
                        opts->depth = 0;

                  }

                  else
                  {
                    unsigned long int __s1_len;
                    unsigned long int sslopts$$1$$19$$__s2_len;
                    signed int return_value___builtin_strcmp$66;
                    return_value___builtin_strcmp$66=__builtin_strcmp(argv[(signed long int)argi], "bugs");
                    tmp_statement_expression$65 = return_value___builtin_strcmp$66;
                    if(tmp_statement_expression$65 == 0)
                      opts->off = opts->off | 0x80000BFFL;

                    else
                    {
                      unsigned long int sslopts$$1$$21$$__s1_len;
                      unsigned long int sslopts$$1$$21$$__s2_len;
                      signed int return_value___builtin_strcmp$64;
                      return_value___builtin_strcmp$64=__builtin_strcmp(argv[(signed long int)argi], "tls1");
                      tmp_statement_expression$63 = return_value___builtin_strcmp$64;
                      if(tmp_statement_expression$63 == 0)
                      {
                        if(!(isserver == 0))
                          opts->meth=TLSv1_server_method();

                        else
                          opts->meth=TLSv1_client_method();
                      }

                      else
                      {
                        unsigned long int sslopts$$1$$23$$__s1_len;
                        unsigned long int sslopts$$1$$23$$__s2_len;
                        signed int return_value___builtin_strcmp$62;
                        return_value___builtin_strcmp$62=__builtin_strcmp(argv[(signed long int)argi], "no_tls1");
                        tmp_statement_expression$61 = return_value___builtin_strcmp$62;
                        if(tmp_statement_expression$61 == 0)
                          opts->off = opts->off | 0x04000000L;

                        else
                        {
                          unsigned long int sslopts$$1$$25$$__s1_len;
                          unsigned long int sslopts$$1$$25$$__s2_len;
                          signed int return_value___builtin_strcmp$60;
                          return_value___builtin_strcmp$60=__builtin_strcmp(argv[(signed long int)argi], "no_ssl3");
                          tmp_statement_expression$59 = return_value___builtin_strcmp$60;
                          if(tmp_statement_expression$59 == 0)
                            opts->off = opts->off | 0x02000000L;

                          else
                          {
                            unsigned long int sslopts$$1$$27$$__s1_len;
                            unsigned long int sslopts$$1$$27$$__s2_len;
                            signed int return_value___builtin_strcmp$58;
                            return_value___builtin_strcmp$58=__builtin_strcmp(argv[(signed long int)argi], "no_ssl2");
                            tmp_statement_expression$57 = return_value___builtin_strcmp$58;
                            if(tmp_statement_expression$57 == 0)
                              opts->off = opts->off | 0x01000000L;

                            else
                            {
                              unsigned long int sslopts$$1$$29$$__s1_len;
                              unsigned long int sslopts$$1$$29$$__s2_len;
                              signed int return_value___builtin_strcmp$56;
                              return_value___builtin_strcmp$56=__builtin_strcmp(argv[(signed long int)argi], "serverpref");
                              tmp_statement_expression$55 = return_value___builtin_strcmp$56;
                              if(tmp_statement_expression$55 == 0)
                                opts->off = opts->off | 0x00400000L;

                              else
                              {
                                unsigned long int sslopts$$1$$31$$__s1_len;
                                unsigned long int sslopts$$1$$31$$__s2_len;
                                signed int return_value___builtin_strcmp$54;
                                return_value___builtin_strcmp$54=__builtin_strcmp(argv[(signed long int)argi], "uniq");
                                tmp_statement_expression$53 = return_value___builtin_strcmp$54;
                                if(tmp_statement_expression$53 == 0)
                                  opts->serial = (signed long int)-1;

                                else
                                {
                                  return_value_strncmp$52=strncmp(argv[(signed long int)argi], "sid_ctx=", (unsigned long int)8);
                                  if(return_value_strncmp$52 == 0)
                                  {
                                    char *return_value___strdup$15;
                                    return_value___strdup$15=__strdup(argv[(signed long int)argi] + (signed long int)8);
                                    opts->sid_ctx = (unsigned char *)return_value___strdup$15;
                                  }

                                  else
                                  {
                                    unsigned long int sslopts$$1$$35$$__s1_len;
                                    unsigned long int sslopts$$1$$35$$__s2_len;
                                    signed int return_value___builtin_strcmp$51;
                                    return_value___builtin_strcmp$51=__builtin_strcmp(argv[(signed long int)argi], "sni");
                                    tmp_statement_expression$50 = return_value___builtin_strcmp$51;
                                    if(tmp_statement_expression$50 == 0)
                                      opts->useSNI = 1;

                                    else
                                    {
                                      return_value_strncmp$49=strncmp(argv[(signed long int)argi], "servername=", (unsigned long int)11);
                                      if(return_value_strncmp$49 == 0)
                                      {
                                        char *return_value___strdup$16;
                                        return_value___strdup$16=__strdup(argv[(signed long int)argi] + (signed long int)11);
                                        opts->servername = return_value___strdup$16;
                                      }

                                      else
                                      {
                                        return_value_strncmp$48=strncmp(argv[(signed long int)argi], "key=", (unsigned long int)4);
                                        if(return_value_strncmp$48 == 0)
                                        {
                                          char *return_value___strdup$17;
                                          return_value___strdup$17=__strdup(argv[(signed long int)argi] + (signed long int)4);
                                          opts->keyFile = return_value___strdup$17;
                                          opts->keyFilePat = (char *)(void *)0;
                                          opts->pfxFile = (char *)(void *)0;
                                        }

                                        else
                                        {
                                          return_value_strncmp$47=strncmp(argv[(signed long int)argi], "keypat=", (unsigned long int)7);
                                          if(return_value_strncmp$47 == 0)
                                          {
                                            char *return_value___strdup$18;
                                            return_value___strdup$18=__strdup(argv[(signed long int)argi] + (signed long int)7);
                                            opts->keyFilePat = return_value___strdup$18;
                                            opts->pfxFile = (char *)(void *)0;
                                          }

                                          else
                                          {
                                            return_value_strncmp$46=strncmp(argv[(signed long int)argi], "cert=", (unsigned long int)5);
                                            if(return_value_strncmp$46 == 0)
                                            {
                                              char *return_value___strdup$19;
                                              return_value___strdup$19=__strdup(argv[(signed long int)argi] + (signed long int)5);
                                              opts->certFile = return_value___strdup$19;
                                              opts->certFilePat = (char *)(void *)0;
                                              opts->pfxFile = (char *)(void *)0;
                                            }

                                            else
                                            {
                                              return_value_strncmp$45=strncmp(argv[(signed long int)argi], "certpat=", (unsigned long int)8);
                                              if(return_value_strncmp$45 == 0)
                                              {
                                                char *return_value___strdup$20;
                                                return_value___strdup$20=__strdup(argv[(signed long int)argi] + (signed long int)8);
                                                opts->certFilePat = return_value___strdup$20;
                                                opts->pfxFile = (char *)(void *)0;
                                              }

                                              else
                                              {
                                                return_value_strncmp$44=strncmp(argv[(signed long int)argi], "certkey=", (unsigned long int)8);
                                                if(return_value_strncmp$44 == 0)
                                                {
                                                  char *return_value___strdup$21;
                                                  return_value___strdup$21=__strdup(argv[(signed long int)argi] + (signed long int)8);
                                                  opts->certFile = return_value___strdup$21;
                                                  opts->keyFile = opts->certFile;
                                                  opts->certFilePat = (char *)(void *)0;
                                                  opts->keyFilePat = opts->certFilePat;
                                                  opts->pfxFile = (char *)(void *)0;
                                                }

                                                else
                                                {
                                                  return_value_strncmp$43=strncmp(argv[(signed long int)argi], "certkeypat=", (unsigned long int)11);
                                                  if(return_value_strncmp$43 == 0)
                                                  {
                                                    char *return_value___strdup$22;
                                                    return_value___strdup$22=__strdup(argv[(signed long int)argi] + (signed long int)11);
                                                    opts->certFilePat = return_value___strdup$22;
                                                    opts->keyFilePat = opts->certFilePat;
                                                    opts->pfxFile = (char *)(void *)0;
                                                  }

                                                  else
                                                  {
                                                    return_value_strncmp$42=strncmp(argv[(signed long int)argi], "CAfile=", (unsigned long int)7);
                                                    if(return_value_strncmp$42 == 0)
                                                    {
                                                      char *return_value___strdup$23;
                                                      return_value___strdup$23=__strdup(argv[(signed long int)argi] + (signed long int)7);
                                                      opts->caFile = return_value___strdup$23;
                                                    }

                                                    else
                                                    {
                                                      return_value_strncmp$41=strncmp(argv[(signed long int)argi], "CApath=", (unsigned long int)7);
                                                      if(return_value_strncmp$41 == 0)
                                                      {
                                                        char *return_value___strdup$24;
                                                        return_value___strdup$24=__strdup(argv[(signed long int)argi] + (signed long int)7);
                                                        opts->caPath = return_value___strdup$24;
                                                      }

                                                      else
                                                      {
                                                        return_value_strncmp$40=strncmp(argv[(signed long int)argi], "pfx=", (unsigned long int)4);
                                                        if(return_value_strncmp$40 == 0)
                                                        {
                                                          char *return_value___strdup$25;
                                                          return_value___strdup$25=__strdup(argv[(signed long int)argi] + (signed long int)4);
                                                          opts->pfxFile = return_value___strdup$25;
                                                          opts->pfxFilePat = (char *)(void *)0;
                                                          opts->certFile = (char *)(void *)0;
                                                          opts->keyFile = opts->certFile;
                                                          opts->certFilePat = (char *)(void *)0;
                                                          opts->keyFilePat = opts->certFilePat;
                                                        }

                                                        else
                                                        {
                                                          return_value_strncmp$39=strncmp(argv[(signed long int)argi], "pfxpat=", (unsigned long int)7);
                                                          if(return_value_strncmp$39 == 0)
                                                          {
                                                            char *return_value___strdup$26;
                                                            return_value___strdup$26=__strdup(argv[(signed long int)argi] + (signed long int)7);
                                                            opts->pfxFilePat = return_value___strdup$26;
                                                            opts->certFile = (char *)(void *)0;
                                                            opts->keyFile = opts->certFile;
                                                            opts->certFilePat = (char *)(void *)0;
                                                            opts->keyFilePat = opts->certFilePat;
                                                          }

                                                          else
                                                          {
                                                            return_value_strncmp$38=strncmp(argv[(signed long int)argi], "passfile=", (unsigned long int)9);
                                                            if(return_value_strncmp$38 == 0)
                                                            {
                                                              char *return_value___strdup$27;
                                                              return_value___strdup$27=__strdup(argv[(signed long int)argi] + (signed long int)9);
                                                              opts->passFile = return_value___strdup$27;
                                                              opts->passFilePat = (char *)(void *)0;
                                                            }

                                                            else
                                                            {
                                                              return_value_strncmp$37=strncmp(argv[(signed long int)argi], "passfilepat=", (unsigned long int)12);
                                                              if(return_value_strncmp$37 == 0)
                                                              {
                                                                char *return_value___strdup$28;
                                                                return_value___strdup$28=__strdup(argv[(signed long int)argi] + (signed long int)12);
                                                                opts->passFilePat = return_value___strdup$28;
                                                                opts->passFile = (char *)(void *)0;
                                                              }

                                                              else
                                                              {
                                                                return_value_strncmp$36=strncmp(argv[(signed long int)argi], "ignore", (unsigned long int)6);
                                                                if(return_value_strncmp$36 == 0)
                                                                  opts->certIgnore = 1;

                                                                else
                                                                {
                                                                  return_value_strncmp$35=strncmp(argv[(signed long int)argi], "cipher=", (unsigned long int)7);
                                                                  if(return_value_strncmp$35 == 0)
                                                                  {
                                                                    char *return_value___strdup$29;
                                                                    return_value___strdup$29=__strdup(argv[(signed long int)argi] + (signed long int)7);
                                                                    opts->cipherList = return_value___strdup$29;
                                                                  }

                                                                  else
                                                                  {
                                                                    return_value_strncmp$31=strncmp(argv[(signed long int)argi], "lb", (unsigned long int)2);
                                                                    if(return_value_strncmp$31 == 0)
                                                                    {
                                                                      return_value___ctype_b_loc$32=__ctype_b_loc();
                                                                      tmp_if_expr$33 = ((signed int)(*return_value___ctype_b_loc$32)[(signed long int)(signed int)argv[(signed long int)argi][(signed long int)2]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
                                                                    }

                                                                    else
                                                                      tmp_if_expr$33 = (_Bool)0;
                                                                    if(tmp_if_expr$33)
                                                                      tmp_if_expr$34 = (signed int)argv[(signed long int)argi][(signed long int)3] == 61 ? (_Bool)1 : (_Bool)0;

                                                                    else
                                                                      tmp_if_expr$34 = (_Bool)0;
                                                                    if(tmp_if_expr$34)
                                                                    {
                                                                      opts->lbparm = (unsigned char)((signed int)argv[(signed long int)argi][(signed long int)2] - 48);
                                                                      signed int return_value_atoi$30;
                                                                      return_value_atoi$30=atoi(argv[(signed long int)argi] + (signed long int)4);
                                                                      opts->lbmod = (unsigned char)return_value_atoi$30;
                                                                    }

                                                                    else
                                                                    {

                                                                    error:
                                                                      ;
                                                                      message(3, "Invalid SSL Option: %s", argv[(signed long int)argi]);
                                                                      help(argv[(signed long int)0], "ssl");
                                                                      exit(1);
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return argi;
}

// sslopts_default
// file stone.c line 8857
void sslopts_default(struct anonymous$8 *opts, signed int isserver)
{
  signed int i;
  opts->verbose = 0;
  opts->shutdown_mode = 0;
  opts->mode = 0x00;
  opts->depth = 10 - 1;
  opts->vflags = 0;
  opts->off = (signed long int)0;
  opts->serial = (signed long int)-2;
  opts->callback = verify_callback;
  opts->sid_ctx = (unsigned char *)(void *)0;
  opts->useSNI = 0;
  if(!(isserver == 0))
  {
    char path[2048l];
    const char *return_value_X509_get_default_cert_dir$1;
    return_value_X509_get_default_cert_dir$1=X509_get_default_cert_dir();
    snprintf(path, (unsigned long int)(2048 - 1), "%s/stone.pem", return_value_X509_get_default_cert_dir$1);
    char *return_value___strdup$2;
    return_value___strdup$2=__strdup(path);
    opts->certFile = return_value___strdup$2;
    opts->keyFile = opts->certFile;
    opts->certFilePat = (char *)(void *)0;
    opts->keyFilePat = opts->certFilePat;
  }

  else
  {
    opts->certFile = (char *)(void *)0;
    opts->keyFile = opts->certFile;
    opts->certFilePat = (char *)(void *)0;
    opts->keyFilePat = opts->certFilePat;
  }
  opts->caPath = (char *)(void *)0;
  opts->caFile = opts->caPath;
  opts->pfxFile = (char *)(void *)0;
  opts->pfxFilePat = (char *)(void *)0;
  opts->passFile = (char *)(void *)0;
  opts->passFilePat = (char *)(void *)0;
  opts->passwd = (char *)(void *)0;
  opts->servername = (char *)(void *)0;
  opts->certIgnore = 0;
  opts->cipherList=getenv("SSL_CIPHER");
  i = 0;
  for( ; !(i >= 10); i = i + 1)
    opts->regexp[(signed long int)i] = (char *)(void *)0;
  opts->lbmod = (unsigned char)0;
  opts->lbparm = (unsigned char)0xFF;
  opts->shutdown_mode = 0;
}

// sslthread_id_callback
// file stone.c line 9067
unsigned long int sslthread_id_callback(void)
{
  unsigned long int ret;
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  ret = (unsigned long int)return_value_pthread_self$1;
  if(Debug >= 20)
    message(7, "SSL_thread id=%ld", ret);

  return ret;
}

// sslthread_initialize
// file stone.c line 9106
signed int sslthread_initialize(void)
{
  signed int i;
  NSSLMutexs=CRYPTO_num_locks();
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)NSSLMutexs * sizeof(union anonymous$3) /*40ul*/ );
  SSLMutex = (union anonymous$3 *)return_value_malloc$1;
  if(SSLMutex == ((union anonymous$3 *)NULL))
    return -1;

  else
  {
    if(Debug >= 2)
      message(7, "SSL thread nlocks=%d", NSSLMutexs);

    i = 0;
    for( ; !(i >= NSSLMutexs); i = i + 1)
      pthread_mutex_init(&SSLMutex[(signed long int)i], (const union anonymous$17 *)(void *)0);
    CRYPTO_set_id_callback(sslthread_id_callback);
    CRYPTO_set_locking_callback(sslthread_lock_callback);
    return 1;
  }
}

// sslthread_lock_callback
// file stone.c line 9080
void sslthread_lock_callback(signed int mode, signed int n, const char *file, signed int line)
{
  if(!((1 & mode) == 0))
  {
    if(Debug >= 20)
      message(7, "SSL_lock mode=%x n=%d file=%s line=%d", mode, n, file, line);

    pthread_mutex_lock(&SSLMutex[(signed long int)n]);
  }

  else
  {
    if(Debug >= 20)
      message(7, "SSL_unlock mode=%x n=%d file=%s line=%d", mode, n, file, line);

    pthread_mutex_unlock(&SSLMutex[(signed long int)n]);
  }
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat$1;
  return_value___xstat$1=__xstat(1, __path, __statbuf);
  return return_value___xstat$1;
}

// stone2str
// file stone.c line 2313
char * stone2str(struct _Stone *stone, char *str, signed int strlen)
{
  signed int proto;
  char src[128l];
  addrport2str(&stone->listen->addr, stone->listen->len, stone->proto & (proto_udp_s | proto_command | proto_ohttp_s | proto_base_s | proto_v6_s | proto_ip_only_s | proto_ssl_s | proto_ident), src, 127, 0);
  src[(signed long int)127] = (char)0;
  proto = stone->proto;
  if((proto_command & proto) == 0x0600)
    snprintf(str, (unsigned long int)strlen, "stone %d: proxy <- %s", stone->sd, (const void *)src);

  else
    if((proto_command & proto) == 0x0400)
      snprintf(str, (unsigned long int)strlen, "stone %d: health <- %s", stone->sd, (const void *)src);

    else
      if((proto_command & proto) == 0x0500)
        snprintf(str, (unsigned long int)strlen, "stone %d: identd <- %s", stone->sd, (const void *)src);

      else
      {
        char dst[128l];
        addrport2str(&stone->dsts[(signed long int)0]->addr, stone->dsts[(signed long int)0]->len, stone->proto & (proto_udp_d | proto_command | proto_ohttp_d | proto_base_d | proto_v6_d | proto_ip_only_d | proto_ssl_d | proto_nobackup), dst, 127, 0);
        dst[(signed long int)127] = (char)0;
        snprintf(str, (unsigned long int)strlen, "stone %d: %s <- %s", stone->sd, (const void *)dst, (const void *)src);
      }
  str[(signed long int)strlen] = (char)0;
  return str;
}

// str2bin
// file stone.c line 2178
char * str2bin(char *p, signed int *lenp)
{
  char buf[2048l];
  char c;
  signed int i = 0;
  char *tmp_post$1;
  char *tmp_post$2;
  signed int return_value_str2num$3;
  signed int return_value_str2num$4;
  signed int tmp_post$5;
  do
  {
    tmp_post$1 = p;
    p = p + 1l;
    c = *tmp_post$1;
    if(c == 0)
      break;

    if(i >= 2048)
      break;

    if((signed int)c == 92)
    {
      tmp_post$2 = p;
      p = p + 1l;
      c = *tmp_post$2;
      switch((signed int)c)
      {
        case 110:
        {
          c = (char)10;
          break;
        }
        case 114:
        {
          c = (char)13;
          break;
        }
        case 116:
        {
          c = (char)9;
          break;
        }
        case 48:
        {
          return_value_str2num$3=str2num(&p, 8);
          c = (char)return_value_str2num$3;
          break;
        }
        case 120:
        {
          return_value_str2num$4=str2num(&p, 16);
          c = (char)return_value_str2num$4;
          break;
        }
        case 0:
        {
          c = (char)92;
          p = p - 1l;
        }
      }
    }

    tmp_post$5 = i;
    i = i + 1;
    buf[(signed long int)tmp_post$5] = c;
  }
  while((_Bool)1);
  void *return_value_malloc$6;
  return_value_malloc$6=malloc((unsigned long int)i);
  p = (char *)return_value_malloc$6;
  if(p == ((char *)NULL))
  {
    message(2, "Out of memory, can't make str");
    exit(1);
  }

  bcopy((const void *)buf, (void *)p, (unsigned long int)i);
  *lenp = i;
  return p;
}

// str2num
// file stone.c line 2155
signed int str2num(char **pp, signed int rad)
{
  char *p;
  signed int num;
  signed int i;
  p = *pp;
  num = 0;
  i = 0;
  signed int tmp_statement_expression$1;
  signed int tmp_if_expr$3;
  const signed int **return_value___ctype_toupper_loc$2;
  const signed int **return_value___ctype_toupper_loc$4;
  for( ; !(i >= 3); i = i + 1)
  {
    char c = p[(signed long int)i];
    if((signed int)c >= 48 && !((signed int)c >= 58))
      num = num * rad + (signed int)c;

    else
    {
      signed int __res;
      return_value___ctype_toupper_loc$4=__ctype_toupper_loc();
      __res = (*return_value___ctype_toupper_loc$4)[(signed long int)(signed int)c];
      tmp_statement_expression$1 = __res;
      c = (char)tmp_statement_expression$1;
      if(65 + rad + -11 >= (signed int)c && rad >= 11 && (signed int)c >= 65)
        num = num * rad + ((signed int)c - 65) + 10;

      else
        break;
    }
  }
  *pp = p;
  return num;
}

// strnAddr
// file stone.c line 4449
signed int strnAddr(char *buf, signed int limit, signed int sd, signed int which, signed int isport)
{
  struct sockaddr_storage ss;
  struct sockaddr *name = (struct sockaddr *)&ss;
  unsigned int namelen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  signed int len;
  char str[128l];
  signed int ret;
  if(which == 1)
  {
    ret=getsockopt(sd, 0, 80, (void *)name, &namelen);
    goto __CPROVER_DUMP_L3;
  }

  ret=getpeername(sd, name, &namelen);

__CPROVER_DUMP_L3:
  ;
  if(!(ret >= 0))
  {
    if(!(isport == 0))
      strcpy(str, "0.0.0.0:0");

    else
      strcpy(str, "0.0.0.0");
  }

  else
  {
    if(!(isport == 0))
      addrport2str(name, namelen, 0, str, 127, 0);

    else
      addr2str(name, namelen, str, 127, 0);
    str[(signed long int)127] = (char)0;
  }
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  len = (signed int)return_value_strlen$1;
  if(!(limit >= len))
    len = limit;

  __builtin_strncpy(buf, str, (unsigned long int)len);
  return len;
}

// strnUser
// file stone.c line 4489
signed int strnUser(char *buf, signed int limit, struct _Pair *pair, signed int which)
{
  struct _Stone *stone = pair->stone;
  struct _ExBuf *ex;
  signed int len;
  char str[128l];
  str[(signed long int)0] = (char)0;
  _Bool tmp_if_expr$5;
  if(which == 2)
  {
    ex=getExData(pair, data_identuser, 0);
    tmp_if_expr$5 = ex != ((struct _ExBuf *)NULL) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$5 = (_Bool)0;
  unsigned int tmp_if_expr$3;
  unsigned int tmp_if_expr$4;
  if(tmp_if_expr$5)
  {
    len = (signed int)((unsigned long int)ex->len - sizeof(signed int) /*4ul*/ );
    __builtin_strncpy(str, ex->buf + (signed long int)sizeof(signed int) /*4ul*/ , (unsigned long int)len);
    str[(signed long int)len] = (char)0;
  }

  else
    if((signed int)stone->listen->addr.sa_family == 1)
    {
      struct ucred *cred = (struct ucred *)(void *)0;
      ex=getExData(pair, data_ucred, 0);
      if(!(ex == ((struct _ExBuf *)NULL)))
        cred = (struct ucred *)(ex->buf + (signed long int)sizeof(signed int) /*4ul*/ );

      else
      {
        unsigned int optlen = (unsigned int)sizeof(struct ucred) /*12ul*/ ;
        ex=newExData(pair, data_ucred);
        if(!(ex == ((struct _ExBuf *)NULL)))
        {
          cred = (struct ucred *)(ex->buf + (signed long int)sizeof(signed int) /*4ul*/ );
          signed int return_value_getsockopt$2;
          return_value_getsockopt$2=getsockopt(pair->sd, 1, 17, (void *)cred, &optlen);
          if(!(return_value_getsockopt$2 >= 0))
          {
            signed int *return_value___errno_location$1;
            return_value___errno_location$1=__errno_location();
            message(3, "%d TCP %d: Can't get PEERCRED err=%d", stone->sd, pair->sd, *return_value___errno_location$1);
            ungetExBuf(ex);
            cred = (struct ucred *)(void *)0;
          }

        }

      }
      switch(which)
      {
        case 1:
        {
          if(!(cred == ((struct ucred *)NULL)))
            tmp_if_expr$3 = cred->gid;

          else
            tmp_if_expr$3 = (unsigned int)-1;
          snprintf(str, (unsigned long int)127, "%d", tmp_if_expr$3);
          break;
        }
        case 2:
        {
          str[0l] = (char)0;
          if(!(cred == ((struct ucred *)NULL)))
          {
            struct passwd pwbuf;
            char strnUser$$1$$2$$3$$1$$sbuf[128l];
            struct passwd *passwd;
            signed int strnUser$$1$$2$$3$$1$$ret;
            strnUser$$1$$2$$3$$1$$ret=getpwuid_r(cred->uid, &pwbuf, strnUser$$1$$2$$3$$1$$sbuf, (unsigned long int)127, &passwd);
            if(strnUser$$1$$2$$3$$1$$ret == 0)
              snprintf(str, (unsigned long int)127, "%s", passwd->pw_name);

          }

          break;
        }
        case 3:
        {
          str[0l] = (char)0;
          if(!(cred == ((struct ucred *)NULL)))
          {
            struct group gbuf;
            char sbuf[128l];
            struct group *group;
            signed int ret;
            ret=getgrgid_r(cred->gid, &gbuf, sbuf, (unsigned long int)127, &group);
            if(ret == 0)
              snprintf(str, (unsigned long int)127, "%s", group->gr_name);

          }

          break;
        }
        default:
        {
          if(!(cred == ((struct ucred *)NULL)))
            tmp_if_expr$4 = cred->uid;

          else
            tmp_if_expr$4 = (unsigned int)-1;
          snprintf(str, (unsigned long int)127, "%d", tmp_if_expr$4);
        }
      }
    }

  unsigned long int return_value_strlen$6;
  return_value_strlen$6=strlen(str);
  len = (signed int)return_value_strlen$6;
  if(!(limit >= len))
    len = limit;

  __builtin_strncpy(buf, str, (unsigned long int)len);
  return len;
}

// strnparse
// file stone.c line 4568
signed int strnparse(char *buf, signed int limit, char **pp, struct _Pair *pair, char term)
{
  signed int i = 0;
  char *p;
  char c;
  char **match = (char **)(void *)0;
  struct ssl_st *ssl = pair->ssl;
  struct ssl_session_st *sess = (struct ssl_session_st *)(void *)0;
  signed int cond;
  p = *pp;
  char *tmp_post$1;
  char *tmp_post$2;
  char *tmp_post$3;
  void *return_value_SSL_SESSION_get_ex_data$4;
  signed int return_value_strnAddr$8;
  signed int return_value_strnAddr$9;
  signed int return_value_strnAddr$10;
  signed int return_value_strnAddr$11;
  signed int return_value_strnUser$12;
  signed int return_value_strnUser$13;
  signed int return_value_strnUser$14;
  signed int return_value_strnUser$15;
  signed int tmp_post$16;
  while(!(i >= limit))
  {
    tmp_post$1 = p;
    p = p + 1l;
    c = *tmp_post$1;
    if(c == 0)
      break;

    if((signed int)c == 92)
    {
      tmp_post$2 = p;
      p = p + 1l;
      c = *tmp_post$2;
      if(c == term)
        break;

      cond = -1;
      if((signed int)c == 63)
      {
        cond = 0;
        tmp_post$3 = p;
        p = p + 1l;
        c = *tmp_post$3;
      }

      if((signed int)c >= 48 && !((signed int)c >= 58))
      {
        if(match == ((char **)NULL) && !(ssl == ((struct ssl_st *)NULL)))
        {
          sess=SSL_get1_session(ssl);
          if(!(sess == ((struct ssl_session_st *)NULL)))
          {
            return_value_SSL_SESSION_get_ex_data$4=SSL_SESSION_get_ex_data(sess, MatchIndex);
            match = (char **)return_value_SSL_SESSION_get_ex_data$4;
          }

          if(match == ((char **)NULL))
            ssl = (struct ssl_st *)(void *)0;

        }

        if(!(match == ((char **)NULL)))
        {
          signed int num = (signed int)c - 48;
          if(!(match[(signed long int)num] == ((char *)NULL)))
          {
            if(cond >= 0)
            {
              if(!(*match[(signed long int)num] == 0))
                cond = 1;

            }

            else
            {
              signed int len;
              unsigned long int return_value_strlen$5;
              return_value_strlen$5=strlen(match[(signed long int)num]);
              len = (signed int)return_value_strlen$5;
              if(len >= limit + -i)
                len = limit - i;

              if(!(buf == ((char *)NULL)))
              {
                __builtin_strncpy(buf + (signed long int)i, match[(signed long int)num], (unsigned long int)len);
                i = i + len;
              }

            }
          }

        }

        if(cond >= 1)
        {
          if(!(buf == ((char *)NULL)))
          {
            signed int return_value_strnparse$6;
            return_value_strnparse$6=strnparse(buf + (signed long int)i, limit - i, &p, pair, (char)58);
            i = i + return_value_strnparse$6;
            strnparse((char *)(void *)0, limit - i, &p, pair, (char)47);
          }

        }

        else
          if(cond == 0)
          {
            if(!(buf == ((char *)NULL)))
            {
              strnparse((char *)(void *)0, limit - i, &p, pair, (char)58);
              signed int return_value_strnparse$7;
              return_value_strnparse$7=strnparse(buf + (signed long int)i, limit - i, &p, pair, (char)47);
              i = i + return_value_strnparse$7;
            }

          }

        continue;
      }

      switch((signed int)c)
      {
        case 110:
        {
          c = (char)10;
          break;
        }
        case 114:
        {
          c = (char)13;
          break;
        }
        case 116:
        {
          c = (char)9;
          break;
        }
        case 97:
        {
          if(!(buf == ((char *)NULL)))
          {
            return_value_strnAddr$8=strnAddr(buf + (signed long int)i, limit - i, pair->sd, 0, 0);
            i = i + return_value_strnAddr$8;
          }

          goto __CPROVER_DUMP_L37;
        }
        case 65:
        {
          if(!(buf == ((char *)NULL)))
          {
            return_value_strnAddr$9=strnAddr(buf + (signed long int)i, limit - i, pair->sd, 0, 1);
            i = i + return_value_strnAddr$9;
          }

          goto __CPROVER_DUMP_L37;
        }
        case 100:
        {
          if(!(buf == ((char *)NULL)))
          {
            return_value_strnAddr$10=strnAddr(buf + (signed long int)i, limit - i, pair->sd, 1, 0);
            i = i + return_value_strnAddr$10;
          }

          goto __CPROVER_DUMP_L37;
        }
        case 68:
        {
          if(!(buf == ((char *)NULL)))
          {
            return_value_strnAddr$11=strnAddr(buf + (signed long int)i, limit - i, pair->sd, 1, 1);
            i = i + return_value_strnAddr$11;
          }

          goto __CPROVER_DUMP_L37;
        }
        case 117:
        {
          if(!(buf == ((char *)NULL)))
          {
            return_value_strnUser$12=strnUser(buf + (signed long int)i, limit - i, pair, 0);
            i = i + return_value_strnUser$12;
          }

          goto __CPROVER_DUMP_L37;
        }
        case 103:
        {
          if(!(buf == ((char *)NULL)))
          {
            return_value_strnUser$13=strnUser(buf + (signed long int)i, limit - i, pair, 1);
            i = i + return_value_strnUser$13;
          }

          goto __CPROVER_DUMP_L37;
        }
        case 85:
        {
          if(!(buf == ((char *)NULL)))
          {
            return_value_strnUser$14=strnUser(buf + (signed long int)i, limit - i, pair, 2);
            i = i + return_value_strnUser$14;
          }

          goto __CPROVER_DUMP_L37;
        }
        case 71:
        {
          if(!(buf == ((char *)NULL)))
          {
            return_value_strnUser$15=strnUser(buf + (signed long int)i, limit - i, pair, 3);
            i = i + return_value_strnUser$15;
          }

          goto __CPROVER_DUMP_L37;
        }
        case 0:
        {
          c = (char)92;
          p = p - 1l;
        }
        default:
          ;
      }
    }

    if(!(buf == ((char *)NULL)))
    {
      tmp_post$16 = i;
      i = i + 1;
      buf[(signed long int)tmp_post$16] = c;
    }


  __CPROVER_DUMP_L37:
    ;
  }
  if(!(sess == ((struct ssl_session_st *)NULL)))
    SSL_SESSION_free(sess);

  if(!(buf == ((char *)NULL)))
    buf[(signed long int)i] = (char)0;

  *pp = p;
  return i;
}

// strntime
// file stone.c line 868
char * strntime(char *str, signed int len, signed long int *clock, signed long int micro)
{
  struct tm tm;
  struct tm *t;
  t=localtime_r(clock, &tm);
  if(micro >= 0l)
    snprintf(str, (unsigned long int)len, "%s %2d %02d:%02d:%02d.%06ld ", (const void *)Month[(signed long int)t->tm_mon], t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec, micro);

  else
    snprintf(str, (unsigned long int)len, "%s %2d %02d:%02d:%02d ", (const void *)Month[(signed long int)t->tm_mon], t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
  return str;
}

// toupper
// file /usr/include/ctype.h line 221
static inline signed int toupper(signed int __c)
{
  signed int tmp_if_expr$2;
  const signed int **return_value___ctype_toupper_loc$1;
  if(__c >= -128 && !(__c >= 256))
  {
    return_value___ctype_toupper_loc$1=__ctype_toupper_loc();
    tmp_if_expr$2 = (*return_value___ctype_toupper_loc$1)[(signed long int)__c];
  }

  else
    tmp_if_expr$2 = __c;
  return tmp_if_expr$2;
}

// ungetExBuf
// file stone.c line 2337
void ungetExBuf(struct _ExBuf *ex)
{
  struct _ExBuf *freeptr = (struct _ExBuf *)(void *)0;
  signed long int now;
  time(&now);
  waitMutex(7);
  if(!(ex->start >= 0))
  {
    freeMutex(7);
    message(3, "ungetExBuf duplication. can't happen, ignore");
  }

  else
  {
    if(now + -freeExBotClock >= 601l)
    {
      if(nFreeExBot >= 3)
      {
        freeptr = freeExBot->next;
        freeExBot->next = (struct _ExBuf *)(void *)0;
        nFreeExBuf = nFreeExBuf - (nFreeExBot - 1);
      }

      else
      {
        freeExBot = freeExBuf;
        nFreeExBot = nFreeExBuf;
      }
      freeExBotClock = now;
    }

    ex->start = -1;
    ex->len = 0;
    ex->next = freeExBuf;
    freeExBuf = ex;
    nFreeExBuf = nFreeExBuf + 1;
    freeMutex(7);
    if(!(freeptr == ((struct _ExBuf *)NULL)))
    {
      if(Debug >= 4)
        message(7, "freeExBot %d nfex=%d", nFreeExBot, nFreeExBuf);

      freeExBot = (struct _ExBuf *)(void *)0;
      nFreeExBot = 0;
      while(!(freeptr == ((struct _ExBuf *)NULL)))
      {
        struct _ExBuf *p = freeptr;
        freeptr = freeptr->next;
        free((void *)p);
      }
    }

  }
}

// ungetPktBuf
// file stone.c line 2579
void ungetPktBuf(struct _PktBuf *pb)
{
  if(!(pb->bufmax >= pkt_len_max))
    free((void *)pb);

  else
  {
    waitMutex(9);
    pb->next = freePktBuf;
    freePktBuf = pb;
    nFreePktBuf = nFreePktBuf + 1;
    freeMutex(9);
  }
}

// verify_callback
// file stone.c line 7150
static signed int verify_callback(signed int preverify_ok, struct x509_store_ctx_st *ctx)
{
  struct x509_st *err_cert;
  signed int err;
  signed int depth;
  signed int depthmax;
  struct re_pattern_buffer *re;
  signed long int serial = (signed long int)-1;
  struct ssl_st *ssl;
  struct _Pair *pair;
  struct anonymous$12 *ss;
  char buf[2048l];
  char *p;
  err_cert=X509_STORE_CTX_get_current_cert(ctx);
  err=X509_STORE_CTX_get_error(ctx);
  depth=X509_STORE_CTX_get_error_depth(ctx);
  signed int return_value_SSL_get_ex_data_X509_STORE_CTX_idx$1;
  return_value_SSL_get_ex_data_X509_STORE_CTX_idx$1=SSL_get_ex_data_X509_STORE_CTX_idx();
  void *return_value_X509_STORE_CTX_get_ex_data$2;
  return_value_X509_STORE_CTX_get_ex_data$2=X509_STORE_CTX_get_ex_data(ctx, return_value_SSL_get_ex_data_X509_STORE_CTX_idx$1);
  ssl = (struct ssl_st *)return_value_X509_STORE_CTX_get_ex_data$2;
  signed int return_value_hostcheck$4;
  const char *return_value_X509_verify_cert_error_string$6;
  _Bool tmp_if_expr$11;
  void *return_value_SSL_SESSION_get_ex_data$10;
  if(ssl == ((struct ssl_st *)NULL))
  {
    message(3, "SSL callback can't get SSL object");
    return 0;
  }

  else
  {
    void *return_value_SSL_get_ex_data$3;
    return_value_SSL_get_ex_data$3=SSL_get_ex_data(ssl, PairIndex);
    pair = (struct _Pair *)return_value_SSL_get_ex_data$3;
    if(pair == ((struct _Pair *)NULL))
    {
      message(3, "SSL callback don't have ex_data, verify fails");
      return 0;
    }

    else
    {
      if((pair->proto & proto_command) == 0x0f00)
        ss = pair->stone->ssl_server;

      else
        ss = pair->stone->ssl_client;
      depthmax = (pair->ssl_flag & sf_depth) >> sf_depth_bit;
      if(depth >= depthmax)
      {
        depthmax = depth + 1;
        pair->ssl_flag = pair->ssl_flag & ~sf_depth | depthmax << sf_depth_bit;
      }

      if(depth == 0)
      {
        struct asn1_string_st *n;
        n=X509_get_serialNumber(err_cert);
        if(!(n == ((struct asn1_string_st *)NULL)))
          serial=ASN1_INTEGER_get(n);

        if(ss->serial == -1l && serial >= 0l)
          ss->serial = serial;

        else
          if(ss->serial >= 0l)
          {
            if(!(serial == ss->serial))
            {
              message(3, "%d TCP %d: SSL callback serial number mismatch %lx != %lx", pair->stone->sd, pair->sd, serial, ss->serial);
              return 0;
            }

          }

        if(!(ss->name == ((char *)NULL)))
        {
          if(ss->re[(signed long int)depth] == ((struct re_pattern_buffer *)NULL))
          {
            return_value_hostcheck$4=hostcheck(pair, err_cert, ss->name);
            if(return_value_hostcheck$4 == 0)
              return 0;

          }

        }

      }

      if(Debug >= 4)
        message(7, "%d TCP %d: callback: err=%d, depth=%d/%d, preverify=%d", pair->stone->sd, pair->sd, err, depth, depth - depthmax, preverify_ok);

      struct X509_name_st *return_value_X509_get_subject_name$5;
      return_value_X509_get_subject_name$5=X509_get_subject_name(err_cert);
      p=X509_NAME_oneline(return_value_X509_get_subject_name$5, buf, 2048 - 1);
      if(p == ((char *)NULL))
        return 0;

      else
      {
        if(!(ss->verbose == 0))
          message(7, "%d TCP %d: [depth%d=%s]", pair->stone->sd, pair->sd, depth, p);

        if(!(ss->depth >= depth))
        {
          preverify_ok = 0;
          X509_STORE_CTX_set_error(ctx, 22);
        }

        if(preverify_ok == 0)
        {
          if(!(ss->verbose == 0))
          {
            return_value_X509_verify_cert_error_string$6=X509_verify_cert_error_string((signed long int)err);
            message(7, "%d TCP %d: verify error err=%d %s", pair->stone->sd, pair->sd, err, return_value_X509_verify_cert_error_string$6);
          }

          if((sslparm_ignore & (signed int)ss->sslparm) == 0)
            return 0;

        }

        re = ss->re[(signed long int)((10 - depthmax) + depth)];
        if(re == ((struct re_pattern_buffer *)NULL))
          re = ss->re[(signed long int)depth];

        if(!(re == ((struct re_pattern_buffer *)NULL)) && !(depth >= 10))
        {
          struct ssl_session_st *sess = (struct ssl_session_st *)(void *)0;
          struct anonymous$19 pmatch[9l];
          char **match;
          err=regexec(re, p, (unsigned long int)9, pmatch, 0);
          if(Debug >= 4)
            message(7, "%d TCP %d: regexec%d=%d", pair->stone->sd, pair->sd, depth, err);

          if(!(err == 0))
            return 0;

          sess=SSL_get1_session(ssl);
          if(!(sess == ((struct ssl_session_st *)NULL)))
          {
            return_value_SSL_SESSION_get_ex_data$10=SSL_SESSION_get_ex_data(sess, MatchIndex);
            match = (char **)return_value_SSL_SESSION_get_ex_data$10;
            tmp_if_expr$11 = match != ((char **)NULL) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$11 = (_Bool)0;
          if(tmp_if_expr$11)
          {
            signed int i;
            signed int j = 1;
            if(serial >= 0l)
            {
              char str[128l];
              signed int len;
              snprintf(str, (unsigned long int)127, "%lx", serial);
              unsigned long int return_value_strlen$7;
              return_value_strlen$7=strlen(str);
              len = (signed int)return_value_strlen$7;
              if(!(*match == ((char *)NULL)))
                free((void *)match[(signed long int)0]);

              void *return_value_malloc$8;
              return_value_malloc$8=malloc((unsigned long int)(len + 1));
              match[(signed long int)0] = (char *)return_value_malloc$8;
              if(!(*match == ((char *)NULL)))
              {
                __builtin_strncpy(match[(signed long int)0], str, (unsigned long int)len);
                match[(signed long int)0][(signed long int)len] = (char)0;
              }

            }

            i = 1;
            for( ; !(i >= 10); i = i + 1)
              if(match[(signed long int)i] == ((char *)NULL))
              {
                if(pmatch[(signed long int)j].rm_so >= 0)
                {
                  signed int verify_callback$$1$$9$$1$$2$$1$$1$$len = pmatch[(signed long int)j].rm_eo - pmatch[(signed long int)j].rm_so;
                  void *return_value_malloc$9;
                  return_value_malloc$9=malloc((unsigned long int)(verify_callback$$1$$9$$1$$2$$1$$1$$len + 1));
                  match[(signed long int)i] = (char *)return_value_malloc$9;
                  if(!(match[(signed long int)i] == ((char *)NULL)))
                  {
                    __builtin_strncpy(match[(signed long int)i], p + (signed long int)pmatch[(signed long int)j].rm_so, (unsigned long int)verify_callback$$1$$9$$1$$2$$1$$1$$len);
                    match[(signed long int)i][(signed long int)verify_callback$$1$$9$$1$$2$$1$$1$$len] = (char)0;
                    if(Debug >= 5)
                      message(7, "%d TCP %d: \\%d=%s", pair->stone->sd, pair->sd, i, match[(signed long int)i]);

                  }

                  j = j + 1;
                }

              }

          }

          else
            message(3, "%d TCP %d: SSL callback can't get session's ex_data", pair->stone->sd, pair->sd);
          if(!(sess == ((struct ssl_session_st *)NULL)))
            SSL_SESSION_free(sess);

        }

        else
          if(Debug >= 4)
            message(7, "%d TCP %d: re%d=NULL", pair->stone->sd, pair->sd, depth);

        return 1;
      }
    }
  }
}

// waitMutex
// file stone.c line 1722
void waitMutex(signed int h)
{
  signed int err;
  do
  {
    err=pthread_mutex_lock(&FastMutex);
    if(!(err == 0))
      message(3, "Mutex %d err=%d", h, err);

    if((signed int)FastMutexs[(signed long int)h] == 0)
    {
      signed int i;
      FastMutexs[(signed long int)h] = FastMutexs[(signed long int)h] + 1;
      i = (signed int)FastMutexs[(signed long int)h];
      pthread_mutex_unlock(&FastMutex);
      if(Debug >= 21)
        message(7, "Lock Mutex %d = %d", h, i);

      break;
    }

    pthread_mutex_unlock(&FastMutex);
    if(Debug >= 11)
      message(7, "Mutex conflict %d = %d", h, FastMutexs[(signed long int)h]);

    MutexConflict = MutexConflict + 1;
    usleep((unsigned int)100);
  }
  while((_Bool)1);
}

