// tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']
// file /usr/include/qdbm/cabin.h line 74
struct anonymous_5;

// tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|S32'asize']
// file /usr/include/qdbm/cabin.h line 46
struct anonymous_9;

// tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']
// file /usr/include/qdbm/cabin.h line 52
struct anonymous_28;

// tag-#anon#ST[*{S8}_S8_'host'|*{S8}_S8_'addr'|S32'port'|U32'_pad0'|*{S8}_S8_'auth'|*{S8}_S8_'path'|*{S8}_S8_'query']
// file estload.c line 25
struct anonymous_30;

// tag-#anon#ST[*{S8}_S8_'name'|S32'inode'|U32'_pad0'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'metadb'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'omode'|U32'_pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#__'dbs'|S32'dnum'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'cdb']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'omode'|U32'_pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#__'dbs'|S32'dnum'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'cdb']#_'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'xfmdb'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#_'attrdb'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#_'textdb'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#_'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#_'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'_pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'keycc'|S32'kcmnum'|U32'_pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'attrcc'|S32'acmnum'|U32'_pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'textcc'|S32'tcmnum'|U32'_pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'veccc'|S32'vcmnum'|U32'_pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'rescc'|S32'rcmnum'|U32'_pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'spacc'|S32'scmnum'|U32'_pad7'|*{S8}_S8_'scname'|*{V(*{cS8}_cS8_|*{V}_V_)->V}_V(*{cS8}_cS8_|*{V}_V_)->V_'infocb'|*{V}_V_'infoop'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'dfdb'|S32'wildmax'|U32'_pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'metacc'|S32'flsflag'|S32'intflag']
// file estraier.h line 398
struct anonymous_0;

// tag-#anon#ST[*{S8}_S8_'name'|S32'nsiz'|U32'_pad0'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#_'nlist'|*{S8}_S8_'oper'|*{S8}_S8_'val'|S32'vsiz'|U32'_pad1'|*{cS8}_cS8_'cop'|S32'sign'|U32'_pad2'|*{S8}_S8_'sval'|S32'ssiz'|U32'_pad3'|*{V}_V_'regex'|S64'num']
// file estraier.c line 240
struct anonymous_16;

// tag-#anon#ST[*{S8}_S8_'name'|S32'omode'|U32'_pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#__'dbs'|S32'dnum'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'cdb']
// file estraier.h line 390
struct anonymous_2;

// tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']
// file /usr/include/qdbm/curia.h line 43
struct anonymous_3;

// tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']
// file /usr/include/qdbm/depot.h line 42
struct anonymous_1;

// tag-#anon#ST[*{S8}_S8_'phrase'|S32'gstep'|S32'tfidf'|S32'pmode'|U32'_pad0'|*{V(*{cS8}_cS8_|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#_)->V}_V(*{cS8}_cS8_|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#_)->V_'cbxpn'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#_'attrs'|*{S8}_S8_'order'|S32'max'|S32'skip'|S32'auxmin'|U32'_pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'auxwords'|S32'scfb'|U32'_pad2'|*{S32}_S32_'scores'|S32'snum'|U32'_pad3'|*{cS32}_cS32_'nscores'|S32'nsnum'|S32'opts'|F64'ecllim'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'shadows'|*{S8}_S8_'distinct'|S32'mask'|U32'_pad4']
// file estraier.h line 256
struct anonymous_15;

// tag-#anon#ST[*{S8}_S8_'url'|*{S8}_S8_'pxhost'|S32'pxport'|S32'timeout'|*{S8}_S8_'auth'|*{S8}_S8_'name'|*{S8}_S8_'label'|S32'dnum'|S32'wnum'|F64'size'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#_'admins'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#_'users'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#_'links'|S32'wwidth'|S32'hwidth'|S32'awidth'|U32'_pad0'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#_'ilist'|*{S8}_S8_'iprev'|S32'status'|U32'_pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'heads']
// file estnode.h line 177
struct anonymous_24;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']
// file /usr/include/qdbm/cabin.h line 57
struct anonymous_6;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'inode'|U32'_pad0'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'metadb'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'omode'|U32'_pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#__'dbs'|S32'dnum'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'cdb']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'omode'|U32'_pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#__'dbs'|S32'dnum'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'cdb']#_'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'xfmdb'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#_'attrdb'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#_'textdb'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#_'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#_'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'_pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'keycc'|S32'kcmnum'|U32'_pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'attrcc'|S32'acmnum'|U32'_pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'textcc'|S32'tcmnum'|U32'_pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'veccc'|S32'vcmnum'|U32'_pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'rescc'|S32'rcmnum'|U32'_pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'spacc'|S32'scmnum'|U32'_pad7'|*{S8}_S8_'scname'|*{V(*{cS8}_cS8_|*{V}_V_)->V}_V(*{cS8}_cS8_|*{V}_V_)->V_'infocb'|*{V}_V_'infoop'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'dfdb'|S32'wildmax'|U32'_pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'metacc'|S32'flsflag'|S32'intflag']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'inode'|U32'_pad0'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'metadb'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'omode'|U32'_pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#__'dbs'|S32'dnum'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'cdb']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'omode'|U32'_pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#__'dbs'|S32'dnum'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'cdb']#_'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'xfmdb'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#_'attrdb'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#_'textdb'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'attr'|*{*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#__'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'_pad0']#_'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#_'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#_'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'_pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'keycc'|S32'kcmnum'|U32'_pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'attrcc'|S32'acmnum'|U32'_pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'textcc'|S32'tcmnum'|U32'_pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'veccc'|S32'vcmnum'|U32'_pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'rescc'|S32'rcmnum'|U32'_pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'spacc'|S32'scmnum'|U32'_pad7'|*{S8}_S8_'scname'|*{V(*{cS8}_cS8_|*{V}_V_)->V}_V(*{cS8}_cS8_|*{V}_V_)->V_'infocb'|*{V}_V_'infoop'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'dfdb'|S32'wildmax'|U32'_pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'metacc'|S32'flsflag'|S32'intflag']#_'db'|*{S8}_S8_'path'|SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']#'mutex']
// file estmtdb.h line 37
struct anonymous_12;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}_S8_'map'|S32'msiz'|U32'_pad0'|*{S32}_S32_'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}_S32_'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'_pad1']#_'depot'|*{S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32}_S32(*{cS8}_cS8_|S32|*{cS8}_cS8_|S32)->S32_'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'nodec'|ARR64{S32}_S32_'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']
// file /usr/include/qdbm/villa.h line 85
struct anonymous_4;

// tag-#anon#ST[*{SYM#tag-_ESTRESDOC#}_SYM#tag-_ESTRESDOC#_'docs'|S32'top'|S32'max'|S32'dnum'|U32'_pad0'|*{*{SYM#tag-_ESTRESDOC#}_SYM#tag-_ESTRESDOC#_}_*{SYM#tag-_ESTRESDOC#}_SYM#tag-_ESTRESDOC#__'survivors'|S32'snum'|U32'_pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'hints'|S64'mdate']
// file estnode.h line 65
struct anonymous_17;

// tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_44;

// tag-#anon#ST[*{V}_V_'db'|S32'type'|U32'_pad0']
// file estraier.c line 199
struct anonymous_7;

// tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_42;

// tag-#anon#ST[*{cS8}_cS8_'key'|S32'score'|U32'_pad0']
// file estraier.h line 779
struct anonymous;

// tag-#anon#ST[*{cS8}_cS8_'word'|S32'wsiz'|S32'pt']
// file estraier.c line 255
struct anonymous_31;

// tag-#anon#ST[ARR16{S64}_S64_'fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_18;

// tag-#anon#ST[ARR16{U64}_U64_'__val']
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_25;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'_pad0']#}_SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'_pad0']#_'__cancel_jmp_buf'|ARR4{*{V}_V_}_*{V}_V__'__pad']
// file /usr/include/pthread.h line 525
struct anonymous_22;

// tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'_pad0']
// file /usr/include/pthread.h line 527
struct anonymous_21;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_19;

// tag-#anon#ST[S32'alive'|U32'_pad0'|*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}_S8_'__size'|S64'__align']#}_SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}_S8_'__size'|S64'__align']#_'cond'|*{cS8}_cS8_'url'|*{cS8}_cS8_'pxhost'|S32'pxport'|S32'limsize'|*{cS8}_cS8_'auth'|*{cSYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#}_cSYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#_'reqheads'|*{cS8}_cS8_'reqbody'|S32'rbsiz'|U32'_pad1'|*{S32}_S32_'rescodep'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'resheads'|*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|S32'asize']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|S32'asize']#_'resbody']
// file estnode.c line 44
struct anonymous_27;

// tag-#anon#ST[S32'db'|S32'id'|S32'score'|U32'_pad0'|*{S8}_S8_'value']
// file estraier.c line 261
struct anonymous_32;

// tag-#anon#ST[S32'id'|S32'ims'|S32'pb'|S32'qb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#_'targets'|S32'alive'|U32'_pad0']
// file estload.c line 34
struct anonymous_29;

// tag-#anon#ST[S32'id'|S32'score'|*{S8}_S8_'value']
// file estraier.c line 234
struct anonymous_8;

// tag-#anon#ST[S32'id'|U32'_pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'attrs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#}_SYM#tag-#anon#ST[*{S8}_S8_'dptr'|S32'dsize'|U32'_pad0']#_'array'|S32'anum'|S32'start'|S32'num'|U32'_pad0']#_'dtexts'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#}_SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_}_*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#__'buckets'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'first'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'last'|*{SYM#tag-_CBMAPDATUM#}_SYM#tag-_CBMAPDATUM#_'cur'|S32'bnum'|S32'rnum']#_'kwords']
// file estraier.h line 72
struct anonymous_14;

// tag-#anon#ST[S32'quot'|S32'rem']
// file /usr/include/stdlib.h line 97
struct anonymous_10;

// tag-#anon#ST[S32'rm_so'|S32'rm_eo']
// file /usr/include/regex.h line 452
struct anonymous_37;

// tag-#anon#ST[S32'si_pid'|U32'si_uid']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_38;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_41;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_40;

// tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_34;

// tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_39;

// tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_43;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'|*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}_SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}_SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#_|*{V}_V_)->V_'sa_sigaction']
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_35;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'|ARR8{U16}_U16_'__u6_addr16'|ARR4{U32}_U32_'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous_23;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_33;

// tag-#anon#UN[ARR4{S8}_S8_'__size'|S32'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_13;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_20;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_11;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'|r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__']
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_26;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'|r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__']_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_45;

// tag-_CBMAPDATUM
// file /usr/include/qdbm/cabin.h line 64
struct _CBMAPDATUM;

// tag-_ESTRESDOC
// file estnode.h line 55
struct _ESTRESDOC;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-internal_state
// file /usr/include/zlib.h line 83
struct internal_state;

// tag-linger
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 379
struct linger;

// tag-md5_state_s
// file md5.h line 67
struct md5_state_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-utimbuf
// file /usr/include/utime.h line 37
struct utimbuf;

// tag-z_stream_s
// file /usr/include/zlib.h line 85
struct z_stream_s;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// VL_CMPLEX_object
//
signed int VL_CMPLEX_object(const char *, signed int, const char *, signed int);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous_22 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous_22 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous_22 *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous_45, unsigned int *);
// acos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 54
extern double acos(double);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous_45, unsigned int);
// cbbaseencode
// file /usr/include/qdbm/cabin.h line 885
char * cbbaseencode(const char *, signed int);
// cbdatumcat
// file /usr/include/qdbm/cabin.h line 322
void cbdatumcat(struct anonymous_9 *, const char *, signed int);
// cbdatumclose
// file /usr/include/qdbm/cabin.h line 314
void cbdatumclose(struct anonymous_9 *);
// cbdatumopen
// file /usr/include/qdbm/cabin.h line 302
struct anonymous_9 * cbdatumopen(const char *, signed int);
// cbdatumprintf
// file /usr/include/qdbm/cabin.h line 353
void cbdatumprintf(struct anonymous_9 *, const char *, ...);
// cbdatumptr
// file /usr/include/qdbm/cabin.h line 330
const char * cbdatumptr(const struct anonymous_9 *);
// cbdatumsetbuf
// file /usr/include/qdbm/cabin.h line 1284
void cbdatumsetbuf(struct anonymous_9 *, char *, signed int);
// cbdatumsize
// file /usr/include/qdbm/cabin.h line 336
signed int cbdatumsize(const struct anonymous_9 *);
// cbdatumtomalloc
// file /usr/include/qdbm/cabin.h line 366
char * cbdatumtomalloc(struct anonymous_9 *, signed int *);
// cbdirlist
// file /usr/include/qdbm/cabin.h line 809
struct anonymous_6 * cbdirlist(const char *);
// cbglobalgc
// file /usr/include/qdbm/cabin.h line 142
void cbglobalgc(void *, void (*)(void *));
// cblistclose
// file /usr/include/qdbm/cabin.h line 383
void cblistclose(struct anonymous_6 *);
// cblistdump
// file /usr/include/qdbm/cabin.h line 510
char * cblistdump(const struct anonymous_6 *, signed int *);
// cblistdup
// file /usr/include/qdbm/cabin.h line 377
struct anonymous_6 * cblistdup(const struct anonymous_6 *);
// cblistload
// file /usr/include/qdbm/cabin.h line 517
struct anonymous_6 * cblistload(const char *, signed int);
// cblistnum
// file /usr/include/qdbm/cabin.h line 389
signed int cblistnum(const struct anonymous_6 *);
// cblistopen
// file /usr/include/qdbm/cabin.h line 371
struct anonymous_6 * cblistopen(void);
// cblistover
// file /usr/include/qdbm/cabin.h line 474
void cblistover(struct anonymous_6 *, signed int, const char *, signed int);
// cblistpush
// file /usr/include/qdbm/cabin.h line 409
void cblistpush(struct anonymous_6 *, const char *, signed int);
// cblistshift
// file /usr/include/qdbm/cabin.h line 441
char * cblistshift(struct anonymous_6 *, signed int *);
// cblistsort
// file /usr/include/qdbm/cabin.h line 480
void cblistsort(struct anonymous_6 *);
// cblistunshift
// file /usr/include/qdbm/cabin.h line 429
void cblistunshift(struct anonymous_6 *, const char *, signed int);
// cblistval
// file /usr/include/qdbm/cabin.h line 401
const char * cblistval(const struct anonymous_6 *, signed int, signed int *);
// cbmalloc
// file /usr/include/qdbm/cabin.h line 105
void * cbmalloc(unsigned long int);
// cbmapclose
// file /usr/include/qdbm/cabin.h line 535
void cbmapclose(struct anonymous_5 *);
// cbmapdump
// file /usr/include/qdbm/cabin.h line 655
char * cbmapdump(struct anonymous_5 *, signed int *);
// cbmapdup
// file /usr/include/qdbm/cabin.h line 529
struct anonymous_5 * cbmapdup(struct anonymous_5 *);
// cbmapget
// file /usr/include/qdbm/cabin.h line 584
const char * cbmapget(const struct anonymous_5 *, const char *, signed int, signed int *);
// cbmapiterinit
// file /usr/include/qdbm/cabin.h line 601
void cbmapiterinit(struct anonymous_5 *);
// cbmapiternext
// file /usr/include/qdbm/cabin.h line 613
const char * cbmapiternext(struct anonymous_5 *, signed int *);
// cbmapiterval
// file /usr/include/qdbm/cabin.h line 623
const char * cbmapiterval(const char *, signed int *);
// cbmapkeys
// file /usr/include/qdbm/cabin.h line 637
struct anonymous_6 * cbmapkeys(struct anonymous_5 *);
// cbmapload
// file /usr/include/qdbm/cabin.h line 662
struct anonymous_5 * cbmapload(const char *, signed int);
// cbmaploadone
// file /usr/include/qdbm/cabin.h line 677
char * cbmaploadone(const char *, signed int, const char *, signed int, signed int *);
// cbmapmove
// file /usr/include/qdbm/cabin.h line 595
signed int cbmapmove(struct anonymous_5 *, const char *, signed int, signed int);
// cbmapopen
// file /usr/include/qdbm/cabin.h line 522
struct anonymous_5 * cbmapopen(void);
// cbmapopenex
// file /usr/include/qdbm/cabin.h line 1298
struct anonymous_5 * cbmapopenex(signed int);
// cbmapout
// file /usr/include/qdbm/cabin.h line 570
signed int cbmapout(struct anonymous_5 *, const char *, signed int);
// cbmapput
// file /usr/include/qdbm/cabin.h line 548
signed int cbmapput(struct anonymous_5 *, const char *, signed int, const char *, signed int, signed int);
// cbmapputcat
// file /usr/include/qdbm/cabin.h line 560
void cbmapputcat(struct anonymous_5 *, const char *, signed int, const char *, signed int);
// cbmaprnum
// file /usr/include/qdbm/cabin.h line 629
signed int cbmaprnum(const struct anonymous_5 *);
// cbmemdup
// file /usr/include/qdbm/cabin.h line 126
char * cbmemdup(const char *, signed int);
// cbmyfatal
// file /usr/include/qdbm/cabin.h line 1270
void * cbmyfatal(const char *);
// cbreadfile
// file /usr/include/qdbm/cabin.h line 783
char * cbreadfile(const char *, signed int *);
// cbreadlines
// file /usr/include/qdbm/cabin.h line 801
struct anonymous_6 * cbreadlines(const char *);
// cbrealloc
// file /usr/include/qdbm/cabin.h line 114
void * cbrealloc(void *, unsigned long int);
// cbsplit
// file /usr/include/qdbm/cabin.h line 771
struct anonymous_6 * cbsplit(const char *, signed int, const char *);
// cbsprintf
// file /usr/include/qdbm/cabin.h line 748
char * cbsprintf(const char *, ...);
// cbstdiobin
// file /usr/include/qdbm/cabin.h line 1258
void cbstdiobin(void);
// cbstrbwmatch
// file /usr/include/qdbm/cabin.h line 230
signed int cbstrbwmatch(const char *, const char *);
// cbstrfwimatch
// file /usr/include/qdbm/cabin.h line 223
signed int cbstrfwimatch(const char *, const char *);
// cbstrfwmatch
// file /usr/include/qdbm/cabin.h line 215
signed int cbstrfwmatch(const char *, const char *);
// cbstricmp
// file /usr/include/qdbm/cabin.h line 208
signed int cbstricmp(const char *, const char *);
// cbstrmktime
// file /usr/include/qdbm/cabin.h line 1245
signed long int cbstrmktime(const char *);
// cbstrsqzspc
// file /usr/include/qdbm/cabin.h line 280
char * cbstrsqzspc(char *);
// cbstrtrim
// file /usr/include/qdbm/cabin.h line 274
char * cbstrtrim(char *);
// cburlbreak
// file /usr/include/qdbm/cabin.h line 843
struct anonymous_5 * cburlbreak(const char *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous_45, unsigned int);
// cos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
extern double cos(double);
// crbnum
// file /usr/include/qdbm/curia.h line 264
signed int crbnum(struct anonymous_3 *);
// crclose
// file /usr/include/qdbm/curia.h line 101
signed int crclose(struct anonymous_3 *);
// crfsizd
// file /usr/include/qdbm/curia.h line 257
double crfsizd(struct anonymous_3 *);
// crget
// file /usr/include/qdbm/curia.h line 146
char * crget(struct anonymous_3 *, const char *, signed int, signed int, signed int, signed int *);
// crgetlob
// file /usr/include/qdbm/curia.h line 398
char * crgetlob(struct anonymous_3 *, const char *, signed int, signed int, signed int, signed int *);
// criterinit
// file /usr/include/qdbm/curia.h line 181
signed int criterinit(struct anonymous_3 *);
// criternext
// file /usr/include/qdbm/curia.h line 197
char * criternext(struct anonymous_3 *, signed int *);
// crmemflush
// file /usr/include/qdbm/curia.h line 448
signed int crmemflush(struct anonymous_3 *);
// cropen
// file /usr/include/qdbm/curia.h line 92
struct anonymous_3 * cropen(const char *, signed int, signed int, signed int);
// croptimize
// file /usr/include/qdbm/curia.h line 236
signed int croptimize(struct anonymous_3 *, signed int);
// crout
// file /usr/include/qdbm/curia.h line 127
signed int crout(struct anonymous_3 *, const char *, signed int);
// croutlob
// file /usr/include/qdbm/curia.h line 378
signed int croutlob(struct anonymous_3 *, const char *, signed int);
// crput
// file /usr/include/qdbm/curia.h line 117
signed int crput(struct anonymous_3 *, const char *, signed int, const char *, signed int, signed int);
// crputlob
// file /usr/include/qdbm/curia.h line 368
signed int crputlob(struct anonymous_3 *, const char *, signed int, const char *, signed int, signed int);
// crrepair
// file /usr/include/qdbm/curia.h line 317
signed int crrepair(const char *);
// crsetalign
// file /usr/include/qdbm/curia.h line 210
signed int crsetalign(struct anonymous_3 *, signed int);
// crsetfbpsiz
// file /usr/include/qdbm/curia.h line 219
signed int crsetfbpsiz(struct anonymous_3 *, signed int);
// crsync
// file /usr/include/qdbm/curia.h line 226
signed int crsync(struct anonymous_3 *);
// crvsiz
// file /usr/include/qdbm/curia.h line 174
signed int crvsiz(struct anonymous_3 *, const char *, signed int);
// deflate
// file /usr/include/zlib.h line 246
extern signed int deflate(struct z_stream_s *, signed int);
// deflateEnd
// file /usr/include/zlib.h line 353
extern signed int deflateEnd(struct z_stream_s *);
// deflateInit2_
// file /usr/include/zlib.h line 1637
extern signed int deflateInit2_(struct z_stream_s *, signed int, signed int, signed int, signed int, signed int, const char *, signed int);
// div
// file /usr/include/stdlib.h line 788
extern struct anonymous_10 div(signed int, signed int);
// dpclose
// file /usr/include/qdbm/depot.h line 145
signed int dpclose(struct anonymous_1 *);
// dpecodeptr
// file /usr/include/qdbm/depot.h line 454
signed int * dpecodeptr(void);
// dpfsiz
// file /usr/include/qdbm/depot.h line 295
signed int dpfsiz(struct anonymous_1 *);
// dpget
// file /usr/include/qdbm/depot.h line 190
char * dpget(struct anonymous_1 *, const char *, signed int, signed int, signed int, signed int *);
// dpgetflags
// file /usr/include/qdbm/depot.h line 472
signed int dpgetflags(struct anonymous_1 *);
// dpgetwb
// file /usr/include/qdbm/depot.h line 207
signed int dpgetwb(struct anonymous_1 *, const char *, signed int, signed int, signed int, char *);
// dpinnerhash
// file /usr/include/qdbm/depot.h line 404
signed int dpinnerhash(const char *, signed int);
// dpmemflush
// file /usr/include/qdbm/depot.h line 466
signed int dpmemflush(struct anonymous_1 *);
// dpopen
// file /usr/include/qdbm/depot.h line 136
struct anonymous_1 * dpopen(const char *, signed int, signed int);
// dpoptimize
// file /usr/include/qdbm/depot.h line 280
signed int dpoptimize(struct anonymous_1 *, signed int);
// dpout
// file /usr/include/qdbm/depot.h line 171
signed int dpout(struct anonymous_1 *, const char *, signed int);
// dpouterhash
// file /usr/include/qdbm/depot.h line 413
signed int dpouterhash(const char *, signed int);
// dpput
// file /usr/include/qdbm/depot.h line 161
signed int dpput(struct anonymous_1 *, const char *, signed int, const char *, signed int, signed int);
// dprepair
// file /usr/include/qdbm/depot.h line 362
signed int dprepair(const char *);
// dprnum
// file /usr/include/qdbm/depot.h line 317
signed int dprnum(struct anonymous_1 *);
// dpsetfbpsiz
// file /usr/include/qdbm/depot.h line 263
signed int dpsetfbpsiz(struct anonymous_1 *, signed int);
// dpsetflags
// file /usr/include/qdbm/depot.h line 479
signed int dpsetflags(struct anonymous_1 *, signed int);
// dpsync
// file /usr/include/qdbm/depot.h line 270
signed int dpsync(struct anonymous_1 *);
// dpwritable
// file /usr/include/qdbm/depot.h line 323
signed int dpwritable(struct anonymous_1 *);
// est_accept_conn
// file estnode.c line 1406
signed int est_accept_conn(signed int sock, char *abuf, signed int *pp);
// est_aidx_attr_narrow
// file estraier.c line 7563
static signed int est_aidx_attr_narrow(struct anonymous_4 *db, const struct anonymous_6 *pdocs, const char *cop, signed int sign, const char *oval, signed int osiz, const char *sval, signed int ssiz, const void *regex, signed int onum, struct anonymous_8 *scores, signed int snum);
// est_aidx_attr_out
// file estraier.c line 7534
static signed int est_aidx_attr_out(struct anonymous_4 *db, signed int id, const char *vbuf, signed int vsiz);
// est_aidx_attr_put
// file estraier.c line 7513
static signed int est_aidx_attr_put(struct anonymous_4 *db, signed int id, const char *vbuf, signed int vsiz);
// est_aidx_numcmp
// file estraier.c line 7500
static signed int est_aidx_numcmp(const char *aptr, signed int asiz, const char *bptr, signed int bsiz);
// est_aidx_seq_get
// file estraier.c line 7439
static char * est_aidx_seq_get(struct anonymous_1 *db, signed int id, signed int *sp);
// est_aidx_seq_narrow
// file estraier.c line 7461
static signed int est_aidx_seq_narrow(struct anonymous_1 *db, const struct anonymous_6 *pdocs, const char *cop, signed int sign, const char *oval, signed int osiz, const char *sval, signed int ssiz, const void *regex, signed int onum, struct anonymous_8 *scores, signed int snum, signed int limit, signed int *restp);
// est_aidx_seq_out
// file estraier.c line 7426
static signed int est_aidx_seq_out(struct anonymous_1 *db, signed int id);
// est_aidx_seq_put
// file estraier.c line 7413
static signed int est_aidx_seq_put(struct anonymous_1 *db, signed int id, const char *vbuf, signed int vsiz);
// est_border_str
// file estraier.c line 4042
const char * est_border_str(void);
// est_break_text
// file estraier.c line 3376
void est_break_text(const char *text, struct anonymous_6 *list, signed int norm, signed int tail);
// est_break_text_chrcat
// file estraier.c line 3509
void est_break_text_chrcat(const char *text, struct anonymous_6 *list, signed int norm);
// est_break_text_perfng
// file estraier.c line 3439
void est_break_text_perfng(const char *text, struct anonymous_6 *list, signed int norm, signed int tail);
// est_bzdecode
// file estraier.c line 3990
char * est_bzdecode(const char *ptr, signed int size, signed int *sp);
// est_bzencode
// file estraier.c line 3936
char * est_bzencode(const char *ptr, signed int size, signed int *sp);
// est_canonicalize_text
// file estraier.c line 6242
static void est_canonicalize_text(unsigned char *utext, signed int size, signed int funcspc);
// est_char_category
// file estraier.c line 6363
static signed int est_char_category(signed int c);
// est_char_category_chrcat
// file estraier.c line 6399
static signed int est_char_category_chrcat(signed int c);
// est_char_category_perfng
// file estraier.c line 6390
static signed int est_char_category_perfng(signed int c);
// est_check_cjk_only
// file estraier.c line 6516
static signed int est_check_cjk_only(const char *str);
// est_check_numbt
// file estraier.c line 10174
static signed int est_check_numbt(const char *tval, const char *oval);
// est_check_strand
// file estraier.c line 10073
static signed int est_check_strand(const char *tval, const char *oval);
// est_check_stror
// file estraier.c line 10109
static signed int est_check_stror(const char *tval, const char *oval);
// est_check_stroreq
// file estraier.c line 10145
static signed int est_check_stroreq(const char *tval, const char *oval);
// est_cond_add_attr
// file estraier.c line 800
void est_cond_add_attr(struct anonymous_15 *cond, const char *expr);
// est_cond_attrs
// file estraier.c line 4315
const struct anonymous_6 * est_cond_attrs(struct anonymous_15 *cond);
// est_cond_auxiliary
// file estraier.c line 4350
signed int est_cond_auxiliary(struct anonymous_15 *cond);
// est_cond_auxiliary_word
// file estraier.c line 4395
signed int est_cond_auxiliary_word(struct anonymous_15 *cond, const char *word);
// est_cond_delete
// file estraier.c line 775
void est_cond_delete(struct anonymous_15 *cond);
// est_cond_distinct
// file estraier.c line 4357
const char * est_cond_distinct(struct anonymous_15 *cond);
// est_cond_dup
// file estraier.c line 4277
struct anonymous_15 * est_cond_dup(struct anonymous_15 *cond);
// est_cond_mask
// file estraier.c line 4364
signed int est_cond_mask(struct anonymous_15 *cond);
// est_cond_max
// file estraier.c line 4329
signed int est_cond_max(struct anonymous_15 *cond);
// est_cond_new
// file estraier.c line 746
struct anonymous_15 * est_cond_new(void);
// est_cond_options
// file estraier.c line 4343
signed int est_cond_options(struct anonymous_15 *cond);
// est_cond_order
// file estraier.c line 4322
const char * est_cond_order(struct anonymous_15 *cond);
// est_cond_phrase
// file estraier.c line 4308
const char * est_cond_phrase(struct anonymous_15 *cond);
// est_cond_score
// file estraier.c line 4371
signed int est_cond_score(struct anonymous_15 *cond, signed int index);
// est_cond_scores
// file estraier.c line 4379
const signed int * est_cond_scores(struct anonymous_15 *cond, signed int *nump);
// est_cond_set_auxiliary
// file estraier.c line 855
void est_cond_set_auxiliary(struct anonymous_15 *cond, signed int min);
// est_cond_set_distinct
// file estraier.c line 869
void est_cond_set_distinct(struct anonymous_15 *cond, const char *name);
// est_cond_set_eclipse
// file estraier.c line 862
void est_cond_set_eclipse(struct anonymous_15 *cond, double limit);
// est_cond_set_expander
// file estraier.c line 4418
void est_cond_set_expander(struct anonymous_15 *cond, void (*func)(const char *, struct anonymous_6 *));
// est_cond_set_expander::func_object
//
void func_object(const char *, struct anonymous_6 *);
// est_cond_set_mask
// file estraier.c line 881
void est_cond_set_mask(struct anonymous_15 *cond, signed int mask);
// est_cond_set_max
// file estraier.c line 824
void est_cond_set_max(struct anonymous_15 *cond, signed int max);
// est_cond_set_narrowing_scores
// file estraier.c line 4387
void est_cond_set_narrowing_scores(struct anonymous_15 *cond, const signed int *scores, signed int num);
// est_cond_set_options
// file estraier.c line 838
void est_cond_set_options(struct anonymous_15 *cond, signed int options);
// est_cond_set_order
// file estraier.c line 812
void est_cond_set_order(struct anonymous_15 *cond, const char *expr);
// est_cond_set_phrase
// file estraier.c line 789
void est_cond_set_phrase(struct anonymous_15 *cond, const char *phrase);
// est_cond_set_skip
// file estraier.c line 831
void est_cond_set_skip(struct anonymous_15 *cond, signed int skip);
// est_cond_shadows
// file estraier.c line 4404
const signed int * est_cond_shadows(struct anonymous_15 *cond, signed int id, signed int *np);
// est_cond_skip
// file estraier.c line 4336
signed int est_cond_skip(struct anonymous_15 *cond);
// est_crget
// file estraier.c line 7370
static char * est_crget(struct anonymous_3 *curia, signed int zmode, signed int id, signed int *sp);
// est_crout
// file estraier.c line 7357
static signed int est_crout(struct anonymous_3 *curia, signed int id);
// est_crput
// file estraier.c line 7307
static signed int est_crput(struct anonymous_3 *curia, signed int zmode, signed int id, const char *vbuf, signed int vsiz, signed int dmode);
// est_db_add_attr_index
// file estraier.c line 1341
signed int est_db_add_attr_index(struct anonymous_0 *db, const char *name, signed int type);
// est_db_add_meta
// file estraier.c line 4525
void est_db_add_meta(struct anonymous_0 *db, const char *name, const char *value);
// est_db_add_pseudo_index
// file estraier.c line 3335
signed int est_db_add_pseudo_index(struct anonymous_0 *db, const char *path);
// est_db_attr_index_exprs
// file estraier.c line 5082
struct anonymous_6 * est_db_attr_index_exprs(struct anonymous_0 *db);
// est_db_cache_num
// file estraier.c line 4957
signed int est_db_cache_num(struct anonymous_0 *db);
// est_db_charge_rescc
// file estraier.c line 5038
void est_db_charge_rescc(struct anonymous_0 *db, signed int max);
// est_db_check_option
// file estraier.c line 4432
signed int est_db_check_option(struct anonymous_0 *db, signed int option);
// est_db_close
// file estraier.c line 1263
signed int est_db_close(struct anonymous_0 *db, signed int *ecp);
// est_db_doc_num
// file estraier.c line 2702
signed int est_db_doc_num(struct anonymous_0 *db);
// est_db_edit_doc
// file estraier.c line 2431
signed int est_db_edit_doc(struct anonymous_0 *db, struct anonymous_14 *doc);
// est_db_error
// file estraier.c line 1327
signed int est_db_error(struct anonymous_0 *db);
// est_db_etch_doc
// file estraier.c line 4560
struct anonymous_5 * est_db_etch_doc(struct anonymous_0 *db, struct anonymous_14 *doc, signed int max);
// est_db_fatal
// file estraier.c line 1334
signed int est_db_fatal(struct anonymous_0 *db);
// est_db_fill_key_cache
// file estraier.c line 4994
void est_db_fill_key_cache(struct anonymous_0 *db);
// est_db_flush
// file estraier.c line 1468
signed int est_db_flush(struct anonymous_0 *db, signed int max);
// est_db_get_doc
// file estraier.c line 2533
struct anonymous_14 * est_db_get_doc(struct anonymous_0 *db, signed int id, signed int options);
// est_db_get_doc_attr
// file estraier.c line 2630
char * est_db_get_doc_attr(struct anonymous_0 *db, signed int id, const char *name);
// est_db_get_doc_entity
// file estraier.c line 4513
char * est_db_get_doc_entity(struct anonymous_0 *db, signed int id, signed int *sp);
// est_db_get_keywords
// file estraier.c line 4774
struct anonymous_5 * est_db_get_keywords(struct anonymous_0 *db, signed int id);
// est_db_inform
// file estraier.c line 7801
static void est_db_inform(struct anonymous_0 *db, const char *info);
// est_db_inode
// file estraier.c line 4475
signed int est_db_inode(struct anonymous_0 *db);
// est_db_interrupt
// file estraier.c line 5110
void est_db_interrupt(struct anonymous_0 *db);
// est_db_iter_init
// file estraier.c line 4815
signed int est_db_iter_init(struct anonymous_0 *db, const char *prev);
// est_db_iter_next
// file estraier.c line 4831
signed int est_db_iter_next(struct anonymous_0 *db);
// est_db_keyword_iter_init
// file estraier.c line 4901
signed int est_db_keyword_iter_init(struct anonymous_0 *db);
// est_db_keyword_iter_next
// file estraier.c line 4913
char * est_db_keyword_iter_next(struct anonymous_0 *db);
// est_db_keyword_num
// file estraier.c line 4892
signed int est_db_keyword_num(struct anonymous_0 *db);
// est_db_keyword_rec_size
// file estraier.c line 4931
signed int est_db_keyword_rec_size(struct anonymous_0 *db, const char *word);
// est_db_keyword_search
// file estraier.c line 4939
signed int * est_db_keyword_search(struct anonymous_0 *db, const char *word, signed int *nump);
// est_db_list_rescc
// file estraier.c line 5060
struct anonymous_6 * est_db_list_rescc(struct anonymous_0 *db);
// est_db_measure_doc
// file estraier.c line 4803
signed int est_db_measure_doc(struct anonymous_0 *db, signed int id, signed int parts);
// est_db_merge
// file estraier.c line 1891
signed int est_db_merge(struct anonymous_0 *db, const char *name, signed int options);
// est_db_meta
// file estraier.c line 4549
char * est_db_meta(struct anonymous_0 *db, const char *name);
// est_db_meta_names
// file estraier.c line 4541
struct anonymous_6 * est_db_meta_names(struct anonymous_0 *db);
// est_db_name
// file estraier.c line 2695
const char * est_db_name(struct anonymous_0 *db);
// est_db_open
// file estraier.c line 914
struct anonymous_0 * est_db_open(const char *name, signed int omode, signed int *ecp);
// est_db_optimize
// file estraier.c line 1742
signed int est_db_optimize(struct anonymous_0 *db, signed int options);
// est_db_out_doc
// file estraier.c line 2323
signed int est_db_out_doc(struct anonymous_0 *db, signed int id, signed int options);
// est_db_out_keywords
// file estraier.c line 4731
signed int est_db_out_keywords(struct anonymous_0 *db, signed int id);
// est_db_prepare_meta
// file estraier.c line 7816
static void est_db_prepare_meta(struct anonymous_0 *db);
// est_db_pseudo_doc_num
// file estraier.c line 5075
signed int est_db_pseudo_doc_num(struct anonymous_0 *db);
// est_db_put_doc
// file estraier.c line 2130
signed int est_db_put_doc(struct anonymous_0 *db, struct anonymous_14 *doc, signed int options);
// est_db_put_keywords
// file estraier.c line 4696
signed int est_db_put_keywords(struct anonymous_0 *db, signed int id, struct anonymous_5 *kwords, double weight);
// est_db_refresh_rescc
// file estraier.c line 5022
void est_db_refresh_rescc(struct anonymous_0 *db);
// est_db_repair
// file estraier.c line 5117
signed int est_db_repair(const char *name, signed int options, signed int *ecp);
// est_db_scan_doc
// file estraier.c line 3226
signed int est_db_scan_doc(struct anonymous_0 *db, struct anonymous_14 *doc, struct anonymous_15 *cond);
// est_db_score_doc
// file estraier.c line 7836
static signed int est_db_score_doc(struct anonymous_0 *db, struct anonymous_14 *doc, struct anonymous_15 *cond, signed int *scp);
// est_db_search
// file estraier.c line 2746
signed int * est_db_search(struct anonymous_0 *db, struct anonymous_15 *cond, signed int *nump, struct anonymous_5 *hints);
// est_db_search_meta
// file estraier.c line 3072
signed int * est_db_search_meta(struct anonymous_0 **dbs, signed int dbnum, struct anonymous_15 *cond, signed int *nump, struct anonymous_5 *hints);
// est_db_set_cache_size
// file estraier.c line 3324
void est_db_set_cache_size(struct anonymous_0 *db, unsigned long int size, signed int anum, signed int tnum, signed int rnum);
// est_db_set_dfdb
// file estraier.c line 5015
void est_db_set_dfdb(struct anonymous_0 *db, struct anonymous_1 *dfdb);
// est_db_set_doc_entity
// file estraier.c line 4482
signed int est_db_set_doc_entity(struct anonymous_0 *db, signed int id, const char *ptr, signed int size);
// est_db_set_ecode
// file estraier.c line 4425
void est_db_set_ecode(struct anonymous_0 *db, signed int ecode);
// est_db_set_informer
// file estraier.c line 4985
void est_db_set_informer(struct anonymous_0 *db, void (*func)(const char *, void *), void *opaque);
// est_db_set_informer::func_object
//
void func_object(const char *, void *);
// est_db_set_special_cache
// file estraier.c line 4972
void est_db_set_special_cache(struct anonymous_0 *db, const char *name, signed int num);
// est_db_set_wildmax
// file estraier.c line 4506
void est_db_set_wildmax(struct anonymous_0 *db, signed int num);
// est_db_size
// file estraier.c line 2718
double est_db_size(struct anonymous_0 *db);
// est_db_sync
// file estraier.c line 1692
signed int est_db_sync(struct anonymous_0 *db);
// est_db_uri_to_id
// file estraier.c line 2681
signed int est_db_uri_to_id(struct anonymous_0 *db, const char *uri);
// est_db_used_cache_size
// file estraier.c line 4964
signed int est_db_used_cache_size(struct anonymous_0 *db);
// est_db_word_iter_init
// file estraier.c line 4853
signed int est_db_word_iter_init(struct anonymous_0 *db);
// est_db_word_iter_next
// file estraier.c line 4865
char * est_db_word_iter_next(struct anonymous_0 *db);
// est_db_word_num
// file estraier.c line 2709
signed int est_db_word_num(struct anonymous_0 *db);
// est_db_word_rec_size
// file estraier.c line 4883
signed int est_db_word_rec_size(struct anonymous_0 *db, const char *word);
// est_db_write_meta
// file estraier.c line 7774
static signed int est_db_write_meta(struct anonymous_0 *db);
// est_decode_idx_rec
// file estraier.c line 6951
static void est_decode_idx_rec(struct anonymous_9 *datum, const char *vbuf, signed int vsiz, signed int smode);
// est_deflate
// file estraier.c line 3750
char * est_deflate(const char *ptr, signed int size, signed int *sp, signed int mode);
// est_doc_add_attr
// file estraier.c line 492
void est_doc_add_attr(struct anonymous_14 *doc, const char *name, const char *value);
// est_doc_add_hidden_text
// file estraier.c line 540
void est_doc_add_hidden_text(struct anonymous_14 *doc, const char *text);
// est_doc_add_text
// file estraier.c line 513
void est_doc_add_text(struct anonymous_14 *doc, const char *text);
// est_doc_attr
// file estraier.c line 616
const char * est_doc_attr(struct anonymous_14 *doc, const char *name);
// est_doc_attr_names
// file estraier.c line 596
struct anonymous_6 * est_doc_attr_names(struct anonymous_14 *doc);
// est_doc_cat_texts
// file estraier.c line 632
char * est_doc_cat_texts(struct anonymous_14 *doc);
// est_doc_delete
// file estraier.c line 482
void est_doc_delete(struct anonymous_14 *doc);
// est_doc_dump_draft
// file estraier.c line 664
char * est_doc_dump_draft(struct anonymous_14 *doc);
// est_doc_dup
// file estraier.c line 4209
struct anonymous_14 * est_doc_dup(struct anonymous_14 *doc);
// est_doc_hidden_texts
// file estraier.c line 4229
const char * est_doc_hidden_texts(struct anonymous_14 *doc);
// est_doc_id
// file estraier.c line 589
signed int est_doc_id(struct anonymous_14 *doc);
// est_doc_is_empty
// file estraier.c line 4268
signed int est_doc_is_empty(struct anonymous_14 *doc);
// est_doc_keywords
// file estraier.c line 648
struct anonymous_5 * est_doc_keywords(struct anonymous_14 *doc);
// est_doc_make_snippet
// file estraier.c line 719
char * est_doc_make_snippet(struct anonymous_14 *doc, const struct anonymous_6 *words, signed int wwidth, signed int hwidth, signed int awidth);
// est_doc_new
// file estraier.c line 417
struct anonymous_14 * est_doc_new(void);
// est_doc_new_from_draft
// file estraier.c line 429
struct anonymous_14 * est_doc_new_from_draft(const char *draft);
// est_doc_score
// file estraier.c line 655
signed int est_doc_score(struct anonymous_14 *doc);
// est_doc_set_id
// file estraier.c line 4222
void est_doc_set_id(struct anonymous_14 *doc, signed int id);
// est_doc_set_keywords
// file estraier.c line 567
void est_doc_set_keywords(struct anonymous_14 *doc, struct anonymous_5 *kwords);
// est_doc_set_score
// file estraier.c line 575
void est_doc_set_score(struct anonymous_14 *doc, signed int score);
// est_doc_slim
// file estraier.c line 4238
void est_doc_slim(struct anonymous_14 *doc, signed int len);
// est_doc_texts
// file estraier.c line 624
const struct anonymous_6 * est_doc_texts(struct anonymous_14 *doc);
// est_eclipse_scores
// file estraier.c line 9858
static signed int est_eclipse_scores(struct anonymous_0 *db, struct anonymous_8 *scores, signed int snum, signed int num, signed int vnum, signed int tfidf, double limit, struct anonymous_5 *shadows);
// est_enc_miss
// file estraier.c line 5917
static signed int est_enc_miss(const char *ptr, signed int size, const char *icode, const char *ocode);
// est_enc_name
// file estraier.c line 3604
const char * est_enc_name(const char *ptr, signed int size, signed int plang);
// est_encode_idx_rec
// file estraier.c line 6912
static void est_encode_idx_rec(struct anonymous_9 *datum, const char *vbuf, signed int vsiz, signed int lid, signed int smode);
// est_err_msg
// file estraier.c line 898
const char * est_err_msg(signed int ecode);
// est_expand_keyword_bw
// file estraier.c line 8347
static void est_expand_keyword_bw(struct anonymous_0 *db, const char *word, struct anonymous_6 *list);
// est_expand_keyword_ew
// file estraier.c line 8366
static void est_expand_keyword_ew(struct anonymous_0 *db, const char *word, struct anonymous_6 *list);
// est_expand_keyword_rx
// file estraier.c line 8387
static void est_expand_keyword_rx(struct anonymous_0 *db, const char *word, struct anonymous_6 *list);
// est_expand_word_bw
// file estraier.c line 8284
static void est_expand_word_bw(struct anonymous_0 *db, const char *word, struct anonymous_6 *list);
// est_expand_word_ew
// file estraier.c line 8303
static void est_expand_word_ew(struct anonymous_0 *db, const char *word, struct anonymous_6 *list);
// est_expand_word_rx
// file estraier.c line 8324
static void est_expand_word_rx(struct anonymous_0 *db, const char *word, struct anonymous_6 *list);
// est_ext_type
// file estraier.c line 5738
const char * est_ext_type(const char *ext);
// est_free_cattr_list
// file estraier.c line 9831
static void est_free_cattr_list(struct anonymous_16 *list, signed int anum);
// est_free_net_env
// file estnode.h line 46
void est_free_net_env(void);
// est_get_client_sock
// file estnode.h line 491
signed int est_get_client_sock(const char *addr, signed int port);
// est_get_host_addr
// file estnode.h line 466
char * est_get_host_addr(const char *name);
// est_get_host_name
// file estnode.c line 1298
const char * est_get_host_name(void);
// est_get_server_sock
// file estnode.c line 1368
signed int est_get_server_sock(const char *addr, signed int port);
// est_get_tvmap
// file estraier.c line 10366
static struct anonymous_5 * est_get_tvmap(struct anonymous_0 *db, signed int id, signed int vnum, signed int tfidf);
// est_gethostaddrbyname
// file estnode.c line 1730
static char * est_gethostaddrbyname(const char *name);
// est_gettimeofday
// file estraier.h line 1523
double est_gettimeofday(void);
// est_global_lock
// file estmtdb.c line 782
static signed int est_global_lock(void);
// est_global_unlock
// file estmtdb.c line 788
static void est_global_unlock(void);
// est_hex_decode
// file estraier.c line 5895
static char * est_hex_decode(const char *str);
// est_hex_encode
// file estraier.c line 5878
static char * est_hex_encode(const char *str);
// est_hints_to_words
// file estraier.c line 5426
struct anonymous_6 * est_hints_to_words(struct anonymous_5 *hints);
// est_iconv
// file estraier.c line 3535
char * est_iconv(const char *ptr, signed int size, const char *icode, const char *ocode, signed int *sp, signed int *mp);
// est_idx_add
// file estraier.c line 7107
static signed int est_idx_add(struct anonymous_2 *idx, const char *word, signed int wsiz, const char *vbuf, signed int vsiz, signed int smode);
// est_idx_close
// file estraier.c line 7034
static signed int est_idx_close(struct anonymous_2 *idx);
// est_idx_dnum
// file estraier.c line 7094
static signed int est_idx_dnum(struct anonymous_2 *idx);
// est_idx_get_one
// file estraier.c line 7189
static const char * est_idx_get_one(struct anonymous_2 *idx, signed int inum, const char *word, signed int wsiz, signed int *sp);
// est_idx_increment
// file estraier.c line 7068
static void est_idx_increment(struct anonymous_2 *idx);
// est_idx_memflush
// file estraier.c line 7249
static signed int est_idx_memflush(struct anonymous_2 *idx);
// est_idx_num
// file estraier.c line 7216
static signed int est_idx_num(struct anonymous_2 *idx);
// est_idx_open
// file estraier.c line 6991
static struct anonymous_2 * est_idx_open(const char *name, signed int omode, signed int dnum);
// est_idx_optimize
// file estraier.c line 7275
static signed int est_idx_optimize(struct anonymous_2 *idx);
// est_idx_out
// file estraier.c line 7145
static signed int est_idx_out(struct anonymous_2 *idx, const char *word, signed int wsiz);
// est_idx_put_one
// file estraier.c line 7131
static signed int est_idx_put_one(struct anonymous_2 *idx, signed int inum, const char *word, signed int wsiz, const char *vbuf, signed int vsiz);
// est_idx_rec_last_id
// file estraier.c line 6874
static signed int est_idx_rec_last_id(const char *vbuf, signed int vsiz, signed int smode);
// est_idx_scan
// file estraier.c line 7165
static char * est_idx_scan(struct anonymous_2 *idx, const char *word, signed int wsiz, signed int *sp, signed int smode);
// est_idx_set_current
// file estraier.c line 7287
static void est_idx_set_current(struct anonymous_2 *idx);
// est_idx_set_tuning
// file estraier.c line 7055
static void est_idx_set_tuning(struct anonymous_2 *idx, signed int lrecmax, signed int nidxmax, signed int lcnum, signed int ncnum, signed int fbpsiz);
// est_idx_size
// file estraier.c line 7225
static double est_idx_size(struct anonymous_2 *idx);
// est_idx_size_current
// file estraier.c line 7240
static signed int est_idx_size_current(struct anonymous_2 *idx);
// est_idx_sync
// file estraier.c line 7262
static signed int est_idx_sync(struct anonymous_2 *idx);
// est_idx_vsiz
// file estraier.c line 7201
static signed int est_idx_vsiz(struct anonymous_2 *idx, const char *word, signed int wsiz);
// est_inet_aton
// file estnode.c line 1782
static signed int est_inet_aton(const char *cp, struct in_addr *inp);
// est_inflate
// file estraier.c line 3819
char * est_inflate(const char *ptr, signed int size, signed int *sp, signed int mode);
// est_init_net_env
// file estnode.h line 42
signed int est_init_net_env(void);
// est_inode
// file estraier.c line 5595
signed int est_inode(const char *path);
// est_inodes_delete
// file estraier.c line 7727
static void est_inodes_delete(void *arg);
// est_inodes_delete_informer
// file estraier.c line 7764
static void est_inodes_delete_informer(const char *msg, void *opaque);
// est_int_compare
// file estraier.c line 7708
static signed int est_int_compare(const void *ap, const void *bp);
// est_keysc_compare
// file estraier.c line 10203
static signed int est_keysc_compare(const void *ap, const void *bp);
// est_kill
// file estraier.c line 5715
signed int est_kill(signed int pid, signed int sig);
// est_lzodecode
// file estraier.c line 3905
char * est_lzodecode(const char *ptr, signed int size, signed int *sp);
// est_lzoencode
// file estraier.c line 3882
char * est_lzoencode(const char *ptr, signed int size, signed int *sp);
// est_make_cattr_list
// file estraier.c line 9703
static struct anonymous_16 * est_make_cattr_list(const struct anonymous_6 *attrs, signed int *nump);
// est_make_crypt
// file estraier.c line 4088
char * est_make_crypt(const char *key);
// est_make_snippet
// file estraier.c line 6438
static char * est_make_snippet(const char *str, signed int len, const struct anonymous_6 *words, signed int wwidth, signed int hwidth, signed int awidth);
// est_match_attr
// file estraier.c line 10008
static signed int est_match_attr(const char *tval, signed int tsiz, const char *cop, signed int sign, const char *oval, signed int osiz, const char *sval, signed int ssiz, const void *regex, signed int onum);
// est_match_crypt
// file estraier.c line 4105
signed int est_match_crypt(const char *key, const char *hash);
// est_memory_usage
// file estraier.c line 5725
double est_memory_usage(void);
// est_metascore_compare_by_id_asc
// file estraier.c line 8168
static signed int est_metascore_compare_by_id_asc(const void *ap, const void *bp);
// est_metascore_compare_by_id_desc
// file estraier.c line 8178
static signed int est_metascore_compare_by_id_desc(const void *ap, const void *bp);
// est_metascore_compare_by_num_asc
// file estraier.c line 8228
static signed int est_metascore_compare_by_num_asc(const void *ap, const void *bp);
// est_metascore_compare_by_num_desc
// file estraier.c line 8238
static signed int est_metascore_compare_by_num_desc(const void *ap, const void *bp);
// est_metascore_compare_by_score_asc
// file estraier.c line 8188
static signed int est_metascore_compare_by_score_asc(const void *ap, const void *bp);
// est_metascore_compare_by_score_desc
// file estraier.c line 8198
static signed int est_metascore_compare_by_score_desc(const void *ap, const void *bp);
// est_metascore_compare_by_str_asc
// file estraier.c line 8208
static signed int est_metascore_compare_by_str_asc(const void *ap, const void *bp);
// est_metascore_compare_by_str_desc
// file estraier.c line 8218
static signed int est_metascore_compare_by_str_desc(const void *ap, const void *bp);
// est_mkdir
// file estraier.c line 5533
signed int est_mkdir(const char *path);
// est_mtdb_add_attr_index
// file estmtdb.c line 123
signed int est_mtdb_add_attr_index(struct anonymous_12 *db, const char *name, signed int type);
// est_mtdb_add_meta
// file estmtdb.c line 449
void est_mtdb_add_meta(struct anonymous_12 *db, const char *name, const char *value);
// est_mtdb_add_pseudo_index
// file estmtdb.c line 370
signed int est_mtdb_add_pseudo_index(struct anonymous_12 *db, const char *path);
// est_mtdb_attr_index_exprs
// file estmtdb.c line 744
struct anonymous_6 * est_mtdb_attr_index_exprs(struct anonymous_12 *db);
// est_mtdb_cache_num
// file estmtdb.c line 646
signed int est_mtdb_cache_num(struct anonymous_12 *db);
// est_mtdb_cache_usage
// file estmtdb.c line 768
double est_mtdb_cache_usage(struct anonymous_12 *db);
// est_mtdb_charge_rescc
// file estmtdb.c line 713
void est_mtdb_charge_rescc(struct anonymous_12 *db, signed int max);
// est_mtdb_check_option
// file estmtdb.c line 396
signed int est_mtdb_check_option(struct anonymous_12 *db, signed int option);
// est_mtdb_close
// file estmtdb.c line 82
signed int est_mtdb_close(struct anonymous_12 *db, signed int *ecp);
// est_mtdb_doc_num
// file estmtdb.c line 255
signed int est_mtdb_doc_num(struct anonymous_12 *db);
// est_mtdb_edit_doc
// file estmtdb.c line 200
signed int est_mtdb_edit_doc(struct anonymous_12 *db, struct anonymous_14 *doc);
// est_mtdb_error
// file estmtdb.c line 101
signed int est_mtdb_error(struct anonymous_12 *db);
// est_mtdb_etch_doc
// file estmtdb.c line 480
struct anonymous_5 * est_mtdb_etch_doc(struct anonymous_12 *db, struct anonymous_14 *doc, signed int max);
// est_mtdb_fatal
// file estmtdb.c line 112
signed int est_mtdb_fatal(struct anonymous_12 *db);
// est_mtdb_fill_key_cache
// file estmtdb.c line 686
void est_mtdb_fill_key_cache(struct anonymous_12 *db);
// est_mtdb_flush
// file estmtdb.c line 134
signed int est_mtdb_flush(struct anonymous_12 *db, signed int max);
// est_mtdb_get_doc
// file estmtdb.c line 211
struct anonymous_14 * est_mtdb_get_doc(struct anonymous_12 *db, signed int id, signed int options);
// est_mtdb_get_doc_attr
// file estmtdb.c line 222
char * est_mtdb_get_doc_attr(struct anonymous_12 *db, signed int id, const char *name);
// est_mtdb_get_doc_entity
// file estmtdb.c line 429
char * est_mtdb_get_doc_entity(struct anonymous_12 *db, signed int id, signed int *sp);
// est_mtdb_get_keywords
// file estmtdb.c line 514
struct anonymous_5 * est_mtdb_get_keywords(struct anonymous_12 *db, signed int id);
// est_mtdb_inode
// file estmtdb.c line 407
signed int est_mtdb_inode(struct anonymous_12 *db);
// est_mtdb_interrupt
// file estmtdb.c line 755
void est_mtdb_interrupt(struct anonymous_12 *db);
// est_mtdb_iter_init
// file estmtdb.c line 536
signed int est_mtdb_iter_init(struct anonymous_12 *db, const char *prev);
// est_mtdb_iter_next
// file estmtdb.c line 547
signed int est_mtdb_iter_next(struct anonymous_12 *db);
// est_mtdb_keyword_iter_init
// file estmtdb.c line 602
signed int est_mtdb_keyword_iter_init(struct anonymous_12 *db);
// est_mtdb_keyword_iter_next
// file estmtdb.c line 613
char * est_mtdb_keyword_iter_next(struct anonymous_12 *db);
// est_mtdb_keyword_num
// file estmtdb.c line 591
signed int est_mtdb_keyword_num(struct anonymous_12 *db);
// est_mtdb_keyword_rec_size
// file estmtdb.c line 624
signed int est_mtdb_keyword_rec_size(struct anonymous_12 *db, const char *word);
// est_mtdb_keyword_search
// file estmtdb.c line 635
signed int * est_mtdb_keyword_search(struct anonymous_12 *db, const char *word, signed int *nump);
// est_mtdb_list_rescc
// file estmtdb.c line 722
struct anonymous_6 * est_mtdb_list_rescc(struct anonymous_12 *db);
// est_mtdb_lock
// file estmtdb.c line 796
static signed int est_mtdb_lock(struct anonymous_12 *db);
// est_mtdb_measure_doc
// file estmtdb.c line 525
signed int est_mtdb_measure_doc(struct anonymous_12 *db, signed int id, signed int parts);
// est_mtdb_merge
// file estmtdb.c line 167
signed int est_mtdb_merge(struct anonymous_12 *db, const char *name, signed int options);
// est_mtdb_meta
// file estmtdb.c line 469
char * est_mtdb_meta(struct anonymous_12 *db, const char *name);
// est_mtdb_meta_names
// file estmtdb.c line 458
struct anonymous_6 * est_mtdb_meta_names(struct anonymous_12 *db);
// est_mtdb_name
// file estmtdb.c line 244
const char * est_mtdb_name(struct anonymous_12 *db);
// est_mtdb_open
// file estmtdb.c line 43
struct anonymous_12 * est_mtdb_open(const char *name, signed int omode, signed int *ecp);
// est_mtdb_optimize
// file estmtdb.c line 156
signed int est_mtdb_optimize(struct anonymous_12 *db, signed int options);
// est_mtdb_out_doc
// file estmtdb.c line 189
signed int est_mtdb_out_doc(struct anonymous_12 *db, signed int id, signed int options);
// est_mtdb_out_keywords
// file estmtdb.c line 503
signed int est_mtdb_out_keywords(struct anonymous_12 *db, signed int id);
// est_mtdb_pseudo_doc_num
// file estmtdb.c line 733
signed int est_mtdb_pseudo_doc_num(struct anonymous_12 *db);
// est_mtdb_put_doc
// file estmtdb.c line 178
signed int est_mtdb_put_doc(struct anonymous_12 *db, struct anonymous_14 *doc, signed int options);
// est_mtdb_put_keywords
// file estmtdb.c line 492
signed int est_mtdb_put_keywords(struct anonymous_12 *db, signed int id, struct anonymous_5 *kwords, double weight);
// est_mtdb_refresh_rescc
// file estmtdb.c line 704
void est_mtdb_refresh_rescc(struct anonymous_12 *db);
// est_mtdb_scan_doc
// file estmtdb.c line 350
signed int est_mtdb_scan_doc(struct anonymous_12 *db, struct anonymous_14 *doc, struct anonymous_15 *cond);
// est_mtdb_search
// file estmtdb.c line 288
signed int * est_mtdb_search(struct anonymous_12 *db, struct anonymous_15 *cond, signed int *nump, struct anonymous_5 *hints);
// est_mtdb_search_meta
// file estmtdb.c line 304
signed int * est_mtdb_search_meta(struct anonymous_12 **dbs, signed int dbnum, struct anonymous_15 *cond, signed int *nump, struct anonymous_5 *hints);
// est_mtdb_set_cache_size
// file estmtdb.c line 361
void est_mtdb_set_cache_size(struct anonymous_12 *db, unsigned long int size, signed int anum, signed int tnum, signed int rnum);
// est_mtdb_set_dfdb
// file estmtdb.c line 695
void est_mtdb_set_dfdb(struct anonymous_12 *db, struct anonymous_1 *dfdb);
// est_mtdb_set_doc_entity
// file estmtdb.c line 418
signed int est_mtdb_set_doc_entity(struct anonymous_12 *db, signed int id, const char *ptr, signed int size);
// est_mtdb_set_ecode
// file estmtdb.c line 387
void est_mtdb_set_ecode(struct anonymous_12 *db, signed int ecode);
// est_mtdb_set_informer
// file estmtdb.c line 677
void est_mtdb_set_informer(struct anonymous_12 *db, void (*func)(const char *, void *), void *opaque);
// est_mtdb_set_informer::func_object
//
void func_object(const char *, void *);
// est_mtdb_set_special_cache
// file estmtdb.c line 668
void est_mtdb_set_special_cache(struct anonymous_12 *db, const char *name, signed int num);
// est_mtdb_set_wildmax
// file estmtdb.c line 440
void est_mtdb_set_wildmax(struct anonymous_12 *db, signed int num);
// est_mtdb_size
// file estmtdb.c line 277
double est_mtdb_size(struct anonymous_12 *db);
// est_mtdb_sync
// file estmtdb.c line 145
signed int est_mtdb_sync(struct anonymous_12 *db);
// est_mtdb_unlock
// file estmtdb.c line 815
static void est_mtdb_unlock(struct anonymous_12 *db);
// est_mtdb_uri_to_id
// file estmtdb.c line 233
signed int est_mtdb_uri_to_id(struct anonymous_12 *db, const char *uri);
// est_mtdb_used_cache_size
// file estmtdb.c line 657
signed int est_mtdb_used_cache_size(struct anonymous_12 *db);
// est_mtdb_word_iter_init
// file estmtdb.c line 558
signed int est_mtdb_word_iter_init(struct anonymous_12 *db);
// est_mtdb_word_iter_next
// file estmtdb.c line 569
char * est_mtdb_word_iter_next(struct anonymous_12 *db);
// est_mtdb_word_num
// file estmtdb.c line 266
signed int est_mtdb_word_num(struct anonymous_12 *db);
// est_mtdb_word_rec_size
// file estmtdb.c line 580
signed int est_mtdb_word_rec_size(struct anonymous_12 *db, const char *word);
// est_narrow_scores
// file estraier.c line 9386
static signed int est_narrow_scores(struct anonymous_0 *db, const struct anonymous_6 *attrs, signed int ign, const char *order, const char *distinct, struct anonymous_8 *scores, signed int snum, signed int limit, signed int *restp, struct anonymous_5 *ordattrs);
// est_node_add_header
// file estnode.c line 1638
void est_node_add_header(struct anonymous_24 *node, const char *name, const char *value);
// est_node_admins
// file estnode.c line 1046
const struct anonymous_6 * est_node_admins(struct anonymous_24 *node);
// est_node_cache_usage
// file estnode.c line 1009
double est_node_cache_usage(struct anonymous_24 *node);
// est_node_delete
// file estnode.c line 358
void est_node_delete(struct anonymous_24 *node);
// est_node_doc_num
// file estnode.c line 982
signed int est_node_doc_num(struct anonymous_24 *node);
// est_node_edit_doc
// file estnode.c line 591
signed int est_node_edit_doc(struct anonymous_24 *node, struct anonymous_14 *doc);
// est_node_etch_doc
// file estnode.c line 814
struct anonymous_5 * est_node_etch_doc(struct anonymous_24 *node, signed int id);
// est_node_etch_doc_by_uri
// file estnode.c line 868
struct anonymous_5 * est_node_etch_doc_by_uri(struct anonymous_24 *node, const char *uri);
// est_node_get_doc
// file estnode.c line 638
struct anonymous_14 * est_node_get_doc(struct anonymous_24 *node, signed int id);
// est_node_get_doc_attr
// file estnode.c line 722
char * est_node_get_doc_attr(struct anonymous_24 *node, signed int id, const char *name);
// est_node_get_doc_attr_by_uri
// file estnode.c line 768
char * est_node_get_doc_attr_by_uri(struct anonymous_24 *node, const char *uri, const char *name);
// est_node_get_doc_by_uri
// file estnode.c line 680
struct anonymous_14 * est_node_get_doc_by_uri(struct anonymous_24 *node, const char *uri);
// est_node_iter_delete
// file estnode.c line 2070
static void est_node_iter_delete(struct anonymous_24 *node);
// est_node_iter_init
// file estnode.c line 1614
signed int est_node_iter_init(struct anonymous_24 *node);
// est_node_iter_next
// file estnode.c line 1621
struct anonymous_14 * est_node_iter_next(struct anonymous_24 *node);
// est_node_label
// file estnode.c line 973
const char * est_node_label(struct anonymous_24 *node);
// est_node_links
// file estnode.c line 1064
const struct anonymous_6 * est_node_links(struct anonymous_24 *node);
// est_node_name
// file estnode.c line 964
const char * est_node_name(struct anonymous_24 *node);
// est_node_new
// file estnode.c line 330
struct anonymous_24 * est_node_new(const char *url);
// est_node_optimize
// file estnode.c line 443
signed int est_node_optimize(struct anonymous_24 *node);
// est_node_out_doc
// file estnode.c line 515
signed int est_node_out_doc(struct anonymous_24 *node, signed int id);
// est_node_out_doc_by_uri
// file estnode.c line 553
signed int est_node_out_doc_by_uri(struct anonymous_24 *node, const char *uri);
// est_node_put_doc
// file estnode.c line 480
signed int est_node_put_doc(struct anonymous_24 *node, struct anonymous_14 *doc);
// est_node_read_list
// file estnode.c line 2088
static signed int est_node_read_list(struct anonymous_24 *node);
// est_node_search
// file estnode.c line 1073
struct anonymous_17 * est_node_search(struct anonymous_24 *node, struct anonymous_15 *cond, signed int depth);
// est_node_set_auth
// file estnode.c line 391
void est_node_set_auth(struct anonymous_24 *node, const char *name, const char *passwd);
// est_node_set_info
// file estnode.c line 1951
static signed int est_node_set_info(struct anonymous_24 *node);
// est_node_set_link
// file estnode.c line 1248
signed int est_node_set_link(struct anonymous_24 *node, const char *url, const char *label, signed int credit);
// est_node_set_proxy
// file estnode.c line 375
void est_node_set_proxy(struct anonymous_24 *node, const char *host, signed int port);
// est_node_set_snippet_width
// file estnode.c line 1199
void est_node_set_snippet_width(struct anonymous_24 *node, signed int wwidth, signed int hwidth, signed int awidth);
// est_node_set_timeout
// file estnode.c line 384
void est_node_set_timeout(struct anonymous_24 *node, signed int sec);
// est_node_set_user
// file estnode.c line 1208
signed int est_node_set_user(struct anonymous_24 *node, const char *name, signed int mode);
// est_node_size
// file estnode.c line 1000
double est_node_size(struct anonymous_24 *node);
// est_node_status
// file estnode.c line 399
signed int est_node_status(struct anonymous_24 *node);
// est_node_sync
// file estnode.c line 406
signed int est_node_sync(struct anonymous_24 *node);
// est_node_uri_to_id
// file estnode.c line 923
signed int est_node_uri_to_id(struct anonymous_24 *node, const char *uri);
// est_node_users
// file estnode.c line 1055
const struct anonymous_6 * est_node_users(struct anonymous_24 *node);
// est_node_word_num
// file estnode.c line 991
signed int est_node_word_num(struct anonymous_24 *node);
// est_noderes_add_doc
// file estnode.c line 1673
void est_noderes_add_doc(struct anonymous_17 *nres, struct anonymous_5 *attrs, char *snippet);
// est_noderes_delete
// file estnode.c line 147
void est_noderes_delete(struct anonymous_17 *nres);
// est_noderes_doc_num
// file estnode.c line 240
signed int est_noderes_doc_num(struct anonymous_17 *nres);
// est_noderes_eclipse
// file estnode.c line 174
void est_noderes_eclipse(struct anonymous_17 *nres, signed int num, double limit);
// est_noderes_get_doc
// file estnode.c line 247
struct _ESTRESDOC * est_noderes_get_doc(struct anonymous_17 *nres, signed int index);
// est_noderes_hints
// file estnode.c line 167
struct anonymous_5 * est_noderes_hints(struct anonymous_17 *nres);
// est_noderes_mdate
// file estnode.c line 1713
signed long int est_noderes_mdate(struct anonymous_17 *nres);
// est_noderes_new
// file estnode.c line 1657
struct anonymous_17 * est_noderes_new(void);
// est_noderes_shift_doc
// file estnode.c line 1699
signed int est_noderes_shift_doc(struct anonymous_17 *nres, struct anonymous_5 **attrp, char **snippetp);
// est_normalize_text
// file estraier.c line 5950
static void est_normalize_text(unsigned char *utext, signed int size, signed int *sp);
// est_parse_search_body
// file estnode.c line 2186
static void est_parse_search_body(struct anonymous_17 *nres, char *str);
// est_parse_search_header
// file estnode.c line 2168
static void est_parse_search_header(struct anonymous_17 *nres, const char *str);
// est_phrase_from_isect
// file estraier.c line 6730
static char * est_phrase_from_isect(const char *iphrase);
// est_phrase_from_rough
// file estraier.c line 6632
static char * est_phrase_from_rough(const char *rphrase);
// est_phrase_from_simple
// file estraier.c line 6549
static char * est_phrase_from_simple(const char *sphrase);
// est_phrase_from_union
// file estraier.c line 6699
static char * est_phrase_from_union(const char *uphrase);
// est_phrase_terms
// file estraier.c line 8020
static struct anonymous_6 * est_phrase_terms(const char *phrase);
// est_phrase_vector
// file estraier.c line 10301
static struct anonymous_5 * est_phrase_vector(const char *phrase);
// est_pidx_uri_to_id
// file estraier.c line 7997
static signed int est_pidx_uri_to_id(struct anonymous_0 *db, const char *uri);
// est_proc_env_reset
// file estraier.h line 1485
void est_proc_env_reset(void);
// est_random
// file estraier.c line 4058
double est_random(void);
// est_random_fclose
// file estraier.c line 10424
static void est_random_fclose(void);
// est_random_nd
// file estraier.c line 4078
double est_random_nd(void);
// est_realpath
// file estraier.c line 5565
char * est_realpath(const char *path);
// est_regex_delete
// file estraier.c line 4132
void est_regex_delete(void *regex);
// est_regex_match
// file estraier.c line 4140
signed int est_regex_match(const void *regex, const char *str);
// est_regex_match_str
// file estraier.c line 4147
signed int est_regex_match_str(const char *rstr, const char *tstr);
// est_regex_new
// file estraier.c line 4117
void * est_regex_new(const char *str);
// est_regex_replace
// file estraier.c line 4159
char * est_regex_replace(const char *str, const char *bef, const char *aft);
// est_rescc_get
// file estraier.c line 8759
static const struct anonymous_8 * est_rescc_get(struct anonymous_0 *db, const char *word, signed int size, signed int *nump);
// est_rescc_put
// file estraier.c line 8777
static void est_rescc_put(struct anonymous_0 *db, const char *word, signed int size, struct anonymous_8 *scores, signed int num);
// est_resdoc_attr
// file estnode.c line 282
const char * est_resdoc_attr(struct _ESTRESDOC *rdoc, const char *name);
// est_resdoc_attr_names
// file estnode.c line 266
struct anonymous_6 * est_resdoc_attr_names(struct _ESTRESDOC *rdoc);
// est_resdoc_keywords
// file estnode.c line 296
const char * est_resdoc_keywords(struct _ESTRESDOC *rdoc);
// est_resdoc_shadows
// file estnode.c line 305
struct _ESTRESDOC ** est_resdoc_shadows(struct _ESTRESDOC *rdoc, signed int *np);
// est_resdoc_similarity
// file estnode.c line 317
double est_resdoc_similarity(struct _ESTRESDOC *rdoc);
// est_resdoc_snippet
// file estnode.c line 289
const char * est_resdoc_snippet(struct _ESTRESDOC *rdoc);
// est_resdoc_uri
// file estnode.c line 259
const char * est_resdoc_uri(struct _ESTRESDOC *rdoc);
// est_resmap_add
// file estraier.c line 5442
void est_resmap_add(struct anonymous_5 *map, const char *key, signed int score, signed int method);
// est_resmap_dump
// file estraier.c line 5485
struct anonymous * est_resmap_dump(struct anonymous_5 *map, signed int min, signed int *nump);
// est_resmapelem_compare
// file estraier.c line 5478
static signed int est_resmapelem_compare(const void *ap, const void *bp);
// est_rmdir_rec
// file estraier.c line 5545
signed int est_rmdir_rec(const char *path);
// est_score_compare_by_id_asc
// file estraier.c line 8088
static signed int est_score_compare_by_id_asc(const void *ap, const void *bp);
// est_score_compare_by_id_desc
// file estraier.c line 8098
static signed int est_score_compare_by_id_desc(const void *ap, const void *bp);
// est_score_compare_by_num_asc
// file estraier.c line 8148
static signed int est_score_compare_by_num_asc(const void *ap, const void *bp);
// est_score_compare_by_num_desc
// file estraier.c line 8158
static signed int est_score_compare_by_num_desc(const void *ap, const void *bp);
// est_score_compare_by_score_asc
// file estraier.c line 8108
static signed int est_score_compare_by_score_asc(const void *ap, const void *bp);
// est_score_compare_by_score_desc
// file estraier.c line 8118
static signed int est_score_compare_by_score_desc(const void *ap, const void *bp);
// est_score_compare_by_str_asc
// file estraier.c line 8128
static signed int est_score_compare_by_str_asc(const void *ap, const void *bp);
// est_score_compare_by_str_desc
// file estraier.c line 8138
static signed int est_score_compare_by_str_desc(const void *ap, const void *bp);
// est_search_aidx_attr
// file estraier.c line 8980
static struct anonymous_8 * est_search_aidx_attr(struct anonymous_0 *db, const char *expr, signed int *nump);
// est_search_keywords
// file estraier.c line 8802
static struct anonymous_8 * est_search_keywords(struct anonymous_0 *db, const char *word, signed int min, signed int *nump);
// est_search_pidxs
// file estraier.c line 9234
static struct anonymous_8 * est_search_pidxs(struct anonymous_0 *db, struct anonymous_15 *cond, struct anonymous_8 *scores, signed int *nump, struct anonymous_5 *ordattrs);
// est_search_rank
// file estraier.c line 8916
static struct anonymous_8 * est_search_rank(struct anonymous_0 *db, const char *name, signed int top, signed int *nump);
// est_search_similar
// file estraier.c line 10222
static struct anonymous_8 * est_search_similar(struct anonymous_0 *db, struct anonymous_5 *svmap, signed int *nump, signed int knum, signed int unum, signed int mnum, signed int tfidf, double nmin, signed int auxmin, struct anonymous_5 *auxwords);
// est_search_union
// file estraier.c line 8420
static struct anonymous_8 * est_search_union(struct anonymous_0 *db, const char *term, signed int gstep, void (*xpn)(const char *, struct anonymous_6 *), signed int *nump, struct anonymous_5 *hints, signed int add, signed int auxmin, struct anonymous_5 *auxwords);
// est_search_union::xpn_object
//
void xpn_object(const char *, struct anonymous_6 *);
// est_search_uvset
// file estraier.c line 8250
static struct anonymous_8 * est_search_uvset(struct anonymous_0 *db, signed int *nump, struct anonymous_5 *hints, signed int add);
// est_set_ecode
// file estraier.c line 5862
static void est_set_ecode(signed int *ecp, signed int value, signed int line);
// est_short_compare
// file estraier.c line 7718
static signed int est_short_compare(const void *ap, const void *bp);
// est_signal
// file estraier.c line 5665
void est_signal(signed int signum, void (*sighandler)(signed int));
// est_signal::sighandler_object
//
void sighandler_object(signed int);
// est_signal_dispatch
// file estraier.c line 10431
static signed int est_signal_dispatch(signed int signum);
// est_snippet_add_text
// file estraier.c line 6765
static void est_snippet_add_text(const unsigned char *rtext, const unsigned char *ctext, signed int size, signed int awsiz, struct anonymous_9 *res, const struct anonymous_6 *rwords);
// est_sock_close
// file estnode.c line 1767
static signed int est_sock_close(signed int sock);
// est_sock_down
// file estnode.h line 496
void est_sock_down(signed int sock);
// est_sock_recv_all
// file estnode.c line 1465
char * est_sock_recv_all(signed int sock, signed int len);
// est_sock_recv_line
// file estnode.c line 1482
signed int est_sock_recv_line(signed int sock, char *buf, signed int max);
// est_sock_recv_void
// file estnode.c line 1518
void est_sock_recv_void(signed int sock);
// est_sock_send_all
// file estnode.h line 530
void est_sock_send_all(signed int sock, const char *buf, signed int len);
// est_sockpt_down
// file estnode.c line 1942
static void est_sockpt_down(void *sp);
// est_str_fwmatch_wide
// file estraier.c line 6812
static signed int est_str_fwmatch_wide(const unsigned char *str, signed int size, const unsigned char *key, signed int ksiz);
// est_str_make_snippet
// file estraier.c line 3498
char * est_str_make_snippet(const char *str, const struct anonymous_6 *words, signed int wwidth, signed int hwidth, signed int awidth);
// est_strstr_sparse
// file estraier.c line 6841
static char * est_strstr_sparse(const char *haystack, const char *needle);
// est_uconv_in
// file estraier.c line 3672
char * est_uconv_in(const char *ptr, signed int size, signed int *sp);
// est_uconv_out
// file estraier.c line 3720
char * est_uconv_out(const char *ptr, signed int size, signed int *sp);
// est_url_sameness
// file estraier.c line 10382
static signed int est_url_sameness(const char *aurl, const char *burl);
// est_url_shuttle
// file estnode.c line 1555
signed int est_url_shuttle(const char *url, const char *pxhost, signed int pxport, signed int outsec, signed int limsize, const char *auth, const struct anonymous_6 *reqheads, const char *reqbody, signed int rbsiz, signed int *rescodep, struct anonymous_5 *resheads, struct anonymous_9 *resbody);
// est_url_shuttle_impl
// file estnode.c line 1805
static void * est_url_shuttle_impl(void *targ);
// est_url_shuttle_impl::1::1::2::2::2::2::2::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// est_url_shuttle_impl::1::1::2::2::2::2::__cancel_routine_object
//
void __cancel_routine_object(void *);
// est_url_shuttle_impl::1::1::2::2::__cancel_routine_object
//
void __cancel_routine_object(void *);
// est_url_shuttle_impl::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// est_usleep
// file estraier.h line 1528
void est_usleep(unsigned long int usec);
// est_utime
// file estraier.c line 5620
signed int est_utime(const char *path, signed long int mtime);
// est_vector_cosine
// file estraier.c line 5829
double est_vector_cosine(const signed int *avec, const signed int *bvec, signed int vnum);
// est_vector_set_seed
// file estraier.c line 5794
void est_vector_set_seed(struct anonymous_5 *svmap, signed int *svec, signed int vnum);
// est_vector_set_target
// file estraier.c line 5812
void est_vector_set_target(struct anonymous_5 *svmap, struct anonymous_5 *tvmap, signed int *tvec, signed int vnum);
// est_weight_keywords
// file estraier.c line 8880
static void est_weight_keywords(struct anonymous_0 *db, const char *word, struct anonymous_8 *scores, signed int snum);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyname_r
// file /usr/include/netdb.h line 179
extern signed int gethostbyname_r(const char *, struct hostent *, char *, unsigned long int, struct hostent ** restrict , signed int *);
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// iconv
// file /usr/include/iconv.h line 42
extern unsigned long int iconv(void *, char ** restrict , unsigned long int *, char ** restrict , unsigned long int *);
// iconv_close
// file /usr/include/iconv.h line 51
extern signed int iconv_close(void *);
// iconv_open
// file /usr/include/iconv.h line 37
extern void * iconv_open(const char *, const char *);
// inet_aton
// file /usr/include/arpa/inet.h line 73
extern signed int inet_aton(const char *, struct in_addr *);
// inet_ntoa
// file /usr/include/arpa/inet.h line 53
extern char * inet_ntoa(struct in_addr);
// inflate
// file /usr/include/zlib.h line 392
extern signed int inflate(struct z_stream_s *, signed int);
// inflateEnd
// file /usr/include/zlib.h line 508
extern signed int inflateEnd(struct z_stream_s *);
// inflateInit2_
// file /usr/include/zlib.h line 1641
extern signed int inflateInit2_(struct z_stream_s *, signed int, const char *, signed int);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// log
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern double log(double);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// md5_append
// file md5.h line 82
void md5_append(struct md5_state_s *pms, const unsigned char *data, signed int nbytes);
// md5_finish
// file md5.h line 85
void md5_finish(struct md5_state_s *pms, unsigned char *digest);
// md5_init
// file md5.h line 79
void md5_init(struct md5_state_s *pms);
// md5_process
// file md5.c line 132
static void md5_process(struct md5_state_s *pms, const unsigned char *data);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// printferror
// file estload.c line 116
static void printferror(const char *format, ...);
// printfinfo
// file estload.c line 128
static void printfinfo(const char *format, ...);
// procmain
// file estload.c line 140
static signed int procmain(const char *file, signed int tnum, signed int lnum, signed int ims, signed int pb, signed int qb);
// procthread
// file estload.c line 243
static void * procthread(void *arg);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_20 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_20 *, const union anonymous_13 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_20 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous_20 *, union anonymous_11 *, struct timespec *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_11 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_11 *, const union anonymous_13 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_11 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_11 *);
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// putchar
// file /usr/include/stdio.h line 580
extern signed int putchar(signed int);
// putenv
// file /usr/include/stdlib.h line 578
extern signed int putenv(char *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// realpath
// file /usr/include/stdlib.h line 733
extern char * realpath(const char *, char *);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous_37 *, signed int);
// regfree
// file /usr/include/regex.h line 574
extern void regfree(struct re_pattern_buffer *);
// rmdir
// file /usr/include/unistd.h line 835
extern signed int rmdir(const char *);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_18 *, struct anonymous_18 *, struct anonymous_18 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_25 *);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern double sqrt(double);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usage
// file estload.c line 105
static void usage(void);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// utime
// file /usr/include/utime.h line 45
extern signed int utime(const char *, struct utimbuf *);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vlclose
// file /usr/include/qdbm/villa.h line 189
signed int vlclose(struct anonymous_4 *);
// vlcrdnumptr
// file /usr/include/qdbm/villa.h line 570
signed int * vlcrdnumptr(void);
// vlcurfirst
// file /usr/include/qdbm/villa.h line 315
signed int vlcurfirst(struct anonymous_4 *);
// vlcurjump
// file /usr/include/qdbm/villa.h line 351
signed int vlcurjump(struct anonymous_4 *, const char *, signed int, signed int);
// vlcurkey
// file /usr/include/qdbm/villa.h line 364
char * vlcurkey(struct anonymous_4 *, signed int *);
// vlcurkeycache
// file /usr/include/qdbm/villa.h line 608
const char * vlcurkeycache(struct anonymous_4 *, signed int *);
// vlcurlast
// file /usr/include/qdbm/villa.h line 322
signed int vlcurlast(struct anonymous_4 *);
// vlcurnext
// file /usr/include/qdbm/villa.h line 336
signed int vlcurnext(struct anonymous_4 *);
// vlcurprev
// file /usr/include/qdbm/villa.h line 329
signed int vlcurprev(struct anonymous_4 *);
// vlcurval
// file /usr/include/qdbm/villa.h line 378
char * vlcurval(struct anonymous_4 *, signed int *);
// vlcurvalcache
// file /usr/include/qdbm/villa.h line 622
const char * vlcurvalcache(struct anonymous_4 *, signed int *);
// vlfsiz
// file /usr/include/qdbm/villa.h line 458
signed int vlfsiz(struct anonymous_4 *);
// vlget
// file /usr/include/qdbm/villa.h line 238
char * vlget(struct anonymous_4 *, const char *, signed int, signed int *);
// vlgetcache
// file /usr/include/qdbm/villa.h line 597
const char * vlgetcache(struct anonymous_4 *, const char *, signed int, signed int *);
// vlmemflush
// file /usr/include/qdbm/villa.h line 582
signed int vlmemflush(struct anonymous_4 *);
// vlopen
// file /usr/include/qdbm/villa.h line 179
struct anonymous_4 * vlopen(const char *, signed int, signed int (*)(const char *, signed int, const char *, signed int));
// vloptimize
// file /usr/include/qdbm/villa.h line 442
signed int vloptimize(struct anonymous_4 *);
// vlout
// file /usr/include/qdbm/villa.h line 220
signed int vlout(struct anonymous_4 *, const char *, signed int);
// vlput
// file /usr/include/qdbm/villa.h line 208
signed int vlput(struct anonymous_4 *, const char *, signed int, const char *, signed int, signed int);
// vlrepair
// file /usr/include/qdbm/villa.h line 540
signed int vlrepair(const char *, signed int (*)(const char *, signed int, const char *, signed int));
// vlrnum
// file /usr/include/qdbm/villa.h line 477
signed int vlrnum(struct anonymous_4 *);
// vlsetfbpsiz
// file /usr/include/qdbm/villa.h line 425
signed int vlsetfbpsiz(struct anonymous_4 *, signed int);
// vlsettuning
// file /usr/include/qdbm/villa.h line 416
void vlsettuning(struct anonymous_4 *, signed int, signed int, signed int, signed int);
// vlsync
// file /usr/include/qdbm/villa.h line 433
signed int vlsync(struct anonymous_4 *);
// vlvsiz
// file /usr/include/qdbm/villa.h line 248
signed int vlvsiz(struct anonymous_4 *, const char *, signed int);
// vprintf
// file /usr/include/stdio.h line 377
extern signed int vprintf(const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_5
{
  // buckets
  struct _CBMAPDATUM **buckets;
  // first
  struct _CBMAPDATUM *first;
  // last
  struct _CBMAPDATUM *last;
  // cur
  struct _CBMAPDATUM *cur;
  // bnum
  signed int bnum;
  // rnum
  signed int rnum;
};

struct anonymous_9
{
  // dptr
  char *dptr;
  // dsize
  signed int dsize;
  // asize
  signed int asize;
};

struct anonymous_28
{
  // dptr
  char *dptr;
  // dsize
  signed int dsize;
};

struct anonymous_30
{
  // host
  char *host;
  // addr
  char *addr;
  // port
  signed int port;
  // auth
  char *auth;
  // path
  char *path;
  // query
  char *query;
};

struct anonymous_0
{
  // name
  char *name;
  // inode
  signed int inode;
  // metadb
  struct anonymous_1 *metadb;
  // idxdb
  struct anonymous_2 *idxdb;
  // fwmdb
  struct anonymous_4 *fwmdb;
  // auxdb
  struct anonymous_4 *auxdb;
  // xfmdb
  struct anonymous_4 *xfmdb;
  // attrdb
  struct anonymous_3 *attrdb;
  // textdb
  struct anonymous_3 *textdb;
  // kwddb
  struct anonymous_3 *kwddb;
  // listdb
  struct anonymous_4 *listdb;
  // aidxs
  struct anonymous_5 *aidxs;
  // pdocs
  struct anonymous_6 *pdocs;
  // puris
  struct anonymous_5 *puris;
  // ecode
  signed int ecode;
  // fatal
  signed int fatal;
  // dseq
  signed int dseq;
  // dnum
  signed int dnum;
  // amode
  signed int amode;
  // zmode
  signed int zmode;
  // smode
  signed int smode;
  // idxcc
  struct anonymous_5 *idxcc;
  // auxcc
  struct anonymous_5 *auxcc;
  // icsiz
  unsigned long int icsiz;
  // icmax
  unsigned long int icmax;
  // outcc
  struct anonymous_5 *outcc;
  // keycc
  struct anonymous_5 *keycc;
  // kcmnum
  signed int kcmnum;
  // attrcc
  struct anonymous_5 *attrcc;
  // acmnum
  signed int acmnum;
  // textcc
  struct anonymous_5 *textcc;
  // tcmnum
  signed int tcmnum;
  // veccc
  struct anonymous_5 *veccc;
  // vcmnum
  signed int vcmnum;
  // rescc
  struct anonymous_5 *rescc;
  // rcmnum
  signed int rcmnum;
  // spacc
  struct anonymous_5 *spacc;
  // scmnum
  signed int scmnum;
  // scname
  char *scname;
  // infocb
  void (*infocb)(const char *, void *);
  // infoop
  void *infoop;
  // dfdb
  struct anonymous_1 *dfdb;
  // wildmax
  signed int wildmax;
  // metacc
  struct anonymous_5 *metacc;
  // flsflag
  signed int flsflag;
  // intflag
  signed int intflag;
};

struct anonymous_16
{
  // name
  char *name;
  // nsiz
  signed int nsiz;
  // nlist
  struct anonymous_6 *nlist;
  // oper
  char *oper;
  // val
  char *val;
  // vsiz
  signed int vsiz;
  // cop
  const char *cop;
  // sign
  signed int sign;
  // sval
  char *sval;
  // ssiz
  signed int ssiz;
  // regex
  void *regex;
  // num
  signed long int num;
};

struct anonymous_4
{
  // depot
  struct anonymous_1 *depot;
  // cmp
  signed int (*cmp)(const char *, signed int, const char *, signed int);
  // wmode
  signed int wmode;
  // cmode
  signed int cmode;
  // root
  signed int root;
  // last
  signed int last;
  // lnum
  signed int lnum;
  // nnum
  signed int nnum;
  // rnum
  signed int rnum;
  // leafc
  struct anonymous_5 *leafc;
  // nodec
  struct anonymous_5 *nodec;
  // hist
  signed int hist[64l];
  // hnum
  signed int hnum;
  // hleaf
  signed int hleaf;
  // lleaf
  signed int lleaf;
  // curleaf
  signed int curleaf;
  // curknum
  signed int curknum;
  // curvnum
  signed int curvnum;
  // leafrecmax
  signed int leafrecmax;
  // nodeidxmax
  signed int nodeidxmax;
  // leafcnum
  signed int leafcnum;
  // nodecnum
  signed int nodecnum;
  // avglsiz
  signed int avglsiz;
  // avgnsiz
  signed int avgnsiz;
  // tran
  signed int tran;
  // rbroot
  signed int rbroot;
  // rblast
  signed int rblast;
  // rblnum
  signed int rblnum;
  // rbnnum
  signed int rbnnum;
  // rbrnum
  signed int rbrnum;
};

struct anonymous_2
{
  // name
  char *name;
  // omode
  signed int omode;
  // dbs
  struct anonymous_4 *dbs[256l];
  // dnum
  signed int dnum;
  // cdb
  struct anonymous_4 *cdb;
};

struct anonymous_3
{
  // name
  char *name;
  // wmode
  signed int wmode;
  // inode
  signed int inode;
  // attr
  struct anonymous_1 *attr;
  // depots
  struct anonymous_1 **depots;
  // dnum
  signed int dnum;
  // inum
  signed int inum;
  // lrnum
  signed int lrnum;
};

struct anonymous_1
{
  // name
  char *name;
  // wmode
  signed int wmode;
  // inode
  signed int inode;
  // mtime
  signed long int mtime;
  // fd
  signed int fd;
  // fsiz
  signed int fsiz;
  // map
  char *map;
  // msiz
  signed int msiz;
  // buckets
  signed int *buckets;
  // bnum
  signed int bnum;
  // rnum
  signed int rnum;
  // fatal
  signed int fatal;
  // ioff
  signed int ioff;
  // fbpool
  signed int *fbpool;
  // fbpsiz
  signed int fbpsiz;
  // fbpinc
  signed int fbpinc;
  // align
  signed int align;
};

struct anonymous_15
{
  // phrase
  char *phrase;
  // gstep
  signed int gstep;
  // tfidf
  signed int tfidf;
  // pmode
  signed int pmode;
  // cbxpn
  void (*cbxpn)(const char *, struct anonymous_6 *);
  // attrs
  struct anonymous_6 *attrs;
  // order
  char *order;
  // max
  signed int max;
  // skip
  signed int skip;
  // auxmin
  signed int auxmin;
  // auxwords
  struct anonymous_5 *auxwords;
  // scfb
  signed int scfb;
  // scores
  signed int *scores;
  // snum
  signed int snum;
  // nscores
  const signed int *nscores;
  // nsnum
  signed int nsnum;
  // opts
  signed int opts;
  // ecllim
  double ecllim;
  // shadows
  struct anonymous_5 *shadows;
  // distinct
  char *distinct;
  // mask
  signed int mask;
};

struct anonymous_24
{
  // url
  char *url;
  // pxhost
  char *pxhost;
  // pxport
  signed int pxport;
  // timeout
  signed int timeout;
  // auth
  char *auth;
  // name
  char *name;
  // label
  char *label;
  // dnum
  signed int dnum;
  // wnum
  signed int wnum;
  // size
  double size;
  // admins
  struct anonymous_6 *admins;
  // users
  struct anonymous_6 *users;
  // links
  struct anonymous_6 *links;
  // wwidth
  signed int wwidth;
  // hwidth
  signed int hwidth;
  // awidth
  signed int awidth;
  // ilist
  struct anonymous_6 *ilist;
  // iprev
  char *iprev;
  // status
  signed int status;
  // heads
  struct anonymous_5 *heads;
};

struct anonymous_6
{
  // array
  struct anonymous_28 *array;
  // anum
  signed int anum;
  // start
  signed int start;
  // num
  signed int num;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_11
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous_12
{
  // db
  struct anonymous_0 *db;
  // path
  char *path;
  // mutex
  union anonymous_11 mutex;
};

struct anonymous_17
{
  // docs
  struct _ESTRESDOC *docs;
  // top
  signed int top;
  // max
  signed int max;
  // dnum
  signed int dnum;
  // survivors
  struct _ESTRESDOC **survivors;
  // snum
  signed int snum;
  // hints
  struct anonymous_5 *hints;
  // mdate
  signed long int mdate;
};

struct anonymous_44
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_7
{
  // db
  void *db;
  // type
  signed int type;
};

struct anonymous_42
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous
{
  // key
  const char *key;
  // score
  signed int score;
};

struct anonymous_31
{
  // word
  const char *word;
  // wsiz
  signed int wsiz;
  // pt
  signed int pt;
};

struct anonymous_18
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous_25
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_21
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous_22
{
  // __cancel_jmp_buf
  struct anonymous_21 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous_19
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_27
{
  // alive
  signed int alive;
  // cond
  union anonymous_20 *cond;
  // url
  const char *url;
  // pxhost
  const char *pxhost;
  // pxport
  signed int pxport;
  // limsize
  signed int limsize;
  // auth
  const char *auth;
  // reqheads
  const struct anonymous_6 *reqheads;
  // reqbody
  const char *reqbody;
  // rbsiz
  signed int rbsiz;
  // rescodep
  signed int *rescodep;
  // resheads
  struct anonymous_5 *resheads;
  // resbody
  struct anonymous_9 *resbody;
};

struct anonymous_32
{
  // db
  signed int db;
  // id
  signed int id;
  // score
  signed int score;
  // value
  char *value;
};

struct anonymous_29
{
  // id
  signed int id;
  // ims
  signed int ims;
  // pb
  signed int pb;
  // qb
  signed int qb;
  // targets
  struct anonymous_6 *targets;
  // alive
  signed int alive;
};

struct anonymous_8
{
  // id
  signed int id;
  // score
  signed int score;
  // value
  char *value;
};

struct anonymous_14
{
  // id
  signed int id;
  // attrs
  struct anonymous_5 *attrs;
  // dtexts
  struct anonymous_6 *dtexts;
  // kwords
  struct anonymous_5 *kwords;
};

struct anonymous_10
{
  // quot
  signed int quot;
  // rem
  signed int rem;
};

struct anonymous_37
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous_38
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_41
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_40
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_39
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_43
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_33
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_38 _kill;
  // _timer
  struct anonymous_39 _timer;
  // _rt
  struct anonymous_40 _rt;
  // _sigchld
  struct anonymous_41 _sigchld;
  // _sigfault
  struct anonymous_42 _sigfault;
  // _sigpoll
  struct anonymous_43 _sigpoll;
  // _sigsys
  struct anonymous_44 _sigsys;
};

struct anonymous_34
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_33 _sifields;
};

union anonymous_35
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_34 *, void *);
};

union anonymous_23
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_13
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_20
{
  // __data
  struct anonymous_19 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous_26
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_45
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _CBMAPDATUM
{
  // ksiz
  signed int ksiz;
  // vsiz
  signed int vsiz;
  // hash
  signed int hash;
  // left
  struct _CBMAPDATUM *left;
  // right
  struct _CBMAPDATUM *right;
  // prev
  struct _CBMAPDATUM *prev;
  // next
  struct _CBMAPDATUM *next;
};

struct _ESTRESDOC
{
  // uri
  const char *uri;
  // attrs
  struct anonymous_5 *attrs;
  // snippet
  char *snippet;
  // kwords
  struct anonymous_5 *kwords;
  // similarity
  double similarity;
  // children
  struct _ESTRESDOC **children;
  // cnum
  signed int cnum;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous_25 __saved_mask;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct in6_addr
{
  // __in6_u
  union anonymous_23 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct internal_state
{
  // dummy
  signed int dummy;
};

struct linger
{
  // l_onoff
  signed int l_onoff;
  // l_linger
  signed int l_linger;
};

struct md5_state_s
{
  // count
  unsigned int count[2l];
  // abcd
  unsigned int abcd[4l];
  // buf
  unsigned char buf[64l];
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct re_pattern_buffer
{
  // buffer
  unsigned char *buffer;
  // allocated
  unsigned long int allocated;
  // used
  unsigned long int used;
  // syntax
  unsigned long int syntax;
  // fastmap
  char *fastmap;
  // translate
  unsigned char *translate;
  // re_nsub
  unsigned long int re_nsub;
  // can_be_null
  unsigned int can_be_null : 1;
  // regs_allocated
  unsigned int regs_allocated : 2;
  // fastmap_accurate
  unsigned int fastmap_accurate : 1;
  // no_sub
  unsigned int no_sub : 1;
  // not_bol
  unsigned int not_bol : 1;
  // not_eol
  unsigned int not_eol : 1;
  // newline_anchor
  unsigned int newline_anchor : 1;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_35 __sigaction_handler;
  // sa_mask
  struct anonymous_25 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct utimbuf
{
  // actime
  signed long int actime;
  // modtime
  signed long int modtime;
};

struct z_stream_s
{
  // next_in
  unsigned char *next_in;
  // avail_in
  unsigned int avail_in;
  // total_in
  unsigned long int total_in;
  // next_out
  unsigned char *next_out;
  // avail_out
  unsigned int avail_out;
  // total_out
  unsigned long int total_out;
  // msg
  char *msg;
  // state
  struct internal_state *state;
  // zalloc
  void * (*zalloc)(void *, unsigned int, unsigned int);
  // zfree
  void (*zfree)(void *, void *);
  // opaque
  void *opaque;
  // data_type
  signed int data_type;
  // adler
  unsigned long int adler;
  // reserved
  unsigned long int reserved;
};


// VL_CMPLEX
// file /usr/include/qdbm/villa.h line 80
extern signed int (*VL_CMPLEX)(const char *, signed int, const char *, signed int);
// dpdbgfd
// file /usr/include/qdbm/depot.h line 439
extern signed int dpdbgfd;
// dpisreentrant
// file /usr/include/qdbm/depot.h line 443
extern const signed int dpisreentrant;
// est_global_db_names
// file estmtdb.c line 39
struct anonymous_5 *est_global_db_names = (struct anonymous_5 *)(void *)0;
// est_global_mutex
// file estmtdb.c line 38
union anonymous_11 est_global_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// est_host_addrs
// file estnode.c line 81
struct anonymous_5 *est_host_addrs = (struct anonymous_5 *)(void *)0;
// est_host_addrs_mutex
// file estnode.c line 83
union anonymous_11 est_host_addrs_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// est_host_attrs_cnt
// file estnode.c line 82
signed int est_host_attrs_cnt = 0;
// est_inodes
// file estraier.c line 894
struct anonymous_5 *est_inodes = (struct anonymous_5 *)(void *)0;
// est_random_ifp
// file estraier.c line 3368
struct _IO_FILE *est_random_ifp = (struct _IO_FILE *)(void *)0;
// est_signal_handlers
// file estraier.c line 3372
void (*est_signal_handlers[64l])(signed int);
// est_version
// file estraier.c line 407
const char *est_version = "1.4.13";
// g_progname
// file estload.c line 45
const char *g_progname;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;

// est_accept_conn
// file estnode.c line 1406
signed int est_accept_conn(signed int sock, char *abuf, signed int *pp)
{
  struct sockaddr_in address;
  unsigned int socklen;
  signed int clsock;
  socklen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  clsock=accept(sock, (struct sockaddr *)&address, &socklen);
  char *return_value_inet_ntoa_1;
  unsigned short int return_value_ntohs_2;
  if(clsock >= 0)
  {
    if(!(abuf == ((char *)NULL)))
    {
      return_value_inet_ntoa_1=inet_ntoa(address.sin_addr);
      sprintf(abuf, "%s", return_value_inet_ntoa_1);
    }

    if(!(pp == ((signed int *)NULL)))
    {
      return_value_ntohs_2=ntohs(address.sin_port);
      *pp = (signed int)return_value_ntohs_2;
    }

    return clsock;
  }

  signed int *return_value___errno_location_3;
  return_value___errno_location_3=__errno_location();
  _Bool tmp_if_expr_5;
  signed int *return_value___errno_location_4;
  if(*return_value___errno_location_3 == 4)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value___errno_location_4=__errno_location();
    tmp_if_expr_5 = *return_value___errno_location_4 == 11 ? (_Bool)1 : (_Bool)0;
  }
  return tmp_if_expr_5 ? 0 : -1;
}

// est_aidx_attr_narrow
// file estraier.c line 7563
static signed int est_aidx_attr_narrow(struct anonymous_4 *db, const struct anonymous_6 *pdocs, const char *cop, signed int sign, const char *oval, signed int osiz, const char *sval, signed int ssiz, const void *regex, signed int onum, struct anonymous_8 *scores, signed int snum)
{
  struct anonymous_9 *abuf;
  struct anonymous_6 *tokens;
  const char *kbuf;
  char numbuf[32l];
  char *tmp;
  char *wp;
  signed int i;
  signed int j;
  signed int ksiz;
  signed int len;
  signed int esc;
  signed int jmp;
  signed int id;
  signed int nnum;
  signed int *ary;
  signed int anum;
  signed long int lower;
  signed long int upper;
  do
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_9) /*16ul*/ );
    abuf = (struct anonymous_9 *)return_value_malloc_1;
    if(!(abuf == ((struct anonymous_9 *)NULL)))
      abuf;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)12);
    abuf->dptr = (char *)return_value_malloc_2;
    if(!(abuf->dptr == ((char *)NULL)))
      abuf->dptr;

    else
      cbmyfatal("out of memory");
    abuf->dptr[(signed long int)0] = (char)0;
    abuf->dsize = 0;
    abuf->asize = 12;
  }
  while((_Bool)0);
  signed int return_value_strcmp_3;
  _Bool tmp_if_expr_7;
  char *tmp_post_6;
  signed long int return_value_cbstrmktime_8;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_13;
  signed long int return_value_cbstrmktime_14;
  signed long int return_value_cbstrmktime_16;
  if(cop == "STROREQ" && sval == ((const char *)NULL) && !(sign == 0))
  {
    tokens=cbsplit(oval, osiz, " ,");
    cblistsort(tokens);
    i = 0;
    for( ; !(i >= tokens->num); i = i + 1)
    {
      osiz = (tokens->array + (signed long int)(tokens->start + i))->dsize;
      oval = (const char *)(tokens->array + (signed long int)(tokens->start + i))->dptr;
      if(osiz >= 1)
      {
        vlcurjump(db, oval, osiz, 0);
        do
        {
          kbuf=vlcurkeycache(db, &ksiz);
          if(kbuf == ((const char *)NULL))
            break;

          return_value_strcmp_3=strcmp(kbuf, oval);
          if(!(return_value_strcmp_3 == 0))
            break;

          do
          {
            if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
            {
              abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
              void *return_value_realloc_4;
              return_value_realloc_4=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
              abuf->dptr = (char *)return_value_realloc_4;
              if(!(abuf->dptr == ((char *)NULL)))
                abuf->dptr;

              else
                cbmyfatal("out of memory");
            }

            memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
            abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
            abuf->dptr[(signed long int)abuf->dsize] = (char)0;
          }
          while((_Bool)0);
          vlcurnext(db);
        }
        while((_Bool)1);
      }

    }
    do
    {
      signed int _CB_i;
      signed int _CB_end = tokens->start + tokens->num;
      _CB_i = tokens->start;
      for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
        free((void *)(tokens->array + (signed long int)_CB_i)->dptr);
      free((void *)tokens->array);
      free((void *)tokens);
    }
    while((_Bool)0);
  }

  else
    if(cop == "NUMBT" && sval == ((const char *)NULL) && !(sign == 0))
    {
      do
      {
        void *return_value_malloc_5;
        return_value_malloc_5=malloc((unsigned long int)(osiz + 1));
        tmp = (char *)return_value_malloc_5;
        if(!(tmp == ((char *)NULL)))
          tmp;

        else
          cbmyfatal("out of memory");
        memcpy((void *)tmp, (const void *)oval, (unsigned long int)osiz);
        tmp[(signed long int)osiz] = (char)0;
      }
      while((_Bool)0);
      wp=strchr(tmp, 32);
      if(!(wp == ((char *)NULL)))
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        wp=strchr(tmp, 9);
        tmp_if_expr_7 = wp != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_7)
      {
        tmp_post_6 = wp;
        wp = wp + 1l;
        *tmp_post_6 = (char)0;
        for( ; (_Bool)1; wp = wp + 1l)
          if(!((signed int)*wp == 32))
          {
            if(!((signed int)*wp == 9))
              goto __CPROVER_DUMP_L25;

          }


      __CPROVER_DUMP_L25:
        ;
        lower=cbstrmktime(tmp);
        upper=cbstrmktime(wp);
      }

      else
      {
        lower=cbstrmktime(tmp);
        upper = (signed long int)0x7fffffff;
      }
      len=sprintf(numbuf, "%.0f", (double)lower);
      vlcurjump(db, numbuf, len, 0);
      do
      {
        kbuf=vlcurkeycache(db, &ksiz);
        if(kbuf == ((const char *)NULL))
          break;

        return_value_cbstrmktime_8=cbstrmktime(kbuf);
        if(!(upper >= return_value_cbstrmktime_8))
          break;

        do
        {
          if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
          {
            abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
            void *return_value_realloc_9;
            return_value_realloc_9=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
            abuf->dptr = (char *)return_value_realloc_9;
            if(!(abuf->dptr == ((char *)NULL)))
              abuf->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
          abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
          abuf->dptr[(signed long int)abuf->dsize] = (char)0;
        }
        while((_Bool)0);
        vlcurnext(db);
      }
      while((_Bool)1);
      free((void *)tmp);
    }

    else
      if(sign == 0 || !(sval == ((const char *)NULL)))
      {
        esc = 0x7fffffff;
        jmp = 0x7fffffff;
        if(osiz >= 1 && !(sign == 0) && (cop == "STRBW" || cop == "STREQ"))
        {
          if((signed int)*sval >= 1)
            tmp_if_expr_10 = (signed int)*sval < 0x7f ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_10 = (_Bool)0;
          if(tmp_if_expr_10)
          {
            numbuf[(signed long int)0] = *sval;
            numbuf[(signed long int)1] = (char)0;
            esc = (signed int)*((unsigned char *)sval);
            if((signed int)*sval >= 97)
            {
              if(!((signed int)*sval >= 123))
              {
                numbuf[(signed long int)0] = numbuf[(signed long int)0] - (char)(97 - 65);
                jmp = ((signed int)*sval - 97) + 65;
              }

            }

            vlcurjump(db, numbuf, 1, 0);
          }

          else
            if((signed int)*((unsigned char *)sval) >= 0xc0)
            {
              numbuf[(signed long int)0] = *sval;
              numbuf[(signed long int)1] = (char)0;
              esc = (signed int)*((unsigned char *)sval);
              vlcurjump(db, numbuf, 1, 0);
            }

            else
              vlcurfirst(db);
        }

        else
          vlcurfirst(db);
        do
        {
          kbuf=vlcurkeycache(db, &ksiz);
          if(kbuf == ((const char *)NULL))
            break;

          signed int return_value_est_match_attr_12;
          return_value_est_match_attr_12=est_match_attr(kbuf, (signed int)(((unsigned long int)ksiz - sizeof(signed int) /*4ul*/ ) - (unsigned long int)1), cop, sign, oval, osiz, sval, ssiz, regex, onum);
          if(!(return_value_est_match_attr_12 == 0))
            do
            {
              if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
              {
                abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
                void *return_value_realloc_11;
                return_value_realloc_11=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
                abuf->dptr = (char *)return_value_realloc_11;
                if(!(abuf->dptr == ((char *)NULL)))
                  abuf->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
              abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
              abuf->dptr[(signed long int)abuf->dsize] = (char)0;
            }
            while((_Bool)0);

          if(!(jmp >= (signed int)*((unsigned char *)kbuf)))
            tmp_if_expr_13 = (signed int)*((unsigned char *)kbuf) < (signed int)*((unsigned char *)sval) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_13 = (_Bool)0;
          if(tmp_if_expr_13)
          {
            numbuf[(signed long int)0] = *sval;
            numbuf[(signed long int)1] = (char)0;
            vlcurjump(db, numbuf, 1, 0);
            jmp = 0x7fffffff;
          }

          else
            if(!(esc >= (signed int)*((unsigned char *)kbuf)))
              break;

            else
              vlcurnext(db);
        }
        while((_Bool)1);
      }

      else
      {
        if(cop == "NUMEQ" || cop == "NUMGE" || cop == "NUMGT" || cop == "STRBW" || cop == "STREQ")
        {
          vlcurjump(db, oval, osiz, 0);
          if(cop == "NUMGT")
            do
            {
              kbuf=vlcurkeycache(db, (signed int *)(void *)0);
              if(kbuf == ((const char *)NULL))
                break;

              return_value_cbstrmktime_14=cbstrmktime(kbuf);
              if(!((signed long int)onum >= return_value_cbstrmktime_14))
                break;

              vlcurnext(db);
            }
            while((_Bool)1);

        }

        else
          if(cop == "NUMLE" || cop == "NUMLT")
          {
            signed long int return_value_cbstrmktime_15;
            return_value_cbstrmktime_15=cbstrmktime(oval);
            len=sprintf(numbuf, "%.0f", (double)return_value_cbstrmktime_15 + (double)1);
            vlcurjump(db, numbuf, len, 1);
            if(cop == "NUMLT")
              do
              {
                kbuf=vlcurkeycache(db, (signed int *)(void *)0);
                if(kbuf == ((const char *)NULL))
                  break;

                return_value_cbstrmktime_16=cbstrmktime(kbuf);
                if(!(return_value_cbstrmktime_16 >= (signed long int)onum))
                  break;

                vlcurprev(db);
              }
              while((_Bool)1);

          }

          else
            vlcurfirst(db);
        do
        {
          kbuf=vlcurkeycache(db, &ksiz);
          if(kbuf == ((const char *)NULL))
            break;

          signed int return_value_est_match_attr_18;
          return_value_est_match_attr_18=est_match_attr(kbuf, (signed int)(((unsigned long int)ksiz - sizeof(signed int) /*4ul*/ ) - (unsigned long int)1), cop, 1, oval, osiz, sval, ssiz, regex, onum);
          if(!(return_value_est_match_attr_18 == 0))
            do
            {
              if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
              {
                abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
                void *return_value_realloc_17;
                return_value_realloc_17=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
                abuf->dptr = (char *)return_value_realloc_17;
                if(!(abuf->dptr == ((char *)NULL)))
                  abuf->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
              abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
              abuf->dptr[(signed long int)abuf->dsize] = (char)0;
            }
            while((_Bool)0);

          else
            if(cop == "NUMEQ" || cop == "STRBW" || cop == "STREQ")
              break;

          if(cop == "NUMLE" || cop == "NUMLT")
            vlcurprev(db);

          else
            vlcurnext(db);
        }
        while((_Bool)1);
      }
  i = 0;
  for( ; !(i >= pdocs->num); i = i + 1)
  {
    id = 2000000001 + i;
    do
    {
      if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
      {
        abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
        void *return_value_realloc_19;
        return_value_realloc_19=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
        abuf->dptr = (char *)return_value_realloc_19;
        if(!(abuf->dptr == ((char *)NULL)))
          abuf->dptr;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)&id, sizeof(signed int) /*4ul*/ );
      abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
      abuf->dptr[(signed long int)abuf->dsize] = (char)0;
    }
    while((_Bool)0);
  }
  nnum = 0;
  ary = (signed int *)(const char *)abuf->dptr;
  anum = (signed int)((unsigned long int)(signed int)abuf->dsize / sizeof(signed int) /*4ul*/ );
  qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_id_asc);
  qsort((void *)ary, (unsigned long int)anum, sizeof(signed int) /*4ul*/ , est_int_compare);
  i = 0;
  j = 0;
  for( ; !(i >= snum); i = i + 1)
  {
    for( ; !(j >= anum); j = j + 1)
      if(ary[(signed long int)j] >= (scores + (signed long int)i)->id)
        break;

    if(!(j >= anum))
    {
      if((scores + (signed long int)i)->id == ary[(signed long int)j])
      {
        (scores + (signed long int)nnum)->id = (scores + (signed long int)i)->id;
        (scores + (signed long int)nnum)->score = (scores + (signed long int)i)->score;
        nnum = nnum + 1;
      }

    }

  }
  do
  {
    free((void *)abuf->dptr);
    free((void *)abuf);
  }
  while((_Bool)0);
  return nnum;
}

// est_aidx_attr_out
// file estraier.c line 7534
static signed int est_aidx_attr_out(struct anonymous_4 *db, signed int id, const char *vbuf, signed int vsiz)
{
  char *tbuf;
  signed int err;
  signed int tsiz;
  err = 0;
  tsiz = (signed int)((unsigned long int)vsiz + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)tsiz);
  tbuf = (char *)return_value_malloc_1;
  if(!(tbuf == ((char *)NULL)))
    tbuf;

  else
    cbmyfatal("out of memory");
  memcpy((void *)tbuf, (const void *)vbuf, (unsigned long int)(vsiz + 1));
  memcpy((void *)(tbuf + (signed long int)vsiz + (signed long int)1), (const void *)&id, sizeof(signed int) /*4ul*/ );
  signed int return_value_vlout_2;
  return_value_vlout_2=vlout(db, tbuf, tsiz);
  if(return_value_vlout_2 == 0)
    err = 1;

  free((void *)tbuf);
  return err != 0 ? 0 : 1;
}

// est_aidx_attr_put
// file estraier.c line 7513
static signed int est_aidx_attr_put(struct anonymous_4 *db, signed int id, const char *vbuf, signed int vsiz)
{
  char *tbuf;
  signed int err;
  signed int tsiz;
  err = 0;
  tsiz = (signed int)((unsigned long int)vsiz + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)tsiz);
  tbuf = (char *)return_value_malloc_1;
  if(!(tbuf == ((char *)NULL)))
    tbuf;

  else
    cbmyfatal("out of memory");
  memcpy((void *)tbuf, (const void *)vbuf, (unsigned long int)(vsiz + 1));
  memcpy((void *)(tbuf + (signed long int)vsiz + (signed long int)1), (const void *)&id, sizeof(signed int) /*4ul*/ );
  signed int return_value_vlput_2;
  return_value_vlput_2=vlput(db, tbuf, tsiz, "", 0, 1);
  if(return_value_vlput_2 == 0)
    err = 1;

  free((void *)tbuf);
  return err != 0 ? 0 : 1;
}

// est_aidx_numcmp
// file estraier.c line 7500
static signed int est_aidx_numcmp(const char *aptr, signed int asiz, const char *bptr, signed int bsiz)
{
  signed int rv;
  signed long int return_value_cbstrmktime_1;
  return_value_cbstrmktime_1=cbstrmktime(aptr);
  signed long int return_value_cbstrmktime_2;
  return_value_cbstrmktime_2=cbstrmktime(bptr);
  rv = (signed int)(return_value_cbstrmktime_1 - return_value_cbstrmktime_2);
  if(!(rv == 0))
    return rv;

  else
  {
    signed int return_value;
    return_value=VL_CMPLEX(aptr, asiz, bptr, bsiz);
    return return_value;
  }
}

// est_aidx_seq_get
// file estraier.c line 7439
static char * est_aidx_seq_get(struct anonymous_1 *db, signed int id, signed int *sp)
{
  char *return_value_dpget_1;
  return_value_dpget_1=dpget(db, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0, -1, sp);
  return return_value_dpget_1;
}

// est_aidx_seq_narrow
// file estraier.c line 7461
static signed int est_aidx_seq_narrow(struct anonymous_1 *db, const struct anonymous_6 *pdocs, const char *cop, signed int sign, const char *oval, signed int osiz, const char *sval, signed int ssiz, const void *regex, signed int onum, struct anonymous_8 *scores, signed int snum, signed int limit, signed int *restp)
{
  char vbuf[8192l];
  signed int i;
  signed int nnum;
  signed int vsiz;
  nnum = 0;
  i = 0;
  for( ; !(i >= snum); i = i + 1)
  {
    if(nnum >= limit)
    {
      *restp = snum - i;
      break;
    }

    if((scores + (signed long int)i)->id >= 2000000001)
    {
      (scores + (signed long int)nnum)->id = (scores + (signed long int)i)->id;
      (scores + (signed long int)nnum)->score = (scores + (signed long int)i)->score;
      nnum = nnum + 1;
    }

    else
    {
      vsiz=dpgetwb(db, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , 0, 8192 - 1, vbuf);
      if(vsiz >= 0)
      {
        vbuf[(signed long int)vsiz] = (char)0;
        signed int return_value_est_match_attr_1;
        return_value_est_match_attr_1=est_match_attr(vbuf, vsiz, cop, sign, oval, osiz, sval, ssiz, regex, onum);
        if(!(return_value_est_match_attr_1 == 0))
        {
          (scores + (signed long int)nnum)->id = (scores + (signed long int)i)->id;
          (scores + (signed long int)nnum)->score = (scores + (signed long int)i)->score;
          nnum = nnum + 1;
        }

      }

    }
  }
  return nnum;
}

// est_aidx_seq_out
// file estraier.c line 7426
static signed int est_aidx_seq_out(struct anonymous_1 *db, signed int id)
{
  signed int err = 0;
  signed int return_value_dpout_1;
  return_value_dpout_1=dpout(db, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
  if(return_value_dpout_1 == 0)
    err = 1;

  return err != 0 ? 0 : 1;
}

// est_aidx_seq_put
// file estraier.c line 7413
static signed int est_aidx_seq_put(struct anonymous_1 *db, signed int id, const char *vbuf, signed int vsiz)
{
  signed int err = 0;
  signed int return_value_dpput_1;
  return_value_dpput_1=dpput(db, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, 1);
  if(return_value_dpput_1 == 0)
    err = 1;

  return err != 0 ? 0 : 1;
}

// est_border_str
// file estraier.c line 4042
const char * est_border_str(void)
{
  signed int t;
  signed int p;
  static char border[4096l];
  static signed int first = 1;
  if(!(first == 0))
  {
    signed long int return_value_time_1;
    return_value_time_1=time((signed long int *)(void *)0);
    double return_value_est_random_2;
    return_value_est_random_2=est_random();
    t = (signed int)((double)return_value_time_1 + return_value_est_random_2 * (double)0x7fffffff);
    signed int return_value_getpid_3;
    return_value_getpid_3=getpid();
    double return_value_est_random_4;
    return_value_est_random_4=est_random();
    p = (signed int)((double)return_value_getpid_3 + return_value_est_random_4 * (double)0x7fffffff);
    signed int return_value_dpouterhash_5;
    return_value_dpouterhash_5=dpouterhash((char *)&t, (signed int)sizeof(signed int) /*4ul*/ );
    signed int return_value_dpouterhash_6;
    return_value_dpouterhash_6=dpouterhash((char *)&p, (signed int)sizeof(signed int) /*4ul*/ );
    sprintf(border, "--------[%08X%08X]--------", return_value_dpouterhash_5, return_value_dpouterhash_6);
    first = 0;
  }

  return border;
}

// est_break_text
// file estraier.c line 3376
void est_break_text(const char *text, struct anonymous_6 *list, signed int norm, signed int tail)
{
  struct anonymous_6 *words;
  const unsigned char *word;
  const unsigned char *next;
  unsigned char *utext;
  char *tmp;
  signed int i;
  signed int j;
  signed int k;
  signed int size;
  signed int cc;
  signed int wsiz;
  signed int nsiz;
  signed int tsiz;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(text);
  char *return_value_est_uconv_in_2;
  return_value_est_uconv_in_2=est_uconv_in(text, (signed int)return_value_strlen_1, &size);
  utext = (unsigned char *)return_value_est_uconv_in_2;
  if(!(norm == 0))
    est_normalize_text(utext, size, &size);

  est_canonicalize_text(utext, size, 0);
  do
  {
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(sizeof(struct anonymous_6) /*24ul*/ );
    words = (struct anonymous_6 *)return_value_malloc_3;
    if(!(words == ((struct anonymous_6 *)NULL)))
      words;

    else
      cbmyfatal("out of memory");
    words->anum = 64;
    void *return_value_malloc_4;
    return_value_malloc_4=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)words->anum);
    words->array = (struct anonymous_28 *)return_value_malloc_4;
    if(!(words->array == ((struct anonymous_28 *)NULL)))
      words->array;

    else
      cbmyfatal("out of memory");
    words->start = 0;
    words->num = 0;
  }
  while((_Bool)0);
  i = 0;
  while(!(i >= size))
  {
    cc=est_char_category((signed int)utext[(signed long int)i] * 0x100 + (signed int)utext[(signed long int)(i + 1)]);
    j = i + 2;
    for( ; !(j >= size); j = j + 2)
    {
      signed int return_value_est_char_category_5;
      return_value_est_char_category_5=est_char_category((signed int)utext[(signed long int)j] * 0x100 + (signed int)utext[(signed long int)(j + 1)]);
      if(!(return_value_est_char_category_5 == cc))
        break;

    }
    switch(cc)
    {
      case 1:

      case 2:
      {
        do
        {
          signed int est_break_text__1__2__1__2__1___CB_index = words->start + words->num;
          if(est_break_text__1__2__1__2__1___CB_index >= words->anum)
          {
            words->anum = words->anum * 2;
            void *return_value_realloc_6;
            return_value_realloc_6=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous_28) /*16ul*/ );
            words->array = (struct anonymous_28 *)return_value_realloc_6;
            if(!(words->array == ((struct anonymous_28 *)NULL)))
              words->array;

            else
              cbmyfatal("out of memory");
          }

          void *return_value_malloc_7;
          return_value_malloc_7=malloc((unsigned long int)((j - i < 12 ? 12 : j - i) + 1));
          (words->array + (signed long int)est_break_text__1__2__1__2__1___CB_index)->dptr = (char *)return_value_malloc_7;
          if(!((words->array + (signed long int)est_break_text__1__2__1__2__1___CB_index)->dptr == ((char *)NULL)))
            (words->array + (signed long int)est_break_text__1__2__1__2__1___CB_index)->dptr;

          else
            cbmyfatal("out of memory");
          memcpy((void *)(words->array + (signed long int)est_break_text__1__2__1__2__1___CB_index)->dptr, (const void *)(char *)(utext + (signed long int)i), (unsigned long int)(j - i));
          (words->array + (signed long int)est_break_text__1__2__1__2__1___CB_index)->dptr[(signed long int)(j - i)] = (char)0;
          (words->array + (signed long int)est_break_text__1__2__1__2__1___CB_index)->dsize = j - i;
          words->num = words->num + 1;
        }
        while((_Bool)0);
        goto __CPROVER_DUMP_L31;
      }
      case 3:
      {
        k = i;
        for( ; !(k >= j); k = k + 2)
          if(j + -k >= 4)
            do
            {
              signed int est_break_text__1__2__1__2__2__1__1__1___CB_index = words->start + words->num;
              if(est_break_text__1__2__1__2__2__1__1__1___CB_index >= words->anum)
              {
                words->anum = words->anum * 2;
                void *return_value_realloc_8;
                return_value_realloc_8=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous_28) /*16ul*/ );
                words->array = (struct anonymous_28 *)return_value_realloc_8;
                if(!(words->array == ((struct anonymous_28 *)NULL)))
                  words->array;

                else
                  cbmyfatal("out of memory");
              }

              void *return_value_malloc_9;
              return_value_malloc_9=malloc((unsigned long int)((4 < 12 ? 12 : 4) + 1));
              (words->array + (signed long int)est_break_text__1__2__1__2__2__1__1__1___CB_index)->dptr = (char *)return_value_malloc_9;
              if(!((words->array + (signed long int)est_break_text__1__2__1__2__2__1__1__1___CB_index)->dptr == ((char *)NULL)))
                (words->array + (signed long int)est_break_text__1__2__1__2__2__1__1__1___CB_index)->dptr;

              else
                cbmyfatal("out of memory");
              memcpy((void *)(words->array + (signed long int)est_break_text__1__2__1__2__2__1__1__1___CB_index)->dptr, (const void *)(char *)(utext + (signed long int)k), (unsigned long int)4);
              (words->array + (signed long int)est_break_text__1__2__1__2__2__1__1__1___CB_index)->dptr[(signed long int)4] = (char)0;
              (words->array + (signed long int)est_break_text__1__2__1__2__2__1__1__1___CB_index)->dsize = 4;
              words->num = words->num + 1;
            }
            while((_Bool)0);

          else
            do
            {
              signed int est_break_text__1__2__1__2__2__1__2__1___CB_index = words->start + words->num;
              if(est_break_text__1__2__1__2__2__1__2__1___CB_index >= words->anum)
              {
                words->anum = words->anum * 2;
                void *return_value_realloc_10;
                return_value_realloc_10=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous_28) /*16ul*/ );
                words->array = (struct anonymous_28 *)return_value_realloc_10;
                if(!(words->array == ((struct anonymous_28 *)NULL)))
                  words->array;

                else
                  cbmyfatal("out of memory");
              }

              void *return_value_malloc_11;
              return_value_malloc_11=malloc((unsigned long int)((2 < 12 ? 12 : 2) + 1));
              (words->array + (signed long int)est_break_text__1__2__1__2__2__1__2__1___CB_index)->dptr = (char *)return_value_malloc_11;
              if(!((words->array + (signed long int)est_break_text__1__2__1__2__2__1__2__1___CB_index)->dptr == ((char *)NULL)))
                (words->array + (signed long int)est_break_text__1__2__1__2__2__1__2__1___CB_index)->dptr;

              else
                cbmyfatal("out of memory");
              memcpy((void *)(words->array + (signed long int)est_break_text__1__2__1__2__2__1__2__1___CB_index)->dptr, (const void *)(char *)(utext + (signed long int)k), (unsigned long int)2);
              (words->array + (signed long int)est_break_text__1__2__1__2__2__1__2__1___CB_index)->dptr[(signed long int)2] = (char)0;
              (words->array + (signed long int)est_break_text__1__2__1__2__2__1__2__1___CB_index)->dsize = 2;
              words->num = words->num + 1;
            }
            while((_Bool)0);
      }
      default:
      {

      __CPROVER_DUMP_L31:
        ;
        i = j - 2;
        i = i + 2;
      }
    }
  }
  i = 0;
  for( ; !(i >= words->num); i = i + 1)
  {
    wsiz = (words->array + (signed long int)(words->start + i))->dsize;
    word = (unsigned char *)(const char *)(words->array + (signed long int)(words->start + i))->dptr;
    signed int return_value_est_char_category_15;
    return_value_est_char_category_15=est_char_category((signed int)word[(signed long int)0] * 0x100 + (signed int)word[(signed long int)1]);
    if(return_value_est_char_category_15 == 3)
    {
      if(wsiz == 2)
      {
        if(!(i >= words->num + -1))
        {
          const char *return_value_cblistval_12;
          return_value_cblistval_12=cblistval(words, i + 1, &nsiz);
          next = (unsigned char *)return_value_cblistval_12;
          if(nsiz >= 5)
            nsiz = 4;

          signed int return_value_est_char_category_13;
          return_value_est_char_category_13=est_char_category((signed int)next[(signed long int)0] * 0x100 + (signed int)next[(signed long int)1]);
          if(return_value_est_char_category_13 == 3)
          {
            if(nsiz >= 3)
              nsiz = 2;

          }

          void *return_value_malloc_14;
          return_value_malloc_14=malloc((unsigned long int)(wsiz + nsiz + 1));
          tmp = (char *)return_value_malloc_14;
          if(!(tmp == ((char *)NULL)))
            tmp;

          else
            cbmyfatal("out of memory");
          memcpy((void *)tmp, (const void *)word, (unsigned long int)wsiz);
          memcpy((void *)(tmp + (signed long int)wsiz), (const void *)next, (unsigned long int)nsiz);
          cblistover(words, i, tmp, wsiz + nsiz);
          free((void *)tmp);
        }

      }

    }

  }
  i = 0;
  for( ; !(i >= words->num); i = i + 1)
  {
    wsiz = (words->array + (signed long int)(words->start + i))->dsize;
    word = (unsigned char *)(const char *)(words->array + (signed long int)(words->start + i))->dptr;
    if(wsiz == 2 && tail == 0)
    {
      if(i == words->num + -1)
      {
        signed int return_value_est_char_category_16;
        return_value_est_char_category_16=est_char_category((signed int)word[(signed long int)0] * 0x100 + (signed int)word[(signed long int)1]);
        if(return_value_est_char_category_16 == 3)
          goto __CPROVER_DUMP_L46;

      }

    }

    tmp=est_uconv_out((char *)word, wsiz, &tsiz);
    do
    {
      signed int _CB_index = list->start + list->num;
      if(_CB_index >= list->anum)
      {
        list->anum = list->anum * 2;
        void *return_value_realloc_17;
        return_value_realloc_17=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous_28) /*16ul*/ );
        list->array = (struct anonymous_28 *)return_value_realloc_17;
        if(!(list->array == ((struct anonymous_28 *)NULL)))
          list->array;

        else
          cbmyfatal("out of memory");
      }

      (list->array + (signed long int)_CB_index)->dptr = tmp;
      (list->array + (signed long int)_CB_index)->dsize = tsiz;
      list->num = list->num + 1;
    }
    while((_Bool)0);

  __CPROVER_DUMP_L46:
    ;
  }
  do
  {
    signed int _CB_i;
    signed int _CB_end = words->start + words->num;
    _CB_i = words->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(words->array + (signed long int)_CB_i)->dptr);
    free((void *)words->array);
    free((void *)words);
  }
  while((_Bool)0);
  free((void *)utext);
}

// est_break_text_chrcat
// file estraier.c line 3509
void est_break_text_chrcat(const char *text, struct anonymous_6 *list, signed int norm)
{
  unsigned char *utext;
  char *tmp;
  signed int i;
  signed int j;
  signed int size;
  signed int cc;
  signed int tsiz;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(text);
  char *return_value_est_uconv_in_2;
  return_value_est_uconv_in_2=est_uconv_in(text, (signed int)return_value_strlen_1, &size);
  utext = (unsigned char *)return_value_est_uconv_in_2;
  if(!(norm == 0))
    est_normalize_text(utext, size, &size);

  est_canonicalize_text(utext, size, 0);
  i = 0;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  for( ; !(i >= size); i = i + 2)
  {
    cc=est_char_category_chrcat((signed int)utext[(signed long int)i] * 0x100 + (signed int)utext[(signed long int)(i + 1)]);
    j = i + 2;
    for( ; !(j >= size); j = j + 2)
    {
      signed int return_value_est_char_category_chrcat_7;
      return_value_est_char_category_chrcat_7=est_char_category_chrcat((signed int)utext[(signed long int)j] * 0x100 + (signed int)utext[(signed long int)(j + 1)]);
      if(!(return_value_est_char_category_chrcat_7 == cc))
      {
        if(!(cc == 2))
          tmp_if_expr_5 = (_Bool)1;

        else
          tmp_if_expr_5 = (signed int)utext[(signed long int)j] != 0x00 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_5)
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = (signed int)utext[(signed long int)(j + 1)] != 0x2d ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_6)
        {
          if(!(cc == 4))
            tmp_if_expr_3 = (_Bool)1;

          else
            tmp_if_expr_3 = (signed int)utext[(signed long int)j] != 0x30 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_3)
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = (signed int)utext[(signed long int)(j + 1)] != 0xfc ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_4)
            break;

        }

      }

    }
    if(!(cc == 0))
    {
      tmp=est_uconv_out((char *)(utext + (signed long int)i), j - i, &tsiz);
      do
      {
        signed int _CB_index = list->start + list->num;
        if(_CB_index >= list->anum)
        {
          list->anum = list->anum * 2;
          void *return_value_realloc_8;
          return_value_realloc_8=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous_28) /*16ul*/ );
          list->array = (struct anonymous_28 *)return_value_realloc_8;
          if(!(list->array == ((struct anonymous_28 *)NULL)))
            list->array;

          else
            cbmyfatal("out of memory");
        }

        (list->array + (signed long int)_CB_index)->dptr = tmp;
        (list->array + (signed long int)_CB_index)->dsize = tsiz;
        list->num = list->num + 1;
      }
      while((_Bool)0);
    }

    i = j - 2;
  }
  free((void *)utext);
}

// est_break_text_perfng
// file estraier.c line 3439
void est_break_text_perfng(const char *text, struct anonymous_6 *list, signed int norm, signed int tail)
{
  struct anonymous_6 *words;
  const unsigned char *word;
  const unsigned char *next;
  unsigned char *utext;
  char *tmp;
  signed int i;
  signed int j;
  signed int k;
  signed int size;
  signed int cc;
  signed int wsiz;
  signed int nsiz;
  signed int tsiz;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(text);
  char *return_value_est_uconv_in_2;
  return_value_est_uconv_in_2=est_uconv_in(text, (signed int)return_value_strlen_1, &size);
  utext = (unsigned char *)return_value_est_uconv_in_2;
  if(!(norm == 0))
    est_normalize_text(utext, size, &size);

  est_canonicalize_text(utext, size, 0);
  do
  {
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(sizeof(struct anonymous_6) /*24ul*/ );
    words = (struct anonymous_6 *)return_value_malloc_3;
    if(!(words == ((struct anonymous_6 *)NULL)))
      words;

    else
      cbmyfatal("out of memory");
    words->anum = 64;
    void *return_value_malloc_4;
    return_value_malloc_4=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)words->anum);
    words->array = (struct anonymous_28 *)return_value_malloc_4;
    if(!(words->array == ((struct anonymous_28 *)NULL)))
      words->array;

    else
      cbmyfatal("out of memory");
    words->start = 0;
    words->num = 0;
  }
  while((_Bool)0);
  i = 0;
  for( ; !(i >= size); i = i + 2)
  {
    cc=est_char_category_perfng((signed int)utext[(signed long int)i] * 0x100 + (signed int)utext[(signed long int)(i + 1)]);
    j = i + 2;
    for( ; !(j >= size); j = j + 2)
    {
      signed int return_value_est_char_category_perfng_5;
      return_value_est_char_category_perfng_5=est_char_category_perfng((signed int)utext[(signed long int)j] * 0x100 + (signed int)utext[(signed long int)(j + 1)]);
      if(!(return_value_est_char_category_perfng_5 == cc))
        break;

    }
    if(cc == 3)
    {
      k = i;
      for( ; !(k >= j); k = k + 2)
        if(j + -k >= 4)
          do
          {
            signed int _CB_index = words->start + words->num;
            if(_CB_index >= words->anum)
            {
              words->anum = words->anum * 2;
              void *return_value_realloc_6;
              return_value_realloc_6=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous_28) /*16ul*/ );
              words->array = (struct anonymous_28 *)return_value_realloc_6;
              if(!(words->array == ((struct anonymous_28 *)NULL)))
                words->array;

              else
                cbmyfatal("out of memory");
            }

            void *return_value_malloc_7;
            return_value_malloc_7=malloc((unsigned long int)((4 < 12 ? 12 : 4) + 1));
            (words->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_7;
            if(!((words->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
              (words->array + (signed long int)_CB_index)->dptr;

            else
              cbmyfatal("out of memory");
            memcpy((void *)(words->array + (signed long int)_CB_index)->dptr, (const void *)(char *)(utext + (signed long int)k), (unsigned long int)4);
            (words->array + (signed long int)_CB_index)->dptr[(signed long int)4] = (char)0;
            (words->array + (signed long int)_CB_index)->dsize = 4;
            words->num = words->num + 1;
          }
          while((_Bool)0);

        else
          do
          {
            signed int est_break_text_perfng__1__2__1__2__1__1__2__1___CB_index = words->start + words->num;
            if(est_break_text_perfng__1__2__1__2__1__1__2__1___CB_index >= words->anum)
            {
              words->anum = words->anum * 2;
              void *return_value_realloc_8;
              return_value_realloc_8=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous_28) /*16ul*/ );
              words->array = (struct anonymous_28 *)return_value_realloc_8;
              if(!(words->array == ((struct anonymous_28 *)NULL)))
                words->array;

              else
                cbmyfatal("out of memory");
            }

            void *return_value_malloc_9;
            return_value_malloc_9=malloc((unsigned long int)((2 < 12 ? 12 : 2) + 1));
            (words->array + (signed long int)est_break_text_perfng__1__2__1__2__1__1__2__1___CB_index)->dptr = (char *)return_value_malloc_9;
            if(!((words->array + (signed long int)est_break_text_perfng__1__2__1__2__1__1__2__1___CB_index)->dptr == ((char *)NULL)))
              (words->array + (signed long int)est_break_text_perfng__1__2__1__2__1__1__2__1___CB_index)->dptr;

            else
              cbmyfatal("out of memory");
            memcpy((void *)(words->array + (signed long int)est_break_text_perfng__1__2__1__2__1__1__2__1___CB_index)->dptr, (const void *)(char *)(utext + (signed long int)k), (unsigned long int)2);
            (words->array + (signed long int)est_break_text_perfng__1__2__1__2__1__1__2__1___CB_index)->dptr[(signed long int)2] = (char)0;
            (words->array + (signed long int)est_break_text_perfng__1__2__1__2__1__1__2__1___CB_index)->dsize = 2;
            words->num = words->num + 1;
          }
          while((_Bool)0);
    }

    i = j - 2;
  }
  i = 0;
  for( ; !(i >= words->num); i = i + 1)
  {
    wsiz = (words->array + (signed long int)(words->start + i))->dsize;
    word = (unsigned char *)(const char *)(words->array + (signed long int)(words->start + i))->dptr;
    signed int return_value_est_char_category_perfng_13;
    return_value_est_char_category_perfng_13=est_char_category_perfng((signed int)word[(signed long int)0] * 0x100 + (signed int)word[(signed long int)1]);
    if(return_value_est_char_category_perfng_13 == 3)
    {
      if(wsiz == 2)
      {
        if(!(i >= words->num + -1))
        {
          const char *return_value_cblistval_10;
          return_value_cblistval_10=cblistval(words, i + 1, &nsiz);
          next = (unsigned char *)return_value_cblistval_10;
          if(nsiz >= 5)
            nsiz = 4;

          signed int return_value_est_char_category_perfng_11;
          return_value_est_char_category_perfng_11=est_char_category_perfng((signed int)next[(signed long int)0] * 0x100 + (signed int)next[(signed long int)1]);
          if(return_value_est_char_category_perfng_11 == 3)
          {
            if(nsiz >= 3)
              nsiz = 2;

          }

          void *return_value_malloc_12;
          return_value_malloc_12=malloc((unsigned long int)(wsiz + nsiz + 1));
          tmp = (char *)return_value_malloc_12;
          if(!(tmp == ((char *)NULL)))
            tmp;

          else
            cbmyfatal("out of memory");
          memcpy((void *)tmp, (const void *)word, (unsigned long int)wsiz);
          memcpy((void *)(tmp + (signed long int)wsiz), (const void *)next, (unsigned long int)nsiz);
          cblistover(words, i, tmp, wsiz + nsiz);
          free((void *)tmp);
        }

      }

    }

  }
  i = 0;
  for( ; !(i >= words->num); i = i + 1)
  {
    wsiz = (words->array + (signed long int)(words->start + i))->dsize;
    word = (unsigned char *)(const char *)(words->array + (signed long int)(words->start + i))->dptr;
    if(wsiz == 2 && tail == 0)
    {
      if(i == words->num + -1)
      {
        signed int return_value_est_char_category_perfng_14;
        return_value_est_char_category_perfng_14=est_char_category_perfng((signed int)word[(signed long int)0] * 0x100 + (signed int)word[(signed long int)1]);
        if(return_value_est_char_category_perfng_14 == 3)
          goto __CPROVER_DUMP_L40;

      }

    }

    tmp=est_uconv_out((char *)word, wsiz, &tsiz);
    do
    {
      signed int est_break_text_perfng__1__4__1__2___CB_index = list->start + list->num;
      if(est_break_text_perfng__1__4__1__2___CB_index >= list->anum)
      {
        list->anum = list->anum * 2;
        void *return_value_realloc_15;
        return_value_realloc_15=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous_28) /*16ul*/ );
        list->array = (struct anonymous_28 *)return_value_realloc_15;
        if(!(list->array == ((struct anonymous_28 *)NULL)))
          list->array;

        else
          cbmyfatal("out of memory");
      }

      (list->array + (signed long int)est_break_text_perfng__1__4__1__2___CB_index)->dptr = tmp;
      (list->array + (signed long int)est_break_text_perfng__1__4__1__2___CB_index)->dsize = tsiz;
      list->num = list->num + 1;
    }
    while((_Bool)0);

  __CPROVER_DUMP_L40:
    ;
  }
  do
  {
    signed int _CB_i;
    signed int _CB_end = words->start + words->num;
    _CB_i = words->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(words->array + (signed long int)_CB_i)->dptr);
    free((void *)words->array);
    free((void *)words);
  }
  while((_Bool)0);
  free((void *)utext);
}

// est_bzdecode
// file estraier.c line 3990
char * est_bzdecode(const char *ptr, signed int size, signed int *sp)
{
  if(!(sp == ((signed int *)NULL)))
    *sp = size;

  char *return_value_cbmemdup_1;
  return_value_cbmemdup_1=cbmemdup(ptr, size);
  return return_value_cbmemdup_1;
}

// est_bzencode
// file estraier.c line 3936
char * est_bzencode(const char *ptr, signed int size, signed int *sp)
{
  unsigned long int return_value_strlen_1;
  if(!(size >= 0))
  {
    return_value_strlen_1=strlen(ptr);
    size = (signed int)return_value_strlen_1;
  }

  *sp = size;
  char *return_value_cbmemdup_2;
  return_value_cbmemdup_2=cbmemdup(ptr, size);
  return return_value_cbmemdup_2;
}

// est_canonicalize_text
// file estraier.c line 6242
static void est_canonicalize_text(unsigned char *utext, signed int size, signed int funcspc)
{
  signed int i = 0;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_15;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_21;
  _Bool tmp_if_expr_19;
  _Bool tmp_if_expr_20;
  _Bool tmp_if_expr_39;
  _Bool tmp_if_expr_38;
  _Bool tmp_if_expr_37;
  _Bool tmp_if_expr_36;
  _Bool tmp_if_expr_35;
  _Bool tmp_if_expr_34;
  _Bool tmp_if_expr_33;
  _Bool tmp_if_expr_32;
  _Bool tmp_if_expr_31;
  _Bool tmp_if_expr_30;
  _Bool tmp_if_expr_29;
  _Bool tmp_if_expr_28;
  _Bool tmp_if_expr_26;
  _Bool tmp_if_expr_27;
  _Bool tmp_if_expr_25;
  _Bool tmp_if_expr_24;
  _Bool tmp_if_expr_23;
  _Bool tmp_if_expr_22;
  _Bool tmp_if_expr_40;
  for( ; !(i >= size); i = i + 2)
    if((signed int)utext[(signed long int)i] == 0x0)
    {
      if(!((signed int)utext[(signed long int)(1 + i)] >= 32))
      {
        if(funcspc == 0)
          utext[(signed long int)(i + 1)] = (unsigned char)32;

      }

      else
      {
        if((signed int)utext[(signed long int)(1 + i)] >= 65)
          tmp_if_expr_11 = (signed int)utext[(signed long int)(i + 1)] <= 90 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_11 = (_Bool)0;
        if(tmp_if_expr_11)
          utext[(signed long int)(i + 1)] = utext[(signed long int)(i + 1)] + (unsigned char)(97 - 65);

        else
          if((signed int)utext[(signed long int)(1 + i)] >= 0xc0)
          {
            if((signed int)utext[(signed long int)(1 + i)] >= 0xc0)
              tmp_if_expr_1 = (signed int)utext[(signed long int)(i + 1)] <= 0xd6 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_1 = (_Bool)0;
            if(tmp_if_expr_1)
              tmp_if_expr_3 = (_Bool)1;

            else
            {
              if((signed int)utext[(signed long int)(1 + i)] >= 0xd8)
                tmp_if_expr_2 = (signed int)utext[(signed long int)(i + 1)] <= 0xde ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_2 = (_Bool)0;
              tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_3)
              utext[(signed long int)(i + 1)] = utext[(signed long int)(i + 1)] + (unsigned char)0x20;

            if((signed int)utext[(signed long int)(1 + i)] >= 0xe0)
              tmp_if_expr_10 = (signed int)utext[(signed long int)(i + 1)] <= 0xe5 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_10 = (_Bool)0;
            if(tmp_if_expr_10)
              utext[(signed long int)(i + 1)] = (unsigned char)97;

            else
              if((signed int)utext[(signed long int)(1 + i)] == 0xe7)
                utext[(signed long int)(i + 1)] = (unsigned char)99;

              else
              {
                if((signed int)utext[(signed long int)(1 + i)] >= 0xe8)
                  tmp_if_expr_9 = (signed int)utext[(signed long int)(i + 1)] <= 0xeb ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_9 = (_Bool)0;
                if(tmp_if_expr_9)
                  utext[(signed long int)(i + 1)] = (unsigned char)101;

                else
                {
                  if((signed int)utext[(signed long int)(1 + i)] >= 0xec)
                    tmp_if_expr_8 = (signed int)utext[(signed long int)(i + 1)] <= 0xef ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_8 = (_Bool)0;
                  if(tmp_if_expr_8)
                    utext[(signed long int)(i + 1)] = (unsigned char)105;

                  else
                    if((signed int)utext[(signed long int)(1 + i)] == 0xf1)
                      utext[(signed long int)(i + 1)] = (unsigned char)110;

                    else
                    {
                      if((signed int)utext[(signed long int)(1 + i)] >= 0xf2)
                        tmp_if_expr_6 = (signed int)utext[(signed long int)(i + 1)] <= 0xf6 ? (_Bool)1 : (_Bool)0;

                      else
                        tmp_if_expr_6 = (_Bool)0;
                      if(tmp_if_expr_6)
                        tmp_if_expr_7 = (_Bool)1;

                      else
                        tmp_if_expr_7 = (signed int)utext[(signed long int)(i + 1)] == 0xf8 ? (_Bool)1 : (_Bool)0;
                      if(tmp_if_expr_7)
                        utext[(signed long int)(i + 1)] = (unsigned char)111;

                      else
                      {
                        if((signed int)utext[(signed long int)(1 + i)] >= 0xf9)
                          tmp_if_expr_5 = (signed int)utext[(signed long int)(i + 1)] <= 0xfc ? (_Bool)1 : (_Bool)0;

                        else
                          tmp_if_expr_5 = (_Bool)0;
                        if(tmp_if_expr_5)
                          utext[(signed long int)(i + 1)] = (unsigned char)117;

                        else
                        {
                          if((signed int)utext[(signed long int)(1 + i)] == 0xfd)
                            tmp_if_expr_4 = (_Bool)1;

                          else
                            tmp_if_expr_4 = (signed int)utext[(signed long int)(i + 1)] == 0xff ? (_Bool)1 : (_Bool)0;
                          if(tmp_if_expr_4)
                            utext[(signed long int)(i + 1)] = (unsigned char)121;

                        }
                      }
                    }
                }
              }
          }

      }
    }

    else
      if((signed int)utext[(signed long int)i] == 0x1)
      {
        if(!((signed int)utext[(signed long int)(1 + i)] >= 55))
          tmp_if_expr_12 = (signed int)utext[(signed long int)(i + 1)] % 2 == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_12 = (_Bool)0;
        if(tmp_if_expr_12)
          tmp_if_expr_15 = (_Bool)1;

        else
        {
          if((signed int)utext[(signed long int)(1 + i)] >= 0x39)
            tmp_if_expr_13 = (signed int)utext[(signed long int)(i + 1)] <= 0x47 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_13 = (_Bool)0;
          if(tmp_if_expr_13)
            tmp_if_expr_14 = (signed int)utext[(signed long int)(i + 1)] % 2 == 1 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_14 = (_Bool)0;
          tmp_if_expr_15 = tmp_if_expr_14 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_15)
          tmp_if_expr_18 = (_Bool)1;

        else
        {
          if((signed int)utext[(signed long int)(1 + i)] >= 0x4a)
            tmp_if_expr_16 = (signed int)utext[(signed long int)(i + 1)] <= 0x76 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_16 = (_Bool)0;
          if(tmp_if_expr_16)
            tmp_if_expr_17 = (signed int)utext[(signed long int)(i + 1)] % 2 == 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_17 = (_Bool)0;
          tmp_if_expr_18 = tmp_if_expr_17 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_18)
          tmp_if_expr_21 = (_Bool)1;

        else
        {
          if((signed int)utext[(signed long int)(1 + i)] >= 0x79)
            tmp_if_expr_19 = (signed int)utext[(signed long int)(i + 1)] <= 0x7d ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_19 = (_Bool)0;
          if(tmp_if_expr_19)
            tmp_if_expr_20 = (signed int)utext[(signed long int)(i + 1)] % 2 == 1 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_20 = (_Bool)0;
          tmp_if_expr_21 = tmp_if_expr_20 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_21)
          utext[(signed long int)(i + 1)] = utext[(signed long int)(i + 1)] + (unsigned char)0x1;

        if(!((signed int)utext[(signed long int)(1 + i)] >= 6))
        {
          utext[(signed long int)i] = (unsigned char)0x0;
          utext[(signed long int)(i + 1)] = (unsigned char)97;
        }

        else
        {
          if((signed int)utext[(signed long int)(1 + i)] >= 0x06)
            tmp_if_expr_39 = (signed int)utext[(signed long int)(i + 1)] <= 0x0d ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_39 = (_Bool)0;
          if(tmp_if_expr_39)
          {
            utext[(signed long int)i] = (unsigned char)0x0;
            utext[(signed long int)(i + 1)] = (unsigned char)99;
          }

          else
          {
            if((signed int)utext[(signed long int)(1 + i)] >= 0x0e)
              tmp_if_expr_38 = (signed int)utext[(signed long int)(i + 1)] <= 0x11 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_38 = (_Bool)0;
            if(tmp_if_expr_38)
            {
              utext[(signed long int)i] = (unsigned char)0x0;
              utext[(signed long int)(i + 1)] = (unsigned char)100;
            }

            else
            {
              if((signed int)utext[(signed long int)(1 + i)] >= 0x12)
                tmp_if_expr_37 = (signed int)utext[(signed long int)(i + 1)] <= 0x1b ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_37 = (_Bool)0;
              if(tmp_if_expr_37)
              {
                utext[(signed long int)i] = (unsigned char)0x0;
                utext[(signed long int)(i + 1)] = (unsigned char)101;
              }

              else
              {
                if((signed int)utext[(signed long int)(1 + i)] >= 0x1c)
                  tmp_if_expr_36 = (signed int)utext[(signed long int)(i + 1)] <= 0x23 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_36 = (_Bool)0;
                if(tmp_if_expr_36)
                {
                  utext[(signed long int)i] = (unsigned char)0x0;
                  utext[(signed long int)(i + 1)] = (unsigned char)103;
                }

                else
                {
                  if((signed int)utext[(signed long int)(1 + i)] >= 0x24)
                    tmp_if_expr_35 = (signed int)utext[(signed long int)(i + 1)] <= 0x27 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_35 = (_Bool)0;
                  if(tmp_if_expr_35)
                  {
                    utext[(signed long int)i] = (unsigned char)0x0;
                    utext[(signed long int)(i + 1)] = (unsigned char)104;
                  }

                  else
                  {
                    if((signed int)utext[(signed long int)(1 + i)] >= 0x28)
                      tmp_if_expr_34 = (signed int)utext[(signed long int)(i + 1)] <= 0x31 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_34 = (_Bool)0;
                    if(tmp_if_expr_34)
                    {
                      utext[(signed long int)i] = (unsigned char)0x0;
                      utext[(signed long int)(i + 1)] = (unsigned char)105;
                    }

                    else
                    {
                      if((signed int)utext[(signed long int)(1 + i)] >= 0x34)
                        tmp_if_expr_33 = (signed int)utext[(signed long int)(i + 1)] <= 0x35 ? (_Bool)1 : (_Bool)0;

                      else
                        tmp_if_expr_33 = (_Bool)0;
                      if(tmp_if_expr_33)
                      {
                        utext[(signed long int)i] = (unsigned char)0x0;
                        utext[(signed long int)(i + 1)] = (unsigned char)106;
                      }

                      else
                      {
                        if((signed int)utext[(signed long int)(1 + i)] >= 0x36)
                          tmp_if_expr_32 = (signed int)utext[(signed long int)(i + 1)] <= 0x38 ? (_Bool)1 : (_Bool)0;

                        else
                          tmp_if_expr_32 = (_Bool)0;
                        if(tmp_if_expr_32)
                        {
                          utext[(signed long int)i] = (unsigned char)0x0;
                          utext[(signed long int)(i + 1)] = (unsigned char)107;
                        }

                        else
                        {
                          if((signed int)utext[(signed long int)(1 + i)] >= 0x39)
                            tmp_if_expr_31 = (signed int)utext[(signed long int)(i + 1)] <= 0x42 ? (_Bool)1 : (_Bool)0;

                          else
                            tmp_if_expr_31 = (_Bool)0;
                          if(tmp_if_expr_31)
                          {
                            utext[(signed long int)i] = (unsigned char)0x0;
                            utext[(signed long int)(i + 1)] = (unsigned char)108;
                          }

                          else
                          {
                            if((signed int)utext[(signed long int)(1 + i)] >= 0x43)
                              tmp_if_expr_30 = (signed int)utext[(signed long int)(i + 1)] <= 0x4b ? (_Bool)1 : (_Bool)0;

                            else
                              tmp_if_expr_30 = (_Bool)0;
                            if(tmp_if_expr_30)
                            {
                              utext[(signed long int)i] = (unsigned char)0x0;
                              utext[(signed long int)(i + 1)] = (unsigned char)110;
                            }

                            else
                            {
                              if((signed int)utext[(signed long int)(1 + i)] >= 0x4c)
                                tmp_if_expr_29 = (signed int)utext[(signed long int)(i + 1)] <= 0x51 ? (_Bool)1 : (_Bool)0;

                              else
                                tmp_if_expr_29 = (_Bool)0;
                              if(tmp_if_expr_29)
                              {
                                utext[(signed long int)i] = (unsigned char)0x0;
                                utext[(signed long int)(i + 1)] = (unsigned char)111;
                              }

                              else
                              {
                                if((signed int)utext[(signed long int)(1 + i)] >= 0x54)
                                  tmp_if_expr_28 = (signed int)utext[(signed long int)(i + 1)] <= 0x59 ? (_Bool)1 : (_Bool)0;

                                else
                                  tmp_if_expr_28 = (_Bool)0;
                                if(tmp_if_expr_28)
                                {
                                  utext[(signed long int)i] = (unsigned char)0x0;
                                  utext[(signed long int)(i + 1)] = (unsigned char)114;
                                }

                                else
                                {
                                  if((signed int)utext[(signed long int)(1 + i)] >= 0x5a)
                                    tmp_if_expr_26 = (signed int)utext[(signed long int)(i + 1)] <= 0x61 ? (_Bool)1 : (_Bool)0;

                                  else
                                    tmp_if_expr_26 = (_Bool)0;
                                  if(tmp_if_expr_26)
                                    tmp_if_expr_27 = (_Bool)1;

                                  else
                                    tmp_if_expr_27 = (signed int)utext[(signed long int)(i + 1)] == 0x7f ? (_Bool)1 : (_Bool)0;
                                  if(tmp_if_expr_27)
                                  {
                                    utext[(signed long int)i] = (unsigned char)0x0;
                                    utext[(signed long int)(i + 1)] = (unsigned char)115;
                                  }

                                  else
                                  {
                                    if((signed int)utext[(signed long int)(1 + i)] >= 0x62)
                                      tmp_if_expr_25 = (signed int)utext[(signed long int)(i + 1)] <= 0x67 ? (_Bool)1 : (_Bool)0;

                                    else
                                      tmp_if_expr_25 = (_Bool)0;
                                    if(tmp_if_expr_25)
                                    {
                                      utext[(signed long int)i] = (unsigned char)0x0;
                                      utext[(signed long int)(i + 1)] = (unsigned char)116;
                                    }

                                    else
                                    {
                                      if((signed int)utext[(signed long int)(1 + i)] >= 0x68)
                                        tmp_if_expr_24 = (signed int)utext[(signed long int)(i + 1)] <= 0x73 ? (_Bool)1 : (_Bool)0;

                                      else
                                        tmp_if_expr_24 = (_Bool)0;
                                      if(tmp_if_expr_24)
                                      {
                                        utext[(signed long int)i] = (unsigned char)0x0;
                                        utext[(signed long int)(i + 1)] = (unsigned char)117;
                                      }

                                      else
                                      {
                                        if((signed int)utext[(signed long int)(1 + i)] >= 0x74)
                                          tmp_if_expr_23 = (signed int)utext[(signed long int)(i + 1)] <= 0x75 ? (_Bool)1 : (_Bool)0;

                                        else
                                          tmp_if_expr_23 = (_Bool)0;
                                        if(tmp_if_expr_23)
                                        {
                                          utext[(signed long int)i] = (unsigned char)0x0;
                                          utext[(signed long int)(i + 1)] = (unsigned char)119;
                                        }

                                        else
                                        {
                                          if((signed int)utext[(signed long int)(1 + i)] >= 0x76)
                                            tmp_if_expr_22 = (signed int)utext[(signed long int)(i + 1)] <= 0x78 ? (_Bool)1 : (_Bool)0;

                                          else
                                            tmp_if_expr_22 = (_Bool)0;
                                          if(tmp_if_expr_22)
                                          {
                                            utext[(signed long int)i] = (unsigned char)0x0;
                                            utext[(signed long int)(i + 1)] = (unsigned char)121;
                                          }

                                          else
                                            if((signed int)utext[(signed long int)(1 + i)] >= 0x79)
                                            {
                                              if(!((signed int)utext[(signed long int)(1 + i)] >= 127))
                                              {
                                                utext[(signed long int)i] = (unsigned char)0x0;
                                                utext[(signed long int)(i + 1)] = (unsigned char)122;
                                              }

                                            }

                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      else
        if((signed int)utext[(signed long int)i] == 0x3)
        {
          if((signed int)utext[(signed long int)(1 + i)] >= 0x91)
          {
            if(!((signed int)utext[(signed long int)(1 + i)] >= 170))
              utext[(signed long int)(i + 1)] = utext[(signed long int)(i + 1)] + (unsigned char)0x20;

          }

        }

        else
          if((signed int)utext[(signed long int)i] == 0x4)
          {
            if((signed int)utext[(signed long int)(1 + i)] >= 0x10)
              tmp_if_expr_40 = (signed int)utext[(signed long int)(i + 1)] <= 0x2f ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_40 = (_Bool)0;
            if(tmp_if_expr_40)
              utext[(signed long int)(i + 1)] = utext[(signed long int)(i + 1)] + (unsigned char)0x20;

            else
              if(!((signed int)utext[(signed long int)(1 + i)] >= 16))
                utext[(signed long int)(i + 1)] = utext[(signed long int)(i + 1)] + (unsigned char)0x50;

          }

          else
            if((signed int)utext[(signed long int)i] == 0xff)
            {
              if((signed int)utext[(signed long int)(1 + i)] >= 0xf0)
              {
                utext[(signed long int)i] = (unsigned char)0x0;
                utext[(signed long int)(i + 1)] = (unsigned char)32;
              }

            }

}

// est_char_category
// file estraier.c line 6363
static signed int est_char_category(signed int c)
{
  if(!(c >= 33))
    return 0;

  else
    if(c >= 0x0030 && !(c >= 58) || c >= 0x0041 && !(c >= 91) || c >= 0x0061 && !(c >= 123))
      return 2;

    else
      if(c >= 0x0100 && !(c >= 384) || c >= 0x00c0 && !(c == 0x00d7) && !(c == 0x00f7) && !(c >= 256))
        return 2;

      else
        if(c >= 0x0600 && !(c >= 2304))
          return 3;

        else
          if(c >= 0x0900 && !(c >= 4256) || c >= 0x1700 && !(c >= 7424))
            return 3;

          else
            if(c >= 0x1100 && !(c >= 4608) || c >= 0x2e80 && !(c >= 57344) || c >= 0xf900 && !(c >= 64256) || c >= 0xff00 && !(c >= 65520))
              return 3;

            else
              if(c >= 0xfb50 && !(c >= 65024) || c >= 0xfe30 && !(c >= 65104) || c >= 0xfe70 && !(c >= 65280))
                return 3;

              else
                return 1;
}

// est_char_category_chrcat
// file estraier.c line 6399
static signed int est_char_category_chrcat(signed int c)
{
  if(!(c >= 33))
    return 0;

  else
    if(c >= 0x0030 && !(c >= 58) || c >= 0x0041 && !(c >= 91) || c >= 0x0061 && !(c >= 123))
      return 2;

    else
      if(c >= 0x0100 && !(c >= 384) || c >= 0x00c0 && !(c == 0x00d7) && !(c == 0x00f7) && !(c >= 256))
        return 2;

      else
        if(c >= 0x0600 && !(c >= 2304))
          return 3;

        else
          if(c >= 0x0900 && !(c >= 4256) || c >= 0x1700 && !(c >= 7424))
            return 3;

          else
            if(c >= 0x3040 && !(c >= 12448))
              return 4;

            else
              if(c >= 0x30a0 && !(c >= 12544))
                return 5;

              else
                if(c >= 0x1100 && !(c >= 4608) || c >= 0x3130 && !(c >= 12688) || c >= 0xac00 && !(c >= 55216))
                  return 6;

                else
                  if(c >= 0x4e00 && !(c >= 40880))
                    return 7;

                  else
                    if(c >= 0x2e80 && !(c >= 57344) || c >= 0xf900 && !(c >= 64256) || c >= 0xff00 && !(c >= 65520))
                      return 3;

                    else
                      if(c >= 0xfb50 && !(c >= 65024) || c >= 0xfe30 && !(c >= 65104) || c >= 0xfe70 && !(c >= 65280))
                        return 3;

                      else
                        return 1;
}

// est_char_category_perfng
// file estraier.c line 6390
static signed int est_char_category_perfng(signed int c)
{
  if(!(c >= 33))
    return 0;

  else
    return 3;
}

// est_check_cjk_only
// file estraier.c line 6516
static signed int est_check_cjk_only(const char *str)
{
  const unsigned char *rp;
  signed int size;
  rp = (unsigned char *)str;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  size = (signed int)return_value_strlen_1;
  while(!(rp >= (unsigned char *)str + (signed long int)size))
    if(!((signed int)*rp >= 0x7f))
      return 0;

    else
      if(!((signed int)*rp >= 0xdf))
        return 0;

      else
        if(!((signed int)*rp >= 0xf0))
        {
          if(rp >= (unsigned char *)str + (signed long int)size + -2l)
            break;

          rp = rp + (signed long int)3;
        }

        else
          if(!((signed int)*rp >= 0xf8))
          {
            if(rp >= (unsigned char *)str + (signed long int)size + -3l)
              break;

            rp = rp + (signed long int)4;
          }

          else
            if(!((signed int)*rp >= 0xfb))
            {
              if(rp >= (unsigned char *)str + (signed long int)size + -4l)
                break;

              rp = rp + (signed long int)5;
            }

            else
              if(!((signed int)*rp >= 0xfd))
              {
                if(rp >= (unsigned char *)str + (signed long int)size + -5l)
                  break;

                rp = rp + (signed long int)6;
              }

              else
                break;
  return 1;
}

// est_check_numbt
// file estraier.c line 10174
static signed int est_check_numbt(const char *tval, const char *oval)
{
  signed long int val;
  signed long int lower;
  signed long int upper;
  signed long int swap;
  char numbuf[32l];
  signed int i = 0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  do
  {
    if(!(i >= 32))
      tmp_if_expr_1 = (signed int)oval[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (signed int)oval[(signed long int)i] != 32 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (signed int)oval[(signed long int)i] != 9 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(!tmp_if_expr_3)
      break;

    numbuf[(signed long int)i] = oval[(signed long int)i];
    i = i + 1;
  }
  while((_Bool)1);
  numbuf[(signed long int)i] = (char)0;
  oval = oval + (signed long int)i;
  for( ; (_Bool)1; oval = oval + 1l)
    if(!((signed int)*oval == 32))
    {
      if(!((signed int)*oval == 9))
        goto __CPROVER_DUMP_L11;

    }


__CPROVER_DUMP_L11:
  ;
  if((signed int)*oval == 0)
    return 0;

  else
  {
    val=cbstrmktime(tval);
    lower=cbstrmktime(numbuf);
    upper=cbstrmktime(oval);
    if(!(upper >= lower))
    {
      swap = lower;
      lower = upper;
      upper = swap;
    }

    return (signed int)(val >= lower && val <= upper);
  }
}

// est_check_strand
// file estraier.c line 10073
static signed int est_check_strand(const char *tval, const char *oval)
{
  const char *sp;
  const char *ep;
  const char *rp;
  const char *pp;
  const char *qp;
  signed int hit;
  sp = oval;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  for( ; !((signed int)*sp == 0); sp = ep)
  {
    for( ; (_Bool)1; sp = sp + 1l)
      if(!((signed int)*sp == 32))
      {
        if(!((signed int)*sp == 44))
          goto __CPROVER_DUMP_L4;

      }


  __CPROVER_DUMP_L4:
    ;
    ep = sp;
    for( ; !((signed int)*ep == 0); ep = ep + 1l)
    {
      if((signed int)*ep == 32)
        break;

      if((signed int)*ep == 44)
        break;

    }
    if(!(sp >= ep))
    {
      hit = 0;
      rp = tval;
      for( ; !((signed int)*rp == 0); rp = rp + 1l)
      {
        pp = sp;
        qp = rp;
        for( ; !(pp >= ep); qp = qp + 1l)
        {
          if(!(*pp == *qp))
            break;

          pp = pp + 1l;
        }
        if(pp == ep)
        {
          if((signed int)*qp == 0)
            tmp_if_expr_1 = (_Bool)1;

          else
            tmp_if_expr_1 = (signed int)*qp == 32 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_1)
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = (signed int)*qp == 44 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_2)
          {
            hit = 1;
            break;
          }

        }

      }
      if(hit == 0)
        return 0;

    }

  }
  return 1;
}

// est_check_stror
// file estraier.c line 10109
static signed int est_check_stror(const char *tval, const char *oval)
{
  const char *sp;
  const char *ep;
  const char *rp;
  const char *pp;
  const char *qp;
  signed int hit;
  sp = oval;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  for( ; !((signed int)*sp == 0); sp = ep)
  {
    for( ; (_Bool)1; sp = sp + 1l)
      if(!((signed int)*sp == 32))
      {
        if(!((signed int)*sp == 44))
          goto __CPROVER_DUMP_L4;

      }


  __CPROVER_DUMP_L4:
    ;
    ep = sp;
    for( ; !((signed int)*ep == 0); ep = ep + 1l)
    {
      if((signed int)*ep == 32)
        break;

      if((signed int)*ep == 44)
        break;

    }
    if(!(sp >= ep))
    {
      hit = 0;
      rp = tval;
      for( ; !((signed int)*rp == 0); rp = rp + 1l)
      {
        pp = sp;
        qp = rp;
        for( ; !(pp >= ep); qp = qp + 1l)
        {
          if(!(*pp == *qp))
            break;

          pp = pp + 1l;
        }
        if(pp == ep)
        {
          if((signed int)*qp == 0)
            tmp_if_expr_1 = (_Bool)1;

          else
            tmp_if_expr_1 = (signed int)*qp == 32 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_1)
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = (signed int)*qp == 44 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_2)
          {
            hit = 1;
            break;
          }

        }

      }
      if(!(hit == 0))
        return 1;

    }

  }
  return 0;
}

// est_check_stroreq
// file estraier.c line 10145
static signed int est_check_stroreq(const char *tval, const char *oval)
{
  const char *sp;
  const char *ep;
  const char *rp;
  sp = oval;
  for( ; !((signed int)*sp == 0); sp = ep)
  {
    for( ; (_Bool)1; sp = sp + 1l)
      if(!((signed int)*sp == 32))
      {
        if(!((signed int)*sp == 44))
          goto __CPROVER_DUMP_L4;

      }


  __CPROVER_DUMP_L4:
    ;
    ep = sp;
    for( ; !((signed int)*ep == 0); ep = ep + 1l)
    {
      if((signed int)*ep == 32)
        break;

      if((signed int)*ep == 44)
        break;

    }
    if(!(sp >= ep))
    {
      rp = tval;
      for( ; !((signed int)*rp == 0); rp = rp + 1l)
      {
        if(sp >= ep || !(*sp == *rp))
          break;

        sp = sp + 1l;
      }
      if((signed int)*rp == 0)
      {
        if(sp == ep)
          return 1;

      }

    }

  }
  return 0;
}

// est_cond_add_attr
// file estraier.c line 800
void est_cond_add_attr(struct anonymous_15 *cond, const char *expr)
{
  for( ; (signed int)*expr >= 1; expr = expr + 1l)
    if((signed int)*expr >= 33)
      break;

  unsigned long int tmp_if_expr_6;
  unsigned long int return_value_strlen_5;
  if(!((signed int)*expr == 0))
  {
    if(cond->attrs == ((struct anonymous_6 *)NULL))
      do
      {
        void *return_value_malloc_1;
        return_value_malloc_1=malloc(sizeof(struct anonymous_6) /*24ul*/ );
        cond->attrs = (struct anonymous_6 *)return_value_malloc_1;
        if(!(cond->attrs == ((struct anonymous_6 *)NULL)))
          cond->attrs;

        else
          cbmyfatal("out of memory");
        cond->attrs->anum = 64;
        void *return_value_malloc_2;
        return_value_malloc_2=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)cond->attrs->anum);
        cond->attrs->array = (struct anonymous_28 *)return_value_malloc_2;
        if(!(cond->attrs->array == ((struct anonymous_28 *)NULL)))
          cond->attrs->array;

        else
          cbmyfatal("out of memory");
        cond->attrs->start = 0;
        cond->attrs->num = 0;
      }
      while((_Bool)0);

    do
    {
      signed int _CB_index = cond->attrs->start + cond->attrs->num;
      if(_CB_index >= cond->attrs->anum)
      {
        cond->attrs->anum = cond->attrs->anum * 2;
        void *return_value_realloc_3;
        return_value_realloc_3=realloc((void *)cond->attrs->array, (unsigned long int)cond->attrs->anum * sizeof(struct anonymous_28) /*16ul*/ );
        cond->attrs->array = (struct anonymous_28 *)return_value_realloc_3;
        if(!(cond->attrs->array == ((struct anonymous_28 *)NULL)))
          cond->attrs->array;

        else
          cbmyfatal("out of memory");
      }

      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(expr);
      if(!(return_value_strlen_4 >= 12ul))
        tmp_if_expr_6 = (unsigned long int)12;

      else
      {
        return_value_strlen_5=strlen(expr);
        tmp_if_expr_6 = return_value_strlen_5;
      }
      void *return_value_malloc_7;
      return_value_malloc_7=malloc(tmp_if_expr_6 + (unsigned long int)1);
      (cond->attrs->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_7;
      if(!((cond->attrs->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
        (cond->attrs->array + (signed long int)_CB_index)->dptr;

      else
        cbmyfatal("out of memory");
      unsigned long int return_value_strlen_8;
      return_value_strlen_8=strlen(expr);
      memcpy((void *)(cond->attrs->array + (signed long int)_CB_index)->dptr, (const void *)expr, return_value_strlen_8);
      unsigned long int return_value_strlen_9;
      return_value_strlen_9=strlen(expr);
      (cond->attrs->array + (signed long int)_CB_index)->dptr[(signed long int)return_value_strlen_9] = (char)0;
      unsigned long int return_value_strlen_10;
      return_value_strlen_10=strlen(expr);
      (cond->attrs->array + (signed long int)_CB_index)->dsize = (signed int)return_value_strlen_10;
      cond->attrs->num = cond->attrs->num + 1;
    }
    while((_Bool)0);
  }

}

// est_cond_attrs
// file estraier.c line 4315
const struct anonymous_6 * est_cond_attrs(struct anonymous_15 *cond)
{
  return cond->attrs;
}

// est_cond_auxiliary
// file estraier.c line 4350
signed int est_cond_auxiliary(struct anonymous_15 *cond)
{
  return cond->auxmin;
}

// est_cond_auxiliary_word
// file estraier.c line 4395
signed int est_cond_auxiliary_word(struct anonymous_15 *cond, const char *word)
{
  const char *return_value_cbmapget_1;
  if(cond->auxwords == ((struct anonymous_5 *)NULL))
    return 0;

  else
    if(!((signed int)*word == 0))
    {
      return_value_cbmapget_1=cbmapget(cond->auxwords, word, -1, (signed int *)(void *)0);
      return (signed int)(return_value_cbmapget_1 != (const char *)(void *)0);
    }

    else
    {
      signed int return_value_cbmaprnum_2;
      return_value_cbmaprnum_2=cbmaprnum(cond->auxwords);
      return (signed int)(return_value_cbmaprnum_2 > 0);
    }
}

// est_cond_delete
// file estraier.c line 775
void est_cond_delete(struct anonymous_15 *cond)
{
  if(!(cond->distinct == ((char *)NULL)))
    free((void *)cond->distinct);

  if(!(cond->shadows == ((struct anonymous_5 *)NULL)))
    cbmapclose(cond->shadows);

  if(!(cond->auxwords == ((struct anonymous_5 *)NULL)))
    cbmapclose(cond->auxwords);

  if(!(cond->scores == ((signed int *)NULL)))
    free((void *)cond->scores);

  if(!(cond->order == ((char *)NULL)))
    free((void *)cond->order);

  if(!(cond->attrs == ((struct anonymous_6 *)NULL)))
    do
    {
      signed int _CB_i;
      signed int _CB_end = cond->attrs->start + cond->attrs->num;
      _CB_i = cond->attrs->start;
      for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
        free((void *)(cond->attrs->array + (signed long int)_CB_i)->dptr);
      free((void *)cond->attrs->array);
      free((void *)cond->attrs);
    }
    while((_Bool)0);

  if(!(cond->phrase == ((char *)NULL)))
    free((void *)cond->phrase);

  free((void *)cond);
}

// est_cond_distinct
// file estraier.c line 4357
const char * est_cond_distinct(struct anonymous_15 *cond)
{
  return cond->distinct;
}

// est_cond_dup
// file estraier.c line 4277
struct anonymous_15 * est_cond_dup(struct anonymous_15 *cond)
{
  struct anonymous_15 *ncond;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_15) /*144ul*/ );
  ncond = (struct anonymous_15 *)return_value_malloc_1;
  if(!(ncond == ((struct anonymous_15 *)NULL)))
    ncond;

  else
    cbmyfatal("out of memory");
  char *tmp_if_expr_3;
  char *return_value_cbmemdup_2;
  if(!(cond->phrase == ((char *)NULL)))
  {
    return_value_cbmemdup_2=cbmemdup(cond->phrase, -1);
    tmp_if_expr_3 = return_value_cbmemdup_2;
  }

  else
    tmp_if_expr_3 = (char *)(void *)0;
  ncond->phrase = tmp_if_expr_3;
  ncond->gstep = cond->gstep;
  ncond->tfidf = cond->tfidf;
  ncond->pmode = cond->pmode;
  ncond->cbxpn = cond->cbxpn;
  struct anonymous_6 *tmp_if_expr_5;
  struct anonymous_6 *return_value_cblistdup_4;
  if(!(cond->attrs == ((struct anonymous_6 *)NULL)))
  {
    return_value_cblistdup_4=cblistdup(cond->attrs);
    tmp_if_expr_5 = return_value_cblistdup_4;
  }

  else
    tmp_if_expr_5 = (struct anonymous_6 *)(void *)0;
  ncond->attrs = tmp_if_expr_5;
  char *tmp_if_expr_7;
  char *return_value_cbmemdup_6;
  if(!(cond->order == ((char *)NULL)))
  {
    return_value_cbmemdup_6=cbmemdup(cond->order, -1);
    tmp_if_expr_7 = return_value_cbmemdup_6;
  }

  else
    tmp_if_expr_7 = (char *)(void *)0;
  ncond->order = tmp_if_expr_7;
  ncond->max = cond->max;
  ncond->skip = cond->skip;
  ncond->auxmin = cond->auxmin;
  struct anonymous_5 *tmp_if_expr_9;
  struct anonymous_5 *return_value_cbmapdup_8;
  if(!(cond->auxwords == ((struct anonymous_5 *)NULL)))
  {
    return_value_cbmapdup_8=cbmapdup(cond->auxwords);
    tmp_if_expr_9 = return_value_cbmapdup_8;
  }

  else
    tmp_if_expr_9 = (struct anonymous_5 *)(void *)0;
  ncond->auxwords = tmp_if_expr_9;
  ncond->scfb = cond->scfb;
  signed int *tmp_if_expr_11;
  char *return_value_cbmemdup_10;
  if(!(cond->scores == ((signed int *)NULL)))
  {
    return_value_cbmemdup_10=cbmemdup((char *)cond->scores, (signed int)((unsigned long int)cond->snum * sizeof(signed int) /*4ul*/ ));
    tmp_if_expr_11 = (signed int *)return_value_cbmemdup_10;
  }

  else
    tmp_if_expr_11 = (signed int *)(void *)0;
  ncond->scores = tmp_if_expr_11;
  ncond->snum = cond->snum;
  ncond->nscores = cond->nscores;
  ncond->nsnum = cond->nsnum;
  ncond->opts = cond->opts;
  ncond->ecllim = cond->ecllim;
  struct anonymous_5 *tmp_if_expr_13;
  struct anonymous_5 *return_value_cbmapdup_12;
  if(!(cond->shadows == ((struct anonymous_5 *)NULL)))
  {
    return_value_cbmapdup_12=cbmapdup(cond->shadows);
    tmp_if_expr_13 = return_value_cbmapdup_12;
  }

  else
    tmp_if_expr_13 = (struct anonymous_5 *)(void *)0;
  ncond->shadows = tmp_if_expr_13;
  char *tmp_if_expr_15;
  char *return_value_cbmemdup_14;
  if(!(cond->distinct == ((char *)NULL)))
  {
    return_value_cbmemdup_14=cbmemdup(cond->distinct, -1);
    tmp_if_expr_15 = return_value_cbmemdup_14;
  }

  else
    tmp_if_expr_15 = (char *)(void *)0;
  ncond->distinct = tmp_if_expr_15;
  ncond->mask = cond->mask;
  return ncond;
}

// est_cond_mask
// file estraier.c line 4364
signed int est_cond_mask(struct anonymous_15 *cond)
{
  return cond->mask;
}

// est_cond_max
// file estraier.c line 4329
signed int est_cond_max(struct anonymous_15 *cond)
{
  return cond->max;
}

// est_cond_new
// file estraier.c line 746
struct anonymous_15 * est_cond_new(void)
{
  struct anonymous_15 *cond;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_15) /*144ul*/ );
  cond = (struct anonymous_15 *)return_value_malloc_1;
  if(!(cond == ((struct anonymous_15 *)NULL)))
    cond;

  else
    cbmyfatal("out of memory");
  cond->phrase = (char *)(void *)0;
  cond->gstep = 2;
  cond->tfidf = 1;
  cond->pmode = 0;
  cond->cbxpn = (void (*)(const char *, struct anonymous_6 *))(void *)0;
  cond->attrs = (struct anonymous_6 *)(void *)0;
  cond->order = (char *)(void *)0;
  cond->max = -1;
  cond->skip = 0;
  cond->auxmin = 32;
  cond->auxwords = (struct anonymous_5 *)(void *)0;
  cond->scfb = 0;
  cond->scores = (signed int *)(void *)0;
  cond->snum = 0;
  cond->nscores = (const signed int *)(void *)0;
  cond->nsnum = -1;
  cond->opts = 0;
  cond->ecllim = -1.0;
  cond->shadows = (struct anonymous_5 *)(void *)0;
  cond->distinct = (char *)(void *)0;
  cond->mask = 0;
  return cond;
}

// est_cond_options
// file estraier.c line 4343
signed int est_cond_options(struct anonymous_15 *cond)
{
  return cond->opts;
}

// est_cond_order
// file estraier.c line 4322
const char * est_cond_order(struct anonymous_15 *cond)
{
  return cond->order;
}

// est_cond_phrase
// file estraier.c line 4308
const char * est_cond_phrase(struct anonymous_15 *cond)
{
  return cond->phrase;
}

// est_cond_score
// file estraier.c line 4371
signed int est_cond_score(struct anonymous_15 *cond, signed int index)
{
  _Bool tmp_if_expr_1;
  if(cond->scores == ((signed int *)NULL) || !(index >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = index >= cond->snum ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return -1;

  else
    return cond->scores[(signed long int)index];
}

// est_cond_scores
// file estraier.c line 4379
const signed int * est_cond_scores(struct anonymous_15 *cond, signed int *nump)
{
  *nump = cond->snum;
  return cond->scores;
}

// est_cond_set_auxiliary
// file estraier.c line 855
void est_cond_set_auxiliary(struct anonymous_15 *cond, signed int min)
{
  cond->auxmin = min;
}

// est_cond_set_distinct
// file estraier.c line 869
void est_cond_set_distinct(struct anonymous_15 *cond, const char *name)
{
  for( ; (signed int)*name >= 1; name = name + 1l)
    if((signed int)*name >= 33)
      break;

  if(!((signed int)*name == 0))
  {
    if(!(cond->distinct == ((char *)NULL)))
      free((void *)cond->distinct);

    cond->distinct=cbmemdup(name, -1);
  }

}

// est_cond_set_eclipse
// file estraier.c line 862
void est_cond_set_eclipse(struct anonymous_15 *cond, double limit)
{
  if(limit > 0.0)
    cond->ecllim = limit;

}

// est_cond_set_expander
// file estraier.c line 4418
void est_cond_set_expander(struct anonymous_15 *cond, void (*func)(const char *, struct anonymous_6 *))
{
  cond->cbxpn = func;
}

// est_cond_set_mask
// file estraier.c line 881
void est_cond_set_mask(struct anonymous_15 *cond, signed int mask)
{
  cond->mask = mask & 0x7fffffff;
}

// est_cond_set_max
// file estraier.c line 824
void est_cond_set_max(struct anonymous_15 *cond, signed int max)
{
  cond->max = max;
}

// est_cond_set_narrowing_scores
// file estraier.c line 4387
void est_cond_set_narrowing_scores(struct anonymous_15 *cond, const signed int *scores, signed int num)
{
  cond->nscores = scores;
  cond->nsnum = num;
}

// est_cond_set_options
// file estraier.c line 838
void est_cond_set_options(struct anonymous_15 *cond, signed int options)
{
  if(!((1 & options) == 0))
    cond->gstep = 1;

  if(!((2 & options) == 0))
    cond->gstep = 2;

  if(!((4 & options) == 0))
    cond->gstep = 3;

  if(!((8 & options) == 0))
    cond->gstep = 4;

  if(!((16 & options) == 0))
    cond->tfidf = 0;

  if(!((1024 & options) == 0))
    cond->pmode = 1;

  if(!((2048 & options) == 0))
    cond->pmode = 2;

  if(!((32768 & options) == 0))
    cond->pmode = 3;

  if(!((65536 & options) == 0))
    cond->pmode = 4;

  if(!((1073741824 & options) == 0))
    cond->scfb = 1;

  cond->opts = cond->opts | options;
}

// est_cond_set_order
// file estraier.c line 812
void est_cond_set_order(struct anonymous_15 *cond, const char *expr)
{
  for( ; (signed int)*expr >= 1; expr = expr + 1l)
    if((signed int)*expr >= 33)
      break;

  if(!((signed int)*expr == 0))
  {
    if(!(cond->order == ((char *)NULL)))
      free((void *)cond->order);

    cond->order=cbmemdup(expr, -1);
  }

}

// est_cond_set_phrase
// file estraier.c line 789
void est_cond_set_phrase(struct anonymous_15 *cond, const char *phrase)
{
  if(!(cond->phrase == ((char *)NULL)))
    free((void *)cond->phrase);

  for( ; (signed int)*phrase >= 1; phrase = phrase + 1l)
    if((signed int)*phrase >= 33)
      break;

  cond->phrase=cbmemdup(phrase, -1);
}

// est_cond_set_skip
// file estraier.c line 831
void est_cond_set_skip(struct anonymous_15 *cond, signed int skip)
{
  cond->skip = skip;
}

// est_cond_shadows
// file estraier.c line 4404
const signed int * est_cond_shadows(struct anonymous_15 *cond, signed int id, signed int *np)
{
  const char *vbuf;
  signed int vsiz;
  _Bool tmp_if_expr_1;
  if(cond->shadows == ((struct anonymous_5 *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    vbuf=cbmapget(cond->shadows, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , &vsiz);
    tmp_if_expr_1 = !(vbuf != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1)
  {
    *np = 0;
    return (signed int *)"";
  }

  else
  {
    *np = (signed int)((unsigned long int)vsiz / sizeof(signed int) /*4ul*/ );
    return (signed int *)vbuf;
  }
}

// est_cond_skip
// file estraier.c line 4336
signed int est_cond_skip(struct anonymous_15 *cond)
{
  return cond->skip;
}

// est_crget
// file estraier.c line 7370
static char * est_crget(struct anonymous_3 *curia, signed int zmode, signed int id, signed int *sp)
{
  char *zbuf;
  char *vbuf;
  signed int zsiz;
  switch(zmode)
  {
    case 32768:
    {
      zbuf=crget(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0, -1, &zsiz);
      if(zbuf == ((char *)NULL))
        return (char *)(void *)0;

      vbuf=est_inflate(zbuf, zsiz, sp, -1);
      if(vbuf == ((char *)NULL))
      {
        free((void *)zbuf);
        return (char *)(void *)0;
      }

      free((void *)zbuf);
      break;
    }
    case 65536:
    {
      zbuf=crget(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0, -1, &zsiz);
      if(zbuf == ((char *)NULL))
        return (char *)(void *)0;

      vbuf=est_lzodecode(zbuf, zsiz, sp);
      if(vbuf == ((char *)NULL))
      {
        free((void *)zbuf);
        return (char *)(void *)0;
      }

      free((void *)zbuf);
      break;
    }
    case 131072:
    {
      zbuf=crget(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0, -1, &zsiz);
      if(zbuf == ((char *)NULL))
        return (char *)(void *)0;

      vbuf=est_bzdecode(zbuf, zsiz, sp);
      if(vbuf == ((char *)NULL))
      {
        free((void *)zbuf);
        return (char *)(void *)0;
      }

      free((void *)zbuf);
      break;
    }
    default:
    {
      vbuf=crget(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0, -1, sp);
      if(vbuf == ((char *)NULL))
        return (char *)(void *)0;

    }
  }
  return vbuf;
}

// est_crout
// file estraier.c line 7357
static signed int est_crout(struct anonymous_3 *curia, signed int id)
{
  signed int return_value_crout_1;
  return_value_crout_1=crout(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
  return return_value_crout_1;
}

// est_crput
// file estraier.c line 7307
static signed int est_crput(struct anonymous_3 *curia, signed int zmode, signed int id, const char *vbuf, signed int vsiz, signed int dmode)
{
  char *zbuf;
  signed int zsiz;
  signed int return_value_crput_2;
  signed int return_value_crput_4;
  signed int return_value_crput_6;
  signed int return_value_crput_7;
  switch(zmode)
  {
    case 32768:
    {
      zbuf=est_deflate(vbuf, vsiz, &zsiz, -1);
      if(zbuf == ((char *)NULL))
      {
        signed int *return_value_dpecodeptr_1;
        return_value_dpecodeptr_1=dpecodeptr();
        *return_value_dpecodeptr_1 = 9999;
        return 0;
      }

      return_value_crput_2=crput(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , zbuf, zsiz, dmode);
      if(return_value_crput_2 == 0)
      {
        free((void *)zbuf);
        return 0;
      }

      free((void *)zbuf);
      break;
    }
    case 65536:
    {
      zbuf=est_lzoencode(vbuf, vsiz, &zsiz);
      if(zbuf == ((char *)NULL))
      {
        signed int *return_value_dpecodeptr_3;
        return_value_dpecodeptr_3=dpecodeptr();
        *return_value_dpecodeptr_3 = 9999;
        return 0;
      }

      return_value_crput_4=crput(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , zbuf, zsiz, dmode);
      if(return_value_crput_4 == 0)
      {
        free((void *)zbuf);
        return 0;
      }

      free((void *)zbuf);
      break;
    }
    case 131072:
    {
      zbuf=est_bzencode(vbuf, vsiz, &zsiz);
      if(zbuf == ((char *)NULL))
      {
        signed int *return_value_dpecodeptr_5;
        return_value_dpecodeptr_5=dpecodeptr();
        *return_value_dpecodeptr_5 = 9999;
        return 0;
      }

      return_value_crput_6=crput(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , zbuf, zsiz, dmode);
      if(return_value_crput_6 == 0)
      {
        free((void *)zbuf);
        return 0;
      }

      free((void *)zbuf);
      break;
    }
    default:
    {
      return_value_crput_7=crput(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, dmode);
      if(return_value_crput_7 == 0)
        return 0;

    }
  }
  return 1;
}

// est_db_add_attr_index
// file estraier.c line 1341
signed int est_db_add_attr_index(struct anonymous_0 *db, const char *name, signed int type)
{
  struct anonymous_7 attridx;
  struct anonymous_8 *scores;
  void *aidxdb;
  char path[4096l];
  char *enc;
  char *vbuf;
  signed int i;
  signed int domode;
  signed int vomode;
  signed int crdnum;
  signed int err;
  signed int snum;
  signed int return_value_dpwritable_1;
  return_value_dpwritable_1=dpwritable(db->metadb);
  signed int *return_value_vlcrdnumptr_4;
  struct anonymous_4 *return_value_vlopen_6;
  signed int return_value_est_db_doc_num_9;
  signed int *return_value_vlcrdnumptr_10;
  struct anonymous_4 *return_value_vlopen_12;
  signed int return_value_est_db_doc_num_15;
  signed int return_value_crbnum_17;
  struct anonymous_1 *return_value_dpopen_18;
  signed int return_value_est_db_doc_num_21;
  if(return_value_dpwritable_1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 1349);
    return 0;
  }

  else
  {
    const char *return_value_cbmapget_2;
    return_value_cbmapget_2=cbmapget(db->aidxs, name, -1, (signed int *)(void *)0);
    if(!(return_value_cbmapget_2 == ((const char *)NULL)))
    {
      est_set_ecode(&db->ecode, 9999, 1353);
      return 0;
    }

    else
    {
      enc=est_hex_encode(name);
      switch(type)
      {
        case 0:
        {
          sprintf(path, "%s%c%s%s", db->name, 47, (const void *)"__seq_", enc);
          break;
        }
        case 1:
        {
          sprintf(path, "%s%c%s%s", db->name, 47, (const void *)"__str_", enc);
          break;
        }
        case 2:
        {
          sprintf(path, "%s%c%s%s", db->name, 47, (const void *)"__num_", enc);
          break;
        }
        default:
        {
          free((void *)enc);
          est_set_ecode(&db->ecode, 1, 1369);
          return 0;
        }
      }
      free((void *)enc);
      domode = 2 | 4 | 8;
      vomode = 2 | 4 | 8;
      vomode = vomode | 64;
      err = 0;
      signed int *return_value_vlcrdnumptr_3;
      return_value_vlcrdnumptr_3=vlcrdnumptr();
      crdnum = *return_value_vlcrdnumptr_3;
      switch(type)
      {
        case 1:
        {
          return_value_vlcrdnumptr_4=vlcrdnumptr();
          *return_value_vlcrdnumptr_4 = 2;
          return_value_vlopen_6=vlopen(path, vomode, VL_CMPLEX);
          aidxdb = (void *)return_value_vlopen_6;
          if(aidxdb == NULL)
          {
            est_set_ecode(&db->ecode, 4, 1388);
            signed int *return_value_vlcrdnumptr_5;
            return_value_vlcrdnumptr_5=vlcrdnumptr();
            *return_value_vlcrdnumptr_5 = crdnum;
            return 0;
          }

          vlsettuning((struct anonymous_4 *)aidxdb, 99, 120, 1024, 256);
          vlsetfbpsiz((struct anonymous_4 *)aidxdb, 128);
          return_value_est_db_doc_num_9=est_db_doc_num(db);
          if(return_value_est_db_doc_num_9 >= 1)
          {
            scores=est_search_uvset(db, &snum, (struct anonymous_5 *)(void *)0, 1);
            i = 0;
            for( ; !(i >= snum); i = i + 1)
            {
              vbuf=est_db_get_doc_attr(db, (scores + (signed long int)i)->id, name);
              if(!(vbuf == ((char *)NULL)))
              {
                unsigned long int return_value_strlen_7;
                return_value_strlen_7=strlen(vbuf);
                signed int return_value_est_aidx_attr_put_8;
                return_value_est_aidx_attr_put_8=est_aidx_attr_put((struct anonymous_4 *)aidxdb, (scores + (signed long int)i)->id, vbuf, (signed int)return_value_strlen_7);
                if(return_value_est_aidx_attr_put_8 == 0)
                {
                  est_set_ecode(&db->ecode, 4, 1399);
                  db->fatal = 1;
                  err = 1;
                }

                free((void *)vbuf);
              }

              if(i % 1000 == 0)
                est_db_inform(db, "entering existing attributes");

            }
            free((void *)scores);
          }

          break;
        }
        case 2:
        {
          return_value_vlcrdnumptr_10=vlcrdnumptr();
          *return_value_vlcrdnumptr_10 = 2;
          return_value_vlopen_12=vlopen(path, vomode, est_aidx_numcmp);
          aidxdb = (void *)return_value_vlopen_12;
          if(aidxdb == NULL)
          {
            est_set_ecode(&db->ecode, 4, 1413);
            signed int *return_value_vlcrdnumptr_11;
            return_value_vlcrdnumptr_11=vlcrdnumptr();
            *return_value_vlcrdnumptr_11 = crdnum;
            return 0;
          }

          vlsettuning((struct anonymous_4 *)aidxdb, 99, 120, 1024, 256);
          vlsetfbpsiz((struct anonymous_4 *)aidxdb, 128);
          return_value_est_db_doc_num_15=est_db_doc_num(db);
          if(return_value_est_db_doc_num_15 >= 1)
          {
            scores=est_search_uvset(db, &snum, (struct anonymous_5 *)(void *)0, 1);
            i = 0;
            for( ; !(i >= snum); i = i + 1)
            {
              vbuf=est_db_get_doc_attr(db, (scores + (signed long int)i)->id, name);
              if(!(vbuf == ((char *)NULL)))
              {
                unsigned long int return_value_strlen_13;
                return_value_strlen_13=strlen(vbuf);
                signed int return_value_est_aidx_attr_put_14;
                return_value_est_aidx_attr_put_14=est_aidx_attr_put((struct anonymous_4 *)aidxdb, (scores + (signed long int)i)->id, vbuf, (signed int)return_value_strlen_13);
                if(return_value_est_aidx_attr_put_14 == 0)
                {
                  est_set_ecode(&db->ecode, 4, 1424);
                  db->fatal = 1;
                  err = 1;
                }

                free((void *)vbuf);
              }

              if(i % 1000 == 0)
                est_db_inform(db, "entering existing attributes");

            }
            free((void *)scores);
          }

          break;
        }
        default:
        {
          return_value_crbnum_17=crbnum(db->attrdb);
          return_value_dpopen_18=dpopen(path, domode, (signed int)((double)return_value_crbnum_17 * 0.8));
          aidxdb = (void *)return_value_dpopen_18;
          if(aidxdb == NULL)
          {
            est_set_ecode(&db->ecode, 4, 1437);
            signed int *return_value_vlcrdnumptr_16;
            return_value_vlcrdnumptr_16=vlcrdnumptr();
            *return_value_vlcrdnumptr_16 = crdnum;
            return 0;
          }

          dpsetfbpsiz((struct anonymous_1 *)aidxdb, 32);
          return_value_est_db_doc_num_21=est_db_doc_num(db);
          if(return_value_est_db_doc_num_21 >= 1)
          {
            scores=est_search_uvset(db, &snum, (struct anonymous_5 *)(void *)0, 1);
            i = 0;
            for( ; !(i >= snum); i = i + 1)
            {
              vbuf=est_db_get_doc_attr(db, (scores + (signed long int)i)->id, name);
              if(!(vbuf == ((char *)NULL)))
              {
                unsigned long int return_value_strlen_19;
                return_value_strlen_19=strlen(vbuf);
                signed int return_value_est_aidx_seq_put_20;
                return_value_est_aidx_seq_put_20=est_aidx_seq_put((struct anonymous_1 *)aidxdb, (scores + (signed long int)i)->id, vbuf, (signed int)return_value_strlen_19);
                if(return_value_est_aidx_seq_put_20 == 0)
                {
                  est_set_ecode(&db->ecode, 4, 1447);
                  db->fatal = 1;
                  err = 1;
                }

                free((void *)vbuf);
              }

              if(i % 1000 == 0)
                est_db_inform(db, "entering existing attributes");

            }
            free((void *)scores);
          }

        }
      }
      signed int *return_value_vlcrdnumptr_22;
      return_value_vlcrdnumptr_22=vlcrdnumptr();
      *return_value_vlcrdnumptr_22 = crdnum;
      attridx.db = aidxdb;
      attridx.type = type;
      cbmapput(db->aidxs, name, -1, (char *)&attridx, (signed int)sizeof(struct anonymous_7) /*16ul*/ , 0);
      return err != 0 ? 0 : 1;
    }
  }
}

// est_db_add_meta
// file estraier.c line 4525
void est_db_add_meta(struct anonymous_0 *db, const char *name, const char *value)
{
  signed int return_value_dpwritable_1;
  return_value_dpwritable_1=dpwritable(db->metadb);
  if(return_value_dpwritable_1 == 0)
    est_set_ecode(&db->ecode, 2, 4528);

  else
  {
    if(db->metacc == ((struct anonymous_5 *)NULL))
      est_db_prepare_meta(db);

    if(!(value == ((const char *)NULL)))
      cbmapput(db->metacc, name, -1, value, -1, 1);

    else
      cbmapout(db->metacc, name, -1);
  }
}

// est_db_add_pseudo_index
// file estraier.c line 3335
signed int est_db_add_pseudo_index(struct anonymous_0 *db, const char *path)
{
  struct anonymous_6 *files;
  const char *file;
  char pbuf[4096l];
  signed int i;
  signed int len;
  files=cbdirlist(path);
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(files == ((struct anonymous_6 *)NULL))
  {
    est_set_ecode(&db->ecode, 1, 3342);
    return 0;
  }

  else
  {
    cblistsort(files);
    i = 0;
    for( ; !(i >= files->num); i = i + 1)
    {
      file = (const char *)(files->array + (signed long int)(files->start + i))->dptr;
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(file, ".");
      if(return_value_strcmp_1 == 0)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_strcmp_2=strcmp(file, "..");
        tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_3)
      {
        len=sprintf(pbuf, "%s%c%s", path, 47, file);
        do
        {
          signed int _CB_index = db->pdocs->start + db->pdocs->num;
          if(_CB_index >= db->pdocs->anum)
          {
            db->pdocs->anum = db->pdocs->anum * 2;
            void *return_value_realloc_4;
            return_value_realloc_4=realloc((void *)db->pdocs->array, (unsigned long int)db->pdocs->anum * sizeof(struct anonymous_28) /*16ul*/ );
            db->pdocs->array = (struct anonymous_28 *)return_value_realloc_4;
            if(!(db->pdocs->array == ((struct anonymous_28 *)NULL)))
              db->pdocs->array;

            else
              cbmyfatal("out of memory");
          }

          void *return_value_malloc_5;
          return_value_malloc_5=malloc((unsigned long int)((len < 12 ? 12 : len) + 1));
          (db->pdocs->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_5;
          if(!((db->pdocs->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
            (db->pdocs->array + (signed long int)_CB_index)->dptr;

          else
            cbmyfatal("out of memory");
          memcpy((void *)(db->pdocs->array + (signed long int)_CB_index)->dptr, (const void *)pbuf, (unsigned long int)len);
          (db->pdocs->array + (signed long int)_CB_index)->dptr[(signed long int)len] = (char)0;
          (db->pdocs->array + (signed long int)_CB_index)->dsize = len;
          db->pdocs->num = db->pdocs->num + 1;
        }
        while((_Bool)0);
      }

    }
    do
    {
      signed int _CB_i;
      signed int _CB_end = files->start + files->num;
      _CB_i = files->start;
      for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
        free((void *)(files->array + (signed long int)_CB_i)->dptr);
      free((void *)files->array);
      free((void *)files);
    }
    while((_Bool)0);
    if(!(db->puris == ((struct anonymous_5 *)NULL)))
    {
      cbmapclose(db->puris);
      db->puris = (struct anonymous_5 *)(void *)0;
    }

    return 1;
  }
}

// est_db_attr_index_exprs
// file estraier.c line 5082
struct anonymous_6 * est_db_attr_index_exprs(struct anonymous_0 *db)
{
  struct anonymous_7 *attridx;
  struct anonymous_6 *list;
  const char *kbuf;
  char *expr;
  list=cblistopen();
  cbmapiterinit(db->aidxs);
  do
  {
    kbuf=cbmapiternext(db->aidxs, (signed int *)(void *)0);
    if(kbuf == ((const char *)NULL))
      break;

    const char *return_value_cbmapiterval_1;
    return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
    attridx = (struct anonymous_7 *)return_value_cbmapiterval_1;
    switch(attridx->type)
    {
      case 1:
      {
        expr=cbsprintf("%s=str", kbuf);
        break;
      }
      case 2:
      {
        expr=cbsprintf("%s=num", kbuf);
        break;
      }
      default:
        expr=cbsprintf("%s=seq", kbuf);
    }
    do
    {
      signed int _CB_index = list->start + list->num;
      if(_CB_index >= list->anum)
      {
        list->anum = list->anum * 2;
        void *return_value_realloc_2;
        return_value_realloc_2=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous_28) /*16ul*/ );
        list->array = (struct anonymous_28 *)return_value_realloc_2;
        if(!(list->array == ((struct anonymous_28 *)NULL)))
          list->array;

        else
          cbmyfatal("out of memory");
      }

      (list->array + (signed long int)_CB_index)->dptr = expr;
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(expr);
      (list->array + (signed long int)_CB_index)->dsize = (signed int)return_value_strlen_3;
      list->num = list->num + 1;
    }
    while((_Bool)0);
  }
  while((_Bool)1);
  return list;
}

// est_db_cache_num
// file estraier.c line 4957
signed int est_db_cache_num(struct anonymous_0 *db)
{
  signed int return_value_cbmaprnum_1;
  return_value_cbmaprnum_1=cbmaprnum(db->idxcc);
  return return_value_cbmaprnum_1;
}

// est_db_charge_rescc
// file estraier.c line 5038
void est_db_charge_rescc(struct anonymous_0 *db, signed int max)
{
  struct anonymous_6 *words;
  const char *word;
  const char *vbuf;
  signed int i;
  signed int num;
  signed int size;
  signed int vsiz;
  if(!(max >= 0))
    max = 0x7fffffff;

  do
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_6) /*24ul*/ );
    words = (struct anonymous_6 *)return_value_malloc_1;
    if(!(words == ((struct anonymous_6 *)NULL)))
      words;

    else
      cbmyfatal("out of memory");
    words->anum = 64;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)words->anum);
    words->array = (struct anonymous_28 *)return_value_malloc_2;
    if(!(words->array == ((struct anonymous_28 *)NULL)))
      words->array;

    else
      cbmyfatal("out of memory");
    words->start = 0;
    words->num = 0;
  }
  while((_Bool)0);
  cbmapiterinit(db->rescc);
  do
  {
    word=cbmapiternext(db->rescc, &size);
    if(word == ((const char *)NULL))
      break;

    do
    {
      struct _CBMAPDATUM *_CB_datum = (struct _CBMAPDATUM *)(word - (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/ );
      vsiz = _CB_datum->vsiz;
      vbuf = (char *)_CB_datum + (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/  + (signed long int)_CB_datum->ksiz + (signed long int)(((_CB_datum->ksiz | ~(-((signed int)sizeof(void *) /*8ul*/ ))) + 1) - _CB_datum->ksiz);
    }
    while((_Bool)0);
    if((unsigned long int)vsiz == sizeof(struct anonymous_8) /*16ul*/ )
    {
      if(((struct anonymous_8 *)vbuf)->id == -1)
        do
        {
          signed int _CB_index = words->start + words->num;
          if(_CB_index >= words->anum)
          {
            words->anum = words->anum * 2;
            void *return_value_realloc_3;
            return_value_realloc_3=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous_28) /*16ul*/ );
            words->array = (struct anonymous_28 *)return_value_realloc_3;
            if(!(words->array == ((struct anonymous_28 *)NULL)))
              words->array;

            else
              cbmyfatal("out of memory");
          }

          void *return_value_malloc_4;
          return_value_malloc_4=malloc((unsigned long int)((size < 12 ? 12 : size) + 1));
          (words->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_4;
          if(!((words->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
            (words->array + (signed long int)_CB_index)->dptr;

          else
            cbmyfatal("out of memory");
          memcpy((void *)(words->array + (signed long int)_CB_index)->dptr, (const void *)word, (unsigned long int)size);
          (words->array + (signed long int)_CB_index)->dptr[(signed long int)size] = (char)0;
          (words->array + (signed long int)_CB_index)->dsize = size;
          words->num = words->num + 1;
        }
        while((_Bool)0);

    }

  }
  while((_Bool)1);
  num = (signed int)words->num;
  i = 0;
  for( ; !(i >= num) && !(i >= max); i = i + 1)
  {
    word=cblistval(words, (num - i) - 1, &size);
    struct anonymous_8 *return_value_est_search_union_5;
    return_value_est_search_union_5=est_search_union(db, word, 1, (void (*)(const char *, struct anonymous_6 *))(void *)0, &size, (struct anonymous_5 *)(void *)0, 1, -1, (struct anonymous_5 *)(void *)0);
    free((void *)return_value_est_search_union_5);
  }
  do
  {
    signed int _CB_i;
    signed int _CB_end = words->start + words->num;
    _CB_i = words->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(words->array + (signed long int)_CB_i)->dptr);
    free((void *)words->array);
    free((void *)words);
  }
  while((_Bool)0);
}

// est_db_check_option
// file estraier.c line 4432
signed int est_db_check_option(struct anonymous_0 *db, signed int option)
{
  signed int return_value_dpwritable_1;
  signed int return_value_dpwritable_2;
  switch(option)
  {
    case 1:
    {
      return_value_dpwritable_1=dpwritable(db->metadb);
      return (signed int)!(return_value_dpwritable_1 != 0);
    }
    case 2:
    {
      return_value_dpwritable_2=dpwritable(db->metadb);
      return return_value_dpwritable_2;
    }
    case 4:
      return -1;
    case 8:
      return -1;
    case 16:
      return -1;
    case 32:
      return -1;
    case 1024:
      return (signed int)(db->amode == 1024);
    case 2048:
      return (signed int)(db->amode == 2048);
    case 1048576:
      return -1;
    case 2097152:
      return -1;
    case 4194304:
      return -1;
    case 8388608:
      return -1;
    case 16777216:
      return -1;
    case 33554432:
      return (signed int)(db->smode == 1048576);
    case 67108864:
      return (signed int)(db->smode == 2097152);
    case 134217728:
      return (signed int)(db->smode == 4194304);
    default:
      return -1;
  }
}

// est_db_close
// file estraier.c line 1263
signed int est_db_close(struct anonymous_0 *db, signed int *ecp)
{
  struct anonymous_7 *attridx;
  const char *kbuf;
  signed int err;
  est_set_ecode(ecp, 0, 1268);
  err = 0;
  cbmapout(est_inodes, (char *)&db->inode, (signed int)sizeof(signed int) /*4ul*/ );
  signed int return_value_dpwritable_3;
  return_value_dpwritable_3=dpwritable(db->metadb);
  if(!(return_value_dpwritable_3 == 0))
  {
    signed int return_value_est_db_flush_1;
    return_value_est_db_flush_1=est_db_flush(db, -1);
    if(return_value_est_db_flush_1 == 0)
      err = 1;

    signed int return_value_est_db_write_meta_2;
    return_value_est_db_write_meta_2=est_db_write_meta(db);
    if(return_value_est_db_write_meta_2 == 0)
      err = 1;

  }

  est_db_inform(db, "closing");
  if(!(db->metacc == ((struct anonymous_5 *)NULL)))
    cbmapclose(db->metacc);

  if(!(db->spacc == ((struct anonymous_5 *)NULL)))
  {
    free((void *)db->scname);
    cbmapclose(db->spacc);
  }

  cbmapclose(db->rescc);
  cbmapclose(db->veccc);
  cbmapclose(db->textcc);
  cbmapclose(db->attrcc);
  cbmapclose(db->keycc);
  cbmapclose(db->outcc);
  cbmapclose(db->auxcc);
  cbmapclose(db->idxcc);
  if(!(db->puris == ((struct anonymous_5 *)NULL)))
    cbmapclose(db->puris);

  do
  {
    signed int _CB_i;
    signed int _CB_end = db->pdocs->start + db->pdocs->num;
    _CB_i = db->pdocs->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(db->pdocs->array + (signed long int)_CB_i)->dptr);
    free((void *)db->pdocs->array);
    free((void *)db->pdocs);
  }
  while((_Bool)0);
  cbmapiterinit(db->aidxs);
  signed int return_value_vlclose_5;
  do
  {
    kbuf=cbmapiternext(db->aidxs, (signed int *)(void *)0);
    if(kbuf == ((const char *)NULL))
      break;

    const char *return_value_cbmapiterval_4;
    return_value_cbmapiterval_4=cbmapiterval(kbuf, (signed int *)(void *)0);
    attridx = (struct anonymous_7 *)return_value_cbmapiterval_4;
    if(attridx->type == 1 || attridx->type == 2)
    {
      return_value_vlclose_5=vlclose((struct anonymous_4 *)attridx->db);
      if(return_value_vlclose_5 == 0)
        err = 1;

      goto __CPROVER_DUMP_L14;
    }

    signed int return_value_dpclose_6;
    return_value_dpclose_6=dpclose((struct anonymous_1 *)attridx->db);
    if(return_value_dpclose_6 == 0)
      err = 1;


  __CPROVER_DUMP_L14:
    ;
  }
  while((_Bool)1);
  cbmapclose(db->aidxs);
  signed int return_value_vlclose_7;
  return_value_vlclose_7=vlclose(db->listdb);
  if(return_value_vlclose_7 == 0)
    err = 1;

  signed int return_value_crclose_8;
  return_value_crclose_8=crclose(db->kwddb);
  if(return_value_crclose_8 == 0)
    err = 1;

  signed int return_value_crclose_9;
  return_value_crclose_9=crclose(db->textdb);
  if(return_value_crclose_9 == 0)
    err = 1;

  signed int return_value_crclose_10;
  return_value_crclose_10=crclose(db->attrdb);
  if(return_value_crclose_10 == 0)
    err = 1;

  signed int return_value_vlclose_11;
  return_value_vlclose_11=vlclose(db->xfmdb);
  if(return_value_vlclose_11 == 0)
    err = 1;

  signed int return_value_vlclose_12;
  return_value_vlclose_12=vlclose(db->auxdb);
  if(return_value_vlclose_12 == 0)
    err = 1;

  signed int return_value_vlclose_13;
  return_value_vlclose_13=vlclose(db->fwmdb);
  if(return_value_vlclose_13 == 0)
    err = 1;

  signed int return_value_est_idx_close_14;
  return_value_est_idx_close_14=est_idx_close(db->idxdb);
  if(return_value_est_idx_close_14 == 0)
    err = 1;

  signed int return_value_dpclose_15;
  return_value_dpclose_15=dpclose(db->metadb);
  if(return_value_dpclose_15 == 0)
    err = 1;

  free((void *)db->name);
  if(!(db->fatal == 0))
  {
    est_set_ecode(ecp, db->ecode, 1316);
    err = 1;
  }

  else
    if(!(err == 0))
      est_set_ecode(ecp, 4, 1319);

  free((void *)db);
  return err != 0 ? 0 : 1;
}

// est_db_doc_num
// file estraier.c line 2702
signed int est_db_doc_num(struct anonymous_0 *db)
{
  return db->dnum;
}

// est_db_edit_doc
// file estraier.c line 2431
signed int est_db_edit_doc(struct anonymous_0 *db, struct anonymous_14 *doc)
{
  struct anonymous_14 *odoc;
  struct anonymous_7 *attridx;
  const char *uri;
  const char *tmp;
  const char *kbuf;
  const char *vbuf;
  char *ouri;
  char numbuf[32l];
  char *text;
  char *sbuf;
  signed int err;
  signed int id;
  signed int oid;
  signed int ksiz;
  signed int vsiz;
  signed int ssiz;
  signed int return_value_dpwritable_1;
  return_value_dpwritable_1=dpwritable(db->metadb);
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_7;
  signed int return_value_vlput_6;
  signed int return_value_est_aidx_attr_out_9;
  signed int return_value_est_aidx_attr_put_12;
  if(return_value_dpwritable_1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 2439);
    return 0;
  }

  else
  {
    id = -1;
    uri = (const char *)(void *)0;
    if(!(doc->attrs == ((struct anonymous_5 *)NULL)))
    {
      tmp=cbmapget(doc->attrs, "@id", -1, (signed int *)(void *)0);
      if(!(tmp == ((const char *)NULL)))
        id=atoi(tmp);

      tmp=cbmapget(doc->attrs, "@uri", -1, (signed int *)(void *)0);
      if(!(tmp == ((const char *)NULL)))
        uri = tmp;

    }

    if(id >= 2000000001 || !(id >= 1))
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      if(doc->id >= 1)
        tmp_if_expr_2 = doc->id != id ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
    }
    if(uri == ((const char *)NULL) || tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)uri[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
    {
      est_set_ecode(&db->ecode, 1, 2449);
      return 0;
    }

    else
    {
      err = 0;
      oid=est_db_uri_to_id(db, uri);
      if(oid == -1)
      {
        ouri=est_db_get_doc_attr(db, id, "@uri");
        if(ouri == ((char *)NULL))
        {
          est_set_ecode(&db->ecode, 1, 2455);
          return 0;
        }

        sprintf(numbuf, "%d", id);
        signed int return_value_vlout_5;
        return_value_vlout_5=vlout(db->listdb, ouri, -1);
        if(return_value_vlout_5 == 0)
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_vlput_6=vlput(db->listdb, uri, -1, numbuf, -1, 1);
          tmp_if_expr_7 = !(return_value_vlput_6 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
          err = 1;

        free((void *)ouri);
      }

      else
        if(!(oid == id))
        {
          est_set_ecode(&db->ecode, 1, 2463);
          return 0;
        }

      doc->id = id;
      signed int return_value_cbmaprnum_14;
      return_value_cbmaprnum_14=cbmaprnum(db->aidxs);
      if(return_value_cbmaprnum_14 >= 1)
      {
        odoc=est_db_get_doc(db, id, 2);
        if(!(odoc == ((struct anonymous_14 *)NULL)))
        {
          if(odoc->attrs == ((struct anonymous_5 *)NULL))
            odoc->attrs=cbmapopenex(31);

          cbmapiterinit(db->aidxs);
          do
          {
            kbuf=cbmapiternext(db->aidxs, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            vbuf=cbmapget(odoc->attrs, kbuf, ksiz, &vsiz);
            if(!(vbuf == ((const char *)NULL)))
            {
              const char *return_value_cbmapiterval_8;
              return_value_cbmapiterval_8=cbmapiterval(kbuf, (signed int *)(void *)0);
              attridx = (struct anonymous_7 *)return_value_cbmapiterval_8;
              if(attridx->type == 1 || attridx->type == 2)
              {
                return_value_est_aidx_attr_out_9=est_aidx_attr_out((struct anonymous_4 *)attridx->db, id, vbuf, vsiz);
                if(return_value_est_aidx_attr_out_9 == 0)
                {
                  est_set_ecode(&db->ecode, 4, 2477);
                  db->fatal = 1;
                  err = 1;
                }

                goto __CPROVER_DUMP_L23;
              }

              signed int return_value_est_aidx_seq_out_10;
              return_value_est_aidx_seq_out_10=est_aidx_seq_out((struct anonymous_1 *)attridx->db, id);
              if(return_value_est_aidx_seq_out_10 == 0)
              {
                est_set_ecode(&db->ecode, 4, 2484);
                db->fatal = 1;
                err = 1;
              }

            }


          __CPROVER_DUMP_L23:
            ;
          }
          while((_Bool)1);
          cbmapiterinit(db->aidxs);
          do
          {
            kbuf=cbmapiternext(db->aidxs, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            vbuf=cbmapget(doc->attrs, kbuf, ksiz, &vsiz);
            if(!(vbuf == ((const char *)NULL)))
            {
              const char *return_value_cbmapiterval_11;
              return_value_cbmapiterval_11=cbmapiterval(kbuf, (signed int *)(void *)0);
              attridx = (struct anonymous_7 *)return_value_cbmapiterval_11;
              if(attridx->type == 1 || attridx->type == 2)
              {
                return_value_est_aidx_attr_put_12=est_aidx_attr_put((struct anonymous_4 *)attridx->db, id, vbuf, vsiz);
                if(return_value_est_aidx_attr_put_12 == 0)
                {
                  est_set_ecode(&db->ecode, 4, 2499);
                  db->fatal = 1;
                  err = 1;
                }

                goto __CPROVER_DUMP_L31;
              }

              signed int return_value_est_aidx_seq_put_13;
              return_value_est_aidx_seq_put_13=est_aidx_seq_put((struct anonymous_1 *)attridx->db, id, vbuf, vsiz);
              if(return_value_est_aidx_seq_put_13 == 0)
              {
                est_set_ecode(&db->ecode, 4, 2506);
                db->fatal = 1;
                err = 1;
              }

            }


          __CPROVER_DUMP_L31:
            ;
          }
          while((_Bool)1);
          est_doc_delete(odoc);
        }

      }

      text=est_db_get_doc_attr(db, id, "");
      if(!(text == ((char *)NULL)))
      {
        cbmapput(doc->attrs, "", 0, text, -1, 1);
        free((void *)text);
      }

      sbuf=cbmapdump(doc->attrs, &ssiz);
      signed int return_value_est_crput_15;
      return_value_est_crput_15=est_crput(db->attrdb, db->zmode, id, sbuf, ssiz, 0);
      if(return_value_est_crput_15 == 0)
      {
        est_set_ecode(&db->ecode, 4, 2521);
        db->fatal = 1;
        err = 1;
      }

      free((void *)sbuf);
      cbmapout(db->attrcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
      if(!(db->spacc == ((struct anonymous_5 *)NULL)))
        cbmapout(db->spacc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );

      return err != 0 ? 0 : 1;
    }
  }
}

// est_db_error
// file estraier.c line 1327
signed int est_db_error(struct anonymous_0 *db)
{
  return db->ecode;
}

// est_db_etch_doc
// file estraier.c line 4560
struct anonymous_5 * est_db_etch_doc(struct anonymous_0 *db, struct anonymous_14 *doc, signed int max)
{
  struct anonymous_31 *scores;
  struct anonymous_5 *keys;
  struct anonymous_5 *umap;
  struct anonymous_6 *words;
  const char *text;
  const char *word;
  const char *vbuf;
  const unsigned char *uword;
  char numbuf[32l];
  signed int i;
  signed int wsiz;
  signed int num;
  signed int smax;
  signed int snum;
  signed int vsiz;
  struct anonymous_5 *return_value_cbmapopenex_1;
  _Bool tmp_if_expr_4;
  signed int tmp_if_expr_5;
  const char *return_value_cbmapiternext_8;
  signed int tmp_if_expr_9;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_15;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_19;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_21;
  _Bool tmp_if_expr_20;
  _Bool tmp_if_expr_25;
  _Bool tmp_if_expr_22;
  _Bool tmp_if_expr_24;
  _Bool tmp_if_expr_23;
  _Bool tmp_if_expr_27;
  _Bool tmp_if_expr_26;
  _Bool tmp_if_expr_28;
  _Bool tmp_if_expr_30;
  _Bool tmp_if_expr_29;
  _Bool tmp_if_expr_32;
  _Bool tmp_if_expr_31;
  _Bool tmp_if_expr_34;
  _Bool tmp_if_expr_33;
  signed int return_value_cbmaprnum_38;
  _Bool tmp_if_expr_37;
  signed int tmp_if_expr_39;
  if(doc->dtexts == ((struct anonymous_6 *)NULL))
  {
    return_value_cbmapopenex_1=cbmapopenex(1);
    return return_value_cbmapopenex_1;
  }

  else
  {
    keys=cbmapopenex(max * 2 + 1);
    do
    {
      void *return_value_malloc_2;
      return_value_malloc_2=malloc(sizeof(struct anonymous_6) /*24ul*/ );
      words = (struct anonymous_6 *)return_value_malloc_2;
      if(!(words == ((struct anonymous_6 *)NULL)))
        words;

      else
        cbmyfatal("out of memory");
      words->anum = 64;
      void *return_value_malloc_3;
      return_value_malloc_3=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)words->anum);
      words->array = (struct anonymous_28 *)return_value_malloc_3;
      if(!(words->array == ((struct anonymous_28 *)NULL)))
        words->array;

      else
        cbmyfatal("out of memory");
      words->start = 0;
      words->num = 0;
    }
    while((_Bool)0);
    i = -1;
    for( ; !(i >= doc->dtexts->num); i = i + 1)
    {
      if(!(i >= 0))
      {
        if(doc->attrs == ((struct anonymous_5 *)NULL))
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          text=cbmapget(doc->attrs, "", 0, (signed int *)(void *)0);
          tmp_if_expr_4 = !(text != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
          goto __CPROVER_DUMP_L17;

      }

      else
        text = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
      if(!(db == ((struct anonymous_0 *)NULL)))
        switch(db->amode)
        {
          case 1024:
          {
            est_break_text_perfng(text, words, 0, 0);
            break;
          }
          case 2048:
          {
            est_break_text_chrcat(text, words, 0);
            break;
          }
          default:
            est_break_text(text, words, 0, 0);
        }

      else
        est_break_text(text, words, 0, 0);

    __CPROVER_DUMP_L17:
      ;
    }
    umap=cbmapopenex((signed int)words->num + 1);
    i = 0;
    for( ; !(i >= words->num); i = i + 1)
    {
      wsiz = (words->array + (signed long int)(words->start + i))->dsize;
      word = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
      if(!(wsiz >= 49))
      {
        vbuf=cbmapget(umap, word, wsiz, (signed int *)(void *)0);
        if(!(vbuf == ((const char *)NULL)))
          tmp_if_expr_5 = *((signed int *)vbuf) + 1;

        else
          tmp_if_expr_5 = 1;
        num = tmp_if_expr_5;
        cbmapput(umap, word, wsiz, (char *)&num, (signed int)sizeof(signed int) /*4ul*/ , 1);
      }

    }
    signed int return_value_cbmaprnum_6;
    return_value_cbmaprnum_6=cbmaprnum(umap);
    void *return_value_malloc_7;
    return_value_malloc_7=malloc((unsigned long int)return_value_cbmaprnum_6 * sizeof(struct anonymous_31) /*16ul*/  + (unsigned long int)1);
    scores = (struct anonymous_31 *)return_value_malloc_7;
    if(!(scores == ((struct anonymous_31 *)NULL)))
      scores;

    else
      cbmyfatal("out of memory");
    snum = 0;
    cbmapiterinit(umap);
    do
    {
      return_value_cbmapiternext_8=cbmapiternext(umap, &wsiz);
      uword = (unsigned char *)return_value_cbmapiternext_8;
      if(uword == ((const unsigned char *)NULL))
        break;

      (scores + (signed long int)snum)->word = (char *)uword;
      (scores + (signed long int)snum)->wsiz = wsiz;
      vbuf=cbmapiterval((char *)uword, (signed int *)(void *)0);
      if(!(vbuf == ((const char *)NULL)))
        tmp_if_expr_9 = *((signed int *)vbuf);

      else
        tmp_if_expr_9 = 0;
      (scores + (signed long int)snum)->pt = tmp_if_expr_9;
      if((signed int)*uword >= 0xe3)
      {
        if(!(wsiz >= 4))
        {
          (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 2;
          if((signed int)*uword == 0xe3)
          {
            if((signed int)uword[1l] == 0x80)
              tmp_if_expr_10 = (_Bool)1;

            else
              tmp_if_expr_10 = (signed int)uword[(signed long int)1] == 0x81 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_10)
              tmp_if_expr_12 = (_Bool)1;

            else
            {
              if((signed int)uword[1l] == 0x82)
                tmp_if_expr_11 = (signed int)uword[(signed long int)2] <= 0x9f ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_11 = (_Bool)0;
              tmp_if_expr_12 = tmp_if_expr_11 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_13 = tmp_if_expr_12 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_13 = (_Bool)0;
          if(tmp_if_expr_13)
            tmp_if_expr_15 = (_Bool)1;

          else
          {
            if((signed int)*uword == 0xef)
              tmp_if_expr_14 = (signed int)uword[(signed long int)1] >= 0xbc ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_14 = (_Bool)0;
            tmp_if_expr_15 = tmp_if_expr_14 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_15)
            (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 2;

        }

        else
        {
          if((signed int)*uword == 0xe3)
          {
            if((signed int)uword[1l] == 0x80)
              tmp_if_expr_16 = (_Bool)1;

            else
              tmp_if_expr_16 = (signed int)uword[(signed long int)1] == 0x81 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_16)
              tmp_if_expr_18 = (_Bool)1;

            else
            {
              if((signed int)uword[1l] == 0x82)
                tmp_if_expr_17 = (signed int)uword[(signed long int)2] <= 0x9f ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_17 = (_Bool)0;
              tmp_if_expr_18 = tmp_if_expr_17 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_19 = tmp_if_expr_18 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_19 = (_Bool)0;
          if(tmp_if_expr_19)
            tmp_if_expr_21 = (_Bool)1;

          else
          {
            if((signed int)*uword == 0xef)
              tmp_if_expr_20 = (signed int)uword[(signed long int)1] >= 0xbc ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_20 = (_Bool)0;
            tmp_if_expr_21 = tmp_if_expr_20 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_21)
            (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 2;

          if((signed int)uword[3l] == 0xe3)
          {
            if((signed int)uword[4l] == 0x80)
              tmp_if_expr_22 = (_Bool)1;

            else
              tmp_if_expr_22 = (signed int)uword[(signed long int)4] == 0x81 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_22)
              tmp_if_expr_24 = (_Bool)1;

            else
            {
              if((signed int)uword[4l] == 0x82)
                tmp_if_expr_23 = (signed int)uword[(signed long int)5] <= 0x9f ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_23 = (_Bool)0;
              tmp_if_expr_24 = tmp_if_expr_23 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_25 = tmp_if_expr_24 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_25 = (_Bool)0;
          if(tmp_if_expr_25)
            tmp_if_expr_27 = (_Bool)1;

          else
          {
            if((signed int)uword[3l] == 0xef)
              tmp_if_expr_26 = (signed int)uword[(signed long int)4] >= 0xbc ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_26 = (_Bool)0;
            tmp_if_expr_27 = tmp_if_expr_26 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_27)
            (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 2;

        }
      }

      else
      {
        if((signed int)*uword >= 1)
          tmp_if_expr_28 = (signed int)uword[(signed long int)0] <= 47 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_28 = (_Bool)0;
        if(tmp_if_expr_28)
          tmp_if_expr_30 = (_Bool)1;

        else
        {
          if((signed int)*uword >= 58)
            tmp_if_expr_29 = (signed int)uword[(signed long int)0] <= 64 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_29 = (_Bool)0;
          tmp_if_expr_30 = tmp_if_expr_29 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_30)
          tmp_if_expr_32 = (_Bool)1;

        else
        {
          if((signed int)*uword >= 91)
            tmp_if_expr_31 = (signed int)uword[(signed long int)0] <= 96 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_31 = (_Bool)0;
          tmp_if_expr_32 = tmp_if_expr_31 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_32)
          tmp_if_expr_34 = (_Bool)1;

        else
        {
          if((signed int)*uword >= 123)
            tmp_if_expr_33 = (signed int)uword[(signed long int)0] <= 126 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_33 = (_Bool)0;
          tmp_if_expr_34 = tmp_if_expr_33 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_34)
        {
          (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 25;
          if(!(wsiz >= 2))
            (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 2;

        }

        else
          switch(wsiz)
          {
            case 1:
            {
              (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 9;
              break;
            }
            case 2:
            {
              (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 5;
              break;
            }
            case 3:
            {
              (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 3;
              break;
            }
            case 4:
            {
              (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 2;
              break;
            }
            case 5:
            {
              (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / (signed int)1.5;
              break;
            }
            case 6:
              (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / (signed int)1.25;
          }
      }
      snum = snum + 1;
    }
    while((_Bool)1);
    qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_31) /*16ul*/ , est_keysc_compare);
    smax = max * (db != ((struct anonymous_0 *)NULL) ? 3 : 1) + 1;
    snum = snum > smax ? smax : snum;
    if(!(db == ((struct anonymous_0 *)NULL)))
    {
      i = 0;
      for( ; !(i >= snum); i = i + 1)
      {
        vbuf=cbmapget(db->keycc, (scores + (signed long int)i)->word, (scores + (signed long int)i)->wsiz, (signed int *)(void *)0);
        if(!(vbuf == ((const char *)NULL)))
        {
          cbmapmove(db->keycc, (scores + (signed long int)i)->word, (scores + (signed long int)i)->wsiz, 0);
          vsiz = *((signed int *)vbuf);
        }

        else
        {
          if(!(db->dfdb == ((struct anonymous_1 *)NULL)))
          {
            vsiz=dpgetwb(db->dfdb, (scores + (signed long int)i)->word, (scores + (signed long int)i)->wsiz, 0, 32 - 1, numbuf);
            if(vsiz >= 1)
            {
              numbuf[(signed long int)vsiz] = (char)0;
              vsiz=atoi(numbuf);
            }

            else
              vsiz = 0;
          }

          else
          {
            vsiz=est_idx_vsiz(db->idxdb, (scores + (signed long int)i)->word, (scores + (signed long int)i)->wsiz);
            const char *return_value_cbmapget_35;
            return_value_cbmapget_35=cbmapget(db->idxcc, (scores + (signed long int)i)->word, (scores + (signed long int)i)->wsiz, &num);
            if(!(return_value_cbmapget_35 == ((const char *)NULL)))
              vsiz = vsiz + num;

          }
          cbmapput(db->keycc, (scores + (signed long int)i)->word, (scores + (signed long int)i)->wsiz, (char *)&vsiz, (signed int)sizeof(signed int) /*4ul*/ , 0);
        }
        double return_value_pow_36;
        return_value_pow_36=pow((double)(vsiz + 64), 0.6);
        (scores + (signed long int)i)->pt = (scores + (signed long int)i)->pt * (signed int)(100000.0 / return_value_pow_36);
      }
      if(db->kcmnum >= 0)
      {
        return_value_cbmaprnum_38=cbmaprnum(db->keycc);
        if(!(db->kcmnum >= return_value_cbmaprnum_38))
        {
          num = (signed int)((double)db->kcmnum * 0.1 + (double)1);
          cbmapiterinit(db->keycc);
          i = 0;
          do
          {
            if(!(i >= num))
            {
              word=cbmapiternext(db->keycc, &wsiz);
              tmp_if_expr_37 = word != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_37 = (_Bool)0;
            if(!tmp_if_expr_37)
              break;

            cbmapout(db->keycc, word, wsiz);
            i = i + 1;
          }
          while((_Bool)1);
        }

      }

      qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_31) /*16ul*/ , est_keysc_compare);
    }

    i = 0;
    for( ; !(i >= snum) && !(i >= max); i = i + 1)
    {
      if((scores + (signed long int)i)->pt >= 1)
        tmp_if_expr_39 = (scores + (signed long int)i)->pt;

      else
        tmp_if_expr_39 = 1;
      vsiz=sprintf(numbuf, "%d", tmp_if_expr_39);
      cbmapput(keys, (scores + (signed long int)i)->word, (scores + (signed long int)i)->wsiz, numbuf, vsiz, 0);
    }
    free((void *)scores);
    cbmapclose(umap);
    do
    {
      signed int _CB_i;
      signed int _CB_end = words->start + words->num;
      _CB_i = words->start;
      for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
        free((void *)(words->array + (signed long int)_CB_i)->dptr);
      free((void *)words->array);
      free((void *)words);
    }
    while((_Bool)0);
    return keys;
  }
}

// est_db_fatal
// file estraier.c line 1334
signed int est_db_fatal(struct anonymous_0 *db)
{
  return db->fatal;
}

// est_db_fill_key_cache
// file estraier.c line 4994
void est_db_fill_key_cache(struct anonymous_0 *db)
{
  const char *kbuf;
  char *msg;
  signed int i;
  signed int ksiz;
  signed int vsiz;
  vlcurfirst(db->fwmdb);
  i = 0;
  do
  {
    kbuf=vlcurkeycache(db->fwmdb, &ksiz);
    if(kbuf == ((const char *)NULL))
      break;

    vsiz=est_idx_vsiz(db->idxdb, kbuf, ksiz);
    cbmapput(db->keycc, kbuf, ksiz, (char *)&vsiz, (signed int)sizeof(signed int) /*4ul*/ , 1);
    vlcurnext(db->fwmdb);
    if(i % 10000 == 0)
    {
      msg=cbsprintf("filling the key cache for TF-IDF (%d)", i + 1);
      est_db_inform(db, msg);
      free((void *)msg);
    }

    i = i + 1;
  }
  while((_Bool)1);
  db->kcmnum = -1;
}

// est_db_flush
// file estraier.c line 1468
signed int est_db_flush(struct anonymous_0 *db, signed int max)
{
  struct anonymous_7 *attridx;
  struct anonymous_5 *ids;
  struct anonymous_6 *keys;
  struct anonymous_9 *nval;
  const char *kbuf;
  const char *vbuf;
  const char *rp;
  const char *pv;
  const char *ep;
  char *tbuf;
  char *wp;
  char numbuf[32l];
  signed int i;
  signed int j;
  signed int inc;
  signed int err;
  signed int ksiz;
  signed int vsiz;
  signed int rnum;
  signed int len;
  signed int id;
  signed int sum;
  signed int cid;
  signed int vnum;
  signed int lid;
  signed int dnum;
  signed int tsiz;
  signed int vstep;
  signed int return_value_dpwritable_1;
  return_value_dpwritable_1=dpwritable(db->metadb);
  signed int return_value_vlmemflush_9;
  signed int return_value_cbmaprnum_12;
  signed int return_value_cbmaprnum_11;
  _Bool tmp_if_expr_23;
  signed int return_value_vlput_20;
  _Bool tmp_if_expr_22;
  signed int *return_value_dpecodeptr_21;
  signed int return_value_cbmaprnum_55;
  signed int *return_value_dpecodeptr_43;
  signed int return_value_vlout_52;
  signed int *return_value_dpecodeptr_51;
  _Bool tmp_if_expr_57;
  signed int return_value_est_idx_size_current_56;
  if(return_value_dpwritable_1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 1478);
    return 0;
  }

  else
  {
    if(max >= 0x7fffffff || !(max >= 1))
    {
      signed int return_value_est_db_write_meta_2;
      return_value_est_db_write_meta_2=est_db_write_meta(db);
      if(return_value_est_db_write_meta_2 == 0)
        err = 1;

      signed int return_value_dpmemflush_3;
      return_value_dpmemflush_3=dpmemflush(db->metadb);
      if(return_value_dpmemflush_3 == 0)
        err = 1;

      signed int return_value_crmemflush_4;
      return_value_crmemflush_4=crmemflush(db->attrdb);
      if(return_value_crmemflush_4 == 0)
        err = 1;

      signed int return_value_crmemflush_5;
      return_value_crmemflush_5=crmemflush(db->textdb);
      if(return_value_crmemflush_5 == 0)
        err = 1;

      signed int return_value_crmemflush_6;
      return_value_crmemflush_6=crmemflush(db->kwddb);
      if(return_value_crmemflush_6 == 0)
        err = 1;

      signed int return_value_vlmemflush_7;
      return_value_vlmemflush_7=vlmemflush(db->listdb);
      if(return_value_vlmemflush_7 == 0)
        err = 1;

      cbmapiterinit(db->aidxs);
      do
      {
        kbuf=cbmapiternext(db->aidxs, (signed int *)(void *)0);
        if(kbuf == ((const char *)NULL))
          break;

        const char *return_value_cbmapiterval_8;
        return_value_cbmapiterval_8=cbmapiterval(kbuf, (signed int *)(void *)0);
        attridx = (struct anonymous_7 *)return_value_cbmapiterval_8;
        if(attridx->type == 1 || attridx->type == 2)
        {
          return_value_vlmemflush_9=vlmemflush((struct anonymous_4 *)attridx->db);
          if(return_value_vlmemflush_9 == 0)
            err = 1;

          goto __CPROVER_DUMP_L13;
        }

        signed int return_value_dpmemflush_10;
        return_value_dpmemflush_10=dpmemflush((struct anonymous_1 *)attridx->db);
        if(return_value_dpmemflush_10 == 0)
          err = 1;


      __CPROVER_DUMP_L13:
        ;
      }
      while((_Bool)1);
    }

    signed int return_value_cbmaprnum_13;
    return_value_cbmaprnum_13=cbmaprnum(db->idxcc);
    if(!(return_value_cbmaprnum_13 >= 1))
    {
      return_value_cbmaprnum_12=cbmaprnum(db->auxcc);
      if(return_value_cbmaprnum_12 >= 1)
        goto __CPROVER_DUMP_L16;

      return_value_cbmaprnum_11=cbmaprnum(db->outcc);
      if(return_value_cbmaprnum_11 >= 1)
        goto __CPROVER_DUMP_L16;

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L16:
      ;
      db->flsflag = 1;
      db->intflag = 0;
      signed int return_value_est_db_used_cache_size_14;
      return_value_est_db_used_cache_size_14=est_db_used_cache_size(db);
      inc = (signed int)((unsigned long int)return_value_est_db_used_cache_size_14 > db->icmax);
      err = 0;
      do
      {
        void *return_value_malloc_15;
        return_value_malloc_15=malloc(sizeof(struct anonymous_6) /*24ul*/ );
        keys = (struct anonymous_6 *)return_value_malloc_15;
        if(!(keys == ((struct anonymous_6 *)NULL)))
          keys;

        else
          cbmyfatal("out of memory");
        keys->anum = 64;
        void *return_value_malloc_16;
        return_value_malloc_16=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)keys->anum);
        keys->array = (struct anonymous_28 *)return_value_malloc_16;
        if(!(keys->array == ((struct anonymous_28 *)NULL)))
          keys->array;

        else
          cbmyfatal("out of memory");
        keys->start = 0;
        keys->num = 0;
      }
      while((_Bool)0);
      cbmapiterinit(db->idxcc);
      do
      {
        kbuf=cbmapiternext(db->idxcc, &ksiz);
        if(kbuf == ((const char *)NULL))
          break;

        do
        {
          signed int _CB_index = keys->start + keys->num;
          if(_CB_index >= keys->anum)
          {
            keys->anum = keys->anum * 2;
            void *return_value_realloc_17;
            return_value_realloc_17=realloc((void *)keys->array, (unsigned long int)keys->anum * sizeof(struct anonymous_28) /*16ul*/ );
            keys->array = (struct anonymous_28 *)return_value_realloc_17;
            if(!(keys->array == ((struct anonymous_28 *)NULL)))
              keys->array;

            else
              cbmyfatal("out of memory");
          }

          void *return_value_malloc_18;
          return_value_malloc_18=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
          (keys->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_18;
          if(!((keys->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
            (keys->array + (signed long int)_CB_index)->dptr;

          else
            cbmyfatal("out of memory");
          memcpy((void *)(keys->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
          (keys->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
          (keys->array + (signed long int)_CB_index)->dsize = ksiz;
          keys->num = keys->num + 1;
        }
        while((_Bool)0);
      }
      while((_Bool)1);
      rnum = (signed int)keys->num;
      cblistsort(keys);
      if(max >= 1)
        while(!(max >= keys->num))
          do
            if(keys->num >= 1)
            {
              free((void *)(keys->array + (signed long int)((keys->start + keys->num) - 1))->dptr);
              keys->num = keys->num - 1;
            }

          while((_Bool)0);

      i = 0;
      for( ; !(i >= keys->num); i = i + 1)
      {
        ksiz = (keys->array + (signed long int)(keys->start + i))->dsize;
        kbuf = (const char *)(keys->array + (signed long int)(keys->start + i))->dptr;
        vbuf=cbmapget(db->idxcc, kbuf, ksiz, &vsiz);
        signed int return_value_est_idx_add_19;
        return_value_est_idx_add_19=est_idx_add(db->idxdb, kbuf, ksiz, vbuf, vsiz, db->smode);
        if(return_value_est_idx_add_19 == 0)
          tmp_if_expr_23 = (_Bool)1;

        else
        {
          return_value_vlput_20=vlput(db->fwmdb, kbuf, ksiz, "", 0, 1);
          if(return_value_vlput_20 == 0)
          {
            return_value_dpecodeptr_21=dpecodeptr();
            tmp_if_expr_22 = *return_value_dpecodeptr_21 != 4 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_22 = (_Bool)0;
          tmp_if_expr_23 = tmp_if_expr_22 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_23)
        {
          err = 1;
          break;
        }

        cbmapout(db->idxcc, kbuf, ksiz);
        db->icsiz = db->icsiz - (unsigned long int)vsiz;
        if(i % 10000 == 0)
        {
          est_db_inform(db, "flushing index words");
          signed int return_value_est_idx_size_current_24;
          return_value_est_idx_size_current_24=est_idx_size_current(db->idxdb);
          if(return_value_est_idx_size_current_24 >= 1536)
          {
            est_db_inform(db, "adding a new database file");
            est_idx_increment(db->idxdb);
            inc = 0;
          }

        }

        if(max >= 1)
        {
          if(!(db->intflag == 0))
          {
            if(i >= 1)
            {
              if(i % 256 == 0)
                break;

            }

          }

        }

      }
      do
      {
        signed int _CB_i;
        signed int _CB_end = keys->start + keys->num;
        _CB_i = keys->start;
        for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
          free((void *)(keys->array + (signed long int)_CB_i)->dptr);
        free((void *)keys->array);
        free((void *)keys);
      }
      while((_Bool)0);
      signed int return_value_cbmaprnum_34;
      return_value_cbmaprnum_34=cbmaprnum(db->idxcc);
      if(!(return_value_cbmaprnum_34 >= 1))
      {
        cbmapclose(db->idxcc);
        db->idxcc=cbmapopenex((signed int)(rnum > 524288 ? (double)rnum * 1.5 : (double)524288));
        signed int return_value_cbmaprnum_33;
        return_value_cbmaprnum_33=cbmaprnum(db->auxcc);
        if(return_value_cbmaprnum_33 >= 1)
        {
          do
          {
            void *return_value_malloc_25;
            return_value_malloc_25=malloc(sizeof(struct anonymous_6) /*24ul*/ );
            keys = (struct anonymous_6 *)return_value_malloc_25;
            if(!(keys == ((struct anonymous_6 *)NULL)))
              keys;

            else
              cbmyfatal("out of memory");
            keys->anum = 64;
            void *return_value_malloc_26;
            return_value_malloc_26=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)keys->anum);
            keys->array = (struct anonymous_28 *)return_value_malloc_26;
            if(!(keys->array == ((struct anonymous_28 *)NULL)))
              keys->array;

            else
              cbmyfatal("out of memory");
            keys->start = 0;
            keys->num = 0;
          }
          while((_Bool)0);
          cbmapiterinit(db->auxcc);
          do
          {
            kbuf=cbmapiternext(db->auxcc, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            do
            {
              signed int est_db_flush__1__8__1__2__1___CB_index = keys->start + keys->num;
              if(est_db_flush__1__8__1__2__1___CB_index >= keys->anum)
              {
                keys->anum = keys->anum * 2;
                void *return_value_realloc_27;
                return_value_realloc_27=realloc((void *)keys->array, (unsigned long int)keys->anum * sizeof(struct anonymous_28) /*16ul*/ );
                keys->array = (struct anonymous_28 *)return_value_realloc_27;
                if(!(keys->array == ((struct anonymous_28 *)NULL)))
                  keys->array;

                else
                  cbmyfatal("out of memory");
              }

              void *return_value_malloc_28;
              return_value_malloc_28=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
              (keys->array + (signed long int)est_db_flush__1__8__1__2__1___CB_index)->dptr = (char *)return_value_malloc_28;
              if(!((keys->array + (signed long int)est_db_flush__1__8__1__2__1___CB_index)->dptr == ((char *)NULL)))
                (keys->array + (signed long int)est_db_flush__1__8__1__2__1___CB_index)->dptr;

              else
                cbmyfatal("out of memory");
              memcpy((void *)(keys->array + (signed long int)est_db_flush__1__8__1__2__1___CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
              (keys->array + (signed long int)est_db_flush__1__8__1__2__1___CB_index)->dptr[(signed long int)ksiz] = (char)0;
              (keys->array + (signed long int)est_db_flush__1__8__1__2__1___CB_index)->dsize = ksiz;
              keys->num = keys->num + 1;
            }
            while((_Bool)0);
          }
          while((_Bool)1);
          cblistsort(keys);
          i = 0;
          for( ; !(i >= keys->num); i = i + 1)
          {
            ksiz = (keys->array + (signed long int)(keys->start + i))->dsize;
            kbuf = (const char *)(keys->array + (signed long int)(keys->start + i))->dptr;
            vbuf=cbmapget(db->auxcc, kbuf, ksiz, &vsiz);
            signed int return_value_vlput_29;
            return_value_vlput_29=vlput(db->auxdb, kbuf, ksiz, vbuf, vsiz, 2);
            if(return_value_vlput_29 == 0)
            {
              err = 1;
              break;
            }

            signed int return_value_vlvsiz_30;
            return_value_vlvsiz_30=vlvsiz(db->auxdb, kbuf, ksiz);
            len=sprintf(numbuf, "%d", return_value_vlvsiz_30 / (signed int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2));
            signed int return_value_vlput_31;
            return_value_vlput_31=vlput(db->xfmdb, kbuf, ksiz, numbuf, len, 0);
            if(return_value_vlput_31 == 0)
            {
              err = 1;
              break;
            }

            cbmapout(db->auxcc, kbuf, ksiz);
            db->icsiz = db->icsiz - (unsigned long int)vsiz;
            if(i % 10000 == 0)
              est_db_inform(db, "flushing auxiliary keywords");

            if(max >= 1)
            {
              if(!(db->intflag == 0))
              {
                if(i >= 1)
                {
                  if(i % 256 == 0)
                    break;

                }

              }

            }

          }
          do
          {
            signed int est_db_flush__1__8__1__4___CB_i;
            signed int est_db_flush__1__8__1__4___CB_end = keys->start + keys->num;
            est_db_flush__1__8__1__4___CB_i = keys->start;
            for( ; !(est_db_flush__1__8__1__4___CB_i >= est_db_flush__1__8__1__4___CB_end); est_db_flush__1__8__1__4___CB_i = est_db_flush__1__8__1__4___CB_i + 1)
              free((void *)(keys->array + (signed long int)est_db_flush__1__8__1__4___CB_i)->dptr);
            free((void *)keys->array);
            free((void *)keys);
          }
          while((_Bool)0);
          signed int return_value_cbmaprnum_32;
          return_value_cbmaprnum_32=cbmaprnum(db->auxcc);
          if(!(return_value_cbmaprnum_32 >= 1))
          {
            cbmapclose(db->auxcc);
            db->auxcc=cbmapopenex(65521);
          }

        }

      }

      if(!(max >= 1))
      {
        return_value_cbmaprnum_55=cbmaprnum(db->outcc);
        if(return_value_cbmaprnum_55 >= 1)
        {
          ids=cbmapopen();
          do
          {
            void *return_value_malloc_35;
            return_value_malloc_35=malloc(sizeof(struct anonymous_6) /*24ul*/ );
            keys = (struct anonymous_6 *)return_value_malloc_35;
            if(!(keys == ((struct anonymous_6 *)NULL)))
              keys;

            else
              cbmyfatal("out of memory");
            keys->anum = 64;
            void *return_value_malloc_36;
            return_value_malloc_36=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)keys->anum);
            keys->array = (struct anonymous_28 *)return_value_malloc_36;
            if(!(keys->array == ((struct anonymous_28 *)NULL)))
              keys->array;

            else
              cbmyfatal("out of memory");
            keys->start = 0;
            keys->num = 0;
          }
          while((_Bool)0);
          cbmapiterinit(db->outcc);
          do
          {
            kbuf=cbmapiternext(db->outcc, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            if((signed int)*kbuf == 9)
            {
              id=atoi(kbuf + (signed long int)1);
              cbmapput(ids, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , "", 0, 0);
            }

            else
              do
              {
                signed int est_db_flush__1__9__2__2__1___CB_index = keys->start + keys->num;
                if(est_db_flush__1__9__2__2__1___CB_index >= keys->anum)
                {
                  keys->anum = keys->anum * 2;
                  void *return_value_realloc_37;
                  return_value_realloc_37=realloc((void *)keys->array, (unsigned long int)keys->anum * sizeof(struct anonymous_28) /*16ul*/ );
                  keys->array = (struct anonymous_28 *)return_value_realloc_37;
                  if(!(keys->array == ((struct anonymous_28 *)NULL)))
                    keys->array;

                  else
                    cbmyfatal("out of memory");
                }

                void *return_value_malloc_38;
                return_value_malloc_38=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
                (keys->array + (signed long int)est_db_flush__1__9__2__2__1___CB_index)->dptr = (char *)return_value_malloc_38;
                if(!((keys->array + (signed long int)est_db_flush__1__9__2__2__1___CB_index)->dptr == ((char *)NULL)))
                  (keys->array + (signed long int)est_db_flush__1__9__2__2__1___CB_index)->dptr;

                else
                  cbmyfatal("out of memory");
                memcpy((void *)(keys->array + (signed long int)est_db_flush__1__9__2__2__1___CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
                (keys->array + (signed long int)est_db_flush__1__9__2__2__1___CB_index)->dptr[(signed long int)ksiz] = (char)0;
                (keys->array + (signed long int)est_db_flush__1__9__2__2__1___CB_index)->dsize = ksiz;
                keys->num = keys->num + 1;
              }
              while((_Bool)0);
          }
          while((_Bool)1);
          cblistsort(keys);
          dnum=est_idx_dnum(db->idxdb);
          i = 0;
          for( ; !(i >= keys->num); i = i + 1)
          {
            ksiz = (keys->array + (signed long int)(keys->start + i))->dsize;
            kbuf = (const char *)(keys->array + (signed long int)(keys->start + i))->dptr;
            if((signed int)*kbuf == 32)
            {
              tbuf=vlget(db->auxdb, kbuf + (signed long int)1, ksiz - 1, &tsiz);
              if(!(tbuf == ((char *)NULL)))
              {
                rp = tbuf;
                wp = tbuf;
                ep = tbuf + (signed long int)tsiz;
                while(!(rp >= ep))
                {
                  const char *return_value_cbmapget_39;
                  return_value_cbmapget_39=cbmapget(ids, rp, (signed int)sizeof(signed int) /*4ul*/ , (signed int *)(void *)0);
                  if(return_value_cbmapget_39 == ((const char *)NULL))
                  {
                    memmove((void *)wp, (const void *)rp, sizeof(signed int) /*4ul*/  * (unsigned long int)2);
                    wp = wp + (signed long int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2);
                  }

                  rp = rp + (signed long int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2);
                }
                if(!(tbuf >= wp))
                {
                  signed int return_value_vlput_40;
                  return_value_vlput_40=vlput(db->auxdb, kbuf + (signed long int)1, ksiz - 1, tbuf, (signed int)(wp - tbuf), 0);
                  if(return_value_vlput_40 == 0)
                    err = 1;

                  len=sprintf(numbuf, "%d", (signed int)((unsigned long int)(wp - tbuf) / (sizeof(signed int) /*4ul*/  * (unsigned long int)2)));
                  signed int return_value_vlput_41;
                  return_value_vlput_41=vlput(db->xfmdb, kbuf + (signed long int)1, ksiz - 1, numbuf, len, 0);
                  if(return_value_vlput_41 == 0)
                    err = 1;

                }

                else
                {
                  signed int return_value_vlout_42;
                  return_value_vlout_42=vlout(db->auxdb, kbuf + (signed long int)1, ksiz - 1);
                  if(return_value_vlout_42 == 0)
                    err = 1;

                  signed int return_value_vlout_44;
                  return_value_vlout_44=vlout(db->xfmdb, kbuf + (signed long int)1, ksiz - 1);
                  if(return_value_vlout_44 == 0)
                  {
                    return_value_dpecodeptr_43=dpecodeptr();
                    if(!(*return_value_dpecodeptr_43 == 5))
                      err = 1;

                  }

                }
                free((void *)tbuf);
              }

            }

            else
            {
              sum = 0;
              j = 0;
              for( ; !(j >= dnum); j = j + 1)
              {
                vbuf=est_idx_get_one(db->idxdb, j, kbuf, ksiz, &tsiz);
                if(!(vbuf == ((const char *)NULL)))
                {
                  do
                  {
                    void *return_value_malloc_45;
                    return_value_malloc_45=malloc(sizeof(struct anonymous_9) /*16ul*/ );
                    nval = (struct anonymous_9 *)return_value_malloc_45;
                    if(!(nval == ((struct anonymous_9 *)NULL)))
                      nval;

                    else
                      cbmyfatal("out of memory");
                    void *return_value_malloc_46;
                    return_value_malloc_46=malloc((unsigned long int)12);
                    nval->dptr = (char *)return_value_malloc_46;
                    if(!(nval->dptr == ((char *)NULL)))
                      nval->dptr;

                    else
                      cbmyfatal("out of memory");
                    nval->dptr[(signed long int)0] = (char)0;
                    nval->dsize = 0;
                    nval->asize = 12;
                  }
                  while((_Bool)0);
                  rp = vbuf;
                  ep = vbuf + (signed long int)tsiz;
                  lid = 0;
                  cid = 0;
                  while(!(rp >= ep))
                  {
                    do
                    {
                      signed int _EST_i;
                      signed int _EST_base;
                      vnum = 0;
                      _EST_base = 1;
                      _EST_i = 0;
                      for( ; (_Bool)1; _EST_i = _EST_i + 1)
                      {
                        if((signed int)rp[(signed long int)_EST_i] >= 0)
                        {
                          vnum = vnum + (signed int)((signed char *)rp)[(signed long int)_EST_i] * _EST_base;
                          break;
                        }

                        vnum = vnum + _EST_base * ((signed int)((signed char *)rp)[(signed long int)_EST_i] + 1) * -1;
                        _EST_base = _EST_base * 128;
                      }
                      vstep = _EST_i + 1;
                    }
                    while((_Bool)0);
                    cid = cid + vnum + 1;
                    rp = rp + (signed long int)vstep;
                    pv = rp;
                    if(!(db->smode == 1048576))
                    {
                      if(db->smode == 2097152 || db->smode == 4194304)
                        goto __CPROVER_DUMP_L109;

                    }

                    else
                      goto __CPROVER_DUMP_L110;
                    rp = rp + 1l;
                    goto __CPROVER_DUMP_L110;

                  __CPROVER_DUMP_L109:
                    ;
                    rp = rp + (signed long int)sizeof(signed int) /*4ul*/ ;

                  __CPROVER_DUMP_L110:
                    ;
                    for( ; !((signed int)*rp == 0x0); rp = rp + (signed long int)2)
                      ;
                    rp = rp + 1l;
                    const char *return_value_cbmapget_49;
                    return_value_cbmapget_49=cbmapget(ids, (char *)&cid, (signed int)sizeof(signed int) /*4ul*/ , (signed int *)(void *)0);
                    if(return_value_cbmapget_49 == ((const char *)NULL))
                    {
                      do
                      {
                        signed int _EST_num = (cid - lid) - 1;
                        struct anonymous_10 EST_d;
                        if(_EST_num == 0)
                        {
                          ((signed char *)numbuf)[(signed long int)0] = (signed char)0;
                          vstep = 1;
                        }

                        else
                        {
                          vstep = 0;
                          for( ; _EST_num >= 1; vstep = vstep + 1)
                          {
                            EST_d=div(_EST_num, 128);
                            _EST_num = EST_d.quot;
                            if(_EST_num >= 1)
                              ((signed char *)numbuf)[(signed long int)vstep] = (signed char)(-EST_d.rem - 1);

                            else
                              ((signed char *)numbuf)[(signed long int)vstep] = (signed char)EST_d.rem;
                          }
                        }
                      }
                      while((_Bool)0);
                      do
                      {
                        if(nval->dsize + vstep >= nval->asize)
                        {
                          nval->asize = nval->asize * 2 + vstep + 1;
                          void *return_value_realloc_47;
                          return_value_realloc_47=realloc((void *)nval->dptr, (unsigned long int)nval->asize);
                          nval->dptr = (char *)return_value_realloc_47;
                          if(!(nval->dptr == ((char *)NULL)))
                            nval->dptr;

                          else
                            cbmyfatal("out of memory");
                        }

                        memcpy((void *)(nval->dptr + (signed long int)nval->dsize), (const void *)numbuf, (unsigned long int)vstep);
                        nval->dsize = nval->dsize + vstep;
                        nval->dptr[(signed long int)nval->dsize] = (char)0;
                      }
                      while((_Bool)0);
                      do
                      {
                        if((rp - pv) + (signed long int)nval->dsize >= (signed long int)nval->asize)
                        {
                          nval->asize = (signed int)((signed long int)(nval->asize * 2) + (rp - pv) + (signed long int)1);
                          void *return_value_realloc_48;
                          return_value_realloc_48=realloc((void *)nval->dptr, (unsigned long int)nval->asize);
                          nval->dptr = (char *)return_value_realloc_48;
                          if(!(nval->dptr == ((char *)NULL)))
                            nval->dptr;

                          else
                            cbmyfatal("out of memory");
                        }

                        memcpy((void *)(nval->dptr + (signed long int)nval->dsize), (const void *)pv, (unsigned long int)(rp - pv));
                        nval->dsize = nval->dsize + (signed int)(rp - pv);
                        nval->dptr[(signed long int)nval->dsize] = (char)0;
                      }
                      while((_Bool)0);
                      lid = cid;
                    }

                  }
                  signed int return_value_est_idx_put_one_50;
                  return_value_est_idx_put_one_50=est_idx_put_one(db->idxdb, j, kbuf, ksiz, (const char *)nval->dptr, (signed int)nval->dsize);
                  if(return_value_est_idx_put_one_50 == 0)
                    err = 1;

                  sum = sum + (signed int)nval->dsize;
                  do
                  {
                    free((void *)nval->dptr);
                    free((void *)nval);
                  }
                  while((_Bool)0);
                }

              }
              if(!(sum >= 1))
              {
                return_value_vlout_52=vlout(db->fwmdb, kbuf, ksiz);
                if(return_value_vlout_52 == 0)
                {
                  return_value_dpecodeptr_51=dpecodeptr();
                  if(!(*return_value_dpecodeptr_51 == 5))
                    err = 1;

                }

              }

            }
            cbmapout(db->outcc, kbuf, ksiz);
            if(i % 10000 == 0)
              est_db_inform(db, "cleaning dispensable keys");

            if(max >= 1)
            {
              if(!(db->intflag == 0))
              {
                if(i >= 1)
                {
                  if(i % 256 == 0)
                    break;

                }

              }

            }

          }
          signed int return_value_cbmaprnum_53;
          return_value_cbmaprnum_53=cbmaprnum(db->outcc);
          signed int return_value_cbmaprnum_54;
          return_value_cbmaprnum_54=cbmaprnum(ids);
          if(return_value_cbmaprnum_54 >= return_value_cbmaprnum_53)
          {
            cbmapclose(db->outcc);
            db->outcc=cbmapopenex(131072);
          }

          do
          {
            signed int est_db_flush__1__9__5___CB_i;
            signed int est_db_flush__1__9__5___CB_end = keys->start + keys->num;
            est_db_flush__1__9__5___CB_i = keys->start;
            for( ; !(est_db_flush__1__9__5___CB_i >= est_db_flush__1__9__5___CB_end); est_db_flush__1__9__5___CB_i = est_db_flush__1__9__5___CB_i + 1)
              free((void *)(keys->array + (signed long int)est_db_flush__1__9__5___CB_i)->dptr);
            free((void *)keys->array);
            free((void *)keys);
          }
          while((_Bool)0);
          cbmapclose(ids);
        }

      }

      cbmapclose(db->keycc);
      db->keycc=cbmapopenex(65536 + 1);
      db->kcmnum = 65536;
      if(max >= 1)
        tmp_if_expr_57 = db->intflag != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_57 = (_Bool)0;
      if(!tmp_if_expr_57)
      {
        if(!(inc == 0))
        {
          return_value_est_idx_size_current_56=est_idx_size_current(db->idxdb);
          if(return_value_est_idx_size_current_56 >= 512)
          {
            est_db_inform(db, "adding a new database file");
            est_idx_increment(db->idxdb);
          }

        }

      }

      if(max >= 0x7fffffff || !(max >= 1))
      {
        signed int return_value_vlmemflush_58;
        return_value_vlmemflush_58=vlmemflush(db->auxdb);
        if(return_value_vlmemflush_58 == 0)
          err = 1;

        signed int return_value_est_idx_memflush_59;
        return_value_est_idx_memflush_59=est_idx_memflush(db->idxdb);
        if(return_value_est_idx_memflush_59 == 0)
          err = 1;

      }

      if(max >= 1)
      {
        if(!(db->intflag == 0))
          est_db_inform(db, "flushing interrupted");

      }

      db->flsflag = 0;
      db->intflag = 0;
      if(!(err == 0))
      {
        est_set_ecode(&db->ecode, 4, 1683);
        db->fatal = 1;
        return 0;
      }

      else
        return 1;
    }
  }
}

// est_db_get_doc
// file estraier.c line 2533
struct anonymous_14 * est_db_get_doc(struct anonymous_0 *db, signed int id, signed int options)
{
  struct anonymous_14 *doc;
  const char *cbuf;
  char *vbuf;
  char numbuf[32l];
  signed int i;
  signed int csiz;
  signed int vsiz;
  signed int num;
  if(id >= 2000000001)
  {
    num = id - 2000000001;
    if(num >= db->pdocs->num)
    {
      est_set_ecode(&db->ecode, 6, 2541);
      return (struct anonymous_14 *)(void *)0;
    }

    vbuf=cbreadfile((const char *)(db->pdocs->array + (signed long int)(db->pdocs->start + num))->dptr, (signed int *)(void *)0);
    if(!(vbuf == ((char *)NULL)))
    {
      doc=est_doc_new_from_draft(vbuf);
      free((void *)vbuf);
    }

    else
      doc=est_doc_new();
    doc->id = id;
    sprintf(numbuf, "%d", id);
    est_doc_add_attr(doc, "@id", numbuf);
    const char *return_value_est_doc_attr_1;
    return_value_est_doc_attr_1=est_doc_attr(doc, "@uri");
    if(return_value_est_doc_attr_1 == ((const char *)NULL))
      est_doc_add_attr(doc, "@uri", (const char *)(db->pdocs->array + (signed long int)(db->pdocs->start + num))->dptr);

    return doc;
  }

  cbuf = (const char *)(void *)0;
  if(!((1 & options) == 0))
  {
    signed int return_value_crvsiz_3;
    return_value_crvsiz_3=crvsiz(db->attrdb, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
    if(return_value_crvsiz_3 == -1)
    {
      signed int *return_value_dpecodeptr_2;
      return_value_dpecodeptr_2=dpecodeptr();
      if(*return_value_dpecodeptr_2 == 5)
      {
        est_set_ecode(&db->ecode, 6, 2561);
        return (struct anonymous_14 *)(void *)0;
      }

      else
      {
        est_set_ecode(&db->ecode, 4, 2564);
        db->fatal = 1;
        return (struct anonymous_14 *)(void *)0;
      }
    }

    vbuf = (char *)(void *)0;
  }

  else
  {
    cbuf=cbmapget(db->attrcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , &csiz);
    if(!(cbuf == ((const char *)NULL)))
    {
      cbmapmove(db->attrcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0);
      vbuf = (char *)(void *)0;
    }

    else
    {
      vbuf=est_crget(db->attrdb, db->zmode, id, &vsiz);
      if(vbuf == ((char *)NULL))
      {
        signed int *return_value_dpecodeptr_4;
        return_value_dpecodeptr_4=dpecodeptr();
        if(*return_value_dpecodeptr_4 == 5)
        {
          est_set_ecode(&db->ecode, 6, 2575);
          return (struct anonymous_14 *)(void *)0;
        }

        else
        {
          est_set_ecode(&db->ecode, 4, 2578);
          db->fatal = 1;
          return (struct anonymous_14 *)(void *)0;
        }
      }

    }
  }
  doc=est_doc_new();
  doc->id = id;
  _Bool tmp_if_expr_6;
  if(!(cbuf == ((const char *)NULL)))
    doc->attrs=cbmapload(cbuf, csiz);

  else
    if(!(vbuf == ((char *)NULL)))
    {
      doc->attrs=cbmapload(vbuf, vsiz);
      if(db->acmnum >= 1)
        cbmapput(db->attrcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, 1);

      free((void *)vbuf);
      signed int return_value_cbmaprnum_7;
      return_value_cbmaprnum_7=cbmaprnum(db->attrcc);
      if(!(db->acmnum >= return_value_cbmaprnum_7))
      {
        signed int return_value_cbmaprnum_5;
        return_value_cbmaprnum_5=cbmaprnum(db->attrcc);
        num = (signed int)((double)return_value_cbmaprnum_5 * 0.1 + (double)1);
        cbmapiterinit(db->attrcc);
        i = 0;
        do
        {
          if(!(i >= num))
          {
            cbuf=cbmapiternext(db->attrcc, (signed int *)(void *)0);
            tmp_if_expr_6 = cbuf != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_6 = (_Bool)0;
          if(!tmp_if_expr_6)
            break;

          cbmapout(db->attrcc, cbuf, (signed int)sizeof(signed int) /*4ul*/ );
          i = i + 1;
        }
        while((_Bool)1);
      }

    }

    else
      doc->attrs = (struct anonymous_5 *)(void *)0;
  _Bool tmp_if_expr_9;
  if((2 & options) == 0)
  {
    cbuf=cbmapget(db->textcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , &csiz);
    if(!(cbuf == ((const char *)NULL)))
    {
      cbmapmove(db->textcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0);
      doc->dtexts=cblistload(cbuf, csiz);
    }

    else
    {
      vbuf=est_crget(db->textdb, db->zmode, id, &vsiz);
      if(vbuf == ((char *)NULL))
      {
        est_set_ecode(&db->ecode, 4, 2607);
        db->fatal = 1;
        est_doc_delete(doc);
        return (struct anonymous_14 *)(void *)0;
      }

      doc->dtexts=cblistload(vbuf, vsiz);
      if(db->tcmnum >= 1)
        cbmapput(db->textcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, 1);

      free((void *)vbuf);
      signed int return_value_cbmaprnum_10;
      return_value_cbmaprnum_10=cbmaprnum(db->textcc);
      if(!(db->tcmnum >= return_value_cbmaprnum_10))
      {
        signed int return_value_cbmaprnum_8;
        return_value_cbmaprnum_8=cbmaprnum(db->textcc);
        num = (signed int)((double)return_value_cbmaprnum_8 * 0.1 + (double)1);
        cbmapiterinit(db->textcc);
        i = 0;
        do
        {
          if(!(i >= num))
          {
            cbuf=cbmapiternext(db->textcc, (signed int *)(void *)0);
            tmp_if_expr_9 = cbuf != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_9 = (_Bool)0;
          if(!tmp_if_expr_9)
            break;

          cbmapout(db->textcc, cbuf, (signed int)sizeof(signed int) /*4ul*/ );
          i = i + 1;
        }
        while((_Bool)1);
      }

    }
  }

  if((4 & options) == 0)
    doc->kwords=est_db_get_keywords(db, id);

  return doc;
}

// est_db_get_doc_attr
// file estraier.c line 2630
char * est_db_get_doc_attr(struct anonymous_0 *db, signed int id, const char *name)
{
  struct anonymous_7 *attridx;
  struct anonymous_14 *doc;
  const char *cbuf;
  char *mbuf;
  char *vbuf;
  signed int cb;
  signed int csiz;
  signed int msiz;
  signed int vsiz;
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  if(id >= 2000000001)
  {
    doc=est_db_get_doc(db, id, 0);
    if(doc == ((struct anonymous_14 *)NULL))
    {
      est_set_ecode(&db->ecode, 6, 2639);
      return (char *)(void *)0;
    }

    cbuf=est_doc_attr(doc, name);
    if(cbuf == ((const char *)NULL))
    {
      est_set_ecode(&db->ecode, 6, 2643);
      est_doc_delete(doc);
      return (char *)(void *)0;
    }

    vbuf=cbmemdup(cbuf, -1);
    est_doc_delete(doc);
    return vbuf;
  }

  else
  {
    if(!(db->spacc == ((struct anonymous_5 *)NULL)))
    {
      return_value_strcmp_1=strcmp(name, db->scname);
      tmp_if_expr_2 = !(return_value_strcmp_1 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    cb = (signed int)tmp_if_expr_2;
    if(!(cb == 0))
    {
      cbuf=cbmapget(db->spacc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , &csiz);
      if(!(cbuf == ((const char *)NULL)))
      {
        cbmapmove(db->spacc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0);
        char *return_value_cbmemdup_3;
        return_value_cbmemdup_3=cbmemdup(cbuf, csiz);
        return return_value_cbmemdup_3;
      }

    }

    const char *return_value_cbmapget_4;
    return_value_cbmapget_4=cbmapget(db->aidxs, name, -1, (signed int *)(void *)0);
    attridx = (struct anonymous_7 *)return_value_cbmapget_4;
    if(!(attridx == ((struct anonymous_7 *)NULL)))
    {
      if(!(attridx->type == 0))
        goto __CPROVER_DUMP_L9;

      vbuf=est_aidx_seq_get((struct anonymous_1 *)attridx->db, id, &vsiz);
      if(vbuf == ((char *)NULL))
      {
        est_set_ecode(&db->ecode, 6, 2659);
        return (char *)(void *)0;
      }

      if(!(cb == 0))
        cbmapput(db->spacc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, 0);

      return vbuf;
    }

    else
    {

    __CPROVER_DUMP_L9:
      ;
      mbuf=est_crget(db->attrdb, db->zmode, id, &msiz);
      if(mbuf == ((char *)NULL))
      {
        signed int *return_value_dpecodeptr_5;
        return_value_dpecodeptr_5=dpecodeptr();
        est_set_ecode(&db->ecode, *return_value_dpecodeptr_5 == 5 ? 6 : 4, 2666);
        return (char *)(void *)0;
      }

      vbuf=cbmaploadone(mbuf, msiz, name, -1, &vsiz);
      if(vbuf == ((char *)NULL))
      {
        est_set_ecode(&db->ecode, 6, 2670);
        free((void *)mbuf);
        return (char *)(void *)0;
      }

      else
      {
        if(!(cb == 0))
          cbmapput(db->spacc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, 0);

        free((void *)mbuf);
        return vbuf;
      }
    }
  }
}

// est_db_get_doc_entity
// file estraier.c line 4513
char * est_db_get_doc_entity(struct anonymous_0 *db, signed int id, signed int *sp)
{
  char *ptr;
  ptr=crgetlob(db->textdb, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0, -1, sp);
  if(ptr == ((char *)NULL))
  {
    signed int *return_value_dpecodeptr_1;
    return_value_dpecodeptr_1=dpecodeptr();
    est_set_ecode(&db->ecode, *return_value_dpecodeptr_1 == 5 ? 6 : 4, 4517);
    return (char *)(void *)0;
  }

  return ptr;
}

// est_db_get_keywords
// file estraier.c line 4774
struct anonymous_5 * est_db_get_keywords(struct anonymous_0 *db, signed int id)
{
  struct anonymous_5 *kwords;
  const char *cbuf;
  char *mbuf;
  signed int i;
  signed int csiz;
  signed int msiz;
  signed int num;
  cbuf=cbmapget(db->veccc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , &csiz);
  if(!(cbuf == ((const char *)NULL)))
  {
    cbmapmove(db->veccc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0);
    struct anonymous_5 *return_value_cbmapload_1;
    return_value_cbmapload_1=cbmapload(cbuf, csiz);
    return return_value_cbmapload_1;
  }

  mbuf=est_crget(db->kwddb, db->zmode, id, &msiz);
  _Bool tmp_if_expr_3;
  if(mbuf == ((char *)NULL))
  {
    est_set_ecode(&db->ecode, 6, 4785);
    return (struct anonymous_5 *)(void *)0;
  }

  else
  {
    kwords=cbmapload(mbuf, msiz);
    if(db->vcmnum >= 1)
      cbmapput(db->veccc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , mbuf, msiz, 1);

    free((void *)mbuf);
    signed int return_value_cbmaprnum_4;
    return_value_cbmaprnum_4=cbmaprnum(db->veccc);
    if(!(db->vcmnum >= return_value_cbmaprnum_4))
    {
      signed int return_value_cbmaprnum_2;
      return_value_cbmaprnum_2=cbmaprnum(db->veccc);
      num = (signed int)((double)return_value_cbmaprnum_2 * 0.1 + (double)1);
      cbmapiterinit(db->veccc);
      i = 0;
      do
      {
        if(!(i >= num))
        {
          cbuf=cbmapiternext(db->veccc, (signed int *)(void *)0);
          tmp_if_expr_3 = cbuf != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_3 = (_Bool)0;
        if(!tmp_if_expr_3)
          break;

        cbmapout(db->veccc, cbuf, (signed int)sizeof(signed int) /*4ul*/ );
        i = i + 1;
      }
      while((_Bool)1);
    }

    return kwords;
  }
}

// est_db_inform
// file estraier.c line 7801
static void est_db_inform(struct anonymous_0 *db, const char *info)
{
  char *msg;
  if(!(db->infocb == ((void (*)(const char *, void *))NULL)))
  {
    signed int return_value_vlrnum_1;
    return_value_vlrnum_1=vlrnum(db->fwmdb);
    double return_value_est_db_size_2;
    return_value_est_db_size_2=est_db_size(db);
    signed int return_value_cbmaprnum_3;
    return_value_cbmaprnum_3=cbmaprnum(db->idxcc);
    signed int return_value_cbmaprnum_4;
    return_value_cbmaprnum_4=cbmaprnum(db->auxcc);
    signed int return_value_est_db_used_cache_size_5;
    return_value_est_db_used_cache_size_5=est_db_used_cache_size(db);
    signed int return_value_cbmaprnum_6;
    return_value_cbmaprnum_6=cbmaprnum(db->outcc);
    msg=cbsprintf("%s: name=%s dnum=%d wnum=%d fsiz=%.0f crnum=%d csiz=%d dknum=%d", info, db->name, db->dnum, return_value_vlrnum_1, (double)return_value_est_db_size_2, return_value_cbmaprnum_3 + return_value_cbmaprnum_4, return_value_est_db_used_cache_size_5, return_value_cbmaprnum_6);
    db->infocb(msg, db->infoop);
    free((void *)msg);
  }

}

// est_db_inode
// file estraier.c line 4475
signed int est_db_inode(struct anonymous_0 *db)
{
  return db->inode;
}

// est_db_interrupt
// file estraier.c line 5110
void est_db_interrupt(struct anonymous_0 *db)
{
  db->intflag = 1;
}

// est_db_iter_init
// file estraier.c line 4815
signed int est_db_iter_init(struct anonymous_0 *db, const char *prev)
{
  char *vbuf;
  signed int *return_value_dpecodeptr_1;
  if(!(prev == ((const char *)NULL)))
  {
    signed int return_value_vlcurjump_2;
    return_value_vlcurjump_2=vlcurjump(db->listdb, prev, -1, 0);
    if(return_value_vlcurjump_2 == 0)
    {
      return_value_dpecodeptr_1=dpecodeptr();
      return (signed int)(*return_value_dpecodeptr_1 == 5);
    }

    vbuf=vlcurkey(db->listdb, (signed int *)(void *)0);
    if(!(vbuf == ((char *)NULL)))
    {
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(prev, vbuf);
      if(return_value_strcmp_3 >= 0)
        vlcurnext(db->listdb);

      free((void *)vbuf);
    }

    return 1;
  }

  signed int return_value_vlcurfirst_4;
  return_value_vlcurfirst_4=vlcurfirst(db->listdb);
  _Bool tmp_if_expr_6;
  signed int *return_value_dpecodeptr_5;
  if(!(return_value_vlcurfirst_4 == 0))
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_dpecodeptr_5=dpecodeptr();
    tmp_if_expr_6 = *return_value_dpecodeptr_5 == 5 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr_6;
}

// est_db_iter_next
// file estraier.c line 4831
signed int est_db_iter_next(struct anonymous_0 *db)
{
  char *vbuf;
  signed int id;
  vbuf=vlcurval(db->listdb, (signed int *)(void *)0);
  if(vbuf == ((char *)NULL))
  {
    signed int *return_value_dpecodeptr_1;
    return_value_dpecodeptr_1=dpecodeptr();
    if(*return_value_dpecodeptr_1 == 5)
    {
      est_set_ecode(&db->ecode, 6, 4837);
      return 0;
    }

    else
    {
      est_set_ecode(&db->ecode, 4, 4840);
      db->fatal = 1;
      return -1;
    }
  }

  id=atoi(vbuf);
  free((void *)vbuf);
  vlcurnext(db->listdb);
  return id;
}

// est_db_keyword_iter_init
// file estraier.c line 4901
signed int est_db_keyword_iter_init(struct anonymous_0 *db)
{
  signed int return_value_vlcurfirst_2;
  return_value_vlcurfirst_2=vlcurfirst(db->xfmdb);
  signed int *return_value_dpecodeptr_1;
  if(return_value_vlcurfirst_2 == 0)
  {
    return_value_dpecodeptr_1=dpecodeptr();
    if(*return_value_dpecodeptr_1 == 5)
      goto __CPROVER_DUMP_L1;

    est_set_ecode(&db->ecode, 4, 4904);
    db->fatal = 1;
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 1;
  }
}

// est_db_keyword_iter_next
// file estraier.c line 4913
char * est_db_keyword_iter_next(struct anonymous_0 *db)
{
  char *word;
  word=vlcurkey(db->xfmdb, (signed int *)(void *)0);
  if(word == ((char *)NULL))
  {
    signed int *return_value_dpecodeptr_1;
    return_value_dpecodeptr_1=dpecodeptr();
    if(*return_value_dpecodeptr_1 == 5)
      est_set_ecode(&db->ecode, 6, 4918);

    else
    {
      est_set_ecode(&db->ecode, 4, 4920);
      db->fatal = 1;
    }
    return (char *)(void *)0;
  }

  vlcurnext(db->xfmdb);
  return word;
}

// est_db_keyword_num
// file estraier.c line 4892
signed int est_db_keyword_num(struct anonymous_0 *db)
{
  signed int wnum;
  wnum=vlrnum(db->xfmdb);
  return wnum > 0 ? wnum : 0;
}

// est_db_keyword_rec_size
// file estraier.c line 4931
signed int est_db_keyword_rec_size(struct anonymous_0 *db, const char *word)
{
  const char *kbuf;
  kbuf=vlgetcache(db->xfmdb, word, -1, (signed int *)(void *)0);
  signed int tmp_if_expr_2;
  signed int return_value_atoi_1;
  if(!(kbuf == ((const char *)NULL)))
  {
    return_value_atoi_1=atoi(kbuf);
    tmp_if_expr_2 = return_value_atoi_1;
  }

  else
    tmp_if_expr_2 = 0;
  return tmp_if_expr_2;
}

// est_db_keyword_search
// file estraier.c line 4939
signed int * est_db_keyword_search(struct anonymous_0 *db, const char *word, signed int *nump)
{
  signed int i;
  signed int *res;
  signed int rnum;
  char *return_value_vlget_2;
  return_value_vlget_2=vlget(db->auxdb, word, -1, &rnum);
  res = (signed int *)return_value_vlget_2;
  if(res == ((signed int *)NULL))
  {
    *nump = 0;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)1);
    res = (signed int *)return_value_malloc_1;
    if(!(res == ((signed int *)NULL)))
      res;

    else
      cbmyfatal("out of memory");
    return res;
  }

  rnum = rnum / (signed int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2);
  i = 0;
  for( ; !(i >= rnum); i = i + 1)
    res[(signed long int)i] = res[(signed long int)(i * 2)];
  *nump = rnum;
  return res;
}

// est_db_list_rescc
// file estraier.c line 5060
struct anonymous_6 * est_db_list_rescc(struct anonymous_0 *db)
{
  struct anonymous_6 *words;
  const char *word;
  signed int size;
  do
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_6) /*24ul*/ );
    words = (struct anonymous_6 *)return_value_malloc_1;
    if(!(words == ((struct anonymous_6 *)NULL)))
      words;

    else
      cbmyfatal("out of memory");
    words->anum = 64;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)words->anum);
    words->array = (struct anonymous_28 *)return_value_malloc_2;
    if(!(words->array == ((struct anonymous_28 *)NULL)))
      words->array;

    else
      cbmyfatal("out of memory");
    words->start = 0;
    words->num = 0;
  }
  while((_Bool)0);
  cbmapiterinit(db->rescc);
  do
  {
    word=cbmapiternext(db->rescc, &size);
    if(word == ((const char *)NULL))
      break;

    cblistunshift(words, word, size);
  }
  while((_Bool)1);
  return words;
}

// est_db_measure_doc
// file estraier.c line 4803
signed int est_db_measure_doc(struct anonymous_0 *db, signed int id, signed int parts)
{
  signed int sum;
  signed int num;
  sum = 0;
  if(!((1 & parts) == 0))
  {
    num=crvsiz(db->attrdb, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
    if(num >= 1)
      sum = sum + num;

  }

  if(!((2 & parts) == 0))
  {
    num=crvsiz(db->textdb, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
    if(num >= 1)
      sum = sum + num;

  }

  if(!((4 & parts) == 0))
  {
    num=crvsiz(db->kwddb, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
    if(num >= 1)
      sum = sum + num;

  }

  return sum;
}

// est_db_merge
// file estraier.c line 1891
signed int est_db_merge(struct anonymous_0 *db, const char *name, signed int options)
{
  struct anonymous_0 *tgdb;
  struct anonymous_7 *attridx;
  struct anonymous_5 *idmap;
  struct anonymous_5 *seqmap;
  struct anonymous_5 *attrs;
  struct anonymous_6 *words;
  struct anonymous_9 *rbuf;
  const char *kbuf;
  const char *vbuf;
  const char *rp;
  const char *ep;
  const char *sp;
  char *tbuf;
  char numbuf[32l];
  signed int i;
  signed int j;
  signed int ecode;
  signed int err;
  signed int ksiz;
  signed int vsiz;
  signed int tsiz;
  signed int oid;
  signed int nid;
  signed int len;
  signed int vstep;
  signed int anum;
  signed int *ary;
  signed int return_value_dpwritable_1;
  return_value_dpwritable_1=dpwritable(db->metadb);
  signed int return_value_atoi_5;
  signed int return_value_est_db_out_doc_6;
  signed int return_value_est_aidx_attr_put_12;
  signed int *return_value_dpecodeptr_17;
  signed int tmp_if_expr_22;
  signed int tmp_if_expr_36;
  signed int return_value_atoi_40;
  if(return_value_dpwritable_1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 1902);
    return 0;
  }

  else
  {
    est_db_inform(db, "opening the target database");
    tgdb=est_db_open(name, 1, &ecode);
    if(tgdb == ((struct anonymous_0 *)NULL))
    {
      est_set_ecode(&db->ecode, ecode, 1907);
      return 0;
    }

    else
    {
      signed int return_value_dpgetflags_2;
      return_value_dpgetflags_2=dpgetflags(db->metadb);
      signed int return_value_dpgetflags_3;
      return_value_dpgetflags_3=dpgetflags(tgdb->metadb);
      if(!(return_value_dpgetflags_2 == return_value_dpgetflags_3))
      {
        est_db_close(tgdb, &ecode);
        est_set_ecode(&db->ecode, 9999, 1912);
        return 0;
      }

      else
      {
        err = 0;
        signed int return_value_est_db_doc_num_4;
        return_value_est_db_doc_num_4=est_db_doc_num(tgdb);
        idmap=cbmapopenex(return_value_est_db_doc_num_4 + 1);
        vlcurfirst(tgdb->listdb);
        i = 0;
        do
        {
          kbuf=vlcurkeycache(tgdb->listdb, &ksiz);
          if(kbuf == ((const char *)NULL))
            break;

          vbuf=vlgetcache(db->listdb, kbuf, ksiz, (signed int *)(void *)0);
          if(!(vbuf == ((const char *)NULL)))
          {
            return_value_atoi_5=atoi(vbuf);
            return_value_est_db_out_doc_6=est_db_out_doc(db, return_value_atoi_5, (options & 1) != 0 ? 1 : 0);
            if(return_value_est_db_out_doc_6 == 0)
              err = 1;

          }

          const char *return_value_vlcurvalcache_7;
          return_value_vlcurvalcache_7=vlcurvalcache(tgdb->listdb, (signed int *)(void *)0);
          oid=atoi(return_value_vlcurvalcache_7);
          db->dseq = db->dseq + 1;
          db->dnum = db->dnum + 1;
          cbmapput(idmap, (char *)&oid, (signed int)sizeof(signed int) /*4ul*/ , (char *)&db->dseq, (signed int)sizeof(signed int) /*4ul*/ , 0);
          vlcurnext(tgdb->listdb);
          if(i % 1000 == 0)
            est_db_inform(db, "calculating ID mapping");

          i = i + 1;
        }
        while((_Bool)1);
        signed int return_value_est_db_flush_8;
        return_value_est_db_flush_8=est_db_flush(db, -1);
        if(return_value_est_db_flush_8 == 0)
        {
          cbmapclose(idmap);
          est_db_close(tgdb, &ecode);
          return 0;
        }

        else
        {
          cbmapiterinit(idmap);
          i = 0;
          do
          {
            kbuf=cbmapiternext(idmap, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            do
            {
              struct _CBMAPDATUM *_CB_datum = (struct _CBMAPDATUM *)(kbuf - (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/ );
              vsiz = _CB_datum->vsiz;
              vbuf = (char *)_CB_datum + (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/  + (signed long int)_CB_datum->ksiz + (signed long int)(((_CB_datum->ksiz | ~(-((signed int)sizeof(void *) /*8ul*/ ))) + 1) - _CB_datum->ksiz);
            }
            while((_Bool)0);
            oid = *((signed int *)kbuf);
            nid = *((signed int *)vbuf);
            tbuf=est_crget(tgdb->attrdb, tgdb->zmode, oid, &tsiz);
            if(!(tbuf == ((char *)NULL)))
            {
              attrs=cbmapload(tbuf, tsiz);
              len=sprintf(numbuf, "%d", nid);
              cbmapput(attrs, "@id", -1, numbuf, len, 1);
              free((void *)tbuf);
              tbuf=cbmapdump(attrs, &tsiz);
              vbuf=cbmapget(attrs, "@uri", -1, &vsiz);
              if(!(vbuf == ((const char *)NULL)))
              {
                signed int return_value_vlput_9;
                return_value_vlput_9=vlput(db->listdb, vbuf, vsiz, numbuf, len, 1);
                if(return_value_vlput_9 == 0)
                {
                  est_set_ecode(&db->ecode, 4, 1946);
                  db->fatal = 1;
                  err = 1;
                }

              }

              else
              {
                est_set_ecode(&db->ecode, 4, 1951);
                db->fatal = 1;
                err = 1;
              }
              signed int return_value_est_crput_10;
              return_value_est_crput_10=est_crput(db->attrdb, db->zmode, nid, tbuf, tsiz, 1);
              if(return_value_est_crput_10 == 0)
              {
                est_set_ecode(&db->ecode, 4, 1956);
                db->fatal = 1;
                err = 1;
              }

              signed int return_value_cbmaprnum_14;
              return_value_cbmaprnum_14=cbmaprnum(db->aidxs);
              if(return_value_cbmaprnum_14 >= 1)
              {
                cbmapiterinit(db->aidxs);
                do
                {
                  kbuf=cbmapiternext(db->aidxs, &ksiz);
                  if(kbuf == ((const char *)NULL))
                    break;

                  vbuf=cbmapget(attrs, kbuf, ksiz, &vsiz);
                  if(!(vbuf == ((const char *)NULL)))
                  {
                    const char *return_value_cbmapiterval_11;
                    return_value_cbmapiterval_11=cbmapiterval(kbuf, (signed int *)(void *)0);
                    attridx = (struct anonymous_7 *)return_value_cbmapiterval_11;
                    if(attridx->type == 1 || attridx->type == 2)
                    {
                      return_value_est_aidx_attr_put_12=est_aidx_attr_put((struct anonymous_4 *)attridx->db, nid, vbuf, vsiz);
                      if(return_value_est_aidx_attr_put_12 == 0)
                      {
                        est_set_ecode(&db->ecode, 4, 1969);
                        db->fatal = 1;
                        err = 1;
                      }

                      goto __CPROVER_DUMP_L20;
                    }

                    signed int return_value_est_aidx_seq_put_13;
                    return_value_est_aidx_seq_put_13=est_aidx_seq_put((struct anonymous_1 *)attridx->db, nid, vbuf, vsiz);
                    if(return_value_est_aidx_seq_put_13 == 0)
                    {
                      est_set_ecode(&db->ecode, 4, 1976);
                      db->fatal = 1;
                      err = 1;
                    }

                  }


                __CPROVER_DUMP_L20:
                  ;
                }
                while((_Bool)1);
              }

              cbmapclose(attrs);
              free((void *)tbuf);
            }

            else
            {
              est_set_ecode(&db->ecode, 4, 1987);
              err = 1;
            }
            tbuf=est_crget(tgdb->textdb, tgdb->zmode, oid, &tsiz);
            if(!(tbuf == ((char *)NULL)))
            {
              signed int return_value_est_crput_15;
              return_value_est_crput_15=est_crput(db->textdb, db->zmode, nid, tbuf, tsiz, 1);
              if(return_value_est_crput_15 == 0)
              {
                est_set_ecode(&db->ecode, 4, 1992);
                db->fatal = 1;
                err = 1;
              }

              free((void *)tbuf);
            }

            else
            {
              est_set_ecode(&db->ecode, 4, 1998);
              err = 1;
            }
            tbuf=est_crget(tgdb->kwddb, tgdb->zmode, oid, &tsiz);
            if(!(tbuf == ((char *)NULL)))
            {
              signed int return_value_est_crput_16;
              return_value_est_crput_16=est_crput(db->kwddb, db->zmode, nid, tbuf, tsiz, 1);
              if(return_value_est_crput_16 == 0)
              {
                est_set_ecode(&db->ecode, 4, 2003);
                db->fatal = 1;
                err = 1;
              }

              free((void *)tbuf);
            }

            else
            {
              return_value_dpecodeptr_17=dpecodeptr();
              if(!(*return_value_dpecodeptr_17 == 5))
              {
                est_set_ecode(&db->ecode, 4, 2009);
                db->fatal = 1;
                err = 1;
              }

            }
            if(i % 1000 == 0)
              est_db_inform(db, "importing documents");

            i = i + 1;
          }
          while((_Bool)1);
          do
          {
            void *return_value_malloc_18;
            return_value_malloc_18=malloc(sizeof(struct anonymous_6) /*24ul*/ );
            words = (struct anonymous_6 *)return_value_malloc_18;
            if(!(words == ((struct anonymous_6 *)NULL)))
              words;

            else
              cbmyfatal("out of memory");
            words->anum = 64;
            void *return_value_malloc_19;
            return_value_malloc_19=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)words->anum);
            words->array = (struct anonymous_28 *)return_value_malloc_19;
            if(!(words->array == ((struct anonymous_28 *)NULL)))
              words->array;

            else
              cbmyfatal("out of memory");
            words->start = 0;
            words->num = 0;
          }
          while((_Bool)0);
          vlcurfirst(tgdb->fwmdb);
          do
          {
            kbuf=vlcurkeycache(tgdb->fwmdb, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            do
            {
              signed int _CB_index = words->start + words->num;
              if(_CB_index >= words->anum)
              {
                words->anum = words->anum * 2;
                void *return_value_realloc_20;
                return_value_realloc_20=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous_28) /*16ul*/ );
                words->array = (struct anonymous_28 *)return_value_realloc_20;
                if(!(words->array == ((struct anonymous_28 *)NULL)))
                  words->array;

                else
                  cbmyfatal("out of memory");
              }

              void *return_value_malloc_21;
              return_value_malloc_21=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
              (words->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_21;
              if(!((words->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
                (words->array + (signed long int)_CB_index)->dptr;

              else
                cbmyfatal("out of memory");
              memcpy((void *)(words->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
              (words->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
              (words->array + (signed long int)_CB_index)->dsize = ksiz;
              words->num = words->num + 1;
            }
            while((_Bool)0);
            vlcurnext(tgdb->fwmdb);
          }
          while((_Bool)1);
          i = 0;
          for( ; !(i >= words->num); i = i + 1)
          {
            ksiz = (words->array + (signed long int)(words->start + i))->dsize;
            kbuf = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
            seqmap=cbmapopenex((signed int)((unsigned long int)tsiz / sizeof(signed int) /*4ul*/  + (unsigned long int)1));
            tbuf=est_idx_scan(tgdb->idxdb, kbuf, ksiz, &tsiz, tgdb->smode);
            rp = tbuf;
            ep = tbuf + (signed long int)tsiz;
            while(!(rp >= ep))
            {
              do
              {
                signed int _EST_i;
                signed int _EST_base;
                oid = 0;
                _EST_base = 1;
                _EST_i = 0;
                for( ; (_Bool)1; _EST_i = _EST_i + 1)
                {
                  if((signed int)rp[(signed long int)_EST_i] >= 0)
                  {
                    oid = oid + (signed int)((signed char *)rp)[(signed long int)_EST_i] * _EST_base;
                    break;
                  }

                  oid = oid + _EST_base * ((signed int)((signed char *)rp)[(signed long int)_EST_i] + 1) * -1;
                  _EST_base = _EST_base * 128;
                }
                vstep = _EST_i + 1;
              }
              while((_Bool)0);
              rp = rp + (signed long int)vstep;
              vbuf=cbmapget(idmap, (char *)&oid, (signed int)sizeof(signed int) /*4ul*/ , (signed int *)(void *)0);
              if(!(vbuf == ((const char *)NULL)))
                tmp_if_expr_22 = *((signed int *)vbuf);

              else
                tmp_if_expr_22 = -1;
              nid = tmp_if_expr_22;
              sp = rp;
              if(!(tgdb->smode == 1048576))
              {
                if(tgdb->smode == 2097152 || tgdb->smode == 4194304)
                  goto __CPROVER_DUMP_L55;

              }

              else
                goto __CPROVER_DUMP_L56;
              rp = rp + 1l;
              goto __CPROVER_DUMP_L56;

            __CPROVER_DUMP_L55:
              ;
              rp = rp + (signed long int)sizeof(signed int) /*4ul*/ ;

            __CPROVER_DUMP_L56:
              ;
              for( ; !((signed int)*rp == 0x00); rp = rp + (signed long int)2)
                ;
              rp = rp + 1l;
              if(nid >= 1)
                cbmapputcat(seqmap, (char *)&nid, (signed int)sizeof(signed int) /*4ul*/ , sp, (signed int)(rp - sp));

            }
            anum=cbmaprnum(seqmap);
            void *return_value_malloc_23;
            return_value_malloc_23=malloc((unsigned long int)anum * sizeof(signed int) /*4ul*/  + (unsigned long int)1);
            ary = (signed int *)return_value_malloc_23;
            if(!(ary == ((signed int *)NULL)))
              ary;

            else
              cbmyfatal("out of memory");
            cbmapiterinit(seqmap);
            j = 0;
            do
            {
              rp=cbmapiternext(seqmap, (signed int *)(void *)0);
              if(rp == ((const char *)NULL))
                break;

              ary[(signed long int)j] = *((signed int *)rp);
              j = j + 1;
            }
            while((_Bool)1);
            qsort((void *)ary, (unsigned long int)anum, sizeof(signed int) /*4ul*/ , est_int_compare);
            do
            {
              void *return_value_malloc_24;
              return_value_malloc_24=malloc(sizeof(struct anonymous_9) /*16ul*/ );
              rbuf = (struct anonymous_9 *)return_value_malloc_24;
              if(!(rbuf == ((struct anonymous_9 *)NULL)))
                rbuf;

              else
                cbmyfatal("out of memory");
              void *return_value_malloc_25;
              return_value_malloc_25=malloc((unsigned long int)12);
              rbuf->dptr = (char *)return_value_malloc_25;
              if(!(rbuf->dptr == ((char *)NULL)))
                rbuf->dptr;

              else
                cbmyfatal("out of memory");
              rbuf->dptr[(signed long int)0] = (char)0;
              rbuf->dsize = 0;
              rbuf->asize = 12;
            }
            while((_Bool)0);
            j = 0;
            for( ; !(j >= anum); j = j + 1)
            {
              do
              {
                signed int _EST_num = ary[(signed long int)j];
                struct anonymous_10 EST_d;
                if(_EST_num == 0)
                {
                  ((signed char *)numbuf)[(signed long int)0] = (signed char)0;
                  vstep = 1;
                }

                else
                {
                  vstep = 0;
                  for( ; _EST_num >= 1; vstep = vstep + 1)
                  {
                    EST_d=div(_EST_num, 128);
                    _EST_num = EST_d.quot;
                    if(_EST_num >= 1)
                      ((signed char *)numbuf)[(signed long int)vstep] = (signed char)(-EST_d.rem - 1);

                    else
                      ((signed char *)numbuf)[(signed long int)vstep] = (signed char)EST_d.rem;
                  }
                }
              }
              while((_Bool)0);
              do
              {
                if(rbuf->dsize + vstep >= rbuf->asize)
                {
                  rbuf->asize = rbuf->asize * 2 + vstep + 1;
                  void *return_value_realloc_26;
                  return_value_realloc_26=realloc((void *)rbuf->dptr, (unsigned long int)rbuf->asize);
                  rbuf->dptr = (char *)return_value_realloc_26;
                  if(!(rbuf->dptr == ((char *)NULL)))
                    rbuf->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                memcpy((void *)(rbuf->dptr + (signed long int)rbuf->dsize), (const void *)numbuf, (unsigned long int)vstep);
                rbuf->dsize = rbuf->dsize + vstep;
                rbuf->dptr[(signed long int)rbuf->dsize] = (char)0;
              }
              while((_Bool)0);
              vbuf=cbmapget(seqmap, (char *)(ary + (signed long int)j), (signed int)sizeof(signed int) /*4ul*/ , &vsiz);
              do
              {
                if(rbuf->dsize + vsiz >= rbuf->asize)
                {
                  rbuf->asize = rbuf->asize * 2 + vsiz + 1;
                  void *return_value_realloc_27;
                  return_value_realloc_27=realloc((void *)rbuf->dptr, (unsigned long int)rbuf->asize);
                  rbuf->dptr = (char *)return_value_realloc_27;
                  if(!(rbuf->dptr == ((char *)NULL)))
                    rbuf->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                memcpy((void *)(rbuf->dptr + (signed long int)rbuf->dsize), (const void *)vbuf, (unsigned long int)vsiz);
                rbuf->dsize = rbuf->dsize + vsiz;
                rbuf->dptr[(signed long int)rbuf->dsize] = (char)0;
              }
              while((_Bool)0);
            }
            signed int return_value_est_idx_add_28;
            return_value_est_idx_add_28=est_idx_add(db->idxdb, kbuf, ksiz, (const char *)rbuf->dptr, (signed int)rbuf->dsize, db->smode);
            if(return_value_est_idx_add_28 == 0)
            {
              est_set_ecode(&db->ecode, 4, 2065);
              db->fatal = 1;
              err = 1;
            }

            do
            {
              free((void *)rbuf->dptr);
              free((void *)rbuf);
            }
            while((_Bool)0);
            free((void *)ary);
            cbmapclose(seqmap);
            free((void *)tbuf);
            vlput(db->fwmdb, kbuf, ksiz, "", 0, 1);
            if(i % 10000 == 0)
            {
              est_db_inform(db, "importing words");
              signed int return_value_est_idx_size_current_29;
              return_value_est_idx_size_current_29=est_idx_size_current(db->idxdb);
              if(return_value_est_idx_size_current_29 >= 1536)
              {
                est_db_inform(db, "adding a new database file");
                est_idx_increment(db->idxdb);
              }

            }

          }
          do
          {
            signed int est_db_merge__1__10___CB_i;
            signed int est_db_merge__1__10___CB_end = words->start + words->num;
            est_db_merge__1__10___CB_i = words->start;
            for( ; !(est_db_merge__1__10___CB_i >= est_db_merge__1__10___CB_end); est_db_merge__1__10___CB_i = est_db_merge__1__10___CB_i + 1)
              free((void *)(words->array + (signed long int)est_db_merge__1__10___CB_i)->dptr);
            free((void *)words->array);
            free((void *)words);
          }
          while((_Bool)0);
          do
          {
            void *return_value_malloc_30;
            return_value_malloc_30=malloc(sizeof(struct anonymous_6) /*24ul*/ );
            words = (struct anonymous_6 *)return_value_malloc_30;
            if(!(words == ((struct anonymous_6 *)NULL)))
              words;

            else
              cbmyfatal("out of memory");
            words->anum = 64;
            void *return_value_malloc_31;
            return_value_malloc_31=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)words->anum);
            words->array = (struct anonymous_28 *)return_value_malloc_31;
            if(!(words->array == ((struct anonymous_28 *)NULL)))
              words->array;

            else
              cbmyfatal("out of memory");
            words->start = 0;
            words->num = 0;
          }
          while((_Bool)0);
          vlcurfirst(tgdb->auxdb);
          do
          {
            kbuf=vlcurkeycache(tgdb->auxdb, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            do
            {
              signed int est_db_merge__1__12__1___CB_index = words->start + words->num;
              if(est_db_merge__1__12__1___CB_index >= words->anum)
              {
                words->anum = words->anum * 2;
                void *return_value_realloc_32;
                return_value_realloc_32=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous_28) /*16ul*/ );
                words->array = (struct anonymous_28 *)return_value_realloc_32;
                if(!(words->array == ((struct anonymous_28 *)NULL)))
                  words->array;

                else
                  cbmyfatal("out of memory");
              }

              void *return_value_malloc_33;
              return_value_malloc_33=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
              (words->array + (signed long int)est_db_merge__1__12__1___CB_index)->dptr = (char *)return_value_malloc_33;
              if(!((words->array + (signed long int)est_db_merge__1__12__1___CB_index)->dptr == ((char *)NULL)))
                (words->array + (signed long int)est_db_merge__1__12__1___CB_index)->dptr;

              else
                cbmyfatal("out of memory");
              memcpy((void *)(words->array + (signed long int)est_db_merge__1__12__1___CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
              (words->array + (signed long int)est_db_merge__1__12__1___CB_index)->dptr[(signed long int)ksiz] = (char)0;
              (words->array + (signed long int)est_db_merge__1__12__1___CB_index)->dsize = ksiz;
              words->num = words->num + 1;
            }
            while((_Bool)0);
            vlcurnext(tgdb->auxdb);
          }
          while((_Bool)1);
          i = 0;
          for( ; !(i >= words->num); i = i + 1)
          {
            ksiz = (words->array + (signed long int)(words->start + i))->dsize;
            kbuf = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
            vbuf=vlgetcache(tgdb->auxdb, kbuf, ksiz, &vsiz);
            do
            {
              void *return_value_malloc_34;
              return_value_malloc_34=malloc(sizeof(struct anonymous_9) /*16ul*/ );
              rbuf = (struct anonymous_9 *)return_value_malloc_34;
              if(!(rbuf == ((struct anonymous_9 *)NULL)))
                rbuf;

              else
                cbmyfatal("out of memory");
              void *return_value_malloc_35;
              return_value_malloc_35=malloc((unsigned long int)12);
              rbuf->dptr = (char *)return_value_malloc_35;
              if(!(rbuf->dptr == ((char *)NULL)))
                rbuf->dptr;

              else
                cbmyfatal("out of memory");
              rbuf->dptr[(signed long int)0] = (char)0;
              rbuf->dsize = 0;
              rbuf->asize = 12;
            }
            while((_Bool)0);
            rp = vbuf;
            ep = vbuf + (signed long int)vsiz;
            for( ; !(rp >= ep); rp = rp + (signed long int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2))
            {
              oid = *((signed int *)rp);
              vbuf=cbmapget(idmap, rp, (signed int)sizeof(signed int) /*4ul*/ , (signed int *)(void *)0);
              if(!(vbuf == ((const char *)NULL)))
                tmp_if_expr_36 = *((signed int *)vbuf);

              else
                tmp_if_expr_36 = -1;
              nid = tmp_if_expr_36;
              if(nid >= 1)
              {
                do
                {
                  if(sizeof(signed int) /*4ul*/  + (unsigned long int)rbuf->dsize >= (unsigned long int)rbuf->asize)
                  {
                    rbuf->asize = (signed int)((unsigned long int)(rbuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
                    void *return_value_realloc_37;
                    return_value_realloc_37=realloc((void *)rbuf->dptr, (unsigned long int)rbuf->asize);
                    rbuf->dptr = (char *)return_value_realloc_37;
                    if(!(rbuf->dptr == ((char *)NULL)))
                      rbuf->dptr;

                    else
                      cbmyfatal("out of memory");
                  }

                  memcpy((void *)(rbuf->dptr + (signed long int)rbuf->dsize), (const void *)(char *)&nid, sizeof(signed int) /*4ul*/ );
                  rbuf->dsize = rbuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
                  rbuf->dptr[(signed long int)rbuf->dsize] = (char)0;
                }
                while((_Bool)0);
                do
                {
                  if(sizeof(signed int) /*4ul*/  + (unsigned long int)rbuf->dsize >= (unsigned long int)rbuf->asize)
                  {
                    rbuf->asize = (signed int)((unsigned long int)(rbuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
                    void *return_value_realloc_38;
                    return_value_realloc_38=realloc((void *)rbuf->dptr, (unsigned long int)rbuf->asize);
                    rbuf->dptr = (char *)return_value_realloc_38;
                    if(!(rbuf->dptr == ((char *)NULL)))
                      rbuf->dptr;

                    else
                      cbmyfatal("out of memory");
                  }

                  memcpy((void *)(rbuf->dptr + (signed long int)rbuf->dsize), (const void *)(rp + (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
                  rbuf->dsize = rbuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
                  rbuf->dptr[(signed long int)rbuf->dsize] = (char)0;
                }
                while((_Bool)0);
              }

            }
            signed int return_value_vlput_39;
            return_value_vlput_39=vlput(db->auxdb, kbuf, ksiz, (const char *)rbuf->dptr, (signed int)rbuf->dsize, 2);
            if(return_value_vlput_39 == 0)
            {
              est_set_ecode(&db->ecode, 4, 2106);
              db->fatal = 1;
              err = 1;
            }

            do
            {
              free((void *)rbuf->dptr);
              free((void *)rbuf);
            }
            while((_Bool)0);
            anum = 0;
            vbuf=vlgetcache(tgdb->xfmdb, kbuf, ksiz, (signed int *)(void *)0);
            if(!(vbuf == ((const char *)NULL)))
            {
              return_value_atoi_40=atoi(vbuf);
              anum = anum + return_value_atoi_40;
            }

            len=sprintf(numbuf, "%d", anum);
            vlput(db->xfmdb, kbuf, ksiz, numbuf, len, 0);
            if(i % 10000 == 0)
              est_db_inform(db, "importing auxiliary words");

          }
          do
          {
            signed int _CB_i;
            signed int _CB_end = words->start + words->num;
            _CB_i = words->start;
            for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
              free((void *)(words->array + (signed long int)_CB_i)->dptr);
            free((void *)words->array);
            free((void *)words);
          }
          while((_Bool)0);
          cbmapclose(idmap);
          est_db_inform(db, "closing the target database");
          signed int return_value_est_db_close_41;
          return_value_est_db_close_41=est_db_close(tgdb, &ecode);
          if(return_value_est_db_close_41 == 0)
          {
            est_set_ecode(&db->ecode, ecode, 2121);
            return 0;
          }

          else
          {
            signed int return_value_est_db_flush_42;
            return_value_est_db_flush_42=est_db_flush(db, -1);
            if(return_value_est_db_flush_42 == 0)
              err = 1;

            return err != 0 ? 0 : 1;
          }
        }
      }
    }
  }
}

// est_db_meta
// file estraier.c line 4549
char * est_db_meta(struct anonymous_0 *db, const char *name)
{
  const char *vbuf;
  signed int vsiz;
  if(db->metacc == ((struct anonymous_5 *)NULL))
    est_db_prepare_meta(db);

  vbuf=cbmapget(db->metacc, name, -1, &vsiz);
  if(vbuf == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    char *return_value_cbmemdup_1;
    return_value_cbmemdup_1=cbmemdup(vbuf, vsiz);
    return return_value_cbmemdup_1;
  }
}

// est_db_meta_names
// file estraier.c line 4541
struct anonymous_6 * est_db_meta_names(struct anonymous_0 *db)
{
  if(db->metacc == ((struct anonymous_5 *)NULL))
    est_db_prepare_meta(db);

  struct anonymous_6 *return_value_cbmapkeys_1;
  return_value_cbmapkeys_1=cbmapkeys(db->metacc);
  return return_value_cbmapkeys_1;
}

// est_db_name
// file estraier.c line 2695
const char * est_db_name(struct anonymous_0 *db)
{
  return db->name;
}

// est_db_open
// file estraier.c line 914
struct anonymous_0 * est_db_open(const char *name, signed int omode, signed int *ecp)
{
  struct anonymous_0 *db;
  struct anonymous_1 *metadb;
  struct anonymous_2 *idxdb;
  struct anonymous_3 *attrdb;
  struct anonymous_3 *textdb;
  struct anonymous_3 *kwddb;
  struct anonymous_4 *fwmdb;
  struct anonymous_4 *auxdb;
  struct anonymous_4 *xfmdb;
  struct anonymous_4 *listdb;
  struct anonymous_5 *aidxs;
  struct anonymous_6 *list;
  struct anonymous_7 attridx;
  void *aidxdb;
  const char *elem;
  char path[4096l];
  char vbuf[32l];
  char *dec;
  signed int i;
  signed int inode;
  signed int domode;
  signed int comode;
  signed int vomode;
  signed int flags;
  signed int idxnum;
  signed int dseq;
  signed int dnum;
  signed int amode;
  signed int zmode;
  signed int smode;
  signed int vsiz;
  signed int type;
  signed int crdnum;
  double bdiam;
  double ddiam;
  if(est_inodes == ((struct anonymous_5 *)NULL))
  {
    est_inodes=cbmapopenex(31);
    cbglobalgc((void *)est_inodes, est_inodes_delete);
  }

  est_set_ecode(ecp, 0, 934);
  signed int return_value_est_mkdir_2;
  if(!((2 & omode) == 0) && !((4 & omode) == 0))
  {
    return_value_est_mkdir_2=est_mkdir(name);
    if(return_value_est_mkdir_2 == 0)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      switch(*return_value___errno_location_1)
      {
        case 13:
        {
          est_set_ecode(ecp, 2, 938);
          return (struct anonymous_0 *)(void *)0;
        }
        case 17:
          break;
        default:
        {
          est_set_ecode(ecp, 5, 943);
          return (struct anonymous_0 *)(void *)0;
        }
      }
    }

  }

  inode=est_inode(name);
  _Bool tmp_if_expr_15;
  signed int return_value_cbstrfwmatch_14;
  _Bool tmp_if_expr_17;
  signed int return_value_cbstrfwmatch_16;
  signed int return_value_cbstrfwmatch_22;
  signed int return_value_cbstrfwmatch_21;
  struct anonymous_4 *return_value_vlopen_24;
  struct anonymous_4 *return_value_vlopen_25;
  signed int return_value_crbnum_26;
  struct anonymous_1 *return_value_dpopen_27;
  if(!(inode >= 1))
  {
    est_set_ecode(ecp, 5, 948);
    return (struct anonymous_0 *)(void *)0;
  }

  else
  {
    const char *return_value_cbmapget_3;
    return_value_cbmapget_3=cbmapget(est_inodes, (char *)&inode, (signed int)sizeof(signed int) /*4ul*/ , (signed int *)(void *)0);
    if(!(return_value_cbmapget_3 == ((const char *)NULL)))
    {
      if(!((16 & omode) == 0))
        goto __CPROVER_DUMP_L8;

      est_set_ecode(ecp, 2, 952);
      return (struct anonymous_0 *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      domode = 1;
      comode = 1;
      vomode = 1;
      if(!((2 & omode) == 0))
      {
        domode = 2;
        comode = 2;
        vomode = 2;
        vomode = vomode | 64;
        if(!((4 & omode) == 0))
        {
          domode = domode | 4;
          comode = comode | 4;
          vomode = vomode | 4;
        }

        if(!((8 & omode) == 0))
        {
          domode = domode | 8;
          comode = comode | 8;
          vomode = vomode | 8;
        }

      }

      if(!((16 & omode) == 0))
      {
        domode = domode | 16;
        comode = comode | 16;
        vomode = vomode | 16;
      }

      if(!((32 & omode) == 0))
      {
        domode = domode | 32;
        comode = comode | 32;
        vomode = vomode | 32;
      }

      flags = 0;
      idxnum = 0;
      dseq = 0;
      dnum = 0;
      amode = 0;
      zmode = 0;
      smode = 0;
      if(!((1048576 & omode) == 0))
      {
        bdiam = 0.3;
        ddiam = 0.4;
      }

      else
        if(!((2097152 & omode) == 0))
        {
          bdiam = 3.0;
          ddiam = 1.0;
        }

        else
          if(!((4194304 & omode) == 0))
          {
            bdiam = 5.0;
            ddiam = 2.0;
          }

          else
            if(!((8388608 & omode) == 0))
            {
              bdiam = 5.0 * 1.4;
              ddiam = 2.0 * 1.4;
            }

            else
              if(!((16777216 & omode) == 0))
              {
                bdiam = 5.0 * 2.0;
                ddiam = 2.0 * 2.0;
              }

              else
              {
                bdiam = 1.0;
                ddiam = 1.0;
              }
      sprintf(path, "%s%c%s", name, 47, (const void *)"_meta");
      metadb=dpopen(path, domode, 31);
      if(!(metadb == ((struct anonymous_1 *)NULL)))
      {
        flags=dpgetflags(metadb);
        signed int return_value_dprnum_4;
        return_value_dprnum_4=dprnum(metadb);
        if(!(return_value_dprnum_4 >= 1))
        {
          if(!((1024 & omode) == 0))
            flags = flags | 1024;

          else
            if(!((2048 & omode) == 0))
              flags = flags | 2048;

          flags = flags | 32768;
          if(!((33554432 & omode) == 0))
            flags = flags | 1048576;

          else
            if(!((67108864 & omode) == 0))
              flags = flags | 2097152;

            else
              if(!((134217728 & omode) == 0))
                flags = flags | 4194304;

          dpsetflags(metadb, flags);
        }

        vsiz=dpgetwb(metadb, "_idxnum", -1, 0, 32 - 1, vbuf);
        if(vsiz >= 1)
        {
          vbuf[(signed long int)vsiz] = (char)0;
          idxnum=atoi(vbuf);
        }

        vsiz=dpgetwb(metadb, "_dseq", -1, 0, 32 - 1, vbuf);
        if(vsiz >= 1)
        {
          vbuf[(signed long int)vsiz] = (char)0;
          dseq=atoi(vbuf);
        }

        vsiz=dpgetwb(metadb, "_dnum", -1, 0, 32 - 1, vbuf);
        if(vsiz >= 1)
        {
          vbuf[(signed long int)vsiz] = (char)0;
          dnum=atoi(vbuf);
        }

        if(!((1024 & flags) == 0))
          amode = 1024;

        else
          if(!((2048 & flags) == 0))
            amode = 2048;

        if(!((32768 & flags) == 0))
          zmode = 32768;

        else
          if(!((65536 & flags) == 0))
            zmode = 65536;

          else
            if(!((131072 & flags) == 0))
              zmode = 131072;

        if(!((1048576 & flags) == 0))
          smode = 1048576;

        else
          if(!((2097152 & flags) == 0))
            smode = 2097152;

          else
            if(!((4194304 & flags) == 0))
              smode = 4194304;

      }

      else
      {
        signed int *return_value_dpecodeptr_5;
        return_value_dpecodeptr_5=dpecodeptr();
        est_set_ecode(ecp, *return_value_dpecodeptr_5 == 16 ? 3 : 4, 1073);
        return (struct anonymous_0 *)(void *)0;
      }
      if(!(idxnum >= 1))
        idxnum = 1;

      if(!(dseq >= 0))
        dseq = 0;

      if(!(dnum >= 0))
        dnum = 0;

      signed int *return_value_vlcrdnumptr_6;
      return_value_vlcrdnumptr_6=vlcrdnumptr();
      crdnum = *return_value_vlcrdnumptr_6;
      sprintf(path, "%s%c%s", name, 47, (const void *)"_idx");
      idxdb=est_idx_open(path, vomode, idxnum);
      sprintf(path, "%s%c%s", name, 47, (const void *)"_fwm");
      signed int *return_value_vlcrdnumptr_7;
      return_value_vlcrdnumptr_7=vlcrdnumptr();
      *return_value_vlcrdnumptr_7 = 2;
      fwmdb=vlopen(path, vomode, VL_CMPLEX);
      sprintf(path, "%s%c%s", name, 47, (const void *)"_aux");
      signed int *return_value_vlcrdnumptr_8;
      return_value_vlcrdnumptr_8=vlcrdnumptr();
      *return_value_vlcrdnumptr_8 = 7;
      auxdb=vlopen(path, vomode, VL_CMPLEX);
      sprintf(path, "%s%c%s", name, 47, (const void *)"_xfm");
      signed int *return_value_vlcrdnumptr_9;
      return_value_vlcrdnumptr_9=vlcrdnumptr();
      *return_value_vlcrdnumptr_9 = 2;
      xfmdb=vlopen(path, vomode, VL_CMPLEX);
      sprintf(path, "%s%c%s", name, 47, (const void *)"_attr");
      attrdb=cropen(path, comode, (signed int)((double)212987 * bdiam), (signed int)((double)3 * ddiam));
      sprintf(path, "%s%c%s", name, 47, (const void *)"_text");
      textdb=cropen(path, comode, (signed int)((double)61417 * bdiam), (signed int)((double)7 * ddiam));
      sprintf(path, "%s%c%s", name, 47, (const void *)"_kwd");
      kwddb=cropen(path, comode, (signed int)((double)163819 * bdiam), (signed int)((double)3 * ddiam));
      sprintf(path, "%s%c%s", name, 47, (const void *)"_list");
      signed int *return_value_vlcrdnumptr_10;
      return_value_vlcrdnumptr_10=vlcrdnumptr();
      *return_value_vlcrdnumptr_10 = 2;
      listdb=vlopen(path, vomode, VL_CMPLEX);
      signed int *return_value_vlcrdnumptr_11;
      return_value_vlcrdnumptr_11=vlcrdnumptr();
      *return_value_vlcrdnumptr_11 = crdnum;
      if(idxdb == ((struct anonymous_2 *)NULL) || attrdb == ((struct anonymous_3 *)NULL) || kwddb == ((struct anonymous_3 *)NULL) || textdb == ((struct anonymous_3 *)NULL) || auxdb == ((struct anonymous_4 *)NULL) || fwmdb == ((struct anonymous_4 *)NULL) || listdb == ((struct anonymous_4 *)NULL) || xfmdb == ((struct anonymous_4 *)NULL))
      {
        if(!(listdb == ((struct anonymous_4 *)NULL)))
          vlclose(listdb);

        if(!(kwddb == ((struct anonymous_3 *)NULL)))
          crclose(kwddb);

        if(!(textdb == ((struct anonymous_3 *)NULL)))
          crclose(textdb);

        if(!(attrdb == ((struct anonymous_3 *)NULL)))
          crclose(attrdb);

        if(!(xfmdb == ((struct anonymous_4 *)NULL)))
          vlclose(xfmdb);

        if(!(auxdb == ((struct anonymous_4 *)NULL)))
          vlclose(auxdb);

        if(!(fwmdb == ((struct anonymous_4 *)NULL)))
          vlclose(fwmdb);

        if(!(idxdb == ((struct anonymous_2 *)NULL)))
          est_idx_close(idxdb);

        dpclose(metadb);
        est_set_ecode(ecp, 4, 1111);
        return (struct anonymous_0 *)(void *)0;
      }

      else
      {
        if(!((2 & omode) == 0))
        {
          est_idx_set_tuning(idxdb, amode == 1024 ? 17 : 109, 160, 16, 16, 512);
          est_idx_set_current(idxdb);
          vlsettuning(fwmdb, 251, 110, 32, 16);
          vlsetfbpsiz(fwmdb, 128);
          vlsettuning(auxdb, 23, 160, 16, 16);
          vlsetfbpsiz(auxdb, 256);
          vlsettuning(xfmdb, 111, 110, 32, 16);
          vlsetfbpsiz(xfmdb, 128);
          crsetalign(attrdb, -5);
          crsetfbpsiz(attrdb, 64);
          crsetalign(textdb, -5);
          crsetfbpsiz(textdb, 128);
          crsetalign(kwddb, -5);
          crsetfbpsiz(kwddb, 64);
          vlsettuning(listdb, 99, 200, 64, 16);
          vlsetfbpsiz(listdb, 128);
        }

        else
        {
          est_idx_set_tuning(idxdb, -1, -1, amode == 1024 ? 32 : 128, 256, -1);
          vlsettuning(fwmdb, -1, -1, 32, 16);
          vlsettuning(auxdb, -1, -1, 256, 64);
          vlsettuning(xfmdb, -1, -1, 32, 16);
          vlsettuning(listdb, -1, -1, 64, 16);
        }
        if(!((2 & omode) == 0) && !((8 & omode) == 0))
        {
          list=cbdirlist(name);
          if(!(list == ((struct anonymous_6 *)NULL)))
          {
            i = 0;
            for( ; !(i >= list->num); i = i + 1)
            {
              elem = (const char *)(list->array + (signed long int)(list->start + i))->dptr;
              signed int return_value_cbstrfwmatch_13;
              return_value_cbstrfwmatch_13=cbstrfwmatch(elem, "__seq_");
              if(!(return_value_cbstrfwmatch_13 == 0))
                tmp_if_expr_15 = (_Bool)1;

              else
              {
                return_value_cbstrfwmatch_14=cbstrfwmatch(elem, "__str_");
                tmp_if_expr_15 = return_value_cbstrfwmatch_14 != 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_15)
                tmp_if_expr_17 = (_Bool)1;

              else
              {
                return_value_cbstrfwmatch_16=cbstrfwmatch(elem, "__num_");
                tmp_if_expr_17 = return_value_cbstrfwmatch_16 != 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_17)
              {
                sprintf(path, "%s%c%s", name, 47, elem);
                signed int return_value_unlink_12;
                return_value_unlink_12=unlink(path);
                if(return_value_unlink_12 == -1)
                  est_rmdir_rec(path);

              }

            }
            do
            {
              signed int _CB_i;
              signed int _CB_end = list->start + list->num;
              _CB_i = list->start;
              for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
                free((void *)(list->array + (signed long int)_CB_i)->dptr);
              free((void *)list->array);
              free((void *)list);
            }
            while((_Bool)0);
          }

        }

        aidxs=cbmapopenex(31);
        list=cbdirlist(name);
        if(!(list == ((struct anonymous_6 *)NULL)))
        {
          i = 0;
          for( ; !(i >= list->num); i = i + 1)
          {
            elem = (const char *)(list->array + (signed long int)(list->start + i))->dptr;
            dec = (char *)(void *)0;
            type = -1;
            signed int return_value_cbstrfwmatch_23;
            return_value_cbstrfwmatch_23=cbstrfwmatch(elem, "__seq_");
            if(!(return_value_cbstrfwmatch_23 == 0))
            {
              unsigned long int return_value_strlen_18;
              return_value_strlen_18=strlen("__seq_");
              dec=est_hex_decode(elem + (signed long int)return_value_strlen_18);
              type = 0;
            }

            else
            {
              return_value_cbstrfwmatch_22=cbstrfwmatch(elem, "__str_");
              if(!(return_value_cbstrfwmatch_22 == 0))
              {
                unsigned long int return_value_strlen_19;
                return_value_strlen_19=strlen("__str_");
                dec=est_hex_decode(elem + (signed long int)return_value_strlen_19);
                type = 1;
              }

              else
              {
                return_value_cbstrfwmatch_21=cbstrfwmatch(elem, "__num_");
                if(!(return_value_cbstrfwmatch_21 == 0))
                {
                  unsigned long int return_value_strlen_20;
                  return_value_strlen_20=strlen("__num_");
                  dec=est_hex_decode(elem + (signed long int)return_value_strlen_20);
                  type = 2;
                }

              }
            }
            if(!(dec == ((char *)NULL)))
            {
              sprintf(path, "%s%c%s", name, 47, elem);
              switch(type)
              {
                case 1:
                {
                  return_value_vlopen_24=vlopen(path, vomode, VL_CMPLEX);
                  aidxdb = (void *)return_value_vlopen_24;
                  if(!(aidxdb == NULL))
                  {
                    vlsettuning((struct anonymous_4 *)aidxdb, 99, 120, 1024, 256);
                    vlsetfbpsiz((struct anonymous_4 *)aidxdb, 128);
                    attridx.db = aidxdb;
                    attridx.type = type;
                    cbmapput(aidxs, dec, -1, (char *)&attridx, (signed int)sizeof(struct anonymous_7) /*16ul*/ , 0);
                  }

                  break;
                }
                case 2:
                {
                  return_value_vlopen_25=vlopen(path, vomode, est_aidx_numcmp);
                  aidxdb = (void *)return_value_vlopen_25;
                  if(!(aidxdb == NULL))
                  {
                    vlsettuning((struct anonymous_4 *)aidxdb, 99, 120, 1024, 256);
                    vlsetfbpsiz((struct anonymous_4 *)aidxdb, 128);
                    attridx.db = aidxdb;
                    attridx.type = type;
                    cbmapput(aidxs, dec, -1, (char *)&attridx, (signed int)sizeof(struct anonymous_7) /*16ul*/ , 0);
                  }

                  break;
                }
                default:
                {
                  return_value_crbnum_26=crbnum(attrdb);
                  return_value_dpopen_27=dpopen(path, domode, (signed int)((double)return_value_crbnum_26 / 0.8));
                  aidxdb = (void *)return_value_dpopen_27;
                  if(!(aidxdb == NULL))
                  {
                    dpsetfbpsiz((struct anonymous_1 *)aidxdb, 32);
                    attridx.db = aidxdb;
                    attridx.type = type;
                    cbmapput(aidxs, dec, -1, (char *)&attridx, (signed int)sizeof(struct anonymous_7) /*16ul*/ , 0);
                  }

                }
              }
              free((void *)dec);
            }

          }
          do
          {
            signed int est_db_open__1__20__2___CB_i;
            signed int est_db_open__1__20__2___CB_end = list->start + list->num;
            est_db_open__1__20__2___CB_i = list->start;
            for( ; !(est_db_open__1__20__2___CB_i >= est_db_open__1__20__2___CB_end); est_db_open__1__20__2___CB_i = est_db_open__1__20__2___CB_i + 1)
              free((void *)(list->array + (signed long int)est_db_open__1__20__2___CB_i)->dptr);
            free((void *)list->array);
            free((void *)list);
          }
          while((_Bool)0);
        }

        void *return_value_malloc_28;
        return_value_malloc_28=malloc(sizeof(struct anonymous_0) /*336ul*/ );
        db = (struct anonymous_0 *)return_value_malloc_28;
        if(!(db == ((struct anonymous_0 *)NULL)))
          db;

        else
          cbmyfatal("out of memory");
        db->name=cbmemdup(name, -1);
        db->inode = inode;
        db->metadb = metadb;
        db->idxdb = idxdb;
        db->fwmdb = fwmdb;
        db->auxdb = auxdb;
        db->xfmdb = xfmdb;
        db->attrdb = attrdb;
        db->textdb = textdb;
        db->kwddb = kwddb;
        db->listdb = listdb;
        db->aidxs = aidxs;
        do
        {
          void *return_value_malloc_29;
          return_value_malloc_29=malloc(sizeof(struct anonymous_6) /*24ul*/ );
          db->pdocs = (struct anonymous_6 *)return_value_malloc_29;
          if(!(db->pdocs == ((struct anonymous_6 *)NULL)))
            db->pdocs;

          else
            cbmyfatal("out of memory");
          db->pdocs->anum = 64;
          void *return_value_malloc_30;
          return_value_malloc_30=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)db->pdocs->anum);
          db->pdocs->array = (struct anonymous_28 *)return_value_malloc_30;
          if(!(db->pdocs->array == ((struct anonymous_28 *)NULL)))
            db->pdocs->array;

          else
            cbmyfatal("out of memory");
          db->pdocs->start = 0;
          db->pdocs->num = 0;
        }
        while((_Bool)0);
        db->puris = (struct anonymous_5 *)(void *)0;
        est_set_ecode(&db->ecode, 0, 1217);
        db->fatal = 0;
        db->dseq = dseq;
        db->dnum = dnum;
        db->amode = amode;
        db->zmode = zmode;
        db->smode = smode;
        if(!((2 & omode) == 0))
        {
          db->idxcc=cbmapopenex(524288);
          db->auxcc=cbmapopenex(65521);
          db->icsiz = (unsigned long int)0;
          db->icmax = (unsigned long int)(1048576 * 64);
          db->outcc=cbmapopenex(131072);
        }

        else
        {
          db->idxcc=cbmapopenex(1);
          db->auxcc=cbmapopenex(1);
          db->icsiz = (unsigned long int)0;
          db->icmax = (unsigned long int)0;
          db->outcc=cbmapopenex(1);
        }
        db->keycc=cbmapopenex(65536 + 1);
        db->kcmnum = 65536;
        db->attrcc=cbmapopenex(8192 + 1);
        db->acmnum = 8192;
        db->textcc=cbmapopenex(1024 + 1);
        db->tcmnum = 1024;
        db->veccc=cbmapopenex(8192 / 2 + 1);
        db->vcmnum = 8192 / 2;
        db->rescc=cbmapopenex(256 * 2 + 1);
        db->rcmnum = 256;
        db->spacc = (struct anonymous_5 *)(void *)0;
        db->scmnum = 0;
        db->scname = (char *)(void *)0;
        db->infocb = (void (*)(const char *, void *))(void *)0;
        db->infoop = (void *)0;
        db->dfdb = (struct anonymous_1 *)(void *)0;
        db->metacc = (struct anonymous_5 *)(void *)0;
        db->wildmax = 256;
        db->flsflag = 0;
        db->intflag = 0;
        cbmapput(est_inodes, (char *)&inode, (signed int)sizeof(signed int) /*4ul*/ , (char *)&db, (signed int)sizeof(struct anonymous_0 *) /*8ul*/ , 0);
        return db;
      }
    }
  }
}

// est_db_optimize
// file estraier.c line 1742
signed int est_db_optimize(struct anonymous_0 *db, signed int options)
{
  struct anonymous_5 *dmap;
  struct anonymous_6 *words;
  struct anonymous_9 *nval;
  struct anonymous_7 *attridx;
  const char *word;
  const char *rp;
  const char *pv;
  const char *ep;
  char *kbuf;
  char *vbuf;
  char *wp;
  char numbuf[32l];
  signed int i;
  signed int err;
  signed int id;
  signed int ksiz;
  signed int vsiz;
  signed int wsiz;
  signed int len;
  signed int vstep;
  signed int return_value_dpwritable_1;
  return_value_dpwritable_1=dpwritable(db->metadb);
  signed int *return_value_dpecodeptr_21;
  signed int return_value_vloptimize_32;
  if(return_value_dpwritable_1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 1752);
    return 0;
  }

  else
  {
    signed int return_value_est_db_flush_2;
    return_value_est_db_flush_2=est_db_flush(db, -1);
    if(return_value_est_db_flush_2 == 0)
      return 0;

    else
    {
      err = 0;
      if((1 & options) == 0)
      {
        signed int return_value_vlrnum_3;
        return_value_vlrnum_3=vlrnum(db->listdb);
        dmap=cbmapopenex(return_value_vlrnum_3 + 1);
        vlcurfirst(db->listdb);
        do
        {
          vbuf=vlcurval(db->listdb, (signed int *)(void *)0);
          if(vbuf == ((char *)NULL))
            break;

          id=atoi(vbuf);
          cbmapput(dmap, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , "", 0, 0);
          free((void *)vbuf);
          vlcurnext(db->listdb);
        }
        while((_Bool)1);
        do
        {
          void *return_value_malloc_4;
          return_value_malloc_4=malloc(sizeof(struct anonymous_6) /*24ul*/ );
          words = (struct anonymous_6 *)return_value_malloc_4;
          if(!(words == ((struct anonymous_6 *)NULL)))
            words;

          else
            cbmyfatal("out of memory");
          words->anum = 64;
          void *return_value_malloc_5;
          return_value_malloc_5=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)words->anum);
          words->array = (struct anonymous_28 *)return_value_malloc_5;
          if(!(words->array == ((struct anonymous_28 *)NULL)))
            words->array;

          else
            cbmyfatal("out of memory");
          words->start = 0;
          words->num = 0;
        }
        while((_Bool)0);
        vlcurfirst(db->fwmdb);
        do
        {
          kbuf=vlcurkey(db->fwmdb, &ksiz);
          if(kbuf == ((char *)NULL))
            break;

          do
          {
            signed int est_db_optimize__1__2__3__1___CB_index = words->start + words->num;
            if(est_db_optimize__1__2__3__1___CB_index >= words->anum)
            {
              words->anum = words->anum * 2;
              void *return_value_realloc_6;
              return_value_realloc_6=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous_28) /*16ul*/ );
              words->array = (struct anonymous_28 *)return_value_realloc_6;
              if(!(words->array == ((struct anonymous_28 *)NULL)))
                words->array;

              else
                cbmyfatal("out of memory");
            }

            (words->array + (signed long int)est_db_optimize__1__2__3__1___CB_index)->dptr = kbuf;
            (words->array + (signed long int)est_db_optimize__1__2__3__1___CB_index)->dsize = ksiz;
            words->num = words->num + 1;
          }
          while((_Bool)0);
          vlcurnext(db->fwmdb);
        }
        while((_Bool)1);
        i = 0;
        for( ; !(i >= words->num); i = i + 1)
        {
          if(i % 4 == 0)
            est_idx_set_current(db->idxdb);

          wsiz = (words->array + (signed long int)(words->start + i))->dsize;
          word = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
          vbuf=est_idx_scan(db->idxdb, word, wsiz, &vsiz, db->smode);
          do
          {
            void *return_value_malloc_7;
            return_value_malloc_7=malloc(sizeof(struct anonymous_9) /*16ul*/ );
            nval = (struct anonymous_9 *)return_value_malloc_7;
            if(!(nval == ((struct anonymous_9 *)NULL)))
              nval;

            else
              cbmyfatal("out of memory");
            void *return_value_malloc_8;
            return_value_malloc_8=malloc((unsigned long int)12);
            nval->dptr = (char *)return_value_malloc_8;
            if(!(nval->dptr == ((char *)NULL)))
              nval->dptr;

            else
              cbmyfatal("out of memory");
            nval->dptr[(signed long int)0] = (char)0;
            nval->dsize = 0;
            nval->asize = 12;
          }
          while((_Bool)0);
          rp = vbuf;
          ep = vbuf + (signed long int)vsiz;
          while(!(rp >= ep))
          {
            pv = rp;
            do
            {
              signed int _EST_i;
              signed int _EST_base;
              id = 0;
              _EST_base = 1;
              _EST_i = 0;
              for( ; (_Bool)1; _EST_i = _EST_i + 1)
              {
                if((signed int)rp[(signed long int)_EST_i] >= 0)
                {
                  id = id + (signed int)((signed char *)rp)[(signed long int)_EST_i] * _EST_base;
                  break;
                }

                id = id + _EST_base * ((signed int)((signed char *)rp)[(signed long int)_EST_i] + 1) * -1;
                _EST_base = _EST_base * 128;
              }
              vstep = _EST_i + 1;
            }
            while((_Bool)0);
            rp = rp + (signed long int)vstep;
            if(!(db->smode == 1048576))
            {
              if(db->smode == 2097152 || db->smode == 4194304)
                goto __CPROVER_DUMP_L29;

            }

            else
              goto __CPROVER_DUMP_L30;
            rp = rp + 1l;
            goto __CPROVER_DUMP_L30;

          __CPROVER_DUMP_L29:
            ;
            rp = rp + (signed long int)sizeof(signed int) /*4ul*/ ;

          __CPROVER_DUMP_L30:
            ;
            for( ; !((signed int)*rp == 0x00); rp = rp + (signed long int)2)
              ;
            rp = rp + 1l;
            const char *return_value_cbmapget_10;
            return_value_cbmapget_10=cbmapget(dmap, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , (signed int *)(void *)0);
            if(!(return_value_cbmapget_10 == ((const char *)NULL)))
              do
              {
                if((rp - pv) + (signed long int)nval->dsize >= (signed long int)nval->asize)
                {
                  nval->asize = (signed int)((signed long int)(nval->asize * 2) + (rp - pv) + (signed long int)1);
                  void *return_value_realloc_9;
                  return_value_realloc_9=realloc((void *)nval->dptr, (unsigned long int)nval->asize);
                  nval->dptr = (char *)return_value_realloc_9;
                  if(!(nval->dptr == ((char *)NULL)))
                    nval->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                memcpy((void *)(nval->dptr + (signed long int)nval->dsize), (const void *)pv, (unsigned long int)(rp - pv));
                nval->dsize = nval->dsize + (signed int)(rp - pv);
                nval->dptr[(signed long int)nval->dsize] = (char)0;
              }
              while((_Bool)0);

          }
          signed int return_value_est_idx_out_11;
          return_value_est_idx_out_11=est_idx_out(db->idxdb, word, wsiz);
          if(return_value_est_idx_out_11 == 0)
            err = 1;

          if(nval->dsize >= 1)
          {
            signed int return_value_est_idx_add_12;
            return_value_est_idx_add_12=est_idx_add(db->idxdb, word, wsiz, (const char *)nval->dptr, (signed int)nval->dsize, db->smode);
            if(return_value_est_idx_add_12 == 0)
              err = 1;

          }

          else
          {
            signed int return_value_vlout_13;
            return_value_vlout_13=vlout(db->fwmdb, word, wsiz);
            if(return_value_vlout_13 == 0)
              err = 1;

          }
          do
          {
            free((void *)nval->dptr);
            free((void *)nval);
          }
          while((_Bool)0);
          free((void *)vbuf);
          free((void *)kbuf);
          if(i % 10000 == 0)
            est_db_inform(db, "cleaning dispensable keys");

        }
        do
        {
          signed int _CB_i;
          signed int _CB_end = words->start + words->num;
          _CB_i = words->start;
          for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
            free((void *)(words->array + (signed long int)_CB_i)->dptr);
          free((void *)words->array);
          free((void *)words);
        }
        while((_Bool)0);
        do
        {
          void *return_value_malloc_14;
          return_value_malloc_14=malloc(sizeof(struct anonymous_6) /*24ul*/ );
          words = (struct anonymous_6 *)return_value_malloc_14;
          if(!(words == ((struct anonymous_6 *)NULL)))
            words;

          else
            cbmyfatal("out of memory");
          words->anum = 64;
          void *return_value_malloc_15;
          return_value_malloc_15=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)words->anum);
          words->array = (struct anonymous_28 *)return_value_malloc_15;
          if(!(words->array == ((struct anonymous_28 *)NULL)))
            words->array;

          else
            cbmyfatal("out of memory");
          words->start = 0;
          words->num = 0;
        }
        while((_Bool)0);
        vlcurfirst(db->auxdb);
        do
        {
          kbuf=vlcurkey(db->auxdb, &ksiz);
          if(kbuf == ((char *)NULL))
            break;

          do
          {
            signed int _CB_index = words->start + words->num;
            if(_CB_index >= words->anum)
            {
              words->anum = words->anum * 2;
              void *return_value_realloc_16;
              return_value_realloc_16=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous_28) /*16ul*/ );
              words->array = (struct anonymous_28 *)return_value_realloc_16;
              if(!(words->array == ((struct anonymous_28 *)NULL)))
                words->array;

              else
                cbmyfatal("out of memory");
            }

            (words->array + (signed long int)_CB_index)->dptr = kbuf;
            (words->array + (signed long int)_CB_index)->dsize = ksiz;
            words->num = words->num + 1;
          }
          while((_Bool)0);
          vlcurnext(db->auxdb);
        }
        while((_Bool)1);
        i = 0;
        for( ; !(i >= words->num); i = i + 1)
        {
          wsiz = (words->array + (signed long int)(words->start + i))->dsize;
          word = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
          vbuf=vlget(db->auxdb, word, wsiz, &vsiz);
          if(!(vbuf == ((char *)NULL)))
          {
            rp = vbuf;
            wp = vbuf;
            ep = vbuf + (signed long int)vsiz;
            while(!(rp >= ep))
            {
              const char *return_value_cbmapget_17;
              return_value_cbmapget_17=cbmapget(dmap, rp, (signed int)sizeof(signed int) /*4ul*/ , (signed int *)(void *)0);
              if(!(return_value_cbmapget_17 == ((const char *)NULL)))
              {
                memmove((void *)wp, (const void *)rp, sizeof(signed int) /*4ul*/  * (unsigned long int)2);
                wp = wp + (signed long int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2);
              }

              rp = rp + (signed long int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2);
            }
            if(!(vbuf >= wp))
            {
              signed int return_value_vlput_18;
              return_value_vlput_18=vlput(db->auxdb, word, wsiz, vbuf, (signed int)(wp - vbuf), 0);
              if(return_value_vlput_18 == 0)
                err = 1;

              len=sprintf(numbuf, "%d", (signed int)((unsigned long int)(wp - vbuf) / (sizeof(signed int) /*4ul*/  * (unsigned long int)2)));
              signed int return_value_vlput_19;
              return_value_vlput_19=vlput(db->xfmdb, word, wsiz, numbuf, len, 0);
              if(return_value_vlput_19 == 0)
                err = 1;

            }

            else
            {
              signed int return_value_vlout_20;
              return_value_vlout_20=vlout(db->auxdb, word, wsiz);
              if(return_value_vlout_20 == 0)
                err = 1;

              signed int return_value_vlout_22;
              return_value_vlout_22=vlout(db->xfmdb, word, wsiz);
              if(return_value_vlout_22 == 0)
              {
                return_value_dpecodeptr_21=dpecodeptr();
                if(!(*return_value_dpecodeptr_21 == 5))
                  err = 1;

              }

            }
            free((void *)vbuf);
            if(i % 10000 == 0)
              est_db_inform(db, "cleaning dispensable auxiliary keys");

          }

        }
        do
        {
          signed int est_db_optimize__1__2__9___CB_i;
          signed int est_db_optimize__1__2__9___CB_end = words->start + words->num;
          est_db_optimize__1__2__9___CB_i = words->start;
          for( ; !(est_db_optimize__1__2__9___CB_i >= est_db_optimize__1__2__9___CB_end); est_db_optimize__1__2__9___CB_i = est_db_optimize__1__2__9___CB_i + 1)
            free((void *)(words->array + (signed long int)est_db_optimize__1__2__9___CB_i)->dptr);
          free((void *)words->array);
          free((void *)words);
        }
        while((_Bool)0);
        cbmapclose(dmap);
      }

      if((2 & options) == 0)
      {
        est_db_inform(db, "optimizing the inverted index");
        signed int return_value_est_idx_optimize_23;
        return_value_est_idx_optimize_23=est_idx_optimize(db->idxdb);
        if(return_value_est_idx_optimize_23 == 0)
          err = 1;

        est_db_inform(db, "optimizing the database for forward matching");
        signed int return_value_vloptimize_24;
        return_value_vloptimize_24=vloptimize(db->fwmdb);
        if(return_value_vloptimize_24 == 0)
          err = 1;

        est_db_inform(db, "optimizing the auxiliary index");
        signed int return_value_vloptimize_25;
        return_value_vloptimize_25=vloptimize(db->auxdb);
        if(return_value_vloptimize_25 == 0)
          err = 1;

        est_db_inform(db, "optimizing the database for auxiliary forward matching");
        signed int return_value_vloptimize_26;
        return_value_vloptimize_26=vloptimize(db->xfmdb);
        if(return_value_vloptimize_26 == 0)
          err = 1;

        est_db_inform(db, "optimizing the database for attributes");
        signed int return_value_croptimize_27;
        return_value_croptimize_27=croptimize(db->attrdb, -1);
        if(return_value_croptimize_27 == 0)
          err = 1;

        est_db_inform(db, "optimizing the database for texts");
        signed int return_value_croptimize_28;
        return_value_croptimize_28=croptimize(db->textdb, -1);
        if(return_value_croptimize_28 == 0)
          err = 1;

        est_db_inform(db, "optimizing the database for keywords");
        signed int return_value_croptimize_29;
        return_value_croptimize_29=croptimize(db->kwddb, -1);
        if(return_value_croptimize_29 == 0)
          err = 1;

        est_db_inform(db, "optimizing the database for document list");
        signed int return_value_vloptimize_30;
        return_value_vloptimize_30=vloptimize(db->listdb);
        if(return_value_vloptimize_30 == 0)
          err = 1;

        signed int return_value_cbmaprnum_34;
        return_value_cbmaprnum_34=cbmaprnum(db->aidxs);
        if(return_value_cbmaprnum_34 >= 1)
        {
          est_db_inform(db, "optimizing the databases for attribute narrowing");
          cbmapiterinit(db->aidxs);
          do
          {
            rp=cbmapiternext(db->aidxs, (signed int *)(void *)0);
            if(rp == ((const char *)NULL))
              break;

            const char *return_value_cbmapiterval_31;
            return_value_cbmapiterval_31=cbmapiterval(rp, (signed int *)(void *)0);
            attridx = (struct anonymous_7 *)return_value_cbmapiterval_31;
            if(attridx->type == 1 || attridx->type == 2)
            {
              return_value_vloptimize_32=vloptimize((struct anonymous_4 *)attridx->db);
              if(return_value_vloptimize_32 == 0)
                err = 1;

              goto __CPROVER_DUMP_L86;
            }

            signed int return_value_dpoptimize_33;
            return_value_dpoptimize_33=dpoptimize((struct anonymous_1 *)attridx->db, -1);
            if(return_value_dpoptimize_33 == 0)
              err = 1;


          __CPROVER_DUMP_L86:
            ;
          }
          while((_Bool)1);
        }

      }

      cbmapclose(db->rescc);
      db->rescc=cbmapopenex(db->rcmnum * 2 + 1);
      if(!(err == 0))
      {
        est_set_ecode(&db->ecode, 4, 1883);
        db->fatal = 1;
      }

      return err != 0 ? 0 : 1;
    }
  }
}

// est_db_out_doc
// file estraier.c line 2323
signed int est_db_out_doc(struct anonymous_0 *db, signed int id, signed int options)
{
  struct anonymous_14 *doc;
  struct anonymous_6 *words;
  struct anonymous_7 *attridx;
  const char *uri;
  const char *kbuf;
  const char *vbuf;
  const char *text;
  const char *word;
  char numbuf[32l];
  signed int i;
  signed int j;
  signed int ksiz;
  signed int vsiz;
  signed int len;
  signed int wsiz;
  signed int return_value_dpwritable_1;
  return_value_dpwritable_1=dpwritable(db->metadb);
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_5;
  signed int return_value_est_crout_4;
  _Bool tmp_if_expr_7;
  signed int return_value_vlout_6;
  signed int return_value_est_aidx_attr_out_9;
  signed int *return_value_dpecodeptr_15;
  if(return_value_dpwritable_1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 2332);
    return 0;
  }

  else
    if(id >= 2000000001)
    {
      est_set_ecode(&db->ecode, 1, 2336);
      return 0;
    }

    else
    {
      doc=est_db_get_doc(db, id, 4);
      if(doc == ((struct anonymous_14 *)NULL))
        return 0;

      else
      {
        if(doc->attrs == ((struct anonymous_5 *)NULL))
          tmp_if_expr_2 = (_Bool)1;

        else
        {
          uri=cbmapget(doc->attrs, "@uri", -1, (signed int *)(void *)0);
          tmp_if_expr_2 = !(uri != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_2)
        {
          est_doc_delete(doc);
          est_set_ecode(&db->ecode, 4, 2342);
          db->fatal = 1;
          return 0;
        }

        else
        {
          signed int return_value_est_crout_3;
          return_value_est_crout_3=est_crout(db->attrdb, id);
          if(return_value_est_crout_3 == 0)
            tmp_if_expr_5 = (_Bool)1;

          else
          {
            return_value_est_crout_4=est_crout(db->textdb, id);
            tmp_if_expr_5 = !(return_value_est_crout_4 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_5)
            tmp_if_expr_7 = (_Bool)1;

          else
          {
            return_value_vlout_6=vlout(db->listdb, uri, -1);
            tmp_if_expr_7 = !(return_value_vlout_6 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_7)
          {
            est_doc_delete(doc);
            est_set_ecode(&db->ecode, 4, 2348);
            db->fatal = 1;
            return 0;
          }

          else
          {
            cbmapout(db->attrcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
            cbmapout(db->textcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
            if(!(db->spacc == ((struct anonymous_5 *)NULL)))
              cbmapout(db->spacc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );

            signed int return_value_cbmaprnum_11;
            return_value_cbmaprnum_11=cbmaprnum(db->aidxs);
            if(return_value_cbmaprnum_11 >= 1)
            {
              cbmapiterinit(db->aidxs);
              do
              {
                kbuf=cbmapiternext(db->aidxs, &ksiz);
                if(kbuf == ((const char *)NULL))
                  break;

                vbuf=cbmapget(doc->attrs, kbuf, ksiz, &vsiz);
                if(!(vbuf == ((const char *)NULL)))
                {
                  const char *return_value_cbmapiterval_8;
                  return_value_cbmapiterval_8=cbmapiterval(kbuf, (signed int *)(void *)0);
                  attridx = (struct anonymous_7 *)return_value_cbmapiterval_8;
                  if(attridx->type == 1 || attridx->type == 2)
                  {
                    return_value_est_aidx_attr_out_9=est_aidx_attr_out((struct anonymous_4 *)attridx->db, doc->id, vbuf, vsiz);
                    if(return_value_est_aidx_attr_out_9 == 0)
                    {
                      est_doc_delete(doc);
                      est_set_ecode(&db->ecode, 4, 2365);
                      db->fatal = 1;
                      return 0;
                    }

                    goto __CPROVER_DUMP_L18;
                  }

                  signed int return_value_est_aidx_seq_out_10;
                  return_value_est_aidx_seq_out_10=est_aidx_seq_out((struct anonymous_1 *)attridx->db, doc->id);
                  if(return_value_est_aidx_seq_out_10 == 0)
                  {
                    est_doc_delete(doc);
                    est_set_ecode(&db->ecode, 4, 2373);
                    db->fatal = 1;
                    return 0;
                  }

                }


              __CPROVER_DUMP_L18:
                ;
              }
              while((_Bool)1);
            }

            if(!((1 & options) == 0))
            {
              len=sprintf(numbuf, "\t%d", doc->id);
              cbmapput(db->outcc, numbuf, len, "", 0, 0);
              i = -1;
              for( ; !(i >= doc->dtexts->num); i = i + 1)
              {
                if(!(i >= 0))
                {
                  text=cbmapget(doc->attrs, "", 0, (signed int *)(void *)0);
                  if(text == ((const char *)NULL))
                    goto __CPROVER_DUMP_L36;

                }

                else
                  text = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
                do
                {
                  void *return_value_malloc_12;
                  return_value_malloc_12=malloc(sizeof(struct anonymous_6) /*24ul*/ );
                  words = (struct anonymous_6 *)return_value_malloc_12;
                  if(!(words == ((struct anonymous_6 *)NULL)))
                    words;

                  else
                    cbmyfatal("out of memory");
                  words->anum = 64;
                  void *return_value_malloc_13;
                  return_value_malloc_13=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)words->anum);
                  words->array = (struct anonymous_28 *)return_value_malloc_13;
                  if(!(words->array == ((struct anonymous_28 *)NULL)))
                    words->array;

                  else
                    cbmyfatal("out of memory");
                  words->start = 0;
                  words->num = 0;
                }
                while((_Bool)0);
                switch(db->amode)
                {
                  case 1024:
                  {
                    est_break_text_perfng(text, words, 0, 1);
                    break;
                  }
                  case 2048:
                  {
                    est_break_text_chrcat(text, words, 0);
                    break;
                  }
                  default:
                    est_break_text(text, words, 0, 1);
                }
                j = 0;
                for( ; !(j >= words->num); j = j + 1)
                {
                  wsiz = (words->array + (signed long int)(words->start + j))->dsize;
                  word = (const char *)(words->array + (signed long int)(words->start + j))->dptr;
                  cbmapput(db->outcc, word, wsiz, "", 0, 0);
                }
                do
                {
                  signed int _CB_i;
                  signed int _CB_end = words->start + words->num;
                  _CB_i = words->start;
                  for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
                    free((void *)(words->array + (signed long int)_CB_i)->dptr);
                  free((void *)words->array);
                  free((void *)words);
                }
                while((_Bool)0);

              __CPROVER_DUMP_L36:
                ;
              }
              signed int return_value_est_db_out_keywords_14;
              return_value_est_db_out_keywords_14=est_db_out_keywords(db, id);
              if(return_value_est_db_out_keywords_14 == 0)
              {
                if(!(db->ecode == 6))
                {
                  est_doc_delete(doc);
                  est_set_ecode(&db->ecode, 4, 2410);
                  db->fatal = 1;
                  return 0;
                }

              }

            }

            else
            {
              signed int return_value_est_crout_16;
              return_value_est_crout_16=est_crout(db->kwddb, id);
              if(return_value_est_crout_16 == 0)
              {
                return_value_dpecodeptr_15=dpecodeptr();
                if(!(*return_value_dpecodeptr_15 == 5))
                {
                  est_doc_delete(doc);
                  est_set_ecode(&db->ecode, 4, 2417);
                  db->fatal = 1;
                  return 0;
                }

              }

              cbmapout(db->veccc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
            }
            est_doc_delete(doc);
            signed int return_value_est_db_set_doc_entity_17;
            return_value_est_db_set_doc_entity_17=est_db_set_doc_entity(db, id, (const char *)(void *)0, -1);
            if(return_value_est_db_set_doc_entity_17 == 0)
            {
              if(db->ecode == 6)
                goto __CPROVER_DUMP_L42;

              return 0;
            }

            else
            {

            __CPROVER_DUMP_L42:
              ;
              db->dnum = db->dnum - 1;
              return 1;
            }
          }
        }
      }
    }
}

// est_db_out_keywords
// file estraier.c line 4731
signed int est_db_out_keywords(struct anonymous_0 *db, signed int id)
{
  struct anonymous_5 *kwords;
  const char *word;
  char wbuf[51l];
  char *tbuf;
  signed int wsiz;
  signed int return_value_dpwritable_1;
  return_value_dpwritable_1=dpwritable(db->metadb);
  if(return_value_dpwritable_1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 4738);
    return 0;
  }

  else
    if(id >= 2000000001)
    {
      est_set_ecode(&db->ecode, 1, 4742);
      return 0;
    }

    else
    {
      kwords=est_db_get_keywords(db, id);
      if(!(kwords == ((struct anonymous_5 *)NULL)))
      {
        cbmapiterinit(kwords);
        do
        {
          word=cbmapiternext(kwords, &wsiz);
          if(word == ((const char *)NULL))
            break;

          if(wsiz >= 49)
          {
            tbuf=cbsprintf(" %s", word);
            cbmapput(db->outcc, tbuf, wsiz + 1, "", 0, 0);
            free((void *)tbuf);
          }

          else
          {
            sprintf(wbuf, " %s", word);
            cbmapput(db->outcc, wbuf, wsiz + 1, "", 0, 0);
          }
        }
        while((_Bool)1);
        cbmapclose(kwords);
      }

      signed int return_value_est_crout_3;
      return_value_est_crout_3=est_crout(db->kwddb, id);
      if(return_value_est_crout_3 == 0)
      {
        signed int *return_value_dpecodeptr_2;
        return_value_dpecodeptr_2=dpecodeptr();
        if(*return_value_dpecodeptr_2 == 5)
          est_set_ecode(&db->ecode, 6, 4761);

        else
        {
          est_set_ecode(&db->ecode, 4, 4763);
          db->fatal = 1;
        }
        return 0;
      }

      cbmapout(db->veccc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
      return 1;
    }
}

// est_db_prepare_meta
// file estraier.c line 7816
static void est_db_prepare_meta(struct anonymous_0 *db)
{
  char *sbuf;
  signed int ssiz;
  sbuf=dpget(db->metadb, "_meta", -1, 0, -1, &ssiz);
  if(!(sbuf == ((char *)NULL)))
  {
    db->metacc=cbmapload(sbuf, ssiz);
    free((void *)sbuf);
  }

  else
    db->metacc=cbmapopenex(31);
}

// est_db_pseudo_doc_num
// file estraier.c line 5075
signed int est_db_pseudo_doc_num(struct anonymous_0 *db)
{
  signed int return_value_cblistnum_1;
  return_value_cblistnum_1=cblistnum(db->pdocs);
  return return_value_cblistnum_1;
}

// est_db_put_doc
// file estraier.c line 2130
signed int est_db_put_doc(struct anonymous_0 *db, struct anonymous_14 *doc, signed int options)
{
  struct anonymous_5 *ocmap;
  struct anonymous_5 *fmap;
  struct anonymous_5 *qmap;
  struct anonymous_6 *words;
  struct anonymous_9 *ocbuf;
  struct anonymous_7 *attridx;
  struct md5_state_s ms;
  const char *uri;
  const char *ndig;
  const char *text;
  const char *word;
  const char *fnext;
  const char *snext;
  const char *kbuf;
  const char *vbuf;
  unsigned char junc[2l];
  unsigned char c;
  char dobuf[32l];
  char dsbuf[64l];
  char *wp;
  char *odig;
  char wbuf[51l];
  char *sbuf;
  char nbuf[32l];
  signed int i;
  signed int j;
  signed int id;
  signed int err;
  signed int wnum;
  signed int wsiz;
  signed int fnsiz;
  signed int snsiz;
  signed int *np;
  signed int score;
  signed int num;
  signed int ksiz;
  signed int vsiz;
  signed int ssiz;
  double tune;
  double weight;
  signed int return_value_dpwritable_1;
  return_value_dpwritable_1=dpwritable(db->metadb);
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  signed int tmp_if_expr_13;
  signed int return_value_dpinnerhash_12;
  signed int tmp_if_expr_15;
  signed int return_value_dpouterhash_14;
  signed int tmp_if_expr_17;
  signed int tmp_if_expr_20;
  signed int return_value_atoi_19;
  double tmp_if_expr_26;
  const char *return_value_cbmapget_25;
  double tmp_if_expr_29;
  const char *return_value_cbmapget_28;
  signed int return_value_est_db_put_keywords_35;
  signed int return_value_est_aidx_attr_put_38;
  signed int return_value_est_db_flush_41;
  if(return_value_dpwritable_1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 2143);
    return 0;
  }

  else
  {
    if(doc->attrs == ((struct anonymous_5 *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      uri=cbmapget(doc->attrs, "@uri", -1, (signed int *)(void *)0);
      tmp_if_expr_2 = !(uri != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)uri[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      est_set_ecode(&db->ecode, 1, 2147);
      return 0;
    }

    else
    {
      if(doc->dtexts == ((struct anonymous_6 *)NULL))
        do
        {
          void *return_value_malloc_4;
          return_value_malloc_4=malloc(sizeof(struct anonymous_6) /*24ul*/ );
          doc->dtexts = (struct anonymous_6 *)return_value_malloc_4;
          if(!(doc->dtexts == ((struct anonymous_6 *)NULL)))
            doc->dtexts;

          else
            cbmyfatal("out of memory");
          doc->dtexts->anum = 64;
          void *return_value_malloc_5;
          return_value_malloc_5=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)doc->dtexts->anum);
          doc->dtexts->array = (struct anonymous_28 *)return_value_malloc_5;
          if(!(doc->dtexts->array == ((struct anonymous_28 *)NULL)))
            doc->dtexts->array;

          else
            cbmyfatal("out of memory");
          doc->dtexts->start = 0;
          doc->dtexts->num = 0;
        }
        while((_Bool)0);

      ndig=cbmapget(doc->attrs, "@digest", -1, (signed int *)(void *)0);
      if(ndig == ((const char *)NULL))
      {
        md5_init(&ms);
        i = 0;
        for( ; !(i >= doc->dtexts->num); i = i + 1)
        {
          vsiz = (doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dsize;
          vbuf = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
          md5_append(&ms, (unsigned char *)vbuf, vsiz);
          md5_append(&ms, (unsigned char *)"\n", 1);
        }
        vbuf=cbmapget(doc->attrs, "", 0, &vsiz);
        if(!(vbuf == ((const char *)NULL)))
        {
          md5_append(&ms, (unsigned char *)"\t", 1);
          md5_append(&ms, (unsigned char *)vbuf, vsiz);
          md5_append(&ms, (unsigned char *)"\n", 1);
        }

        md5_finish(&ms, (unsigned char *)dobuf);
        wp = dsbuf;
        i = 0;
        for( ; !(i >= 16); i = i + 1)
        {
          signed int return_value_sprintf_6;
          return_value_sprintf_6=sprintf(wp, "%02x", ((unsigned char *)dobuf)[(signed long int)i]);
          wp = wp + (signed long int)return_value_sprintf_6;
        }
        ndig = dsbuf;
        cbmapput(doc->attrs, "@digest", -1, ndig, -1, 0);
      }

      id=est_db_uri_to_id(db, uri);
      if(id >= 1)
      {
        odig=est_db_get_doc_attr(db, id, "@digest");
        if(!(odig == ((char *)NULL)))
        {
          signed int return_value_strcmp_8;
          return_value_strcmp_8=strcmp(odig, ndig);
          if(return_value_strcmp_8 == 0)
          {
            free((void *)odig);
            doc->id = id;
            sprintf(nbuf, "%d", id);
            cbmapput(doc->attrs, "@id", -1, nbuf, -1, 1);
            signed int return_value_est_db_edit_doc_7;
            return_value_est_db_edit_doc_7=est_db_edit_doc(db, doc);
            return return_value_est_db_edit_doc_7;
          }

          free((void *)odig);
        }

        signed int return_value_est_db_out_doc_9;
        return_value_est_db_out_doc_9=est_db_out_doc(db, id, (options & 1) != 0 ? 1 : 0);
        if(return_value_est_db_out_doc_9 == 0)
          return 0;

      }

      db->dseq = db->dseq + 1;
      doc->id = db->dseq;
      sprintf(nbuf, "%d", doc->id);
      cbmapput(doc->attrs, "@id", -1, nbuf, -1, 1);
      ocmap=cbmapopen();
      fmap=cbmapopen();
      qmap=cbmapopen();
      wnum = 0;
      i = -1;
      for( ; !(i >= doc->dtexts->num); i = i + 1)
      {
        if(!(i >= 0))
        {
          text=cbmapget(doc->attrs, "", 0, (signed int *)(void *)0);
          if(text == ((const char *)NULL))
            goto __CPROVER_DUMP_L46;

        }

        else
          text = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
        do
        {
          void *return_value_malloc_10;
          return_value_malloc_10=malloc(sizeof(struct anonymous_6) /*24ul*/ );
          words = (struct anonymous_6 *)return_value_malloc_10;
          if(!(words == ((struct anonymous_6 *)NULL)))
            words;

          else
            cbmyfatal("out of memory");
          words->anum = 64;
          void *return_value_malloc_11;
          return_value_malloc_11=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)words->anum);
          words->array = (struct anonymous_28 *)return_value_malloc_11;
          if(!(words->array == ((struct anonymous_28 *)NULL)))
            words->array;

          else
            cbmyfatal("out of memory");
          words->start = 0;
          words->num = 0;
        }
        while((_Bool)0);
        switch(db->amode)
        {
          case 1024:
          {
            est_break_text_perfng(text, words, 0, 1);
            break;
          }
          case 2048:
          {
            est_break_text_chrcat(text, words, 0);
            break;
          }
          default:
            est_break_text(text, words, 0, 1);
        }
        wnum = wnum + (signed int)words->num;
        j = 0;
        for( ; !(j >= words->num); j = j + 1)
        {
          wsiz = (words->array + (signed long int)(words->start + j))->dsize;
          word = (const char *)(words->array + (signed long int)(words->start + j))->dptr;
          if(!(wsiz >= 49))
          {
            fnext=cblistval(words, j + 1, &fnsiz);
            snext=cblistval(words, j + 2, &snsiz);
            if(!(fnext == ((const char *)NULL)))
            {
              return_value_dpinnerhash_12=dpinnerhash(fnext, fnsiz);
              tmp_if_expr_13 = return_value_dpinnerhash_12 % 251 + 1;
            }

            else
              tmp_if_expr_13 = 0xff;
            junc[(signed long int)0] = (unsigned char)tmp_if_expr_13;
            if(!(snext == ((const char *)NULL)))
            {
              return_value_dpouterhash_14=dpouterhash(snext, snsiz);
              tmp_if_expr_15 = return_value_dpouterhash_14 % 251 + 1;
            }

            else
              tmp_if_expr_15 = 0xff;
            junc[(signed long int)1] = (unsigned char)tmp_if_expr_15;
            memcpy((void *)wbuf, (const void *)word, (unsigned long int)wsiz);
            memcpy((void *)(wbuf + (signed long int)wsiz), (const void *)"\t", (unsigned long int)1);
            memcpy((void *)(wbuf + (signed long int)wsiz + (signed long int)1), (const void *)junc, (unsigned long int)2);
            const char *return_value_cbmapget_16;
            return_value_cbmapget_16=cbmapget(fmap, word, wsiz, (signed int *)(void *)0);
            np = (signed int *)return_value_cbmapget_16;
            if(!(np == ((signed int *)NULL)))
              tmp_if_expr_17 = *((signed int *)np);

            else
              tmp_if_expr_17 = 0;
            num = tmp_if_expr_17;
            num = num + 16;
            cbmapput(fmap, word, wsiz, (char *)&num, (signed int)sizeof(signed int) /*4ul*/ , 1);
            signed int return_value_cbmapput_18;
            return_value_cbmapput_18=cbmapput(qmap, wbuf, wsiz + 3, "", 0, 0);
            if(!(return_value_cbmapput_18 == 0))
              cbmapputcat(ocmap, word, wsiz, (char *)junc, fnext != ((const char *)NULL) ? 2 : 0);

          }

        }
        do
        {
          signed int _CB_i;
          signed int _CB_end = words->start + words->num;
          _CB_i = words->start;
          for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
            free((void *)(words->array + (signed long int)_CB_i)->dptr);
          free((void *)words->array);
          free((void *)words);
        }
        while((_Bool)0);

      __CPROVER_DUMP_L46:
        ;
      }
      vbuf=cbmapget(doc->attrs, "\t", 1, (signed int *)(void *)0);
      if(!(vbuf == ((const char *)NULL)))
      {
        return_value_atoi_19=atoi(vbuf);
        tmp_if_expr_20 = return_value_atoi_19;
      }

      else
        tmp_if_expr_20 = -1;
      score = tmp_if_expr_20;
      weight = 1.0;
      if(!((2 & options) == 0) && !(score >= 0))
      {
        vbuf=cbmapget(doc->attrs, "@weight", -1, (signed int *)(void *)0);
        if(!(vbuf == ((const char *)NULL)))
        {
          weight=strtod(vbuf, (char ** restrict )(void *)0);
          weight = weight >= 0.01 ? weight : 0.01;
        }

      }

      double return_value_sqrt_21;
      return_value_sqrt_21=sqrt((double)(wnum + 128));
      tune = (return_value_sqrt_21 / 16.0) / weight;
      cbmapiterinit(ocmap);
      do
      {
        kbuf=cbmapiternext(ocmap, &ksiz);
        if(kbuf == ((const char *)NULL))
          break;

        do
        {
          struct _CBMAPDATUM *_CB_datum = (struct _CBMAPDATUM *)(kbuf - (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/ );
          vsiz = _CB_datum->vsiz;
          vbuf = (char *)_CB_datum + (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/  + (signed long int)_CB_datum->ksiz + (signed long int)(((_CB_datum->ksiz | ~(-((signed int)sizeof(void *) /*8ul*/ ))) + 1) - _CB_datum->ksiz);
        }
        while((_Bool)0);
        if(vsiz >= 3)
          qsort((void *)vbuf, (unsigned long int)(vsiz / 2), (unsigned long int)2, est_short_compare);

        do
        {
          void *return_value_malloc_22;
          return_value_malloc_22=malloc(sizeof(struct anonymous_9) /*16ul*/ );
          ocbuf = (struct anonymous_9 *)return_value_malloc_22;
          if(!(ocbuf == ((struct anonymous_9 *)NULL)))
            ocbuf;

          else
            cbmyfatal("out of memory");
          void *return_value_malloc_23;
          return_value_malloc_23=malloc((unsigned long int)12);
          ocbuf->dptr = (char *)return_value_malloc_23;
          if(!(ocbuf->dptr == ((char *)NULL)))
            ocbuf->dptr;

          else
            cbmyfatal("out of memory");
          ocbuf->dptr[(signed long int)0] = (char)0;
          ocbuf->dsize = 0;
          ocbuf->asize = 12;
        }
        while((_Bool)0);
        do
        {
          signed int _EST_num = doc->id;
          struct anonymous_10 EST_d;
          if(_EST_num == 0)
          {
            ((signed char *)wbuf)[(signed long int)0] = (signed char)0;
            wsiz = 1;
          }

          else
          {
            wsiz = 0;
            for( ; _EST_num >= 1; wsiz = wsiz + 1)
            {
              EST_d=div(_EST_num, 128);
              _EST_num = EST_d.quot;
              if(_EST_num >= 1)
                ((signed char *)wbuf)[(signed long int)wsiz] = (signed char)(-EST_d.rem - 1);

              else
                ((signed char *)wbuf)[(signed long int)wsiz] = (signed char)EST_d.rem;
            }
          }
        }
        while((_Bool)0);
        do
        {
          if(ocbuf->dsize + wsiz >= ocbuf->asize)
          {
            ocbuf->asize = ocbuf->asize * 2 + wsiz + 1;
            void *return_value_realloc_24;
            return_value_realloc_24=realloc((void *)ocbuf->dptr, (unsigned long int)ocbuf->asize);
            ocbuf->dptr = (char *)return_value_realloc_24;
            if(!(ocbuf->dptr == ((char *)NULL)))
              ocbuf->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(ocbuf->dptr + (signed long int)ocbuf->dsize), (const void *)wbuf, (unsigned long int)wsiz);
          ocbuf->dsize = ocbuf->dsize + wsiz;
          ocbuf->dptr[(signed long int)ocbuf->dsize] = (char)0;
        }
        while((_Bool)0);
        if(!(db->smode == 1048576))
        {
          if(db->smode == 2097152 || db->smode == 4194304)
            goto __CPROVER_DUMP_L78;

        }

        else
          goto __CPROVER_DUMP_L85;
        if(!(score >= 0))
        {
          return_value_cbmapget_25=cbmapget(fmap, kbuf, ksiz, (signed int *)(void *)0);
          tmp_if_expr_26 = (double)*((signed int *)return_value_cbmapget_25) / tune;
        }

        else
          tmp_if_expr_26 = (double)score;
        num = (signed int)tmp_if_expr_26;
        if(num >= 0x80)
          num = num + (signed int)((double)(0x80 - num) * 0.75);

        if(num >= 0xc0)
          num = num + (signed int)((double)(0xc0 - num) * 0.75);

        c = (unsigned char)(num < 0xff ? num : 0xff);
        do
        {
          if(1 + ocbuf->dsize >= ocbuf->asize)
          {
            ocbuf->asize = ocbuf->asize * 2 + 1 + 1;
            void *return_value_realloc_27;
            return_value_realloc_27=realloc((void *)ocbuf->dptr, (unsigned long int)ocbuf->asize);
            ocbuf->dptr = (char *)return_value_realloc_27;
            if(!(ocbuf->dptr == ((char *)NULL)))
              ocbuf->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(ocbuf->dptr + (signed long int)ocbuf->dsize), (const void *)(char *)&c, (unsigned long int)1);
          ocbuf->dsize = ocbuf->dsize + 1;
          ocbuf->dptr[(signed long int)ocbuf->dsize] = (char)0;
        }
        while((_Bool)0);
        goto __CPROVER_DUMP_L85;

      __CPROVER_DUMP_L78:
        ;
        if(!(score >= 0))
        {
          return_value_cbmapget_28=cbmapget(fmap, kbuf, ksiz, (signed int *)(void *)0);
          tmp_if_expr_29 = (double)(*((signed int *)return_value_cbmapget_28) * 10) / tune;
        }

        else
          tmp_if_expr_29 = (double)score;
        num = (signed int)tmp_if_expr_29;
        do
        {
          if(sizeof(signed int) /*4ul*/  + (unsigned long int)ocbuf->dsize >= (unsigned long int)ocbuf->asize)
          {
            ocbuf->asize = (signed int)((unsigned long int)(ocbuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
            void *return_value_realloc_30;
            return_value_realloc_30=realloc((void *)ocbuf->dptr, (unsigned long int)ocbuf->asize);
            ocbuf->dptr = (char *)return_value_realloc_30;
            if(!(ocbuf->dptr == ((char *)NULL)))
              ocbuf->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(ocbuf->dptr + (signed long int)ocbuf->dsize), (const void *)(char *)&num, sizeof(signed int) /*4ul*/ );
          ocbuf->dsize = ocbuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
          ocbuf->dptr[(signed long int)ocbuf->dsize] = (char)0;
        }
        while((_Bool)0);

      __CPROVER_DUMP_L85:
        ;
        do
        {
          if(ocbuf->dsize + vsiz >= ocbuf->asize)
          {
            ocbuf->asize = ocbuf->asize * 2 + vsiz + 1;
            void *return_value_realloc_31;
            return_value_realloc_31=realloc((void *)ocbuf->dptr, (unsigned long int)ocbuf->asize);
            ocbuf->dptr = (char *)return_value_realloc_31;
            if(!(ocbuf->dptr == ((char *)NULL)))
              ocbuf->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(ocbuf->dptr + (signed long int)ocbuf->dsize), (const void *)vbuf, (unsigned long int)vsiz);
          ocbuf->dsize = ocbuf->dsize + vsiz;
          ocbuf->dptr[(signed long int)ocbuf->dsize] = (char)0;
        }
        while((_Bool)0);
        c = (unsigned char)0x00;
        do
        {
          if(1 + ocbuf->dsize >= ocbuf->asize)
          {
            ocbuf->asize = ocbuf->asize * 2 + 1 + 1;
            void *return_value_realloc_32;
            return_value_realloc_32=realloc((void *)ocbuf->dptr, (unsigned long int)ocbuf->asize);
            ocbuf->dptr = (char *)return_value_realloc_32;
            if(!(ocbuf->dptr == ((char *)NULL)))
              ocbuf->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(ocbuf->dptr + (signed long int)ocbuf->dsize), (const void *)(char *)&c, (unsigned long int)1);
          ocbuf->dsize = ocbuf->dsize + 1;
          ocbuf->dptr[(signed long int)ocbuf->dsize] = (char)0;
        }
        while((_Bool)0);
        cbmapputcat(db->idxcc, kbuf, ksiz, (const char *)ocbuf->dptr, (signed int)ocbuf->dsize);
        db->icsiz = db->icsiz + (unsigned long int)(signed int)ocbuf->dsize;
        do
        {
          free((void *)ocbuf->dptr);
          free((void *)ocbuf);
        }
        while((_Bool)0);
      }
      while((_Bool)1);
      cbmapclose(qmap);
      cbmapclose(fmap);
      cbmapclose(ocmap);
      err = 0;
      sbuf=cbmapdump(doc->attrs, &ssiz);
      signed int return_value_est_crput_33;
      return_value_est_crput_33=est_crput(db->attrdb, db->zmode, doc->id, sbuf, ssiz, 1);
      if(return_value_est_crput_33 == 0)
      {
        est_set_ecode(&db->ecode, 4, 2273);
        db->fatal = 1;
        err = 1;
      }

      free((void *)sbuf);
      sbuf=cblistdump(doc->dtexts, &ssiz);
      signed int return_value_est_crput_34;
      return_value_est_crput_34=est_crput(db->textdb, db->zmode, doc->id, sbuf, ssiz, 1);
      if(return_value_est_crput_34 == 0)
      {
        est_set_ecode(&db->ecode, 4, 2280);
        db->fatal = 1;
        err = 1;
      }

      free((void *)sbuf);
      if(!(doc->kwords == ((struct anonymous_5 *)NULL)))
      {
        return_value_est_db_put_keywords_35=est_db_put_keywords(db, doc->id, doc->kwords, weight);
        if(return_value_est_db_put_keywords_35 == 0)
          err = 1;

      }

      sprintf(nbuf, "%d", doc->id);
      signed int return_value_vlput_36;
      return_value_vlput_36=vlput(db->listdb, uri, -1, nbuf, -1, 1);
      if(return_value_vlput_36 == 0)
      {
        est_set_ecode(&db->ecode, 4, 2288);
        db->fatal = 1;
        err = 1;
      }

      signed int return_value_cbmaprnum_40;
      return_value_cbmaprnum_40=cbmaprnum(db->aidxs);
      if(return_value_cbmaprnum_40 >= 1)
      {
        cbmapiterinit(db->aidxs);
        do
        {
          kbuf=cbmapiternext(db->aidxs, &ksiz);
          if(kbuf == ((const char *)NULL))
            break;

          vbuf=cbmapget(doc->attrs, kbuf, ksiz, &vsiz);
          if(!(vbuf == ((const char *)NULL)))
          {
            const char *return_value_cbmapiterval_37;
            return_value_cbmapiterval_37=cbmapiterval(kbuf, (signed int *)(void *)0);
            attridx = (struct anonymous_7 *)return_value_cbmapiterval_37;
            if(attridx->type == 1 || attridx->type == 2)
            {
              return_value_est_aidx_attr_put_38=est_aidx_attr_put((struct anonymous_4 *)attridx->db, doc->id, vbuf, vsiz);
              if(return_value_est_aidx_attr_put_38 == 0)
              {
                est_set_ecode(&db->ecode, 4, 2301);
                db->fatal = 1;
                err = 1;
              }

              goto __CPROVER_DUMP_L104;
            }

            signed int return_value_est_aidx_seq_put_39;
            return_value_est_aidx_seq_put_39=est_aidx_seq_put((struct anonymous_1 *)attridx->db, doc->id, vbuf, vsiz);
            if(return_value_est_aidx_seq_put_39 == 0)
            {
              est_set_ecode(&db->ecode, 4, 2308);
              db->fatal = 1;
              err = 1;
            }

          }


        __CPROVER_DUMP_L104:
          ;
        }
        while((_Bool)1);
      }

      db->dnum = db->dnum + 1;
      signed int return_value_est_db_used_cache_size_42;
      return_value_est_db_used_cache_size_42=est_db_used_cache_size(db);
      if(!(db->icmax >= (unsigned long int)return_value_est_db_used_cache_size_42))
      {
        return_value_est_db_flush_41=est_db_flush(db, 0x7fffffff);
        if(return_value_est_db_flush_41 == 0)
          err = 1;

      }

      return err != 0 ? 0 : 1;
    }
  }
}

// est_db_put_keywords
// file estraier.c line 4696
signed int est_db_put_keywords(struct anonymous_0 *db, signed int id, struct anonymous_5 *kwords, double weight)
{
  const char *kbuf;
  char *mbuf;
  signed int err;
  signed int ksiz;
  signed int pair[2l];
  signed int msiz;
  signed int return_value_dpwritable_1;
  return_value_dpwritable_1=dpwritable(db->metadb);
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  if(return_value_dpwritable_1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 4702);
    return 0;
  }

  else
  {
    signed int return_value_crvsiz_2;
    return_value_crvsiz_2=crvsiz(db->attrdb, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
    if(return_value_crvsiz_2 == -1)
    {
      est_set_ecode(&db->ecode, 6, 4706);
      return 0;
    }

    else
    {
      err = 0;
      signed int return_value_est_db_out_keywords_3;
      return_value_est_db_out_keywords_3=est_db_out_keywords(db, id);
      if(return_value_est_db_out_keywords_3 == 0)
      {
        if(!(db->ecode == 6))
          err = 1;

      }

      pair[(signed long int)0] = id;
      cbmapiterinit(kwords);
      do
      {
        kbuf=cbmapiternext(kwords, &ksiz);
        if(kbuf == ((const char *)NULL))
          break;

        if(!(ksiz >= 1))
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          if((signed int)*kbuf >= 0)
            tmp_if_expr_4 = (signed int)kbuf[(signed long int)0] <= 32 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr_5)
        {
          const char *return_value_cbmapiterval_6;
          return_value_cbmapiterval_6=cbmapiterval(kbuf, (signed int *)(void *)0);
          signed int return_value_atoi_7;
          return_value_atoi_7=atoi(return_value_cbmapiterval_6);
          pair[(signed long int)1] = (signed int)((double)return_value_atoi_7 * weight);
          cbmapputcat(db->auxcc, kbuf, ksiz, (char *)pair, (signed int)sizeof(signed int [2l]) /*8ul*/ );
          db->icsiz = db->icsiz + sizeof(signed int [2l]) /*8ul*/ ;
        }

      }
      while((_Bool)1);
      mbuf=cbmapdump(kwords, &msiz);
      signed int return_value_est_crput_8;
      return_value_est_crput_8=est_crput(db->kwddb, db->zmode, id, mbuf, msiz, 0);
      if(return_value_est_crput_8 == 0)
      {
        est_set_ecode(&db->ecode, 4, 4721);
        db->fatal = 1;
        err = 1;
      }

      free((void *)mbuf);
      return err != 0 ? 0 : 1;
    }
  }
}

// est_db_refresh_rescc
// file estraier.c line 5022
void est_db_refresh_rescc(struct anonymous_0 *db)
{
  struct anonymous_8 sc;
  const char *word;
  signed int size;
  sc.id = -1;
  sc.score = 0;
  sc.value = (char *)(void *)0;
  cbmapiterinit(db->rescc);
  do
  {
    word=cbmapiternext(db->rescc, &size);
    if(word == ((const char *)NULL))
      break;

    cbmapput(db->rescc, word, size, (char *)&sc, (signed int)sizeof(struct anonymous_8) /*16ul*/ , 1);
  }
  while((_Bool)1);
}

// est_db_repair
// file estraier.c line 5117
signed int est_db_repair(const char *name, signed int options, signed int *ecp)
{
  struct anonymous_0 *db;
  struct anonymous_1 *depot;
  struct anonymous_1 *metadb;
  struct anonymous_3 *curia;
  struct anonymous_3 *attrdb;
  struct anonymous_3 *textdb;
  struct anonymous_3 *kwddb;
  struct anonymous_4 *villa;
  struct anonymous_4 *listdb;
  struct anonymous_6 *list;
  struct anonymous_5 *aidxs;
  struct anonymous_5 *attrs;
  struct anonymous_7 attridx;
  struct anonymous_7 *attridxp;
  void *aidxdb;
  const char *elem;
  const char *abuf;
  char path[4096l];
  char *kbuf;
  char vbuf[32l];
  char *dec;
  char *mbuf;
  signed int i;
  signed int err;
  signed int idmax;
  signed int flags;
  signed int zmode;
  signed int dnum;
  signed int dseq;
  signed int ksiz;
  signed int vsiz;
  signed int type;
  signed int id;
  signed int msiz;
  signed int esiz;
  signed int asiz;
  sprintf(path, "%s%c%s", name, 47, (const void *)"_meta");
  signed int return_value_est_inode_1;
  return_value_est_inode_1=est_inode(path);
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_15;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_19;
  _Bool tmp_if_expr_20;
  signed int return_value_cbstrfwmatch_24;
  _Bool tmp_if_expr_21;
  signed int return_value_cbstrfwmatch_23;
  _Bool tmp_if_expr_22;
  signed int return_value_cbstrfwmatch_31;
  signed int return_value_cbstrfwmatch_30;
  struct anonymous_4 *return_value_vlopen_33;
  struct anonymous_4 *return_value_vlopen_34;
  signed int return_value_crbnum_35;
  struct anonymous_1 *return_value_dpopen_36;
  _Bool tmp_if_expr_44;
  _Bool tmp_if_expr_46;
  signed int return_value_crvsiz_45;
  _Bool tmp_if_expr_48;
  signed int return_value_crvsiz_47;
  signed int return_value_vlclose_53;
  if(return_value_est_inode_1 == -1)
  {
    est_set_ecode(ecp, 5, 5132);
    return 0;
  }

  else
  {
    if((1 & options) == 0)
    {
      depot=dpopen(path, 2, -1);
      tmp_if_expr_2 = depot != (struct anonymous_1 *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      dpclose(depot);

    else
      dprepair(path);
    sprintf(path, "%s%c%s", name, 47, (const void *)"_idx");
    signed int return_value_est_inode_3;
    return_value_est_inode_3=est_inode(path);
    if(return_value_est_inode_3 == -1)
    {
      est_set_ecode(ecp, 5, 5142);
      return 0;
    }

    else
    {
      list=cbdirlist(path);
      if(!(list == ((struct anonymous_6 *)NULL)))
      {
        i = 1;
        for( ; !(i >= list->num); i = i + 1)
        {
          elem = (const char *)(list->array + (signed long int)(list->start + i))->dptr;
          if(!((signed int)*elem >= 48))
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = (signed int)elem[(signed long int)0] > 57 ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr_4)
          {
            sprintf(path, "%s%c%s%c%s", name, 47, (const void *)"_idx", 47, elem);
            if((1 & options) == 0)
            {
              villa=vlopen(path, 2, VL_CMPLEX);
              tmp_if_expr_5 = villa != (struct anonymous_4 *)(void *)0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_5 = (_Bool)0;
            if(tmp_if_expr_5)
              vlclose(villa);

            else
              vlrepair(path, VL_CMPLEX);
          }

        }
        do
        {
          signed int est_db_repair__1__5__2___CB_i;
          signed int est_db_repair__1__5__2___CB_end = list->start + list->num;
          est_db_repair__1__5__2___CB_i = list->start;
          for( ; !(est_db_repair__1__5__2___CB_i >= est_db_repair__1__5__2___CB_end); est_db_repair__1__5__2___CB_i = est_db_repair__1__5__2___CB_i + 1)
            free((void *)(list->array + (signed long int)est_db_repair__1__5__2___CB_i)->dptr);
          free((void *)list->array);
          free((void *)list);
        }
        while((_Bool)0);
      }

      sprintf(path, "%s%c%s", name, 47, (const void *)"_fwm");
      signed int return_value_est_inode_6;
      return_value_est_inode_6=est_inode(path);
      if(return_value_est_inode_6 == -1)
      {
        est_set_ecode(ecp, 5, 5160);
        return 0;
      }

      else
      {
        if((1 & options) == 0)
        {
          villa=vlopen(path, 2, VL_CMPLEX);
          tmp_if_expr_7 = villa != (struct anonymous_4 *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_7 = (_Bool)0;
        if(tmp_if_expr_7)
          vlclose(villa);

        else
          vlrepair(path, VL_CMPLEX);
        sprintf(path, "%s%c%s", name, 47, (const void *)"_aux");
        signed int return_value_est_inode_8;
        return_value_est_inode_8=est_inode(path);
        if(return_value_est_inode_8 == -1)
        {
          est_set_ecode(ecp, 5, 5170);
          return 0;
        }

        else
        {
          if((1 & options) == 0)
          {
            villa=vlopen(path, 2, VL_CMPLEX);
            tmp_if_expr_9 = villa != (struct anonymous_4 *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_9 = (_Bool)0;
          if(tmp_if_expr_9)
            vlclose(villa);

          else
            vlrepair(path, VL_CMPLEX);
          sprintf(path, "%s%c%s", name, 47, (const void *)"_xfm");
          signed int return_value_est_inode_10;
          return_value_est_inode_10=est_inode(path);
          if(return_value_est_inode_10 == -1)
          {
            est_set_ecode(ecp, 5, 5180);
            return 0;
          }

          else
          {
            if((1 & options) == 0)
            {
              villa=vlopen(path, 2, VL_CMPLEX);
              tmp_if_expr_11 = villa != (struct anonymous_4 *)(void *)0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_11 = (_Bool)0;
            if(tmp_if_expr_11)
              vlclose(villa);

            else
              vlrepair(path, VL_CMPLEX);
            sprintf(path, "%s%c%s", name, 47, (const void *)"_attr");
            signed int return_value_est_inode_12;
            return_value_est_inode_12=est_inode(path);
            if(return_value_est_inode_12 == -1)
            {
              est_set_ecode(ecp, 5, 5190);
              return 0;
            }

            else
            {
              if((1 & options) == 0)
              {
                curia=cropen(path, 2, -1, -1);
                tmp_if_expr_13 = curia != (struct anonymous_3 *)(void *)0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_13 = (_Bool)0;
              if(tmp_if_expr_13)
                crclose(curia);

              else
                crrepair(path);
              sprintf(path, "%s%c%s", name, 47, (const void *)"_text");
              signed int return_value_est_inode_14;
              return_value_est_inode_14=est_inode(path);
              if(return_value_est_inode_14 == -1)
              {
                est_set_ecode(ecp, 5, 5200);
                return 0;
              }

              else
              {
                if((1 & options) == 0)
                {
                  curia=cropen(path, 2, -1, -1);
                  tmp_if_expr_15 = curia != (struct anonymous_3 *)(void *)0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_15 = (_Bool)0;
                if(tmp_if_expr_15)
                  crclose(curia);

                else
                  crrepair(path);
                sprintf(path, "%s%c%s", name, 47, (const void *)"_kwd");
                signed int return_value_est_inode_16;
                return_value_est_inode_16=est_inode(path);
                if(return_value_est_inode_16 == -1)
                {
                  est_set_ecode(ecp, 5, 5210);
                  return 0;
                }

                else
                {
                  if((1 & options) == 0)
                  {
                    curia=cropen(path, 2, -1, -1);
                    tmp_if_expr_17 = curia != (struct anonymous_3 *)(void *)0 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr_17 = (_Bool)0;
                  if(tmp_if_expr_17)
                    crclose(curia);

                  else
                    crrepair(path);
                  sprintf(path, "%s%c%s", name, 47, (const void *)"_list");
                  signed int return_value_est_inode_18;
                  return_value_est_inode_18=est_inode(path);
                  if(return_value_est_inode_18 == -1)
                  {
                    est_set_ecode(ecp, 5, 5220);
                    return 0;
                  }

                  else
                  {
                    if((1 & options) == 0)
                    {
                      villa=vlopen(path, 2, VL_CMPLEX);
                      tmp_if_expr_19 = villa != (struct anonymous_4 *)(void *)0 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_19 = (_Bool)0;
                    if(tmp_if_expr_19)
                      vlclose(villa);

                    else
                      vlrepair(path, VL_CMPLEX);
                    list=cbdirlist(name);
                    if(!(list == ((struct anonymous_6 *)NULL)))
                    {
                      i = 0;
                      for( ; !(i >= list->num); i = i + 1)
                      {
                        elem = (const char *)(list->array + (signed long int)(list->start + i))->dptr;
                        signed int return_value_cbstrfwmatch_25;
                        return_value_cbstrfwmatch_25=cbstrfwmatch(elem, "__seq_");
                        if(!(return_value_cbstrfwmatch_25 == 0))
                        {
                          sprintf(path, "%s%c%s", name, 47, elem);
                          if((1 & options) == 0)
                          {
                            depot=dpopen(path, 2, -1);
                            tmp_if_expr_20 = depot != (struct anonymous_1 *)(void *)0 ? (_Bool)1 : (_Bool)0;
                          }

                          else
                            tmp_if_expr_20 = (_Bool)0;
                          if(tmp_if_expr_20)
                            dpclose(depot);

                          else
                            dprepair(path);
                        }

                        else
                        {
                          return_value_cbstrfwmatch_24=cbstrfwmatch(elem, "__str_");
                          if(!(return_value_cbstrfwmatch_24 == 0))
                          {
                            sprintf(path, "%s%c%s", name, 47, elem);
                            if((1 & options) == 0)
                            {
                              villa=vlopen(path, 2, VL_CMPLEX);
                              tmp_if_expr_21 = villa != (struct anonymous_4 *)(void *)0 ? (_Bool)1 : (_Bool)0;
                            }

                            else
                              tmp_if_expr_21 = (_Bool)0;
                            if(tmp_if_expr_21)
                              vlclose(villa);

                            else
                              vlrepair(path, VL_CMPLEX);
                          }

                          else
                          {
                            return_value_cbstrfwmatch_23=cbstrfwmatch(elem, "__num_");
                            if(!(return_value_cbstrfwmatch_23 == 0))
                            {
                              sprintf(path, "%s%c%s", name, 47, elem);
                              if((1 & options) == 0)
                              {
                                villa=vlopen(path, 2, VL_CMPLEX);
                                tmp_if_expr_22 = villa != (struct anonymous_4 *)(void *)0 ? (_Bool)1 : (_Bool)0;
                              }

                              else
                                tmp_if_expr_22 = (_Bool)0;
                              if(tmp_if_expr_22)
                                vlclose(villa);

                              else
                                vlrepair(path, VL_CMPLEX);
                            }

                          }
                        }
                      }
                      do
                      {
                        signed int _CB_i;
                        signed int _CB_end = list->start + list->num;
                        _CB_i = list->start;
                        for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
                          free((void *)(list->array + (signed long int)_CB_i)->dptr);
                        free((void *)list->array);
                        free((void *)list);
                      }
                      while((_Bool)0);
                    }

                    if(!((2 & options) == 0))
                    {
                      db=est_db_open(name, 2, ecp);
                      if(!(db == ((struct anonymous_0 *)NULL)))
                      {
                        signed int return_value_est_db_close_26;
                        return_value_est_db_close_26=est_db_close(db, ecp);
                        if(return_value_est_db_close_26 == 0)
                          return 0;

                        return 1;
                      }

                    }

                    sprintf(path, "%s%c%s", name, 47, (const void *)"_meta");
                    metadb=dpopen(path, 2, -1);
                    sprintf(path, "%s%c%s", name, 47, (const void *)"_attr");
                    attrdb=cropen(path, 2, -1, -1);
                    sprintf(path, "%s%c%s", name, 47, (const void *)"_text");
                    textdb=cropen(path, 2, -1, -1);
                    sprintf(path, "%s%c%s", name, 47, (const void *)"_kwd");
                    kwddb=cropen(path, 2, -1, -1);
                    sprintf(path, "%s%c%s", name, 47, (const void *)"_list");
                    listdb=vlopen(path, 2, VL_CMPLEX);
                    if(attrdb == ((struct anonymous_3 *)NULL) || kwddb == ((struct anonymous_3 *)NULL) || textdb == ((struct anonymous_3 *)NULL) || listdb == ((struct anonymous_4 *)NULL))
                    {
                      if(!(listdb == ((struct anonymous_4 *)NULL)))
                        vlclose(listdb);

                      if(!(kwddb == ((struct anonymous_3 *)NULL)))
                        crclose(kwddb);

                      if(!(textdb == ((struct anonymous_3 *)NULL)))
                        crclose(textdb);

                      if(!(attrdb == ((struct anonymous_3 *)NULL)))
                        crclose(attrdb);

                      if(!(metadb == ((struct anonymous_1 *)NULL)))
                        dpclose(metadb);

                      est_set_ecode(ecp, 4, 5276);
                      return 0;
                    }

                    else
                    {
                      aidxs=cbmapopenex(31);
                      list=cbdirlist(name);
                      if(!(list == ((struct anonymous_6 *)NULL)))
                      {
                        i = 0;
                        for( ; !(i >= list->num); i = i + 1)
                        {
                          elem = (const char *)(list->array + (signed long int)(list->start + i))->dptr;
                          dec = (char *)(void *)0;
                          type = -1;
                          signed int return_value_cbstrfwmatch_32;
                          return_value_cbstrfwmatch_32=cbstrfwmatch(elem, "__seq_");
                          if(!(return_value_cbstrfwmatch_32 == 0))
                          {
                            unsigned long int return_value_strlen_27;
                            return_value_strlen_27=strlen("__seq_");
                            dec=est_hex_decode(elem + (signed long int)return_value_strlen_27);
                            type = 0;
                          }

                          else
                          {
                            return_value_cbstrfwmatch_31=cbstrfwmatch(elem, "__str_");
                            if(!(return_value_cbstrfwmatch_31 == 0))
                            {
                              unsigned long int return_value_strlen_28;
                              return_value_strlen_28=strlen("__str_");
                              dec=est_hex_decode(elem + (signed long int)return_value_strlen_28);
                              type = 1;
                            }

                            else
                            {
                              return_value_cbstrfwmatch_30=cbstrfwmatch(elem, "__num_");
                              if(!(return_value_cbstrfwmatch_30 == 0))
                              {
                                unsigned long int return_value_strlen_29;
                                return_value_strlen_29=strlen("__num_");
                                dec=est_hex_decode(elem + (signed long int)return_value_strlen_29);
                                type = 2;
                              }

                            }
                          }
                          if(!(dec == ((char *)NULL)))
                          {
                            sprintf(path, "%s%c%s", name, 47, elem);
                            switch(type)
                            {
                              case 1:
                              {
                                return_value_vlopen_33=vlopen(path, 2, VL_CMPLEX);
                                aidxdb = (void *)return_value_vlopen_33;
                                if(!(aidxdb == NULL))
                                {
                                  vlsettuning((struct anonymous_4 *)aidxdb, 99, 120, 1024, 256);
                                  vlsetfbpsiz((struct anonymous_4 *)aidxdb, 128);
                                  attridx.db = aidxdb;
                                  attridx.type = type;
                                  cbmapput(aidxs, dec, -1, (char *)&attridx, (signed int)sizeof(struct anonymous_7) /*16ul*/ , 0);
                                }

                                break;
                              }
                              case 2:
                              {
                                return_value_vlopen_34=vlopen(path, 2, est_aidx_numcmp);
                                aidxdb = (void *)return_value_vlopen_34;
                                if(!(aidxdb == NULL))
                                {
                                  vlsettuning((struct anonymous_4 *)aidxdb, 99, 120, 1024, 256);
                                  vlsetfbpsiz((struct anonymous_4 *)aidxdb, 128);
                                  attridx.db = aidxdb;
                                  attridx.type = type;
                                  cbmapput(aidxs, dec, -1, (char *)&attridx, (signed int)sizeof(struct anonymous_7) /*16ul*/ , 0);
                                }

                                break;
                              }
                              default:
                              {
                                return_value_crbnum_35=crbnum(attrdb);
                                return_value_dpopen_36=dpopen(path, 2, (signed int)((double)return_value_crbnum_35 / 0.8));
                                aidxdb = (void *)return_value_dpopen_36;
                                if(!(aidxdb == NULL))
                                {
                                  dpsetfbpsiz((struct anonymous_1 *)aidxdb, 32);
                                  attridx.db = aidxdb;
                                  attridx.type = type;
                                  cbmapput(aidxs, dec, -1, (char *)&attridx, (signed int)sizeof(struct anonymous_7) /*16ul*/ , 0);
                                }

                              }
                            }
                            free((void *)dec);
                          }

                        }
                        do
                        {
                          signed int est_db_repair__1__30__2___CB_i;
                          signed int est_db_repair__1__30__2___CB_end = list->start + list->num;
                          est_db_repair__1__30__2___CB_i = list->start;
                          for( ; !(est_db_repair__1__30__2___CB_i >= est_db_repair__1__30__2___CB_end); est_db_repair__1__30__2___CB_i = est_db_repair__1__30__2___CB_i + 1)
                            free((void *)(list->array + (signed long int)est_db_repair__1__30__2___CB_i)->dptr);
                          free((void *)list->array);
                          free((void *)list);
                        }
                        while((_Bool)0);
                      }

                      err = 0;
                      idmax = 0;
                      vsiz=dpgetwb(metadb, "_dnum", -1, 0, 32 - 1, vbuf);
                      if(vsiz >= 1)
                      {
                        vbuf[(signed long int)vsiz] = (char)0;
                        idmax=atoi(vbuf);
                      }

                      flags=dpgetflags(metadb);
                      zmode = 0;
                      if(!((32768 & flags) == 0))
                        zmode = 32768;

                      else
                        if(!((65536 & flags) == 0))
                          zmode = 65536;

                        else
                          if(!((131072 & flags) == 0))
                            zmode = 131072;

                      dnum = 0;
                      dseq = 0;
                      do
                      {
                        void *return_value_malloc_37;
                        return_value_malloc_37=malloc(sizeof(struct anonymous_6) /*24ul*/ );
                        list = (struct anonymous_6 *)return_value_malloc_37;
                        if(!(list == ((struct anonymous_6 *)NULL)))
                          list;

                        else
                          cbmyfatal("out of memory");
                        list->anum = 64;
                        void *return_value_malloc_38;
                        return_value_malloc_38=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)list->anum);
                        list->array = (struct anonymous_28 *)return_value_malloc_38;
                        if(!(list->array == ((struct anonymous_28 *)NULL)))
                          list->array;

                        else
                          cbmyfatal("out of memory");
                        list->start = 0;
                        list->num = 0;
                      }
                      while((_Bool)0);
                      signed int return_value_criterinit_39;
                      return_value_criterinit_39=criterinit(attrdb);
                      if(return_value_criterinit_39 == 0)
                        err = 1;

                      do
                      {
                        kbuf=criternext(attrdb, &ksiz);
                        if(kbuf == ((char *)NULL))
                          break;

                        if((unsigned long int)ksiz == sizeof(signed int) /*4ul*/ )
                        {
                          id = *((signed int *)kbuf);
                          tmp_if_expr_44 = id > 0 ? (_Bool)1 : (_Bool)0;
                        }

                        else
                          tmp_if_expr_44 = (_Bool)0;
                        if(idmax >= id && tmp_if_expr_44)
                        {
                          return_value_crvsiz_45=crvsiz(attrdb, kbuf, ksiz);
                          tmp_if_expr_46 = return_value_crvsiz_45 > 0 ? (_Bool)1 : (_Bool)0;
                        }

                        else
                          tmp_if_expr_46 = (_Bool)0;
                        if(tmp_if_expr_46)
                        {
                          return_value_crvsiz_47=crvsiz(textdb, kbuf, ksiz);
                          tmp_if_expr_48 = return_value_crvsiz_47 > 0 ? (_Bool)1 : (_Bool)0;
                        }

                        else
                          tmp_if_expr_48 = (_Bool)0;
                        if(tmp_if_expr_48)
                        {
                          dnum = dnum + 1;
                          if(!(dseq >= id))
                            dseq = id;

                          if(!((1 & options) == 0))
                          {
                            mbuf=est_crget(attrdb, zmode, id, &msiz);
                            if(!(mbuf == ((char *)NULL)))
                            {
                              attrs=cbmapload(mbuf, msiz);
                              elem=cbmapget(attrs, "@uri", -1, &esiz);
                              if(!(elem == ((const char *)NULL)))
                              {
                                vsiz=sprintf(vbuf, "%d", id);
                                vlput(listdb, elem, esiz, vbuf, vsiz, 1);
                              }

                              signed int return_value_cbmaprnum_41;
                              return_value_cbmaprnum_41=cbmaprnum(aidxs);
                              if(return_value_cbmaprnum_41 >= 1)
                              {
                                cbmapiterinit(aidxs);
                                do
                                {
                                  abuf=cbmapiternext(aidxs, &asiz);
                                  if(abuf == ((const char *)NULL))
                                    break;

                                  elem=cbmapget(attrs, abuf, asiz, &esiz);
                                  if(!(elem == ((const char *)NULL)))
                                  {
                                    const char *return_value_cbmapiterval_40;
                                    return_value_cbmapiterval_40=cbmapiterval(abuf, (signed int *)(void *)0);
                                    attridxp = (struct anonymous_7 *)return_value_cbmapiterval_40;
                                    if(attridxp->type == 1 || attridxp->type == 2)
                                    {
                                      est_aidx_attr_put((struct anonymous_4 *)attridxp->db, id, elem, esiz);
                                      goto __CPROVER_DUMP_L117;
                                    }

                                    est_aidx_seq_put((struct anonymous_1 *)attridxp->db, id, elem, esiz);
                                  }


                                __CPROVER_DUMP_L117:
                                  ;
                                }
                                while((_Bool)1);
                              }

                              cbmapclose(attrs);
                              free((void *)mbuf);
                            }

                          }

                        }

                        else
                          do
                          {
                            signed int _CB_index = list->start + list->num;
                            if(_CB_index >= list->anum)
                            {
                              list->anum = list->anum * 2;
                              void *return_value_realloc_42;
                              return_value_realloc_42=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous_28) /*16ul*/ );
                              list->array = (struct anonymous_28 *)return_value_realloc_42;
                              if(!(list->array == ((struct anonymous_28 *)NULL)))
                                list->array;

                              else
                                cbmyfatal("out of memory");
                            }

                            void *return_value_malloc_43;
                            return_value_malloc_43=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
                            (list->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_43;
                            if(!((list->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
                              (list->array + (signed long int)_CB_index)->dptr;

                            else
                              cbmyfatal("out of memory");
                            memcpy((void *)(list->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
                            (list->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
                            (list->array + (signed long int)_CB_index)->dsize = ksiz;
                            list->num = list->num + 1;
                          }
                          while((_Bool)0);
                        free((void *)kbuf);
                      }
                      while((_Bool)1);
                      signed int *return_value_dpecodeptr_49;
                      return_value_dpecodeptr_49=dpecodeptr();
                      if(!(*return_value_dpecodeptr_49 == 5))
                        err = 1;

                      i = 0;
                      for( ; !(i >= list->num); i = i + 1)
                      {
                        esiz = (list->array + (signed long int)(list->start + i))->dsize;
                        elem = (const char *)(list->array + (signed long int)(list->start + i))->dptr;
                        crout(attrdb, elem, esiz);
                        crout(textdb, elem, esiz);
                        crout(kwddb, elem, esiz);
                      }
                      do
                      {
                        signed int est_db_repair__1__38___CB_i;
                        signed int est_db_repair__1__38___CB_end = list->start + list->num;
                        est_db_repair__1__38___CB_i = list->start;
                        for( ; !(est_db_repair__1__38___CB_i >= est_db_repair__1__38___CB_end); est_db_repair__1__38___CB_i = est_db_repair__1__38___CB_i + 1)
                          free((void *)(list->array + (signed long int)est_db_repair__1__38___CB_i)->dptr);
                        free((void *)list->array);
                        free((void *)list);
                      }
                      while((_Bool)0);
                      sprintf(vbuf, "%d", dseq);
                      signed int return_value_dpput_50;
                      return_value_dpput_50=dpput(metadb, "_dseq", -1, vbuf, -1, 0);
                      if(return_value_dpput_50 == 0)
                        err = 1;

                      sprintf(vbuf, "%d", dnum);
                      signed int return_value_dpput_51;
                      return_value_dpput_51=dpput(metadb, "_dnum", -1, vbuf, -1, 0);
                      if(return_value_dpput_51 == 0)
                        err = 1;

                      cbmapiterinit(aidxs);
                      do
                      {
                        elem=cbmapiternext(aidxs, (signed int *)(void *)0);
                        if(elem == ((const char *)NULL))
                          break;

                        const char *return_value_cbmapiterval_52;
                        return_value_cbmapiterval_52=cbmapiterval(elem, (signed int *)(void *)0);
                        attridxp = (struct anonymous_7 *)return_value_cbmapiterval_52;
                        if(attridxp->type == 1 || attridxp->type == 2)
                        {
                          return_value_vlclose_53=vlclose((struct anonymous_4 *)attridxp->db);
                          if(return_value_vlclose_53 == 0)
                            err = 1;

                          goto __CPROVER_DUMP_L141;
                        }

                        signed int return_value_dpclose_54;
                        return_value_dpclose_54=dpclose((struct anonymous_1 *)attridxp->db);
                        if(return_value_dpclose_54 == 0)
                          err = 1;


                      __CPROVER_DUMP_L141:
                        ;
                      }
                      while((_Bool)1);
                      cbmapclose(aidxs);
                      signed int return_value_vlclose_55;
                      return_value_vlclose_55=vlclose(listdb);
                      if(return_value_vlclose_55 == 0)
                        err = 1;

                      signed int return_value_crclose_56;
                      return_value_crclose_56=crclose(kwddb);
                      if(return_value_crclose_56 == 0)
                        err = 1;

                      signed int return_value_crclose_57;
                      return_value_crclose_57=crclose(textdb);
                      if(return_value_crclose_57 == 0)
                        err = 1;

                      signed int return_value_crclose_58;
                      return_value_crclose_58=crclose(attrdb);
                      if(return_value_crclose_58 == 0)
                        err = 1;

                      signed int return_value_dpclose_59;
                      return_value_dpclose_59=dpclose(metadb);
                      if(return_value_dpclose_59 == 0)
                        err = 1;

                      if(!(err == 0))
                      {
                        est_set_ecode(ecp, 4, 5418);
                        return 0;
                      }

                      else
                        return err != 0 ? 0 : 1;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// est_db_scan_doc
// file estraier.c line 3226
signed int est_db_scan_doc(struct anonymous_0 *db, struct anonymous_14 *doc, struct anonymous_15 *cond)
{
  /* tag-#anon#lST[l*{S8}_S8_'word'|S32'num'|U32'_pad0'] */
struct anonymous_36
{
  // word
  char *word;
  // num
  signed int num;
};

/* */
  ;
  struct anonymous_36 wsets[256l];
  struct anonymous_6 *terms;
  struct anonymous_6 *words;
  const char *term;
  const char *text;
  unsigned char *rbuf;
  char *tmp;
  signed int i;
  signed int j;
  signed int k;
  signed int wsnum;
  signed int add;
  signed int rsiz;
  signed int hit;
  _Bool tmp_if_expr_2;
  signed int return_value_cbstrfwmatch_1;
  if(cond->phrase == ((char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_cbstrfwmatch_1=cbstrfwmatch(cond->phrase, "[SIMILAR]");
    tmp_if_expr_2 = return_value_cbstrfwmatch_1 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_4;
  signed int return_value_cbstrfwmatch_3;
  if(tmp_if_expr_2)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_cbstrfwmatch_3=cbstrfwmatch(cond->phrase, "[ID]");
    tmp_if_expr_4 = return_value_cbstrfwmatch_3 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_6;
  signed int return_value_cbstrfwmatch_5;
  if(tmp_if_expr_4)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_cbstrfwmatch_5=cbstrfwmatch(cond->phrase, "[URI]");
    tmp_if_expr_6 = return_value_cbstrfwmatch_5 != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_9;
  _Bool tmp_if_expr_12;
  if(tmp_if_expr_6)
    return 0;

  else
  {
    if(doc->dtexts == ((struct anonymous_6 *)NULL))
      do
      {
        void *return_value_malloc_7;
        return_value_malloc_7=malloc(sizeof(struct anonymous_6) /*24ul*/ );
        doc->dtexts = (struct anonymous_6 *)return_value_malloc_7;
        if(!(doc->dtexts == ((struct anonymous_6 *)NULL)))
          doc->dtexts;

        else
          cbmyfatal("out of memory");
        doc->dtexts->anum = 64;
        void *return_value_malloc_8;
        return_value_malloc_8=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)doc->dtexts->anum);
        doc->dtexts->array = (struct anonymous_28 *)return_value_malloc_8;
        if(!(doc->dtexts->array == ((struct anonymous_28 *)NULL)))
          doc->dtexts->array;

        else
          cbmyfatal("out of memory");
        doc->dtexts->start = 0;
        doc->dtexts->num = 0;
      }
      while((_Bool)0);

    if(!(cond->pmode == 1))
    {
      if(cond->pmode == 2)
        goto __CPROVER_DUMP_L15;

      if(cond->pmode == 3)
        goto __CPROVER_DUMP_L16;

      if(cond->pmode == 4)
        goto __CPROVER_DUMP_L17;

      terms=est_phrase_terms(cond->phrase);
    }

    else
    {
      tmp=est_phrase_from_simple(cond->phrase);
      terms=est_phrase_terms(tmp);
      free((void *)tmp);
      goto __CPROVER_DUMP_L18;

    __CPROVER_DUMP_L15:
      ;
      tmp=est_phrase_from_rough(cond->phrase);
      terms=est_phrase_terms(tmp);
      free((void *)tmp);
      goto __CPROVER_DUMP_L18;

    __CPROVER_DUMP_L16:
      ;
      tmp=est_phrase_from_union(cond->phrase);
      terms=est_phrase_terms(tmp);
      free((void *)tmp);
      goto __CPROVER_DUMP_L18;

    __CPROVER_DUMP_L17:
      ;
      tmp=est_phrase_from_isect(cond->phrase);
      terms=est_phrase_terms(tmp);
      free((void *)tmp);
    }

  __CPROVER_DUMP_L18:
    ;
    wsnum = 0;
    add = 1;
    i = 0;
    for( ; !(i >= terms->num); i = i + 1)
    {
      term = (const char *)(terms->array + (signed long int)(terms->start + i))->dptr;
      signed int return_value_strcmp_11;
      return_value_strcmp_11=strcmp(term, "AND");
      if(return_value_strcmp_11 == 0)
        add = 1;

      else
      {
        return_value_strcmp_10=strcmp(term, "ANDNOT");
        if(return_value_strcmp_10 == 0)
          add = 0;

        else
          if(!(add == 0))
          {
            return_value_strcmp_9=strcmp(term, "[UVSET]");
            if(!(return_value_strcmp_9 == 0))
            {
              if((signed int)*term == 32)
              {
                term = term + 1l;
                if((signed int)*term == 98)
                  term = term + 1l;

                else
                  if((signed int)*term == 101)
                    term = term + 1l;

              }

              words=cbsplit(term, -1, "\t");
              for( ; !(wsnum >= 256); wsnum = wsnum + 1)
              {
                if(!(words->num >= 1))
                  break;

                wsets[(signed long int)wsnum].word=cblistshift(words, (signed int *)(void *)0);
                wsets[(signed long int)wsnum].num = i;
              }
              do
              {
                signed int _CB_i;
                signed int _CB_end = words->start + words->num;
                _CB_i = words->start;
                for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
                  free((void *)(words->array + (signed long int)_CB_i)->dptr);
                free((void *)words->array);
                free((void *)words);
              }
              while((_Bool)0);
            }

          }

      }
    }
    i = -1;
    for( ; !(i >= doc->dtexts->num); i = i + 1)
    {
      if(!(i >= 0))
      {
        if(doc->attrs == ((struct anonymous_5 *)NULL))
          tmp_if_expr_12 = (_Bool)1;

        else
        {
          text=cbmapget(doc->attrs, "", 0, (signed int *)(void *)0);
          tmp_if_expr_12 = !(text != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_12)
          goto __CPROVER_DUMP_L41;

      }

      else
        text = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
      unsigned long int return_value_strlen_13;
      return_value_strlen_13=strlen(text);
      char *return_value_est_uconv_in_14;
      return_value_est_uconv_in_14=est_uconv_in(text, (signed int)return_value_strlen_13, &rsiz);
      rbuf = (unsigned char *)return_value_est_uconv_in_14;
      est_canonicalize_text(rbuf, rsiz, 0);
      tmp=est_uconv_out((char *)rbuf, rsiz, &rsiz);
      j = 0;
      for( ; !(j >= wsnum); j = j + 1)
        if(!(wsets[(signed long int)j].word == ((char *)NULL)))
        {
          char *return_value_est_strstr_sparse_15;
          return_value_est_strstr_sparse_15=est_strstr_sparse(tmp, wsets[(signed long int)j].word);
          if(!(return_value_est_strstr_sparse_15 == ((char *)NULL)))
          {
            k = 0;
            for( ; !(k >= wsnum); k = k + 1)
              if(!(wsets[(signed long int)k].word == ((char *)NULL)))
              {
                if(wsets[(signed long int)k].num == wsets[(signed long int)j].num)
                {
                  free((void *)wsets[(signed long int)k].word);
                  wsets[(signed long int)k].word = (char *)(void *)0;
                }

              }

          }

        }

      free((void *)tmp);
      free((void *)rbuf);

    __CPROVER_DUMP_L41:
      ;
    }
    hit = 1;
    i = 0;
    for( ; !(i >= wsnum); i = i + 1)
      if(!(wsets[(signed long int)i].word == ((char *)NULL)))
      {
        free((void *)wsets[(signed long int)i].word);
        hit = 0;
      }

    do
    {
      signed int est_db_scan_doc__1__6___CB_i;
      signed int est_db_scan_doc__1__6___CB_end = terms->start + terms->num;
      est_db_scan_doc__1__6___CB_i = terms->start;
      for( ; !(est_db_scan_doc__1__6___CB_i >= est_db_scan_doc__1__6___CB_end); est_db_scan_doc__1__6___CB_i = est_db_scan_doc__1__6___CB_i + 1)
        free((void *)(terms->array + (signed long int)est_db_scan_doc__1__6___CB_i)->dptr);
      free((void *)terms->array);
      free((void *)terms);
    }
    while((_Bool)0);
    return hit;
  }
}

// est_db_score_doc
// file estraier.c line 7836
static signed int est_db_score_doc(struct anonymous_0 *db, struct anonymous_14 *doc, struct anonymous_15 *cond, signed int *scp)
{
  /* tag-#anon#lST[l*{S8}_S8_'word'|S32'num'|U32'_pad0'] */
struct anonymous_36
{
  // word
  char *word;
  // num
  signed int num;
};

/* */
  ;
  struct anonymous_36 wsets[256l];
  struct anonymous_36 nsets[256l];
  struct anonymous_6 *terms;
  struct anonymous_6 *words;
  const char *term;
  const char *text;
  const char *rp;
  unsigned char *rbuf;
  char *tmp;
  signed int i;
  signed int j;
  signed int k;
  signed int sc;
  signed int wsnum;
  signed int nsnum;
  signed int asiz;
  signed int tsiz;
  signed int add;
  signed int rsiz;
  signed int hit;
  double tune;
  *scp = 0;
  _Bool tmp_if_expr_2;
  signed int return_value_cbstrfwmatch_1;
  if(cond->phrase == ((char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_cbstrfwmatch_1=cbstrfwmatch(cond->phrase, "[SIMILAR]");
    tmp_if_expr_2 = return_value_cbstrfwmatch_1 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_4;
  signed int return_value_cbstrfwmatch_3;
  if(tmp_if_expr_2)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_cbstrfwmatch_3=cbstrfwmatch(cond->phrase, "[ID]");
    tmp_if_expr_4 = return_value_cbstrfwmatch_3 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_6;
  signed int return_value_cbstrfwmatch_5;
  if(tmp_if_expr_4)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_cbstrfwmatch_5=cbstrfwmatch(cond->phrase, "[URI]");
    tmp_if_expr_6 = return_value_cbstrfwmatch_5 != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_9;
  signed int return_value_atoi_12;
  _Bool tmp_if_expr_13;
  if(tmp_if_expr_6)
    return 0;

  else
  {
    if(doc->dtexts == ((struct anonymous_6 *)NULL))
      do
      {
        void *return_value_malloc_7;
        return_value_malloc_7=malloc(sizeof(struct anonymous_6) /*24ul*/ );
        doc->dtexts = (struct anonymous_6 *)return_value_malloc_7;
        if(!(doc->dtexts == ((struct anonymous_6 *)NULL)))
          doc->dtexts;

        else
          cbmyfatal("out of memory");
        doc->dtexts->anum = 64;
        void *return_value_malloc_8;
        return_value_malloc_8=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)doc->dtexts->anum);
        doc->dtexts->array = (struct anonymous_28 *)return_value_malloc_8;
        if(!(doc->dtexts->array == ((struct anonymous_28 *)NULL)))
          doc->dtexts->array;

        else
          cbmyfatal("out of memory");
        doc->dtexts->start = 0;
        doc->dtexts->num = 0;
      }
      while((_Bool)0);

    if(!(cond->pmode == 1))
    {
      if(cond->pmode == 2)
        goto __CPROVER_DUMP_L15;

      if(cond->pmode == 3)
        goto __CPROVER_DUMP_L16;

      if(cond->pmode == 4)
        goto __CPROVER_DUMP_L17;

      terms=est_phrase_terms(cond->phrase);
    }

    else
    {
      tmp=est_phrase_from_simple(cond->phrase);
      terms=est_phrase_terms(tmp);
      free((void *)tmp);
      goto __CPROVER_DUMP_L18;

    __CPROVER_DUMP_L15:
      ;
      tmp=est_phrase_from_rough(cond->phrase);
      terms=est_phrase_terms(tmp);
      free((void *)tmp);
      goto __CPROVER_DUMP_L18;

    __CPROVER_DUMP_L16:
      ;
      tmp=est_phrase_from_union(cond->phrase);
      terms=est_phrase_terms(tmp);
      free((void *)tmp);
      goto __CPROVER_DUMP_L18;

    __CPROVER_DUMP_L17:
      ;
      tmp=est_phrase_from_isect(cond->phrase);
      terms=est_phrase_terms(tmp);
      free((void *)tmp);
    }

  __CPROVER_DUMP_L18:
    ;
    wsnum = 0;
    nsnum = 0;
    add = 1;
    i = 0;
    for( ; !(i >= terms->num); i = i + 1)
    {
      term = (const char *)(terms->array + (signed long int)(terms->start + i))->dptr;
      signed int return_value_strcmp_11;
      return_value_strcmp_11=strcmp(term, "AND");
      if(return_value_strcmp_11 == 0)
        add = 1;

      else
      {
        return_value_strcmp_10=strcmp(term, "ANDNOT");
        if(return_value_strcmp_10 == 0)
          add = 0;

        else
        {
          return_value_strcmp_9=strcmp(term, "[UVSET]");
          if(!(return_value_strcmp_9 == 0))
          {
            if((signed int)*term == 32)
            {
              term = term + 1l;
              if((signed int)*term == 98)
                term = term + 1l;

              else
                if((signed int)*term == 101)
                  term = term + 1l;

            }

            words=cbsplit(term, -1, "\t");
            if(!(add == 0))
              for( ; !(wsnum >= 256); wsnum = wsnum + 1)
              {
                if(!(words->num >= 1))
                  break;

                wsets[(signed long int)wsnum].word=cblistshift(words, (signed int *)(void *)0);
                wsets[(signed long int)wsnum].num = i;
              }

            else
              for( ; !(nsnum >= 256); nsnum = nsnum + 1)
              {
                if(!(words->num >= 1))
                  break;

                nsets[(signed long int)nsnum].word=cblistshift(words, (signed int *)(void *)0);
                nsets[(signed long int)nsnum].num = i;
              }
            do
            {
              signed int _CB_i;
              signed int est_db_score_doc__1__3__1__3__4___CB_end = words->start + words->num;
              _CB_i = words->start;
              for( ; !(_CB_i >= est_db_score_doc__1__3__1__3__4___CB_end); _CB_i = _CB_i + 1)
                free((void *)(words->array + (signed long int)_CB_i)->dptr);
              free((void *)words->array);
              free((void *)words);
            }
            while((_Bool)0);
          }

        }
      }
    }
    asiz = 0;
    sc = 0;
    rp=cbmapget(doc->attrs, "\t", 1, (signed int *)(void *)0);
    if(!(rp == ((const char *)NULL)))
    {
      return_value_atoi_12=atoi(rp);
      sc = -1 - return_value_atoi_12;
    }

    i = -1;
    for( ; !(i >= doc->dtexts->num); i = i + 1)
    {
      if(!(i >= 0))
      {
        if(doc->attrs == ((struct anonymous_5 *)NULL))
          tmp_if_expr_13 = (_Bool)1;

        else
        {
          text=cbmapget(doc->attrs, "", 0, (signed int *)(void *)0);
          tmp_if_expr_13 = !(text != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_13)
          goto __CPROVER_DUMP_L50;

        unsigned long int return_value_strlen_14;
        return_value_strlen_14=strlen(text);
        asiz = asiz + (signed int)return_value_strlen_14;
      }

      else
      {
        tsiz = (doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dsize;
        text = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
        asiz = asiz + tsiz;
      }
      unsigned long int return_value_strlen_15;
      return_value_strlen_15=strlen(text);
      char *return_value_est_uconv_in_16;
      return_value_est_uconv_in_16=est_uconv_in(text, (signed int)return_value_strlen_15, &rsiz);
      rbuf = (unsigned char *)return_value_est_uconv_in_16;
      est_canonicalize_text(rbuf, rsiz, 0);
      tmp=est_uconv_out((char *)rbuf, rsiz, &rsiz);
      j = 0;
      for( ; !(j >= wsnum); j = j + 1)
        if(!(wsets[(signed long int)j].word == ((char *)NULL)))
        {
          rp=est_strstr_sparse(tmp, wsets[(signed long int)j].word);
          if(!(rp == ((const char *)NULL)))
          {
            if(sc >= 0)
              do
              {
                sc = sc + 16;
                unsigned long int return_value_strlen_17;
                return_value_strlen_17=strlen(wsets[(signed long int)j].word);
                rp = rp + (signed long int)return_value_strlen_17;
                rp=est_strstr_sparse(rp, wsets[(signed long int)j].word);
              }
              while(!(rp == ((const char *)NULL)));

            k = 0;
            for( ; !(k >= wsnum); k = k + 1)
              if(!(wsets[(signed long int)k].word == ((char *)NULL)))
              {
                if(wsets[(signed long int)k].num == wsets[(signed long int)j].num)
                {
                  free((void *)wsets[(signed long int)k].word);
                  wsets[(signed long int)k].word = (char *)(void *)0;
                }

              }

          }

        }

      j = 0;
      for( ; !(j >= nsnum); j = j + 1)
        if(!(nsets[(signed long int)j].word == ((char *)NULL)))
        {
          rp=est_strstr_sparse(tmp, nsets[(signed long int)j].word);
          if(!(rp == ((const char *)NULL)))
          {
            k = 0;
            for( ; !(k >= nsnum); k = k + 1)
              if(!(nsets[(signed long int)k].word == ((char *)NULL)))
              {
                if(nsets[(signed long int)k].num == nsets[(signed long int)j].num)
                {
                  free((void *)nsets[(signed long int)k].word);
                  nsets[(signed long int)k].word = (char *)(void *)0;
                }

              }

          }

        }

      free((void *)tmp);
      free((void *)rbuf);

    __CPROVER_DUMP_L50:
      ;
    }
    hit = 1;
    i = 0;
    for( ; !(i >= wsnum); i = i + 1)
      if(!(wsets[(signed long int)i].word == ((char *)NULL)))
      {
        free((void *)wsets[(signed long int)i].word);
        hit = 0;
      }

    i = 0;
    for( ; !(i >= nsnum); i = i + 1)
      if(nsets[(signed long int)i].word == ((char *)NULL))
        hit = 0;

      else
        free((void *)nsets[(signed long int)i].word);
    do
    {
      signed int est_db_score_doc__1__7___CB_i;
      signed int _CB_end = terms->start + terms->num;
      est_db_score_doc__1__7___CB_i = terms->start;
      for( ; !(est_db_score_doc__1__7___CB_i >= _CB_end); est_db_score_doc__1__7___CB_i = est_db_score_doc__1__7___CB_i + 1)
        free((void *)(terms->array + (signed long int)est_db_score_doc__1__7___CB_i)->dptr);
      free((void *)terms->array);
      free((void *)terms);
    }
    while((_Bool)0);
    if(!(sc >= 0))
      sc = -1 - sc;

    double return_value_sqrt_18;
    return_value_sqrt_18=sqrt((double)asiz / 8.0 + (double)128);
    tune = return_value_sqrt_18 / 16.0;
    if(!(db->smode == 1048576))
    {
      if(db->smode == 2097152)
        goto __CPROVER_DUMP_L66;

      if(db->smode == 4194304)
        goto __CPROVER_DUMP_L67;

    }

    else
    {
      sc = 0;
      goto __CPROVER_DUMP_L67;
    }
    sc = sc / (signed int)tune;
    if(sc >= 0x80)
      sc = sc + (signed int)((double)(0x80 - sc) * 0.75);

    if(sc >= 0xc0)
      sc = sc + (signed int)((double)(0xc0 - sc) * 0.75);

    sc = sc < 0xff ? sc : 0xff;
    goto __CPROVER_DUMP_L67;

  __CPROVER_DUMP_L66:
    ;
    sc = sc / (signed int)tune;

  __CPROVER_DUMP_L67:
    ;
    *scp = sc;
    return hit;
  }
}

// est_db_search
// file estraier.c line 2746
signed int * est_db_search(struct anonymous_0 *db, struct anonymous_15 *cond, signed int *nump, struct anonymous_5 *hints)
{
  struct anonymous_8 *scores;
  struct anonymous_8 *tscores;
  struct anonymous_5 *svmap;
  struct anonymous_5 *ordattrs;
  struct anonymous_6 *terms;
  const char *term;
  const char *rp;
  char *tmp;
  char numbuf[32l];
  const signed int *nscores;
  signed int i;
  signed int j;
  signed int snum;
  signed int ign;
  signed int nsnum;
  signed int unum;
  signed int knum;
  signed int mnum;
  signed int top;
  signed int pcnum;
  signed int ncnum;
  signed int tsnum;
  signed int add;
  signed int nnum;
  signed int id;
  signed int score;
  signed int hnum;
  signed int len;
  signed int rest;
  signed int *rval;
  signed int rnum;
  double tune;
  if(!(cond->auxwords == ((struct anonymous_5 *)NULL)))
    cbmapclose(cond->auxwords);

  cond->auxwords=cbmapopenex(31);
  scores = (struct anonymous_8 *)(void *)0;
  snum = 0;
  ign = -1;
  nscores = cond->nscores;
  nsnum = cond->nsnum;
  signed int tmp_if_expr_1;
  if(!(cond->order == ((char *)NULL)))
    tmp_if_expr_1 = (signed int)db->pdocs->num + 31;

  else
    tmp_if_expr_1 = 1;
  ordattrs=cbmapopenex(tmp_if_expr_1);
  signed int return_value_cbstrfwmatch_22;
  signed int return_value_cbstrfwmatch_21;
  signed int return_value_cbstrfwmatch_20;
  signed int return_value_strcmp_15;
  _Bool tmp_if_expr_10;
  signed int tmp_if_expr_11;
  signed int tmp_if_expr_14;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_18;
  if(!(cond->phrase == ((char *)NULL)))
  {
    signed int return_value_cbstrfwmatch_23;
    return_value_cbstrfwmatch_23=cbstrfwmatch(cond->phrase, "[ID]");
    if(!(return_value_cbstrfwmatch_23 == 0))
    {
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen("[ID]");
      id=atoi(cond->phrase + (signed long int)return_value_strlen_4);
      if(id >= 1)
      {
        void *return_value_malloc_2;
        return_value_malloc_2=malloc(sizeof(struct anonymous_8) /*16ul*/ );
        scores = (struct anonymous_8 *)return_value_malloc_2;
        if(!(scores == ((struct anonymous_8 *)NULL)))
          scores;

        else
          cbmyfatal("out of memory");
        (scores + (signed long int)0)->id = id;
        (scores + (signed long int)0)->score = 0;
        (scores + (signed long int)0)->value = (char *)(void *)0;
        snum = 1;
      }

      else
      {
        void *return_value_malloc_3;
        return_value_malloc_3=malloc((unsigned long int)1);
        scores = (struct anonymous_8 *)return_value_malloc_3;
        if(!(scores == ((struct anonymous_8 *)NULL)))
          scores;

        else
          cbmyfatal("out of memory");
        snum = 0;
      }
    }

    else
    {
      return_value_cbstrfwmatch_22=cbstrfwmatch(cond->phrase, "[URI]");
      if(!(return_value_cbstrfwmatch_22 == 0))
      {
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen("[URI]");
        rp = cond->phrase + (signed long int)return_value_strlen_5;
        for( ; (signed int)*rp >= 1; rp = rp + 1l)
          if((signed int)*rp >= 33)
            break;

        id=est_db_uri_to_id(db, rp);
        if(id >= 1)
        {
          void *return_value_malloc_6;
          return_value_malloc_6=malloc(sizeof(struct anonymous_8) /*16ul*/ );
          scores = (struct anonymous_8 *)return_value_malloc_6;
          if(!(scores == ((struct anonymous_8 *)NULL)))
            scores;

          else
            cbmyfatal("out of memory");
          (scores + (signed long int)0)->id = id;
          (scores + (signed long int)0)->score = 0;
          (scores + (signed long int)0)->value = (char *)(void *)0;
          snum = 1;
        }

        else
        {
          void *return_value_malloc_7;
          return_value_malloc_7=malloc((unsigned long int)1);
          scores = (struct anonymous_8 *)return_value_malloc_7;
          if(!(scores == ((struct anonymous_8 *)NULL)))
            scores;

          else
            cbmyfatal("out of memory");
          snum = 0;
        }
      }

      else
      {
        return_value_cbstrfwmatch_21=cbstrfwmatch(cond->phrase, "[SIMILAR]");
        if(!(return_value_cbstrfwmatch_21 == 0))
        {
          unsigned long int return_value_strlen_8;
          return_value_strlen_8=strlen("[SIMILAR]");
          rp = cond->phrase + (signed long int)return_value_strlen_8;
          for( ; (signed int)*rp >= 1; rp = rp + 1l)
            if((signed int)*rp >= 33)
              break;

          knum = -1;
          unum = -1;
          mnum = -1;
          if((signed int)*rp >= 48)
          {
            if(!((signed int)*rp >= 58))
            {
              knum=atoi(rp);
              for( ; (signed int)*rp >= 48; rp = rp + 1l)
                if((signed int)*rp >= 58)
                  break;

              for( ; (signed int)*rp >= 1; rp = rp + 1l)
                if((signed int)*rp >= 33)
                  break;

              if((signed int)*rp >= 48)
              {
                if(!((signed int)*rp >= 58))
                {
                  unum=atoi(rp);
                  for( ; (signed int)*rp >= 48; rp = rp + 1l)
                    if((signed int)*rp >= 58)
                      break;

                  for( ; (signed int)*rp >= 1; rp = rp + 1l)
                    if((signed int)*rp >= 33)
                      break;

                  if((signed int)*rp >= 48)
                  {
                    if(!((signed int)*rp >= 58))
                    {
                      mnum=atoi(rp);
                      for( ; (signed int)*rp >= 48; rp = rp + 1l)
                        if((signed int)*rp >= 58)
                          break;

                      for( ; (signed int)*rp >= 1; rp = rp + 1l)
                        if((signed int)*rp >= 33)
                          break;

                    }

                  }

                }

              }

            }

          }

          if(!(knum >= 1))
            knum = 16;

          if(!(unum >= 1))
            unum = 1024;

          if(!(mnum >= 1))
            mnum = 4096;

          svmap=est_phrase_vector(rp);
          scores=est_search_similar(db, svmap, &snum, knum, unum, mnum, cond->tfidf, cond->order != ((char *)NULL) ? 0.5 : 0.0, cond->auxmin, cond->auxwords);
          cbmapclose(svmap);
        }

        else
        {
          return_value_cbstrfwmatch_20=cbstrfwmatch(cond->phrase, "[RANK]");
          if(!(return_value_cbstrfwmatch_20 == 0))
          {
            unsigned long int return_value_strlen_9;
            return_value_strlen_9=strlen("[RANK]");
            rp = cond->phrase + (signed long int)return_value_strlen_9;
            for( ; (signed int)*rp >= 1; rp = rp + 1l)
              if((signed int)*rp >= 33)
                break;

            top=atoi(rp);
            for( ; (_Bool)1; rp = rp + 1l)
              if((signed int)*rp >= 48)
              {
                if((signed int)*rp >= 58)
                  goto __CPROVER_DUMP_L38;

              }

              else
              {

              __CPROVER_DUMP_L38:
                ;
                if(!((signed int)*rp == 45))
                  goto __CPROVER_DUMP_L40;

              }

          __CPROVER_DUMP_L40:
            ;
            for( ; (signed int)*rp >= 1; rp = rp + 1l)
              if((signed int)*rp >= 33)
                break;

            scores=est_search_rank(db, rp, top, &snum);
          }

          else
          {
            if(!(cond->pmode == 1))
            {
              if(cond->pmode == 2)
                goto __CPROVER_DUMP_L44;

              if(cond->pmode == 3)
                goto __CPROVER_DUMP_L45;

              if(cond->pmode == 4)
                goto __CPROVER_DUMP_L46;

              terms=est_phrase_terms(cond->phrase);
            }

            else
            {
              tmp=est_phrase_from_simple(cond->phrase);
              terms=est_phrase_terms(tmp);
              free((void *)tmp);
              goto __CPROVER_DUMP_L47;

            __CPROVER_DUMP_L44:
              ;
              tmp=est_phrase_from_rough(cond->phrase);
              terms=est_phrase_terms(tmp);
              free((void *)tmp);
              goto __CPROVER_DUMP_L47;

            __CPROVER_DUMP_L45:
              ;
              tmp=est_phrase_from_union(cond->phrase);
              terms=est_phrase_terms(tmp);
              free((void *)tmp);
              goto __CPROVER_DUMP_L47;

            __CPROVER_DUMP_L46:
              ;
              tmp=est_phrase_from_isect(cond->phrase);
              terms=est_phrase_terms(tmp);
              free((void *)tmp);
            }

          __CPROVER_DUMP_L47:
            ;
            pcnum = 0;
            ncnum = 0;
            add = 1;
            i = 0;
            for( ; !(i >= terms->num); i = i + 1)
            {
              term = (const char *)(terms->array + (signed long int)(terms->start + i))->dptr;
              signed int return_value_strcmp_16;
              return_value_strcmp_16=strcmp(term, "AND");
              if(return_value_strcmp_16 == 0)
                add = 1;

              else
              {
                return_value_strcmp_15=strcmp(term, "ANDNOT");
                if(return_value_strcmp_15 == 0)
                  add = 0;

                else
                {
                  signed int return_value_strcmp_12;
                  return_value_strcmp_12=strcmp(term, "[UVSET]");
                  if(return_value_strcmp_12 == 0)
                    tscores=est_search_uvset(db, &tsnum, hints, add);

                  else
                  {
                    if(!(add == 0))
                      tmp_if_expr_10 = !(cond->order != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_10 = (_Bool)0;
                    if(tmp_if_expr_10)
                      tmp_if_expr_11 = cond->auxmin;

                    else
                      tmp_if_expr_11 = -1;
                    tscores=est_search_union(db, term, cond->gstep, cond->cbxpn, &tsnum, hints, add, tmp_if_expr_11, cond->auxwords);
                  }
                  if(!(add == 0))
                  {
                    if(!(db->smode == 4194304))
                    {
                      if(!(cond->tfidf == 0))
                      {
                        tune=pow((double)(tsnum + 64), 0.4);
                        j = 0;
                        for( ; !(j >= tsnum); j = j + 1)
                          (tscores + (signed long int)j)->score = (tscores + (signed long int)j)->score * (signed int)(100.0 / tune);
                      }

                      else
                      {
                        j = 0;
                        for( ; !(j >= tsnum); j = j + 1)
                          (tscores + (signed long int)j)->score = (tscores + (signed long int)j)->score * 10;
                      }
                    }

                    pcnum = pcnum + 1;
                  }

                  else
                    ncnum = ncnum + 1;
                  if(!(scores == ((struct anonymous_8 *)NULL)))
                  {
                    void *return_value_realloc_13;
                    return_value_realloc_13=realloc((void *)scores, (unsigned long int)(snum + tsnum) * sizeof(struct anonymous_8) /*16ul*/  + (unsigned long int)1);
                    scores = (struct anonymous_8 *)return_value_realloc_13;
                    if(!(scores == ((struct anonymous_8 *)NULL)))
                      scores;

                    else
                      cbmyfatal("out of memory");
                    j = 0;
                    for( ; !(j >= tsnum); j = j + 1)
                    {
                      (scores + (signed long int)(snum + j))->id = (tscores + (signed long int)j)->id;
                      if(!(add == 0))
                        tmp_if_expr_14 = (tscores + (signed long int)j)->score;

                      else
                        tmp_if_expr_14 = -1;
                      (scores + (signed long int)(snum + j))->score = tmp_if_expr_14;
                      (scores + (signed long int)(snum + j))->value = (char *)(void *)0;
                    }
                    snum = snum + tsnum;
                    free((void *)tscores);
                  }

                  else
                  {
                    scores = tscores;
                    snum = tsnum;
                  }
                }
              }
            }
            if(!(scores == ((struct anonymous_8 *)NULL)))
            {
              if(ncnum >= 1 || pcnum >= 2)
              {
                qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_id_asc);
                nnum = 0;
                i = 0;
                for( ; !(i >= snum); i = i + 1)
                {
                  id = (scores + (signed long int)i)->id;
                  score = (scores + (signed long int)i)->score;
                  hnum = score >= 0 ? 1 : 0;
                  j = i + 1;
                  do
                  {
                    if(!(j >= snum))
                      tmp_if_expr_17 = (scores + (signed long int)j)->id == id ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_17 = (_Bool)0;
                    if(!tmp_if_expr_17)
                      break;

                    if(score >= 0)
                      tmp_if_expr_18 = (scores + (signed long int)j)->score >= 0 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_18 = (_Bool)0;
                    if(tmp_if_expr_18)
                    {
                      if(!(db->smode == 4194304))
                        score = score + (scores + (signed long int)j)->score;

                      hnum = hnum + 1;
                    }

                    else
                      score = -1;
                    j = j + 1;
                  }
                  while((_Bool)1);
                  if(hnum >= pcnum && score >= 0)
                  {
                    (scores + (signed long int)nnum)->id = id;
                    (scores + (signed long int)nnum)->score = score;
                    (scores + (signed long int)nnum)->value = (char *)(void *)0;
                    nnum = nnum + 1;
                  }

                  i = j - 1;
                }
                snum = nnum;
              }

            }

            else
            {
              void *return_value_malloc_19;
              return_value_malloc_19=malloc((unsigned long int)1);
              scores = (struct anonymous_8 *)return_value_malloc_19;
              if(!(scores == ((struct anonymous_8 *)NULL)))
                scores;

              else
                cbmyfatal("out of memory");
              snum = 0;
            }
            do
            {
              signed int _CB_i;
              signed int _CB_end = terms->start + terms->num;
              _CB_i = terms->start;
              for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
                free((void *)(terms->array + (signed long int)_CB_i)->dptr);
              free((void *)terms->array);
              free((void *)terms);
            }
            while((_Bool)0);
          }
        }
      }
    }
  }

  else
    if(!(cond->attrs == ((struct anonymous_6 *)NULL)))
    {
      if(!(nscores == ((const signed int *)NULL)) && !(nsnum >= 4))
      {
        void *return_value_malloc_24;
        return_value_malloc_24=malloc((unsigned long int)nsnum * sizeof(struct anonymous_8) /*16ul*/  + (unsigned long int)1);
        scores = (struct anonymous_8 *)return_value_malloc_24;
        if(!(scores == ((struct anonymous_8 *)NULL)))
          scores;

        else
          cbmyfatal("out of memory");
        nnum = 0;
        i = 0;
        for( ; !(i >= nsnum); i = i + 1)
        {
          sprintf(numbuf, "%d", nscores[(signed long int)i]);
          id=est_db_uri_to_id(db, numbuf);
          if(id >= 1)
          {
            (scores + (signed long int)nnum)->id = id;
            (scores + (signed long int)nnum)->score = nscores[(signed long int)i];
            (scores + (signed long int)nnum)->value = (char *)(void *)0;
            nnum = nnum + 1;
          }

        }
        snum = nnum;
        nscores = (const signed int *)(void *)0;
        nsnum = -1;
      }

      else
      {
        scores = (struct anonymous_8 *)(void *)0;
        i = 0;
        for( ; !(i >= cond->attrs->num); i = i + 1)
        {
          scores=est_search_aidx_attr(db, (const char *)(cond->attrs->array + (signed long int)(cond->attrs->start + i))->dptr, &snum);
          if(!(scores == ((struct anonymous_8 *)NULL)))
          {
            ign = i;
            break;
          }

        }
        if(scores == ((struct anonymous_8 *)NULL))
          scores=est_search_uvset(db, &snum, hints, 1);

      }
    }

    else
    {
      void *return_value_malloc_25;
      return_value_malloc_25=malloc((unsigned long int)1);
      scores = (struct anonymous_8 *)return_value_malloc_25;
      if(!(scores == ((struct anonymous_8 *)NULL)))
        scores;

      else
        cbmyfatal("out of memory");
      snum = 0;
    }
  if(db->pdocs->num >= 1)
    scores=est_search_pidxs(db, cond, scores, &snum, ordattrs);

  if(!(nscores == ((const signed int *)NULL)))
  {
    if(!(cond->phrase == ((char *)NULL)))
    {
      if(!((signed int)*cond->phrase == 0))
      {
        qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_score_desc);
        nnum = 0;
        j = 0;
        i = 0;
        for( ; !(i >= snum); i = i + 1)
        {
          id = (scores + (signed long int)i)->id;
          score = (scores + (signed long int)i)->score;
          for( ; !(j >= nsnum); j = j + 1)
            if(score >= nscores[(signed long int)j])
              break;

          if(!(j >= nsnum))
          {
            if(nscores[(signed long int)j] == score)
            {
              (scores + (signed long int)nnum)->id = id;
              (scores + (signed long int)nnum)->score = score;
              (scores + (signed long int)nnum)->value = (char *)(void *)0;
              nnum = nnum + 1;
              j = j + 1;
            }

          }

        }
        snum = nnum;
      }

    }

  }

  signed int return_value_cbmaprnum_28;
  return_value_cbmaprnum_28=cbmaprnum(db->outcc);
  signed int tmp_post_27;
  if(return_value_cbmaprnum_28 >= 1)
  {
    tsnum = 0;
    i = 0;
    for( ; !(i >= snum); i = i + 1)
    {
      len=sprintf(numbuf, "\t%d", (scores + (signed long int)i)->id);
      const char *return_value_cbmapget_26;
      return_value_cbmapget_26=cbmapget(db->outcc, numbuf, len, (signed int *)(void *)0);
      if(return_value_cbmapget_26 == ((const char *)NULL))
      {
        tmp_post_27 = tsnum;
        tsnum = tsnum + 1;
        scores[(signed long int)tmp_post_27] = scores[(signed long int)i];
      }

    }
    snum = tsnum;
  }

  _Bool tmp_if_expr_31;
  if(cond->max >= 1)
    tmp_if_expr_31 = (double)cond->max * 1.5 + (double)1 < (double)snum ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_31 = (_Bool)0;
  _Bool tmp_if_expr_32;
  if(tmp_if_expr_31)
    tmp_if_expr_32 = cond->attrs != ((struct anonymous_6 *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_32 = (_Bool)0;
  _Bool tmp_if_expr_33;
  if(tmp_if_expr_32)
    tmp_if_expr_33 = !(cond->order != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_33 = (_Bool)0;
  _Bool tmp_if_expr_34;
  if(tmp_if_expr_33)
    tmp_if_expr_34 = !(cond->distinct != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_34 = (_Bool)0;
  _Bool tmp_if_expr_29;
  _Bool tmp_if_expr_30;
  if(tmp_if_expr_34)
  {
    qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_score_desc);
    nnum=est_narrow_scores(db, cond->attrs, ign, cond->order, cond->distinct, scores, snum, (signed int)((double)cond->max * 1.5 + (double)1), &rest, ordattrs);
    if(!(hints == ((struct anonymous_5 *)NULL)))
    {
      sprintf(numbuf, "%d", rest > cond->max / 2 ? (signed int)((double)snum * ((double)nnum / (double)(snum - rest))) : nnum);
      cbmapput(hints, "", 0, numbuf, -1, 1);
    }

    snum = nnum;
  }

  else
  {
    if(!(cond->attrs == ((struct anonymous_6 *)NULL)))
      tmp_if_expr_29 = (_Bool)1;

    else
      tmp_if_expr_29 = cond->order != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_29)
      tmp_if_expr_30 = (_Bool)1;

    else
      tmp_if_expr_30 = cond->distinct != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_30)
      snum=est_narrow_scores(db, cond->attrs, ign, cond->order, cond->distinct, scores, snum, 0x7fffffff, &rest, ordattrs);

    if(cond->order == ((char *)NULL))
      qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_score_desc);

    if(!(hints == ((struct anonymous_5 *)NULL)))
    {
      sprintf(numbuf, "%d", snum);
      cbmapput(hints, "", 0, numbuf, -1, 1);
    }

  }
  if(!(cond->shadows == ((struct anonymous_5 *)NULL)))
    cbmapclose(cond->shadows);

  signed int tmp_if_expr_35;
  if(cond->ecllim >= 0.0)
  {
    cond->shadows=cbmapopenex(snum + 1);
    if(cond->max >= 1)
      tmp_if_expr_35 = cond->max;

    else
      tmp_if_expr_35 = snum;
    snum=est_eclipse_scores(db, scores, snum, tmp_if_expr_35, 32, cond->tfidf, cond->ecllim, cond->shadows);
  }

  else
    cond->shadows = (struct anonymous_5 *)(void *)0;
  rnum = snum - cond->skip;
  if(!(rnum >= 0))
    rnum = 0;

  if(cond->max >= 0)
  {
    if(!(cond->max >= rnum))
      rnum = cond->max;

  }

  void *return_value_malloc_36;
  return_value_malloc_36=malloc((unsigned long int)rnum * sizeof(signed int) /*4ul*/  + (unsigned long int)1);
  rval = (signed int *)return_value_malloc_36;
  if(!(rval == ((signed int *)NULL)))
    rval;

  else
    cbmyfatal("out of memory");
  tscores = scores + (signed long int)cond->skip;
  i = 0;
  for( ; !(i >= rnum); i = i + 1)
    rval[(signed long int)i] = (tscores + (signed long int)i)->id;
  if(!(cond->scfb == 0))
  {
    if(rnum >= 1)
    {
      void *return_value_realloc_37;
      return_value_realloc_37=realloc((void *)cond->scores, (unsigned long int)rnum * sizeof(signed int) /*4ul*/  + (unsigned long int)1);
      cond->scores = (signed int *)return_value_realloc_37;
      if(!(cond->scores == ((signed int *)NULL)))
        cond->scores;

      else
        cbmyfatal("out of memory");
      i = 0;
      for( ; !(i >= rnum); i = i + 1)
        cond->scores[(signed long int)i] = (tscores + (signed long int)i)->score;
      cond->snum = rnum;
    }

    else
    {
      free((void *)cond->scores);
      cond->scores = (signed int *)(void *)0;
      cond->snum = 0;
    }
  }

  *nump = rnum;
  if(!(*nump >= 1))
    est_set_ecode(&db->ecode, 6, 3064);

  cbmapclose(ordattrs);
  free((void *)scores);
  return rval;
}

// est_db_search_meta
// file estraier.c line 3072
signed int * est_db_search_meta(struct anonymous_0 **dbs, signed int dbnum, struct anonymous_15 *cond, signed int *nump, struct anonymous_5 *hints)
{
  struct anonymous_32 *scores;
  struct anonymous_32 *tscores;
  struct anonymous_15 *tcond;
  struct anonymous_5 *thints;
  struct anonymous_5 *umap;
  const char *kbuf;
  const char *otype;
  const char *rp;
  char *distinct;
  char numbuf[32l];
  char *oname;
  char *wp;
  char *vbuf;
  signed int i;
  signed int j;
  signed int max;
  signed int skip;
  signed int smax;
  signed int snum;
  signed int *res;
  signed int rnum;
  signed int ksiz;
  signed int num;
  signed long int tval;
  max = cond->max;
  if(!(cond->distinct == ((char *)NULL)))
    cond->max = -1;

  skip = cond->skip;
  cond->skip = 0;
  distinct = cond->distinct;
  cond->distinct = (char *)(void *)0;
  smax = 1024;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)smax * sizeof(struct anonymous_32) /*24ul*/ );
  scores = (struct anonymous_32 *)return_value_malloc_1;
  if(!(scores == ((struct anonymous_32 *)NULL)))
    scores;

  else
    cbmyfatal("out of memory");
  snum = 0;
  i = 0;
  signed int return_value_atoi_4;
  for( ; !(i >= dbnum); i = i + 1)
    if((cond->mask & 1 << i) == 0)
    {
      tcond=est_cond_dup(cond);
      est_cond_set_options(tcond, 1073741824);
      thints=cbmapopenex(31);
      res=est_db_search(dbs[(signed long int)i], tcond, &rnum, thints);
      j = 0;
      for( ; !(j >= rnum); j = j + 1)
      {
        if(snum >= smax)
        {
          smax = smax * 2;
          void *return_value_realloc_2;
          return_value_realloc_2=realloc((void *)scores, (unsigned long int)smax * sizeof(struct anonymous_32) /*24ul*/ );
          scores = (struct anonymous_32 *)return_value_realloc_2;
          if(!(scores == ((struct anonymous_32 *)NULL)))
            scores;

          else
            cbmyfatal("out of memory");
        }

        (scores + (signed long int)snum)->db = i;
        (scores + (signed long int)snum)->id = res[(signed long int)j];
        (scores + (signed long int)snum)->score=est_cond_score(tcond, j);
        (scores + (signed long int)snum)->value = (char *)(void *)0;
        snum = snum + 1;
      }
      if(!(hints == ((struct anonymous_5 *)NULL)))
      {
        cbmapiterinit(thints);
        do
        {
          kbuf=cbmapiternext(thints, &ksiz);
          if(kbuf == ((const char *)NULL))
            break;

          const char *return_value_cbmapiterval_3;
          return_value_cbmapiterval_3=cbmapiterval(kbuf, (signed int *)(void *)0);
          num=atoi(return_value_cbmapiterval_3);
          rp=cbmapget(hints, kbuf, ksiz, (signed int *)(void *)0);
          if(!(rp == ((const char *)NULL)))
          {
            return_value_atoi_4=atoi(rp);
            num = num + return_value_atoi_4;
          }

          sprintf(numbuf, "%d", num);
          cbmapput(hints, kbuf, ksiz, numbuf, -1, 1);
        }
        while((_Bool)1);
      }

      free((void *)res);
      cbmapclose(thints);
      est_cond_delete(tcond);
    }

  oname = (char *)(void *)0;
  otype = (const char *)(void *)0;
  if(!(cond->order == ((char *)NULL)))
  {
    oname=cbmemdup(cond->order, -1);
    cbstrtrim(oname);
    otype = "STRA";
    wp=strchr(oname, 32);
    if(!(wp == ((char *)NULL)))
    {
      *wp = (char)0;
      rp = wp + (signed long int)1;
      for( ; (signed int)*rp == 32; rp = rp + 1l)
        ;
      otype = rp;
    }

  }

  signed int return_value_cbstricmp_11;
  signed int return_value_cbstricmp_10;
  signed int return_value_cbstricmp_9;
  signed int return_value_cbstricmp_7;
  signed int return_value_cbstricmp_6;
  signed int return_value_cbstricmp_5;
  if(!(oname == ((char *)NULL)))
  {
    signed int return_value_cbstricmp_12;
    return_value_cbstricmp_12=cbstricmp(oname, "[IDA]");
    if(return_value_cbstricmp_12 == 0)
      qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_32) /*24ul*/ , est_metascore_compare_by_id_asc);

    else
    {
      return_value_cbstricmp_11=cbstricmp(oname, "[IDD]");
      if(return_value_cbstricmp_11 == 0)
        qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_32) /*24ul*/ , est_metascore_compare_by_id_desc);

      else
      {
        return_value_cbstricmp_10=cbstricmp(oname, "[SCA]");
        if(return_value_cbstricmp_10 == 0)
          qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_32) /*24ul*/ , est_metascore_compare_by_score_asc);

        else
        {
          return_value_cbstricmp_9=cbstricmp(oname, "[SCD]");
          if(return_value_cbstricmp_9 == 0)
            qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_32) /*24ul*/ , est_metascore_compare_by_score_desc);

          else
          {
            i = 0;
            for( ; !(i >= snum); i = i + 1)
            {
              (scores + (signed long int)i)->value=est_db_get_doc_attr(dbs[(signed long int)(scores + (signed long int)i)->db], (scores + (signed long int)i)->id, oname);
              if((scores + (signed long int)i)->value == ((char *)NULL))
                (scores + (signed long int)i)->value=cbmemdup("", 0);

            }
            signed int return_value_cbstricmp_8;
            return_value_cbstricmp_8=cbstricmp(otype, "STRA");
            if(return_value_cbstricmp_8 == 0)
              qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_32) /*24ul*/ , est_metascore_compare_by_str_asc);

            else
            {
              return_value_cbstricmp_7=cbstricmp(otype, "STRD");
              if(return_value_cbstricmp_7 == 0)
                qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_32) /*24ul*/ , est_metascore_compare_by_str_desc);

              else
              {
                return_value_cbstricmp_6=cbstricmp(otype, "NUMA");
                if(return_value_cbstricmp_6 == 0)
                {
                  i = 0;
                  for( ; !(i >= snum); i = i + 1)
                  {
                    tval=cbstrmktime((scores + (signed long int)i)->value);
                    free((void *)(scores + (signed long int)i)->value);
                    (scores + (signed long int)i)->value = (char *)(void *)tval;
                  }
                  qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_32) /*24ul*/ , est_metascore_compare_by_num_asc);
                  i = 0;
                  for( ; !(i >= snum); i = i + 1)
                    (scores + (signed long int)i)->value = (char *)(void *)0;
                }

                else
                {
                  return_value_cbstricmp_5=cbstricmp(otype, "NUMD");
                  if(return_value_cbstricmp_5 == 0)
                  {
                    i = 0;
                    for( ; !(i >= snum); i = i + 1)
                    {
                      tval=cbstrmktime((scores + (signed long int)i)->value);
                      free((void *)(scores + (signed long int)i)->value);
                      (scores + (signed long int)i)->value = (char *)(void *)tval;
                    }
                    qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_32) /*24ul*/ , est_metascore_compare_by_num_desc);
                    i = 0;
                    for( ; !(i >= snum); i = i + 1)
                      (scores + (signed long int)i)->value = (char *)(void *)0;
                  }

                }
              }
            }
            i = 0;
            for( ; !(i >= snum); i = i + 1)
              free((void *)(scores + (signed long int)i)->value);
          }
        }
      }
    }
    free((void *)oname);
  }

  else
    qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_32) /*24ul*/ , est_metascore_compare_by_score_desc);
  signed int tmp_post_13;
  if(!(distinct == ((char *)NULL)))
  {
    umap=cbmapopenex(snum + 1);
    rnum = 0;
    i = 0;
    for( ; !(i >= snum); i = i + 1)
    {
      vbuf=est_db_get_doc_attr(dbs[(signed long int)(scores + (signed long int)i)->db], (scores + (signed long int)i)->id, distinct);
      if(vbuf == ((char *)NULL))
        vbuf=cbmemdup("", 0);

      signed int return_value_cbmapput_14;
      return_value_cbmapput_14=cbmapput(umap, vbuf, -1, "", 0, 0);
      if(!(return_value_cbmapput_14 == 0))
      {
        tmp_post_13 = rnum;
        rnum = rnum + 1;
        scores[(signed long int)tmp_post_13] = scores[(signed long int)i];
      }

      free((void *)vbuf);
    }
    snum = rnum;
    cbmapclose(umap);
  }

  rnum = snum - skip;
  if(!(rnum >= 0))
    rnum = 0;

  if(cond->max >= 0)
  {
    if(!(cond->max >= rnum))
      rnum = cond->max;

  }

  void *return_value_malloc_15;
  return_value_malloc_15=malloc((unsigned long int)rnum * sizeof(signed int) /*4ul*/  * (unsigned long int)2 + (unsigned long int)1);
  res = (signed int *)return_value_malloc_15;
  if(!(res == ((signed int *)NULL)))
    res;

  else
    cbmyfatal("out of memory");
  tscores = scores + (signed long int)skip;
  i = 0;
  for( ; !(i >= rnum); i = i + 1)
  {
    res[(signed long int)(i * 2)] = (tscores + (signed long int)i)->db;
    res[(signed long int)(i * 2 + 1)] = (tscores + (signed long int)i)->id;
  }
  if(!(cond->scfb == 0))
  {
    if(rnum >= 1)
    {
      void *return_value_realloc_16;
      return_value_realloc_16=realloc((void *)cond->scores, (unsigned long int)rnum * sizeof(signed int) /*4ul*/  + (unsigned long int)1);
      cond->scores = (signed int *)return_value_realloc_16;
      if(!(cond->scores == ((signed int *)NULL)))
        cond->scores;

      else
        cbmyfatal("out of memory");
      i = 0;
      for( ; !(i >= rnum); i = i + 1)
        cond->scores[(signed long int)i] = (tscores + (signed long int)i)->score;
      cond->snum = rnum;
    }

    else
    {
      free((void *)cond->scores);
      cond->scores = (signed int *)(void *)0;
      cond->snum = 0;
    }
  }

  *nump = rnum * 2;
  free((void *)scores);
  cond->max = max;
  cond->skip = skip;
  cond->distinct = distinct;
  return res;
}

// est_db_set_cache_size
// file estraier.c line 3324
void est_db_set_cache_size(struct anonymous_0 *db, unsigned long int size, signed int anum, signed int tnum, signed int rnum)
{
  signed int return_value_dpwritable_1;
  return_value_dpwritable_1=dpwritable(db->metadb);
  if(!(return_value_dpwritable_1 == 0))
    db->icmax = size;

  if(anum >= 0)
    db->acmnum = anum;

  if(tnum >= 0)
    db->tcmnum = tnum;

  if(rnum >= 0)
    db->rcmnum = rnum;

  db->vcmnum = db->acmnum / 2;
}

// est_db_set_dfdb
// file estraier.c line 5015
void est_db_set_dfdb(struct anonymous_0 *db, struct anonymous_1 *dfdb)
{
  db->dfdb = dfdb;
}

// est_db_set_doc_entity
// file estraier.c line 4482
signed int est_db_set_doc_entity(struct anonymous_0 *db, signed int id, const char *ptr, signed int size)
{
  signed int err;
  signed int return_value_dpwritable_1;
  return_value_dpwritable_1=dpwritable(db->metadb);
  if(return_value_dpwritable_1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 4486);
    return 0;
  }

  else
  {
    err = 0;
    if(!(ptr == ((const char *)NULL)))
    {
      signed int return_value_crputlob_2;
      return_value_crputlob_2=crputlob(db->textdb, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , ptr, size, 0);
      if(return_value_crputlob_2 == 0)
      {
        est_set_ecode(&db->ecode, 4, 4492);
        err = 1;
      }

    }

    else
    {
      signed int return_value_croutlob_4;
      return_value_croutlob_4=croutlob(db->textdb, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
      if(return_value_croutlob_4 == 0)
      {
        signed int *return_value_dpecodeptr_3;
        return_value_dpecodeptr_3=dpecodeptr();
        est_set_ecode(&db->ecode, *return_value_dpecodeptr_3 == 5 ? 6 : 4, 4497);
        err = 1;
      }

    }
    return err != 0 ? 0 : 1;
  }
}

// est_db_set_ecode
// file estraier.c line 4425
void est_db_set_ecode(struct anonymous_0 *db, signed int ecode)
{
  est_set_ecode(&db->ecode, ecode, 4427);
}

// est_db_set_informer
// file estraier.c line 4985
void est_db_set_informer(struct anonymous_0 *db, void (*func)(const char *, void *), void *opaque)
{
  db->infocb = func;
  db->infoop = opaque;
  est_db_inform(db, "status");
}

// est_db_set_special_cache
// file estraier.c line 4972
void est_db_set_special_cache(struct anonymous_0 *db, const char *name, signed int num)
{
  if(!(db->spacc == ((struct anonymous_5 *)NULL)))
  {
    free((void *)db->scname);
    cbmapclose(db->spacc);
  }

  db->spacc=cbmapopenex(num + 1);
  db->scmnum = num;
  db->scname=cbmemdup(name, -1);
}

// est_db_set_wildmax
// file estraier.c line 4506
void est_db_set_wildmax(struct anonymous_0 *db, signed int num)
{
  db->wildmax = num;
}

// est_db_size
// file estraier.c line 2718
double est_db_size(struct anonymous_0 *db)
{
  struct anonymous_7 *attridx;
  const char *kbuf;
  double size;
  signed int return_value_dpfsiz_1;
  return_value_dpfsiz_1=dpfsiz(db->metadb);
  double return_value_est_idx_size_2;
  return_value_est_idx_size_2=est_idx_size(db->idxdb);
  signed int return_value_vlfsiz_3;
  return_value_vlfsiz_3=vlfsiz(db->fwmdb);
  signed int return_value_vlfsiz_4;
  return_value_vlfsiz_4=vlfsiz(db->auxdb);
  signed int return_value_vlfsiz_5;
  return_value_vlfsiz_5=vlfsiz(db->xfmdb);
  double return_value_crfsizd_6;
  return_value_crfsizd_6=crfsizd(db->attrdb);
  double return_value_crfsizd_7;
  return_value_crfsizd_7=crfsizd(db->textdb);
  double return_value_crfsizd_8;
  return_value_crfsizd_8=crfsizd(db->kwddb);
  signed int return_value_vlfsiz_9;
  return_value_vlfsiz_9=vlfsiz(db->listdb);
  size = (double)return_value_dpfsiz_1 + return_value_est_idx_size_2 + (double)return_value_vlfsiz_3 + (double)return_value_vlfsiz_4 + (double)return_value_vlfsiz_5 + return_value_crfsizd_6 + return_value_crfsizd_7 + return_value_crfsizd_8 + (double)return_value_vlfsiz_9;
  signed int return_value_cbmaprnum_13;
  return_value_cbmaprnum_13=cbmaprnum(db->aidxs);
  signed int return_value_vlfsiz_11;
  if(return_value_cbmaprnum_13 >= 1)
  {
    cbmapiterinit(db->aidxs);
    do
    {
      kbuf=cbmapiternext(db->aidxs, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_10;
      return_value_cbmapiterval_10=cbmapiterval(kbuf, (signed int *)(void *)0);
      attridx = (struct anonymous_7 *)return_value_cbmapiterval_10;
      if(attridx->type == 1 || attridx->type == 2)
      {
        return_value_vlfsiz_11=vlfsiz((struct anonymous_4 *)attridx->db);
        size = size + (double)return_value_vlfsiz_11;
        goto __CPROVER_DUMP_L4;
      }

      signed int return_value_dpfsiz_12;
      return_value_dpfsiz_12=dpfsiz((struct anonymous_1 *)attridx->db);
      size = size + (double)return_value_dpfsiz_12;

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)1);
  }

  return size;
}

// est_db_sync
// file estraier.c line 1692
signed int est_db_sync(struct anonymous_0 *db)
{
  struct anonymous_7 *attridx;
  const char *kbuf;
  signed int err;
  signed int return_value_dpwritable_1;
  return_value_dpwritable_1=dpwritable(db->metadb);
  _Bool tmp_if_expr_4;
  signed int return_value_est_db_write_meta_3;
  signed int return_value_vlsync_13;
  if(return_value_dpwritable_1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 1698);
    return 0;
  }

  else
  {
    err = 0;
    signed int return_value_est_db_flush_2;
    return_value_est_db_flush_2=est_db_flush(db, -1);
    if(return_value_est_db_flush_2 == 0)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_est_db_write_meta_3=est_db_write_meta(db);
      tmp_if_expr_4 = !(return_value_est_db_write_meta_3 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      err = 1;

    est_db_inform(db, "synchronizing the database for meta information");
    signed int return_value_dpsync_5;
    return_value_dpsync_5=dpsync(db->metadb);
    if(return_value_dpsync_5 == 0)
      err = 1;

    est_db_inform(db, "synchronizing the inverted index");
    signed int return_value_est_idx_sync_6;
    return_value_est_idx_sync_6=est_idx_sync(db->idxdb);
    if(return_value_est_idx_sync_6 == 0)
      err = 1;

    est_db_inform(db, "synchronizing the database for forward matching");
    signed int return_value_vlsync_7;
    return_value_vlsync_7=vlsync(db->fwmdb);
    if(return_value_vlsync_7 == 0)
      err = 1;

    est_db_inform(db, "synchronizing the database for attributes");
    signed int return_value_crsync_8;
    return_value_crsync_8=crsync(db->attrdb);
    if(return_value_crsync_8 == 0)
      err = 1;

    est_db_inform(db, "synchronizing the database for texts");
    signed int return_value_crsync_9;
    return_value_crsync_9=crsync(db->textdb);
    if(return_value_crsync_9 == 0)
      err = 1;

    est_db_inform(db, "synchronizing the database for keywords");
    signed int return_value_crsync_10;
    return_value_crsync_10=crsync(db->kwddb);
    if(return_value_crsync_10 == 0)
      err = 1;

    est_db_inform(db, "synchronizing the database for document list");
    signed int return_value_vlsync_11;
    return_value_vlsync_11=vlsync(db->listdb);
    if(return_value_vlsync_11 == 0)
      err = 1;

    signed int return_value_cbmaprnum_15;
    return_value_cbmaprnum_15=cbmaprnum(db->aidxs);
    if(return_value_cbmaprnum_15 >= 1)
    {
      est_db_inform(db, "synchronizing the databases for attribute narrowing");
      cbmapiterinit(db->aidxs);
      do
      {
        kbuf=cbmapiternext(db->aidxs, (signed int *)(void *)0);
        if(kbuf == ((const char *)NULL))
          break;

        const char *return_value_cbmapiterval_12;
        return_value_cbmapiterval_12=cbmapiterval(kbuf, (signed int *)(void *)0);
        attridx = (struct anonymous_7 *)return_value_cbmapiterval_12;
        if(attridx->type == 1 || attridx->type == 2)
        {
          return_value_vlsync_13=vlsync((struct anonymous_4 *)attridx->db);
          if(return_value_vlsync_13 == 0)
            err = 1;

          goto __CPROVER_DUMP_L17;
        }

        signed int return_value_dpsync_14;
        return_value_dpsync_14=dpsync((struct anonymous_1 *)attridx->db);
        if(return_value_dpsync_14 == 0)
          err = 1;


      __CPROVER_DUMP_L17:
        ;
      }
      while((_Bool)1);
    }

    if(!(err == 0))
    {
      est_set_ecode(&db->ecode, 4, 1734);
      db->fatal = 1;
    }

    return err != 0 ? 0 : 1;
  }
}

// est_db_uri_to_id
// file estraier.c line 2681
signed int est_db_uri_to_id(struct anonymous_0 *db, const char *uri)
{
  const char *vbuf;
  signed int id;
  vbuf=vlgetcache(db->listdb, uri, -1, (signed int *)(void *)0);
  if(vbuf == ((const char *)NULL))
  {
    if(db->pdocs->num >= 1)
    {
      id=est_pidx_uri_to_id(db, uri);
      if(id >= 1)
        return id;

    }

    est_set_ecode(&db->ecode, 6, 2687);
    return -1;
  }

  else
  {
    signed int return_value_atoi_1;
    return_value_atoi_1=atoi(vbuf);
    return return_value_atoi_1;
  }
}

// est_db_used_cache_size
// file estraier.c line 4964
signed int est_db_used_cache_size(struct anonymous_0 *db)
{
  signed int return_value_cbmaprnum_1;
  return_value_cbmaprnum_1=cbmaprnum(db->idxcc);
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(db->auxcc);
  return (signed int)((double)(db->icsiz + (unsigned long int)(return_value_cbmaprnum_1 + return_value_cbmaprnum_2) * (sizeof(struct _CBMAPDATUM) /*48ul*/  + (unsigned long int)8)) * 1.1);
}

// est_db_word_iter_init
// file estraier.c line 4853
signed int est_db_word_iter_init(struct anonymous_0 *db)
{
  signed int return_value_vlcurfirst_2;
  return_value_vlcurfirst_2=vlcurfirst(db->fwmdb);
  signed int *return_value_dpecodeptr_1;
  if(return_value_vlcurfirst_2 == 0)
  {
    return_value_dpecodeptr_1=dpecodeptr();
    if(*return_value_dpecodeptr_1 == 5)
      goto __CPROVER_DUMP_L1;

    est_set_ecode(&db->ecode, 4, 4856);
    db->fatal = 1;
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 1;
  }
}

// est_db_word_iter_next
// file estraier.c line 4865
char * est_db_word_iter_next(struct anonymous_0 *db)
{
  char *word;
  word=vlcurkey(db->fwmdb, (signed int *)(void *)0);
  if(word == ((char *)NULL))
  {
    signed int *return_value_dpecodeptr_1;
    return_value_dpecodeptr_1=dpecodeptr();
    if(*return_value_dpecodeptr_1 == 5)
      est_set_ecode(&db->ecode, 6, 4870);

    else
    {
      est_set_ecode(&db->ecode, 4, 4872);
      db->fatal = 1;
    }
    return (char *)(void *)0;
  }

  vlcurnext(db->fwmdb);
  return word;
}

// est_db_word_num
// file estraier.c line 2709
signed int est_db_word_num(struct anonymous_0 *db)
{
  signed int wnum;
  wnum=vlrnum(db->fwmdb);
  return wnum > 0 ? wnum : 0;
}

// est_db_word_rec_size
// file estraier.c line 4883
signed int est_db_word_rec_size(struct anonymous_0 *db, const char *word)
{
  signed int num;
  const char *return_value_cbmapget_1;
  return_value_cbmapget_1=cbmapget(db->idxcc, word, -1, &num);
  if(return_value_cbmapget_1 == ((const char *)NULL))
    num = 0;

  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(word);
  signed int return_value_est_idx_vsiz_3;
  return_value_est_idx_vsiz_3=est_idx_vsiz(db->idxdb, word, (signed int)return_value_strlen_2);
  return return_value_est_idx_vsiz_3 + num;
}

// est_db_write_meta
// file estraier.c line 7774
static signed int est_db_write_meta(struct anonymous_0 *db)
{
  char vbuf[32l];
  char *sbuf;
  signed int err;
  signed int ssiz;
  err = 0;
  signed int return_value_est_idx_num_1;
  return_value_est_idx_num_1=est_idx_num(db->idxdb);
  sprintf(vbuf, "%d", return_value_est_idx_num_1);
  signed int return_value_dpput_2;
  return_value_dpput_2=dpput(db->metadb, "_idxnum", -1, vbuf, -1, 0);
  if(return_value_dpput_2 == 0)
    err = 1;

  sprintf(vbuf, "%d", db->dseq);
  signed int return_value_dpput_3;
  return_value_dpput_3=dpput(db->metadb, "_dseq", -1, vbuf, -1, 0);
  if(return_value_dpput_3 == 0)
    err = 1;

  sprintf(vbuf, "%d", db->dnum);
  signed int return_value_dpput_4;
  return_value_dpput_4=dpput(db->metadb, "_dnum", -1, vbuf, -1, 0);
  if(return_value_dpput_4 == 0)
    err = 1;

  if(!(db->metacc == ((struct anonymous_5 *)NULL)))
  {
    sbuf=cbmapdump(db->metacc, &ssiz);
    signed int return_value_dpput_5;
    return_value_dpput_5=dpput(db->metadb, "_meta", -1, sbuf, ssiz, 0);
    if(return_value_dpput_5 == 0)
      err = 1;

    free((void *)sbuf);
  }

  if(!(err == 0))
  {
    est_set_ecode(&db->ecode, 4, 7791);
    db->fatal = 1;
  }

  return err != 0 ? 0 : 1;
}

// est_decode_idx_rec
// file estraier.c line 6951
static void est_decode_idx_rec(struct anonymous_9 *datum, const char *vbuf, signed int vsiz, signed int smode)
{
  const char *rp;
  const char *ep;
  const char *sp;
  char nbuf[32l];
  signed int cid;
  signed int vnum;
  signed int vstep;
  rp = vbuf;
  ep = vbuf + (signed long int)vsiz;
  cid = 0;
  while(!(rp >= ep))
  {
    do
    {
      signed int _EST_i;
      signed int _EST_base;
      vnum = 0;
      _EST_base = 1;
      _EST_i = 0;
      for( ; (_Bool)1; _EST_i = _EST_i + 1)
      {
        if((signed int)rp[(signed long int)_EST_i] >= 0)
        {
          vnum = vnum + (signed int)((signed char *)rp)[(signed long int)_EST_i] * _EST_base;
          break;
        }

        vnum = vnum + _EST_base * ((signed int)((signed char *)rp)[(signed long int)_EST_i] + 1) * -1;
        _EST_base = _EST_base * 128;
      }
      vstep = _EST_i + 1;
    }
    while((_Bool)0);
    cid = cid + vnum + 1;
    rp = rp + (signed long int)vstep;
    sp = rp;
    if(!(smode == 1048576))
    {
      if(smode == 2097152 || smode == 4194304)
        goto __CPROVER_DUMP_L8;

    }

    else
      goto __CPROVER_DUMP_L9;
    rp = rp + 1l;
    goto __CPROVER_DUMP_L9;

  __CPROVER_DUMP_L8:
    ;
    rp = rp + (signed long int)sizeof(signed int) /*4ul*/ ;

  __CPROVER_DUMP_L9:
    ;
    for( ; !((signed int)*rp == 0x00); rp = rp + (signed long int)2)
      ;
    rp = rp + 1l;
    do
    {
      signed int _EST_num = cid;
      struct anonymous_10 EST_d;
      if(_EST_num == 0)
      {
        ((signed char *)nbuf)[(signed long int)0] = (signed char)0;
        vstep = 1;
      }

      else
      {
        vstep = 0;
        for( ; _EST_num >= 1; vstep = vstep + 1)
        {
          EST_d=div(_EST_num, 128);
          _EST_num = EST_d.quot;
          if(_EST_num >= 1)
            ((signed char *)nbuf)[(signed long int)vstep] = (signed char)(-EST_d.rem - 1);

          else
            ((signed char *)nbuf)[(signed long int)vstep] = (signed char)EST_d.rem;
        }
      }
    }
    while((_Bool)0);
    do
    {
      if(datum->dsize + vstep >= datum->asize)
      {
        datum->asize = datum->asize * 2 + vstep + 1;
        void *return_value_realloc_1;
        return_value_realloc_1=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
        datum->dptr = (char *)return_value_realloc_1;
        if(!(datum->dptr == ((char *)NULL)))
          datum->dptr;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)nbuf, (unsigned long int)vstep);
      datum->dsize = datum->dsize + vstep;
      datum->dptr[(signed long int)datum->dsize] = (char)0;
    }
    while((_Bool)0);
    do
    {
      if((rp - sp) + (signed long int)datum->dsize >= (signed long int)datum->asize)
      {
        datum->asize = (signed int)((signed long int)(datum->asize * 2) + (rp - sp) + (signed long int)1);
        void *return_value_realloc_2;
        return_value_realloc_2=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
        datum->dptr = (char *)return_value_realloc_2;
        if(!(datum->dptr == ((char *)NULL)))
          datum->dptr;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)sp, (unsigned long int)(rp - sp));
      datum->dsize = datum->dsize + (signed int)(rp - sp);
      datum->dptr[(signed long int)datum->dsize] = (char)0;
    }
    while((_Bool)0);
  }
}

// est_deflate
// file estraier.c line 3750
char * est_deflate(const char *ptr, signed int size, signed int *sp, signed int mode)
{
  struct z_stream_s zs;
  char *buf;
  unsigned char obuf[8192l];
  signed int rv;
  signed int asiz;
  signed int bsiz;
  signed int osiz;
  unsigned long int return_value_strlen_1;
  if(!(size >= 0))
  {
    return_value_strlen_1=strlen(ptr);
    size = (signed int)return_value_strlen_1;
  }

  zs.zalloc = ((void * (*)(void *, unsigned int, unsigned int))NULL);
  zs.zfree = ((void (*)(void *, void *))NULL);
  zs.opaque = NULL;
  signed int return_value_deflateInit2__2;
  signed int return_value_deflateInit2__3;
  if(!(mode == -1))
  {
    if(mode == 1)
      goto __CPROVER_DUMP_L4;

  }

  else
  {
    return_value_deflateInit2__2=deflateInit2_(&zs, 5, 8, -15, 7, 0, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
    if(!(return_value_deflateInit2__2 == 0))
      return (char *)(void *)0;

    goto __CPROVER_DUMP_L8;

  __CPROVER_DUMP_L4:
    ;
    return_value_deflateInit2__3=deflateInit2_(&zs, 6, 8, 15 + 16, 9, 0, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
    if(!(return_value_deflateInit2__3 == 0))
      return (char *)(void *)0;

    goto __CPROVER_DUMP_L8;
  }
  signed int return_value_deflateInit2__4;
  return_value_deflateInit2__4=deflateInit2_(&zs, 6, 8, 15, 8, 0, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
  if(!(return_value_deflateInit2__4 == 0))
    return (char *)(void *)0;

  else
  {
    goto __CPROVER_DUMP_L8;

  __CPROVER_DUMP_L8:
    ;
    asiz = size + 16;
    if(!(asiz >= 8192))
      asiz = 8192;

    void *return_value_malloc_5;
    return_value_malloc_5=malloc((unsigned long int)asiz);
    buf = (char *)return_value_malloc_5;
    if(!(buf == ((char *)NULL)))
      buf;

    else
      cbmyfatal("out of memory");
    bsiz = 0;
    zs.next_in = (unsigned char *)ptr;
    zs.avail_in = (unsigned int)size;
    zs.next_out = obuf;
    zs.avail_out = (unsigned int)8192;
    do
    {
      rv=deflate(&zs, 4);
      if(!(rv == 0))
        break;

      osiz = (signed int)((unsigned int)8192 - zs.avail_out);
      if(!(asiz >= bsiz + osiz))
      {
        asiz = asiz * 2 + osiz;
        void *return_value_realloc_6;
        return_value_realloc_6=realloc((void *)buf, (unsigned long int)asiz);
        buf = (char *)return_value_realloc_6;
        if(!(buf == ((char *)NULL)))
          buf;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(buf + (signed long int)bsiz), (const void *)obuf, (unsigned long int)osiz);
      bsiz = bsiz + osiz;
      zs.next_out = obuf;
      zs.avail_out = (unsigned int)8192;
    }
    while((_Bool)1);
    if(!(rv == 1))
    {
      free((void *)buf);
      deflateEnd(&zs);
      return (char *)(void *)0;
    }

    else
    {
      osiz = (signed int)((unsigned int)8192 - zs.avail_out);
      if(!(asiz >= 1 + bsiz + osiz))
      {
        asiz = asiz * 2 + osiz;
        void *return_value_realloc_7;
        return_value_realloc_7=realloc((void *)buf, (unsigned long int)asiz);
        buf = (char *)return_value_realloc_7;
        if(!(buf == ((char *)NULL)))
          buf;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(buf + (signed long int)bsiz), (const void *)obuf, (unsigned long int)osiz);
      bsiz = bsiz + osiz;
      buf[(signed long int)bsiz] = (char)0;
      if(mode == -1)
        bsiz = bsiz + 1;

      *sp = bsiz;
      deflateEnd(&zs);
      return buf;
    }
  }
}

// est_doc_add_attr
// file estraier.c line 492
void est_doc_add_attr(struct anonymous_14 *doc, const char *name, const char *value)
{
  char *rbuf;
  char *wp;
  signed int len;
  _Bool tmp_if_expr_1;
  if((signed int)*name == 0)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)name[(signed long int)0] == 37 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    if(doc->attrs == ((struct anonymous_5 *)NULL))
      doc->attrs=cbmapopenex(31);

    if(!(value == ((const char *)NULL)))
    {
      rbuf=cbmemdup(value, -1);
      wp = rbuf;
      for( ; !((signed int)*wp == 0); wp = wp + 1l)
        if((signed int)*wp >= 1)
        {
          if(!((signed int)*wp >= 32))
            *wp = (char)32;

        }

      cbstrsqzspc(rbuf);
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(name);
      len = (signed int)return_value_strlen_2;
      if(len >= 1)
        cbmapput(doc->attrs, name, len, rbuf, -1, 1);

      free((void *)rbuf);
    }

    else
      cbmapout(doc->attrs, name, -1);
  }

}

// est_doc_add_hidden_text
// file estraier.c line 540
void est_doc_add_hidden_text(struct anonymous_14 *doc, const char *text)
{
  unsigned char *utext;
  char *rtext;
  char *wp;
  signed int size;
  for( ; (signed int)*text >= 1; text = text + 1l)
    if((signed int)*text >= 33)
      break;

  if(!((signed int)*text == 0))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(text);
    char *return_value_est_uconv_in_2;
    return_value_est_uconv_in_2=est_uconv_in(text, (signed int)return_value_strlen_1, &size);
    utext = (unsigned char *)return_value_est_uconv_in_2;
    est_normalize_text(utext, size, &size);
    rtext=est_uconv_out((char *)utext, size, (signed int *)(void *)0);
    wp = rtext;
    for( ; !((signed int)*wp == 0); wp = wp + 1l)
      if((signed int)*wp >= 1)
      {
        if(!((signed int)*wp >= 32))
          *wp = (char)32;

      }

    cbstrsqzspc(rtext);
    if(!((signed int)*rtext == 0))
    {
      if(doc->attrs == ((struct anonymous_5 *)NULL))
        doc->attrs=cbmapopenex(31);

      const char *return_value_cbmapget_3;
      return_value_cbmapget_3=cbmapget(doc->attrs, "", 0, (signed int *)(void *)0);
      if(!(return_value_cbmapget_3 == ((const char *)NULL)))
        cbmapputcat(doc->attrs, "", 0, " ", 1);

      cbmapputcat(doc->attrs, "", 0, rtext, -1);
    }

    free((void *)rtext);
    free((void *)utext);
  }

}

// est_doc_add_text
// file estraier.c line 513
void est_doc_add_text(struct anonymous_14 *doc, const char *text)
{
  unsigned char *utext;
  char *rtext;
  char *wp;
  signed int size;
  for( ; (signed int)*text >= 1; text = text + 1l)
    if((signed int)*text >= 33)
      break;

  if(!((signed int)*text == 0))
  {
    if(doc->dtexts == ((struct anonymous_6 *)NULL))
      do
      {
        void *return_value_malloc_1;
        return_value_malloc_1=malloc(sizeof(struct anonymous_6) /*24ul*/ );
        doc->dtexts = (struct anonymous_6 *)return_value_malloc_1;
        if(!(doc->dtexts == ((struct anonymous_6 *)NULL)))
          doc->dtexts;

        else
          cbmyfatal("out of memory");
        doc->dtexts->anum = 64;
        void *return_value_malloc_2;
        return_value_malloc_2=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)doc->dtexts->anum);
        doc->dtexts->array = (struct anonymous_28 *)return_value_malloc_2;
        if(!(doc->dtexts->array == ((struct anonymous_28 *)NULL)))
          doc->dtexts->array;

        else
          cbmyfatal("out of memory");
        doc->dtexts->start = 0;
        doc->dtexts->num = 0;
      }
      while((_Bool)0);

    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(text);
    char *return_value_est_uconv_in_4;
    return_value_est_uconv_in_4=est_uconv_in(text, (signed int)return_value_strlen_3, &size);
    utext = (unsigned char *)return_value_est_uconv_in_4;
    est_normalize_text(utext, size, &size);
    rtext=est_uconv_out((char *)utext, size, (signed int *)(void *)0);
    wp = rtext;
    for( ; !((signed int)*wp == 0); wp = wp + 1l)
      if((signed int)*wp >= 1)
      {
        if(!((signed int)*wp >= 32))
          *wp = (char)32;

      }

    cbstrsqzspc(rtext);
    if(!((signed int)*rtext == 0))
      do
      {
        signed int _CB_index = doc->dtexts->start + doc->dtexts->num;
        if(_CB_index >= doc->dtexts->anum)
        {
          doc->dtexts->anum = doc->dtexts->anum * 2;
          void *return_value_realloc_5;
          return_value_realloc_5=realloc((void *)doc->dtexts->array, (unsigned long int)doc->dtexts->anum * sizeof(struct anonymous_28) /*16ul*/ );
          doc->dtexts->array = (struct anonymous_28 *)return_value_realloc_5;
          if(!(doc->dtexts->array == ((struct anonymous_28 *)NULL)))
            doc->dtexts->array;

          else
            cbmyfatal("out of memory");
        }

        (doc->dtexts->array + (signed long int)_CB_index)->dptr = rtext;
        unsigned long int return_value_strlen_6;
        return_value_strlen_6=strlen(rtext);
        (doc->dtexts->array + (signed long int)_CB_index)->dsize = (signed int)return_value_strlen_6;
        doc->dtexts->num = doc->dtexts->num + 1;
      }
      while((_Bool)0);

    else
      free((void *)rtext);
    free((void *)utext);
  }

}

// est_doc_attr
// file estraier.c line 616
const char * est_doc_attr(struct anonymous_14 *doc, const char *name)
{
  _Bool tmp_if_expr_1;
  if(doc->attrs == ((struct anonymous_5 *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)name[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (const char *)(void *)0;

  else
  {
    const char *return_value_cbmapget_2;
    return_value_cbmapget_2=cbmapget(doc->attrs, name, -1, (signed int *)(void *)0);
    return return_value_cbmapget_2;
  }
}

// est_doc_attr_names
// file estraier.c line 596
struct anonymous_6 * est_doc_attr_names(struct anonymous_14 *doc)
{
  struct anonymous_6 *names;
  const char *kbuf;
  signed int ksiz;
  if(doc->attrs == ((struct anonymous_5 *)NULL))
  {
    do
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(sizeof(struct anonymous_6) /*24ul*/ );
      names = (struct anonymous_6 *)return_value_malloc_1;
      if(!(names == ((struct anonymous_6 *)NULL)))
        names;

      else
        cbmyfatal("out of memory");
      names->anum = 64;
      void *return_value_malloc_2;
      return_value_malloc_2=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)names->anum);
      names->array = (struct anonymous_28 *)return_value_malloc_2;
      if(!(names->array == ((struct anonymous_28 *)NULL)))
        names->array;

      else
        cbmyfatal("out of memory");
      names->start = 0;
      names->num = 0;
    }
    while((_Bool)0);
    return names;
  }

  else
  {
    do
    {
      void *return_value_malloc_3;
      return_value_malloc_3=malloc(sizeof(struct anonymous_6) /*24ul*/ );
      names = (struct anonymous_6 *)return_value_malloc_3;
      if(!(names == ((struct anonymous_6 *)NULL)))
        names;

      else
        cbmyfatal("out of memory");
      names->anum = 64;
      void *return_value_malloc_4;
      return_value_malloc_4=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)names->anum);
      names->array = (struct anonymous_28 *)return_value_malloc_4;
      if(!(names->array == ((struct anonymous_28 *)NULL)))
        names->array;

      else
        cbmyfatal("out of memory");
      names->start = 0;
      names->num = 0;
    }
    while((_Bool)0);
    cbmapiterinit(doc->attrs);
    do
    {
      kbuf=cbmapiternext(doc->attrs, &ksiz);
      if(kbuf == ((const char *)NULL))
        break;

      if(ksiz >= 1)
      {
        if(!((signed int)*kbuf == 9))
          do
          {
            signed int _CB_index = names->start + names->num;
            if(_CB_index >= names->anum)
            {
              names->anum = names->anum * 2;
              void *return_value_realloc_5;
              return_value_realloc_5=realloc((void *)names->array, (unsigned long int)names->anum * sizeof(struct anonymous_28) /*16ul*/ );
              names->array = (struct anonymous_28 *)return_value_realloc_5;
              if(!(names->array == ((struct anonymous_28 *)NULL)))
                names->array;

              else
                cbmyfatal("out of memory");
            }

            void *return_value_malloc_6;
            return_value_malloc_6=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
            (names->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_6;
            if(!((names->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
              (names->array + (signed long int)_CB_index)->dptr;

            else
              cbmyfatal("out of memory");
            memcpy((void *)(names->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
            (names->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
            (names->array + (signed long int)_CB_index)->dsize = ksiz;
            names->num = names->num + 1;
          }
          while((_Bool)0);

      }

    }
    while((_Bool)1);
    cblistsort(names);
    return names;
  }
}

// est_doc_cat_texts
// file estraier.c line 632
char * est_doc_cat_texts(struct anonymous_14 *doc)
{
  struct anonymous_9 *datum;
  const char *elem;
  signed int i;
  signed int size;
  char *return_value_cbmemdup_1;
  if(doc->dtexts == ((struct anonymous_6 *)NULL))
  {
    return_value_cbmemdup_1=cbmemdup("", 0);
    return return_value_cbmemdup_1;
  }

  else
  {
    do
    {
      void *return_value_malloc_2;
      return_value_malloc_2=malloc(sizeof(struct anonymous_9) /*16ul*/ );
      datum = (struct anonymous_9 *)return_value_malloc_2;
      if(!(datum == ((struct anonymous_9 *)NULL)))
        datum;

      else
        cbmyfatal("out of memory");
      void *return_value_malloc_3;
      return_value_malloc_3=malloc((unsigned long int)12);
      datum->dptr = (char *)return_value_malloc_3;
      if(!(datum->dptr == ((char *)NULL)))
        datum->dptr;

      else
        cbmyfatal("out of memory");
      datum->dptr[(signed long int)0] = (char)0;
      datum->dsize = 0;
      datum->asize = 12;
    }
    while((_Bool)0);
    i = 0;
    for( ; !(i >= doc->dtexts->num); i = i + 1)
    {
      size = (doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dsize;
      elem = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
      if(i >= 1)
        do
        {
          if(1 + datum->dsize >= datum->asize)
          {
            datum->asize = datum->asize * 2 + 1 + 1;
            void *return_value_realloc_4;
            return_value_realloc_4=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc_4;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)" ", (unsigned long int)1);
          datum->dsize = datum->dsize + 1;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);

      do
      {
        if(datum->dsize + size >= datum->asize)
        {
          datum->asize = datum->asize * 2 + size + 1;
          void *return_value_realloc_5;
          return_value_realloc_5=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_5;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)elem, (unsigned long int)size);
        datum->dsize = datum->dsize + size;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
    }
    char *return_value_cbdatumtomalloc_6;
    return_value_cbdatumtomalloc_6=cbdatumtomalloc(datum, (signed int *)(void *)0);
    return return_value_cbdatumtomalloc_6;
  }
}

// est_doc_delete
// file estraier.c line 482
void est_doc_delete(struct anonymous_14 *doc)
{
  if(!(doc->kwords == ((struct anonymous_5 *)NULL)))
    cbmapclose(doc->kwords);

  if(!(doc->dtexts == ((struct anonymous_6 *)NULL)))
    do
    {
      signed int _CB_i;
      signed int _CB_end = doc->dtexts->start + doc->dtexts->num;
      _CB_i = doc->dtexts->start;
      for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
        free((void *)(doc->dtexts->array + (signed long int)_CB_i)->dptr);
      free((void *)doc->dtexts->array);
      free((void *)doc->dtexts);
    }
    while((_Bool)0);

  if(!(doc->attrs == ((struct anonymous_5 *)NULL)))
    cbmapclose(doc->attrs);

  free((void *)doc);
}

// est_doc_dump_draft
// file estraier.c line 664
char * est_doc_dump_draft(struct anonymous_14 *doc)
{
  struct anonymous_6 *list;
  struct anonymous_9 *datum;
  const char *kbuf;
  const char *vbuf;
  signed int i;
  signed int ksiz;
  signed int vsiz;
  do
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_9) /*16ul*/ );
    datum = (struct anonymous_9 *)return_value_malloc_1;
    if(!(datum == ((struct anonymous_9 *)NULL)))
      datum;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)12);
    datum->dptr = (char *)return_value_malloc_2;
    if(!(datum->dptr == ((char *)NULL)))
      datum->dptr;

    else
      cbmyfatal("out of memory");
    datum->dptr[(signed long int)0] = (char)0;
    datum->dsize = 0;
    datum->asize = 12;
  }
  while((_Bool)0);
  if(!(doc->attrs == ((struct anonymous_5 *)NULL)))
  {
    list=est_doc_attr_names(doc);
    i = 0;
    for( ; !(i >= list->num); i = i + 1)
    {
      ksiz = (list->array + (signed long int)(list->start + i))->dsize;
      kbuf = (const char *)(list->array + (signed long int)(list->start + i))->dptr;
      vbuf=cbmapget(doc->attrs, kbuf, ksiz, &vsiz);
      do
      {
        if(datum->dsize + ksiz >= datum->asize)
        {
          datum->asize = datum->asize * 2 + ksiz + 1;
          void *return_value_realloc_3;
          return_value_realloc_3=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_3;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)kbuf, (unsigned long int)ksiz);
        datum->dsize = datum->dsize + ksiz;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(1 + datum->dsize >= datum->asize)
        {
          datum->asize = datum->asize * 2 + 1 + 1;
          void *return_value_realloc_4;
          return_value_realloc_4=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_4;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"=", (unsigned long int)1);
        datum->dsize = datum->dsize + 1;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(datum->dsize + vsiz >= datum->asize)
        {
          datum->asize = datum->asize * 2 + vsiz + 1;
          void *return_value_realloc_5;
          return_value_realloc_5=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_5;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)vbuf, (unsigned long int)vsiz);
        datum->dsize = datum->dsize + vsiz;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(1 + datum->dsize >= datum->asize)
        {
          datum->asize = datum->asize * 2 + 1 + 1;
          void *return_value_realloc_6;
          return_value_realloc_6=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_6;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\n", (unsigned long int)1);
        datum->dsize = datum->dsize + 1;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
    }
    do
    {
      signed int _CB_i;
      signed int _CB_end = list->start + list->num;
      _CB_i = list->start;
      for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
        free((void *)(list->array + (signed long int)_CB_i)->dptr);
      free((void *)list->array);
      free((void *)list);
    }
    while((_Bool)0);
  }

  signed int return_value_cbmaprnum_17;
  if(!(doc->kwords == ((struct anonymous_5 *)NULL)))
  {
    return_value_cbmaprnum_17=cbmaprnum(doc->kwords);
    if(return_value_cbmaprnum_17 >= 1)
    {
      do
      {
        unsigned long int return_value_strlen_9;
        return_value_strlen_9=strlen("%VECTOR");
        if(return_value_strlen_9 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
        {
          unsigned long int return_value_strlen_7;
          return_value_strlen_7=strlen("%VECTOR");
          datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen_7 + (unsigned long int)1);
          void *return_value_realloc_8;
          return_value_realloc_8=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_8;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        unsigned long int return_value_strlen_10;
        return_value_strlen_10=strlen("%VECTOR");
        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"%VECTOR", return_value_strlen_10);
        unsigned long int return_value_strlen_11;
        return_value_strlen_11=strlen("%VECTOR");
        datum->dsize = datum->dsize + (signed int)return_value_strlen_11;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      cbmapiterinit(doc->kwords);
      do
      {
        kbuf=cbmapiternext(doc->kwords, &ksiz);
        if(kbuf == ((const char *)NULL))
          break;

        do
        {
          struct _CBMAPDATUM *_CB_datum = (struct _CBMAPDATUM *)(kbuf - (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/ );
          vsiz = _CB_datum->vsiz;
          vbuf = (char *)_CB_datum + (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/  + (signed long int)_CB_datum->ksiz + (signed long int)(((_CB_datum->ksiz | ~(-((signed int)sizeof(void *) /*8ul*/ ))) + 1) - _CB_datum->ksiz);
        }
        while((_Bool)0);
        do
        {
          if(1 + datum->dsize >= datum->asize)
          {
            datum->asize = datum->asize * 2 + 1 + 1;
            void *return_value_realloc_12;
            return_value_realloc_12=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc_12;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\t", (unsigned long int)1);
          datum->dsize = datum->dsize + 1;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);
        do
        {
          if(datum->dsize + ksiz >= datum->asize)
          {
            datum->asize = datum->asize * 2 + ksiz + 1;
            void *return_value_realloc_13;
            return_value_realloc_13=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc_13;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)kbuf, (unsigned long int)ksiz);
          datum->dsize = datum->dsize + ksiz;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);
        do
        {
          if(1 + datum->dsize >= datum->asize)
          {
            datum->asize = datum->asize * 2 + 1 + 1;
            void *return_value_realloc_14;
            return_value_realloc_14=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc_14;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\t", (unsigned long int)1);
          datum->dsize = datum->dsize + 1;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);
        do
        {
          if(datum->dsize + vsiz >= datum->asize)
          {
            datum->asize = datum->asize * 2 + vsiz + 1;
            void *return_value_realloc_15;
            return_value_realloc_15=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc_15;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)vbuf, (unsigned long int)vsiz);
          datum->dsize = datum->dsize + vsiz;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);
      }
      while((_Bool)1);
      do
      {
        if(1 + datum->dsize >= datum->asize)
        {
          datum->asize = datum->asize * 2 + 1 + 1;
          void *return_value_realloc_16;
          return_value_realloc_16=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_16;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\n", (unsigned long int)1);
        datum->dsize = datum->dsize + 1;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
    }

  }

  if(!(doc->attrs == ((struct anonymous_5 *)NULL)))
  {
    vbuf=cbmapget(doc->attrs, "\t", 1, &vsiz);
    if(!(vbuf == ((const char *)NULL)))
    {
      do
      {
        unsigned long int return_value_strlen_20;
        return_value_strlen_20=strlen("%SCORE");
        if(return_value_strlen_20 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
        {
          unsigned long int return_value_strlen_18;
          return_value_strlen_18=strlen("%SCORE");
          datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen_18 + (unsigned long int)1);
          void *return_value_realloc_19;
          return_value_realloc_19=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_19;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        unsigned long int return_value_strlen_21;
        return_value_strlen_21=strlen("%SCORE");
        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"%SCORE", return_value_strlen_21);
        unsigned long int return_value_strlen_22;
        return_value_strlen_22=strlen("%SCORE");
        datum->dsize = datum->dsize + (signed int)return_value_strlen_22;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(1 + datum->dsize >= datum->asize)
        {
          datum->asize = datum->asize * 2 + 1 + 1;
          void *return_value_realloc_23;
          return_value_realloc_23=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_23;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\t", (unsigned long int)1);
        datum->dsize = datum->dsize + 1;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(datum->dsize + vsiz >= datum->asize)
        {
          datum->asize = datum->asize * 2 + vsiz + 1;
          void *return_value_realloc_24;
          return_value_realloc_24=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_24;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)vbuf, (unsigned long int)vsiz);
        datum->dsize = datum->dsize + vsiz;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(1 + datum->dsize >= datum->asize)
        {
          datum->asize = datum->asize * 2 + 1 + 1;
          void *return_value_realloc_25;
          return_value_realloc_25=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_25;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\n", (unsigned long int)1);
        datum->dsize = datum->dsize + 1;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
    }

  }

  do
  {
    if(1 + datum->dsize >= datum->asize)
    {
      datum->asize = datum->asize * 2 + 1 + 1;
      void *return_value_realloc_26;
      return_value_realloc_26=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
      datum->dptr = (char *)return_value_realloc_26;
      if(!(datum->dptr == ((char *)NULL)))
        datum->dptr;

      else
        cbmyfatal("out of memory");
    }

    memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\n", (unsigned long int)1);
    datum->dsize = datum->dsize + 1;
    datum->dptr[(signed long int)datum->dsize] = (char)0;
  }
  while((_Bool)0);
  if(!(doc->dtexts == ((struct anonymous_6 *)NULL)))
  {
    i = 0;
    for( ; !(i >= doc->dtexts->num); i = i + 1)
    {
      ksiz = (doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dsize;
      kbuf = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
      do
      {
        if(datum->dsize + ksiz >= datum->asize)
        {
          datum->asize = datum->asize * 2 + ksiz + 1;
          void *return_value_realloc_27;
          return_value_realloc_27=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_27;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)kbuf, (unsigned long int)ksiz);
        datum->dsize = datum->dsize + ksiz;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(1 + datum->dsize >= datum->asize)
        {
          datum->asize = datum->asize * 2 + 1 + 1;
          void *return_value_realloc_28;
          return_value_realloc_28=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_28;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\n", (unsigned long int)1);
        datum->dsize = datum->dsize + 1;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
    }
  }

  if(!(doc->attrs == ((struct anonymous_5 *)NULL)))
  {
    vbuf=cbmapget(doc->attrs, "", 0, &vsiz);
    if(!(vbuf == ((const char *)NULL)))
    {
      do
      {
        if(1 + datum->dsize >= datum->asize)
        {
          datum->asize = datum->asize * 2 + 1 + 1;
          void *return_value_realloc_29;
          return_value_realloc_29=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_29;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\t", (unsigned long int)1);
        datum->dsize = datum->dsize + 1;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(datum->dsize + vsiz >= datum->asize)
        {
          datum->asize = datum->asize * 2 + vsiz + 1;
          void *return_value_realloc_30;
          return_value_realloc_30=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_30;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)vbuf, (unsigned long int)vsiz);
        datum->dsize = datum->dsize + vsiz;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(1 + datum->dsize >= datum->asize)
        {
          datum->asize = datum->asize * 2 + 1 + 1;
          void *return_value_realloc_31;
          return_value_realloc_31=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_31;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\n", (unsigned long int)1);
        datum->dsize = datum->dsize + 1;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
    }

  }

  char *return_value_cbdatumtomalloc_32;
  return_value_cbdatumtomalloc_32=cbdatumtomalloc(datum, (signed int *)(void *)0);
  return return_value_cbdatumtomalloc_32;
}

// est_doc_dup
// file estraier.c line 4209
struct anonymous_14 * est_doc_dup(struct anonymous_14 *doc)
{
  struct anonymous_14 *ndoc;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_14) /*32ul*/ );
  ndoc = (struct anonymous_14 *)return_value_malloc_1;
  if(!(ndoc == ((struct anonymous_14 *)NULL)))
    ndoc;

  else
    cbmyfatal("out of memory");
  ndoc->id = doc->id;
  struct anonymous_5 *tmp_if_expr_3;
  struct anonymous_5 *return_value_cbmapdup_2;
  if(!(doc->attrs == ((struct anonymous_5 *)NULL)))
  {
    return_value_cbmapdup_2=cbmapdup(doc->attrs);
    tmp_if_expr_3 = return_value_cbmapdup_2;
  }

  else
    tmp_if_expr_3 = (struct anonymous_5 *)(void *)0;
  ndoc->attrs = tmp_if_expr_3;
  struct anonymous_6 *tmp_if_expr_5;
  struct anonymous_6 *return_value_cblistdup_4;
  if(!(doc->dtexts == ((struct anonymous_6 *)NULL)))
  {
    return_value_cblistdup_4=cblistdup(doc->dtexts);
    tmp_if_expr_5 = return_value_cblistdup_4;
  }

  else
    tmp_if_expr_5 = (struct anonymous_6 *)(void *)0;
  ndoc->dtexts = tmp_if_expr_5;
  struct anonymous_5 *tmp_if_expr_7;
  struct anonymous_5 *return_value_cbmapdup_6;
  if(!(doc->kwords == ((struct anonymous_5 *)NULL)))
  {
    return_value_cbmapdup_6=cbmapdup(doc->kwords);
    tmp_if_expr_7 = return_value_cbmapdup_6;
  }

  else
    tmp_if_expr_7 = (struct anonymous_5 *)(void *)0;
  ndoc->kwords = tmp_if_expr_7;
  return ndoc;
}

// est_doc_hidden_texts
// file estraier.c line 4229
const char * est_doc_hidden_texts(struct anonymous_14 *doc)
{
  const char *rv;
  const char *tmp_if_expr_2;
  const char *return_value_cbmapget_1;
  if(!(doc->attrs == ((struct anonymous_5 *)NULL)))
  {
    return_value_cbmapget_1=cbmapget(doc->attrs, "", 0, (signed int *)(void *)0);
    tmp_if_expr_2 = return_value_cbmapget_1;
  }

  else
    tmp_if_expr_2 = (const char *)(void *)0;
  rv = tmp_if_expr_2;
  return rv != ((const char *)NULL) ? rv : "";
}

// est_doc_id
// file estraier.c line 589
signed int est_doc_id(struct anonymous_14 *doc)
{
  return doc->id;
}

// est_doc_is_empty
// file estraier.c line 4268
signed int est_doc_is_empty(struct anonymous_14 *doc)
{
  _Bool tmp_if_expr_3;
  if(doc->dtexts == ((struct anonymous_6 *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)doc->dtexts->num < 1 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  const char *return_value_cbmapget_1;
  if(tmp_if_expr_3)
  {
    if(doc->attrs == ((struct anonymous_5 *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_cbmapget_1=cbmapget(doc->attrs, "", 0, (signed int *)(void *)0);
      tmp_if_expr_2 = !(return_value_cbmapget_1 != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_2)
      goto __CPROVER_DUMP_L5;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L5:
    ;
    return 0;
  }
}

// est_doc_keywords
// file estraier.c line 648
struct anonymous_5 * est_doc_keywords(struct anonymous_14 *doc)
{
  return doc->kwords;
}

// est_doc_make_snippet
// file estraier.c line 719
char * est_doc_make_snippet(struct anonymous_14 *doc, const struct anonymous_6 *words, signed int wwidth, signed int hwidth, signed int awidth)
{
  struct anonymous_9 *sbuf;
  const char *text;
  char *snippet;
  signed int i;
  signed int size;
  if(doc->dtexts == ((struct anonymous_6 *)NULL))
    do
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(sizeof(struct anonymous_6) /*24ul*/ );
      doc->dtexts = (struct anonymous_6 *)return_value_malloc_1;
      if(!(doc->dtexts == ((struct anonymous_6 *)NULL)))
        doc->dtexts;

      else
        cbmyfatal("out of memory");
      doc->dtexts->anum = 64;
      void *return_value_malloc_2;
      return_value_malloc_2=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)doc->dtexts->anum);
      doc->dtexts->array = (struct anonymous_28 *)return_value_malloc_2;
      if(!(doc->dtexts->array == ((struct anonymous_28 *)NULL)))
        doc->dtexts->array;

      else
        cbmyfatal("out of memory");
      doc->dtexts->start = 0;
      doc->dtexts->num = 0;
    }
    while((_Bool)0);

  do
  {
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(sizeof(struct anonymous_9) /*16ul*/ );
    sbuf = (struct anonymous_9 *)return_value_malloc_3;
    if(!(sbuf == ((struct anonymous_9 *)NULL)))
      sbuf;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc_4;
    return_value_malloc_4=malloc((unsigned long int)12);
    sbuf->dptr = (char *)return_value_malloc_4;
    if(!(sbuf->dptr == ((char *)NULL)))
      sbuf->dptr;

    else
      cbmyfatal("out of memory");
    sbuf->dptr[(signed long int)0] = (char)0;
    sbuf->dsize = 0;
    sbuf->asize = 12;
  }
  while((_Bool)0);
  i = 0;
  for( ; !(i >= doc->dtexts->num); i = i + 1)
  {
    size = (doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dsize;
    text = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
    if(i >= 1)
      do
      {
        if(1 + sbuf->dsize >= sbuf->asize)
        {
          sbuf->asize = sbuf->asize * 2 + 1 + 1;
          void *return_value_realloc_5;
          return_value_realloc_5=realloc((void *)sbuf->dptr, (unsigned long int)sbuf->asize);
          sbuf->dptr = (char *)return_value_realloc_5;
          if(!(sbuf->dptr == ((char *)NULL)))
            sbuf->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(sbuf->dptr + (signed long int)sbuf->dsize), (const void *)" ", (unsigned long int)1);
        sbuf->dsize = sbuf->dsize + 1;
        sbuf->dptr[(signed long int)sbuf->dsize] = (char)0;
      }
      while((_Bool)0);

    do
    {
      if(sbuf->dsize + size >= sbuf->asize)
      {
        sbuf->asize = sbuf->asize * 2 + size + 1;
        void *return_value_realloc_6;
        return_value_realloc_6=realloc((void *)sbuf->dptr, (unsigned long int)sbuf->asize);
        sbuf->dptr = (char *)return_value_realloc_6;
        if(!(sbuf->dptr == ((char *)NULL)))
          sbuf->dptr;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(sbuf->dptr + (signed long int)sbuf->dsize), (const void *)text, (unsigned long int)size);
      sbuf->dsize = sbuf->dsize + size;
      sbuf->dptr[(signed long int)sbuf->dsize] = (char)0;
    }
    while((_Bool)0);
  }
  snippet=est_make_snippet((const char *)sbuf->dptr, (signed int)sbuf->dsize, words, wwidth, hwidth, awidth);
  do
  {
    free((void *)sbuf->dptr);
    free((void *)sbuf);
  }
  while((_Bool)0);
  return snippet;
}

// est_doc_new
// file estraier.c line 417
struct anonymous_14 * est_doc_new(void)
{
  struct anonymous_14 *doc;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_14) /*32ul*/ );
  doc = (struct anonymous_14 *)return_value_malloc_1;
  if(!(doc == ((struct anonymous_14 *)NULL)))
    doc;

  else
    cbmyfatal("out of memory");
  doc->id = -1;
  doc->attrs = (struct anonymous_5 *)(void *)0;
  doc->dtexts = (struct anonymous_6 *)(void *)0;
  doc->kwords = (struct anonymous_5 *)(void *)0;
  return doc;
}

// est_doc_new_from_draft
// file estraier.c line 429
struct anonymous_14 * est_doc_new_from_draft(const char *draft)
{
  struct anonymous_14 *doc;
  struct anonymous_6 *lines;
  const char *line;
  char *pv;
  char *rp;
  char *ep;
  signed int i;
  doc=est_doc_new();
  lines=cbsplit(draft, -1, "\n");
  i = 0;
  signed int return_value_cbstrfwmatch_2;
  signed int return_value_atoi_1;
  char *tmp_post_4;
  for( ; !(i >= lines->num); i = i + 1)
  {
    line = (const char *)(lines->array + (signed long int)(lines->start + i))->dptr;
    for( ; (signed int)*line >= 1; line = line + 1l)
      if((signed int)*line >= 33)
        break;

    if((signed int)*line == 0)
    {
      i = i + 1;
      break;
    }

    if((signed int)*line == 37)
    {
      signed int return_value_cbstrfwmatch_3;
      return_value_cbstrfwmatch_3=cbstrfwmatch(line, "%VECTOR");
      if(!(return_value_cbstrfwmatch_3 == 0))
      {
        if(doc->kwords == ((struct anonymous_5 *)NULL))
          doc->kwords=cbmapopenex(31);

        rp=strchr(line, 9);
        if(!(rp == ((char *)NULL)))
          rp = rp + 1l;

        for( ; !(rp == ((char *)NULL)); rp = ep)
        {
          pv=strchr(rp, 9);
          if(pv == ((char *)NULL))
            break;

          pv = pv + 1l;
          ep=strchr(pv, 9);
          if(!(ep == ((char *)NULL)))
          {
            *ep = (char)0;
            ep = ep + 1l;
          }

          if(!((signed int)*rp == 0))
          {
            if(!((signed int)*pv == 0))
              cbmapput(doc->kwords, rp, (signed int)((pv - rp) - (signed long int)1), pv, -1, 1);

          }

        }
      }

      else
      {
        return_value_cbstrfwmatch_2=cbstrfwmatch(line, "%SCORE");
        if(!(return_value_cbstrfwmatch_2 == 0))
        {
          rp=strchr(line, 9);
          if(!(rp == ((char *)NULL)))
          {
            return_value_atoi_1=atoi(rp + (signed long int)1);
            est_doc_set_score(doc, return_value_atoi_1);
          }

        }

      }
    }

    else
    {
      pv=strchr(line, 61);
      if(!(pv == ((char *)NULL)))
      {
        tmp_post_4 = pv;
        pv = pv + 1l;
        *tmp_post_4 = (char)0;
        est_doc_add_attr(doc, line, pv);
      }

    }
  }
  for( ; !(i >= lines->num); i = i + 1)
  {
    line = (const char *)(lines->array + (signed long int)(lines->start + i))->dptr;
    if((signed int)*line == 9)
      est_doc_add_hidden_text(doc, line + (signed long int)1);

    else
      est_doc_add_text(doc, line);
  }
  do
  {
    signed int _CB_i;
    signed int _CB_end = lines->start + lines->num;
    _CB_i = lines->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(lines->array + (signed long int)_CB_i)->dptr);
    free((void *)lines->array);
    free((void *)lines);
  }
  while((_Bool)0);
  return doc;
}

// est_doc_score
// file estraier.c line 655
signed int est_doc_score(struct anonymous_14 *doc)
{
  const char *vbuf;
  signed int return_value_atoi_1;
  if(!(doc->attrs == ((struct anonymous_5 *)NULL)))
  {
    vbuf=cbmapget(doc->attrs, "\t", 1, (signed int *)(void *)0);
    if(vbuf == ((const char *)NULL))
      goto __CPROVER_DUMP_L1;

    return_value_atoi_1=atoi(vbuf);
    return return_value_atoi_1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return -1;
  }
}

// est_doc_set_id
// file estraier.c line 4222
void est_doc_set_id(struct anonymous_14 *doc, signed int id)
{
  doc->id = id;
}

// est_doc_set_keywords
// file estraier.c line 567
void est_doc_set_keywords(struct anonymous_14 *doc, struct anonymous_5 *kwords)
{
  if(!(doc->kwords == ((struct anonymous_5 *)NULL)))
    cbmapclose(doc->kwords);

  doc->kwords=cbmapdup(kwords);
}

// est_doc_set_score
// file estraier.c line 575
void est_doc_set_score(struct anonymous_14 *doc, signed int score)
{
  char numbuf[32l];
  if(doc->attrs == ((struct anonymous_5 *)NULL))
    doc->attrs=cbmapopenex(31);

  if(score >= 0)
  {
    sprintf(numbuf, "%d", score);
    cbmapput(doc->attrs, "\t", 1, numbuf, -1, 1);
  }

  else
    cbmapout(doc->attrs, "\t", 1);
}

// est_doc_slim
// file estraier.c line 4238
void est_doc_slim(struct anonymous_14 *doc, signed int len)
{
  const char *vbuf;
  unsigned char *tbuf;
  signed int i;
  signed int vsiz;
  signed int tsiz;
  const char *return_value_cbmapget_1;
  _Bool tmp_if_expr_3;
  if(!(doc->dtexts == ((struct anonymous_6 *)NULL)))
  {
    if(!(doc->attrs == ((struct anonymous_5 *)NULL)))
    {
      return_value_cbmapget_1=cbmapget(doc->attrs, "", 0, &vsiz);
      if(!(return_value_cbmapget_1 == ((const char *)NULL)))
        len = len - vsiz;

    }

    i = 0;
    for( ; !(i >= doc->dtexts->num); i = i + 1)
    {
      vsiz = (doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dsize;
      vbuf = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
      len = len - vsiz;
      if(!(len >= 0))
      {
        char *return_value_cbmemdup_2;
        return_value_cbmemdup_2=cbmemdup(vbuf, vsiz);
        tbuf = (unsigned char *)return_value_cbmemdup_2;
        tsiz = vsiz > -len ? vsiz + len : 0;
        if(tsiz >= 1)
          for( ; !(tsiz >= vsiz); tsiz = tsiz + 1)
          {
            if(!((signed int)tbuf[(signed long int)tsiz] >= 33))
              tmp_if_expr_3 = (_Bool)1;

            else
              tmp_if_expr_3 = ((signed int)tbuf[(signed long int)tsiz] & 0xf0) == 0xe0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_3)
              break;

          }

        while(!(i >= doc->dtexts->num))
          do
            if(doc->dtexts->num >= 1)
            {
              free((void *)(doc->dtexts->array + (signed long int)((doc->dtexts->start + doc->dtexts->num) - 1))->dptr);
              doc->dtexts->num = doc->dtexts->num - 1;
            }

          while((_Bool)0);
        do
        {
          signed int _CB_index = doc->dtexts->start + doc->dtexts->num;
          if(_CB_index >= doc->dtexts->anum)
          {
            doc->dtexts->anum = doc->dtexts->anum * 2;
            void *return_value_realloc_4;
            return_value_realloc_4=realloc((void *)doc->dtexts->array, (unsigned long int)doc->dtexts->anum * sizeof(struct anonymous_28) /*16ul*/ );
            doc->dtexts->array = (struct anonymous_28 *)return_value_realloc_4;
            if(!(doc->dtexts->array == ((struct anonymous_28 *)NULL)))
              doc->dtexts->array;

            else
              cbmyfatal("out of memory");
          }

          (doc->dtexts->array + (signed long int)_CB_index)->dptr = (char *)tbuf;
          (doc->dtexts->array + (signed long int)_CB_index)->dsize = tsiz;
          doc->dtexts->num = doc->dtexts->num + 1;
        }
        while((_Bool)0);
        break;
      }

    }
  }

}

// est_doc_texts
// file estraier.c line 624
const struct anonymous_6 * est_doc_texts(struct anonymous_14 *doc)
{
  if(doc->dtexts == ((struct anonymous_6 *)NULL))
    do
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(sizeof(struct anonymous_6) /*24ul*/ );
      doc->dtexts = (struct anonymous_6 *)return_value_malloc_1;
      if(!(doc->dtexts == ((struct anonymous_6 *)NULL)))
        doc->dtexts;

      else
        cbmyfatal("out of memory");
      doc->dtexts->anum = 64;
      void *return_value_malloc_2;
      return_value_malloc_2=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)doc->dtexts->anum);
      doc->dtexts->array = (struct anonymous_28 *)return_value_malloc_2;
      if(!(doc->dtexts->array == ((struct anonymous_28 *)NULL)))
        doc->dtexts->array;

      else
        cbmyfatal("out of memory");
      doc->dtexts->start = 0;
      doc->dtexts->num = 0;
    }
    while((_Bool)0);

  return doc->dtexts;
}

// est_eclipse_scores
// file estraier.c line 9858
static signed int est_eclipse_scores(struct anonymous_0 *db, struct anonymous_8 *scores, signed int snum, signed int num, signed int vnum, signed int tfidf, double limit, struct anonymous_5 *shadows)
{
  struct anonymous_5 *svmap;
  struct anonymous_5 *tvmap;
  const char *suri;
  const char *turi;
  char *tmp;
  signed int i;
  signed int j;
  signed int ubase;
  signed int simurl;
  signed int max;
  signed int *svec;
  signed int *tvec;
  signed int pair[2l];
  signed int nnum;
  double dval;
  ubase = 0;
  simurl = 0;
  if(IEEE_FLOAT_EQUAL(limit, 100.0) || IEEE_FLOAT_EQUAL(limit, 101.0) || IEEE_FLOAT_EQUAL(limit, 102.0))
    ubase = 1;

  else
    if(limit >= 10.0)
    {
      simurl = 1;
      limit = limit - 10.0;
      if(limit < 0.01)
        limit = 0.01;

      if(limit > 1.0)
        limit = 1.0;

    }

  nnum = 0;
  signed int tmp_post_2;
  signed int tmp_post_3;
  _Bool tmp_if_expr_7;
  signed int return_value_cbmaprnum_6;
  signed int tmp_post_8;
  _Bool tmp_if_expr_10;
  signed int return_value_cbmaprnum_9;
  double return_value_acos_12;
  double return_value_pow_13;
  double return_value_cos_14;
  signed int tmp_post_24;
  signed int tmp_post_25;
  if(!(ubase == 0))
  {
    if(IEEE_FLOAT_EQUAL(limit, 100.0))
      max = (signed int)((double)num * 14.8 + (double)8);

    else
      if(IEEE_FLOAT_EQUAL(limit, 101.0))
        max = (signed int)((double)num * 6.8 + (double)8);

      else
        max = (signed int)((double)num * 4.8 + (double)8);
    if(!(snum >= max))
      max = snum;

    i = 0;
    for( ; !(i >= max); i = i + 1)
      (scores + (signed long int)i)->value=est_db_get_doc_attr(db, (scores + (signed long int)i)->id, "@uri");
    i = 0;
    for( ; !(i >= max); i = i + 1)
      if(!((scores + (signed long int)i)->value == ((char *)NULL)))
      {
        j = i + 1;
        for( ; !(j >= max); j = j + 1)
        {
          dval = 0.0;
          if(!((scores + (signed long int)j)->value == ((char *)NULL)))
          {
            signed int return_value_est_url_sameness_1;
            return_value_est_url_sameness_1=est_url_sameness((scores + (signed long int)i)->value, (scores + (signed long int)j)->value);
            switch(return_value_est_url_sameness_1)
            {
              case 1:
              {
                dval = 100.0;
                break;
              }
              case 2:
              {
                dval = 101.0;
                break;
              }
              case 3:
                dval = 102.0;
            }
          }

          if(dval >= limit)
          {
            free((void *)(scores + (signed long int)j)->value);
            (scores + (signed long int)j)->value = (char *)(void *)0;
            pair[(signed long int)0] = (scores + (signed long int)j)->id;
            pair[(signed long int)1] = 0;
            cbmapputcat(shadows, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , (char *)pair, (signed int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2));
          }

        }
      }

    i = 0;
    for( ; !(i >= max); i = i + 1)
      if(!((scores + (signed long int)i)->value == ((char *)NULL)))
      {
        free((void *)(scores + (signed long int)i)->value);
        tmp_post_2 = nnum;
        nnum = nnum + 1;
        scores[(signed long int)tmp_post_2] = scores[(signed long int)i];
      }

    i = max;
    for( ; !(i >= snum); i = i + 1)
    {
      tmp_post_3 = nnum;
      nnum = nnum + 1;
      scores[(signed long int)tmp_post_3] = scores[(signed long int)i];
    }
  }

  else
  {
    max = (signed int)(limit < 0.1 ? (double)snum : (double)num * (2.4 / (limit - 0.05) + 0.8) + (double)8);
    if(!(simurl == 0))
      max = max * (signed int)1.4;

    if(!(snum >= max))
      max = snum;

    void *return_value_malloc_4;
    return_value_malloc_4=malloc((unsigned long int)vnum * sizeof(signed int) /*4ul*/ );
    svec = (signed int *)return_value_malloc_4;
    if(!(svec == ((signed int *)NULL)))
      svec;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc_5;
    return_value_malloc_5=malloc((unsigned long int)vnum * sizeof(signed int) /*4ul*/ );
    tvec = (signed int *)return_value_malloc_5;
    if(!(tvec == ((signed int *)NULL)))
      tvec;

    else
      cbmyfatal("out of memory");
    i = 0;
    for( ; !(i >= max); i = i + 1)
    {
      svmap=est_get_tvmap(db, (scores + (signed long int)i)->id, vnum, tfidf);
      if(!(svmap == ((struct anonymous_5 *)NULL)))
      {
        (scores + (signed long int)i)->value = (char *)svmap;
        if(!(simurl == 0))
        {
          tmp=est_db_get_doc_attr(db, (scores + (signed long int)i)->id, "@uri");
          if(!(tmp == ((char *)NULL)))
          {
            cbmapput(svmap, "", 0, tmp, -1, 1);
            free((void *)tmp);
          }

        }

      }

      else
        (scores + (signed long int)i)->value = (char *)(void *)0;
    }
    i = 0;
    for( ; !(i >= max); i = i + 1)
    {
      svmap = (struct anonymous_5 *)(scores + (signed long int)i)->value;
      if(svmap == ((struct anonymous_5 *)NULL))
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_cbmaprnum_6=cbmaprnum(svmap);
        tmp_if_expr_7 = return_value_cbmaprnum_6 < 1 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_7)
      {
        suri=cbmapget((struct anonymous_5 *)(scores + (signed long int)i)->value, "", -1, (signed int *)(void *)0);
        tmp_post_8 = num;
        num = num - 1;
        if(tmp_post_8 >= 1)
        {
          est_vector_set_seed(svmap, svec, vnum);
          j = i + 1;
          for( ; !(j >= max); j = j + 1)
          {
            tvmap = (struct anonymous_5 *)(scores + (signed long int)j)->value;
            if(tvmap == ((struct anonymous_5 *)NULL))
              tmp_if_expr_10 = (_Bool)1;

            else
            {
              return_value_cbmaprnum_9=cbmaprnum(tvmap);
              tmp_if_expr_10 = return_value_cbmaprnum_9 < 1 ? (_Bool)1 : (_Bool)0;
            }
            if(!tmp_if_expr_10)
            {
              est_vector_set_target(svmap, tvmap, tvec, vnum);
              dval=est_vector_cosine(svec, tvec, vnum);
              if(dval > 0.01 && !(suri == ((const char *)NULL)))
              {
                turi=cbmapget((struct anonymous_5 *)(scores + (signed long int)j)->value, "", -1, (signed int *)(void *)0);
                if(!(turi == ((const char *)NULL)))
                {
                  signed int return_value_est_url_sameness_11;
                  return_value_est_url_sameness_11=est_url_sameness(suri, turi);
                  if(!(return_value_est_url_sameness_11 == 1))
                  {
                    if(return_value_est_url_sameness_11 == 2)
                      goto __CPROVER_DUMP_L45;

                    if(return_value_est_url_sameness_11 == 3)
                      goto __CPROVER_DUMP_L46;

                    return_value_acos_12=acos(dval);
                    return_value_pow_13=pow(dval, 9.9);
                    return_value_cos_14=cos(return_value_acos_12 * (1.0 - return_value_pow_13));
                    dval=pow(return_value_cos_14, 1.07);
                  }

                  else
                  {
                    double return_value_acos_15;
                    return_value_acos_15=acos(dval);
                    double return_value_pow_16;
                    return_value_pow_16=pow(dval, 4.1);
                    double return_value_cos_17;
                    return_value_cos_17=cos(return_value_acos_15 * (1.0 - return_value_pow_16));
                    dval=pow(return_value_cos_17, 1.05);
                    goto __CPROVER_DUMP_L47;

                  __CPROVER_DUMP_L45:
                    ;
                    double return_value_acos_18;
                    return_value_acos_18=acos(dval);
                    double return_value_pow_19;
                    return_value_pow_19=pow(dval, 2.9);
                    double return_value_cos_20;
                    return_value_cos_20=cos(return_value_acos_18 * (1.0 - return_value_pow_19));
                    dval=pow(return_value_cos_20, 1.03);
                    goto __CPROVER_DUMP_L47;

                  __CPROVER_DUMP_L46:
                    ;
                    double return_value_acos_21;
                    return_value_acos_21=acos(dval);
                    double return_value_pow_22;
                    return_value_pow_22=pow(dval, 2.1);
                    double return_value_cos_23;
                    return_value_cos_23=cos(return_value_acos_21 * (1.0 - return_value_pow_22));
                    dval=pow(return_value_cos_23, 1.01);
                  }
                }

              }


            __CPROVER_DUMP_L47:
              ;
              if(dval > limit)
              {
                cbmapclose(tvmap);
                (scores + (signed long int)j)->value = (char *)(void *)0;
                pair[(signed long int)0] = (scores + (signed long int)j)->id;
                pair[(signed long int)1] = (signed int)(dval * 10000.0);
                cbmapputcat(shadows, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , (char *)pair, (signed int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2));
              }

            }

          }
        }

      }

    }
    i = 0;
    for( ; !(i >= max); i = i + 1)
      if(!((scores + (signed long int)i)->value == ((char *)NULL)))
      {
        cbmapclose((struct anonymous_5 *)(scores + (signed long int)i)->value);
        tmp_post_24 = nnum;
        nnum = nnum + 1;
        scores[(signed long int)tmp_post_24] = scores[(signed long int)i];
      }

    i = max;
    for( ; !(i >= snum); i = i + 1)
    {
      tmp_post_25 = nnum;
      nnum = nnum + 1;
      scores[(signed long int)tmp_post_25] = scores[(signed long int)i];
    }
    free((void *)tvec);
    free((void *)svec);
  }
  return nnum;
}

// est_enc_miss
// file estraier.c line 5917
static signed int est_enc_miss(const char *ptr, signed int size, const char *icode, const char *ocode)
{
  void *ic;
  char obuf[32768l];
  char *wp;
  char *rp;
  unsigned long int isiz;
  unsigned long int osiz;
  signed int miss;
  isiz = (unsigned long int)size;
  ic=iconv_open(ocode, icode);
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  if(ic == (void *)-1)
    return 256;

  else
  {
    miss = 0;
    rp = (char *)ptr;
    while(isiz >= 1ul)
    {
      osiz = (unsigned long int)32768;
      wp = obuf;
      unsigned long int return_value_iconv_4;
      return_value_iconv_4=iconv(ic, (char ** restrict )(void *)&rp, &isiz, &wp, &osiz);
      if(return_value_iconv_4 == 18446744073709551615ul)
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        if(*return_value___errno_location_1 == 84)
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value___errno_location_2=__errno_location();
          tmp_if_expr_3 = *return_value___errno_location_2 == 22 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
        {
          rp = rp + 1l;
          isiz = isiz - 1ul;
          miss = miss + 1;
          if(miss >= 256)
            break;

        }

        else
          break;
      }

    }
    signed int return_value_iconv_close_5;
    return_value_iconv_close_5=iconv_close(ic);
    if(return_value_iconv_close_5 == -1)
      return 256;

    else
      return miss;
  }
}

// est_enc_name
// file estraier.c line 3604
const char * est_enc_name(const char *ptr, signed int size, signed int plang)
{
  const char *hypo;
  signed int i;
  signed int lim;
  signed int miss;
  signed int ascii;
  signed int cr;
  unsigned long int return_value_strlen_1;
  if(!(size >= 0))
  {
    return_value_strlen_1=strlen(ptr);
    size = (signed int)return_value_strlen_1;
  }

  if(size >= 32769)
    size = 32768;

  signed int return_value_memcmp_2;
  _Bool tmp_if_expr_4;
  signed int return_value_memcmp_3;
  _Bool tmp_if_expr_5;
  signed int return_value_est_enc_miss_6;
  char *return_value_strchr_7;
  char *return_value_strchr_8;
  signed int return_value_est_enc_miss_9;
  signed int return_value_est_enc_miss_10;
  signed int return_value_est_enc_miss_11;
  signed int return_value_est_enc_miss_12;
  signed int return_value_est_enc_miss_13;
  signed int return_value_est_enc_miss_14;
  if(size >= 2)
  {
    return_value_memcmp_2=memcmp((const void *)ptr, (const void *)"", (unsigned long int)2);
    if(return_value_memcmp_2 == 0)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_memcmp_3=memcmp((const void *)ptr, (const void *)"", (unsigned long int)2);
      tmp_if_expr_4 = !(return_value_memcmp_3 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_4)
      goto __CPROVER_DUMP_L5;

    return "UTF-16";
  }

  else
  {

  __CPROVER_DUMP_L5:
    ;
    ascii = 1;
    cr = 0;
    lim = size - 1;
    i = 0;
    for( ; !(i >= lim); i = i + 2)
    {
      if((signed int)ptr[(signed long int)i] == 0x0)
        return "UTF-16BE";

      if((signed int)ptr[(signed long int)(1 + i)] == 0x0)
        return "UTF-16LE";

      if(!((signed int)ptr[(signed long int)i] >= 0x0))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)ptr[(signed long int)i] == 0x1b ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
        ascii = 0;

      else
        if((signed int)ptr[(signed long int)i] == 0xd)
          cr = 1;

    }
    if(!(ascii == 0))
      return "US-ASCII";

    else
      switch(plang)
      {
        case 0:
        {
          return_value_est_enc_miss_6=est_enc_miss(ptr, size, "UTF-8", "UTF-16BE");
          if(!(return_value_est_enc_miss_6 >= 1))
            return "UTF-8";

          return "ISO-8859-1";
        }
        case 1:
        {
          lim = size - 3;
          i = 0;
          for( ; !(i >= lim); i = i + 1)
            if((signed int)ptr[(signed long int)i] == 0x1b)
            {
              i = i + 1;
              if((signed int)ptr[(signed long int)i] == 40)
              {
                return_value_strchr_7=strchr("BJHI", (signed int)ptr[(signed long int)(i + 1)]);
                if(!(return_value_strchr_7 == ((char *)NULL)))
                  return "ISO-2022-JP";

              }

              if((signed int)ptr[(signed long int)i] == 36)
              {
                return_value_strchr_8=strchr("@B(", (signed int)ptr[(signed long int)(i + 1)]);
                if(!(return_value_strchr_8 == ((char *)NULL)))
                  return "ISO-2022-JP";

              }

            }

          return_value_est_enc_miss_9=est_enc_miss(ptr, size, "UTF-8", "UTF-16BE");
          if(!(return_value_est_enc_miss_9 >= 1))
            return "UTF-8";

          hypo = (const char *)(void *)0;
          if(!(cr == 0))
          {
            miss=est_enc_miss(ptr, size, "Shift_JIS", "EUC-JP");
            if(!(miss >= 1))
              return "Shift_JIS";

            if((double)miss / (double)size <= 0.001 && hypo == ((const char *)NULL))
              hypo = "Shift_JIS";

            miss=est_enc_miss(ptr, size, "EUC-JP", "UTF-16BE");
            if(!(miss >= 1))
              return "EUC-JP";

            if((double)miss / (double)size <= 0.001 && hypo == ((const char *)NULL))
              hypo = "EUC-JP";

          }

          else
          {
            miss=est_enc_miss(ptr, size, "EUC-JP", "UTF-16BE");
            if(!(miss >= 1))
              return "EUC-JP";

            if((double)miss / (double)size <= 0.001 && hypo == ((const char *)NULL))
              hypo = "EUC-JP";

            miss=est_enc_miss(ptr, size, "Shift_JIS", "EUC-JP");
            if(!(miss >= 1))
              return "Shift_JIS";

            if((double)miss / (double)size <= 0.001 && hypo == ((const char *)NULL))
              hypo = "Shift_JIS";

          }
          miss=est_enc_miss(ptr, size, "UTF-8", "UTF-16BE");
          if(!(miss >= 1))
            return "UTF-8";

          if((double)miss / (double)size <= 0.001 && hypo == ((const char *)NULL))
            hypo = "UTF-8";

          miss=est_enc_miss(ptr, size, "CP932", "UTF-16BE");
          if(!(miss >= 1))
            return "CP932";

          if((double)miss / (double)size <= 0.001 && hypo == ((const char *)NULL))
            hypo = "CP932";

          return hypo != ((const char *)NULL) ? hypo : "ISO-8859-1";
        }
        case 2:
        {
          return_value_est_enc_miss_10=est_enc_miss(ptr, size, "UTF-8", "UTF-16BE");
          if(!(return_value_est_enc_miss_10 >= 1))
            return "UTF-8";

          return_value_est_enc_miss_11=est_enc_miss(ptr, size, "EUC-CN", "UTF-16BE");
          if(!(return_value_est_enc_miss_11 >= 1))
            return "EUC-CN";

          return_value_est_enc_miss_12=est_enc_miss(ptr, size, "BIG5", "UTF-16BE");
          if(!(return_value_est_enc_miss_12 >= 1))
            return "BIG5";

          return "ISO-8859-1";
        }
        case 3:
        {
          return_value_est_enc_miss_13=est_enc_miss(ptr, size, "UTF-8", "UTF-16BE");
          if(!(return_value_est_enc_miss_13 >= 1))
            return "UTF-8";

          return_value_est_enc_miss_14=est_enc_miss(ptr, size, "EUC-KR", "UTF-16BE");
          if(!(return_value_est_enc_miss_14 >= 1))
            return "EUC-KR";

          return "ISO-8859-1";
        }
        default:
          return "ISO-8859-1";
      }
  }
}

// est_encode_idx_rec
// file estraier.c line 6912
static void est_encode_idx_rec(struct anonymous_9 *datum, const char *vbuf, signed int vsiz, signed int lid, signed int smode)
{
  const char *rp;
  const char *ep;
  const char *sp;
  char nbuf[32l];
  signed int cid;
  signed int vstep;
  rp = vbuf;
  ep = vbuf + (signed long int)vsiz;
  for( ; !(rp >= ep); lid = cid)
  {
    do
    {
      signed int _EST_i;
      signed int _EST_base;
      cid = 0;
      _EST_base = 1;
      _EST_i = 0;
      for( ; (_Bool)1; _EST_i = _EST_i + 1)
      {
        if((signed int)rp[(signed long int)_EST_i] >= 0)
        {
          cid = cid + (signed int)((signed char *)rp)[(signed long int)_EST_i] * _EST_base;
          break;
        }

        cid = cid + _EST_base * ((signed int)((signed char *)rp)[(signed long int)_EST_i] + 1) * -1;
        _EST_base = _EST_base * 128;
      }
      vstep = _EST_i + 1;
    }
    while((_Bool)0);
    rp = rp + (signed long int)vstep;
    sp = rp;
    if(!(smode == 1048576))
    {
      if(smode == 2097152 || smode == 4194304)
        goto __CPROVER_DUMP_L8;

    }

    else
      goto __CPROVER_DUMP_L9;
    rp = rp + 1l;
    goto __CPROVER_DUMP_L9;

  __CPROVER_DUMP_L8:
    ;
    rp = rp + (signed long int)sizeof(signed int) /*4ul*/ ;

  __CPROVER_DUMP_L9:
    ;
    for( ; !((signed int)*rp == 0x00); rp = rp + (signed long int)2)
      ;
    rp = rp + 1l;
    do
    {
      signed int _EST_num = (cid - lid) - 1;
      struct anonymous_10 EST_d;
      if(_EST_num == 0)
      {
        ((signed char *)nbuf)[(signed long int)0] = (signed char)0;
        vstep = 1;
      }

      else
      {
        vstep = 0;
        for( ; _EST_num >= 1; vstep = vstep + 1)
        {
          EST_d=div(_EST_num, 128);
          _EST_num = EST_d.quot;
          if(_EST_num >= 1)
            ((signed char *)nbuf)[(signed long int)vstep] = (signed char)(-EST_d.rem - 1);

          else
            ((signed char *)nbuf)[(signed long int)vstep] = (signed char)EST_d.rem;
        }
      }
    }
    while((_Bool)0);
    do
    {
      if(datum->dsize + vstep >= datum->asize)
      {
        datum->asize = datum->asize * 2 + vstep + 1;
        void *return_value_realloc_1;
        return_value_realloc_1=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
        datum->dptr = (char *)return_value_realloc_1;
        if(!(datum->dptr == ((char *)NULL)))
          datum->dptr;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)nbuf, (unsigned long int)vstep);
      datum->dsize = datum->dsize + vstep;
      datum->dptr[(signed long int)datum->dsize] = (char)0;
    }
    while((_Bool)0);
    do
    {
      if((rp - sp) + (signed long int)datum->dsize >= (signed long int)datum->asize)
      {
        datum->asize = (signed int)((signed long int)(datum->asize * 2) + (rp - sp) + (signed long int)1);
        void *return_value_realloc_2;
        return_value_realloc_2=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
        datum->dptr = (char *)return_value_realloc_2;
        if(!(datum->dptr == ((char *)NULL)))
          datum->dptr;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)sp, (unsigned long int)(rp - sp));
      datum->dsize = datum->dsize + (signed int)(rp - sp);
      datum->dptr[(signed long int)datum->dsize] = (char)0;
    }
    while((_Bool)0);
  }
}

// est_err_msg
// file estraier.c line 898
const char * est_err_msg(signed int ecode)
{
  switch(ecode)
  {
    case 0:
      return "no error";
    case 1:
      return "invalid argument";
    case 2:
      return "access forbidden";
    case 3:
      return "lock failure";
    case 4:
      return "database problem";
    case 5:
      return "I/O problem";
    case 6:
      return "no such item";
    default:
      return "miscellaneous";
  }
}

// est_expand_keyword_bw
// file estraier.c line 8347
static void est_expand_keyword_bw(struct anonymous_0 *db, const char *word, struct anonymous_6 *list)
{
  const char *kbuf;
  signed int num;
  signed int ksiz;
  num = 0;
  vlcurjump(db->xfmdb, word, -1, 0);
  do
  {
    kbuf=vlcurkeycache(db->xfmdb, &ksiz);
    if(kbuf == ((const char *)NULL))
      break;

    signed int return_value_cbstrfwmatch_1;
    return_value_cbstrfwmatch_1=cbstrfwmatch(kbuf, word);
    if(return_value_cbstrfwmatch_1 == 0)
      break;

    do
    {
      signed int _CB_index = list->start + list->num;
      if(_CB_index >= list->anum)
      {
        list->anum = list->anum * 2;
        void *return_value_realloc_2;
        return_value_realloc_2=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous_28) /*16ul*/ );
        list->array = (struct anonymous_28 *)return_value_realloc_2;
        if(!(list->array == ((struct anonymous_28 *)NULL)))
          list->array;

        else
          cbmyfatal("out of memory");
      }

      void *return_value_malloc_3;
      return_value_malloc_3=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
      (list->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_3;
      if(!((list->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
        (list->array + (signed long int)_CB_index)->dptr;

      else
        cbmyfatal("out of memory");
      memcpy((void *)(list->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
      (list->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
      (list->array + (signed long int)_CB_index)->dsize = ksiz;
      list->num = list->num + 1;
    }
    while((_Bool)0);
    num = num + 1;
    if(num >= db->wildmax)
      break;

    vlcurnext(db->xfmdb);
  }
  while((_Bool)1);
}

// est_expand_keyword_ew
// file estraier.c line 8366
static void est_expand_keyword_ew(struct anonymous_0 *db, const char *word, struct anonymous_6 *list)
{
  const char *kbuf;
  signed int num;
  signed int wsiz;
  signed int ksiz;
  num = 0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(word);
  wsiz = (signed int)return_value_strlen_1;
  vlcurfirst(db->xfmdb);
  signed int return_value_memcmp_4;
  do
  {
    kbuf=vlcurkeycache(db->xfmdb, &ksiz);
    if(kbuf == ((const char *)NULL))
      break;

    if(ksiz >= wsiz)
    {
      return_value_memcmp_4=memcmp((const void *)((kbuf + (signed long int)ksiz) - (signed long int)wsiz), (const void *)word, (unsigned long int)wsiz);
      if(return_value_memcmp_4 == 0)
      {
        do
        {
          signed int _CB_index = list->start + list->num;
          if(_CB_index >= list->anum)
          {
            list->anum = list->anum * 2;
            void *return_value_realloc_2;
            return_value_realloc_2=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous_28) /*16ul*/ );
            list->array = (struct anonymous_28 *)return_value_realloc_2;
            if(!(list->array == ((struct anonymous_28 *)NULL)))
              list->array;

            else
              cbmyfatal("out of memory");
          }

          void *return_value_malloc_3;
          return_value_malloc_3=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
          (list->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_3;
          if(!((list->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
            (list->array + (signed long int)_CB_index)->dptr;

          else
            cbmyfatal("out of memory");
          memcpy((void *)(list->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
          (list->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
          (list->array + (signed long int)_CB_index)->dsize = ksiz;
          list->num = list->num + 1;
        }
        while((_Bool)0);
        num = num + 1;
        if(num >= db->wildmax)
          break;

      }

    }

    vlcurnext(db->xfmdb);
  }
  while((_Bool)1);
}

// est_expand_keyword_rx
// file estraier.c line 8387
static void est_expand_keyword_rx(struct anonymous_0 *db, const char *word, struct anonymous_6 *list)
{
  void *regex;
  const char *kbuf;
  signed int num;
  signed int ksiz;
  regex=est_regex_new(word);
  if(!(regex == NULL))
  {
    num = 0;
    vlcurfirst(db->xfmdb);
    do
    {
      kbuf=vlcurkeycache(db->xfmdb, &ksiz);
      if(kbuf == ((const char *)NULL))
        break;

      signed int return_value_est_regex_match_3;
      return_value_est_regex_match_3=est_regex_match(regex, kbuf);
      if(!(return_value_est_regex_match_3 == 0))
      {
        do
        {
          signed int _CB_index = list->start + list->num;
          if(_CB_index >= list->anum)
          {
            list->anum = list->anum * 2;
            void *return_value_realloc_1;
            return_value_realloc_1=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous_28) /*16ul*/ );
            list->array = (struct anonymous_28 *)return_value_realloc_1;
            if(!(list->array == ((struct anonymous_28 *)NULL)))
              list->array;

            else
              cbmyfatal("out of memory");
          }

          void *return_value_malloc_2;
          return_value_malloc_2=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
          (list->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_2;
          if(!((list->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
            (list->array + (signed long int)_CB_index)->dptr;

          else
            cbmyfatal("out of memory");
          memcpy((void *)(list->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
          (list->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
          (list->array + (signed long int)_CB_index)->dsize = ksiz;
          list->num = list->num + 1;
        }
        while((_Bool)0);
        num = num + 1;
        if(num >= db->wildmax)
          break;

      }

      vlcurnext(db->xfmdb);
    }
    while((_Bool)1);
    est_regex_delete(regex);
  }

}

// est_expand_word_bw
// file estraier.c line 8284
static void est_expand_word_bw(struct anonymous_0 *db, const char *word, struct anonymous_6 *list)
{
  const char *kbuf;
  signed int num;
  signed int ksiz;
  num = 0;
  vlcurjump(db->fwmdb, word, -1, 0);
  do
  {
    kbuf=vlcurkeycache(db->fwmdb, &ksiz);
    if(kbuf == ((const char *)NULL))
      break;

    signed int return_value_cbstrfwmatch_1;
    return_value_cbstrfwmatch_1=cbstrfwmatch(kbuf, word);
    if(return_value_cbstrfwmatch_1 == 0)
      break;

    do
    {
      signed int _CB_index = list->start + list->num;
      if(_CB_index >= list->anum)
      {
        list->anum = list->anum * 2;
        void *return_value_realloc_2;
        return_value_realloc_2=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous_28) /*16ul*/ );
        list->array = (struct anonymous_28 *)return_value_realloc_2;
        if(!(list->array == ((struct anonymous_28 *)NULL)))
          list->array;

        else
          cbmyfatal("out of memory");
      }

      void *return_value_malloc_3;
      return_value_malloc_3=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
      (list->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_3;
      if(!((list->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
        (list->array + (signed long int)_CB_index)->dptr;

      else
        cbmyfatal("out of memory");
      memcpy((void *)(list->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
      (list->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
      (list->array + (signed long int)_CB_index)->dsize = ksiz;
      list->num = list->num + 1;
    }
    while((_Bool)0);
    num = num + 1;
    if(num >= db->wildmax)
      break;

    vlcurnext(db->fwmdb);
  }
  while((_Bool)1);
}

// est_expand_word_ew
// file estraier.c line 8303
static void est_expand_word_ew(struct anonymous_0 *db, const char *word, struct anonymous_6 *list)
{
  const char *kbuf;
  signed int num;
  signed int wsiz;
  signed int ksiz;
  num = 0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(word);
  wsiz = (signed int)return_value_strlen_1;
  vlcurfirst(db->fwmdb);
  signed int return_value_memcmp_4;
  do
  {
    kbuf=vlcurkeycache(db->fwmdb, &ksiz);
    if(kbuf == ((const char *)NULL))
      break;

    if(ksiz >= wsiz)
    {
      return_value_memcmp_4=memcmp((const void *)((kbuf + (signed long int)ksiz) - (signed long int)wsiz), (const void *)word, (unsigned long int)wsiz);
      if(return_value_memcmp_4 == 0)
      {
        do
        {
          signed int _CB_index = list->start + list->num;
          if(_CB_index >= list->anum)
          {
            list->anum = list->anum * 2;
            void *return_value_realloc_2;
            return_value_realloc_2=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous_28) /*16ul*/ );
            list->array = (struct anonymous_28 *)return_value_realloc_2;
            if(!(list->array == ((struct anonymous_28 *)NULL)))
              list->array;

            else
              cbmyfatal("out of memory");
          }

          void *return_value_malloc_3;
          return_value_malloc_3=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
          (list->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_3;
          if(!((list->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
            (list->array + (signed long int)_CB_index)->dptr;

          else
            cbmyfatal("out of memory");
          memcpy((void *)(list->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
          (list->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
          (list->array + (signed long int)_CB_index)->dsize = ksiz;
          list->num = list->num + 1;
        }
        while((_Bool)0);
        num = num + 1;
        if(num >= db->wildmax)
          break;

      }

    }

    vlcurnext(db->fwmdb);
  }
  while((_Bool)1);
}

// est_expand_word_rx
// file estraier.c line 8324
static void est_expand_word_rx(struct anonymous_0 *db, const char *word, struct anonymous_6 *list)
{
  void *regex;
  const char *kbuf;
  signed int num;
  signed int ksiz;
  regex=est_regex_new(word);
  if(!(regex == NULL))
  {
    num = 0;
    vlcurfirst(db->fwmdb);
    do
    {
      kbuf=vlcurkeycache(db->fwmdb, &ksiz);
      if(kbuf == ((const char *)NULL))
        break;

      signed int return_value_est_regex_match_3;
      return_value_est_regex_match_3=est_regex_match(regex, kbuf);
      if(!(return_value_est_regex_match_3 == 0))
      {
        do
        {
          signed int _CB_index = list->start + list->num;
          if(_CB_index >= list->anum)
          {
            list->anum = list->anum * 2;
            void *return_value_realloc_1;
            return_value_realloc_1=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous_28) /*16ul*/ );
            list->array = (struct anonymous_28 *)return_value_realloc_1;
            if(!(list->array == ((struct anonymous_28 *)NULL)))
              list->array;

            else
              cbmyfatal("out of memory");
          }

          void *return_value_malloc_2;
          return_value_malloc_2=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
          (list->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_2;
          if(!((list->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
            (list->array + (signed long int)_CB_index)->dptr;

          else
            cbmyfatal("out of memory");
          memcpy((void *)(list->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
          (list->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
          (list->array + (signed long int)_CB_index)->dsize = ksiz;
          list->num = list->num + 1;
        }
        while((_Bool)0);
        num = num + 1;
        if(num >= db->wildmax)
          break;

      }

      vlcurnext(db->fwmdb);
    }
    while((_Bool)1);
    est_regex_delete(regex);
  }

}

// est_ext_type
// file estraier.c line 5738
const char * est_ext_type(const char *ext)
{
  signed int i = 0;
  static const char *list[169l] = { ".txt", "text/plain", ".txt.en", "text/plain", ".txt.ja", "text/plain", ".asc", "text/plain", ".in", "text/plain", ".c", "text/plain", ".h", "text/plain", ".cc", "text/plain", ".java", "text/plain", ".sh", "text/plain", ".pl", "text/plain", ".py", "text/plain", ".rb", "text/plain", ".idl", "text/plain", ".csv", "text/plain", ".log", "text/plain", ".conf", "text/plain", ".rc", "text/plain", ".ini", "text/plain", ".html", "text/html", ".htm", "text/html", ".xhtml", "text/html", ".xht", "text/html", ".css", "text/css", ".js", "text/javascript", ".tsv", "text/tab-separated-values", ".eml", "message/rfc822", ".mime", "message/rfc822", ".mht", "message/rfc822", ".mhtml", "message/rfc822", ".sgml", "application/sgml", ".sgm", "application/sgml", ".xml", "application/xml", ".xsl", "application/xml", ".xslt", "application/xslt+xml", ".xhtml", "application/xhtml+xml", ".xht", "application/xhtml+xml", ".rdf", "application/rdf+xml", ".rss", "application/rss+xml", ".dtd", "application/xml-dtd", ".rtf", "application/rtf", ".pdf", "application/pdf", ".ps", "application/postscript", ".eps", "application/postscript", ".doc", "application/msword", ".xls", "application/vnd.ms-excel", ".ppt", "application/vnd.ms-powerpoint", ".xdw", "application/vnd.fujixerox.docuworks", ".swf", "application/x-shockwave-flash", ".zip", "application/zip", ".tar", "application/x-tar", ".gz", "application/x-gzip", ".bz2", "application/octet-stream", ".z", "application/octet-stream", ".lha", "application/octet-stream", ".lzh", "application/octet-stream", ".cab", "application/octet-stream", ".rar", "application/octet-stream", ".sit", "application/octet-stream", ".bin", "application/octet-stream", ".o", "application/octet-stream", ".so", "application/octet-stream", ".exe", "application/octet-stream", ".dll", "application/octet-stream", ".class", "application/octet-stream", ".png", "image/png", ".gif", "image/gif", ".jpg", "image/jpeg", ".jpeg", "image/jpeg", ".tif", "image/tiff", ".tiff", "image/tiff", ".bmp", "image/bmp", ".au", "audio/basic", ".snd", "audio/basic", ".mid", "audio/midi", ".midi", "audio/midi", ".mp2", "audio/mpeg", ".mp3", "audio/mpeg", ".wav", "audio/x-wav", ".mpg", "video/mpeg", ".mpeg", "video/mpeg", ".qt", "video/quicktime", ".mov", "video/quicktime", ".avi", "video/x-msvideo", (const char *)(void *)0 };
  for( ; !(list[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    signed int return_value_cbstricmp_1;
    return_value_cbstricmp_1=cbstricmp(ext, list[(signed long int)i]);
    if(return_value_cbstricmp_1 == 0)
      return list[(signed long int)(i + 1)];

  }
  return "application/octet-stream";
}

// est_free_cattr_list
// file estraier.c line 9831
static void est_free_cattr_list(struct anonymous_16 *list, signed int anum)
{
  signed int i = 0;
  for( ; !(i >= anum); i = i + 1)
  {
    if(!((list + (signed long int)i)->regex == NULL))
      est_regex_delete((list + (signed long int)i)->regex);

    free((void *)(list + (signed long int)i)->sval);
    free((void *)(list + (signed long int)i)->val);
    free((void *)(list + (signed long int)i)->oper);
    if(!((list + (signed long int)i)->nlist == ((struct anonymous_6 *)NULL)))
      do
      {
        signed int _CB_i;
        signed int _CB_end = (list + (signed long int)i)->nlist->start + (list + (signed long int)i)->nlist->num;
        _CB_i = (list + (signed long int)i)->nlist->start;
        for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
          free((void *)((list + (signed long int)i)->nlist->array + (signed long int)_CB_i)->dptr);
        free((void *)(list + (signed long int)i)->nlist->array);
        free((void *)(list + (signed long int)i)->nlist);
      }
      while((_Bool)0);

    free((void *)(list + (signed long int)i)->name);
  }
  free((void *)list);
}

// est_free_net_env
// file estnode.h line 46
void est_free_net_env(void)
{
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&est_host_addrs_mutex);
  if(return_value_pthread_mutex_lock_1 == 0)
  {
    if(!(est_host_attrs_cnt >= 1))
      pthread_mutex_unlock(&est_host_addrs_mutex);

    else
    {
      est_host_attrs_cnt = est_host_attrs_cnt - 1;
      if(!(est_host_attrs_cnt >= 1))
      {
        cbmapclose(est_host_addrs);
        est_host_addrs = (struct anonymous_5 *)(void *)0;
      }

      pthread_mutex_unlock(&est_host_addrs_mutex);
    }
  }

}

// est_get_client_sock
// file estnode.h line 491
signed int est_get_client_sock(const char *addr, signed int port)
{
  struct sockaddr_in address;
  struct linger li;
  signed int ost;
  signed int sock;
  signed int return_value_pthread_setcancelstate_1;
  return_value_pthread_setcancelstate_1=pthread_setcancelstate(1, &ost);
  if(!(return_value_pthread_setcancelstate_1 == 0))
    return -1;

  else
  {
    memset((void *)&address, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    address.sin_family = (unsigned short int)2;
    signed int return_value_est_inet_aton_2;
    return_value_est_inet_aton_2=est_inet_aton(addr, &address.sin_addr);
    if(return_value_est_inet_aton_2 == 0)
    {
      pthread_setcancelstate(ost, (signed int *)(void *)0);
      return -1;
    }

    else
    {
      address.sin_port=htons((unsigned short int)port);
      sock=socket(2, 1, 6);
      if(sock == -1)
      {
        pthread_setcancelstate(ost, (signed int *)(void *)0);
        return -1;
      }

      else
      {
        li.l_onoff = 1;
        li.l_linger = 100;
        signed int return_value_setsockopt_3;
        return_value_setsockopt_3=setsockopt(sock, 1, 13, (const void *)(char *)&li, (unsigned int)sizeof(struct linger) /*8ul*/ );
        if(return_value_setsockopt_3 == -1)
        {
          est_sock_close(sock);
          pthread_setcancelstate(ost, (signed int *)(void *)0);
          return -1;
        }

        else
        {
          signed int return_value_connect_4;
          return_value_connect_4=connect(sock, (struct sockaddr *)&address, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
          if(return_value_connect_4 == -1)
          {
            est_sock_close(sock);
            pthread_setcancelstate(ost, (signed int *)(void *)0);
            return -1;
          }

          else
          {
            pthread_setcancelstate(ost, (signed int *)(void *)0);
            return sock;
          }
        }
      }
    }
  }
}

// est_get_host_addr
// file estnode.h line 466
char * est_get_host_addr(const char *name)
{
  const char *addr;
  char *buf;
  char *pv;
  char vbuf[64l];
  signed int i;
  signed int ost;
  signed int nsiz;
  signed int asiz;
  signed int vsiz;
  signed int return_value_pthread_setcancelstate_1;
  return_value_pthread_setcancelstate_1=pthread_setcancelstate(1, &ost);
  _Bool tmp_if_expr_7;
  if(!(return_value_pthread_setcancelstate_1 == 0))
    return (char *)(void *)0;

  else
  {
    signed int return_value_pthread_mutex_lock_2;
    return_value_pthread_mutex_lock_2=pthread_mutex_lock(&est_host_addrs_mutex);
    if(!(return_value_pthread_mutex_lock_2 == 0))
    {
      pthread_setcancelstate(ost, (signed int *)(void *)0);
      return (char *)(void *)0;
    }

    else
      if(est_host_addrs == ((struct anonymous_5 *)NULL))
      {
        pthread_mutex_unlock(&est_host_addrs_mutex);
        pthread_setcancelstate(ost, (signed int *)(void *)0);
        return (char *)(void *)0;
      }

      else
      {
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(name);
        nsiz = (signed int)return_value_strlen_3;
        buf = (char *)(void *)0;
        addr=cbmapget(est_host_addrs, name, nsiz, &asiz);
        if(!(addr == ((const char *)NULL)))
        {
          buf=cbmemdup(addr, asiz);
          pv=strchr(buf, 9);
          if(!(pv == ((char *)NULL)))
          {
            *pv = (char)0;
            signed long int return_value_time_4;
            return_value_time_4=time((signed long int *)(void *)0);
            signed int return_value_atoi_5;
            return_value_atoi_5=atoi(pv + (signed long int)1);
            if((signed int)return_value_time_4 + -return_value_atoi_5 >= 301)
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          }

          cbmapmove(est_host_addrs, name, nsiz, 0);
        }

        pthread_mutex_unlock(&est_host_addrs_mutex);
        pthread_setcancelstate(ost, (signed int *)(void *)0);
        if(!(buf == ((char *)NULL)))
        {
          if(!((signed int)*buf == 0))
            return buf;

          free((void *)buf);
          return (char *)(void *)0;
        }

        else
        {
          buf=est_gethostaddrbyname(name);
          signed int return_value_pthread_setcancelstate_10;
          return_value_pthread_setcancelstate_10=pthread_setcancelstate(1, &ost);
          if(return_value_pthread_setcancelstate_10 == 0)
          {
            signed int return_value_pthread_mutex_lock_9;
            return_value_pthread_mutex_lock_9=pthread_mutex_lock(&est_host_addrs_mutex);
            if(return_value_pthread_mutex_lock_9 == 0)
            {
              signed long int return_value_time_6;
              return_value_time_6=time((signed long int *)(void *)0);
              vsiz=sprintf(vbuf, "%s\t%d", buf != ((char *)NULL) ? buf : "", (signed int)return_value_time_6);
              cbmapput(est_host_addrs, name, nsiz, vbuf, vsiz, 1);
              signed int return_value_cbmaprnum_8;
              return_value_cbmaprnum_8=cbmaprnum(est_host_addrs);
              if(return_value_cbmaprnum_8 >= 4097)
              {
                cbmapiterinit(est_host_addrs);
                i = 0;
                do
                {
                  if(!(i >= 1024))
                  {
                    addr=cbmapiternext(est_host_addrs, &asiz);
                    tmp_if_expr_7 = addr != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr_7 = (_Bool)0;
                  if(!tmp_if_expr_7)
                    break;

                  cbmapout(est_host_addrs, addr, asiz);
                  i = i + 1;
                }
                while((_Bool)1);
              }

              pthread_mutex_unlock(&est_host_addrs_mutex);
            }

            pthread_setcancelstate(ost, (signed int *)(void *)0);
          }

          return buf;
        }
      }
  }
}

// est_get_host_name
// file estnode.c line 1298
const char * est_get_host_name(void)
{
  if(est_host_addrs == ((struct anonymous_5 *)NULL))
    return "127.0.0.1";

  else
  {
    static char host[4096l];
    static signed int first = 1;
    if(!(first == 0))
    {
      first = 0;
      signed int return_value_gethostname_1;
      return_value_gethostname_1=gethostname(host, (unsigned long int)(4096 - 1));
      if(return_value_gethostname_1 == -1)
        return "127.0.0.1";

      return host;
    }

    return host;
  }
}

// est_get_server_sock
// file estnode.c line 1368
signed int est_get_server_sock(const char *addr, signed int port)
{
  struct sockaddr_in address;
  struct linger li;
  signed int ost;
  signed int sock;
  signed int optone;
  signed int return_value_pthread_setcancelstate_1;
  return_value_pthread_setcancelstate_1=pthread_setcancelstate(1, &ost);
  _Bool tmp_if_expr_5;
  signed int return_value_setsockopt_4;
  _Bool tmp_if_expr_8;
  signed int return_value_listen_7;
  if(!(return_value_pthread_setcancelstate_1 == 0))
    return -1;

  else
  {
    memset((void *)&address, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    address.sin_family = (unsigned short int)2;
    signed int return_value_est_inet_aton_2;
    return_value_est_inet_aton_2=est_inet_aton(addr != ((const char *)NULL) ? addr : "0.0.0.0", &address.sin_addr);
    if(return_value_est_inet_aton_2 == 0)
    {
      pthread_setcancelstate(ost, (signed int *)(void *)0);
      return -1;
    }

    else
    {
      address.sin_port=htons((unsigned short int)port);
      sock=socket(2, 1, 6);
      if(sock == -1)
      {
        pthread_setcancelstate(ost, (signed int *)(void *)0);
        return -1;
      }

      else
      {
        li.l_onoff = 1;
        li.l_linger = 100;
        optone = 1;
        signed int return_value_setsockopt_3;
        return_value_setsockopt_3=setsockopt(sock, 1, 13, (const void *)(char *)&li, (unsigned int)sizeof(struct linger) /*8ul*/ );
        if(return_value_setsockopt_3 == -1)
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          return_value_setsockopt_4=setsockopt(sock, 1, 2, (const void *)(char *)&optone, (unsigned int)sizeof(signed int) /*4ul*/ );
          tmp_if_expr_5 = return_value_setsockopt_4 == -1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
        {
          est_sock_close(sock);
          pthread_setcancelstate(ost, (signed int *)(void *)0);
          return -1;
        }

        else
        {
          signed int return_value_bind_6;
          return_value_bind_6=bind(sock, (struct sockaddr *)&address, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
          if(return_value_bind_6 == -1)
            tmp_if_expr_8 = (_Bool)1;

          else
          {
            return_value_listen_7=listen(sock, 128);
            tmp_if_expr_8 = return_value_listen_7 == -1 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_8)
          {
            est_sock_close(sock);
            pthread_setcancelstate(ost, (signed int *)(void *)0);
            return -1;
          }

          else
          {
            pthread_setcancelstate(ost, (signed int *)(void *)0);
            return sock;
          }
        }
      }
    }
  }
}

// est_get_tvmap
// file estraier.c line 10366
static struct anonymous_5 * est_get_tvmap(struct anonymous_0 *db, signed int id, signed int vnum, signed int tfidf)
{
  struct anonymous_14 *doc;
  struct anonymous_5 *tvmap;
  tvmap=est_db_get_keywords(db, id);
  if(!(tvmap == ((struct anonymous_5 *)NULL)))
    return tvmap;

  else
  {
    doc=est_db_get_doc(db, id, 0);
    if(doc == ((struct anonymous_14 *)NULL))
      return (struct anonymous_5 *)(void *)0;

    else
    {
      tvmap=est_db_etch_doc(tfidf != 0 ? db : (struct anonymous_0 *)(void *)0, doc, vnum);
      est_doc_delete(doc);
      signed int return_value_dpwritable_1;
      return_value_dpwritable_1=dpwritable(db->metadb);
      if(!(return_value_dpwritable_1 == 0))
        est_db_put_keywords(db, id, tvmap, 1.0);

      return tvmap;
    }
  }
}

// est_gethostaddrbyname
// file estnode.c line 1730
static char * est_gethostaddrbyname(const char *name)
{
  struct hostent infobuf;
  struct hostent *info;
  char buf[8192l];
  char *addr;
  signed int ecode;
  signed int return_value_gethostbyname_r_2;
  return_value_gethostbyname_r_2=gethostbyname_r(name, &infobuf, buf, (unsigned long int)8192, &info, &ecode);
  if(return_value_gethostbyname_r_2 == 0 && !(info == ((struct hostent *)NULL)))
  {
    char *return_value_inet_ntoa_1;
    return_value_inet_ntoa_1=inet_ntoa(*((struct in_addr *)info->h_addr_list[(signed long int)0]));
    addr=cbmemdup(return_value_inet_ntoa_1, -1);
  }

  else
    addr = (char *)(void *)0;
  return addr;
}

// est_gettimeofday
// file estraier.h line 1523
double est_gettimeofday(void)
{
  struct timeval tv;
  struct timezone tz;
  signed int return_value_gettimeofday_1;
  return_value_gettimeofday_1=gettimeofday(&tv, &tz);
  if(return_value_gettimeofday_1 == -1)
    return 0.0;

  else
    return (double)tv.tv_sec * (double)1000 + (double)tv.tv_usec / (double)1000;
}

// est_global_lock
// file estmtdb.c line 782
static signed int est_global_lock(void)
{
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&est_global_mutex);
  return (signed int)(return_value_pthread_mutex_lock_1 == 0);
}

// est_global_unlock
// file estmtdb.c line 788
static void est_global_unlock(void)
{
  pthread_mutex_unlock(&est_global_mutex);
}

// est_hex_decode
// file estraier.c line 5895
static char * est_hex_decode(const char *str)
{
  char *res;
  char *wp;
  signed int i;
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  len = (signed int)return_value_strlen_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(len + 1));
  res = (char *)return_value_malloc_2;
  if(!(res == ((char *)NULL)))
    res;

  else
    cbmyfatal("out of memory");
  wp = res;
  i = 0;
  char *tmp_post_3;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_5;
  for( ; !(i >= len); i = i + 2)
  {
    tmp_post_3 = wp;
    wp = wp + 1l;
    if((signed int)str[(signed long int)i] >= 65)
      tmp_if_expr_4 = ((signed int)str[(signed long int)i] - 65) + 10;

    else
      tmp_if_expr_4 = (signed int)str[(signed long int)i] - 48;
    if((signed int)str[(signed long int)(1 + i)] >= 65)
      tmp_if_expr_5 = ((signed int)str[(signed long int)(i + 1)] - 65) + 10;

    else
      tmp_if_expr_5 = (signed int)str[(signed long int)(i + 1)] - 48;
    *tmp_post_3 = (char)(tmp_if_expr_4 * 16 + tmp_if_expr_5);
  }
  *wp = (char)0;
  return res;
}

// est_hex_encode
// file estraier.c line 5878
static char * est_hex_encode(const char *str)
{
  char *res;
  char *wp;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(return_value_strlen_1 * (unsigned long int)2 + (unsigned long int)1);
  res = (char *)return_value_malloc_2;
  if(!(res == ((char *)NULL)))
    res;

  else
    cbmyfatal("out of memory");
  wp = res;
  while(!((signed int)*str == 0))
  {
    signed int return_value_sprintf_3;
    return_value_sprintf_3=sprintf(wp, "%02X", *((unsigned char *)str));
    wp = wp + (signed long int)return_value_sprintf_3;
    str = str + 1l;
  }
  *wp = (char)0;
  return res;
}

// est_hints_to_words
// file estraier.c line 5426
struct anonymous_6 * est_hints_to_words(struct anonymous_5 *hints)
{
  struct anonymous_6 *words;
  const char *kbuf;
  signed int ksiz;
  do
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_6) /*24ul*/ );
    words = (struct anonymous_6 *)return_value_malloc_1;
    if(!(words == ((struct anonymous_6 *)NULL)))
      words;

    else
      cbmyfatal("out of memory");
    words->anum = 64;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)words->anum);
    words->array = (struct anonymous_28 *)return_value_malloc_2;
    if(!(words->array == ((struct anonymous_28 *)NULL)))
      words->array;

    else
      cbmyfatal("out of memory");
    words->start = 0;
    words->num = 0;
  }
  while((_Bool)0);
  cbmapiterinit(hints);
  _Bool tmp_if_expr_5;
  const char *return_value_cbmapget_3;
  signed int return_value_atoi_4;
  do
  {
    kbuf=cbmapiternext(hints, &ksiz);
    if(kbuf == ((const char *)NULL))
      break;

    if(!(ksiz >= 1))
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_cbmapget_3=cbmapget(hints, kbuf, ksiz, (signed int *)(void *)0);
      return_value_atoi_4=atoi(return_value_cbmapget_3);
      tmp_if_expr_5 = return_value_atoi_4 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_5)
      do
      {
        signed int _CB_index = words->start + words->num;
        if(_CB_index >= words->anum)
        {
          words->anum = words->anum * 2;
          void *return_value_realloc_6;
          return_value_realloc_6=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous_28) /*16ul*/ );
          words->array = (struct anonymous_28 *)return_value_realloc_6;
          if(!(words->array == ((struct anonymous_28 *)NULL)))
            words->array;

          else
            cbmyfatal("out of memory");
        }

        void *return_value_malloc_7;
        return_value_malloc_7=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
        (words->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_7;
        if(!((words->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
          (words->array + (signed long int)_CB_index)->dptr;

        else
          cbmyfatal("out of memory");
        memcpy((void *)(words->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
        (words->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
        (words->array + (signed long int)_CB_index)->dsize = ksiz;
        words->num = words->num + 1;
      }
      while((_Bool)0);

  }
  while((_Bool)1);
  return words;
}

// est_iconv
// file estraier.c line 3535
char * est_iconv(const char *ptr, signed int size, const char *icode, const char *ocode, signed int *sp, signed int *mp)
{
  void *ic;
  char *obuf;
  char *wp;
  char *rp;
  unsigned long int isiz;
  unsigned long int osiz;
  signed int miss;
  unsigned long int return_value_strlen_1;
  if(!(size >= 0))
  {
    return_value_strlen_1=strlen(ptr);
    size = (signed int)return_value_strlen_1;
  }

  _Bool tmp_if_expr_7;
  if((signed int)*icode == 120)
    tmp_if_expr_7 = (signed int)icode[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_7 = (_Bool)0;
  signed int return_value_cbstricmp_3;
  signed int return_value_cbstricmp_2;
  _Bool tmp_if_expr_6;
  if(tmp_if_expr_7)
  {
    signed int return_value_cbstricmp_4;
    return_value_cbstricmp_4=cbstricmp(icode, "x-sjis");
    if(return_value_cbstricmp_4 == 0)
      icode = "Shift_JIS";

    else
    {
      return_value_cbstricmp_3=cbstricmp(icode, "x-ujis");
      if(return_value_cbstricmp_3 == 0)
        icode = "EUC-JP";

      else
      {
        return_value_cbstricmp_2=cbstricmp(icode, "x-euc-jp");
        if(return_value_cbstricmp_2 == 0)
          icode = "EUC-JP";

      }
    }
  }

  else
  {
    if((signed int)*icode == 119)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = (signed int)icode[(signed long int)0] == 87 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      signed int return_value_cbstricmp_5;
      return_value_cbstricmp_5=cbstricmp(icode, "windows-31j");
      if(return_value_cbstricmp_5 == 0)
        icode = "CP932";

    }

  }
  _Bool tmp_if_expr_13;
  if((signed int)*ocode == 120)
    tmp_if_expr_13 = (signed int)ocode[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_13 = (_Bool)0;
  signed int return_value_cbstricmp_9;
  signed int return_value_cbstricmp_8;
  _Bool tmp_if_expr_12;
  if(tmp_if_expr_13)
  {
    signed int return_value_cbstricmp_10;
    return_value_cbstricmp_10=cbstricmp(ocode, "x-sjis");
    if(return_value_cbstricmp_10 == 0)
      ocode = "Shift_JIS";

    else
    {
      return_value_cbstricmp_9=cbstricmp(ocode, "x-ujis");
      if(return_value_cbstricmp_9 == 0)
        ocode = "EUC-JP";

      else
      {
        return_value_cbstricmp_8=cbstricmp(ocode, "x-euc-jp");
        if(return_value_cbstricmp_8 == 0)
          ocode = "EUC-JP";

      }
    }
  }

  else
  {
    if((signed int)*ocode == 119)
      tmp_if_expr_12 = (_Bool)1;

    else
      tmp_if_expr_12 = (signed int)ocode[(signed long int)0] == 87 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_12)
    {
      signed int return_value_cbstricmp_11;
      return_value_cbstricmp_11=cbstricmp(ocode, "windows-31j");
      if(return_value_cbstricmp_11 == 0)
        ocode = "CP932";

    }

  }
  ic=iconv_open(ocode, icode);
  _Bool tmp_if_expr_20;
  _Bool tmp_if_expr_19;
  signed int *return_value___errno_location_15;
  _Bool tmp_if_expr_17;
  signed int *return_value___errno_location_16;
  if(ic == (void *)-1)
    return (char *)(void *)0;

  else
  {
    isiz = (unsigned long int)size;
    osiz = isiz * (unsigned long int)5;
    void *return_value_malloc_14;
    return_value_malloc_14=malloc(osiz + (unsigned long int)1);
    obuf = (char *)return_value_malloc_14;
    if(!(obuf == ((char *)NULL)))
      obuf;

    else
      cbmyfatal("out of memory");
    wp = obuf;
    rp = (char *)ptr;
    miss = 0;
    while(isiz >= 1ul)
    {
      unsigned long int return_value_iconv_21;
      return_value_iconv_21=iconv(ic, (char ** restrict )(void *)&rp, &isiz, &wp, &osiz);
      if(return_value_iconv_21 == 18446744073709551615ul)
      {
        signed int *return_value___errno_location_18;
        return_value___errno_location_18=__errno_location();
        if(*return_value___errno_location_18 == 84)
        {
          if((signed int)*rp == 0x5c)
            tmp_if_expr_19 = (_Bool)1;

          else
            tmp_if_expr_19 = (signed int)*rp == 0x7e ? (_Bool)1 : (_Bool)0;
          tmp_if_expr_20 = tmp_if_expr_19 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_20 = (_Bool)0;
        if(tmp_if_expr_20)
        {
          *wp = *rp;
          wp = wp + 1l;
          rp = rp + 1l;
          isiz = isiz - 1ul;
        }

        else
        {
          return_value___errno_location_15=__errno_location();
          if(*return_value___errno_location_15 == 84)
            tmp_if_expr_17 = (_Bool)1;

          else
          {
            return_value___errno_location_16=__errno_location();
            tmp_if_expr_17 = *return_value___errno_location_16 == 22 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_17)
          {
            rp = rp + 1l;
            isiz = isiz - 1ul;
            miss = miss + 1;
          }

          else
            break;
        }
      }

    }
    *wp = (char)0;
    if(!(sp == ((signed int *)NULL)))
      *sp = (signed int)(wp - obuf);

    if(!(mp == ((signed int *)NULL)))
      *mp = miss;

    signed int return_value_iconv_close_22;
    return_value_iconv_close_22=iconv_close(ic);
    if(return_value_iconv_close_22 == -1)
    {
      free((void *)obuf);
      return (char *)(void *)0;
    }

    else
      return obuf;
  }
}

// est_idx_add
// file estraier.c line 7107
static signed int est_idx_add(struct anonymous_2 *idx, const char *word, signed int wsiz, const char *vbuf, signed int vsiz, signed int smode)
{
  struct anonymous_9 *datum;
  const char *obuf;
  signed int rv;
  signed int lid;
  signed int osiz;
  do
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_9) /*16ul*/ );
    datum = (struct anonymous_9 *)return_value_malloc_1;
    if(!(datum == ((struct anonymous_9 *)NULL)))
      datum;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)12);
    datum->dptr = (char *)return_value_malloc_2;
    if(!(datum->dptr == ((char *)NULL)))
      datum->dptr;

    else
      cbmyfatal("out of memory");
    datum->dptr[(signed long int)0] = (char)0;
    datum->dsize = 0;
    datum->asize = 12;
  }
  while((_Bool)0);
  lid = 0;
  obuf=vlgetcache(idx->cdb, word, wsiz, &osiz);
  if(!(obuf == ((const char *)NULL)))
    lid=est_idx_rec_last_id(obuf, osiz, smode);

  est_encode_idx_rec(datum, vbuf, vsiz, lid, smode);
  rv=vlput(idx->cdb, word, wsiz, (const char *)datum->dptr, (signed int)datum->dsize, 2);
  do
  {
    free((void *)datum->dptr);
    free((void *)datum);
  }
  while((_Bool)0);
  return rv;
}

// est_idx_close
// file estraier.c line 7034
static signed int est_idx_close(struct anonymous_2 *idx)
{
  signed int i;
  signed int err = 0;
  i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    signed int return_value_vlclose_1;
    return_value_vlclose_1=vlclose(idx->dbs[(signed long int)i]);
    if(return_value_vlclose_1 == 0)
      err = 1;

  }
  free((void *)idx->name);
  free((void *)idx);
  return err != 0 ? 0 : 1;
}

// est_idx_dnum
// file estraier.c line 7094
static signed int est_idx_dnum(struct anonymous_2 *idx)
{
  return idx->dnum;
}

// est_idx_get_one
// file estraier.c line 7189
static const char * est_idx_get_one(struct anonymous_2 *idx, signed int inum, const char *word, signed int wsiz, signed int *sp)
{
  const char *return_value_vlgetcache_1;
  return_value_vlgetcache_1=vlgetcache(idx->dbs[(signed long int)inum], word, wsiz, sp);
  return return_value_vlgetcache_1;
}

// est_idx_increment
// file estraier.c line 7068
static void est_idx_increment(struct anonymous_2 *idx)
{
  char path[4096l];
  signed int i;
  signed int min;
  signed int size;
  signed int crdnum;
  min = 0x7fffffff;
  i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    size=vlfsiz(idx->cdb);
    if(!(size >= min))
      min = size;

  }
  _Bool tmp_if_expr_1;
  if(idx->dnum >= 256)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (idx->dnum >= 16 ? (min < 1048576 * 1536 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    est_idx_set_current(idx);

  else
  {
    sprintf(path, "%s%c%04d", idx->name, 47, idx->dnum + 1);
    signed int *return_value_vlcrdnumptr_2;
    return_value_vlcrdnumptr_2=vlcrdnumptr();
    crdnum = *return_value_vlcrdnumptr_2;
    signed int *return_value_vlcrdnumptr_3;
    return_value_vlcrdnumptr_3=vlcrdnumptr();
    *return_value_vlcrdnumptr_3 = 2;
    idx->dbs[(signed long int)idx->dnum]=vlopen(path, idx->omode | 4 | 8, VL_CMPLEX);
    if(!(idx->dbs[(signed long int)idx->dnum] == ((struct anonymous_4 *)NULL)))
    {
      idx->cdb = idx->dbs[(signed long int)idx->dnum];
      idx->dnum = idx->dnum + 1;
    }

    signed int *return_value_vlcrdnumptr_4;
    return_value_vlcrdnumptr_4=vlcrdnumptr();
    *return_value_vlcrdnumptr_4 = crdnum;
  }
}

// est_idx_memflush
// file estraier.c line 7249
static signed int est_idx_memflush(struct anonymous_2 *idx)
{
  signed int i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    signed int return_value_vlmemflush_1;
    return_value_vlmemflush_1=vlmemflush(idx->dbs[(signed long int)i]);
    if(return_value_vlmemflush_1 == 0)
      return 0;

  }
  return 1;
}

// est_idx_num
// file estraier.c line 7216
static signed int est_idx_num(struct anonymous_2 *idx)
{
  return idx->dnum;
}

// est_idx_open
// file estraier.c line 6991
static struct anonymous_2 * est_idx_open(const char *name, signed int omode, signed int dnum)
{
  struct anonymous_2 *idx;
  struct anonymous_6 *files;
  const char *file;
  char path[4096l];
  signed int i;
  signed int crdnum;
  if(dnum >= 257)
    dnum = 256;

  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_2) /*2080ul*/ );
  idx = (struct anonymous_2 *)return_value_malloc_1;
  if(!(idx == ((struct anonymous_2 *)NULL)))
    idx;

  else
    cbmyfatal("out of memory");
  signed int return_value_est_mkdir_3;
  signed int *return_value___errno_location_2;
  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_5;
  if(!((4 & omode) == 0))
  {
    return_value_est_mkdir_3=est_mkdir(name);
    if(!(return_value_est_mkdir_3 == 0))
      goto __CPROVER_DUMP_L4;

    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 17)
      goto __CPROVER_DUMP_L4;

    return (struct anonymous_2 *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    if(!((8 & omode) == 0))
    {
      files=cbdirlist(name);
      if(!(files == ((struct anonymous_6 *)NULL)))
      {
        i = 0;
        for( ; !(i >= files->num); i = i + 1)
        {
          file = (const char *)(files->array + (signed long int)(files->start + i))->dptr;
          signed int return_value_strcmp_4;
          return_value_strcmp_4=strcmp(file, ".");
          if(return_value_strcmp_4 == 0)
            tmp_if_expr_6 = (_Bool)1;

          else
          {
            return_value_strcmp_5=strcmp(file, "..");
            tmp_if_expr_6 = !(return_value_strcmp_5 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr_6)
          {
            sprintf(path, "%s%c%s", name, 47, file);
            signed int return_value_unlink_7;
            return_value_unlink_7=unlink(path);
            if(return_value_unlink_7 == -1)
              est_rmdir_rec(path);

          }

        }
        do
        {
          signed int _CB_i;
          signed int _CB_end = files->start + files->num;
          _CB_i = files->start;
          for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
            free((void *)(files->array + (signed long int)_CB_i)->dptr);
          free((void *)files->array);
          free((void *)files);
        }
        while((_Bool)0);
      }

    }

    i = 0;
    for( ; !(i >= dnum); i = i + 1)
    {
      sprintf(path, "%s%c%04d", name, 47, i + 1);
      signed int *return_value_vlcrdnumptr_8;
      return_value_vlcrdnumptr_8=vlcrdnumptr();
      crdnum = *return_value_vlcrdnumptr_8;
      signed int *return_value_vlcrdnumptr_9;
      return_value_vlcrdnumptr_9=vlcrdnumptr();
      *return_value_vlcrdnumptr_9 = 2;
      idx->dbs[(signed long int)i]=vlopen(path, omode, VL_CMPLEX);
      if(idx->dbs[(signed long int)i] == ((struct anonymous_4 *)NULL))
      {
        do
        {
          i = i - 1;
          if(!(i >= 0))
            break;

          vlclose(idx->dbs[(signed long int)i]);
        }
        while((_Bool)1);
        signed int *return_value_vlcrdnumptr_10;
        return_value_vlcrdnumptr_10=vlcrdnumptr();
        *return_value_vlcrdnumptr_10 = crdnum;
        return (struct anonymous_2 *)(void *)0;
      }

      signed int *return_value_vlcrdnumptr_11;
      return_value_vlcrdnumptr_11=vlcrdnumptr();
      *return_value_vlcrdnumptr_11 = crdnum;
    }
    idx->name=cbmemdup(name, -1);
    idx->omode = omode;
    idx->dnum = dnum;
    idx->cdb = idx->dbs[(signed long int)(dnum - 1)];
    return idx;
  }
}

// est_idx_optimize
// file estraier.c line 7275
static signed int est_idx_optimize(struct anonymous_2 *idx)
{
  signed int i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    signed int return_value_vloptimize_1;
    return_value_vloptimize_1=vloptimize(idx->dbs[(signed long int)i]);
    if(return_value_vloptimize_1 == 0)
      return 0;

  }
  return 1;
}

// est_idx_out
// file estraier.c line 7145
static signed int est_idx_out(struct anonymous_2 *idx, const char *word, signed int wsiz)
{
  signed int i;
  signed int err = 0;
  i = 0;
  signed int *return_value_dpecodeptr_1;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    signed int return_value_vlout_2;
    return_value_vlout_2=vlout(idx->dbs[(signed long int)i], word, wsiz);
    if(return_value_vlout_2 == 0)
    {
      return_value_dpecodeptr_1=dpecodeptr();
      if(!(*return_value_dpecodeptr_1 == 5))
        err = 1;

    }

  }
  return err != 0 ? 0 : 1;
}

// est_idx_put_one
// file estraier.c line 7131
static signed int est_idx_put_one(struct anonymous_2 *idx, signed int inum, const char *word, signed int wsiz, const char *vbuf, signed int vsiz)
{
  signed int tmp_if_expr_5;
  signed int return_value_vlput_1;
  signed int return_value_vlout_2;
  _Bool tmp_if_expr_4;
  signed int *return_value_dpecodeptr_3;
  if(vsiz >= 1)
  {
    return_value_vlput_1=vlput(idx->dbs[(signed long int)inum], word, wsiz, vbuf, vsiz, 0);
    tmp_if_expr_5 = return_value_vlput_1;
  }

  else
  {
    return_value_vlout_2=vlout(idx->dbs[(signed long int)inum], word, wsiz);
    if(!(return_value_vlout_2 == 0))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_dpecodeptr_3=dpecodeptr();
      tmp_if_expr_4 = *return_value_dpecodeptr_3 == 5 ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr_5 = (signed int)tmp_if_expr_4;
  }
  return tmp_if_expr_5;
}

// est_idx_rec_last_id
// file estraier.c line 6874
static signed int est_idx_rec_last_id(const char *vbuf, signed int vsiz, signed int smode)
{
  const char *rp;
  const char *ep;
  const char *sp;
  signed int cid;
  signed int vnum;
  signed int vstep;
  cid = 0;
  rp = vbuf;
  ep = vbuf + (signed long int)vsiz;
  for( ; !(rp >= ep); rp = rp + 1l)
  {
    do
    {
      signed int _EST_i;
      signed int _EST_base;
      vnum = 0;
      _EST_base = 1;
      _EST_i = 0;
      for( ; (_Bool)1; _EST_i = _EST_i + 1)
      {
        if((signed int)rp[(signed long int)_EST_i] >= 0)
        {
          vnum = vnum + (signed int)((signed char *)rp)[(signed long int)_EST_i] * _EST_base;
          break;
        }

        vnum = vnum + _EST_base * ((signed int)((signed char *)rp)[(signed long int)_EST_i] + 1) * -1;
        _EST_base = _EST_base * 128;
      }
      vstep = _EST_i + 1;
    }
    while((_Bool)0);
    cid = cid + vnum + 1;
    rp = rp + (signed long int)vstep;
    sp = rp;
    if(!(smode == 1048576))
    {
      if(smode == 2097152 || smode == 4194304)
        goto __CPROVER_DUMP_L8;

    }

    else
      goto __CPROVER_DUMP_L9;
    rp = rp + 1l;
    goto __CPROVER_DUMP_L9;

  __CPROVER_DUMP_L8:
    ;
    rp = rp + (signed long int)sizeof(signed int) /*4ul*/ ;

  __CPROVER_DUMP_L9:
    ;
    for( ; !((signed int)*rp == 0x00); rp = rp + (signed long int)2)
      ;
  }
  return cid;
}

// est_idx_scan
// file estraier.c line 7165
static char * est_idx_scan(struct anonymous_2 *idx, const char *word, signed int wsiz, signed int *sp, signed int smode)
{
  struct anonymous_9 *datum;
  const char *vbuf;
  signed int i;
  signed int vsiz;
  do
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_9) /*16ul*/ );
    datum = (struct anonymous_9 *)return_value_malloc_1;
    if(!(datum == ((struct anonymous_9 *)NULL)))
      datum;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)12);
    datum->dptr = (char *)return_value_malloc_2;
    if(!(datum->dptr == ((char *)NULL)))
      datum->dptr;

    else
      cbmyfatal("out of memory");
    datum->dptr[(signed long int)0] = (char)0;
    datum->dsize = 0;
    datum->asize = 12;
  }
  while((_Bool)0);
  i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    vbuf=vlgetcache(idx->dbs[(signed long int)i], word, wsiz, &vsiz);
    if(!(vbuf == ((const char *)NULL)))
      est_decode_idx_rec(datum, vbuf, vsiz, smode);

  }
  char *return_value_cbdatumtomalloc_3;
  return_value_cbdatumtomalloc_3=cbdatumtomalloc(datum, sp);
  return return_value_cbdatumtomalloc_3;
}

// est_idx_set_current
// file estraier.c line 7287
static void est_idx_set_current(struct anonymous_2 *idx)
{
  signed int i;
  signed int size;
  signed int min;
  min=vlfsiz(idx->cdb);
  i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    size=vlfsiz(idx->dbs[(signed long int)i]);
    if(!(size >= min))
    {
      idx->cdb = idx->dbs[(signed long int)i];
      min = size;
    }

  }
}

// est_idx_set_tuning
// file estraier.c line 7055
static void est_idx_set_tuning(struct anonymous_2 *idx, signed int lrecmax, signed int nidxmax, signed int lcnum, signed int ncnum, signed int fbpsiz)
{
  signed int i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    vlsettuning(idx->dbs[(signed long int)i], lrecmax, nidxmax, lcnum, ncnum);
    if(fbpsiz >= 1)
      vlsetfbpsiz(idx->dbs[(signed long int)i], fbpsiz);

  }
}

// est_idx_size
// file estraier.c line 7225
static double est_idx_size(struct anonymous_2 *idx)
{
  signed int i;
  double size = (double)0;
  i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    signed int return_value_vlfsiz_1;
    return_value_vlfsiz_1=vlfsiz(idx->dbs[(signed long int)i]);
    size = size + (double)return_value_vlfsiz_1;
  }
  return size;
}

// est_idx_size_current
// file estraier.c line 7240
static signed int est_idx_size_current(struct anonymous_2 *idx)
{
  signed int return_value_vlfsiz_1;
  return_value_vlfsiz_1=vlfsiz(idx->cdb);
  return return_value_vlfsiz_1;
}

// est_idx_sync
// file estraier.c line 7262
static signed int est_idx_sync(struct anonymous_2 *idx)
{
  signed int i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    signed int return_value_vlsync_1;
    return_value_vlsync_1=vlsync(idx->dbs[(signed long int)i]);
    if(return_value_vlsync_1 == 0)
      return 0;

  }
  return 1;
}

// est_idx_vsiz
// file estraier.c line 7201
static signed int est_idx_vsiz(struct anonymous_2 *idx, const char *word, signed int wsiz)
{
  signed int i;
  signed int sum;
  signed int vsiz;
  sum = 0;
  i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    vsiz=vlvsiz(idx->dbs[(signed long int)i], word, wsiz);
    if(vsiz >= 1)
      sum = sum + vsiz;

  }
  return sum;
}

// est_inet_aton
// file estnode.c line 1782
static signed int est_inet_aton(const char *cp, struct in_addr *inp)
{
  signed int return_value_inet_aton_1;
  return_value_inet_aton_1=inet_aton(cp, inp);
  return return_value_inet_aton_1;
}

// est_inflate
// file estraier.c line 3819
char * est_inflate(const char *ptr, signed int size, signed int *sp, signed int mode)
{
  struct z_stream_s zs;
  char *buf;
  unsigned char obuf[8192l];
  signed int rv;
  signed int asiz;
  signed int bsiz;
  signed int osiz;
  zs.zalloc = ((void * (*)(void *, unsigned int, unsigned int))NULL);
  zs.zfree = ((void (*)(void *, void *))NULL);
  zs.opaque = NULL;
  signed int return_value_inflateInit2__1;
  signed int return_value_inflateInit2__2;
  if(!(mode == -1))
  {
    if(mode == 1)
      goto __CPROVER_DUMP_L3;

  }

  else
  {
    return_value_inflateInit2__1=inflateInit2_(&zs, -15, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
    if(!(return_value_inflateInit2__1 == 0))
      return (char *)(void *)0;

    goto __CPROVER_DUMP_L7;

  __CPROVER_DUMP_L3:
    ;
    return_value_inflateInit2__2=inflateInit2_(&zs, 15 + 16, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
    if(!(return_value_inflateInit2__2 == 0))
      return (char *)(void *)0;

    goto __CPROVER_DUMP_L7;
  }
  signed int return_value_inflateInit2__3;
  return_value_inflateInit2__3=inflateInit2_(&zs, 15, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
  if(!(return_value_inflateInit2__3 == 0))
    return (char *)(void *)0;

  else
  {
    goto __CPROVER_DUMP_L7;

  __CPROVER_DUMP_L7:
    ;
    asiz = size * 2 + 16;
    if(!(asiz >= 8192))
      asiz = 8192;

    void *return_value_malloc_4;
    return_value_malloc_4=malloc((unsigned long int)asiz);
    buf = (char *)return_value_malloc_4;
    if(!(buf == ((char *)NULL)))
      buf;

    else
      cbmyfatal("out of memory");
    bsiz = 0;
    zs.next_in = (unsigned char *)ptr;
    zs.avail_in = (unsigned int)size;
    zs.next_out = obuf;
    zs.avail_out = (unsigned int)8192;
    do
    {
      rv=inflate(&zs, 0);
      if(!(rv == 0))
        break;

      osiz = (signed int)((unsigned int)8192 - zs.avail_out);
      if(bsiz + osiz >= asiz)
      {
        asiz = asiz * 2 + osiz;
        void *return_value_realloc_5;
        return_value_realloc_5=realloc((void *)buf, (unsigned long int)asiz);
        buf = (char *)return_value_realloc_5;
        if(!(buf == ((char *)NULL)))
          buf;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(buf + (signed long int)bsiz), (const void *)obuf, (unsigned long int)osiz);
      bsiz = bsiz + osiz;
      zs.next_out = obuf;
      zs.avail_out = (unsigned int)8192;
    }
    while((_Bool)1);
    if(!(rv == 1))
    {
      free((void *)buf);
      inflateEnd(&zs);
      return (char *)(void *)0;
    }

    else
    {
      osiz = (signed int)((unsigned int)8192 - zs.avail_out);
      if(bsiz + osiz >= asiz)
      {
        asiz = asiz * 2 + osiz;
        void *return_value_realloc_6;
        return_value_realloc_6=realloc((void *)buf, (unsigned long int)asiz);
        buf = (char *)return_value_realloc_6;
        if(!(buf == ((char *)NULL)))
          buf;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(buf + (signed long int)bsiz), (const void *)obuf, (unsigned long int)osiz);
      bsiz = bsiz + osiz;
      buf[(signed long int)bsiz] = (char)0;
      if(!(sp == ((signed int *)NULL)))
        *sp = bsiz;

      inflateEnd(&zs);
      return buf;
    }
  }
}

// est_init_net_env
// file estnode.h line 42
signed int est_init_net_env(void)
{
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&est_host_addrs_mutex);
  if(!(return_value_pthread_mutex_lock_1 == 0))
    return 0;

  else
  {
    if(!(est_host_attrs_cnt >= 1))
      est_host_addrs=cbmapopenex(4096 + 1);

    est_host_attrs_cnt = est_host_attrs_cnt + 1;
    pthread_mutex_unlock(&est_host_addrs_mutex);
    return 1;
  }
}

// est_inode
// file estraier.c line 5595
signed int est_inode(const char *path)
{
  struct stat sbuf;
  signed int return_value_stat_1;
  return_value_stat_1=stat(path, &sbuf);
  if(return_value_stat_1 == -1)
    return -1;

  else
    return (signed int)(sbuf.st_ino & (unsigned long int)0x7fffffff);
}

// est_inodes_delete
// file estraier.c line 7727
static void est_inodes_delete(void *arg)
{
  struct anonymous_0 *db;
  const char *kbuf;
  signed int ecode;
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(est_inodes);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(est_inodes);
    do
    {
      kbuf=cbmapiternext(est_inodes, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      db = *((struct anonymous_0 **)return_value_cbmapiterval_1);
      est_db_set_informer(db, est_inodes_delete_informer, (void *)0);
      est_db_close(db, &ecode);
    }
    while((_Bool)1);
  }

  cbmapclose(est_inodes);
}

// est_inodes_delete_informer
// file estraier.c line 7764
static void est_inodes_delete_informer(const char *msg, void *opaque)
{
  ;
}

// est_int_compare
// file estraier.c line 7708
static signed int est_int_compare(const void *ap, const void *bp)
{
  return *((signed int *)ap) - *((signed int *)bp);
}

// est_keysc_compare
// file estraier.c line 10203
static signed int est_keysc_compare(const void *ap, const void *bp)
{
  return ((struct anonymous_31 *)bp)->pt - ((struct anonymous_31 *)ap)->pt;
}

// est_kill
// file estraier.c line 5715
signed int est_kill(signed int pid, signed int sig)
{
  signed int return_value_kill_1;
  return_value_kill_1=kill(pid, sig);
  return (signed int)(return_value_kill_1 == 0);
}

// est_lzodecode
// file estraier.c line 3905
char * est_lzodecode(const char *ptr, signed int size, signed int *sp)
{
  if(!(sp == ((signed int *)NULL)))
    *sp = size;

  char *return_value_cbmemdup_1;
  return_value_cbmemdup_1=cbmemdup(ptr, size);
  return return_value_cbmemdup_1;
}

// est_lzoencode
// file estraier.c line 3882
char * est_lzoencode(const char *ptr, signed int size, signed int *sp)
{
  unsigned long int return_value_strlen_1;
  if(!(size >= 0))
  {
    return_value_strlen_1=strlen(ptr);
    size = (signed int)return_value_strlen_1;
  }

  *sp = size;
  char *return_value_cbmemdup_2;
  return_value_cbmemdup_2=cbmemdup(ptr, size);
  return return_value_cbmemdup_2;
}

// est_make_cattr_list
// file estraier.c line 9703
static struct anonymous_16 * est_make_cattr_list(const struct anonymous_6 *attrs, signed int *nump)
{
  struct anonymous_16 *list;
  const char *rp;
  const char *pv;
  unsigned char *utmp;
  signed int i;
  signed int anum;
  signed int tsiz;
  anum = (signed int)attrs->num;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_16) /*96ul*/  * (unsigned long int)anum + (unsigned long int)1);
  list = (struct anonymous_16 *)return_value_malloc_1;
  if(!(list == ((struct anonymous_16 *)NULL)))
    list;

  else
    cbmyfatal("out of memory");
  i = 0;
  for( ; !(i >= anum); i = i + 1)
  {
    (list + (signed long int)i)->name = (char *)(void *)0;
    (list + (signed long int)i)->oper = (char *)(void *)0;
    (list + (signed long int)i)->val = (char *)(void *)0;
    rp = (const char *)(attrs->array + (signed long int)(attrs->start + i))->dptr;
    for( ; (signed int)*rp >= 1; rp = rp + 1l)
      if((signed int)*rp >= 33)
        break;

    pv=strchr(rp, 32);
    if(!(pv == ((const char *)NULL)))
    {
      (list + (signed long int)i)->nsiz = (signed int)(pv - rp);
      (list + (signed long int)i)->name=cbmemdup(rp, (list + (signed long int)i)->nsiz);
      rp = pv;
      for( ; (signed int)*rp >= 1; rp = rp + 1l)
        if((signed int)*rp >= 33)
          break;

      pv=strchr(rp, 32);
      if(!(pv == ((const char *)NULL)))
      {
        (list + (signed long int)i)->oper=cbmemdup(rp, (signed int)(pv - rp));
        rp = pv;
        for( ; (signed int)*rp >= 1; rp = rp + 1l)
          if((signed int)*rp >= 33)
            break;

        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(rp);
        (list + (signed long int)i)->vsiz = (signed int)return_value_strlen_2;
        (list + (signed long int)i)->val=cbmemdup(rp, (list + (signed long int)i)->vsiz);
      }

      else
        (list + (signed long int)i)->oper=cbmemdup(rp, -1);
    }

    else
    {
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(rp);
      (list + (signed long int)i)->nsiz = (signed int)return_value_strlen_3;
      (list + (signed long int)i)->name=cbmemdup(rp, (list + (signed long int)i)->nsiz);
    }
    char *return_value_strchr_4;
    return_value_strchr_4=strchr((list + (signed long int)i)->name, 44);
    if(!(return_value_strchr_4 == ((char *)NULL)))
      (list + (signed long int)i)->nlist=cbsplit((list + (signed long int)i)->name, (list + (signed long int)i)->nsiz, ",");

    else
      (list + (signed long int)i)->nlist = (struct anonymous_6 *)(void *)0;
    if((list + (signed long int)i)->oper == ((char *)NULL))
      (list + (signed long int)i)->oper=cbmemdup("", 0);

    if((list + (signed long int)i)->val == ((char *)NULL))
    {
      (list + (signed long int)i)->vsiz = 0;
      (list + (signed long int)i)->val=cbmemdup("", 0);
    }

  }
  i = 0;
  _Bool tmp_if_expr_8;
  signed int return_value_cbstricmp_26;
  signed int return_value_cbstricmp_25;
  signed int return_value_cbstricmp_24;
  signed int return_value_cbstricmp_23;
  signed int return_value_cbstricmp_22;
  signed int return_value_cbstricmp_21;
  signed int return_value_cbstricmp_20;
  signed int return_value_cbstricmp_19;
  void *tmp_if_expr_11;
  void *return_value_est_regex_new_9;
  void *return_value_est_regex_new_10;
  signed int return_value_cbstricmp_18;
  signed int return_value_cbstricmp_17;
  signed int return_value_cbstricmp_16;
  signed int return_value_cbstricmp_15;
  signed int return_value_cbstricmp_14;
  signed int return_value_cbstricmp_13;
  signed int return_value_cbstricmp_12;
  for( ; !(i >= anum); i = i + 1)
  {
    rp = (list + (signed long int)i)->oper;
    if((signed int)*rp == 33)
    {
      (list + (signed long int)i)->sign = 0;
      rp = rp + 1l;
    }

    else
      (list + (signed long int)i)->sign = 1;
    if((signed int)*rp == 73)
      tmp_if_expr_8 = (_Bool)1;

    else
      tmp_if_expr_8 = (signed int)*rp == 105 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_8)
    {
      signed int return_value_est_check_cjk_only_7;
      return_value_est_check_cjk_only_7=est_check_cjk_only((list + (signed long int)i)->val);
      if(!(return_value_est_check_cjk_only_7 == 0))
      {
        (list + (signed long int)i)->sval = (char *)(void *)0;
        (list + (signed long int)i)->ssiz = 0;
      }

      else
      {
        char *return_value_est_uconv_in_5;
        return_value_est_uconv_in_5=est_uconv_in((list + (signed long int)i)->val, (list + (signed long int)i)->vsiz, &tsiz);
        utmp = (unsigned char *)return_value_est_uconv_in_5;
        est_normalize_text(utmp, tsiz, &tsiz);
        est_canonicalize_text(utmp, tsiz, 0);
        char *return_value_est_uconv_out_6;
        return_value_est_uconv_out_6=est_uconv_out((char *)utmp, tsiz, &(list + (signed long int)i)->ssiz);
        (list + (signed long int)i)->sval = (char *)return_value_est_uconv_out_6;
        free((void *)utmp);
      }
      rp = rp + 1l;
    }

    else
    {
      (list + (signed long int)i)->sval = (char *)(void *)0;
      (list + (signed long int)i)->ssiz = 0;
    }
    (list + (signed long int)i)->regex = (void *)0;
    (list + (signed long int)i)->num=cbstrmktime((list + (signed long int)i)->val);
    signed int return_value_cbstricmp_27;
    return_value_cbstricmp_27=cbstricmp(rp, "STREQ");
    if(return_value_cbstricmp_27 == 0)
      (list + (signed long int)i)->cop = "STREQ";

    else
    {
      return_value_cbstricmp_26=cbstricmp(rp, "STRNE");
      if(return_value_cbstricmp_26 == 0)
        (list + (signed long int)i)->cop = "STRNE";

      else
      {
        return_value_cbstricmp_25=cbstricmp(rp, "STRINC");
        if(return_value_cbstricmp_25 == 0)
          (list + (signed long int)i)->cop = "STRINC";

        else
        {
          return_value_cbstricmp_24=cbstricmp(rp, "STRBW");
          if(return_value_cbstricmp_24 == 0)
            (list + (signed long int)i)->cop = "STRBW";

          else
          {
            return_value_cbstricmp_23=cbstricmp(rp, "STREW");
            if(return_value_cbstricmp_23 == 0)
              (list + (signed long int)i)->cop = "STREW";

            else
            {
              return_value_cbstricmp_22=cbstricmp(rp, "STRAND");
              if(return_value_cbstricmp_22 == 0)
                (list + (signed long int)i)->cop = "STRAND";

              else
              {
                return_value_cbstricmp_21=cbstricmp(rp, "STROR");
                if(return_value_cbstricmp_21 == 0)
                  (list + (signed long int)i)->cop = "STROR";

                else
                {
                  return_value_cbstricmp_20=cbstricmp(rp, "STROREQ");
                  if(return_value_cbstricmp_20 == 0)
                    (list + (signed long int)i)->cop = "STROREQ";

                  else
                  {
                    return_value_cbstricmp_19=cbstricmp(rp, "STRRX");
                    if(return_value_cbstricmp_19 == 0)
                    {
                      (list + (signed long int)i)->cop = "STRRX";
                      if(!((list + (signed long int)i)->sval == ((char *)NULL)))
                      {
                        return_value_est_regex_new_9=est_regex_new((list + (signed long int)i)->sval);
                        tmp_if_expr_11 = return_value_est_regex_new_9;
                      }

                      else
                      {
                        return_value_est_regex_new_10=est_regex_new((list + (signed long int)i)->val);
                        tmp_if_expr_11 = return_value_est_regex_new_10;
                      }
                      (list + (signed long int)i)->regex = tmp_if_expr_11;
                    }

                    else
                    {
                      return_value_cbstricmp_18=cbstricmp(rp, "NUMEQ");
                      if(return_value_cbstricmp_18 == 0)
                        (list + (signed long int)i)->cop = "NUMEQ";

                      else
                      {
                        return_value_cbstricmp_17=cbstricmp(rp, "NUMNE");
                        if(return_value_cbstricmp_17 == 0)
                          (list + (signed long int)i)->cop = "NUMNE";

                        else
                        {
                          return_value_cbstricmp_16=cbstricmp(rp, "NUMGT");
                          if(return_value_cbstricmp_16 == 0)
                            (list + (signed long int)i)->cop = "NUMGT";

                          else
                          {
                            return_value_cbstricmp_15=cbstricmp(rp, "NUMGE");
                            if(return_value_cbstricmp_15 == 0)
                              (list + (signed long int)i)->cop = "NUMGE";

                            else
                            {
                              return_value_cbstricmp_14=cbstricmp(rp, "NUMLT");
                              if(return_value_cbstricmp_14 == 0)
                                (list + (signed long int)i)->cop = "NUMLT";

                              else
                              {
                                return_value_cbstricmp_13=cbstricmp(rp, "NUMLE");
                                if(return_value_cbstricmp_13 == 0)
                                  (list + (signed long int)i)->cop = "NUMLE";

                                else
                                {
                                  return_value_cbstricmp_12=cbstricmp(rp, "NUMBT");
                                  if(return_value_cbstricmp_12 == 0)
                                    (list + (signed long int)i)->cop = "NUMBT";

                                  else
                                  {
                                    (list + (signed long int)i)->cop = "STRINC";
                                    (list + (signed long int)i)->val[(signed long int)0] = (char)0;
                                    (list + (signed long int)i)->vsiz = 0;
                                    if(!((list + (signed long int)i)->sval == ((char *)NULL)))
                                    {
                                      (list + (signed long int)i)->sval[(signed long int)0] = (char)0;
                                      (list + (signed long int)i)->ssiz = 0;
                                    }

                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  *nump = anum;
  return list;
}

// est_make_crypt
// file estraier.c line 4088
char * est_make_crypt(const char *key)
{
  struct md5_state_s ms;
  char digest[32l];
  char str[64l];
  char *wp;
  signed int i;
  md5_init(&ms);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(key);
  md5_append(&ms, (unsigned char *)key, (signed int)return_value_strlen_1);
  md5_finish(&ms, (unsigned char *)digest);
  wp = str;
  i = 0;
  for( ; !(i >= 16); i = i + 1)
  {
    signed int return_value_sprintf_2;
    return_value_sprintf_2=sprintf(wp, "%02x", ((unsigned char *)digest)[(signed long int)i]);
    wp = wp + (signed long int)return_value_sprintf_2;
  }
  char *return_value_cbmemdup_3;
  return_value_cbmemdup_3=cbmemdup(str, -1);
  return return_value_cbmemdup_3;
}

// est_make_snippet
// file estraier.c line 6438
static char * est_make_snippet(const char *str, signed int len, const struct anonymous_6 *words, signed int wwidth, signed int hwidth, signed int awidth)
{
  struct anonymous_9 *res;
  struct anonymous_5 *counts;
  struct anonymous_6 *rwords;
  const char *word;
  const char *cval;
  const unsigned char *rword;
  unsigned char *rtext;
  unsigned char *ctext;
  signed int i;
  signed int j;
  signed int k;
  signed int bi;
  signed int size;
  signed int wsiz;
  signed int rwsiz;
  signed int mywidth;
  signed int awsiz;
  signed int csiz;
  do
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_9) /*16ul*/ );
    res = (struct anonymous_9 *)return_value_malloc_1;
    if(!(res == ((struct anonymous_9 *)NULL)))
      res;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)12);
    res->dptr = (char *)return_value_malloc_2;
    if(!(res->dptr == ((char *)NULL)))
      res->dptr;

    else
      cbmyfatal("out of memory");
    res->dptr[(signed long int)0] = (char)0;
    res->dsize = 0;
    res->asize = 12;
  }
  while((_Bool)0);
  do
  {
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(sizeof(struct anonymous_6) /*24ul*/ );
    rwords = (struct anonymous_6 *)return_value_malloc_3;
    if(!(rwords == ((struct anonymous_6 *)NULL)))
      rwords;

    else
      cbmyfatal("out of memory");
    rwords->anum = 64;
    void *return_value_malloc_4;
    return_value_malloc_4=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)rwords->anum);
    rwords->array = (struct anonymous_28 *)return_value_malloc_4;
    if(!(rwords->array == ((struct anonymous_28 *)NULL)))
      rwords->array;

    else
      cbmyfatal("out of memory");
    rwords->start = 0;
    rwords->num = 0;
  }
  while((_Bool)0);
  i = 0;
  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_5;
  for( ; !(i >= words->num); i = i + 1)
  {
    wsiz = (words->array + (signed long int)(words->start + i))->dsize;
    word = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
    if(!(wsiz >= 1))
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_strcmp_5=strcmp(word, "[UVSET]");
      tmp_if_expr_6 = !(return_value_strcmp_5 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_6)
    {
      char *return_value_est_uconv_in_7;
      return_value_est_uconv_in_7=est_uconv_in(word, wsiz, &size);
      rtext = (unsigned char *)return_value_est_uconv_in_7;
      est_canonicalize_text(rtext, size, 1);
      do
      {
        signed int _CB_index = rwords->start + rwords->num;
        if(_CB_index >= rwords->anum)
        {
          rwords->anum = rwords->anum * 2;
          void *return_value_realloc_8;
          return_value_realloc_8=realloc((void *)rwords->array, (unsigned long int)rwords->anum * sizeof(struct anonymous_28) /*16ul*/ );
          rwords->array = (struct anonymous_28 *)return_value_realloc_8;
          if(!(rwords->array == ((struct anonymous_28 *)NULL)))
            rwords->array;

          else
            cbmyfatal("out of memory");
        }

        (rwords->array + (signed long int)_CB_index)->dptr = (char *)rtext;
        (rwords->array + (signed long int)_CB_index)->dsize = size;
        rwords->num = rwords->num + 1;
      }
      while((_Bool)0);
    }

  }
  char *return_value_est_uconv_in_9;
  return_value_est_uconv_in_9=est_uconv_in(str, len, &size);
  rtext = (unsigned char *)return_value_est_uconv_in_9;
  char *return_value_cbmemdup_10;
  return_value_cbmemdup_10=cbmemdup((char *)rtext, size);
  ctext = (unsigned char *)return_value_cbmemdup_10;
  est_canonicalize_text(ctext, size, 0);
  mywidth = hwidth;
  if(!(rwords->num >= 1))
    mywidth = mywidth * 3;

  if(!(wwidth >= mywidth))
    mywidth = wwidth;

  i = 0;
  for( ; mywidth >= 1 && !(i >= size); i = i + 2)
  {
    signed int return_value_est_char_category_11;
    return_value_est_char_category_11=est_char_category((signed int)rtext[(signed long int)i] * 0x100 + (signed int)rtext[(signed long int)(i + 1)]);
    mywidth = mywidth - (return_value_est_char_category_11 == 3 ? 2 : 1);
  }
  awsiz = size - i;
  if(awsiz >= 49)
    awsiz = 48;

  est_snippet_add_text(rtext, ctext, i, awsiz, res, rwords);
  wwidth = wwidth - hwidth;
  bi = i + 2;
  do
  {
    if(1 + res->dsize >= res->asize)
    {
      res->asize = res->asize * 2 + 1 + 1;
      void *return_value_realloc_12;
      return_value_realloc_12=realloc((void *)res->dptr, (unsigned long int)res->asize);
      res->dptr = (char *)return_value_realloc_12;
      if(!(res->dptr == ((char *)NULL)))
        res->dptr;

      else
        cbmyfatal("out of memory");
    }

    memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)"\n", (unsigned long int)1);
    res->dsize = res->dsize + 1;
    res->dptr[(signed long int)res->dsize] = (char)0;
  }
  while((_Bool)0);
  if(awidth >= 1)
  {
    counts=cbmapopenex(31);
    i = bi;
    for( ; wwidth >= 0 && !(i >= size); i = i + 2)
    {
      j = 0;
      for( ; !(j >= rwords->num); j = j + 1)
      {
        rwsiz = (rwords->array + (signed long int)(rwords->start + j))->dsize;
        rword = (unsigned char *)(const char *)(rwords->array + (signed long int)(rwords->start + j))->dptr;
        signed int return_value_est_str_fwmatch_wide_17;
        return_value_est_str_fwmatch_wide_17=est_str_fwmatch_wide(ctext + (signed long int)i, size - i, rword, rwsiz);
        if(return_value_est_str_fwmatch_wide_17 >= 1)
        {
          cval=cbmapget(counts, (char *)rword, rwsiz, &csiz);
          if(cval == ((const char *)NULL) || !(csiz >= ((double)wwidth > (double)awidth * 1.2 ? 2 : 1)))
          {
            cbmapputcat(counts, (char *)rword, rwsiz, "*", 1);
            signed int return_value_cbmaprnum_13;
            return_value_cbmaprnum_13=cbmaprnum(counts);
            if(return_value_cbmaprnum_13 >= rwords->num)
            {
              cbmapclose(counts);
              counts=cbmapopenex(31);
            }

            mywidth = awidth / 2 + 1;
            k = i - 2;
            for( ; k >= bi && mywidth >= 0; k = k - 2)
            {
              signed int return_value_est_char_category_14;
              return_value_est_char_category_14=est_char_category((signed int)rtext[(signed long int)k] * 0x100 + (signed int)rtext[(signed long int)(k + 1)]);
              mywidth = mywidth - (return_value_est_char_category_14 == 3 ? 2 : 1);
            }
            bi = k;
            mywidth = awidth / 2 + 1;
            k = i + rwsiz + 2;
            for( ; mywidth >= 0 && !(k >= size); k = k + 2)
            {
              signed int return_value_est_char_category_15;
              return_value_est_char_category_15=est_char_category((signed int)rtext[(signed long int)k] * 0x100 + (signed int)rtext[(signed long int)(k + 1)]);
              mywidth = mywidth - (return_value_est_char_category_15 == 3 ? 2 : 1);
            }
            if(!(size >= k))
              k = size;

            est_snippet_add_text(rtext + (signed long int)bi, ctext + (signed long int)bi, k - bi, 0, res, rwords);
            wwidth = wwidth - (awidth + rwsiz / 2);
            bi = k + 2;
            i = bi - 2;
            do
            {
              if(1 + res->dsize >= res->asize)
              {
                res->asize = res->asize * 2 + 1 + 1;
                void *return_value_realloc_16;
                return_value_realloc_16=realloc((void *)res->dptr, (unsigned long int)res->asize);
                res->dptr = (char *)return_value_realloc_16;
                if(!(res->dptr == ((char *)NULL)))
                  res->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)"\n", (unsigned long int)1);
              res->dsize = res->dsize + 1;
              res->dptr[(signed long int)res->dsize] = (char)0;
            }
            while((_Bool)0);
            break;
          }

        }

      }
    }
    cbmapclose(counts);
  }

  free((void *)ctext);
  free((void *)rtext);
  do
  {
    signed int _CB_i;
    signed int _CB_end = rwords->start + rwords->num;
    _CB_i = rwords->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(rwords->array + (signed long int)_CB_i)->dptr);
    free((void *)rwords->array);
    free((void *)rwords);
  }
  while((_Bool)0);
  char *return_value_cbdatumtomalloc_18;
  return_value_cbdatumtomalloc_18=cbdatumtomalloc(res, (signed int *)(void *)0);
  return return_value_cbdatumtomalloc_18;
}

// est_match_attr
// file estraier.c line 10008
static signed int est_match_attr(const char *tval, signed int tsiz, const char *cop, signed int sign, const char *oval, signed int osiz, const char *sval, signed int ssiz, const void *regex, signed int onum)
{
  unsigned char *eval;
  char *cval;
  signed int csiz;
  signed int esiz;
  signed int hit;
  cval = (char *)(void *)0;
  if(!(sval == ((const char *)NULL)))
  {
    char *return_value_est_uconv_in_1;
    return_value_est_uconv_in_1=est_uconv_in(tval, tsiz, &esiz);
    eval = (unsigned char *)return_value_est_uconv_in_1;
    est_normalize_text(eval, esiz, &esiz);
    est_canonicalize_text(eval, esiz, 0);
    char *return_value_est_uconv_out_2;
    return_value_est_uconv_out_2=est_uconv_out((char *)eval, esiz, &csiz);
    cval = (char *)return_value_est_uconv_out_2;
    free((void *)eval);
    tval = cval;
    tsiz = csiz;
    oval = sval;
    osiz = ssiz;
  }

  signed int tmp_if_expr_7;
  signed int return_value_est_regex_match_6;
  if(cop == "STREQ")
  {
    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(tval, oval);
    hit = (signed int)!(return_value_strcmp_3 != 0);
  }

  else
    if(cop == "STRNE")
    {
      signed int return_value_strcmp_4;
      return_value_strcmp_4=strcmp(tval, oval);
      hit = (signed int)(return_value_strcmp_4 != 0);
    }

    else
      if(cop == "STRINC")
      {
        char *return_value_strstr_5;
        return_value_strstr_5=strstr(tval, oval);
        hit = (signed int)(return_value_strstr_5 != (char *)(void *)0);
      }

      else
        if(cop == "STRBW")
          hit=cbstrfwmatch(tval, oval);

        else
          if(cop == "STREW")
            hit=cbstrbwmatch(tval, oval);

          else
            if(cop == "STRAND")
              hit=est_check_strand(tval, oval);

            else
              if(cop == "STROR")
                hit=est_check_stror(tval, oval);

              else
                if(cop == "STROREQ")
                  hit=est_check_stroreq(tval, oval);

                else
                  if(cop == "STRRX")
                  {
                    if(!(regex == NULL))
                    {
                      return_value_est_regex_match_6=est_regex_match(regex, tval);
                      tmp_if_expr_7 = return_value_est_regex_match_6;
                    }

                    else
                      tmp_if_expr_7 = 0;
                    hit = tmp_if_expr_7;
                  }

                  else
                    if(cop == "NUMEQ")
                    {
                      signed long int return_value_cbstrmktime_8;
                      return_value_cbstrmktime_8=cbstrmktime(tval);
                      hit = (signed int)(return_value_cbstrmktime_8 == (signed long int)onum);
                    }

                    else
                      if(cop == "NUMNE")
                      {
                        signed long int return_value_cbstrmktime_9;
                        return_value_cbstrmktime_9=cbstrmktime(tval);
                        hit = (signed int)(return_value_cbstrmktime_9 != (signed long int)onum);
                      }

                      else
                        if(cop == "NUMGT")
                        {
                          signed long int return_value_cbstrmktime_10;
                          return_value_cbstrmktime_10=cbstrmktime(tval);
                          hit = (signed int)(return_value_cbstrmktime_10 > (signed long int)onum);
                        }

                        else
                          if(cop == "NUMGE")
                          {
                            signed long int return_value_cbstrmktime_11;
                            return_value_cbstrmktime_11=cbstrmktime(tval);
                            hit = (signed int)(return_value_cbstrmktime_11 >= (signed long int)onum);
                          }

                          else
                            if(cop == "NUMLT")
                            {
                              signed long int return_value_cbstrmktime_12;
                              return_value_cbstrmktime_12=cbstrmktime(tval);
                              hit = (signed int)(return_value_cbstrmktime_12 < (signed long int)onum);
                            }

                            else
                              if(cop == "NUMLE")
                              {
                                signed long int return_value_cbstrmktime_13;
                                return_value_cbstrmktime_13=cbstrmktime(tval);
                                hit = (signed int)(return_value_cbstrmktime_13 <= (signed long int)onum);
                              }

                              else
                                if(cop == "NUMBT")
                                  hit=est_check_numbt(tval, oval);

                                else
                                  if(cop == "[DUMMY]")
                                    hit = 1;

                                  else
                                    hit = 0;
  free((void *)cval);
  return sign != 0 ? hit : (signed int)!(hit != 0);
}

// est_match_crypt
// file estraier.c line 4105
signed int est_match_crypt(const char *key, const char *hash)
{
  char *khash;
  signed int rv;
  khash=est_make_crypt(key);
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(khash, hash);
  rv = (signed int)!(return_value_strcmp_1 != 0);
  free((void *)khash);
  return rv;
}

// est_memory_usage
// file estraier.c line 5725
double est_memory_usage(void)
{
  return 0.0;
}

// est_metascore_compare_by_id_asc
// file estraier.c line 8168
static signed int est_metascore_compare_by_id_asc(const void *ap, const void *bp)
{
  return ((struct anonymous_32 *)ap)->id - ((struct anonymous_32 *)bp)->id;
}

// est_metascore_compare_by_id_desc
// file estraier.c line 8178
static signed int est_metascore_compare_by_id_desc(const void *ap, const void *bp)
{
  return ((struct anonymous_32 *)bp)->id - ((struct anonymous_32 *)ap)->id;
}

// est_metascore_compare_by_num_asc
// file estraier.c line 8228
static signed int est_metascore_compare_by_num_asc(const void *ap, const void *bp)
{
  return (signed int)((signed long int)((struct anonymous_32 *)ap)->value - (signed long int)((struct anonymous_32 *)bp)->value);
}

// est_metascore_compare_by_num_desc
// file estraier.c line 8238
static signed int est_metascore_compare_by_num_desc(const void *ap, const void *bp)
{
  return (signed int)((signed long int)((struct anonymous_32 *)bp)->value - (signed long int)((struct anonymous_32 *)ap)->value);
}

// est_metascore_compare_by_score_asc
// file estraier.c line 8188
static signed int est_metascore_compare_by_score_asc(const void *ap, const void *bp)
{
  return ((struct anonymous_32 *)ap)->score - ((struct anonymous_32 *)bp)->score;
}

// est_metascore_compare_by_score_desc
// file estraier.c line 8198
static signed int est_metascore_compare_by_score_desc(const void *ap, const void *bp)
{
  return ((struct anonymous_32 *)bp)->score - ((struct anonymous_32 *)ap)->score;
}

// est_metascore_compare_by_str_asc
// file estraier.c line 8208
static signed int est_metascore_compare_by_str_asc(const void *ap, const void *bp)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(((struct anonymous_32 *)ap)->value, ((struct anonymous_32 *)bp)->value);
  return return_value_strcmp_1;
}

// est_metascore_compare_by_str_desc
// file estraier.c line 8218
static signed int est_metascore_compare_by_str_desc(const void *ap, const void *bp)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(((struct anonymous_32 *)bp)->value, ((struct anonymous_32 *)ap)->value);
  return return_value_strcmp_1;
}

// est_mkdir
// file estraier.c line 5533
signed int est_mkdir(const char *path)
{
  signed int return_value_mkdir_1;
  return_value_mkdir_1=mkdir(path, (unsigned int)00755);
  return return_value_mkdir_1 == 0 ? 1 : 0;
}

// est_mtdb_add_attr_index
// file estmtdb.c line 123
signed int est_mtdb_add_attr_index(struct anonymous_12 *db, const char *name, signed int type)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_add_attr_index(db->db, name, type);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_add_meta
// file estmtdb.c line 449
void est_mtdb_add_meta(struct anonymous_12 *db, const char *name, const char *value)
{
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock_1 == 0))
  {
    est_db_add_meta(db->db, name, value);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_add_pseudo_index
// file estmtdb.c line 370
signed int est_mtdb_add_pseudo_index(struct anonymous_12 *db, const char *path)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_add_pseudo_index(db->db, path);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_attr_index_exprs
// file estmtdb.c line 744
struct anonymous_6 * est_mtdb_attr_index_exprs(struct anonymous_12 *db)
{
  struct anonymous_6 *rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return ((struct anonymous_6 *)NULL);

  else
  {
    rv=est_db_attr_index_exprs(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_cache_num
// file estmtdb.c line 646
signed int est_mtdb_cache_num(struct anonymous_12 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_cache_num(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_cache_usage
// file estmtdb.c line 768
double est_mtdb_cache_usage(struct anonymous_12 *db)
{
  if(!(db->db->flsflag == 0))
    return 1.0;

  else
    return (double)db->db->icsiz / (double)db->db->icmax;
}

// est_mtdb_charge_rescc
// file estmtdb.c line 713
void est_mtdb_charge_rescc(struct anonymous_12 *db, signed int max)
{
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock_1 == 0))
  {
    est_db_charge_rescc(db->db, max);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_check_option
// file estmtdb.c line 396
signed int est_mtdb_check_option(struct anonymous_12 *db, signed int option)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return -1;

  else
  {
    rv=est_db_check_option(db->db, option);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_close
// file estmtdb.c line 82
signed int est_mtdb_close(struct anonymous_12 *db, signed int *ecp)
{
  signed int err;
  signed int return_value_est_global_lock_1;
  return_value_est_global_lock_1=est_global_lock();
  if(return_value_est_global_lock_1 == 0)
  {
    *ecp = 3;
    return 0;
  }

  else
  {
    err = 0;
    cbmapout(est_global_db_names, db->path, -1);
    pthread_mutex_destroy(&db->mutex);
    free((void *)db->path);
    signed int return_value_est_db_close_2;
    return_value_est_db_close_2=est_db_close(db->db, ecp);
    if(return_value_est_db_close_2 == 0)
      err = 1;

    free((void *)db);
    est_global_unlock();
    return err != 0 ? 0 : 1;
  }
}

// est_mtdb_doc_num
// file estmtdb.c line 255
signed int est_mtdb_doc_num(struct anonymous_12 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_doc_num(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_edit_doc
// file estmtdb.c line 200
signed int est_mtdb_edit_doc(struct anonymous_12 *db, struct anonymous_14 *doc)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_edit_doc(db->db, doc);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_error
// file estmtdb.c line 101
signed int est_mtdb_error(struct anonymous_12 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 3;

  else
  {
    rv=est_db_error(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_etch_doc
// file estmtdb.c line 480
struct anonymous_5 * est_mtdb_etch_doc(struct anonymous_12 *db, struct anonymous_14 *doc, signed int max)
{
  struct anonymous_5 *rv;
  struct anonymous_5 *return_value_est_db_etch_doc_1;
  struct anonymous_5 *return_value_cbmapopenex_2;
  if(db == ((struct anonymous_12 *)NULL))
  {
    return_value_est_db_etch_doc_1=est_db_etch_doc((struct anonymous_0 *)(void *)0, doc, max);
    return return_value_est_db_etch_doc_1;
  }

  else
  {
    signed int return_value_est_mtdb_lock_3;
    return_value_est_mtdb_lock_3=est_mtdb_lock(db);
    if(return_value_est_mtdb_lock_3 == 0)
    {
      return_value_cbmapopenex_2=cbmapopenex(1);
      return return_value_cbmapopenex_2;
    }

    else
    {
      rv=est_db_etch_doc(db->db, doc, max);
      est_mtdb_unlock(db);
      return rv;
    }
  }
}

// est_mtdb_fatal
// file estmtdb.c line 112
signed int est_mtdb_fatal(struct anonymous_12 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_fatal(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_fill_key_cache
// file estmtdb.c line 686
void est_mtdb_fill_key_cache(struct anonymous_12 *db)
{
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock_1 == 0))
  {
    est_db_fill_key_cache(db->db);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_flush
// file estmtdb.c line 134
signed int est_mtdb_flush(struct anonymous_12 *db, signed int max)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_flush(db->db, max);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_get_doc
// file estmtdb.c line 211
struct anonymous_14 * est_mtdb_get_doc(struct anonymous_12 *db, signed int id, signed int options)
{
  struct anonymous_14 *rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return (struct anonymous_14 *)(void *)0;

  else
  {
    rv=est_db_get_doc(db->db, id, options);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_get_doc_attr
// file estmtdb.c line 222
char * est_mtdb_get_doc_attr(struct anonymous_12 *db, signed int id, const char *name)
{
  char *rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return (char *)(void *)0;

  else
  {
    rv=est_db_get_doc_attr(db->db, id, name);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_get_doc_entity
// file estmtdb.c line 429
char * est_mtdb_get_doc_entity(struct anonymous_12 *db, signed int id, signed int *sp)
{
  char *rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return ((char *)NULL);

  else
  {
    rv=est_db_get_doc_entity(db->db, id, sp);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_get_keywords
// file estmtdb.c line 514
struct anonymous_5 * est_mtdb_get_keywords(struct anonymous_12 *db, signed int id)
{
  struct anonymous_5 *rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return ((struct anonymous_5 *)NULL);

  else
  {
    rv=est_db_get_keywords(db->db, id);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_inode
// file estmtdb.c line 407
signed int est_mtdb_inode(struct anonymous_12 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return -1;

  else
  {
    rv=est_db_inode(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_interrupt
// file estmtdb.c line 755
void est_mtdb_interrupt(struct anonymous_12 *db)
{
  est_db_interrupt(db->db);
}

// est_mtdb_iter_init
// file estmtdb.c line 536
signed int est_mtdb_iter_init(struct anonymous_12 *db, const char *prev)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_iter_init(db->db, prev);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_iter_next
// file estmtdb.c line 547
signed int est_mtdb_iter_next(struct anonymous_12 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return -1;

  else
  {
    rv=est_db_iter_next(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_keyword_iter_init
// file estmtdb.c line 602
signed int est_mtdb_keyword_iter_init(struct anonymous_12 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_keyword_iter_init(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_keyword_iter_next
// file estmtdb.c line 613
char * est_mtdb_keyword_iter_next(struct anonymous_12 *db)
{
  char *rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return (char *)(void *)0;

  else
  {
    rv=est_db_keyword_iter_next(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_keyword_num
// file estmtdb.c line 591
signed int est_mtdb_keyword_num(struct anonymous_12 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_keyword_num(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_keyword_rec_size
// file estmtdb.c line 624
signed int est_mtdb_keyword_rec_size(struct anonymous_12 *db, const char *word)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_keyword_rec_size(db->db, word);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_keyword_search
// file estmtdb.c line 635
signed int * est_mtdb_keyword_search(struct anonymous_12 *db, const char *word, signed int *nump)
{
  signed int *rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return (signed int *)(void *)0;

  else
  {
    rv=est_db_keyword_search(db->db, word, nump);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_list_rescc
// file estmtdb.c line 722
struct anonymous_6 * est_mtdb_list_rescc(struct anonymous_12 *db)
{
  struct anonymous_6 *rv;
  signed int return_value_est_mtdb_lock_2;
  return_value_est_mtdb_lock_2=est_mtdb_lock(db);
  struct anonymous_6 *return_value_cblistopen_1;
  if(return_value_est_mtdb_lock_2 == 0)
  {
    return_value_cblistopen_1=cblistopen();
    return return_value_cblistopen_1;
  }

  else
  {
    rv=est_db_list_rescc(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_lock
// file estmtdb.c line 796
static signed int est_mtdb_lock(struct anonymous_12 *db)
{
  if(!(dpisreentrant == 0))
  {
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&db->mutex);
    if(!(return_value_pthread_mutex_lock_1 == 0))
    {
      est_db_set_ecode(db->db, 3);
      return 0;
    }

    return 1;
  }

  signed int return_value_pthread_mutex_lock_2;
  return_value_pthread_mutex_lock_2=pthread_mutex_lock(&est_global_mutex);
  if(!(return_value_pthread_mutex_lock_2 == 0))
  {
    est_db_set_ecode(db->db, 3);
    return 0;
  }

  else
    return 1;
}

// est_mtdb_measure_doc
// file estmtdb.c line 525
signed int est_mtdb_measure_doc(struct anonymous_12 *db, signed int id, signed int parts)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_measure_doc(db->db, id, parts);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_merge
// file estmtdb.c line 167
signed int est_mtdb_merge(struct anonymous_12 *db, const char *name, signed int options)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_merge(db->db, name, options);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_meta
// file estmtdb.c line 469
char * est_mtdb_meta(struct anonymous_12 *db, const char *name)
{
  char *rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return (char *)(void *)0;

  else
  {
    rv=est_db_meta(db->db, name);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_meta_names
// file estmtdb.c line 458
struct anonymous_6 * est_mtdb_meta_names(struct anonymous_12 *db)
{
  struct anonymous_6 *rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return (struct anonymous_6 *)(void *)0;

  else
  {
    rv=est_db_meta_names(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_name
// file estmtdb.c line 244
const char * est_mtdb_name(struct anonymous_12 *db)
{
  const char *rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return "";

  else
  {
    rv=est_db_name(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_open
// file estmtdb.c line 43
struct anonymous_12 * est_mtdb_open(const char *name, signed int omode, signed int *ecp)
{
  struct anonymous_12 *mtdb;
  struct anonymous_0 *db;
  char *path;
  signed int return_value_est_global_lock_1;
  return_value_est_global_lock_1=est_global_lock();
  if(return_value_est_global_lock_1 == 0)
  {
    *ecp = 3;
    return (struct anonymous_12 *)(void *)0;
  }

  else
  {
    if(est_global_db_names == ((struct anonymous_5 *)NULL))
    {
      est_global_db_names=cbmapopenex(31);
      cbglobalgc((void *)est_global_db_names, (void (*)(void *))cbmapclose);
    }

    path=est_realpath(name);
    const char *return_value_cbmapget_2;
    return_value_cbmapget_2=cbmapget(est_global_db_names, path, -1, (signed int *)(void *)0);
    if(!(return_value_cbmapget_2 == ((const char *)NULL)))
    {
      free((void *)path);
      *ecp = 2;
      est_global_unlock();
      return (struct anonymous_12 *)(void *)0;
    }

    else
    {
      void *return_value_cbmalloc_3;
      return_value_cbmalloc_3=cbmalloc(sizeof(struct anonymous_12) /*56ul*/ );
      mtdb = (struct anonymous_12 *)return_value_cbmalloc_3;
      db=est_db_open(name, omode, ecp);
      if(db == ((struct anonymous_0 *)NULL))
      {
        free((void *)mtdb);
        free((void *)path);
        est_global_unlock();
        return (struct anonymous_12 *)(void *)0;
      }

      else
      {
        free((void *)path);
        path=est_realpath(name);
        cbmapput(est_global_db_names, path, -1, "", 0, 0);
        mtdb->db = db;
        mtdb->path = path;
        pthread_mutex_init(&mtdb->mutex, (const union anonymous_13 *)(void *)0);
        est_global_unlock();
        return mtdb;
      }
    }
  }
}

// est_mtdb_optimize
// file estmtdb.c line 156
signed int est_mtdb_optimize(struct anonymous_12 *db, signed int options)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_optimize(db->db, options);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_out_doc
// file estmtdb.c line 189
signed int est_mtdb_out_doc(struct anonymous_12 *db, signed int id, signed int options)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_out_doc(db->db, id, options);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_out_keywords
// file estmtdb.c line 503
signed int est_mtdb_out_keywords(struct anonymous_12 *db, signed int id)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_out_keywords(db->db, id);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_pseudo_doc_num
// file estmtdb.c line 733
signed int est_mtdb_pseudo_doc_num(struct anonymous_12 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_pseudo_doc_num(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_put_doc
// file estmtdb.c line 178
signed int est_mtdb_put_doc(struct anonymous_12 *db, struct anonymous_14 *doc, signed int options)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_put_doc(db->db, doc, options);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_put_keywords
// file estmtdb.c line 492
signed int est_mtdb_put_keywords(struct anonymous_12 *db, signed int id, struct anonymous_5 *kwords, double weight)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_put_keywords(db->db, id, kwords, weight);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_refresh_rescc
// file estmtdb.c line 704
void est_mtdb_refresh_rescc(struct anonymous_12 *db)
{
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock_1 == 0))
  {
    est_db_refresh_rescc(db->db);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_scan_doc
// file estmtdb.c line 350
signed int est_mtdb_scan_doc(struct anonymous_12 *db, struct anonymous_14 *doc, struct anonymous_15 *cond)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_scan_doc(db->db, doc, cond);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_search
// file estmtdb.c line 288
signed int * est_mtdb_search(struct anonymous_12 *db, struct anonymous_15 *cond, signed int *nump, struct anonymous_5 *hints)
{
  signed int *rv;
  signed int return_value_est_mtdb_lock_2;
  return_value_est_mtdb_lock_2=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_2 == 0)
  {
    est_db_set_ecode(db->db, 3);
    cbmapput(hints, "", 0, "0", -1, 1);
    *nump = 0;
    void *return_value_cbmalloc_1;
    return_value_cbmalloc_1=cbmalloc((unsigned long int)1);
    return (signed int *)return_value_cbmalloc_1;
  }

  rv=est_db_search(db->db, cond, nump, hints);
  est_mtdb_unlock(db);
  return rv;
}

// est_mtdb_search_meta
// file estmtdb.c line 304
signed int * est_mtdb_search_meta(struct anonymous_12 **dbs, signed int dbnum, struct anonymous_15 *cond, signed int *nump, struct anonymous_5 *hints)
{
  struct anonymous_0 **cdbs;
  struct anonymous_5 *umap;
  const char *kbuf;
  signed int i;
  signed int *rv;
  void *return_value_cbmalloc_1;
  return_value_cbmalloc_1=cbmalloc((unsigned long int)dbnum * sizeof(struct anonymous_0 *) /*8ul*/  + (unsigned long int)1);
  cdbs = (struct anonymous_0 **)return_value_cbmalloc_1;
  signed int return_value_est_mtdb_lock_3;
  if(!(dpisreentrant == 0))
  {
    umap=cbmapopenex(dbnum + 1);
    i = 0;
    for( ; !(i >= dbnum); i = i + 1)
    {
      const char *return_value_cbmapget_4;
      return_value_cbmapget_4=cbmapget(umap, (char *)&dbs[(signed long int)i], (signed int)sizeof(struct anonymous_0 *) /*8ul*/ , (signed int *)(void *)0);
      if(return_value_cbmapget_4 == ((const char *)NULL))
      {
        return_value_est_mtdb_lock_3=est_mtdb_lock(dbs[(signed long int)i]);
        if(return_value_est_mtdb_lock_3 == 0)
        {
          do
          {
            i = i - 1;
            if(!(i >= 0))
              break;

            est_mtdb_unlock(dbs[(signed long int)i]);
          }
          while((_Bool)1);
          free((void *)cdbs);
          est_db_set_ecode(cdbs[(signed long int)i], 3);
          cbmapput(hints, "", 0, "0", -1, 1);
          *nump = 0;
          void *return_value_cbmalloc_2;
          return_value_cbmalloc_2=cbmalloc((unsigned long int)1);
          return (signed int *)return_value_cbmalloc_2;
        }

      }

      cbmapput(umap, (char *)&dbs[(signed long int)i], (signed int)sizeof(struct anonymous_0 *) /*8ul*/ , "", 0, 0);
      cdbs[(signed long int)i] = dbs[(signed long int)i]->db;
    }
    rv=est_db_search_meta(cdbs, dbnum, cond, nump, hints);
    cbmapiterinit(umap);
    do
    {
      kbuf=cbmapiternext(umap, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      est_mtdb_unlock(*((struct anonymous_12 **)kbuf));
    }
    while((_Bool)1);
    cbmapclose(umap);
  }

  else
  {
    signed int return_value_pthread_mutex_lock_6;
    return_value_pthread_mutex_lock_6=pthread_mutex_lock(&est_global_mutex);
    if(!(return_value_pthread_mutex_lock_6 == 0))
    {
      *nump = 0;
      void *return_value_cbmalloc_5;
      return_value_cbmalloc_5=cbmalloc((unsigned long int)1);
      return (signed int *)return_value_cbmalloc_5;
    }

    i = 0;
    for( ; !(i >= dbnum); i = i + 1)
      cdbs[(signed long int)i] = dbs[(signed long int)i]->db;
    rv=est_db_search_meta(cdbs, dbnum, cond, nump, hints);
    pthread_mutex_unlock(&est_global_mutex);
  }
  free((void *)cdbs);
  return rv;
}

// est_mtdb_set_cache_size
// file estmtdb.c line 361
void est_mtdb_set_cache_size(struct anonymous_12 *db, unsigned long int size, signed int anum, signed int tnum, signed int rnum)
{
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock_1 == 0))
  {
    est_db_set_cache_size(db->db, size, anum, tnum, rnum);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_set_dfdb
// file estmtdb.c line 695
void est_mtdb_set_dfdb(struct anonymous_12 *db, struct anonymous_1 *dfdb)
{
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock_1 == 0))
  {
    est_db_set_dfdb(db->db, dfdb);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_set_doc_entity
// file estmtdb.c line 418
signed int est_mtdb_set_doc_entity(struct anonymous_12 *db, signed int id, const char *ptr, signed int size)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_set_doc_entity(db->db, id, ptr, size);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_set_ecode
// file estmtdb.c line 387
void est_mtdb_set_ecode(struct anonymous_12 *db, signed int ecode)
{
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock_1 == 0))
  {
    est_db_set_ecode(db->db, ecode);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_set_informer
// file estmtdb.c line 677
void est_mtdb_set_informer(struct anonymous_12 *db, void (*func)(const char *, void *), void *opaque)
{
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock_1 == 0))
  {
    est_db_set_informer(db->db, func, opaque);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_set_special_cache
// file estmtdb.c line 668
void est_mtdb_set_special_cache(struct anonymous_12 *db, const char *name, signed int num)
{
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock_1 == 0))
  {
    est_db_set_special_cache(db->db, name, num);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_set_wildmax
// file estmtdb.c line 440
void est_mtdb_set_wildmax(struct anonymous_12 *db, signed int num)
{
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock_1 == 0))
  {
    est_db_set_wildmax(db->db, num);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_size
// file estmtdb.c line 277
double est_mtdb_size(struct anonymous_12 *db)
{
  double rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0.0;

  else
  {
    rv=est_db_size(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_sync
// file estmtdb.c line 145
signed int est_mtdb_sync(struct anonymous_12 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_sync(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_unlock
// file estmtdb.c line 815
static void est_mtdb_unlock(struct anonymous_12 *db)
{
  if(!(dpisreentrant == 0))
    pthread_mutex_unlock(&db->mutex);

  else
    pthread_mutex_unlock(&est_global_mutex);
}

// est_mtdb_uri_to_id
// file estmtdb.c line 233
signed int est_mtdb_uri_to_id(struct anonymous_12 *db, const char *uri)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return -1;

  else
  {
    rv=est_db_uri_to_id(db->db, uri);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_used_cache_size
// file estmtdb.c line 657
signed int est_mtdb_used_cache_size(struct anonymous_12 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_used_cache_size(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_word_iter_init
// file estmtdb.c line 558
signed int est_mtdb_word_iter_init(struct anonymous_12 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_word_iter_init(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_word_iter_next
// file estmtdb.c line 569
char * est_mtdb_word_iter_next(struct anonymous_12 *db)
{
  char *rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return (char *)(void *)0;

  else
  {
    rv=est_db_word_iter_next(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_word_num
// file estmtdb.c line 266
signed int est_mtdb_word_num(struct anonymous_12 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_word_num(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_word_rec_size
// file estmtdb.c line 580
signed int est_mtdb_word_rec_size(struct anonymous_12 *db, const char *word)
{
  signed int rv;
  signed int return_value_est_mtdb_lock_1;
  return_value_est_mtdb_lock_1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock_1 == 0)
    return 0;

  else
  {
    rv=est_db_word_rec_size(db->db, word);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_narrow_scores
// file estraier.c line 9386
static signed int est_narrow_scores(struct anonymous_0 *db, const struct anonymous_6 *attrs, signed int ign, const char *order, const char *distinct, struct anonymous_8 *scores, signed int snum, signed int limit, signed int *restp, struct anonymous_5 *ordattrs)
{
  struct anonymous_16 *list;
  struct anonymous_7 *attridx;
  struct anonymous_5 *umap;
  const char *otype;
  const char *cbuf;
  const char *ibuf;
  const char *lbuf;
  char *oname;
  char *wp;
  char *mbuf;
  char *vbuf;
  signed int i;
  signed int j;
  signed int k;
  signed int ci;
  signed int oi;
  signed int anum;
  signed int done;
  signed int mixed;
  signed int nnum;
  signed int csiz;
  signed int msiz;
  signed int miss;
  signed int vsiz;
  signed int num;
  signed int isiz;
  signed int lsiz;
  signed int hit;
  signed int onlen;
  signed int dnlen;
  signed long int tval;
  *restp = 0;
  ci = -1;
  oi = -1;
  oname = (char *)(void *)0;
  otype = (const char *)(void *)0;
  char *tmp_post_1;
  if(!(order == ((const char *)NULL)))
  {
    oname=cbmemdup(order, -1);
    cbstrtrim(oname);
    otype = "STRA";
    wp=strchr(oname, 32);
    if(!(wp == ((char *)NULL)))
    {
      tmp_post_1 = wp;
      wp = wp + 1l;
      *tmp_post_1 = (char)0;
      for( ; (signed int)*wp == 32; wp = wp + 1l)
        ;
      otype = wp;
    }

  }

  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_11;
  signed int tmp_post_15;
  _Bool tmp_if_expr_22;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_19;
  signed int tmp_post_21;
  if(!(attrs == ((const struct anonymous_6 *)NULL)))
  {
    list=est_make_cattr_list(attrs, &anum);
    signed int return_value_cbmaprnum_12;
    return_value_cbmaprnum_12=cbmaprnum(db->aidxs);
    if(return_value_cbmaprnum_12 >= 1)
    {
      done = 1;
      mixed = 0;
      i = 0;
      for( ; !(i >= anum); i = i + 1)
        if(!(i == ign))
        {
          const char *return_value_cbmapget_2;
          return_value_cbmapget_2=cbmapget(db->aidxs, (list + (signed long int)i)->name, (list + (signed long int)i)->nsiz, (signed int *)(void *)0);
          attridx = (struct anonymous_7 *)return_value_cbmapget_2;
          if(attridx == ((struct anonymous_7 *)NULL))
            tmp_if_expr_10 = (_Bool)1;

          else
          {
            if(attridx->type == 2)
              tmp_if_expr_3 = (list + (signed long int)i)->cop != "NUMEQ" ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_3 = (_Bool)0;
            if(tmp_if_expr_3)
              tmp_if_expr_4 = (list + (signed long int)i)->cop != "NUMNE" ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_4 = (_Bool)0;
            if(tmp_if_expr_4)
              tmp_if_expr_5 = (list + (signed long int)i)->cop != "NUMGT" ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_5 = (_Bool)0;
            if(tmp_if_expr_5)
              tmp_if_expr_6 = (list + (signed long int)i)->cop != "NUMGE" ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_6 = (_Bool)0;
            if(tmp_if_expr_6)
              tmp_if_expr_7 = (list + (signed long int)i)->cop != "NUMLT" ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_7 = (_Bool)0;
            if(tmp_if_expr_7)
              tmp_if_expr_8 = (list + (signed long int)i)->cop != "NUMLE" ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_8 = (_Bool)0;
            if(tmp_if_expr_8)
              tmp_if_expr_9 = (list + (signed long int)i)->cop != "NUMBT" ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_9 = (_Bool)0;
            tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_10)
            tmp_if_expr_11 = (_Bool)1;

          else
            tmp_if_expr_11 = (attridx->type != 0 ? (snum < 256 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_11)
            done = 0;

          else
          {
            if(attridx->type == 1 || attridx->type == 2)
            {
              snum=est_aidx_attr_narrow((struct anonymous_4 *)attridx->db, db->pdocs, (list + (signed long int)i)->cop, (list + (signed long int)i)->sign, (list + (signed long int)i)->val, (list + (signed long int)i)->vsiz, (list + (signed long int)i)->sval, (list + (signed long int)i)->ssiz, (list + (signed long int)i)->regex, (signed int)(list + (signed long int)i)->num, scores, snum);
              mixed = 1;
              goto __CPROVER_DUMP_L27;
            }

            if(order == ((const char *)NULL) && i == anum + -1 && !(done == 0) && !(mixed == 0))
            {
              qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_score_desc);
              mixed = 0;
            }

            snum=est_aidx_seq_narrow((struct anonymous_1 *)attridx->db, db->pdocs, (list + (signed long int)i)->cop, (list + (signed long int)i)->sign, (list + (signed long int)i)->val, (list + (signed long int)i)->vsiz, (list + (signed long int)i)->sval, (list + (signed long int)i)->ssiz, (list + (signed long int)i)->regex, (signed int)(list + (signed long int)i)->num, scores, snum, done != 0 && i == anum - 1 ? limit : 0x7fffffff, restp);

          __CPROVER_DUMP_L27:
            ;
            (list + (signed long int)i)->cop = "[DUMMY]";
          }
        }

      if(order == ((const char *)NULL) && !(mixed == 0))
        qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_score_desc);

    }

    else
      done = 0;
    if(!(db->spacc == ((struct anonymous_5 *)NULL)))
    {
      i = 0;
      for( ; !(i >= anum); i = i + 1)
      {
        signed int return_value_strcmp_13;
        return_value_strcmp_13=strcmp((list + (signed long int)i)->name, db->scname);
        if(return_value_strcmp_13 == 0)
        {
          ci = i;
          break;
        }

      }
    }

    if(!(oname == ((char *)NULL)))
    {
      i = 0;
      for( ; !(i >= anum); i = i + 1)
      {
        signed int return_value_strcmp_14;
        return_value_strcmp_14=strcmp((list + (signed long int)i)->name, oname);
        if(return_value_strcmp_14 == 0)
        {
          oi = i;
          break;
        }

      }
    }

    if(done == 0)
    {
      nnum = 0;
      i = 0;
      for( ; !(i >= snum); i = i + 1)
      {
        if(nnum >= limit)
        {
          *restp = snum - i;
          break;
        }

        (scores + (signed long int)i)->value = (char *)(void *)0;
        if(ci >= 0)
        {
          cbuf=cbmapget(db->spacc, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , &csiz);
          if(!(cbuf == ((const char *)NULL)))
            cbmapmove(db->spacc, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , 0);

        }

        else
        {
          cbuf = (const char *)(void *)0;
          csiz = 0;
        }
        mbuf = (char *)(void *)0;
        if((scores + (signed long int)i)->id >= 2000000001)
        {
          tmp_post_15 = nnum;
          nnum = nnum + 1;
          scores[(signed long int)tmp_post_15] = scores[(signed long int)i];
        }

        else
        {
          if(anum == 1 && !(cbuf == ((const char *)NULL)))
            tmp_if_expr_22 = (_Bool)1;

          else
          {
            mbuf=est_crget(db->attrdb, db->zmode, (scores + (signed long int)i)->id, &msiz);
            tmp_if_expr_22 = mbuf != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_22)
          {
            miss = 0;
            j = 0;
            for( ; miss == 0 && !(j >= anum); j = j + 1)
              if((list + (signed long int)j)->nsiz >= 1)
              {
                if(!((list + (signed long int)j)->nlist == ((struct anonymous_6 *)NULL)))
                {
                  hit = 0;
                  k = 0;
                  for( ; !(k >= (list + (signed long int)j)->nlist->num); k = k + 1)
                  {
                    lsiz = ((list + (signed long int)j)->nlist->array + (signed long int)((list + (signed long int)j)->nlist->start + k))->dsize;
                    lbuf = (const char *)((list + (signed long int)j)->nlist->array + (signed long int)((list + (signed long int)j)->nlist->start + k))->dptr;
                    if(lsiz >= 1)
                    {
                      vbuf=cbmaploadone(mbuf, msiz, lbuf, lsiz, &vsiz);
                      if(!(vbuf == ((char *)NULL)))
                      {
                        signed int return_value_est_match_attr_16;
                        return_value_est_match_attr_16=est_match_attr(vbuf, vsiz, (list + (signed long int)j)->cop, (list + (signed long int)j)->sign, (list + (signed long int)j)->val, (list + (signed long int)j)->vsiz, (list + (signed long int)j)->sval, (list + (signed long int)j)->ssiz, (list + (signed long int)j)->regex, (signed int)(list + (signed long int)j)->num);
                        if(!(return_value_est_match_attr_16 == 0))
                        {
                          hit = 1;
                          free((void *)vbuf);
                          break;
                        }

                        free((void *)vbuf);
                      }

                    }

                  }
                  if(hit == 0)
                    miss = 1;

                  vbuf = (char *)(void *)0;
                }

                else
                {
                  if(!(mbuf == ((char *)NULL)))
                    vbuf=cbmaploadone(mbuf, msiz, (list + (signed long int)j)->name, (list + (signed long int)j)->nsiz, &vsiz);

                  else
                  {
                    if(!(csiz == 1))
                      tmp_if_expr_17 = (_Bool)1;

                    else
                      tmp_if_expr_17 = (signed int)cbuf[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr_17)
                    {
                      vbuf=cbmemdup(cbuf, csiz);
                      vsiz = csiz;
                    }

                    else
                      vbuf = (char *)(void *)0;
                  }
                  if((signed int)*(list + (signed long int)j)->oper == 0)
                  {
                    if(vbuf == ((char *)NULL))
                      miss = 1;

                  }

                  else
                  {
                    if(vbuf == ((char *)NULL))
                    {
                      vbuf=cbmemdup("", 0);
                      vsiz = 0;
                    }

                    signed int return_value_est_match_attr_18;
                    return_value_est_match_attr_18=est_match_attr(vbuf, vsiz, (list + (signed long int)j)->cop, (list + (signed long int)j)->sign, (list + (signed long int)j)->val, (list + (signed long int)j)->vsiz, (list + (signed long int)j)->sval, (list + (signed long int)j)->ssiz, (list + (signed long int)j)->regex, (signed int)(list + (signed long int)j)->num);
                    if(return_value_est_match_attr_18 == 0)
                      miss = 1;

                  }
                }
                if(cbuf == ((const char *)NULL) && j == ci)
                {
                  if(!(vbuf == ((char *)NULL)))
                    cbmapput(db->spacc, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, 0);

                  else
                    cbmapput(db->spacc, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , "", 1, 0);
                  signed int return_value_cbmaprnum_20;
                  return_value_cbmaprnum_20=cbmaprnum(db->spacc);
                  if(!(db->scmnum >= return_value_cbmaprnum_20))
                  {
                    num = (signed int)((double)db->scmnum * 0.1 + (double)1);
                    cbmapiterinit(db->spacc);
                    k = 0;
                    do
                    {
                      if(!(k >= num))
                      {
                        ibuf=cbmapiternext(db->spacc, &isiz);
                        tmp_if_expr_19 = ibuf != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
                      }

                      else
                        tmp_if_expr_19 = (_Bool)0;
                      if(!tmp_if_expr_19)
                        break;

                      cbmapout(db->spacc, ibuf, isiz);
                      k = k + 1;
                    }
                    while((_Bool)1);
                  }

                }

                if(j == oi)
                  (scores + (signed long int)i)->value = vbuf;

                else
                  free((void *)vbuf);
              }

            if(!(miss == 0))
              free((void *)(scores + (signed long int)i)->value);

            else
            {
              tmp_post_21 = nnum;
              nnum = nnum + 1;
              scores[(signed long int)tmp_post_21] = scores[(signed long int)i];
            }
          }

        }
        free((void *)mbuf);
      }
      snum = nnum;
    }

    else
    {
      i = 0;
      for( ; !(i >= snum); i = i + 1)
        (scores + (signed long int)i)->value = (char *)(void *)0;
    }
    est_free_cattr_list(list, anum);
  }

  else
  {
    i = 0;
    for( ; !(i >= snum); i = i + 1)
      (scores + (signed long int)i)->value = (char *)(void *)0;
  }
  signed int return_value_cbstricmp_36;
  signed int return_value_cbstricmp_35;
  signed int return_value_cbstricmp_34;
  _Bool tmp_if_expr_24;
  signed int return_value_strcmp_23;
  _Bool tmp_if_expr_27;
  signed int return_value_cbmaprnum_29;
  _Bool tmp_if_expr_28;
  signed int return_value_cbstricmp_32;
  signed int return_value_cbstricmp_31;
  signed int return_value_cbstricmp_30;
  if(!(oname == ((char *)NULL)))
  {
    signed int return_value_cbstricmp_37;
    return_value_cbstricmp_37=cbstricmp(oname, "[IDA]");
    if(return_value_cbstricmp_37 == 0)
      qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_id_asc);

    else
    {
      return_value_cbstricmp_36=cbstricmp(oname, "[IDD]");
      if(return_value_cbstricmp_36 == 0)
        qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_id_desc);

      else
      {
        return_value_cbstricmp_35=cbstricmp(oname, "[SCA]");
        if(return_value_cbstricmp_35 == 0)
          qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_score_asc);

        else
        {
          return_value_cbstricmp_34=cbstricmp(oname, "[SCD]");
          if(return_value_cbstricmp_34 == 0)
            qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_score_desc);

          else
          {
            if(!(db->spacc == ((struct anonymous_5 *)NULL)))
            {
              return_value_strcmp_23=strcmp(oname, db->scname);
              tmp_if_expr_24 = !(return_value_strcmp_23 != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_24 = (_Bool)0;
            ci = (signed int)tmp_if_expr_24;
            unsigned long int return_value_strlen_25;
            return_value_strlen_25=strlen(oname);
            onlen = (signed int)return_value_strlen_25;
            const char *return_value_cbmapget_26;
            return_value_cbmapget_26=cbmapget(db->aidxs, oname, onlen, (signed int *)(void *)0);
            attridx = (struct anonymous_7 *)return_value_cbmapget_26;
            if(!(attridx == ((struct anonymous_7 *)NULL)))
            {
              if(!(attridx->type == 0))
                attridx = (struct anonymous_7 *)(void *)0;

            }

            i = 0;
            for( ; !(i >= snum); i = i + 1)
              if((scores + (signed long int)i)->value == ((char *)NULL))
              {
                if(!(ci == 0))
                {
                  cbuf=cbmapget(db->spacc, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , &csiz);
                  if(cbuf == ((const char *)NULL))
                    goto __CPROVER_DUMP_L95;

                  cbmapmove(db->spacc, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , 0);
                  if(csiz == 1)
                    tmp_if_expr_27 = (signed int)cbuf[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_27 = (_Bool)0;
                  if(tmp_if_expr_27)
                    (scores + (signed long int)i)->value=cbmemdup("", 0);

                  else
                    (scores + (signed long int)i)->value=cbmemdup(cbuf, csiz);
                }

                else
                {

                __CPROVER_DUMP_L95:
                  ;
                  cbuf=cbmapget(ordattrs, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , &csiz);
                  if(!(cbuf == ((const char *)NULL)))
                    (scores + (signed long int)i)->value=cbmemdup(cbuf, csiz);

                  else
                    if(!(attridx == ((struct anonymous_7 *)NULL)))
                    {
                      vbuf=est_aidx_seq_get((struct anonymous_1 *)attridx->db, (scores + (signed long int)i)->id, &vsiz);
                      if(vbuf == ((char *)NULL))
                        vbuf=cbmemdup("", 0);

                      (scores + (signed long int)i)->value = vbuf;
                    }

                    else
                    {
                      mbuf=est_crget(db->attrdb, db->zmode, (scores + (signed long int)i)->id, &msiz);
                      if(!(mbuf == ((char *)NULL)))
                      {
                        vbuf=cbmaploadone(mbuf, msiz, oname, onlen, &vsiz);
                        if(!(vbuf == ((char *)NULL)))
                        {
                          if(!(ci == 0))
                            cbmapput(db->spacc, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, 0);

                          (scores + (signed long int)i)->value = vbuf;
                        }

                        else
                        {
                          if(!(ci == 0))
                            cbmapput(db->spacc, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , "", 1, 0);

                          (scores + (signed long int)i)->value=cbmemdup("", 0);
                        }
                        if(!(ci == 0))
                        {
                          return_value_cbmaprnum_29=cbmaprnum(db->spacc);
                          if(!(db->scmnum >= return_value_cbmaprnum_29))
                          {
                            num = (signed int)((double)db->scmnum * 0.1 + (double)1);
                            cbmapiterinit(db->spacc);
                            j = 0;
                            do
                            {
                              if(!(j >= num))
                              {
                                ibuf=cbmapiternext(db->spacc, &isiz);
                                tmp_if_expr_28 = ibuf != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
                              }

                              else
                                tmp_if_expr_28 = (_Bool)0;
                              if(!tmp_if_expr_28)
                                break;

                              cbmapout(db->spacc, ibuf, isiz);
                              j = j + 1;
                            }
                            while((_Bool)1);
                          }

                        }

                        free((void *)mbuf);
                      }

                      else
                        (scores + (signed long int)i)->value=cbmemdup("", 0);
                    }
                }
              }

            signed int return_value_cbstricmp_33;
            return_value_cbstricmp_33=cbstricmp(otype, "STRA");
            if(return_value_cbstricmp_33 == 0)
              qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_str_asc);

            else
            {
              return_value_cbstricmp_32=cbstricmp(otype, "STRD");
              if(return_value_cbstricmp_32 == 0)
                qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_str_desc);

              else
              {
                return_value_cbstricmp_31=cbstricmp(otype, "NUMA");
                if(return_value_cbstricmp_31 == 0)
                {
                  i = 0;
                  for( ; !(i >= snum); i = i + 1)
                  {
                    tval=cbstrmktime((scores + (signed long int)i)->value);
                    free((void *)(scores + (signed long int)i)->value);
                    (scores + (signed long int)i)->value = (char *)(void *)tval;
                  }
                  qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_num_asc);
                  i = 0;
                  for( ; !(i >= snum); i = i + 1)
                    (scores + (signed long int)i)->value = (char *)(void *)0;
                }

                else
                {
                  return_value_cbstricmp_30=cbstricmp(otype, "NUMD");
                  if(return_value_cbstricmp_30 == 0)
                  {
                    i = 0;
                    for( ; !(i >= snum); i = i + 1)
                    {
                      tval=cbstrmktime((scores + (signed long int)i)->value);
                      free((void *)(scores + (signed long int)i)->value);
                      (scores + (signed long int)i)->value = (char *)(void *)tval;
                    }
                    qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_num_desc);
                    i = 0;
                    for( ; !(i >= snum); i = i + 1)
                      (scores + (signed long int)i)->value = (char *)(void *)0;
                  }

                }
              }
            }
            i = 0;
            for( ; !(i >= snum); i = i + 1)
              free((void *)(scores + (signed long int)i)->value);
          }
        }
      }
    }
    free((void *)oname);
  }

  signed int tmp_post_41;
  if(!(distinct == ((const char *)NULL)))
  {
    if(order == ((const char *)NULL))
    {
      if(!((signed int)*distinct == 126))
        qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_score_desc);

    }

    if((signed int)*distinct == 126)
      distinct = distinct + 1l;

    unsigned long int return_value_strlen_38;
    return_value_strlen_38=strlen(distinct);
    dnlen = (signed int)return_value_strlen_38;
    umap=cbmapopenex(snum + 1);
    const char *return_value_cbmapget_39;
    return_value_cbmapget_39=cbmapget(db->aidxs, distinct, dnlen, (signed int *)(void *)0);
    attridx = (struct anonymous_7 *)return_value_cbmapget_39;
    if(!(attridx == ((struct anonymous_7 *)NULL)))
    {
      if(!(attridx->type == 0))
        attridx = (struct anonymous_7 *)(void *)0;

    }

    nnum = 0;
    i = 0;
    for( ; !(i >= snum); i = i + 1)
    {
      if((scores + (signed long int)i)->id >= 2000000001)
      {
        vbuf=est_db_get_doc_attr(db, (scores + (signed long int)i)->id, distinct);
        if(vbuf == ((char *)NULL))
          vbuf=cbmemdup("", 0);

        unsigned long int return_value_strlen_40;
        return_value_strlen_40=strlen(vbuf);
        vsiz = (signed int)return_value_strlen_40;
      }

      else
        if(!(attridx == ((struct anonymous_7 *)NULL)))
        {
          vbuf=est_aidx_seq_get((struct anonymous_1 *)attridx->db, (scores + (signed long int)i)->id, &vsiz);
          if(vbuf == ((char *)NULL))
          {
            vbuf=cbmemdup("", 0);
            vsiz = 0;
          }

        }

        else
        {
          mbuf=est_crget(db->attrdb, db->zmode, (scores + (signed long int)i)->id, &msiz);
          if(!(mbuf == ((char *)NULL)))
          {
            vbuf=cbmaploadone(mbuf, msiz, distinct, dnlen, &vsiz);
            if(vbuf == ((char *)NULL))
            {
              vbuf=cbmemdup("", 0);
              vsiz = 0;
            }

            free((void *)mbuf);
          }

          else
          {
            vbuf=cbmemdup("", 0);
            vsiz = 0;
          }
        }
      signed int return_value_cbmapput_42;
      return_value_cbmapput_42=cbmapput(umap, vbuf, vsiz, "", 0, 0);
      if(!(return_value_cbmapput_42 == 0))
      {
        tmp_post_41 = nnum;
        nnum = nnum + 1;
        scores[(signed long int)tmp_post_41] = scores[(signed long int)i];
      }

      free((void *)vbuf);
    }
    snum = nnum;
    cbmapclose(umap);
  }

  return snum;
}

// est_node_add_header
// file estnode.c line 1638
void est_node_add_header(struct anonymous_24 *node, const char *name, const char *value)
{
  const char *vbuf;
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  len = (signed int)return_value_strlen_1;
  if(!(value == ((const char *)NULL)))
  {
    vbuf=cbmapget(node->heads, name, len, (signed int *)(void *)0);
    if(!(vbuf == ((const char *)NULL)))
    {
      cbmapputcat(node->heads, name, len, ", ", 2);
      cbmapputcat(node->heads, name, len, value, -1);
    }

    else
      cbmapput(node->heads, name, len, value, -1, 0);
  }

  else
    cbmapout(node->heads, name, len);
}

// est_node_admins
// file estnode.c line 1046
const struct anonymous_6 * est_node_admins(struct anonymous_24 *node)
{
  if(!(node->admins == ((struct anonymous_6 *)NULL)))
    return node->admins;

  else
  {
    est_node_set_info(node);
    return node->admins;
  }
}

// est_node_cache_usage
// file estnode.c line 1009
double est_node_cache_usage(struct anonymous_24 *node)
{
  struct anonymous_6 *reqheads;
  struct anonymous_9 *resbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err;
  double ratio;
  err = 0;
  sprintf(url, "%s/cacheusage", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  resbody=cbdatumopen((const char *)(void *)0, -1);
  signed int return_value_est_url_shuttle_3;
  return_value_est_url_shuttle_3=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, (const char *)(void *)0, -1, &rescode, (struct anonymous_5 *)(void *)0, resbody);
  if(return_value_est_url_shuttle_3 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  double tmp_if_expr_6;
  const char *return_value_cbdatumptr_4;
  double return_value_strtod_5;
  if(!(err == 0))
    tmp_if_expr_6 = -1.0;

  else
  {
    return_value_cbdatumptr_4=cbdatumptr(resbody);
    return_value_strtod_5=strtod(return_value_cbdatumptr_4, (char ** restrict )(void *)0);
    tmp_if_expr_6 = return_value_strtod_5;
  }
  ratio = tmp_if_expr_6;
  cbdatumclose(resbody);
  cblistclose(reqheads);
  return ratio;
}

// est_node_delete
// file estnode.c line 358
void est_node_delete(struct anonymous_24 *node)
{
  cbmapclose(node->heads);
  est_node_iter_delete(node);
  if(!(node->links == ((struct anonymous_6 *)NULL)))
    cblistclose(node->links);

  if(!(node->users == ((struct anonymous_6 *)NULL)))
    cblistclose(node->users);

  if(!(node->admins == ((struct anonymous_6 *)NULL)))
    cblistclose(node->admins);

  free((void *)node->label);
  free((void *)node->name);
  free((void *)node->auth);
  free((void *)node->pxhost);
  free((void *)node->url);
  free((void *)node);
}

// est_node_doc_num
// file estnode.c line 982
signed int est_node_doc_num(struct anonymous_24 *node)
{
  if(node->dnum >= 0)
    return node->dnum;

  else
  {
    est_node_set_info(node);
    return node->dnum;
  }
}

// est_node_edit_doc
// file estnode.c line 591
signed int est_node_edit_doc(struct anonymous_24 *node, struct anonymous_14 *doc)
{
  struct anonymous_6 *reqheads;
  struct anonymous_6 *names;
  struct anonymous_9 *reqbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int i;
  signed int rescode;
  signed int err;
  signed int ksiz;
  err = 0;
  sprintf(url, "%s/edit_doc", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: text/x-estraier-draft", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  names=est_doc_attr_names(doc);
  i = 0;
  signed int return_value_cblistnum_3;
  do
  {
    return_value_cblistnum_3=cblistnum(names);
    if(i >= return_value_cblistnum_3)
      break;

    kbuf=cblistval(names, i, &ksiz);
    cbdatumcat(reqbody, kbuf, ksiz);
    cbdatumcat(reqbody, "=", 1);
    const char *return_value_est_doc_attr_4;
    return_value_est_doc_attr_4=est_doc_attr(doc, kbuf);
    cbdatumcat(reqbody, return_value_est_doc_attr_4, -1);
    cbdatumcat(reqbody, "\n", 1);
    i = i + 1;
  }
  while((_Bool)1);
  cbdatumcat(reqbody, "\n", 1);
  const char *return_value_cbdatumptr_5;
  return_value_cbdatumptr_5=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize_6;
  return_value_cbdatumsize_6=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle_7;
  return_value_est_url_shuttle_7=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr_5, return_value_cbdatumsize_6, &rescode, (struct anonymous_5 *)(void *)0, (struct anonymous_9 *)(void *)0);
  if(return_value_est_url_shuttle_7 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  cblistclose(names);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_etch_doc
// file estnode.c line 814
struct anonymous_5 * est_node_etch_doc(struct anonymous_24 *node, signed int id)
{
  struct anonymous_6 *reqheads;
  struct anonymous_9 *reqbody;
  struct anonymous_9 *resbody;
  struct anonymous_5 *kwords;
  struct anonymous_6 *lines;
  const char *kbuf;
  const char *pv;
  char url[4096l];
  char *vbuf;
  signed int i;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/etch_doc", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "id=%d", id);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr_3;
  return_value_cbdatumptr_3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize_4;
  return_value_cbdatumsize_4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle_5;
  return_value_est_url_shuttle_5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr_3, return_value_cbdatumsize_4, &rescode, (struct anonymous_5 *)(void *)0, resbody);
  if(return_value_est_url_shuttle_5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  signed int return_value_cblistnum_8;
  if(!(err == 0))
    kwords = (struct anonymous_5 *)(void *)0;

  else
  {
    kwords=cbmapopenex(31);
    const char *return_value_cbdatumptr_6;
    return_value_cbdatumptr_6=cbdatumptr(resbody);
    signed int return_value_cbdatumsize_7;
    return_value_cbdatumsize_7=cbdatumsize(resbody);
    lines=cbsplit(return_value_cbdatumptr_6, return_value_cbdatumsize_7, "\n");
    i = 0;
    do
    {
      return_value_cblistnum_8=cblistnum(lines);
      if(i >= return_value_cblistnum_8)
        break;

      kbuf=cblistval(lines, i, (signed int *)(void *)0);
      pv=strchr(kbuf, 9);
      if(!(pv == ((const char *)NULL)) && !(pv == kbuf))
        cbmapput(kwords, kbuf, (signed int)(pv - kbuf), pv + (signed long int)1, -1, 1);

      i = i + 1;
    }
    while((_Bool)1);
    cblistclose(lines);
  }
  cbdatumclose(resbody);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return kwords;
}

// est_node_etch_doc_by_uri
// file estnode.c line 868
struct anonymous_5 * est_node_etch_doc_by_uri(struct anonymous_24 *node, const char *uri)
{
  struct anonymous_6 *reqheads;
  struct anonymous_9 *reqbody;
  struct anonymous_9 *resbody;
  struct anonymous_5 *kwords;
  struct anonymous_6 *lines;
  const char *kbuf;
  const char *pv;
  char url[4096l];
  char *vbuf;
  signed int i;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/etch_doc", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "uri=%?", uri);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr_3;
  return_value_cbdatumptr_3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize_4;
  return_value_cbdatumsize_4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle_5;
  return_value_est_url_shuttle_5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr_3, return_value_cbdatumsize_4, &rescode, (struct anonymous_5 *)(void *)0, resbody);
  if(return_value_est_url_shuttle_5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  signed int return_value_cblistnum_8;
  if(!(err == 0))
    kwords = (struct anonymous_5 *)(void *)0;

  else
  {
    kwords=cbmapopenex(31);
    const char *return_value_cbdatumptr_6;
    return_value_cbdatumptr_6=cbdatumptr(resbody);
    signed int return_value_cbdatumsize_7;
    return_value_cbdatumsize_7=cbdatumsize(resbody);
    lines=cbsplit(return_value_cbdatumptr_6, return_value_cbdatumsize_7, "\n");
    i = 0;
    do
    {
      return_value_cblistnum_8=cblistnum(lines);
      if(i >= return_value_cblistnum_8)
        break;

      kbuf=cblistval(lines, i, (signed int *)(void *)0);
      pv=strchr(kbuf, 9);
      if(!(pv == ((const char *)NULL)) && !(pv == kbuf))
        cbmapput(kwords, kbuf, (signed int)(pv - kbuf), pv + (signed long int)1, -1, 1);

      i = i + 1;
    }
    while((_Bool)1);
    cblistclose(lines);
  }
  cbdatumclose(resbody);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return kwords;
}

// est_node_get_doc
// file estnode.c line 638
struct anonymous_14 * est_node_get_doc(struct anonymous_24 *node, signed int id)
{
  struct anonymous_14 *doc;
  struct anonymous_6 *reqheads;
  struct anonymous_9 *reqbody;
  struct anonymous_9 *resbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/get_doc", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "id=%d", id);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr_3;
  return_value_cbdatumptr_3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize_4;
  return_value_cbdatumsize_4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle_5;
  return_value_est_url_shuttle_5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr_3, return_value_cbdatumsize_4, &rescode, (struct anonymous_5 *)(void *)0, resbody);
  if(return_value_est_url_shuttle_5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  struct anonymous_14 *tmp_if_expr_8;
  const char *return_value_cbdatumptr_6;
  struct anonymous_14 *return_value_est_doc_new_from_draft_7;
  if(!(err == 0))
    tmp_if_expr_8 = (struct anonymous_14 *)(void *)0;

  else
  {
    return_value_cbdatumptr_6=cbdatumptr(resbody);
    return_value_est_doc_new_from_draft_7=est_doc_new_from_draft(return_value_cbdatumptr_6);
    tmp_if_expr_8 = return_value_est_doc_new_from_draft_7;
  }
  doc = tmp_if_expr_8;
  cbdatumclose(resbody);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return doc;
}

// est_node_get_doc_attr
// file estnode.c line 722
char * est_node_get_doc_attr(struct anonymous_24 *node, signed int id, const char *name)
{
  struct anonymous_6 *reqheads;
  struct anonymous_9 *reqbody;
  struct anonymous_9 *resbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/get_doc_attr", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "id=%d&attr=%?", id, name);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr_3;
  return_value_cbdatumptr_3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize_4;
  return_value_cbdatumsize_4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle_5;
  return_value_est_url_shuttle_5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr_3, return_value_cbdatumsize_4, &rescode, (struct anonymous_5 *)(void *)0, resbody);
  if(return_value_est_url_shuttle_5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  if(!(err == 0))
  {
    cbdatumclose(resbody);
    vbuf = (char *)(void *)0;
  }

  else
  {
    vbuf=cbdatumtomalloc(resbody, (signed int *)(void *)0);
    cbstrtrim(vbuf);
  }
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return vbuf;
}

// est_node_get_doc_attr_by_uri
// file estnode.c line 768
char * est_node_get_doc_attr_by_uri(struct anonymous_24 *node, const char *uri, const char *name)
{
  struct anonymous_6 *reqheads;
  struct anonymous_9 *reqbody;
  struct anonymous_9 *resbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/get_doc_attr", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "uri=%?&attr=%?", uri, name);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr_3;
  return_value_cbdatumptr_3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize_4;
  return_value_cbdatumsize_4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle_5;
  return_value_est_url_shuttle_5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr_3, return_value_cbdatumsize_4, &rescode, (struct anonymous_5 *)(void *)0, resbody);
  if(return_value_est_url_shuttle_5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  if(!(err == 0))
  {
    cbdatumclose(resbody);
    vbuf = (char *)(void *)0;
  }

  else
  {
    vbuf=cbdatumtomalloc(resbody, (signed int *)(void *)0);
    cbstrtrim(vbuf);
  }
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return vbuf;
}

// est_node_get_doc_by_uri
// file estnode.c line 680
struct anonymous_14 * est_node_get_doc_by_uri(struct anonymous_24 *node, const char *uri)
{
  struct anonymous_14 *doc;
  struct anonymous_6 *reqheads;
  struct anonymous_9 *reqbody;
  struct anonymous_9 *resbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/get_doc", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "uri=%?", uri);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr_3;
  return_value_cbdatumptr_3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize_4;
  return_value_cbdatumsize_4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle_5;
  return_value_est_url_shuttle_5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr_3, return_value_cbdatumsize_4, &rescode, (struct anonymous_5 *)(void *)0, resbody);
  if(return_value_est_url_shuttle_5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  struct anonymous_14 *tmp_if_expr_8;
  const char *return_value_cbdatumptr_6;
  struct anonymous_14 *return_value_est_doc_new_from_draft_7;
  if(!(err == 0))
    tmp_if_expr_8 = (struct anonymous_14 *)(void *)0;

  else
  {
    return_value_cbdatumptr_6=cbdatumptr(resbody);
    return_value_est_doc_new_from_draft_7=est_doc_new_from_draft(return_value_cbdatumptr_6);
    tmp_if_expr_8 = return_value_est_doc_new_from_draft_7;
  }
  doc = tmp_if_expr_8;
  cbdatumclose(resbody);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return doc;
}

// est_node_iter_delete
// file estnode.c line 2070
static void est_node_iter_delete(struct anonymous_24 *node)
{
  signed int i;
  signed int return_value_cblistnum_1;
  if(!(node->ilist == ((struct anonymous_6 *)NULL)))
  {
    i = 0;
    do
    {
      return_value_cblistnum_1=cblistnum(node->ilist);
      if(i >= return_value_cblistnum_1)
        break;

      const char *return_value_cblistval_2;
      return_value_cblistval_2=cblistval(node->ilist, i, (signed int *)(void *)0);
      est_doc_delete(*((struct anonymous_14 **)return_value_cblistval_2));
      i = i + 1;
    }
    while((_Bool)1);
    cblistclose(node->ilist);
    node->ilist = (struct anonymous_6 *)(void *)0;
  }

  free((void *)node->iprev);
  node->iprev = (char *)(void *)0;
}

// est_node_iter_init
// file estnode.c line 1614
signed int est_node_iter_init(struct anonymous_24 *node)
{
  est_node_iter_delete(node);
  signed int return_value_est_node_read_list_1;
  return_value_est_node_read_list_1=est_node_read_list(node);
  return (signed int)(return_value_est_node_read_list_1 != -1);
}

// est_node_iter_next
// file estnode.c line 1621
struct anonymous_14 * est_node_iter_next(struct anonymous_24 *node)
{
  struct anonymous_14 *doc;
  char *vbuf;
  _Bool tmp_if_expr_3;
  signed int return_value_cblistnum_2;
  if(node->ilist == ((struct anonymous_6 *)NULL))
    return (struct anonymous_14 *)(void *)0;

  else
  {
    signed int return_value_cblistnum_4;
    return_value_cblistnum_4=cblistnum(node->ilist);
    if(!(return_value_cblistnum_4 >= 1))
    {
      cblistclose(node->ilist);
      node->ilist=cblistopen();
      signed int return_value_est_node_read_list_1;
      return_value_est_node_read_list_1=est_node_read_list(node);
      if(return_value_est_node_read_list_1 == -1)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_cblistnum_2=cblistnum(node->ilist);
        tmp_if_expr_3 = return_value_cblistnum_2 < 1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        return (struct anonymous_14 *)(void *)0;

    }

    vbuf=cblistshift(node->ilist, (signed int *)(void *)0);
    doc = *((struct anonymous_14 **)vbuf);
    free((void *)vbuf);
    return doc;
  }
}

// est_node_label
// file estnode.c line 973
const char * est_node_label(struct anonymous_24 *node)
{
  if(!(node->label == ((char *)NULL)))
    return node->label;

  else
  {
    est_node_set_info(node);
    return node->label;
  }
}

// est_node_links
// file estnode.c line 1064
const struct anonymous_6 * est_node_links(struct anonymous_24 *node)
{
  if(!(node->links == ((struct anonymous_6 *)NULL)))
    return node->links;

  else
  {
    est_node_set_info(node);
    return node->links;
  }
}

// est_node_name
// file estnode.c line 964
const char * est_node_name(struct anonymous_24 *node)
{
  if(!(node->name == ((char *)NULL)))
    return node->name;

  else
  {
    est_node_set_info(node);
    return node->name;
  }
}

// est_node_new
// file estnode.c line 330
struct anonymous_24 * est_node_new(const char *url)
{
  struct anonymous_24 *node;
  void *return_value_cbmalloc_1;
  return_value_cbmalloc_1=cbmalloc(sizeof(struct anonymous_24) /*136ul*/ );
  node = (struct anonymous_24 *)return_value_cbmalloc_1;
  node->url=cbmemdup(url, -1);
  node->pxhost = (char *)(void *)0;
  node->pxport = 0;
  node->timeout = -1;
  node->auth = (char *)(void *)0;
  node->name = (char *)(void *)0;
  node->label = (char *)(void *)0;
  node->dnum = -1;
  node->wnum = -1;
  node->size = -1.0;
  node->admins = (struct anonymous_6 *)(void *)0;
  node->users = (struct anonymous_6 *)(void *)0;
  node->links = (struct anonymous_6 *)(void *)0;
  node->wwidth = 480;
  node->hwidth = 96;
  node->awidth = 96;
  node->ilist = (struct anonymous_6 *)(void *)0;
  node->iprev = (char *)(void *)0;
  node->status = 0;
  node->heads=cbmapopenex(31);
  return node;
}

// est_node_optimize
// file estnode.c line 443
signed int est_node_optimize(struct anonymous_24 *node)
{
  struct anonymous_6 *reqheads;
  struct anonymous_9 *reqbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/optimize", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr_3;
  return_value_cbdatumptr_3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize_4;
  return_value_cbdatumsize_4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle_5;
  return_value_est_url_shuttle_5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr_3, return_value_cbdatumsize_4, &rescode, (struct anonymous_5 *)(void *)0, (struct anonymous_9 *)(void *)0);
  if(return_value_est_url_shuttle_5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_out_doc
// file estnode.c line 515
signed int est_node_out_doc(struct anonymous_24 *node, signed int id)
{
  struct anonymous_6 *reqheads;
  struct anonymous_9 *reqbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/out_doc", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "id=%d", id);
  const char *return_value_cbdatumptr_3;
  return_value_cbdatumptr_3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize_4;
  return_value_cbdatumsize_4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle_5;
  return_value_est_url_shuttle_5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr_3, return_value_cbdatumsize_4, &rescode, (struct anonymous_5 *)(void *)0, (struct anonymous_9 *)(void *)0);
  if(return_value_est_url_shuttle_5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_out_doc_by_uri
// file estnode.c line 553
signed int est_node_out_doc_by_uri(struct anonymous_24 *node, const char *uri)
{
  struct anonymous_6 *reqheads;
  struct anonymous_9 *reqbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/out_doc", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "uri=%?", uri);
  const char *return_value_cbdatumptr_3;
  return_value_cbdatumptr_3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize_4;
  return_value_cbdatumsize_4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle_5;
  return_value_est_url_shuttle_5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr_3, return_value_cbdatumsize_4, &rescode, (struct anonymous_5 *)(void *)0, (struct anonymous_9 *)(void *)0);
  if(return_value_est_url_shuttle_5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_put_doc
// file estnode.c line 480
signed int est_node_put_doc(struct anonymous_24 *node, struct anonymous_14 *doc)
{
  struct anonymous_6 *reqheads;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  char *reqbody;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/put_doc", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: text/x-estraier-draft", -1);
  reqbody=est_doc_dump_draft(doc);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(reqbody);
  signed int return_value_est_url_shuttle_4;
  return_value_est_url_shuttle_4=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, reqbody, (signed int)return_value_strlen_3, &rescode, (struct anonymous_5 *)(void *)0, (struct anonymous_9 *)(void *)0);
  if(return_value_est_url_shuttle_4 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  free((void *)reqbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_read_list
// file estnode.c line 2088
static signed int est_node_read_list(struct anonymous_24 *node)
{
  struct anonymous_14 *doc;
  struct anonymous_6 *reqheads;
  struct anonymous_6 *lines;
  struct anonymous_6 *fields;
  struct anonymous_9 *reqbody;
  struct anonymous_9 *resbody;
  const char *kbuf;
  const char *id;
  const char *uri;
  char url[4096l];
  char *vbuf;
  signed int i;
  signed int rescode;
  signed int err;
  signed int ksiz;
  signed int dnum;
  err = 0;
  sprintf(url, "%s/list", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "max=%d", 256);
  if(!(node->iprev == ((char *)NULL)))
    cbdatumprintf(reqbody, "&prev=%?", node->iprev);

  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr_3;
  return_value_cbdatumptr_3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize_4;
  return_value_cbdatumsize_4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle_5;
  return_value_est_url_shuttle_5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr_3, return_value_cbdatumsize_4, &rescode, (struct anonymous_5 *)(void *)0, resbody);
  if(return_value_est_url_shuttle_5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  dnum = 0;
  signed int return_value_cblistnum_8;
  if(err == 0)
  {
    if(node->ilist == ((struct anonymous_6 *)NULL))
      node->ilist=cblistopen();

    const char *return_value_cbdatumptr_6;
    return_value_cbdatumptr_6=cbdatumptr(resbody);
    signed int return_value_cbdatumsize_7;
    return_value_cbdatumsize_7=cbdatumsize(resbody);
    lines=cbsplit(return_value_cbdatumptr_6, return_value_cbdatumsize_7, "\r\n");
    i = 0;
    do
    {
      return_value_cblistnum_8=cblistnum(lines);
      if(i >= return_value_cblistnum_8)
        break;

      kbuf=cblistval(lines, i, &ksiz);
      if(ksiz >= 1)
      {
        fields=cbsplit(kbuf, ksiz, "\t");
        signed int return_value_cblistnum_22;
        return_value_cblistnum_22=cblistnum(fields);
        if(return_value_cblistnum_22 == 14)
        {
          id=cblistval(fields, 0, (signed int *)(void *)0);
          uri=cblistval(fields, 1, (signed int *)(void *)0);
          doc=est_doc_new();
          signed int return_value_atoi_9;
          return_value_atoi_9=atoi(id);
          est_doc_set_id(doc, return_value_atoi_9);
          est_doc_add_attr(doc, "@id", id);
          est_doc_add_attr(doc, "@uri", uri);
          const char *return_value_cblistval_10;
          return_value_cblistval_10=cblistval(fields, 2, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@digest", return_value_cblistval_10);
          const char *return_value_cblistval_11;
          return_value_cblistval_11=cblistval(fields, 3, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@cdate", return_value_cblistval_11);
          const char *return_value_cblistval_12;
          return_value_cblistval_12=cblistval(fields, 4, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@mdate", return_value_cblistval_12);
          const char *return_value_cblistval_13;
          return_value_cblistval_13=cblistval(fields, 5, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@adate", return_value_cblistval_13);
          const char *return_value_cblistval_14;
          return_value_cblistval_14=cblistval(fields, 6, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@title", return_value_cblistval_14);
          const char *return_value_cblistval_15;
          return_value_cblistval_15=cblistval(fields, 7, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@author", return_value_cblistval_15);
          const char *return_value_cblistval_16;
          return_value_cblistval_16=cblistval(fields, 8, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@type", return_value_cblistval_16);
          const char *return_value_cblistval_17;
          return_value_cblistval_17=cblistval(fields, 9, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@lang", return_value_cblistval_17);
          const char *return_value_cblistval_18;
          return_value_cblistval_18=cblistval(fields, 10, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@genre", return_value_cblistval_18);
          const char *return_value_cblistval_19;
          return_value_cblistval_19=cblistval(fields, 11, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@size", return_value_cblistval_19);
          const char *return_value_cblistval_20;
          return_value_cblistval_20=cblistval(fields, 12, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@weight", return_value_cblistval_20);
          const char *return_value_cblistval_21;
          return_value_cblistval_21=cblistval(fields, 13, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@misc", return_value_cblistval_21);
          cblistpush(node->ilist, (char *)&doc, (signed int)sizeof(struct anonymous_14 *) /*8ul*/ );
          dnum = dnum + 1;
          free((void *)node->iprev);
          node->iprev=cbmemdup(uri, -1);
        }

        cblistclose(fields);
      }

      i = i + 1;
    }
    while((_Bool)1);
    cblistclose(lines);
  }

  cbdatumclose(resbody);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return err != 0 ? -1 : dnum;
}

// est_node_search
// file estnode.c line 1073
struct anonymous_17 * est_node_search(struct anonymous_24 *node, struct anonymous_15 *cond, signed int depth)
{
  struct anonymous_17 *nres;
  const struct anonymous_6 *attrs;
  struct anonymous_5 *resheads;
  struct anonymous_6 *reqheads;
  struct anonymous_9 *reqbody;
  struct anonymous_9 *resbody;
  const char *kbuf;
  const char *phrase;
  const char *order;
  const char *distinct;
  const char *cbuf;
  char buf[4096l];
  char *vbuf;
  char *ptr;
  char *pv;
  char *ep;
  signed int i;
  signed int rescode;
  signed int err;
  signed int max;
  signed int plen;
  signed int part;
  signed int end;
  err = 0;
  sprintf(buf, "%s/search", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  phrase=est_cond_phrase(cond);
  if(!(phrase == ((const char *)NULL)))
    cbdatumprintf(reqbody, "phrase=%?", phrase);

  attrs=est_cond_attrs(cond);
  signed int return_value_cblistnum_3;
  if(!(attrs == ((const struct anonymous_6 *)NULL)))
  {
    i = 0;
    do
    {
      return_value_cblistnum_3=cblistnum(attrs);
      if(i >= return_value_cblistnum_3)
        break;

      signed int return_value_cbdatumsize_4;
      return_value_cbdatumsize_4=cbdatumsize(reqbody);
      if(return_value_cbdatumsize_4 >= 1)
        cbdatumcat(reqbody, "&", 1);

      const char *return_value_cblistval_5;
      return_value_cblistval_5=cblistval(attrs, i, (signed int *)(void *)0);
      cbdatumprintf(reqbody, "attr%d=%?", i + 1, return_value_cblistval_5);
      i = i + 1;
    }
    while((_Bool)1);
  }

  max=est_cond_max(cond);
  if(max >= 0)
  {
    signed int return_value_cbdatumsize_6;
    return_value_cbdatumsize_6=cbdatumsize(reqbody);
    if(return_value_cbdatumsize_6 >= 1)
      cbdatumcat(reqbody, "&", 1);

    cbdatumprintf(reqbody, "max=%d", max);
  }

  else
  {
    signed int return_value_cbdatumsize_7;
    return_value_cbdatumsize_7=cbdatumsize(reqbody);
    if(return_value_cbdatumsize_7 >= 1)
      cbdatumcat(reqbody, "&", 1);

    cbdatumprintf(reqbody, "max=%d", 0x7fffffff / 2);
  }
  order=est_cond_order(cond);
  if(!(order == ((const char *)NULL)))
  {
    signed int return_value_cbdatumsize_8;
    return_value_cbdatumsize_8=cbdatumsize(reqbody);
    if(return_value_cbdatumsize_8 >= 1)
      cbdatumcat(reqbody, "&", 1);

    cbdatumprintf(reqbody, "order=%?", order);
  }

  signed int return_value_cbdatumsize_9;
  return_value_cbdatumsize_9=cbdatumsize(reqbody);
  if(return_value_cbdatumsize_9 >= 1)
    cbdatumcat(reqbody, "&", 1);

  signed int return_value_est_cond_options_10;
  return_value_est_cond_options_10=est_cond_options(cond);
  cbdatumprintf(reqbody, "options=%d", return_value_est_cond_options_10);
  signed int return_value_est_cond_auxiliary_11;
  return_value_est_cond_auxiliary_11=est_cond_auxiliary(cond);
  cbdatumprintf(reqbody, "&auxiliary=%d", return_value_est_cond_auxiliary_11);
  distinct=est_cond_distinct(cond);
  if(!(distinct == ((const char *)NULL)))
    cbdatumprintf(reqbody, "&distinct=%?", distinct);

  cbdatumprintf(reqbody, "&depth=%d", depth);
  cbdatumprintf(reqbody, "&wwidth=%d", node->wwidth);
  cbdatumprintf(reqbody, "&hwidth=%d", node->hwidth);
  cbdatumprintf(reqbody, "&awidth=%d", node->awidth);
  signed int return_value_est_cond_skip_12;
  return_value_est_cond_skip_12=est_cond_skip(cond);
  cbdatumprintf(reqbody, "&skip=%d", return_value_est_cond_skip_12);
  signed int return_value_est_cond_mask_13;
  return_value_est_cond_mask_13=est_cond_mask(cond);
  cbdatumprintf(reqbody, "&mask=%d", return_value_est_cond_mask_13);
  resheads=cbmapopenex(31);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr_14;
  return_value_cbdatumptr_14=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize_15;
  return_value_cbdatumsize_15=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle_16;
  return_value_est_url_shuttle_16=est_url_shuttle(buf, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr_14, return_value_cbdatumsize_15, &rescode, resheads, resbody);
  if(return_value_est_url_shuttle_16 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  _Bool tmp_if_expr_20;
  signed int return_value_cbstrfwmatch_19;
  _Bool tmp_if_expr_21;
  _Bool tmp_if_expr_24;
  _Bool tmp_if_expr_22;
  _Bool tmp_if_expr_23;
  if(!(err == 0))
  {
    cbdatumclose(resbody);
    cbmapclose(resheads);
    cbdatumclose(reqbody);
    cblistclose(reqheads);
    return (struct anonymous_17 *)(void *)0;
  }

  else
  {
    ptr=cbdatumtomalloc(resbody, (signed int *)(void *)0);
    pv=strchr(ptr, 10);
    if(pv == ((char *)NULL) || ptr + 3l >= pv)
    {
      free((void *)ptr);
      cbdatumclose(reqbody);
      cblistclose(reqheads);
      return (struct anonymous_17 *)(void *)0;
    }

    else
    {
      *pv = (char)0;
      if((signed int)pv[-1l] == 13)
        pv[(signed long int)-1] = (char)0;

      unsigned long int return_value_strlen_17;
      return_value_strlen_17=strlen(ptr);
      plen = (signed int)return_value_strlen_17;
      pv = pv + 1l;
      ep = pv;
      nres=est_noderes_new();
      part = 0;
      end = 0;
      while(!((signed int)*ep == 0))
      {
        if(*ep == *ptr)
        {
          return_value_cbstrfwmatch_19=cbstrfwmatch(ep, ptr);
          tmp_if_expr_20 = return_value_cbstrfwmatch_19 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_20 = (_Bool)0;
        if(tmp_if_expr_20)
          tmp_if_expr_21 = (signed int)ep[(signed long int)-1] == 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_21 = (_Bool)0;
        if(tmp_if_expr_21)
        {
          if((signed int)ep[(signed long int)plen] == 13)
            tmp_if_expr_22 = (_Bool)1;

          else
            tmp_if_expr_22 = (signed int)ep[(signed long int)plen] == 10 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_22)
            tmp_if_expr_23 = (_Bool)1;

          else
            tmp_if_expr_23 = (signed int)ep[(signed long int)plen] == 58 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr_24 = tmp_if_expr_23 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_24 = (_Bool)0;
        if(tmp_if_expr_24)
        {
          *ep = (char)0;
          if(part == 0)
            est_parse_search_header(nres, pv);

          else
            est_parse_search_body(nres, pv);
          ep = ep + (signed long int)plen;
          signed int return_value_cbstrfwmatch_18;
          return_value_cbstrfwmatch_18=cbstrfwmatch(ep, ":END");
          if(!(return_value_cbstrfwmatch_18 == 0))
          {
            end = 1;
            break;
          }

          if((signed int)*ep == 13)
            ep = ep + 1l;

          if((signed int)*ep == 10)
            ep = ep + 1l;

          pv = ep;
          part = part + 1;
        }

        else
          ep = ep + 1l;
      }
      free((void *)ptr);
      cbuf=cbmapget(resheads, "last-modified", -1, (signed int *)(void *)0);
      if(!(cbuf == ((const char *)NULL)))
        nres->mdate=cbstrmktime(cbuf);

      else
        nres->mdate=time((signed long int *)(void *)0);
      cbmapclose(resheads);
      cbdatumclose(reqbody);
      cblistclose(reqheads);
      if(end == 0)
      {
        est_noderes_delete(nres);
        return (struct anonymous_17 *)(void *)0;
      }

      else
        return nres;
    }
  }
}

// est_node_set_auth
// file estnode.c line 391
void est_node_set_auth(struct anonymous_24 *node, const char *name, const char *passwd)
{
  free((void *)node->auth);
  node->auth=cbsprintf("%s:%s", name, passwd);
}

// est_node_set_info
// file estnode.c line 1951
static signed int est_node_set_info(struct anonymous_24 *node)
{
  struct anonymous_6 *reqheads;
  struct anonymous_6 *elems;
  struct anonymous_9 *resbody;
  const char *kbuf;
  const char *ptr;
  const char *pv;
  const char *tv;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err;
  signed int tc;
  err = 0;
  sprintf(url, "%s/inform", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  node->dnum = -1;
  node->wnum = -1;
  node->size = -1.0;
  if(!(node->admins == ((struct anonymous_6 *)NULL)))
  {
    cblistclose(node->admins);
    node->admins = (struct anonymous_6 *)(void *)0;
  }

  if(!(node->users == ((struct anonymous_6 *)NULL)))
  {
    cblistclose(node->users);
    node->users = (struct anonymous_6 *)(void *)0;
  }

  if(!(node->links == ((struct anonymous_6 *)NULL)))
  {
    cblistclose(node->links);
    node->links = (struct anonymous_6 *)(void *)0;
  }

  resbody=cbdatumopen((const char *)(void *)0, -1);
  signed int return_value_est_url_shuttle_3;
  return_value_est_url_shuttle_3=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, (const char *)(void *)0, -1, &rescode, (struct anonymous_5 *)(void *)0, resbody);
  if(return_value_est_url_shuttle_3 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  const char *return_value_cblistval_4;
  const char *return_value_cblistval_5;
  if(err == 0)
  {
    ptr=cbdatumptr(resbody);
    pv=strchr(ptr, 10);
    if(!(pv == ((const char *)NULL)))
    {
      elems=cbsplit(ptr, (signed int)(pv - ptr), "\t");
      signed int return_value_cblistnum_9;
      return_value_cblistnum_9=cblistnum(elems);
      if(return_value_cblistnum_9 == 5)
      {
        if(node->name == ((char *)NULL))
        {
          return_value_cblistval_4=cblistval(elems, 0, (signed int *)(void *)0);
          node->name=cbmemdup(return_value_cblistval_4, -1);
        }

        if(node->label == ((char *)NULL))
        {
          return_value_cblistval_5=cblistval(elems, 1, (signed int *)(void *)0);
          node->label=cbmemdup(return_value_cblistval_5, -1);
        }

        const char *return_value_cblistval_6;
        return_value_cblistval_6=cblistval(elems, 2, (signed int *)(void *)0);
        node->dnum=atoi(return_value_cblistval_6);
        const char *return_value_cblistval_7;
        return_value_cblistval_7=cblistval(elems, 3, (signed int *)(void *)0);
        node->wnum=atoi(return_value_cblistval_7);
        const char *return_value_cblistval_8;
        return_value_cblistval_8=cblistval(elems, 4, (signed int *)(void *)0);
        node->size=strtod(return_value_cblistval_8, (char ** restrict )(void *)0);
        if(!(node->dnum >= 0))
        {
          node->dnum = -1;
          err = 1;
        }

        if(!(node->wnum >= 0))
        {
          node->wnum = -1;
          err = 1;
        }

        if(node->size < 0.0)
        {
          node->size = -1.0;
          err = 1;
        }

        ptr = pv;
        ptr = ptr + 1l;
        if((signed int)*ptr == 10)
          ptr = ptr + 1l;

        node->admins=cblistopen();
        do
        {
          pv=strchr(ptr, 10);
          if(pv == ((const char *)NULL))
            break;

          if(ptr == pv)
          {
            ptr = pv + (signed long int)1;
            break;
          }

          cblistpush(node->admins, ptr, (signed int)(pv - ptr));
          ptr = pv + (signed long int)1;
        }
        while((_Bool)1);
        if((signed int)*pv == 10)
          pv = pv + 1l;

        node->users=cblistopen();
        do
        {
          pv=strchr(ptr, 10);
          if(pv == ((const char *)NULL))
            break;

          if(ptr == pv)
          {
            ptr = pv + (signed long int)1;
            break;
          }

          cblistpush(node->users, ptr, (signed int)(pv - ptr));
          ptr = pv + (signed long int)1;
        }
        while((_Bool)1);
        if((signed int)*pv == 10)
          pv = pv + 1l;

        node->links=cblistopen();
        do
        {
          pv=strchr(ptr, 10);
          if(pv == ((const char *)NULL))
            break;

          if(ptr == pv)
          {
            ptr = pv + (signed long int)1;
            break;
          }

          tc = 0;
          tv = ptr;
          for( ; !(tv >= pv); tv = tv + 1l)
            if((signed int)*tv == 9)
              tc = tc + 1;

          if(tc == 2)
            cblistpush(node->links, ptr, (signed int)(pv - ptr));

          ptr = pv + (signed long int)1;
        }
        while((_Bool)1);
      }

      else
        err = 1;
      cblistclose(elems);
    }

    else
      err = 1;
  }

  cbdatumclose(resbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_set_link
// file estnode.c line 1248
signed int est_node_set_link(struct anonymous_24 *node, const char *url, const char *label, signed int credit)
{
  struct anonymous_6 *reqheads;
  struct anonymous_9 *reqbody;
  struct anonymous_9 *resbody;
  const char *kbuf;
  char myurl[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(myurl, "%s/_set_link", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  if(credit >= 0)
    cbdatumprintf(reqbody, "url=%?&label=%?&credit=%d", url, label, credit);

  else
    cbdatumprintf(reqbody, "url=%?&label=%?", url, label);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr_3;
  return_value_cbdatumptr_3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize_4;
  return_value_cbdatumsize_4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle_5;
  return_value_est_url_shuttle_5=est_url_shuttle(myurl, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr_3, return_value_cbdatumsize_4, &rescode, (struct anonymous_5 *)(void *)0, resbody);
  if(return_value_est_url_shuttle_5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  cbdatumclose(resbody);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_set_proxy
// file estnode.c line 375
void est_node_set_proxy(struct anonymous_24 *node, const char *host, signed int port)
{
  free((void *)node->pxhost);
  node->pxhost=cbmemdup(host, -1);
  node->pxport = port;
}

// est_node_set_snippet_width
// file estnode.c line 1199
void est_node_set_snippet_width(struct anonymous_24 *node, signed int wwidth, signed int hwidth, signed int awidth)
{
  node->wwidth = wwidth;
  if(hwidth >= 0)
    node->hwidth = hwidth;

  if(awidth >= 0)
    node->awidth = awidth;

}

// est_node_set_timeout
// file estnode.c line 384
void est_node_set_timeout(struct anonymous_24 *node, signed int sec)
{
  node->timeout = sec;
}

// est_node_set_user
// file estnode.c line 1208
signed int est_node_set_user(struct anonymous_24 *node, const char *name, signed int mode)
{
  struct anonymous_6 *reqheads;
  struct anonymous_9 *reqbody;
  struct anonymous_9 *resbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/_set_user", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "name=%?&mode=%d", name, mode);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr_3;
  return_value_cbdatumptr_3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize_4;
  return_value_cbdatumsize_4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle_5;
  return_value_est_url_shuttle_5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr_3, return_value_cbdatumsize_4, &rescode, (struct anonymous_5 *)(void *)0, resbody);
  if(return_value_est_url_shuttle_5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  cbdatumclose(resbody);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_size
// file estnode.c line 1000
double est_node_size(struct anonymous_24 *node)
{
  if(node->size >= 0.0)
    return node->size;

  else
  {
    est_node_set_info(node);
    return node->size;
  }
}

// est_node_status
// file estnode.c line 399
signed int est_node_status(struct anonymous_24 *node)
{
  return node->status;
}

// est_node_sync
// file estnode.c line 406
signed int est_node_sync(struct anonymous_24 *node)
{
  struct anonymous_6 *reqheads;
  struct anonymous_9 *reqbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/sync", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr_3;
  return_value_cbdatumptr_3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize_4;
  return_value_cbdatumsize_4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle_5;
  return_value_est_url_shuttle_5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr_3, return_value_cbdatumsize_4, &rescode, (struct anonymous_5 *)(void *)0, (struct anonymous_9 *)(void *)0);
  if(return_value_est_url_shuttle_5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_uri_to_id
// file estnode.c line 923
signed int est_node_uri_to_id(struct anonymous_24 *node, const char *uri)
{
  struct anonymous_6 *reqheads;
  struct anonymous_9 *reqbody;
  struct anonymous_9 *resbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err;
  signed int id;
  err = 0;
  sprintf(url, "%s/uri_to_id", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum_2;
  return_value_cbmaprnum_2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum_2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval_1;
      return_value_cbmapiterval_1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval_1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "uri=%?", uri);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr_3;
  return_value_cbdatumptr_3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize_4;
  return_value_cbdatumsize_4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle_5;
  return_value_est_url_shuttle_5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr_3, return_value_cbdatumsize_4, &rescode, (struct anonymous_5 *)(void *)0, resbody);
  if(return_value_est_url_shuttle_5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  signed int tmp_if_expr_8;
  const char *return_value_cbdatumptr_6;
  signed int return_value_atoi_7;
  if(!(err == 0))
    tmp_if_expr_8 = -1;

  else
  {
    return_value_cbdatumptr_6=cbdatumptr(resbody);
    return_value_atoi_7=atoi(return_value_cbdatumptr_6);
    tmp_if_expr_8 = return_value_atoi_7;
  }
  id = tmp_if_expr_8;
  cbdatumclose(resbody);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return id;
}

// est_node_users
// file estnode.c line 1055
const struct anonymous_6 * est_node_users(struct anonymous_24 *node)
{
  if(!(node->users == ((struct anonymous_6 *)NULL)))
    return node->users;

  else
  {
    est_node_set_info(node);
    return node->users;
  }
}

// est_node_word_num
// file estnode.c line 991
signed int est_node_word_num(struct anonymous_24 *node)
{
  if(node->wnum >= 0)
    return node->wnum;

  else
  {
    est_node_set_info(node);
    return node->wnum;
  }
}

// est_noderes_add_doc
// file estnode.c line 1673
void est_noderes_add_doc(struct anonymous_17 *nres, struct anonymous_5 *attrs, char *snippet)
{
  const char *uri;
  signed int idx;
  uri=cbmapget(attrs, "@uri", -1, (signed int *)(void *)0);
  if(uri == ((const char *)NULL))
  {
    free((void *)snippet);
    cbmapclose(attrs);
  }

  else
  {
    if(nres->dnum + nres->top >= nres->max)
    {
      nres->max = nres->max * 2;
      void *return_value_cbrealloc_1;
      return_value_cbrealloc_1=cbrealloc((void *)nres->docs, (unsigned long int)nres->max * sizeof(struct _ESTRESDOC) /*56ul*/ );
      nres->docs = (struct _ESTRESDOC *)return_value_cbrealloc_1;
    }

    idx = nres->top + nres->dnum;
    (nres->docs + (signed long int)idx)->uri = uri;
    (nres->docs + (signed long int)idx)->attrs = attrs;
    (nres->docs + (signed long int)idx)->snippet = snippet;
    (nres->docs + (signed long int)idx)->kwords = (struct anonymous_5 *)(void *)0;
    (nres->docs + (signed long int)idx)->similarity = -1.0;
    (nres->docs + (signed long int)idx)->children = (struct _ESTRESDOC **)(void *)0;
    (nres->docs + (signed long int)idx)->cnum = 0;
    nres->dnum = nres->dnum + 1;
  }
}

// est_noderes_delete
// file estnode.c line 147
void est_noderes_delete(struct anonymous_17 *nres)
{
  struct _ESTRESDOC *docs;
  signed int i;
  signed int dnum;
  cbmapclose(nres->hints);
  free((void *)nres->survivors);
  docs = nres->docs + (signed long int)nres->top;
  dnum = nres->dnum;
  i = 0;
  for( ; !(i >= dnum); i = i + 1)
  {
    free((void *)(nres->docs + (signed long int)i)->children);
    if(!((docs + (signed long int)i)->kwords == ((struct anonymous_5 *)NULL)))
      cbmapclose((docs + (signed long int)i)->kwords);

    free((void *)(docs + (signed long int)i)->snippet);
    cbmapclose((docs + (signed long int)i)->attrs);
  }
  free((void *)nres->docs);
  free((void *)nres);
}

// est_noderes_doc_num
// file estnode.c line 240
signed int est_noderes_doc_num(struct anonymous_17 *nres)
{
  signed int tmp_if_expr_1;
  if(!(nres->survivors == ((struct _ESTRESDOC **)NULL)))
    tmp_if_expr_1 = nres->snum;

  else
    tmp_if_expr_1 = nres->dnum;
  return tmp_if_expr_1;
}

// est_noderes_eclipse
// file estnode.c line 174
void est_noderes_eclipse(struct anonymous_17 *nres, signed int num, double limit)
{
  struct _ESTRESDOC *docs;
  struct anonymous_6 *fields;
  struct anonymous_5 *kwords;
  const char *kbuf;
  const char *vbuf;
  signed int i;
  signed int j;
  signed int dnum;
  signed int ksiz;
  signed int vsiz;
  signed int snum;
  signed int vnum;
  signed int svec[256l];
  signed int tvec[256l];
  double dval;
  docs = nres->docs + (signed long int)nres->top;
  dnum = nres->dnum;
  signed int return_value_cblistnum_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  signed int return_value_cbmaprnum_3;
  void *return_value_cbmalloc_5;
  signed int tmp_post_6;
  signed int tmp_post_8;
  if(!(num >= 1))
  {
    i = 0;
    for( ; !(i >= dnum); i = i + 1)
    {
      (docs + (signed long int)i)->cnum = 0;
      (docs + (signed long int)i)->similarity = -1.0;
    }
    free((void *)nres->survivors);
    nres->survivors = (struct _ESTRESDOC **)(void *)0;
    nres->snum = 0;
  }

  else
  {
    i = 0;
    for( ; !(i >= dnum); i = i + 1)
      if((docs + (signed long int)i)->kwords == ((struct anonymous_5 *)NULL))
      {
        vbuf=cbmapget((docs + (signed long int)i)->attrs, "%VECTOR", -1, &vsiz);
        if(!(vbuf == ((const char *)NULL)) && vsiz >= 0)
        {
          kwords=cbmapopenex(31);
          fields=cbsplit(vbuf, vsiz, "\t");
          j = 0;
          do
          {
            return_value_cblistnum_1=cblistnum(fields);
            if(j >= return_value_cblistnum_1 + -1)
              break;

            kbuf=cblistval(fields, j, &ksiz);
            vbuf=cblistval(fields, j + 1, &vsiz);
            cbmapput(kwords, kbuf, ksiz, vbuf, vsiz, 0);
            j = j + 2;
          }
          while((_Bool)1);
          cblistclose(fields);
          (docs + (signed long int)i)->kwords = kwords;
          (docs + (signed long int)i)->cnum = 0;
          (docs + (signed long int)i)->similarity = -1.0;
        }

      }

    snum = 0;
    i = 0;
    for( ; !(i >= dnum) && !(snum >= num); i = i + 1)
      if(!((docs + (signed long int)i)->similarity >= 0.0))
      {
        if(!((docs + (signed long int)i)->kwords == ((struct anonymous_5 *)NULL)))
        {
          vnum=cbmaprnum((docs + (signed long int)i)->kwords);
          if(vnum >= 1)
          {
            vnum = vnum < 256 ? vnum : 256;
            est_vector_set_seed((docs + (signed long int)i)->kwords, svec, vnum);
            j = i + 1;
            for( ; !(j >= dnum); j = j + 1)
            {
              if((docs + (signed long int)j)->similarity >= 0.0)
                tmp_if_expr_2 = (_Bool)1;

              else
                tmp_if_expr_2 = !((docs + (signed long int)j)->kwords != ((struct anonymous_5 *)NULL)) ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_2)
                tmp_if_expr_4 = (_Bool)1;

              else
              {
                return_value_cbmaprnum_3=cbmaprnum((docs + (signed long int)j)->kwords);
                tmp_if_expr_4 = return_value_cbmaprnum_3 < 1 ? (_Bool)1 : (_Bool)0;
              }
              if(!tmp_if_expr_4)
              {
                est_vector_set_target((docs + (signed long int)i)->kwords, (docs + (signed long int)j)->kwords, tvec, vnum);
                dval=est_vector_cosine(svec, tvec, vnum);
                if(dval > limit)
                {
                  if(!((docs + (signed long int)i)->cnum >= 64))
                  {
                    if((docs + (signed long int)i)->children == ((struct _ESTRESDOC **)NULL))
                    {
                      return_value_cbmalloc_5=cbmalloc((unsigned long int)64 * sizeof(struct _ESTRESDOC *) /*8ul*/ );
                      (docs + (signed long int)i)->children = (struct _ESTRESDOC **)return_value_cbmalloc_5;
                    }

                    tmp_post_6 = (docs + (signed long int)i)->cnum;
                    (docs + (signed long int)i)->cnum = (docs + (signed long int)i)->cnum + 1;
                    (docs + (signed long int)i)->children[(signed long int)tmp_post_6] = docs + (signed long int)j;
                    (docs + (signed long int)j)->similarity = dval;
                  }

                }

              }

            }
          }

        }

        snum = snum + 1;
      }

    free((void *)nres->survivors);
    void *return_value_cbmalloc_7;
    return_value_cbmalloc_7=cbmalloc((unsigned long int)dnum * sizeof(struct _ESTRESDOC *) /*8ul*/  + (unsigned long int)1);
    nres->survivors = (struct _ESTRESDOC **)return_value_cbmalloc_7;
    snum = 0;
    i = 0;
    for( ; !(i >= dnum); i = i + 1)
      if(!((docs + (signed long int)i)->similarity >= 0.0))
      {
        tmp_post_8 = snum;
        snum = snum + 1;
        nres->survivors[(signed long int)tmp_post_8] = docs + (signed long int)i;
      }

    nres->snum = snum;
  }
}

// est_noderes_get_doc
// file estnode.c line 247
struct _ESTRESDOC * est_noderes_get_doc(struct anonymous_17 *nres, signed int index)
{
  if(!(nres->survivors == ((struct _ESTRESDOC **)NULL)))
  {
    if(index >= nres->snum)
      return (struct _ESTRESDOC *)(void *)0;

    return nres->survivors[(signed long int)index];
  }

  else
    if(index >= nres->dnum)
      return (struct _ESTRESDOC *)(void *)0;

    else
      return nres->docs + (signed long int)(nres->top + index);
}

// est_noderes_hints
// file estnode.c line 167
struct anonymous_5 * est_noderes_hints(struct anonymous_17 *nres)
{
  return nres->hints;
}

// est_noderes_mdate
// file estnode.c line 1713
signed long int est_noderes_mdate(struct anonymous_17 *nres)
{
  return nres->mdate;
}

// est_noderes_new
// file estnode.c line 1657
struct anonymous_17 * est_noderes_new(void)
{
  struct anonymous_17 *nres;
  void *return_value_cbmalloc_1;
  return_value_cbmalloc_1=cbmalloc(sizeof(struct anonymous_17) /*56ul*/ );
  nres = (struct anonymous_17 *)return_value_cbmalloc_1;
  nres->top = 0;
  nres->max = 64;
  void *return_value_cbmalloc_2;
  return_value_cbmalloc_2=cbmalloc(sizeof(struct _ESTRESDOC) /*56ul*/  * (unsigned long int)nres->max);
  nres->docs = (struct _ESTRESDOC *)return_value_cbmalloc_2;
  nres->dnum = 0;
  nres->survivors = (struct _ESTRESDOC **)(void *)0;
  nres->snum = 0;
  nres->hints=cbmapopenex(31);
  nres->mdate = (signed long int)0;
  return nres;
}

// est_noderes_shift_doc
// file estnode.c line 1699
signed int est_noderes_shift_doc(struct anonymous_17 *nres, struct anonymous_5 **attrp, char **snippetp)
{
  if(!(nres->dnum >= 1))
    return 0;

  else
  {
    *attrp = (nres->docs + (signed long int)nres->top)->attrs;
    *snippetp = (nres->docs + (signed long int)nres->top)->snippet;
    if(!((nres->docs + (signed long int)nres->top)->kwords == ((struct anonymous_5 *)NULL)))
      cbmapclose((nres->docs + (signed long int)nres->top)->kwords);

    free((void *)(nres->docs + (signed long int)nres->top)->children);
    nres->top = nres->top + 1;
    nres->dnum = nres->dnum - 1;
    return 1;
  }
}

// est_normalize_text
// file estraier.c line 5950
static void est_normalize_text(unsigned char *utext, signed int size, signed int *sp)
{
  signed int i;
  signed int wi;
  signed int b1;
  signed int b2;
  wi = 0;
  i = 0;
  signed int tmp_post_1;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int tmp_post_4;
  signed int tmp_post_5;
  signed int tmp_post_6;
  signed int tmp_post_7;
  signed int tmp_post_8;
  signed int tmp_post_9;
  signed int tmp_post_10;
  signed int tmp_post_11;
  signed int tmp_post_12;
  signed int tmp_post_13;
  signed int tmp_post_14;
  signed int tmp_post_15;
  signed int tmp_post_16;
  signed int tmp_post_17;
  signed int tmp_post_18;
  signed int tmp_post_19;
  signed int tmp_post_20;
  signed int tmp_post_21;
  signed int tmp_post_22;
  signed int tmp_post_23;
  signed int tmp_post_24;
  signed int tmp_post_25;
  signed int tmp_post_26;
  signed int tmp_post_27;
  signed int tmp_post_28;
  signed int tmp_post_29;
  signed int tmp_post_30;
  signed int tmp_post_31;
  signed int tmp_post_32;
  signed int tmp_post_33;
  signed int tmp_post_34;
  signed int tmp_post_35;
  signed int tmp_post_36;
  signed int tmp_post_37;
  signed int tmp_post_38;
  signed int tmp_post_39;
  signed int tmp_post_40;
  signed int tmp_post_41;
  signed int tmp_post_42;
  signed int tmp_post_43;
  signed int tmp_post_44;
  signed int tmp_post_45;
  signed int tmp_post_46;
  signed int tmp_post_47;
  signed int tmp_post_48;
  signed int tmp_post_49;
  signed int tmp_post_50;
  signed int tmp_post_51;
  signed int tmp_post_52;
  signed int tmp_post_53;
  signed int tmp_post_54;
  signed int tmp_post_55;
  signed int tmp_post_56;
  signed int tmp_post_57;
  signed int tmp_post_58;
  signed int tmp_post_59;
  signed int tmp_post_60;
  signed int tmp_post_61;
  signed int tmp_post_62;
  signed int tmp_post_63;
  signed int tmp_post_64;
  signed int tmp_post_65;
  signed int tmp_post_66;
  signed int tmp_post_67;
  signed int tmp_post_68;
  signed int tmp_post_69;
  signed int tmp_post_70;
  signed int tmp_post_71;
  signed int tmp_post_72;
  signed int tmp_post_73;
  signed int tmp_post_74;
  signed int tmp_post_75;
  signed int tmp_post_76;
  signed int tmp_post_77;
  signed int tmp_post_78;
  signed int tmp_post_79;
  signed int tmp_post_80;
  signed int tmp_post_81;
  signed int tmp_post_82;
  signed int tmp_post_83;
  signed int tmp_post_84;
  signed int tmp_post_85;
  signed int tmp_post_86;
  signed int tmp_post_87;
  signed int tmp_post_88;
  signed int tmp_post_89;
  signed int tmp_post_90;
  signed int tmp_post_91;
  signed int tmp_post_92;
  signed int tmp_post_93;
  signed int tmp_post_94;
  signed int tmp_post_95;
  signed int tmp_post_96;
  signed int tmp_post_97;
  signed int tmp_post_98;
  signed int tmp_post_99;
  signed int tmp_post_100;
  signed int tmp_post_101;
  signed int tmp_post_102;
  signed int tmp_post_103;
  signed int tmp_post_104;
  signed int tmp_post_105;
  signed int tmp_post_106;
  _Bool tmp_if_expr_107;
  signed int tmp_post_108;
  signed int tmp_post_109;
  signed int tmp_post_110;
  signed int tmp_post_111;
  signed int tmp_post_112;
  signed int tmp_post_113;
  signed int tmp_post_114;
  signed int tmp_post_115;
  signed int tmp_post_116;
  signed int tmp_post_117;
  signed int tmp_post_118;
  signed int tmp_post_119;
  signed int tmp_post_120;
  signed int tmp_post_121;
  for( ; !(i >= size + -1); i = i + 2)
  {
    b1 = (signed int)utext[(signed long int)i];
    b2 = (signed int)utext[(signed long int)(i + 1)];
    if(b1 == 0x0)
    {
      if(b2 >= 0x0e && !(b2 >= 32) || !(b2 >= 9))
      {
        tmp_post_1 = wi;
        wi = wi + 1;
        utext[(signed long int)tmp_post_1] = (unsigned char)0x0;
        tmp_post_2 = wi;
        wi = wi + 1;
        utext[(signed long int)tmp_post_2] = (unsigned char)0x20;
      }

      else
        if(b2 == 0xa0)
        {
          tmp_post_3 = wi;
          wi = wi + 1;
          utext[(signed long int)tmp_post_3] = (unsigned char)0x0;
          tmp_post_4 = wi;
          wi = wi + 1;
          utext[(signed long int)tmp_post_4] = (unsigned char)0x20;
        }

        else
        {
          tmp_post_5 = wi;
          wi = wi + 1;
          utext[(signed long int)tmp_post_5] = (unsigned char)b1;
          tmp_post_6 = wi;
          wi = wi + 1;
          utext[(signed long int)tmp_post_6] = (unsigned char)b2;
        }
    }

    else
      if(b1 == 0x20)
      {
        if(b2 == 0x2)
        {
          tmp_post_7 = wi;
          wi = wi + 1;
          utext[(signed long int)tmp_post_7] = (unsigned char)0x0;
          tmp_post_8 = wi;
          wi = wi + 1;
          utext[(signed long int)tmp_post_8] = (unsigned char)0x20;
        }

        else
          if(b2 == 0x3)
          {
            tmp_post_9 = wi;
            wi = wi + 1;
            utext[(signed long int)tmp_post_9] = (unsigned char)0x0;
            tmp_post_10 = wi;
            wi = wi + 1;
            utext[(signed long int)tmp_post_10] = (unsigned char)0x20;
          }

          else
            if(b2 == 0x9)
            {
              tmp_post_11 = wi;
              wi = wi + 1;
              utext[(signed long int)tmp_post_11] = (unsigned char)0x0;
              tmp_post_12 = wi;
              wi = wi + 1;
              utext[(signed long int)tmp_post_12] = (unsigned char)0x20;
            }

            else
              if(b2 == 0x10)
              {
                tmp_post_13 = wi;
                wi = wi + 1;
                utext[(signed long int)tmp_post_13] = (unsigned char)0x0;
                tmp_post_14 = wi;
                wi = wi + 1;
                utext[(signed long int)tmp_post_14] = (unsigned char)0x2d;
              }

              else
                if(b2 == 0x15)
                {
                  tmp_post_15 = wi;
                  wi = wi + 1;
                  utext[(signed long int)tmp_post_15] = (unsigned char)0x0;
                  tmp_post_16 = wi;
                  wi = wi + 1;
                  utext[(signed long int)tmp_post_16] = (unsigned char)0x2d;
                }

                else
                  if(b2 == 0x19)
                  {
                    tmp_post_17 = wi;
                    wi = wi + 1;
                    utext[(signed long int)tmp_post_17] = (unsigned char)0x0;
                    tmp_post_18 = wi;
                    wi = wi + 1;
                    utext[(signed long int)tmp_post_18] = (unsigned char)0x27;
                  }

                  else
                    if(b2 == 0x33)
                    {
                      tmp_post_19 = wi;
                      wi = wi + 1;
                      utext[(signed long int)tmp_post_19] = (unsigned char)0x0;
                      tmp_post_20 = wi;
                      wi = wi + 1;
                      utext[(signed long int)tmp_post_20] = (unsigned char)0x22;
                    }

                    else
                    {
                      tmp_post_21 = wi;
                      wi = wi + 1;
                      utext[(signed long int)tmp_post_21] = (unsigned char)b1;
                      tmp_post_22 = wi;
                      wi = wi + 1;
                      utext[(signed long int)tmp_post_22] = (unsigned char)b2;
                    }
      }

      else
        if(b1 == 0x22)
        {
          if(b2 == 0x12)
          {
            tmp_post_23 = wi;
            wi = wi + 1;
            utext[(signed long int)tmp_post_23] = (unsigned char)0x0;
            tmp_post_24 = wi;
            wi = wi + 1;
            utext[(signed long int)tmp_post_24] = (unsigned char)0x2d;
          }

          else
          {
            tmp_post_25 = wi;
            wi = wi + 1;
            utext[(signed long int)tmp_post_25] = (unsigned char)b1;
            tmp_post_26 = wi;
            wi = wi + 1;
            utext[(signed long int)tmp_post_26] = (unsigned char)b2;
          }
        }

        else
          if(b1 == 0x30)
          {
            if(b2 == 0x0)
            {
              tmp_post_27 = wi;
              wi = wi + 1;
              utext[(signed long int)tmp_post_27] = (unsigned char)0x0;
              tmp_post_28 = wi;
              wi = wi + 1;
              utext[(signed long int)tmp_post_28] = (unsigned char)0x20;
            }

            else
            {
              tmp_post_29 = wi;
              wi = wi + 1;
              utext[(signed long int)tmp_post_29] = (unsigned char)b1;
              tmp_post_30 = wi;
              wi = wi + 1;
              utext[(signed long int)tmp_post_30] = (unsigned char)b2;
            }
          }

          else
            if(b1 == 0xff)
            {
              if(b2 == 0x01)
              {
                tmp_post_31 = wi;
                wi = wi + 1;
                utext[(signed long int)tmp_post_31] = (unsigned char)0x0;
                tmp_post_32 = wi;
                wi = wi + 1;
                utext[(signed long int)tmp_post_32] = (unsigned char)0x21;
              }

              else
                if(b2 == 0x03)
                {
                  tmp_post_33 = wi;
                  wi = wi + 1;
                  utext[(signed long int)tmp_post_33] = (unsigned char)0x0;
                  tmp_post_34 = wi;
                  wi = wi + 1;
                  utext[(signed long int)tmp_post_34] = (unsigned char)0x23;
                }

                else
                  if(b2 == 0x04)
                  {
                    tmp_post_35 = wi;
                    wi = wi + 1;
                    utext[(signed long int)tmp_post_35] = (unsigned char)0x0;
                    tmp_post_36 = wi;
                    wi = wi + 1;
                    utext[(signed long int)tmp_post_36] = (unsigned char)0x24;
                  }

                  else
                    if(b2 == 0x05)
                    {
                      tmp_post_37 = wi;
                      wi = wi + 1;
                      utext[(signed long int)tmp_post_37] = (unsigned char)0x0;
                      tmp_post_38 = wi;
                      wi = wi + 1;
                      utext[(signed long int)tmp_post_38] = (unsigned char)0x25;
                    }

                    else
                      if(b2 == 0x06)
                      {
                        tmp_post_39 = wi;
                        wi = wi + 1;
                        utext[(signed long int)tmp_post_39] = (unsigned char)0x0;
                        tmp_post_40 = wi;
                        wi = wi + 1;
                        utext[(signed long int)tmp_post_40] = (unsigned char)0x26;
                      }

                      else
                        if(b2 == 0x0a)
                        {
                          tmp_post_41 = wi;
                          wi = wi + 1;
                          utext[(signed long int)tmp_post_41] = (unsigned char)0x0;
                          tmp_post_42 = wi;
                          wi = wi + 1;
                          utext[(signed long int)tmp_post_42] = (unsigned char)0x2a;
                        }

                        else
                          if(b2 == 0x0b)
                          {
                            tmp_post_43 = wi;
                            wi = wi + 1;
                            utext[(signed long int)tmp_post_43] = (unsigned char)0x0;
                            tmp_post_44 = wi;
                            wi = wi + 1;
                            utext[(signed long int)tmp_post_44] = (unsigned char)0x2b;
                          }

                          else
                            if(b2 == 0x0c)
                            {
                              tmp_post_45 = wi;
                              wi = wi + 1;
                              utext[(signed long int)tmp_post_45] = (unsigned char)0x0;
                              tmp_post_46 = wi;
                              wi = wi + 1;
                              utext[(signed long int)tmp_post_46] = (unsigned char)0x2c;
                            }

                            else
                              if(b2 == 0x0e)
                              {
                                tmp_post_47 = wi;
                                wi = wi + 1;
                                utext[(signed long int)tmp_post_47] = (unsigned char)0x0;
                                tmp_post_48 = wi;
                                wi = wi + 1;
                                utext[(signed long int)tmp_post_48] = (unsigned char)0x2e;
                              }

                              else
                                if(b2 == 0x0f)
                                {
                                  tmp_post_49 = wi;
                                  wi = wi + 1;
                                  utext[(signed long int)tmp_post_49] = (unsigned char)0x0;
                                  tmp_post_50 = wi;
                                  wi = wi + 1;
                                  utext[(signed long int)tmp_post_50] = (unsigned char)0x2f;
                                }

                                else
                                  if(b2 == 0x1a)
                                  {
                                    tmp_post_51 = wi;
                                    wi = wi + 1;
                                    utext[(signed long int)tmp_post_51] = (unsigned char)0x0;
                                    tmp_post_52 = wi;
                                    wi = wi + 1;
                                    utext[(signed long int)tmp_post_52] = (unsigned char)0x3a;
                                  }

                                  else
                                    if(b2 == 0x1b)
                                    {
                                      tmp_post_53 = wi;
                                      wi = wi + 1;
                                      utext[(signed long int)tmp_post_53] = (unsigned char)0x0;
                                      tmp_post_54 = wi;
                                      wi = wi + 1;
                                      utext[(signed long int)tmp_post_54] = (unsigned char)0x3b;
                                    }

                                    else
                                      if(b2 == 0x1d)
                                      {
                                        tmp_post_55 = wi;
                                        wi = wi + 1;
                                        utext[(signed long int)tmp_post_55] = (unsigned char)0x0;
                                        tmp_post_56 = wi;
                                        wi = wi + 1;
                                        utext[(signed long int)tmp_post_56] = (unsigned char)0x3d;
                                      }

                                      else
                                        if(b2 == 0x1f)
                                        {
                                          tmp_post_57 = wi;
                                          wi = wi + 1;
                                          utext[(signed long int)tmp_post_57] = (unsigned char)0x0;
                                          tmp_post_58 = wi;
                                          wi = wi + 1;
                                          utext[(signed long int)tmp_post_58] = (unsigned char)0x3f;
                                        }

                                        else
                                          if(b2 == 0x20)
                                          {
                                            tmp_post_59 = wi;
                                            wi = wi + 1;
                                            utext[(signed long int)tmp_post_59] = (unsigned char)0x0;
                                            tmp_post_60 = wi;
                                            wi = wi + 1;
                                            utext[(signed long int)tmp_post_60] = (unsigned char)0x40;
                                          }

                                          else
                                            if(b2 == 0x3c)
                                            {
                                              tmp_post_61 = wi;
                                              wi = wi + 1;
                                              utext[(signed long int)tmp_post_61] = (unsigned char)0x0;
                                              tmp_post_62 = wi;
                                              wi = wi + 1;
                                              utext[(signed long int)tmp_post_62] = (unsigned char)0x5c;
                                            }

                                            else
                                              if(b2 == 0x3e)
                                              {
                                                tmp_post_63 = wi;
                                                wi = wi + 1;
                                                utext[(signed long int)tmp_post_63] = (unsigned char)0x0;
                                                tmp_post_64 = wi;
                                                wi = wi + 1;
                                                utext[(signed long int)tmp_post_64] = (unsigned char)0x5e;
                                              }

                                              else
                                                if(b2 == 0x3f)
                                                {
                                                  tmp_post_65 = wi;
                                                  wi = wi + 1;
                                                  utext[(signed long int)tmp_post_65] = (unsigned char)0x0;
                                                  tmp_post_66 = wi;
                                                  wi = wi + 1;
                                                  utext[(signed long int)tmp_post_66] = (unsigned char)0x5f;
                                                }

                                                else
                                                  if(b2 == 0x5c)
                                                  {
                                                    tmp_post_67 = wi;
                                                    wi = wi + 1;
                                                    utext[(signed long int)tmp_post_67] = (unsigned char)0x0;
                                                    tmp_post_68 = wi;
                                                    wi = wi + 1;
                                                    utext[(signed long int)tmp_post_68] = (unsigned char)0x7c;
                                                  }

                                                  else
                                                    if(b2 >= 0x21 && !(b2 >= 59))
                                                    {
                                                      tmp_post_69 = wi;
                                                      wi = wi + 1;
                                                      utext[(signed long int)tmp_post_69] = (unsigned char)0x0;
                                                      tmp_post_70 = wi;
                                                      wi = wi + 1;
                                                      utext[(signed long int)tmp_post_70] = (unsigned char)((b2 - 0x21) + 0x41);
                                                    }

                                                    else
                                                      if(b2 >= 0x41 && !(b2 >= 91))
                                                      {
                                                        tmp_post_71 = wi;
                                                        wi = wi + 1;
                                                        utext[(signed long int)tmp_post_71] = (unsigned char)0x0;
                                                        tmp_post_72 = wi;
                                                        wi = wi + 1;
                                                        utext[(signed long int)tmp_post_72] = (unsigned char)((b2 - 0x41) + 0x61);
                                                      }

                                                      else
                                                        if(b2 >= 0x10 && !(b2 >= 26))
                                                        {
                                                          tmp_post_73 = wi;
                                                          wi = wi + 1;
                                                          utext[(signed long int)tmp_post_73] = (unsigned char)0x0;
                                                          tmp_post_74 = wi;
                                                          wi = wi + 1;
                                                          utext[(signed long int)tmp_post_74] = (unsigned char)((b2 - 0x10) + 0x30);
                                                        }

                                                        else
                                                          if(b2 == 0x61)
                                                          {
                                                            tmp_post_75 = wi;
                                                            wi = wi + 1;
                                                            utext[(signed long int)tmp_post_75] = (unsigned char)0x30;
                                                            tmp_post_76 = wi;
                                                            wi = wi + 1;
                                                            utext[(signed long int)tmp_post_76] = (unsigned char)0x2;
                                                          }

                                                          else
                                                            if(b2 == 0x62)
                                                            {
                                                              tmp_post_77 = wi;
                                                              wi = wi + 1;
                                                              utext[(signed long int)tmp_post_77] = (unsigned char)0x30;
                                                              tmp_post_78 = wi;
                                                              wi = wi + 1;
                                                              utext[(signed long int)tmp_post_78] = (unsigned char)0xc;
                                                            }

                                                            else
                                                              if(b2 == 0x63)
                                                              {
                                                                tmp_post_79 = wi;
                                                                wi = wi + 1;
                                                                utext[(signed long int)tmp_post_79] = (unsigned char)0x30;
                                                                tmp_post_80 = wi;
                                                                wi = wi + 1;
                                                                utext[(signed long int)tmp_post_80] = (unsigned char)0xd;
                                                              }

                                                              else
                                                                if(b2 == 0x64)
                                                                {
                                                                  tmp_post_81 = wi;
                                                                  wi = wi + 1;
                                                                  utext[(signed long int)tmp_post_81] = (unsigned char)0x30;
                                                                  tmp_post_82 = wi;
                                                                  wi = wi + 1;
                                                                  utext[(signed long int)tmp_post_82] = (unsigned char)0x1;
                                                                }

                                                                else
                                                                  if(b2 == 0x65)
                                                                  {
                                                                    tmp_post_83 = wi;
                                                                    wi = wi + 1;
                                                                    utext[(signed long int)tmp_post_83] = (unsigned char)0x30;
                                                                    tmp_post_84 = wi;
                                                                    wi = wi + 1;
                                                                    utext[(signed long int)tmp_post_84] = (unsigned char)0xfb;
                                                                  }

                                                                  else
                                                                    if(b2 == 0x66)
                                                                    {
                                                                      tmp_post_85 = wi;
                                                                      wi = wi + 1;
                                                                      utext[(signed long int)tmp_post_85] = (unsigned char)0x30;
                                                                      tmp_post_86 = wi;
                                                                      wi = wi + 1;
                                                                      utext[(signed long int)tmp_post_86] = (unsigned char)0xf2;
                                                                    }

                                                                    else
                                                                      if(b2 >= 0x67 && !(b2 >= 108))
                                                                      {
                                                                        tmp_post_87 = wi;
                                                                        wi = wi + 1;
                                                                        utext[(signed long int)tmp_post_87] = (unsigned char)0x30;
                                                                        tmp_post_88 = wi;
                                                                        wi = wi + 1;
                                                                        utext[(signed long int)tmp_post_88] = (unsigned char)((b2 - 0x67) * 2 + 0xa1);
                                                                      }

                                                                      else
                                                                        if(b2 >= 0x6c && !(b2 >= 111))
                                                                        {
                                                                          tmp_post_89 = wi;
                                                                          wi = wi + 1;
                                                                          utext[(signed long int)tmp_post_89] = (unsigned char)0x30;
                                                                          tmp_post_90 = wi;
                                                                          wi = wi + 1;
                                                                          utext[(signed long int)tmp_post_90] = (unsigned char)((b2 - 0x6c) * 2 + 0xe3);
                                                                        }

                                                                        else
                                                                          if(b2 == 0x6f)
                                                                          {
                                                                            tmp_post_91 = wi;
                                                                            wi = wi + 1;
                                                                            utext[(signed long int)tmp_post_91] = (unsigned char)0x30;
                                                                            tmp_post_92 = wi;
                                                                            wi = wi + 1;
                                                                            utext[(signed long int)tmp_post_92] = (unsigned char)0xc3;
                                                                          }

                                                                          else
                                                                            if(b2 == 0x70)
                                                                            {
                                                                              tmp_post_93 = wi;
                                                                              wi = wi + 1;
                                                                              utext[(signed long int)tmp_post_93] = (unsigned char)0x30;
                                                                              tmp_post_94 = wi;
                                                                              wi = wi + 1;
                                                                              utext[(signed long int)tmp_post_94] = (unsigned char)0xfc;
                                                                            }

                                                                            else
                                                                              if(b2 >= 0x71 && !(b2 >= 118))
                                                                              {
                                                                                tmp_post_95 = wi;
                                                                                wi = wi + 1;
                                                                                utext[(signed long int)tmp_post_95] = (unsigned char)0x30;
                                                                                tmp_post_96 = wi;
                                                                                wi = wi + 1;
                                                                                utext[(signed long int)tmp_post_96] = (unsigned char)((b2 - 0x71) * 2 + 0xa2);
                                                                                if(b2 == 0x73 && !(2 + i >= size + -1))
                                                                                {
                                                                                  if((signed int)utext[(signed long int)(2 + i)] == 0xff)
                                                                                  {
                                                                                    if((signed int)utext[(signed long int)(3 + i)] == 0x9e)
                                                                                    {
                                                                                      utext[(signed long int)(wi - 1)] = (unsigned char)0xf4;
                                                                                      i = i + 2;
                                                                                    }

                                                                                  }

                                                                                }

                                                                              }

                                                                              else
                                                                                if(b2 >= 0x76 && !(b2 >= 123))
                                                                                {
                                                                                  tmp_post_97 = wi;
                                                                                  wi = wi + 1;
                                                                                  utext[(signed long int)tmp_post_97] = (unsigned char)0x30;
                                                                                  tmp_post_98 = wi;
                                                                                  wi = wi + 1;
                                                                                  utext[(signed long int)tmp_post_98] = (unsigned char)((b2 - 0x76) * 2 + 0xab);
                                                                                  if(!(2 + i >= size + -1))
                                                                                  {
                                                                                    if((signed int)utext[(signed long int)(2 + i)] == 0xff)
                                                                                    {
                                                                                      if((signed int)utext[(signed long int)(3 + i)] == 0x9e)
                                                                                      {
                                                                                        utext[(signed long int)(wi - 1)] = utext[(signed long int)(wi - 1)] + (unsigned char)1;
                                                                                        i = i + 2;
                                                                                      }

                                                                                    }

                                                                                  }

                                                                                }

                                                                                else
                                                                                  if(b2 >= 0x7b && !(b2 >= 128))
                                                                                  {
                                                                                    tmp_post_99 = wi;
                                                                                    wi = wi + 1;
                                                                                    utext[(signed long int)tmp_post_99] = (unsigned char)0x30;
                                                                                    tmp_post_100 = wi;
                                                                                    wi = wi + 1;
                                                                                    utext[(signed long int)tmp_post_100] = (unsigned char)((b2 - 0x7b) * 2 + 0xb5);
                                                                                    if(!(2 + i >= size + -1))
                                                                                    {
                                                                                      if((signed int)utext[(signed long int)(2 + i)] == 0xff)
                                                                                      {
                                                                                        if((signed int)utext[(signed long int)(3 + i)] == 0x9e)
                                                                                        {
                                                                                          utext[(signed long int)(wi - 1)] = utext[(signed long int)(wi - 1)] + (unsigned char)1;
                                                                                          i = i + 2;
                                                                                        }

                                                                                      }

                                                                                    }

                                                                                  }

                                                                                  else
                                                                                    if(b2 >= 0x80 && !(b2 >= 133))
                                                                                    {
                                                                                      tmp_post_101 = wi;
                                                                                      wi = wi + 1;
                                                                                      utext[(signed long int)tmp_post_101] = (unsigned char)0x30;
                                                                                      tmp_post_102 = wi;
                                                                                      wi = wi + 1;
                                                                                      utext[(signed long int)tmp_post_102] = (unsigned char)((b2 - 0x80) * 2 + 0xbf + (b2 >= 0x82 ? 1 : 0));
                                                                                      if(!(2 + i >= size + -1))
                                                                                      {
                                                                                        if((signed int)utext[(signed long int)(2 + i)] == 0xff)
                                                                                        {
                                                                                          if((signed int)utext[(signed long int)(3 + i)] == 0x9e)
                                                                                          {
                                                                                            utext[(signed long int)(wi - 1)] = utext[(signed long int)(wi - 1)] + (unsigned char)1;
                                                                                            i = i + 2;
                                                                                          }

                                                                                        }

                                                                                      }

                                                                                    }

                                                                                    else
                                                                                      if(b2 >= 0x85 && !(b2 >= 138))
                                                                                      {
                                                                                        tmp_post_103 = wi;
                                                                                        wi = wi + 1;
                                                                                        utext[(signed long int)tmp_post_103] = (unsigned char)0x30;
                                                                                        tmp_post_104 = wi;
                                                                                        wi = wi + 1;
                                                                                        utext[(signed long int)tmp_post_104] = (unsigned char)((b2 - 0x85) + 0xca);
                                                                                      }

                                                                                      else
                                                                                        if(b2 >= 0x8a && !(b2 >= 143))
                                                                                        {
                                                                                          tmp_post_105 = wi;
                                                                                          wi = wi + 1;
                                                                                          utext[(signed long int)tmp_post_105] = (unsigned char)0x30;
                                                                                          tmp_post_106 = wi;
                                                                                          wi = wi + 1;
                                                                                          utext[(signed long int)tmp_post_106] = (unsigned char)((b2 - 0x8a) * 3 + 0xcf);
                                                                                          if(!(2 + i >= size + -1))
                                                                                          {
                                                                                            if((signed int)utext[(signed long int)(2 + i)] == 0xff)
                                                                                              tmp_if_expr_107 = (signed int)utext[(signed long int)(i + 3)] == 0x9e ? (_Bool)1 : (_Bool)0;

                                                                                            else
                                                                                              tmp_if_expr_107 = (_Bool)0;
                                                                                            if(tmp_if_expr_107)
                                                                                            {
                                                                                              utext[(signed long int)(wi - 1)] = utext[(signed long int)(wi - 1)] + (unsigned char)1;
                                                                                              i = i + 2;
                                                                                            }

                                                                                            else
                                                                                              if((signed int)utext[(signed long int)(2 + i)] == 0xff)
                                                                                              {
                                                                                                if((signed int)utext[(signed long int)(3 + i)] == 0x9f)
                                                                                                {
                                                                                                  utext[(signed long int)(wi - 1)] = utext[(signed long int)(wi - 1)] + (unsigned char)2;
                                                                                                  i = i + 2;
                                                                                                }

                                                                                              }

                                                                                          }

                                                                                        }

                                                                                        else
                                                                                          if(b2 >= 0x8f && !(b2 >= 148))
                                                                                          {
                                                                                            tmp_post_108 = wi;
                                                                                            wi = wi + 1;
                                                                                            utext[(signed long int)tmp_post_108] = (unsigned char)0x30;
                                                                                            tmp_post_109 = wi;
                                                                                            wi = wi + 1;
                                                                                            utext[(signed long int)tmp_post_109] = (unsigned char)((b2 - 0x8f) + 0xde);
                                                                                          }

                                                                                          else
                                                                                            if(b2 >= 0x94 && !(b2 >= 151))
                                                                                            {
                                                                                              tmp_post_110 = wi;
                                                                                              wi = wi + 1;
                                                                                              utext[(signed long int)tmp_post_110] = (unsigned char)0x30;
                                                                                              tmp_post_111 = wi;
                                                                                              wi = wi + 1;
                                                                                              utext[(signed long int)tmp_post_111] = (unsigned char)((b2 - 0x94) * 2 + 0xe4);
                                                                                            }

                                                                                            else
                                                                                              if(b2 >= 0x97 && !(b2 >= 156))
                                                                                              {
                                                                                                tmp_post_112 = wi;
                                                                                                wi = wi + 1;
                                                                                                utext[(signed long int)tmp_post_112] = (unsigned char)0x30;
                                                                                                tmp_post_113 = wi;
                                                                                                wi = wi + 1;
                                                                                                utext[(signed long int)tmp_post_113] = (unsigned char)((b2 - 0x97) + 0xe9);
                                                                                              }

                                                                                              else
                                                                                                if(b2 == 0x9c)
                                                                                                {
                                                                                                  tmp_post_114 = wi;
                                                                                                  wi = wi + 1;
                                                                                                  utext[(signed long int)tmp_post_114] = (unsigned char)0x30;
                                                                                                  tmp_post_115 = wi;
                                                                                                  wi = wi + 1;
                                                                                                  utext[(signed long int)tmp_post_115] = (unsigned char)0xef;
                                                                                                }

                                                                                                else
                                                                                                  if(b2 == 0x9d)
                                                                                                  {
                                                                                                    tmp_post_116 = wi;
                                                                                                    wi = wi + 1;
                                                                                                    utext[(signed long int)tmp_post_116] = (unsigned char)0x30;
                                                                                                    tmp_post_117 = wi;
                                                                                                    wi = wi + 1;
                                                                                                    utext[(signed long int)tmp_post_117] = (unsigned char)0xf3;
                                                                                                  }

                                                                                                  else
                                                                                                  {
                                                                                                    tmp_post_118 = wi;
                                                                                                    wi = wi + 1;
                                                                                                    utext[(signed long int)tmp_post_118] = (unsigned char)b1;
                                                                                                    tmp_post_119 = wi;
                                                                                                    wi = wi + 1;
                                                                                                    utext[(signed long int)tmp_post_119] = (unsigned char)b2;
                                                                                                  }
            }

            else
            {
              tmp_post_120 = wi;
              wi = wi + 1;
              utext[(signed long int)tmp_post_120] = (unsigned char)b1;
              tmp_post_121 = wi;
              wi = wi + 1;
              utext[(signed long int)tmp_post_121] = (unsigned char)b2;
            }
  }
  *sp = wi;
}

// est_parse_search_body
// file estnode.c line 2186
static void est_parse_search_body(struct anonymous_17 *nres, char *str)
{
  struct anonymous_5 *attrs;
  char *pv;
  char *ep;
  char *mp;
  pv = str;
  attrs=cbmapopenex(31);
  for( ; (_Bool)1; pv = ep + (signed long int)1)
  {
    ep=strchr(pv, 10);
    if(ep == ((char *)NULL) || ep == pv)
      break;

    *ep = (char)0;
    cbstrtrim(pv);
    if((signed int)*pv == 0)
      break;

    if((signed int)*pv == 37)
    {
      signed int return_value_cbstrfwmatch_1;
      return_value_cbstrfwmatch_1=cbstrfwmatch(pv, "%VECTOR");
      if(!(return_value_cbstrfwmatch_1 == 0))
      {
        pv=strchr(pv, 9);
        if(!(pv == ((char *)NULL)))
          cbmapput(attrs, "%VECTOR", -1, pv + (signed long int)1, -1, 0);

      }

    }

    else
    {
      mp=strchr(pv, 61);
      if(!(mp == ((char *)NULL)))
      {
        *mp = (char)0;
        cbmapput(attrs, pv, -1, mp + (signed long int)1, -1, 1);
      }

    }
  }
  for( ; (_Bool)1; pv = pv + 1l)
    if(!((signed int)*pv == 13))
    {
      if(!((signed int)*pv == 10))
        goto __CPROVER_DUMP_L7;

    }


__CPROVER_DUMP_L7:
  ;
  char *return_value_cbmemdup_2;
  return_value_cbmemdup_2=cbmemdup(pv, -1);
  est_noderes_add_doc(nres, attrs, return_value_cbmemdup_2);
}

// est_parse_search_header
// file estnode.c line 2168
static void est_parse_search_header(struct anonymous_17 *nres, const char *str)
{
  struct anonymous_6 *lines;
  const char *line;
  const char *pv;
  signed int i;
  lines=cbsplit(str, -1, "\r\n");
  i = 0;
  signed int return_value_cblistnum_1;
  _Bool tmp_if_expr_2;
  do
  {
    return_value_cblistnum_1=cblistnum(lines);
    if(i >= return_value_cblistnum_1)
      break;

    line=cblistval(lines, i, (signed int *)(void *)0);
    pv=strchr(line, 9);
    if(pv == ((const char *)NULL) || pv == line)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)pv[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_2)
      cbmapput(nres->hints, line, (signed int)(pv - line), pv + (signed long int)1, -1, 0);

    i = i + 1;
  }
  while((_Bool)1);
  cblistclose(lines);
}

// est_phrase_from_isect
// file estraier.c line 6730
static char * est_phrase_from_isect(const char *iphrase)
{
  struct anonymous_9 *datum;
  struct anonymous_6 *terms;
  const char *term;
  unsigned char *utext;
  char *rtext;
  signed int i;
  signed int size;
  do
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_9) /*16ul*/ );
    datum = (struct anonymous_9 *)return_value_malloc_1;
    if(!(datum == ((struct anonymous_9 *)NULL)))
      datum;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)12);
    datum->dptr = (char *)return_value_malloc_2;
    if(!(datum->dptr == ((char *)NULL)))
      datum->dptr;

    else
      cbmyfatal("out of memory");
    datum->dptr[(signed long int)0] = (char)0;
    datum->dsize = 0;
    datum->asize = 12;
  }
  while((_Bool)0);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(iphrase);
  char *return_value_est_uconv_in_4;
  return_value_est_uconv_in_4=est_uconv_in(iphrase, (signed int)return_value_strlen_3, &size);
  utext = (unsigned char *)return_value_est_uconv_in_4;
  est_normalize_text(utext, size, &size);
  est_canonicalize_text(utext, size, 0);
  rtext=est_uconv_out((char *)utext, size, (signed int *)(void *)0);
  cbstrsqzspc(rtext);
  terms=cbsplit(rtext, -1, " ");
  i = 0;
  for( ; !(i >= terms->num); i = i + 1)
  {
    size = (terms->array + (signed long int)(terms->start + i))->dsize;
    term = (const char *)(terms->array + (signed long int)(terms->start + i))->dptr;
    if(size >= 1)
    {
      if(datum->dsize >= 1)
        do
        {
          if(5 + datum->dsize >= datum->asize)
          {
            datum->asize = datum->asize * 2 + 5 + 1;
            void *return_value_realloc_5;
            return_value_realloc_5=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc_5;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)" AND ", (unsigned long int)5);
          datum->dsize = datum->dsize + 5;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);

      do
      {
        if(datum->dsize + size >= datum->asize)
        {
          datum->asize = datum->asize * 2 + size + 1;
          void *return_value_realloc_6;
          return_value_realloc_6=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_6;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)term, (unsigned long int)size);
        datum->dsize = datum->dsize + size;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
    }

  }
  do
  {
    signed int _CB_i;
    signed int _CB_end = terms->start + terms->num;
    _CB_i = terms->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(terms->array + (signed long int)_CB_i)->dptr);
    free((void *)terms->array);
    free((void *)terms);
  }
  while((_Bool)0);
  free((void *)rtext);
  free((void *)utext);
  char *return_value_cbdatumtomalloc_7;
  return_value_cbdatumtomalloc_7=cbdatumtomalloc(datum, (signed int *)(void *)0);
  return return_value_cbdatumtomalloc_7;
}

// est_phrase_from_rough
// file estraier.c line 6632
static char * est_phrase_from_rough(const char *rphrase)
{
  struct anonymous_9 *datum;
  const char *oper;
  const char *rp;
  unsigned char *utext;
  char *rtext;
  signed int size;
  signed int quote;
  signed int lw;
  do
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_9) /*16ul*/ );
    datum = (struct anonymous_9 *)return_value_malloc_1;
    if(!(datum == ((struct anonymous_9 *)NULL)))
      datum;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)12);
    datum->dptr = (char *)return_value_malloc_2;
    if(!(datum->dptr == ((char *)NULL)))
      datum->dptr;

    else
      cbmyfatal("out of memory");
    datum->dptr[(signed long int)0] = (char)0;
    datum->dsize = 0;
    datum->asize = 12;
  }
  while((_Bool)0);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(rphrase);
  char *return_value_est_uconv_in_4;
  return_value_est_uconv_in_4=est_uconv_in(rphrase, (signed int)return_value_strlen_3, &size);
  utext = (unsigned char *)return_value_est_uconv_in_4;
  est_normalize_text(utext, size, &size);
  est_canonicalize_text(utext, size, 0);
  rtext=est_uconv_out((char *)utext, size, (signed int *)(void *)0);
  cbstrsqzspc(rtext);
  quote = 0;
  oper = (const char *)(void *)0;
  lw = 0;
  rp = rtext;
  for( ; !((signed int)*rp == 0); rp = rp + 1l)
    if((signed int)*rp == 34)
    {
      if(!(oper == ((const char *)NULL)))
      {
        do
        {
          unsigned long int return_value_strlen_7;
          return_value_strlen_7=strlen(oper);
          if(return_value_strlen_7 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
          {
            unsigned long int return_value_strlen_5;
            return_value_strlen_5=strlen(oper);
            datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen_5 + (unsigned long int)1);
            void *return_value_realloc_6;
            return_value_realloc_6=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc_6;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          unsigned long int return_value_strlen_8;
          return_value_strlen_8=strlen(oper);
          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)oper, return_value_strlen_8);
          unsigned long int return_value_strlen_9;
          return_value_strlen_9=strlen(oper);
          datum->dsize = datum->dsize + (signed int)return_value_strlen_9;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);
        oper = (const char *)(void *)0;
      }

      quote = (signed int)!(quote != 0);
    }

    else
      if(!(quote == 0))
        do
        {
          if(1 + datum->dsize >= datum->asize)
          {
            datum->asize = datum->asize * 2 + 1 + 1;
            void *return_value_realloc_10;
            return_value_realloc_10=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc_10;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)rp, (unsigned long int)1);
          datum->dsize = datum->dsize + 1;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);

      else
        switch((signed int)*rp)
        {
          case 32:
          {
            if(oper == ((const char *)NULL))
              oper = " AND ";

            lw = 0;
            break;
          }
          case 38:
          {
            oper = " AND ";
            lw = 0;
            break;
          }
          case 124:
          {
            oper = " OR ";
            lw = 0;
            break;
          }
          case 45:
          {
            if(!(lw == 0))
              do
              {
                if(1 + datum->dsize >= datum->asize)
                {
                  datum->asize = datum->asize * 2 + 1 + 1;
                  void *return_value_realloc_11;
                  return_value_realloc_11=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                  datum->dptr = (char *)return_value_realloc_11;
                  if(!(datum->dptr == ((char *)NULL)))
                    datum->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)rp, (unsigned long int)1);
                datum->dsize = datum->dsize + 1;
                datum->dptr[(signed long int)datum->dsize] = (char)0;
              }
              while((_Bool)0);

            else
              oper = " ANDNOT ";
            break;
          }
          default:
          {
            if(!(oper == ((const char *)NULL)))
            {
              do
              {
                unsigned long int return_value_strlen_14;
                return_value_strlen_14=strlen(oper);
                if(return_value_strlen_14 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
                {
                  unsigned long int return_value_strlen_12;
                  return_value_strlen_12=strlen(oper);
                  datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen_12 + (unsigned long int)1);
                  void *return_value_realloc_13;
                  return_value_realloc_13=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                  datum->dptr = (char *)return_value_realloc_13;
                  if(!(datum->dptr == ((char *)NULL)))
                    datum->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                unsigned long int return_value_strlen_15;
                return_value_strlen_15=strlen(oper);
                memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)oper, return_value_strlen_15);
                unsigned long int return_value_strlen_16;
                return_value_strlen_16=strlen(oper);
                datum->dsize = datum->dsize + (signed int)return_value_strlen_16;
                datum->dptr[(signed long int)datum->dsize] = (char)0;
              }
              while((_Bool)0);
              oper = (const char *)(void *)0;
            }

            do
            {
              if(1 + datum->dsize >= datum->asize)
              {
                datum->asize = datum->asize * 2 + 1 + 1;
                void *return_value_realloc_17;
                return_value_realloc_17=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                datum->dptr = (char *)return_value_realloc_17;
                if(!(datum->dptr == ((char *)NULL)))
                  datum->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)rp, (unsigned long int)1);
              datum->dsize = datum->dsize + 1;
              datum->dptr[(signed long int)datum->dsize] = (char)0;
            }
            while((_Bool)0);
            lw = 1;
          }
        }
  free((void *)rtext);
  free((void *)utext);
  char *return_value_cbdatumtomalloc_18;
  return_value_cbdatumtomalloc_18=cbdatumtomalloc(datum, (signed int *)(void *)0);
  return return_value_cbdatumtomalloc_18;
}

// est_phrase_from_simple
// file estraier.c line 6549
static char * est_phrase_from_simple(const char *sphrase)
{
  struct anonymous_9 *datum;
  const char *oper;
  const char *rp;
  const char *pv;
  unsigned char *utext;
  char *rtext;
  signed int size;
  signed int quote;
  signed int lw;
  do
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_9) /*16ul*/ );
    datum = (struct anonymous_9 *)return_value_malloc_1;
    if(!(datum == ((struct anonymous_9 *)NULL)))
      datum;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)12);
    datum->dptr = (char *)return_value_malloc_2;
    if(!(datum->dptr == ((char *)NULL)))
      datum->dptr;

    else
      cbmyfatal("out of memory");
    datum->dptr[(signed long int)0] = (char)0;
    datum->dsize = 0;
    datum->asize = 12;
  }
  while((_Bool)0);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(sphrase);
  char *return_value_est_uconv_in_4;
  return_value_est_uconv_in_4=est_uconv_in(sphrase, (signed int)return_value_strlen_3, &size);
  utext = (unsigned char *)return_value_est_uconv_in_4;
  est_normalize_text(utext, size, &size);
  est_canonicalize_text(utext, size, 0);
  rtext=est_uconv_out((char *)utext, size, (signed int *)(void *)0);
  cbstrsqzspc(rtext);
  quote = 0;
  oper = (const char *)(void *)0;
  lw = 0;
  rp = rtext;
  _Bool tmp_if_expr_36;
  _Bool tmp_if_expr_40;
  _Bool tmp_if_expr_38;
  _Bool tmp_if_expr_39;
  for( ; !((signed int)*rp == 0); rp = rp + 1l)
    if((signed int)*rp == 34)
    {
      if(!(oper == ((const char *)NULL)))
      {
        do
        {
          unsigned long int return_value_strlen_7;
          return_value_strlen_7=strlen(oper);
          if(return_value_strlen_7 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
          {
            unsigned long int return_value_strlen_5;
            return_value_strlen_5=strlen(oper);
            datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen_5 + (unsigned long int)1);
            void *return_value_realloc_6;
            return_value_realloc_6=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc_6;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          unsigned long int return_value_strlen_8;
          return_value_strlen_8=strlen(oper);
          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)oper, return_value_strlen_8);
          unsigned long int return_value_strlen_9;
          return_value_strlen_9=strlen(oper);
          datum->dsize = datum->dsize + (signed int)return_value_strlen_9;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);
        oper = (const char *)(void *)0;
      }

      quote = (signed int)!(quote != 0);
    }

    else
      if(!(quote == 0))
        do
        {
          if(1 + datum->dsize >= datum->asize)
          {
            datum->asize = datum->asize * 2 + 1 + 1;
            void *return_value_realloc_10;
            return_value_realloc_10=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc_10;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)rp, (unsigned long int)1);
          datum->dsize = datum->dsize + 1;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);

      else
        switch((signed int)*rp)
        {
          case 32:
          {
            if(oper == ((const char *)NULL))
              oper = " AND ";

            lw = 0;
            break;
          }
          case 38:
          {
            oper = " AND ";
            lw = 0;
            break;
          }
          case 124:
          {
            oper = " OR ";
            lw = 0;
            break;
          }
          case 33:
          {
            oper = " ANDNOT ";
            lw = 0;
            break;
          }
          default:
          {
            if(!(oper == ((const char *)NULL)))
            {
              do
              {
                unsigned long int return_value_strlen_13;
                return_value_strlen_13=strlen(oper);
                if(return_value_strlen_13 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
                {
                  unsigned long int return_value_strlen_11;
                  return_value_strlen_11=strlen(oper);
                  datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen_11 + (unsigned long int)1);
                  void *return_value_realloc_12;
                  return_value_realloc_12=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                  datum->dptr = (char *)return_value_realloc_12;
                  if(!(datum->dptr == ((char *)NULL)))
                    datum->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                unsigned long int return_value_strlen_14;
                return_value_strlen_14=strlen(oper);
                memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)oper, return_value_strlen_14);
                unsigned long int return_value_strlen_15;
                return_value_strlen_15=strlen(oper);
                datum->dsize = datum->dsize + (signed int)return_value_strlen_15;
                datum->dptr[(signed long int)datum->dsize] = (char)0;
              }
              while((_Bool)0);
              oper = (const char *)(void *)0;
            }

            if(lw == 0)
            {
              pv = rp;
              for( ; !((signed int)*pv == 0); pv = pv + 1l)
                if((signed int)*pv == 32)
                  break;

              if(!(rp + 1l >= pv))
                tmp_if_expr_36 = (signed int)pv[(signed long int)-1] == 42 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_36 = (_Bool)0;
              if(tmp_if_expr_36)
              {
                if((signed int)*rp == 42)
                  do
                  {
                    unsigned long int return_value_strlen_18;
                    return_value_strlen_18=strlen("[RX]");
                    if(1ul + return_value_strlen_18 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
                    {
                      unsigned long int return_value_strlen_16;
                      return_value_strlen_16=strlen("[RX]");
                      datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen_16 + (unsigned long int)1 + (unsigned long int)1);
                      void *return_value_realloc_17;
                      return_value_realloc_17=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                      datum->dptr = (char *)return_value_realloc_17;
                      if(!(datum->dptr == ((char *)NULL)))
                        datum->dptr;

                      else
                        cbmyfatal("out of memory");
                    }

                    unsigned long int return_value_strlen_19;
                    return_value_strlen_19=strlen("[RX]");
                    memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"[RX] ", return_value_strlen_19 + (unsigned long int)1);
                    unsigned long int return_value_strlen_20;
                    return_value_strlen_20=strlen("[RX]");
                    datum->dsize = datum->dsize + (signed int)(return_value_strlen_20 + (unsigned long int)1);
                    datum->dptr[(signed long int)datum->dsize] = (char)0;
                  }
                  while((_Bool)0);

                else
                  do
                  {
                    unsigned long int return_value_strlen_23;
                    return_value_strlen_23=strlen("[BW]");
                    if(1ul + return_value_strlen_23 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
                    {
                      unsigned long int return_value_strlen_21;
                      return_value_strlen_21=strlen("[BW]");
                      datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen_21 + (unsigned long int)1 + (unsigned long int)1);
                      void *return_value_realloc_22;
                      return_value_realloc_22=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                      datum->dptr = (char *)return_value_realloc_22;
                      if(!(datum->dptr == ((char *)NULL)))
                        datum->dptr;

                      else
                        cbmyfatal("out of memory");
                    }

                    unsigned long int return_value_strlen_24;
                    return_value_strlen_24=strlen("[BW]");
                    memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"[BW] ", return_value_strlen_24 + (unsigned long int)1);
                    unsigned long int return_value_strlen_25;
                    return_value_strlen_25=strlen("[BW]");
                    datum->dsize = datum->dsize + (signed int)(return_value_strlen_25 + (unsigned long int)1);
                    datum->dptr[(signed long int)datum->dsize] = (char)0;
                  }
                  while((_Bool)0);
              }

              else
                if(!(rp + 1l >= pv))
                {
                  if((signed int)*rp == 42)
                  {
                    if((signed int)pv[-1l] == 42)
                      do
                      {
                        unsigned long int return_value_strlen_28;
                        return_value_strlen_28=strlen("[RX]");
                        if(1ul + return_value_strlen_28 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
                        {
                          unsigned long int return_value_strlen_26;
                          return_value_strlen_26=strlen("[RX]");
                          datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen_26 + (unsigned long int)1 + (unsigned long int)1);
                          void *return_value_realloc_27;
                          return_value_realloc_27=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                          datum->dptr = (char *)return_value_realloc_27;
                          if(!(datum->dptr == ((char *)NULL)))
                            datum->dptr;

                          else
                            cbmyfatal("out of memory");
                        }

                        unsigned long int return_value_strlen_29;
                        return_value_strlen_29=strlen("[RX]");
                        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"[RX] ", return_value_strlen_29 + (unsigned long int)1);
                        unsigned long int return_value_strlen_30;
                        return_value_strlen_30=strlen("[RX]");
                        datum->dsize = datum->dsize + (signed int)(return_value_strlen_30 + (unsigned long int)1);
                        datum->dptr[(signed long int)datum->dsize] = (char)0;
                      }
                      while((_Bool)0);

                    else
                      do
                      {
                        unsigned long int return_value_strlen_33;
                        return_value_strlen_33=strlen("[EW]");
                        if(1ul + return_value_strlen_33 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
                        {
                          unsigned long int return_value_strlen_31;
                          return_value_strlen_31=strlen("[EW]");
                          datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen_31 + (unsigned long int)1 + (unsigned long int)1);
                          void *return_value_realloc_32;
                          return_value_realloc_32=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                          datum->dptr = (char *)return_value_realloc_32;
                          if(!(datum->dptr == ((char *)NULL)))
                            datum->dptr;

                          else
                            cbmyfatal("out of memory");
                        }

                        unsigned long int return_value_strlen_34;
                        return_value_strlen_34=strlen("[EW]");
                        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"[EW] ", return_value_strlen_34 + (unsigned long int)1);
                        unsigned long int return_value_strlen_35;
                        return_value_strlen_35=strlen("[EW]");
                        datum->dsize = datum->dsize + (signed int)(return_value_strlen_35 + (unsigned long int)1);
                        datum->dptr[(signed long int)datum->dsize] = (char)0;
                      }
                      while((_Bool)0);
                  }

                }

            }

            if(!((signed int)*rp == 42))
              tmp_if_expr_40 = (_Bool)1;

            else
            {
              if(!(lw == 0))
                tmp_if_expr_38 = (signed int)rp[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_38 = (_Bool)0;
              if(tmp_if_expr_38)
                tmp_if_expr_39 = (signed int)rp[(signed long int)1] != 32 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_39 = (_Bool)0;
              tmp_if_expr_40 = tmp_if_expr_39 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_40)
              do
              {
                if(1 + datum->dsize >= datum->asize)
                {
                  datum->asize = datum->asize * 2 + 1 + 1;
                  void *return_value_realloc_37;
                  return_value_realloc_37=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                  datum->dptr = (char *)return_value_realloc_37;
                  if(!(datum->dptr == ((char *)NULL)))
                    datum->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)rp, (unsigned long int)1);
                datum->dsize = datum->dsize + 1;
                datum->dptr[(signed long int)datum->dsize] = (char)0;
              }
              while((_Bool)0);

            lw = 1;
          }
        }
  free((void *)rtext);
  free((void *)utext);
  char *return_value_cbdatumtomalloc_41;
  return_value_cbdatumtomalloc_41=cbdatumtomalloc(datum, (signed int *)(void *)0);
  return return_value_cbdatumtomalloc_41;
}

// est_phrase_from_union
// file estraier.c line 6699
static char * est_phrase_from_union(const char *uphrase)
{
  struct anonymous_9 *datum;
  struct anonymous_6 *terms;
  const char *term;
  unsigned char *utext;
  char *rtext;
  signed int i;
  signed int size;
  do
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_9) /*16ul*/ );
    datum = (struct anonymous_9 *)return_value_malloc_1;
    if(!(datum == ((struct anonymous_9 *)NULL)))
      datum;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)12);
    datum->dptr = (char *)return_value_malloc_2;
    if(!(datum->dptr == ((char *)NULL)))
      datum->dptr;

    else
      cbmyfatal("out of memory");
    datum->dptr[(signed long int)0] = (char)0;
    datum->dsize = 0;
    datum->asize = 12;
  }
  while((_Bool)0);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(uphrase);
  char *return_value_est_uconv_in_4;
  return_value_est_uconv_in_4=est_uconv_in(uphrase, (signed int)return_value_strlen_3, &size);
  utext = (unsigned char *)return_value_est_uconv_in_4;
  est_normalize_text(utext, size, &size);
  est_canonicalize_text(utext, size, 0);
  rtext=est_uconv_out((char *)utext, size, (signed int *)(void *)0);
  cbstrsqzspc(rtext);
  terms=cbsplit(rtext, -1, " ");
  i = 0;
  for( ; !(i >= terms->num); i = i + 1)
  {
    size = (terms->array + (signed long int)(terms->start + i))->dsize;
    term = (const char *)(terms->array + (signed long int)(terms->start + i))->dptr;
    if(size >= 1)
    {
      if(datum->dsize >= 1)
        do
        {
          if(4 + datum->dsize >= datum->asize)
          {
            datum->asize = datum->asize * 2 + 4 + 1;
            void *return_value_realloc_5;
            return_value_realloc_5=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc_5;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)" OR ", (unsigned long int)4);
          datum->dsize = datum->dsize + 4;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);

      do
      {
        if(datum->dsize + size >= datum->asize)
        {
          datum->asize = datum->asize * 2 + size + 1;
          void *return_value_realloc_6;
          return_value_realloc_6=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_6;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)term, (unsigned long int)size);
        datum->dsize = datum->dsize + size;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
    }

  }
  do
  {
    signed int _CB_i;
    signed int _CB_end = terms->start + terms->num;
    _CB_i = terms->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(terms->array + (signed long int)_CB_i)->dptr);
    free((void *)terms->array);
    free((void *)terms);
  }
  while((_Bool)0);
  free((void *)rtext);
  free((void *)utext);
  char *return_value_cbdatumtomalloc_7;
  return_value_cbdatumtomalloc_7=cbdatumtomalloc(datum, (signed int *)(void *)0);
  return return_value_cbdatumtomalloc_7;
}

// est_phrase_terms
// file estraier.c line 8020
static struct anonymous_6 * est_phrase_terms(const char *phrase)
{
  struct anonymous_6 *terms;
  struct anonymous_6 *elems;
  struct anonymous_9 *datum;
  const char *elem;
  char *tbuf;
  char *pbuf;
  signed int i;
  signed int tsiz;
  signed int psiz;
  signed int lw;
  do
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_6) /*24ul*/ );
    terms = (struct anonymous_6 *)return_value_malloc_1;
    if(!(terms == ((struct anonymous_6 *)NULL)))
      terms;

    else
      cbmyfatal("out of memory");
    terms->anum = 64;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)terms->anum);
    terms->array = (struct anonymous_28 *)return_value_malloc_2;
    if(!(terms->array == ((struct anonymous_28 *)NULL)))
      terms->array;

    else
      cbmyfatal("out of memory");
    terms->start = 0;
    terms->num = 0;
  }
  while((_Bool)0);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(phrase);
  tbuf=est_uconv_in(phrase, (signed int)return_value_strlen_3, &tsiz);
  est_normalize_text((unsigned char *)tbuf, tsiz, &tsiz);
  pbuf=est_uconv_out(tbuf, tsiz, &psiz);
  elems=cbsplit(pbuf, psiz, "\a\b\t\n\v\f\r ");
  do
  {
    void *return_value_malloc_4;
    return_value_malloc_4=malloc(sizeof(struct anonymous_9) /*16ul*/ );
    datum = (struct anonymous_9 *)return_value_malloc_4;
    if(!(datum == ((struct anonymous_9 *)NULL)))
      datum;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc_5;
    return_value_malloc_5=malloc((unsigned long int)12);
    datum->dptr = (char *)return_value_malloc_5;
    if(!(datum->dptr == ((char *)NULL)))
      datum->dptr;

    else
      cbmyfatal("out of memory");
    datum->dptr[(signed long int)0] = (char)0;
    datum->dsize = 0;
    datum->asize = 12;
  }
  while((_Bool)0);
  lw = 0;
  i = 0;
  signed int return_value_strcmp_33;
  signed int return_value_strcmp_32;
  signed int return_value_strcmp_31;
  signed int return_value_strcmp_28;
  _Bool tmp_if_expr_30;
  signed int return_value_strcmp_29;
  signed int tmp_if_expr_11;
  unsigned long int tmp_if_expr_17;
  unsigned long int return_value_strlen_16;
  for( ; !(i >= elems->num); i = i + 1)
  {
    elem = (const char *)(elems->array + (signed long int)(elems->start + i))->dptr;
    if(!((signed int)*elem == 0))
    {
      signed int return_value_strcmp_34;
      return_value_strcmp_34=strcmp(elem, "OR");
      if(return_value_strcmp_34 == 0)
      {
        if(!(datum->dsize >= 1))
          goto __CPROVER_DUMP_L70;

        if(!(lw == 0))
          do
          {
            if(1 + datum->dsize >= datum->asize)
            {
              datum->asize = datum->asize * 2 + 1 + 1;
              void *return_value_realloc_6;
              return_value_realloc_6=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
              datum->dptr = (char *)return_value_realloc_6;
              if(!(datum->dptr == ((char *)NULL)))
                datum->dptr;

              else
                cbmyfatal("out of memory");
            }

            memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\t", (unsigned long int)1);
            datum->dsize = datum->dsize + 1;
            datum->dptr[(signed long int)datum->dsize] = (char)0;
          }
          while((_Bool)0);

        lw = 0;
      }

      else
      {
        return_value_strcmp_33=strcmp(elem, "[BW]");
        if(return_value_strcmp_33 == 0)
        {
          if(lw == 0)
            do
            {
              if(2 + datum->dsize >= datum->asize)
              {
                datum->asize = datum->asize * 2 + 2 + 1;
                void *return_value_realloc_7;
                return_value_realloc_7=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                datum->dptr = (char *)return_value_realloc_7;
                if(!(datum->dptr == ((char *)NULL)))
                  datum->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)" b", (unsigned long int)2);
              datum->dsize = datum->dsize + 2;
              datum->dptr[(signed long int)datum->dsize] = (char)0;
            }
            while((_Bool)0);

        }

        else
        {
          return_value_strcmp_32=strcmp(elem, "[EW]");
          if(return_value_strcmp_32 == 0)
          {
            if(lw == 0)
              do
              {
                if(2 + datum->dsize >= datum->asize)
                {
                  datum->asize = datum->asize * 2 + 2 + 1;
                  void *return_value_realloc_8;
                  return_value_realloc_8=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                  datum->dptr = (char *)return_value_realloc_8;
                  if(!(datum->dptr == ((char *)NULL)))
                    datum->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)" e", (unsigned long int)2);
                datum->dsize = datum->dsize + 2;
                datum->dptr[(signed long int)datum->dsize] = (char)0;
              }
              while((_Bool)0);

          }

          else
          {
            return_value_strcmp_31=strcmp(elem, "[RX]");
            if(return_value_strcmp_31 == 0)
            {
              if(lw == 0)
                do
                {
                  if(2 + datum->dsize >= datum->asize)
                  {
                    datum->asize = datum->asize * 2 + 2 + 1;
                    void *return_value_realloc_9;
                    return_value_realloc_9=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                    datum->dptr = (char *)return_value_realloc_9;
                    if(!(datum->dptr == ((char *)NULL)))
                      datum->dptr;

                    else
                      cbmyfatal("out of memory");
                  }

                  memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)" r", (unsigned long int)2);
                  datum->dsize = datum->dsize + 2;
                  datum->dptr[(signed long int)datum->dsize] = (char)0;
                }
                while((_Bool)0);

            }

            else
            {
              return_value_strcmp_28=strcmp(elem, "AND");
              if(return_value_strcmp_28 == 0)
                tmp_if_expr_30 = (_Bool)1;

              else
              {
                return_value_strcmp_29=strcmp(elem, "ANDNOT");
                tmp_if_expr_30 = !(return_value_strcmp_29 != 0) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_30)
              {
                if(!(datum->dsize >= 1))
                  goto __CPROVER_DUMP_L70;

                do
                {
                  signed int _CB_index = terms->start + terms->num;
                  if(_CB_index >= terms->anum)
                  {
                    terms->anum = terms->anum * 2;
                    void *return_value_realloc_10;
                    return_value_realloc_10=realloc((void *)terms->array, (unsigned long int)terms->anum * sizeof(struct anonymous_28) /*16ul*/ );
                    terms->array = (struct anonymous_28 *)return_value_realloc_10;
                    if(!(terms->array == ((struct anonymous_28 *)NULL)))
                      terms->array;

                    else
                      cbmyfatal("out of memory");
                  }

                  if(!(datum->dsize >= 12))
                    tmp_if_expr_11 = 12;

                  else
                    tmp_if_expr_11 = (signed int)datum->dsize;
                  void *return_value_malloc_12;
                  return_value_malloc_12=malloc((unsigned long int)(tmp_if_expr_11 + 1));
                  (terms->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_12;
                  if(!((terms->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
                    (terms->array + (signed long int)_CB_index)->dptr;

                  else
                    cbmyfatal("out of memory");
                  memcpy((void *)(terms->array + (signed long int)_CB_index)->dptr, (const void *)(const char *)datum->dptr, (unsigned long int)(signed int)datum->dsize);
                  (terms->array + (signed long int)_CB_index)->dptr[(signed long int)(signed int)datum->dsize] = (char)0;
                  (terms->array + (signed long int)_CB_index)->dsize = (signed int)datum->dsize;
                  terms->num = terms->num + 1;
                }
                while((_Bool)0);
                do
                  if(datum->dsize >= 0)
                  {
                    datum->dsize = 0;
                    datum->dptr[(signed long int)0] = (char)0;
                  }

                  else
                  {
                    if(!(datum->asize >= 1))
                    {
                      datum->asize = datum->asize * 2 + 0 + 1;
                      void *return_value_realloc_13;
                      return_value_realloc_13=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                      datum->dptr = (char *)return_value_realloc_13;
                      if(!(datum->dptr == ((char *)NULL)))
                        datum->dptr;

                      else
                        cbmyfatal("out of memory");
                    }

                    memset((void *)(datum->dptr + (signed long int)datum->dsize), 0, (unsigned long int)((0 - datum->dsize) + 1));
                    datum->dsize = 0;
                  }
                while((_Bool)0);
                do
                {
                  signed int est_phrase_terms__1__3__1__5__3___CB_index = terms->start + terms->num;
                  if(est_phrase_terms__1__3__1__5__3___CB_index >= terms->anum)
                  {
                    terms->anum = terms->anum * 2;
                    void *return_value_realloc_14;
                    return_value_realloc_14=realloc((void *)terms->array, (unsigned long int)terms->anum * sizeof(struct anonymous_28) /*16ul*/ );
                    terms->array = (struct anonymous_28 *)return_value_realloc_14;
                    if(!(terms->array == ((struct anonymous_28 *)NULL)))
                      terms->array;

                    else
                      cbmyfatal("out of memory");
                  }

                  unsigned long int return_value_strlen_15;
                  return_value_strlen_15=strlen(elem);
                  if(!(return_value_strlen_15 >= 12ul))
                    tmp_if_expr_17 = (unsigned long int)12;

                  else
                  {
                    return_value_strlen_16=strlen(elem);
                    tmp_if_expr_17 = return_value_strlen_16;
                  }
                  void *return_value_malloc_18;
                  return_value_malloc_18=malloc(tmp_if_expr_17 + (unsigned long int)1);
                  (terms->array + (signed long int)est_phrase_terms__1__3__1__5__3___CB_index)->dptr = (char *)return_value_malloc_18;
                  if(!((terms->array + (signed long int)est_phrase_terms__1__3__1__5__3___CB_index)->dptr == ((char *)NULL)))
                    (terms->array + (signed long int)est_phrase_terms__1__3__1__5__3___CB_index)->dptr;

                  else
                    cbmyfatal("out of memory");
                  unsigned long int return_value_strlen_19;
                  return_value_strlen_19=strlen(elem);
                  memcpy((void *)(terms->array + (signed long int)est_phrase_terms__1__3__1__5__3___CB_index)->dptr, (const void *)elem, return_value_strlen_19);
                  unsigned long int return_value_strlen_20;
                  return_value_strlen_20=strlen(elem);
                  (terms->array + (signed long int)est_phrase_terms__1__3__1__5__3___CB_index)->dptr[(signed long int)return_value_strlen_20] = (char)0;
                  unsigned long int return_value_strlen_21;
                  return_value_strlen_21=strlen(elem);
                  (terms->array + (signed long int)est_phrase_terms__1__3__1__5__3___CB_index)->dsize = (signed int)return_value_strlen_21;
                  terms->num = terms->num + 1;
                }
                while((_Bool)0);
                lw = 0;
              }

              else
              {
                if(datum->dsize >= 1)
                {
                  if(!(lw == 0))
                    do
                    {
                      if(1 + datum->dsize >= datum->asize)
                      {
                        datum->asize = datum->asize * 2 + 1 + 1;
                        void *return_value_realloc_22;
                        return_value_realloc_22=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                        datum->dptr = (char *)return_value_realloc_22;
                        if(!(datum->dptr == ((char *)NULL)))
                          datum->dptr;

                        else
                          cbmyfatal("out of memory");
                      }

                      memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)" ", (unsigned long int)1);
                      datum->dsize = datum->dsize + 1;
                      datum->dptr[(signed long int)datum->dsize] = (char)0;
                    }
                    while((_Bool)0);

                }

                do
                {
                  unsigned long int return_value_strlen_25;
                  return_value_strlen_25=strlen(elem);
                  if(return_value_strlen_25 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
                  {
                    unsigned long int return_value_strlen_23;
                    return_value_strlen_23=strlen(elem);
                    datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen_23 + (unsigned long int)1);
                    void *return_value_realloc_24;
                    return_value_realloc_24=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                    datum->dptr = (char *)return_value_realloc_24;
                    if(!(datum->dptr == ((char *)NULL)))
                      datum->dptr;

                    else
                      cbmyfatal("out of memory");
                  }

                  unsigned long int return_value_strlen_26;
                  return_value_strlen_26=strlen(elem);
                  memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)elem, return_value_strlen_26);
                  unsigned long int return_value_strlen_27;
                  return_value_strlen_27=strlen(elem);
                  datum->dsize = datum->dsize + (signed int)return_value_strlen_27;
                  datum->dptr[(signed long int)datum->dsize] = (char)0;
                }
                while((_Bool)0);
                lw = 1;
              }
            }
          }
        }
      }
    }


  __CPROVER_DUMP_L70:
    ;
  }
  signed int tmp_if_expr_36;
  if(datum->dsize >= 1)
    do
    {
      signed int est_phrase_terms__1__4___CB_index = terms->start + terms->num;
      if(est_phrase_terms__1__4___CB_index >= terms->anum)
      {
        terms->anum = terms->anum * 2;
        void *return_value_realloc_35;
        return_value_realloc_35=realloc((void *)terms->array, (unsigned long int)terms->anum * sizeof(struct anonymous_28) /*16ul*/ );
        terms->array = (struct anonymous_28 *)return_value_realloc_35;
        if(!(terms->array == ((struct anonymous_28 *)NULL)))
          terms->array;

        else
          cbmyfatal("out of memory");
      }

      if(!(datum->dsize >= 12))
        tmp_if_expr_36 = 12;

      else
        tmp_if_expr_36 = (signed int)datum->dsize;
      void *return_value_malloc_37;
      return_value_malloc_37=malloc((unsigned long int)(tmp_if_expr_36 + 1));
      (terms->array + (signed long int)est_phrase_terms__1__4___CB_index)->dptr = (char *)return_value_malloc_37;
      if(!((terms->array + (signed long int)est_phrase_terms__1__4___CB_index)->dptr == ((char *)NULL)))
        (terms->array + (signed long int)est_phrase_terms__1__4___CB_index)->dptr;

      else
        cbmyfatal("out of memory");
      memcpy((void *)(terms->array + (signed long int)est_phrase_terms__1__4___CB_index)->dptr, (const void *)(const char *)datum->dptr, (unsigned long int)(signed int)datum->dsize);
      (terms->array + (signed long int)est_phrase_terms__1__4___CB_index)->dptr[(signed long int)(signed int)datum->dsize] = (char)0;
      (terms->array + (signed long int)est_phrase_terms__1__4___CB_index)->dsize = (signed int)datum->dsize;
      terms->num = terms->num + 1;
    }
    while((_Bool)0);

  do
  {
    free((void *)datum->dptr);
    free((void *)datum);
  }
  while((_Bool)0);
  do
  {
    signed int _CB_i;
    signed int _CB_end = elems->start + elems->num;
    _CB_i = elems->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(elems->array + (signed long int)_CB_i)->dptr);
    free((void *)elems->array);
    free((void *)elems);
  }
  while((_Bool)0);
  free((void *)pbuf);
  free((void *)tbuf);
  i = 0;
  _Bool tmp_if_expr_40;
  signed int return_value_strcmp_39;
  _Bool tmp_if_expr_42;
  signed int return_value_strcmp_41;
  for( ; !(i >= terms->num); i = i + 1)
  {
    elem = (const char *)(terms->array + (signed long int)(terms->start + i))->dptr;
    signed int return_value_strcmp_38;
    return_value_strcmp_38=strcmp(elem, "[UVSET]");
    if(return_value_strcmp_38 == 0)
      tmp_if_expr_40 = (_Bool)1;

    else
    {
      return_value_strcmp_39=strcmp(elem, "AND");
      tmp_if_expr_40 = !(return_value_strcmp_39 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_40)
      tmp_if_expr_42 = (_Bool)1;

    else
    {
      return_value_strcmp_41=strcmp(elem, "ANDNOT");
      tmp_if_expr_42 = !(return_value_strcmp_41 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_42)
    {
      unsigned long int return_value_strlen_43;
      return_value_strlen_43=strlen(elem);
      tbuf=est_uconv_in(elem, (signed int)return_value_strlen_43, &tsiz);
      est_canonicalize_text((unsigned char *)tbuf, tsiz, 1);
      pbuf=est_uconv_out(tbuf, tsiz, &psiz);
      cblistover(terms, i, pbuf, -1);
      free((void *)pbuf);
      free((void *)tbuf);
    }

  }
  i = (signed int)terms->num - 1;
  signed int return_value_strcmp_44;
  for( ; i >= 0; i = i - 1)
  {
    elem = (const char *)(terms->array + (signed long int)(terms->start + i))->dptr;
    signed int return_value_strcmp_45;
    return_value_strcmp_45=strcmp(elem, "AND");
    if(!(return_value_strcmp_45 == 0))
    {
      return_value_strcmp_44=strcmp(elem, "ANDNOT");
      if(!(return_value_strcmp_44 == 0))
        break;

    }

    do
      if(terms->num >= 1)
      {
        free((void *)(terms->array + (signed long int)((terms->start + terms->num) - 1))->dptr);
        terms->num = terms->num - 1;
      }

    while((_Bool)0);
  }
  return terms;
}

// est_phrase_vector
// file estraier.c line 10301
static struct anonymous_5 * est_phrase_vector(const char *phrase)
{
  struct anonymous_31 *scores;
  struct anonymous_5 *svmap;
  struct anonymous_6 *list;
  const char *pv;
  const char *rp;
  char *utext;
  char *rtext;
  signed int i;
  signed int num;
  signed int len;
  signed int size;
  svmap=cbmapopenex(31);
  do
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_6) /*24ul*/ );
    list = (struct anonymous_6 *)return_value_malloc_1;
    if(!(list == ((struct anonymous_6 *)NULL)))
      list;

    else
      cbmyfatal("out of memory");
    list->anum = 64;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)list->anum);
    list->array = (struct anonymous_28 *)return_value_malloc_2;
    if(!(list->array == ((struct anonymous_28 *)NULL)))
      list->array;

    else
      cbmyfatal("out of memory");
    list->start = 0;
    list->num = 0;
  }
  while((_Bool)0);
  _Bool tmp_if_expr_8;
  signed int return_value_cbstrfwmatch_7;
  signed int return_value_cbstrfwmatch_4;
  while(!((signed int)*phrase == 0))
  {
    if(*phrase == 'W')
    {
      return_value_cbstrfwmatch_7=cbstrfwmatch(phrase, "WITH");
      tmp_if_expr_8 = return_value_cbstrfwmatch_7 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    if(tmp_if_expr_8)
    {
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen("WITH");
      phrase = phrase + (signed long int)return_value_strlen_3;
      pv = phrase;
      while(!((signed int)*phrase == 0))
      {
        if(!((signed int)*phrase >= 33))
        {
          return_value_cbstrfwmatch_4=cbstrfwmatch(phrase + (signed long int)1, "WITH");
          if(!(return_value_cbstrfwmatch_4 == 0))
          {
            phrase = phrase + 1l;
            break;
          }

        }

        phrase = phrase + 1l;
      }
      do
      {
        signed int _CB_index = list->start + list->num;
        if(_CB_index >= list->anum)
        {
          list->anum = list->anum * 2;
          void *return_value_realloc_5;
          return_value_realloc_5=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous_28) /*16ul*/ );
          list->array = (struct anonymous_28 *)return_value_realloc_5;
          if(!(list->array == ((struct anonymous_28 *)NULL)))
            list->array;

          else
            cbmyfatal("out of memory");
        }

        void *return_value_malloc_6;
        return_value_malloc_6=malloc((unsigned long int)((phrase - pv < (signed long int)12 ? (signed long int)12 : phrase - pv) + (signed long int)1));
        (list->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_6;
        if(!((list->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
          (list->array + (signed long int)_CB_index)->dptr;

        else
          cbmyfatal("out of memory");
        memcpy((void *)(list->array + (signed long int)_CB_index)->dptr, (const void *)pv, (unsigned long int)(phrase - pv));
        (list->array + (signed long int)_CB_index)->dptr[phrase - pv] = (char)0;
        (list->array + (signed long int)_CB_index)->dsize = (signed int)(phrase - pv);
        list->num = list->num + 1;
      }
      while((_Bool)0);
    }

    else
      phrase = phrase + 1l;
  }
  i = 0;
  for( ; !(i >= list->num); i = i + 1)
  {
    pv = (const char *)(list->array + (signed long int)(list->start + i))->dptr;
    for( ; (signed int)*pv >= 1; pv = pv + 1l)
      if((signed int)*pv >= 33)
        break;

    signed long int return_value_strtol_9;
    return_value_strtol_9=strtol(pv, (char **)&rp, 10);
    num = (signed int)return_value_strtol_9;
    if(!(rp == ((const char *)NULL)))
    {
      len = (signed int)(rp - pv);
      if(len >= 1)
      {
        if(num >= 0)
        {
          unsigned long int return_value_strlen_10;
          return_value_strlen_10=strlen(rp);
          utext=est_uconv_in(rp, (signed int)return_value_strlen_10, &size);
          est_normalize_text((unsigned char *)utext, size, &size);
          est_canonicalize_text((unsigned char *)utext, size, 0);
          rtext=est_uconv_out(utext, size, (signed int *)(void *)0);
          cbstrsqzspc(rtext);
          if(!((signed int)*rtext == 0))
            cbmapput(svmap, rtext, -1, pv, len, 0);

          free((void *)rtext);
          free((void *)utext);
        }

      }

    }

  }
  do
  {
    signed int _CB_i;
    signed int _CB_end = list->start + list->num;
    _CB_i = list->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(list->array + (signed long int)_CB_i)->dptr);
    free((void *)list->array);
    free((void *)list);
  }
  while((_Bool)0);
  signed int return_value_cbmaprnum_11;
  return_value_cbmaprnum_11=cbmaprnum(svmap);
  void *return_value_malloc_12;
  return_value_malloc_12=malloc((unsigned long int)return_value_cbmaprnum_11 * sizeof(struct anonymous_31) /*16ul*/  + (unsigned long int)1);
  scores = (struct anonymous_31 *)return_value_malloc_12;
  if(!(scores == ((struct anonymous_31 *)NULL)))
    scores;

  else
    cbmyfatal("out of memory");
  cbmapiterinit(svmap);
  i = 0;
  do
  {
    rp=cbmapiternext(svmap, &len);
    if(rp == ((const char *)NULL))
      break;

    (scores + (signed long int)i)->word = rp;
    (scores + (signed long int)i)->wsiz = len;
    const char *return_value_cbmapiterval_13;
    return_value_cbmapiterval_13=cbmapiterval(rp, (signed int *)(void *)0);
    (scores + (signed long int)i)->pt=atoi(return_value_cbmapiterval_13);
    i = i + 1;
  }
  while((_Bool)1);
  qsort((void *)scores, (unsigned long int)i, sizeof(struct anonymous_31) /*16ul*/ , est_keysc_compare);
  i = i - 1;
  for( ; i >= 0; i = i - 1)
    cbmapmove(svmap, (scores + (signed long int)i)->word, (scores + (signed long int)i)->wsiz, 1);
  free((void *)scores);
  return svmap;
}

// est_pidx_uri_to_id
// file estraier.c line 7997
static signed int est_pidx_uri_to_id(struct anonymous_0 *db, const char *uri)
{
  struct anonymous_14 *doc;
  const char *vbuf;
  signed int i;
  signed int vsiz;
  if(db->puris == ((struct anonymous_5 *)NULL))
  {
    db->puris=cbmapopenex((signed int)db->pdocs->num + 1);
    i = 0;
    for( ; !(i >= db->pdocs->num); i = i + 1)
    {
      doc=est_db_get_doc(db, 2000000001 + i, 0);
      if(!(doc == ((struct anonymous_14 *)NULL)))
      {
        vbuf=cbmapget(doc->attrs, "@uri", -1, &vsiz);
        if(!(vbuf == ((const char *)NULL)))
          cbmapput(db->puris, vbuf, vsiz, (char *)&doc->id, (signed int)sizeof(signed int) /*4ul*/ , 0);

        est_doc_delete(doc);
      }

    }
  }

  vbuf=cbmapget(db->puris, uri, -1, (signed int *)(void *)0);
  if(!(vbuf == ((const char *)NULL)))
    return *((signed int *)vbuf);

  else
    return -1;
}

// est_proc_env_reset
// file estraier.h line 1485
void est_proc_env_reset(void)
{
  char *value;
  char *pbuf;
  cbstdiobin();
  putenv("LANG=C");
  putenv("LANGUAGE=C");
  putenv("LC_CTYPE=C");
  putenv("LC_COLLATE=C");
  putenv("LC_TIME=C");
  putenv("LC_NUMERIC=C");
  putenv("LC_MONETARY=C");
  putenv("LC_ALL=C");
  putenv("EST_VERSION=1.4.13");
  value=getenv("PATH");
  if(!(value == ((char *)NULL)))
  {
    pbuf=cbsprintf("PATH=%s:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin", value);
    putenv(pbuf);
    cbglobalgc((void *)pbuf, free);
  }

}

// est_random
// file estraier.c line 4058
double est_random(void)
{
  signed int num;
  static signed int first = 1;
  if(est_random_ifp == ((struct _IO_FILE *)NULL) && !(first == 0))
  {
    est_random_ifp=fopen("/dev/urandom", "rb");
    if(!(est_random_ifp == ((struct _IO_FILE *)NULL)))
      atexit(est_random_fclose);

    else
    {
      signed int return_value_getpid_1;
      return_value_getpid_1=getpid();
      srand((unsigned int)return_value_getpid_1);
    }
    first = 0;
  }

  if(!(est_random_ifp == ((struct _IO_FILE *)NULL)))
  {
    fread((void *)&num, sizeof(signed int) /*4ul*/ , (unsigned long int)1, est_random_ifp);
    return (double)(num & 0x7fffffff) / (double)0x7fffffff;
  }

  else
  {
    signed int return_value_rand_2;
    return_value_rand_2=rand();
    return (double)return_value_rand_2 / (double)2147483647;
  }
}

// est_random_fclose
// file estraier.c line 10424
static void est_random_fclose(void)
{
  if(!(est_random_ifp == ((struct _IO_FILE *)NULL)))
    fclose(est_random_ifp);

}

// est_random_nd
// file estraier.c line 4078
double est_random_nd(void)
{
  double d;
  double return_value_est_random_1;
  return_value_est_random_1=est_random();
  double return_value_log_2;
  return_value_log_2=log(1.0 - return_value_est_random_1);
  double return_value_sqrt_3;
  return_value_sqrt_3=sqrt((double)-2 * return_value_log_2);
  double return_value_est_random_4;
  return_value_est_random_4=est_random();
  double return_value_cos_5;
  return_value_cos_5=cos(3.1415926535 * (double)2 * return_value_est_random_4);
  d = (return_value_sqrt_3 * return_value_cos_5 + 6.0) / 12.0;
  if(d > 1.0)
    d = 1.0;

  if(d < 0.0)
    d = 0.0;

  return d;
}

// est_realpath
// file estraier.c line 5565
char * est_realpath(const char *path)
{
  char pbuf[8192l];
  char *return_value_realpath_4;
  return_value_realpath_4=realpath(path, pbuf);
  _Bool tmp_if_expr_3;
  char *return_value_realpath_2;
  if(return_value_realpath_4 == ((char *)NULL))
  {
    if((signed int)*path == 47)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_realpath_2=realpath(".", pbuf);
      tmp_if_expr_3 = !(return_value_realpath_2 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      sprintf(pbuf, "%s", path);

    else
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(pbuf);
      sprintf(pbuf + (signed long int)return_value_strlen_1, "%c%s", 47, path);
    }
  }

  char *return_value_cbmemdup_5;
  return_value_cbmemdup_5=cbmemdup(pbuf, -1);
  return return_value_cbmemdup_5;
}

// est_regex_delete
// file estraier.c line 4132
void est_regex_delete(void *regex)
{
  regfree((struct re_pattern_buffer *)regex);
  free(regex);
}

// est_regex_match
// file estraier.c line 4140
signed int est_regex_match(const void *regex, const char *str)
{
  signed int return_value_regexec_1;
  return_value_regexec_1=regexec((const struct re_pattern_buffer *)regex, str, (unsigned long int)0, (struct anonymous_37 *)(void *)0, 0);
  return (signed int)(return_value_regexec_1 == 0);
}

// est_regex_match_str
// file estraier.c line 4147
signed int est_regex_match_str(const char *rstr, const char *tstr)
{
  void *regex;
  signed int rv;
  regex=est_regex_new(rstr);
  if(regex == NULL)
    return 0;

  else
  {
    rv=est_regex_match(regex, tstr);
    est_regex_delete(regex);
    return rv;
  }
}

// est_regex_new
// file estraier.c line 4117
void * est_regex_new(const char *str)
{
  struct re_pattern_buffer regex;
  signed int options = 1 | ((1 << 1) << 1) << 1;
  if((signed int)*str == 42)
  {
    if((signed int)str[1l] == 73)
    {
      if((signed int)str[2l] == 58)
      {
        options = options | 1 << 1;
        str = str + (signed long int)3;
      }

    }

  }

  signed int return_value_regcomp_1;
  return_value_regcomp_1=regcomp(&regex, str, options);
  if(!(return_value_regcomp_1 == 0))
    return (void *)0;

  else
  {
    char *return_value_cbmemdup_2;
    return_value_cbmemdup_2=cbmemdup((char *)&regex, (signed int)sizeof(struct re_pattern_buffer) /*64ul*/ );
    return (void *)return_value_cbmemdup_2;
  }
}

// est_regex_replace
// file estraier.c line 4159
char * est_regex_replace(const char *str, const char *bef, const char *aft)
{
  struct re_pattern_buffer regex;
  struct anonymous_37 subs[256l];
  struct anonymous_9 *datum;
  const char *sp;
  const char *rp;
  signed int options;
  signed int first;
  signed int num;
  options = 1;
  if((signed int)*bef == 42)
  {
    if((signed int)bef[1l] == 73)
    {
      if((signed int)bef[2l] == 58)
      {
        options = options | 1 << 1;
        bef = bef + (signed long int)3;
      }

    }

  }

  _Bool tmp_if_expr_3;
  signed int return_value_regcomp_2;
  if((signed int)*bef == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_regcomp_2=regcomp(&regex, bef, options);
    tmp_if_expr_3 = return_value_regcomp_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  char *return_value_cbmemdup_1;
  signed int return_value_regexec_8;
  _Bool tmp_if_expr_12;
  if(tmp_if_expr_3)
  {
    return_value_cbmemdup_1=cbmemdup(str, -1);
    return return_value_cbmemdup_1;
  }

  else
  {
    signed int return_value_regexec_5;
    return_value_regexec_5=regexec(&regex, str, (unsigned long int)32, subs, 0);
    if(!(return_value_regexec_5 == 0))
    {
      regfree(&regex);
      char *return_value_cbmemdup_4;
      return_value_cbmemdup_4=cbmemdup(str, -1);
      return return_value_cbmemdup_4;
    }

    sp = str;
    do
    {
      void *return_value_malloc_6;
      return_value_malloc_6=malloc(sizeof(struct anonymous_9) /*16ul*/ );
      datum = (struct anonymous_9 *)return_value_malloc_6;
      if(!(datum == ((struct anonymous_9 *)NULL)))
        datum;

      else
        cbmyfatal("out of memory");
      void *return_value_malloc_7;
      return_value_malloc_7=malloc((unsigned long int)12);
      datum->dptr = (char *)return_value_malloc_7;
      if(!(datum->dptr == ((char *)NULL)))
        datum->dptr;

      else
        cbmyfatal("out of memory");
      datum->dptr[(signed long int)0] = (char)0;
      datum->dsize = 0;
      datum->asize = 12;
    }
    while((_Bool)0);
    first = 1;
    while(!((signed int)*sp == 0))
    {
      return_value_regexec_8=regexec(&regex, sp, (unsigned long int)10, subs, first != 0 ? 0 : 1);
      if(!(return_value_regexec_8 == 0))
        break;

      first = 0;
      if(subs[0l].rm_so == -1)
        break;

      do
      {
        if(datum->dsize + subs[0l].rm_so >= datum->asize)
        {
          datum->asize = datum->asize * 2 + subs[(signed long int)0].rm_so + 1;
          void *return_value_realloc_9;
          return_value_realloc_9=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc_9;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)sp, (unsigned long int)subs[(signed long int)0].rm_so);
        datum->dsize = datum->dsize + subs[(signed long int)0].rm_so;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      rp = aft;
      for( ; !((signed int)*rp == 0); rp = rp + 1l)
        if((signed int)*rp == 92)
        {
          if((signed int)rp[1l] >= 48)
            tmp_if_expr_12 = (signed int)rp[(signed long int)1] <= 57 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_12 = (_Bool)0;
          if(tmp_if_expr_12)
          {
            num = (signed int)rp[(signed long int)1] - 48;
            if(!(subs[(signed long int)num].rm_so == -1))
            {
              if(!(subs[(signed long int)num].rm_eo == -1))
                do
                {
                  if(datum->dsize + subs[(signed long int)num].rm_eo + -subs[(signed long int)num].rm_so >= datum->asize)
                  {
                    datum->asize = datum->asize * 2 + (subs[(signed long int)num].rm_eo - subs[(signed long int)num].rm_so) + 1;
                    void *return_value_realloc_10;
                    return_value_realloc_10=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                    datum->dptr = (char *)return_value_realloc_10;
                    if(!(datum->dptr == ((char *)NULL)))
                      datum->dptr;

                    else
                      cbmyfatal("out of memory");
                  }

                  memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)(sp + (signed long int)subs[(signed long int)num].rm_so), (unsigned long int)(subs[(signed long int)num].rm_eo - subs[(signed long int)num].rm_so));
                  datum->dsize = datum->dsize + (subs[(signed long int)num].rm_eo - subs[(signed long int)num].rm_so);
                  datum->dptr[(signed long int)datum->dsize] = (char)0;
                }
                while((_Bool)0);

            }

            rp = rp + 1l;
          }

          else
            if(!((signed int)rp[1l] == 0))
              do
              {
                if(1 + datum->dsize >= datum->asize)
                {
                  datum->asize = datum->asize * 2 + 1 + 1;
                  void *return_value_realloc_11;
                  return_value_realloc_11=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                  datum->dptr = (char *)return_value_realloc_11;
                  if(!(datum->dptr == ((char *)NULL)))
                    datum->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                rp = rp + 1l;
                memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)rp, (unsigned long int)1);
                datum->dsize = datum->dsize + 1;
                datum->dptr[(signed long int)datum->dsize] = (char)0;
              }
              while((_Bool)0);

        }

        else
          if((signed int)*rp == 38)
            do
            {
              if(datum->dsize + subs[0l].rm_eo + -subs[0l].rm_so >= datum->asize)
              {
                datum->asize = datum->asize * 2 + (subs[(signed long int)0].rm_eo - subs[(signed long int)0].rm_so) + 1;
                void *return_value_realloc_13;
                return_value_realloc_13=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                datum->dptr = (char *)return_value_realloc_13;
                if(!(datum->dptr == ((char *)NULL)))
                  datum->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)(sp + (signed long int)subs[(signed long int)0].rm_so), (unsigned long int)(subs[(signed long int)0].rm_eo - subs[(signed long int)0].rm_so));
              datum->dsize = datum->dsize + (subs[(signed long int)0].rm_eo - subs[(signed long int)0].rm_so);
              datum->dptr[(signed long int)datum->dsize] = (char)0;
            }
            while((_Bool)0);

          else
            do
            {
              if(1 + datum->dsize >= datum->asize)
              {
                datum->asize = datum->asize * 2 + 1 + 1;
                void *return_value_realloc_14;
                return_value_realloc_14=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                datum->dptr = (char *)return_value_realloc_14;
                if(!(datum->dptr == ((char *)NULL)))
                  datum->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)rp, (unsigned long int)1);
              datum->dsize = datum->dsize + 1;
              datum->dptr[(signed long int)datum->dsize] = (char)0;
            }
            while((_Bool)0);
      sp = sp + (signed long int)subs[(signed long int)0].rm_eo;
      if(!(subs[0l].rm_eo >= 1))
        break;

    }
    do
    {
      unsigned long int return_value_strlen_17;
      return_value_strlen_17=strlen(sp);
      if(return_value_strlen_17 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
      {
        unsigned long int return_value_strlen_15;
        return_value_strlen_15=strlen(sp);
        datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen_15 + (unsigned long int)1);
        void *return_value_realloc_16;
        return_value_realloc_16=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
        datum->dptr = (char *)return_value_realloc_16;
        if(!(datum->dptr == ((char *)NULL)))
          datum->dptr;

        else
          cbmyfatal("out of memory");
      }

      unsigned long int return_value_strlen_18;
      return_value_strlen_18=strlen(sp);
      memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)sp, return_value_strlen_18);
      unsigned long int return_value_strlen_19;
      return_value_strlen_19=strlen(sp);
      datum->dsize = datum->dsize + (signed int)return_value_strlen_19;
      datum->dptr[(signed long int)datum->dsize] = (char)0;
    }
    while((_Bool)0);
    regfree(&regex);
    char *return_value_cbdatumtomalloc_20;
    return_value_cbdatumtomalloc_20=cbdatumtomalloc(datum, (signed int *)(void *)0);
    return return_value_cbdatumtomalloc_20;
  }
}

// est_rescc_get
// file estraier.c line 8759
static const struct anonymous_8 * est_rescc_get(struct anonymous_0 *db, const char *word, signed int size, signed int *nump)
{
  const char *vbuf;
  signed int vsiz;
  vbuf=cbmapget(db->rescc, word, size, &vsiz);
  if(vbuf == ((const char *)NULL))
    return (const struct anonymous_8 *)(void *)0;

  else
    if((unsigned long int)vsiz == sizeof(struct anonymous_8) /*16ul*/ )
    {
      if(!(((struct anonymous_8 *)vbuf)->id == -1))
        goto __CPROVER_DUMP_L2;

      return (const struct anonymous_8 *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      cbmapmove(db->rescc, word, size, 0);
      *nump = (signed int)((unsigned long int)vsiz / sizeof(struct anonymous_8) /*16ul*/ );
      return (struct anonymous_8 *)vbuf;
    }
}

// est_rescc_put
// file estraier.c line 8777
static void est_rescc_put(struct anonymous_0 *db, const char *word, signed int size, struct anonymous_8 *scores, signed int num)
{
  signed int i;
  _Bool tmp_if_expr_1;
  if(!(db->rcmnum >= 1))
    free((void *)scores);

  else
  {
    cbmapput(db->rescc, word, size, (char *)scores, (signed int)((unsigned long int)num * sizeof(struct anonymous_8) /*16ul*/ ), 1);
    free((void *)scores);
    signed int return_value_cbmaprnum_2;
    return_value_cbmaprnum_2=cbmaprnum(db->rescc);
    if(!(db->rcmnum >= return_value_cbmaprnum_2))
    {
      num = (signed int)((double)db->rcmnum * 0.1 + (double)1);
      cbmapiterinit(db->rescc);
      i = 0;
      do
      {
        if(!(i >= num))
        {
          word=cbmapiternext(db->rescc, &size);
          tmp_if_expr_1 = word != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_1 = (_Bool)0;
        if(!tmp_if_expr_1)
          break;

        cbmapout(db->rescc, word, size);
        i = i + 1;
      }
      while((_Bool)1);
    }

  }
}

// est_resdoc_attr
// file estnode.c line 282
const char * est_resdoc_attr(struct _ESTRESDOC *rdoc, const char *name)
{
  const char *return_value_cbmapget_1;
  return_value_cbmapget_1=cbmapget(rdoc->attrs, name, -1, (signed int *)(void *)0);
  return return_value_cbmapget_1;
}

// est_resdoc_attr_names
// file estnode.c line 266
struct anonymous_6 * est_resdoc_attr_names(struct _ESTRESDOC *rdoc)
{
  struct anonymous_6 *names;
  const char *kbuf;
  signed int ksiz;
  names=cblistopen();
  cbmapiterinit(rdoc->attrs);
  do
  {
    kbuf=cbmapiternext(rdoc->attrs, &ksiz);
    if(kbuf == ((const char *)NULL))
      break;

    if(!((signed int)*kbuf == 37))
      cblistpush(names, kbuf, ksiz);

  }
  while((_Bool)1);
  cblistsort(names);
  return names;
}

// est_resdoc_keywords
// file estnode.c line 296
const char * est_resdoc_keywords(struct _ESTRESDOC *rdoc)
{
  const char *vbuf;
  vbuf=cbmapget(rdoc->attrs, "%VECTOR", -1, (signed int *)(void *)0);
  return vbuf != ((const char *)NULL) ? vbuf : "";
}

// est_resdoc_shadows
// file estnode.c line 305
struct _ESTRESDOC ** est_resdoc_shadows(struct _ESTRESDOC *rdoc, signed int *np)
{
  if(rdoc->children == ((struct _ESTRESDOC **)NULL))
  {
    *np = 0;
    return (struct _ESTRESDOC **)"";
  }

  else
  {
    *np = rdoc->cnum;
    return rdoc->children;
  }
}

// est_resdoc_similarity
// file estnode.c line 317
double est_resdoc_similarity(struct _ESTRESDOC *rdoc)
{
  return rdoc->similarity;
}

// est_resdoc_snippet
// file estnode.c line 289
const char * est_resdoc_snippet(struct _ESTRESDOC *rdoc)
{
  return rdoc->snippet;
}

// est_resdoc_uri
// file estnode.c line 259
const char * est_resdoc_uri(struct _ESTRESDOC *rdoc)
{
  return rdoc->uri;
}

// est_resmap_add
// file estraier.c line 5442
void est_resmap_add(struct anonymous_5 *map, const char *key, signed int score, signed int method)
{
  signed int elem[2l];
  signed int *ep;
  signed int size;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(key);
  size = (signed int)return_value_strlen_1;
  const char *return_value_cbmapget_4;
  return_value_cbmapget_4=cbmapget(map, key, size, (signed int *)(void *)0);
  ep = (signed int *)return_value_cbmapget_4;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_3;
  if(!(ep == ((signed int *)NULL)))
  {
    elem[(signed long int)0] = ep[(signed long int)0] + 1;
    switch(method)
    {
      case 0:
      {
        elem[(signed long int)1] = ep[(signed long int)1] + score;
        break;
      }
      case 1:
      {
        if(!(ep[1l] >= score))
          tmp_if_expr_2 = score;

        else
          tmp_if_expr_2 = ep[(signed long int)1];
        elem[(signed long int)1] = tmp_if_expr_2;
        break;
      }
      case 2:
      {
        if(!(score >= ep[1l]))
          tmp_if_expr_3 = score;

        else
          tmp_if_expr_3 = ep[(signed long int)1];
        elem[(signed long int)1] = tmp_if_expr_3;
        break;
      }
      case 3:
      {
        elem[(signed long int)1] = (ep[(signed long int)1] * (ep[(signed long int)0] - 1) + score) / ep[(signed long int)0];
        break;
      }
      default:
        elem[(signed long int)1] = score;
    }
  }

  else
  {
    elem[(signed long int)0] = 1;
    elem[(signed long int)1] = score;
  }
  cbmapput(map, key, size, (char *)&elem, (signed int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2), 1);
}

// est_resmap_dump
// file estraier.c line 5485
struct anonymous * est_resmap_dump(struct anonymous_5 *map, signed int min, signed int *nump)
{
  struct anonymous *elems;
  const char *key;
  const char *vbuf;
  signed int num;
  signed int vsiz;
  signed int return_value_cbmaprnum_1;
  return_value_cbmaprnum_1=cbmaprnum(map);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)return_value_cbmaprnum_1 * sizeof(struct anonymous) /*16ul*/  + (unsigned long int)1);
  elems = (struct anonymous *)return_value_malloc_2;
  if(!(elems == ((struct anonymous *)NULL)))
    elems;

  else
    cbmyfatal("out of memory");
  num = 0;
  cbmapiterinit(map);
  do
  {
    key=cbmapiternext(map, (signed int *)(void *)0);
    if(key == ((const char *)NULL))
      break;

    do
    {
      struct _CBMAPDATUM *_CB_datum = (struct _CBMAPDATUM *)(key - (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/ );
      vsiz = _CB_datum->vsiz;
      vbuf = (char *)_CB_datum + (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/  + (signed long int)_CB_datum->ksiz + (signed long int)(((_CB_datum->ksiz | ~(-((signed int)sizeof(void *) /*8ul*/ ))) + 1) - _CB_datum->ksiz);
    }
    while((_Bool)0);
    if(*((signed int *)vbuf) >= min)
    {
      (elems + (signed long int)num)->key = key;
      (elems + (signed long int)num)->score = ((signed int *)vbuf)[(signed long int)1];
      num = num + 1;
    }

  }
  while((_Bool)1);
  qsort((void *)elems, (unsigned long int)num, sizeof(struct anonymous) /*16ul*/ , est_resmapelem_compare);
  *nump = num;
  return elems;
}

// est_resmapelem_compare
// file estraier.c line 5478
static signed int est_resmapelem_compare(const void *ap, const void *bp)
{
  return ((struct anonymous *)bp)->score - ((struct anonymous *)ap)->score;
}

// est_rmdir_rec
// file estraier.c line 5545
signed int est_rmdir_rec(const char *path)
{
  struct anonymous_6 *files;
  const char *file;
  char pbuf[4096l];
  signed int i;
  files=cbdirlist(path);
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(files == ((struct anonymous_6 *)NULL)))
  {
    i = 0;
    for( ; !(i >= files->num); i = i + 1)
    {
      file = (const char *)(files->array + (signed long int)(files->start + i))->dptr;
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(file, ".");
      if(return_value_strcmp_1 == 0)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_strcmp_2=strcmp(file, "..");
        tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_3)
      {
        sprintf(pbuf, "%s%c%s", path, 47, file);
        signed int return_value_unlink_4;
        return_value_unlink_4=unlink(pbuf);
        if(return_value_unlink_4 == -1)
          est_rmdir_rec(pbuf);

      }

    }
    do
    {
      signed int _CB_i;
      signed int _CB_end = files->start + files->num;
      _CB_i = files->start;
      for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
        free((void *)(files->array + (signed long int)_CB_i)->dptr);
      free((void *)files->array);
      free((void *)files);
    }
    while((_Bool)0);
  }

  signed int return_value_rmdir_5;
  return_value_rmdir_5=rmdir(path);
  return (signed int)(return_value_rmdir_5 == 0);
}

// est_score_compare_by_id_asc
// file estraier.c line 8088
static signed int est_score_compare_by_id_asc(const void *ap, const void *bp)
{
  return ((struct anonymous_8 *)ap)->id - ((struct anonymous_8 *)bp)->id;
}

// est_score_compare_by_id_desc
// file estraier.c line 8098
static signed int est_score_compare_by_id_desc(const void *ap, const void *bp)
{
  return ((struct anonymous_8 *)bp)->id - ((struct anonymous_8 *)ap)->id;
}

// est_score_compare_by_num_asc
// file estraier.c line 8148
static signed int est_score_compare_by_num_asc(const void *ap, const void *bp)
{
  return (signed int)((signed long int)((struct anonymous_8 *)ap)->value - (signed long int)((struct anonymous_8 *)bp)->value);
}

// est_score_compare_by_num_desc
// file estraier.c line 8158
static signed int est_score_compare_by_num_desc(const void *ap, const void *bp)
{
  return (signed int)((signed long int)((struct anonymous_8 *)bp)->value - (signed long int)((struct anonymous_8 *)ap)->value);
}

// est_score_compare_by_score_asc
// file estraier.c line 8108
static signed int est_score_compare_by_score_asc(const void *ap, const void *bp)
{
  return ((struct anonymous_8 *)ap)->score - ((struct anonymous_8 *)bp)->score;
}

// est_score_compare_by_score_desc
// file estraier.c line 8118
static signed int est_score_compare_by_score_desc(const void *ap, const void *bp)
{
  return ((struct anonymous_8 *)bp)->score - ((struct anonymous_8 *)ap)->score;
}

// est_score_compare_by_str_asc
// file estraier.c line 8128
static signed int est_score_compare_by_str_asc(const void *ap, const void *bp)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(((struct anonymous_8 *)ap)->value, ((struct anonymous_8 *)bp)->value);
  return return_value_strcmp_1;
}

// est_score_compare_by_str_desc
// file estraier.c line 8138
static signed int est_score_compare_by_str_desc(const void *ap, const void *bp)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(((struct anonymous_8 *)bp)->value, ((struct anonymous_8 *)ap)->value);
  return return_value_strcmp_1;
}

// est_search_aidx_attr
// file estraier.c line 8980
static struct anonymous_8 * est_search_aidx_attr(struct anonymous_0 *db, const char *expr, signed int *nump)
{
  struct anonymous_7 *attridx;
  struct anonymous_8 *scores;
  struct anonymous_9 *abuf;
  struct anonymous_6 *tokens;
  void *regex;
  const char *cop;
  const char *pv;
  const char *kbuf;
  const char *tbuf;
  unsigned char *utmp;
  char *name;
  char *oper;
  char *val;
  char *sval;
  char *wp;
  char numbuf[32l];
  signed int i;
  signed int nsiz;
  signed int vsiz;
  signed int ksiz;
  signed int tsiz;
  signed int sign;
  signed int ic;
  signed int ssiz;
  signed int esc;
  signed int jmp;
  signed int len;
  signed int *ary;
  signed int anum;
  signed long int num;
  signed long int lower;
  signed long int upper;
  name = (char *)(void *)0;
  oper = (char *)(void *)0;
  val = (char *)(void *)0;
  nsiz = 0;
  vsiz = 0;
  for( ; (signed int)*expr >= 1; expr = expr + 1l)
    if((signed int)*expr >= 33)
      break;

  pv=strchr(expr, 32);
  if(!(pv == ((const char *)NULL)))
  {
    nsiz = (signed int)(pv - expr);
    name=cbmemdup(expr, nsiz);
    expr = pv;
    for( ; (signed int)*expr >= 1; expr = expr + 1l)
      if((signed int)*expr >= 33)
        break;

    pv=strchr(expr, 32);
    if(!(pv == ((const char *)NULL)))
    {
      oper=cbmemdup(expr, (signed int)(pv - expr));
      expr = pv;
      for( ; (signed int)*expr >= 1; expr = expr + 1l)
        if((signed int)*expr >= 33)
          break;

      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(expr);
      vsiz = (signed int)return_value_strlen_1;
      val=cbmemdup(expr, vsiz);
    }

    else
      oper=cbmemdup(expr, -1);
  }

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(expr);
    nsiz = (signed int)return_value_strlen_2;
    name=cbmemdup(expr, nsiz);
  }
  if(oper == ((char *)NULL))
    oper=cbmemdup("", 0);

  if(val == ((char *)NULL))
  {
    vsiz = 0;
    val=cbmemdup("", 0);
  }

  cop = oper;
  if((signed int)*cop == 33)
  {
    sign = 0;
    cop = cop + 1l;
  }

  else
    sign = 1;
  _Bool tmp_if_expr_4;
  if((signed int)*cop == 73)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = (signed int)*cop == 105 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_4)
  {
    signed int return_value_est_check_cjk_only_3;
    return_value_est_check_cjk_only_3=est_check_cjk_only(val);
    ic = (signed int)!(return_value_est_check_cjk_only_3 != 0);
    cop = cop + 1l;
  }

  else
    ic = 0;
  regex = (void *)0;
  signed int return_value_cbstricmp_20;
  return_value_cbstricmp_20=cbstricmp(cop, "STREQ");
  signed int return_value_cbstricmp_19;
  signed int return_value_cbstricmp_18;
  signed int return_value_cbstricmp_17;
  signed int return_value_cbstricmp_16;
  signed int return_value_cbstricmp_15;
  signed int return_value_cbstricmp_14;
  signed int return_value_cbstricmp_13;
  signed int return_value_cbstricmp_12;
  signed int return_value_cbstricmp_11;
  signed int return_value_cbstricmp_10;
  signed int return_value_cbstricmp_9;
  signed int return_value_cbstricmp_8;
  signed int return_value_cbstricmp_7;
  signed int return_value_cbstricmp_6;
  signed int return_value_cbstricmp_5;
  if(return_value_cbstricmp_20 == 0)
    cop = "STREQ";

  else
  {
    return_value_cbstricmp_19=cbstricmp(cop, "STRNE");
    if(return_value_cbstricmp_19 == 0)
      cop = "STRNE";

    else
    {
      return_value_cbstricmp_18=cbstricmp(cop, "STRINC");
      if(return_value_cbstricmp_18 == 0)
        cop = "STRINC";

      else
      {
        return_value_cbstricmp_17=cbstricmp(cop, "STRBW");
        if(return_value_cbstricmp_17 == 0)
          cop = "STRBW";

        else
        {
          return_value_cbstricmp_16=cbstricmp(cop, "STREW");
          if(return_value_cbstricmp_16 == 0)
            cop = "STREW";

          else
          {
            return_value_cbstricmp_15=cbstricmp(cop, "STRAND");
            if(return_value_cbstricmp_15 == 0)
              cop = "STRAND";

            else
            {
              return_value_cbstricmp_14=cbstricmp(cop, "STROR");
              if(return_value_cbstricmp_14 == 0)
                cop = "STROR";

              else
              {
                return_value_cbstricmp_13=cbstricmp(cop, "STROREQ");
                if(return_value_cbstricmp_13 == 0)
                  cop = "STROREQ";

                else
                {
                  return_value_cbstricmp_12=cbstricmp(cop, "STRRX");
                  if(return_value_cbstricmp_12 == 0)
                  {
                    cop = "STRRX";
                    regex=est_regex_new(val);
                  }

                  else
                  {
                    return_value_cbstricmp_11=cbstricmp(cop, "NUMEQ");
                    if(return_value_cbstricmp_11 == 0)
                      cop = "NUMEQ";

                    else
                    {
                      return_value_cbstricmp_10=cbstricmp(cop, "NUMNE");
                      if(return_value_cbstricmp_10 == 0)
                        cop = "NUMNE";

                      else
                      {
                        return_value_cbstricmp_9=cbstricmp(cop, "NUMGT");
                        if(return_value_cbstricmp_9 == 0)
                          cop = "NUMGT";

                        else
                        {
                          return_value_cbstricmp_8=cbstricmp(cop, "NUMGE");
                          if(return_value_cbstricmp_8 == 0)
                            cop = "NUMGE";

                          else
                          {
                            return_value_cbstricmp_7=cbstricmp(cop, "NUMLT");
                            if(return_value_cbstricmp_7 == 0)
                              cop = "NUMLT";

                            else
                            {
                              return_value_cbstricmp_6=cbstricmp(cop, "NUMLE");
                              if(return_value_cbstricmp_6 == 0)
                                cop = "NUMLE";

                              else
                              {
                                return_value_cbstricmp_5=cbstricmp(cop, "NUMBT");
                                if(return_value_cbstricmp_5 == 0)
                                  cop = "NUMBT";

                                else
                                {
                                  cop = "STRINC";
                                  val[(signed long int)0] = (char)0;
                                  vsiz = 0;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  num=cbstrmktime(val);
  const char *return_value_cbmapget_21;
  return_value_cbmapget_21=cbmapget(db->aidxs, name, nsiz, (signed int *)(void *)0);
  attridx = (struct anonymous_7 *)return_value_cbmapget_21;
  _Bool tmp_if_expr_23;
  _Bool tmp_if_expr_22;
  if(attridx == ((struct anonymous_7 *)NULL))
    tmp_if_expr_23 = (_Bool)1;

  else
  {
    if(!(attridx->type == 1))
      tmp_if_expr_22 = attridx->type != 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_22 = (_Bool)0;
    tmp_if_expr_23 = tmp_if_expr_22 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_24;
  if(tmp_if_expr_23)
    tmp_if_expr_24 = (_Bool)1;

  else
    tmp_if_expr_24 = (((((((attridx->type == 2 ? (cop != "NUMEQ" ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (cop != "NUMNE" ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (cop != "NUMGT" ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (cop != "NUMGE" ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (cop != "NUMLT" ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (cop != "NUMLE" ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (cop != "NUMBT" ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_29;
  _Bool tmp_if_expr_32;
  signed int return_value_strcmp_33;
  _Bool tmp_if_expr_36;
  char *tmp_post_35;
  signed long int return_value_cbstrmktime_37;
  signed long int return_value_cbstrmktime_39;
  signed long int return_value_cbstrmktime_41;
  if(tmp_if_expr_24)
  {
    if(!(regex == NULL))
      est_regex_delete(regex);

    free((void *)val);
    free((void *)oper);
    free((void *)name);
    return (struct anonymous_8 *)(void *)0;
  }

  else
  {
    do
    {
      void *return_value_malloc_25;
      return_value_malloc_25=malloc(sizeof(struct anonymous_9) /*16ul*/ );
      abuf = (struct anonymous_9 *)return_value_malloc_25;
      if(!(abuf == ((struct anonymous_9 *)NULL)))
        abuf;

      else
        cbmyfatal("out of memory");
      void *return_value_malloc_26;
      return_value_malloc_26=malloc((unsigned long int)12);
      abuf->dptr = (char *)return_value_malloc_26;
      if(!(abuf->dptr == ((char *)NULL)))
        abuf->dptr;

      else
        cbmyfatal("out of memory");
      abuf->dptr[(signed long int)0] = (char)0;
      abuf->dsize = 0;
      abuf->asize = 12;
    }
    while((_Bool)0);
    if(sign == 0 || !(ic == 0))
    {
      if(!(ic == 0))
      {
        char *return_value_est_uconv_in_27;
        return_value_est_uconv_in_27=est_uconv_in(val, vsiz, &tsiz);
        utmp = (unsigned char *)return_value_est_uconv_in_27;
        est_normalize_text(utmp, tsiz, &tsiz);
        est_canonicalize_text(utmp, tsiz, 0);
        char *return_value_est_uconv_out_28;
        return_value_est_uconv_out_28=est_uconv_out((char *)utmp, tsiz, &ssiz);
        sval = (char *)return_value_est_uconv_out_28;
        free((void *)utmp);
      }

      else
      {
        sval = (char *)(void *)0;
        ssiz = 0;
      }
      esc = 0x7fffffff;
      jmp = 0x7fffffff;
      if(vsiz >= 1 && !(sign == 0) && (cop == "STRBW" || cop == "STREQ"))
      {
        if((signed int)*sval >= 1)
          tmp_if_expr_29 = (signed int)*sval < 0x7f ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_29 = (_Bool)0;
        if(tmp_if_expr_29)
        {
          numbuf[(signed long int)0] = *sval;
          numbuf[(signed long int)1] = (char)0;
          esc = (signed int)*((unsigned char *)sval);
          if((signed int)*sval >= 97)
          {
            if(!((signed int)*sval >= 123))
            {
              numbuf[(signed long int)0] = numbuf[(signed long int)0] - (char)(97 - 65);
              jmp = ((signed int)*sval - 97) + 65;
            }

          }

          vlcurjump((struct anonymous_4 *)attridx->db, numbuf, 1, 0);
        }

        else
          if((signed int)*((unsigned char *)sval) >= 0xc0)
          {
            numbuf[(signed long int)0] = *sval;
            numbuf[(signed long int)1] = (char)0;
            esc = (signed int)*((unsigned char *)sval);
            vlcurjump((struct anonymous_4 *)attridx->db, numbuf, 1, 0);
          }

          else
            vlcurfirst((struct anonymous_4 *)attridx->db);
      }

      else
        vlcurfirst((struct anonymous_4 *)attridx->db);
      do
      {
        kbuf=vlcurkeycache((struct anonymous_4 *)attridx->db, &ksiz);
        if(kbuf == ((const char *)NULL))
          break;

        signed int return_value_est_match_attr_31;
        return_value_est_match_attr_31=est_match_attr(kbuf, (signed int)(((unsigned long int)ksiz - sizeof(signed int) /*4ul*/ ) - (unsigned long int)1), cop, sign, val, vsiz, sval, ssiz, regex, (signed int)num);
        if(!(return_value_est_match_attr_31 == 0))
          do
          {
            if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
            {
              abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
              void *return_value_realloc_30;
              return_value_realloc_30=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
              abuf->dptr = (char *)return_value_realloc_30;
              if(!(abuf->dptr == ((char *)NULL)))
                abuf->dptr;

              else
                cbmyfatal("out of memory");
            }

            memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
            abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
            abuf->dptr[(signed long int)abuf->dsize] = (char)0;
          }
          while((_Bool)0);

        if(!(jmp >= (signed int)*((unsigned char *)kbuf)))
          tmp_if_expr_32 = (signed int)*((unsigned char *)kbuf) < (signed int)*((unsigned char *)sval) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_32 = (_Bool)0;
        if(tmp_if_expr_32)
        {
          numbuf[(signed long int)0] = *sval;
          numbuf[(signed long int)1] = (char)0;
          vlcurjump((struct anonymous_4 *)attridx->db, numbuf, 1, 0);
          jmp = 0x7fffffff;
        }

        else
          if(!(esc >= (signed int)*((unsigned char *)kbuf)))
            break;

          else
            vlcurnext((struct anonymous_4 *)attridx->db);
      }
      while((_Bool)1);
      if(!(sval == ((char *)NULL)))
        free((void *)sval);

    }

    else
      if(cop == "STROREQ")
      {
        tokens=cbsplit(val, vsiz, " ,");
        cblistsort(tokens);
        i = 0;
        for( ; !(i >= tokens->num); i = i + 1)
        {
          tsiz = (tokens->array + (signed long int)(tokens->start + i))->dsize;
          tbuf = (const char *)(tokens->array + (signed long int)(tokens->start + i))->dptr;
          vlcurjump((struct anonymous_4 *)attridx->db, tbuf, tsiz, 0);
          do
          {
            kbuf=vlcurkeycache((struct anonymous_4 *)attridx->db, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            return_value_strcmp_33=strcmp(kbuf, tbuf);
            if(!(return_value_strcmp_33 == 0))
              break;

            do
            {
              if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
              {
                abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
                void *return_value_realloc_34;
                return_value_realloc_34=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
                abuf->dptr = (char *)return_value_realloc_34;
                if(!(abuf->dptr == ((char *)NULL)))
                  abuf->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
              abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
              abuf->dptr[(signed long int)abuf->dsize] = (char)0;
            }
            while((_Bool)0);
            vlcurnext((struct anonymous_4 *)attridx->db);
          }
          while((_Bool)1);
        }
        do
        {
          signed int _CB_i;
          signed int _CB_end = tokens->start + tokens->num;
          _CB_i = tokens->start;
          for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
            free((void *)(tokens->array + (signed long int)_CB_i)->dptr);
          free((void *)tokens->array);
          free((void *)tokens);
        }
        while((_Bool)0);
      }

      else
        if(cop == "NUMBT")
        {
          wp=strchr(val, 32);
          if(!(wp == ((char *)NULL)))
            tmp_if_expr_36 = (_Bool)1;

          else
          {
            wp=strchr(val, 9);
            tmp_if_expr_36 = wp != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_36)
          {
            tmp_post_35 = wp;
            wp = wp + 1l;
            *tmp_post_35 = (char)0;
            for( ; (_Bool)1; wp = wp + 1l)
              if(!((signed int)*wp == 32))
              {
                if(!((signed int)*wp == 9))
                  goto __CPROVER_DUMP_L86;

              }


          __CPROVER_DUMP_L86:
            ;
            lower=cbstrmktime(val);
            upper=cbstrmktime(wp);
          }

          else
          {
            lower=cbstrmktime(val);
            upper = (signed long int)0x7fffffff;
          }
          len=sprintf(numbuf, "%.0f", (double)lower);
          vlcurjump((struct anonymous_4 *)attridx->db, numbuf, len, 0);
          do
          {
            kbuf=vlcurkeycache((struct anonymous_4 *)attridx->db, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            return_value_cbstrmktime_37=cbstrmktime(kbuf);
            if(!(upper >= return_value_cbstrmktime_37))
              break;

            do
            {
              if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
              {
                abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
                void *return_value_realloc_38;
                return_value_realloc_38=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
                abuf->dptr = (char *)return_value_realloc_38;
                if(!(abuf->dptr == ((char *)NULL)))
                  abuf->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
              abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
              abuf->dptr[(signed long int)abuf->dsize] = (char)0;
            }
            while((_Bool)0);
            vlcurnext((struct anonymous_4 *)attridx->db);
          }
          while((_Bool)1);
        }

        else
        {
          if(cop == "NUMEQ" || cop == "NUMGE" || cop == "NUMGT" || cop == "STRBW" || cop == "STREQ")
          {
            vlcurjump((struct anonymous_4 *)attridx->db, val, vsiz, 0);
            if(cop == "NUMGT")
              do
              {
                kbuf=vlcurkeycache((struct anonymous_4 *)attridx->db, (signed int *)(void *)0);
                if(kbuf == ((const char *)NULL))
                  break;

                return_value_cbstrmktime_39=cbstrmktime(kbuf);
                if(!(num >= return_value_cbstrmktime_39))
                  break;

                vlcurnext((struct anonymous_4 *)attridx->db);
              }
              while((_Bool)1);

          }

          else
            if(cop == "NUMLE" || cop == "NUMLT")
            {
              signed long int return_value_cbstrmktime_40;
              return_value_cbstrmktime_40=cbstrmktime(val);
              len=sprintf(numbuf, "%.0f", (double)return_value_cbstrmktime_40 + (double)1);
              vlcurjump((struct anonymous_4 *)attridx->db, numbuf, len, 1);
              if(cop == "NUMLT")
                do
                {
                  kbuf=vlcurkeycache((struct anonymous_4 *)attridx->db, (signed int *)(void *)0);
                  if(kbuf == ((const char *)NULL))
                    break;

                  return_value_cbstrmktime_41=cbstrmktime(kbuf);
                  if(!(return_value_cbstrmktime_41 >= num))
                    break;

                  vlcurprev((struct anonymous_4 *)attridx->db);
                }
                while((_Bool)1);

            }

            else
              vlcurfirst((struct anonymous_4 *)attridx->db);
          do
          {
            kbuf=vlcurkeycache((struct anonymous_4 *)attridx->db, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            signed int return_value_est_match_attr_43;
            return_value_est_match_attr_43=est_match_attr(kbuf, (signed int)(((unsigned long int)ksiz - sizeof(signed int) /*4ul*/ ) - (unsigned long int)1), cop, 1, val, vsiz, (const char *)(void *)0, 0, regex, (signed int)num);
            if(!(return_value_est_match_attr_43 == 0))
              do
              {
                if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
                {
                  abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
                  void *return_value_realloc_42;
                  return_value_realloc_42=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
                  abuf->dptr = (char *)return_value_realloc_42;
                  if(!(abuf->dptr == ((char *)NULL)))
                    abuf->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
                abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
                abuf->dptr[(signed long int)abuf->dsize] = (char)0;
              }
              while((_Bool)0);

            else
              if(cop == "NUMEQ" || cop == "STRBW" || cop == "STREQ")
                break;

            if(cop == "NUMLE" || cop == "NUMLT")
              vlcurprev((struct anonymous_4 *)attridx->db);

            else
              vlcurnext((struct anonymous_4 *)attridx->db);
          }
          while((_Bool)1);
        }
    ary = (signed int *)(const char *)abuf->dptr;
    anum = (signed int)((unsigned long int)(signed int)abuf->dsize / sizeof(signed int) /*4ul*/ );
    void *return_value_malloc_44;
    return_value_malloc_44=malloc((unsigned long int)anum * sizeof(struct anonymous_8) /*16ul*/  + (unsigned long int)1);
    scores = (struct anonymous_8 *)return_value_malloc_44;
    if(!(scores == ((struct anonymous_8 *)NULL)))
      scores;

    else
      cbmyfatal("out of memory");
    i = 0;
    for( ; !(i >= anum); i = i + 1)
    {
      (scores + (signed long int)i)->id = ary[(signed long int)i];
      (scores + (signed long int)i)->score = 0;
      (scores + (signed long int)i)->value = (char *)(void *)0;
    }
    *nump = anum;
    do
    {
      free((void *)abuf->dptr);
      free((void *)abuf);
    }
    while((_Bool)0);
    if(!(regex == NULL))
      est_regex_delete(regex);

    free((void *)val);
    free((void *)oper);
    free((void *)name);
    return scores;
  }
}

// est_search_keywords
// file estraier.c line 8802
static struct anonymous_8 * est_search_keywords(struct anonymous_0 *db, const char *word, signed int min, signed int *nump)
{
  struct anonymous_8 *scores;
  struct anonymous_6 *words;
  struct anonymous_9 *rbuf;
  const signed int *res;
  signed int i;
  signed int rnum;
  signed int snum;
  signed int wsiz;
  signed int nnum;
  signed int lid;
  const char *return_value_vlgetcache_2;
  if(!((signed int)*word == 32))
  {
    return_value_vlgetcache_2=vlgetcache(db->auxdb, word, -1, &rnum);
    res = (signed int *)return_value_vlgetcache_2;
    if(!(res == ((const signed int *)NULL)))
    {
      rnum = rnum / (signed int)sizeof(signed int) /*4ul*/ ;
      if(rnum / 2 >= min)
      {
        void *return_value_malloc_1;
        return_value_malloc_1=malloc((unsigned long int)(rnum / 2) * sizeof(struct anonymous_8) /*16ul*/  + (unsigned long int)1);
        scores = (struct anonymous_8 *)return_value_malloc_1;
        if(!(scores == ((struct anonymous_8 *)NULL)))
          scores;

        else
          cbmyfatal("out of memory");
        snum = 0;
        i = 0;
        for( ; !(i >= rnum); i = i + 2)
        {
          (scores + (signed long int)snum)->id = res[(signed long int)i];
          (scores + (signed long int)snum)->score = res[(signed long int)(i + 1)];
          snum = snum + 1;
        }
        *nump = snum;
        return scores;
      }

    }

  }

  do
  {
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(sizeof(struct anonymous_6) /*24ul*/ );
    words = (struct anonymous_6 *)return_value_malloc_3;
    if(!(words == ((struct anonymous_6 *)NULL)))
      words;

    else
      cbmyfatal("out of memory");
    words->anum = 64;
    void *return_value_malloc_4;
    return_value_malloc_4=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)words->anum);
    words->array = (struct anonymous_28 *)return_value_malloc_4;
    if(!(words->array == ((struct anonymous_28 *)NULL)))
      words->array;

    else
      cbmyfatal("out of memory");
    words->start = 0;
    words->num = 0;
  }
  while((_Bool)0);
  if((signed int)*word == 32)
  {
    word = word + 1l;
    if((signed int)*word == 98)
      est_expand_keyword_bw(db, word + (signed long int)1, words);

    else
      if((signed int)*word == 101)
        est_expand_keyword_ew(db, word + (signed long int)1, words);

      else
        if((signed int)*word == 114)
          est_expand_keyword_rx(db, word + (signed long int)1, words);

  }

  else
    if((signed int)*((unsigned char *)word) >= 0xe3)
      est_expand_keyword_bw(db, word, words);

  do
  {
    void *return_value_malloc_5;
    return_value_malloc_5=malloc(sizeof(struct anonymous_9) /*16ul*/ );
    rbuf = (struct anonymous_9 *)return_value_malloc_5;
    if(!(rbuf == ((struct anonymous_9 *)NULL)))
      rbuf;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc_6;
    return_value_malloc_6=malloc((unsigned long int)12);
    rbuf->dptr = (char *)return_value_malloc_6;
    if(!(rbuf->dptr == ((char *)NULL)))
      rbuf->dptr;

    else
      cbmyfatal("out of memory");
    rbuf->dptr[(signed long int)0] = (char)0;
    rbuf->dsize = 0;
    rbuf->asize = 12;
  }
  while((_Bool)0);
  i = 0;
  _Bool tmp_if_expr_7;
  do
  {
    if(!(i >= words->num))
      tmp_if_expr_7 = (unsigned long int)(signed int)rbuf->dsize <= sizeof(signed int) /*4ul*/  * (unsigned long int)2 * (unsigned long int)min * (unsigned long int)16 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_7 = (_Bool)0;
    if(!tmp_if_expr_7)
      break;

    wsiz = (words->array + (signed long int)(words->start + i))->dsize;
    word = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
    const char *return_value_vlgetcache_8;
    return_value_vlgetcache_8=vlgetcache(db->auxdb, word, wsiz, &rnum);
    res = (signed int *)return_value_vlgetcache_8;
    if(!(res == ((const signed int *)NULL)))
      do
      {
        if(rbuf->dsize + rnum >= rbuf->asize)
        {
          rbuf->asize = rbuf->asize * 2 + rnum + 1;
          void *return_value_realloc_9;
          return_value_realloc_9=realloc((void *)rbuf->dptr, (unsigned long int)rbuf->asize);
          rbuf->dptr = (char *)return_value_realloc_9;
          if(!(rbuf->dptr == ((char *)NULL)))
            rbuf->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(rbuf->dptr + (signed long int)rbuf->dsize), (const void *)(char *)res, (unsigned long int)rnum);
        rbuf->dsize = rbuf->dsize + rnum;
        rbuf->dptr[(signed long int)rbuf->dsize] = (char)0;
      }
      while((_Bool)0);

    i = i + 1;
  }
  while((_Bool)1);
  res = (signed int *)(const char *)rbuf->dptr;
  rnum = (signed int)rbuf->dsize;
  rnum = rnum / (signed int)sizeof(signed int) /*4ul*/ ;
  if(!(rnum / 2 >= min))
  {
    do
    {
      free((void *)rbuf->dptr);
      free((void *)rbuf);
    }
    while((_Bool)0);
    do
    {
      signed int _CB_i;
      signed int est_search_keywords__1__7__2___CB_end = words->start + words->num;
      _CB_i = words->start;
      for( ; !(_CB_i >= est_search_keywords__1__7__2___CB_end); _CB_i = _CB_i + 1)
        free((void *)(words->array + (signed long int)_CB_i)->dptr);
      free((void *)words->array);
      free((void *)words);
    }
    while((_Bool)0);
    return (struct anonymous_8 *)(void *)0;
  }

  else
  {
    void *return_value_malloc_10;
    return_value_malloc_10=malloc((unsigned long int)(rnum / 2) * sizeof(struct anonymous_8) /*16ul*/  + (unsigned long int)1);
    scores = (struct anonymous_8 *)return_value_malloc_10;
    if(!(scores == ((struct anonymous_8 *)NULL)))
      scores;

    else
      cbmyfatal("out of memory");
    snum = 0;
    i = 0;
    for( ; !(i >= rnum); i = i + 2)
    {
      (scores + (signed long int)snum)->id = res[(signed long int)i];
      (scores + (signed long int)snum)->score = res[(signed long int)(i + 1)];
      snum = snum + 1;
    }
    qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_id_asc);
    nnum = 0;
    lid = -1;
    i = 0;
    for( ; !(i >= snum); i = i + 1)
      if(nnum >= 1)
      {
        if(!((scores + (signed long int)i)->id == lid))
          goto __CPROVER_DUMP_L38;

        (scores + (signed long int)(nnum - 1))->score = (scores + (signed long int)(nnum - 1))->score + (scores + (signed long int)i)->score;
      }

      else
      {

      __CPROVER_DUMP_L38:
        ;
        (scores + (signed long int)nnum)->id = (scores + (signed long int)i)->id;
        (scores + (signed long int)nnum)->score = (scores + (signed long int)i)->score;
        nnum = nnum + 1;
        lid = (scores + (signed long int)i)->id;
      }
    do
    {
      free((void *)rbuf->dptr);
      free((void *)rbuf);
    }
    while((_Bool)0);
    do
    {
      signed int est_search_keywords__1__11___CB_i;
      signed int _CB_end = words->start + words->num;
      est_search_keywords__1__11___CB_i = words->start;
      for( ; !(est_search_keywords__1__11___CB_i >= _CB_end); est_search_keywords__1__11___CB_i = est_search_keywords__1__11___CB_i + 1)
        free((void *)(words->array + (signed long int)est_search_keywords__1__11___CB_i)->dptr);
      free((void *)words->array);
      free((void *)words);
    }
    while((_Bool)0);
    *nump = nnum;
    return scores;
  }
}

// est_search_pidxs
// file estraier.c line 9234
static struct anonymous_8 * est_search_pidxs(struct anonymous_0 *db, struct anonymous_15 *cond, struct anonymous_8 *scores, signed int *nump, struct anonymous_5 *ordattrs)
{
  struct anonymous_16 *list;
  struct anonymous_14 *doc;
  const char *otype;
  const char *lbuf;
  const char *vbuf;
  char *oname;
  char *wp;
  signed int i;
  signed int j;
  signed int k;
  signed int snum;
  signed int anum;
  signed int id;
  signed int hit;
  signed int sc;
  signed int miss;
  signed int lsiz;
  signed int vsiz;
  double avg;
  double sd;
  double dif;
  double tune;
  snum = *nump;
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)scores, (unsigned long int)(snum + (signed int)db->pdocs->num) * sizeof(struct anonymous_8) /*16ul*/  + (unsigned long int)1);
  scores = (struct anonymous_8 *)return_value_realloc_1;
  if(!(scores == ((struct anonymous_8 *)NULL)))
    scores;

  else
    cbmyfatal("out of memory");
  signed int return_value_cbstrfwmatch_3;
  signed int return_value_cbstrfwmatch_2;
  if(!(cond->phrase == ((char *)NULL)))
  {
    signed int return_value_cbstrfwmatch_4;
    return_value_cbstrfwmatch_4=cbstrfwmatch(cond->phrase, "[ID]");
    if(!(return_value_cbstrfwmatch_4 == 0))
      return scores;

    else
    {
      return_value_cbstrfwmatch_3=cbstrfwmatch(cond->phrase, "[URI]");
      if(!(return_value_cbstrfwmatch_3 == 0))
        return scores;

      else
      {
        return_value_cbstrfwmatch_2=cbstrfwmatch(cond->phrase, "[SIMILAR]");
        if(!(return_value_cbstrfwmatch_2 == 0))
          return scores;

      }
    }
  }

  oname = (char *)(void *)0;
  otype = (const char *)(void *)0;
  char *tmp_post_5;
  if(!(cond->order == ((char *)NULL)))
  {
    oname=cbmemdup(cond->order, -1);
    cbstrtrim(oname);
    otype = "STRA";
    wp=strchr(oname, 32);
    if(!(wp == ((char *)NULL)))
    {
      tmp_post_5 = wp;
      wp = wp + 1l;
      *tmp_post_5 = (char)0;
      for( ; (signed int)*wp == 32; wp = wp + 1l)
        ;
      otype = wp;
    }

  }

  list = (struct anonymous_16 *)(void *)0;
  anum = -1;
  if(!(cond->attrs == ((struct anonymous_6 *)NULL)))
    list=est_make_cattr_list(cond->attrs, &anum);

  i = 0;
  _Bool tmp_if_expr_7;
  signed int return_value_cbstrfwmatch_6;
  _Bool tmp_if_expr_10;
  signed int return_value_est_match_attr_9;
  _Bool tmp_if_expr_11;
  for( ; !(i >= db->pdocs->num); i = i + 1)
  {
    id = 2000000001 + i;
    hit = 0;
    sc = 0;
    doc = (struct anonymous_14 *)(void *)0;
    if(cond->phrase == ((char *)NULL))
      tmp_if_expr_7 = (_Bool)1;

    else
      tmp_if_expr_7 = (signed int)cond->phrase[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_7)
      hit = cond->attrs != ((struct anonymous_6 *)NULL) ? 1 : 0;

    else
    {
      return_value_cbstrfwmatch_6=cbstrfwmatch(cond->phrase, "[UVSET]");
      if(!(return_value_cbstrfwmatch_6 == 0))
        hit = 1;

      else
      {
        doc=est_db_get_doc(db, id, 0);
        if(!(doc == ((struct anonymous_14 *)NULL)))
          hit=est_db_score_doc(db, doc, cond, &sc);

        else
          hit = 0;
      }
    }
    if(!(list == ((struct anonymous_16 *)NULL)) && !(hit == 0))
    {
      if(doc == ((struct anonymous_14 *)NULL))
      {
        doc=est_db_get_doc(db, id, 0);
        tmp_if_expr_10 = !(doc != ((struct anonymous_14 *)NULL)) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_10 = (_Bool)0;
      if(tmp_if_expr_10)
        hit = 0;

      else
      {
        miss = 0;
        j = 0;
        for( ; miss == 0 && !(j >= anum); j = j + 1)
          if((list + (signed long int)j)->nsiz >= 1)
          {
            if(!((list + (signed long int)j)->nlist == ((struct anonymous_6 *)NULL)))
            {
              hit = 0;
              k = 0;
              for( ; !(k >= (list + (signed long int)j)->nlist->num); k = k + 1)
              {
                lsiz = ((list + (signed long int)j)->nlist->array + (signed long int)((list + (signed long int)j)->nlist->start + k))->dsize;
                lbuf = (const char *)((list + (signed long int)j)->nlist->array + (signed long int)((list + (signed long int)j)->nlist->start + k))->dptr;
                if(lsiz >= 1)
                {
                  vbuf=cbmapget(doc->attrs, lbuf, lsiz, &vsiz);
                  if(!(vbuf == ((const char *)NULL)))
                  {
                    signed int return_value_est_match_attr_8;
                    return_value_est_match_attr_8=est_match_attr(vbuf, vsiz, (list + (signed long int)j)->cop, (list + (signed long int)j)->sign, (list + (signed long int)j)->val, (list + (signed long int)j)->vsiz, (list + (signed long int)j)->sval, (list + (signed long int)j)->ssiz, (list + (signed long int)j)->regex, (signed int)(list + (signed long int)j)->num);
                    if(!(return_value_est_match_attr_8 == 0))
                    {
                      hit = 1;
                      break;
                    }

                  }

                }

              }
              if(hit == 0)
                miss = 1;

            }

            else
            {
              vbuf=cbmapget(doc->attrs, (list + (signed long int)j)->name, (list + (signed long int)j)->nsiz, &vsiz);
              if(vbuf == ((const char *)NULL))
                miss = 1;

              else
              {
                return_value_est_match_attr_9=est_match_attr(vbuf, vsiz, (list + (signed long int)j)->cop, (list + (signed long int)j)->sign, (list + (signed long int)j)->val, (list + (signed long int)j)->vsiz, (list + (signed long int)j)->sval, (list + (signed long int)j)->ssiz, (list + (signed long int)j)->regex, (signed int)(list + (signed long int)j)->num);
                if(return_value_est_match_attr_9 == 0)
                  miss = 1;

              }
            }
          }

        hit = (signed int)!(miss != 0);
      }
    }

    if(!(hit == 0))
    {
      (scores + (signed long int)snum)->id = id;
      (scores + (signed long int)snum)->score = sc;
      (scores + (signed long int)snum)->value = (char *)(void *)0;
      snum = snum + 1;
      if(!(oname == ((char *)NULL)))
      {
        if(!(doc == ((struct anonymous_14 *)NULL)))
          tmp_if_expr_11 = (_Bool)1;

        else
        {
          doc=est_db_get_doc(db, id, 0);
          tmp_if_expr_11 = doc != (struct anonymous_14 *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_11)
        {
          vbuf=cbmapget(doc->attrs, oname, -1, &vsiz);
          if(vbuf == ((const char *)NULL))
          {
            vbuf = "";
            vsiz = 0;
          }

          cbmapput(ordattrs, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, 0);
        }

      }

    }

    if(!(doc == ((struct anonymous_14 *)NULL)))
      est_doc_delete(doc);

  }
  if(!(list == ((struct anonymous_16 *)NULL)))
    est_free_cattr_list(list, anum);

  if(!(oname == ((char *)NULL)))
    free((void *)oname);

  if(!(db->smode == 4194304))
  {
    if(!(*nump >= snum))
    {
      avg = 0.0;
      i = *nump;
      for( ; !(i >= snum); i = i + 1)
        avg = avg + (double)(scores + (signed long int)i)->score;
      avg = avg / (double)(snum - *nump);
      sd = 0.0;
      i = *nump;
      for( ; !(i >= snum); i = i + 1)
      {
        dif = avg - (double)(scores + (signed long int)i)->score;
        sd = sd + dif * dif;
      }
      sd = sd / (double)(snum - *nump);
      sd=sqrt(sd);
      if(sd < 0.1)
      {
        i = *nump;
        for( ; !(i >= snum); i = i + 1)
          (scores + (signed long int)i)->score = 1000 / 2;
      }

      else
      {
        i = *nump;
        for( ; !(i >= snum); i = i + 1)
          (scores + (signed long int)i)->score = (signed int)((((double)(scores + (signed long int)i)->score - avg) * ((double)1000 / 10.0)) / sd + (double)1000 / 2.0);
      }
      if(!(cond->tfidf == 0))
      {
        tune=pow((double)((snum - *nump) + 64), 0.4);
        i = *nump;
        for( ; !(i >= snum); i = i + 1)
          (scores + (signed long int)i)->score = (scores + (signed long int)i)->score * (signed int)(100.0 / tune);
      }

      else
      {
        i = *nump;
        for( ; !(i >= snum); i = i + 1)
          (scores + (signed long int)i)->score = (scores + (signed long int)i)->score * 10;
      }
    }

  }

  *nump = snum;
  return scores;
}

// est_search_rank
// file estraier.c line 8916
static struct anonymous_8 * est_search_rank(struct anonymous_0 *db, const char *name, signed int top, signed int *nump)
{
  struct anonymous_7 *attridx;
  struct anonymous_8 *scores;
  const char *kbuf;
  signed int snum;
  signed int ksiz;
  signed int id;
  _Bool tmp_if_expr_3;
  const char *return_value_cbmapget_2;
  if(top == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_cbmapget_2=cbmapget(db->aidxs, name, -1, (signed int *)(void *)0);
    attridx = (struct anonymous_7 *)return_value_cbmapget_2;
    tmp_if_expr_3 = !(attridx != ((struct anonymous_7 *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    if(!(attridx->type == 1))
      tmp_if_expr_4 = attridx->type != 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
  {
    *nump = 0;
    void *return_value_cbmalloc_1;
    return_value_cbmalloc_1=cbmalloc((unsigned long int)1);
    return (struct anonymous_8 *)return_value_cbmalloc_1;
  }

  snum=abs(top);
  if(!(db->dnum >= snum))
    snum = db->dnum;

  void *return_value_malloc_6;
  return_value_malloc_6=malloc((unsigned long int)snum * sizeof(struct anonymous_8) /*16ul*/  + (unsigned long int)1);
  scores = (struct anonymous_8 *)return_value_malloc_6;
  if(!(scores == ((struct anonymous_8 *)NULL)))
    scores;

  else
    cbmyfatal("out of memory");
  snum = 0;
  if(top >= 1)
  {
    vlcurfirst((struct anonymous_4 *)attridx->db);
    while(!(snum >= top))
    {
      kbuf=vlcurkeycache((struct anonymous_4 *)attridx->db, &ksiz);
      if(kbuf == ((const char *)NULL))
        break;

      if(!((unsigned long int)ksiz >= sizeof(signed int) /*4ul*/ ))
        vlcurnext((struct anonymous_4 *)attridx->db);

      else
      {
        memcpy((void *)&id, (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
        if(!(id >= 1))
          vlcurnext((struct anonymous_4 *)attridx->db);

        else
        {
          (scores + (signed long int)snum)->id = id;
          (scores + (signed long int)snum)->score = 0;
          (scores + (signed long int)snum)->value = (char *)(void *)0;
          snum = snum + 1;
          vlcurnext((struct anonymous_4 *)attridx->db);
        }
      }
    }
  }

  else
  {
    top = top * -1;
    vlcurlast((struct anonymous_4 *)attridx->db);
    while(!(snum >= top))
    {
      kbuf=vlcurkeycache((struct anonymous_4 *)attridx->db, &ksiz);
      if(kbuf == ((const char *)NULL))
        break;

      if(!((unsigned long int)ksiz >= sizeof(signed int) /*4ul*/ ))
        vlcurprev((struct anonymous_4 *)attridx->db);

      else
      {
        memcpy((void *)&id, (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
        if(!(id >= 1))
          vlcurprev((struct anonymous_4 *)attridx->db);

        else
        {
          (scores + (signed long int)snum)->id = id;
          (scores + (signed long int)snum)->score = 0;
          (scores + (signed long int)snum)->value = (char *)(void *)0;
          snum = snum + 1;
          vlcurprev((struct anonymous_4 *)attridx->db);
        }
      }
    }
  }
  *nump = snum;
  return scores;
}

// est_search_similar
// file estraier.c line 10222
static struct anonymous_8 * est_search_similar(struct anonymous_0 *db, struct anonymous_5 *svmap, signed int *nump, signed int knum, signed int unum, signed int mnum, signed int tfidf, double nmin, signed int auxmin, struct anonymous_5 *auxwords)
{
  struct anonymous_8 *scores;
  struct anonymous_8 *tscores;
  struct anonymous_5 *tvmap;
  const char *word;
  signed int i;
  signed int j;
  signed int vnum;
  signed int snum;
  signed int tmax;
  signed int tsnum;
  signed int nnum;
  signed int lid;
  signed int *svec;
  signed int *tvec;
  double dval;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_8) /*16ul*/  * (unsigned long int)(unum * knum + (signed int)db->pdocs->num) + (unsigned long int)1);
  scores = (struct anonymous_8 *)return_value_malloc_1;
  if(!(scores == ((struct anonymous_8 *)NULL)))
    scores;

  else
    cbmyfatal("out of memory");
  snum = 0;
  vnum=cbmaprnum(svmap);
  if(!(vnum >= 1))
    vnum = 1;

  cbmapiterinit(svmap);
  tmax = unum;
  i = 0;
  _Bool tmp_if_expr_2;
  do
  {
    if(!(i >= 2 * knum) && !(snum >= 2 * unum) || !(i >= knum))
    {
      word=cbmapiternext(svmap, (signed int *)(void *)0);
      tmp_if_expr_2 = word != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      break;

    for( ; (signed int)*word >= 1; word = word + 1l)
      if((signed int)*word >= 33)
        break;

    tscores=est_search_union(db, word, 1, (void (*)(const char *, struct anonymous_6 *))(void *)0, &tsnum, (struct anonymous_5 *)(void *)0, 1, auxmin, auxwords);
    qsort((void *)tscores, (unsigned long int)tsnum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_score_desc);
    j = 0;
    for( ; !(j >= tmax) && !(j >= tsnum); j = j + 1)
    {
      (scores + (signed long int)snum)->id = (tscores + (signed long int)j)->id;
      (scores + (signed long int)snum)->score = (signed int)((double)(tscores + (signed long int)j)->score * ((double)knum * 2.2 - (double)i));
      snum = snum + 1;
    }
    free((void *)tscores);
    tmax = tmax - (signed int)((double)(unum / knum) / 1.25);
    if(!(tmax >= unum / 4))
      tmax = unum / 4;

    i = i + 1;
  }
  while((_Bool)1);
  i = 0;
  for( ; !(i >= db->pdocs->num); i = i + 1)
  {
    (scores + (signed long int)snum)->id = 2000000001 + i;
    (scores + (signed long int)snum)->score = 1;
    snum = snum + 1;
  }
  qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_id_asc);
  nnum = 0;
  lid = -1;
  i = 0;
  for( ; !(i >= snum); i = i + 1)
    if(nnum >= 1)
    {
      if(!((scores + (signed long int)i)->id == lid))
        goto __CPROVER_DUMP_L16;

      (scores + (signed long int)(nnum - 1))->score = (scores + (signed long int)(nnum - 1))->score + (scores + (signed long int)i)->score;
    }

    else
    {

    __CPROVER_DUMP_L16:
      ;
      (scores + (signed long int)nnum)->id = (scores + (signed long int)i)->id;
      (scores + (signed long int)nnum)->score = (scores + (signed long int)i)->score;
      nnum = nnum + 1;
      lid = (scores + (signed long int)i)->id;
    }
  snum = nnum;
  qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_score_desc);
  nnum = 0;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)vnum * sizeof(signed int) /*4ul*/ );
  svec = (signed int *)return_value_malloc_3;
  if(!(svec == ((signed int *)NULL)))
    svec;

  else
    cbmyfatal("out of memory");
  void *return_value_malloc_4;
  return_value_malloc_4=malloc((unsigned long int)vnum * sizeof(signed int) /*4ul*/ );
  tvec = (signed int *)return_value_malloc_4;
  if(!(tvec == ((signed int *)NULL)))
    tvec;

  else
    cbmyfatal("out of memory");
  est_vector_set_seed(svmap, svec, vnum);
  i = 0;
  for( ; !(i >= snum) && !(nnum >= mnum); i = i + 1)
  {
    tvmap=est_get_tvmap(db, (scores + (signed long int)i)->id, vnum, tfidf);
    if(!(tvmap == ((struct anonymous_5 *)NULL)))
    {
      est_vector_set_target(svmap, tvmap, tvec, vnum);
      dval=est_vector_cosine(svec, tvec, vnum);
      if(dval >= nmin)
      {
        (scores + (signed long int)nnum)->id = (scores + (signed long int)i)->id;
        (scores + (signed long int)nnum)->score = (signed int)(dval * (double)10000);
        if((scores + (signed long int)nnum)->score == 9999)
          (scores + (signed long int)nnum)->score = 10000;

        (scores + (signed long int)nnum)->value = (char *)(void *)0;
        nnum = nnum + 1;
      }

      cbmapclose(tvmap);
    }

  }
  free((void *)tvec);
  free((void *)svec);
  snum = nnum;
  *nump = snum;
  return scores;
}

// est_search_union
// file estraier.c line 8420
static struct anonymous_8 * est_search_union(struct anonymous_0 *db, const char *term, signed int gstep, void (*xpn)(const char *, struct anonymous_6 *), signed int *nump, struct anonymous_5 *hints, signed int add, signed int auxmin, struct anonymous_5 *auxwords)
{
  const struct anonymous_8 *cscores;
  struct anonymous_8 *scores;
  struct anonymous_8 *tscores;
  struct anonymous_8 *nscores;
  struct anonymous_5 *umap;
  struct anonymous_6 *words;
  struct anonymous_6 *grams;
  struct anonymous_6 *tgrams;
  const char *ckey;
  const char *word;
  const char *gram;
  const char *rp;
  const char *fnext;
  const char *snext;
  const char *cbuf;
  char *vbuf;
  char *wbuf;
  char numbuf[32l];
  signed int i;
  signed int j;
  signed int k;
  signed int snum;
  signed int smax;
  signed int cksiz;
  signed int single;
  signed int tsmax;
  signed int tsnum;
  signed int nsnum;
  signed int vsiz;
  signed int gcnum;
  signed int gsiz;
  signed int csiz;
  signed int wgstep;
  signed int nnum;
  signed int west;
  signed int wild;
  signed int mfsiz;
  signed int mssiz;
  signed int mfhash;
  signed int mshash;
  signed int tfhash;
  signed int tshash;
  signed int id;
  signed int vstep;
  signed int score;
  signed int hit;
  signed int hnum;
  double avg;
  double sd;
  double dif;
  smax = 1024;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)smax * sizeof(struct anonymous_8) /*16ul*/ );
  scores = (struct anonymous_8 *)return_value_malloc_1;
  if(!(scores == ((struct anonymous_8 *)NULL)))
    scores;

  else
    cbmyfatal("out of memory");
  snum = 0;
  words=cbsplit(term, -1, "\t");
  _Bool tmp_if_expr_2;
  if(!(xpn == ((void (*)(const char *, struct anonymous_6 *))NULL)))
  {
    umap=cbmapopenex(31);
    i = 0;
    for( ; !(i >= words->num); i = i + 1)
    {
      word = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
      if((signed int)*word == 0)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)word[(signed long int)0] == 32 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_2)
      {
        do
        {
          void *return_value_malloc_3;
          return_value_malloc_3=malloc(sizeof(struct anonymous_6) /*24ul*/ );
          grams = (struct anonymous_6 *)return_value_malloc_3;
          if(!(grams == ((struct anonymous_6 *)NULL)))
            grams;

          else
            cbmyfatal("out of memory");
          grams->anum = 64;
          void *return_value_malloc_4;
          return_value_malloc_4=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)grams->anum);
          grams->array = (struct anonymous_28 *)return_value_malloc_4;
          if(!(grams->array == ((struct anonymous_28 *)NULL)))
            grams->array;

          else
            cbmyfatal("out of memory");
          grams->start = 0;
          grams->num = 0;
        }
        while((_Bool)0);
        xpn(word, grams);
        j = 0;
        if(!(j >= grams->num))
        {
          word = (const char *)(grams->array + (signed long int)(grams->start + j))->dptr;
          cbmapput(umap, word, -1, "", 0, 0);
          j = j + 1;
        }

        signed int est_search_union__1__1__1__1__3___CB_i;
        signed int est_search_union__1__1__1__1__3___CB_end = grams->start + grams->num;
        est_search_union__1__1__1__1__3___CB_i = grams->start;
        if(!(est_search_union__1__1__1__1__3___CB_i >= est_search_union__1__1__1__1__3___CB_end))
        {
          free((void *)(grams->array + (signed long int)est_search_union__1__1__1__1__3___CB_i)->dptr);
          est_search_union__1__1__1__1__3___CB_i = est_search_union__1__1__1__1__3___CB_i + 1;
        }

        free((void *)grams->array);
        free((void *)grams);
      }

    }
    do
    {
      signed int est_search_union__1__1__2___CB_i;
      signed int est_search_union__1__1__2___CB_end = words->start + words->num;
      est_search_union__1__1__2___CB_i = words->start;
      for( ; !(est_search_union__1__1__2___CB_i >= est_search_union__1__1__2___CB_end); est_search_union__1__1__2___CB_i = est_search_union__1__1__2___CB_i + 1)
        free((void *)(words->array + (signed long int)est_search_union__1__1__2___CB_i)->dptr);
      free((void *)words->array);
      free((void *)words);
    }
    while((_Bool)0);
    words=cbmapkeys(umap);
    cbmapclose(umap);
  }

  i = 0;
  char *return_value_strchr_35;
  _Bool tmp_if_expr_36;
  _Bool tmp_if_expr_7;
  unsigned long int tmp_if_expr_13;
  unsigned long int return_value_strlen_12;
  _Bool tmp_if_expr_21;
  signed int tmp_if_expr_23;
  signed int return_value_dpinnerhash_22;
  signed int tmp_if_expr_25;
  signed int return_value_dpouterhash_24;
  _Bool tmp_if_expr_31;
  _Bool tmp_if_expr_32;
  char *return_value_strchr_33;
  for( ; !(i >= words->num); i = i + 1)
  {
    cksiz = (words->array + (signed long int)(words->start + i))->dsize;
    ckey = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
    if(cksiz >= 1)
    {
      word = ckey;
      wbuf = (char *)(void *)0;
      cscores=est_rescc_get(db, ckey, cksiz, &tsnum);
      if(!(cscores == ((const struct anonymous_8 *)NULL)))
      {
        if((signed int)*word == 32)
        {
          word = word + 1l;
          if(!((signed int)*word == 0))
            word = word + 1l;

        }

        if(!(hints == ((struct anonymous_5 *)NULL)))
        {
          sprintf(numbuf, "%d", tsnum * (add != 0 ? 1 : -1));
          cbmapput(hints, word, -1, numbuf, -1, 1);
        }

        j = 0;
        for( ; !(j >= tsnum); j = j + 1)
        {
          if(snum >= smax)
          {
            smax = smax * 2;
            void *return_value_realloc_5;
            return_value_realloc_5=realloc((void *)scores, (unsigned long int)smax * sizeof(struct anonymous_8) /*16ul*/ );
            scores = (struct anonymous_8 *)return_value_realloc_5;
            if(!(scores == ((struct anonymous_8 *)NULL)))
              scores;

            else
              cbmyfatal("out of memory");
          }

          (scores + (signed long int)snum)->id = (cscores + (signed long int)j)->id;
          (scores + (signed long int)snum)->score = (cscores + (signed long int)j)->score;
          snum = snum + 1;
        }
      }

      else
      {
        return_value_strchr_35=strchr(word + (signed long int)1, 32);
        if(return_value_strchr_35 == ((char *)NULL) && auxmin >= 1)
        {
          tscores=est_search_keywords(db, word, auxmin, &tsnum);
          tmp_if_expr_36 = tscores != (struct anonymous_8 *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_36 = (_Bool)0;
        if(tmp_if_expr_36)
        {
          if((signed int)*word == 32)
          {
            word = word + 1l;
            if(!((signed int)*word == 0))
              word = word + 1l;

          }

          if(!(hints == ((struct anonymous_5 *)NULL)))
          {
            sprintf(numbuf, "%d", tsnum * (add != 0 ? 1 : -1));
            cbmapput(hints, word, -1, numbuf, -1, 1);
          }

          if(!(auxwords == ((struct anonymous_5 *)NULL)))
            cbmapput(auxwords, word, -1, "", 0, 0);

          j = 0;
          for( ; !(j >= tsnum); j = j + 1)
          {
            if(snum >= smax)
            {
              smax = smax * 2;
              void *return_value_realloc_6;
              return_value_realloc_6=realloc((void *)scores, (unsigned long int)smax * sizeof(struct anonymous_8) /*16ul*/ );
              scores = (struct anonymous_8 *)return_value_realloc_6;
              if(!(scores == ((struct anonymous_8 *)NULL)))
                scores;

              else
                cbmyfatal("out of memory");
            }

            (scores + (signed long int)snum)->id = (tscores + (signed long int)j)->id;
            (scores + (signed long int)snum)->score = (tscores + (signed long int)j)->score;
            snum = snum + 1;
          }
          free((void *)tscores);
        }

        else
        {
          wild = 0;
          if((signed int)*word == 32)
          {
            word = word + 1l;
            if((signed int)*word == 98)
            {
              wild = 98;
              word = word + 1l;
            }

            else
              if((signed int)*word == 101)
              {
                wild = 101;
                word = word + 1l;
              }

              else
                if((signed int)*word == 114)
                {
                  wild = 114;
                  word = word + 1l;
                }

          }

          west = (signed int)((signed int)((unsigned char *)word)[(signed long int)0] <= 0xdf);
          if(west == 0)
            tmp_if_expr_7 = (_Bool)1;

          else
            tmp_if_expr_7 = db->amode != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_7)
            wild = 0;

          single = 0;
          do
          {
            void *return_value_malloc_8;
            return_value_malloc_8=malloc(sizeof(struct anonymous_6) /*24ul*/ );
            grams = (struct anonymous_6 *)return_value_malloc_8;
            if(!(grams == ((struct anonymous_6 *)NULL)))
              grams;

            else
              cbmyfatal("out of memory");
            grams->anum = 64;
            void *return_value_malloc_9;
            return_value_malloc_9=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)grams->anum);
            grams->array = (struct anonymous_28 *)return_value_malloc_9;
            if(!(grams->array == ((struct anonymous_28 *)NULL)))
              grams->array;

            else
              cbmyfatal("out of memory");
            grams->start = 0;
            grams->num = 0;
          }
          while((_Bool)0);
          switch(wild)
          {
            case 98:
            {
              est_break_text(word, grams, 1, 0);
              do
              {
                signed int _CB_index = grams->start + grams->num;
                if(_CB_index >= grams->anum)
                {
                  grams->anum = grams->anum * 2;
                  void *return_value_realloc_10;
                  return_value_realloc_10=realloc((void *)grams->array, (unsigned long int)grams->anum * sizeof(struct anonymous_28) /*16ul*/ );
                  grams->array = (struct anonymous_28 *)return_value_realloc_10;
                  if(!(grams->array == ((struct anonymous_28 *)NULL)))
                    grams->array;

                  else
                    cbmyfatal("out of memory");
                }

                unsigned long int return_value_strlen_11;
                return_value_strlen_11=strlen(word);
                if(!(return_value_strlen_11 >= 12ul))
                  tmp_if_expr_13 = (unsigned long int)12;

                else
                {
                  return_value_strlen_12=strlen(word);
                  tmp_if_expr_13 = return_value_strlen_12;
                }
                void *return_value_malloc_14;
                return_value_malloc_14=malloc(tmp_if_expr_13 + (unsigned long int)1);
                (grams->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc_14;
                if(!((grams->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
                  (grams->array + (signed long int)_CB_index)->dptr;

                else
                  cbmyfatal("out of memory");
                unsigned long int return_value_strlen_15;
                return_value_strlen_15=strlen(word);
                memcpy((void *)(grams->array + (signed long int)_CB_index)->dptr, (const void *)word, return_value_strlen_15);
                unsigned long int return_value_strlen_16;
                return_value_strlen_16=strlen(word);
                (grams->array + (signed long int)_CB_index)->dptr[(signed long int)return_value_strlen_16] = (char)0;
                unsigned long int return_value_strlen_17;
                return_value_strlen_17=strlen(word);
                (grams->array + (signed long int)_CB_index)->dsize = (signed int)return_value_strlen_17;
                grams->num = grams->num + 1;
              }
              while((_Bool)0);
              while(grams->num >= 2)
                do
                  if(grams->num >= 1)
                  {
                    free((void *)(grams->array + (signed long int)((grams->start + grams->num) - 1))->dptr);
                    grams->num = grams->num - 1;
                  }

                while((_Bool)0);
              wbuf=cbmemdup((const char *)(grams->array + (signed long int)(grams->start + 0))->dptr, -1);
              word = wbuf;
              est_expand_word_bw(db, word, grams);
              single = 1;
              break;
            }
            case 101:
            {
              est_break_text(word, grams, 1, 0);
              cblistunshift(grams, word, -1);
              while(grams->num >= 2)
              {
                char *return_value_cblistshift_18;
                return_value_cblistshift_18=cblistshift(grams, (signed int *)(void *)0);
                free((void *)return_value_cblistshift_18);
              }
              wbuf=cbmemdup((const char *)(grams->array + (signed long int)(grams->start + 0))->dptr, -1);
              word = wbuf;
              est_expand_word_ew(db, word, grams);
              single = 1;
              break;
            }
            case 114:
            {
              est_break_text(word, grams, 1, 0);
              while(grams->num >= 1)
              {
                char *return_value_cblistshift_19;
                return_value_cblistshift_19=cblistshift(grams, (signed int *)(void *)0);
                free((void *)return_value_cblistshift_19);
              }
              est_expand_word_rx(db, word, grams);
              single = 1;
              break;
            }
            default:
            {
              switch(db->amode)
              {
                case 1024:
                {
                  est_break_text_perfng(word, grams, 1, 0);
                  break;
                }
                case 2048:
                {
                  est_break_text_chrcat(word, grams, 1);
                  break;
                }
                default:
                  est_break_text(word, grams, 1, 0);
              }
              if(!(grams->num >= 1))
              {
                est_expand_word_bw(db, word, grams);
                single = 1;
              }

            }
          }
          tsmax = 1024;
          void *return_value_malloc_20;
          return_value_malloc_20=malloc((unsigned long int)tsmax * sizeof(struct anonymous_8) /*16ul*/ );
          tscores = (struct anonymous_8 *)return_value_malloc_20;
          if(!(tscores == ((struct anonymous_8 *)NULL)))
            tscores;

          else
            cbmyfatal("out of memory");
          tsnum = 0;
          gcnum = 0;
          if(single == 0)
            tmp_if_expr_21 = ((signed int)grams->num > 2 ? (_Bool)1 : (gstep > 2 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_21 = (_Bool)0;
          wgstep = tmp_if_expr_21 ? gstep : 1;
          if(!(west == 0) && !(gstep >= 3))
            wgstep = 1;

          j = 0;
          for( ; !(j >= grams->num); j = j + wgstep)
          {
            gcnum = gcnum + 1;
            gsiz = (grams->array + (signed long int)(grams->start + j))->dsize;
            gram = (const char *)(grams->array + (signed long int)(grams->start + j))->dptr;
            fnext=cblistval(grams, j + 1, &mfsiz);
            snext=cblistval(grams, j + 2, &mssiz);
            if(!(fnext == ((const char *)NULL)))
            {
              return_value_dpinnerhash_22=dpinnerhash(fnext, mfsiz);
              tmp_if_expr_23 = return_value_dpinnerhash_22 % 251 + 1;
            }

            else
              tmp_if_expr_23 = 0xff;
            mfhash = tmp_if_expr_23;
            if(!(snext == ((const char *)NULL)))
            {
              return_value_dpouterhash_24=dpouterhash(snext, mssiz);
              tmp_if_expr_25 = return_value_dpouterhash_24 % 251 + 1;
            }

            else
              tmp_if_expr_25 = 0xff;
            mshash = tmp_if_expr_25;
            vbuf=est_idx_scan(db->idxdb, gram, gsiz, &vsiz, db->smode);
            cbuf=cbmapget(db->idxcc, gram, gsiz, &csiz);
            if(!(cbuf == ((const char *)NULL)))
            {
              void *return_value_realloc_26;
              return_value_realloc_26=realloc((void *)vbuf, (unsigned long int)(vsiz + csiz + 1));
              vbuf = (char *)return_value_realloc_26;
              if(!(vbuf == ((char *)NULL)))
                vbuf;

              else
                cbmyfatal("out of memory");
              memcpy((void *)(vbuf + (signed long int)vsiz), (const void *)cbuf, (unsigned long int)csiz);
              vsiz = vsiz + csiz;
            }

            rp = vbuf;
            while(!(rp >= vbuf + (signed long int)vsiz))
            {
              do
              {
                signed int _EST_i;
                signed int _EST_base;
                id = 0;
                _EST_base = 1;
                _EST_i = 0;
                for( ; (_Bool)1; _EST_i = _EST_i + 1)
                {
                  if((signed int)rp[(signed long int)_EST_i] >= 0)
                  {
                    id = id + (signed int)((signed char *)rp)[(signed long int)_EST_i] * _EST_base;
                    break;
                  }

                  id = id + _EST_base * ((signed int)((signed char *)rp)[(signed long int)_EST_i] + 1) * -1;
                  _EST_base = _EST_base * 128;
                }
                vstep = _EST_i + 1;
              }
              while((_Bool)0);
              rp = rp + (signed long int)vstep;
              if(!(db->smode == 1048576))
              {
                if(db->smode == 2097152 || db->smode == 4194304)
                  goto __CPROVER_DUMP_L96;

              }

              else
              {
                score = 0;
                goto __CPROVER_DUMP_L97;
              }
              score = (signed int)*((unsigned char *)rp);
              rp = rp + 1l;
              goto __CPROVER_DUMP_L97;

            __CPROVER_DUMP_L96:
              ;
              memcpy((void *)&score, (const void *)rp, sizeof(signed int) /*4ul*/ );
              rp = rp + (signed long int)sizeof(signed int) /*4ul*/ ;

            __CPROVER_DUMP_L97:
              ;
              hit = (signed int)(mfhash == 0xff && mshash == 0xff);
              while(!(rp >= vbuf + (signed long int)vsiz))
              {
                if((signed int)*((unsigned char *)rp) == 0x00)
                  break;

                tfhash = (signed int)*((unsigned char *)rp);
                rp = rp + 1l;
                tshash = (signed int)*((unsigned char *)rp);
                rp = rp + 1l;
                if((mfhash == 0xff || mfhash == tfhash) && (mshash == 0xff || mshash == tshash))
                  hit = 1;

              }
              rp = rp + 1l;
              if(!(hit == 0) || !(single == 0))
              {
                if(tsnum >= tsmax)
                {
                  tsmax = tsmax * 2;
                  void *return_value_realloc_27;
                  return_value_realloc_27=realloc((void *)tscores, (unsigned long int)tsmax * sizeof(struct anonymous_8) /*16ul*/ );
                  tscores = (struct anonymous_8 *)return_value_realloc_27;
                  if(!(tscores == ((struct anonymous_8 *)NULL)))
                    tscores;

                  else
                    cbmyfatal("out of memory");
                }

                (tscores + (signed long int)tsnum)->id = id;
                if(!(db->smode == 1048576))
                {
                  if(db->smode == 4194304)
                    goto __CPROVER_DUMP_L106;

                }

                else
                {
                  (tscores + (signed long int)tsnum)->score = (signed int)(rp - vbuf);
                  goto __CPROVER_DUMP_L107;
                }
                (tscores + (signed long int)tsnum)->score = score * 100 + 10;
                goto __CPROVER_DUMP_L107;

              __CPROVER_DUMP_L106:
                ;
                (tscores + (signed long int)tsnum)->score = score;

              __CPROVER_DUMP_L107:
                ;
                tsnum = tsnum + 1;
              }

            }
            free((void *)vbuf);
          }
          if(grams->num == 1)
          {
            if(single == 0)
            {
              if(db->amode == 0)
              {
                if(!((signed int)*((unsigned char *)word) >= 0xe0))
                {
                  do
                  {
                    void *return_value_malloc_28;
                    return_value_malloc_28=malloc(sizeof(struct anonymous_6) /*24ul*/ );
                    tgrams = (struct anonymous_6 *)return_value_malloc_28;
                    if(!(tgrams == ((struct anonymous_6 *)NULL)))
                      tgrams;

                    else
                      cbmyfatal("out of memory");
                    tgrams->anum = 64;
                    void *return_value_malloc_29;
                    return_value_malloc_29=malloc(sizeof(struct anonymous_28) /*16ul*/  * (unsigned long int)tgrams->anum);
                    tgrams->array = (struct anonymous_28 *)return_value_malloc_29;
                    if(!(tgrams->array == ((struct anonymous_28 *)NULL)))
                      tgrams->array;

                    else
                      cbmyfatal("out of memory");
                    tgrams->start = 0;
                    tgrams->num = 0;
                  }
                  while((_Bool)0);
                  est_break_text(word, tgrams, 1, 1);
                  if(tgrams->num == 2)
                  {
                    gram = (const char *)(tgrams->array + (signed long int)(tgrams->start + 1))->dptr;
                    nscores=est_search_union(db, gram, 1, (void (*)(const char *, struct anonymous_6 *))(void *)0, &nsnum, (struct anonymous_5 *)(void *)0, 1, -1, (struct anonymous_5 *)(void *)0);
                    j = 0;
                    for( ; !(j >= nsnum); j = j + 1)
                    {
                      if(tsnum >= tsmax)
                      {
                        tsmax = tsmax * 2;
                        void *return_value_realloc_30;
                        return_value_realloc_30=realloc((void *)tscores, (unsigned long int)tsmax * sizeof(struct anonymous_8) /*16ul*/ );
                        tscores = (struct anonymous_8 *)return_value_realloc_30;
                        if(!(tscores == ((struct anonymous_8 *)NULL)))
                          tscores;

                        else
                          cbmyfatal("out of memory");
                      }

                      (tscores + (signed long int)tsnum)->id = (nscores + (signed long int)j)->id;
                      (tscores + (signed long int)tsnum)->score = (nscores + (signed long int)j)->score;
                      tsnum = tsnum + 1;
                    }
                    free((void *)nscores);
                    gcnum = gcnum + 1;
                  }

                  do
                  {
                    signed int _CB_i;
                    signed int _CB_end = tgrams->start + tgrams->num;
                    _CB_i = tgrams->start;
                    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
                      free((void *)(tgrams->array + (signed long int)_CB_i)->dptr);
                    free((void *)tgrams->array);
                    free((void *)tgrams);
                  }
                  while((_Bool)0);
                }

              }

            }

          }

          if(gcnum >= 2)
          {
            qsort((void *)tscores, (unsigned long int)tsnum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_id_asc);
            nnum = 0;
            j = 0;
            for( ; !(j >= tsnum); j = j + 1)
            {
              id = (tscores + (signed long int)j)->id;
              score = (tscores + (signed long int)j)->score;
              hnum = 1;
              if(db->smode == 4194304)
              {
                k = j + 1;
                do
                {
                  if(!(k >= tsnum))
                    tmp_if_expr_31 = (tscores + (signed long int)k)->id == id ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_31 = (_Bool)0;
                  if(!tmp_if_expr_31)
                    break;

                  hnum = hnum + 1;
                  k = k + 1;
                }
                while((_Bool)1);
                if(hnum >= gcnum || !(single == 0))
                {
                  (tscores + (signed long int)nnum)->id = id;
                  (tscores + (signed long int)nnum)->score = score;
                  nnum = nnum + 1;
                }

              }

              else
              {
                k = j + 1;
                do
                {
                  if(!(k >= tsnum))
                    tmp_if_expr_32 = (tscores + (signed long int)k)->id == id ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_32 = (_Bool)0;
                  if(!tmp_if_expr_32)
                    break;

                  score = score + (tscores + (signed long int)k)->score;
                  hnum = hnum + 1;
                  k = k + 1;
                }
                while((_Bool)1);
                if(hnum >= gcnum || !(single == 0))
                {
                  (tscores + (signed long int)nnum)->id = id;
                  (tscores + (signed long int)nnum)->score = score / hnum;
                  nnum = nnum + 1;
                }

              }
              j = k - 1;
            }
            tsnum = nnum;
          }

          if(!(hints == ((struct anonymous_5 *)NULL)))
          {
            sprintf(numbuf, "%d", tsnum * (add != 0 ? 1 : -1));
            cbmapput(hints, word, -1, numbuf, -1, 1);
          }

          do
          {
            signed int est_search_union__1__2__1__3__8___CB_i;
            signed int est_search_union__1__2__1__3__8___CB_end = grams->start + grams->num;
            est_search_union__1__2__1__3__8___CB_i = grams->start;
            for( ; !(est_search_union__1__2__1__3__8___CB_i >= est_search_union__1__2__1__3__8___CB_end); est_search_union__1__2__1__3__8___CB_i = est_search_union__1__2__1__3__8___CB_i + 1)
              free((void *)(grams->array + (signed long int)est_search_union__1__2__1__3__8___CB_i)->dptr);
            free((void *)grams->array);
            free((void *)grams);
          }
          while((_Bool)0);
          if(!(db->smode == 4194304))
          {
            return_value_strchr_33=strchr(word, 32);
            if(return_value_strchr_33 == ((char *)NULL))
            {
              if(auxmin >= 1)
                est_weight_keywords(db, word, tscores, tsnum);

            }

          }

          j = 0;
          for( ; !(j >= tsnum); j = j + 1)
          {
            if(snum >= smax)
            {
              smax = smax * 2;
              void *return_value_realloc_34;
              return_value_realloc_34=realloc((void *)scores, (unsigned long int)smax * sizeof(struct anonymous_8) /*16ul*/ );
              scores = (struct anonymous_8 *)return_value_realloc_34;
              if(!(scores == ((struct anonymous_8 *)NULL)))
                scores;

              else
                cbmyfatal("out of memory");
            }

            (scores + (signed long int)snum)->id = (tscores + (signed long int)j)->id;
            (scores + (signed long int)snum)->score = (tscores + (signed long int)j)->score;
            snum = snum + 1;
          }
          est_rescc_put(db, ckey, cksiz, tscores, tsnum);
        }
      }
      free((void *)wbuf);
    }

  }
  do
  {
    signed int est_search_union__1__3___CB_i;
    signed int est_search_union__1__3___CB_end = words->start + words->num;
    est_search_union__1__3___CB_i = words->start;
    for( ; !(est_search_union__1__3___CB_i >= est_search_union__1__3___CB_end); est_search_union__1__3___CB_i = est_search_union__1__3___CB_i + 1)
      free((void *)(words->array + (signed long int)est_search_union__1__3___CB_i)->dptr);
    free((void *)words->array);
    free((void *)words);
  }
  while((_Bool)0);
  qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_id_asc);
  nnum = 0;
  i = 0;
  _Bool tmp_if_expr_37;
  for( ; !(i >= snum); i = i + 1)
  {
    id = (scores + (signed long int)i)->id;
    score = (scores + (signed long int)i)->score;
    hnum = 1;
    j = i + 1;
    do
    {
      if(!(j >= snum))
        tmp_if_expr_37 = (scores + (signed long int)j)->id == id ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_37 = (_Bool)0;
      if(!tmp_if_expr_37)
        break;

      score = score + (scores + (signed long int)j)->score;
      hnum = hnum + 1;
      j = j + 1;
    }
    while((_Bool)1);
    (scores + (signed long int)nnum)->id = id;
    (scores + (signed long int)nnum)->score = score / hnum;
    (scores + (signed long int)nnum)->value = (char *)(void *)0;
    nnum = nnum + 1;
    i = j - 1;
  }
  *nump = nnum;
  if(!(db->smode == 4194304))
  {
    if(nnum >= 1)
    {
      avg = 0.0;
      i = 0;
      for( ; !(i >= nnum); i = i + 1)
        avg = avg + (double)(scores + (signed long int)i)->score;
      avg = avg / (double)nnum;
      sd = 0.0;
      i = 0;
      for( ; !(i >= nnum); i = i + 1)
      {
        dif = avg - (double)(scores + (signed long int)i)->score;
        sd = sd + dif * dif;
      }
      sd = sd / (double)nnum;
      sd=sqrt(sd);
      if(sd < 0.1)
      {
        i = 0;
        for( ; !(i >= nnum); i = i + 1)
          (scores + (signed long int)i)->score = 1000 / 2;
      }

      else
      {
        i = 0;
        for( ; !(i >= nnum); i = i + 1)
          (scores + (signed long int)i)->score = (signed int)((((double)(scores + (signed long int)i)->score - avg) * ((double)1000 / 10.0)) / sd + (double)1000 / 2.0);
      }
    }

  }

  return scores;
}

// est_search_uvset
// file estraier.c line 8250
static struct anonymous_8 * est_search_uvset(struct anonymous_0 *db, signed int *nump, struct anonymous_5 *hints, signed int add)
{
  struct anonymous_8 *scores;
  char *vbuf;
  char numbuf[32l];
  signed int snum;
  signed int smax = 1024;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)smax * sizeof(struct anonymous_8) /*16ul*/ );
  scores = (struct anonymous_8 *)return_value_malloc_1;
  if(!(scores == ((struct anonymous_8 *)NULL)))
    scores;

  else
    cbmyfatal("out of memory");
  snum = 0;
  vlcurfirst(db->listdb);
  do
  {
    vbuf=vlcurval(db->listdb, (signed int *)(void *)0);
    if(vbuf == ((char *)NULL))
      break;

    if(snum >= smax)
    {
      smax = smax * 2;
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)scores, (unsigned long int)smax * sizeof(struct anonymous_8) /*16ul*/ );
      scores = (struct anonymous_8 *)return_value_realloc_2;
      if(!(scores == ((struct anonymous_8 *)NULL)))
        scores;

      else
        cbmyfatal("out of memory");
    }

    (scores + (signed long int)snum)->id=atoi(vbuf);
    (scores + (signed long int)snum)->score = 0;
    (scores + (signed long int)snum)->value = (char *)(void *)0;
    snum = snum + 1;
    free((void *)vbuf);
    vlcurnext(db->listdb);
  }
  while((_Bool)1);
  *nump = snum;
  if(!(hints == ((struct anonymous_5 *)NULL)))
  {
    sprintf(numbuf, "%d", snum * (add != 0 ? 1 : -1));
    cbmapput(hints, "[UVSET]", -1, numbuf, -1, 1);
  }

  return scores;
}

// est_set_ecode
// file estraier.c line 5862
static void est_set_ecode(signed int *ecp, signed int value, signed int line)
{
  char buf[4096l];
  *ecp = value;
  if(dpdbgfd >= 0)
  {
    fflush(stdout);
    fflush(stderr);
    const char *return_value_est_err_msg_1;
    return_value_est_err_msg_1=est_err_msg(value);
    sprintf(buf, "* est_set_ecode: %d: [%d] %s\n", line, value, return_value_est_err_msg_1);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(buf);
    write(dpdbgfd, (const void *)buf, return_value_strlen_2);
  }

}

// est_short_compare
// file estraier.c line 7718
static signed int est_short_compare(const void *ap, const void *bp)
{
  return (((signed int)((unsigned char *)ap)[(signed long int)0] << 8) + (signed int)((unsigned char *)ap)[(signed long int)1]) - (((signed int)((unsigned char *)bp)[(signed long int)0] << 8) + (signed int)((unsigned char *)bp)[(signed long int)1]);
}

// est_signal
// file estraier.c line 5665
void est_signal(signed int signum, void (*sighandler)(signed int))
{
  struct sigaction act;
  signed int i;
  static signed int first = 1;
  if(!(first == 0))
  {
    i = 1;
    for( ; !(i >= 64); i = i + 1)
      est_signal_handlers[(signed long int)i] = (void (*)(signed int))(void *)0;
    first = 0;
  }

  if(!(signum >= 64))
  {
    memset((void *)&act, 0, sizeof(struct sigaction) /*152ul*/ );
    if(sighandler == (void (*)(signed int))1)
      act.__sigaction_handler.sa_handler = (void (*)(signed int))1;

    else
      if(sighandler == ((void (*)(signed int))NULL))
        act.__sigaction_handler.sa_handler = (void (*)(signed int))0;

      else
      {
        act.__sigaction_handler.sa_handler = (void (*)(signed int))est_signal_dispatch;
        est_signal_handlers[(signed long int)signum] = sighandler;
      }
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    sigaction(signum, &act, (struct sigaction *)(void *)0);
  }

}

// est_signal_dispatch
// file estraier.c line 10431
static signed int est_signal_dispatch(signed int signum)
{
  if(!(est_signal_handlers[(signed long int)signum] == ((void (*)(signed int))NULL)))
    est_signal_handlers[(signed long int)signum](signum);

  return 1;
}

// est_snippet_add_text
// file estraier.c line 6765
static void est_snippet_add_text(const unsigned char *rtext, const unsigned char *ctext, signed int size, signed int awsiz, struct anonymous_9 *res, const struct anonymous_6 *rwords)
{
  const unsigned char *rword;
  char *orig;
  signed int i;
  signed int j;
  signed int bi;
  signed int rwsiz;
  signed int step;
  signed int osiz;
  bi = 0;
  i = 0;
  for( ; !(i >= size); i = i + 2)
  {
    j = 0;
    for( ; !(j >= rwords->num); j = j + 1)
    {
      rwsiz = (rwords->array + (signed long int)(rwords->start + j))->dsize;
      rword = (unsigned char *)(const char *)(rwords->array + (signed long int)(rwords->start + j))->dptr;
      step=est_str_fwmatch_wide(ctext + (signed long int)i, (size + awsiz) - i, rword, rwsiz);
      if(step >= 1)
      {
        if(i + -bi >= 1)
        {
          orig=est_uconv_out((char *)rtext + (signed long int)bi, i - bi, &osiz);
          do
          {
            if(res->dsize + osiz >= res->asize)
            {
              res->asize = res->asize * 2 + osiz + 1;
              void *return_value_realloc_1;
              return_value_realloc_1=realloc((void *)res->dptr, (unsigned long int)res->asize);
              res->dptr = (char *)return_value_realloc_1;
              if(!(res->dptr == ((char *)NULL)))
                res->dptr;

              else
                cbmyfatal("out of memory");
            }

            memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)orig, (unsigned long int)osiz);
            res->dsize = res->dsize + osiz;
            res->dptr[(signed long int)res->dsize] = (char)0;
          }
          while((_Bool)0);
          do
          {
            if(1 + res->dsize >= res->asize)
            {
              res->asize = res->asize * 2 + 1 + 1;
              void *return_value_realloc_2;
              return_value_realloc_2=realloc((void *)res->dptr, (unsigned long int)res->asize);
              res->dptr = (char *)return_value_realloc_2;
              if(!(res->dptr == ((char *)NULL)))
                res->dptr;

              else
                cbmyfatal("out of memory");
            }

            memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)"\n", (unsigned long int)1);
            res->dsize = res->dsize + 1;
            res->dptr[(signed long int)res->dsize] = (char)0;
          }
          while((_Bool)0);
          free((void *)orig);
        }

        orig=est_uconv_out((char *)rtext + (signed long int)i, step, &osiz);
        do
        {
          if(res->dsize + osiz >= res->asize)
          {
            res->asize = res->asize * 2 + osiz + 1;
            void *return_value_realloc_3;
            return_value_realloc_3=realloc((void *)res->dptr, (unsigned long int)res->asize);
            res->dptr = (char *)return_value_realloc_3;
            if(!(res->dptr == ((char *)NULL)))
              res->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)orig, (unsigned long int)osiz);
          res->dsize = res->dsize + osiz;
          res->dptr[(signed long int)res->dsize] = (char)0;
        }
        while((_Bool)0);
        free((void *)orig);
        do
        {
          if(1 + res->dsize >= res->asize)
          {
            res->asize = res->asize * 2 + 1 + 1;
            void *return_value_realloc_4;
            return_value_realloc_4=realloc((void *)res->dptr, (unsigned long int)res->asize);
            res->dptr = (char *)return_value_realloc_4;
            if(!(res->dptr == ((char *)NULL)))
              res->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)"\t", (unsigned long int)1);
          res->dsize = res->dsize + 1;
          res->dptr[(signed long int)res->dsize] = (char)0;
        }
        while((_Bool)0);
        orig=est_uconv_out((char *)rword, rwsiz, &osiz);
        do
        {
          if(res->dsize + osiz >= res->asize)
          {
            res->asize = res->asize * 2 + osiz + 1;
            void *return_value_realloc_5;
            return_value_realloc_5=realloc((void *)res->dptr, (unsigned long int)res->asize);
            res->dptr = (char *)return_value_realloc_5;
            if(!(res->dptr == ((char *)NULL)))
              res->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)orig, (unsigned long int)osiz);
          res->dsize = res->dsize + osiz;
          res->dptr[(signed long int)res->dsize] = (char)0;
        }
        while((_Bool)0);
        free((void *)orig);
        do
        {
          if(1 + res->dsize >= res->asize)
          {
            res->asize = res->asize * 2 + 1 + 1;
            void *return_value_realloc_6;
            return_value_realloc_6=realloc((void *)res->dptr, (unsigned long int)res->asize);
            res->dptr = (char *)return_value_realloc_6;
            if(!(res->dptr == ((char *)NULL)))
              res->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)"\n", (unsigned long int)1);
          res->dsize = res->dsize + 1;
          res->dptr[(signed long int)res->dsize] = (char)0;
        }
        while((_Bool)0);
        bi = i + step;
        i = bi - 2;
        break;
      }

    }
  }
  if(i + -bi >= 1)
  {
    orig=est_uconv_out((char *)rtext + (signed long int)bi, i - bi, &osiz);
    do
    {
      if(res->dsize + osiz >= res->asize)
      {
        res->asize = res->asize * 2 + osiz + 1;
        void *return_value_realloc_7;
        return_value_realloc_7=realloc((void *)res->dptr, (unsigned long int)res->asize);
        res->dptr = (char *)return_value_realloc_7;
        if(!(res->dptr == ((char *)NULL)))
          res->dptr;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)orig, (unsigned long int)osiz);
      res->dsize = res->dsize + osiz;
      res->dptr[(signed long int)res->dsize] = (char)0;
    }
    while((_Bool)0);
    do
    {
      if(1 + res->dsize >= res->asize)
      {
        res->asize = res->asize * 2 + 1 + 1;
        void *return_value_realloc_8;
        return_value_realloc_8=realloc((void *)res->dptr, (unsigned long int)res->asize);
        res->dptr = (char *)return_value_realloc_8;
        if(!(res->dptr == ((char *)NULL)))
          res->dptr;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)"\n", (unsigned long int)1);
      res->dsize = res->dsize + 1;
      res->dptr[(signed long int)res->dsize] = (char)0;
    }
    while((_Bool)0);
    free((void *)orig);
  }

}

// est_sock_close
// file estnode.c line 1767
static signed int est_sock_close(signed int sock)
{
  signed int return_value_close_1;
  return_value_close_1=close(sock);
  return return_value_close_1;
}

// est_sock_down
// file estnode.h line 496
void est_sock_down(signed int sock)
{
  shutdown(sock, 2);
  est_sock_close(sock);
}

// est_sock_recv_all
// file estnode.c line 1465
char * est_sock_recv_all(signed int sock, signed int len)
{
  char *buf;
  signed int i;
  signed int bs;
  void *return_value_cbmalloc_1;
  return_value_cbmalloc_1=cbmalloc((unsigned long int)(len + 1));
  buf = (char *)return_value_cbmalloc_1;
  i = 0;
  _Bool tmp_if_expr_3;
  signed long int return_value_recv_2;
  signed int *return_value___errno_location_4;
  do
  {
    if(!(i >= len))
    {
      return_value_recv_2=recv(sock, (void *)(buf + (signed long int)i), (unsigned long int)(len - i), 0);
      bs = (signed int)return_value_recv_2;
      tmp_if_expr_3 = bs != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(!tmp_if_expr_3)
      break;

    if(bs == -1)
    {
      return_value___errno_location_4=__errno_location();
      if(!(*return_value___errno_location_4 == 4))
      {
        free((void *)buf);
        return (char *)(void *)0;
      }

    }

    i = i + bs;
  }
  while((_Bool)1);
  buf[(signed long int)i] = (char)0;
  return buf;
}

// est_sock_recv_line
// file estnode.c line 1482
signed int est_sock_recv_line(signed int sock, char *buf, signed int max)
{
  char *wp;
  max = max - 1;
  wp = buf;
  signed int *return_value___errno_location_2;
  while(!(wp >= buf + (signed long int)max))
  {
    signed long int return_value_recv_1;
    return_value_recv_1=recv(sock, (void *)wp, (unsigned long int)1, 0);
    if(!(return_value_recv_1 == -1l))
    {
      if(return_value_recv_1 == 0l)
        goto __CPROVER_DUMP_L4;

    }

    else
    {
      return_value___errno_location_2=__errno_location();
      if(!(*return_value___errno_location_2 == 4))
      {
        *wp = (char)0;
        return (signed int)(wp - buf);
      }

      goto __CPROVER_DUMP_L10;

    __CPROVER_DUMP_L4:
      ;
      *wp = (char)0;
      return (signed int)(wp - buf);
    }
    switch((signed int)*wp)
    {
      case 13:
        break;
      case 10:
      {
        *wp = (char)0;
        return (signed int)(wp - buf);
      }
      default:
        wp = wp + 1l;
    }

  __CPROVER_DUMP_L10:
    ;
  }
  *wp = (char)0;
  return (signed int)(wp - buf);
}

// est_sock_recv_void
// file estnode.c line 1518
void est_sock_recv_void(signed int sock)
{
  struct anonymous_18 rfds;
  struct timeval tv;
  char ibuf[8192l];
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_18) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfds)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&rfds)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfds)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  tv.tv_sec = (signed long int)0;
  tv.tv_usec = (signed long int)0;
  signed int return_value_select_1;
  return_value_select_1=select(sock + 1, &rfds, (struct anonymous_18 *)(void *)0, (struct anonymous_18 *)(void *)0, &tv);
  if(return_value_select_1 >= 1)
  {
    if(!((rfds.fds_bits[(signed long int)(sock / 8)] & (signed long int)(1UL << sock % 8)) == 0l))
      recv(sock, (void *)ibuf, (unsigned long int)8192, 0);

  }

}

// est_sock_send_all
// file estnode.h line 530
void est_sock_send_all(signed int sock, const char *buf, signed int len)
{
  const char *rp;
  signed int rv;
  signed int wb;
  rp = buf;
  rv = 0;
  signed int *return_value___errno_location_2;
  do
  {
    signed long int return_value_send_1;
    return_value_send_1=send(sock, (const void *)rp, (unsigned long int)len, 0);
    wb = (signed int)return_value_send_1;
    if(!(wb == -1))
    {
      if(wb == 0)
        goto __CPROVER_DUMP_L3;

    }

    else
    {
      return_value___errno_location_2=__errno_location();
      if(!(*return_value___errno_location_2 == 4))
        goto __CPROVER_DUMP_L6;


    __CPROVER_DUMP_L3:
      ;
      goto __CPROVER_DUMP_L5;
    }
    rp = rp + (signed long int)wb;
    len = len - wb;
    rv = rv + wb;

  __CPROVER_DUMP_L5:
    ;
  }
  while(len >= 1);

__CPROVER_DUMP_L6:
  ;
}

// est_sockpt_down
// file estnode.c line 1942
static void est_sockpt_down(void *sp)
{
  est_sock_down(*((signed int *)sp));
  free(sp);
}

// est_str_fwmatch_wide
// file estraier.c line 6812
static signed int est_str_fwmatch_wide(const unsigned char *str, signed int size, const unsigned char *key, signed int ksiz)
{
  signed int si;
  signed int ki;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(!(ksiz >= 2) || !(size >= 2))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if((signed int)*str == 0x0)
      tmp_if_expr_1 = (signed int)str[(signed long int)1] <= 0x20 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    return 0;

  else
  {
    si = 0;
    ki = 0;
    while(!(ki >= ksiz))
    {
      if(si >= size)
        return 0;

      if((signed int)str[(signed long int)si] == 0x0)
      {
        if((signed int)str[(signed long int)(1 + si)] >= 33)
          goto __CPROVER_DUMP_L8;

        si = si + 2;
      }

      else
      {

      __CPROVER_DUMP_L8:
        ;
        if((signed int)key[(signed long int)ki] == 0x0)
        {
          if((signed int)key[(signed long int)(1 + ki)] >= 33)
            goto __CPROVER_DUMP_L9;

          ki = ki + 2;
        }

        else
        {

        __CPROVER_DUMP_L9:
          ;
          if(!(str[(signed long int)si] == key[(signed long int)ki]))
            tmp_if_expr_3 = (_Bool)1;

          else
            tmp_if_expr_3 = str[(signed long int)(si + 1)] != key[(signed long int)(ki + 1)] ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_3)
            return 0;

          si = si + 2;
          ki = ki + 2;
        }
      }
    }
    return si;
  }
}

// est_str_make_snippet
// file estraier.c line 3498
char * est_str_make_snippet(const char *str, const struct anonymous_6 *words, signed int wwidth, signed int hwidth, signed int awidth)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  char *return_value_est_make_snippet_2;
  return_value_est_make_snippet_2=est_make_snippet(str, (signed int)return_value_strlen_1, words, wwidth, hwidth, awidth);
  return return_value_est_make_snippet_2;
}

// est_strstr_sparse
// file estraier.c line 6841
static char * est_strstr_sparse(const char *haystack, const char *needle)
{
  const char *hp;
  const char *np;
  for( ; (signed int)*needle >= 1; needle = needle + 1l)
    if((signed int)*needle >= 33)
      break;

  _Bool tmp_if_expr_1;
  if((signed int)*needle == 0)
    return (char *)haystack;

  else
  {
    do
    {
      haystack=strchr(haystack, (signed int)*needle);
      if(haystack == ((const char *)NULL))
        break;

      hp = haystack;
      np = needle;
      for( ; (_Bool)1; np = np + 1l)
      {
        for( ; (signed int)*hp >= 1; hp = hp + 1l)
          if((signed int)*hp >= 33)
            break;

        for( ; (signed int)*np >= 1; np = np + 1l)
          if((signed int)*np >= 33)
            break;

        if((signed int)*np == 0)
          return (char *)haystack;

        if(!(*hp == *np))
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = (signed int)*hp == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
          break;

        hp = hp + 1l;
      }
      haystack = haystack + 1l;
    }
    while((_Bool)1);
    return (char *)(void *)0;
  }
}

// est_uconv_in
// file estraier.c line 3672
char * est_uconv_in(const char *ptr, signed int size, signed int *sp)
{
  const unsigned char *rp;
  char *rbuf;
  char *wp;
  rp = (unsigned char *)ptr;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(size * 2 + 1));
  rbuf = (char *)return_value_malloc_1;
  if(!(rbuf == ((char *)NULL)))
    rbuf;

  else
    cbmyfatal("out of memory");
  wp = rbuf;
  char *tmp_post_2;
  char *tmp_post_3;
  char *tmp_post_4;
  char *tmp_post_5;
  char *tmp_post_6;
  char *tmp_post_7;
  char *tmp_post_8;
  char *tmp_post_9;
  char *tmp_post_10;
  char *tmp_post_11;
  char *tmp_post_12;
  char *tmp_post_13;
  while(!(rp >= (unsigned char *)ptr + (signed long int)size))
    if(!((signed int)*rp >= 0x7f))
    {
      tmp_post_2 = wp;
      wp = wp + 1l;
      *tmp_post_2 = (char)0x00;
      tmp_post_3 = wp;
      wp = wp + 1l;
      *tmp_post_3 = (char)*rp;
      rp = rp + (signed long int)1;
    }

    else
      if(!((signed int)*rp >= 0xdf))
      {
        if(rp >= (unsigned char *)ptr + (signed long int)size + -1l)
          break;

        tmp_post_4 = wp;
        wp = wp + 1l;
        *tmp_post_4 = (char)(((signed int)rp[(signed long int)0] & 0x1f) >> 2);
        tmp_post_5 = wp;
        wp = wp + 1l;
        *tmp_post_5 = (char)((signed int)rp[(signed long int)0] << 6 | (signed int)rp[(signed long int)1] & 0x3f);
        rp = rp + (signed long int)2;
      }

      else
        if(!((signed int)*rp >= 0xf0))
        {
          if(rp >= (unsigned char *)ptr + (signed long int)size + -2l)
            break;

          tmp_post_6 = wp;
          wp = wp + 1l;
          *tmp_post_6 = (char)((signed int)rp[(signed long int)0] << 4 | ((signed int)rp[(signed long int)1] & 0x3f) >> 2);
          tmp_post_7 = wp;
          wp = wp + 1l;
          *tmp_post_7 = (char)((signed int)rp[(signed long int)1] << 6 | (signed int)rp[(signed long int)2] & 0x3f);
          rp = rp + (signed long int)3;
        }

        else
          if(!((signed int)*rp >= 0xf8))
          {
            if(rp >= (unsigned char *)ptr + (signed long int)size + -3l)
              break;

            tmp_post_8 = wp;
            wp = wp + 1l;
            *tmp_post_8 = (char)0x00;
            tmp_post_9 = wp;
            wp = wp + 1l;
            *tmp_post_9 = (char)63;
            rp = rp + (signed long int)4;
          }

          else
            if(!((signed int)*rp >= 0xfb))
            {
              if(rp >= (unsigned char *)ptr + (signed long int)size + -4l)
                break;

              tmp_post_10 = wp;
              wp = wp + 1l;
              *tmp_post_10 = (char)0x00;
              tmp_post_11 = wp;
              wp = wp + 1l;
              *tmp_post_11 = (char)63;
              rp = rp + (signed long int)5;
            }

            else
              if(!((signed int)*rp >= 0xfd))
              {
                if(rp >= (unsigned char *)ptr + (signed long int)size + -5l)
                  break;

                tmp_post_12 = wp;
                wp = wp + 1l;
                *tmp_post_12 = (char)0x00;
                tmp_post_13 = wp;
                wp = wp + 1l;
                *tmp_post_13 = (char)63;
                rp = rp + (signed long int)6;
              }

              else
                break;
  *wp = (char)0;
  *sp = (signed int)(wp - rbuf);
  return rbuf;
}

// est_uconv_out
// file estraier.c line 3720
char * est_uconv_out(const char *ptr, signed int size, signed int *sp)
{
  const unsigned char *rp;
  char *rbuf;
  char *wp;
  signed int c;
  if(!(size % 2 == 0))
    size = size - 1;

  rp = (unsigned char *)ptr;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(size * 2 + 1));
  rbuf = (char *)return_value_malloc_1;
  if(!(rbuf == ((char *)NULL)))
    rbuf;

  else
    cbmyfatal("out of memory");
  wp = rbuf;
  char *tmp_post_2;
  char *tmp_post_3;
  char *tmp_post_4;
  char *tmp_post_5;
  char *tmp_post_6;
  char *tmp_post_7;
  for( ; !(rp >= (unsigned char *)ptr + (signed long int)size); rp = rp + (signed long int)2)
  {
    c = (signed int)rp[(signed long int)0] * 0x100 + (signed int)rp[(signed long int)1];
    if(!(c >= 0x0080))
    {
      tmp_post_2 = wp;
      wp = wp + 1l;
      *tmp_post_2 = (char)rp[(signed long int)1];
    }

    else
      if(!(c >= 0x0900))
      {
        tmp_post_3 = wp;
        wp = wp + 1l;
        *tmp_post_3 = (char)(0xc0 | (signed int)rp[(signed long int)0] << 2 | (signed int)rp[(signed long int)1] >> 6 & 0x03);
        tmp_post_4 = wp;
        wp = wp + 1l;
        *tmp_post_4 = (char)(0x80 | (signed int)rp[(signed long int)1] & 0x3f);
      }

      else
      {
        tmp_post_5 = wp;
        wp = wp + 1l;
        *tmp_post_5 = (char)(0xe0 | (signed int)rp[(signed long int)0] >> 4 & 0x0f);
        tmp_post_6 = wp;
        wp = wp + 1l;
        *tmp_post_6 = (char)(0x80 | ((signed int)rp[(signed long int)0] & 0x0f) << 2 | (signed int)rp[(signed long int)1] >> 6 & 0x03);
        tmp_post_7 = wp;
        wp = wp + 1l;
        *tmp_post_7 = (char)(0x80 | (signed int)rp[(signed long int)1] & 0x3f);
      }
  }
  *wp = (char)0;
  if(!(sp == ((signed int *)NULL)))
    *sp = (signed int)(wp - rbuf);

  return rbuf;
}

// est_url_sameness
// file estraier.c line 10382
static signed int est_url_sameness(const char *aurl, const char *burl)
{
  const char *apv;
  const char *bpv;
  signed int i;
  signed int alen;
  signed int blen;
  apv=strstr(aurl, "://");
  if(!(apv == ((const char *)NULL)))
    aurl = apv + (signed long int)3;

  else
    return 0;
  bpv=strstr(burl, "://");
  if(!(bpv == ((const char *)NULL)))
    burl = bpv + (signed long int)3;

  else
    return 0;
  apv=strchr(aurl, 47);
  unsigned long int return_value_strlen_1;
  if(apv == ((const char *)NULL))
  {
    return_value_strlen_1=strlen(aurl);
    apv = aurl + (signed long int)return_value_strlen_1;
  }

  bpv=strchr(burl, 47);
  unsigned long int return_value_strlen_2;
  if(bpv == ((const char *)NULL))
  {
    return_value_strlen_2=strlen(burl);
    bpv = burl + (signed long int)return_value_strlen_2;
  }

  alen = (signed int)(apv - aurl);
  blen = (signed int)(bpv - burl);
  _Bool tmp_if_expr_4;
  signed int return_value_memcmp_3;
  if(!(alen == blen))
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_memcmp_3=memcmp((const void *)aurl, (const void *)burl, (unsigned long int)alen);
    tmp_if_expr_4 = return_value_memcmp_3 != 0 ? (_Bool)1 : (_Bool)0;
  }
  unsigned long int return_value_strlen_5;
  unsigned long int return_value_strlen_6;
  signed int return_value_memcmp_7;
  signed int return_value_memcmp_8;
  if(tmp_if_expr_4)
    return 0;

  else
  {
    aurl = (signed int)*apv == 0 ? "/" : apv;
    burl = (signed int)*bpv == 0 ? "/" : bpv;
    apv=strchr(aurl, 63);
    if(apv == ((const char *)NULL))
    {
      return_value_strlen_5=strlen(aurl);
      apv = aurl + (signed long int)return_value_strlen_5;
    }

    bpv=strchr(burl, 63);
    if(bpv == ((const char *)NULL))
    {
      return_value_strlen_6=strlen(burl);
      bpv = burl + (signed long int)return_value_strlen_6;
    }

    alen = (signed int)(apv - aurl);
    blen = (signed int)(bpv - burl);
    if(alen == blen)
    {
      return_value_memcmp_7=memcmp((const void *)aurl, (const void *)burl, (unsigned long int)alen);
      if(!(return_value_memcmp_7 == 0))
        goto __CPROVER_DUMP_L12;

      return 3;
    }

    else
    {

    __CPROVER_DUMP_L12:
      ;
      apv = aurl;
      i = 0;
      for( ; !(i >= alen); i = i + 1)
        if((signed int)aurl[(signed long int)i] == 47)
          apv = aurl + (signed long int)i;

      bpv = burl;
      i = 0;
      for( ; !(i >= blen); i = i + 1)
        if((signed int)burl[(signed long int)i] == 47)
          bpv = burl + (signed long int)i;

      alen = (signed int)(apv - aurl);
      blen = (signed int)(bpv - burl);
      if(alen == blen)
      {
        return_value_memcmp_8=memcmp((const void *)aurl, (const void *)burl, (unsigned long int)alen);
        if(!(return_value_memcmp_8 == 0))
          goto __CPROVER_DUMP_L19;

        return 2;
      }

      else
      {

      __CPROVER_DUMP_L19:
        ;
        return 1;
      }
    }
  }
}

// est_url_shuttle
// file estnode.c line 1555
signed int est_url_shuttle(const char *url, const char *pxhost, signed int pxport, signed int outsec, signed int limsize, const char *auth, const struct anonymous_6 *reqheads, const char *reqbody, signed int rbsiz, signed int *rescodep, struct anonymous_5 *resheads, struct anonymous_9 *resbody)
{
  unsigned long int th;
  union anonymous_11 mutex;
  union anonymous_20 cond;
  struct timespec timeout;
  struct anonymous_27 targ;
  signed int err;
  signed int rv;
  void *rvp;
  pthread_mutex_init(&mutex, (const union anonymous_13 *)(void *)0);
  pthread_cond_init(&cond, (const union anonymous_13 *)(void *)0);
  targ.alive = 1;
  targ.cond = &cond;
  targ.url = url;
  targ.pxhost = pxhost;
  targ.pxport = pxport;
  targ.limsize = limsize;
  targ.auth = auth;
  targ.reqheads = reqheads;
  targ.reqbody = reqbody;
  targ.rbsiz = rbsiz;
  targ.rescodep = rescodep;
  targ.resheads = resheads;
  targ.resbody = resbody;
  err = 0;
  signed int return_value_pthread_join_2;
  if(outsec >= 0)
  {
    signed int return_value_pthread_mutex_lock_4;
    return_value_pthread_mutex_lock_4=pthread_mutex_lock(&mutex);
    if(return_value_pthread_mutex_lock_4 == 0)
    {
      signed int return_value_pthread_create_3;
      return_value_pthread_create_3=pthread_create(&th, (const union pthread_attr_t *)(void *)0, est_url_shuttle_impl, (void *)&targ);
      if(return_value_pthread_create_3 == 0)
      {
        signed long int return_value_time_1;
        return_value_time_1=time((signed long int *)(void *)0);
        timeout.tv_sec = return_value_time_1 + (signed long int)outsec;
        timeout.tv_nsec = (signed long int)(1000 * 1000 * 500);
        rv = 0;
        while(!(targ.alive == 0) && !(rv == 110))
          rv=pthread_cond_timedwait(&cond, &mutex, &timeout);
        if(rv == 110)
        {
          pthread_cancel(th);
          pthread_join(th, (void **)(void *)0);
          err = 1;
        }

        else
        {
          return_value_pthread_join_2=pthread_join(th, &rvp);
          if(!(rvp == NULL) || !(return_value_pthread_join_2 == 0))
            err = 1;

        }
      }

      else
        err = 1;
      pthread_mutex_unlock(&mutex);
    }

    else
      err = 1;
  }

  else
  {
    void *return_value_est_url_shuttle_impl_5;
    return_value_est_url_shuttle_impl_5=est_url_shuttle_impl((void *)&targ);
    if(!(return_value_est_url_shuttle_impl_5 == NULL))
      err = 1;

  }
  signed int return_value_pthread_mutex_destroy_6;
  return_value_pthread_mutex_destroy_6=pthread_mutex_destroy(&mutex);
  if(!(return_value_pthread_mutex_destroy_6 == 0))
    err = 1;

  signed int return_value_pthread_cond_destroy_7;
  return_value_pthread_cond_destroy_7=pthread_cond_destroy(&cond);
  if(!(return_value_pthread_cond_destroy_7 == 0))
    err = 1;

  return err != 0 ? 0 : 1;
}

// est_url_shuttle_impl
// file estnode.c line 1805
static void * est_url_shuttle_impl(void *targ)
{
  const struct anonymous_6 *reqheads;
  struct anonymous_5 *resheads;
  struct anonymous_5 *elems;
  struct anonymous_9 *resbody;
  struct anonymous_9 *datum;
  const char *url;
  const char *pxhost;
  const char *auth;
  const char *reqbody;
  const char *tmp;
  const char *scheme;
  const char *host;
  const char *path;
  const char *query;
  const char *rp;
  char *addr;
  char *enc;
  char iobuf[8192l];
  char name[8192l];
  char *pv;
  char *zbuf;
  signed int i;
  signed int pxport;
  signed int limsize;
  signed int rbsiz;
  signed int *rescodep;
  signed int port;
  signed int sock;
  signed int *sp;
  signed int size;
  signed int nsiz;
  signed int defl;
  signed int zsiz;
  url = ((struct anonymous_27 *)targ)->url;
  pxhost = ((struct anonymous_27 *)targ)->pxhost;
  pxport = ((struct anonymous_27 *)targ)->pxport;
  limsize = ((struct anonymous_27 *)targ)->limsize;
  auth = ((struct anonymous_27 *)targ)->auth;
  reqheads = ((struct anonymous_27 *)targ)->reqheads;
  reqbody = ((struct anonymous_27 *)targ)->reqbody;
  rbsiz = ((struct anonymous_27 *)targ)->rbsiz;
  rescodep = ((struct anonymous_27 *)targ)->rescodep;
  resheads = ((struct anonymous_27 *)targ)->resheads;
  resbody = ((struct anonymous_27 *)targ)->resbody;
  elems=cburlbreak(url);
  signed int tmp_if_expr_2;
  signed int return_value_atoi_1;
  _Bool tmp_if_expr_4;
  signed int return_value_cbstricmp_3;
  _Bool tmp_if_expr_5;
  signed int return_value_cblistnum_7;
  _Bool tmp_if_expr_11;
  signed int return_value_cbstrfwmatch_10;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_15;
  _Bool tmp_if_expr_13;
  char *return_value_strstr_16;
  signed long int return_value_recv_18;
  signed int return_value_cbdatumsize_19;
  const char *return_value_cbdatumptr_20;
  signed int return_value_cbdatumsize_21;
  do
  {
    struct anonymous_22 __cancel_buf;
    void (*__cancel_routine)(void *) = (void (*)(void *))cbmapclose;
    void *__cancel_arg = (void *)elems;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      scheme=cbmapget(elems, "scheme", -1, (signed int *)(void *)0);
      host=cbmapget(elems, "host", -1, (signed int *)(void *)0);
      tmp=cbmapget(elems, "port", -1, (signed int *)(void *)0);
      if(!(tmp == ((const char *)NULL)))
      {
        return_value_atoi_1=atoi(tmp);
        tmp_if_expr_2 = return_value_atoi_1;
      }

      else
        tmp_if_expr_2 = 80;
      port = tmp_if_expr_2;
      if(auth == ((const char *)NULL))
        auth=cbmapget(elems, "authority", -1, (signed int *)(void *)0);

      path=cbmapget(elems, "path", -1, (signed int *)(void *)0);
      if(path == ((const char *)NULL))
        path = "/";

      query=cbmapget(elems, "query", -1, (signed int *)(void *)0);
      if(query == ((const char *)NULL))
        query = "";

      if(scheme == ((const char *)NULL))
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        return_value_cbstricmp_3=cbstricmp(scheme, "http");
        tmp_if_expr_4 = return_value_cbstricmp_3 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(host == ((const char *)NULL) || !(port >= 1) || tmp_if_expr_4)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        addr=est_get_host_addr(pxhost != ((const char *)NULL) ? pxhost : host);
        tmp_if_expr_5 = !(addr != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
      {
        ((struct anonymous_27 *)targ)->alive = 0;
        pthread_cond_signal(((struct anonymous_27 *)targ)->cond);
        cbmapclose(elems);
        return (void *)"error";
      }

      do
      {
        struct anonymous_22 est_url_shuttle_impl__1__1__2__2____cancel_buf;
        void (*est_url_shuttle_impl__1__1__2__2____cancel_routine)(void *) = (void (*)(void *))free;
        void *est_url_shuttle_impl__1__1__2__2____cancel_arg = (void *)addr;
        signed int est_url_shuttle_impl__1__1__2__2____not_first_call;
        est_url_shuttle_impl__1__1__2__2____not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)est_url_shuttle_impl__1__1__2__2____cancel_buf.__cancel_jmp_buf, 0);
        if(!((signed long int)est_url_shuttle_impl__1__1__2__2____not_first_call == 0l))
        {
          est_url_shuttle_impl__1__1__2__2____cancel_routine(est_url_shuttle_impl__1__1__2__2____cancel_arg);
          __pthread_unwind_next(&est_url_shuttle_impl__1__1__2__2____cancel_buf);
        }

        __pthread_register_cancel(&est_url_shuttle_impl__1__1__2__2____cancel_buf);
        do
        {
          sock=est_get_client_sock(addr, pxhost != ((const char *)NULL) ? pxport : port);
          if(sock == -1)
          {
            ((struct anonymous_27 *)targ)->alive = 0;
            pthread_cond_signal(((struct anonymous_27 *)targ)->cond);
            free((void *)addr);
            cbmapclose(elems);
            return (void *)"error";
          }

          void *return_value_cbmalloc_6;
          return_value_cbmalloc_6=cbmalloc(sizeof(signed int) /*4ul*/ );
          sp = (signed int *)return_value_cbmalloc_6;
          *sp = sock;
          do
          {
            struct anonymous_22 est_url_shuttle_impl__1__1__2__2__2__2____cancel_buf;
            void (*est_url_shuttle_impl__1__1__2__2__2__2____cancel_routine)(void *) = (void (*)(void *))est_sockpt_down;
            void *est_url_shuttle_impl__1__1__2__2__2__2____cancel_arg = (void *)sp;
            signed int est_url_shuttle_impl__1__1__2__2__2__2____not_first_call;
            est_url_shuttle_impl__1__1__2__2__2__2____not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)est_url_shuttle_impl__1__1__2__2__2__2____cancel_buf.__cancel_jmp_buf, 0);
            if(!((signed long int)est_url_shuttle_impl__1__1__2__2__2__2____not_first_call == 0l))
            {
              est_url_shuttle_impl__1__1__2__2__2__2____cancel_routine(est_url_shuttle_impl__1__1__2__2__2__2____cancel_arg);
              __pthread_unwind_next(&est_url_shuttle_impl__1__1__2__2__2__2____cancel_buf);
            }

            __pthread_register_cancel(&est_url_shuttle_impl__1__1__2__2__2__2____cancel_buf);
            do
            {
              datum=cbdatumopen((const char *)(void *)0, -1);
              do
              {
                struct anonymous_22 est_url_shuttle_impl__1__1__2__2__2__2__2__1____cancel_buf;
                void (*est_url_shuttle_impl__1__1__2__2__2__2__2__1____cancel_routine)(void *) = (void (*)(void *))cbdatumclose;
                void *est_url_shuttle_impl__1__1__2__2__2__2__2__1____cancel_arg = (void *)datum;
                signed int est_url_shuttle_impl__1__1__2__2__2__2__2__1____not_first_call;
                est_url_shuttle_impl__1__1__2__2__2__2__2__1____not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)est_url_shuttle_impl__1__1__2__2__2__2__2__1____cancel_buf.__cancel_jmp_buf, 0);
                if(!((signed long int)est_url_shuttle_impl__1__1__2__2__2__2__2__1____not_first_call == 0l))
                {
                  est_url_shuttle_impl__1__1__2__2__2__2__2__1____cancel_routine(est_url_shuttle_impl__1__1__2__2__2__2__2__1____cancel_arg);
                  __pthread_unwind_next(&est_url_shuttle_impl__1__1__2__2__2__2__2__1____cancel_buf);
                }

                __pthread_register_cancel(&est_url_shuttle_impl__1__1__2__2__2__2__2__1____cancel_buf);
                do
                {
                  if(!(pxhost == ((const char *)NULL)))
                    cbdatumprintf(datum, "%s %s HTTP/1.0\r\n", reqbody != ((const char *)NULL) ? "POST" : "GET", url);

                  else
                    if(!(reqbody == ((const char *)NULL)))
                      cbdatumprintf(datum, "POST %s HTTP/1.0\r\n", path);

                    else
                      if(!((signed int)*query == 0))
                        cbdatumprintf(datum, "GET %s?%s HTTP/1.0\r\n", path, query);

                      else
                        cbdatumprintf(datum, "GET %s HTTP/1.0\r\n", path);
                  cbdatumprintf(datum, "Host: %s:%d\r\n", host, port);
                  cbdatumprintf(datum, "Connection: close\r\n", path);
                  cbdatumprintf(datum, "User-Agent: %s/%s\r\n", (const void *)"HyperEstraier", est_version);
                  if(!(auth == ((const char *)NULL)))
                  {
                    enc=cbbaseencode(auth, -1);
                    cbdatumprintf(datum, "Authorization: Basic %s\r\n", enc);
                    free((void *)enc);
                  }

                  cbdatumprintf(datum, "Accept-Encoding: deflate\r\n");
                  if(!(reqbody == ((const char *)NULL)))
                    cbdatumprintf(datum, "Content-Length: %d\r\n", rbsiz);

                  if(!(reqheads == ((const struct anonymous_6 *)NULL)))
                  {
                    i = 0;
                    do
                    {
                      return_value_cblistnum_7=cblistnum(reqheads);
                      if(i >= return_value_cblistnum_7)
                        break;

                      rp=cblistval(reqheads, i, &size);
                      cbdatumprintf(datum, rp, size);
                      cbdatumprintf(datum, "\r\n", 2);
                      i = i + 1;
                    }
                    while((_Bool)1);
                  }

                  cbdatumprintf(datum, "\r\n");
                  const char *return_value_cbdatumptr_8;
                  return_value_cbdatumptr_8=cbdatumptr(datum);
                  signed int return_value_cbdatumsize_9;
                  return_value_cbdatumsize_9=cbdatumsize(datum);
                  est_sock_send_all(sock, return_value_cbdatumptr_8, return_value_cbdatumsize_9);
                  if(!(reqbody == ((const char *)NULL)))
                    est_sock_send_all(sock, reqbody, rbsiz);

                  size=est_sock_recv_line(sock, iobuf, 8192 - 1);
                  if(!(size >= 1))
                    tmp_if_expr_11 = (_Bool)1;

                  else
                  {
                    return_value_cbstrfwmatch_10=cbstrfwmatch(iobuf, "HTTP/");
                    tmp_if_expr_11 = !(return_value_cbstrfwmatch_10 != 0) ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_11)
                    tmp_if_expr_12 = (_Bool)1;

                  else
                  {
                    rp=strchr(iobuf, 32);
                    tmp_if_expr_12 = !(rp != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_12)
                  {
                    ((struct anonymous_27 *)targ)->alive = 0;
                    pthread_cond_signal(((struct anonymous_27 *)targ)->cond);
                    cbdatumclose(datum);
                    est_sockpt_down((void *)sp);
                    free((void *)addr);
                    cbmapclose(elems);
                    return (void *)"error";
                  }

                  rp = rp + 1l;
                  if(!(rescodep == ((signed int *)NULL)))
                    *rescodep=atoi(rp);

                  if(!(resheads == ((struct anonymous_5 *)NULL)))
                    cbmapput(resheads, "", 0, iobuf, size, 1);

                  name[(signed long int)0] = (char)0;
                  nsiz = 0;
                  defl = 0;
                  do
                  {
                    size=est_sock_recv_line(sock, iobuf, 8192 - 1);
                    if(!(size >= 1))
                      break;

                    if(!(resheads == ((struct anonymous_5 *)NULL)))
                    {
                      if((signed int)iobuf[0l] == 32)
                        tmp_if_expr_15 = (_Bool)1;

                      else
                        tmp_if_expr_15 = (signed int)iobuf[(signed long int)0] == 9 ? (_Bool)1 : (_Bool)0;
                      if(tmp_if_expr_15)
                      {
                        if(!((signed int)name[0l] == 0))
                        {
                          iobuf[(signed long int)0] = (char)32;
                          cbmapputcat(resheads, name, nsiz, iobuf, size);
                        }

                      }

                      else
                      {
                        rp=strchr(iobuf, 58);
                        if(!(iobuf >= rp))
                        {
                          nsiz = (signed int)(rp - iobuf);
                          memcpy((void *)name, (const void *)iobuf, (unsigned long int)nsiz);
                          name[(signed long int)nsiz] = (char)0;
                          pv = name;
                          for( ; !((signed int)*pv == 0); pv = pv + 1l)
                            if((signed int)*pv >= 65)
                            {
                              if(!((signed int)*pv >= 91))
                                *pv = (char)((signed int)*pv + (97 - 65));

                            }

                          rp = rp + 1l;
                          if((signed int)*rp == 32)
                            tmp_if_expr_13 = (_Bool)1;

                          else
                            tmp_if_expr_13 = (signed int)*rp == 9 ? (_Bool)1 : (_Bool)0;
                          if(tmp_if_expr_13)
                            rp = rp + 1l;

                          const char *return_value_cbmapget_14;
                          return_value_cbmapget_14=cbmapget(resheads, name, nsiz, (signed int *)(void *)0);
                          if(!(return_value_cbmapget_14 == ((const char *)NULL)))
                          {
                            cbmapputcat(resheads, name, nsiz, ", ", 2);
                            cbmapputcat(resheads, name, nsiz, pv, -1);
                          }

                          else
                            cbmapput(resheads, name, nsiz, rp, -1, 1);
                        }

                      }
                    }

                    signed int return_value_cbstrfwimatch_17;
                    return_value_cbstrfwimatch_17=cbstrfwimatch(iobuf, "content-encoding:");
                    if(!(return_value_cbstrfwimatch_17 == 0))
                    {
                      return_value_strstr_16=strstr(iobuf + (signed long int)17, "deflate");
                      if(!(return_value_strstr_16 == ((char *)NULL)))
                        defl = 1;

                    }

                  }
                  while((_Bool)1);
                  if(!(limsize >= 0))
                    limsize = 0x7fffffff;

                  do
                  {
                    return_value_recv_18=recv(sock, (void *)iobuf, (unsigned long int)8192, 0);
                    size = (signed int)return_value_recv_18;
                    if(!(size >= 1))
                      break;

                    if(!(resbody == ((struct anonymous_9 *)NULL)))
                    {
                      return_value_cbdatumsize_19=cbdatumsize(resbody);
                      if(limsize >= return_value_cbdatumsize_19)
                        cbdatumcat(resbody, iobuf, size);

                    }

                  }
                  while((_Bool)1);
                  if(!(defl == 0))
                  {
                    return_value_cbdatumptr_20=cbdatumptr(resbody);
                    return_value_cbdatumsize_21=cbdatumsize(resbody);
                    zbuf=est_inflate(return_value_cbdatumptr_20, return_value_cbdatumsize_21, &zsiz, 0);
                    if(!(zbuf == ((char *)NULL)))
                      cbdatumsetbuf(resbody, zbuf, zsiz);

                  }


                __CPROVER_DUMP_L60:
                  ;
                }
                while((_Bool)0);
                __pthread_unregister_cancel(&est_url_shuttle_impl__1__1__2__2__2__2__2__1____cancel_buf);
                est_url_shuttle_impl__1__1__2__2__2__2__2__1____cancel_routine(est_url_shuttle_impl__1__1__2__2__2__2__2__1____cancel_arg);
              }
              while((_Bool)0);

            __CPROVER_DUMP_L62:
              ;
            }
            while((_Bool)0);
            __pthread_unregister_cancel(&est_url_shuttle_impl__1__1__2__2__2__2____cancel_buf);
            est_url_shuttle_impl__1__1__2__2__2__2____cancel_routine(est_url_shuttle_impl__1__1__2__2__2__2____cancel_arg);
          }
          while((_Bool)0);

        __CPROVER_DUMP_L64:
          ;
        }
        while((_Bool)0);
        __pthread_unregister_cancel(&est_url_shuttle_impl__1__1__2__2____cancel_buf);
        est_url_shuttle_impl__1__1__2__2____cancel_routine(est_url_shuttle_impl__1__1__2__2____cancel_arg);
      }
      while((_Bool)0);

    __CPROVER_DUMP_L66:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
  }
  while((_Bool)0);
  ((struct anonymous_27 *)targ)->alive = 0;
  pthread_cond_signal(((struct anonymous_27 *)targ)->cond);
  return (void *)0;
}

// est_usleep
// file estraier.h line 1528
void est_usleep(unsigned long int usec)
{
  usleep((unsigned int)usec);
}

// est_utime
// file estraier.c line 5620
signed int est_utime(const char *path, signed long int mtime)
{
  struct utimbuf buf;
  signed int return_value_utime_1;
  if(!(mtime >= 0l))
  {
    return_value_utime_1=utime(path, (struct utimbuf *)(void *)0);
    return (signed int)(return_value_utime_1 == 0);
  }

  else
  {
    buf.actime = mtime;
    buf.modtime = mtime;
    signed int return_value_utime_2;
    return_value_utime_2=utime(path, &buf);
    return (signed int)(return_value_utime_2 == 0);
  }
}

// est_vector_cosine
// file estraier.c line 5829
double est_vector_cosine(const signed int *avec, const signed int *bvec, signed int vnum)
{
  signed int i;
  double iprod;
  double aabs;
  double babs;
  iprod = 0.0;
  i = 0;
  for( ; !(i >= vnum); i = i + 1)
    iprod = iprod + (double)avec[(signed long int)i] * (double)bvec[(signed long int)i];
  aabs = 0.0;
  i = 0;
  for( ; !(i >= vnum); i = i + 1)
    aabs = aabs + (double)avec[(signed long int)i] * (double)avec[(signed long int)i];
  aabs=sqrt(aabs);
  babs = 0.0;
  i = 0;
  for( ; !(i >= vnum); i = i + 1)
    babs = babs + (double)bvec[(signed long int)i] * (double)bvec[(signed long int)i];
  babs=sqrt(babs);
  if(aabs < 1.0 || babs < 1.0 || iprod <= 0.0)
    return 0.0;

  else
    return iprod / (aabs * babs);
}

// est_vector_set_seed
// file estraier.c line 5794
void est_vector_set_seed(struct anonymous_5 *svmap, signed int *svec, signed int vnum)
{
  const char *kbuf;
  signed int nnum;
  signed int ksiz;
  cbmapiterinit(svmap);
  nnum = 0;
  signed int tmp_post_1;
  signed int tmp_post_3;
  while(!(nnum >= vnum))
  {
    kbuf=cbmapiternext(svmap, &ksiz);
    if(!(kbuf == ((const char *)NULL)))
    {
      if(!(ksiz >= 1))
        continue;

      tmp_post_1 = nnum;
      nnum = nnum + 1;
      const char *return_value_cbmapiterval_2;
      return_value_cbmapiterval_2=cbmapiterval(kbuf, (signed int *)(void *)0);
      svec[(signed long int)tmp_post_1]=atoi(return_value_cbmapiterval_2);
    }

    else
    {
      tmp_post_3 = nnum;
      nnum = nnum + 1;
      svec[(signed long int)tmp_post_3] = 0;
    }
  }
}

// est_vector_set_target
// file estraier.c line 5812
void est_vector_set_target(struct anonymous_5 *svmap, struct anonymous_5 *tvmap, signed int *tvec, signed int vnum)
{
  const char *kbuf;
  const char *vbuf;
  signed int i;
  signed int ksiz;
  cbmapiterinit(svmap);
  i = 0;
  signed int tmp_if_expr_2;
  signed int return_value_atoi_1;
  for( ; !(i >= vnum); i = i + 1)
  {
    kbuf=cbmapiternext(svmap, &ksiz);
    if(!(kbuf == ((const char *)NULL)))
    {
      vbuf=cbmapget(tvmap, kbuf, ksiz, (signed int *)(void *)0);
      if(!(vbuf == ((const char *)NULL)))
      {
        return_value_atoi_1=atoi(vbuf);
        tmp_if_expr_2 = return_value_atoi_1;
      }

      else
        tmp_if_expr_2 = 0;
      tvec[(signed long int)i] = tmp_if_expr_2;
    }

    else
      tvec[(signed long int)i] = 0;
  }
}

// est_weight_keywords
// file estraier.c line 8880
static void est_weight_keywords(struct anonymous_0 *db, const char *word, struct anonymous_8 *scores, signed int snum)
{
  struct anonymous_8 *kscores;
  const signed int *res;
  signed int i;
  signed int knum;
  signed int nnum;
  double rank;
  const char *return_value_vlgetcache_1;
  return_value_vlgetcache_1=vlgetcache(db->auxdb, word, -1, &knum);
  res = (signed int *)return_value_vlgetcache_1;
  if(!(res == ((const signed int *)NULL)) && knum >= 2)
  {
    knum = knum / (signed int)sizeof(signed int) /*4ul*/ ;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)(knum / 2) * sizeof(struct anonymous_8) /*16ul*/ );
    kscores = (struct anonymous_8 *)return_value_malloc_2;
    if(!(kscores == ((struct anonymous_8 *)NULL)))
      kscores;

    else
      cbmyfatal("out of memory");
    rank = (double)(knum / 2 + 1);
    nnum = 0;
    i = 0;
    for( ; !(i >= knum); i = i + 2)
    {
      (kscores + (signed long int)nnum)->id = res[(signed long int)i];
      double return_value_pow_3;
      return_value_pow_3=pow(rank, 0.7);
      (kscores + (signed long int)nnum)->score = (signed int)((return_value_pow_3 / 8.0 + 1.0) * 10000.0);
      nnum = nnum + 1;
      rank = rank - 1.0;
    }
    knum = nnum;
    qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_id_asc);
    qsort((void *)kscores, (unsigned long int)knum, sizeof(struct anonymous_8) /*16ul*/ , est_score_compare_by_id_asc);
    nnum = 0;
    i = 0;
    for( ; !(i >= snum); i = i + 1)
    {
      for( ; !(nnum >= knum); nnum = nnum + 1)
        if((kscores + (signed long int)nnum)->id >= (scores + (signed long int)i)->id)
          break;

      if(!(nnum >= knum))
      {
        if((kscores + (signed long int)nnum)->id == (scores + (signed long int)i)->id)
          (scores + (signed long int)i)->score = (scores + (signed long int)i)->score * (signed int)((double)(kscores + (signed long int)nnum)->score / 10000.0);

      }

    }
    free((void *)kscores);
  }

}

// main
// file estload.c line 58
signed int main(signed int argc, char **argv)
{
  char *file;
  signed int i;
  signed int tnum;
  signed int lnum;
  signed int ims;
  signed int pb;
  signed int qb;
  signed int rv;
  est_proc_env_reset();
  g_progname = argv[(signed long int)0];
  signed int return_value_est_init_net_env_1;
  return_value_est_init_net_env_1=est_init_net_env();
  if(return_value_est_init_net_env_1 == 0)
  {
    printferror("could not initialize network environment");
    exit(1);
  }

  atexit(est_free_net_env);
  file = (char *)(void *)0;
  tnum = 1;
  lnum = 1;
  ims = 0;
  pb = 0;
  qb = 0;
  i = 1;
  _Bool tmp_if_expr_7;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  for( ; !(i >= argc); i = i + 1)
  {
    if(file == ((char *)NULL))
      tmp_if_expr_7 = (signed int)argv[(signed long int)i][(signed long int)0] == 45 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_7 = (_Bool)0;
    if(tmp_if_expr_7)
    {
      signed int return_value_strcmp_6;
      return_value_strcmp_6=strcmp(argv[(signed long int)i], "-t");
      if(return_value_strcmp_6 == 0)
      {
        i = i + 1;
        if(i >= argc)
          usage();

        tnum=atoi(argv[(signed long int)i]);
      }

      else
      {
        return_value_strcmp_5=strcmp(argv[(signed long int)i], "-l");
        if(return_value_strcmp_5 == 0)
        {
          i = i + 1;
          if(i >= argc)
            usage();

          lnum=atoi(argv[(signed long int)i]);
        }

        else
        {
          return_value_strcmp_4=strcmp(argv[(signed long int)i], "-i");
          if(return_value_strcmp_4 == 0)
          {
            i = i + 1;
            if(i >= argc)
              usage();

            ims=atoi(argv[(signed long int)i]);
          }

          else
          {
            return_value_strcmp_3=strcmp(argv[(signed long int)i], "-p");
            if(return_value_strcmp_3 == 0)
              pb = 1;

            else
            {
              return_value_strcmp_2=strcmp(argv[(signed long int)i], "-q");
              if(return_value_strcmp_2 == 0)
                qb = 1;

              else
                usage();
            }
          }
        }
      }
    }

    else
      if(file == ((char *)NULL))
        file = argv[(signed long int)i];

      else
        usage();
  }
  if(file == ((char *)NULL) || !(lnum >= 1) || !(tnum >= 1))
    usage();

  rv=procmain(file, tnum, lnum, ims, pb, qb);
  return rv;
}

// md5_append
// file md5.h line 82
void md5_append(struct md5_state_s *pms, const unsigned char *data, signed int nbytes)
{
  const unsigned char *p = data;
  signed int left = nbytes;
  signed int offset = (signed int)(pms->count[(signed long int)0] >> 3 & (unsigned int)63);
  unsigned int nbits = (unsigned int)(nbytes << 3);
  if(nbytes >= 1)
  {
    pms->count[(signed long int)1] = pms->count[(signed long int)1] + (unsigned int)(nbytes >> 29);
    pms->count[(signed long int)0] = pms->count[(signed long int)0] + nbits;
    if(!(pms->count[0l] >= nbits))
      pms->count[(signed long int)1] = pms->count[(signed long int)1] + 1u;

    if(!(offset == 0))
    {
      signed int copy = offset + nbytes > 64 ? 64 - offset : nbytes;
      memcpy((void *)(pms->buf + (signed long int)offset), (const void *)p, (unsigned long int)copy);
      if(!(copy + offset >= 64))
        goto __CPROVER_DUMP_L7;

      p = p + (signed long int)copy;
      left = left - copy;
      md5_process(pms, pms->buf);
    }

    for( ; left >= 64; left = left - 64)
    {
      md5_process(pms, p);
      p = p + (signed long int)64;
    }
    if(!(left == 0))
      memcpy((void *)pms->buf, (const void *)p, (unsigned long int)left);

  }


__CPROVER_DUMP_L7:
  ;
}

// md5_finish
// file md5.h line 85
void md5_finish(struct md5_state_s *pms, unsigned char *digest)
{
  unsigned char data[8l];
  signed int i = 0;
  for( ; !(i >= 8); i = i + 1)
    data[(signed long int)i] = (unsigned char)(pms->count[(signed long int)(i >> 2)] >> ((i & 3) << 3));
  static const unsigned char pad[64l] = { (const unsigned char)0x80, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0 };
  md5_append(pms, pad, (signed int)(((unsigned int)55 - (pms->count[(signed long int)0] >> 3) & (unsigned int)63) + (unsigned int)1));
  md5_append(pms, data, 8);
  i = 0;
  for( ; !(i >= 16); i = i + 1)
    digest[(signed long int)i] = (unsigned char)(pms->abcd[(signed long int)(i >> 2)] >> ((i & 3) << 3));
}

// md5_init
// file md5.h line 79
void md5_init(struct md5_state_s *pms)
{
  pms->count[(signed long int)1] = (unsigned int)0;
  pms->count[(signed long int)0] = pms->count[(signed long int)1];
  pms->abcd[(signed long int)0] = (unsigned int)0x67452301;
  pms->abcd[(signed long int)1] = (unsigned int)~0 ^ (unsigned int)0x10325476;
  pms->abcd[(signed long int)2] = (unsigned int)~0 ^ (unsigned int)0x67452301;
  pms->abcd[(signed long int)3] = (unsigned int)0x10325476;
}

// md5_process
// file md5.c line 132
static void md5_process(struct md5_state_s *pms, const unsigned char *data)
{
  unsigned int a = pms->abcd[(signed long int)0];
  unsigned int b = pms->abcd[(signed long int)1];
  unsigned int c = pms->abcd[(signed long int)2];
  unsigned int d = pms->abcd[(signed long int)3];
  unsigned int t;
  unsigned int xbuf[16l];
  const unsigned int *X;
  static const signed int w = 1;
  if(!(*((const unsigned char *)&w) == 0))
  {
    if((data - ((const unsigned char *)NULL) & 3l) == 0l)
      X = (const unsigned int *)data;

    else
    {
      memcpy((void *)xbuf, (const void *)data, (unsigned long int)64);
      X = xbuf;
    }
  }

  else
  {
    const unsigned char *xp = data;
    signed int i;
    X = xbuf;
    i = 0;
    for( ; !(i >= 16); xp = xp + (signed long int)4)
    {
      xbuf[(signed long int)i] = (unsigned int)((signed int)xp[(signed long int)0] + ((signed int)xp[(signed long int)1] << 8) + ((signed int)xp[(signed long int)2] << 16) + ((signed int)xp[(signed long int)3] << 24));
      i = i + 1;
    }
  }
  t = a + (b & c | ~b & d) + X[(signed long int)0] + ((unsigned int)~0 ^ (unsigned int)0x28955b87);
  a = (t << 7 | t >> 32 - 7) + b;
  t = d + (a & b | ~a & c) + X[(signed long int)1] + ((unsigned int)~0 ^ (unsigned int)0x173848a9);
  d = (t << 12 | t >> 32 - 12) + a;
  t = c + (d & a | ~d & b) + X[(signed long int)2] + (unsigned int)0x242070db;
  c = (t << 17 | t >> 32 - 17) + d;
  t = b + (c & d | ~c & a) + X[(signed long int)3] + ((unsigned int)~0 ^ (unsigned int)0x3e423111);
  b = (t << 22 | t >> 32 - 22) + c;
  t = a + (b & c | ~b & d) + X[(signed long int)4] + ((unsigned int)~0 ^ (unsigned int)0x0a83f050);
  a = (t << 7 | t >> 32 - 7) + b;
  t = d + (a & b | ~a & c) + X[(signed long int)5] + (unsigned int)0x4787c62a;
  d = (t << 12 | t >> 32 - 12) + a;
  t = c + (d & a | ~d & b) + X[(signed long int)6] + ((unsigned int)~0 ^ (unsigned int)0x57cfb9ec);
  c = (t << 17 | t >> 32 - 17) + d;
  t = b + (c & d | ~c & a) + X[(signed long int)7] + ((unsigned int)~0 ^ (unsigned int)0x02b96afe);
  b = (t << 22 | t >> 32 - 22) + c;
  t = a + (b & c | ~b & d) + X[(signed long int)8] + (unsigned int)0x698098d8;
  a = (t << 7 | t >> 32 - 7) + b;
  t = d + (a & b | ~a & c) + X[(signed long int)9] + ((unsigned int)~0 ^ (unsigned int)0x74bb0850);
  d = (t << 12 | t >> 32 - 12) + a;
  t = c + (d & a | ~d & b) + X[(signed long int)10] + ((unsigned int)~0 ^ (unsigned int)0x0000a44e);
  c = (t << 17 | t >> 32 - 17) + d;
  t = b + (c & d | ~c & a) + X[(signed long int)11] + ((unsigned int)~0 ^ (unsigned int)0x76a32841);
  b = (t << 22 | t >> 32 - 22) + c;
  t = a + (b & c | ~b & d) + X[(signed long int)12] + (unsigned int)0x6b901122;
  a = (t << 7 | t >> 32 - 7) + b;
  t = d + (a & b | ~a & c) + X[(signed long int)13] + ((unsigned int)~0 ^ (unsigned int)0x02678e6c);
  d = (t << 12 | t >> 32 - 12) + a;
  t = c + (d & a | ~d & b) + X[(signed long int)14] + ((unsigned int)~0 ^ (unsigned int)0x5986bc71);
  c = (t << 17 | t >> 32 - 17) + d;
  t = b + (c & d | ~c & a) + X[(signed long int)15] + (unsigned int)0x49b40821;
  b = (t << 22 | t >> 32 - 22) + c;
  t = a + (b & d | c & ~d) + X[(signed long int)1] + ((unsigned int)~0 ^ (unsigned int)0x09e1da9d);
  a = (t << 5 | t >> 32 - 5) + b;
  t = d + (a & c | b & ~c) + X[(signed long int)6] + ((unsigned int)~0 ^ (unsigned int)0x3fbf4cbf);
  d = (t << 9 | t >> 32 - 9) + a;
  t = c + (d & b | a & ~b) + X[(signed long int)11] + (unsigned int)0x265e5a51;
  c = (t << 14 | t >> 32 - 14) + d;
  t = b + (c & a | d & ~a) + X[(signed long int)0] + ((unsigned int)~0 ^ (unsigned int)0x16493855);
  b = (t << 20 | t >> 32 - 20) + c;
  t = a + (b & d | c & ~d) + X[(signed long int)5] + ((unsigned int)~0 ^ (unsigned int)0x29d0efa2);
  a = (t << 5 | t >> 32 - 5) + b;
  t = d + (a & c | b & ~c) + X[(signed long int)10] + (unsigned int)0x02441453;
  d = (t << 9 | t >> 32 - 9) + a;
  t = c + (d & b | a & ~b) + X[(signed long int)15] + ((unsigned int)~0 ^ (unsigned int)0x275e197e);
  c = (t << 14 | t >> 32 - 14) + d;
  t = b + (c & a | d & ~a) + X[(signed long int)4] + ((unsigned int)~0 ^ (unsigned int)0x182c0437);
  b = (t << 20 | t >> 32 - 20) + c;
  t = a + (b & d | c & ~d) + X[(signed long int)9] + (unsigned int)0x21e1cde6;
  a = (t << 5 | t >> 32 - 5) + b;
  t = d + (a & c | b & ~c) + X[(signed long int)14] + ((unsigned int)~0 ^ (unsigned int)0x3cc8f829);
  d = (t << 9 | t >> 32 - 9) + a;
  t = c + (d & b | a & ~b) + X[(signed long int)3] + ((unsigned int)~0 ^ (unsigned int)0x0b2af278);
  c = (t << 14 | t >> 32 - 14) + d;
  t = b + (c & a | d & ~a) + X[(signed long int)8] + (unsigned int)0x455a14ed;
  b = (t << 20 | t >> 32 - 20) + c;
  t = a + (b & d | c & ~d) + X[(signed long int)13] + ((unsigned int)~0 ^ (unsigned int)0x561c16fa);
  a = (t << 5 | t >> 32 - 5) + b;
  t = d + (a & c | b & ~c) + X[(signed long int)2] + ((unsigned int)~0 ^ (unsigned int)0x03105c07);
  d = (t << 9 | t >> 32 - 9) + a;
  t = c + (d & b | a & ~b) + X[(signed long int)7] + (unsigned int)0x676f02d9;
  c = (t << 14 | t >> 32 - 14) + d;
  t = b + (c & a | d & ~a) + X[(signed long int)12] + ((unsigned int)~0 ^ (unsigned int)0x72d5b375);
  b = (t << 20 | t >> 32 - 20) + c;
  t = a + (b ^ c ^ d) + X[(signed long int)5] + ((unsigned int)~0 ^ (unsigned int)0x0005c6bd);
  a = (t << 4 | t >> 32 - 4) + b;
  t = d + (a ^ b ^ c) + X[(signed long int)8] + ((unsigned int)~0 ^ (unsigned int)0x788e097e);
  d = (t << 11 | t >> 32 - 11) + a;
  t = c + (d ^ a ^ b) + X[(signed long int)11] + (unsigned int)0x6d9d6122;
  c = (t << 16 | t >> 32 - 16) + d;
  t = b + (c ^ d ^ a) + X[(signed long int)14] + ((unsigned int)~0 ^ (unsigned int)0x021ac7f3);
  b = (t << 23 | t >> 32 - 23) + c;
  t = a + (b ^ c ^ d) + X[(signed long int)1] + ((unsigned int)~0 ^ (unsigned int)0x5b4115bb);
  a = (t << 4 | t >> 32 - 4) + b;
  t = d + (a ^ b ^ c) + X[(signed long int)4] + (unsigned int)0x4bdecfa9;
  d = (t << 11 | t >> 32 - 11) + a;
  t = c + (d ^ a ^ b) + X[(signed long int)7] + ((unsigned int)~0 ^ (unsigned int)0x0944b49f);
  c = (t << 16 | t >> 32 - 16) + d;
  t = b + (c ^ d ^ a) + X[(signed long int)10] + ((unsigned int)~0 ^ (unsigned int)0x4140438f);
  b = (t << 23 | t >> 32 - 23) + c;
  t = a + (b ^ c ^ d) + X[(signed long int)13] + (unsigned int)0x289b7ec6;
  a = (t << 4 | t >> 32 - 4) + b;
  t = d + (a ^ b ^ c) + X[(signed long int)0] + ((unsigned int)~0 ^ (unsigned int)0x155ed805);
  d = (t << 11 | t >> 32 - 11) + a;
  t = c + (d ^ a ^ b) + X[(signed long int)3] + ((unsigned int)~0 ^ (unsigned int)0x2b10cf7a);
  c = (t << 16 | t >> 32 - 16) + d;
  t = b + (c ^ d ^ a) + X[(signed long int)6] + (unsigned int)0x04881d05;
  b = (t << 23 | t >> 32 - 23) + c;
  t = a + (b ^ c ^ d) + X[(signed long int)9] + ((unsigned int)~0 ^ (unsigned int)0x262b2fc6);
  a = (t << 4 | t >> 32 - 4) + b;
  t = d + (a ^ b ^ c) + X[(signed long int)12] + ((unsigned int)~0 ^ (unsigned int)0x1924661a);
  d = (t << 11 | t >> 32 - 11) + a;
  t = c + (d ^ a ^ b) + X[(signed long int)15] + (unsigned int)0x1fa27cf8;
  c = (t << 16 | t >> 32 - 16) + d;
  t = b + (c ^ d ^ a) + X[(signed long int)2] + ((unsigned int)~0 ^ (unsigned int)0x3b53a99a);
  b = (t << 23 | t >> 32 - 23) + c;
  t = a + (c ^ (b | ~d)) + X[(signed long int)0] + ((unsigned int)~0 ^ (unsigned int)0x0bd6ddbb);
  a = (t << 6 | t >> 32 - 6) + b;
  t = d + (b ^ (a | ~c)) + X[(signed long int)7] + (unsigned int)0x432aff97;
  d = (t << 10 | t >> 32 - 10) + a;
  t = c + (a ^ (d | ~b)) + X[(signed long int)14] + ((unsigned int)~0 ^ (unsigned int)0x546bdc58);
  c = (t << 15 | t >> 32 - 15) + d;
  t = b + (d ^ (c | ~a)) + X[(signed long int)5] + ((unsigned int)~0 ^ (unsigned int)0x036c5fc6);
  b = (t << 21 | t >> 32 - 21) + c;
  t = a + (c ^ (b | ~d)) + X[(signed long int)12] + (unsigned int)0x655b59c3;
  a = (t << 6 | t >> 32 - 6) + b;
  t = d + (b ^ (a | ~c)) + X[(signed long int)3] + ((unsigned int)~0 ^ (unsigned int)0x70f3336d);
  d = (t << 10 | t >> 32 - 10) + a;
  t = c + (a ^ (d | ~b)) + X[(signed long int)10] + ((unsigned int)~0 ^ (unsigned int)0x00100b82);
  c = (t << 15 | t >> 32 - 15) + d;
  t = b + (d ^ (c | ~a)) + X[(signed long int)1] + ((unsigned int)~0 ^ (unsigned int)0x7a7ba22e);
  b = (t << 21 | t >> 32 - 21) + c;
  t = a + (c ^ (b | ~d)) + X[(signed long int)8] + (unsigned int)0x6fa87e4f;
  a = (t << 6 | t >> 32 - 6) + b;
  t = d + (b ^ (a | ~c)) + X[(signed long int)15] + ((unsigned int)~0 ^ (unsigned int)0x01d3191f);
  d = (t << 10 | t >> 32 - 10) + a;
  t = c + (a ^ (d | ~b)) + X[(signed long int)6] + ((unsigned int)~0 ^ (unsigned int)0x5cfebceb);
  c = (t << 15 | t >> 32 - 15) + d;
  t = b + (d ^ (c | ~a)) + X[(signed long int)13] + (unsigned int)0x4e0811a1;
  b = (t << 21 | t >> 32 - 21) + c;
  t = a + (c ^ (b | ~d)) + X[(signed long int)4] + ((unsigned int)~0 ^ (unsigned int)0x08ac817d);
  a = (t << 6 | t >> 32 - 6) + b;
  t = d + (b ^ (a | ~c)) + X[(signed long int)11] + ((unsigned int)~0 ^ (unsigned int)0x42c50dca);
  d = (t << 10 | t >> 32 - 10) + a;
  t = c + (a ^ (d | ~b)) + X[(signed long int)2] + (unsigned int)0x2ad7d2bb;
  c = (t << 15 | t >> 32 - 15) + d;
  t = b + (d ^ (c | ~a)) + X[(signed long int)9] + ((unsigned int)~0 ^ (unsigned int)0x14792c6e);
  b = (t << 21 | t >> 32 - 21) + c;
  pms->abcd[(signed long int)0] = pms->abcd[(signed long int)0] + a;
  pms->abcd[(signed long int)1] = pms->abcd[(signed long int)1] + b;
  pms->abcd[(signed long int)2] = pms->abcd[(signed long int)2] + c;
  pms->abcd[(signed long int)3] = pms->abcd[(signed long int)3] + d;
}

// printferror
// file estload.c line 116
static void printferror(const char *format, ...)
{
  void **ap = (void **)&format;
  fprintf(stderr, "%s: ERROR: ", g_progname);
  vfprintf(stderr, format, ap);
  fputc(10, stderr);
  fflush(stderr);
  ap = ((void **)NULL);
}

// printfinfo
// file estload.c line 128
static void printfinfo(const char *format, ...)
{
  void **ap = (void **)&format;
  printf("%s: INFO: ", g_progname);
  vprintf(format, ap);
  putchar(10);
  fflush(stdout);
  ap = ((void **)NULL);
}

// procmain
// file estload.c line 140
static signed int procmain(const char *file, signed int tnum, signed int lnum, signed int ims, signed int pb, signed int qb)
{
  unsigned long int *threads;
  struct anonymous_29 *missions;
  struct anonymous_30 target;
  struct anonymous_6 *list;
  struct anonymous_5 *elems;
  const char *line;
  const char *host;
  const char *pstr;
  const char *auth;
  const char *path;
  const char *query;
  signed int i;
  signed int j;
  signed int cnt;
  signed int pnum;
  signed int err;
  double etime;
  signed int return_value_cbstrfwimatch_1;
  return_value_cbstrfwimatch_1=cbstrfwimatch(file, "http://");
  if(!(return_value_cbstrfwimatch_1 == 0))
  {
    list=cblistopen();
    cblistpush(list, file, -1);
  }

  else
  {
    list=cbreadlines(file);
    if(list == ((struct anonymous_6 *)NULL))
    {
      printferror("%s: could not open", file);
      return 1;
    }

  }
  void *return_value_cbmalloc_2;
  return_value_cbmalloc_2=cbmalloc((unsigned long int)tnum * sizeof(unsigned long int) /*8ul*/ );
  threads = (unsigned long int *)return_value_cbmalloc_2;
  void *return_value_cbmalloc_3;
  return_value_cbmalloc_3=cbmalloc((unsigned long int)tnum * sizeof(struct anonymous_29) /*32ul*/ );
  missions = (struct anonymous_29 *)return_value_cbmalloc_3;
  i = 0;
  for( ; !(i >= tnum); i = i + 1)
  {
    (missions + (signed long int)i)->id = i + 1;
    (missions + (signed long int)i)->ims = ims;
    (missions + (signed long int)i)->pb = pb;
    (missions + (signed long int)i)->qb = qb;
    (missions + (signed long int)i)->targets=cblistopen();
  }
  cnt = 0;
  i = 0;
  signed int return_value_cblistnum_4;
  signed int tmp_if_expr_6;
  signed int return_value_atoi_5;
  signed int tmp_post_7;
  for( ; !(i >= lnum); i = i + 1)
  {
    j = 0;
    do
    {
      return_value_cblistnum_4=cblistnum(list);
      if(j >= return_value_cblistnum_4)
        break;

      line=cblistval(list, j, (signed int *)(void *)0);
      if(!((signed int)*line == 0))
      {
        elems=cburlbreak(line);
        host=cbmapget(elems, "host", -1, (signed int *)(void *)0);
        pstr=cbmapget(elems, "port", -1, (signed int *)(void *)0);
        if(!(pstr == ((const char *)NULL)))
        {
          return_value_atoi_5=atoi(pstr);
          tmp_if_expr_6 = return_value_atoi_5;
        }

        else
          tmp_if_expr_6 = 80;
        pnum = tmp_if_expr_6;
        auth=cbmapget(elems, "authority", -1, (signed int *)(void *)0);
        path=cbmapget(elems, "path", -1, (signed int *)(void *)0);
        query=cbmapget(elems, "query", -1, (signed int *)(void *)0);
        if(host == ((const char *)NULL) || !(pnum >= 1))
        {
          printferror("%s: invalid URL", line);
          cbmapclose(elems);
        }

        else
        {
          if(auth == ((const char *)NULL))
            auth = "";

          if(path == ((const char *)NULL))
            path = "/";

          if(query == ((const char *)NULL))
            query = "";

          target.addr=est_get_host_addr(host);
          if(target.addr == ((char *)NULL))
          {
            printferror("%s: unknown host", host);
            cbmapclose(elems);
          }

          else
          {
            target.host=cbmemdup(host, -1);
            target.port = pnum;
            target.auth=cbmemdup(auth, -1);
            target.path=cbmemdup(path, -1);
            target.query=cbmemdup(query, -1);
            tmp_post_7 = cnt;
            cnt = cnt + 1;
            cblistpush((missions + (signed long int)(tmp_post_7 % tnum))->targets, (char *)&target, (signed int)sizeof(struct anonymous_30) /*48ul*/ );
            cbmapclose(elems);
          }
        }
      }

      j = j + 1;
    }
    while((_Bool)1);
  }
  cblistclose(list);
  err = 0;
  etime=est_gettimeofday();
  if(tnum >= 2)
  {
    i = 0;
    for( ; !(i >= tnum); i = i + 1)
    {
      (missions + (signed long int)i)->alive = 0;
      signed int return_value_pthread_create_8;
      return_value_pthread_create_8=pthread_create(threads + (signed long int)i, (const union pthread_attr_t *)(void *)0, procthread, (void *)(missions + (signed long int)i));
      if(return_value_pthread_create_8 == 0)
        (missions + (signed long int)i)->alive = 1;

      else
      {
        printferror("thread creation failed");
        err = 1;
      }
    }
    i = 0;
    for( ; !(i >= tnum); i = i + 1)
      if(!((missions + (signed long int)i)->alive == 0))
      {
        signed int return_value_pthread_join_9;
        return_value_pthread_join_9=pthread_join(threads[(signed long int)i], (void **)(void *)0);
        if(!(return_value_pthread_join_9 == 0))
        {
          printferror("thread join failed");
          err = 1;
        }

      }

  }

  else
    procthread((void *)missions);
  double return_value_est_gettimeofday_10;
  return_value_est_gettimeofday_10=est_gettimeofday();
  etime = return_value_est_gettimeofday_10 - etime;
  if(err == 0 && cnt >= 1)
    printfinfo("finished: elepsed time: %.3f sec. (average: %.3f)", etime / (double)1000, (etime / (double)cnt) / (double)1000);

  i = 0;
  signed int return_value_cblistnum_11;
  for( ; !(i >= tnum); i = i + 1)
  {
    j = 0;
    do
    {
      return_value_cblistnum_11=cblistnum((missions + (signed long int)i)->targets);
      if(j >= return_value_cblistnum_11)
        break;

      const char *return_value_cblistval_12;
      return_value_cblistval_12=cblistval((missions + (signed long int)i)->targets, j, (signed int *)(void *)0);
      target = *((struct anonymous_30 *)return_value_cblistval_12);
      free((void *)target.query);
      free((void *)target.path);
      free((void *)target.auth);
      free((void *)target.addr);
      free((void *)target.host);
      j = j + 1;
    }
    while((_Bool)1);
    cblistclose((missions + (signed long int)i)->targets);
  }
  free((void *)missions);
  free((void *)threads);
  return err != 0 ? 1 : 0;
}

// procthread
// file estload.c line 243
static void * procthread(void *arg)
{
  struct anonymous_6 *targets;
  struct anonymous_30 target;
  char iobuf[8192l];
  char *wp;
  char *tmp;
  signed int i;
  signed int id;
  signed int ims;
  signed int pb;
  signed int qb;
  signed int clsock;
  signed int size;
  double etime;
  targets = ((struct anonymous_29 *)arg)->targets;
  id = ((struct anonymous_29 *)arg)->id;
  ims = ((struct anonymous_29 *)arg)->ims;
  pb = ((struct anonymous_29 *)arg)->pb;
  qb = ((struct anonymous_29 *)arg)->qb;
  signed int return_value_cblistnum_1;
  return_value_cblistnum_1=cblistnum(targets);
  signed int return_value_cblistnum_2;
  signed int return_value_cblistnum_4;
  signed long int return_value_recv_12;
  if(!(return_value_cblistnum_1 >= 1))
    return (void *)0;

  else
  {
    printfinfo("%d: started", id);
    etime=est_gettimeofday();
    i = 0;
    do
    {
      return_value_cblistnum_2=cblistnum(targets);
      if(i >= return_value_cblistnum_2)
        break;

      const char *return_value_cblistval_3;
      return_value_cblistval_3=cblistval(targets, i, (signed int *)(void *)0);
      target = *((struct anonymous_30 *)return_value_cblistval_3);
      if(qb == 0)
      {
        return_value_cblistnum_4=cblistnum(targets);
        printfinfo("%d(%d/%d): http://%s:%d%s%s%s", id, i + 1, return_value_cblistnum_4, target.host, target.port, target.path, (signed int)target.query[(signed long int)0] != 0 ? "?" : "", target.query);
      }

      clsock=est_get_client_sock(target.addr, target.port);
      if(!(clsock == -1))
      {
        wp = iobuf;
        signed int return_value_sprintf_5;
        return_value_sprintf_5=sprintf(wp, "GET %s%s%s HTTP/1.0\r\n", target.path, (signed int)target.query[(signed long int)0] != 0 ? "?" : "", target.query);
        wp = wp + (signed long int)return_value_sprintf_5;
        signed int return_value_sprintf_6;
        return_value_sprintf_6=sprintf(wp, "Host: %s:%d\r\n", target.host, target.port);
        wp = wp + (signed long int)return_value_sprintf_6;
        signed int return_value_sprintf_7;
        return_value_sprintf_7=sprintf(wp, "Connection: close\r\n");
        wp = wp + (signed long int)return_value_sprintf_7;
        if(!((signed int)*target.auth == 0))
        {
          tmp=cbbaseencode(target.auth, -1);
          signed int return_value_sprintf_8;
          return_value_sprintf_8=sprintf(wp, "Authorization: Basic %s\r\n", tmp);
          wp = wp + (signed long int)return_value_sprintf_8;
          free((void *)tmp);
        }

        signed int return_value_sprintf_9;
        return_value_sprintf_9=sprintf(wp, "Referer: http://%s:%d%s%s%s\r\n", target.host, target.port, target.path, (signed int)target.query[(signed long int)0] != 0 ? "?" : "", target.query);
        wp = wp + (signed long int)return_value_sprintf_9;
        signed int return_value_sprintf_10;
        return_value_sprintf_10=sprintf(wp, "User-Agent: %s/%s\r\n", (const void *)"EstLoad", est_version);
        wp = wp + (signed long int)return_value_sprintf_10;
        signed int return_value_sprintf_11;
        return_value_sprintf_11=sprintf(wp, "\r\n");
        wp = wp + (signed long int)return_value_sprintf_11;
        est_sock_send_all(clsock, iobuf, (signed int)(wp - iobuf));
        do
        {
          return_value_recv_12=recv(clsock, (void *)iobuf, (unsigned long int)8192, 0);
          size = (signed int)return_value_recv_12;
          if(!(size >= 1))
            break;

          if(!(pb == 0))
            fwrite((const void *)iobuf, (unsigned long int)1, (unsigned long int)size, stdout);

        }
        while((_Bool)1);
        est_sock_down(clsock);
      }

      else
      {
        signed int return_value_cblistnum_13;
        return_value_cblistnum_13=cblistnum(targets);
        printferror("%d(%d/%d): connection failed", id, i + 1, return_value_cblistnum_13);
      }
      if(ims >= 1)
        est_usleep((unsigned long int)(ims * 1000));

      i = i + 1;
    }
    while((_Bool)1);
    double return_value_est_gettimeofday_14;
    return_value_est_gettimeofday_14=est_gettimeofday();
    etime = return_value_est_gettimeofday_14 - etime;
    signed int return_value_cblistnum_15;
    return_value_cblistnum_15=cblistnum(targets);
    printfinfo("%d: finished: elapsed time: %.3f sec. (average: %.3f)", id, etime / (double)1000, (etime / (double)return_value_cblistnum_15) / (double)1000);
    return (void *)0;
  }
}

// usage
// file estload.c line 105
static void usage(void)
{
  fprintf(stderr, "%s: stresser for web applications\n", g_progname);
  fprintf(stderr, "\n");
  fprintf(stderr, "usage:\n");
  fprintf(stderr, "  %s [-t num] [-l num] [-i num] [-p] [-q] [file|url]\n", g_progname);
  fprintf(stderr, "\n");
  exit(1);
}

