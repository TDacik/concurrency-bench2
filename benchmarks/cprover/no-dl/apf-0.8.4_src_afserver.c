// tag-#anon#ST[*{S8}_S8_'cacertificateFile'||*{S8}_S8_'cacertificatePath'||*{S8}_S8_'sCertificateDepth'||S32'certificateDepth'||U32'_pad0'||*{S8}_S8_'certificateFile'||*{S8}_S8_'keysFile'||*{S8}_S8_'dateFormat'||S32'realmsNumber'||U32'_pad1'||S64'startTime'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'hostName'||*{S8}_S8_'sUsersLimit'||*{S8}_S8_'sClientsLimit'||*{S8}_S8_'sRaClientsLimit'||*{S8}_S8_'sUsersPerClient'||*{S8}_S8_'sClientMode'||*{S8}_S8_'sTimeout'||*{S8}_S8_'sMaxIdle'||*{S8}_S8_'realmName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'_pad0'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#__'usersClientsTable'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'hostName'||*{S8}_S8_'sUsersLimit'||*{S8}_S8_'sClientsLimit'||*{S8}_S8_'sRaClientsLimit'||*{S8}_S8_'sUsersPerClient'||*{S8}_S8_'sClientMode'||*{S8}_S8_'sTimeout'||*{S8}_S8_'sMaxIdle'||*{S8}_S8_'realmName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'_pad0'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#__'usersClientsTable'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'hostName'||*{S8}_S8_'sUsersLimit'||*{S8}_S8_'sClientsLimit'||*{S8}_S8_'sRaClientsLimit'||*{S8}_S8_'sUsersPerClient'||*{S8}_S8_'sClientMode'||*{S8}_S8_'sTimeout'||*{S8}_S8_'sMaxIdle'||*{S8}_S8_'realmName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'_pad0'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#__'usersClientsTable'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'hostName'||*{S8}_S8_'sUsersLimit'||*{S8}_S8_'sClientsLimit'||*{S8}_S8_'sRaClientsLimit'||*{S8}_S8_'sUsersPerClient'||*{S8}_S8_'sClientMode'||*{S8}_S8_'sTimeout'||*{S8}_S8_'sMaxIdle'||*{S8}_S8_'realmName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'_pad0'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#__'usersClientsTable'|]#__'realmsTable'|]
// file server_configuration_struct.h line 27
struct anonymous_2;

// tag-#anon#ST[*{S8}_S8_'hostName'||*{S8}_S8_'sUsersLimit'||*{S8}_S8_'sClientsLimit'||*{S8}_S8_'sRaClientsLimit'||*{S8}_S8_'sUsersPerClient'||*{S8}_S8_'sClientMode'||*{S8}_S8_'sTimeout'||*{S8}_S8_'sMaxIdle'||*{S8}_S8_'realmName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'_pad0'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#__'usersClientsTable'|]
// file server_realm_struct.h line 26
struct anonymous_5;

// tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]
// file usr_cli_struct.h line 25
struct anonymous_7;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}_S8_'cacertificateFile'||*{S8}_S8_'cacertificatePath'||*{S8}_S8_'sCertificateDepth'||S32'certificateDepth'||U32'_pad0'||*{S8}_S8_'certificateFile'||*{S8}_S8_'keysFile'||*{S8}_S8_'dateFormat'||S32'realmsNumber'||U32'_pad1'||S64'startTime'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'hostName'||*{S8}_S8_'sUsersLimit'||*{S8}_S8_'sClientsLimit'||*{S8}_S8_'sRaClientsLimit'||*{S8}_S8_'sUsersPerClient'||*{S8}_S8_'sClientMode'||*{S8}_S8_'sTimeout'||*{S8}_S8_'sMaxIdle'||*{S8}_S8_'realmName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'_pad0'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#__'usersClientsTable'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'hostName'||*{S8}_S8_'sUsersLimit'||*{S8}_S8_'sClientsLimit'||*{S8}_S8_'sRaClientsLimit'||*{S8}_S8_'sUsersPerClient'||*{S8}_S8_'sClientMode'||*{S8}_S8_'sTimeout'||*{S8}_S8_'sMaxIdle'||*{S8}_S8_'realmName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'_pad0'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#__'usersClientsTable'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'hostName'||*{S8}_S8_'sUsersLimit'||*{S8}_S8_'sClientsLimit'||*{S8}_S8_'sRaClientsLimit'||*{S8}_S8_'sUsersPerClient'||*{S8}_S8_'sClientMode'||*{S8}_S8_'sTimeout'||*{S8}_S8_'sMaxIdle'||*{S8}_S8_'realmName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'_pad0'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#__'usersClientsTable'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'hostName'||*{S8}_S8_'sUsersLimit'||*{S8}_S8_'sClientsLimit'||*{S8}_S8_'sRaClientsLimit'||*{S8}_S8_'sUsersPerClient'||*{S8}_S8_'sClientMode'||*{S8}_S8_'sTimeout'||*{S8}_S8_'sMaxIdle'||*{S8}_S8_'realmName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'_pad0'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#__'usersClientsTable'|]#__'realmsTable'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'cacertificateFile'||*{S8}_S8_'cacertificatePath'||*{S8}_S8_'sCertificateDepth'||S32'certificateDepth'||U32'_pad0'||*{S8}_S8_'certificateFile'||*{S8}_S8_'keysFile'||*{S8}_S8_'dateFormat'||S32'realmsNumber'||U32'_pad1'||S64'startTime'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'hostName'||*{S8}_S8_'sUsersLimit'||*{S8}_S8_'sClientsLimit'||*{S8}_S8_'sRaClientsLimit'||*{S8}_S8_'sUsersPerClient'||*{S8}_S8_'sClientMode'||*{S8}_S8_'sTimeout'||*{S8}_S8_'sMaxIdle'||*{S8}_S8_'realmName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'_pad0'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#__'usersClientsTable'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'hostName'||*{S8}_S8_'sUsersLimit'||*{S8}_S8_'sClientsLimit'||*{S8}_S8_'sRaClientsLimit'||*{S8}_S8_'sUsersPerClient'||*{S8}_S8_'sClientMode'||*{S8}_S8_'sTimeout'||*{S8}_S8_'sMaxIdle'||*{S8}_S8_'realmName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'_pad0'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#__'usersClientsTable'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'hostName'||*{S8}_S8_'sUsersLimit'||*{S8}_S8_'sClientsLimit'||*{S8}_S8_'sRaClientsLimit'||*{S8}_S8_'sUsersPerClient'||*{S8}_S8_'sClientMode'||*{S8}_S8_'sTimeout'||*{S8}_S8_'sMaxIdle'||*{S8}_S8_'realmName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'_pad0'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#__'usersClientsTable'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'hostName'||*{S8}_S8_'sUsersLimit'||*{S8}_S8_'sClientsLimit'||*{S8}_S8_'sRaClientsLimit'||*{S8}_S8_'sUsersPerClient'||*{S8}_S8_'sClientMode'||*{S8}_S8_'sTimeout'||*{S8}_S8_'sMaxIdle'||*{S8}_S8_'realmName'||ARR4{U8}_U8_'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'_pad0'||U32'addressLength'||U32'_pad1'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#}_SYM#tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]#__'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#_}_*{SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#}_SYM#tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]#__'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'listenHostName'||*{S8}_S8_'manageHostName'||*{S8}_S8_'listenPortName'||*{S8}_S8_'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'_pad0'|]#__'usersClientsTable'|]#__'realmsTable'|]#_'config'||S32'realm'||S32'client'||S8'ra'||S8'reason'||U48'_pad0'||*{SYM#tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]#}_SYM#tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]#_'set'||*{SYM#tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]#}_SYM#tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]#_'wset'|]
// file remove_client_task.h line 29
struct anonymous_25;

// tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]
// file task_struct.h line 24
struct anonymous_13;

// tag-#anon#ST[*{SYM#tag-tlnode#}_SYM#tag-tlnode#_'head'||S32'numberOfTasks'||U32'_pad0'||*{SYM#tag-tlnode#}_SYM#tag-tlnode#_'actualTask'||SYM#tag-timeval#'delta'|]
// file task_scheduler_struct.h line 26
struct anonymous_16;

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_17;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_14;

// tag-#anon#ST[ARR128{U8}_U8_'cert_verify_md'||ARR128{U8}_U8_'finish_md'||S32'finish_md_len'||ARR128{U8}_U8_'peer_finish_md'||S32'peer_finish_md_len'||U64'message_size'||S32'message_type'||U32'_pad0'||*{cSYM#tag-ssl_cipher_st#}_cSYM#tag-ssl_cipher_st#_'new_cipher'||*{SYM#tag-dh_st#}_SYM#tag-dh_st#_'dh'||*{SYM#tag-ec_key_st#}_SYM#tag-ec_key_st#_'ecdh'||S32'next_state'||S32'reuse_message'||S32'cert_req'||S32'ctype_num'||ARR9{S8}_S8_'ctype'||U56'_pad1'||*{SYM#tag-stack_st_X509_NAME#}_SYM#tag-stack_st_X509_NAME#_'ca_names'||S32'use_rsa_tmp'||S32'key_block_length'||*{U8}_U8_'key_block'||*{cSYM#tag-evp_cipher_st#}_cSYM#tag-evp_cipher_st#_'new_sym_enc'||*{cSYM#tag-env_md_st#}_cSYM#tag-env_md_st#_'new_hash'||S32'new_mac_pkey_type'||S32'new_mac_secret_size'||*{cSYM#tag-ssl_comp_st#}_cSYM#tag-ssl_comp_st#_'new_compression'||S32'cert_request'||U32'_pad2'|]
// file /usr/include/openssl/ssl3.h line 553
struct anonymous_0;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_22;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_19;

// tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]
// file header_buffer_struct.h line 24
struct anonymous_8;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 140
struct anonymous_30;

// tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]
// file ssl_fd_struct.h line 27
struct anonymous_1;

// tag-#anon#ST[S32'sess_connect'||S32'sess_connect_renegotiate'||S32'sess_connect_good'||S32'sess_accept'||S32'sess_accept_renegotiate'||S32'sess_accept_good'||S32'sess_miss'||S32'sess_timeout'||S32'sess_cache_full'||S32'sess_hit'||S32'sess_cb_hit'|]
// file /usr/include/openssl/ssl.h line 964
struct anonymous_24;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_9;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_12;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_11;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_21;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_10;

// tag-#anon#ST[S32'sockfd'||U32'_pad0'||*{S8}_S8_'host'||*{S8}_S8_'serv'||*{U32}_U32_'addrlenp'||S8'type'||U24'_pad1'||S32'limit'||S8'https'||U56'_pad2'||*{SYM#tag-ssl_ctx_st#}_SYM#tag-ssl_ctx_st#_'ctx'|]
// file http_proxy_server.c line 32
struct anonymous_28;

// tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]
// file user_stats_struct.h line 27
struct anonymous_6;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_15;

// tag-#anon#ST[S8'read_state'||ARR4{S8}_S8_'readed_length'||S8'state'||ARR10{S8}_S8_'id'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'postFd'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'getFd'||S32'sent_ptr'||S32'sockfd'||ARR9000{S8}_S8_'buf'||ARR9000{S8}_S8_'tmpbuf'||S8'tmpstate'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'tmpFd'||S8'type'||U24'_pad1'||SYM#tag-#anon#ST[S8'type'||ARR10{S8}_S8_'id'||U8'_pad0'||S32'ptr'||S32'length'||S32'allreaded'|]#'tmpheader'||S32'ptr'||S32'length'||S32'curreceived'||S32'toreceive'||S32'received'|]
// file http_proxy_functions.h line 52
struct anonymous_27;

// tag-#anon#ST[S8'state'||U24'_pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||U8'_pad1'||*{SYM#tag-buflist#}_SYM#tag-buflist#_'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#}_SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}_S32_'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}_S32_'downloadSpeedQueue'|]#_'stats'|]
// file connect_user_struct.h line 30
struct anonymous_4;

// tag-#anon#ST[S8'state'||U56'_pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#}_SYM#tag-#anon#ST[S32'fd'||U32'_pad0'||*{SYM#tag-ssl_st#}_SYM#tag-ssl_st#_'ssl'|]#_'sslFd'||SYM#tag-timeval#'timer'||*{S32}_S32_'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'_pad1'||S64'connectTime'||S64'lastActivity'||*{S8}_S8_'sClientId'||ARR128{S8}_S8_'nameBuf'||ARR7{S8}_S8_'portBuf'||S8'tunnelType'||S8'multi'||U56'_pad2'||*{SYM#tag-auditlist#}_SYM#tag-auditlist#_'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#}_SYM#tag-#anon#ST[ARR5{U8}_U8_'tab'||U24'_pad0'||S32'readed'|]#_'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#}_SYM#tag-#anon#ST[*{SYM#tag-timeval#}_SYM#tag-timeval#_'timerp'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'function'||*{V}_V_'data'||*{V(*{*{V}_V_}_*{V}_V__)->V}_V(*{*{V}_V_}_*{V}_V__)->V_'clean'|]#_'task'|]
// file connect_client_struct.h line 46
struct anonymous_3;

// tag-#anon#ST[S8'type'||ARR10{S8}_S8_'id'||U8'_pad0'||S32'ptr'||S32'length'||S32'allreaded'|]
// file http_proxy_functions.h line 44
struct anonymous_26;

// tag-#anon#ST[U32'conn_id_length'||U32'cert_type'||U32'cert_length'||U32'csl'||U32'clear'||U32'enc'||ARR32{U8}_U8_'ccl'||U32'cipher_spec_length'||U32'session_id_length'||U32'clen'||U32'rlen'|]
// file /usr/include/openssl/ssl2.h line 203
struct anonymous;

// tag-#anon#UN[*{S8}_S8_'ptr'||*{SYM#tag-rsa_st#}_SYM#tag-rsa_st#_'rsa'||*{SYM#tag-dsa_st#}_SYM#tag-dsa_st#_'dsa'||*{SYM#tag-dh_st#}_SYM#tag-dh_st#_'dh'||*{SYM#tag-ec_key_st#}_SYM#tag-ec_key_st#_'ec'|]
// file /usr/include/openssl/evp.h line 135
union anonymous_34;

// tag-#anon#UN[*{S8}_S8_'ptr'||S32'boolean'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'asn1_string'||*{SYM#tag-asn1_object_st#}_SYM#tag-asn1_object_st#_'object'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'integer'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'enumerated'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'bit_string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'octet_string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'printablestring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'t61string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'ia5string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'generalstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'bmpstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'universalstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'utctime'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'generalizedtime'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'visiblestring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'utf8string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'set'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'sequence'||*{SYM#tag-ASN1_VALUE_st#}_SYM#tag-ASN1_VALUE_st#_'asn1_value'|]
// file /usr/include/openssl/asn1.h line 526
union anonymous_32;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_18;

// tag-#anon#UN[*{V(S32|S32|*{V}_V_)->V}_V(S32|S32|*{V}_V_)->V_'cb_1'||*{S32(S32|S32|*{SYM#tag-bn_gencb_st#}_SYM#tag-bn_gencb_st#_)->S32}_S32(S32|S32|*{SYM#tag-bn_gencb_st#}_SYM#tag-bn_gencb_st#_)->S32_'cb_2'|]
// file /usr/include/openssl/bn.h line 351
union anonymous_33;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_23;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_20;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 138
union anonymous_31;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_29;

// tag-ASN1_ENCODING_st
// file /usr/include/openssl/asn1.h line 257
struct ASN1_ENCODING_st;

// tag-ASN1_VALUE_st
// file /usr/include/openssl/asn1.h line 299
struct ASN1_VALUE_st;

// tag-AUTHORITY_KEYID_st
// file /usr/include/openssl/ossl_typ.h line 186
struct AUTHORITY_KEYID_st;

// tag-DSA_SIG_st
// file /usr/include/openssl/dsa.h line 124
struct DSA_SIG_st;

// tag-ISSUING_DIST_POINT_st
// file /usr/include/openssl/ossl_typ.h line 188
struct ISSUING_DIST_POINT_st;

// tag-NAME_CONSTRAINTS_st
// file /usr/include/openssl/ossl_typ.h line 189
struct NAME_CONSTRAINTS_st;

// tag-X509_POLICY_CACHE_st
// file /usr/include/openssl/ossl_typ.h line 184
struct X509_POLICY_CACHE_st;

// tag-X509_POLICY_TREE_st
// file /usr/include/openssl/ossl_typ.h line 183
struct X509_POLICY_TREE_st;

// tag-X509_VERIFY_PARAM_ID_st
// file /usr/include/openssl/x509_vfy.h line 159
struct X509_VERIFY_PARAM_ID_st;

// tag-X509_VERIFY_PARAM_st
// file /usr/include/openssl/x509_vfy.h line 167
struct X509_VERIFY_PARAM_st;

// tag-X509_algor_st
// file /usr/include/openssl/ossl_typ.h line 155
struct X509_algor_st;

// tag-X509_crl_info_st
// file /usr/include/openssl/x509.h line 441
struct X509_crl_info_st;

// tag-X509_crl_st
// file /usr/include/openssl/ossl_typ.h line 156
struct X509_crl_st;

// tag-X509_name_entry_st
// file /usr/include/openssl/x509.h line 168
struct X509_name_entry_st;

// tag-X509_name_st
// file /usr/include/openssl/ossl_typ.h line 159
struct X509_name_st;

// tag-X509_pubkey_st
// file /usr/include/openssl/ossl_typ.h line 160
struct X509_pubkey_st;

// tag-X509_req_info_st
// file /usr/include/openssl/x509.h line 226
struct X509_req_info_st;

// tag-X509_req_st
// file /usr/include/openssl/x509.h line 235
struct X509_req_st;

// tag-X509_val_st
// file /usr/include/openssl/x509.h line 152
struct X509_val_st;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_pqueue
// file /usr/include/openssl/pqueue.h line 70
struct _pqueue;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-alnode
// file audit_list_node_struct.h line 26
struct alnode;

// tag-asn1_object_st
// file /usr/include/openssl/ossl_typ.h line 103
struct asn1_object_st;

// tag-asn1_string_st
// file /usr/include/openssl/ossl_typ.h line 83
struct asn1_string_st;

// tag-asn1_type_st
// file /usr/include/openssl/asn1.h line 524
struct asn1_type_st;

// tag-auditlist
// file audit_list_struct.h line 26
struct auditlist;

// tag-bignum_ctx
// file /usr/include/openssl/ossl_typ.h line 121
struct bignum_ctx;

// tag-bignum_st
// file /usr/include/openssl/ossl_typ.h line 120
struct bignum_st;

// tag-bio_method_st
// file /usr/include/openssl/bio.h line 312
struct bio_method_st;

// tag-bio_st
// file /usr/include/openssl/crypto.h line 290
struct bio_st;

// tag-blnode
// file buf_list_node_struct.h line 24
struct blnode;

// tag-bn_blinding_st
// file /usr/include/openssl/ossl_typ.h line 122
struct bn_blinding_st;

// tag-bn_gencb_st
// file /usr/include/openssl/ossl_typ.h line 125
struct bn_gencb_st;

// tag-bn_mont_ctx_st
// file /usr/include/openssl/ossl_typ.h line 123
struct bn_mont_ctx_st;

// tag-buf_mem_st
// file /usr/include/openssl/ossl_typ.h line 127
struct buf_mem_st;

// tag-buflist
// file buf_list_struct.h line 26
struct buflist;

// tag-cert_st
// file /usr/include/openssl/ssl.h line 1035
struct cert_st;

// tag-comp_ctx_st
// file /usr/include/openssl/comp.h line 11
struct comp_ctx_st;

// tag-comp_method_st
// file /usr/include/openssl/comp.h line 13
struct comp_method_st;

// tag-crypto_ex_data_st
// file /usr/include/openssl/ossl_typ.h line 195
struct crypto_ex_data_st;

// tag-dh_method
// file /usr/include/openssl/ossl_typ.h line 141
struct dh_method;

// tag-dh_st
// file /usr/include/openssl/ossl_typ.h line 140
struct dh_st;

// tag-dsa_method
// file /usr/include/openssl/ossl_typ.h line 144
struct dsa_method;

// tag-dsa_st
// file /usr/include/openssl/ossl_typ.h line 143
struct dsa_st;

// tag-dtls1_bitmap_st
// file /usr/include/openssl/dtls1.h line 128
struct dtls1_bitmap_st;

// tag-dtls1_retransmit_state
// file /usr/include/openssl/dtls1.h line 135
struct dtls1_retransmit_state;

// tag-dtls1_state_st
// file /usr/include/openssl/ssl.h line 1493
struct dtls1_state_st;

// tag-dtls1_timeout_st
// file /usr/include/openssl/dtls1.h line 162
struct dtls1_timeout_st;

// tag-ec_key_st
// file /usr/include/openssl/evp.h line 147
struct ec_key_st;

// tag-engine_st
// file /usr/include/openssl/ossl_typ.h line 177
struct engine_st;

// tag-entry
// file first_run.c line 40
struct entry;

// tag-env_md_ctx_st
// file /usr/include/openssl/ossl_typ.h line 132
struct env_md_ctx_st;

// tag-env_md_st
// file /usr/include/openssl/ossl_typ.h line 131
struct env_md_st;

// tag-evp_cipher_ctx_st
// file /usr/include/openssl/ossl_typ.h line 130
struct evp_cipher_ctx_st;

// tag-evp_cipher_st
// file /usr/include/openssl/ossl_typ.h line 129
struct evp_cipher_st;

// tag-evp_pkey_asn1_method_st
// file /usr/include/openssl/ossl_typ.h line 135
struct evp_pkey_asn1_method_st;

// tag-evp_pkey_ctx_st
// file /usr/include/openssl/ossl_typ.h line 138
struct evp_pkey_ctx_st;

// tag-evp_pkey_st
// file /usr/include/openssl/ossl_typ.h line 133
struct evp_pkey_st;

// tag-hm_header_st
// file /usr/include/openssl/dtls1.h line 147
struct hm_header_st;

// tag-hmac_ctx_st
// file /usr/include/openssl/hmac.h line 75
struct hmac_ctx_st;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-lhash_st_SSL_SESSION
// file /usr/include/openssl/ssl.h line 923
struct lhash_st_SSL_SESSION;

// tag-llnode
// file logging.h line 54
struct llnode;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-record_pqueue_st
// file /usr/include/openssl/dtls1.h line 171
struct record_pqueue_st;

// tag-rsa_meth_st
// file /usr/include/openssl/ossl_typ.h line 147
struct rsa_meth_st;

// tag-rsa_st
// file /usr/include/openssl/ossl_typ.h line 146
struct rsa_st;

// tag-sess_cert_st
// file /usr/include/openssl/ssl.h line 531
struct sess_cert_st;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/netinet/in.h line 252
struct sockaddr_in6;

// tag-srp_ctx_st
// file /usr/include/openssl/ssl.h line 849
struct srp_ctx_st;

// tag-srtp_protection_profile_st
// file /usr/include/openssl/ssl.h line 383
struct srtp_protection_profile_st;

// tag-ssl2_state_st
// file /usr/include/openssl/ssl.h line 1491
struct ssl2_state_st;

// tag-ssl3_buf_freelist_st
// file /usr/include/openssl/ssl.h line 1114
struct ssl3_buf_freelist_st;

// tag-ssl3_buffer_st
// file /usr/include/openssl/ssl3.h line 438
struct ssl3_buffer_st;

// tag-ssl3_enc_method
// file /usr/include/openssl/ssl.h line 466
struct ssl3_enc_method;

// tag-ssl3_record_st
// file /usr/include/openssl/ssl3.h line 403
struct ssl3_record_st;

// tag-ssl3_state_st
// file /usr/include/openssl/ssl.h line 1492
struct ssl3_state_st;

// tag-ssl_cipher_st
// file /usr/include/openssl/ssl.h line 375
struct ssl_cipher_st;

// tag-ssl_comp_st
// file /usr/include/openssl/ssl.h line 908
struct ssl_comp_st;

// tag-ssl_ctx_st
// file /usr/include/openssl/ossl_typ.h line 179
struct ssl_ctx_st;

// tag-ssl_method_st
// file /usr/include/openssl/ssl.h line 374
struct ssl_method_st;

// tag-ssl_session_st
// file /usr/include/openssl/ssl.h line 376
struct ssl_session_st;

// tag-ssl_st
// file /usr/include/openssl/ossl_typ.h line 178
struct ssl_st;

// tag-stack_st
// file /usr/include/openssl/stack.h line 66
struct stack_st;

// tag-stack_st_ASN1_OBJECT
// file /usr/include/openssl/asn1.h line 793
struct stack_st_ASN1_OBJECT;

// tag-stack_st_DIST_POINT
// file /usr/include/openssl/x509.h line 288
struct stack_st_DIST_POINT;

// tag-stack_st_GENERAL_NAME
// file /usr/include/openssl/x509.h line 289
struct stack_st_GENERAL_NAME;

// tag-stack_st_GENERAL_NAMES
// file /usr/include/openssl/x509.h line 471
struct stack_st_GENERAL_NAMES;

// tag-stack_st_OCSP_RESPID
// file /usr/include/openssl/ssl.h line 1610
struct stack_st_OCSP_RESPID;

// tag-stack_st_SRTP_PROTECTION_PROFILE
// file /usr/include/openssl/ssl.h line 388
struct stack_st_SRTP_PROTECTION_PROFILE;

// tag-stack_st_SSL_CIPHER
// file /usr/include/openssl/ssl.h line 380
struct stack_st_SSL_CIPHER;

// tag-stack_st_SSL_COMP
// file /usr/include/openssl/ssl.h line 922
struct stack_st_SSL_COMP;

// tag-stack_st_X509
// file /usr/include/openssl/x509.h line 301
struct stack_st_X509;

// tag-stack_st_X509_ALGOR
// file /usr/include/openssl/asn1.h line 162
struct stack_st_X509_ALGOR;

// tag-stack_st_X509_ATTRIBUTE
// file /usr/include/openssl/evp.h line 151
struct stack_st_X509_ATTRIBUTE;

// tag-stack_st_X509_CRL
// file /usr/include/openssl/x509.h line 476
struct stack_st_X509_CRL;

// tag-stack_st_X509_EXTENSION
// file /usr/include/openssl/x509.h line 202
struct stack_st_X509_EXTENSION;

// tag-stack_st_X509_LOOKUP
// file /usr/include/openssl/x509_vfy.h line 136
struct stack_st_X509_LOOKUP;

// tag-stack_st_X509_NAME
// file /usr/include/openssl/x509.h line 192
struct stack_st_X509_NAME;

// tag-stack_st_X509_NAME_ENTRY
// file /usr/include/openssl/x509.h line 175
struct stack_st_X509_NAME_ENTRY;

// tag-stack_st_X509_OBJECT
// file /usr/include/openssl/x509_vfy.h line 137
struct stack_st_X509_OBJECT;

// tag-stack_st_X509_REVOKED
// file /usr/include/openssl/x509.h line 438
struct stack_st_X509_REVOKED;

// tag-stack_st_void
// file /usr/include/openssl/crypto.h line 293
struct stack_st_void;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tlnode
// file task_list_node_struct.h line 26
struct tlnode;

// tag-tls_session_ticket_ext_st
// file /usr/include/openssl/ssl.h line 373
struct tls_session_ticket_ext_st;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-x509_cert_aux_st
// file /usr/include/openssl/x509.h line 262
struct x509_cert_aux_st;

// tag-x509_cinf_st
// file /usr/include/openssl/x509.h line 242
struct x509_cinf_st;

// tag-x509_crl_method_st
// file /usr/include/openssl/ossl_typ.h line 157
struct x509_crl_method_st;

// tag-x509_st
// file /usr/include/openssl/ossl_typ.h line 154
struct x509_st;

// tag-x509_store_ctx_st
// file /usr/include/openssl/ossl_typ.h line 162
struct x509_store_ctx_st;

// tag-x509_store_st
// file /usr/include/openssl/ossl_typ.h line 161
struct x509_store_st;

#ifndef NULL
#define NULL ((void*)0)
#endif

// ASN1_INTEGER_set
// file /usr/include/openssl/asn1.h line 927
signed int ASN1_INTEGER_set(struct asn1_string_st *, signed long int);
// AuditListNode_free
// file audit_list_node_struct.c line 81
void AuditListNode_free(struct alnode **aln);
// AuditListNode_get_connectTime
// file audit_list_node_struct.c line 258
signed long int AuditListNode_get_connectTime(struct alnode *aln);
// AuditListNode_get_connectTimep
// file audit_list_node_struct.h line 56
signed long int * AuditListNode_get_connectTimep(struct alnode *aln);
// AuditListNode_get_duration
// file audit_list_node_struct.h line 53
signed long int AuditListNode_get_duration(struct alnode *aln);
// AuditListNode_get_nameBuf
// file audit_list_node_struct.h line 50
char * AuditListNode_get_nameBuf(struct alnode *aln);
// AuditListNode_get_nextNode
// file audit_list_node_struct.h line 54
struct alnode * AuditListNode_get_nextNode(struct alnode *aln);
// AuditListNode_get_portBuf
// file audit_list_node_struct.h line 51
char * AuditListNode_get_portBuf(struct alnode *aln);
// AuditListNode_get_userId
// file audit_list_node_struct.h line 49
signed int AuditListNode_get_userId(struct alnode *aln);
// AuditListNode_new
// file audit_list_node_struct.c line 36
struct alnode * AuditListNode_new();
// AuditListNode_new_entry
// file audit_list_node_struct.h line 37
struct alnode * AuditListNode_new_entry(signed int userId, char *nameBuf, char *portBuf, signed long int connectTime, signed long int duration);
// AuditListNode_set_connectTime
// file audit_list_node_struct.c line 156
void AuditListNode_set_connectTime(struct alnode *aln, signed long int connectTime);
// AuditListNode_set_duration
// file audit_list_node_struct.c line 173
void AuditListNode_set_duration(struct alnode *aln, signed long int duration);
// AuditListNode_set_nameBuf
// file audit_list_node_struct.c line 120
void AuditListNode_set_nameBuf(struct alnode *aln, char *nameBuf);
// AuditListNode_set_nextNode
// file audit_list_node_struct.c line 190
void AuditListNode_set_nextNode(struct alnode *aln, struct alnode *nextNode);
// AuditListNode_set_portBuf
// file audit_list_node_struct.c line 138
void AuditListNode_set_portBuf(struct alnode *aln, char *portBuf);
// AuditListNode_set_userId
// file audit_list_node_struct.c line 103
void AuditListNode_set_userId(struct alnode *aln, signed int userId);
// AuditList_clear
// file audit_list_struct.h line 39
void AuditList_clear(struct auditlist *al);
// AuditList_delete_first
// file audit_list_struct.h line 38
void AuditList_delete_first(struct auditlist *al);
// AuditList_free
// file audit_list_struct.c line 53
void AuditList_free(struct auditlist **al);
// AuditList_get_first
// file audit_list_struct.h line 37
struct alnode * AuditList_get_first(struct auditlist *al);
// AuditList_insert_back
// file audit_list_struct.h line 36
void AuditList_insert_back(struct auditlist *al, struct alnode *aln);
// AuditList_new
// file audit_list_struct.c line 36
struct auditlist * AuditList_new();
// BufListNode_free
// file buf_list_node_struct.c line 76
void BufListNode_free(struct blnode **bln);
// BufListNode_get_actPtr
// file buf_list_node_struct.h line 42
signed int BufListNode_get_actPtr(struct blnode *bln);
// BufListNode_get_message
// file buf_list_node_struct.c line 221
unsigned char * BufListNode_get_message(struct blnode *bln);
// BufListNode_get_msgLen
// file buf_list_node_struct.c line 204
signed int BufListNode_get_msgLen(struct blnode *bln);
// BufListNode_get_nextNode
// file buf_list_node_struct.c line 238
struct blnode * BufListNode_get_nextNode(struct blnode *bln);
// BufListNode_new
// file buf_list_node_struct.c line 36
struct blnode * BufListNode_new();
// BufListNode_new_message
// file buf_list_node_struct.h line 33
struct blnode * BufListNode_new_message(signed int actPtr, signed int msgLen, unsigned char *message);
// BufListNode_readMessage
// file buf_list_node_struct.h line 47
unsigned char * BufListNode_readMessage(struct blnode *bln);
// BufListNode_readMessageLength
// file buf_list_node_struct.h line 48
signed int BufListNode_readMessageLength(struct blnode *bln);
// BufListNode_set_actPtr
// file buf_list_node_struct.h line 37
void BufListNode_set_actPtr(struct blnode *bln, signed int actPtr);
// BufListNode_set_message
// file buf_list_node_struct.c line 137
void BufListNode_set_message(struct blnode *bln, unsigned char *message, signed int msgLen);
// BufListNode_set_msgLen
// file buf_list_node_struct.c line 119
void BufListNode_set_msgLen(struct blnode *bln, signed int msgLen);
// BufListNode_set_nextNode
// file buf_list_node_struct.c line 170
void BufListNode_set_nextNode(struct blnode *bln, struct blnode *nextNode);
// BufList_clear
// file buf_list_struct.h line 39
void BufList_clear(struct buflist *bl);
// BufList_delete_first
// file buf_list_struct.h line 38
void BufList_delete_first(struct buflist *bl);
// BufList_free
// file buf_list_struct.c line 53
void BufList_free(struct buflist **bl);
// BufList_get_first
// file buf_list_struct.h line 37
struct blnode * BufList_get_first(struct buflist *bl);
// BufList_insert_back
// file buf_list_struct.h line 36
void BufList_insert_back(struct buflist *bl, struct blnode *bln);
// BufList_new
// file buf_list_struct.c line 36
struct buflist * BufList_new();
// ConnectClient_create_users
// file connect_client_struct.h line 113
signed int ConnectClient_create_users(struct anonymous_3 *cc);
// ConnectClient_decrease_connected
// file connect_client_struct.h line 116
void ConnectClient_decrease_connected(struct anonymous_3 *cc);
// ConnectClient_free
// file connect_client_struct.c line 73
void ConnectClient_free(struct anonymous_3 **cc);
// ConnectClient_get_auditList
// file connect_client_struct.h line 109
struct auditlist * ConnectClient_get_auditList(struct anonymous_3 *cc);
// ConnectClient_get_clientId
// file connect_client_struct.h line 101
signed int ConnectClient_get_clientId(struct anonymous_3 *cc);
// ConnectClient_get_connectTime
// file connect_client_struct.h line 102
signed long int ConnectClient_get_connectTime(struct anonymous_3 *cc);
// ConnectClient_get_connected
// file connect_client_struct.h line 97
signed int ConnectClient_get_connected(struct anonymous_3 *cc);
// ConnectClient_get_header
// file connect_client_struct.h line 110
struct anonymous_8 * ConnectClient_get_header(struct anonymous_3 *cc);
// ConnectClient_get_lastActivity
// file connect_client_struct.h line 103
signed long int ConnectClient_get_lastActivity(struct anonymous_3 *cc);
// ConnectClient_get_limit
// file connect_client_struct.h line 98
signed int ConnectClient_get_limit(struct anonymous_3 *cc);
// ConnectClient_get_listenFd
// file connect_client_struct.h line 99
signed int ConnectClient_get_listenFd(struct anonymous_3 *cc);
// ConnectClient_get_listenFdp
// file connect_client_struct.h line 117
signed int * ConnectClient_get_listenFdp(struct anonymous_3 *cc);
// ConnectClient_get_multi
// file connect_client_struct.h line 108
char ConnectClient_get_multi(struct anonymous_3 *cc);
// ConnectClient_get_nameBuf
// file connect_client_struct.h line 105
char * ConnectClient_get_nameBuf(struct anonymous_3 *cc);
// ConnectClient_get_portBuf
// file connect_client_struct.h line 106
char * ConnectClient_get_portBuf(struct anonymous_3 *cc);
// ConnectClient_get_sClientId
// file connect_client_struct.h line 104
char * ConnectClient_get_sClientId(struct anonymous_3 *cc);
// ConnectClient_get_sslFd
// file connect_client_struct.h line 94
struct anonymous_1 * ConnectClient_get_sslFd(struct anonymous_3 *cc);
// ConnectClient_get_state
// file connect_client_struct.h line 93
char ConnectClient_get_state(struct anonymous_3 *cc);
// ConnectClient_get_task
// file connect_client_struct.h line 111
struct anonymous_13 * ConnectClient_get_task(struct anonymous_3 *cc);
// ConnectClient_get_timer
// file connect_client_struct.c line 484
struct timeval ConnectClient_get_timer(struct anonymous_3 *cc);
// ConnectClient_get_timerp
// file connect_client_struct.h line 114
struct timeval * ConnectClient_get_timerp(struct anonymous_3 *cc);
// ConnectClient_get_tunnelType
// file connect_client_struct.h line 107
char ConnectClient_get_tunnelType(struct anonymous_3 *cc);
// ConnectClient_get_users
// file connect_client_struct.h line 96
signed int * ConnectClient_get_users(struct anonymous_3 *cc);
// ConnectClient_get_usrCliPair
// file connect_client_struct.h line 100
signed int ConnectClient_get_usrCliPair(struct anonymous_3 *cc);
// ConnectClient_increase_connected
// file connect_client_struct.h line 115
void ConnectClient_increase_connected(struct anonymous_3 *cc);
// ConnectClient_new
// file connect_client_struct.h line 69
struct anonymous_3 * ConnectClient_new();
// ConnectClient_set_auditList
// file connect_client_struct.c line 390
void ConnectClient_set_auditList(struct anonymous_3 *cc, struct auditlist *al);
// ConnectClient_set_clientId
// file connect_client_struct.h line 81
void ConnectClient_set_clientId(struct anonymous_3 *cc, signed int clientId);
// ConnectClient_set_connectTime
// file connect_client_struct.h line 82
void ConnectClient_set_connectTime(struct anonymous_3 *cc, signed long int connectTime);
// ConnectClient_set_connected
// file connect_client_struct.h line 77
void ConnectClient_set_connected(struct anonymous_3 *cc, signed int connected);
// ConnectClient_set_header
// file connect_client_struct.c line 410
void ConnectClient_set_header(struct anonymous_3 *cc, struct anonymous_8 *hb);
// ConnectClient_set_lastActivity
// file connect_client_struct.h line 83
void ConnectClient_set_lastActivity(struct anonymous_3 *cc, signed long int lastActivity);
// ConnectClient_set_limit
// file connect_client_struct.h line 78
void ConnectClient_set_limit(struct anonymous_3 *cc, signed int limit);
// ConnectClient_set_listenFd
// file connect_client_struct.c line 217
void ConnectClient_set_listenFd(struct anonymous_3 *cc, signed int listenFd);
// ConnectClient_set_multi
// file connect_client_struct.h line 88
void ConnectClient_set_multi(struct anonymous_3 *cc, char multi);
// ConnectClient_set_nameBuf
// file connect_client_struct.h line 85
void ConnectClient_set_nameBuf(struct anonymous_3 *cc, char *nameBuf);
// ConnectClient_set_portBuf
// file connect_client_struct.h line 86
void ConnectClient_set_portBuf(struct anonymous_3 *cc, char *portBuf);
// ConnectClient_set_sClientId
// file connect_client_struct.h line 84
void ConnectClient_set_sClientId(struct anonymous_3 *cc, char *sClientId);
// ConnectClient_set_sslFd
// file connect_client_struct.c line 126
void ConnectClient_set_sslFd(struct anonymous_3 *cc, struct anonymous_1 *sf);
// ConnectClient_set_state
// file connect_client_struct.h line 73
void ConnectClient_set_state(struct anonymous_3 *cc, char state);
// ConnectClient_set_task
// file connect_client_struct.h line 91
void ConnectClient_set_task(struct anonymous_3 *cc, struct anonymous_13 *task);
// ConnectClient_set_timer
// file connect_client_struct.h line 75
void ConnectClient_set_timer(struct anonymous_3 *cc, struct timeval timer);
// ConnectClient_set_tunnelType
// file connect_client_struct.h line 87
void ConnectClient_set_tunnelType(struct anonymous_3 *cc, char tunnelType);
// ConnectClient_set_users
// file connect_client_struct.c line 163
void ConnectClient_set_users(struct anonymous_3 *cc, signed int *users);
// ConnectClient_set_usrCliPair
// file connect_client_struct.h line 80
void ConnectClient_set_usrCliPair(struct anonymous_3 *cc, signed int usrCliPair);
// ConnectUser_free
// file connect_user_struct.c line 66
void ConnectUser_free(struct anonymous_4 **cu);
// ConnectUser_get_bufList
// file connect_user_struct.h line 64
struct buflist * ConnectUser_get_bufList(struct anonymous_4 *cu);
// ConnectUser_get_connFd
// file connect_user_struct.h line 58
signed int ConnectUser_get_connFd(struct anonymous_4 *cu);
// ConnectUser_get_connectTime
// file connect_user_struct.h line 61
signed long int ConnectUser_get_connectTime(struct anonymous_4 *cu);
// ConnectUser_get_nameBuf
// file connect_user_struct.h line 62
char * ConnectUser_get_nameBuf(struct anonymous_4 *cu);
// ConnectUser_get_portBuf
// file connect_user_struct.h line 63
char * ConnectUser_get_portBuf(struct anonymous_4 *cu);
// ConnectUser_get_state
// file connect_user_struct.h line 57
char ConnectUser_get_state(struct anonymous_4 *cu);
// ConnectUser_get_stats
// file connect_user_struct.h line 65
struct anonymous_6 * ConnectUser_get_stats(struct anonymous_4 *cu);
// ConnectUser_get_userId
// file connect_user_struct.h line 60
signed int ConnectUser_get_userId(struct anonymous_4 *cu);
// ConnectUser_get_whatClient
// file connect_user_struct.h line 59
signed int ConnectUser_get_whatClient(struct anonymous_4 *cu);
// ConnectUser_new
// file connect_user_struct.h line 43
struct anonymous_4 * ConnectUser_new();
// ConnectUser_set_bufList
// file connect_user_struct.c line 215
void ConnectUser_set_bufList(struct anonymous_4 *cu, struct buflist *bufList);
// ConnectUser_set_connFd
// file connect_user_struct.h line 48
void ConnectUser_set_connFd(struct anonymous_4 *cu, signed int connFd);
// ConnectUser_set_connectTime
// file connect_user_struct.h line 51
void ConnectUser_set_connectTime(struct anonymous_4 *cu, signed long int connectTime);
// ConnectUser_set_nameBuf
// file connect_user_struct.c line 179
void ConnectUser_set_nameBuf(struct anonymous_4 *cu, char *nameBuf);
// ConnectUser_set_portBuf
// file connect_user_struct.c line 197
void ConnectUser_set_portBuf(struct anonymous_4 *cu, char *portBuf);
// ConnectUser_set_state
// file connect_user_struct.h line 47
void ConnectUser_set_state(struct anonymous_4 *cu, char state);
// ConnectUser_set_stats
// file connect_user_struct.c line 235
void ConnectUser_set_stats(struct anonymous_4 *cu, struct anonymous_6 *stats);
// ConnectUser_set_userId
// file connect_user_struct.h line 50
void ConnectUser_set_userId(struct anonymous_4 *cu, signed int userId);
// ConnectUser_set_whatClient
// file connect_user_struct.h line 49
void ConnectUser_set_whatClient(struct anonymous_4 *cu, signed int whatClient);
// ERR_error_string
// file /usr/include/openssl/err.h line 334
char * ERR_error_string(unsigned long int, char *);
// ERR_get_error
// file /usr/include/openssl/err.h line 321
unsigned long int ERR_get_error(void);
// EVP_PKEY_free
// file /usr/include/openssl/evp.h line 981
void EVP_PKEY_free(struct evp_pkey_st *);
// EVP_PKEY_new
// file /usr/include/openssl/evp.h line 980
struct evp_pkey_st * EVP_PKEY_new(void);
// EVP_PKEY_set1_RSA
// file /usr/include/openssl/evp.h line 961
signed int EVP_PKEY_set1_RSA(struct evp_pkey_st *, struct rsa_st *);
// EVP_sha1
// file /usr/include/openssl/evp.h line 720
const struct env_md_st * EVP_sha1(void);
// HeaderBuffer_free
// file header_buffer_struct.h line 32
void HeaderBuffer_free(struct anonymous_8 **hb);
// HeaderBuffer_new
// file header_buffer_struct.h line 30
struct anonymous_8 * HeaderBuffer_new();
// HeaderBuffer_restore
// file header_buffer_struct.h line 36
void HeaderBuffer_restore(struct anonymous_8 *hb, unsigned char *buff);
// HeaderBuffer_store
// file header_buffer_struct.h line 35
void HeaderBuffer_store(struct anonymous_8 *hb, unsigned char *buff, signed int n);
// HeaderBuffer_to_read
// file header_buffer_struct.h line 34
signed int HeaderBuffer_to_read(struct anonymous_8 *hb);
// OBJ_txt2nid
// file /usr/include/openssl/objects.h line 1014
signed int OBJ_txt2nid(const char *);
// PEM_read_RSAPrivateKey
// file /usr/include/openssl/pem.h line 462
struct rsa_st * PEM_read_RSAPrivateKey(struct _IO_FILE *, struct rsa_st **, signed int (*)(char *, signed int, signed int, void *), void *);
// PEM_write_RSAPrivateKey
// file /usr/include/openssl/pem.h line 462
signed int PEM_write_RSAPrivateKey(struct _IO_FILE *, struct rsa_st *, const struct evp_cipher_st *, unsigned char *, signed int, signed int (*)(char *, signed int, signed int, void *), void *);
// PEM_write_X509
// file /usr/include/openssl/pem.h line 451
signed int PEM_write_X509(struct _IO_FILE *, struct x509_st *);
// RCTdata_free
// file remove_client_task.h line 43
void RCTdata_free(void **ptr);
// RCTdata_new
// file remove_client_task.h line 40
struct anonymous_25 * RCTdata_new(struct anonymous_2 *config, signed int realm, signed int client, char ra, char reason, struct anonymous_22 *set, struct anonymous_22 *wset);
// RCTfunction
// file remove_client_task.h line 45
void RCTfunction(void *data);
// RSA_check_key
// file /usr/include/openssl/rsa.h line 333
signed int RSA_check_key(const struct rsa_st *);
// RSA_generate_key
// file /usr/include/openssl/rsa.h line 326
struct rsa_st * RSA_generate_key(signed int, unsigned long int, void (*)(signed int, signed int, void *), void *);
// SSL_CTX_load_verify_locations
// file /usr/include/openssl/ssl.h line 2442
signed int SSL_CTX_load_verify_locations(struct ssl_ctx_st *, const char *, const char *);
// SSL_CTX_new
// file /usr/include/openssl/ssl.h line 2131
struct ssl_ctx_st * SSL_CTX_new(const struct ssl_method_st *);
// SSL_CTX_set_cipher_list
// file /usr/include/openssl/ssl.h line 2130
signed int SSL_CTX_set_cipher_list(struct ssl_ctx_st *, const char *);
// SSL_CTX_set_verify
// file /usr/include/openssl/ssl.h line 2262
void SSL_CTX_set_verify(struct ssl_ctx_st *, signed int, signed int (*)(signed int, struct x509_store_ctx_st *));
// SSL_CTX_set_verify_depth
// file /usr/include/openssl/ssl.h line 2264
void SSL_CTX_set_verify_depth(struct ssl_ctx_st *, signed int);
// SSL_CTX_use_RSAPrivateKey_file
// file /usr/include/openssl/ssl.h line 2198
signed int SSL_CTX_use_RSAPrivateKey_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_CTX_use_certificate_file
// file /usr/include/openssl/ssl.h line 2200
signed int SSL_CTX_use_certificate_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_accept
// file /usr/include/openssl/ssl.h line 2332
signed int SSL_accept(struct ssl_st *);
// SSL_clear
// file /usr/include/openssl/ssl.h line 2138
signed int SSL_clear(struct ssl_st *);
// SSL_free
// file /usr/include/openssl/ssl.h line 2331
void SSL_free(struct ssl_st *);
// SSL_get_error
// file /usr/include/openssl/ssl.h line 2342
signed int SSL_get_error(const struct ssl_st *, signed int);
// SSL_library_init
// file /usr/include/openssl/ssl.h line 2419
signed int SSL_library_init(void);
// SSL_load_error_strings
// file /usr/include/openssl/ssl.h line 2216
void SSL_load_error_strings(void);
// SSL_new
// file /usr/include/openssl/ssl.h line 2291
struct ssl_st * SSL_new(struct ssl_ctx_st *);
// SSL_read
// file /usr/include/openssl/ssl.h line 2334
signed int SSL_read(struct ssl_st *, void *, signed int);
// SSL_readn
// file network.c line 483
signed int SSL_readn(struct ssl_st *fd, unsigned char *buf, signed int amount);
// SSL_set_fd
// file /usr/include/openssl/ssl.h line 2156
signed int SSL_set_fd(struct ssl_st *, signed int);
// SSL_write
// file /usr/include/openssl/ssl.h line 2336
signed int SSL_write(struct ssl_st *, const void *, signed int);
// SSL_writen
// file network.c line 454
signed int SSL_writen(struct ssl_st *fd, unsigned char *buf, signed int amount);
// SSLv3_server_method
// file /usr/include/openssl/ssl.h line 2356
const struct ssl_method_st * SSLv3_server_method(void);
// ServerConfiguration_free
// file server_configuration_struct.c line 54
void ServerConfiguration_free(struct anonymous_2 **sc);
// ServerConfiguration_get_cacertificateFile
// file server_configuration_struct.h line 57
char * ServerConfiguration_get_cacertificateFile(struct anonymous_2 *sc);
// ServerConfiguration_get_cacertificatePath
// file server_configuration_struct.c line 309
char * ServerConfiguration_get_cacertificatePath(struct anonymous_2 *sc);
// ServerConfiguration_get_certificateDepth
// file server_configuration_struct.c line 329
signed int ServerConfiguration_get_certificateDepth(struct anonymous_2 *sc);
// ServerConfiguration_get_certificateFile
// file server_configuration_struct.h line 56
char * ServerConfiguration_get_certificateFile(struct anonymous_2 *sc);
// ServerConfiguration_get_dateFormat
// file server_configuration_struct.h line 62
char * ServerConfiguration_get_dateFormat(struct anonymous_2 *sc);
// ServerConfiguration_get_keysFile
// file server_configuration_struct.h line 61
char * ServerConfiguration_get_keysFile(struct anonymous_2 *sc);
// ServerConfiguration_get_realmsNumber
// file server_configuration_struct.h line 63
signed int ServerConfiguration_get_realmsNumber(struct anonymous_2 *sc);
// ServerConfiguration_get_realmsTable
// file server_configuration_struct.h line 65
struct anonymous_5 ** ServerConfiguration_get_realmsTable(struct anonymous_2 *sc);
// ServerConfiguration_get_sCertificateDepth
// file server_configuration_struct.h line 59
char * ServerConfiguration_get_sCertificateDepth(struct anonymous_2 *sc);
// ServerConfiguration_get_startTime
// file server_configuration_struct.h line 64
signed long int ServerConfiguration_get_startTime(struct anonymous_2 *sc);
// ServerConfiguration_new
// file server_configuration_struct.h line 41
struct anonymous_2 * ServerConfiguration_new();
// ServerConfiguration_set_cacertificateFile
// file server_configuration_struct.h line 46
void ServerConfiguration_set_cacertificateFile(struct anonymous_2 *sc, char *cacertificateFile);
// ServerConfiguration_set_cacertificatePath
// file server_configuration_struct.c line 144
void ServerConfiguration_set_cacertificatePath(struct anonymous_2 *sc, char *cacertificatePath);
// ServerConfiguration_set_certificateDepth
// file server_configuration_struct.c line 163
void ServerConfiguration_set_certificateDepth(struct anonymous_2 *sc, signed int certificateDepth);
// ServerConfiguration_set_certificateFile
// file server_configuration_struct.h line 45
void ServerConfiguration_set_certificateFile(struct anonymous_2 *sc, char *certificateFile);
// ServerConfiguration_set_dateFormat
// file server_configuration_struct.h line 51
void ServerConfiguration_set_dateFormat(struct anonymous_2 *sc, char *dateFormat);
// ServerConfiguration_set_keysFile
// file server_configuration_struct.h line 50
void ServerConfiguration_set_keysFile(struct anonymous_2 *sc, char *keysFile);
// ServerConfiguration_set_realmsNumber
// file server_configuration_struct.h line 52
void ServerConfiguration_set_realmsNumber(struct anonymous_2 *sc, signed int realmsNumber);
// ServerConfiguration_set_realmsTable
// file server_configuration_struct.h line 54
void ServerConfiguration_set_realmsTable(struct anonymous_2 *sc, struct anonymous_5 **realmsTable);
// ServerConfiguration_set_sCertificateDepth
// file server_configuration_struct.h line 48
void ServerConfiguration_set_sCertificateDepth(struct anonymous_2 *sc, char *sCertificateDepth);
// ServerConfiguration_set_startTime
// file server_configuration_struct.h line 53
void ServerConfiguration_set_startTime(struct anonymous_2 *sc, signed long int startTime);
// ServerRealm_decrease_connectedClients
// file server_realm_struct.h line 141
void ServerRealm_decrease_connectedClients(struct anonymous_5 *sr);
// ServerRealm_decrease_connectedRaClients
// file server_realm_struct.h line 143
void ServerRealm_decrease_connectedRaClients(struct anonymous_5 *sr);
// ServerRealm_decrease_connectedUsers
// file server_realm_struct.h line 139
void ServerRealm_decrease_connectedUsers(struct anonymous_5 *sr);
// ServerRealm_free
// file server_realm_struct.c line 58
void ServerRealm_free(struct anonymous_5 **sr);
// ServerRealm_get_addressLength
// file server_realm_struct.h line 131
unsigned int ServerRealm_get_addressLength(struct anonymous_5 *sr);
// ServerRealm_get_auditOn
// file server_realm_struct.h line 130
char ServerRealm_get_auditOn(struct anonymous_5 *sr);
// ServerRealm_get_basePortOn
// file server_realm_struct.h line 129
char ServerRealm_get_basePortOn(struct anonymous_5 *sr);
// ServerRealm_get_clientAddress
// file server_realm_struct.h line 132
struct sockaddr * ServerRealm_get_clientAddress(struct anonymous_5 *sr);
// ServerRealm_get_clientMode
// file server_realm_struct.h line 122
signed int ServerRealm_get_clientMode(struct anonymous_5 *sr);
// ServerRealm_get_clientsCounter
// file server_realm_struct.h line 124
signed int ServerRealm_get_clientsCounter(struct anonymous_5 *sr);
// ServerRealm_get_clientsLimit
// file server_realm_struct.h line 116
signed int ServerRealm_get_clientsLimit(struct anonymous_5 *sr);
// ServerRealm_get_clientsTable
// file server_realm_struct.h line 134
struct anonymous_3 ** ServerRealm_get_clientsTable(struct anonymous_5 *sr);
// ServerRealm_get_connectedClients
// file server_realm_struct.h line 115
signed int ServerRealm_get_connectedClients(struct anonymous_5 *sr);
// ServerRealm_get_connectedRaClients
// file server_realm_struct.h line 117
signed int ServerRealm_get_connectedRaClients(struct anonymous_5 *sr);
// ServerRealm_get_connectedUsers
// file server_realm_struct.h line 113
signed int ServerRealm_get_connectedUsers(struct anonymous_5 *sr);
// ServerRealm_get_dnsLookupsOn
// file server_realm_struct.h line 128
char ServerRealm_get_dnsLookupsOn(struct anonymous_5 *sr);
// ServerRealm_get_hostName
// file server_realm_struct.h line 103
char * ServerRealm_get_hostName(struct anonymous_5 *sr);
// ServerRealm_get_maxIdle
// file server_realm_struct.h line 121
signed int ServerRealm_get_maxIdle(struct anonymous_5 *sr);
// ServerRealm_get_password
// file server_realm_struct.h line 112
unsigned char * ServerRealm_get_password(struct anonymous_5 *sr);
// ServerRealm_get_raClientsLimit
// file server_realm_struct.h line 118
signed int ServerRealm_get_raClientsLimit(struct anonymous_5 *sr);
// ServerRealm_get_raClientsTable
// file server_realm_struct.h line 135
struct anonymous_3 ** ServerRealm_get_raClientsTable(struct anonymous_5 *sr);
// ServerRealm_get_realmName
// file server_realm_struct.h line 111
char * ServerRealm_get_realmName(struct anonymous_5 *sr);
// ServerRealm_get_realmType
// file server_realm_struct.h line 126
char ServerRealm_get_realmType(struct anonymous_5 *sr);
// ServerRealm_get_sClientMode
// file server_realm_struct.h line 108
char * ServerRealm_get_sClientMode(struct anonymous_5 *sr);
// ServerRealm_get_sClientsLimit
// file server_realm_struct.h line 105
char * ServerRealm_get_sClientsLimit(struct anonymous_5 *sr);
// ServerRealm_get_sMaxIdle
// file server_realm_struct.h line 110
char * ServerRealm_get_sMaxIdle(struct anonymous_5 *sr);
// ServerRealm_get_sRaClientsLimit
// file server_realm_struct.h line 106
char * ServerRealm_get_sRaClientsLimit(struct anonymous_5 *sr);
// ServerRealm_get_sTimeout
// file server_realm_struct.h line 109
char * ServerRealm_get_sTimeout(struct anonymous_5 *sr);
// ServerRealm_get_sUsersLimit
// file server_realm_struct.h line 104
char * ServerRealm_get_sUsersLimit(struct anonymous_5 *sr);
// ServerRealm_get_sUsersPerClient
// file server_realm_struct.h line 107
char * ServerRealm_get_sUsersPerClient(struct anonymous_5 *sr);
// ServerRealm_get_timeout
// file server_realm_struct.h line 120
signed int ServerRealm_get_timeout(struct anonymous_5 *sr);
// ServerRealm_get_tunnelType
// file server_realm_struct.h line 127
char ServerRealm_get_tunnelType(struct anonymous_5 *sr);
// ServerRealm_get_userClientPairs
// file server_realm_struct.h line 123
signed int ServerRealm_get_userClientPairs(struct anonymous_5 *sr);
// ServerRealm_get_usersClientsTable
// file server_realm_struct.h line 136
struct anonymous_7 ** ServerRealm_get_usersClientsTable(struct anonymous_5 *sr);
// ServerRealm_get_usersCounter
// file server_realm_struct.h line 125
signed int ServerRealm_get_usersCounter(struct anonymous_5 *sr);
// ServerRealm_get_usersLimit
// file server_realm_struct.h line 114
signed int ServerRealm_get_usersLimit(struct anonymous_5 *sr);
// ServerRealm_get_usersPerClient
// file server_realm_struct.h line 119
signed int ServerRealm_get_usersPerClient(struct anonymous_5 *sr);
// ServerRealm_get_usersTable
// file server_realm_struct.h line 133
struct anonymous_4 ** ServerRealm_get_usersTable(struct anonymous_5 *sr);
// ServerRealm_increase_clientsCounter
// file server_realm_struct.h line 145
void ServerRealm_increase_clientsCounter(struct anonymous_5 *sr);
// ServerRealm_increase_connectedClients
// file server_realm_struct.h line 140
void ServerRealm_increase_connectedClients(struct anonymous_5 *sr);
// ServerRealm_increase_connectedRaClients
// file server_realm_struct.h line 142
void ServerRealm_increase_connectedRaClients(struct anonymous_5 *sr);
// ServerRealm_increase_connectedUsers
// file server_realm_struct.h line 138
void ServerRealm_increase_connectedUsers(struct anonymous_5 *sr);
// ServerRealm_increase_usersCounter
// file server_realm_struct.h line 144
void ServerRealm_increase_usersCounter(struct anonymous_5 *sr);
// ServerRealm_new
// file server_realm_struct.h line 64
struct anonymous_5 * ServerRealm_new();
// ServerRealm_set_addressLength
// file server_realm_struct.h line 96
void ServerRealm_set_addressLength(struct anonymous_5 *sr, unsigned int addressLength);
// ServerRealm_set_auditOn
// file server_realm_struct.h line 95
void ServerRealm_set_auditOn(struct anonymous_5 *sr, char auditOn);
// ServerRealm_set_basePortOn
// file server_realm_struct.h line 94
void ServerRealm_set_basePortOn(struct anonymous_5 *sr, char basePortOn);
// ServerRealm_set_clientAddress
// file server_realm_struct.h line 97
void ServerRealm_set_clientAddress(struct anonymous_5 *sr, struct sockaddr *clientAddress);
// ServerRealm_set_clientMode
// file server_realm_struct.h line 87
void ServerRealm_set_clientMode(struct anonymous_5 *sr, signed int clientMode);
// ServerRealm_set_clientsCounter
// file server_realm_struct.c line 510
void ServerRealm_set_clientsCounter(struct anonymous_5 *sr, signed int clientsCounter);
// ServerRealm_set_clientsLimit
// file server_realm_struct.h line 81
void ServerRealm_set_clientsLimit(struct anonymous_5 *sr, signed int clientsLimit);
// ServerRealm_set_clientsTable
// file server_realm_struct.h line 99
void ServerRealm_set_clientsTable(struct anonymous_5 *sr, struct anonymous_3 **clientsTable);
// ServerRealm_set_connectedClients
// file server_realm_struct.h line 80
void ServerRealm_set_connectedClients(struct anonymous_5 *sr, signed int connectedClients);
// ServerRealm_set_connectedRaClients
// file server_realm_struct.h line 82
void ServerRealm_set_connectedRaClients(struct anonymous_5 *sr, signed int connectedRaClients);
// ServerRealm_set_connectedUsers
// file server_realm_struct.h line 78
void ServerRealm_set_connectedUsers(struct anonymous_5 *sr, signed int connectedUsers);
// ServerRealm_set_dnsLookupsOn
// file server_realm_struct.h line 93
void ServerRealm_set_dnsLookupsOn(struct anonymous_5 *sr, char dnsLookupsOn);
// ServerRealm_set_hostName
// file server_realm_struct.h line 68
void ServerRealm_set_hostName(struct anonymous_5 *sr, char *hostName);
// ServerRealm_set_maxIdle
// file server_realm_struct.h line 86
void ServerRealm_set_maxIdle(struct anonymous_5 *sr, signed int maxIdle);
// ServerRealm_set_password
// file server_realm_struct.h line 77
void ServerRealm_set_password(struct anonymous_5 *sr, unsigned char *password);
// ServerRealm_set_raClientsLimit
// file server_realm_struct.h line 83
void ServerRealm_set_raClientsLimit(struct anonymous_5 *sr, signed int raClientsLimit);
// ServerRealm_set_raClientsTable
// file server_realm_struct.h line 100
void ServerRealm_set_raClientsTable(struct anonymous_5 *sr, struct anonymous_3 **raClientsTable);
// ServerRealm_set_realmName
// file server_realm_struct.h line 76
void ServerRealm_set_realmName(struct anonymous_5 *sr, char *realmName);
// ServerRealm_set_realmType
// file server_realm_struct.h line 91
void ServerRealm_set_realmType(struct anonymous_5 *sr, char realmType);
// ServerRealm_set_sClientMode
// file server_realm_struct.h line 73
void ServerRealm_set_sClientMode(struct anonymous_5 *sr, char *sClientMode);
// ServerRealm_set_sClientsLimit
// file server_realm_struct.h line 70
void ServerRealm_set_sClientsLimit(struct anonymous_5 *sr, char *sClientsLimit);
// ServerRealm_set_sMaxIdle
// file server_realm_struct.h line 75
void ServerRealm_set_sMaxIdle(struct anonymous_5 *sr, char *sMaxIdle);
// ServerRealm_set_sRaClientsLimit
// file server_realm_struct.h line 71
void ServerRealm_set_sRaClientsLimit(struct anonymous_5 *sr, char *sRaClientsLimit);
// ServerRealm_set_sTimeout
// file server_realm_struct.h line 74
void ServerRealm_set_sTimeout(struct anonymous_5 *sr, char *sTimeout);
// ServerRealm_set_sUsersLimit
// file server_realm_struct.h line 69
void ServerRealm_set_sUsersLimit(struct anonymous_5 *sr, char *sUsersLimit);
// ServerRealm_set_sUsersPerClient
// file server_realm_struct.h line 72
void ServerRealm_set_sUsersPerClient(struct anonymous_5 *sr, char *sUsersPerClient);
// ServerRealm_set_timeout
// file server_realm_struct.h line 85
void ServerRealm_set_timeout(struct anonymous_5 *sr, signed int timeout);
// ServerRealm_set_tunnelType
// file server_realm_struct.h line 92
void ServerRealm_set_tunnelType(struct anonymous_5 *sr, char tunnelType);
// ServerRealm_set_userClientPairs
// file server_realm_struct.h line 88
void ServerRealm_set_userClientPairs(struct anonymous_5 *sr, signed int userClientPairs);
// ServerRealm_set_usersClientsTable
// file server_realm_struct.h line 101
void ServerRealm_set_usersClientsTable(struct anonymous_5 *sr, struct anonymous_7 **usersClientsTable);
// ServerRealm_set_usersCounter
// file server_realm_struct.c line 527
void ServerRealm_set_usersCounter(struct anonymous_5 *sr, signed int usersCounter);
// ServerRealm_set_usersLimit
// file server_realm_struct.h line 79
void ServerRealm_set_usersLimit(struct anonymous_5 *sr, signed int usersLimit);
// ServerRealm_set_usersPerClient
// file server_realm_struct.h line 84
void ServerRealm_set_usersPerClient(struct anonymous_5 *sr, signed int usersPerClient);
// ServerRealm_set_usersTable
// file server_realm_struct.h line 98
void ServerRealm_set_usersTable(struct anonymous_5 *sr, struct anonymous_4 **usersTable);
// SslFd_free
// file ssl_fd_struct.c line 54
void SslFd_free(struct anonymous_1 **sf);
// SslFd_get_fd
// file ssl_fd_struct.h line 41
signed int SslFd_get_fd(struct anonymous_1 *sf);
// SslFd_get_message
// file ssl_fd_struct.h line 45
signed int SslFd_get_message(char type, struct anonymous_1 *sf, unsigned char *buf, signed int amount);
// SslFd_get_ssl
// file ssl_fd_struct.h line 42
struct ssl_st * SslFd_get_ssl(struct anonymous_1 *sf);
// SslFd_new
// file ssl_fd_struct.h line 33
struct anonymous_1 * SslFd_new();
// SslFd_send_message
// file ssl_fd_struct.h line 44
signed int SslFd_send_message(char type, struct anonymous_1 *sf, unsigned char *buf, signed int amount);
// SslFd_set_fd
// file ssl_fd_struct.h line 37
void SslFd_set_fd(struct anonymous_1 *sf, signed int fd);
// SslFd_set_ssl
// file ssl_fd_struct.h line 38
void SslFd_set_ssl(struct anonymous_1 *sf, struct ssl_st *ssl);
// SslFd_set_ssl_general
// file ssl_fd_struct.c line 98
void SslFd_set_ssl_general(struct anonymous_1 *sf, struct ssl_st *ssl, signed int free);
// SslFd_set_ssl_nf
// file ssl_fd_struct.h line 39
void SslFd_set_ssl_nf(struct anonymous_1 *sf, struct ssl_st *ssl);
// SslFd_swap_content
// file ssl_fd_struct.h line 46
void SslFd_swap_content(struct anonymous_1 *sf1, struct anonymous_1 *sf2);
// TaskListNode_free
// file task_list_node_struct.c line 60
void TaskListNode_free(struct tlnode **node);
// TaskListNode_get_task
// file task_list_node_struct.c line 117
struct anonymous_13 * TaskListNode_get_task(struct tlnode *node);
// TaskListNode_new
// file task_list_node_struct.c line 37
struct tlnode * TaskListNode_new(struct anonymous_13 *task);
// TaskListNode_set_next
// file task_list_node_struct.c line 83
void TaskListNode_set_next(struct tlnode *node, struct tlnode *next);
// TaskListNode_set_previous
// file task_list_node_struct.c line 100
void TaskListNode_set_previous(struct tlnode *node, struct tlnode *previous);
// TaskScheduler_addTask
// file task_scheduler_struct.h line 41
signed int TaskScheduler_addTask(struct anonymous_16 *scheduler, struct anonymous_13 *task);
// TaskScheduler_free
// file task_scheduler_struct.c line 54
void TaskScheduler_free(struct anonymous_16 **scheduler);
// TaskScheduler_get_actualTimer
// file task_scheduler_struct.h line 38
struct timeval * TaskScheduler_get_actualTimer(struct anonymous_16 *scheduler);
// TaskScheduler_hasMoreTasks
// file task_scheduler_struct.h line 40
signed int TaskScheduler_hasMoreTasks(struct anonymous_16 *scheduler);
// TaskScheduler_new
// file task_scheduler_struct.h line 34
struct anonymous_16 * TaskScheduler_new();
// TaskScheduler_removeTask
// file task_scheduler_struct.h line 42
signed int TaskScheduler_removeTask(struct anonymous_16 *scheduler, struct anonymous_13 *task);
// TaskScheduler_startWatching
// file task_scheduler_struct.h line 43
signed int TaskScheduler_startWatching(struct anonymous_16 *scheduler);
// TaskScheduler_stopWatching
// file task_scheduler_struct.h line 44
signed int TaskScheduler_stopWatching(struct anonymous_16 *scheduler);
// TaskScheduler_update
// file task_scheduler_struct.h line 45
signed int TaskScheduler_update(struct anonymous_16 *scheduler);
// Task_exec
// file task_struct.c line 113
void Task_exec(struct anonymous_13 *task);
// Task_free
// file task_struct.h line 34
void Task_free(struct anonymous_13 **task);
// Task_get_timer
// file task_struct.c line 97
struct timeval * Task_get_timer(struct anonymous_13 *task);
// Task_new
// file task_struct.h line 32
struct anonymous_13 * Task_new(struct timeval *timerp, void (*function)(void *), void *data, void (*clean)(void **));
// Task_new::clean_object
//
void clean_object(void **);
// Task_new::function_object
//
void function_object(void *);
// UserStats_add_download
// file user_stats_struct.h line 52
void UserStats_add_download(struct anonymous_6 *us, signed int bytes);
// UserStats_add_upload
// file user_stats_struct.h line 53
void UserStats_add_upload(struct anonymous_6 *us, signed int bytes);
// UserStats_clear
// file user_stats_struct.h line 57
void UserStats_clear(struct anonymous_6 *us);
// UserStats_free
// file user_stats_struct.c line 53
void UserStats_free(struct anonymous_6 **us);
// UserStats_get_downloadSpeed
// file user_stats_struct.h line 54
double UserStats_get_downloadSpeed(struct anonymous_6 *us);
// UserStats_get_lastActivity
// file user_stats_struct.h line 48
signed long int UserStats_get_lastActivity(struct anonymous_6 *us);
// UserStats_get_totalDownloadedBytes
// file user_stats_struct.h line 49
signed int UserStats_get_totalDownloadedBytes(struct anonymous_6 *us);
// UserStats_get_totalUploadedBytes
// file user_stats_struct.h line 50
signed int UserStats_get_totalUploadedBytes(struct anonymous_6 *us);
// UserStats_get_uploadSpeed
// file user_stats_struct.h line 55
double UserStats_get_uploadSpeed(struct anonymous_6 *us);
// UserStats_new
// file user_stats_struct.c line 36
struct anonymous_6 * UserStats_new();
// UserStats_set_lastActivity
// file user_stats_struct.h line 44
void UserStats_set_lastActivity(struct anonymous_6 *us, signed long int lastActivity);
// UserStats_set_totalDownloadedBytes
// file user_stats_struct.c line 92
void UserStats_set_totalDownloadedBytes(struct anonymous_6 *us, signed int totalDownloadedBytes);
// UserStats_set_totalUploadedBytes
// file user_stats_struct.c line 109
void UserStats_set_totalUploadedBytes(struct anonymous_6 *us, signed int totalUploadedBytes);
// UsrCli_free
// file usr_cli_struct.c line 54
void UsrCli_free(struct anonymous_7 **uc);
// UsrCli_get_listenFd
// file usr_cli_struct.h line 48
signed int UsrCli_get_listenFd(struct anonymous_7 *uc);
// UsrCli_get_listenHostName
// file usr_cli_struct.h line 50
char * UsrCli_get_listenHostName(struct anonymous_7 *uc);
// UsrCli_get_listenPortName
// file usr_cli_struct.h line 46
char * UsrCli_get_listenPortName(struct anonymous_7 *uc);
// UsrCli_get_manageFd
// file usr_cli_struct.h line 49
signed int UsrCli_get_manageFd(struct anonymous_7 *uc);
// UsrCli_get_manageHostName
// file usr_cli_struct.h line 51
char * UsrCli_get_manageHostName(struct anonymous_7 *uc);
// UsrCli_get_managePortName
// file usr_cli_struct.h line 47
char * UsrCli_get_managePortName(struct anonymous_7 *uc);
// UsrCli_get_number
// file usr_cli_struct.h line 52
signed int UsrCli_get_number(struct anonymous_7 *uc);
// UsrCli_new
// file usr_cli_struct.h line 36
struct anonymous_7 * UsrCli_new();
// UsrCli_set_listenFd
// file usr_cli_struct.h line 42
void UsrCli_set_listenFd(struct anonymous_7 *uc, signed int listenFd);
// UsrCli_set_listenPortName
// file usr_cli_struct.h line 40
void UsrCli_set_listenPortName(struct anonymous_7 *uc, char *listenPortName);
// UsrCli_set_manageFd
// file usr_cli_struct.h line 43
void UsrCli_set_manageFd(struct anonymous_7 *uc, signed int manageFd);
// UsrCli_set_managePortName
// file usr_cli_struct.h line 41
void UsrCli_set_managePortName(struct anonymous_7 *uc, char *managePortName);
// UsrCli_set_number
// file usr_cli_struct.h line 44
void UsrCli_set_number(struct anonymous_7 *uc, signed int number);
// X509_NAME_ENTRY_create_by_NID
// file /usr/include/openssl/x509.h line 1036
struct X509_name_entry_st * X509_NAME_ENTRY_create_by_NID(struct X509_name_entry_st **, signed int, signed int, unsigned char *, signed int);
// X509_NAME_add_entry
// file /usr/include/openssl/x509.h line 1024
signed int X509_NAME_add_entry(struct X509_name_st *, struct X509_name_entry_st *, signed int, signed int);
// X509_NAME_new
// file /usr/include/openssl/x509.h line 817
struct X509_name_st * X509_NAME_new(void);
// X509_REQ_free
// file /usr/include/openssl/x509.h line 807
void X509_REQ_free(struct X509_req_st *);
// X509_REQ_new
// file /usr/include/openssl/x509.h line 807
struct X509_req_st * X509_REQ_new(void);
// X509_REQ_set_pubkey
// file /usr/include/openssl/x509.h line 917
signed int X509_REQ_set_pubkey(struct X509_req_st *, struct evp_pkey_st *);
// X509_REQ_set_subject_name
// file /usr/include/openssl/x509.h line 916
signed int X509_REQ_set_subject_name(struct X509_req_st *, struct X509_name_st *);
// X509_REQ_sign
// file /usr/include/openssl/x509.h line 650
signed int X509_REQ_sign(struct X509_req_st *, struct evp_pkey_st *, const struct env_md_st *);
// X509_REQ_to_X509
// file /usr/include/openssl/x509.h line 779
struct x509_st * X509_REQ_to_X509(struct X509_req_st *, signed int, struct evp_pkey_st *);
// X509_free
// file /usr/include/openssl/x509.h line 823
void X509_free(struct x509_st *);
// X509_get_serialNumber
// file /usr/include/openssl/x509.h line 903
struct asn1_string_st * X509_get_serialNumber(struct x509_st *);
// X509_set_version
// file /usr/include/openssl/x509.h line 901
signed int X509_set_version(struct x509_st *, signed long int);
// X509_sign
// file /usr/include/openssl/x509.h line 647
signed int X509_sign(struct x509_st *, struct evp_pkey_st *, const struct env_md_st *);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __bswap_32_link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link1(unsigned int __bsx_link1);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 401
extern signed int __xstat(signed int, const char *, struct stat *);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// add_to_message
// file server_remoteadmin.c line 188
static void add_to_message(unsigned char *buff, const char *format, ...);
// add_uptime_to_message
// file server_remoteadmin.c line 221
static void add_uptime_to_message(unsigned char *buff, char *info, signed long int period);
// addlogtarget
// file logging.h line 69
void addlogtarget(char *cmdline);
// addtocg
// file stats.c line 61
void addtocg(signed int amount);
// aflog
// file logging.h line 73
void aflog(char type, char importance, const char *form, ...);
// afserver_connect
// file http_proxy_server.c line 54
signed int afserver_connect(signed int *sockfd, signed int afserverfd, struct sockaddr *cliaddr, unsigned int *addrlenp, char type);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// broadcast_condition
// file thread_management.h line 31
void broadcast_condition(void);
// bzero
// file /usr/include/strings.h line 50
extern void bzero(void *, unsigned long int);
// callback
// file first_run.c line 63
static void callback(signed int i, signed int j, void *k);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_long
// file server_check.h line 26
signed int check_long(char *text, signed long int *number);
// check_value
// file server_check.h line 24
signed int check_value(char *what, char *info);
// check_value_liberal
// file server_check.h line 25
signed int check_value_liberal(char *what, char *info);
// checklogtarget
// file logging.c line 175
signed int checklogtarget(struct llnode *target);
// checkmsgti
// file logging.c line 119
signed int checkmsgti(struct llnode *target, char *tab);
// clear_fd
// file http_proxy_functions.c line 261
void clear_fd(signed int *fd, struct anonymous_22 *set);
// clear_sslFd
// file http_proxy_functions.c line 362
void clear_sslFd(struct anonymous_1 *sf, struct anonymous_22 *set);
// client_long_usage
// file usage.c line 148
void client_long_usage(char *info);
// client_short_usage
// file usage.c line 132
void client_short_usage(char *info);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_fd
// file http_proxy_functions.c line 248
void close_fd(signed int *fd);
// compress
// file /usr/include/zlib.h line 1160
extern signed int compress(unsigned char *, unsigned long int *, const unsigned char *, unsigned long int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// create_apf_dir
// file first_run.h line 24
signed int create_apf_dir(char type);
// create_publickey_store
// file first_run.c line 147
signed int create_publickey_store(char **storefile);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// datum
// file logging.c line 85
char * datum(void);
// delete_user
// file http_proxy_functions.c line 77
void delete_user(struct anonymous_27 *cnts, signed int i, struct anonymous_22 *allset);
// end_critical_section
// file thread_management.h line 29
void end_critical_section(void);
// eval_UsrCliPair
// file server_eval.h line 29
signed int eval_UsrCliPair(struct anonymous_7 **table, signed int index, char *host, char *serv);
// eval_numofcon
// file server_eval.h line 27
signed int eval_numofcon(struct anonymous_5 *ptr, signed int client, signed int numofcon);
// eval_usernum
// file server_eval.h line 28
signed int eval_usernum(struct anonymous_3 *ptr, signed int usernum);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// find_client
// file server_find.h line 27
signed int find_client(struct anonymous_5 *ptr, char mode, signed int usrclipair);
// find_previousFd
// file server_find.h line 29
signed int find_previousFd(struct anonymous_7 **table, signed int index, char *host, char *serv);
// find_tasknode_with_minimal_timer
// file task_scheduler_struct.c line 158
static struct tlnode * find_tasknode_with_minimal_timer(struct anonymous_16 *scheduler);
// find_usernum
// file server_find.h line 28
signed int find_usernum(struct anonymous_3 *ptr, signed int usernum);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// generate_certificate
// file first_run.h line 27
signed int generate_certificate(char **cerfile, char *keyfile);
// generate_rsa_key
// file first_run.h line 26
signed int generate_rsa_key(char **keyfile);
// get_cer_filename
// file first_run.c line 400
char * get_cer_filename();
// get_clientid
// file clientnames.c line 48
signed int get_clientid(struct anonymous_5 *pointer, char *clientname);
// get_clientname
// file clientnames.h line 27
char * get_clientname(struct anonymous_5 *pointer, signed int client);
// get_clientnumber
// file clientnames.h line 29
signed int get_clientnumber(struct anonymous_5 *pointer, signed int clientid);
// get_key_filename
// file first_run.c line 388
char * get_key_filename();
// get_new_socket
// file server_get.h line 28
signed int get_new_socket(signed int sockfd, char type, struct sockaddr *addr, unsigned int *addrlen, char *tunneltype);
// get_raclientid
// file clientnames.c line 121
signed int get_raclientid(struct anonymous_5 *pointer, char *clientname);
// get_raclientname
// file clientnames.h line 31
char * get_raclientname(struct anonymous_5 *pointer, signed int client);
// get_raclientnumber
// file clientnames.c line 157
signed int get_raclientnumber(struct anonymous_5 *pointer, signed int clientid);
// get_realmname
// file realmnames.h line 27
char * get_realmname(struct anonymous_2 *config, signed int realm);
// get_realmnumber
// file realmnames.h line 28
signed int get_realmnumber(struct anonymous_2 *config, char *realmname);
// get_ssl_error
// file make_ssl_handshake.c line 75
signed int get_ssl_error(struct anonymous_1 *sf, char *info, signed int result);
// get_store_filename
// file first_run.c line 376
char * get_store_filename();
// get_username
// file usernames.h line 27
signed int get_username(struct anonymous_5 *pointer, signed int user);
// get_usernumber
// file usernames.h line 28
signed int get_usernumber(struct anonymous_5 *pointer, signed int userid);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getcg
// file stats.c line 73
signed long int getcg(void);
// getdateformat
// file logging.h line 65
char * getdateformat();
// getloglisthead
// file logging.h line 67
struct llnode * getloglisthead();
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// http_proxy_server
// file http_proxy_server.c line 83
void * http_proxy_server(void *vptr);
// http_read
// file http_proxy_functions.c line 402
signed int http_read(char https, struct anonymous_1 *sf, unsigned char *buf, signed int amount);
// http_write
// file http_proxy_functions.c line 381
signed int http_write(char https, struct anonymous_1 *sf, unsigned char *buf, signed int amount);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// initialize_http_proxy_server
// file http_proxy_server.h line 27
signed int initialize_http_proxy_server(signed int *sockfd, const char *host, const char *serv, unsigned int *addrlenp, const char type, signed int limit, char https, struct ssl_ctx_st *ctx);
// initializelogging
// file logging.h line 71
void initializelogging(char verl, char *dateformat);
// ip_connect
// file network.c line 186
signed int ip_connect(signed int *sockfd, const char *host, const char *serv, const char type, const char *lhost, const char *lserv);
// ip_listen
// file network.h line 39
signed int ip_listen(signed int *sockfd, const char *host, const char *serv, unsigned int *addrlenp, const char type);
// is_this_a_mainthread
// file thread_management.c line 50
signed int is_this_a_mainthread(void);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// localdate
// file logging.h line 75
char * localdate(signed long int *sec);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// loginit
// file logging.c line 334
signed int loginit(char verl, char *dateformat);
// make_ssl_accept
// file make_ssl_handshake.h line 28
signed int make_ssl_accept(struct anonymous_1 *sf);
// make_ssl_initialize
// file make_ssl_handshake.h line 27
void make_ssl_initialize(struct anonymous_1 *sf);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 321
extern signed int mkdir(const char *, unsigned int);
// myrand
// file http_proxy_functions.c line 42
signed int myrand(signed int down, signed int up);
// mysleep
// file http_proxy_functions.c line 60
void mysleep(double time);
// parse_cmd
// file server_remoteadmin.c line 89
static signed int parse_cmd(unsigned char *buff, signed int *ret);
// parse_header
// file http_proxy_functions.c line 105
signed int parse_header(struct anonymous_1 *sf, char *tab, struct anonymous_26 *hdr, char https);
// parse_int
// file server_remoteadmin.c line 38
static signed int parse_int(unsigned char *buff, signed int *ret);
// parse_line
// file file.c line 45
signed int parse_line(char *buff, char *tab1, char *tab2);
// parsefile
// file file.h line 37
struct anonymous_2 * parsefile(char *name, signed int *status);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 992
extern signed int pthread_cond_broadcast(union anonymous_31 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 1000
extern signed int pthread_cond_wait(union anonymous_31 *, union anonymous_29 *);
// pthread_create
// file /usr/include/pthread.h line 244
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_lock(union anonymous_29 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 784
extern signed int pthread_mutex_unlock(union anonymous_29 *);
// pthread_self
// file /usr/include/pthread.h line 286
extern unsigned long int pthread_self(void);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_message
// file http_proxy_functions.c line 281
signed int read_message(signed int fd, signed int length, struct anonymous_27 *client, char *tab, signed int ptr);
// readn
// file network.h line 47
signed int readn(signed int fd, unsigned char *buf, signed int amount);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// remember_mainthread
// file thread_management.h line 26
void remember_mainthread(void);
// remove_client
// file server_remove.h line 27
void remove_client(struct anonymous_5 *ptr, signed int client, struct anonymous_22 *set, struct anonymous_22 *wset, struct anonymous_16 *scheduler);
// remove_raclient
// file server_remove.h line 28
void remove_raclient(struct anonymous_5 *ptr, signed int client, struct anonymous_22 *set, struct anonymous_22 *wset, struct anonymous_16 *scheduler);
// resetcg
// file stats.c line 84
void resetcg(void);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// rindex
// file /usr/include/string.h line 517
extern char * rindex(const char *, signed int);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_22 *, struct anonymous_22 *, struct anonymous_22 *, struct timeval *);
// send_adm_message
// file server_remoteadmin.c line 158
static void send_adm_message(char type, struct anonymous_1 *master, unsigned char *buff, unsigned char st);
// serve_admin
// file server_remoteadmin.h line 35
signed int serve_admin(struct anonymous_2 *config, signed int realm, signed int client, unsigned char *buff);
// server_long_usage
// file usage.h line 25
void server_long_usage(char *info);
// server_short_usage
// file usage.h line 24
void server_short_usage(char *info);
// server_sig_int
// file server_signals.h line 24
void server_sig_int(signed int signo);
// set_fd
// file http_proxy_functions.c line 235
void set_fd(signed int fd, signed int *maxfdp1, struct anonymous_22 *allset);
// set_value
// file server_set.h line 24
void set_value(char **dest, char *from, char *def);
// setdateformat
// file logging.h line 63
void setdateformat(char *dateformat);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous_19 *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sock_ntop
// file network.h line 42
char * sock_ntop(struct sockaddr *sa, unsigned int salen, char *namebuf, char *portbuf, char type);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// start_critical_section
// file thread_management.h line 28
void start_critical_section(void);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 453
static inline signed int stat(const char *__path, struct stat *__statbuf);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// string_cp
// file string_functions.h line 24
char * string_cp(char **dest, char *src);
// strlen
// file /usr/include/string.h line 399
extern unsigned long int strlen(const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timeperiod
// file stats.h line 29
char * timeperiod(signed long int period);
// timeval_compare
// file timeval_functions.c line 56
signed int timeval_compare(struct timeval *first, struct timeval *second);
// timeval_create
// file timeval_functions.h line 26
struct timeval timeval_create(signed long int tv_sec, signed long int tv_usec);
// timeval_lq_zero
// file timeval_functions.c line 121
signed int timeval_lq_zero(struct timeval *timer);
// timeval_subtract
// file timeval_functions.c line 94
signed int timeval_subtract(struct timeval *first, struct timeval *second);
// uncompress
// file /usr/include/zlib.h line 1197
extern signed int uncompress(unsigned char *, unsigned long int *, const unsigned char *, unsigned long int);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsprintf
// file /usr/include/stdio.h line 379
extern signed int vsprintf(char *, const char *, void **);
// wait_for_condition
// file thread_management.h line 30
void wait_for_condition(void);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// writen
// file network.c line 513
signed int writen(signed int fd, unsigned char *buf, signed int amount);

struct anonymous_2
{
  // cacertificateFile
  char *cacertificateFile;
  // cacertificatePath
  char *cacertificatePath;
  // sCertificateDepth
  char *sCertificateDepth;
  // certificateDepth
  signed int certificateDepth;
  // certificateFile
  char *certificateFile;
  // keysFile
  char *keysFile;
  // dateFormat
  char *dateFormat;
  // realmsNumber
  signed int realmsNumber;
  // startTime
  signed long int startTime;
  // realmsTable
  struct anonymous_5 **realmsTable;
};

struct anonymous_5
{
  // hostName
  char *hostName;
  // sUsersLimit
  char *sUsersLimit;
  // sClientsLimit
  char *sClientsLimit;
  // sRaClientsLimit
  char *sRaClientsLimit;
  // sUsersPerClient
  char *sUsersPerClient;
  // sClientMode
  char *sClientMode;
  // sTimeout
  char *sTimeout;
  // sMaxIdle
  char *sMaxIdle;
  // realmName
  char *realmName;
  // password
  unsigned char password[4l];
  // connectedUsers
  signed int connectedUsers;
  // usersLimit
  signed int usersLimit;
  // connectedClients
  signed int connectedClients;
  // clientsLimit
  signed int clientsLimit;
  // connectedRaClients
  signed int connectedRaClients;
  // raClientsLimit
  signed int raClientsLimit;
  // usersPerClient
  signed int usersPerClient;
  // timeout
  signed int timeout;
  // maxIdle
  signed int maxIdle;
  // clientMode
  signed int clientMode;
  // userClientPairs
  signed int userClientPairs;
  // clientsCounter
  signed int clientsCounter;
  // usersCounter
  signed int usersCounter;
  // realmType
  char realmType;
  // tunnelType
  char tunnelType;
  // dnsLookupsOn
  char dnsLookupsOn;
  // basePortOn
  char basePortOn;
  // auditOn
  char auditOn;
  // addressLength
  unsigned int addressLength;
  // clientAddress
  struct sockaddr *clientAddress;
  // usersTable
  struct anonymous_4 **usersTable;
  // clientsTable
  struct anonymous_3 **clientsTable;
  // raClientsTable
  struct anonymous_3 **raClientsTable;
  // usersClientsTable
  struct anonymous_7 **usersClientsTable;
};

struct anonymous_7
{
  // listenHostName
  char *listenHostName;
  // manageHostName
  char *manageHostName;
  // listenPortName
  char *listenPortName;
  // managePortName
  char *managePortName;
  // listenFd
  signed int listenFd;
  // manageFd
  signed int manageFd;
  // number
  signed int number;
};

struct anonymous_25
{
  // config
  struct anonymous_2 *config;
  // realm
  signed int realm;
  // client
  signed int client;
  // ra
  char ra;
  // reason
  char reason;
  // set
  struct anonymous_22 *set;
  // wset
  struct anonymous_22 *wset;
};

struct anonymous_13
{
  // timerp
  struct timeval *timerp;
  // function
  void (*function)(void *);
  // data
  void *data;
  // clean
  void (*clean)(void **);
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct anonymous_16
{
  // head
  struct tlnode *head;
  // numberOfTasks
  signed int numberOfTasks;
  // actualTask
  struct tlnode *actualTask;
  // delta
  struct timeval delta;
};

struct anonymous_17
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_14
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_0
{
  // cert_verify_md
  unsigned char cert_verify_md[128l];
  // finish_md
  unsigned char finish_md[128l];
  // finish_md_len
  signed int finish_md_len;
  // peer_finish_md
  unsigned char peer_finish_md[128l];
  // peer_finish_md_len
  signed int peer_finish_md_len;
  // message_size
  unsigned long int message_size;
  // message_type
  signed int message_type;
  // new_cipher
  const struct ssl_cipher_st *new_cipher;
  // dh
  struct dh_st *dh;
  // ecdh
  struct ec_key_st *ecdh;
  // next_state
  signed int next_state;
  // reuse_message
  signed int reuse_message;
  // cert_req
  signed int cert_req;
  // ctype_num
  signed int ctype_num;
  // ctype
  char ctype[9l];
  // ca_names
  struct stack_st_X509_NAME *ca_names;
  // use_rsa_tmp
  signed int use_rsa_tmp;
  // key_block_length
  signed int key_block_length;
  // key_block
  unsigned char *key_block;
  // new_sym_enc
  const struct evp_cipher_st *new_sym_enc;
  // new_hash
  const struct env_md_st *new_hash;
  // new_mac_pkey_type
  signed int new_mac_pkey_type;
  // new_mac_secret_size
  signed int new_mac_secret_size;
  // new_compression
  const struct ssl_comp_st *new_compression;
  // cert_request
  signed int cert_request;
};

struct anonymous_22
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_19
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_8
{
  // tab
  unsigned char tab[5l];
  // readed
  signed int readed;
};

struct anonymous_30
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_1
{
  // fd
  signed int fd;
  // ssl
  struct ssl_st *ssl;
};

struct anonymous_24
{
  // sess_connect
  signed int sess_connect;
  // sess_connect_renegotiate
  signed int sess_connect_renegotiate;
  // sess_connect_good
  signed int sess_connect_good;
  // sess_accept
  signed int sess_accept;
  // sess_accept_renegotiate
  signed int sess_accept_renegotiate;
  // sess_accept_good
  signed int sess_accept_good;
  // sess_miss
  signed int sess_miss;
  // sess_timeout
  signed int sess_timeout;
  // sess_cache_full
  signed int sess_cache_full;
  // sess_hit
  signed int sess_hit;
  // sess_cb_hit
  signed int sess_cb_hit;
};

struct anonymous_9
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_12
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_11
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_10
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_15
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_20
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_9 _kill;
  // _timer
  struct anonymous_10 _timer;
  // _rt
  struct anonymous_11 _rt;
  // _sigchld
  struct anonymous_12 _sigchld;
  // _sigfault
  struct anonymous_14 _sigfault;
  // _sigpoll
  struct anonymous_15 _sigpoll;
  // _sigsys
  struct anonymous_17 _sigsys;
};

struct anonymous_21
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_20 _sifields;
};

struct anonymous_28
{
  // sockfd
  signed int sockfd;
  // host
  char *host;
  // serv
  char *serv;
  // addrlenp
  unsigned int *addrlenp;
  // type
  char type;
  // limit
  signed int limit;
  // https
  char https;
  // ctx
  struct ssl_ctx_st *ctx;
};

struct anonymous_6
{
  // lastActivity
  signed long int lastActivity;
  // lastUSQChange
  signed long int lastUSQChange;
  // lastDSQChange
  signed long int lastDSQChange;
  // totalDownloadedBytes
  signed int totalDownloadedBytes;
  // totalUploadedBytes
  signed int totalUploadedBytes;
  // uploadSQP
  signed int uploadSQP;
  // uploadSpeedQueue
  signed int uploadSpeedQueue[3l];
  // downloadSQP
  signed int downloadSQP;
  // downloadSpeedQueue
  signed int downloadSpeedQueue[3l];
};

struct anonymous_26
{
  // type
  char type;
  // id
  char id[10l];
  // ptr
  signed int ptr;
  // length
  signed int length;
  // allreaded
  signed int allreaded;
};

struct anonymous_27
{
  // read_state
  char read_state;
  // readed_length
  char readed_length[4l];
  // state
  char state;
  // id
  char id[10l];
  // postFd
  struct anonymous_1 *postFd;
  // getFd
  struct anonymous_1 *getFd;
  // sent_ptr
  signed int sent_ptr;
  // sockfd
  signed int sockfd;
  // buf
  char buf[9000l];
  // tmpbuf
  char tmpbuf[9000l];
  // tmpstate
  char tmpstate;
  // tmpFd
  struct anonymous_1 *tmpFd;
  // type
  char type;
  // tmpheader
  struct anonymous_26 tmpheader;
  // ptr
  signed int ptr;
  // length
  signed int length;
  // curreceived
  signed int curreceived;
  // toreceive
  signed int toreceive;
  // received
  signed int received;
};

struct anonymous_4
{
  // state
  char state;
  // connFd
  signed int connFd;
  // whatClient
  signed int whatClient;
  // userId
  signed int userId;
  // connectTime
  signed long int connectTime;
  // nameBuf
  char nameBuf[128l];
  // portBuf
  char portBuf[7l];
  // bufList
  struct buflist *bufList;
  // stats
  struct anonymous_6 *stats;
};

struct anonymous_3
{
  // state
  char state;
  // sslFd
  struct anonymous_1 *sslFd;
  // timer
  struct timeval timer;
  // users
  signed int *users;
  // connected
  signed int connected;
  // limit
  signed int limit;
  // listenFd
  signed int listenFd;
  // usrCliPair
  signed int usrCliPair;
  // clientId
  signed int clientId;
  // connectTime
  signed long int connectTime;
  // lastActivity
  signed long int lastActivity;
  // sClientId
  char *sClientId;
  // nameBuf
  char nameBuf[128l];
  // portBuf
  char portBuf[7l];
  // tunnelType
  char tunnelType;
  // multi
  char multi;
  // auditList
  struct auditlist *auditList;
  // header
  struct anonymous_8 *header;
  // task
  struct anonymous_13 *task;
};

struct anonymous
{
  // conn_id_length
  unsigned int conn_id_length;
  // cert_type
  unsigned int cert_type;
  // cert_length
  unsigned int cert_length;
  // csl
  unsigned int csl;
  // clear
  unsigned int clear;
  // enc
  unsigned int enc;
  // ccl
  unsigned char ccl[32l];
  // cipher_spec_length
  unsigned int cipher_spec_length;
  // session_id_length
  unsigned int session_id_length;
  // clen
  unsigned int clen;
  // rlen
  unsigned int rlen;
};

union anonymous_34
{
  // ptr
  char *ptr;
  // rsa
  struct rsa_st *rsa;
  // dsa
  struct dsa_st *dsa;
  // dh
  struct dh_st *dh;
  // ec
  struct ec_key_st *ec;
};

union anonymous_32
{
  // ptr
  char *ptr;
  // boolean
  signed int boolean;
  // asn1_string
  struct asn1_string_st *asn1_string;
  // object
  struct asn1_object_st *object;
  // integer
  struct asn1_string_st *integer;
  // enumerated
  struct asn1_string_st *enumerated;
  // bit_string
  struct asn1_string_st *bit_string;
  // octet_string
  struct asn1_string_st *octet_string;
  // printablestring
  struct asn1_string_st *printablestring;
  // t61string
  struct asn1_string_st *t61string;
  // ia5string
  struct asn1_string_st *ia5string;
  // generalstring
  struct asn1_string_st *generalstring;
  // bmpstring
  struct asn1_string_st *bmpstring;
  // universalstring
  struct asn1_string_st *universalstring;
  // utctime
  struct asn1_string_st *utctime;
  // generalizedtime
  struct asn1_string_st *generalizedtime;
  // visiblestring
  struct asn1_string_st *visiblestring;
  // utf8string
  struct asn1_string_st *utf8string;
  // set
  struct asn1_string_st *set;
  // sequence
  struct asn1_string_st *sequence;
  // asn1_value
  struct ASN1_VALUE_st *asn1_value;
};

union anonymous_18
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_21 *, void *);
};

union anonymous_33
{
  // cb_1
  void (*cb_1)(signed int, signed int, void *);
  // cb_2
  signed int (*cb_2)(signed int, signed int, struct bn_gencb_st *);
};

union anonymous_23
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_31
{
  // __data
  struct anonymous_30 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_29
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ASN1_ENCODING_st
{
  // enc
  unsigned char *enc;
  // len
  signed long int len;
  // modified
  signed int modified;
};

struct DSA_SIG_st
{
  // r
  struct bignum_st *r;
  // s
  struct bignum_st *s;
};

struct X509_VERIFY_PARAM_st
{
  // name
  char *name;
  // check_time
  signed long int check_time;
  // inh_flags
  unsigned long int inh_flags;
  // flags
  unsigned long int flags;
  // purpose
  signed int purpose;
  // trust
  signed int trust;
  // depth
  signed int depth;
  // policies
  struct stack_st_ASN1_OBJECT *policies;
  // id
  struct X509_VERIFY_PARAM_ID_st *id;
};

struct X509_algor_st
{
  // algorithm
  struct asn1_object_st *algorithm;
  // parameter
  struct asn1_type_st *parameter;
};

struct X509_crl_info_st
{
  // version
  struct asn1_string_st *version;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // issuer
  struct X509_name_st *issuer;
  // lastUpdate
  struct asn1_string_st *lastUpdate;
  // nextUpdate
  struct asn1_string_st *nextUpdate;
  // revoked
  struct stack_st_X509_REVOKED *revoked;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct X509_crl_st
{
  // crl
  struct X509_crl_info_st *crl;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
  // flags
  signed int flags;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // idp
  struct ISSUING_DIST_POINT_st *idp;
  // idp_flags
  signed int idp_flags;
  // idp_reasons
  signed int idp_reasons;
  // crl_number
  struct asn1_string_st *crl_number;
  // base_crl_number
  struct asn1_string_st *base_crl_number;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // issuers
  struct stack_st_GENERAL_NAMES *issuers;
  // meth
  const struct x509_crl_method_st *meth;
  // meth_data
  void *meth_data;
};

struct X509_name_entry_st
{
  // object
  struct asn1_object_st *object;
  // value
  struct asn1_string_st *value;
  // set
  signed int set;
  // size
  signed int size;
};

struct X509_name_st
{
  // entries
  struct stack_st_X509_NAME_ENTRY *entries;
  // modified
  signed int modified;
  // bytes
  struct buf_mem_st *bytes;
  // canon_enc
  unsigned char *canon_enc;
  // canon_enclen
  signed int canon_enclen;
};

struct X509_pubkey_st
{
  // algor
  struct X509_algor_st *algor;
  // public_key
  struct asn1_string_st *public_key;
  // pkey
  struct evp_pkey_st *pkey;
};

struct X509_req_info_st
{
  // enc
  struct ASN1_ENCODING_st enc;
  // version
  struct asn1_string_st *version;
  // subject
  struct X509_name_st *subject;
  // pubkey
  struct X509_pubkey_st *pubkey;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct X509_req_st
{
  // req_info
  struct X509_req_info_st *req_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
};

struct X509_val_st
{
  // notBefore
  struct asn1_string_st *notBefore;
  // notAfter
  struct asn1_string_st *notAfter;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct alnode
{
  // userId
  signed int userId;
  // nameBuf
  char nameBuf[128l];
  // portBuf
  char portBuf[7l];
  // connectTime
  signed long int connectTime;
  // duration
  signed long int duration;
  // nextNode
  struct alnode *nextNode;
};

struct asn1_object_st
{
  // sn
  const char *sn;
  // ln
  const char *ln;
  // nid
  signed int nid;
  // length
  signed int length;
  // data
  const unsigned char *data;
  // flags
  signed int flags;
};

struct asn1_string_st
{
  // length
  signed int length;
  // type
  signed int type;
  // data
  unsigned char *data;
  // flags
  signed long int flags;
};

struct asn1_type_st
{
  // type
  signed int type;
  // value
  union anonymous_32 value;
};

struct auditlist
{
  // head
  struct alnode *head;
  // tail
  struct alnode *tail;
};

struct bignum_st
{
  // d
  unsigned long int *d;
  // top
  signed int top;
  // dmax
  signed int dmax;
  // neg
  signed int neg;
  // flags
  signed int flags;
};

struct bio_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // bwrite
  signed int (*bwrite)(struct bio_st *, const char *, signed int);
  // bread
  signed int (*bread)(struct bio_st *, char *, signed int);
  // bputs
  signed int (*bputs)(struct bio_st *, const char *);
  // bgets
  signed int (*bgets)(struct bio_st *, char *, signed int);
  // ctrl
  signed long int (*ctrl)(struct bio_st *, signed int, signed long int, void *);
  // create
  signed int (*create)(struct bio_st *);
  // destroy
  signed int (*destroy)(struct bio_st *);
  // callback_ctrl
  signed long int (*callback_ctrl)(struct bio_st *, signed int, void (*)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int));
};

struct crypto_ex_data_st
{
  // sk
  struct stack_st_void *sk;
  // dummy
  signed int dummy;
};

struct bio_st
{
  // method
  struct bio_method_st *method;
  // callback
  signed long int (*callback)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int);
  // cb_arg
  char *cb_arg;
  // init
  signed int init;
  // shutdown
  signed int shutdown;
  // flags
  signed int flags;
  // retry_reason
  signed int retry_reason;
  // num
  signed int num;
  // ptr
  void *ptr;
  // next_bio
  struct bio_st *next_bio;
  // prev_bio
  struct bio_st *prev_bio;
  // references
  signed int references;
  // num_read
  unsigned long int num_read;
  // num_write
  unsigned long int num_write;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct blnode
{
  // actPtr
  signed int actPtr;
  // msgLen
  signed int msgLen;
  // message
  unsigned char *message;
  // nextNode
  struct blnode *nextNode;
};

struct bn_gencb_st
{
  // ver
  unsigned int ver;
  // arg
  void *arg;
  // cb
  union anonymous_33 cb;
};

struct bn_mont_ctx_st
{
  // ri
  signed int ri;
  // RR
  struct bignum_st RR;
  // N
  struct bignum_st N;
  // Ni
  struct bignum_st Ni;
  // n0
  unsigned long int n0[2l];
  // flags
  signed int flags;
};

struct buf_mem_st
{
  // length
  unsigned long int length;
  // data
  char *data;
  // max
  unsigned long int max;
};

struct buflist
{
  // head
  struct blnode *head;
  // tail
  struct blnode *tail;
};

struct comp_ctx_st
{
  // meth
  struct comp_method_st *meth;
  // compress_in
  unsigned long int compress_in;
  // compress_out
  unsigned long int compress_out;
  // expand_in
  unsigned long int expand_in;
  // expand_out
  unsigned long int expand_out;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct comp_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // init
  signed int (*init)(struct comp_ctx_st *);
  // finish
  void (*finish)(struct comp_ctx_st *);
  // compress
  signed int (*compress)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // expand
  signed int (*expand)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // ctrl
  signed long int (*ctrl)(void);
  // callback_ctrl
  signed long int (*callback_ctrl)(void);
};

struct dh_method
{
  // name
  const char *name;
  // generate_key
  signed int (*generate_key)(struct dh_st *);
  // compute_key
  signed int (*compute_key)(unsigned char *, const struct bignum_st *, struct dh_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(const struct dh_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dh_st *);
  // finish
  signed int (*finish)(struct dh_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // generate_params
  signed int (*generate_params)(struct dh_st *, signed int, signed int, struct bn_gencb_st *);
};

struct dh_st
{
  // pad
  signed int pad;
  // version
  signed int version;
  // p
  struct bignum_st *p;
  // g
  struct bignum_st *g;
  // length
  signed long int length;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // q
  struct bignum_st *q;
  // j
  struct bignum_st *j;
  // seed
  unsigned char *seed;
  // seedlen
  signed int seedlen;
  // counter
  struct bignum_st *counter;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dh_method *meth;
  // engine
  struct engine_st *engine;
};

struct dsa_method
{
  // name
  const char *name;
  // dsa_do_sign
  struct DSA_SIG_st * (*dsa_do_sign)(const unsigned char *, signed int, struct dsa_st *);
  // dsa_sign_setup
  signed int (*dsa_sign_setup)(struct dsa_st *, struct bignum_ctx *, struct bignum_st **, struct bignum_st **);
  // dsa_do_verify
  signed int (*dsa_do_verify)(const unsigned char *, signed int, struct DSA_SIG_st *, struct dsa_st *);
  // dsa_mod_exp
  signed int (*dsa_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dsa_st *);
  // finish
  signed int (*finish)(struct dsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // dsa_paramgen
  signed int (*dsa_paramgen)(struct dsa_st *, signed int, const unsigned char *, signed int, signed int *, unsigned long int *, struct bn_gencb_st *);
  // dsa_keygen
  signed int (*dsa_keygen)(struct dsa_st *);
};

struct dsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // write_params
  signed int write_params;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // g
  struct bignum_st *g;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // kinv
  struct bignum_st *kinv;
  // r
  struct bignum_st *r;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dsa_method *meth;
  // engine
  struct engine_st *engine;
};

struct dtls1_bitmap_st
{
  // map
  unsigned long int map;
  // max_seq_num
  unsigned char max_seq_num[8l];
};

struct dtls1_retransmit_state
{
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // session
  struct ssl_session_st *session;
  // epoch
  unsigned short int epoch;
};

struct record_pqueue_st
{
  // epoch
  unsigned short int epoch;
  // q
  struct _pqueue *q;
};

struct hm_header_st
{
  // type
  unsigned char type;
  // msg_len
  unsigned long int msg_len;
  // seq
  unsigned short int seq;
  // frag_off
  unsigned long int frag_off;
  // frag_len
  unsigned long int frag_len;
  // is_ccs
  unsigned int is_ccs;
  // saved_retransmit_state
  struct dtls1_retransmit_state saved_retransmit_state;
};

struct dtls1_timeout_st
{
  // read_timeouts
  unsigned int read_timeouts;
  // write_timeouts
  unsigned int write_timeouts;
  // num_alerts
  unsigned int num_alerts;
};

struct dtls1_state_st
{
  // send_cookie
  unsigned int send_cookie;
  // cookie
  unsigned char cookie[256l];
  // rcvd_cookie
  unsigned char rcvd_cookie[256l];
  // cookie_len
  unsigned int cookie_len;
  // r_epoch
  unsigned short int r_epoch;
  // w_epoch
  unsigned short int w_epoch;
  // bitmap
  struct dtls1_bitmap_st bitmap;
  // next_bitmap
  struct dtls1_bitmap_st next_bitmap;
  // handshake_write_seq
  unsigned short int handshake_write_seq;
  // next_handshake_write_seq
  unsigned short int next_handshake_write_seq;
  // handshake_read_seq
  unsigned short int handshake_read_seq;
  // last_write_sequence
  unsigned char last_write_sequence[8l];
  // unprocessed_rcds
  struct record_pqueue_st unprocessed_rcds;
  // processed_rcds
  struct record_pqueue_st processed_rcds;
  // buffered_messages
  struct _pqueue *buffered_messages;
  // sent_messages
  struct _pqueue *sent_messages;
  // buffered_app_data
  struct record_pqueue_st buffered_app_data;
  // listen
  unsigned int listen;
  // link_mtu
  unsigned int link_mtu;
  // mtu
  unsigned int mtu;
  // w_msg_hdr
  struct hm_header_st w_msg_hdr;
  // r_msg_hdr
  struct hm_header_st r_msg_hdr;
  // timeout
  struct dtls1_timeout_st timeout;
  // next_timeout
  struct timeval next_timeout;
  // timeout_duration
  unsigned short int timeout_duration;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[12l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // retransmitting
  unsigned int retransmitting;
  // change_cipher_spec_ok
  unsigned int change_cipher_spec_ok;
};

struct entry
{
  // key
  char *key;
  // value
  unsigned char *value;
};

struct env_md_ctx_st
{
  // digest
  const struct env_md_st *digest;
  // engine
  struct engine_st *engine;
  // flags
  unsigned long int flags;
  // md_data
  void *md_data;
  // pctx
  struct evp_pkey_ctx_st *pctx;
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
};

struct env_md_st
{
  // type
  signed int type;
  // pkey_type
  signed int pkey_type;
  // md_size
  signed int md_size;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct env_md_ctx_st *);
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
  // final
  signed int (*final)(struct env_md_ctx_st *, unsigned char *);
  // copy
  signed int (*copy)(struct env_md_ctx_st *, const struct env_md_ctx_st *);
  // cleanup
  signed int (*cleanup)(struct env_md_ctx_st *);
  // sign
  signed int (*sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, void *);
  // verify
  signed int (*verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, void *);
  // required_pkey_type
  signed int required_pkey_type[5l];
  // block_size
  signed int block_size;
  // ctx_size
  signed int ctx_size;
  // md_ctrl
  signed int (*md_ctrl)(struct env_md_ctx_st *, signed int, signed int, void *);
};

struct evp_cipher_ctx_st
{
  // cipher
  const struct evp_cipher_st *cipher;
  // engine
  struct engine_st *engine;
  // encrypt
  signed int encrypt;
  // buf_len
  signed int buf_len;
  // oiv
  unsigned char oiv[16l];
  // iv
  unsigned char iv[16l];
  // buf
  unsigned char buf[32l];
  // num
  signed int num;
  // app_data
  void *app_data;
  // key_len
  signed int key_len;
  // flags
  unsigned long int flags;
  // cipher_data
  void *cipher_data;
  // final_used
  signed int final_used;
  // block_mask
  signed int block_mask;
  // final
  unsigned char final[32l];
};

struct evp_cipher_st
{
  // nid
  signed int nid;
  // block_size
  signed int block_size;
  // key_len
  signed int key_len;
  // iv_len
  signed int iv_len;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct evp_cipher_ctx_st *, const unsigned char *, const unsigned char *, signed int);
  // do_cipher
  signed int (*do_cipher)(struct evp_cipher_ctx_st *, unsigned char *, const unsigned char *, unsigned long int);
  // cleanup
  signed int (*cleanup)(struct evp_cipher_ctx_st *);
  // ctx_size
  signed int ctx_size;
  // set_asn1_parameters
  signed int (*set_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // get_asn1_parameters
  signed int (*get_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // ctrl
  signed int (*ctrl)(struct evp_cipher_ctx_st *, signed int, signed int, void *);
  // app_data
  void *app_data;
};

struct evp_pkey_st
{
  // type
  signed int type;
  // save_type
  signed int save_type;
  // references
  signed int references;
  // ameth
  const struct evp_pkey_asn1_method_st *ameth;
  // engine
  struct engine_st *engine;
  // pkey
  union anonymous_34 pkey;
  // save_parameters
  signed int save_parameters;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct hmac_ctx_st
{
  // md
  const struct env_md_st *md;
  // md_ctx
  struct env_md_ctx_st md_ctx;
  // i_ctx
  struct env_md_ctx_st i_ctx;
  // o_ctx
  struct env_md_ctx_st o_ctx;
  // key_length
  unsigned int key_length;
  // key
  unsigned char key[128l];
};

struct in6_addr
{
  // __in6_u
  union anonymous_23 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct lhash_st_SSL_SESSION
{
  // dummy
  signed int dummy;
};

struct llnode
{
  // cmdline
  char *cmdline;
  // msgtype
  char msgtype;
  // importance
  char importance;
  // logfd
  struct _IO_FILE *logfd;
  // next
  struct llnode *next;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rsa_meth_st
{
  // name
  const char *name;
  // rsa_pub_enc
  signed int (*rsa_pub_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_pub_dec
  signed int (*rsa_pub_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_enc
  signed int (*rsa_priv_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_dec
  signed int (*rsa_priv_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_mod_exp
  signed int (*rsa_mod_exp)(struct bignum_st *, const struct bignum_st *, struct rsa_st *, struct bignum_ctx *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct rsa_st *);
  // finish
  signed int (*finish)(struct rsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // rsa_sign
  signed int (*rsa_sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, const struct rsa_st *);
  // rsa_verify
  signed int (*rsa_verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, const struct rsa_st *);
  // rsa_keygen
  signed int (*rsa_keygen)(struct rsa_st *, signed int, struct bignum_st *, struct bn_gencb_st *);
};

struct rsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // meth
  const struct rsa_meth_st *meth;
  // engine
  struct engine_st *engine;
  // n
  struct bignum_st *n;
  // e
  struct bignum_st *e;
  // d
  struct bignum_st *d;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // dmp1
  struct bignum_st *dmp1;
  // dmq1
  struct bignum_st *dmq1;
  // iqmp
  struct bignum_st *iqmp;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
  // flags
  signed int flags;
  // _method_mod_n
  struct bn_mont_ctx_st *_method_mod_n;
  // _method_mod_p
  struct bn_mont_ctx_st *_method_mod_p;
  // _method_mod_q
  struct bn_mont_ctx_st *_method_mod_q;
  // bignum_data
  char *bignum_data;
  // blinding
  struct bn_blinding_st *blinding;
  // mt_blinding
  struct bn_blinding_st *mt_blinding;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_18 __sigaction_handler;
  // sa_mask
  struct anonymous_19 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct srp_ctx_st
{
  // SRP_cb_arg
  void *SRP_cb_arg;
  // TLS_ext_srp_username_callback
  signed int (*TLS_ext_srp_username_callback)(struct ssl_st *, signed int *, void *);
  // SRP_verify_param_callback
  signed int (*SRP_verify_param_callback)(struct ssl_st *, void *);
  // SRP_give_srp_client_pwd_callback
  char * (*SRP_give_srp_client_pwd_callback)(struct ssl_st *, void *);
  // login
  char *login;
  // N
  struct bignum_st *N;
  // g
  struct bignum_st *g;
  // s
  struct bignum_st *s;
  // B
  struct bignum_st *B;
  // A
  struct bignum_st *A;
  // a
  struct bignum_st *a;
  // b
  struct bignum_st *b;
  // v
  struct bignum_st *v;
  // info
  char *info;
  // strength
  signed int strength;
  // srp_Mask
  unsigned long int srp_Mask;
};

struct srtp_protection_profile_st
{
  // name
  const char *name;
  // id
  unsigned long int id;
};

struct ssl2_state_st
{
  // three_byte_header
  signed int three_byte_header;
  // clear_text
  signed int clear_text;
  // escape
  signed int escape;
  // ssl2_rollback
  signed int ssl2_rollback;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_buf
  const unsigned char *wpend_buf;
  // wpend_off
  signed int wpend_off;
  // wpend_len
  signed int wpend_len;
  // wpend_ret
  signed int wpend_ret;
  // rbuf_left
  signed int rbuf_left;
  // rbuf_offs
  signed int rbuf_offs;
  // rbuf
  unsigned char *rbuf;
  // wbuf
  unsigned char *wbuf;
  // write_ptr
  unsigned char *write_ptr;
  // padding
  unsigned int padding;
  // rlength
  unsigned int rlength;
  // ract_data_length
  signed int ract_data_length;
  // wlength
  unsigned int wlength;
  // wact_data_length
  signed int wact_data_length;
  // ract_data
  unsigned char *ract_data;
  // wact_data
  unsigned char *wact_data;
  // mac_data
  unsigned char *mac_data;
  // read_key
  unsigned char *read_key;
  // write_key
  unsigned char *write_key;
  // challenge_length
  unsigned int challenge_length;
  // challenge
  unsigned char challenge[32l];
  // conn_id_length
  unsigned int conn_id_length;
  // conn_id
  unsigned char conn_id[16l];
  // key_material_length
  unsigned int key_material_length;
  // key_material
  unsigned char key_material[48l];
  // read_sequence
  unsigned long int read_sequence;
  // write_sequence
  unsigned long int write_sequence;
  // tmp
  struct anonymous tmp;
};

struct ssl3_buffer_st
{
  // buf
  unsigned char *buf;
  // len
  unsigned long int len;
  // offset
  signed int offset;
  // left
  signed int left;
};

struct ssl3_record_st
{
  // type
  signed int type;
  // length
  unsigned int length;
  // off
  unsigned int off;
  // data
  unsigned char *data;
  // input
  unsigned char *input;
  // comp
  unsigned char *comp;
  // epoch
  unsigned long int epoch;
  // seq_num
  unsigned char seq_num[8l];
};

struct ssl3_state_st
{
  // flags
  signed long int flags;
  // delay_buf_pop_ret
  signed int delay_buf_pop_ret;
  // read_sequence
  unsigned char read_sequence[8l];
  // read_mac_secret_size
  signed int read_mac_secret_size;
  // read_mac_secret
  unsigned char read_mac_secret[64l];
  // write_sequence
  unsigned char write_sequence[8l];
  // write_mac_secret_size
  signed int write_mac_secret_size;
  // write_mac_secret
  unsigned char write_mac_secret[64l];
  // server_random
  unsigned char server_random[32l];
  // client_random
  unsigned char client_random[32l];
  // need_empty_fragments
  signed int need_empty_fragments;
  // empty_fragment_done
  signed int empty_fragment_done;
  // init_extra
  signed int init_extra;
  // rbuf
  struct ssl3_buffer_st rbuf;
  // wbuf
  struct ssl3_buffer_st wbuf;
  // rrec
  struct ssl3_record_st rrec;
  // wrec
  struct ssl3_record_st wrec;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[4l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_type
  signed int wpend_type;
  // wpend_ret
  signed int wpend_ret;
  // wpend_buf
  const unsigned char *wpend_buf;
  // handshake_buffer
  struct bio_st *handshake_buffer;
  // handshake_dgst
  struct env_md_ctx_st **handshake_dgst;
  // change_cipher_spec
  signed int change_cipher_spec;
  // warn_alert
  signed int warn_alert;
  // fatal_alert
  signed int fatal_alert;
  // alert_dispatch
  signed int alert_dispatch;
  // send_alert
  unsigned char send_alert[2l];
  // renegotiate
  signed int renegotiate;
  // total_renegotiations
  signed int total_renegotiations;
  // num_renegotiations
  signed int num_renegotiations;
  // in_read_app_data
  signed int in_read_app_data;
  // client_opaque_prf_input
  void *client_opaque_prf_input;
  // client_opaque_prf_input_len
  unsigned long int client_opaque_prf_input_len;
  // server_opaque_prf_input
  void *server_opaque_prf_input;
  // server_opaque_prf_input_len
  unsigned long int server_opaque_prf_input_len;
  // tmp
  struct anonymous_0 tmp;
  // previous_client_finished
  unsigned char previous_client_finished[64l];
  // previous_client_finished_len
  unsigned char previous_client_finished_len;
  // previous_server_finished
  unsigned char previous_server_finished[64l];
  // previous_server_finished_len
  unsigned char previous_server_finished_len;
  // send_connection_binding
  signed int send_connection_binding;
  // next_proto_neg_seen
  signed int next_proto_neg_seen;
  // is_probably_safari
  char is_probably_safari;
  // alpn_selected
  unsigned char *alpn_selected;
  // alpn_selected_len
  unsigned int alpn_selected_len;
};

struct ssl_cipher_st
{
  // valid
  signed int valid;
  // name
  const char *name;
  // id
  unsigned long int id;
  // algorithm_mkey
  unsigned long int algorithm_mkey;
  // algorithm_auth
  unsigned long int algorithm_auth;
  // algorithm_enc
  unsigned long int algorithm_enc;
  // algorithm_mac
  unsigned long int algorithm_mac;
  // algorithm_ssl
  unsigned long int algorithm_ssl;
  // algo_strength
  unsigned long int algo_strength;
  // algorithm2
  unsigned long int algorithm2;
  // strength_bits
  signed int strength_bits;
  // alg_bits
  signed int alg_bits;
};

struct ssl_comp_st
{
  // id
  signed int id;
  // name
  const char *name;
  // method
  struct comp_method_st *method;
};

struct ssl_ctx_st
{
  // method
  const struct ssl_method_st *method;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // cert_store
  struct x509_store_st *cert_store;
  // sessions
  struct lhash_st_SSL_SESSION *sessions;
  // session_cache_size
  unsigned long int session_cache_size;
  // session_cache_head
  struct ssl_session_st *session_cache_head;
  // session_cache_tail
  struct ssl_session_st *session_cache_tail;
  // session_cache_mode
  signed int session_cache_mode;
  // session_timeout
  signed long int session_timeout;
  // new_session_cb
  signed int (*new_session_cb)(struct ssl_st *, struct ssl_session_st *);
  // remove_session_cb
  void (*remove_session_cb)(struct ssl_ctx_st *, struct ssl_session_st *);
  // get_session_cb
  struct ssl_session_st * (*get_session_cb)(struct ssl_st *, unsigned char *, signed int, signed int *);
  // stats
  struct anonymous_24 stats;
  // references
  signed int references;
  // app_verify_callback
  signed int (*app_verify_callback)(struct x509_store_ctx_st *, void *);
  // app_verify_arg
  void *app_verify_arg;
  // default_passwd_callback
  signed int (*default_passwd_callback)(char *, signed int, signed int, void *);
  // default_passwd_callback_userdata
  void *default_passwd_callback_userdata;
  // client_cert_cb
  signed int (*client_cert_cb)(struct ssl_st *, struct x509_st **, struct evp_pkey_st **);
  // app_gen_cookie_cb
  signed int (*app_gen_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int *);
  // app_verify_cookie_cb
  signed int (*app_verify_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // rsa_md5
  const struct env_md_st *rsa_md5;
  // md5
  const struct env_md_st *md5;
  // sha1
  const struct env_md_st *sha1;
  // extra_certs
  struct stack_st_X509 *extra_certs;
  // comp_methods
  struct stack_st_SSL_COMP *comp_methods;
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // cert
  struct cert_st *cert;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // verify_mode
  signed int verify_mode;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // default_verify_callback
  signed int (*default_verify_callback)(signed int, struct x509_store_ctx_st *);
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // param
  struct X509_VERIFY_PARAM_st *param;
  // quiet_shutdown
  signed int quiet_shutdown;
  // max_send_fragment
  unsigned int max_send_fragment;
  // client_cert_engine
  struct engine_st *client_cert_engine;
  // tlsext_servername_callback
  signed int (*tlsext_servername_callback)(struct ssl_st *, signed int *, void *);
  // tlsext_servername_arg
  void *tlsext_servername_arg;
  // tlsext_tick_key_name
  unsigned char tlsext_tick_key_name[16l];
  // tlsext_tick_hmac_key
  unsigned char tlsext_tick_hmac_key[16l];
  // tlsext_tick_aes_key
  unsigned char tlsext_tick_aes_key[16l];
  // tlsext_ticket_key_cb
  signed int (*tlsext_ticket_key_cb)(struct ssl_st *, unsigned char *, unsigned char *, struct evp_cipher_ctx_st *, struct hmac_ctx_st *, signed int);
  // tlsext_status_cb
  signed int (*tlsext_status_cb)(struct ssl_st *, void *);
  // tlsext_status_arg
  void *tlsext_status_arg;
  // tlsext_opaque_prf_input_callback
  signed int (*tlsext_opaque_prf_input_callback)(struct ssl_st *, void *, unsigned long int, void *);
  // tlsext_opaque_prf_input_callback_arg
  void *tlsext_opaque_prf_input_callback_arg;
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // freelist_max_len
  unsigned int freelist_max_len;
  // wbuf_freelist
  struct ssl3_buf_freelist_st *wbuf_freelist;
  // rbuf_freelist
  struct ssl3_buf_freelist_st *rbuf_freelist;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // next_protos_advertised_cb
  signed int (*next_protos_advertised_cb)(struct ssl_st *, const unsigned char **, unsigned int *, void *);
  // next_protos_advertised_cb_arg
  void *next_protos_advertised_cb_arg;
  // next_proto_select_cb
  signed int (*next_proto_select_cb)(struct ssl_st *, unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // next_proto_select_cb_arg
  void *next_proto_select_cb_arg;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // alpn_select_cb
  signed int (*alpn_select_cb)(struct ssl_st *, const unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // alpn_select_cb_arg
  void *alpn_select_cb_arg;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
};

struct ssl_method_st
{
  // version
  signed int version;
  // ssl_new
  signed int (*ssl_new)(struct ssl_st *);
  // ssl_clear
  void (*ssl_clear)(struct ssl_st *);
  // ssl_free
  void (*ssl_free)(struct ssl_st *);
  // ssl_accept
  signed int (*ssl_accept)(struct ssl_st *);
  // ssl_connect
  signed int (*ssl_connect)(struct ssl_st *);
  // ssl_read
  signed int (*ssl_read)(struct ssl_st *, void *, signed int);
  // ssl_peek
  signed int (*ssl_peek)(struct ssl_st *, void *, signed int);
  // ssl_write
  signed int (*ssl_write)(struct ssl_st *, const void *, signed int);
  // ssl_shutdown
  signed int (*ssl_shutdown)(struct ssl_st *);
  // ssl_renegotiate
  signed int (*ssl_renegotiate)(struct ssl_st *);
  // ssl_renegotiate_check
  signed int (*ssl_renegotiate_check)(struct ssl_st *);
  // ssl_get_message
  signed long int (*ssl_get_message)(struct ssl_st *, signed int, signed int, signed int, signed long int, signed int *);
  // ssl_read_bytes
  signed int (*ssl_read_bytes)(struct ssl_st *, signed int, unsigned char *, signed int, signed int);
  // ssl_write_bytes
  signed int (*ssl_write_bytes)(struct ssl_st *, signed int, const void *, signed int);
  // ssl_dispatch_alert
  signed int (*ssl_dispatch_alert)(struct ssl_st *);
  // ssl_ctrl
  signed long int (*ssl_ctrl)(struct ssl_st *, signed int, signed long int, void *);
  // ssl_ctx_ctrl
  signed long int (*ssl_ctx_ctrl)(struct ssl_ctx_st *, signed int, signed long int, void *);
  // get_cipher_by_char
  const struct ssl_cipher_st * (*get_cipher_by_char)(const unsigned char *);
  // put_cipher_by_char
  signed int (*put_cipher_by_char)(const struct ssl_cipher_st *, unsigned char *);
  // ssl_pending
  signed int (*ssl_pending)(const struct ssl_st *);
  // num_ciphers
  signed int (*num_ciphers)(void);
  // get_cipher
  const struct ssl_cipher_st * (*get_cipher)(unsigned int);
  // get_ssl_method
  struct ssl_method_st * (*get_ssl_method)(signed int);
  // get_timeout
  signed long int (*get_timeout)(void);
  // ssl3_enc
  struct ssl3_enc_method *ssl3_enc;
  // ssl_version
  signed int (*ssl_version)(void);
  // ssl_callback_ctrl
  signed long int (*ssl_callback_ctrl)(struct ssl_st *, signed int, void (*)(void));
  // ssl_ctx_callback_ctrl
  signed long int (*ssl_ctx_callback_ctrl)(struct ssl_ctx_st *, signed int, void (*)(void));
};

struct ssl_session_st
{
  // ssl_version
  signed int ssl_version;
  // key_arg_length
  unsigned int key_arg_length;
  // key_arg
  unsigned char key_arg[8l];
  // master_key_length
  signed int master_key_length;
  // master_key
  unsigned char master_key[48l];
  // session_id_length
  unsigned int session_id_length;
  // session_id
  unsigned char session_id[32l];
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_identity
  char *psk_identity;
  // not_resumable
  signed int not_resumable;
  // sess_cert
  struct sess_cert_st *sess_cert;
  // peer
  struct x509_st *peer;
  // verify_result
  signed long int verify_result;
  // references
  signed int references;
  // timeout
  signed long int timeout;
  // time
  signed long int time;
  // compress_meth
  unsigned int compress_meth;
  // cipher
  const struct ssl_cipher_st *cipher;
  // cipher_id
  unsigned long int cipher_id;
  // ciphers
  struct stack_st_SSL_CIPHER *ciphers;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // prev
  struct ssl_session_st *prev;
  // next
  struct ssl_session_st *next;
  // tlsext_hostname
  char *tlsext_hostname;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_tick
  unsigned char *tlsext_tick;
  // tlsext_ticklen
  unsigned long int tlsext_ticklen;
  // tlsext_tick_lifetime_hint
  signed long int tlsext_tick_lifetime_hint;
  // srp_username
  char *srp_username;
};

struct ssl_st
{
  // version
  signed int version;
  // type
  signed int type;
  // method
  const struct ssl_method_st *method;
  // rbio
  struct bio_st *rbio;
  // wbio
  struct bio_st *wbio;
  // bbio
  struct bio_st *bbio;
  // rwstate
  signed int rwstate;
  // in_handshake
  signed int in_handshake;
  // handshake_func
  signed int (*handshake_func)(struct ssl_st *);
  // server
  signed int server;
  // new_session
  signed int new_session;
  // quiet_shutdown
  signed int quiet_shutdown;
  // shutdown
  signed int shutdown;
  // state
  signed int state;
  // rstate
  signed int rstate;
  // init_buf
  struct buf_mem_st *init_buf;
  // init_msg
  void *init_msg;
  // init_num
  signed int init_num;
  // init_off
  signed int init_off;
  // packet
  unsigned char *packet;
  // packet_length
  unsigned int packet_length;
  // s2
  struct ssl2_state_st *s2;
  // s3
  struct ssl3_state_st *s3;
  // d1
  struct dtls1_state_st *d1;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // hit
  signed int hit;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // mac_flags
  signed int mac_flags;
  // enc_read_ctx
  struct evp_cipher_ctx_st *enc_read_ctx;
  // read_hash
  struct env_md_ctx_st *read_hash;
  // expand
  struct comp_ctx_st *expand;
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // cert
  struct cert_st *cert;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // session
  struct ssl_session_st *session;
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // verify_mode
  signed int verify_mode;
  // verify_callback
  signed int (*verify_callback)(signed int, struct x509_store_ctx_st *);
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // error
  signed int error;
  // error_code
  signed int error_code;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // ctx
  struct ssl_ctx_st *ctx;
  // debug
  signed int debug;
  // verify_result
  signed long int verify_result;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // references
  signed int references;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // first_packet
  signed int first_packet;
  // client_version
  signed int client_version;
  // max_send_fragment
  unsigned int max_send_fragment;
  // tlsext_debug_cb
  void (*tlsext_debug_cb)(struct ssl_st *, signed int, signed int, unsigned char *, signed int, void *);
  // tlsext_debug_arg
  void *tlsext_debug_arg;
  // tlsext_hostname
  char *tlsext_hostname;
  // servername_done
  signed int servername_done;
  // tlsext_status_type
  signed int tlsext_status_type;
  // tlsext_status_expected
  signed int tlsext_status_expected;
  // tlsext_ocsp_ids
  struct stack_st_OCSP_RESPID *tlsext_ocsp_ids;
  // tlsext_ocsp_exts
  struct stack_st_X509_EXTENSION *tlsext_ocsp_exts;
  // tlsext_ocsp_resp
  unsigned char *tlsext_ocsp_resp;
  // tlsext_ocsp_resplen
  signed int tlsext_ocsp_resplen;
  // tlsext_ticket_expected
  signed int tlsext_ticket_expected;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_opaque_prf_input
  void *tlsext_opaque_prf_input;
  // tlsext_opaque_prf_input_len
  unsigned long int tlsext_opaque_prf_input_len;
  // tlsext_session_ticket
  struct tls_session_ticket_ext_st *tlsext_session_ticket;
  // tls_session_ticket_ext_cb
  signed int (*tls_session_ticket_ext_cb)(struct ssl_st *, const unsigned char *, signed int, void *);
  // tls_session_ticket_ext_cb_arg
  void *tls_session_ticket_ext_cb_arg;
  // tls_session_secret_cb
  signed int (*tls_session_secret_cb)(struct ssl_st *, void *, signed int *, struct stack_st_SSL_CIPHER *, struct ssl_cipher_st **, void *);
  // tls_session_secret_cb_arg
  void *tls_session_secret_cb_arg;
  // initial_ctx
  struct ssl_ctx_st *initial_ctx;
  // next_proto_negotiated
  unsigned char *next_proto_negotiated;
  // next_proto_negotiated_len
  unsigned char next_proto_negotiated_len;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // srtp_profile
  struct srtp_protection_profile_st *srtp_profile;
  // tlsext_heartbeat
  unsigned int tlsext_heartbeat;
  // tlsext_hb_pending
  unsigned int tlsext_hb_pending;
  // tlsext_hb_seq
  unsigned int tlsext_hb_seq;
  // renegotiate
  signed int renegotiate;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
};

struct stack_st
{
  // num
  signed int num;
  // data
  char **data;
  // sorted
  signed int sorted;
  // num_alloc
  signed int num_alloc;
  // comp
  signed int (*comp)(const void *, const void *);
};

struct stack_st_ASN1_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_SRTP_PROTECTION_PROFILE
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_CIPHER
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_COMP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ALGOR
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ATTRIBUTE
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_CRL
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_EXTENSION
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_LOOKUP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME_ENTRY
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_REVOKED
{
  // stack
  struct stack_st stack;
};

struct stack_st_void
{
  // stack
  struct stack_st stack;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tlnode
{
  // task
  struct anonymous_13 *task;
  // previous
  struct tlnode *previous;
  // next
  struct tlnode *next;
};

struct tls_session_ticket_ext_st
{
  // length
  unsigned short int length;
  // data
  void *data;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct x509_cert_aux_st
{
  // trust
  struct stack_st_ASN1_OBJECT *trust;
  // reject
  struct stack_st_ASN1_OBJECT *reject;
  // alias
  struct asn1_string_st *alias;
  // keyid
  struct asn1_string_st *keyid;
  // other
  struct stack_st_X509_ALGOR *other;
};

struct x509_cinf_st
{
  // version
  struct asn1_string_st *version;
  // serialNumber
  struct asn1_string_st *serialNumber;
  // signature
  struct X509_algor_st *signature;
  // issuer
  struct X509_name_st *issuer;
  // validity
  struct X509_val_st *validity;
  // subject
  struct X509_name_st *subject;
  // key
  struct X509_pubkey_st *key;
  // issuerUID
  struct asn1_string_st *issuerUID;
  // subjectUID
  struct asn1_string_st *subjectUID;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct x509_st
{
  // cert_info
  struct x509_cinf_st *cert_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // valid
  signed int valid;
  // references
  signed int references;
  // name
  char *name;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // ex_pathlen
  signed long int ex_pathlen;
  // ex_pcpathlen
  signed long int ex_pcpathlen;
  // ex_flags
  unsigned long int ex_flags;
  // ex_kusage
  unsigned long int ex_kusage;
  // ex_xkusage
  unsigned long int ex_xkusage;
  // ex_nscert
  unsigned long int ex_nscert;
  // skid
  struct asn1_string_st *skid;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // policy_cache
  struct X509_POLICY_CACHE_st *policy_cache;
  // crldp
  struct stack_st_DIST_POINT *crldp;
  // altname
  struct stack_st_GENERAL_NAME *altname;
  // nc
  struct NAME_CONSTRAINTS_st *nc;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // aux
  struct x509_cert_aux_st *aux;
};

struct x509_store_ctx_st
{
  // ctx
  struct x509_store_st *ctx;
  // current_method
  signed int current_method;
  // cert
  struct x509_st *cert;
  // untrusted
  struct stack_st_X509 *untrusted;
  // crls
  struct stack_st_X509_CRL *crls;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // other_ctx
  void *other_ctx;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // check_policy
  signed int (*check_policy)(struct x509_store_ctx_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // valid
  signed int valid;
  // last_untrusted
  signed int last_untrusted;
  // chain
  struct stack_st_X509 *chain;
  // tree
  struct X509_POLICY_TREE_st *tree;
  // explicit_policy
  signed int explicit_policy;
  // error_depth
  signed int error_depth;
  // error
  signed int error;
  // current_cert
  struct x509_st *current_cert;
  // current_issuer
  struct x509_st *current_issuer;
  // current_crl
  struct X509_crl_st *current_crl;
  // current_crl_score
  signed int current_crl_score;
  // current_reasons
  unsigned int current_reasons;
  // parent
  struct x509_store_ctx_st *parent;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct x509_store_st
{
  // cache
  signed int cache;
  // objs
  struct stack_st_X509_OBJECT *objs;
  // get_cert_methods
  struct stack_st_X509_LOOKUP *get_cert_methods;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
};


// compressgained
// file stats.c line 25
static signed long int compressgained;
// config
// file afserver.c line 67
struct anonymous_2 *config;
// entries
// file first_run.c line 47
static struct entry entries[6l] = { { .key="countryName", .value=(unsigned char *)"PL" },
    { .key="stateOrProvinceName", .value=(unsigned char *)"War-Maz" },
    { .key="localityName", .value=(unsigned char *)"Olsztyn" },
    { .key="organizationName", .value=(unsigned char *)"gray-world.net" },
    { .key="organizationalUnitName", .value=(unsigned char *)"APF team" },
    { .key="commonName", .value=(unsigned char *)"Jeremian <jeremian [at] poczta [dot] fm>" } };
// format
// file logging.c line 32
static char format[51l] = { '%', 'Y', '-', '%', 'm', '-', '%', 'd', ' ', '%', 'H', ':', '%', 'M', ':', '%', 'S', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// head
// file logging.c line 30
static struct llnode *head = (struct llnode *)(void *)0;
// home_dir
// file first_run.c line 35
static char *home_dir = (char *)(void *)0;
// home_dir_cer
// file first_run.c line 38
static char *home_dir_cer = (char *)(void *)0;
// home_dir_key
// file first_run.c line 37
static char *home_dir_key = (char *)(void *)0;
// home_dir_store
// file first_run.c line 36
static char *home_dir_store = (char *)(void *)0;
// isseed
// file http_proxy_functions.c line 28
static char isseed;
// long_options
// file afserver.c line 25
static struct option long_options[32l] = { { .name="help", .has_arg=0, .flag=((signed int *)NULL), .val=104 },
    { .name="hostname", .has_arg=1, .flag=((signed int *)NULL), .val=110 },
    { .name="listenport", .has_arg=1, .flag=((signed int *)NULL), .val=108 },
    { .name="manageport", .has_arg=1, .flag=((signed int *)NULL), .val=109 },
    { .name="timeout", .has_arg=1, .flag=((signed int *)NULL), .val=116 },
    { .name="maxidle", .has_arg=1, .flag=((signed int *)NULL), .val=321 },
    { .name="verbose", .has_arg=0, .flag=((signed int *)NULL), .val=118 },
    { .name="users", .has_arg=1, .flag=((signed int *)NULL), .val=117 },
    { .name="clients", .has_arg=1, .flag=((signed int *)NULL), .val=67 },
    { .name="realm", .has_arg=1, .flag=((signed int *)NULL), .val=114 },
    { .name="raclients", .has_arg=1, .flag=((signed int *)NULL), .val=82 },
    { .name="usrpcli", .has_arg=1, .flag=((signed int *)NULL), .val=85 },
    { .name="climode", .has_arg=1, .flag=((signed int *)NULL), .val=77 },
    { .name="cerfile", .has_arg=1, .flag=((signed int *)NULL), .val=99 },
    { .name="cacerfile", .has_arg=1, .flag=((signed int *)NULL), .val=65 },
    { .name="cerdepth", .has_arg=1, .flag=((signed int *)NULL), .val=100 },
    { .name="keyfile", .has_arg=1, .flag=((signed int *)NULL), .val=107 },
    { .name="cfgfile", .has_arg=1, .flag=((signed int *)NULL), .val=102 },
    { .name="proto", .has_arg=1, .flag=((signed int *)NULL), .val=112 },
    { .name="log", .has_arg=1, .flag=((signed int *)NULL), .val=111 },
    { .name="audit", .has_arg=0, .flag=((signed int *)NULL), .val=97 },
    { .name="nossl", .has_arg=0, .flag=((signed int *)NULL), .val=301 },
    { .name="nozlib", .has_arg=0, .flag=((signed int *)NULL), .val=302 },
    { .name="pass", .has_arg=1, .flag=((signed int *)NULL), .val=303 },
    { .name="ipv4", .has_arg=0, .flag=((signed int *)NULL), .val=52 },
    { .name="ipv6", .has_arg=0, .flag=((signed int *)NULL), .val=54 },
    { .name="baseport", .has_arg=0, .flag=((signed int *)NULL), .val=98 },
    { .name="dnslookups", .has_arg=0, .flag=((signed int *)NULL), .val=311 },
    { .name="dateformat", .has_arg=1, .flag=((signed int *)NULL), .val=68 },
    { .name="enableproxy", .has_arg=0, .flag=((signed int *)NULL), .val=80 },
    { .name="version", .has_arg=0, .flag=((signed int *)NULL), .val=86 },
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
// maincond
// file thread_management.c line 29
static union anonymous_31 maincond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// mainmutex
// file thread_management.c line 28
static union anonymous_29 mainmutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// mainthread
// file thread_management.c line 27
static unsigned long int mainthread;
// newmessage
// file server_remoteadmin.c line 26
static char newmessage;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// verlev
// file logging.c line 31
static char verlev;

// AuditListNode_free
// file audit_list_node_struct.c line 81
void AuditListNode_free(struct alnode **aln)
{
  if(!(aln == ((struct alnode **)NULL)))
  {
    if(!(*aln == ((struct alnode *)NULL)))
    {
      free((void *)*aln);
      *aln = (struct alnode *)(void *)0;
    }

  }

}

// AuditListNode_get_connectTime
// file audit_list_node_struct.c line 258
signed long int AuditListNode_get_connectTime(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (signed long int)0;

  else
    return aln->connectTime;
}

// AuditListNode_get_connectTimep
// file audit_list_node_struct.h line 56
signed long int * AuditListNode_get_connectTimep(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return ((signed long int *)NULL);

  else
    return &aln->connectTime;
}

// AuditListNode_get_duration
// file audit_list_node_struct.h line 53
signed long int AuditListNode_get_duration(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (signed long int)0;

  else
    return aln->duration;
}

// AuditListNode_get_nameBuf
// file audit_list_node_struct.h line 50
char * AuditListNode_get_nameBuf(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (char *)(void *)0;

  else
    return aln->nameBuf;
}

// AuditListNode_get_nextNode
// file audit_list_node_struct.h line 54
struct alnode * AuditListNode_get_nextNode(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (struct alnode *)(void *)0;

  else
    return aln->nextNode;
}

// AuditListNode_get_portBuf
// file audit_list_node_struct.h line 51
char * AuditListNode_get_portBuf(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (char *)(void *)0;

  else
    return aln->portBuf;
}

// AuditListNode_get_userId
// file audit_list_node_struct.h line 49
signed int AuditListNode_get_userId(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return -1;

  else
    return aln->userId;
}

// AuditListNode_new
// file audit_list_node_struct.c line 36
struct alnode * AuditListNode_new()
{
  struct alnode *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct alnode) /*168ul*/ );
  tmp = (struct alnode *)return_value_calloc_1;
  if(tmp == ((struct alnode *)NULL))
    return (struct alnode *)(void *)0;

  else
    return tmp;
}

// AuditListNode_new_entry
// file audit_list_node_struct.h line 37
struct alnode * AuditListNode_new_entry(signed int userId, char *nameBuf, char *portBuf, signed long int connectTime, signed long int duration)
{
  struct alnode *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct alnode) /*168ul*/ );
  tmp = (struct alnode *)return_value_calloc_1;
  if(tmp == ((struct alnode *)NULL))
    return (struct alnode *)(void *)0;

  else
  {
    AuditListNode_set_userId(tmp, userId);
    AuditListNode_set_nameBuf(tmp, nameBuf);
    AuditListNode_set_portBuf(tmp, portBuf);
    AuditListNode_set_connectTime(tmp, connectTime);
    AuditListNode_set_duration(tmp, duration);
    return tmp;
  }
}

// AuditListNode_set_connectTime
// file audit_list_node_struct.c line 156
void AuditListNode_set_connectTime(struct alnode *aln, signed long int connectTime)
{
  if(!(aln == ((struct alnode *)NULL)))
    aln->connectTime = connectTime;

}

// AuditListNode_set_duration
// file audit_list_node_struct.c line 173
void AuditListNode_set_duration(struct alnode *aln, signed long int duration)
{
  if(!(aln == ((struct alnode *)NULL)))
    aln->duration = duration;

}

// AuditListNode_set_nameBuf
// file audit_list_node_struct.c line 120
void AuditListNode_set_nameBuf(struct alnode *aln, char *nameBuf)
{
  if(!(aln == ((struct alnode *)NULL)))
  {
    memset((void *)aln->nameBuf, 0, (unsigned long int)7);
    __builtin_strncpy(aln->nameBuf, nameBuf, (unsigned long int)6);
  }

}

// AuditListNode_set_nextNode
// file audit_list_node_struct.c line 190
void AuditListNode_set_nextNode(struct alnode *aln, struct alnode *nextNode)
{
  if(!(aln == ((struct alnode *)NULL)))
    aln->nextNode = nextNode;

}

// AuditListNode_set_portBuf
// file audit_list_node_struct.c line 138
void AuditListNode_set_portBuf(struct alnode *aln, char *portBuf)
{
  if(!(aln == ((struct alnode *)NULL)))
  {
    memset((void *)aln->portBuf, 0, (unsigned long int)7);
    __builtin_strncpy(aln->portBuf, portBuf, (unsigned long int)6);
  }

}

// AuditListNode_set_userId
// file audit_list_node_struct.c line 103
void AuditListNode_set_userId(struct alnode *aln, signed int userId)
{
  if(!(aln == ((struct alnode *)NULL)))
    aln->userId = userId;

}

// AuditList_clear
// file audit_list_struct.h line 39
void AuditList_clear(struct auditlist *al)
{
  struct alnode *return_value_AuditList_get_first_1;
  if(!(al == ((struct auditlist *)NULL)))
    do
    {
      return_value_AuditList_get_first_1=AuditList_get_first(al);
      if(return_value_AuditList_get_first_1 == ((struct alnode *)NULL))
        break;

      AuditList_delete_first(al);
    }
    while((_Bool)1);

}

// AuditList_delete_first
// file audit_list_struct.h line 38
void AuditList_delete_first(struct auditlist *al)
{
  struct alnode *tmp;
  tmp=AuditList_get_first(al);
  if(!(tmp == ((struct alnode *)NULL)))
  {
    if(tmp == al->tail)
    {
      al->tail = (struct alnode *)(void *)0;
      al->head = al->tail;
    }

    else
      al->head=AuditListNode_get_nextNode(tmp);
    AuditListNode_free(&tmp);
  }

}

// AuditList_free
// file audit_list_struct.c line 53
void AuditList_free(struct auditlist **al)
{
  if(!(al == ((struct auditlist **)NULL)))
  {
    if(!(*al == ((struct auditlist *)NULL)))
    {
      AuditList_clear(*al);
      free((void *)*al);
      *al = (struct auditlist *)(void *)0;
    }

  }

}

// AuditList_get_first
// file audit_list_struct.h line 37
struct alnode * AuditList_get_first(struct auditlist *al)
{
  if(al == ((struct auditlist *)NULL))
    return (struct alnode *)(void *)0;

  else
    return al->head;
}

// AuditList_insert_back
// file audit_list_struct.h line 36
void AuditList_insert_back(struct auditlist *al, struct alnode *aln)
{
  if(!(al == ((struct auditlist *)NULL)))
  {
    if(!(aln == ((struct alnode *)NULL)))
    {
      if(!(al->tail == ((struct alnode *)NULL)))
        al->tail->nextNode = aln;

      else
        al->head = aln;
      al->tail = aln;
      aln->nextNode = (struct alnode *)(void *)0;
    }

  }

}

// AuditList_new
// file audit_list_struct.c line 36
struct auditlist * AuditList_new()
{
  struct auditlist *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct auditlist) /*16ul*/ );
  tmp = (struct auditlist *)return_value_calloc_1;
  if(tmp == ((struct auditlist *)NULL))
    return (struct auditlist *)(void *)0;

  else
    return tmp;
}

// BufListNode_free
// file buf_list_node_struct.c line 76
void BufListNode_free(struct blnode **bln)
{
  if(!(bln == ((struct blnode **)NULL)))
  {
    if(!(*bln == ((struct blnode *)NULL)))
    {
      if(!((*bln)->message == ((unsigned char *)NULL)))
      {
        free((void *)(*bln)->message);
        (*bln)->message = (unsigned char *)(void *)0;
      }

      free((void *)*bln);
      *bln = (struct blnode *)(void *)0;
    }

  }

}

// BufListNode_get_actPtr
// file buf_list_node_struct.h line 42
signed int BufListNode_get_actPtr(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return -1;

  else
    return bln->actPtr;
}

// BufListNode_get_message
// file buf_list_node_struct.c line 221
unsigned char * BufListNode_get_message(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return (unsigned char *)(void *)0;

  else
    return bln->message;
}

// BufListNode_get_msgLen
// file buf_list_node_struct.c line 204
signed int BufListNode_get_msgLen(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return -1;

  else
    return bln->msgLen;
}

// BufListNode_get_nextNode
// file buf_list_node_struct.c line 238
struct blnode * BufListNode_get_nextNode(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return (struct blnode *)(void *)0;

  else
    return bln->nextNode;
}

// BufListNode_new
// file buf_list_node_struct.c line 36
struct blnode * BufListNode_new()
{
  struct blnode *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct blnode) /*24ul*/ );
  tmp = (struct blnode *)return_value_calloc_1;
  if(tmp == ((struct blnode *)NULL))
    return (struct blnode *)(void *)0;

  else
    return tmp;
}

// BufListNode_new_message
// file buf_list_node_struct.h line 33
struct blnode * BufListNode_new_message(signed int actPtr, signed int msgLen, unsigned char *message)
{
  struct blnode *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct blnode) /*24ul*/ );
  tmp = (struct blnode *)return_value_calloc_1;
  if(tmp == ((struct blnode *)NULL))
    return (struct blnode *)(void *)0;

  else
  {
    BufListNode_set_message(tmp, message, msgLen);
    BufListNode_set_actPtr(tmp, actPtr);
    return tmp;
  }
}

// BufListNode_readMessage
// file buf_list_node_struct.h line 47
unsigned char * BufListNode_readMessage(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return (unsigned char *)(void *)0;

  else
  {
    signed int return_value_BufListNode_get_actPtr_1;
    return_value_BufListNode_get_actPtr_1=BufListNode_get_actPtr(bln);
    return &bln->message[(signed long int)return_value_BufListNode_get_actPtr_1];
  }
}

// BufListNode_readMessageLength
// file buf_list_node_struct.h line 48
signed int BufListNode_readMessageLength(struct blnode *bln)
{
  signed int tmp = 0;
  if(bln == ((struct blnode *)NULL))
    return -1;

  else
  {
    unsigned char *return_value_BufListNode_get_message_1;
    return_value_BufListNode_get_message_1=BufListNode_get_message(bln);
    if(return_value_BufListNode_get_message_1 == ((unsigned char *)NULL))
      return -1;

    else
    {
      signed int return_value_BufListNode_get_msgLen_2;
      return_value_BufListNode_get_msgLen_2=BufListNode_get_msgLen(bln);
      signed int return_value_BufListNode_get_actPtr_3;
      return_value_BufListNode_get_actPtr_3=BufListNode_get_actPtr(bln);
      tmp = return_value_BufListNode_get_msgLen_2 - return_value_BufListNode_get_actPtr_3;
      if(!(tmp >= 0))
        return 0;

      else
        return tmp;
    }
  }
}

// BufListNode_set_actPtr
// file buf_list_node_struct.h line 37
void BufListNode_set_actPtr(struct blnode *bln, signed int actPtr)
{
  if(!(bln == ((struct blnode *)NULL)))
    bln->actPtr = actPtr;

}

// BufListNode_set_message
// file buf_list_node_struct.c line 137
void BufListNode_set_message(struct blnode *bln, unsigned char *message, signed int msgLen)
{
  if(!(bln == ((struct blnode *)NULL)))
  {
    if(!(bln->message == ((unsigned char *)NULL)))
    {
      free((void *)bln->message);
      bln->message = (unsigned char *)(void *)0;
    }

    BufListNode_set_actPtr(bln, 0);
    BufListNode_set_msgLen(bln, 0);
    if(!(message == ((unsigned char *)NULL)))
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)1, (unsigned long int)msgLen);
      bln->message = (unsigned char *)return_value_calloc_1;
      if(!(bln->message == ((unsigned char *)NULL)))
      {
        memcpy((void *)bln->message, (const void *)message, (unsigned long int)msgLen);
        BufListNode_set_msgLen(bln, msgLen);
      }

    }

  }

}

// BufListNode_set_msgLen
// file buf_list_node_struct.c line 119
void BufListNode_set_msgLen(struct blnode *bln, signed int msgLen)
{
  if(!(bln == ((struct blnode *)NULL)))
    bln->msgLen = msgLen;

}

// BufListNode_set_nextNode
// file buf_list_node_struct.c line 170
void BufListNode_set_nextNode(struct blnode *bln, struct blnode *nextNode)
{
  if(!(bln == ((struct blnode *)NULL)))
    bln->nextNode = nextNode;

}

// BufList_clear
// file buf_list_struct.h line 39
void BufList_clear(struct buflist *bl)
{
  struct blnode *return_value_BufList_get_first_1;
  if(!(bl == ((struct buflist *)NULL)))
    do
    {
      return_value_BufList_get_first_1=BufList_get_first(bl);
      if(return_value_BufList_get_first_1 == ((struct blnode *)NULL))
        break;

      BufList_delete_first(bl);
    }
    while((_Bool)1);

}

// BufList_delete_first
// file buf_list_struct.h line 38
void BufList_delete_first(struct buflist *bl)
{
  struct blnode *tmp;
  tmp=BufList_get_first(bl);
  if(!(tmp == ((struct blnode *)NULL)))
  {
    if(tmp == bl->tail)
    {
      bl->tail = (struct blnode *)(void *)0;
      bl->head = bl->tail;
    }

    else
      bl->head=BufListNode_get_nextNode(tmp);
    BufListNode_free(&tmp);
  }

}

// BufList_free
// file buf_list_struct.c line 53
void BufList_free(struct buflist **bl)
{
  if(!(bl == ((struct buflist **)NULL)))
  {
    if(!(*bl == ((struct buflist *)NULL)))
    {
      BufList_clear(*bl);
      free((void *)*bl);
      *bl = (struct buflist *)(void *)0;
    }

  }

}

// BufList_get_first
// file buf_list_struct.h line 37
struct blnode * BufList_get_first(struct buflist *bl)
{
  if(bl == ((struct buflist *)NULL))
    return (struct blnode *)(void *)0;

  else
    return bl->head;
}

// BufList_insert_back
// file buf_list_struct.h line 36
void BufList_insert_back(struct buflist *bl, struct blnode *bln)
{
  if(!(bl == ((struct buflist *)NULL)))
  {
    if(!(bln == ((struct blnode *)NULL)))
    {
      if(!(bl->tail == ((struct blnode *)NULL)))
        bl->tail->nextNode = bln;

      else
        bl->head = bln;
      bl->tail = bln;
      bln->nextNode = (struct blnode *)(void *)0;
    }

  }

}

// BufList_new
// file buf_list_struct.c line 36
struct buflist * BufList_new()
{
  struct buflist *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct buflist) /*16ul*/ );
  tmp = (struct buflist *)return_value_calloc_1;
  if(tmp == ((struct buflist *)NULL))
    return (struct buflist *)(void *)0;

  else
    return tmp;
}

// ConnectClient_create_users
// file connect_client_struct.h line 113
signed int ConnectClient_create_users(struct anonymous_3 *cc)
{
  signed int i;
  signed int limit;
  if(cc == ((struct anonymous_3 *)NULL))
    return 1;

  else
  {
    limit=ConnectClient_get_limit(cc);
    if(limit == -1)
      return 2;

    else
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc((unsigned long int)limit * sizeof(signed int) /*4ul*/ );
      cc->users = (signed int *)return_value_malloc_1;
      if(cc->users == ((signed int *)NULL))
        return 3;

      else
      {
        i = 0;
        for( ; !(i >= limit); i = i + 1)
          cc->users[(signed long int)i] = -1;
        return 0;
      }
    }
  }
}

// ConnectClient_decrease_connected
// file connect_client_struct.h line 116
void ConnectClient_decrease_connected(struct anonymous_3 *cc)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
  {
    signed int return_value_ConnectClient_get_connected_1;
    return_value_ConnectClient_get_connected_1=ConnectClient_get_connected(cc);
    ConnectClient_set_connected(cc, return_value_ConnectClient_get_connected_1 - 1);
  }

}

// ConnectClient_free
// file connect_client_struct.c line 73
void ConnectClient_free(struct anonymous_3 **cc)
{
  struct anonymous_1 *sftmp;
  struct auditlist *altmp;
  if(!(cc == ((struct anonymous_3 **)NULL)))
  {
    if(!(*cc == ((struct anonymous_3 *)NULL)))
    {
      sftmp=ConnectClient_get_sslFd(*cc);
      altmp=ConnectClient_get_auditList(*cc);
      SslFd_free(&sftmp);
      AuditList_free(&altmp);
      if(!((*cc)->users == ((signed int *)NULL)))
      {
        free((void *)(*cc)->users);
        (*cc)->users = (signed int *)(void *)0;
      }

      if(!((*cc)->sClientId == ((char *)NULL)))
      {
        free((void *)(*cc)->sClientId);
        (*cc)->sClientId = (char *)(void *)0;
      }

      free((void *)*cc);
      *cc = (struct anonymous_3 *)(void *)0;
    }

  }

}

// ConnectClient_get_auditList
// file connect_client_struct.h line 109
struct auditlist * ConnectClient_get_auditList(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return (struct auditlist *)(void *)0;

  else
    return cc->auditList;
}

// ConnectClient_get_clientId
// file connect_client_struct.h line 101
signed int ConnectClient_get_clientId(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return -1;

  else
    return cc->clientId;
}

// ConnectClient_get_connectTime
// file connect_client_struct.h line 102
signed long int ConnectClient_get_connectTime(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return (signed long int)0;

  else
    return cc->connectTime;
}

// ConnectClient_get_connected
// file connect_client_struct.h line 97
signed int ConnectClient_get_connected(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return -1;

  else
    return cc->connected;
}

// ConnectClient_get_header
// file connect_client_struct.h line 110
struct anonymous_8 * ConnectClient_get_header(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return (struct anonymous_8 *)(void *)0;

  else
    return cc->header;
}

// ConnectClient_get_lastActivity
// file connect_client_struct.h line 103
signed long int ConnectClient_get_lastActivity(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return (signed long int)0;

  else
    return cc->lastActivity;
}

// ConnectClient_get_limit
// file connect_client_struct.h line 98
signed int ConnectClient_get_limit(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return -1;

  else
    return cc->limit;
}

// ConnectClient_get_listenFd
// file connect_client_struct.h line 99
signed int ConnectClient_get_listenFd(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return -1;

  else
    return cc->listenFd;
}

// ConnectClient_get_listenFdp
// file connect_client_struct.h line 117
signed int * ConnectClient_get_listenFdp(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return (signed int *)(void *)0;

  else
    return &cc->listenFd;
}

// ConnectClient_get_multi
// file connect_client_struct.h line 108
char ConnectClient_get_multi(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return (char)0;

  else
    return cc->multi;
}

// ConnectClient_get_nameBuf
// file connect_client_struct.h line 105
char * ConnectClient_get_nameBuf(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return (char *)(void *)0;

  else
    return cc->nameBuf;
}

// ConnectClient_get_portBuf
// file connect_client_struct.h line 106
char * ConnectClient_get_portBuf(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return (char *)(void *)0;

  else
    return cc->portBuf;
}

// ConnectClient_get_sClientId
// file connect_client_struct.h line 104
char * ConnectClient_get_sClientId(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return (char *)(void *)0;

  else
    return cc->sClientId;
}

// ConnectClient_get_sslFd
// file connect_client_struct.h line 94
struct anonymous_1 * ConnectClient_get_sslFd(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return (struct anonymous_1 *)(void *)0;

  else
    return cc->sslFd;
}

// ConnectClient_get_state
// file connect_client_struct.h line 93
char ConnectClient_get_state(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return (char)-1;

  else
    return cc->state;
}

// ConnectClient_get_task
// file connect_client_struct.h line 111
struct anonymous_13 * ConnectClient_get_task(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return (struct anonymous_13 *)(void *)0;

  else
    return cc->task;
}

// ConnectClient_get_timer
// file connect_client_struct.c line 484
struct timeval ConnectClient_get_timer(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
  {
    struct timeval return_value_timeval_create_1;
    return_value_timeval_create_1=timeval_create((signed long int)0, (signed long int)0);
    return return_value_timeval_create_1;
  }

  return cc->timer;
}

// ConnectClient_get_timerp
// file connect_client_struct.h line 114
struct timeval * ConnectClient_get_timerp(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return (struct timeval *)(void *)0;

  else
    return &cc->timer;
}

// ConnectClient_get_tunnelType
// file connect_client_struct.h line 107
char ConnectClient_get_tunnelType(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return (char)-1;

  else
    return cc->tunnelType;
}

// ConnectClient_get_users
// file connect_client_struct.h line 96
signed int * ConnectClient_get_users(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return (signed int *)(void *)0;

  else
    return cc->users;
}

// ConnectClient_get_usrCliPair
// file connect_client_struct.h line 100
signed int ConnectClient_get_usrCliPair(struct anonymous_3 *cc)
{
  if(cc == ((struct anonymous_3 *)NULL))
    return -1;

  else
    return cc->usrCliPair;
}

// ConnectClient_increase_connected
// file connect_client_struct.h line 115
void ConnectClient_increase_connected(struct anonymous_3 *cc)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
  {
    signed int return_value_ConnectClient_get_connected_1;
    return_value_ConnectClient_get_connected_1=ConnectClient_get_connected(cc);
    ConnectClient_set_connected(cc, return_value_ConnectClient_get_connected_1 + 1);
  }

}

// ConnectClient_new
// file connect_client_struct.h line 69
struct anonymous_3 * ConnectClient_new()
{
  struct anonymous_3 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_3) /*256ul*/ );
  tmp = (struct anonymous_3 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_3 *)NULL))
    return (struct anonymous_3 *)(void *)0;

  else
  {
    tmp->sslFd=SslFd_new();
    if(tmp->sslFd == ((struct anonymous_1 *)NULL))
    {
      ConnectClient_free(&tmp);
      return (struct anonymous_3 *)(void *)0;
    }

    else
    {
      tmp->auditList=AuditList_new();
      if(tmp->auditList == ((struct auditlist *)NULL))
      {
        ConnectClient_free(&tmp);
        return (struct anonymous_3 *)(void *)0;
      }

      else
      {
        tmp->header=HeaderBuffer_new();
        if(tmp->header == ((struct anonymous_8 *)NULL))
        {
          ConnectClient_free(&tmp);
          return (struct anonymous_3 *)(void *)0;
        }

        else
          return tmp;
      }
    }
  }
}

// ConnectClient_set_auditList
// file connect_client_struct.c line 390
void ConnectClient_set_auditList(struct anonymous_3 *cc, struct auditlist *al)
{
  struct auditlist *altmp;
  if(!(cc == ((struct anonymous_3 *)NULL)))
  {
    altmp=ConnectClient_get_auditList(cc);
    AuditList_free(&altmp);
    cc->auditList = al;
  }

}

// ConnectClient_set_clientId
// file connect_client_struct.h line 81
void ConnectClient_set_clientId(struct anonymous_3 *cc, signed int clientId)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
    cc->clientId = clientId;

}

// ConnectClient_set_connectTime
// file connect_client_struct.h line 82
void ConnectClient_set_connectTime(struct anonymous_3 *cc, signed long int connectTime)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
    cc->connectTime = connectTime;

}

// ConnectClient_set_connected
// file connect_client_struct.h line 77
void ConnectClient_set_connected(struct anonymous_3 *cc, signed int connected)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
    cc->connected = connected;

}

// ConnectClient_set_header
// file connect_client_struct.c line 410
void ConnectClient_set_header(struct anonymous_3 *cc, struct anonymous_8 *hb)
{
  struct anonymous_8 *hbtmp;
  if(!(cc == ((struct anonymous_3 *)NULL)))
  {
    hbtmp=ConnectClient_get_header(cc);
    HeaderBuffer_free(&hbtmp);
    cc->header = hb;
  }

}

// ConnectClient_set_lastActivity
// file connect_client_struct.h line 83
void ConnectClient_set_lastActivity(struct anonymous_3 *cc, signed long int lastActivity)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
    cc->lastActivity = lastActivity;

}

// ConnectClient_set_limit
// file connect_client_struct.h line 78
void ConnectClient_set_limit(struct anonymous_3 *cc, signed int limit)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
    cc->limit = limit;

}

// ConnectClient_set_listenFd
// file connect_client_struct.c line 217
void ConnectClient_set_listenFd(struct anonymous_3 *cc, signed int listenFd)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
    cc->listenFd = listenFd;

}

// ConnectClient_set_multi
// file connect_client_struct.h line 88
void ConnectClient_set_multi(struct anonymous_3 *cc, char multi)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
    cc->multi = multi;

}

// ConnectClient_set_nameBuf
// file connect_client_struct.h line 85
void ConnectClient_set_nameBuf(struct anonymous_3 *cc, char *nameBuf)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
  {
    memset((void *)cc->nameBuf, 0, (unsigned long int)128);
    __builtin_strncpy(cc->nameBuf, nameBuf, (unsigned long int)127);
  }

}

// ConnectClient_set_portBuf
// file connect_client_struct.h line 86
void ConnectClient_set_portBuf(struct anonymous_3 *cc, char *portBuf)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
  {
    memset((void *)cc->portBuf, 0, (unsigned long int)7);
    __builtin_strncpy(cc->portBuf, portBuf, (unsigned long int)6);
  }

}

// ConnectClient_set_sClientId
// file connect_client_struct.h line 84
void ConnectClient_set_sClientId(struct anonymous_3 *cc, char *sClientId)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
    string_cp(&cc->sClientId, sClientId);

}

// ConnectClient_set_sslFd
// file connect_client_struct.c line 126
void ConnectClient_set_sslFd(struct anonymous_3 *cc, struct anonymous_1 *sf)
{
  struct anonymous_1 *sftmp;
  if(!(cc == ((struct anonymous_3 *)NULL)))
  {
    sftmp=ConnectClient_get_sslFd(cc);
    SslFd_free(&sftmp);
    cc->sslFd = sf;
  }

}

// ConnectClient_set_state
// file connect_client_struct.h line 73
void ConnectClient_set_state(struct anonymous_3 *cc, char state)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
    cc->state = state;

}

// ConnectClient_set_task
// file connect_client_struct.h line 91
void ConnectClient_set_task(struct anonymous_3 *cc, struct anonymous_13 *task)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
  {
    if(!(cc->task == ((struct anonymous_13 *)NULL)))
      Task_free(&cc->task);

    cc->task = task;
  }

}

// ConnectClient_set_timer
// file connect_client_struct.h line 75
void ConnectClient_set_timer(struct anonymous_3 *cc, struct timeval timer)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
    cc->timer = timer;

}

// ConnectClient_set_tunnelType
// file connect_client_struct.h line 87
void ConnectClient_set_tunnelType(struct anonymous_3 *cc, char tunnelType)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
    cc->tunnelType = tunnelType;

}

// ConnectClient_set_users
// file connect_client_struct.c line 163
void ConnectClient_set_users(struct anonymous_3 *cc, signed int *users)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
  {
    if(!(cc->users == ((signed int *)NULL)))
      free((void *)cc->users);

    cc->users = users;
  }

}

// ConnectClient_set_usrCliPair
// file connect_client_struct.h line 80
void ConnectClient_set_usrCliPair(struct anonymous_3 *cc, signed int usrCliPair)
{
  if(!(cc == ((struct anonymous_3 *)NULL)))
    cc->usrCliPair = usrCliPair;

}

// ConnectUser_free
// file connect_user_struct.c line 66
void ConnectUser_free(struct anonymous_4 **cu)
{
  struct buflist *bftmp;
  struct anonymous_6 *ustmp;
  if(!(cu == ((struct anonymous_4 **)NULL)))
  {
    if(!(*cu == ((struct anonymous_4 *)NULL)))
    {
      bftmp=ConnectUser_get_bufList(*cu);
      ustmp=ConnectUser_get_stats(*cu);
      BufList_free(&bftmp);
      UserStats_free(&ustmp);
      free((void *)*cu);
      *cu = (struct anonymous_4 *)(void *)0;
    }

  }

}

// ConnectUser_get_bufList
// file connect_user_struct.h line 64
struct buflist * ConnectUser_get_bufList(struct anonymous_4 *cu)
{
  if(cu == ((struct anonymous_4 *)NULL))
    return (struct buflist *)(void *)0;

  else
    return cu->bufList;
}

// ConnectUser_get_connFd
// file connect_user_struct.h line 58
signed int ConnectUser_get_connFd(struct anonymous_4 *cu)
{
  if(cu == ((struct anonymous_4 *)NULL))
    return -1;

  else
    return cu->connFd;
}

// ConnectUser_get_connectTime
// file connect_user_struct.h line 61
signed long int ConnectUser_get_connectTime(struct anonymous_4 *cu)
{
  if(cu == ((struct anonymous_4 *)NULL))
    return (signed long int)0;

  else
    return cu->connectTime;
}

// ConnectUser_get_nameBuf
// file connect_user_struct.h line 62
char * ConnectUser_get_nameBuf(struct anonymous_4 *cu)
{
  if(cu == ((struct anonymous_4 *)NULL))
    return (char *)(void *)0;

  else
    return cu->nameBuf;
}

// ConnectUser_get_portBuf
// file connect_user_struct.h line 63
char * ConnectUser_get_portBuf(struct anonymous_4 *cu)
{
  if(cu == ((struct anonymous_4 *)NULL))
    return (char *)(void *)0;

  else
    return cu->portBuf;
}

// ConnectUser_get_state
// file connect_user_struct.h line 57
char ConnectUser_get_state(struct anonymous_4 *cu)
{
  if(cu == ((struct anonymous_4 *)NULL))
    return (char)0;

  else
    return cu->state;
}

// ConnectUser_get_stats
// file connect_user_struct.h line 65
struct anonymous_6 * ConnectUser_get_stats(struct anonymous_4 *cu)
{
  if(cu == ((struct anonymous_4 *)NULL))
    return (struct anonymous_6 *)(void *)0;

  else
    return cu->stats;
}

// ConnectUser_get_userId
// file connect_user_struct.h line 60
signed int ConnectUser_get_userId(struct anonymous_4 *cu)
{
  if(cu == ((struct anonymous_4 *)NULL))
    return -1;

  else
    return cu->userId;
}

// ConnectUser_get_whatClient
// file connect_user_struct.h line 59
signed int ConnectUser_get_whatClient(struct anonymous_4 *cu)
{
  if(cu == ((struct anonymous_4 *)NULL))
    return -1;

  else
    return cu->whatClient;
}

// ConnectUser_new
// file connect_user_struct.h line 43
struct anonymous_4 * ConnectUser_new()
{
  struct anonymous_4 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_4) /*176ul*/ );
  tmp = (struct anonymous_4 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_4 *)NULL))
    return (struct anonymous_4 *)(void *)0;

  else
  {
    tmp->bufList=BufList_new();
    if(tmp->bufList == ((struct buflist *)NULL))
    {
      ConnectUser_free(&tmp);
      return (struct anonymous_4 *)(void *)0;
    }

    else
    {
      tmp->stats=UserStats_new();
      if(tmp->stats == ((struct anonymous_6 *)NULL))
      {
        ConnectUser_free(&tmp);
        return (struct anonymous_4 *)(void *)0;
      }

      else
        return tmp;
    }
  }
}

// ConnectUser_set_bufList
// file connect_user_struct.c line 215
void ConnectUser_set_bufList(struct anonymous_4 *cu, struct buflist *bufList)
{
  struct buflist *bftmp;
  if(!(cu == ((struct anonymous_4 *)NULL)))
  {
    bftmp=ConnectUser_get_bufList(cu);
    BufList_free(&bftmp);
    cu->bufList = bufList;
  }

}

// ConnectUser_set_connFd
// file connect_user_struct.h line 48
void ConnectUser_set_connFd(struct anonymous_4 *cu, signed int connFd)
{
  if(!(cu == ((struct anonymous_4 *)NULL)))
    cu->connFd = connFd;

}

// ConnectUser_set_connectTime
// file connect_user_struct.h line 51
void ConnectUser_set_connectTime(struct anonymous_4 *cu, signed long int connectTime)
{
  if(!(cu == ((struct anonymous_4 *)NULL)))
    cu->connectTime = connectTime;

}

// ConnectUser_set_nameBuf
// file connect_user_struct.c line 179
void ConnectUser_set_nameBuf(struct anonymous_4 *cu, char *nameBuf)
{
  if(!(cu == ((struct anonymous_4 *)NULL)))
  {
    memset((void *)cu->nameBuf, 0, (unsigned long int)128);
    __builtin_strncpy(cu->nameBuf, nameBuf, (unsigned long int)127);
  }

}

// ConnectUser_set_portBuf
// file connect_user_struct.c line 197
void ConnectUser_set_portBuf(struct anonymous_4 *cu, char *portBuf)
{
  if(!(cu == ((struct anonymous_4 *)NULL)))
  {
    memset((void *)cu->portBuf, 0, (unsigned long int)7);
    __builtin_strncpy(cu->portBuf, portBuf, (unsigned long int)6);
  }

}

// ConnectUser_set_state
// file connect_user_struct.h line 47
void ConnectUser_set_state(struct anonymous_4 *cu, char state)
{
  if(!(cu == ((struct anonymous_4 *)NULL)))
    cu->state = state;

}

// ConnectUser_set_stats
// file connect_user_struct.c line 235
void ConnectUser_set_stats(struct anonymous_4 *cu, struct anonymous_6 *stats)
{
  struct anonymous_6 *ustmp;
  if(!(cu == ((struct anonymous_4 *)NULL)))
  {
    ustmp=ConnectUser_get_stats(cu);
    UserStats_free(&ustmp);
    cu->stats = stats;
  }

}

// ConnectUser_set_userId
// file connect_user_struct.h line 50
void ConnectUser_set_userId(struct anonymous_4 *cu, signed int userId)
{
  if(!(cu == ((struct anonymous_4 *)NULL)))
    cu->userId = userId;

}

// ConnectUser_set_whatClient
// file connect_user_struct.h line 49
void ConnectUser_set_whatClient(struct anonymous_4 *cu, signed int whatClient)
{
  if(!(cu == ((struct anonymous_4 *)NULL)))
    cu->whatClient = whatClient;

}

// HeaderBuffer_free
// file header_buffer_struct.h line 32
void HeaderBuffer_free(struct anonymous_8 **hb)
{
  if(!(hb == ((struct anonymous_8 **)NULL)))
  {
    if(!(*hb == ((struct anonymous_8 *)NULL)))
    {
      free((void *)*hb);
      *hb = (struct anonymous_8 *)(void *)0;
    }

  }

}

// HeaderBuffer_new
// file header_buffer_struct.h line 30
struct anonymous_8 * HeaderBuffer_new()
{
  struct anonymous_8 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_8) /*12ul*/ );
  tmp = (struct anonymous_8 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_8 *)NULL))
    return (struct anonymous_8 *)(void *)0;

  else
    return tmp;
}

// HeaderBuffer_restore
// file header_buffer_struct.h line 36
void HeaderBuffer_restore(struct anonymous_8 *hb, unsigned char *buff)
{
  if(!(hb == ((struct anonymous_8 *)NULL)))
  {
    memcpy((void *)buff, (const void *)hb->tab, (unsigned long int)5);
    hb->readed = 0;
  }

}

// HeaderBuffer_store
// file header_buffer_struct.h line 35
void HeaderBuffer_store(struct anonymous_8 *hb, unsigned char *buff, signed int n)
{
  if(!(hb == ((struct anonymous_8 *)NULL)))
  {
    if(!(hb->readed + n >= 6))
    {
      if(n >= 1)
      {
        memcpy((void *)&hb->tab[(signed long int)hb->readed], (const void *)buff, (unsigned long int)n);
        hb->readed = hb->readed + n;
      }

    }

  }

}

// HeaderBuffer_to_read
// file header_buffer_struct.h line 34
signed int HeaderBuffer_to_read(struct anonymous_8 *hb)
{
  if(hb == ((struct anonymous_8 *)NULL))
    return -1;

  else
    return 5 - hb->readed;
}

// RCTdata_free
// file remove_client_task.h line 43
void RCTdata_free(void **ptr)
{
  struct anonymous_25 **data = (struct anonymous_25 **)ptr;
  if(!(data == ((struct anonymous_25 **)NULL)))
  {
    if(!(*data == ((struct anonymous_25 *)NULL)))
    {
      free((void *)*data);
      *data = (struct anonymous_25 *)(void *)0;
    }

  }

}

// RCTdata_new
// file remove_client_task.h line 40
struct anonymous_25 * RCTdata_new(struct anonymous_2 *config, signed int realm, signed int client, char ra, char reason, struct anonymous_22 *set, struct anonymous_22 *wset)
{
  struct anonymous_25 *tmp;
  if(config == ((struct anonymous_2 *)NULL))
    return (struct anonymous_25 *)(void *)0;

  else
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_25) /*40ul*/ );
    tmp = (struct anonymous_25 *)return_value_calloc_1;
    if(tmp == ((struct anonymous_25 *)NULL))
      return (struct anonymous_25 *)(void *)0;

    else
    {
      tmp->config = config;
      tmp->realm = realm;
      tmp->client = client;
      tmp->ra = ra;
      tmp->reason = reason;
      tmp->set = set;
      tmp->wset = wset;
      return tmp;
    }
  }
}

// RCTfunction
// file remove_client_task.h line 45
void RCTfunction(void *data)
{
  struct anonymous_3 **clientsTable;
  struct anonymous_5 **realmsTable;
  struct anonymous_25 *ptr;
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_1;
  signed int return_value_SslFd_get_fd_2;
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_3;
  signed int return_value_SslFd_get_fd_4;
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_5;
  signed int return_value_SslFd_get_fd_6;
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_7;
  struct ssl_st *return_value_SslFd_get_ssl_8;
  char *return_value_get_realmname_9;
  char *tmp_if_expr_12;
  char *return_value_get_raclientname_10;
  char *return_value_get_clientname_11;
  if(!(data == NULL))
  {
    ptr = (struct anonymous_25 *)data;
    realmsTable=ServerConfiguration_get_realmsTable(ptr->config);
    if(!(ptr->ra == 0))
      clientsTable=ServerRealm_get_raClientsTable(realmsTable[(signed long int)ptr->realm]);

    else
      clientsTable=ServerRealm_get_clientsTable(realmsTable[(signed long int)ptr->realm]);
    switch((signed int)ptr->reason)
    {
      case 0:
      {
        return_value_ConnectClient_get_sslFd_1=ConnectClient_get_sslFd(clientsTable[(signed long int)ptr->client]);
        return_value_SslFd_get_fd_2=SslFd_get_fd(return_value_ConnectClient_get_sslFd_1);
        close(return_value_SslFd_get_fd_2);
        return_value_ConnectClient_get_sslFd_3=ConnectClient_get_sslFd(clientsTable[(signed long int)ptr->client]);
        return_value_SslFd_get_fd_4=SslFd_get_fd(return_value_ConnectClient_get_sslFd_3);
        return_value_ConnectClient_get_sslFd_5=ConnectClient_get_sslFd(clientsTable[(signed long int)ptr->client]);
        return_value_SslFd_get_fd_6=SslFd_get_fd(return_value_ConnectClient_get_sslFd_5);
        ptr->set->__fds_bits[(signed long int)(return_value_SslFd_get_fd_4 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = ptr->set->__fds_bits[(signed long int)(return_value_SslFd_get_fd_4 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_SslFd_get_fd_6 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        return_value_ConnectClient_get_sslFd_7=ConnectClient_get_sslFd(clientsTable[(signed long int)ptr->client]);
        return_value_SslFd_get_ssl_8=SslFd_get_ssl(return_value_ConnectClient_get_sslFd_7);
        SSL_clear(return_value_SslFd_get_ssl_8);
        ConnectClient_set_state(clientsTable[(signed long int)ptr->client], (char)0);
        ServerRealm_decrease_connectedClients(realmsTable[(signed long int)ptr->realm]);
        return_value_get_realmname_9=get_realmname(ptr->config, ptr->realm);
        if(!(ptr->ra == 0))
        {
          return_value_get_raclientname_10=get_raclientname(realmsTable[(signed long int)ptr->realm], ptr->client);
          tmp_if_expr_12 = return_value_get_raclientname_10;
        }

        else
        {
          return_value_get_clientname_11=get_clientname(realmsTable[(signed long int)ptr->realm], ptr->client);
          tmp_if_expr_12 = return_value_get_clientname_11;
        }
        aflog((char)2, (char)32, "realm[%s]: Client[%s]%s: SSL_accept failed (timeout)", return_value_get_realmname_9, tmp_if_expr_12, ptr->ra != 0 ? " (ra)" : "");
        break;
      }
      case 1:
      {
        char *return_value_get_realmname_13;
        return_value_get_realmname_13=get_realmname(ptr->config, ptr->realm);
        char *return_value_get_clientname_14;
        return_value_get_clientname_14=get_clientname(realmsTable[(signed long int)ptr->realm], ptr->client);
        aflog((char)2, (char)32, "realm[%s]: Client[%s]: too long idle --> DROPPING", return_value_get_realmname_13, return_value_get_clientname_14);
        remove_client(realmsTable[(signed long int)ptr->realm], ptr->client, ptr->set, ptr->wset, (struct anonymous_16 *)(void *)0);
      }
    }
    ConnectClient_set_task(clientsTable[(signed long int)ptr->client], (struct anonymous_13 *)(void *)0);
  }

}

// SSL_readn
// file network.c line 483
signed int SSL_readn(struct ssl_st *fd, unsigned char *buf, signed int amount)
{
  signed int sent;
  signed int n;
  sent = 0;
  while(!(sent >= amount))
  {
    n=SSL_read(fd, (void *)(buf + (signed long int)sent), amount - sent);
    if(!(n == -1))
      sent = sent + n;

    if(n == 0)
      return 0;

    if(n == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(!(*return_value___errno_location_1 == 11))
        return 0;

    }

  }
  return amount;
}

// SSL_writen
// file network.c line 454
signed int SSL_writen(struct ssl_st *fd, unsigned char *buf, signed int amount)
{
  signed int sent;
  signed int n;
  sent = 0;
  while(!(sent >= amount))
  {
    n=SSL_write(fd, (const void *)(buf + (signed long int)sent), amount - sent);
    if(!(n == -1))
      sent = sent + n;

    if(n == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(!(*return_value___errno_location_1 == 11))
        return 0;

    }

  }
  return amount;
}

// ServerConfiguration_free
// file server_configuration_struct.c line 54
void ServerConfiguration_free(struct anonymous_2 **sc)
{
  signed int i;
  if(!(sc == ((struct anonymous_2 **)NULL)))
  {
    if(!(*sc == ((struct anonymous_2 *)NULL)))
    {
      if(!((*sc)->certificateFile == ((char *)NULL)))
      {
        free((void *)(*sc)->certificateFile);
        (*sc)->certificateFile = (char *)(void *)0;
      }

      if(!((*sc)->cacertificateFile == ((char *)NULL)))
      {
        free((void *)(*sc)->cacertificateFile);
        (*sc)->cacertificateFile = (char *)(void *)0;
      }

      if(!((*sc)->cacertificatePath == ((char *)NULL)))
      {
        free((void *)(*sc)->cacertificatePath);
        (*sc)->cacertificatePath = (char *)(void *)0;
      }

      if(!((*sc)->sCertificateDepth == ((char *)NULL)))
      {
        free((void *)(*sc)->sCertificateDepth);
        (*sc)->sCertificateDepth = (char *)(void *)0;
      }

      if(!((*sc)->keysFile == ((char *)NULL)))
      {
        free((void *)(*sc)->keysFile);
        (*sc)->keysFile = (char *)(void *)0;
      }

      if(!((*sc)->dateFormat == ((char *)NULL)))
      {
        free((void *)(*sc)->dateFormat);
        (*sc)->dateFormat = (char *)(void *)0;
      }

      if(!((*sc)->realmsTable == ((struct anonymous_5 **)NULL)))
      {
        i = 0;
        for( ; !(i >= (*sc)->realmsNumber); i = i + 1)
          if(!((*sc)->realmsTable[(signed long int)i] == ((struct anonymous_5 *)NULL)))
            ServerRealm_free(&(*sc)->realmsTable[(signed long int)i]);

        free((void *)(*sc)->realmsTable);
        (*sc)->realmsTable = (struct anonymous_5 **)(void *)0;
      }

      free((void *)*sc);
      *sc = (struct anonymous_2 *)(void *)0;
    }

  }

}

// ServerConfiguration_get_cacertificateFile
// file server_configuration_struct.h line 57
char * ServerConfiguration_get_cacertificateFile(struct anonymous_2 *sc)
{
  if(sc == ((struct anonymous_2 *)NULL))
    return (char *)(void *)0;

  else
    return sc->cacertificateFile;
}

// ServerConfiguration_get_cacertificatePath
// file server_configuration_struct.c line 309
char * ServerConfiguration_get_cacertificatePath(struct anonymous_2 *sc)
{
  if(sc == ((struct anonymous_2 *)NULL))
    return (char *)(void *)0;

  else
    return sc->cacertificatePath;
}

// ServerConfiguration_get_certificateDepth
// file server_configuration_struct.c line 329
signed int ServerConfiguration_get_certificateDepth(struct anonymous_2 *sc)
{
  if(sc == ((struct anonymous_2 *)NULL))
    return -1;

  else
    return sc->certificateDepth;
}

// ServerConfiguration_get_certificateFile
// file server_configuration_struct.h line 56
char * ServerConfiguration_get_certificateFile(struct anonymous_2 *sc)
{
  if(sc == ((struct anonymous_2 *)NULL))
    return (char *)(void *)0;

  else
    return sc->certificateFile;
}

// ServerConfiguration_get_dateFormat
// file server_configuration_struct.h line 62
char * ServerConfiguration_get_dateFormat(struct anonymous_2 *sc)
{
  if(sc == ((struct anonymous_2 *)NULL))
    return (char *)(void *)0;

  else
    return sc->dateFormat;
}

// ServerConfiguration_get_keysFile
// file server_configuration_struct.h line 61
char * ServerConfiguration_get_keysFile(struct anonymous_2 *sc)
{
  if(sc == ((struct anonymous_2 *)NULL))
    return (char *)(void *)0;

  else
    return sc->keysFile;
}

// ServerConfiguration_get_realmsNumber
// file server_configuration_struct.h line 63
signed int ServerConfiguration_get_realmsNumber(struct anonymous_2 *sc)
{
  if(sc == ((struct anonymous_2 *)NULL))
    return -1;

  else
    return sc->realmsNumber;
}

// ServerConfiguration_get_realmsTable
// file server_configuration_struct.h line 65
struct anonymous_5 ** ServerConfiguration_get_realmsTable(struct anonymous_2 *sc)
{
  if(sc == ((struct anonymous_2 *)NULL))
    return (struct anonymous_5 **)(void *)0;

  else
    return sc->realmsTable;
}

// ServerConfiguration_get_sCertificateDepth
// file server_configuration_struct.h line 59
char * ServerConfiguration_get_sCertificateDepth(struct anonymous_2 *sc)
{
  if(sc == ((struct anonymous_2 *)NULL))
    return (char *)(void *)0;

  else
    return sc->sCertificateDepth;
}

// ServerConfiguration_get_startTime
// file server_configuration_struct.h line 64
signed long int ServerConfiguration_get_startTime(struct anonymous_2 *sc)
{
  if(sc == ((struct anonymous_2 *)NULL))
    return (signed long int)0;

  else
    return sc->startTime;
}

// ServerConfiguration_new
// file server_configuration_struct.h line 41
struct anonymous_2 * ServerConfiguration_new()
{
  struct anonymous_2 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_2) /*80ul*/ );
  tmp = (struct anonymous_2 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_2 *)NULL))
    return (struct anonymous_2 *)(void *)0;

  else
    return tmp;
}

// ServerConfiguration_set_cacertificateFile
// file server_configuration_struct.h line 46
void ServerConfiguration_set_cacertificateFile(struct anonymous_2 *sc, char *cacertificateFile)
{
  if(!(sc == ((struct anonymous_2 *)NULL)))
    string_cp(&sc->cacertificateFile, cacertificateFile);

}

// ServerConfiguration_set_cacertificatePath
// file server_configuration_struct.c line 144
void ServerConfiguration_set_cacertificatePath(struct anonymous_2 *sc, char *cacertificatePath)
{
  if(!(sc == ((struct anonymous_2 *)NULL)))
    string_cp(&sc->cacertificatePath, cacertificatePath);

}

// ServerConfiguration_set_certificateDepth
// file server_configuration_struct.c line 163
void ServerConfiguration_set_certificateDepth(struct anonymous_2 *sc, signed int certificateDepth)
{
  if(!(sc == ((struct anonymous_2 *)NULL)))
    sc->certificateDepth = certificateDepth;

}

// ServerConfiguration_set_certificateFile
// file server_configuration_struct.h line 45
void ServerConfiguration_set_certificateFile(struct anonymous_2 *sc, char *certificateFile)
{
  if(!(sc == ((struct anonymous_2 *)NULL)))
    string_cp(&sc->certificateFile, certificateFile);

}

// ServerConfiguration_set_dateFormat
// file server_configuration_struct.h line 51
void ServerConfiguration_set_dateFormat(struct anonymous_2 *sc, char *dateFormat)
{
  if(!(sc == ((struct anonymous_2 *)NULL)))
    string_cp(&sc->dateFormat, dateFormat);

}

// ServerConfiguration_set_keysFile
// file server_configuration_struct.h line 50
void ServerConfiguration_set_keysFile(struct anonymous_2 *sc, char *keysFile)
{
  if(!(sc == ((struct anonymous_2 *)NULL)))
    string_cp(&sc->keysFile, keysFile);

}

// ServerConfiguration_set_realmsNumber
// file server_configuration_struct.h line 52
void ServerConfiguration_set_realmsNumber(struct anonymous_2 *sc, signed int realmsNumber)
{
  if(!(sc == ((struct anonymous_2 *)NULL)))
    sc->realmsNumber = realmsNumber;

}

// ServerConfiguration_set_realmsTable
// file server_configuration_struct.h line 54
void ServerConfiguration_set_realmsTable(struct anonymous_2 *sc, struct anonymous_5 **realmsTable)
{
  signed int i;
  if(!(sc == ((struct anonymous_2 *)NULL)))
  {
    if(!(sc->realmsTable == ((struct anonymous_5 **)NULL)))
    {
      i = 0;
      for( ; !(i >= sc->realmsNumber); i = i + 1)
        if(!(sc->realmsTable[(signed long int)i] == ((struct anonymous_5 *)NULL)))
          ServerRealm_free(&sc->realmsTable[(signed long int)i]);

      free((void *)sc->realmsTable);
      sc->realmsTable = (struct anonymous_5 **)(void *)0;
    }

    sc->realmsTable = realmsTable;
  }

}

// ServerConfiguration_set_sCertificateDepth
// file server_configuration_struct.h line 48
void ServerConfiguration_set_sCertificateDepth(struct anonymous_2 *sc, char *sCertificateDepth)
{
  if(!(sc == ((struct anonymous_2 *)NULL)))
    string_cp(&sc->sCertificateDepth, sCertificateDepth);

}

// ServerConfiguration_set_startTime
// file server_configuration_struct.h line 53
void ServerConfiguration_set_startTime(struct anonymous_2 *sc, signed long int startTime)
{
  if(!(sc == ((struct anonymous_2 *)NULL)))
    sc->startTime = startTime;

}

// ServerRealm_decrease_connectedClients
// file server_realm_struct.h line 141
void ServerRealm_decrease_connectedClients(struct anonymous_5 *sr)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
  {
    signed int return_value_ServerRealm_get_connectedClients_1;
    return_value_ServerRealm_get_connectedClients_1=ServerRealm_get_connectedClients(sr);
    ServerRealm_set_connectedClients(sr, return_value_ServerRealm_get_connectedClients_1 - 1);
  }

}

// ServerRealm_decrease_connectedRaClients
// file server_realm_struct.h line 143
void ServerRealm_decrease_connectedRaClients(struct anonymous_5 *sr)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
  {
    signed int return_value_ServerRealm_get_connectedRaClients_1;
    return_value_ServerRealm_get_connectedRaClients_1=ServerRealm_get_connectedRaClients(sr);
    ServerRealm_set_connectedRaClients(sr, return_value_ServerRealm_get_connectedRaClients_1 - 1);
  }

}

// ServerRealm_decrease_connectedUsers
// file server_realm_struct.h line 139
void ServerRealm_decrease_connectedUsers(struct anonymous_5 *sr)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
  {
    signed int return_value_ServerRealm_get_connectedUsers_1;
    return_value_ServerRealm_get_connectedUsers_1=ServerRealm_get_connectedUsers(sr);
    ServerRealm_set_connectedUsers(sr, return_value_ServerRealm_get_connectedUsers_1 - 1);
  }

}

// ServerRealm_free
// file server_realm_struct.c line 58
void ServerRealm_free(struct anonymous_5 **sr)
{
  signed int i;
  if(!(sr == ((struct anonymous_5 **)NULL)))
  {
    if(!(*sr == ((struct anonymous_5 *)NULL)))
    {
      if(!((*sr)->hostName == ((char *)NULL)))
      {
        free((void *)(*sr)->hostName);
        (*sr)->hostName = (char *)(void *)0;
      }

      if(!((*sr)->sUsersLimit == ((char *)NULL)))
      {
        free((void *)(*sr)->sUsersLimit);
        (*sr)->sUsersLimit = (char *)(void *)0;
      }

      if(!((*sr)->sClientsLimit == ((char *)NULL)))
      {
        free((void *)(*sr)->sClientsLimit);
        (*sr)->sClientsLimit = (char *)(void *)0;
      }

      if(!((*sr)->sRaClientsLimit == ((char *)NULL)))
      {
        free((void *)(*sr)->sRaClientsLimit);
        (*sr)->sRaClientsLimit = (char *)(void *)0;
      }

      if(!((*sr)->sUsersPerClient == ((char *)NULL)))
      {
        free((void *)(*sr)->sUsersPerClient);
        (*sr)->sUsersPerClient = (char *)(void *)0;
      }

      if(!((*sr)->sClientMode == ((char *)NULL)))
      {
        free((void *)(*sr)->sClientMode);
        (*sr)->sClientMode = (char *)(void *)0;
      }

      if(!((*sr)->sTimeout == ((char *)NULL)))
      {
        free((void *)(*sr)->sTimeout);
        (*sr)->sTimeout = (char *)(void *)0;
      }

      if(!((*sr)->realmName == ((char *)NULL)))
      {
        free((void *)(*sr)->realmName);
        (*sr)->realmName = (char *)(void *)0;
      }

      if(!((*sr)->clientAddress == ((struct sockaddr *)NULL)))
      {
        free((void *)(*sr)->clientAddress);
        (*sr)->clientAddress = (struct sockaddr *)(void *)0;
      }

      if(!((*sr)->usersTable == ((struct anonymous_4 **)NULL)))
      {
        i = 0;
        for( ; !(i >= (*sr)->usersLimit); i = i + 1)
          if(!((*sr)->usersTable[(signed long int)i] == ((struct anonymous_4 *)NULL)))
            ConnectUser_free(&(*sr)->usersTable[(signed long int)i]);

        free((void *)(*sr)->usersTable);
        (*sr)->usersTable = (struct anonymous_4 **)(void *)0;
      }

      if(!((*sr)->clientsTable == ((struct anonymous_3 **)NULL)))
      {
        i = 0;
        for( ; !(i >= (*sr)->clientsLimit); i = i + 1)
          if(!((*sr)->clientsTable[(signed long int)i] == ((struct anonymous_3 *)NULL)))
            ConnectClient_free(&(*sr)->clientsTable[(signed long int)i]);

        free((void *)(*sr)->clientsTable);
        (*sr)->clientsTable = (struct anonymous_3 **)(void *)0;
      }

      if(!((*sr)->raClientsTable == ((struct anonymous_3 **)NULL)))
      {
        i = 0;
        for( ; !(i >= (*sr)->raClientsLimit); i = i + 1)
          if(!((*sr)->raClientsTable[(signed long int)i] == ((struct anonymous_3 *)NULL)))
            ConnectClient_free(&(*sr)->raClientsTable[(signed long int)i]);

        free((void *)(*sr)->raClientsTable);
        (*sr)->raClientsTable = (struct anonymous_3 **)(void *)0;
      }

      if(!((*sr)->usersClientsTable == ((struct anonymous_7 **)NULL)))
      {
        i = 0;
        for( ; !(i >= (*sr)->userClientPairs); i = i + 1)
          if(!((*sr)->usersClientsTable[(signed long int)i] == ((struct anonymous_7 *)NULL)))
            UsrCli_free(&(*sr)->usersClientsTable[(signed long int)i]);

        free((void *)(*sr)->usersClientsTable);
        (*sr)->usersClientsTable = (struct anonymous_7 **)(void *)0;
      }

      free((void *)*sr);
      *sr = (struct anonymous_5 *)(void *)0;
    }

  }

}

// ServerRealm_get_addressLength
// file server_realm_struct.h line 131
unsigned int ServerRealm_get_addressLength(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (unsigned int)0;

  else
    return sr->addressLength;
}

// ServerRealm_get_auditOn
// file server_realm_struct.h line 130
char ServerRealm_get_auditOn(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (char)0;

  else
    return sr->auditOn;
}

// ServerRealm_get_basePortOn
// file server_realm_struct.h line 129
char ServerRealm_get_basePortOn(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (char)0;

  else
    return sr->basePortOn;
}

// ServerRealm_get_clientAddress
// file server_realm_struct.h line 132
struct sockaddr * ServerRealm_get_clientAddress(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (struct sockaddr *)(void *)0;

  else
    return sr->clientAddress;
}

// ServerRealm_get_clientMode
// file server_realm_struct.h line 122
signed int ServerRealm_get_clientMode(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return 0;

  else
    return sr->clientMode;
}

// ServerRealm_get_clientsCounter
// file server_realm_struct.h line 124
signed int ServerRealm_get_clientsCounter(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return -1;

  else
    return sr->clientsCounter;
}

// ServerRealm_get_clientsLimit
// file server_realm_struct.h line 116
signed int ServerRealm_get_clientsLimit(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return -1;

  else
    return sr->clientsLimit;
}

// ServerRealm_get_clientsTable
// file server_realm_struct.h line 134
struct anonymous_3 ** ServerRealm_get_clientsTable(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (struct anonymous_3 **)(void *)0;

  else
    return sr->clientsTable;
}

// ServerRealm_get_connectedClients
// file server_realm_struct.h line 115
signed int ServerRealm_get_connectedClients(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return -1;

  else
    return sr->connectedClients;
}

// ServerRealm_get_connectedRaClients
// file server_realm_struct.h line 117
signed int ServerRealm_get_connectedRaClients(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return -1;

  else
    return sr->connectedRaClients;
}

// ServerRealm_get_connectedUsers
// file server_realm_struct.h line 113
signed int ServerRealm_get_connectedUsers(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return -1;

  else
    return sr->connectedUsers;
}

// ServerRealm_get_dnsLookupsOn
// file server_realm_struct.h line 128
char ServerRealm_get_dnsLookupsOn(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (char)0;

  else
    return sr->dnsLookupsOn;
}

// ServerRealm_get_hostName
// file server_realm_struct.h line 103
char * ServerRealm_get_hostName(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->hostName;
}

// ServerRealm_get_maxIdle
// file server_realm_struct.h line 121
signed int ServerRealm_get_maxIdle(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return 0;

  else
    return sr->maxIdle;
}

// ServerRealm_get_password
// file server_realm_struct.h line 112
unsigned char * ServerRealm_get_password(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (unsigned char *)(void *)0;

  else
    return sr->password;
}

// ServerRealm_get_raClientsLimit
// file server_realm_struct.h line 118
signed int ServerRealm_get_raClientsLimit(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return -1;

  else
    return sr->raClientsLimit;
}

// ServerRealm_get_raClientsTable
// file server_realm_struct.h line 135
struct anonymous_3 ** ServerRealm_get_raClientsTable(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (struct anonymous_3 **)(void *)0;

  else
    return sr->raClientsTable;
}

// ServerRealm_get_realmName
// file server_realm_struct.h line 111
char * ServerRealm_get_realmName(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->realmName;
}

// ServerRealm_get_realmType
// file server_realm_struct.h line 126
char ServerRealm_get_realmType(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (char)0;

  else
    return sr->realmType;
}

// ServerRealm_get_sClientMode
// file server_realm_struct.h line 108
char * ServerRealm_get_sClientMode(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->sClientMode;
}

// ServerRealm_get_sClientsLimit
// file server_realm_struct.h line 105
char * ServerRealm_get_sClientsLimit(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->sClientsLimit;
}

// ServerRealm_get_sMaxIdle
// file server_realm_struct.h line 110
char * ServerRealm_get_sMaxIdle(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->sMaxIdle;
}

// ServerRealm_get_sRaClientsLimit
// file server_realm_struct.h line 106
char * ServerRealm_get_sRaClientsLimit(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->sRaClientsLimit;
}

// ServerRealm_get_sTimeout
// file server_realm_struct.h line 109
char * ServerRealm_get_sTimeout(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->sTimeout;
}

// ServerRealm_get_sUsersLimit
// file server_realm_struct.h line 104
char * ServerRealm_get_sUsersLimit(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->sUsersLimit;
}

// ServerRealm_get_sUsersPerClient
// file server_realm_struct.h line 107
char * ServerRealm_get_sUsersPerClient(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->sUsersPerClient;
}

// ServerRealm_get_timeout
// file server_realm_struct.h line 120
signed int ServerRealm_get_timeout(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return 0;

  else
    return sr->timeout;
}

// ServerRealm_get_tunnelType
// file server_realm_struct.h line 127
char ServerRealm_get_tunnelType(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (char)0;

  else
    return sr->tunnelType;
}

// ServerRealm_get_userClientPairs
// file server_realm_struct.h line 123
signed int ServerRealm_get_userClientPairs(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return 0;

  else
    return sr->userClientPairs;
}

// ServerRealm_get_usersClientsTable
// file server_realm_struct.h line 136
struct anonymous_7 ** ServerRealm_get_usersClientsTable(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (struct anonymous_7 **)(void *)0;

  else
    return sr->usersClientsTable;
}

// ServerRealm_get_usersCounter
// file server_realm_struct.h line 125
signed int ServerRealm_get_usersCounter(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return -1;

  else
    return sr->usersCounter;
}

// ServerRealm_get_usersLimit
// file server_realm_struct.h line 114
signed int ServerRealm_get_usersLimit(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return -1;

  else
    return sr->usersLimit;
}

// ServerRealm_get_usersPerClient
// file server_realm_struct.h line 119
signed int ServerRealm_get_usersPerClient(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return -1;

  else
    return sr->usersPerClient;
}

// ServerRealm_get_usersTable
// file server_realm_struct.h line 133
struct anonymous_4 ** ServerRealm_get_usersTable(struct anonymous_5 *sr)
{
  if(sr == ((struct anonymous_5 *)NULL))
    return (struct anonymous_4 **)(void *)0;

  else
    return sr->usersTable;
}

// ServerRealm_increase_clientsCounter
// file server_realm_struct.h line 145
void ServerRealm_increase_clientsCounter(struct anonymous_5 *sr)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
  {
    signed int return_value_ServerRealm_get_clientsCounter_1;
    return_value_ServerRealm_get_clientsCounter_1=ServerRealm_get_clientsCounter(sr);
    ServerRealm_set_clientsCounter(sr, return_value_ServerRealm_get_clientsCounter_1 + 1);
  }

}

// ServerRealm_increase_connectedClients
// file server_realm_struct.h line 140
void ServerRealm_increase_connectedClients(struct anonymous_5 *sr)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
  {
    signed int return_value_ServerRealm_get_connectedClients_1;
    return_value_ServerRealm_get_connectedClients_1=ServerRealm_get_connectedClients(sr);
    ServerRealm_set_connectedClients(sr, return_value_ServerRealm_get_connectedClients_1 + 1);
  }

}

// ServerRealm_increase_connectedRaClients
// file server_realm_struct.h line 142
void ServerRealm_increase_connectedRaClients(struct anonymous_5 *sr)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
  {
    signed int return_value_ServerRealm_get_connectedRaClients_1;
    return_value_ServerRealm_get_connectedRaClients_1=ServerRealm_get_connectedRaClients(sr);
    ServerRealm_set_connectedRaClients(sr, return_value_ServerRealm_get_connectedRaClients_1 + 1);
  }

}

// ServerRealm_increase_connectedUsers
// file server_realm_struct.h line 138
void ServerRealm_increase_connectedUsers(struct anonymous_5 *sr)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
  {
    signed int return_value_ServerRealm_get_connectedUsers_1;
    return_value_ServerRealm_get_connectedUsers_1=ServerRealm_get_connectedUsers(sr);
    ServerRealm_set_connectedUsers(sr, return_value_ServerRealm_get_connectedUsers_1 + 1);
  }

}

// ServerRealm_increase_usersCounter
// file server_realm_struct.h line 144
void ServerRealm_increase_usersCounter(struct anonymous_5 *sr)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
  {
    signed int return_value_ServerRealm_get_usersCounter_1;
    return_value_ServerRealm_get_usersCounter_1=ServerRealm_get_usersCounter(sr);
    ServerRealm_set_usersCounter(sr, return_value_ServerRealm_get_usersCounter_1 + 1);
  }

}

// ServerRealm_new
// file server_realm_struct.h line 64
struct anonymous_5 * ServerRealm_new()
{
  struct anonymous_5 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_5) /*184ul*/ );
  tmp = (struct anonymous_5 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_5 *)NULL))
    return (struct anonymous_5 *)(void *)0;

  else
  {
    tmp->password[(signed long int)0] = (unsigned char)1;
    tmp->password[(signed long int)1] = (unsigned char)2;
    tmp->password[(signed long int)2] = (unsigned char)3;
    tmp->password[(signed long int)3] = (unsigned char)4;
    return tmp;
  }
}

// ServerRealm_set_addressLength
// file server_realm_struct.h line 96
void ServerRealm_set_addressLength(struct anonymous_5 *sr, unsigned int addressLength)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->addressLength = addressLength;

}

// ServerRealm_set_auditOn
// file server_realm_struct.h line 95
void ServerRealm_set_auditOn(struct anonymous_5 *sr, char auditOn)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->auditOn = auditOn;

}

// ServerRealm_set_basePortOn
// file server_realm_struct.h line 94
void ServerRealm_set_basePortOn(struct anonymous_5 *sr, char basePortOn)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->basePortOn = basePortOn;

}

// ServerRealm_set_clientAddress
// file server_realm_struct.h line 97
void ServerRealm_set_clientAddress(struct anonymous_5 *sr, struct sockaddr *clientAddress)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
  {
    if(!(sr->clientAddress == ((struct sockaddr *)NULL)))
    {
      free((void *)sr->clientAddress);
      sr->clientAddress = (struct sockaddr *)(void *)0;
    }

    sr->clientAddress = clientAddress;
  }

}

// ServerRealm_set_clientMode
// file server_realm_struct.h line 87
void ServerRealm_set_clientMode(struct anonymous_5 *sr, signed int clientMode)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->clientMode = clientMode;

}

// ServerRealm_set_clientsCounter
// file server_realm_struct.c line 510
void ServerRealm_set_clientsCounter(struct anonymous_5 *sr, signed int clientsCounter)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->clientsCounter = clientsCounter;

}

// ServerRealm_set_clientsLimit
// file server_realm_struct.h line 81
void ServerRealm_set_clientsLimit(struct anonymous_5 *sr, signed int clientsLimit)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->clientsLimit = clientsLimit;

}

// ServerRealm_set_clientsTable
// file server_realm_struct.h line 99
void ServerRealm_set_clientsTable(struct anonymous_5 *sr, struct anonymous_3 **clientsTable)
{
  signed int i;
  if(!(sr == ((struct anonymous_5 *)NULL)))
  {
    if(!(sr->clientsTable == ((struct anonymous_3 **)NULL)))
    {
      i = 0;
      for( ; !(i >= sr->clientsLimit); i = i + 1)
        if(!(sr->clientsTable[(signed long int)i] == ((struct anonymous_3 *)NULL)))
          ConnectClient_free(&sr->clientsTable[(signed long int)i]);

      free((void *)sr->clientsTable);
      sr->clientsTable = (struct anonymous_3 **)(void *)0;
    }

    sr->clientsTable = clientsTable;
  }

}

// ServerRealm_set_connectedClients
// file server_realm_struct.h line 80
void ServerRealm_set_connectedClients(struct anonymous_5 *sr, signed int connectedClients)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->connectedClients = connectedClients;

}

// ServerRealm_set_connectedRaClients
// file server_realm_struct.h line 82
void ServerRealm_set_connectedRaClients(struct anonymous_5 *sr, signed int connectedRaClients)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->connectedRaClients = connectedRaClients;

}

// ServerRealm_set_connectedUsers
// file server_realm_struct.h line 78
void ServerRealm_set_connectedUsers(struct anonymous_5 *sr, signed int connectedUsers)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->connectedUsers = connectedUsers;

}

// ServerRealm_set_dnsLookupsOn
// file server_realm_struct.h line 93
void ServerRealm_set_dnsLookupsOn(struct anonymous_5 *sr, char dnsLookupsOn)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->dnsLookupsOn = dnsLookupsOn;

}

// ServerRealm_set_hostName
// file server_realm_struct.h line 68
void ServerRealm_set_hostName(struct anonymous_5 *sr, char *hostName)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    string_cp(&sr->hostName, hostName);

}

// ServerRealm_set_maxIdle
// file server_realm_struct.h line 86
void ServerRealm_set_maxIdle(struct anonymous_5 *sr, signed int maxIdle)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->maxIdle = maxIdle;

}

// ServerRealm_set_password
// file server_realm_struct.h line 77
void ServerRealm_set_password(struct anonymous_5 *sr, unsigned char *password)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    memcpy((void *)sr->password, (const void *)password, (unsigned long int)4);

}

// ServerRealm_set_raClientsLimit
// file server_realm_struct.h line 83
void ServerRealm_set_raClientsLimit(struct anonymous_5 *sr, signed int raClientsLimit)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->raClientsLimit = raClientsLimit;

}

// ServerRealm_set_raClientsTable
// file server_realm_struct.h line 100
void ServerRealm_set_raClientsTable(struct anonymous_5 *sr, struct anonymous_3 **raClientsTable)
{
  signed int i;
  if(!(sr == ((struct anonymous_5 *)NULL)))
  {
    if(!(sr->raClientsTable == ((struct anonymous_3 **)NULL)))
    {
      i = 0;
      for( ; !(i >= sr->raClientsLimit); i = i + 1)
        if(!(sr->raClientsTable[(signed long int)i] == ((struct anonymous_3 *)NULL)))
          ConnectClient_free(&sr->raClientsTable[(signed long int)i]);

      free((void *)sr->raClientsTable);
      sr->raClientsTable = (struct anonymous_3 **)(void *)0;
    }

    sr->raClientsTable = raClientsTable;
  }

}

// ServerRealm_set_realmName
// file server_realm_struct.h line 76
void ServerRealm_set_realmName(struct anonymous_5 *sr, char *realmName)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    string_cp(&sr->realmName, realmName);

}

// ServerRealm_set_realmType
// file server_realm_struct.h line 91
void ServerRealm_set_realmType(struct anonymous_5 *sr, char realmType)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->realmType = realmType;

}

// ServerRealm_set_sClientMode
// file server_realm_struct.h line 73
void ServerRealm_set_sClientMode(struct anonymous_5 *sr, char *sClientMode)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    string_cp(&sr->sClientMode, sClientMode);

}

// ServerRealm_set_sClientsLimit
// file server_realm_struct.h line 70
void ServerRealm_set_sClientsLimit(struct anonymous_5 *sr, char *sClientsLimit)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    string_cp(&sr->sClientsLimit, sClientsLimit);

}

// ServerRealm_set_sMaxIdle
// file server_realm_struct.h line 75
void ServerRealm_set_sMaxIdle(struct anonymous_5 *sr, char *sMaxIdle)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    string_cp(&sr->sMaxIdle, sMaxIdle);

}

// ServerRealm_set_sRaClientsLimit
// file server_realm_struct.h line 71
void ServerRealm_set_sRaClientsLimit(struct anonymous_5 *sr, char *sRaClientsLimit)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    string_cp(&sr->sRaClientsLimit, sRaClientsLimit);

}

// ServerRealm_set_sTimeout
// file server_realm_struct.h line 74
void ServerRealm_set_sTimeout(struct anonymous_5 *sr, char *sTimeout)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    string_cp(&sr->sTimeout, sTimeout);

}

// ServerRealm_set_sUsersLimit
// file server_realm_struct.h line 69
void ServerRealm_set_sUsersLimit(struct anonymous_5 *sr, char *sUsersLimit)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    string_cp(&sr->sUsersLimit, sUsersLimit);

}

// ServerRealm_set_sUsersPerClient
// file server_realm_struct.h line 72
void ServerRealm_set_sUsersPerClient(struct anonymous_5 *sr, char *sUsersPerClient)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    string_cp(&sr->sUsersPerClient, sUsersPerClient);

}

// ServerRealm_set_timeout
// file server_realm_struct.h line 85
void ServerRealm_set_timeout(struct anonymous_5 *sr, signed int timeout)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->timeout = timeout;

}

// ServerRealm_set_tunnelType
// file server_realm_struct.h line 92
void ServerRealm_set_tunnelType(struct anonymous_5 *sr, char tunnelType)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->tunnelType = tunnelType;

}

// ServerRealm_set_userClientPairs
// file server_realm_struct.h line 88
void ServerRealm_set_userClientPairs(struct anonymous_5 *sr, signed int userClientPairs)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->userClientPairs = userClientPairs;

}

// ServerRealm_set_usersClientsTable
// file server_realm_struct.h line 101
void ServerRealm_set_usersClientsTable(struct anonymous_5 *sr, struct anonymous_7 **usersClientsTable)
{
  signed int i;
  if(!(sr == ((struct anonymous_5 *)NULL)))
  {
    if(!(sr->usersClientsTable == ((struct anonymous_7 **)NULL)))
    {
      i = 0;
      for( ; !(i >= sr->userClientPairs); i = i + 1)
        if(!(sr->usersClientsTable[(signed long int)i] == ((struct anonymous_7 *)NULL)))
          UsrCli_free(&sr->usersClientsTable[(signed long int)i]);

      free((void *)sr->usersClientsTable);
      sr->usersClientsTable = (struct anonymous_7 **)(void *)0;
    }

    sr->usersClientsTable = usersClientsTable;
  }

}

// ServerRealm_set_usersCounter
// file server_realm_struct.c line 527
void ServerRealm_set_usersCounter(struct anonymous_5 *sr, signed int usersCounter)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->usersCounter = usersCounter;

}

// ServerRealm_set_usersLimit
// file server_realm_struct.h line 79
void ServerRealm_set_usersLimit(struct anonymous_5 *sr, signed int usersLimit)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->usersLimit = usersLimit;

}

// ServerRealm_set_usersPerClient
// file server_realm_struct.h line 84
void ServerRealm_set_usersPerClient(struct anonymous_5 *sr, signed int usersPerClient)
{
  if(!(sr == ((struct anonymous_5 *)NULL)))
    sr->usersPerClient = usersPerClient;

}

// ServerRealm_set_usersTable
// file server_realm_struct.h line 98
void ServerRealm_set_usersTable(struct anonymous_5 *sr, struct anonymous_4 **usersTable)
{
  signed int i;
  if(!(sr == ((struct anonymous_5 *)NULL)))
  {
    if(!(sr->usersTable == ((struct anonymous_4 **)NULL)))
    {
      i = 0;
      for( ; !(i >= sr->usersLimit); i = i + 1)
        if(!(sr->usersTable[(signed long int)i] == ((struct anonymous_4 *)NULL)))
          ConnectUser_free(&sr->usersTable[(signed long int)i]);

      free((void *)sr->usersTable);
      sr->usersTable = (struct anonymous_4 **)(void *)0;
    }

    sr->usersTable = usersTable;
  }

}

// SslFd_free
// file ssl_fd_struct.c line 54
void SslFd_free(struct anonymous_1 **sf)
{
  if(!(sf == ((struct anonymous_1 **)NULL)))
  {
    if(!(*sf == ((struct anonymous_1 *)NULL)))
    {
      if(!((*sf)->ssl == ((struct ssl_st *)NULL)))
      {
        SSL_free((*sf)->ssl);
        (*sf)->ssl = (struct ssl_st *)(void *)0;
      }

      free((void *)*sf);
      *sf = (struct anonymous_1 *)(void *)0;
    }

  }

}

// SslFd_get_fd
// file ssl_fd_struct.h line 41
signed int SslFd_get_fd(struct anonymous_1 *sf)
{
  if(sf == ((struct anonymous_1 *)NULL))
    return -1;

  else
    return sf->fd;
}

// SslFd_get_message
// file ssl_fd_struct.h line 45
signed int SslFd_get_message(char type, struct anonymous_1 *sf, unsigned char *buf, signed int amount)
{
  signed int length;
  unsigned long int elen;
  if(sf == ((struct anonymous_1 *)NULL) || buf == ((unsigned char *)NULL))
    return -1;

  else
  {
    aflog((char)16, (char)2, "get_message: ssl:%s zlib:%s length:%d", ((signed int)type & 4) != 0 ? "yes" : "no", ((signed int)type & 8) != 0 ? "yes" : "no", amount);
    if(!(amount >= 0))
    {
      if(!((4 & (signed int)type) == 0))
      {
        signed int return_value_SSL_read_1;
        return_value_SSL_read_1=SSL_read(sf->ssl, (void *)buf, -amount);
        return return_value_SSL_read_1;
      }

      else
      {
        signed long int return_value_read_2;
        return_value_read_2=read(sf->fd, (void *)buf, (unsigned long int)-amount);
        return (signed int)return_value_read_2;
      }
    }

    if(!((8 & (signed int)type) == 0))
    {
      static unsigned char bufor[9000l];
      if(!((4 & (signed int)type) == 0))
        length=SSL_readn(sf->ssl, bufor, amount & 0xBFFF);

      else
        length=readn(sf->fd, bufor, amount & 0xBFFF);
      if(!(length >= 1))
        return length;

      elen = (unsigned long int)8096;
      if(!((0x4000 & amount) == 0))
        uncompress(buf, &elen, bufor, (unsigned long int)length);

      else
      {
        memcpy((void *)buf, (const void *)bufor, (unsigned long int)length);
        elen = (unsigned long int)length;
      }
      return (signed int)elen;
    }

    else
      if(!((4 & (signed int)type) == 0))
      {
        signed int return_value_SSL_readn_3;
        return_value_SSL_readn_3=SSL_readn(sf->ssl, buf, amount);
        return return_value_SSL_readn_3;
      }

      else
      {
        signed int return_value_readn_4;
        return_value_readn_4=readn(sf->fd, buf, amount);
        return return_value_readn_4;
      }
  }
}

// SslFd_get_ssl
// file ssl_fd_struct.h line 42
struct ssl_st * SslFd_get_ssl(struct anonymous_1 *sf)
{
  if(sf == ((struct anonymous_1 *)NULL))
    return (struct ssl_st *)(void *)0;

  else
    return sf->ssl;
}

// SslFd_new
// file ssl_fd_struct.h line 33
struct anonymous_1 * SslFd_new()
{
  struct anonymous_1 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_1) /*16ul*/ );
  tmp = (struct anonymous_1 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_1 *)NULL))
    return (struct anonymous_1 *)(void *)0;

  else
    return tmp;
}

// SslFd_send_message
// file ssl_fd_struct.h line 44
signed int SslFd_send_message(char type, struct anonymous_1 *sf, unsigned char *buf, signed int amount)
{
  unsigned long int clen;
  signed int length;
  if(sf == ((struct anonymous_1 *)NULL) || buf == ((unsigned char *)NULL))
    return -1;

  else
  {
    aflog((char)16, (char)2, "send_message: ssl:%s zlib:%s length:%d", ((signed int)type & 4) != 0 ? "yes" : "no", ((signed int)type & 8) != 0 ? "yes" : "no", amount);
    clen = (unsigned long int)8995;
    length = amount - 5;
    if(!((8 & (signed int)type) == 0))
    {
      static unsigned char buffer[9000l];
      memcpy((void *)buffer, (const void *)buf, (unsigned long int)5);
      if(amount >= 6)
      {
        compress(&buffer[(signed long int)5], &clen, &buf[(signed long int)5], (unsigned long int)length);
        if(!(clen >= (unsigned long int)length))
        {
          length = (signed int)clen;
          length = length | 0x4000;
          buffer[(signed long int)3] = (unsigned char)(length >> 8);
          buffer[(signed long int)4] = (unsigned char)length;
          addtocg((signed int)((unsigned long int)(amount - 5) - clen));
        }

      }

      if(!((4 & (signed int)type) == 0))
      {
        if(!((0x4000 & length) == 0))
        {
          signed int return_value_SSL_writen_1;
          return_value_SSL_writen_1=SSL_writen(sf->ssl, buffer, (signed int)(clen + (unsigned long int)5));
          return return_value_SSL_writen_1;
        }

        else
        {
          signed int return_value_SSL_writen_2;
          return_value_SSL_writen_2=SSL_writen(sf->ssl, buf, amount);
          return return_value_SSL_writen_2;
        }
      }

      else
        if(!((0x4000 & length) == 0))
        {
          signed int return_value_writen_3;
          return_value_writen_3=writen(sf->fd, buffer, (signed int)(clen + (unsigned long int)5));
          return return_value_writen_3;
        }

        else
        {
          signed int return_value_writen_4;
          return_value_writen_4=writen(sf->fd, buf, amount);
          return return_value_writen_4;
        }
    }

    else
      if(!((4 & (signed int)type) == 0))
      {
        signed int return_value_SSL_writen_5;
        return_value_SSL_writen_5=SSL_writen(sf->ssl, buf, amount);
        return return_value_SSL_writen_5;
      }

      else
      {
        signed int return_value_writen_6;
        return_value_writen_6=writen(sf->fd, buf, amount);
        return return_value_writen_6;
      }
  }
}

// SslFd_set_fd
// file ssl_fd_struct.h line 37
void SslFd_set_fd(struct anonymous_1 *sf, signed int fd)
{
  if(!(sf == ((struct anonymous_1 *)NULL)))
    sf->fd = fd;

}

// SslFd_set_ssl
// file ssl_fd_struct.h line 38
void SslFd_set_ssl(struct anonymous_1 *sf, struct ssl_st *ssl)
{
  SslFd_set_ssl_general(sf, ssl, 1);
}

// SslFd_set_ssl_general
// file ssl_fd_struct.c line 98
void SslFd_set_ssl_general(struct anonymous_1 *sf, struct ssl_st *ssl, signed int free)
{
  if(!(sf == ((struct anonymous_1 *)NULL)))
  {
    if(!(free == 0))
    {
      if(!(sf->ssl == ((struct ssl_st *)NULL)))
        SSL_free(sf->ssl);

    }

    sf->ssl = ssl;
  }

}

// SslFd_set_ssl_nf
// file ssl_fd_struct.h line 39
void SslFd_set_ssl_nf(struct anonymous_1 *sf, struct ssl_st *ssl)
{
  SslFd_set_ssl_general(sf, ssl, 0);
}

// SslFd_swap_content
// file ssl_fd_struct.h line 46
void SslFd_swap_content(struct anonymous_1 *sf1, struct anonymous_1 *sf2)
{
  signed int tmpfd;
  struct ssl_st *tmpssl;
  tmpfd=SslFd_get_fd(sf1);
  tmpssl=SslFd_get_ssl(sf2);
  signed int return_value_SslFd_get_fd_1;
  return_value_SslFd_get_fd_1=SslFd_get_fd(sf2);
  SslFd_set_fd(sf1, return_value_SslFd_get_fd_1);
  struct ssl_st *return_value_SslFd_get_ssl_2;
  return_value_SslFd_get_ssl_2=SslFd_get_ssl(sf2);
  SslFd_set_ssl(sf1, return_value_SslFd_get_ssl_2);
  SslFd_set_fd(sf2, tmpfd);
  SslFd_set_ssl(sf2, tmpssl);
}

// TaskListNode_free
// file task_list_node_struct.c line 60
void TaskListNode_free(struct tlnode **node)
{
  if(!(node == ((struct tlnode **)NULL)))
  {
    if(!(*node == ((struct tlnode *)NULL)))
    {
      free((void *)*node);
      *node = (struct tlnode *)(void *)0;
    }

  }

}

// TaskListNode_get_task
// file task_list_node_struct.c line 117
struct anonymous_13 * TaskListNode_get_task(struct tlnode *node)
{
  if(node == ((struct tlnode *)NULL))
    return (struct anonymous_13 *)(void *)0;

  else
    return node->task;
}

// TaskListNode_new
// file task_list_node_struct.c line 37
struct tlnode * TaskListNode_new(struct anonymous_13 *task)
{
  struct tlnode *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct tlnode) /*24ul*/ );
  tmp = (struct tlnode *)return_value_calloc_1;
  if(task == ((struct anonymous_13 *)NULL))
    return (struct tlnode *)(void *)0;

  else
    if(tmp == ((struct tlnode *)NULL))
      return (struct tlnode *)(void *)0;

    else
    {
      tmp->task = task;
      return tmp;
    }
}

// TaskListNode_set_next
// file task_list_node_struct.c line 83
void TaskListNode_set_next(struct tlnode *node, struct tlnode *next)
{
  if(!(node == ((struct tlnode *)NULL)))
    node->next = next;

}

// TaskListNode_set_previous
// file task_list_node_struct.c line 100
void TaskListNode_set_previous(struct tlnode *node, struct tlnode *previous)
{
  if(!(node == ((struct tlnode *)NULL)))
    node->previous = previous;

}

// TaskScheduler_addTask
// file task_scheduler_struct.h line 41
signed int TaskScheduler_addTask(struct anonymous_16 *scheduler, struct anonymous_13 *task)
{
  struct tlnode *tmp;
  if(scheduler == ((struct anonymous_16 *)NULL))
    return 1;

  else
    if(task == ((struct anonymous_13 *)NULL))
      return 1;

    else
    {
      tmp=TaskListNode_new(task);
      if(tmp == ((struct tlnode *)NULL))
        return 1;

      else
      {
        if(!(scheduler->head == ((struct tlnode *)NULL)))
        {
          TaskListNode_set_next(tmp, scheduler->head);
          TaskListNode_set_previous(scheduler->head, tmp);
        }

        scheduler->head = tmp;
        scheduler->numberOfTasks = scheduler->numberOfTasks + 1;
        if(!(scheduler->actualTask == ((struct tlnode *)NULL)))
        {
          struct timeval *return_value_TaskScheduler_get_actualTimer_1;
          return_value_TaskScheduler_get_actualTimer_1=TaskScheduler_get_actualTimer(scheduler);
          struct timeval *return_value_Task_get_timer_2;
          return_value_Task_get_timer_2=Task_get_timer(task);
          signed int return_value_timeval_compare_3;
          return_value_timeval_compare_3=timeval_compare(return_value_TaskScheduler_get_actualTimer_1, return_value_Task_get_timer_2);
          if(return_value_timeval_compare_3 >= 1)
            scheduler->actualTask = tmp;

        }

        else
          scheduler->actualTask = tmp;
        return 0;
      }
    }
}

// TaskScheduler_free
// file task_scheduler_struct.c line 54
void TaskScheduler_free(struct anonymous_16 **scheduler)
{
  if(!(scheduler == ((struct anonymous_16 **)NULL)))
  {
    if(!(*scheduler == ((struct anonymous_16 *)NULL)))
    {
      while(!((*scheduler)->head == ((struct tlnode *)NULL)))
      {
        struct anonymous_13 *return_value_TaskListNode_get_task_1;
        return_value_TaskListNode_get_task_1=TaskListNode_get_task((*scheduler)->head);
        TaskScheduler_removeTask(*scheduler, return_value_TaskListNode_get_task_1);
      }
      free((void *)*scheduler);
      *scheduler = (struct anonymous_16 *)(void *)0;
    }

  }

}

// TaskScheduler_get_actualTimer
// file task_scheduler_struct.h line 38
struct timeval * TaskScheduler_get_actualTimer(struct anonymous_16 *scheduler)
{
  if(scheduler == ((struct anonymous_16 *)NULL))
    return (struct timeval *)(void *)0;

  else
  {
    struct anonymous_13 *return_value_TaskListNode_get_task_1;
    return_value_TaskListNode_get_task_1=TaskListNode_get_task(scheduler->actualTask);
    struct timeval *return_value_Task_get_timer_2;
    return_value_Task_get_timer_2=Task_get_timer(return_value_TaskListNode_get_task_1);
    return return_value_Task_get_timer_2;
  }
}

// TaskScheduler_hasMoreTasks
// file task_scheduler_struct.h line 40
signed int TaskScheduler_hasMoreTasks(struct anonymous_16 *scheduler)
{
  if(scheduler == ((struct anonymous_16 *)NULL))
    return 0;

  else
    return scheduler->numberOfTasks;
}

// TaskScheduler_new
// file task_scheduler_struct.h line 34
struct anonymous_16 * TaskScheduler_new()
{
  struct anonymous_16 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_16) /*40ul*/ );
  tmp = (struct anonymous_16 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_16 *)NULL))
    return (struct anonymous_16 *)(void *)0;

  else
    return tmp;
}

// TaskScheduler_removeTask
// file task_scheduler_struct.h line 42
signed int TaskScheduler_removeTask(struct anonymous_16 *scheduler, struct anonymous_13 *task)
{
  struct tlnode *iterator;
  struct anonymous_13 *tmp;
  if(scheduler == ((struct anonymous_16 *)NULL))
    return 1;

  else
    if(task == ((struct anonymous_13 *)NULL))
      return 1;

    else
    {
      iterator = scheduler->head;
      for( ; !(iterator == ((struct tlnode *)NULL)); iterator = iterator->next)
      {
        tmp=TaskListNode_get_task(iterator);
        if(tmp == task)
        {
          if(!(iterator->previous == ((struct tlnode *)NULL)))
            TaskListNode_set_next(iterator->previous, iterator->next);

          if(!(iterator->next == ((struct tlnode *)NULL)))
            TaskListNode_set_previous(iterator->next, iterator->previous);

          if(iterator == scheduler->head)
            scheduler->head = iterator->next;

          if(iterator == scheduler->actualTask)
            scheduler->actualTask=find_tasknode_with_minimal_timer(scheduler);

          scheduler->numberOfTasks = scheduler->numberOfTasks - 1;
          TaskListNode_free(&iterator);
          return 0;
        }

      }
      return 1;
    }
}

// TaskScheduler_startWatching
// file task_scheduler_struct.h line 43
signed int TaskScheduler_startWatching(struct anonymous_16 *scheduler)
{
  struct timeval *tmp;
  if(scheduler == ((struct anonymous_16 *)NULL))
    return 1;

  else
  {
    tmp=TaskScheduler_get_actualTimer(scheduler);
    if(tmp == ((struct timeval *)NULL))
      return 1;

    else
    {
      scheduler->delta = *tmp;
      return 0;
    }
  }
}

// TaskScheduler_stopWatching
// file task_scheduler_struct.h line 44
signed int TaskScheduler_stopWatching(struct anonymous_16 *scheduler)
{
  struct tlnode *iterator;
  struct tlnode *actualTask;
  struct anonymous_13 *backup;
  struct timeval *tmp;
  signed int result;
  if(scheduler == ((struct anonymous_16 *)NULL))
    return 1;

  else
  {
    tmp=TaskScheduler_get_actualTimer(scheduler);
    if(tmp == ((struct timeval *)NULL))
      return 1;

    else
    {
      signed int return_value_timeval_subtract_1;
      return_value_timeval_subtract_1=timeval_subtract(&scheduler->delta, tmp);
      if(!(return_value_timeval_subtract_1 == 0))
        return 1;

      else
      {
        actualTask = scheduler->actualTask;
        iterator = scheduler->head;
        while(!(iterator == ((struct tlnode *)NULL)))
        {
          if(!(iterator == actualTask))
          {
            struct anonymous_13 *return_value_TaskListNode_get_task_2;
            return_value_TaskListNode_get_task_2=TaskListNode_get_task(iterator);
            struct timeval *return_value_Task_get_timer_3;
            return_value_Task_get_timer_3=Task_get_timer(return_value_TaskListNode_get_task_2);
            result=timeval_subtract(return_value_Task_get_timer_3, &scheduler->delta);
          }

          struct anonymous_13 *return_value_TaskListNode_get_task_5;
          return_value_TaskListNode_get_task_5=TaskListNode_get_task(iterator);
          struct timeval *return_value_Task_get_timer_6;
          return_value_Task_get_timer_6=Task_get_timer(return_value_TaskListNode_get_task_5);
          signed int return_value_timeval_lq_zero_7;
          return_value_timeval_lq_zero_7=timeval_lq_zero(return_value_Task_get_timer_6);
          if(!(return_value_timeval_lq_zero_7 == 0))
          {
            struct anonymous_13 *return_value_TaskListNode_get_task_4;
            return_value_TaskListNode_get_task_4=TaskListNode_get_task(iterator);
            Task_exec(return_value_TaskListNode_get_task_4);
            backup=TaskListNode_get_task(iterator);
            iterator = iterator->next;
            TaskScheduler_removeTask(scheduler, backup);
            continue;
          }

          iterator = iterator->next;
        }
        TaskScheduler_update(scheduler);
        return 0;
      }
    }
  }
}

// TaskScheduler_update
// file task_scheduler_struct.h line 45
signed int TaskScheduler_update(struct anonymous_16 *scheduler)
{
  if(scheduler == ((struct anonymous_16 *)NULL))
    return 1;

  else
  {
    scheduler->actualTask=find_tasknode_with_minimal_timer(scheduler);
    return 0;
  }
}

// Task_exec
// file task_struct.c line 113
void Task_exec(struct anonymous_13 *task)
{
  if(!(task == ((struct anonymous_13 *)NULL)))
  {
    if(!(task->function == ((void (*)(void *))NULL)))
      task->function(task->data);

  }

}

// Task_free
// file task_struct.h line 34
void Task_free(struct anonymous_13 **task)
{
  if(!(task == ((struct anonymous_13 **)NULL)))
  {
    if(!(*task == ((struct anonymous_13 *)NULL)))
    {
      if(!((*task)->clean == ((void (*)(void **))NULL)))
      {
        if(!((*task)->data == NULL))
          (*task)->clean(&(*task)->data);

      }

      free((void *)*task);
      *task = (struct anonymous_13 *)(void *)0;
    }

  }

}

// Task_get_timer
// file task_struct.c line 97
struct timeval * Task_get_timer(struct anonymous_13 *task)
{
  if(task == ((struct anonymous_13 *)NULL))
    return (struct timeval *)(void *)0;

  else
    return task->timerp;
}

// Task_new
// file task_struct.h line 32
struct anonymous_13 * Task_new(struct timeval *timerp, void (*function)(void *), void *data, void (*clean)(void **))
{
  struct anonymous_13 *tmp;
  if(timerp == ((struct timeval *)NULL))
    return (struct anonymous_13 *)(void *)0;

  else
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_13) /*32ul*/ );
    tmp = (struct anonymous_13 *)return_value_calloc_1;
    if(tmp == ((struct anonymous_13 *)NULL))
      return (struct anonymous_13 *)(void *)0;

    else
    {
      tmp->timerp = timerp;
      tmp->function = function;
      tmp->data = data;
      tmp->clean = clean;
      return tmp;
    }
  }
}

// UserStats_add_download
// file user_stats_struct.h line 52
void UserStats_add_download(struct anonymous_6 *us, signed int bytes)
{
  signed long int now;
  if(!(us == ((struct anonymous_6 *)NULL)))
  {
    time(&now);
    switch(now - us->lastDSQChange)
    {
      case (signed long int)0:
      {
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = us->downloadSpeedQueue[(signed long int)us->downloadSQP] + bytes;
        break;
      }
      case (signed long int)2:
      {
        us->downloadSQP = (us->downloadSQP + 1) % 3;
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = 0;
      }
      case (signed long int)1:
      {
        us->downloadSQP = (us->downloadSQP + 1) % 3;
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = bytes;
        break;
      }
      default:
      {
        us->downloadSpeedQueue[(signed long int)2] = 0;
        us->downloadSpeedQueue[(signed long int)1] = us->downloadSpeedQueue[(signed long int)2];
        us->downloadSpeedQueue[(signed long int)0] = us->downloadSpeedQueue[(signed long int)1];
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = bytes;
      }
    }
    us->totalDownloadedBytes = us->totalDownloadedBytes + bytes;
    us->lastActivity = now;
    us->lastDSQChange = now;
  }

}

// UserStats_add_upload
// file user_stats_struct.h line 53
void UserStats_add_upload(struct anonymous_6 *us, signed int bytes)
{
  signed long int now;
  if(!(us == ((struct anonymous_6 *)NULL)))
  {
    time(&now);
    switch(now - us->lastUSQChange)
    {
      case (signed long int)0:
      {
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = us->uploadSpeedQueue[(signed long int)us->uploadSQP] + bytes;
        break;
      }
      case (signed long int)2:
      {
        us->uploadSQP = (us->uploadSQP + 1) % 3;
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = 0;
      }
      case (signed long int)1:
      {
        us->uploadSQP = (us->uploadSQP + 1) % 3;
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = bytes;
        break;
      }
      default:
      {
        us->uploadSpeedQueue[(signed long int)2] = 0;
        us->uploadSpeedQueue[(signed long int)1] = us->uploadSpeedQueue[(signed long int)2];
        us->uploadSpeedQueue[(signed long int)0] = us->uploadSpeedQueue[(signed long int)1];
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = bytes;
      }
    }
    us->totalUploadedBytes = us->totalUploadedBytes + bytes;
    us->lastActivity = now;
    us->lastUSQChange = now;
  }

}

// UserStats_clear
// file user_stats_struct.h line 57
void UserStats_clear(struct anonymous_6 *us)
{
  if(!(us == ((struct anonymous_6 *)NULL)))
  {
    us->lastActivity = (signed long int)0;
    us->lastUSQChange = (signed long int)0;
    us->lastDSQChange = (signed long int)0;
    us->totalDownloadedBytes = 0;
    us->totalUploadedBytes = 0;
    us->uploadSQP = 0;
    us->uploadSpeedQueue[(signed long int)2] = 0;
    us->uploadSpeedQueue[(signed long int)1] = us->uploadSpeedQueue[(signed long int)2];
    us->uploadSpeedQueue[(signed long int)0] = us->uploadSpeedQueue[(signed long int)1];
    us->downloadSQP = 0;
    us->downloadSpeedQueue[(signed long int)2] = 0;
    us->downloadSpeedQueue[(signed long int)1] = us->downloadSpeedQueue[(signed long int)2];
    us->downloadSpeedQueue[(signed long int)0] = us->downloadSpeedQueue[(signed long int)1];
  }

}

// UserStats_free
// file user_stats_struct.c line 53
void UserStats_free(struct anonymous_6 **us)
{
  if(!(us == ((struct anonymous_6 **)NULL)))
  {
    if(!(*us == ((struct anonymous_6 *)NULL)))
    {
      free((void *)*us);
      *us = (struct anonymous_6 *)(void *)0;
    }

  }

}

// UserStats_get_downloadSpeed
// file user_stats_struct.h line 54
double UserStats_get_downloadSpeed(struct anonymous_6 *us)
{
  signed long int now;
  if(us == ((struct anonymous_6 *)NULL))
    return 0.0;

  else
  {
    time(&now);
    switch(now - us->lastDSQChange)
    {
      case (signed long int)0:
        break;
      case (signed long int)2:
      {
        us->downloadSQP = (us->downloadSQP + 1) % 3;
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = 0;
      }
      case (signed long int)1:
      {
        us->downloadSQP = (us->downloadSQP + 1) % 3;
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = 0;
        break;
      }
      default:
      {
        us->downloadSpeedQueue[(signed long int)2] = 0;
        us->downloadSpeedQueue[(signed long int)1] = us->downloadSpeedQueue[(signed long int)2];
        us->downloadSpeedQueue[(signed long int)0] = us->downloadSpeedQueue[(signed long int)1];
      }
    }
    us->lastDSQChange = now;
    return (double)(us->downloadSpeedQueue[(signed long int)0] + us->downloadSpeedQueue[(signed long int)1] + us->downloadSpeedQueue[(signed long int)2]) / 3.0;
  }
}

// UserStats_get_lastActivity
// file user_stats_struct.h line 48
signed long int UserStats_get_lastActivity(struct anonymous_6 *us)
{
  if(us == ((struct anonymous_6 *)NULL))
    return (signed long int)0;

  else
    return us->lastActivity;
}

// UserStats_get_totalDownloadedBytes
// file user_stats_struct.h line 49
signed int UserStats_get_totalDownloadedBytes(struct anonymous_6 *us)
{
  if(us == ((struct anonymous_6 *)NULL))
    return 0;

  else
    return us->totalDownloadedBytes;
}

// UserStats_get_totalUploadedBytes
// file user_stats_struct.h line 50
signed int UserStats_get_totalUploadedBytes(struct anonymous_6 *us)
{
  if(us == ((struct anonymous_6 *)NULL))
    return 0;

  else
    return us->totalUploadedBytes;
}

// UserStats_get_uploadSpeed
// file user_stats_struct.h line 55
double UserStats_get_uploadSpeed(struct anonymous_6 *us)
{
  signed long int now;
  if(us == ((struct anonymous_6 *)NULL))
    return 0.0;

  else
  {
    time(&now);
    switch(now - us->lastUSQChange)
    {
      case (signed long int)0:
        break;
      case (signed long int)2:
      {
        us->uploadSQP = (us->uploadSQP + 1) % 3;
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = 0;
      }
      case (signed long int)1:
      {
        us->uploadSQP = (us->uploadSQP + 1) % 3;
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = 0;
        break;
      }
      default:
      {
        us->uploadSpeedQueue[(signed long int)2] = 0;
        us->uploadSpeedQueue[(signed long int)1] = us->uploadSpeedQueue[(signed long int)2];
        us->uploadSpeedQueue[(signed long int)0] = us->uploadSpeedQueue[(signed long int)1];
      }
    }
    us->lastUSQChange = now;
    return (double)(us->uploadSpeedQueue[(signed long int)0] + us->uploadSpeedQueue[(signed long int)1] + us->uploadSpeedQueue[(signed long int)2]) / 3.0;
  }
}

// UserStats_new
// file user_stats_struct.c line 36
struct anonymous_6 * UserStats_new()
{
  struct anonymous_6 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_6) /*64ul*/ );
  tmp = (struct anonymous_6 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_6 *)NULL))
    return (struct anonymous_6 *)(void *)0;

  else
    return tmp;
}

// UserStats_set_lastActivity
// file user_stats_struct.h line 44
void UserStats_set_lastActivity(struct anonymous_6 *us, signed long int lastActivity)
{
  if(!(us == ((struct anonymous_6 *)NULL)))
    us->lastActivity = lastActivity;

}

// UserStats_set_totalDownloadedBytes
// file user_stats_struct.c line 92
void UserStats_set_totalDownloadedBytes(struct anonymous_6 *us, signed int totalDownloadedBytes)
{
  if(!(us == ((struct anonymous_6 *)NULL)))
    us->totalDownloadedBytes = totalDownloadedBytes;

}

// UserStats_set_totalUploadedBytes
// file user_stats_struct.c line 109
void UserStats_set_totalUploadedBytes(struct anonymous_6 *us, signed int totalUploadedBytes)
{
  if(!(us == ((struct anonymous_6 *)NULL)))
    us->totalUploadedBytes = totalUploadedBytes;

}

// UsrCli_free
// file usr_cli_struct.c line 54
void UsrCli_free(struct anonymous_7 **uc)
{
  if(!(uc == ((struct anonymous_7 **)NULL)))
  {
    if(!(*uc == ((struct anonymous_7 *)NULL)))
    {
      if(!((*uc)->listenPortName == ((char *)NULL)))
      {
        free((void *)(*uc)->listenPortName);
        (*uc)->listenPortName = (char *)(void *)0;
      }

      if(!((*uc)->managePortName == ((char *)NULL)))
      {
        free((void *)(*uc)->managePortName);
        (*uc)->managePortName = (char *)(void *)0;
      }

      free((void *)*uc);
      *uc = (struct anonymous_7 *)(void *)0;
    }

  }

}

// UsrCli_get_listenFd
// file usr_cli_struct.h line 48
signed int UsrCli_get_listenFd(struct anonymous_7 *uc)
{
  if(uc == ((struct anonymous_7 *)NULL))
    return -1;

  else
    return uc->listenFd;
}

// UsrCli_get_listenHostName
// file usr_cli_struct.h line 50
char * UsrCli_get_listenHostName(struct anonymous_7 *uc)
{
  if(uc == ((struct anonymous_7 *)NULL))
    return (char *)(void *)0;

  else
    return uc->listenHostName;
}

// UsrCli_get_listenPortName
// file usr_cli_struct.h line 46
char * UsrCli_get_listenPortName(struct anonymous_7 *uc)
{
  if(uc == ((struct anonymous_7 *)NULL))
    return (char *)(void *)0;

  else
    return uc->listenPortName;
}

// UsrCli_get_manageFd
// file usr_cli_struct.h line 49
signed int UsrCli_get_manageFd(struct anonymous_7 *uc)
{
  if(uc == ((struct anonymous_7 *)NULL))
    return -1;

  else
    return uc->manageFd;
}

// UsrCli_get_manageHostName
// file usr_cli_struct.h line 51
char * UsrCli_get_manageHostName(struct anonymous_7 *uc)
{
  if(uc == ((struct anonymous_7 *)NULL))
    return (char *)(void *)0;

  else
    return uc->manageHostName;
}

// UsrCli_get_managePortName
// file usr_cli_struct.h line 47
char * UsrCli_get_managePortName(struct anonymous_7 *uc)
{
  if(uc == ((struct anonymous_7 *)NULL))
    return (char *)(void *)0;

  else
    return uc->managePortName;
}

// UsrCli_get_number
// file usr_cli_struct.h line 52
signed int UsrCli_get_number(struct anonymous_7 *uc)
{
  if(uc == ((struct anonymous_7 *)NULL))
    return -1;

  else
    return uc->number;
}

// UsrCli_new
// file usr_cli_struct.h line 36
struct anonymous_7 * UsrCli_new()
{
  struct anonymous_7 *tmp;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_7) /*48ul*/ );
  tmp = (struct anonymous_7 *)return_value_calloc_1;
  if(tmp == ((struct anonymous_7 *)NULL))
    return (struct anonymous_7 *)(void *)0;

  else
    return tmp;
}

// UsrCli_set_listenFd
// file usr_cli_struct.h line 42
void UsrCli_set_listenFd(struct anonymous_7 *uc, signed int listenFd)
{
  if(!(uc == ((struct anonymous_7 *)NULL)))
    uc->listenFd = listenFd;

}

// UsrCli_set_listenPortName
// file usr_cli_struct.h line 40
void UsrCli_set_listenPortName(struct anonymous_7 *uc, char *listenPortName)
{
  char *tmp;
  if(!(uc == ((struct anonymous_7 *)NULL)))
  {
    tmp=rindex(listenPortName, 58);
    if(!(tmp == ((char *)NULL)))
    {
      *tmp = (char)0;
      tmp = tmp + 1l;
      string_cp(&uc->listenHostName, listenPortName);
      string_cp(&uc->listenPortName, tmp);
    }

    else
      string_cp(&uc->listenPortName, listenPortName);
  }

}

// UsrCli_set_manageFd
// file usr_cli_struct.h line 43
void UsrCli_set_manageFd(struct anonymous_7 *uc, signed int manageFd)
{
  if(!(uc == ((struct anonymous_7 *)NULL)))
    uc->manageFd = manageFd;

}

// UsrCli_set_managePortName
// file usr_cli_struct.h line 41
void UsrCli_set_managePortName(struct anonymous_7 *uc, char *managePortName)
{
  char *tmp;
  if(!(uc == ((struct anonymous_7 *)NULL)))
  {
    tmp=rindex(managePortName, 58);
    if(!(tmp == ((char *)NULL)))
    {
      *tmp = (char)0;
      tmp = tmp + 1l;
      string_cp(&uc->manageHostName, managePortName);
      string_cp(&uc->managePortName, tmp);
    }

    else
      string_cp(&uc->managePortName, managePortName);
  }

}

// UsrCli_set_number
// file usr_cli_struct.h line 44
void UsrCli_set_number(struct anonymous_7 *uc, signed int number)
{
  if(!(uc == ((struct anonymous_7 *)NULL)))
    uc->number = number;

}

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32_1;
  return_value___builtin_bswap32_1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32_1;
}

// __bswap_32_link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link1(unsigned int __bsx_link1)
{
  signed long int return_value___builtin_bswap32_1_link1;
  return_value___builtin_bswap32_1_link1=__builtin_bswap32((signed long int)__bsx_link1);
  return (unsigned int)return_value___builtin_bswap32_1_link1;
}

// add_to_message
// file server_remoteadmin.c line 188
static void add_to_message(unsigned char *buff, const char *format, ...)
{
  void **ap;
  signed int n;
  if(newmessage == 0)
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen((char *)&buff[(signed long int)5]);
    n = (signed int)return_value_strlen_1;
  }

  else
    n = 0;
  newmessage = (char)0;
  ap = (void **)&format;
  vsprintf((char *)&buff[(signed long int)(5 + n)], format, ap);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen((char *)&buff[(signed long int)5]);
  n = (signed int)return_value_strlen_2;
  sprintf((char *)&buff[(signed long int)(5 + n)], "\n");
  ap = ((void **)NULL);
}

// add_uptime_to_message
// file server_remoteadmin.c line 221
static void add_uptime_to_message(unsigned char *buff, char *info, signed long int period)
{
  signed int hours;
  signed int minutes;
  signed int seconds;
  hours = (signed int)(period / (signed long int)3600);
  minutes = (signed int)((period / (signed long int)60) % (signed long int)60);
  seconds = (signed int)(period % (signed long int)60);
  if(!(hours == 0))
    add_to_message(buff, "%s: %d:%02d:%02d", info, hours, minutes, seconds);

  else
    add_to_message(buff, "%s: %d:%02d", info, minutes, seconds);
}

// addlogtarget
// file logging.h line 69
void addlogtarget(char *cmdline)
{
  struct llnode *newnode;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct llnode) /*32ul*/ );
  newnode = (struct llnode *)return_value_calloc_1;
  newnode->cmdline = cmdline;
  newnode->next = head;
  head = newnode;
}

// addtocg
// file stats.c line 61
void addtocg(signed int amount)
{
  compressgained = compressgained + (signed long int)amount;
}

// aflog
// file logging.h line 73
void aflog(char type, char importance, const char *form, ...)
{
  struct llnode *ptr;
  void **ap;
  if(!(((signed int)importance & (signed int)verlev) == 0))
  {
    if(!((signed int)format[0l] == 0))
    {
      char *return_value_datum_1;
      return_value_datum_1=datum();
      printf("[%s] ", return_value_datum_1);
    }

    ap = (void **)&form;
    vfprintf(stdout, form, ap);
    ap = ((void **)NULL);
    printf("\n");
  }

  ptr = head;
  for( ; !(ptr == ((struct llnode *)NULL)); ptr = ptr->next)
    if(!(((signed int)ptr->msgtype & (signed int)type) == 0))
    {
      if(!(((signed int)ptr->importance & (signed int)importance) == 0))
      {
        if(!((signed int)format[0l] == 0))
        {
          char *return_value_datum_2;
          return_value_datum_2=datum();
          fprintf(ptr->logfd, "[%s] ", return_value_datum_2);
        }

        ap = (void **)&form;
        vfprintf(ptr->logfd, form, ap);
        ap = ((void **)NULL);
        fprintf(ptr->logfd, "\n");
        fflush(ptr->logfd);
      }

    }

}

// afserver_connect
// file http_proxy_server.c line 54
signed int afserver_connect(signed int *sockfd, signed int afserverfd, struct sockaddr *cliaddr, unsigned int *addrlenp, char type)
{
  signed int sockets[2l];
  signed int return_value_socketpair_1;
  return_value_socketpair_1=socketpair(1, 1, 0, sockets);
  if(!(return_value_socketpair_1 == 0))
    return 1;

  else
  {
    signed long int return_value_write_2;
    return_value_write_2=write(afserverfd, (const void *)&sockets[(signed long int)0], (unsigned long int)4);
    if(!(return_value_write_2 == 4l))
      return 2;

    else
    {
      signed long int return_value_write_3;
      return_value_write_3=write(afserverfd, (const void *)&type, (unsigned long int)1);
      if(!(return_value_write_3 == 1l))
        return 3;

      else
      {
        signed long int return_value_write_4;
        return_value_write_4=write(afserverfd, (const void *)addrlenp, (unsigned long int)4);
        if(!(return_value_write_4 == 4l))
          return 4;

        else
        {
          signed long int return_value_write_5;
          return_value_write_5=write(afserverfd, (const void *)cliaddr, (unsigned long int)*addrlenp);
          if(!(return_value_write_5 == (signed long int)*addrlenp))
            return 5;

          else
          {
            *sockfd = sockets[(signed long int)1];
            return 0;
          }
        }
      }
    }
  }
}

// broadcast_condition
// file thread_management.h line 31
void broadcast_condition(void)
{
  pthread_cond_broadcast(&maincond);
}

// callback
// file first_run.c line 63
static void callback(signed int i, signed int j, void *k)
{
  if(k == NULL)
  {
    printf("%d", i);
    fflush(stdout);
  }

}

// check_long
// file server_check.h line 26
signed int check_long(char *text, signed long int *number)
{
  char *tmp;
  *number=strtol(text, &tmp, 10);
  _Bool tmp_if_expr_1;
  if(*number == 0x7fffffffffffffffL)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = *number == -0x7fffffffffffffffL - 1L ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    return 1;

  else
  {
    if(!((signed int)*text == 0))
      tmp_if_expr_2 = (signed int)*tmp == 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      return 0;

    else
      return 2;
  }
}

// check_value
// file server_check.h line 24
signed int check_value(char *what, char *info)
{
  signed long int tmp;
  signed int return_value_check_value_liberal_1;
  return_value_check_value_liberal_1=check_value_liberal(what, info);
  tmp = (signed long int)return_value_check_value_liberal_1;
  if(!(tmp >= 1l))
  {
    aflog((char)4, (char)1, "%s: %d\n", info, tmp);
    exit(1);
  }

  return (signed int)tmp;
}

// check_value_liberal
// file server_check.h line 25
signed int check_value_liberal(char *what, char *info)
{
  char *znak;
  signed long int tmp;
  tmp=strtol(what, &znak, 10);
  if(tmp >= 2147483647l)
  {
    aflog((char)4, (char)1, "%s: %s\n", info, what);
    exit(1);
  }

  _Bool tmp_if_expr_1;
  if((signed int)*what == 0)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)*znak != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    aflog((char)4, (char)1, "%s: %s\n", info, what);
    exit(1);
  }

  return (signed int)tmp;
}

// checklogtarget
// file logging.c line 175
signed int checklogtarget(struct llnode *target)
{
  char *ptr;
  char desc[100l];
  char type = (char)0;
  char tab[100l];
  signed int tmpfd;
  signed int state;
  signed int i;
  _Bool tmp_if_expr_1;
  if(target == ((struct llnode *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = target->cmdline == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  signed int tmp_statement_expression_4;
  signed int tmp_statement_expression_2;
  if(tmp_if_expr_1)
    return 1;

  else
  {
    state = 0;
    memset((void *)tab, 0, (unsigned long int)100);
    i = 0;
    ptr = target->cmdline;
    for( ; !((signed int)*ptr == 0); ptr = ptr + 1l)
      switch(state)
      {
        case 0:
        {
          if((signed int)*ptr == 44)
          {
            tab[(signed long int)i] = (char)0;
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp_5;
            return_value___builtin_strcmp_5=__builtin_strcmp(tab, "file");
            tmp_statement_expression_4 = return_value___builtin_strcmp_5;
            if(tmp_statement_expression_4 == 0)
              type = (char)1;

            else
            {
              unsigned long int checklogtarget__1__2__1__1__1__3____s1_len;
              unsigned long int checklogtarget__1__2__1__1__1__3____s2_len;
              signed int return_value___builtin_strcmp_3;
              return_value___builtin_strcmp_3=__builtin_strcmp(tab, "sock");
              tmp_statement_expression_2 = return_value___builtin_strcmp_3;
              if(tmp_statement_expression_2 == 0)
                type = (char)2;

              else
                return 2;
            }
            state = 1;
            memset((void *)tab, 0, (unsigned long int)100);
            memset((void *)desc, 0, (unsigned long int)100);
            i = 0;
            break;
          }

          if(i == 98)
            return 2;

          tab[(signed long int)i] = *ptr;
          i = i + 1;
          break;
        }
        case 1:
        {
          if((signed int)*ptr == 44)
          {
            tab[(signed long int)i] = (char)0;
            switch((signed int)type)
            {
              case 1:
              {
                target->logfd=fopen(tab, "a");
                if(target->logfd == ((struct _IO_FILE *)NULL))
                  return 4;

                state = 3;
                break;
              }
              case 2:
              {
                __builtin_strncpy(desc, tab, (unsigned long int)99);
                state = 2;
                break;
              }
              default:
                return 2;
            }
            memset((void *)tab, 0, (unsigned long int)100);
            i = 0;
            break;
          }

          if(i == 98)
            return 3;

          tab[(signed long int)i] = *ptr;
          i = i + 1;
          break;
        }
        case 2:
        {
          if((signed int)*ptr == 44)
          {
            tab[(signed long int)i] = (char)0;
            signed int return_value_ip_connect_6;
            return_value_ip_connect_6=ip_connect(&tmpfd, desc, tab, (const char)1, (const char *)(void *)0, (const char *)(void *)0);
            if(!(return_value_ip_connect_6 == 0))
              return 5;

            target->logfd=fdopen(tmpfd, "a");
            if(target->logfd == ((struct _IO_FILE *)NULL))
              return 4;

            state = 3;
            memset((void *)tab, 0, (unsigned long int)100);
            i = 0;
            break;
          }

          if(i == 98)
            return 3;

          tab[(signed long int)i] = *ptr;
          i = i + 1;
          break;
        }
        case 3:
        {
          if((signed int)*ptr == 44)
          {
            tab[(signed long int)i] = (char)0;
            signed int return_value_checkmsgti_7;
            return_value_checkmsgti_7=checkmsgti(target, tab);
            if(!(return_value_checkmsgti_7 == 0))
              return 6;

            memset((void *)tab, 0, (unsigned long int)100);
            i = 0;
            break;
          }

          if(i == 98)
            return 6;

          tab[(signed long int)i] = *ptr;
          i = i + 1;
        }
      }
    if(!(i == 0))
    {
      if(state == 3)
      {
        tab[(signed long int)i] = (char)0;
        signed int return_value_checkmsgti_8;
        return_value_checkmsgti_8=checkmsgti(target, tab);
        if(!(return_value_checkmsgti_8 == 0))
          return 6;

        goto __CPROVER_DUMP_L32;
      }

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L32:
      ;
      return 0;
    }
  }
}

// checkmsgti
// file logging.c line 119
signed int checkmsgti(struct llnode *target, char *tab)
{
  signed int tmp_statement_expression_25;
  unsigned long int checkmsgti__1__1____s1_len;
  unsigned long int checkmsgti__1__1____s2_len;
  signed int return_value___builtin_strcmp_26;
  return_value___builtin_strcmp_26=__builtin_strcmp(tab, "LOG_T_ALL");
  tmp_statement_expression_25 = return_value___builtin_strcmp_26;
  signed int tmp_statement_expression_23;
  signed int tmp_statement_expression_21;
  signed int tmp_statement_expression_19;
  signed int tmp_statement_expression_17;
  signed int tmp_statement_expression_15;
  signed int tmp_statement_expression_13;
  signed int tmp_statement_expression_11;
  signed int tmp_statement_expression_9;
  signed int tmp_statement_expression_7;
  signed int tmp_statement_expression_5;
  signed int tmp_statement_expression_3;
  signed int tmp_statement_expression_1;
  if(tmp_statement_expression_25 == 0)
    target->msgtype = target->msgtype | (char)(1 | 2 | 4 | 8 | 16);

  else
  {
    unsigned long int checkmsgti__1__3____s1_len;
    unsigned long int checkmsgti__1__3____s2_len;
    signed int return_value___builtin_strcmp_24;
    return_value___builtin_strcmp_24=__builtin_strcmp(tab, "LOG_T_USER");
    tmp_statement_expression_23 = return_value___builtin_strcmp_24;
    if(tmp_statement_expression_23 == 0)
      target->msgtype = target->msgtype | (char)1;

    else
    {
      unsigned long int checkmsgti__1__5____s1_len;
      unsigned long int checkmsgti__1__5____s2_len;
      signed int return_value___builtin_strcmp_22;
      return_value___builtin_strcmp_22=__builtin_strcmp(tab, "LOG_T_CLIENT");
      tmp_statement_expression_21 = return_value___builtin_strcmp_22;
      if(tmp_statement_expression_21 == 0)
        target->msgtype = target->msgtype | (char)2;

      else
      {
        unsigned long int checkmsgti__1__7____s1_len;
        unsigned long int checkmsgti__1__7____s2_len;
        signed int return_value___builtin_strcmp_20;
        return_value___builtin_strcmp_20=__builtin_strcmp(tab, "LOG_T_INIT");
        tmp_statement_expression_19 = return_value___builtin_strcmp_20;
        if(tmp_statement_expression_19 == 0)
          target->msgtype = target->msgtype | (char)4;

        else
        {
          unsigned long int checkmsgti__1__9____s1_len;
          unsigned long int checkmsgti__1__9____s2_len;
          signed int return_value___builtin_strcmp_18;
          return_value___builtin_strcmp_18=__builtin_strcmp(tab, "LOG_T_MANAGE");
          tmp_statement_expression_17 = return_value___builtin_strcmp_18;
          if(tmp_statement_expression_17 == 0)
            target->msgtype = target->msgtype | (char)8;

          else
          {
            unsigned long int checkmsgti__1__11____s1_len;
            unsigned long int checkmsgti__1__11____s2_len;
            signed int return_value___builtin_strcmp_16;
            return_value___builtin_strcmp_16=__builtin_strcmp(tab, "LOG_T_MAIN");
            tmp_statement_expression_15 = return_value___builtin_strcmp_16;
            if(tmp_statement_expression_15 == 0)
              target->msgtype = target->msgtype | (char)16;

            else
            {
              unsigned long int __s1_len;
              unsigned long int __s2_len;
              signed int return_value___builtin_strcmp_14;
              return_value___builtin_strcmp_14=__builtin_strcmp(tab, "LOG_I_ALL");
              tmp_statement_expression_13 = return_value___builtin_strcmp_14;
              if(tmp_statement_expression_13 == 0)
                target->importance = target->importance | (char)(1 | 2 | 4 | 8 | 16 | 32 | 64);

              else
              {
                unsigned long int checkmsgti__1__15____s1_len;
                unsigned long int checkmsgti__1__15____s2_len;
                signed int return_value___builtin_strcmp_12;
                return_value___builtin_strcmp_12=__builtin_strcmp(tab, "LOG_I_CRIT");
                tmp_statement_expression_11 = return_value___builtin_strcmp_12;
                if(tmp_statement_expression_11 == 0)
                  target->importance = target->importance | (char)1;

                else
                {
                  unsigned long int checkmsgti__1__17____s1_len;
                  unsigned long int checkmsgti__1__17____s2_len;
                  signed int return_value___builtin_strcmp_10;
                  return_value___builtin_strcmp_10=__builtin_strcmp(tab, "LOG_I_DEBUG");
                  tmp_statement_expression_9 = return_value___builtin_strcmp_10;
                  if(tmp_statement_expression_9 == 0)
                    target->importance = target->importance | (char)2;

                  else
                  {
                    unsigned long int checkmsgti__1__19____s1_len;
                    unsigned long int checkmsgti__1__19____s2_len;
                    signed int return_value___builtin_strcmp_8;
                    return_value___builtin_strcmp_8=__builtin_strcmp(tab, "LOG_I_INFO");
                    tmp_statement_expression_7 = return_value___builtin_strcmp_8;
                    if(tmp_statement_expression_7 == 0)
                      target->importance = target->importance | (char)8;

                    else
                    {
                      unsigned long int checkmsgti__1__21____s1_len;
                      unsigned long int checkmsgti__1__21____s2_len;
                      signed int return_value___builtin_strcmp_6;
                      return_value___builtin_strcmp_6=__builtin_strcmp(tab, "LOG_I_NOTICE");
                      tmp_statement_expression_5 = return_value___builtin_strcmp_6;
                      if(tmp_statement_expression_5 == 0)
                        target->importance = target->importance | (char)16;

                      else
                      {
                        unsigned long int checkmsgti__1__23____s1_len;
                        unsigned long int checkmsgti__1__23____s2_len;
                        signed int return_value___builtin_strcmp_4;
                        return_value___builtin_strcmp_4=__builtin_strcmp(tab, "LOG_I_WARNING");
                        tmp_statement_expression_3 = return_value___builtin_strcmp_4;
                        if(tmp_statement_expression_3 == 0)
                          target->importance = target->importance | (char)32;

                        else
                        {
                          unsigned long int checkmsgti__1__25____s1_len;
                          unsigned long int checkmsgti__1__25____s2_len;
                          signed int return_value___builtin_strcmp_2;
                          return_value___builtin_strcmp_2=__builtin_strcmp(tab, "LOG_I_ERR");
                          tmp_statement_expression_1 = return_value___builtin_strcmp_2;
                          if(tmp_statement_expression_1 == 0)
                            target->importance = target->importance | (char)64;

                          else
                            return 1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

// clear_fd
// file http_proxy_functions.c line 261
void clear_fd(signed int *fd, struct anonymous_22 *set)
{
  set->__fds_bits[(signed long int)(*fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = set->__fds_bits[(signed long int)(*fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << *fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  close_fd(fd);
}

// clear_sslFd
// file http_proxy_functions.c line 362
void clear_sslFd(struct anonymous_1 *sf, struct anonymous_22 *set)
{
  clear_fd(&sf->fd, set);
  struct ssl_st *return_value_SslFd_get_ssl_2;
  return_value_SslFd_get_ssl_2=SslFd_get_ssl(sf);
  if(!(return_value_SslFd_get_ssl_2 == ((struct ssl_st *)NULL)))
  {
    struct ssl_st *return_value_SslFd_get_ssl_1;
    return_value_SslFd_get_ssl_1=SslFd_get_ssl(sf);
    SSL_clear(return_value_SslFd_get_ssl_1);
  }

}

// client_long_usage
// file usage.c line 148
void client_long_usage(char *info)
{
  printf("\n%s\n\n\n", info);
  printf(" Basic options:\n\n");
  printf("  -n, --servername    - where the second part of the active\n");
  printf("                        port forwarder is running (required)\n");
  printf("  -m, --manageport    - manage port number - server must be\n");
  printf("                        listening on it (default: 50126)\n");
  printf("  -d, --hostname      - the name of this host/remote host - the final\n");
  printf("                        destination of the packets (default: the name\n");
  printf("                        returned by hostname function)\n");
  printf("  -p, --portnum       - the port we are forwarding connection to (required)\n");
  printf("  --localname         - local machine name for connection with afserver\n");
  printf("                        (used to bind socket to different interfaces)\n");
  printf("  --localport         - local port name for connection with afserver\n");
  printf("                        (used to bind socket to different addressees)\n");
  printf("  --localdesname      - local machine name for connections with destination\n");
  printf("                        application (used to bind socket to different interfaces)\n");
  printf("  -V, --version       - display version number\n");
  printf("  -h, --help          - prints this help\n\n");
  printf(" Authorization:\n\n");
  printf("  -i, --id            - sends the id string to afserver\n");
  printf("  --pass              - set the password used for client identification\n");
  printf("                        (default: no password)\n");
  printf("  --ignorepkeys       - ignore invalid server's public keys\n\n");
  printf(" Configuration:\n\n");
  printf("  -k, --keyfile       - the name of the file with RSA key (default: client.rsa)\n");
  printf("  -c, --cerfile       - the name of the file with certificate\n");
  printf("                        (default: no certificate used)\n");
  printf("  -f, --cfgfile       - the name of the file with the configuration for the\n");
  printf("                        active forwarder (client)\n");
  printf("  -s, --storefile     - the name of the file with stored public keys\n");
  printf("                        (default: known_hosts)\n");
  printf("  -D, --dateformat    - format of the date printed in logs (see 'man strftime'\n");
  printf("                        for details) (default: %%Y-%%m-%%d %%H:%%M:%%S)\n");
  printf("  -K, --keep-alive N  - send keepalive packets every N seconds\n");
  printf("                        (default: not send keepalive packets)\n\n");
  printf(" Auto-reconnection:\n\n");
  printf("  --ar-start          - enable auto-reconnection when afserver is not\n");
  printf("                        reachable on start (default: disabled)\n");
  printf("  --ar-quit           - enable auto-reconnection after normal afserver quit\n");
  printf("                        (default: disabled)\n");
  printf("  --noar              - disable auto-reconnection after premature afserver\n");
  printf("                        quit (default: enabled)\n");
  printf("  -A, --ar-tries N    - try N times to reconnect (default: unlimited)\n");
  printf("  -T, --ar-delay N    - wait N seconds between reconnect tries (default: 5)\n\n");
  printf(" Modes:\n\n");
  printf("  -u, --udpmode       - udp mode - client will use udp protocol to\n");
  printf("                        communicate with the hostname:portnum\n");
  printf("  -U, --reverseudp    - reverse udp forwarding. Udp packets will be forwarded\n");
  printf("                        from hostname:portnum to the server name:manageport\n");
  printf("  -r, --remoteadmin   - remote administration mode. (using '-p #port' will\n");
  printf("                        force afclient to use port rather than stdin-stdout)\n\n");
  printf(" Logging:\n\n");
  printf("  -o, --log           - log choosen information to file/socket\n");
  printf("  -v, --verbose       - to be verbose - program won't enter the daemon mode\n");
  printf("                        (use several times for greater effect)\n\n");
  printf(" IP family:\n\n");
  printf("  -4, --ipv4          - use ipv4 only\n");
  printf("  -6, --ipv6          - use ipv6 only\n\n");
  printf(" Modules:\n\n");
  printf("  -l, --load          - load a module for user's packets filtering\n");
  printf("  -L, --Load          - load a module for service's packets filtering\n\n");
  printf(" HTTP/HTTPS PROXY:\n\n");
  printf("  -S, --use-https     - use https proxy instead of http proxy\n");
  printf("  -P, --proxyname     - the name of the machine with proxy server\n");
  printf("  -X, --proxyport     - the port used by proxy server (default: 8080)\n");
  printf("  -C, --pa-cred  U:P  - the user (U) and password (P) used in proxy\n");
  printf("                        authorization\n");
  printf("  -B, --pa-t-basic    - the Basic type of proxy authorization (default)\n\n");
  exit(0);
}

// client_short_usage
// file usage.c line 132
void client_short_usage(char *info)
{
  printf("\n%s\n\n\n", info);
  printf("Try `afclient --help' for more information.\n");
  exit(1);
}

// close_fd
// file http_proxy_functions.c line 248
void close_fd(signed int *fd)
{
  close(*fd);
}

// create_apf_dir
// file first_run.h line 24
signed int create_apf_dir(char type)
{
  signed int length;
  struct stat buf;
  struct passwd *user;
  unsigned int return_value_getuid_1;
  return_value_getuid_1=getuid();
  user=getpwuid(return_value_getuid_1);
  if((signed int)type == 0)
  {
    if(user == ((struct passwd *)NULL))
      return 1;

    if(user->pw_dir == ((char *)NULL))
      return 2;

    if(!(home_dir == ((char *)NULL)))
    {
      free((void *)home_dir);
      home_dir = (char *)(void *)0;
    }

    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(user->pw_dir);
    length = (signed int)return_value_strlen_2;
    void *return_value_calloc_3;
    return_value_calloc_3=calloc((unsigned long int)1, (unsigned long int)(length + 6));
    home_dir = (char *)return_value_calloc_3;
    if(home_dir == ((char *)NULL))
      return 3;

    strcpy(home_dir, user->pw_dir);
    if((signed int)home_dir[(signed long int)length] == 47)
      strcpy(&home_dir[(signed long int)length], ".apf");

    else
      strcpy(&home_dir[(signed long int)length], "/.apf");
    signed int return_value_stat_5;
    return_value_stat_5=stat(home_dir, &buf);
    if(!(return_value_stat_5 == 0))
    {
      signed int return_value_mkdir_4;
      return_value_mkdir_4=mkdir(home_dir, (unsigned int)0700);
      if(!(return_value_mkdir_4 == 0))
        return 4;

    }

  }

  else
  {
    if(!(home_dir == ((char *)NULL)))
    {
      free((void *)home_dir);
      home_dir = (char *)(void *)0;
    }

    void *return_value_calloc_6;
    return_value_calloc_6=calloc((unsigned long int)1, (unsigned long int)4);
    home_dir = (char *)return_value_calloc_6;
    if(home_dir == ((char *)NULL))
      return 3;

    strcpy(home_dir, "apf");
    signed int return_value_stat_8;
    return_value_stat_8=stat(home_dir, &buf);
    if(!(return_value_stat_8 == 0))
    {
      signed int return_value_mkdir_7;
      return_value_mkdir_7=mkdir(home_dir, (unsigned int)0700);
      if(!(return_value_mkdir_7 == 0))
        return 4;

    }

  }
  return 0;
}

// create_publickey_store
// file first_run.c line 147
signed int create_publickey_store(char **storefile)
{
  signed int store_length;
  signed int home_length;
  struct stat buf;
  struct _IO_FILE *store_file;
  signed int return_value_stat_1;
  return_value_stat_1=stat(*storefile, &buf);
  if(return_value_stat_1 == 0)
    return 0;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(*storefile);
    store_length = (signed int)return_value_strlen_2;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(home_dir);
    home_length = (signed int)return_value_strlen_3;
    if(!(home_dir_store == ((char *)NULL)))
    {
      free((void *)home_dir_store);
      home_dir_store = (char *)(void *)0;
    }

    void *return_value_calloc_4;
    return_value_calloc_4=calloc((unsigned long int)1, (unsigned long int)(home_length + store_length + 2));
    home_dir_store = (char *)return_value_calloc_4;
    if(home_dir_store == ((char *)NULL))
      return 1;

    else
    {
      strcpy(home_dir_store, home_dir);
      home_dir_store[(signed long int)home_length] = (char)47;
      strcpy(&home_dir_store[(signed long int)(home_length + 1)], *storefile);
      *storefile = home_dir_store;
      store_file=fopen(home_dir_store, "a");
      if(store_file == ((struct _IO_FILE *)NULL))
        return 1;

      else
      {
        fclose(store_file);
        signed int return_value_stat_5;
        return_value_stat_5=stat(home_dir_store, &buf);
        if(return_value_stat_5 == 0)
          return 0;

        else
          return 2;
      }
    }
  }
}

// datum
// file logging.c line 85
char * datum(void)
{
  signed long int sec;
  struct tm *tm;
  time(&sec);
  tm=localtime(&sec);
  static char timedat[31l];
  memset((void *)timedat, 0, (unsigned long int)31);
  strftime(timedat, (unsigned long int)30, format, tm);
  return timedat;
}

// delete_user
// file http_proxy_functions.c line 77
void delete_user(struct anonymous_27 *cnts, signed int i, struct anonymous_22 *allset)
{
  aflog((char)16, (char)2, "http proxy: delete_user(%d)", i);
  clear_fd(&(cnts + (signed long int)i)->sockfd, allset);
  if((1 & (signed int)(cnts + (signed long int)i)->state) == 0)
    clear_sslFd((cnts + (signed long int)i)->postFd, allset);

  if((signed int)(cnts + (signed long int)i)->type == 0)
  {
    if((2 & (signed int)(cnts + (signed long int)i)->state) == 0)
      clear_sslFd((cnts + (signed long int)i)->getFd, allset);

  }

  (cnts + (signed long int)i)->state = (char)0;
  (cnts + (signed long int)i)->length = 0;
  (cnts + (signed long int)i)->ptr = (cnts + (signed long int)i)->length;
  (cnts + (signed long int)i)->sent_ptr = (cnts + (signed long int)i)->ptr;
  (cnts + (signed long int)i)->type = (char)0;
}

// end_critical_section
// file thread_management.h line 29
void end_critical_section(void)
{
  pthread_mutex_unlock(&mainmutex);
}

// eval_UsrCliPair
// file server_eval.h line 29
signed int eval_UsrCliPair(struct anonymous_7 **table, signed int index, char *host, char *serv)
{
  signed int i;
  signed int result = 0;
  i = 0;
  signed int tmp_statement_expression_1;
  signed int tmp_statement_expression_5;
  for( ; !(i >= index); i = i + 1)
  {
    char *return_value_UsrCli_get_manageHostName_4;
    return_value_UsrCli_get_manageHostName_4=UsrCli_get_manageHostName(table[(signed long int)i]);
    if(!(return_value_UsrCli_get_manageHostName_4 == ((char *)NULL)))
    {
      if(!(host == ((char *)NULL)))
      {
        unsigned long int eval_UsrCliPair__1__1__1__1__1____s1_len;
        unsigned long int eval_UsrCliPair__1__1__1__1__1____s2_len;
        char *return_value_UsrCli_get_listenHostName_2;
        return_value_UsrCli_get_listenHostName_2=UsrCli_get_listenHostName(table[(signed long int)i]);
        signed int return_value___builtin_strcmp_3;
        return_value___builtin_strcmp_3=__builtin_strcmp(return_value_UsrCli_get_listenHostName_2, host);
        tmp_statement_expression_1 = return_value___builtin_strcmp_3;
        if(!(tmp_statement_expression_1 == 0))
          goto __CPROVER_DUMP_L11;

      }

      else
        goto __CPROVER_DUMP_L11;
    }

    else
      if(!(host == ((char *)NULL)))
        goto __CPROVER_DUMP_L11;

    char *return_value_UsrCli_get_managePortName_8;
    return_value_UsrCli_get_managePortName_8=UsrCli_get_managePortName(table[(signed long int)i]);
    if(!(return_value_UsrCli_get_managePortName_8 == ((char *)NULL)))
    {
      if(!(serv == ((char *)NULL)))
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        char *return_value_UsrCli_get_managePortName_6;
        return_value_UsrCli_get_managePortName_6=UsrCli_get_managePortName(table[(signed long int)i]);
        signed int return_value___builtin_strcmp_7;
        return_value___builtin_strcmp_7=__builtin_strcmp(return_value_UsrCli_get_managePortName_6, serv);
        tmp_statement_expression_5 = return_value___builtin_strcmp_7;
        if(!(tmp_statement_expression_5 == 0))
          goto __CPROVER_DUMP_L11;

      }

      else
        goto __CPROVER_DUMP_L11;
    }

    else
      if(!(serv == ((char *)NULL)))
        goto __CPROVER_DUMP_L11;

    result = result + 1;

  __CPROVER_DUMP_L11:
    ;
  }
  return result;
}

// eval_numofcon
// file server_eval.h line 27
signed int eval_numofcon(struct anonymous_5 *ptr, signed int client, signed int numofcon)
{
  _Bool tmp_if_expr_5;
  struct anonymous_3 **return_value_ServerRealm_get_clientsTable_3;
  signed int return_value_ConnectClient_get_limit_4;
  if(numofcon >= 0)
  {
    return_value_ServerRealm_get_clientsTable_3=ServerRealm_get_clientsTable(ptr);
    return_value_ConnectClient_get_limit_4=ConnectClient_get_limit(return_value_ServerRealm_get_clientsTable_3[(signed long int)client]);
    tmp_if_expr_5 = numofcon < return_value_ConnectClient_get_limit_4 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_5 = (_Bool)0;
  if(tmp_if_expr_5)
  {
    struct anonymous_3 **return_value_ServerRealm_get_clientsTable_1;
    return_value_ServerRealm_get_clientsTable_1=ServerRealm_get_clientsTable(ptr);
    signed int *return_value_ConnectClient_get_users_2;
    return_value_ConnectClient_get_users_2=ConnectClient_get_users(return_value_ServerRealm_get_clientsTable_1[(signed long int)client]);
    numofcon = return_value_ConnectClient_get_users_2[(signed long int)numofcon];
  }

  else
    numofcon = -1;
  return numofcon;
}

// eval_usernum
// file server_eval.h line 28
signed int eval_usernum(struct anonymous_3 *ptr, signed int usernum)
{
  signed int i = 0;
  signed int return_value_ConnectClient_get_limit_1;
  do
  {
    return_value_ConnectClient_get_limit_1=ConnectClient_get_limit(ptr);
    if(i >= return_value_ConnectClient_get_limit_1)
      break;

    signed int *return_value_ConnectClient_get_users_2;
    return_value_ConnectClient_get_users_2=ConnectClient_get_users(ptr);
    if(return_value_ConnectClient_get_users_2[(signed long int)i] == usernum)
      return i;

    i = i + 1;
  }
  while((_Bool)1);
  return -1;
}

// find_client
// file server_find.h line 27
signed int find_client(struct anonymous_5 *ptr, char mode, signed int usrclipair)
{
  signed int i;
  signed int return_value_ServerRealm_get_clientsLimit_1;
  struct anonymous_3 **return_value_ServerRealm_get_clientsTable_6;
  signed int return_value_ConnectClient_get_usrCliPair_7;
  if((signed int)mode == 1)
  {
    i = 0;
    do
    {
      return_value_ServerRealm_get_clientsLimit_1=ServerRealm_get_clientsLimit(ptr);
      if(i >= return_value_ServerRealm_get_clientsLimit_1)
        break;

      struct anonymous_3 **return_value_ServerRealm_get_clientsTable_8;
      return_value_ServerRealm_get_clientsTable_8=ServerRealm_get_clientsTable(ptr);
      char return_value_ConnectClient_get_state_9;
      return_value_ConnectClient_get_state_9=ConnectClient_get_state(return_value_ServerRealm_get_clientsTable_8[(signed long int)i]);
      if((signed int)return_value_ConnectClient_get_state_9 == 3)
      {
        return_value_ServerRealm_get_clientsTable_6=ServerRealm_get_clientsTable(ptr);
        return_value_ConnectClient_get_usrCliPair_7=ConnectClient_get_usrCliPair(return_value_ServerRealm_get_clientsTable_6[(signed long int)i]);
        if(return_value_ConnectClient_get_usrCliPair_7 == usrclipair)
        {
          struct anonymous_3 **return_value_ServerRealm_get_clientsTable_2;
          return_value_ServerRealm_get_clientsTable_2=ServerRealm_get_clientsTable(ptr);
          signed int return_value_ConnectClient_get_connected_3;
          return_value_ConnectClient_get_connected_3=ConnectClient_get_connected(return_value_ServerRealm_get_clientsTable_2[(signed long int)i]);
          struct anonymous_3 **return_value_ServerRealm_get_clientsTable_4;
          return_value_ServerRealm_get_clientsTable_4=ServerRealm_get_clientsTable(ptr);
          signed int return_value_ConnectClient_get_limit_5;
          return_value_ConnectClient_get_limit_5=ConnectClient_get_limit(return_value_ServerRealm_get_clientsTable_4[(signed long int)i]);
          if(!(return_value_ConnectClient_get_connected_3 >= return_value_ConnectClient_get_limit_5))
            return i;

        }

      }

      i = i + 1;
    }
    while((_Bool)1);
    goto __CPROVER_DUMP_L7;
  }

  return 0;

__CPROVER_DUMP_L7:
  ;
  return 0;
}

// find_previousFd
// file server_find.h line 29
signed int find_previousFd(struct anonymous_7 **table, signed int index, char *host, char *serv)
{
  signed int i = 0;
  signed int tmp_statement_expression_1;
  signed int tmp_statement_expression_5;
  for( ; !(i >= index); i = i + 1)
  {
    char *return_value_UsrCli_get_manageHostName_4;
    return_value_UsrCli_get_manageHostName_4=UsrCli_get_manageHostName(table[(signed long int)i]);
    if(!(return_value_UsrCli_get_manageHostName_4 == ((char *)NULL)))
    {
      if(!(host == ((char *)NULL)))
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        char *return_value_UsrCli_get_listenHostName_2;
        return_value_UsrCli_get_listenHostName_2=UsrCli_get_listenHostName(table[(signed long int)i]);
        signed int return_value___builtin_strcmp_3;
        return_value___builtin_strcmp_3=__builtin_strcmp(return_value_UsrCli_get_listenHostName_2, host);
        tmp_statement_expression_1 = return_value___builtin_strcmp_3;
        if(!(tmp_statement_expression_1 == 0))
          goto __CPROVER_DUMP_L11;

      }

      else
        goto __CPROVER_DUMP_L11;
    }

    else
      if(!(host == ((char *)NULL)))
        goto __CPROVER_DUMP_L11;

    char *return_value_UsrCli_get_managePortName_8;
    return_value_UsrCli_get_managePortName_8=UsrCli_get_managePortName(table[(signed long int)i]);
    if(!(return_value_UsrCli_get_managePortName_8 == ((char *)NULL)))
    {
      if(!(serv == ((char *)NULL)))
      {
        unsigned long int find_previousFd__1__1__3__1__1____s1_len;
        unsigned long int find_previousFd__1__1__3__1__1____s2_len;
        char *return_value_UsrCli_get_managePortName_6;
        return_value_UsrCli_get_managePortName_6=UsrCli_get_managePortName(table[(signed long int)i]);
        signed int return_value___builtin_strcmp_7;
        return_value___builtin_strcmp_7=__builtin_strcmp(return_value_UsrCli_get_managePortName_6, serv);
        tmp_statement_expression_5 = return_value___builtin_strcmp_7;
        if(!(tmp_statement_expression_5 == 0))
          goto __CPROVER_DUMP_L11;

      }

      else
        goto __CPROVER_DUMP_L11;
    }

    else
      if(!(serv == ((char *)NULL)))
        goto __CPROVER_DUMP_L11;

    signed int return_value_UsrCli_get_manageFd_9;
    return_value_UsrCli_get_manageFd_9=UsrCli_get_manageFd(table[(signed long int)i]);
    return return_value_UsrCli_get_manageFd_9;

  __CPROVER_DUMP_L11:
    ;
  }
  return -1;
}

// find_tasknode_with_minimal_timer
// file task_scheduler_struct.c line 158
static struct tlnode * find_tasknode_with_minimal_timer(struct anonymous_16 *scheduler)
{
  struct tlnode *iterator;
  struct tlnode *candidate;
  if(scheduler == ((struct anonymous_16 *)NULL))
    return (struct tlnode *)(void *)0;

  else
    if(scheduler->head == ((struct tlnode *)NULL))
      return (struct tlnode *)(void *)0;

    else
    {
      candidate = scheduler->head;
      iterator = scheduler->head;
      iterator = iterator->next;
      while(!(iterator == ((struct tlnode *)NULL)))
      {
        struct anonymous_13 *return_value_TaskListNode_get_task_1;
        return_value_TaskListNode_get_task_1=TaskListNode_get_task(iterator);
        struct timeval *return_value_Task_get_timer_2;
        return_value_Task_get_timer_2=Task_get_timer(return_value_TaskListNode_get_task_1);
        struct anonymous_13 *return_value_TaskListNode_get_task_3;
        return_value_TaskListNode_get_task_3=TaskListNode_get_task(candidate);
        struct timeval *return_value_Task_get_timer_4;
        return_value_Task_get_timer_4=Task_get_timer(return_value_TaskListNode_get_task_3);
        signed int return_value_timeval_compare_5;
        return_value_timeval_compare_5=timeval_compare(return_value_Task_get_timer_2, return_value_Task_get_timer_4);
        if(return_value_timeval_compare_5 == -1)
          candidate = iterator;

        iterator = iterator->next;
      }
      return candidate;
    }
}

// find_usernum
// file server_find.h line 28
signed int find_usernum(struct anonymous_3 *ptr, signed int usernum)
{
  signed int i = 0;
  signed int return_value_ConnectClient_get_limit_1;
  do
  {
    return_value_ConnectClient_get_limit_1=ConnectClient_get_limit(ptr);
    if(i >= return_value_ConnectClient_get_limit_1)
      break;

    signed int *return_value_ConnectClient_get_users_3;
    return_value_ConnectClient_get_users_3=ConnectClient_get_users(ptr);
    if(return_value_ConnectClient_get_users_3[(signed long int)i] == -1)
    {
      signed int *return_value_ConnectClient_get_users_2;
      return_value_ConnectClient_get_users_2=ConnectClient_get_users(ptr);
      return_value_ConnectClient_get_users_2[(signed long int)i] = usernum;
      return i;
    }

    i = i + 1;
  }
  while((_Bool)1);
  return -1;
}

// generate_certificate
// file first_run.h line 27
signed int generate_certificate(char **cerfile, char *keyfile)
{
  signed int cer_length;
  signed int home_length;
  signed int i;
  struct stat buf;
  struct x509_st *cert;
  struct X509_req_st *req;
  struct X509_name_st *subj;
  struct rsa_st *rsa_key;
  struct evp_pkey_st *pkey;
  const struct env_md_st *digest;
  struct _IO_FILE *fp;
  signed int return_value_stat_1;
  return_value_stat_1=stat(*cerfile, &buf);
  if(return_value_stat_1 == 0)
    return 0;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(*cerfile);
    cer_length = (signed int)return_value_strlen_2;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(home_dir);
    home_length = (signed int)return_value_strlen_3;
    if(!(home_dir_cer == ((char *)NULL)))
    {
      free((void *)home_dir_cer);
      home_dir_cer = (char *)(void *)0;
    }

    void *return_value_calloc_4;
    return_value_calloc_4=calloc((unsigned long int)1, (unsigned long int)(home_length + cer_length + 2));
    home_dir_cer = (char *)return_value_calloc_4;
    if(home_dir_cer == ((char *)NULL))
      return 1;

    else
    {
      strcpy(home_dir_cer, home_dir);
      home_dir_cer[(signed long int)home_length] = (char)47;
      strcpy(&home_dir_cer[(signed long int)(home_length + 1)], *cerfile);
      *cerfile = home_dir_cer;
      signed int return_value_stat_5;
      return_value_stat_5=stat(home_dir_cer, &buf);
      if(return_value_stat_5 == 0)
        return 0;

      else
      {
        printf("generating self signed certificate\n");
        fp=fopen(keyfile, "r");
        if(fp == ((struct _IO_FILE *)NULL))
          return 2;

        else
        {
          rsa_key=PEM_read_RSAPrivateKey(fp, (struct rsa_st **)(void *)0, (signed int (*)(char *, signed int, signed int, void *))(void *)0, (void *)0);
          fclose(fp);
          if(rsa_key == ((struct rsa_st *)NULL))
            return 3;

          else
          {
            pkey=EVP_PKEY_new();
            if(pkey == ((struct evp_pkey_st *)NULL))
              return 4;

            else
            {
              signed int return_value_EVP_PKEY_set1_RSA_6;
              return_value_EVP_PKEY_set1_RSA_6=EVP_PKEY_set1_RSA(pkey, rsa_key);
              if(return_value_EVP_PKEY_set1_RSA_6 == 0)
                return 5;

              else
              {
                req=X509_REQ_new();
                if(req == ((struct X509_req_st *)NULL))
                  return 6;

                else
                {
                  X509_REQ_set_pubkey(req, pkey);
                  subj=X509_NAME_new();
                  if(subj == ((struct X509_name_st *)NULL))
                    return 7;

                  else
                  {
                    i = 0;
                    for( ; !(i >= 6); i = i + 1)
                    {
                      signed int nid;
                      struct X509_name_entry_st *ent;
                      nid=OBJ_txt2nid(entries[(signed long int)i].key);
                      if(nid == 0)
                        return 8;

                      ent=X509_NAME_ENTRY_create_by_NID((struct X509_name_entry_st **)(void *)0, nid, 0x1000 | 1, entries[(signed long int)i].value, -1);
                      if(ent == ((struct X509_name_entry_st *)NULL))
                        return 9;

                      signed int return_value_X509_NAME_add_entry_7;
                      return_value_X509_NAME_add_entry_7=X509_NAME_add_entry(subj, ent, -1, 0);
                      if(return_value_X509_NAME_add_entry_7 == 0)
                        return 10;

                    }
                    signed int return_value_X509_REQ_set_subject_name_8;
                    return_value_X509_REQ_set_subject_name_8=X509_REQ_set_subject_name(req, subj);
                    if(return_value_X509_REQ_set_subject_name_8 == 0)
                      return 11;

                    else
                    {
                      digest=EVP_sha1();
                      signed int return_value_X509_REQ_sign_9;
                      return_value_X509_REQ_sign_9=X509_REQ_sign(req, pkey, digest);
                      if(return_value_X509_REQ_sign_9 == 0)
                        return 12;

                      else
                      {
                        cert=X509_REQ_to_X509(req, 1000, pkey);
                        signed int return_value_X509_set_version_10;
                        return_value_X509_set_version_10=X509_set_version(cert, 2L);
                        if(return_value_X509_set_version_10 == 0)
                          return 13;

                        else
                        {
                          struct asn1_string_st *return_value_X509_get_serialNumber_11;
                          return_value_X509_get_serialNumber_11=X509_get_serialNumber(cert);
                          ASN1_INTEGER_set(return_value_X509_get_serialNumber_11, (signed long int)1);
                          if(cert == ((struct x509_st *)NULL))
                            return 14;

                          else
                          {
                            signed int return_value_X509_sign_12;
                            return_value_X509_sign_12=X509_sign(cert, pkey, digest);
                            if(return_value_X509_sign_12 == 0)
                              return 15;

                            else
                            {
                              fp=fopen(home_dir_cer, "w");
                              if(fp == ((struct _IO_FILE *)NULL))
                                return 16;

                              else
                              {
                                PEM_write_X509(fp, cert);
                                fclose(fp);
                                EVP_PKEY_free(pkey);
                                X509_REQ_free(req);
                                X509_free(cert);
                                return 0;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// generate_rsa_key
// file first_run.h line 26
signed int generate_rsa_key(char **keyfile)
{
  signed int key_length;
  signed int home_length;
  struct rsa_st *rsa_key;
  struct _IO_FILE *rsa_file;
  struct stat buf;
  signed int return_value_stat_1;
  return_value_stat_1=stat(*keyfile, &buf);
  if(return_value_stat_1 == 0)
    return 0;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(*keyfile);
    key_length = (signed int)return_value_strlen_2;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(home_dir);
    home_length = (signed int)return_value_strlen_3;
    if(!(home_dir_key == ((char *)NULL)))
    {
      free((void *)home_dir_key);
      home_dir_key = (char *)(void *)0;
    }

    void *return_value_calloc_4;
    return_value_calloc_4=calloc((unsigned long int)1, (unsigned long int)(home_length + key_length + 2));
    home_dir_key = (char *)return_value_calloc_4;
    if(home_dir_key == ((char *)NULL))
      return 1;

    else
    {
      strcpy(home_dir_key, home_dir);
      home_dir_key[(signed long int)home_length] = (char)47;
      strcpy(&home_dir_key[(signed long int)(home_length + 1)], *keyfile);
      *keyfile = home_dir_key;
      signed int return_value_stat_5;
      return_value_stat_5=stat(home_dir_key, &buf);
      if(return_value_stat_5 == 0)
        return 0;

      else
      {
        printf("generating rsa key: 2048 bits\n");
        rsa_key=RSA_generate_key(2048, (unsigned long int)65537, callback, (void *)0);
        signed int return_value_RSA_check_key_6;
        return_value_RSA_check_key_6=RSA_check_key(rsa_key);
        if(return_value_RSA_check_key_6 == 1)
          printf("   OK!\n");

        else
        {
          printf("   FAILED!\n");
          return 1;
        }
        rsa_file=fopen(home_dir_key, "a");
        PEM_write_RSAPrivateKey(rsa_file, rsa_key, (const struct evp_cipher_st *)(void *)0, (unsigned char *)(void *)0, 0, (signed int (*)(char *, signed int, signed int, void *))(void *)0, (void *)0);
        fclose(rsa_file);
        return 0;
      }
    }
  }
}

// get_cer_filename
// file first_run.c line 400
char * get_cer_filename()
{
  return home_dir_cer;
}

// get_clientid
// file clientnames.c line 48
signed int get_clientid(struct anonymous_5 *pointer, char *clientname)
{
  signed int i;
  signed int n;
  char guard;
  signed int return_value_ServerRealm_get_clientsLimit_1;
  signed int tmp_statement_expression_4;
  signed int return_value_ServerRealm_get_clientsLimit_12;
  if(pointer == ((struct anonymous_5 *)NULL))
    return -1;

  else
    if(clientname == ((char *)NULL))
      return -1;

    else
    {
      i = 0;
      do
      {
        return_value_ServerRealm_get_clientsLimit_1=ServerRealm_get_clientsLimit(pointer);
        if(i >= return_value_ServerRealm_get_clientsLimit_1)
          break;

        struct anonymous_3 **return_value_ServerRealm_get_clientsTable_8;
        return_value_ServerRealm_get_clientsTable_8=ServerRealm_get_clientsTable(pointer);
        char *return_value_ConnectClient_get_sClientId_9;
        return_value_ConnectClient_get_sClientId_9=ConnectClient_get_sClientId(return_value_ServerRealm_get_clientsTable_8[(signed long int)i]);
        if(!(return_value_ConnectClient_get_sClientId_9 == ((char *)NULL)))
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          struct anonymous_3 **return_value_ServerRealm_get_clientsTable_5;
          return_value_ServerRealm_get_clientsTable_5=ServerRealm_get_clientsTable(pointer);
          char *return_value_ConnectClient_get_sClientId_6;
          return_value_ConnectClient_get_sClientId_6=ConnectClient_get_sClientId(return_value_ServerRealm_get_clientsTable_5[(signed long int)i]);
          signed int return_value___builtin_strcmp_7;
          return_value___builtin_strcmp_7=__builtin_strcmp(clientname, return_value_ConnectClient_get_sClientId_6);
          tmp_statement_expression_4 = return_value___builtin_strcmp_7;
          if(tmp_statement_expression_4 == 0)
          {
            struct anonymous_3 **return_value_ServerRealm_get_clientsTable_2;
            return_value_ServerRealm_get_clientsTable_2=ServerRealm_get_clientsTable(pointer);
            signed int return_value_ConnectClient_get_clientId_3;
            return_value_ConnectClient_get_clientId_3=ConnectClient_get_clientId(return_value_ServerRealm_get_clientsTable_2[(signed long int)i]);
            return return_value_ConnectClient_get_clientId_3;
          }

        }

        i = i + 1;
      }
      while((_Bool)1);
      signed int return_value_sscanf_13;
      return_value_sscanf_13=sscanf(clientname, "%d%c", &i, &guard);
      if(return_value_sscanf_13 == 1)
      {
        n=get_clientnumber(pointer, i);
        if(n >= 0)
        {
          return_value_ServerRealm_get_clientsLimit_12=ServerRealm_get_clientsLimit(pointer);
          if(!(n >= return_value_ServerRealm_get_clientsLimit_12))
          {
            struct anonymous_3 **return_value_ServerRealm_get_clientsTable_10;
            return_value_ServerRealm_get_clientsTable_10=ServerRealm_get_clientsTable(pointer);
            char *return_value_ConnectClient_get_sClientId_11;
            return_value_ConnectClient_get_sClientId_11=ConnectClient_get_sClientId(return_value_ServerRealm_get_clientsTable_10[(signed long int)n]);
            if(return_value_ConnectClient_get_sClientId_11 == ((char *)NULL))
              return i;

          }

        }

      }

      return -1;
    }
}

// get_clientname
// file clientnames.h line 27
char * get_clientname(struct anonymous_5 *pointer, signed int client)
{
  if(pointer == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
  {
    struct anonymous_3 **return_value_ServerRealm_get_clientsTable_3;
    return_value_ServerRealm_get_clientsTable_3=ServerRealm_get_clientsTable(pointer);
    char *return_value_ConnectClient_get_sClientId_4;
    return_value_ConnectClient_get_sClientId_4=ConnectClient_get_sClientId(return_value_ServerRealm_get_clientsTable_3[(signed long int)client]);
    if(return_value_ConnectClient_get_sClientId_4 == ((char *)NULL))
    {
      static char clientname[10l];
      memset((void *)clientname, 0, (unsigned long int)10);
      struct anonymous_3 **return_value_ServerRealm_get_clientsTable_1;
      return_value_ServerRealm_get_clientsTable_1=ServerRealm_get_clientsTable(pointer);
      signed int return_value_ConnectClient_get_clientId_2;
      return_value_ConnectClient_get_clientId_2=ConnectClient_get_clientId(return_value_ServerRealm_get_clientsTable_1[(signed long int)client]);
      sprintf(clientname, "%d", return_value_ConnectClient_get_clientId_2);
      return clientname;
    }

    struct anonymous_3 **return_value_ServerRealm_get_clientsTable_5;
    return_value_ServerRealm_get_clientsTable_5=ServerRealm_get_clientsTable(pointer);
    char *return_value_ConnectClient_get_sClientId_6;
    return_value_ConnectClient_get_sClientId_6=ConnectClient_get_sClientId(return_value_ServerRealm_get_clientsTable_5[(signed long int)client]);
    return return_value_ConnectClient_get_sClientId_6;
  }
}

// get_clientnumber
// file clientnames.h line 29
signed int get_clientnumber(struct anonymous_5 *pointer, signed int clientid)
{
  signed int i;
  signed int return_value_ServerRealm_get_clientsLimit_1;
  if(pointer == ((struct anonymous_5 *)NULL))
    return -1;

  else
  {
    i = 0;
    do
    {
      return_value_ServerRealm_get_clientsLimit_1=ServerRealm_get_clientsLimit(pointer);
      if(i >= return_value_ServerRealm_get_clientsLimit_1)
        break;

      struct anonymous_3 **return_value_ServerRealm_get_clientsTable_2;
      return_value_ServerRealm_get_clientsTable_2=ServerRealm_get_clientsTable(pointer);
      signed int return_value_ConnectClient_get_clientId_3;
      return_value_ConnectClient_get_clientId_3=ConnectClient_get_clientId(return_value_ServerRealm_get_clientsTable_2[(signed long int)i]);
      if(return_value_ConnectClient_get_clientId_3 == clientid)
        return i;

      i = i + 1;
    }
    while((_Bool)1);
    return -1;
  }
}

// get_key_filename
// file first_run.c line 388
char * get_key_filename()
{
  return home_dir_key;
}

// get_new_socket
// file server_get.h line 28
signed int get_new_socket(signed int sockfd, char type, struct sockaddr *addr, unsigned int *addrlen, char *tunneltype)
{
  signed int tmp;
  signed int n;
  signed int i;
  signed int return_value_accept_1;
  signed int *return_value___errno_location_2;
  signed int *return_value___errno_location_4;
  signed int *return_value___errno_location_6;
  signed int *return_value___errno_location_8;
  switch((signed int)type)
  {
    case 0:
    {
      return_value_accept_1=accept(sockfd, addr, addrlen);
      return return_value_accept_1;
    }
    case 1:
    {
      i = 0;
      while(!(i >= 4))
      {
        signed long int return_value_read_3;
        return_value_read_3=read(sockfd, (void *)(&tmp + (signed long int)i), (unsigned long int)(4 - i));
        n = (signed int)return_value_read_3;
        if(!(n == 4 + -i))
        {
          sleep((unsigned int)2);
          if(n >= 1 && !(n >= 4))
          {
            i = i + n;
            continue;
          }

          if(n == -1)
          {
            return_value___errno_location_2=__errno_location();
            if(*return_value___errno_location_2 == 11)
              continue;

          }

          return -1;
        }

        else
          break;
      }
      i = 0;
      while(!(i >= 1))
      {
        signed long int return_value_read_5;
        return_value_read_5=read(sockfd, (void *)(tunneltype + (signed long int)i), (unsigned long int)(1 - i));
        n = (signed int)return_value_read_5;
        if(!(n == 1 + -i))
        {
          if(n == -1)
          {
            return_value___errno_location_4=__errno_location();
            if(*return_value___errno_location_4 == 11)
              continue;

          }

          return -1;
        }

        else
          break;
      }
      i = 0;
      while(!(i >= 4))
      {
        signed long int return_value_read_7;
        return_value_read_7=read(sockfd, (void *)(addrlen + (signed long int)i), (unsigned long int)(4 - i));
        n = (signed int)return_value_read_7;
        if(!(n == 4 + -i))
        {
          if(n >= 1 && !(n >= 4))
          {
            i = i + n;
            continue;
          }

          if(n == -1)
          {
            return_value___errno_location_6=__errno_location();
            if(*return_value___errno_location_6 == 11)
              continue;

          }

          return -1;
        }

        else
          break;
      }
      i = 0;
      while(!((unsigned int)i >= *addrlen))
      {
        signed long int return_value_read_9;
        return_value_read_9=read(sockfd, (void *)(addr + (signed long int)i), (unsigned long int)(*addrlen - (unsigned int)i));
        n = (signed int)return_value_read_9;
        if(!((unsigned int)n == *addrlen + -((unsigned int)i)))
        {
          if(n >= 1)
          {
            if(!((unsigned int)n >= *addrlen))
            {
              i = i + n;
              continue;
            }

          }

          if(n == -1)
          {
            return_value___errno_location_8=__errno_location();
            if(*return_value___errno_location_8 == 11)
              continue;

          }

          return -1;
        }

        else
          break;
      }
      return tmp;
    }
    default:
      return -1;
  }
}

// get_raclientid
// file clientnames.c line 121
signed int get_raclientid(struct anonymous_5 *pointer, char *clientname)
{
  signed int i;
  signed int n;
  char guard;
  signed int return_value_ServerRealm_get_raClientsLimit_1;
  signed int tmp_statement_expression_4;
  signed int return_value_ServerRealm_get_raClientsLimit_12;
  if(pointer == ((struct anonymous_5 *)NULL))
    return -1;

  else
    if(clientname == ((char *)NULL))
      return -1;

    else
    {
      i = 0;
      do
      {
        return_value_ServerRealm_get_raClientsLimit_1=ServerRealm_get_raClientsLimit(pointer);
        if(i >= return_value_ServerRealm_get_raClientsLimit_1)
          break;

        struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_8;
        return_value_ServerRealm_get_raClientsTable_8=ServerRealm_get_raClientsTable(pointer);
        char *return_value_ConnectClient_get_sClientId_9;
        return_value_ConnectClient_get_sClientId_9=ConnectClient_get_sClientId(return_value_ServerRealm_get_raClientsTable_8[(signed long int)i]);
        if(!(return_value_ConnectClient_get_sClientId_9 == ((char *)NULL)))
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_5;
          return_value_ServerRealm_get_raClientsTable_5=ServerRealm_get_raClientsTable(pointer);
          char *return_value_ConnectClient_get_sClientId_6;
          return_value_ConnectClient_get_sClientId_6=ConnectClient_get_sClientId(return_value_ServerRealm_get_raClientsTable_5[(signed long int)i]);
          signed int return_value___builtin_strcmp_7;
          return_value___builtin_strcmp_7=__builtin_strcmp(clientname, return_value_ConnectClient_get_sClientId_6);
          tmp_statement_expression_4 = return_value___builtin_strcmp_7;
          if(tmp_statement_expression_4 == 0)
          {
            struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_2;
            return_value_ServerRealm_get_raClientsTable_2=ServerRealm_get_raClientsTable(pointer);
            signed int return_value_ConnectClient_get_clientId_3;
            return_value_ConnectClient_get_clientId_3=ConnectClient_get_clientId(return_value_ServerRealm_get_raClientsTable_2[(signed long int)i]);
            return return_value_ConnectClient_get_clientId_3;
          }

        }

        i = i + 1;
      }
      while((_Bool)1);
      signed int return_value_sscanf_13;
      return_value_sscanf_13=sscanf(clientname, "%d%c", &i, &guard);
      if(return_value_sscanf_13 == 1)
      {
        n=get_raclientnumber(pointer, i);
        if(n >= 0)
        {
          return_value_ServerRealm_get_raClientsLimit_12=ServerRealm_get_raClientsLimit(pointer);
          if(!(n >= return_value_ServerRealm_get_raClientsLimit_12))
          {
            struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_10;
            return_value_ServerRealm_get_raClientsTable_10=ServerRealm_get_raClientsTable(pointer);
            char *return_value_ConnectClient_get_sClientId_11;
            return_value_ConnectClient_get_sClientId_11=ConnectClient_get_sClientId(return_value_ServerRealm_get_raClientsTable_10[(signed long int)n]);
            if(return_value_ConnectClient_get_sClientId_11 == ((char *)NULL))
              return i;

          }

        }

      }

      return -1;
    }
}

// get_raclientname
// file clientnames.h line 31
char * get_raclientname(struct anonymous_5 *pointer, signed int client)
{
  if(pointer == ((struct anonymous_5 *)NULL))
    return (char *)(void *)0;

  else
  {
    struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_3;
    return_value_ServerRealm_get_raClientsTable_3=ServerRealm_get_raClientsTable(pointer);
    char *return_value_ConnectClient_get_sClientId_4;
    return_value_ConnectClient_get_sClientId_4=ConnectClient_get_sClientId(return_value_ServerRealm_get_raClientsTable_3[(signed long int)client]);
    if(return_value_ConnectClient_get_sClientId_4 == ((char *)NULL))
    {
      static char clientname[10l];
      memset((void *)clientname, 0, (unsigned long int)10);
      struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_1;
      return_value_ServerRealm_get_raClientsTable_1=ServerRealm_get_raClientsTable(pointer);
      signed int return_value_ConnectClient_get_clientId_2;
      return_value_ConnectClient_get_clientId_2=ConnectClient_get_clientId(return_value_ServerRealm_get_raClientsTable_1[(signed long int)client]);
      sprintf(clientname, "%d", return_value_ConnectClient_get_clientId_2);
      return clientname;
    }

    struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_5;
    return_value_ServerRealm_get_raClientsTable_5=ServerRealm_get_raClientsTable(pointer);
    char *return_value_ConnectClient_get_sClientId_6;
    return_value_ConnectClient_get_sClientId_6=ConnectClient_get_sClientId(return_value_ServerRealm_get_raClientsTable_5[(signed long int)client]);
    return return_value_ConnectClient_get_sClientId_6;
  }
}

// get_raclientnumber
// file clientnames.c line 157
signed int get_raclientnumber(struct anonymous_5 *pointer, signed int clientid)
{
  signed int i;
  signed int return_value_ServerRealm_get_raClientsLimit_1;
  if(pointer == ((struct anonymous_5 *)NULL))
    return -1;

  else
  {
    i = 0;
    do
    {
      return_value_ServerRealm_get_raClientsLimit_1=ServerRealm_get_raClientsLimit(pointer);
      if(i >= return_value_ServerRealm_get_raClientsLimit_1)
        break;

      struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_2;
      return_value_ServerRealm_get_raClientsTable_2=ServerRealm_get_raClientsTable(pointer);
      signed int return_value_ConnectClient_get_clientId_3;
      return_value_ConnectClient_get_clientId_3=ConnectClient_get_clientId(return_value_ServerRealm_get_raClientsTable_2[(signed long int)i]);
      if(return_value_ConnectClient_get_clientId_3 == clientid)
        return i;

      i = i + 1;
    }
    while((_Bool)1);
    return -1;
  }
}

// get_realmname
// file realmnames.h line 27
char * get_realmname(struct anonymous_2 *config, signed int realm)
{
  struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_1;
  return_value_ServerConfiguration_get_realmsTable_1=ServerConfiguration_get_realmsTable(config);
  char *return_value_ServerRealm_get_realmName_2;
  return_value_ServerRealm_get_realmName_2=ServerRealm_get_realmName(return_value_ServerConfiguration_get_realmsTable_1[(signed long int)realm]);
  if(return_value_ServerRealm_get_realmName_2 == ((char *)NULL))
  {
    static char realmname[10l];
    memset((void *)realmname, 0, (unsigned long int)10);
    sprintf(realmname, "%d", realm);
    return realmname;
  }

  else
  {
    struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_3;
    return_value_ServerConfiguration_get_realmsTable_3=ServerConfiguration_get_realmsTable(config);
    char *return_value_ServerRealm_get_realmName_4;
    return_value_ServerRealm_get_realmName_4=ServerRealm_get_realmName(return_value_ServerConfiguration_get_realmsTable_3[(signed long int)realm]);
    return return_value_ServerRealm_get_realmName_4;
  }
}

// get_realmnumber
// file realmnames.h line 28
signed int get_realmnumber(struct anonymous_2 *config, char *realmname)
{
  signed int i;
  char guard;
  i = 0;
  signed int return_value_ServerConfiguration_get_realmsNumber_1;
  signed int tmp_statement_expression_2;
  do
  {
    return_value_ServerConfiguration_get_realmsNumber_1=ServerConfiguration_get_realmsNumber(config);
    if(i >= return_value_ServerConfiguration_get_realmsNumber_1)
      break;

    struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_6;
    return_value_ServerConfiguration_get_realmsTable_6=ServerConfiguration_get_realmsTable(config);
    char *return_value_ServerRealm_get_realmName_7;
    return_value_ServerRealm_get_realmName_7=ServerRealm_get_realmName(return_value_ServerConfiguration_get_realmsTable_6[(signed long int)i]);
    if(!(return_value_ServerRealm_get_realmName_7 == ((char *)NULL)))
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_3;
      return_value_ServerConfiguration_get_realmsTable_3=ServerConfiguration_get_realmsTable(config);
      char *return_value_ServerRealm_get_realmName_4;
      return_value_ServerRealm_get_realmName_4=ServerRealm_get_realmName(return_value_ServerConfiguration_get_realmsTable_3[(signed long int)i]);
      signed int return_value___builtin_strcmp_5;
      return_value___builtin_strcmp_5=__builtin_strcmp(realmname, return_value_ServerRealm_get_realmName_4);
      tmp_statement_expression_2 = return_value___builtin_strcmp_5;
      if(tmp_statement_expression_2 == 0)
        return i;

    }

    i = i + 1;
  }
  while((_Bool)1);
  signed int return_value_sscanf_11;
  return_value_sscanf_11=sscanf(realmname, "%d%c", &i, &guard);
  signed int return_value_ServerConfiguration_get_realmsNumber_10;
  if(return_value_sscanf_11 == 1)
  {
    if(i >= 0)
    {
      return_value_ServerConfiguration_get_realmsNumber_10=ServerConfiguration_get_realmsNumber(config);
      if(!(i >= return_value_ServerConfiguration_get_realmsNumber_10))
      {
        struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_8;
        return_value_ServerConfiguration_get_realmsTable_8=ServerConfiguration_get_realmsTable(config);
        char *return_value_ServerRealm_get_realmName_9;
        return_value_ServerRealm_get_realmName_9=ServerRealm_get_realmName(return_value_ServerConfiguration_get_realmsTable_8[(signed long int)i]);
        if(return_value_ServerRealm_get_realmName_9 == ((char *)NULL))
          return i;

      }

    }

  }

  return -1;
}

// get_ssl_error
// file make_ssl_handshake.c line 75
signed int get_ssl_error(struct anonymous_1 *sf, char *info, signed int result)
{
  signed int merror;
  char err_buff[200l];
  struct ssl_st *return_value_SslFd_get_ssl_1;
  return_value_SslFd_get_ssl_1=SslFd_get_ssl(sf);
  merror=SSL_get_error(return_value_SslFd_get_ssl_1, result);
  unsigned long int return_value_ERR_get_error_2;
  char *return_value_ERR_error_string_3;
  switch(merror)
  {
    case 0:
    {
      aflog((char)16, (char)32, "%s(%d): none", info, result);
      break;
    }
    case 6:
    {
      aflog((char)16, (char)32, "%s(%d): zero", info, result);
      break;
    }
    case 2:
    {
      aflog((char)16, (char)32, "%s(%d): w_read", info, result);
      break;
    }
    case 3:
    {
      aflog((char)16, (char)32, "%s(%d): w_write", info, result);
      break;
    }
    case 7:
    {
      aflog((char)16, (char)32, "%s(%d): w_connect", info, result);
      break;
    }
    case 4:
    {
      aflog((char)16, (char)32, "%s(%d): w_x509_lookup", info, result);
      break;
    }
    case 5:
    {
      aflog((char)16, (char)32, "%s(%d): syscall", info, result);
      break;
    }
    case 1:
    {
      SSL_load_error_strings();
      return_value_ERR_get_error_2=ERR_get_error();
      return_value_ERR_error_string_3=ERR_error_string(return_value_ERR_get_error_2, err_buff);
      aflog((char)16, (char)32, "%s(%d): ssl:%s", info, result, return_value_ERR_error_string_3);
      break;
    }
    default:
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      aflog((char)16, (char)32, "%s(%d): unrecognized error (%d)", info, result, *return_value___errno_location_4);
    }
  }
  if(merror == 2 || merror == 3)
    return 1;

  else
    return 2;
}

// get_store_filename
// file first_run.c line 376
char * get_store_filename()
{
  return home_dir_store;
}

// get_username
// file usernames.h line 27
signed int get_username(struct anonymous_5 *pointer, signed int user)
{
  struct anonymous_4 **return_value_ServerRealm_get_usersTable_1;
  return_value_ServerRealm_get_usersTable_1=ServerRealm_get_usersTable(pointer);
  signed int return_value_ConnectUser_get_userId_2;
  return_value_ConnectUser_get_userId_2=ConnectUser_get_userId(return_value_ServerRealm_get_usersTable_1[(signed long int)user]);
  return return_value_ConnectUser_get_userId_2;
}

// get_usernumber
// file usernames.h line 28
signed int get_usernumber(struct anonymous_5 *pointer, signed int userid)
{
  signed int i = 0;
  signed int return_value_ServerRealm_get_usersLimit_1;
  do
  {
    return_value_ServerRealm_get_usersLimit_1=ServerRealm_get_usersLimit(pointer);
    if(i >= return_value_ServerRealm_get_usersLimit_1)
      break;

    struct anonymous_4 **return_value_ServerRealm_get_usersTable_2;
    return_value_ServerRealm_get_usersTable_2=ServerRealm_get_usersTable(pointer);
    signed int return_value_ConnectUser_get_userId_3;
    return_value_ConnectUser_get_userId_3=ConnectUser_get_userId(return_value_ServerRealm_get_usersTable_2[(signed long int)i]);
    if(userid == return_value_ConnectUser_get_userId_3)
      return i;

    i = i + 1;
  }
  while((_Bool)1);
  return -1;
}

// getcg
// file stats.c line 73
signed long int getcg(void)
{
  return compressgained;
}

// getdateformat
// file logging.h line 65
char * getdateformat()
{
  return format;
}

// getloglisthead
// file logging.h line 67
struct llnode * getloglisthead()
{
  return head;
}

// http_proxy_server
// file http_proxy_server.c line 83
void * http_proxy_server(void *vptr)
{
  signed int listenfd;
  signed int afserverfd;
  struct anonymous_1 *connFd;
  struct sockaddr *cliaddr;
  char tab[9000l];
  struct anonymous_27 *table;
  struct anonymous_26 hdr;
  signed int i;
  signed int n;
  signed int maxfdp1;
  struct anonymous_22 rset;
  struct anonymous_22 allset;
  struct timeval tv;
  signed int maxclients;
  signed int tmp;
  signed int timeout = 5;
  unsigned int *addrlenp;
  unsigned int addrlen;
  char type;
  char nothttp;
  char https;
  char *host;
  char *serv;
  char *name = "";
  struct ssl_ctx_st *ctx;
  struct anonymous_28 *proxy_argptr;
  start_critical_section();
  proxy_argptr = (struct anonymous_28 *)vptr;
  afserverfd = proxy_argptr->sockfd;
  host = proxy_argptr->host;
  serv = proxy_argptr->serv;
  addrlenp = proxy_argptr->addrlenp;
  type = proxy_argptr->type;
  maxclients = proxy_argptr->limit + 1;
  https = proxy_argptr->https;
  ctx = proxy_argptr->ctx;
  if(!(https == 0))
    name = "s";

  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)maxclients, sizeof(struct anonymous_27) /*18104ul*/ );
  table = (struct anonymous_27 *)return_value_calloc_1;
  if(table == ((struct anonymous_27 *)NULL))
  {
    aflog((char)4, (char)1, "http%s proxy: Can't allocate memory... exiting.", name);
    exit(1);
  }

  i = 0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_9;
  struct ssl_st *return_value_SslFd_get_ssl_8;
  _Bool tmp_if_expr_11;
  struct ssl_st *return_value_SslFd_get_ssl_10;
  for( ; !(i >= maxclients); i = i + 1)
  {
    (table + (signed long int)i)->postFd=SslFd_new();
    (table + (signed long int)i)->getFd=SslFd_new();
    (table + (signed long int)i)->tmpFd=SslFd_new();
    if((table + (signed long int)i)->postFd == ((struct anonymous_1 *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (table + (signed long int)i)->getFd == (struct anonymous_1 *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (table + (signed long int)i)->tmpFd == (struct anonymous_1 *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      aflog((char)4, (char)1, "http%s proxy: Can't allocate memory... exiting.", name);
      exit(1);
    }

    if(!(https == 0))
    {
      struct ssl_st *return_value_SSL_new_4;
      return_value_SSL_new_4=SSL_new(ctx);
      SslFd_set_ssl((table + (signed long int)i)->postFd, return_value_SSL_new_4);
      struct ssl_st *return_value_SSL_new_5;
      return_value_SSL_new_5=SSL_new(ctx);
      SslFd_set_ssl((table + (signed long int)i)->getFd, return_value_SSL_new_5);
      struct ssl_st *return_value_SSL_new_6;
      return_value_SSL_new_6=SSL_new(ctx);
      SslFd_set_ssl((table + (signed long int)i)->tmpFd, return_value_SSL_new_6);
      struct ssl_st *return_value_SslFd_get_ssl_7;
      return_value_SslFd_get_ssl_7=SslFd_get_ssl((table + (signed long int)i)->postFd);
      if(return_value_SslFd_get_ssl_7 == ((struct ssl_st *)NULL))
        tmp_if_expr_9 = (_Bool)1;

      else
      {
        return_value_SslFd_get_ssl_8=SslFd_get_ssl((table + (signed long int)i)->getFd);
        tmp_if_expr_9 = return_value_SslFd_get_ssl_8 == (struct ssl_st *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_9)
        tmp_if_expr_11 = (_Bool)1;

      else
      {
        return_value_SslFd_get_ssl_10=SslFd_get_ssl((table + (signed long int)i)->tmpFd);
        tmp_if_expr_11 = return_value_SslFd_get_ssl_10 == (struct ssl_st *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_11)
      {
        aflog((char)4, (char)1, "http%s proxy: Can't allocate memory... exiting.", name);
        exit(1);
      }

    }

  }
  connFd=SslFd_new();
  if(connFd == ((struct anonymous_1 *)NULL))
  {
    aflog((char)4, (char)1, "http%s proxy: Can't allocate memory... exiting.", name);
    exit(1);
  }

  if(!(https == 0))
  {
    struct ssl_st *return_value_SSL_new_12;
    return_value_SSL_new_12=SSL_new(ctx);
    SslFd_set_ssl(connFd, return_value_SSL_new_12);
    struct ssl_st *return_value_SslFd_get_ssl_13;
    return_value_SslFd_get_ssl_13=SslFd_get_ssl(connFd);
    if(return_value_SslFd_get_ssl_13 == ((struct ssl_st *)NULL))
    {
      aflog((char)4, (char)1, "http%s proxy: Can't allocate memory... exiting.", name);
      exit(1);
    }

  }

  signed int return_value_ip_listen_14;
  return_value_ip_listen_14=ip_listen(&listenfd, host, serv, addrlenp, type);
  if(!(return_value_ip_listen_14 == 0))
  {
    aflog((char)4, (char)1, "http%s proxy: Can't listen on %s:%s", name, host, serv);
    exit(1);
  }

  void *return_value_malloc_15;
  return_value_malloc_15=malloc((unsigned long int)*addrlenp);
  cliaddr = (struct sockaddr *)return_value_malloc_15;
  addrlen = *addrlenp;
  addrlenp = &addrlen;
  broadcast_condition();
  end_critical_section();
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_22) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&allset)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&allset)->__fds_bits[(signed long int)(listenfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(listenfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << listenfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
  maxfdp1 = listenfd + 1;
  tv.tv_usec = (signed long int)0;
  tv.tv_sec = (signed long int)timeout;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_19;
  _Bool tmp_if_expr_27;
  signed int tmp_statement_expression_40;
  while((_Bool)1)
  {
    rset = allset;
    signed int return_value_select_18;
    return_value_select_18=select(maxfdp1, &rset, (struct anonymous_22 *)(void *)0, (struct anonymous_22 *)(void *)0, &tv);
    if(return_value_select_18 == 0)
    {
      aflog((char)16, (char)4, "http%s proxy: timeout", name);
      tv.tv_sec = (signed long int)timeout;
      i = 0;
      for( ; !(i >= maxclients); i = i + 1)
      {
        if((signed int)(table + (signed long int)i)->state == 0)
          tmp_if_expr_16 = (_Bool)1;

        else
          tmp_if_expr_16 = ((signed int)(table + (signed long int)i)->state & 2) != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_16)
          tmp_if_expr_17 = (_Bool)1;

        else
          tmp_if_expr_17 = (signed int)(table + (signed long int)i)->type == 1 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_17)
        {
          aflog((char)16, (char)4, "http%s proxy: send T to table[%d].getfd", name, i);
          if(1 + (table + (signed long int)i)->sent_ptr >= 90000)
          {
            http_write(https, (table + (signed long int)i)->getFd, (unsigned char *)"T", 1);
            (table + (signed long int)i)->sent_ptr = 0;
            clear_sslFd((table + (signed long int)i)->getFd, &allset);
            (&allset)->__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << (table + (signed long int)i)->sockfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
            (table + (signed long int)i)->state = (table + (signed long int)i)->state | (char)2;
          }

          else
          {
            http_write(https, (table + (signed long int)i)->getFd, (unsigned char *)"T", 1);
            (table + (signed long int)i)->sent_ptr = (table + (signed long int)i)->sent_ptr + 1;
          }
        }

      }
    }

    else
    {
      i = 0;
      for( ; !(i >= maxclients); i = i + 1)
      {
        if((signed int)(table + (signed long int)i)->state == 0)
          tmp_if_expr_19 = (_Bool)1;

        else
          tmp_if_expr_19 = (signed int)(table + (signed long int)i)->type == 1 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_19)
        {
          if((2 & (signed int)(table + (signed long int)i)->state) == 0)
          {
            if(!((rset.__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / 8)] & 1l << (table + (signed long int)i)->sockfd % 8) == 0l))
            {
              aflog((char)16, (char)4, "http%s proxy: FD_ISSET(table[%d].sockfd)", name, i);
              signed long int return_value_read_20;
              return_value_read_20=read((table + (signed long int)i)->sockfd, (void *)((table + (signed long int)i)->buf + (signed long int)5), (unsigned long int)8995);
              n = (signed int)return_value_read_20;
              if(!(n >= 1))
              {
                http_write(https, (table + (signed long int)i)->getFd, (unsigned char *)"Q", 1);
                delete_user(table, i, &allset);
                goto __CPROVER_DUMP_L51;
              }

              (table + (signed long int)i)->buf[(signed long int)0] = (char)77;
              unsigned int return_value___bswap_32_21;
              return_value___bswap_32_21=__bswap_32_link1((unsigned int)n);
              tmp = (signed int)return_value___bswap_32_21;
              memcpy((void *)&(table + (signed long int)i)->buf[(signed long int)1], (const void *)&tmp, (unsigned long int)4);
              if(5 + (table + (signed long int)i)->sent_ptr + n >= 90000)
              {
                http_write(https, (table + (signed long int)i)->getFd, (unsigned char *)(table + (signed long int)i)->buf, 90000 - (table + (signed long int)i)->sent_ptr);
                (table + (signed long int)i)->ptr = 90000 - (table + (signed long int)i)->sent_ptr;
                (table + (signed long int)i)->length = (5 + n) - (table + (signed long int)i)->ptr;
                (table + (signed long int)i)->sent_ptr = 0;
                clear_sslFd((table + (signed long int)i)->getFd, &allset);
                (&allset)->__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << (table + (signed long int)i)->sockfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                (table + (signed long int)i)->state = (table + (signed long int)i)->state | (char)2;
                goto __CPROVER_DUMP_L51;
              }

              else
              {
                http_write(https, (table + (signed long int)i)->getFd, (unsigned char *)(table + (signed long int)i)->buf, n + 5);
                (table + (signed long int)i)->sent_ptr = (table + (signed long int)i)->sent_ptr + n + 5;
              }
            }

          }

          signed int return_value_SslFd_get_fd_22;
          return_value_SslFd_get_fd_22=SslFd_get_fd((table + (signed long int)i)->getFd);
          signed int return_value_SslFd_get_fd_23;
          return_value_SslFd_get_fd_23=SslFd_get_fd((table + (signed long int)i)->getFd);
          if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd_22 / 8)] & 1l << return_value_SslFd_get_fd_23 % 8) == 0l))
          {
            aflog((char)16, (char)4, "http%s proxy: FD_ISSET(table[%d].getfd)", name, i);
            delete_user(table, i, &allset);
          }

          else
          {
            signed int return_value_SslFd_get_fd_28;
            return_value_SslFd_get_fd_28=SslFd_get_fd((table + (signed long int)i)->postFd);
            signed int return_value_SslFd_get_fd_29;
            return_value_SslFd_get_fd_29=SslFd_get_fd((table + (signed long int)i)->postFd);
            if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd_28 / 8)] & 1l << return_value_SslFd_get_fd_29 % 8) == 0l))
            {
              aflog((char)16, (char)4, "http%s proxy: FD_ISSET(table[%d].postfd)", name, i);
              n=http_read(https, (table + (signed long int)i)->postFd, (unsigned char *)tab, 9000);
              if(!(n == 0))
              {
                (table + (signed long int)i)->received = (table + (signed long int)i)->received + n;
                signed int return_value_read_message_24;
                return_value_read_message_24=read_message((table + (signed long int)i)->sockfd, n, &table[(signed long int)i], tab, 0);
                if(!(return_value_read_message_24 == 0))
                  delete_user(table, i, &allset);

              }

              if(n == 0)
                tmp_if_expr_27 = (_Bool)1;

              else
                tmp_if_expr_27 = (table + (signed long int)i)->received == 90000 ? (_Bool)1 : (_Bool)0;
              if(!tmp_if_expr_27)
                goto __CPROVER_DUMP_L50;

              (table + (signed long int)i)->received = 0;
              clear_sslFd((table + (signed long int)i)->postFd, &allset);
              (table + (signed long int)i)->state = (table + (signed long int)i)->state | (char)1;
              if((2 & (signed int)(table + (signed long int)i)->state) == 0)
              {
                aflog((char)16, (char)4, "http%s proxy: send A to table[%d].getfd", name, i);
                if(1 + (table + (signed long int)i)->sent_ptr >= 90000)
                {
                  http_write(https, (table + (signed long int)i)->getFd, (unsigned char *)"A", 1);
                  (table + (signed long int)i)->sent_ptr = 0;
                  clear_sslFd((table + (signed long int)i)->getFd, &allset);
                  (&allset)->__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << (table + (signed long int)i)->sockfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  (table + (signed long int)i)->state = (table + (signed long int)i)->state | (char)2;
                }

                else
                {
                  http_write(https, (table + (signed long int)i)->getFd, (unsigned char *)"A", 1);
                  (table + (signed long int)i)->sent_ptr = (table + (signed long int)i)->sent_ptr + 1;
                }
              }

              else
                (table + (signed long int)i)->state = (table + (signed long int)i)->state | (char)8;
              if((signed int)(table + (signed long int)i)->tmpstate == 1)
              {
                aflog((char)16, (char)2, "http%s proxy: get old POST request...", name);
                (table + (signed long int)i)->state = (table + (signed long int)i)->state & (char)~1;
                SslFd_swap_content((table + (signed long int)i)->postFd, (table + (signed long int)i)->tmpFd);
                signed int return_value_SslFd_get_fd_25;
                return_value_SslFd_get_fd_25=SslFd_get_fd((table + (signed long int)i)->postFd);
                set_fd(return_value_SslFd_get_fd_25, &maxfdp1, &allset);
                (table + (signed long int)i)->tmpstate = (char)0;
                if(!((table + (signed long int)i)->tmpheader.length == 0))
                {
                  (table + (signed long int)i)->received = (table + (signed long int)i)->received + (table + (signed long int)i)->tmpheader.length;
                  signed int return_value_read_message_26;
                  return_value_read_message_26=read_message((table + (signed long int)i)->sockfd, (table + (signed long int)i)->tmpheader.length, &table[(signed long int)i], (table + (signed long int)i)->tmpbuf, (table + (signed long int)i)->tmpheader.ptr);
                  if(!(return_value_read_message_26 == 0))
                    delete_user(table, i, &allset);

                }

              }

            }

            else

              __CPROVER_DUMP_L50:
                ;
          }
        }


      __CPROVER_DUMP_L51:
        ;
      }
      i = 0;
      for( ; !(i >= maxclients); i = i + 1)
      {
        if((signed int)(table + (signed long int)i)->state == 4)
        {
          if((signed int)(table + (signed long int)i)->type == 1)
          {
            if(!((rset.__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / 8)] & 1l << (table + (signed long int)i)->sockfd % 8) == 0l))
            {
              signed long int return_value_read_30;
              return_value_read_30=read((table + (signed long int)i)->sockfd, (void *)(table + (signed long int)i)->buf, (unsigned long int)9000);
              n = (signed int)return_value_read_30;
              if(n >= 1)
              {
                signed int return_value_SslFd_get_fd_31;
                return_value_SslFd_get_fd_31=SslFd_get_fd((table + (signed long int)i)->postFd);
                writen(return_value_SslFd_get_fd_31, (unsigned char *)(table + (signed long int)i)->buf, n);
              }

              else
              {
                delete_user(table, i, &allset);
                goto __CPROVER_DUMP_L60;
              }
            }

            signed int return_value_SslFd_get_fd_34;
            return_value_SslFd_get_fd_34=SslFd_get_fd((table + (signed long int)i)->postFd);
            signed int return_value_SslFd_get_fd_35;
            return_value_SslFd_get_fd_35=SslFd_get_fd((table + (signed long int)i)->postFd);
            if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd_34 / 8)] & 1l << return_value_SslFd_get_fd_35 % 8) == 0l))
            {
              signed int return_value_SslFd_get_fd_32;
              return_value_SslFd_get_fd_32=SslFd_get_fd((table + (signed long int)i)->postFd);
              signed long int return_value_read_33;
              return_value_read_33=read(return_value_SslFd_get_fd_32, (void *)tab, (unsigned long int)9000);
              n = (signed int)return_value_read_33;
              if(n >= 1)
                writen((table + (signed long int)i)->sockfd, (unsigned char *)tab, n);

              else
              {
                delete_user(table, i, &allset);
                goto __CPROVER_DUMP_L60;
              }
            }

          }

        }


      __CPROVER_DUMP_L60:
        ;
      }
      if(!((rset.__fds_bits[(signed long int)(listenfd / 8)] & 1l << listenfd % 8) == 0l))
      {
        aflog((char)16, (char)4, "http%s proxy: FD_ISSET(listenfd)", name);
        tmp=accept(listenfd, cliaddr, addrlenp);
        if(!(tmp == -1))
        {
          aflog((char)16, (char)2, "http%s proxy: New connection...", name);
          SslFd_set_fd(connFd, tmp);
          if(!(https == 0))
          {
            make_ssl_initialize(connFd);
            signed int return_value_make_ssl_accept_38;
            return_value_make_ssl_accept_38=make_ssl_accept(connFd);
            if(!(return_value_make_ssl_accept_38 == 0))
            {
              aflog((char)16, (char)2, "https proxy: DENIED by SSL_accept");
              signed int return_value_SslFd_get_fd_36;
              return_value_SslFd_get_fd_36=SslFd_get_fd(connFd);
              close(return_value_SslFd_get_fd_36);
              struct ssl_st *return_value_SslFd_get_ssl_37;
              return_value_SslFd_get_ssl_37=SslFd_get_ssl(connFd);
              SSL_clear(return_value_SslFd_get_ssl_37);
              continue;
            }

          }

        }

        else
        {
          aflog((char)16, (char)2, "http%s proxy: New connection --> EAGAIN", name);
          continue;
        }
        memset((void *)tab, 0, (unsigned long int)9000);
        nothttp = (char)0;
        signed int return_value_parse_header_39;
        return_value_parse_header_39=parse_header(connFd, tab, &hdr, https);
        if(!(return_value_parse_header_39 == 0))
        {
          nothttp = (char)1;
          aflog((char)16, (char)2, "http%s proxy: no http header...", name);
        }

        n = -1;
        i = 0;
        for( ; !(i >= maxclients); i = i + 1)
          if((signed int)(table + (signed long int)i)->state == 0)
          {
            if(n == -1)
              n = i;

          }

          else
            if(nothttp == 0)
            {
              unsigned long int __s1_len;
              unsigned long int __s2_len;
              signed int return_value___builtin_strcmp_41;
              return_value___builtin_strcmp_41=__builtin_strcmp((table + (signed long int)i)->id, hdr.id);
              tmp_statement_expression_40 = return_value___builtin_strcmp_41;
              if(tmp_statement_expression_40 == 0)
                break;

            }

        if(!(i >= maxclients))
        {
          aflog((char)16, (char)2, "http%s proxy: the client exist...", name);
          if((signed int)hdr.type == 0)
          {
            aflog((char)16, (char)2, "http%s proxy: type GET...", name);
            if((2 & (signed int)(table + (signed long int)i)->state) == 0)
            {
              aflog((char)16, (char)2, "http%s proxy: not waiting for GET...", name);
              (table + (signed long int)i)->sent_ptr = 0;
              (&allset)->__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << (table + (signed long int)i)->sockfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
              clear_sslFd((table + (signed long int)i)->getFd, &allset);
              (table + (signed long int)i)->state = (table + (signed long int)i)->state | (char)2;
            }

            if((4 & (signed int)(table + (signed long int)i)->state) == 0)
            {
              aflog((char)16, (char)2, "http%s proxy: not opened...", name);
              signed int return_value_afserver_connect_44;
              return_value_afserver_connect_44=afserver_connect(&(table + (signed long int)i)->sockfd, afserverfd, cliaddr, addrlenp, (char)1);
              if(!(return_value_afserver_connect_44 == 0))
              {
                memset((void *)tab, 0, (unsigned long int)9000);
                sprintf(tab, "HTTP/1.1 400 Bad Request\r\n\r\n");
                unsigned long int return_value_strlen_42;
                return_value_strlen_42=strlen(tab);
                n = (signed int)return_value_strlen_42;
                http_write(https, connFd, (unsigned char *)tab, n);
                close_fd(&connFd->fd);
                struct ssl_st *return_value_SslFd_get_ssl_43;
                return_value_SslFd_get_ssl_43=SslFd_get_ssl(connFd);
                SSL_clear(return_value_SslFd_get_ssl_43);
                clear_sslFd((table + (signed long int)i)->postFd, &allset);
                (table + (signed long int)i)->state = (char)0;
                continue;
              }

              (table + (signed long int)i)->state = (table + (signed long int)i)->state | (char)4;
              aflog((char)16, (char)2, "http%s proxy: OPEN...", name);
            }

            (table + (signed long int)i)->state = (table + (signed long int)i)->state & (char)~2;
            (table + (signed long int)i)->sent_ptr = 0;
            SslFd_swap_content((table + (signed long int)i)->getFd, connFd);
            set_fd((table + (signed long int)i)->sockfd, &maxfdp1, &allset);
            signed int return_value_SslFd_get_fd_45;
            return_value_SslFd_get_fd_45=SslFd_get_fd((table + (signed long int)i)->getFd);
            set_fd(return_value_SslFd_get_fd_45, &maxfdp1, &allset);
            memset((void *)tab, 0, (unsigned long int)9000);
            sprintf(tab, "HTTP/1.1 200 OK\r\nContent-Length: 90000\r\nConnection: close\r\nPragma: no-cache\r\nCache-Control: no-cache, no-store, must-revalidate\r\nExpires: 0\r\nContent-Type: text/html\r\n\r\n");
            unsigned long int return_value_strlen_46;
            return_value_strlen_46=strlen(tab);
            n = (signed int)return_value_strlen_46;
            signed int return_value_SslFd_get_fd_47;
            return_value_SslFd_get_fd_47=SslFd_get_fd((table + (signed long int)i)->getFd);
            signed int return_value_writen_48;
            return_value_writen_48=writen(return_value_SslFd_get_fd_47, (unsigned char *)tab, n);
            if(!(return_value_writen_48 >= 1))
            {
              delete_user(table, i, &allset);
              continue;
            }

            if(!((table + (signed long int)i)->length == 0))
            {
              signed int return_value_SslFd_get_fd_49;
              return_value_SslFd_get_fd_49=SslFd_get_fd((table + (signed long int)i)->getFd);
              signed int return_value_writen_50;
              return_value_writen_50=writen(return_value_SslFd_get_fd_49, (unsigned char *)((table + (signed long int)i)->buf + (signed long int)(table + (signed long int)i)->ptr), (table + (signed long int)i)->length);
              if(!(return_value_writen_50 >= 1))
              {
                delete_user(table, i, &allset);
                continue;
              }

            }

            (table + (signed long int)i)->sent_ptr = (table + (signed long int)i)->length;
            (table + (signed long int)i)->ptr = 0;
            (table + (signed long int)i)->length = 0;
            if(!((8 & (signed int)(table + (signed long int)i)->state) == 0))
            {
              aflog((char)16, (char)4, "http%s proxy: send A to table[%d].getfd", name, i);
              http_write(https, (table + (signed long int)i)->getFd, (unsigned char *)"A", 1);
              (table + (signed long int)i)->sent_ptr = (table + (signed long int)i)->sent_ptr + 1;
              (table + (signed long int)i)->state = (table + (signed long int)i)->state & (char)~8;
            }

          }

          else
            if((signed int)hdr.type == 1)
            {
              aflog((char)16, (char)2, "http%s proxy: type POST...", name);
              if((1 & (signed int)(table + (signed long int)i)->state) == 0)
              {
                aflog((char)16, (char)2, "http%s proxy: unexpected POST request...", name);
                if((signed int)(table + (signed long int)i)->tmpstate == 0)
                {
                  aflog((char)16, (char)2, "http%s proxy: buffering POST request...", name);
                  (table + (signed long int)i)->tmpstate = (char)1;
                  SslFd_swap_content((table + (signed long int)i)->tmpFd, connFd);
                  memcpy((void *)(table + (signed long int)i)->tmpbuf, (const void *)tab, (unsigned long int)9000);
                  (table + (signed long int)i)->tmpheader = hdr;
                }

                else
                {
                  aflog((char)16, (char)2, "http%s proxy: no space to buffer POST request (received from first postfd: %d)", name, (table + (signed long int)i)->received);
                  delete_user(table, i, &allset);
                }
              }

              else
              {
                if(!(hdr.length == 0))
                {
                  (table + (signed long int)i)->received = (table + (signed long int)i)->received + hdr.length;
                  signed int return_value_read_message_51;
                  return_value_read_message_51=read_message((table + (signed long int)i)->sockfd, hdr.length, &table[(signed long int)i], tab, hdr.ptr);
                  if(!(return_value_read_message_51 == 0))
                    delete_user(table, i, &allset);

                }

                (table + (signed long int)i)->state = (table + (signed long int)i)->state & (char)~1;
                SslFd_swap_content((table + (signed long int)i)->postFd, connFd);
                signed int return_value_SslFd_get_fd_52;
                return_value_SslFd_get_fd_52=SslFd_get_fd((table + (signed long int)i)->postFd);
                set_fd(return_value_SslFd_get_fd_52, &maxfdp1, &allset);
              }
            }

            else
            {
              aflog((char)16, (char)2, "http%s proxy: unrecognized type...", name);
              delete_user(table, i, &allset);
            }
        }

        else
          if(!(n == -1))
          {
            aflog((char)16, (char)2, "http%s proxy: there are free slots...", name);
            if(nothttp == 0)
            {
              aflog((char)16, (char)2, "http%s proxy: http header...", name);
              if((signed int)hdr.type == 1)
              {
                aflog((char)16, (char)2, "http%s proxy: type POST...", name);
                (table + (signed long int)n)->state = (char)2;
                memcpy((void *)(table + (signed long int)n)->id, (const void *)hdr.id, (unsigned long int)9);
                SslFd_swap_content((table + (signed long int)n)->postFd, connFd);
                signed int return_value_SslFd_get_fd_53;
                return_value_SslFd_get_fd_53=SslFd_get_fd((table + (signed long int)n)->postFd);
                set_fd(return_value_SslFd_get_fd_53, &maxfdp1, &allset);
              }

              else
              {
                aflog((char)16, (char)2, "http%s proxy: closing this connection... (not POST type)", name);
                close_fd(&connFd->fd);
                if(!(https == 0))
                {
                  struct ssl_st *return_value_SslFd_get_ssl_54;
                  return_value_SslFd_get_ssl_54=SslFd_get_ssl(connFd);
                  SSL_clear(return_value_SslFd_get_ssl_54);
                }

                continue;
              }
            }

            else
            {
              (table + (signed long int)n)->state = (char)4;
              signed int return_value_SslFd_get_fd_55;
              return_value_SslFd_get_fd_55=SslFd_get_fd(connFd);
              SslFd_set_fd((table + (signed long int)n)->postFd, return_value_SslFd_get_fd_55);
              (table + (signed long int)n)->type = (char)1;
              signed int return_value_SslFd_get_fd_56;
              return_value_SslFd_get_fd_56=SslFd_get_fd((table + (signed long int)n)->postFd);
              set_fd(return_value_SslFd_get_fd_56, &maxfdp1, &allset);
              signed int return_value_afserver_connect_57;
              return_value_afserver_connect_57=afserver_connect(&(table + (signed long int)n)->sockfd, afserverfd, cliaddr, addrlenp, (char)0);
              if(!(return_value_afserver_connect_57 == 0))
              {
                clear_sslFd((table + (signed long int)n)->postFd, &allset);
                (table + (signed long int)n)->state = (char)0;
                continue;
              }

              set_fd((table + (signed long int)n)->sockfd, &maxfdp1, &allset);
              write((table + (signed long int)n)->sockfd, (const void *)tab, (unsigned long int)hdr.allreaded);
            }
          }

          else
          {
            aflog((char)16, (char)2, "http%s proxy: closing this connection... (no free slots)", name);
            close_fd(&connFd->fd);
            continue;
          }
      }

    }
  }
  return NULL;
}

// http_read
// file http_proxy_functions.c line 402
signed int http_read(char https, struct anonymous_1 *sf, unsigned char *buf, signed int amount)
{
  if(!(https == 0))
  {
    struct ssl_st *return_value_SslFd_get_ssl_1;
    return_value_SslFd_get_ssl_1=SslFd_get_ssl(sf);
    signed int return_value_SSL_read_2;
    return_value_SSL_read_2=SSL_read(return_value_SslFd_get_ssl_1, (void *)buf, amount);
    return return_value_SSL_read_2;
  }

  else
  {
    signed int return_value_SslFd_get_fd_3;
    return_value_SslFd_get_fd_3=SslFd_get_fd(sf);
    signed long int return_value_read_4;
    return_value_read_4=read(return_value_SslFd_get_fd_3, (void *)buf, (unsigned long int)amount);
    return (signed int)return_value_read_4;
  }
}

// http_write
// file http_proxy_functions.c line 381
signed int http_write(char https, struct anonymous_1 *sf, unsigned char *buf, signed int amount)
{
  if(!(https == 0))
  {
    struct ssl_st *return_value_SslFd_get_ssl_1;
    return_value_SslFd_get_ssl_1=SslFd_get_ssl(sf);
    signed int return_value_SSL_writen_2;
    return_value_SSL_writen_2=SSL_writen(return_value_SslFd_get_ssl_1, buf, amount);
    return return_value_SSL_writen_2;
  }

  else
  {
    signed int return_value_SslFd_get_fd_3;
    return_value_SslFd_get_fd_3=SslFd_get_fd(sf);
    signed int return_value_writen_4;
    return_value_writen_4=writen(return_value_SslFd_get_fd_3, buf, amount);
    return return_value_writen_4;
  }
}

// initialize_http_proxy_server
// file http_proxy_server.h line 27
signed int initialize_http_proxy_server(signed int *sockfd, const char *host, const char *serv, unsigned int *addrlenp, const char type, signed int limit, char https, struct ssl_ctx_st *ctx)
{
  signed int retval;
  signed int sockets[2l];
  unsigned long int proxy_thread;
  signed int return_value_socketpair_1;
  return_value_socketpair_1=socketpair(1, 1, 0, sockets);
  if(!(return_value_socketpair_1 == 0))
    return 1;

  else
  {
    *sockfd = sockets[(signed long int)0];
    start_critical_section();
    static struct anonymous_28 arg;
    arg.host = (char *)host;
    arg.serv = (char *)serv;
    arg.addrlenp = addrlenp;
    arg.limit = limit;
    arg.type = (char)type;
    arg.sockfd = sockets[(signed long int)1];
    arg.https = https;
    arg.ctx = ctx;
    retval=pthread_create(&proxy_thread, (const union pthread_attr_t *)(void *)0, http_proxy_server, (void *)&arg);
    wait_for_condition();
    end_critical_section();
    return retval;
  }
}

// initializelogging
// file logging.h line 71
void initializelogging(char verl, char *dateformat)
{
  signed int k;
  k=loginit(verl, dateformat);
  if(!(k == 0))
  {
    switch(k)
    {
      case 1:
      {
        printf("Wrong format of the logcmd\n");
        break;
      }
      case 2:
      {
        printf("Unknown type of the logging target\n");
        break;
      }
      case 3:
      {
        printf("Wrong description of the logging target (name too long)\n");
        break;
      }
      case 4:
      {
        printf("Can't open file to log to\n");
        break;
      }
      case 5:
      {
        printf("Can't connect to target host\n");
        break;
      }
      case 6:
        printf("Wrong msgtype/importance description\n");
    }
    exit(1);
  }

}

// ip_connect
// file network.c line 186
signed int ip_connect(signed int *sockfd, const char *host, const char *serv, const char type, const char *lhost, const char *lserv)
{
  const signed int on = 1;
  signed int n;
  signed int bindFailed;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *ressave;
  struct addrinfo lhints;
  struct addrinfo *lres;
  struct addrinfo *lressave = (struct addrinfo *)(void *)0;
  aflog((char)4, (char)4, "ip_connect: host=[%s] serv=[%s], type=[%d], lhost=[%s], lserv=[%s]", host, serv, type, lhost, lserv);
  bzero((void *)&hints, sizeof(struct addrinfo) /*48ul*/ );
  if(!((0x02 & (signed int)type) == 0))
    hints.ai_family = 2;

  else
    if(!((0x04 & (signed int)type) == 0))
      hints.ai_family = 10;

    else
      hints.ai_family = 0;
  if(!((0x01 & (signed int)type) == 0))
    hints.ai_socktype = 1;

  else
    hints.ai_socktype = 2;
  lhints = hints;
  if(!(lhost == ((const char *)NULL)) || !(lserv == ((const char *)NULL)))
  {
    n=getaddrinfo(lhost, lserv, &lhints, &lres);
    if(!(n == 0))
      return n;

    lressave = lres;
  }

  n=getaddrinfo(host, serv, &hints, &res);
  if(!(n == 0))
    return n;

  else
  {
    ressave = res;
    do
    {
      *sockfd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
      if(*sockfd >= 0)
      {
        if(!((0x01 & (signed int)type) == 0))
          setsockopt(*sockfd, 1, 9, (const void *)&on, (unsigned int)sizeof(const signed int) /*4ul*/ );

        bindFailed = 0;
        if(!(lhost == ((const char *)NULL)) || !(lserv == ((const char *)NULL)))
        {
          bindFailed = 1;
          lres = lressave;
          do
          {
            signed int return_value_bind_1;
            return_value_bind_1=bind(*sockfd, lres->ai_addr, lres->ai_addrlen);
            if(return_value_bind_1 == 0)
            {
              bindFailed = 0;
              break;
            }

            lres = lres->ai_next;
          }
          while(!(lres == ((struct addrinfo *)NULL)));
        }

        if(bindFailed == 1)
          close(*sockfd);

        else
        {
          signed int return_value_connect_2;
          return_value_connect_2=connect(*sockfd, res->ai_addr, res->ai_addrlen);
          if(return_value_connect_2 == 0)
            break;

          close(*sockfd);
        }
      }

      res = res->ai_next;
    }
    while(!(res == ((struct addrinfo *)NULL)));
    if(res == ((struct addrinfo *)NULL))
      return 1;

    else
    {
      if(!(lhost == ((const char *)NULL)) || !(lserv == ((const char *)NULL)))
        freeaddrinfo(lressave);

      freeaddrinfo(ressave);
      return 0;
    }
  }
}

// ip_listen
// file network.h line 39
signed int ip_listen(signed int *sockfd, const char *host, const char *serv, unsigned int *addrlenp, const char type)
{
  const signed int on = 1;
  signed int n;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *ressave;
  aflog((char)4, (char)4, "ip_listen: host=[%s] serv=[%s], type=[%d]", host, serv, type);
  bzero((void *)&hints, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_flags = 0x0001;
  if(!((0x02 & (signed int)type) == 0))
    hints.ai_family = 2;

  else
    if(!((0x04 & (signed int)type) == 0))
      hints.ai_family = 10;

    else
      hints.ai_family = 0;
  if(!((0x01 & (signed int)type) == 0))
    hints.ai_socktype = 1;

  else
    hints.ai_socktype = 2;
  n=getaddrinfo(host, serv, &hints, &res);
  if(!(n == 0))
    return n;

  else
  {
    ressave = res;
    do
    {
      *sockfd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
      if(*sockfd >= 0)
      {
        if(!((0x01 & (signed int)type) == 0))
        {
          setsockopt(*sockfd, 1, 2, (const void *)&on, (unsigned int)sizeof(const signed int) /*4ul*/ );
          setsockopt(*sockfd, 1, 9, (const void *)&on, (unsigned int)sizeof(const signed int) /*4ul*/ );
        }

        signed int return_value_bind_1;
        return_value_bind_1=bind(*sockfd, res->ai_addr, res->ai_addrlen);
        if(return_value_bind_1 == 0)
          break;

        close(*sockfd);
      }

      res = res->ai_next;
    }
    while(!(res == ((struct addrinfo *)NULL)));
    if(res == ((struct addrinfo *)NULL))
      return 1;

    else
    {
      if(!((0x01 & (signed int)type) == 0))
        listen(*sockfd, 1);

      if(!(addrlenp == ((unsigned int *)NULL)))
        *addrlenp = res->ai_addrlen;

      freeaddrinfo(ressave);
      return 0;
    }
  }
}

// is_this_a_mainthread
// file thread_management.c line 50
signed int is_this_a_mainthread(void)
{
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  if(return_value_pthread_self_1 == mainthread)
    return 1;

  else
    return 0;
}

// localdate
// file logging.h line 75
char * localdate(signed long int *sec)
{
  struct tm *tm;
  tm=localtime(sec);
  static char localdat[31l];
  memset((void *)localdat, 0, (unsigned long int)31);
  strftime(localdat, (unsigned long int)30, format, tm);
  return localdat;
}

// loginit
// file logging.c line 334
signed int loginit(char verl, char *dateformat)
{
  struct llnode *ptr;
  signed int n;
  verlev = (char)0;
  if(!(verl == 0))
    switch((signed int)verl)
    {
      case 1:
      {
        verlev = (char)(16 | 1);
        break;
      }
      case 2:
      {
        verlev = (char)(8 | 16 | 1);
        break;
      }
      case 3:
      {
        verlev = (char)(8 | 16 | 32 | 1);
        break;
      }
      case 4:
      {
        verlev = (char)(8 | 16 | 32 | 64 | 1);
        break;
      }
      case 5:
      {
        verlev = (char)(8 | 16 | 32 | 64 | 1 | 2);
        break;
      }
      default:
        verlev = (char)(1 | 2 | 4 | 8 | 16 | 32 | 64);
    }

  setdateformat(dateformat);
  ptr = head;
  for( ; !(ptr == ((struct llnode *)NULL)); ptr = ptr->next)
  {
    n=checklogtarget(ptr);
    if(!(n == 0))
      return n;

  }
  return 0;
}

// main
// file afserver.c line 70
signed int main(signed int argc, char **argv)
{
  signed int i;
  signed int j = 0;
  signed int k;
  signed int l;
  signed int n;
  signed int flags;
  signed int sent = 0;
  signed int temp;
  unsigned int len;
  unsigned char buff[9000l];
  signed int maxfdp1;
  struct anonymous_22 rset;
  struct anonymous_22 allset;
  struct anonymous_22 wset;
  struct anonymous_22 tmpset;
  signed int numofcon;
  signed int length;
  char *name = (char *)(void *)0;
  char **main__1__listen = (char **)(void *)0;
  signed int listencount = 0;
  char **manage = (char **)(void *)0;
  signed int managecount = 0;
  char *amount = (char *)(void *)0;
  char *clients = (char *)(void *)0;
  char *raclients = (char *)(void *)0;
  char *usrpcli = (char *)(void *)0;
  char *clim = (char *)(void *)0;
  char *filenam = (char *)(void *)0;
  char *type = (char *)(void *)0;
  char *timeout = (char *)(void *)0;
  char *maxidle = (char *)(void *)0;
  char *realmname = (char *)(void *)0;
  unsigned char pass[4l] = { (unsigned char)1, (unsigned char)2, (unsigned char)3, (unsigned char)4 };
  char verbose = (char)0;
  char mode = (char)0;
  char tunneltype = (char)0;
  char ipfam = (char)0;
  char baseport = (char)0;
  char audit = (char)0;
  char dnslookups = (char)0;
  struct anonymous_5 *pointer = (struct anonymous_5 *)(void *)0;
  struct anonymous_16 *scheduler;
  struct anonymous_13 *task;
  struct sigaction act;
  signed long int now;
  struct anonymous_5 **scRealmsTable;
  struct anonymous_7 **srUsersClientsTable;
  struct anonymous_4 **srUsersTable;
  struct anonymous_3 **srClientsTable;
  struct anonymous_3 **srRaClientsTable;
  char *certif = (char *)(void *)0;
  char *cacertif = (char *)(void *)0;
  char *cerdepth = (char *)(void *)0;
  char *keys = (char *)(void *)0;
  char *dateformat = (char *)(void *)0;
  struct ssl_method_st *method;
  struct ssl_ctx_st *ctx;
  struct ssl_st *tmp_ssl;
  sigfillset(&act.sa_mask);
  act.sa_flags = 0;
  act.__sigaction_handler.sa_handler = (void (*)(signed int))1;
  sigaction(13, &act, (struct sigaction *)(void *)0);
  act.__sigaction_handler.sa_handler = server_sig_int;
  sigaction(2, &act, (struct sigaction *)(void *)0);
  sigaction(15, &act, (struct sigaction *)(void *)0);
  mode = mode | (char)4;
  mode = mode | (char)8;
  mode = mode | (char)64;
  remember_mainthread();
  void *return_value_realloc_1;
  void *return_value_realloc_2;
  unsigned long int return_value_strlen_3;
  do
  {
    n=getopt_long(argc, argv, "P46hn:l:m:vu:c:A:d:k:f:p:o:t:C:U:M:abD:R:r:V", long_options, ((signed int *)NULL));
    if(n == -1)
      break;

    switch(n)
    {
      case 104:
      {
        server_long_usage("Active port forwarder (server) v0.8.4");
        break;
      }
      case 110:
      {
        name = optarg;
        break;
      }
      case 108:
      {
        listencount = listencount + 1;
        return_value_realloc_1=realloc((void *)main__1__listen, sizeof(char *) /*8ul*/ );
        main__1__listen = (char **)return_value_realloc_1;
        main__1__listen[(signed long int)(listencount - 1)] = optarg;
        break;
      }
      case 109:
      {
        managecount = managecount + 1;
        return_value_realloc_2=realloc((void *)manage, sizeof(char *) /*8ul*/ );
        manage = (char **)return_value_realloc_2;
        manage[(signed long int)(managecount - 1)] = optarg;
        break;
      }
      case 116:
      {
        timeout = optarg;
        break;
      }
      case 321:
      {
        maxidle = optarg;
        break;
      }
      case 118:
      {
        verbose = verbose + 1;
        break;
      }
      case 117:
      {
        amount = optarg;
        break;
      }
      case 67:
      {
        clients = optarg;
        break;
      }
      case 114:
      {
        realmname = optarg;
        break;
      }
      case 82:
      {
        raclients = optarg;
        break;
      }
      case 85:
      {
        usrpcli = optarg;
        break;
      }
      case 77:
      {
        clim = optarg;
        break;
      }
      case 99:
      {
        certif = optarg;
        break;
      }
      case 65:
      {
        cacertif = optarg;
        break;
      }
      case 100:
      {
        cerdepth = optarg;
        break;
      }
      case 107:
      {
        keys = optarg;
        break;
      }
      case 112:
      {
        type = optarg;
        break;
      }
      case 102:
      {
        filenam = optarg;
        break;
      }
      case 111:
      {
        addlogtarget(optarg);
        break;
      }
      case 301:
      {
        mode = mode & (char)~4;
        break;
      }
      case 302:
      {
        mode = mode & (char)~8;
        break;
      }
      case 303:
      {
        return_value_strlen_3=strlen(optarg);
        n = (signed int)return_value_strlen_3;
        memset((void *)pass, 0, (unsigned long int)4);
        i = 0;
        for( ; !(i >= n); i = i + 1)
          pass[(signed long int)(i % 4)] = pass[(signed long int)(i % 4)] + (unsigned char)optarg[(signed long int)i];
        sent = 1;
        break;
      }
      case 52:
      {
        if(!((signed int)ipfam == 0))
          ipfam = (char)-1;

        else
          ipfam = (char)4;
        break;
      }
      case 54:
      {
        if(!((signed int)ipfam == 0))
          ipfam = (char)-1;

        else
          ipfam = (char)6;
        break;
      }
      case 98:
      {
        baseport = (char)1;
        break;
      }
      case 97:
      {
        audit = (char)1;
        break;
      }
      case 311:
      {
        dnslookups = (char)1;
        break;
      }
      case 68:
      {
        dateformat = optarg;
        break;
      }
      case 80:
      {
        if((signed int)tunneltype >= 3 || !((signed int)tunneltype >= 0))
          tunneltype = (char)-1;

        else
          if(!((signed int)tunneltype == 2))
            tunneltype = (char)1;

        break;
      }
      case 86:
      {
        printf("%s\n", (const void *)"Active port forwarder (server) v0.8.4");
        exit(0);
        break;
      }
      case 63:
        server_short_usage("");
    }
  }
  while((_Bool)1);
  if(!(optind >= argc))
    server_short_usage("Unrecognized non-option elements");

  signed int tmp_statement_expression_20;
  signed int tmp_statement_expression_18;
  if(!(filenam == ((char *)NULL)))
  {
    config=parsefile(filenam, &n);
    if(!(n == 0))
    {
      printf("parsing failed! line:%d\n", n);
      exit(1);
    }

    else
    {
      if(certif == ((char *)NULL))
      {
        char *return_value_ServerConfiguration_get_certificateFile_4;
        return_value_ServerConfiguration_get_certificateFile_4=ServerConfiguration_get_certificateFile(config);
        if(return_value_ServerConfiguration_get_certificateFile_4 == ((char *)NULL))
          ServerConfiguration_set_certificateFile(config, "server-cert.pem");

      }

      else
        ServerConfiguration_set_certificateFile(config, certif);
      if(!(cacertif == ((char *)NULL)))
        ServerConfiguration_set_cacertificateFile(config, cacertif);

      if(!(cerdepth == ((char *)NULL)))
        ServerConfiguration_set_sCertificateDepth(config, cerdepth);

      if(keys == ((char *)NULL))
      {
        char *return_value_ServerConfiguration_get_keysFile_5;
        return_value_ServerConfiguration_get_keysFile_5=ServerConfiguration_get_keysFile(config);
        if(return_value_ServerConfiguration_get_keysFile_5 == ((char *)NULL))
          ServerConfiguration_set_keysFile(config, "server.rsa");

      }

      else
        ServerConfiguration_set_keysFile(config, keys);
      if(!(dateformat == ((char *)NULL)))
        ServerConfiguration_set_dateFormat(config, dateformat);

      char *return_value_ServerConfiguration_get_dateFormat_6;
      return_value_ServerConfiguration_get_dateFormat_6=ServerConfiguration_get_dateFormat(config);
      initializelogging(verbose, return_value_ServerConfiguration_get_dateFormat_6);
      signed int return_value_ServerConfiguration_get_realmsNumber_7;
      return_value_ServerConfiguration_get_realmsNumber_7=ServerConfiguration_get_realmsNumber(config);
      aflog((char)4, (char)8, "cfg file OK! (readed realms: %d)", return_value_ServerConfiguration_get_realmsNumber_7);
      if(!(name == ((char *)NULL)))
        aflog((char)4, (char)32, "Warning: hostname=%s will be ignored", name);

      if(!(main__1__listen == ((char **)NULL)))
        aflog((char)4, (char)32, "Warning: listenport will be ignored");

      if(!(manage == ((char **)NULL)))
        aflog((char)4, (char)32, "Warning: manageport will be ignored");

      if(!(realmname == ((char *)NULL)))
        aflog((char)4, (char)32, "Warning: realmname=%s will be ignored", realmname);

      if(sent == 1)
        aflog((char)4, (char)32, "Warning: password from command line will be ignored");

    }
  }

  else
  {
    config=ServerConfiguration_new();
    if(config == ((struct anonymous_2 *)NULL))
    {
      printf("Can't allocate memory for server configuration... exiting\n");
      exit(1);
    }

    ServerConfiguration_set_certificateFile(config, certif);
    ServerConfiguration_set_cacertificateFile(config, cacertif);
    ServerConfiguration_set_sCertificateDepth(config, cerdepth);
    ServerConfiguration_set_keysFile(config, keys);
    ServerConfiguration_set_dateFormat(config, dateformat);
    char *return_value_ServerConfiguration_get_dateFormat_8;
    return_value_ServerConfiguration_get_dateFormat_8=ServerConfiguration_get_dateFormat(config);
    initializelogging(verbose, return_value_ServerConfiguration_get_dateFormat_8);
    if(main__1__listen == ((char **)NULL))
    {
      listencount = 1;
      void *return_value_calloc_9;
      return_value_calloc_9=calloc((unsigned long int)1, sizeof(char *) /*8ul*/ );
      main__1__listen = (char **)return_value_calloc_9;
      main__1__listen[(signed long int)0] = "50127";
    }

    if(manage == ((char **)NULL))
    {
      managecount = 1;
      void *return_value_calloc_10;
      return_value_calloc_10=calloc((unsigned long int)1, sizeof(char *) /*8ul*/ );
      manage = (char **)return_value_calloc_10;
      manage[(signed long int)0] = "50126";
    }

    if(!(managecount == listencount))
    {
      aflog((char)4, (char)1, "Number of listen and manage options are not the same... exiting");
      exit(1);
    }

    char *return_value_ServerConfiguration_get_certificateFile_11;
    return_value_ServerConfiguration_get_certificateFile_11=ServerConfiguration_get_certificateFile(config);
    if(return_value_ServerConfiguration_get_certificateFile_11 == ((char *)NULL))
      ServerConfiguration_set_certificateFile(config, "server-cert.pem");

    char *return_value_ServerConfiguration_get_keysFile_12;
    return_value_ServerConfiguration_get_keysFile_12=ServerConfiguration_get_keysFile(config);
    if(return_value_ServerConfiguration_get_keysFile_12 == ((char *)NULL))
      ServerConfiguration_set_keysFile(config, "server.rsa");

    if(type == ((char *)NULL))
      type = "tcp";

    ServerConfiguration_set_realmsNumber(config, 1);
    void *return_value_calloc_13;
    return_value_calloc_13=calloc((unsigned long int)1, sizeof(struct anonymous_5 *) /*8ul*/ );
    scRealmsTable = (struct anonymous_5 **)return_value_calloc_13;
    if(scRealmsTable == ((struct anonymous_5 **)NULL))
    {
      aflog((char)4, (char)1, "Problem with allocating memory for ServerRealm* table... exiting");
      exit(1);
    }

    ServerConfiguration_set_realmsTable(config, scRealmsTable);
    pointer=ServerRealm_new();
    if(pointer == ((struct anonymous_5 *)NULL))
    {
      aflog((char)4, (char)1, "Problem with allocating memory for ServerRealm structure... exiting");
      exit(1);
    }

    scRealmsTable[(signed long int)0] = pointer;
    ServerRealm_set_hostName(pointer, name);
    ServerRealm_set_userClientPairs(pointer, managecount);
    void *return_value_calloc_14;
    return_value_calloc_14=calloc((unsigned long int)managecount, sizeof(struct anonymous_7 *) /*8ul*/ );
    srUsersClientsTable = (struct anonymous_7 **)return_value_calloc_14;
    if(srUsersClientsTable == ((struct anonymous_7 **)NULL))
    {
      aflog((char)4, (char)1, "Problem with allocating memory for UsrCli* table... exiting");
      exit(1);
    }

    ServerRealm_set_usersClientsTable(pointer, srUsersClientsTable);
    i = 0;
    for( ; !(i >= managecount); i = i + 1)
    {
      srUsersClientsTable[(signed long int)i]=UsrCli_new();
      if(srUsersClientsTable[(signed long int)i] == ((struct anonymous_7 *)NULL))
      {
        aflog((char)4, (char)1, "Problem with allocating memory for UsrCli structure... exiting");
        exit(1);
      }

      UsrCli_set_listenPortName(srUsersClientsTable[(signed long int)i], main__1__listen[(signed long int)i]);
      UsrCli_set_managePortName(srUsersClientsTable[(signed long int)i], manage[(signed long int)i]);
    }
    ServerRealm_set_sUsersLimit(pointer, amount);
    ServerRealm_set_sClientsLimit(pointer, clients);
    ServerRealm_set_sRaClientsLimit(pointer, raclients);
    ServerRealm_set_sTimeout(pointer, timeout);
    ServerRealm_set_sMaxIdle(pointer, maxidle);
    ServerRealm_set_sUsersPerClient(pointer, usrpcli);
    ServerRealm_set_sClientMode(pointer, clim);
    ServerRealm_set_basePortOn(pointer, baseport);
    ServerRealm_set_auditOn(pointer, audit);
    ServerRealm_set_tunnelType(pointer, tunneltype);
    ServerRealm_set_dnsLookupsOn(pointer, dnslookups);
    ServerRealm_set_realmName(pointer, realmname);
    ServerRealm_set_password(pointer, pass);
    unsigned long int main__1__4__12____s1_len;
    unsigned long int main__1__4__12____s2_len;
    signed int return_value___builtin_strcmp_21;
    return_value___builtin_strcmp_21=__builtin_strcmp(type, "tcp");
    tmp_statement_expression_20 = return_value___builtin_strcmp_21;
    if(tmp_statement_expression_20 == 0)
    {
      char return_value_ServerRealm_get_realmType_15;
      return_value_ServerRealm_get_realmType_15=ServerRealm_get_realmType(pointer);
      temp = (signed int)return_value_ServerRealm_get_realmType_15;
      temp = temp | 1;
      ServerRealm_set_realmType(pointer, (char)temp);
    }

    else
    {
      unsigned long int main__1__4__14____s1_len;
      unsigned long int main__1__4__14____s2_len;
      signed int return_value___builtin_strcmp_19;
      return_value___builtin_strcmp_19=__builtin_strcmp(type, "udp");
      tmp_statement_expression_18 = return_value___builtin_strcmp_19;
      if(tmp_statement_expression_18 == 0)
      {
        char return_value_ServerRealm_get_realmType_16;
        return_value_ServerRealm_get_realmType_16=ServerRealm_get_realmType(pointer);
        temp = (signed int)return_value_ServerRealm_get_realmType_16;
        temp = temp | 3;
        ServerRealm_set_realmType(pointer, (char)temp);
      }

      else
      {
        char return_value_ServerRealm_get_realmType_17;
        return_value_ServerRealm_get_realmType_17=ServerRealm_get_realmType(pointer);
        temp = (signed int)return_value_ServerRealm_get_realmType_17;
        temp = 0;
        ServerRealm_set_realmType(pointer, (char)temp);
      }
    }
    if((signed int)ipfam == -1)
    {
      aflog((char)4, (char)1, "Conflicting types of ip protocol family... exiting");
      exit(1);
    }

    else
      if((signed int)ipfam == 4)
      {
        char return_value_ServerRealm_get_realmType_22;
        return_value_ServerRealm_get_realmType_22=ServerRealm_get_realmType(pointer);
        temp = (signed int)return_value_ServerRealm_get_realmType_22;
        temp = temp | 16;
        ServerRealm_set_realmType(pointer, (char)temp);
      }

      else
        if((signed int)ipfam == 6)
        {
          char return_value_ServerRealm_get_realmType_23;
          return_value_ServerRealm_get_realmType_23=ServerRealm_get_realmType(pointer);
          temp = (signed int)return_value_ServerRealm_get_realmType_23;
          temp = temp | 32;
          ServerRealm_set_realmType(pointer, (char)temp);
        }

    char return_value_ServerRealm_get_realmType_24;
    return_value_ServerRealm_get_realmType_24=ServerRealm_get_realmType(pointer);
    temp = (signed int)return_value_ServerRealm_get_realmType_24;
    temp = temp | (signed int)mode;
    ServerRealm_set_realmType(pointer, (char)temp);
  }
  maxfdp1 = 0;
  SSL_library_init();
  method=SSLv3_server_method();
  ctx=SSL_CTX_new(method);
  signed int return_value_SSL_CTX_set_cipher_list_25;
  return_value_SSL_CTX_set_cipher_list_25=SSL_CTX_set_cipher_list(ctx, "ALL:@STRENGTH");
  if(return_value_SSL_CTX_set_cipher_list_25 == 0)
  {
    aflog((char)4, (char)1, "Setting ciphers list failed... exiting");
    exit(1);
  }

  flags=create_apf_dir((char)0);
  if(!(flags == 0))
  {
    aflog((char)4, (char)32, "Warning: Creating ~/.apf directory failed (%d)", flags);
    flags=create_apf_dir((char)1);
    if(!(flags == 0))
      aflog((char)4, (char)32, "Warning: Creating ./apf directory failed (%d)", flags);

  }

  keys=ServerConfiguration_get_keysFile(config);
  flags=generate_rsa_key(&keys);
  if(!(flags == 0))
    aflog((char)4, (char)32, "Warning: Something bad happened when generating rsa keys... (%d)", flags);

  ServerConfiguration_set_keysFile(config, keys);
  char *return_value_ServerConfiguration_get_keysFile_27;
  return_value_ServerConfiguration_get_keysFile_27=ServerConfiguration_get_keysFile(config);
  signed int return_value_SSL_CTX_use_RSAPrivateKey_file_28;
  return_value_SSL_CTX_use_RSAPrivateKey_file_28=SSL_CTX_use_RSAPrivateKey_file(ctx, return_value_ServerConfiguration_get_keysFile_27, 1);
  if(!(return_value_SSL_CTX_use_RSAPrivateKey_file_28 == 1))
  {
    char *return_value_ServerConfiguration_get_keysFile_26;
    return_value_ServerConfiguration_get_keysFile_26=ServerConfiguration_get_keysFile(config);
    aflog((char)4, (char)1, "Setting rsa key failed (%s)... exiting", return_value_ServerConfiguration_get_keysFile_26);
    exit(1);
  }

  certif=ServerConfiguration_get_certificateFile(config);
  char *return_value_ServerConfiguration_get_keysFile_29;
  return_value_ServerConfiguration_get_keysFile_29=ServerConfiguration_get_keysFile(config);
  flags=generate_certificate(&certif, return_value_ServerConfiguration_get_keysFile_29);
  if(!(flags == 0))
    aflog((char)4, (char)32, "Warning: Something bad happened when generating certificate... (%d)", flags);

  ServerConfiguration_set_certificateFile(config, certif);
  char *return_value_ServerConfiguration_get_certificateFile_31;
  return_value_ServerConfiguration_get_certificateFile_31=ServerConfiguration_get_certificateFile(config);
  signed int return_value_SSL_CTX_use_certificate_file_32;
  return_value_SSL_CTX_use_certificate_file_32=SSL_CTX_use_certificate_file(ctx, return_value_ServerConfiguration_get_certificateFile_31, 1);
  if(!(return_value_SSL_CTX_use_certificate_file_32 == 1))
  {
    char *return_value_ServerConfiguration_get_certificateFile_30;
    return_value_ServerConfiguration_get_certificateFile_30=ServerConfiguration_get_certificateFile(config);
    aflog((char)4, (char)1, "Setting certificate failed (%s)... exiting", return_value_ServerConfiguration_get_certificateFile_30);
    exit(1);
  }

  cacertif=ServerConfiguration_get_cacertificateFile(config);
  if(!(cacertif == ((char *)NULL)))
  {
    signed int return_value_SSL_CTX_load_verify_locations_33;
    return_value_SSL_CTX_load_verify_locations_33=SSL_CTX_load_verify_locations(ctx, cacertif, (const char *)(void *)0);
    if(!(return_value_SSL_CTX_load_verify_locations_33 == 1))
    {
      aflog((char)4, (char)1, "Setting CA certificate failed (%s)... exiting", cacertif);
      exit(1);
    }

    SSL_CTX_set_verify(ctx, 0x01 | 0x02, (signed int (*)(signed int, struct x509_store_ctx_st *))(void *)0);
    cerdepth=ServerConfiguration_get_sCertificateDepth(config);
    if(cerdepth == ((char *)NULL))
      cerdepth = "9";

    signed int return_value_check_value_liberal_34;
    return_value_check_value_liberal_34=check_value_liberal(cerdepth, "Invalid max certificate-depth");
    SSL_CTX_set_verify_depth(ctx, return_value_check_value_liberal_34);
  }

  signed int return_value_ServerConfiguration_get_realmsNumber_35;
  return_value_ServerConfiguration_get_realmsNumber_35=ServerConfiguration_get_realmsNumber(config);
  if(return_value_ServerConfiguration_get_realmsNumber_35 == 0)
  {
    aflog((char)4, (char)1, "Working without sense is really without sense...");
    exit(1);
  }

  do
  {
    signed int main__1__13____d0;
    signed int main__1__13____d1;
    asm("cld; rep; stosq" : "=c"(main__1__13____d0), "=D"(main__1__13____d1) : "a"(0), "0"(sizeof(struct anonymous_22) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&allset)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_22) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wset)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  if(verbose == 0)
    daemon(0, 0);

  scheduler=TaskScheduler_new();
  if(scheduler == ((struct anonymous_16 *)NULL))
  {
    aflog((char)4, (char)1, "Problems with creating task scheduler... exiting");
    exit(1);
  }

  scRealmsTable=ServerConfiguration_get_realmsTable(config);
  i = 0;
  signed int return_value_ServerConfiguration_get_realmsNumber_36;
  signed int return_value_ServerRealm_get_userClientPairs_38;
  _Bool tmp_if_expr_43;
  char *return_value_UsrCli_get_managePortName_42;
  signed int tmp_statement_expression_49;
  signed int tmp_statement_expression_47;
  signed int return_value_ServerRealm_get_usersLimit_78;
  signed int return_value_ServerRealm_get_clientsLimit_81;
  signed int return_value_ServerRealm_get_raClientsLimit_84;
  char return_value_ServerRealm_get_realmType_85;
  signed int return_value_ServerRealm_get_userClientPairs_87;
  char *tmp_if_expr_96;
  char *return_value_UsrCli_get_listenHostName_94;
  char *return_value_ServerRealm_get_hostName_95;
  char *tmp_if_expr_91;
  char *return_value_UsrCli_get_listenHostName_89;
  char *return_value_ServerRealm_get_hostName_90;
  signed int return_value_ServerRealm_get_userClientPairs_102;
  char *return_value_UsrCli_get_manageHostName_104;
  char *return_value_UsrCli_get_managePortName_105;
  char *tmp_if_expr_114;
  char *return_value_UsrCli_get_manageHostName_112;
  char *return_value_ServerRealm_get_hostName_113;
  char *tmp_if_expr_109;
  char *return_value_UsrCli_get_manageHostName_107;
  char *return_value_ServerRealm_get_hostName_108;
  signed int return_value_UsrCli_get_manageFd_117;
  signed int return_value_UsrCli_get_manageFd_118;
  char *return_value_UsrCli_get_manageHostName_119;
  char *return_value_UsrCli_get_managePortName_120;
  signed int return_value_eval_UsrCliPair_121;
  char *return_value_UsrCli_get_manageHostName_122;
  char *return_value_UsrCli_get_managePortName_123;
  char *tmp_if_expr_133;
  char *return_value_UsrCli_get_manageHostName_131;
  char *return_value_ServerRealm_get_hostName_132;
  char *tmp_if_expr_128;
  char *return_value_UsrCli_get_manageHostName_126;
  char *return_value_ServerRealm_get_hostName_127;
  signed int return_value_UsrCli_get_manageFd_139;
  signed int return_value_UsrCli_get_manageFd_140;
  char *return_value_UsrCli_get_manageHostName_141;
  char *return_value_UsrCli_get_managePortName_142;
  signed int return_value_eval_UsrCliPair_143;
  signed int return_value_ServerRealm_get_clientsLimit_147;
  signed int return_value_ServerRealm_get_raClientsLimit_152;
  signed int return_value_ServerRealm_get_userClientPairs_157;
  signed int tmp_if_expr_162;
  signed int return_value_UsrCli_get_manageFd_161;
  signed int return_value_ServerRealm_get_userClientPairs_163;
  signed int tmp_if_expr_168;
  signed int return_value_UsrCli_get_listenFd_167;
  signed int return_value_ServerRealm_get_clientsLimit_170;
  signed int return_value_ServerRealm_get_raClientsLimit_175;
  do
  {
    return_value_ServerConfiguration_get_realmsNumber_36=ServerConfiguration_get_realmsNumber(config);
    if(i >= return_value_ServerConfiguration_get_realmsNumber_36)
      break;

    signed int return_value_ServerRealm_get_userClientPairs_37;
    return_value_ServerRealm_get_userClientPairs_37=ServerRealm_get_userClientPairs(scRealmsTable[(signed long int)i]);
    if(return_value_ServerRealm_get_userClientPairs_37 == 0)
    {
      aflog((char)4, (char)1, "You have to specify at least one listen port and one manage port in each realm");
      exit(1);
    }

    srUsersClientsTable=ServerRealm_get_usersClientsTable(scRealmsTable[(signed long int)i]);
    j = 0;
    do
    {
      return_value_ServerRealm_get_userClientPairs_38=ServerRealm_get_userClientPairs(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_userClientPairs_38)
        break;

      char *return_value_UsrCli_get_listenPortName_41;
      return_value_UsrCli_get_listenPortName_41=UsrCli_get_listenPortName(srUsersClientsTable[(signed long int)j]);
      if(return_value_UsrCli_get_listenPortName_41 == ((char *)NULL))
        tmp_if_expr_43 = (_Bool)1;

      else
      {
        return_value_UsrCli_get_managePortName_42=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
        tmp_if_expr_43 = return_value_UsrCli_get_managePortName_42 == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_43)
      {
        char *return_value_UsrCli_get_listenPortName_39;
        return_value_UsrCli_get_listenPortName_39=UsrCli_get_listenPortName(srUsersClientsTable[(signed long int)j]);
        char *return_value_UsrCli_get_managePortName_40;
        return_value_UsrCli_get_managePortName_40=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
        aflog((char)4, (char)1, "Missing some of the variables...\nRealm: %d\nlistenport[%d]: %s\nmanageport[%d]: %s", i, j, return_value_UsrCli_get_listenPortName_39, j, return_value_UsrCli_get_managePortName_40);
        exit(1);
      }

      j = j + 1;
    }
    while((_Bool)1);
    char return_value_ServerRealm_get_realmType_52;
    return_value_ServerRealm_get_realmType_52=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
    if((1 & (signed int)return_value_ServerRealm_get_realmType_52) == 0)
    {
      if(!(type == ((char *)NULL)))
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp_50;
        return_value___builtin_strcmp_50=__builtin_strcmp(type, "tcp");
        tmp_statement_expression_49 = return_value___builtin_strcmp_50;
        if(tmp_statement_expression_49 == 0)
        {
          char return_value_ServerRealm_get_realmType_44;
          return_value_ServerRealm_get_realmType_44=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
          temp = (signed int)return_value_ServerRealm_get_realmType_44;
          temp = temp | 1;
          ServerRealm_set_realmType(scRealmsTable[(signed long int)i], (char)temp);
        }

        else
        {
          unsigned long int main__1__16__3__1__3____s1_len;
          unsigned long int main__1__16__3__1__3____s2_len;
          signed int return_value___builtin_strcmp_48;
          return_value___builtin_strcmp_48=__builtin_strcmp(type, "udp");
          tmp_statement_expression_47 = return_value___builtin_strcmp_48;
          if(tmp_statement_expression_47 == 0)
          {
            char return_value_ServerRealm_get_realmType_45;
            return_value_ServerRealm_get_realmType_45=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
            temp = (signed int)return_value_ServerRealm_get_realmType_45;
            temp = temp | 3;
            ServerRealm_set_realmType(scRealmsTable[(signed long int)i], (char)temp);
          }

          else
          {
            char return_value_ServerRealm_get_realmType_46;
            return_value_ServerRealm_get_realmType_46=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
            temp = (signed int)return_value_ServerRealm_get_realmType_46;
            temp = temp | 1;
            ServerRealm_set_realmType(scRealmsTable[(signed long int)i], (char)temp);
          }
        }
      }

      else
      {
        char return_value_ServerRealm_get_realmType_51;
        return_value_ServerRealm_get_realmType_51=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
        temp = (signed int)return_value_ServerRealm_get_realmType_51;
        temp = temp | 1;
        ServerRealm_set_realmType(scRealmsTable[(signed long int)i], (char)temp);
      }
    }

    char return_value_ServerRealm_get_realmType_55;
    return_value_ServerRealm_get_realmType_55=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
    if((48 & (signed int)return_value_ServerRealm_get_realmType_55) == 0)
    {
      if((signed int)ipfam == -1)
      {
        aflog((char)4, (char)1, "Conflicting types of ip protocol family... exiting");
        exit(1);
      }

      else
        if((signed int)ipfam == 4)
        {
          char return_value_ServerRealm_get_realmType_53;
          return_value_ServerRealm_get_realmType_53=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
          temp = (signed int)return_value_ServerRealm_get_realmType_53;
          temp = temp | 16;
          ServerRealm_set_realmType(scRealmsTable[(signed long int)i], (char)temp);
        }

        else
          if((signed int)ipfam == 6)
          {
            char return_value_ServerRealm_get_realmType_54;
            return_value_ServerRealm_get_realmType_54=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
            temp = (signed int)return_value_ServerRealm_get_realmType_54;
            temp = temp | 32;
            ServerRealm_set_realmType(scRealmsTable[(signed long int)i], (char)temp);
          }

    }

    if((4 & (signed int)mode) == 0)
    {
      char return_value_ServerRealm_get_realmType_56;
      return_value_ServerRealm_get_realmType_56=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
      temp = (signed int)return_value_ServerRealm_get_realmType_56;
      temp = temp & ~4;
      ServerRealm_set_realmType(scRealmsTable[(signed long int)i], (char)temp);
    }

    if((8 & (signed int)mode) == 0)
    {
      char return_value_ServerRealm_get_realmType_57;
      return_value_ServerRealm_get_realmType_57=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
      temp = (signed int)return_value_ServerRealm_get_realmType_57;
      temp = temp & ~8;
      ServerRealm_set_realmType(scRealmsTable[(signed long int)i], (char)temp);
    }

    char return_value_ServerRealm_get_basePortOn_58;
    return_value_ServerRealm_get_basePortOn_58=ServerRealm_get_basePortOn(scRealmsTable[(signed long int)i]);
    if((signed int)return_value_ServerRealm_get_basePortOn_58 == 0)
      ServerRealm_set_basePortOn(scRealmsTable[(signed long int)i], baseport);

    char return_value_ServerRealm_get_auditOn_59;
    return_value_ServerRealm_get_auditOn_59=ServerRealm_get_auditOn(scRealmsTable[(signed long int)i]);
    if((signed int)return_value_ServerRealm_get_auditOn_59 == 0)
      ServerRealm_set_auditOn(scRealmsTable[(signed long int)i], audit);

    char return_value_ServerRealm_get_tunnelType_60;
    return_value_ServerRealm_get_tunnelType_60=ServerRealm_get_tunnelType(scRealmsTable[(signed long int)i]);
    if((signed int)return_value_ServerRealm_get_tunnelType_60 == 0)
    {
      if((signed int)tunneltype == -1)
      {
        aflog((char)4, (char)1, "Conflicting types of tunnel type... exiting");
        exit(1);
      }

      ServerRealm_set_tunnelType(scRealmsTable[(signed long int)i], tunneltype);
    }

    char return_value_ServerRealm_get_dnsLookupsOn_61;
    return_value_ServerRealm_get_dnsLookupsOn_61=ServerRealm_get_dnsLookupsOn(scRealmsTable[(signed long int)i]);
    if((signed int)return_value_ServerRealm_get_dnsLookupsOn_61 == 0)
      ServerRealm_set_dnsLookupsOn(scRealmsTable[(signed long int)i], dnslookups);

    static char *stemp = (char *)(void *)0;
    stemp=ServerRealm_get_sUsersLimit(scRealmsTable[(signed long int)i]);
    set_value(&stemp, amount, "5");
    ServerRealm_set_sUsersLimit(scRealmsTable[(signed long int)i], stemp);
    char *return_value_ServerRealm_get_sUsersLimit_62;
    return_value_ServerRealm_get_sUsersLimit_62=ServerRealm_get_sUsersLimit(scRealmsTable[(signed long int)i]);
    signed int return_value_check_value_63;
    return_value_check_value_63=check_value(return_value_ServerRealm_get_sUsersLimit_62, "Invalid users amount");
    ServerRealm_set_usersLimit(scRealmsTable[(signed long int)i], return_value_check_value_63);
    stemp=ServerRealm_get_sClientsLimit(scRealmsTable[(signed long int)i]);
    set_value(&stemp, clients, "1");
    ServerRealm_set_sClientsLimit(scRealmsTable[(signed long int)i], stemp);
    char *return_value_ServerRealm_get_sClientsLimit_64;
    return_value_ServerRealm_get_sClientsLimit_64=ServerRealm_get_sClientsLimit(scRealmsTable[(signed long int)i]);
    signed int return_value_check_value_65;
    return_value_check_value_65=check_value(return_value_ServerRealm_get_sClientsLimit_64, "Invalid clients amount");
    ServerRealm_set_clientsLimit(scRealmsTable[(signed long int)i], return_value_check_value_65);
    stemp=ServerRealm_get_sRaClientsLimit(scRealmsTable[(signed long int)i]);
    set_value(&stemp, raclients, "1");
    ServerRealm_set_sRaClientsLimit(scRealmsTable[(signed long int)i], stemp);
    char *return_value_ServerRealm_get_sRaClientsLimit_66;
    return_value_ServerRealm_get_sRaClientsLimit_66=ServerRealm_get_sRaClientsLimit(scRealmsTable[(signed long int)i]);
    signed int return_value_check_value_67;
    return_value_check_value_67=check_value(return_value_ServerRealm_get_sRaClientsLimit_66, "Invalid raclients amount");
    ServerRealm_set_raClientsLimit(scRealmsTable[(signed long int)i], return_value_check_value_67);
    stemp=ServerRealm_get_sUsersPerClient(scRealmsTable[(signed long int)i]);
    char *return_value_ServerRealm_get_sUsersLimit_68;
    return_value_ServerRealm_get_sUsersLimit_68=ServerRealm_get_sUsersLimit(scRealmsTable[(signed long int)i]);
    set_value(&stemp, usrpcli, return_value_ServerRealm_get_sUsersLimit_68);
    ServerRealm_set_sUsersPerClient(scRealmsTable[(signed long int)i], stemp);
    char *return_value_ServerRealm_get_sUsersPerClient_69;
    return_value_ServerRealm_get_sUsersPerClient_69=ServerRealm_get_sUsersPerClient(scRealmsTable[(signed long int)i]);
    signed int return_value_check_value_70;
    return_value_check_value_70=check_value(return_value_ServerRealm_get_sUsersPerClient_69, "Invalid usrpcli value");
    ServerRealm_set_usersPerClient(scRealmsTable[(signed long int)i], return_value_check_value_70);
    stemp=ServerRealm_get_sTimeout(scRealmsTable[(signed long int)i]);
    set_value(&stemp, timeout, "5");
    ServerRealm_set_sTimeout(scRealmsTable[(signed long int)i], stemp);
    char *return_value_ServerRealm_get_sTimeout_71;
    return_value_ServerRealm_get_sTimeout_71=ServerRealm_get_sTimeout(scRealmsTable[(signed long int)i]);
    signed int return_value_check_value_72;
    return_value_check_value_72=check_value(return_value_ServerRealm_get_sTimeout_71, "Invalid timeout value");
    ServerRealm_set_timeout(scRealmsTable[(signed long int)i], return_value_check_value_72);
    stemp=ServerRealm_get_sMaxIdle(scRealmsTable[(signed long int)i]);
    set_value(&stemp, maxidle, "0");
    ServerRealm_set_sMaxIdle(scRealmsTable[(signed long int)i], stemp);
    char *return_value_ServerRealm_get_sMaxIdle_73;
    return_value_ServerRealm_get_sMaxIdle_73=ServerRealm_get_sMaxIdle(scRealmsTable[(signed long int)i]);
    temp=check_value_liberal(return_value_ServerRealm_get_sMaxIdle_73, "Invalid maxidle value");
    if(!(temp >= 0))
    {
      aflog((char)4, (char)1, "Invalid maxidle value: %d\n", temp);
      exit(1);
    }

    ServerRealm_set_maxIdle(scRealmsTable[(signed long int)i], temp);
    stemp=ServerRealm_get_sClientMode(scRealmsTable[(signed long int)i]);
    set_value(&stemp, clim, "1");
    ServerRealm_set_sClientMode(scRealmsTable[(signed long int)i], stemp);
    char *return_value_ServerRealm_get_sClientMode_74;
    return_value_ServerRealm_get_sClientMode_74=ServerRealm_get_sClientMode(scRealmsTable[(signed long int)i]);
    signed int return_value_check_value_75;
    return_value_check_value_75=check_value(return_value_ServerRealm_get_sClientMode_74, "Invalid climode value");
    ServerRealm_set_clientMode(scRealmsTable[(signed long int)i], return_value_check_value_75);
    signed int return_value_ServerRealm_get_usersLimit_76;
    return_value_ServerRealm_get_usersLimit_76=ServerRealm_get_usersLimit(scRealmsTable[(signed long int)i]);
    void *return_value_calloc_77;
    return_value_calloc_77=calloc((unsigned long int)return_value_ServerRealm_get_usersLimit_76, sizeof(struct anonymous_4 *) /*8ul*/ );
    srUsersTable = (struct anonymous_4 **)return_value_calloc_77;
    if(srUsersTable == ((struct anonymous_4 **)NULL))
    {
      aflog((char)4, (char)1, "Calloc error - try define smaller amount of users");
      exit(1);
    }

    ServerRealm_set_usersTable(scRealmsTable[(signed long int)i], srUsersTable);
    j = 0;
    do
    {
      return_value_ServerRealm_get_usersLimit_78=ServerRealm_get_usersLimit(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_usersLimit_78)
        break;

      srUsersTable[(signed long int)j]=ConnectUser_new();
      if(srUsersTable[(signed long int)j] == ((struct anonymous_4 *)NULL))
      {
        aflog((char)4, (char)1, "Calloc error - try define smaller amount of users");
        exit(1);
      }

      j = j + 1;
    }
    while((_Bool)1);
    signed int return_value_ServerRealm_get_clientsLimit_79;
    return_value_ServerRealm_get_clientsLimit_79=ServerRealm_get_clientsLimit(scRealmsTable[(signed long int)i]);
    void *return_value_calloc_80;
    return_value_calloc_80=calloc((unsigned long int)return_value_ServerRealm_get_clientsLimit_79, sizeof(struct anonymous_3 *) /*8ul*/ );
    srClientsTable = (struct anonymous_3 **)return_value_calloc_80;
    if(srClientsTable == ((struct anonymous_3 **)NULL))
    {
      aflog((char)4, (char)1, "Calloc error - try define smaller amount of clients");
      exit(1);
    }

    ServerRealm_set_clientsTable(scRealmsTable[(signed long int)i], srClientsTable);
    j = 0;
    do
    {
      return_value_ServerRealm_get_clientsLimit_81=ServerRealm_get_clientsLimit(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_clientsLimit_81)
        break;

      srClientsTable[(signed long int)j]=ConnectClient_new();
      if(srClientsTable[(signed long int)j] == ((struct anonymous_3 *)NULL))
      {
        aflog((char)4, (char)1, "Calloc error - try define smaller amount of clients");
        exit(1);
      }

      j = j + 1;
    }
    while((_Bool)1);
    signed int return_value_ServerRealm_get_raClientsLimit_82;
    return_value_ServerRealm_get_raClientsLimit_82=ServerRealm_get_raClientsLimit(scRealmsTable[(signed long int)i]);
    void *return_value_calloc_83;
    return_value_calloc_83=calloc((unsigned long int)return_value_ServerRealm_get_raClientsLimit_82, sizeof(struct anonymous_3 *) /*8ul*/ );
    srRaClientsTable = (struct anonymous_3 **)return_value_calloc_83;
    if(srRaClientsTable == ((struct anonymous_3 **)NULL))
    {
      aflog((char)4, (char)1, "Calloc error - try define smaller amount of raclients");
      exit(1);
    }

    ServerRealm_set_raClientsTable(scRealmsTable[(signed long int)i], srRaClientsTable);
    j = 0;
    do
    {
      return_value_ServerRealm_get_raClientsLimit_84=ServerRealm_get_raClientsLimit(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_raClientsLimit_84)
        break;

      srRaClientsTable[(signed long int)j]=ConnectClient_new();
      if(srRaClientsTable[(signed long int)j] == ((struct anonymous_3 *)NULL))
      {
        aflog((char)4, (char)1, "Calloc error - try define smaller amount of raclients");
        exit(1);
      }

      j = j + 1;
    }
    while((_Bool)1);
    ipfam = (char)0x01;
    char return_value_ServerRealm_get_realmType_86;
    return_value_ServerRealm_get_realmType_86=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
    if(!((16 & (signed int)return_value_ServerRealm_get_realmType_86) == 0))
      ipfam = ipfam | (char)0x02;

    else
    {
      return_value_ServerRealm_get_realmType_85=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
      if(!((32 & (signed int)return_value_ServerRealm_get_realmType_85) == 0))
        ipfam = ipfam | (char)0x04;

    }
    char return_value_ServerRealm_get_basePortOn_101;
    return_value_ServerRealm_get_basePortOn_101=ServerRealm_get_basePortOn(scRealmsTable[(signed long int)i]);
    if((signed int)return_value_ServerRealm_get_basePortOn_101 == 0)
    {
      j = 0;
      do
      {
        return_value_ServerRealm_get_userClientPairs_87=ServerRealm_get_userClientPairs(scRealmsTable[(signed long int)i]);
        if(j >= return_value_ServerRealm_get_userClientPairs_87)
          break;

        char *return_value_UsrCli_get_listenHostName_93;
        return_value_UsrCli_get_listenHostName_93=UsrCli_get_listenHostName(srUsersClientsTable[(signed long int)j]);
        if(!(return_value_UsrCli_get_listenHostName_93 == ((char *)NULL)))
        {
          return_value_UsrCli_get_listenHostName_94=UsrCli_get_listenHostName(srUsersClientsTable[(signed long int)j]);
          tmp_if_expr_96 = return_value_UsrCli_get_listenHostName_94;
        }

        else
        {
          return_value_ServerRealm_get_hostName_95=ServerRealm_get_hostName(scRealmsTable[(signed long int)i]);
          tmp_if_expr_96 = return_value_ServerRealm_get_hostName_95;
        }
        char *return_value_UsrCli_get_listenPortName_97;
        return_value_UsrCli_get_listenPortName_97=UsrCli_get_listenPortName(srUsersClientsTable[(signed long int)j]);
        signed int return_value_ip_listen_98;
        return_value_ip_listen_98=ip_listen(&temp, tmp_if_expr_96, return_value_UsrCli_get_listenPortName_97, &len, ipfam);
        if(!(return_value_ip_listen_98 == 0))
        {
          char *return_value_UsrCli_get_listenHostName_88;
          return_value_UsrCli_get_listenHostName_88=UsrCli_get_listenHostName(srUsersClientsTable[(signed long int)j]);
          if(!(return_value_UsrCli_get_listenHostName_88 == ((char *)NULL)))
          {
            return_value_UsrCli_get_listenHostName_89=UsrCli_get_listenHostName(srUsersClientsTable[(signed long int)j]);
            tmp_if_expr_91 = return_value_UsrCli_get_listenHostName_89;
          }

          else
          {
            return_value_ServerRealm_get_hostName_90=ServerRealm_get_hostName(scRealmsTable[(signed long int)i]);
            tmp_if_expr_91 = return_value_ServerRealm_get_hostName_90;
          }
          char *return_value_UsrCli_get_listenPortName_92;
          return_value_UsrCli_get_listenPortName_92=UsrCli_get_listenPortName(srUsersClientsTable[(signed long int)j]);
          aflog((char)4, (char)1, "tcp_listen_%s error for %s, %s", ((signed int)ipfam & 0x02) != 0 ? "ipv4" : (((signed int)ipfam & 0x04) != 0 ? "ipv6" : "unspec"), tmp_if_expr_91, return_value_UsrCli_get_listenPortName_92);
          exit(1);
        }

        ServerRealm_set_addressLength(scRealmsTable[(signed long int)i], len);
        UsrCli_set_listenFd(srUsersClientsTable[(signed long int)j], temp);
        signed int return_value_UsrCli_get_listenFd_99;
        return_value_UsrCli_get_listenFd_99=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)j]);
        flags=fcntl(return_value_UsrCli_get_listenFd_99, 3, 0);
        signed int return_value_UsrCli_get_listenFd_100;
        return_value_UsrCli_get_listenFd_100=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)j]);
        fcntl(return_value_UsrCli_get_listenFd_100, 4, flags | 04000);
        j = j + 1;
      }
      while((_Bool)1);
    }

    j = 0;
    do
    {
      return_value_ServerRealm_get_userClientPairs_102=ServerRealm_get_userClientPairs(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_userClientPairs_102)
        break;

      char return_value_ServerRealm_get_tunnelType_103;
      return_value_ServerRealm_get_tunnelType_103=ServerRealm_get_tunnelType(scRealmsTable[(signed long int)i]);
      switch((signed int)return_value_ServerRealm_get_tunnelType_103)
      {
        case 0:
        {
          return_value_UsrCli_get_manageHostName_104=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
          return_value_UsrCli_get_managePortName_105=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
          temp=find_previousFd(srUsersClientsTable, j, return_value_UsrCli_get_manageHostName_104, return_value_UsrCli_get_managePortName_105);
          if(temp == -1)
          {
            char *return_value_UsrCli_get_manageHostName_111;
            return_value_UsrCli_get_manageHostName_111=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
            if(!(return_value_UsrCli_get_manageHostName_111 == ((char *)NULL)))
            {
              return_value_UsrCli_get_manageHostName_112=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
              tmp_if_expr_114 = return_value_UsrCli_get_manageHostName_112;
            }

            else
            {
              return_value_ServerRealm_get_hostName_113=ServerRealm_get_hostName(scRealmsTable[(signed long int)i]);
              tmp_if_expr_114 = return_value_ServerRealm_get_hostName_113;
            }
            char *return_value_UsrCli_get_managePortName_115;
            return_value_UsrCli_get_managePortName_115=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
            signed int return_value_ip_listen_116;
            return_value_ip_listen_116=ip_listen(&temp, tmp_if_expr_114, return_value_UsrCli_get_managePortName_115, &len, ipfam);
            if(!(return_value_ip_listen_116 == 0))
            {
              char *return_value_UsrCli_get_manageHostName_106;
              return_value_UsrCli_get_manageHostName_106=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
              if(!(return_value_UsrCli_get_manageHostName_106 == ((char *)NULL)))
              {
                return_value_UsrCli_get_manageHostName_107=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
                tmp_if_expr_109 = return_value_UsrCli_get_manageHostName_107;
              }

              else
              {
                return_value_ServerRealm_get_hostName_108=ServerRealm_get_hostName(scRealmsTable[(signed long int)i]);
                tmp_if_expr_109 = return_value_ServerRealm_get_hostName_108;
              }
              char *return_value_UsrCli_get_managePortName_110;
              return_value_UsrCli_get_managePortName_110=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
              aflog((char)4, (char)1, "tcp_listen_%s error for %s, %s", ((signed int)ipfam & 0x02) != 0 ? "ipv4" : (((signed int)ipfam & 0x04) != 0 ? "ipv6" : "unspec"), tmp_if_expr_109, return_value_UsrCli_get_managePortName_110);
              exit(1);
            }

          }

          ServerRealm_set_addressLength(scRealmsTable[(signed long int)i], len);
          UsrCli_set_manageFd(srUsersClientsTable[(signed long int)j], temp);
          return_value_UsrCli_get_manageFd_117=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)j]);
          flags=fcntl(return_value_UsrCli_get_manageFd_117, 3, 0);
          return_value_UsrCli_get_manageFd_118=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)j]);
          fcntl(return_value_UsrCli_get_manageFd_118, 4, flags | 04000);
          return_value_UsrCli_get_manageHostName_119=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
          return_value_UsrCli_get_managePortName_120=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
          return_value_eval_UsrCliPair_121=eval_UsrCliPair(srUsersClientsTable, j, return_value_UsrCli_get_manageHostName_119, return_value_UsrCli_get_managePortName_120);
          UsrCli_set_number(srUsersClientsTable[(signed long int)j], return_value_eval_UsrCliPair_121);
          break;
        }
        case 1:

        case 2:
        {
          return_value_UsrCli_get_manageHostName_122=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
          return_value_UsrCli_get_managePortName_123=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
          temp=find_previousFd(srUsersClientsTable, j, return_value_UsrCli_get_manageHostName_122, return_value_UsrCli_get_managePortName_123);
          if(temp == -1)
          {
            char *return_value_UsrCli_get_manageHostName_130;
            return_value_UsrCli_get_manageHostName_130=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
            if(!(return_value_UsrCli_get_manageHostName_130 == ((char *)NULL)))
            {
              return_value_UsrCli_get_manageHostName_131=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
              tmp_if_expr_133 = return_value_UsrCli_get_manageHostName_131;
            }

            else
            {
              return_value_ServerRealm_get_hostName_132=ServerRealm_get_hostName(scRealmsTable[(signed long int)i]);
              tmp_if_expr_133 = return_value_ServerRealm_get_hostName_132;
            }
            char *return_value_UsrCli_get_managePortName_134;
            return_value_UsrCli_get_managePortName_134=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
            signed int return_value_ServerRealm_get_clientsLimit_135;
            return_value_ServerRealm_get_clientsLimit_135=ServerRealm_get_clientsLimit(scRealmsTable[(signed long int)i]);
            signed int return_value_ServerRealm_get_raClientsLimit_136;
            return_value_ServerRealm_get_raClientsLimit_136=ServerRealm_get_raClientsLimit(scRealmsTable[(signed long int)i]);
            char return_value_ServerRealm_get_tunnelType_137;
            return_value_ServerRealm_get_tunnelType_137=ServerRealm_get_tunnelType(scRealmsTable[(signed long int)i]);
            signed int return_value_initialize_http_proxy_server_138;
            return_value_initialize_http_proxy_server_138=initialize_http_proxy_server(&temp, tmp_if_expr_133, return_value_UsrCli_get_managePortName_134, &len, ipfam, return_value_ServerRealm_get_clientsLimit_135 + return_value_ServerRealm_get_raClientsLimit_136, (char)((signed int)return_value_ServerRealm_get_tunnelType_137 - 1), ctx);
            if(!(return_value_initialize_http_proxy_server_138 == 0))
            {
              char return_value_ServerRealm_get_tunnelType_124;
              return_value_ServerRealm_get_tunnelType_124=ServerRealm_get_tunnelType(scRealmsTable[(signed long int)i]);
              char *return_value_UsrCli_get_manageHostName_125;
              return_value_UsrCli_get_manageHostName_125=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
              if(!(return_value_UsrCli_get_manageHostName_125 == ((char *)NULL)))
              {
                return_value_UsrCli_get_manageHostName_126=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
                tmp_if_expr_128 = return_value_UsrCli_get_manageHostName_126;
              }

              else
              {
                return_value_ServerRealm_get_hostName_127=ServerRealm_get_hostName(scRealmsTable[(signed long int)i]);
                tmp_if_expr_128 = return_value_ServerRealm_get_hostName_127;
              }
              char *return_value_UsrCli_get_managePortName_129;
              return_value_UsrCli_get_managePortName_129=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
              aflog((char)4, (char)1, "http%s_proxy_listen_%s error for %s, %s", (signed int)return_value_ServerRealm_get_tunnelType_124 == 2 ? "s" : "", ((signed int)ipfam & 0x02) != 0 ? "ipv4" : (((signed int)ipfam & 0x04) != 0 ? "ipv6" : "unspec"), tmp_if_expr_128, return_value_UsrCli_get_managePortName_129);
              exit(1);
            }

          }

          ServerRealm_set_addressLength(scRealmsTable[(signed long int)i], len);
          UsrCli_set_manageFd(srUsersClientsTable[(signed long int)j], temp);
          return_value_UsrCli_get_manageFd_139=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)j]);
          flags=fcntl(return_value_UsrCli_get_manageFd_139, 3, 0);
          return_value_UsrCli_get_manageFd_140=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)j]);
          fcntl(return_value_UsrCli_get_manageFd_140, 4, flags | 04000);
          return_value_UsrCli_get_manageHostName_141=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
          return_value_UsrCli_get_managePortName_142=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
          return_value_eval_UsrCliPair_143=eval_UsrCliPair(srUsersClientsTable, j, return_value_UsrCli_get_manageHostName_141, return_value_UsrCli_get_managePortName_142);
          UsrCli_set_number(srUsersClientsTable[(signed long int)j], return_value_eval_UsrCliPair_143);
          break;
        }
        default:
        {
          aflog((char)4, (char)1, "Unknown tunnel type");
          exit(1);
        }
      }
      j = j + 1;
    }
    while((_Bool)1);
    unsigned int return_value_ServerRealm_get_addressLength_144;
    return_value_ServerRealm_get_addressLength_144=ServerRealm_get_addressLength(scRealmsTable[(signed long int)i]);
    void *return_value_malloc_145;
    return_value_malloc_145=malloc((unsigned long int)return_value_ServerRealm_get_addressLength_144);
    ServerRealm_set_clientAddress(scRealmsTable[(signed long int)i], (struct sockaddr *)return_value_malloc_145);
    struct sockaddr *return_value_ServerRealm_get_clientAddress_146;
    return_value_ServerRealm_get_clientAddress_146=ServerRealm_get_clientAddress(scRealmsTable[(signed long int)i]);
    if(return_value_ServerRealm_get_clientAddress_146 == ((struct sockaddr *)NULL))
    {
      aflog((char)4, (char)1, "Allocating memory for client addresses failed... exiting");
      exit(1);
    }

    j = 0;
    do
    {
      return_value_ServerRealm_get_clientsLimit_147=ServerRealm_get_clientsLimit(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_clientsLimit_147)
        break;

      struct anonymous_1 *return_value_ConnectClient_get_sslFd_148;
      return_value_ConnectClient_get_sslFd_148=ConnectClient_get_sslFd(srClientsTable[(signed long int)j]);
      struct ssl_st *return_value_SSL_new_149;
      return_value_SSL_new_149=SSL_new(ctx);
      SslFd_set_ssl(return_value_ConnectClient_get_sslFd_148, return_value_SSL_new_149);
      struct anonymous_1 *return_value_ConnectClient_get_sslFd_150;
      return_value_ConnectClient_get_sslFd_150=ConnectClient_get_sslFd(srClientsTable[(signed long int)j]);
      struct ssl_st *return_value_SslFd_get_ssl_151;
      return_value_SslFd_get_ssl_151=SslFd_get_ssl(return_value_ConnectClient_get_sslFd_150);
      if(return_value_SslFd_get_ssl_151 == ((struct ssl_st *)NULL))
      {
        aflog((char)4, (char)1, "Creation of ssl object failed... exiting");
        exit(1);
      }

      j = j + 1;
    }
    while((_Bool)1);
    j = 0;
    do
    {
      return_value_ServerRealm_get_raClientsLimit_152=ServerRealm_get_raClientsLimit(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_raClientsLimit_152)
        break;

      struct anonymous_1 *return_value_ConnectClient_get_sslFd_153;
      return_value_ConnectClient_get_sslFd_153=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)j]);
      struct ssl_st *return_value_SSL_new_154;
      return_value_SSL_new_154=SSL_new(ctx);
      SslFd_set_ssl(return_value_ConnectClient_get_sslFd_153, return_value_SSL_new_154);
      struct anonymous_1 *return_value_ConnectClient_get_sslFd_155;
      return_value_ConnectClient_get_sslFd_155=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)j]);
      struct ssl_st *return_value_SslFd_get_ssl_156;
      return_value_SslFd_get_ssl_156=SslFd_get_ssl(return_value_ConnectClient_get_sslFd_155);
      if(return_value_SslFd_get_ssl_156 == ((struct ssl_st *)NULL))
      {
        aflog((char)4, (char)1, "Creation of ssl object failed... exiting");
        exit(1);
      }

      j = j + 1;
    }
    while((_Bool)1);
    j = 0;
    do
    {
      return_value_ServerRealm_get_userClientPairs_157=ServerRealm_get_userClientPairs(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_userClientPairs_157)
        break;

      signed int return_value_UsrCli_get_manageFd_158;
      return_value_UsrCli_get_manageFd_158=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)j]);
      signed int return_value_UsrCli_get_manageFd_159;
      return_value_UsrCli_get_manageFd_159=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)j]);
      (&allset)->__fds_bits[(signed long int)(return_value_UsrCli_get_manageFd_158 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_UsrCli_get_manageFd_158 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_UsrCli_get_manageFd_159 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
      signed int return_value_UsrCli_get_manageFd_160;
      return_value_UsrCli_get_manageFd_160=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)j]);
      if(!(1 + return_value_UsrCli_get_manageFd_160 >= maxfdp1))
        tmp_if_expr_162 = maxfdp1;

      else
      {
        return_value_UsrCli_get_manageFd_161=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)j]);
        tmp_if_expr_162 = return_value_UsrCli_get_manageFd_161 + 1;
      }
      maxfdp1 = tmp_if_expr_162;
      j = j + 1;
    }
    while((_Bool)1);
    char return_value_ServerRealm_get_basePortOn_169;
    return_value_ServerRealm_get_basePortOn_169=ServerRealm_get_basePortOn(scRealmsTable[(signed long int)i]);
    if((signed int)return_value_ServerRealm_get_basePortOn_169 == 0)
    {
      j = 0;
      do
      {
        return_value_ServerRealm_get_userClientPairs_163=ServerRealm_get_userClientPairs(scRealmsTable[(signed long int)i]);
        if(j >= return_value_ServerRealm_get_userClientPairs_163)
          break;

        signed int return_value_UsrCli_get_listenFd_164;
        return_value_UsrCli_get_listenFd_164=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)j]);
        signed int return_value_UsrCli_get_listenFd_165;
        return_value_UsrCli_get_listenFd_165=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)j]);
        (&allset)->__fds_bits[(signed long int)(return_value_UsrCli_get_listenFd_164 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_UsrCli_get_listenFd_164 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_UsrCli_get_listenFd_165 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
        signed int return_value_UsrCli_get_listenFd_166;
        return_value_UsrCli_get_listenFd_166=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)j]);
        if(!(1 + return_value_UsrCli_get_listenFd_166 >= maxfdp1))
          tmp_if_expr_168 = maxfdp1;

        else
        {
          return_value_UsrCli_get_listenFd_167=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)j]);
          tmp_if_expr_168 = return_value_UsrCli_get_listenFd_167 + 1;
        }
        maxfdp1 = tmp_if_expr_168;
        j = j + 1;
      }
      while((_Bool)1);
    }

    ServerRealm_set_connectedUsers(scRealmsTable[(signed long int)i], 0);
    ServerRealm_set_connectedClients(scRealmsTable[(signed long int)i], 0);
    ServerRealm_set_connectedRaClients(scRealmsTable[(signed long int)i], 0);
    j = 0;
    do
    {
      return_value_ServerRealm_get_clientsLimit_170=ServerRealm_get_clientsLimit(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_clientsLimit_170)
        break;

      signed int return_value_ServerRealm_get_timeout_171;
      return_value_ServerRealm_get_timeout_171=ServerRealm_get_timeout(scRealmsTable[(signed long int)i]);
      struct timeval return_value_timeval_create_172;
      return_value_timeval_create_172=timeval_create((signed long int)return_value_ServerRealm_get_timeout_171, (signed long int)0);
      ConnectClient_set_timer(srClientsTable[(signed long int)j], return_value_timeval_create_172);
      signed int return_value_ServerRealm_get_usersPerClient_173;
      return_value_ServerRealm_get_usersPerClient_173=ServerRealm_get_usersPerClient(scRealmsTable[(signed long int)i]);
      ConnectClient_set_limit(srClientsTable[(signed long int)j], return_value_ServerRealm_get_usersPerClient_173);
      signed int return_value_ConnectClient_create_users_174;
      return_value_ConnectClient_create_users_174=ConnectClient_create_users(srClientsTable[(signed long int)j]);
      if(!(return_value_ConnectClient_create_users_174 == 0))
      {
        aflog((char)4, (char)1, "Calloc error - try define smaller amount of usrpcli (or users)");
        exit(1);
      }

      j = j + 1;
    }
    while((_Bool)1);
    j = 0;
    do
    {
      return_value_ServerRealm_get_raClientsLimit_175=ServerRealm_get_raClientsLimit(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_raClientsLimit_175)
        break;

      signed int return_value_ServerRealm_get_timeout_176;
      return_value_ServerRealm_get_timeout_176=ServerRealm_get_timeout(scRealmsTable[(signed long int)i]);
      struct timeval return_value_timeval_create_177;
      return_value_timeval_create_177=timeval_create((signed long int)return_value_ServerRealm_get_timeout_176, (signed long int)0);
      ConnectClient_set_timer(srRaClientsTable[(signed long int)j], return_value_timeval_create_177);
      j = j + 1;
    }
    while((_Bool)1);
    i = i + 1;
  }
  while((_Bool)1);
  signed int return_value_ServerConfiguration_get_realmsNumber_178;
  return_value_ServerConfiguration_get_realmsNumber_178=ServerConfiguration_get_realmsNumber(config);
  aflog((char)16, (char)8, "SERVER STARTED realms: %d", return_value_ServerConfiguration_get_realmsNumber_178);
  time(&now);
  ServerConfiguration_set_startTime(config, now);
  signed int return_value_ServerConfiguration_get_realmsNumber_181;
  signed int return_value_ServerRealm_get_usersLimit_182;
  _Bool tmp_if_expr_277;
  char return_value_ConnectUser_get_state_276;
  _Bool tmp_if_expr_279;
  char return_value_ConnectUser_get_state_278;
  _Bool tmp_if_expr_272;
  char return_value_ServerRealm_get_realmType_271;
  _Bool tmp_if_expr_247;
  _Bool tmp_if_expr_248;
  signed int return_value_ServerRealm_get_usersLimit_280;
  _Bool tmp_if_expr_378;
  char return_value_ConnectUser_get_state_377;
  signed int return_value_ConnectUser_get_connFd_374;
  signed int return_value_ConnectUser_get_connFd_375;
  _Bool tmp_if_expr_373;
  signed int *return_value___errno_location_372;
  signed int return_value_ServerRealm_get_userClientPairs_379;
  signed int return_value_ConnectClient_get_connected_409;
  signed int return_value_ConnectClient_get_limit_410;
  signed int return_value_ServerRealm_get_usersLimit_391;
  signed int return_value_ServerRealm_get_clientsLimit_418;
  signed int return_value_ConnectClient_get_connected_446;
  signed int return_value_ConnectClient_get_limit_447;
  signed int return_value_ServerRealm_get_usersLimit_430;
  signed int return_value_ServerRealm_get_clientsLimit_454;
  char return_value_ConnectClient_get_state_794;
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_790;
  signed int return_value_SslFd_get_fd_791;
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_792;
  signed int return_value_SslFd_get_fd_793;
  char *return_value_get_realmname_470;
  char *return_value_get_clientname_471;
  struct auditlist *return_value_ConnectClient_get_auditList_504;
  struct alnode *return_value_AuditList_get_first_505;
  _Bool tmp_if_expr_558;
  signed int return_value_ServerRealm_get_usersLimit_557;
  _Bool tmp_if_expr_560;
  char return_value_ConnectClient_get_state_559;
  char return_value_ConnectUser_get_state_554;
  _Bool tmp_if_expr_575;
  signed int return_value_ServerRealm_get_usersLimit_574;
  _Bool tmp_if_expr_577;
  char return_value_ConnectClient_get_state_576;
  signed int tmp_if_expr_567;
  signed int return_value_ConnectUser_get_connFd_566;
  _Bool tmp_if_expr_587;
  signed int return_value_ServerRealm_get_usersLimit_586;
  _Bool tmp_if_expr_589;
  char return_value_ConnectClient_get_state_588;
  _Bool tmp_if_expr_585;
  char return_value_ConnectUser_get_state_584;
  char return_value_ConnectClient_get_state_590;
  char return_value_ServerRealm_get_realmType_595;
  _Bool tmp_if_expr_597;
  char return_value_ServerRealm_get_realmType_596;
  _Bool tmp_if_expr_676;
  signed int return_value_ServerRealm_get_usersLimit_675;
  _Bool tmp_if_expr_657;
  char return_value_ServerRealm_get_realmType_656;
  _Bool tmp_if_expr_654;
  signed int *return_value___errno_location_653;
  char return_value_ConnectUser_get_state_672;
  _Bool tmp_if_expr_666;
  char return_value_ServerRealm_get_realmType_665;
  char return_value_ConnectUser_get_state_671;
  char return_value_ConnectClient_get_state_725;
  _Bool tmp_if_expr_728;
  unsigned char *return_value_ServerRealm_get_password_726;
  unsigned char *return_value_ServerRealm_get_password_727;
  _Bool tmp_if_expr_731;
  unsigned char *return_value_ServerRealm_get_password_729;
  unsigned char *return_value_ServerRealm_get_password_730;
  char return_value_ServerRealm_get_realmType_694;
  signed int *return_value_ConnectClient_get_listenFdp_696;
  signed int return_value_ConnectClient_get_usrCliPair_697;
  char *return_value_UsrCli_get_listenHostName_698;
  char *tmp_if_expr_702;
  signed int return_value_ConnectClient_get_usrCliPair_699;
  char *return_value_UsrCli_get_listenHostName_700;
  char *return_value_ServerRealm_get_hostName_701;
  signed int return_value_ip_listen_703;
  signed int tmp_if_expr_708;
  signed int return_value_ConnectClient_get_listenFd_707;
  char return_value_ConnectClient_get_state_724;
  char return_value_ConnectUser_get_state_738;
  _Bool tmp_if_expr_740;
  char return_value_ConnectUser_get_state_739;
  char return_value_ConnectUser_get_state_747;
  _Bool tmp_if_expr_749;
  char return_value_ConnectUser_get_state_748;
  char *return_value_get_realmname_750;
  char *return_value_get_clientname_751;
  char return_value_ConnectClient_get_state_783;
  unsigned char *return_value_ServerRealm_get_password_781;
  unsigned char *return_value_ServerRealm_get_password_782;
  unsigned char *return_value_ServerRealm_get_password_779;
  unsigned char *return_value_ServerRealm_get_password_780;
  signed int return_value_ServerRealm_get_raClientsLimit_754;
  char *return_value_get_realmname_784;
  char *return_value_get_clientname_785;
  char *return_value_get_realmname_786;
  char *return_value_get_clientname_787;
  signed int return_value_ServerRealm_get_raClientsLimit_795;
  char return_value_ConnectClient_get_state_971;
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_967;
  signed int return_value_SslFd_get_fd_968;
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_969;
  signed int return_value_SslFd_get_fd_970;
  char *return_value_get_realmname_811;
  char *return_value_get_raclientname_812;
  char return_value_ConnectClient_get_state_904;
  _Bool tmp_if_expr_907;
  unsigned char *return_value_ServerRealm_get_password_905;
  unsigned char *return_value_ServerRealm_get_password_906;
  _Bool tmp_if_expr_910;
  unsigned char *return_value_ServerRealm_get_password_908;
  unsigned char *return_value_ServerRealm_get_password_909;
  signed int return_value_ServerRealm_get_clientsLimit_838;
  char return_value_ServerRealm_get_realmType_875;
  signed int *return_value_ConnectClient_get_listenFdp_877;
  signed int return_value_ConnectClient_get_usrCliPair_878;
  char *return_value_UsrCli_get_listenHostName_879;
  char *tmp_if_expr_883;
  signed int return_value_ConnectClient_get_usrCliPair_880;
  char *return_value_UsrCli_get_listenHostName_881;
  char *return_value_ServerRealm_get_hostName_882;
  signed int return_value_ip_listen_884;
  signed int tmp_if_expr_889;
  signed int return_value_ConnectClient_get_listenFd_888;
  char return_value_ConnectClient_get_state_903;
  char *return_value_get_realmname_911;
  char *return_value_get_raclientname_912;
  char return_value_ConnectClient_get_state_923;
  unsigned char *return_value_ServerRealm_get_password_921;
  unsigned char *return_value_ServerRealm_get_password_922;
  unsigned char *return_value_ServerRealm_get_password_919;
  unsigned char *return_value_ServerRealm_get_password_920;
  char return_value_ConnectClient_get_state_962;
  signed int return_value_ServerConfiguration_get_realmsNumber_926;
  struct auditlist *return_value_ConnectClient_get_auditList_939;
  struct alnode *return_value_AuditList_get_first_940;
  char *return_value_get_realmname_963;
  char *return_value_get_raclientname_964;
  signed int return_value_ServerRealm_get_userClientPairs_972;
  signed int return_value_ServerRealm_get_clientsLimit_981;
  signed int tmp_if_expr_1001;
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_999;
  signed int return_value_SslFd_get_fd_1000;
  signed int return_value_ServerRealm_get_raClientsLimit_1007;
  signed int tmp_if_expr_1027;
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_1025;
  signed int return_value_SslFd_get_fd_1026;
  do
  {
    rset = allset;
    tmpset = wset;
    aflog((char)16, (char)4, "select, maxfdp1: %d", maxfdp1);
    signed int return_value_TaskScheduler_hasMoreTasks_180;
    return_value_TaskScheduler_hasMoreTasks_180=TaskScheduler_hasMoreTasks(scheduler);
    if(!(return_value_TaskScheduler_hasMoreTasks_180 == 0))
    {
      TaskScheduler_startWatching(scheduler);
      struct timeval *return_value_TaskScheduler_get_actualTimer_179;
      return_value_TaskScheduler_get_actualTimer_179=TaskScheduler_get_actualTimer(scheduler);
      select(maxfdp1, &rset, &tmpset, (struct anonymous_22 *)(void *)0, return_value_TaskScheduler_get_actualTimer_179);
      TaskScheduler_stopWatching(scheduler);
    }

    else
      select(maxfdp1, &rset, &tmpset, (struct anonymous_22 *)(void *)0, (struct timeval *)(void *)0);
    aflog((char)16, (char)4, "after select...");
    j = 0;
    do
    {
      return_value_ServerConfiguration_get_realmsNumber_181=ServerConfiguration_get_realmsNumber(config);
      if(j >= return_value_ServerConfiguration_get_realmsNumber_181)
        break;

      pointer = scRealmsTable[(signed long int)j];
      srUsersTable=ServerRealm_get_usersTable(pointer);
      srClientsTable=ServerRealm_get_clientsTable(pointer);
      srRaClientsTable=ServerRealm_get_raClientsTable(pointer);
      srUsersClientsTable=ServerRealm_get_usersClientsTable(pointer);
      i = 0;
      do
      {
        return_value_ServerRealm_get_usersLimit_182=ServerRealm_get_usersLimit(pointer);
        if(i >= return_value_ServerRealm_get_usersLimit_182)
          break;

        char return_value_ConnectUser_get_state_275;
        return_value_ConnectUser_get_state_275=ConnectUser_get_state(srUsersTable[(signed long int)i]);
        if((signed int)return_value_ConnectUser_get_state_275 == 7)
          tmp_if_expr_277 = (_Bool)1;

        else
        {
          return_value_ConnectUser_get_state_276=ConnectUser_get_state(srUsersTable[(signed long int)i]);
          tmp_if_expr_277 = (signed int)return_value_ConnectUser_get_state_276 == 11 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_277)
          tmp_if_expr_279 = (_Bool)1;

        else
        {
          return_value_ConnectUser_get_state_278=ConnectUser_get_state(srUsersTable[(signed long int)i]);
          tmp_if_expr_279 = (signed int)return_value_ConnectUser_get_state_278 == 19 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_279)
        {
          signed int return_value_ConnectUser_get_connFd_273;
          return_value_ConnectUser_get_connFd_273=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
          signed int return_value_ConnectUser_get_connFd_274;
          return_value_ConnectUser_get_connFd_274=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
          if(!((rset.__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_273 / 8)] & 1l << return_value_ConnectUser_get_connFd_274 % 8) == 0l))
          {
            signed int return_value_ConnectUser_get_whatClient_183;
            return_value_ConnectUser_get_whatClient_183=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
            k=eval_usernum(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient_183], i);
            char *return_value_get_realmname_184;
            return_value_get_realmname_184=get_realmname(config, j);
            signed int return_value_ConnectUser_get_whatClient_185;
            return_value_ConnectUser_get_whatClient_185=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
            char *return_value_get_clientname_186;
            return_value_get_clientname_186=get_clientname(pointer, return_value_ConnectUser_get_whatClient_185);
            signed int return_value_get_username_187;
            return_value_get_username_187=get_username(pointer, i);
            aflog((char)1, (char)4, "realm[%s]: Client[%s]: user[%d]: FD_ISSET", return_value_get_realmname_184, return_value_get_clientname_186, return_value_get_username_187);
            char return_value_ServerRealm_get_realmType_270;
            return_value_ServerRealm_get_realmType_270=ServerRealm_get_realmType(pointer);
            if(!((1 & (signed int)return_value_ServerRealm_get_realmType_270) == 0))
            {
              return_value_ServerRealm_get_realmType_271=ServerRealm_get_realmType(pointer);
              tmp_if_expr_272 = !(((signed int)return_value_ServerRealm_get_realmType_271 & 2) != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_272 = (_Bool)0;
            if(tmp_if_expr_272)
            {
              signed int return_value_ConnectUser_get_connFd_188;
              return_value_ConnectUser_get_connFd_188=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
              signed long int return_value_read_189;
              return_value_read_189=read(return_value_ConnectUser_get_connFd_188, (void *)&buff[(signed long int)5], (unsigned long int)8091);
              n = (signed int)return_value_read_189;
              if(n == -1)
              {
                signed int *return_value___errno_location_190;
                return_value___errno_location_190=__errno_location();
                if(*return_value___errno_location_190 == 11)
                  goto __CPROVER_DUMP_L212;

                char *return_value_get_realmname_191;
                return_value_get_realmname_191=get_realmname(config, j);
                signed int return_value_ConnectUser_get_whatClient_192;
                return_value_ConnectUser_get_whatClient_192=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                char *return_value_get_clientname_193;
                return_value_get_clientname_193=get_clientname(pointer, return_value_ConnectUser_get_whatClient_192);
                signed int return_value_get_username_194;
                return_value_get_username_194=get_username(pointer, i);
                signed int *return_value___errno_location_195;
                return_value___errno_location_195=__errno_location();
                aflog((char)1, (char)64, "realm[%s]: Client[%s]: user[%d]: READ ERROR (%d)", return_value_get_realmname_191, return_value_get_clientname_193, return_value_get_username_194, *return_value___errno_location_195);
                n = 0;
              }

              if(!(n == 0))
              {
                char *return_value_get_realmname_196;
                return_value_get_realmname_196=get_realmname(config, j);
                signed int return_value_ConnectUser_get_whatClient_197;
                return_value_ConnectUser_get_whatClient_197=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                char *return_value_get_clientname_198;
                return_value_get_clientname_198=get_clientname(pointer, return_value_ConnectUser_get_whatClient_197);
                signed int return_value_get_username_199;
                return_value_get_username_199=get_username(pointer, i);
                aflog((char)1, (char)2, "realm[%s]: Client[%s]: FROM user[%d]: MESSAGE length=%d", return_value_get_realmname_196, return_value_get_clientname_198, return_value_get_username_199, n);
                struct anonymous_6 *return_value_ConnectUser_get_stats_200;
                return_value_ConnectUser_get_stats_200=ConnectUser_get_stats(srUsersTable[(signed long int)i]);
                UserStats_add_upload(return_value_ConnectUser_get_stats_200, n);
                if((signed int)buff[5l] == 3)
                {
                  if((signed int)buff[6l] == 8)
                  {
                    if((signed int)buff[7l] == 3)
                      aflog((char)1, (char)32, "WARNING: got packet similiar to udp");

                  }

                }

                buff[(signed long int)0] = (unsigned char)3;
                buff[(signed long int)1] = (unsigned char)(k >> 8);
                buff[(signed long int)2] = (unsigned char)k;
                buff[(signed long int)3] = (unsigned char)(n >> 8);
                buff[(signed long int)4] = (unsigned char)n;
                char return_value_ServerRealm_get_realmType_201;
                return_value_ServerRealm_get_realmType_201=ServerRealm_get_realmType(pointer);
                signed int return_value_ConnectUser_get_whatClient_202;
                return_value_ConnectUser_get_whatClient_202=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                struct anonymous_1 *return_value_ConnectClient_get_sslFd_203;
                return_value_ConnectClient_get_sslFd_203=ConnectClient_get_sslFd(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient_202]);
                SslFd_send_message(return_value_ServerRealm_get_realmType_201, return_value_ConnectClient_get_sslFd_203, buff, n + 5);
              }

              else
              {
                char *return_value_get_realmname_204;
                return_value_get_realmname_204=get_realmname(config, j);
                signed int return_value_ConnectUser_get_whatClient_205;
                return_value_ConnectUser_get_whatClient_205=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                char *return_value_get_clientname_206;
                return_value_get_clientname_206=get_clientname(pointer, return_value_ConnectUser_get_whatClient_205);
                signed int return_value_get_username_207;
                return_value_get_username_207=get_username(pointer, i);
                aflog((char)1, (char)8, "realm[%s]: Client[%s]: user[%d]: CLOSED", return_value_get_realmname_204, return_value_get_clientname_206, return_value_get_username_207);
                time(&now);
                char *return_value_get_realmname_208;
                return_value_get_realmname_208=get_realmname(config, j);
                signed int return_value_ConnectUser_get_whatClient_209;
                return_value_ConnectUser_get_whatClient_209=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                char *return_value_get_clientname_210;
                return_value_get_clientname_210=get_clientname(pointer, return_value_ConnectUser_get_whatClient_209);
                signed int return_value_get_username_211;
                return_value_get_username_211=get_username(pointer, i);
                char *return_value_ConnectUser_get_nameBuf_212;
                return_value_ConnectUser_get_nameBuf_212=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                char *return_value_ConnectUser_get_portBuf_213;
                return_value_ConnectUser_get_portBuf_213=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                signed long int return_value_ConnectUser_get_connectTime_214;
                return_value_ConnectUser_get_connectTime_214=ConnectUser_get_connectTime(srUsersTable[(signed long int)i]);
                char *return_value_timeperiod_215;
                return_value_timeperiod_215=timeperiod(now - return_value_ConnectUser_get_connectTime_214);
                aflog((char)1, (char)16, "REALM: %s CLIENT: %s USER: %d IP: %s PORT: %s DURATION: %s", return_value_get_realmname_208, return_value_get_clientname_210, return_value_get_username_211, return_value_ConnectUser_get_nameBuf_212, return_value_ConnectUser_get_portBuf_213, return_value_timeperiod_215);
                char return_value_ServerRealm_get_auditOn_224;
                return_value_ServerRealm_get_auditOn_224=ServerRealm_get_auditOn(pointer);
                if(!(return_value_ServerRealm_get_auditOn_224 == 0))
                {
                  signed int return_value_ConnectUser_get_whatClient_216;
                  return_value_ConnectUser_get_whatClient_216=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                  struct auditlist *return_value_ConnectClient_get_auditList_217;
                  return_value_ConnectClient_get_auditList_217=ConnectClient_get_auditList(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient_216]);
                  signed int return_value_get_username_218;
                  return_value_get_username_218=get_username(pointer, i);
                  char *return_value_ConnectUser_get_nameBuf_219;
                  return_value_ConnectUser_get_nameBuf_219=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                  char *return_value_ConnectUser_get_portBuf_220;
                  return_value_ConnectUser_get_portBuf_220=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                  signed long int return_value_ConnectUser_get_connectTime_221;
                  return_value_ConnectUser_get_connectTime_221=ConnectUser_get_connectTime(srUsersTable[(signed long int)i]);
                  signed long int return_value_ConnectUser_get_connectTime_222;
                  return_value_ConnectUser_get_connectTime_222=ConnectUser_get_connectTime(srUsersTable[(signed long int)i]);
                  struct alnode *return_value_AuditListNode_new_entry_223;
                  return_value_AuditListNode_new_entry_223=AuditListNode_new_entry(return_value_get_username_218, return_value_ConnectUser_get_nameBuf_219, return_value_ConnectUser_get_portBuf_220, return_value_ConnectUser_get_connectTime_221, now - return_value_ConnectUser_get_connectTime_222);
                  AuditList_insert_back(return_value_ConnectClient_get_auditList_217, return_value_AuditListNode_new_entry_223);
                }

                signed int return_value_ConnectUser_get_connFd_225;
                return_value_ConnectUser_get_connFd_225=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                close(return_value_ConnectUser_get_connFd_225);
                signed int return_value_ConnectUser_get_connFd_226;
                return_value_ConnectUser_get_connFd_226=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                signed int return_value_ConnectUser_get_connFd_227;
                return_value_ConnectUser_get_connFd_227=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_226 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_226 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_227 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                signed int return_value_ConnectUser_get_connFd_228;
                return_value_ConnectUser_get_connFd_228=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                signed int return_value_ConnectUser_get_connFd_229;
                return_value_ConnectUser_get_connFd_229=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_228 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_228 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_229 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                char return_value_ConnectUser_get_state_233;
                return_value_ConnectUser_get_state_233=ConnectUser_get_state(srUsersTable[(signed long int)i]);
                if((signed int)return_value_ConnectUser_get_state_233 == 19)
                {
                  ConnectUser_set_state(srUsersTable[(signed long int)i], (char)0);
                  ServerRealm_decrease_connectedUsers(pointer);
                  signed int return_value_ConnectUser_get_whatClient_230;
                  return_value_ConnectUser_get_whatClient_230=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                  ConnectClient_decrease_connected(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient_230]);
                  signed int return_value_ConnectUser_get_whatClient_231;
                  return_value_ConnectUser_get_whatClient_231=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                  signed int *return_value_ConnectClient_get_users_232;
                  return_value_ConnectClient_get_users_232=ConnectClient_get_users(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient_231]);
                  return_value_ConnectClient_get_users_232[(signed long int)k] = -1;
                }

                else
                  ConnectUser_set_state(srUsersTable[(signed long int)i], (char)5);
                struct buflist *return_value_ConnectUser_get_bufList_234;
                return_value_ConnectUser_get_bufList_234=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
                BufList_clear(return_value_ConnectUser_get_bufList_234);
                buff[(signed long int)0] = (unsigned char)1;
                buff[(signed long int)1] = (unsigned char)(k >> 8);
                buff[(signed long int)2] = (unsigned char)k;
                char return_value_ServerRealm_get_realmType_235;
                return_value_ServerRealm_get_realmType_235=ServerRealm_get_realmType(pointer);
                signed int return_value_ConnectUser_get_whatClient_236;
                return_value_ConnectUser_get_whatClient_236=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                struct anonymous_1 *return_value_ConnectClient_get_sslFd_237;
                return_value_ConnectClient_get_sslFd_237=ConnectClient_get_sslFd(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient_236]);
                SslFd_send_message(return_value_ServerRealm_get_realmType_235, return_value_ConnectClient_get_sslFd_237, buff, 5);
              }
            }

            else
            {
              signed int return_value_ConnectUser_get_connFd_238;
              return_value_ConnectUser_get_connFd_238=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
              n=readn(return_value_ConnectUser_get_connFd_238, buff, 5);
              if(!(n == 5))
                n = 0;

              if(!(n == 0))
              {
                if((signed int)buff[0l] == 3)
                  tmp_if_expr_247 = (signed int)buff[(signed long int)1] == 8 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_247 = (_Bool)0;
                if(tmp_if_expr_247)
                  tmp_if_expr_248 = (signed int)buff[(signed long int)2] == 3 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_248 = (_Bool)0;
                if(tmp_if_expr_248)
                {
                  length = (signed int)buff[(signed long int)3];
                  length = length << 8;
                  length = length + (signed int)buff[(signed long int)4];
                  signed int return_value_ConnectUser_get_connFd_246;
                  return_value_ConnectUser_get_connFd_246=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                  n=readn(return_value_ConnectUser_get_connFd_246, &buff[(signed long int)5], length);
                  if(!(n == 0))
                  {
                    char *return_value_get_realmname_239;
                    return_value_get_realmname_239=get_realmname(config, j);
                    signed int return_value_ConnectUser_get_whatClient_240;
                    return_value_ConnectUser_get_whatClient_240=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                    char *return_value_get_clientname_241;
                    return_value_get_clientname_241=get_clientname(pointer, return_value_ConnectUser_get_whatClient_240);
                    signed int return_value_get_username_242;
                    return_value_get_username_242=get_username(pointer, i);
                    aflog((char)1, (char)2, "realm[%s]: Client[%s]: FROM user[%d]: MESSAGE length=%d", return_value_get_realmname_239, return_value_get_clientname_241, return_value_get_username_242, n);
                    buff[(signed long int)1] = (unsigned char)(k >> 8);
                    buff[(signed long int)2] = (unsigned char)k;
                    char return_value_ServerRealm_get_realmType_243;
                    return_value_ServerRealm_get_realmType_243=ServerRealm_get_realmType(pointer);
                    signed int return_value_ConnectUser_get_whatClient_244;
                    return_value_ConnectUser_get_whatClient_244=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                    struct anonymous_1 *return_value_ConnectClient_get_sslFd_245;
                    return_value_ConnectClient_get_sslFd_245=ConnectClient_get_sslFd(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient_244]);
                    SslFd_send_message(return_value_ServerRealm_get_realmType_243, return_value_ConnectClient_get_sslFd_245, buff, n + 5);
                  }

                }

                else
                  n = 0;
              }

              if(n == 0)
              {
                char *return_value_get_realmname_249;
                return_value_get_realmname_249=get_realmname(config, j);
                signed int return_value_ConnectUser_get_whatClient_250;
                return_value_ConnectUser_get_whatClient_250=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                char *return_value_get_clientname_251;
                return_value_get_clientname_251=get_clientname(pointer, return_value_ConnectUser_get_whatClient_250);
                signed int return_value_get_username_252;
                return_value_get_username_252=get_username(pointer, i);
                aflog((char)1, (char)8, "realm[%s]: Client[%s]: user[%d]: CLOSED (udp mode)", return_value_get_realmname_249, return_value_get_clientname_251, return_value_get_username_252);
                time(&now);
                char *return_value_get_realmname_253;
                return_value_get_realmname_253=get_realmname(config, j);
                signed int return_value_ConnectUser_get_whatClient_254;
                return_value_ConnectUser_get_whatClient_254=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                char *return_value_get_clientname_255;
                return_value_get_clientname_255=get_clientname(pointer, return_value_ConnectUser_get_whatClient_254);
                signed int return_value_get_username_256;
                return_value_get_username_256=get_username(pointer, i);
                char *return_value_ConnectUser_get_nameBuf_257;
                return_value_ConnectUser_get_nameBuf_257=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                char *return_value_ConnectUser_get_portBuf_258;
                return_value_ConnectUser_get_portBuf_258=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                signed long int return_value_ConnectUser_get_connectTime_259;
                return_value_ConnectUser_get_connectTime_259=ConnectUser_get_connectTime(srUsersTable[(signed long int)i]);
                char *return_value_timeperiod_260;
                return_value_timeperiod_260=timeperiod(now - return_value_ConnectUser_get_connectTime_259);
                aflog((char)1, (char)16, "REALM: %s CLIENT: %s USER: %d IP: %s PORT: %s DURATION: %s", return_value_get_realmname_253, return_value_get_clientname_255, return_value_get_username_256, return_value_ConnectUser_get_nameBuf_257, return_value_ConnectUser_get_portBuf_258, return_value_timeperiod_260);
                signed int return_value_ConnectUser_get_connFd_261;
                return_value_ConnectUser_get_connFd_261=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                close(return_value_ConnectUser_get_connFd_261);
                signed int return_value_ConnectUser_get_connFd_262;
                return_value_ConnectUser_get_connFd_262=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                signed int return_value_ConnectUser_get_connFd_263;
                return_value_ConnectUser_get_connFd_263=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_262 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_262 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_263 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                signed int return_value_ConnectUser_get_connFd_264;
                return_value_ConnectUser_get_connFd_264=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                signed int return_value_ConnectUser_get_connFd_265;
                return_value_ConnectUser_get_connFd_265=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_264 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_264 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_265 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                ConnectUser_set_state(srUsersTable[(signed long int)i], (char)5);
                struct buflist *return_value_ConnectUser_get_bufList_266;
                return_value_ConnectUser_get_bufList_266=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
                BufList_clear(return_value_ConnectUser_get_bufList_266);
                buff[(signed long int)0] = (unsigned char)1;
                buff[(signed long int)1] = (unsigned char)(k >> 8);
                buff[(signed long int)2] = (unsigned char)k;
                char return_value_ServerRealm_get_realmType_267;
                return_value_ServerRealm_get_realmType_267=ServerRealm_get_realmType(pointer);
                signed int return_value_ConnectUser_get_whatClient_268;
                return_value_ConnectUser_get_whatClient_268=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                struct anonymous_1 *return_value_ConnectClient_get_sslFd_269;
                return_value_ConnectClient_get_sslFd_269=ConnectClient_get_sslFd(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient_268]);
                SslFd_send_message(return_value_ServerRealm_get_realmType_267, return_value_ConnectClient_get_sslFd_269, buff, 5);
              }

            }
          }

        }


      __CPROVER_DUMP_L212:
        ;
        i = i + 1;
      }
      while((_Bool)1);
      i = 0;
      do
      {
        return_value_ServerRealm_get_usersLimit_280=ServerRealm_get_usersLimit(pointer);
        if(i >= return_value_ServerRealm_get_usersLimit_280)
          break;

        char return_value_ConnectUser_get_state_376;
        return_value_ConnectUser_get_state_376=ConnectUser_get_state(srUsersTable[(signed long int)i]);
        if((signed int)return_value_ConnectUser_get_state_376 == 11)
          tmp_if_expr_378 = (_Bool)1;

        else
        {
          return_value_ConnectUser_get_state_377=ConnectUser_get_state(srUsersTable[(signed long int)i]);
          tmp_if_expr_378 = (signed int)return_value_ConnectUser_get_state_377 == 19 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_378)
        {
          return_value_ConnectUser_get_connFd_374=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
          return_value_ConnectUser_get_connFd_375=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
          if(!((tmpset.__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_374 / 8)] & 1l << return_value_ConnectUser_get_connFd_375 % 8) == 0l))
          {
            signed int return_value_ConnectUser_get_whatClient_281;
            return_value_ConnectUser_get_whatClient_281=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
            k=eval_usernum(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient_281], i);
            char *return_value_get_realmname_282;
            return_value_get_realmname_282=get_realmname(config, j);
            signed int return_value_ConnectUser_get_whatClient_283;
            return_value_ConnectUser_get_whatClient_283=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
            char *return_value_get_clientname_284;
            return_value_get_clientname_284=get_clientname(pointer, return_value_ConnectUser_get_whatClient_283);
            signed int return_value_get_username_285;
            return_value_get_username_285=get_username(pointer, i);
            aflog((char)1, (char)4, "realm[%s]: Client[%s]: user[%d]: FD_ISSET - WRITE", return_value_get_realmname_282, return_value_get_clientname_284, return_value_get_username_285);
            struct buflist *return_value_ConnectUser_get_bufList_286;
            return_value_ConnectUser_get_bufList_286=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
            struct blnode *return_value_BufList_get_first_287;
            return_value_BufList_get_first_287=BufList_get_first(return_value_ConnectUser_get_bufList_286);
            n=BufListNode_readMessageLength(return_value_BufList_get_first_287);
            signed int return_value_ConnectUser_get_connFd_288;
            return_value_ConnectUser_get_connFd_288=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
            struct buflist *return_value_ConnectUser_get_bufList_289;
            return_value_ConnectUser_get_bufList_289=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
            struct blnode *return_value_BufList_get_first_290;
            return_value_BufList_get_first_290=BufList_get_first(return_value_ConnectUser_get_bufList_289);
            unsigned char *return_value_BufListNode_readMessage_291;
            return_value_BufListNode_readMessage_291=BufListNode_readMessage(return_value_BufList_get_first_290);
            signed long int return_value_write_292;
            return_value_write_292=write(return_value_ConnectUser_get_connFd_288, (const void *)return_value_BufListNode_readMessage_291, (unsigned long int)n);
            sent = (signed int)return_value_write_292;
            if(sent >= 1 && !(sent == n))
            {
              struct buflist *return_value_ConnectUser_get_bufList_293;
              return_value_ConnectUser_get_bufList_293=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
              struct blnode *return_value_BufList_get_first_294;
              return_value_BufList_get_first_294=BufList_get_first(return_value_ConnectUser_get_bufList_293);
              struct buflist *return_value_ConnectUser_get_bufList_295;
              return_value_ConnectUser_get_bufList_295=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
              struct blnode *return_value_BufList_get_first_296;
              return_value_BufList_get_first_296=BufList_get_first(return_value_ConnectUser_get_bufList_295);
              signed int return_value_BufListNode_get_actPtr_297;
              return_value_BufListNode_get_actPtr_297=BufListNode_get_actPtr(return_value_BufList_get_first_296);
              BufListNode_set_actPtr(return_value_BufList_get_first_294, return_value_BufListNode_get_actPtr_297 + sent);
              char *return_value_get_realmname_298;
              return_value_get_realmname_298=get_realmname(config, j);
              signed int return_value_ConnectUser_get_whatClient_299;
              return_value_ConnectUser_get_whatClient_299=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
              char *return_value_get_clientname_300;
              return_value_get_clientname_300=get_clientname(pointer, return_value_ConnectUser_get_whatClient_299);
              signed int return_value_get_username_301;
              return_value_get_username_301=get_username(pointer, i);
              aflog((char)1, (char)4, "realm[%s]: Client[%s]: user[%d]: (%d/%d)", return_value_get_realmname_298, return_value_get_clientname_300, return_value_get_username_301, sent, n);
            }

            else
            {
              if(sent == -1)
              {
                return_value___errno_location_372=__errno_location();
                tmp_if_expr_373 = *return_value___errno_location_372 == 11 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_373 = (_Bool)0;
              if(tmp_if_expr_373)
              {
                char *return_value_get_realmname_302;
                return_value_get_realmname_302=get_realmname(config, j);
                signed int return_value_ConnectUser_get_whatClient_303;
                return_value_ConnectUser_get_whatClient_303=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                char *return_value_get_clientname_304;
                return_value_get_clientname_304=get_clientname(pointer, return_value_ConnectUser_get_whatClient_303);
                signed int return_value_get_username_305;
                return_value_get_username_305=get_username(pointer, i);
                aflog((char)1, (char)4, "realm[%s]: Client[%s]: user[%d]: EAGAIN", return_value_get_realmname_302, return_value_get_clientname_304, return_value_get_username_305);
              }

              else
                if(sent == -1)
                {
                  char *return_value_get_realmname_306;
                  return_value_get_realmname_306=get_realmname(config, j);
                  signed int return_value_ConnectUser_get_whatClient_307;
                  return_value_ConnectUser_get_whatClient_307=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                  char *return_value_get_clientname_308;
                  return_value_get_clientname_308=get_clientname(pointer, return_value_ConnectUser_get_whatClient_307);
                  signed int return_value_get_username_309;
                  return_value_get_username_309=get_username(pointer, i);
                  aflog((char)1, (char)8, "realm[%s]: Client[%s]: user[%d]: CLOSED", return_value_get_realmname_306, return_value_get_clientname_308, return_value_get_username_309);
                  time(&now);
                  char *return_value_get_realmname_310;
                  return_value_get_realmname_310=get_realmname(config, j);
                  signed int return_value_ConnectUser_get_whatClient_311;
                  return_value_ConnectUser_get_whatClient_311=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                  char *return_value_get_clientname_312;
                  return_value_get_clientname_312=get_clientname(pointer, return_value_ConnectUser_get_whatClient_311);
                  signed int return_value_get_username_313;
                  return_value_get_username_313=get_username(pointer, i);
                  char *return_value_ConnectUser_get_nameBuf_314;
                  return_value_ConnectUser_get_nameBuf_314=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                  char *return_value_ConnectUser_get_portBuf_315;
                  return_value_ConnectUser_get_portBuf_315=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                  signed long int return_value_ConnectUser_get_connectTime_316;
                  return_value_ConnectUser_get_connectTime_316=ConnectUser_get_connectTime(srUsersTable[(signed long int)i]);
                  char *return_value_timeperiod_317;
                  return_value_timeperiod_317=timeperiod(now - return_value_ConnectUser_get_connectTime_316);
                  aflog((char)1, (char)16, "REALM: %s CLIENT: %s USER: %d IP: %s PORT: %s DURATION: %s", return_value_get_realmname_310, return_value_get_clientname_312, return_value_get_username_313, return_value_ConnectUser_get_nameBuf_314, return_value_ConnectUser_get_portBuf_315, return_value_timeperiod_317);
                  signed int return_value_ConnectUser_get_connFd_318;
                  return_value_ConnectUser_get_connFd_318=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                  close(return_value_ConnectUser_get_connFd_318);
                  signed int return_value_ConnectUser_get_connFd_319;
                  return_value_ConnectUser_get_connFd_319=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                  signed int return_value_ConnectUser_get_connFd_320;
                  return_value_ConnectUser_get_connFd_320=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                  (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_319 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_319 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_320 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  signed int return_value_ConnectUser_get_connFd_321;
                  return_value_ConnectUser_get_connFd_321=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                  signed int return_value_ConnectUser_get_connFd_322;
                  return_value_ConnectUser_get_connFd_322=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                  (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_321 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_321 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_322 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  char return_value_ConnectUser_get_state_326;
                  return_value_ConnectUser_get_state_326=ConnectUser_get_state(srUsersTable[(signed long int)i]);
                  if((signed int)return_value_ConnectUser_get_state_326 == 19)
                  {
                    ConnectUser_set_state(srUsersTable[(signed long int)i], (char)0);
                    ServerRealm_decrease_connectedUsers(pointer);
                    signed int return_value_ConnectUser_get_whatClient_323;
                    return_value_ConnectUser_get_whatClient_323=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                    ConnectClient_decrease_connected(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient_323]);
                    signed int return_value_ConnectUser_get_whatClient_324;
                    return_value_ConnectUser_get_whatClient_324=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                    signed int *return_value_ConnectClient_get_users_325;
                    return_value_ConnectClient_get_users_325=ConnectClient_get_users(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient_324]);
                    return_value_ConnectClient_get_users_325[(signed long int)k] = -1;
                  }

                  else
                    ConnectUser_set_state(srUsersTable[(signed long int)i], (char)5);
                  struct buflist *return_value_ConnectUser_get_bufList_327;
                  return_value_ConnectUser_get_bufList_327=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
                  BufList_clear(return_value_ConnectUser_get_bufList_327);
                  buff[(signed long int)0] = (unsigned char)1;
                  buff[(signed long int)1] = (unsigned char)(k >> 8);
                  buff[(signed long int)2] = (unsigned char)k;
                  char return_value_ServerRealm_get_realmType_328;
                  return_value_ServerRealm_get_realmType_328=ServerRealm_get_realmType(pointer);
                  signed int return_value_ConnectUser_get_whatClient_329;
                  return_value_ConnectUser_get_whatClient_329=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                  struct anonymous_1 *return_value_ConnectClient_get_sslFd_330;
                  return_value_ConnectClient_get_sslFd_330=ConnectClient_get_sslFd(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient_329]);
                  SslFd_send_message(return_value_ServerRealm_get_realmType_328, return_value_ConnectClient_get_sslFd_330, buff, 5);
                }

                else
                {
                  char *return_value_get_realmname_331;
                  return_value_get_realmname_331=get_realmname(config, j);
                  signed int return_value_ConnectUser_get_whatClient_332;
                  return_value_ConnectUser_get_whatClient_332=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                  char *return_value_get_clientname_333;
                  return_value_get_clientname_333=get_clientname(pointer, return_value_ConnectUser_get_whatClient_332);
                  signed int return_value_get_username_334;
                  return_value_get_username_334=get_username(pointer, i);
                  aflog((char)1, (char)4, "realm[%s]: Client[%s]: user[%d]: (%d/%d)", return_value_get_realmname_331, return_value_get_clientname_333, return_value_get_username_334, sent, n);
                  struct buflist *return_value_ConnectUser_get_bufList_335;
                  return_value_ConnectUser_get_bufList_335=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
                  BufList_delete_first(return_value_ConnectUser_get_bufList_335);
                  struct buflist *return_value_ConnectUser_get_bufList_370;
                  return_value_ConnectUser_get_bufList_370=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
                  struct blnode *return_value_BufList_get_first_371;
                  return_value_BufList_get_first_371=BufList_get_first(return_value_ConnectUser_get_bufList_370);
                  if(return_value_BufList_get_first_371 == ((struct blnode *)NULL))
                  {
                    signed int return_value_ConnectUser_get_connFd_336;
                    return_value_ConnectUser_get_connFd_336=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                    signed int return_value_ConnectUser_get_connFd_337;
                    return_value_ConnectUser_get_connFd_337=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                    (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_336 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_336 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_337 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                    buff[(signed long int)0] = (unsigned char)10;
                    buff[(signed long int)1] = (unsigned char)(k >> 8);
                    buff[(signed long int)2] = (unsigned char)k;
                    char *return_value_get_realmname_338;
                    return_value_get_realmname_338=get_realmname(config, j);
                    signed int return_value_ConnectUser_get_whatClient_339;
                    return_value_ConnectUser_get_whatClient_339=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                    char *return_value_get_clientname_340;
                    return_value_get_clientname_340=get_clientname(pointer, return_value_ConnectUser_get_whatClient_339);
                    signed int return_value_get_username_341;
                    return_value_get_username_341=get_username(pointer, i);
                    aflog((char)1, (char)4, "realm[%s]: Client[%s]: TO user[%d]: BUFFERING MESSAGE ENDED", return_value_get_realmname_338, return_value_get_clientname_340, return_value_get_username_341);
                    char return_value_ServerRealm_get_realmType_342;
                    return_value_ServerRealm_get_realmType_342=ServerRealm_get_realmType(pointer);
                    signed int return_value_ConnectUser_get_whatClient_343;
                    return_value_ConnectUser_get_whatClient_343=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                    struct anonymous_1 *return_value_ConnectClient_get_sslFd_344;
                    return_value_ConnectClient_get_sslFd_344=ConnectClient_get_sslFd(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient_343]);
                    SslFd_send_message(return_value_ServerRealm_get_realmType_342, return_value_ConnectClient_get_sslFd_344, buff, 5);
                    char return_value_ConnectUser_get_state_369;
                    return_value_ConnectUser_get_state_369=ConnectUser_get_state(srUsersTable[(signed long int)i]);
                    if((signed int)return_value_ConnectUser_get_state_369 == 19)
                    {
                      char *return_value_get_realmname_345;
                      return_value_get_realmname_345=get_realmname(config, j);
                      signed int return_value_ConnectUser_get_whatClient_346;
                      return_value_ConnectUser_get_whatClient_346=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                      char *return_value_get_clientname_347;
                      return_value_get_clientname_347=get_clientname(pointer, return_value_ConnectUser_get_whatClient_346);
                      signed int return_value_get_username_348;
                      return_value_get_username_348=get_username(pointer, i);
                      aflog((char)1, (char)8, "realm[%s]: Client[%s]: user[%d]: delayed CLOSED", return_value_get_realmname_345, return_value_get_clientname_347, return_value_get_username_348);
                      time(&now);
                      char *return_value_get_realmname_349;
                      return_value_get_realmname_349=get_realmname(config, j);
                      signed int return_value_ConnectUser_get_whatClient_350;
                      return_value_ConnectUser_get_whatClient_350=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                      char *return_value_get_clientname_351;
                      return_value_get_clientname_351=get_clientname(pointer, return_value_ConnectUser_get_whatClient_350);
                      signed int return_value_get_username_352;
                      return_value_get_username_352=get_username(pointer, i);
                      char *return_value_ConnectUser_get_nameBuf_353;
                      return_value_ConnectUser_get_nameBuf_353=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                      char *return_value_ConnectUser_get_portBuf_354;
                      return_value_ConnectUser_get_portBuf_354=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                      signed long int return_value_ConnectUser_get_connectTime_355;
                      return_value_ConnectUser_get_connectTime_355=ConnectUser_get_connectTime(srUsersTable[(signed long int)i]);
                      char *return_value_timeperiod_356;
                      return_value_timeperiod_356=timeperiod(now - return_value_ConnectUser_get_connectTime_355);
                      aflog((char)1, (char)16, "REALM: %s CLIENT: %s USER: %d IP: %s PORT: %s DURATION: %s", return_value_get_realmname_349, return_value_get_clientname_351, return_value_get_username_352, return_value_ConnectUser_get_nameBuf_353, return_value_ConnectUser_get_portBuf_354, return_value_timeperiod_356);
                      signed int return_value_ConnectUser_get_connFd_357;
                      return_value_ConnectUser_get_connFd_357=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                      close(return_value_ConnectUser_get_connFd_357);
                      signed int return_value_ConnectUser_get_connFd_358;
                      return_value_ConnectUser_get_connFd_358=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                      signed int return_value_ConnectUser_get_connFd_359;
                      return_value_ConnectUser_get_connFd_359=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                      (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_358 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_358 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_359 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                      signed int return_value_ConnectUser_get_connFd_360;
                      return_value_ConnectUser_get_connFd_360=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                      signed int return_value_ConnectUser_get_connFd_361;
                      return_value_ConnectUser_get_connFd_361=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                      (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_360 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_360 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_361 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                      ConnectUser_set_state(srUsersTable[(signed long int)i], (char)0);
                      ServerRealm_decrease_connectedUsers(pointer);
                      signed int return_value_ConnectUser_get_whatClient_362;
                      return_value_ConnectUser_get_whatClient_362=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                      ConnectClient_decrease_connected(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient_362]);
                      signed int return_value_ConnectUser_get_whatClient_363;
                      return_value_ConnectUser_get_whatClient_363=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                      signed int *return_value_ConnectClient_get_users_364;
                      return_value_ConnectClient_get_users_364=ConnectClient_get_users(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient_363]);
                      return_value_ConnectClient_get_users_364[(signed long int)k] = -1;
                      struct buflist *return_value_ConnectUser_get_bufList_365;
                      return_value_ConnectUser_get_bufList_365=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
                      BufList_clear(return_value_ConnectUser_get_bufList_365);
                      buff[(signed long int)0] = (unsigned char)1;
                      buff[(signed long int)1] = (unsigned char)(k >> 8);
                      buff[(signed long int)2] = (unsigned char)k;
                      char return_value_ServerRealm_get_realmType_366;
                      return_value_ServerRealm_get_realmType_366=ServerRealm_get_realmType(pointer);
                      signed int return_value_ConnectUser_get_whatClient_367;
                      return_value_ConnectUser_get_whatClient_367=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                      struct anonymous_1 *return_value_ConnectClient_get_sslFd_368;
                      return_value_ConnectClient_get_sslFd_368=ConnectClient_get_sslFd(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient_367]);
                      SslFd_send_message(return_value_ServerRealm_get_realmType_366, return_value_ConnectClient_get_sslFd_368, buff, 5);
                    }

                    else
                      ConnectUser_set_state(srUsersTable[(signed long int)i], (char)7);
                  }

                }
            }
          }

        }

        i = i + 1;
      }
      while((_Bool)1);
      char return_value_ServerRealm_get_basePortOn_417;
      return_value_ServerRealm_get_basePortOn_417=ServerRealm_get_basePortOn(pointer);
      if((signed int)return_value_ServerRealm_get_basePortOn_417 == 0)
      {
        l = 0;
        do
        {
          return_value_ServerRealm_get_userClientPairs_379=ServerRealm_get_userClientPairs(pointer);
          if(l >= return_value_ServerRealm_get_userClientPairs_379)
            break;

          signed int return_value_UsrCli_get_listenFd_415;
          return_value_UsrCli_get_listenFd_415=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)l]);
          signed int return_value_UsrCli_get_listenFd_416;
          return_value_UsrCli_get_listenFd_416=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)l]);
          if(!((rset.__fds_bits[(signed long int)(return_value_UsrCli_get_listenFd_415 / 8)] & 1l << return_value_UsrCli_get_listenFd_416 % 8) == 0l))
          {
            len=ServerRealm_get_addressLength(pointer);
            signed int return_value_UsrCli_get_listenFd_380;
            return_value_UsrCli_get_listenFd_380=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)l]);
            struct sockaddr *return_value_ServerRealm_get_clientAddress_381;
            return_value_ServerRealm_get_clientAddress_381=ServerRealm_get_clientAddress(pointer);
            sent=accept(return_value_UsrCli_get_listenFd_380, return_value_ServerRealm_get_clientAddress_381, &len);
            if(sent == -1)
            {
              signed int *return_value___errno_location_385;
              return_value___errno_location_385=__errno_location();
              if(*return_value___errno_location_385 == 11)
              {
                char *return_value_get_realmname_382;
                return_value_get_realmname_382=get_realmname(config, j);
                aflog((char)1, (char)4, "realm[%s]: listenfd: FD_ISSET --> EAGAIN", return_value_get_realmname_382);
              }

              else
              {
                char *return_value_get_realmname_383;
                return_value_get_realmname_383=get_realmname(config, j);
                signed int *return_value___errno_location_384;
                return_value___errno_location_384=__errno_location();
                aflog((char)1, (char)4, "realm[%s]: listenfd: FD_ISSET --> errno=%d", return_value_get_realmname_383, *return_value___errno_location_384);
              }
              goto __CPROVER_DUMP_L244;
            }

            flags=fcntl(sent, 3, 0);
            fcntl(sent, 4, flags | 04000);
            char *return_value_get_realmname_386;
            return_value_get_realmname_386=get_realmname(config, j);
            aflog((char)1, (char)4, "realm[%s]: listenfd: FD_ISSET", return_value_get_realmname_386);
            signed int return_value_ServerRealm_get_clientMode_387;
            return_value_ServerRealm_get_clientMode_387=ServerRealm_get_clientMode(pointer);
            k=find_client(pointer, (char)return_value_ServerRealm_get_clientMode_387, l);
            char return_value_ConnectClient_get_state_414;
            return_value_ConnectClient_get_state_414=ConnectClient_get_state(srClientsTable[(signed long int)k]);
            if((signed int)return_value_ConnectClient_get_state_414 == 3)
            {
              signed int return_value_ServerRealm_get_connectedUsers_411;
              return_value_ServerRealm_get_connectedUsers_411=ServerRealm_get_connectedUsers(pointer);
              signed int return_value_ServerRealm_get_usersLimit_412;
              return_value_ServerRealm_get_usersLimit_412=ServerRealm_get_usersLimit(pointer);
              if(return_value_ServerRealm_get_connectedUsers_411 == return_value_ServerRealm_get_usersLimit_412)
              {
                close(sent);
                char *return_value_get_realmname_388;
                return_value_get_realmname_388=get_realmname(config, j);
                aflog((char)1, (char)32, "realm[%s]: user limit EXCEEDED", return_value_get_realmname_388);
              }

              else
              {
                return_value_ConnectClient_get_connected_409=ConnectClient_get_connected(srClientsTable[(signed long int)k]);
                return_value_ConnectClient_get_limit_410=ConnectClient_get_limit(srClientsTable[(signed long int)k]);
                if(return_value_ConnectClient_get_connected_409 == return_value_ConnectClient_get_limit_410)
                {
                  close(sent);
                  char *return_value_get_realmname_389;
                  return_value_get_realmname_389=get_realmname(config, j);
                  char *return_value_get_clientname_390;
                  return_value_get_clientname_390=get_clientname(pointer, k);
                  aflog((char)1, (char)32, "realm[%s]: Client[%s]: usrpcli limit EXCEEDED", return_value_get_realmname_389, return_value_get_clientname_390);
                }

                else
                {
                  i = 0;
                  do
                  {
                    return_value_ServerRealm_get_usersLimit_391=ServerRealm_get_usersLimit(pointer);
                    if(i >= return_value_ServerRealm_get_usersLimit_391)
                      break;

                    char return_value_ConnectUser_get_state_408;
                    return_value_ConnectUser_get_state_408=ConnectUser_get_state(srUsersTable[(signed long int)i]);
                    if((signed int)return_value_ConnectUser_get_state_408 == 0)
                    {
                      signed int return_value_ServerRealm_get_usersCounter_392;
                      return_value_ServerRealm_get_usersCounter_392=ServerRealm_get_usersCounter(pointer);
                      ConnectUser_set_userId(srUsersTable[(signed long int)i], return_value_ServerRealm_get_usersCounter_392);
                      ServerRealm_increase_usersCounter(pointer);
                      char *return_value_get_realmname_393;
                      return_value_get_realmname_393=get_realmname(config, j);
                      char *return_value_get_clientname_394;
                      return_value_get_clientname_394=get_clientname(pointer, k);
                      struct sockaddr *return_value_ServerRealm_get_clientAddress_395;
                      return_value_ServerRealm_get_clientAddress_395=ServerRealm_get_clientAddress(pointer);
                      char *return_value_ConnectUser_get_nameBuf_396;
                      return_value_ConnectUser_get_nameBuf_396=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                      char *return_value_ConnectUser_get_portBuf_397;
                      return_value_ConnectUser_get_portBuf_397=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                      char return_value_ServerRealm_get_dnsLookupsOn_398;
                      return_value_ServerRealm_get_dnsLookupsOn_398=ServerRealm_get_dnsLookupsOn(pointer);
                      char *return_value_sock_ntop_399;
                      return_value_sock_ntop_399=sock_ntop(return_value_ServerRealm_get_clientAddress_395, len, return_value_ConnectUser_get_nameBuf_396, return_value_ConnectUser_get_portBuf_397, return_value_ServerRealm_get_dnsLookupsOn_398);
                      aflog((char)1, (char)8, "realm[%s]: Client[%s]: new user: CONNECTING from IP: %s", return_value_get_realmname_393, return_value_get_clientname_394, return_value_sock_ntop_399);
                      ConnectUser_set_connFd(srUsersTable[(signed long int)i], sent);
                      ConnectUser_set_state(srUsersTable[(signed long int)i], (char)6);
                      ConnectUser_set_whatClient(srUsersTable[(signed long int)i], k);
                      time(&now);
                      ConnectUser_set_connectTime(srUsersTable[(signed long int)i], now);
                      struct anonymous_6 *return_value_ConnectUser_get_stats_400;
                      return_value_ConnectUser_get_stats_400=ConnectUser_get_stats(srUsersTable[(signed long int)i]);
                      UserStats_clear(return_value_ConnectUser_get_stats_400);
                      struct anonymous_6 *return_value_ConnectUser_get_stats_401;
                      return_value_ConnectUser_get_stats_401=ConnectUser_get_stats(srUsersTable[(signed long int)i]);
                      UserStats_set_lastActivity(return_value_ConnectUser_get_stats_401, now);
                      ServerRealm_increase_connectedUsers(pointer);
                      ConnectClient_increase_connected(srClientsTable[(signed long int)k]);
                      char *return_value_ConnectUser_get_nameBuf_402;
                      return_value_ConnectUser_get_nameBuf_402=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                      memcpy((void *)&buff[(signed long int)5], (const void *)return_value_ConnectUser_get_nameBuf_402, (unsigned long int)128);
                      char *return_value_ConnectUser_get_portBuf_403;
                      return_value_ConnectUser_get_portBuf_403=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                      memcpy((void *)&buff[(signed long int)133], (const void *)return_value_ConnectUser_get_portBuf_403, (unsigned long int)7);
                      n = 135;
                      char return_value_ConnectClient_get_multi_405;
                      return_value_ConnectClient_get_multi_405=ConnectClient_get_multi(srClientsTable[(signed long int)k]);
                      if((signed int)return_value_ConnectClient_get_multi_405 == 1)
                      {
                        n = 136;
                        signed int return_value_UsrCli_get_number_404;
                        return_value_UsrCli_get_number_404=UsrCli_get_number(srUsersClientsTable[(signed long int)l]);
                        buff[(signed long int)140] = (unsigned char)return_value_UsrCli_get_number_404;
                      }

                      i=find_usernum(srClientsTable[(signed long int)k], i);
                      buff[(signed long int)0] = (unsigned char)2;
                      buff[(signed long int)1] = (unsigned char)(i >> 8);
                      buff[(signed long int)2] = (unsigned char)i;
                      buff[(signed long int)3] = (unsigned char)(n >> 8);
                      buff[(signed long int)4] = (unsigned char)n;
                      char return_value_ServerRealm_get_realmType_406;
                      return_value_ServerRealm_get_realmType_406=ServerRealm_get_realmType(pointer);
                      struct anonymous_1 *return_value_ConnectClient_get_sslFd_407;
                      return_value_ConnectClient_get_sslFd_407=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                      SslFd_send_message(return_value_ServerRealm_get_realmType_406, return_value_ConnectClient_get_sslFd_407, buff, n + 5);
                      break;
                    }

                    i = i + 1;
                  }
                  while((_Bool)1);
                }
              }
            }

            else
            {
              close(sent);
              char *return_value_get_realmname_413;
              return_value_get_realmname_413=get_realmname(config, j);
              aflog((char)1, (char)64, "realm[%s]: Client(%d) is NOT CONNECTED", return_value_get_realmname_413, k);
            }
          }


        __CPROVER_DUMP_L244:
          ;
          l = l + 1;
        }
        while((_Bool)1);
      }

      char return_value_ServerRealm_get_basePortOn_453;
      return_value_ServerRealm_get_basePortOn_453=ServerRealm_get_basePortOn(pointer);
      if((signed int)return_value_ServerRealm_get_basePortOn_453 == 1)
      {
        k = 0;
        do
        {
          return_value_ServerRealm_get_clientsLimit_418=ServerRealm_get_clientsLimit(pointer);
          if(k >= return_value_ServerRealm_get_clientsLimit_418)
            break;

          char return_value_ConnectClient_get_state_452;
          return_value_ConnectClient_get_state_452=ConnectClient_get_state(srClientsTable[(signed long int)k]);
          if((signed int)return_value_ConnectClient_get_state_452 == 3)
          {
            signed int return_value_ConnectClient_get_listenFd_450;
            return_value_ConnectClient_get_listenFd_450=ConnectClient_get_listenFd(srClientsTable[(signed long int)k]);
            signed int return_value_ConnectClient_get_listenFd_451;
            return_value_ConnectClient_get_listenFd_451=ConnectClient_get_listenFd(srClientsTable[(signed long int)k]);
            if(!((rset.__fds_bits[(signed long int)(return_value_ConnectClient_get_listenFd_450 / 8)] & 1l << return_value_ConnectClient_get_listenFd_451 % 8) == 0l))
            {
              len=ServerRealm_get_addressLength(pointer);
              signed int return_value_ConnectClient_get_listenFd_419;
              return_value_ConnectClient_get_listenFd_419=ConnectClient_get_listenFd(srClientsTable[(signed long int)k]);
              struct sockaddr *return_value_ServerRealm_get_clientAddress_420;
              return_value_ServerRealm_get_clientAddress_420=ServerRealm_get_clientAddress(pointer);
              sent=accept(return_value_ConnectClient_get_listenFd_419, return_value_ServerRealm_get_clientAddress_420, &len);
              if(sent == -1)
              {
                signed int *return_value___errno_location_424;
                return_value___errno_location_424=__errno_location();
                if(*return_value___errno_location_424 == 11)
                {
                  char *return_value_get_realmname_421;
                  return_value_get_realmname_421=get_realmname(config, j);
                  aflog((char)1, (char)4, "realm[%s]: listenfd: FD_ISSET --> EAGAIN", return_value_get_realmname_421);
                }

                else
                {
                  char *return_value_get_realmname_422;
                  return_value_get_realmname_422=get_realmname(config, j);
                  signed int *return_value___errno_location_423;
                  return_value___errno_location_423=__errno_location();
                  aflog((char)1, (char)4, "realm[%s]: listenfd: FD_ISSET --> errno=%d", return_value_get_realmname_422, *return_value___errno_location_423);
                }
                goto __CPROVER_DUMP_L259;
              }

              flags=fcntl(sent, 3, 0);
              fcntl(sent, 4, flags | 04000);
              char *return_value_get_realmname_425;
              return_value_get_realmname_425=get_realmname(config, j);
              char *return_value_get_clientname_426;
              return_value_get_clientname_426=get_clientname(pointer, k);
              aflog((char)1, (char)4, "realm[%s]: Client[%s]: listenfd: FD_ISSET", return_value_get_realmname_425, return_value_get_clientname_426);
              signed int return_value_ServerRealm_get_connectedUsers_448;
              return_value_ServerRealm_get_connectedUsers_448=ServerRealm_get_connectedUsers(pointer);
              signed int return_value_ServerRealm_get_usersLimit_449;
              return_value_ServerRealm_get_usersLimit_449=ServerRealm_get_usersLimit(pointer);
              if(return_value_ServerRealm_get_connectedUsers_448 == return_value_ServerRealm_get_usersLimit_449)
              {
                close(sent);
                char *return_value_get_realmname_427;
                return_value_get_realmname_427=get_realmname(config, j);
                aflog((char)1, (char)32, "realm[%s]: user limit EXCEEDED", return_value_get_realmname_427);
              }

              else
              {
                return_value_ConnectClient_get_connected_446=ConnectClient_get_connected(srClientsTable[(signed long int)k]);
                return_value_ConnectClient_get_limit_447=ConnectClient_get_limit(srClientsTable[(signed long int)k]);
                if(return_value_ConnectClient_get_connected_446 == return_value_ConnectClient_get_limit_447)
                {
                  close(sent);
                  char *return_value_get_realmname_428;
                  return_value_get_realmname_428=get_realmname(config, j);
                  char *return_value_get_clientname_429;
                  return_value_get_clientname_429=get_clientname(pointer, k);
                  aflog((char)1, (char)32, "realm[%s]: Client[%s]: usrpcli limit EXCEEDED", return_value_get_realmname_428, return_value_get_clientname_429);
                }

                else
                {
                  i = 0;
                  do
                  {
                    return_value_ServerRealm_get_usersLimit_430=ServerRealm_get_usersLimit(pointer);
                    if(i >= return_value_ServerRealm_get_usersLimit_430)
                      break;

                    char return_value_ConnectUser_get_state_445;
                    return_value_ConnectUser_get_state_445=ConnectUser_get_state(srUsersTable[(signed long int)i]);
                    if((signed int)return_value_ConnectUser_get_state_445 == 0)
                    {
                      signed int return_value_ServerRealm_get_usersCounter_431;
                      return_value_ServerRealm_get_usersCounter_431=ServerRealm_get_usersCounter(pointer);
                      ConnectUser_set_userId(srUsersTable[(signed long int)i], return_value_ServerRealm_get_usersCounter_431);
                      ServerRealm_increase_usersCounter(pointer);
                      char *return_value_get_realmname_432;
                      return_value_get_realmname_432=get_realmname(config, j);
                      char *return_value_get_clientname_433;
                      return_value_get_clientname_433=get_clientname(pointer, k);
                      struct sockaddr *return_value_ServerRealm_get_clientAddress_434;
                      return_value_ServerRealm_get_clientAddress_434=ServerRealm_get_clientAddress(pointer);
                      char *return_value_ConnectUser_get_nameBuf_435;
                      return_value_ConnectUser_get_nameBuf_435=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                      char *return_value_ConnectUser_get_portBuf_436;
                      return_value_ConnectUser_get_portBuf_436=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                      char return_value_ServerRealm_get_dnsLookupsOn_437;
                      return_value_ServerRealm_get_dnsLookupsOn_437=ServerRealm_get_dnsLookupsOn(pointer);
                      char *return_value_sock_ntop_438;
                      return_value_sock_ntop_438=sock_ntop(return_value_ServerRealm_get_clientAddress_434, len, return_value_ConnectUser_get_nameBuf_435, return_value_ConnectUser_get_portBuf_436, return_value_ServerRealm_get_dnsLookupsOn_437);
                      aflog((char)1, (char)8, "realm[%s]: Client[%s]: new user: CONNECTING from IP: %s", return_value_get_realmname_432, return_value_get_clientname_433, return_value_sock_ntop_438);
                      ConnectUser_set_connFd(srUsersTable[(signed long int)i], sent);
                      ConnectUser_set_state(srUsersTable[(signed long int)i], (char)6);
                      ConnectUser_set_whatClient(srUsersTable[(signed long int)i], k);
                      time(&now);
                      ConnectUser_set_connectTime(srUsersTable[(signed long int)i], now);
                      struct anonymous_6 *return_value_ConnectUser_get_stats_439;
                      return_value_ConnectUser_get_stats_439=ConnectUser_get_stats(srUsersTable[(signed long int)i]);
                      UserStats_clear(return_value_ConnectUser_get_stats_439);
                      struct anonymous_6 *return_value_ConnectUser_get_stats_440;
                      return_value_ConnectUser_get_stats_440=ConnectUser_get_stats(srUsersTable[(signed long int)i]);
                      UserStats_set_lastActivity(return_value_ConnectUser_get_stats_440, now);
                      ServerRealm_increase_connectedUsers(pointer);
                      ConnectClient_increase_connected(srClientsTable[(signed long int)k]);
                      char *return_value_ConnectUser_get_nameBuf_441;
                      return_value_ConnectUser_get_nameBuf_441=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                      memcpy((void *)&buff[(signed long int)5], (const void *)return_value_ConnectUser_get_nameBuf_441, (unsigned long int)128);
                      char *return_value_ConnectUser_get_portBuf_442;
                      return_value_ConnectUser_get_portBuf_442=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                      memcpy((void *)&buff[(signed long int)133], (const void *)return_value_ConnectUser_get_portBuf_442, (unsigned long int)7);
                      n = 135;
                      i=find_usernum(srClientsTable[(signed long int)k], i);
                      buff[(signed long int)0] = (unsigned char)2;
                      buff[(signed long int)1] = (unsigned char)(i >> 8);
                      buff[(signed long int)2] = (unsigned char)i;
                      buff[(signed long int)3] = (unsigned char)(n >> 8);
                      buff[(signed long int)4] = (unsigned char)n;
                      char return_value_ServerRealm_get_realmType_443;
                      return_value_ServerRealm_get_realmType_443=ServerRealm_get_realmType(pointer);
                      struct anonymous_1 *return_value_ConnectClient_get_sslFd_444;
                      return_value_ConnectClient_get_sslFd_444=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                      SslFd_send_message(return_value_ServerRealm_get_realmType_443, return_value_ConnectClient_get_sslFd_444, buff, n + 5);
                      break;
                    }

                    i = i + 1;
                  }
                  while((_Bool)1);
                }
              }
            }

          }


        __CPROVER_DUMP_L259:
          ;
          k = k + 1;
        }
        while((_Bool)1);
      }

      k = 0;
      do
      {
        return_value_ServerRealm_get_clientsLimit_454=ServerRealm_get_clientsLimit(pointer);
        if(k >= return_value_ServerRealm_get_clientsLimit_454)
          break;

        return_value_ConnectClient_get_state_794=ConnectClient_get_state(srClientsTable[(signed long int)k]);
        if((signed int)return_value_ConnectClient_get_state_794 >= 1)
        {
          return_value_ConnectClient_get_sslFd_790=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
          return_value_SslFd_get_fd_791=SslFd_get_fd(return_value_ConnectClient_get_sslFd_790);
          return_value_ConnectClient_get_sslFd_792=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
          return_value_SslFd_get_fd_793=SslFd_get_fd(return_value_ConnectClient_get_sslFd_792);
          if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd_791 / 8)] & 1l << return_value_SslFd_get_fd_793 % 8) == 0l))
          {
            char return_value_ConnectClient_get_state_472;
            return_value_ConnectClient_get_state_472=ConnectClient_get_state(srClientsTable[(signed long int)k]);
            if((signed int)return_value_ConnectClient_get_state_472 == 1)
            {
              struct anonymous_1 *return_value_ConnectClient_get_sslFd_455;
              return_value_ConnectClient_get_sslFd_455=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
              make_ssl_initialize(return_value_ConnectClient_get_sslFd_455);
              char *return_value_get_realmname_456;
              return_value_get_realmname_456=get_realmname(config, j);
              char *return_value_get_clientname_457;
              return_value_get_clientname_457=get_clientname(pointer, k);
              aflog((char)2, (char)4, "realm[%s]: new Client[%s]: SSL_accept", return_value_get_realmname_456, return_value_get_clientname_457);
              struct anonymous_1 *return_value_ConnectClient_get_sslFd_458;
              return_value_ConnectClient_get_sslFd_458=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
              signed int return_value_make_ssl_accept_459;
              return_value_make_ssl_accept_459=make_ssl_accept(return_value_ConnectClient_get_sslFd_458);
              switch(return_value_make_ssl_accept_459)
              {
                case 2:
                {
                  struct anonymous_1 *return_value_ConnectClient_get_sslFd_460;
                  return_value_ConnectClient_get_sslFd_460=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                  signed int return_value_SslFd_get_fd_461;
                  return_value_SslFd_get_fd_461=SslFd_get_fd(return_value_ConnectClient_get_sslFd_460);
                  close(return_value_SslFd_get_fd_461);
                  struct anonymous_1 *return_value_ConnectClient_get_sslFd_462;
                  return_value_ConnectClient_get_sslFd_462=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                  signed int return_value_SslFd_get_fd_463;
                  return_value_SslFd_get_fd_463=SslFd_get_fd(return_value_ConnectClient_get_sslFd_462);
                  struct anonymous_1 *return_value_ConnectClient_get_sslFd_464;
                  return_value_ConnectClient_get_sslFd_464=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                  signed int return_value_SslFd_get_fd_465;
                  return_value_SslFd_get_fd_465=SslFd_get_fd(return_value_ConnectClient_get_sslFd_464);
                  (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd_463 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd_463 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_SslFd_get_fd_465 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  struct anonymous_1 *return_value_ConnectClient_get_sslFd_466;
                  return_value_ConnectClient_get_sslFd_466=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                  struct ssl_st *return_value_SSL_new_467;
                  return_value_SSL_new_467=SSL_new(ctx);
                  SslFd_set_ssl(return_value_ConnectClient_get_sslFd_466, return_value_SSL_new_467);
                  ConnectClient_set_state(srClientsTable[(signed long int)k], (char)0);
                  task=ConnectClient_get_task(srClientsTable[(signed long int)k]);
                  if(!(task == ((struct anonymous_13 *)NULL)))
                  {
                    TaskScheduler_removeTask(scheduler, task);
                    ConnectClient_set_task(srClientsTable[(signed long int)k], (struct anonymous_13 *)(void *)0);
                  }

                  ServerRealm_decrease_connectedClients(pointer);
                  char *return_value_get_realmname_468;
                  return_value_get_realmname_468=get_realmname(config, j);
                  char *return_value_get_clientname_469;
                  return_value_get_clientname_469=get_clientname(pointer, k);
                  aflog((char)2, (char)64, "realm[%s]: new Client[%s]: DENIED by SSL_accept", return_value_get_realmname_468, return_value_get_clientname_469);
                }
                case 1:
                  goto __CPROVER_DUMP_L389;
                default:
                {
                  return_value_get_realmname_470=get_realmname(config, j);
                  return_value_get_clientname_471=get_clientname(pointer, k);
                  aflog((char)2, (char)2, "realm[%s]: new Client[%s]: ACCEPTED by SSL_accept", return_value_get_realmname_470, return_value_get_clientname_471);
                  ConnectClient_set_state(srClientsTable[(signed long int)k], (char)2);
                  goto __CPROVER_DUMP_L389;
                }
              }
            }

            char *return_value_get_realmname_473;
            return_value_get_realmname_473=get_realmname(config, j);
            char *return_value_get_clientname_474;
            return_value_get_clientname_474=get_clientname(pointer, k);
            aflog((char)2, (char)4, "realm[%s]: Client[%s]: commfd: FD_ISSET", return_value_get_realmname_473, return_value_get_clientname_474);
            char return_value_ConnectClient_get_state_483;
            return_value_ConnectClient_get_state_483=ConnectClient_get_state(srClientsTable[(signed long int)k]);
            if((signed int)return_value_ConnectClient_get_state_483 == 2)
            {
              char return_value_ServerRealm_get_realmType_475;
              return_value_ServerRealm_get_realmType_475=ServerRealm_get_realmType(pointer);
              struct anonymous_1 *return_value_ConnectClient_get_sslFd_476;
              return_value_ConnectClient_get_sslFd_476=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
              struct anonymous_8 *return_value_ConnectClient_get_header_477;
              return_value_ConnectClient_get_header_477=ConnectClient_get_header(srClientsTable[(signed long int)k]);
              signed int return_value_HeaderBuffer_to_read_478;
              return_value_HeaderBuffer_to_read_478=HeaderBuffer_to_read(return_value_ConnectClient_get_header_477);
              n=SslFd_get_message((char)((signed int)return_value_ServerRealm_get_realmType_475 | 4 | 8), return_value_ConnectClient_get_sslFd_476, buff, -1 * return_value_HeaderBuffer_to_read_478);
            }

            else
            {
              char return_value_ServerRealm_get_realmType_479;
              return_value_ServerRealm_get_realmType_479=ServerRealm_get_realmType(pointer);
              struct anonymous_1 *return_value_ConnectClient_get_sslFd_480;
              return_value_ConnectClient_get_sslFd_480=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
              struct anonymous_8 *return_value_ConnectClient_get_header_481;
              return_value_ConnectClient_get_header_481=ConnectClient_get_header(srClientsTable[(signed long int)k]);
              signed int return_value_HeaderBuffer_to_read_482;
              return_value_HeaderBuffer_to_read_482=HeaderBuffer_to_read(return_value_ConnectClient_get_header_481);
              n=SslFd_get_message(return_value_ServerRealm_get_realmType_479, return_value_ConnectClient_get_sslFd_480, buff, -1 * return_value_HeaderBuffer_to_read_482);
            }
            if(n == -1)
            {
              signed int *return_value___errno_location_489;
              return_value___errno_location_489=__errno_location();
              if(*return_value___errno_location_489 == 11)
              {
                char *return_value_get_realmname_484;
                return_value_get_realmname_484=get_realmname(config, j);
                char *return_value_get_clientname_485;
                return_value_get_clientname_485=get_clientname(pointer, k);
                aflog((char)2, (char)4, "realm[%s]: Client[%s]: commfd: EAGAIN", return_value_get_realmname_484, return_value_get_clientname_485);
                goto __CPROVER_DUMP_L389;
              }

              else
              {
                char *return_value_get_realmname_486;
                return_value_get_realmname_486=get_realmname(config, j);
                char *return_value_get_clientname_487;
                return_value_get_clientname_487=get_clientname(pointer, k);
                signed int *return_value___errno_location_488;
                return_value___errno_location_488=__errno_location();
                aflog((char)2, (char)64, "realm[%s]: Client[%s]: commfd: ERROR: %d", return_value_get_realmname_486, return_value_get_clientname_487, *return_value___errno_location_488);
                n = 0;
              }
            }

            else
              if(!(n == 5))
              {
                if(!(n == 0))
                {
                  char *return_value_get_realmname_490;
                  return_value_get_realmname_490=get_realmname(config, j);
                  char *return_value_get_clientname_491;
                  return_value_get_clientname_491=get_clientname(pointer, k);
                  aflog((char)2, (char)2, "realm[%s]: Client[%s]: header length = %d --> buffering", return_value_get_realmname_490, return_value_get_clientname_491, n);
                  struct anonymous_8 *return_value_ConnectClient_get_header_492;
                  return_value_ConnectClient_get_header_492=ConnectClient_get_header(srClientsTable[(signed long int)k]);
                  HeaderBuffer_store(return_value_ConnectClient_get_header_492, buff, n);
                  struct anonymous_8 *return_value_ConnectClient_get_header_494;
                  return_value_ConnectClient_get_header_494=ConnectClient_get_header(srClientsTable[(signed long int)k]);
                  signed int return_value_HeaderBuffer_to_read_495;
                  return_value_HeaderBuffer_to_read_495=HeaderBuffer_to_read(return_value_ConnectClient_get_header_494);
                  if(return_value_HeaderBuffer_to_read_495 == 0)
                  {
                    struct anonymous_8 *return_value_ConnectClient_get_header_493;
                    return_value_ConnectClient_get_header_493=ConnectClient_get_header(srClientsTable[(signed long int)k]);
                    HeaderBuffer_restore(return_value_ConnectClient_get_header_493, buff);
                    n = 5;
                  }

                  else
                    goto __CPROVER_DUMP_L389;
                }

              }

            if(n == 0)
            {
              char *return_value_get_realmname_496;
              return_value_get_realmname_496=get_realmname(config, j);
              char *return_value_get_clientname_497;
              return_value_get_clientname_497=get_clientname(pointer, k);
              aflog((char)2, (char)8, "realm[%s]: Client[%s]: commfd: CLOSED", return_value_get_realmname_496, return_value_get_clientname_497);
              time(&now);
              char *return_value_get_realmname_498;
              return_value_get_realmname_498=get_realmname(config, j);
              char *return_value_get_clientname_499;
              return_value_get_clientname_499=get_clientname(pointer, k);
              char *return_value_ConnectClient_get_nameBuf_500;
              return_value_ConnectClient_get_nameBuf_500=ConnectClient_get_nameBuf(srClientsTable[(signed long int)k]);
              char *return_value_ConnectClient_get_portBuf_501;
              return_value_ConnectClient_get_portBuf_501=ConnectClient_get_portBuf(srClientsTable[(signed long int)k]);
              signed long int return_value_ConnectClient_get_connectTime_502;
              return_value_ConnectClient_get_connectTime_502=ConnectClient_get_connectTime(srClientsTable[(signed long int)k]);
              char *return_value_timeperiod_503;
              return_value_timeperiod_503=timeperiod(now - return_value_ConnectClient_get_connectTime_502);
              aflog((char)2, (char)16, "REALM: %s CLIENT: %s IP: %s PORT: %s DURATION: %s", return_value_get_realmname_498, return_value_get_clientname_499, return_value_ConnectClient_get_nameBuf_500, return_value_ConnectClient_get_portBuf_501, return_value_timeperiod_503);
              char return_value_ServerRealm_get_auditOn_524;
              return_value_ServerRealm_get_auditOn_524=ServerRealm_get_auditOn(pointer);
              if(!(return_value_ServerRealm_get_auditOn_524 == 0))
                do
                {
                  return_value_ConnectClient_get_auditList_504=ConnectClient_get_auditList(srClientsTable[(signed long int)k]);
                  return_value_AuditList_get_first_505=AuditList_get_first(return_value_ConnectClient_get_auditList_504);
                  if(return_value_AuditList_get_first_505 == ((struct alnode *)NULL))
                    break;

                  struct auditlist *return_value_ConnectClient_get_auditList_506;
                  return_value_ConnectClient_get_auditList_506=ConnectClient_get_auditList(srClientsTable[(signed long int)k]);
                  struct alnode *return_value_AuditList_get_first_507;
                  return_value_AuditList_get_first_507=AuditList_get_first(return_value_ConnectClient_get_auditList_506);
                  signed int return_value_AuditListNode_get_userId_508;
                  return_value_AuditListNode_get_userId_508=AuditListNode_get_userId(return_value_AuditList_get_first_507);
                  struct auditlist *return_value_ConnectClient_get_auditList_509;
                  return_value_ConnectClient_get_auditList_509=ConnectClient_get_auditList(srClientsTable[(signed long int)k]);
                  struct alnode *return_value_AuditList_get_first_510;
                  return_value_AuditList_get_first_510=AuditList_get_first(return_value_ConnectClient_get_auditList_509);
                  char *return_value_AuditListNode_get_nameBuf_511;
                  return_value_AuditListNode_get_nameBuf_511=AuditListNode_get_nameBuf(return_value_AuditList_get_first_510);
                  struct auditlist *return_value_ConnectClient_get_auditList_512;
                  return_value_ConnectClient_get_auditList_512=ConnectClient_get_auditList(srClientsTable[(signed long int)k]);
                  struct alnode *return_value_AuditList_get_first_513;
                  return_value_AuditList_get_first_513=AuditList_get_first(return_value_ConnectClient_get_auditList_512);
                  char *return_value_AuditListNode_get_portBuf_514;
                  return_value_AuditListNode_get_portBuf_514=AuditListNode_get_portBuf(return_value_AuditList_get_first_513);
                  struct auditlist *return_value_ConnectClient_get_auditList_515;
                  return_value_ConnectClient_get_auditList_515=ConnectClient_get_auditList(srClientsTable[(signed long int)k]);
                  struct alnode *return_value_AuditList_get_first_516;
                  return_value_AuditList_get_first_516=AuditList_get_first(return_value_ConnectClient_get_auditList_515);
                  signed long int *return_value_AuditListNode_get_connectTimep_517;
                  return_value_AuditListNode_get_connectTimep_517=AuditListNode_get_connectTimep(return_value_AuditList_get_first_516);
                  char *return_value_localdate_518;
                  return_value_localdate_518=localdate(return_value_AuditListNode_get_connectTimep_517);
                  struct auditlist *return_value_ConnectClient_get_auditList_519;
                  return_value_ConnectClient_get_auditList_519=ConnectClient_get_auditList(srClientsTable[(signed long int)k]);
                  struct alnode *return_value_AuditList_get_first_520;
                  return_value_AuditList_get_first_520=AuditList_get_first(return_value_ConnectClient_get_auditList_519);
                  signed long int return_value_AuditListNode_get_duration_521;
                  return_value_AuditListNode_get_duration_521=AuditListNode_get_duration(return_value_AuditList_get_first_520);
                  char *return_value_timeperiod_522;
                  return_value_timeperiod_522=timeperiod(return_value_AuditListNode_get_duration_521);
                  aflog((char)2, (char)16, "USERID: %d IP: %s PORT: %s CONNECTED: %s DURATION: %s", return_value_AuditListNode_get_userId_508, return_value_AuditListNode_get_nameBuf_511, return_value_AuditListNode_get_portBuf_514, return_value_localdate_518, return_value_timeperiod_522);
                  struct auditlist *return_value_ConnectClient_get_auditList_523;
                  return_value_ConnectClient_get_auditList_523=ConnectClient_get_auditList(srClientsTable[(signed long int)k]);
                  AuditList_delete_first(return_value_ConnectClient_get_auditList_523);
                }
                while((_Bool)1);

              remove_client(pointer, k, &allset, &wset, scheduler);
              goto __CPROVER_DUMP_L389;
            }

            numofcon = (signed int)buff[(signed long int)1];
            numofcon = numofcon << 8;
            numofcon = numofcon + (signed int)buff[(signed long int)2];
            length = (signed int)buff[(signed long int)3];
            length = length << 8;
            length = length + (signed int)buff[(signed long int)4];
            signed int return_value_ServerRealm_get_clientsLimit_525;
            return_value_ServerRealm_get_clientsLimit_525=ServerRealm_get_clientsLimit(pointer);
            if(k == return_value_ServerRealm_get_clientsLimit_525)
            {
              if(!((signed int)buff[0l] == 8))
              {
                if(!((signed int)buff[0l] == 14))
                {
                  if(!((signed int)buff[0l] == 15))
                    buff[(signed long int)0] = (unsigned char)13;

                }

              }

            }

            char return_value_ConnectClient_get_state_528;
            return_value_ConnectClient_get_state_528=ConnectClient_get_state(srClientsTable[(signed long int)k]);
            if(!((signed int)return_value_ConnectClient_get_state_528 >= 2))
            {
              char *return_value_get_realmname_526;
              return_value_get_realmname_526=get_realmname(config, j);
              char *return_value_get_clientname_527;
              return_value_get_clientname_527=get_clientname(pointer, k);
              aflog((char)2, (char)32, "realm[%s]: Client[%s]: Impossible behaviour --> ignoring", return_value_get_realmname_526, return_value_get_clientname_527);
              goto __CPROVER_DUMP_L389;
            }

            char return_value_ConnectClient_get_state_529;
            return_value_ConnectClient_get_state_529=ConnectClient_get_state(srClientsTable[(signed long int)k]);
            if((signed int)return_value_ConnectClient_get_state_529 == 2)
            {
              if(!((signed int)buff[0l] == 8))
              {
                if(!((signed int)buff[0l] == 14))
                  buff[(signed long int)0] = (unsigned char)13;

              }

            }

            time(&now);
            ConnectClient_set_lastActivity(srClientsTable[(signed long int)k], now);
            signed int return_value_ServerRealm_get_maxIdle_532;
            return_value_ServerRealm_get_maxIdle_532=ServerRealm_get_maxIdle(pointer);
            if(!(return_value_ServerRealm_get_maxIdle_532 == 0))
            {
              signed int return_value_ServerRealm_get_maxIdle_530;
              return_value_ServerRealm_get_maxIdle_530=ServerRealm_get_maxIdle(pointer);
              struct timeval return_value_timeval_create_531;
              return_value_timeval_create_531=timeval_create((signed long int)return_value_ServerRealm_get_maxIdle_530, (signed long int)0);
              ConnectClient_set_timer(srClientsTable[(signed long int)k], return_value_timeval_create_531);
              TaskScheduler_update(scheduler);
            }

            switch((signed int)buff[(signed long int)0])
            {
              case 1:
              {
                n = numofcon;
                numofcon=eval_numofcon(pointer, k, numofcon);
                if(numofcon >= 0)
                {
                  return_value_ServerRealm_get_usersLimit_557=ServerRealm_get_usersLimit(pointer);
                  tmp_if_expr_558 = numofcon < return_value_ServerRealm_get_usersLimit_557 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_558 = (_Bool)0;
                if(tmp_if_expr_558)
                {
                  return_value_ConnectClient_get_state_559=ConnectClient_get_state(srClientsTable[(signed long int)k]);
                  tmp_if_expr_560 = (signed int)return_value_ConnectClient_get_state_559 == 3 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_560 = (_Bool)0;
                if(tmp_if_expr_560)
                {
                  char return_value_ConnectUser_get_state_556;
                  return_value_ConnectUser_get_state_556=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                  if((signed int)return_value_ConnectUser_get_state_556 == 11)
                  {
                    ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)19);
                    char *return_value_get_realmname_533;
                    return_value_get_realmname_533=get_realmname(config, j);
                    signed int return_value_get_username_534;
                    return_value_get_username_534=get_username(pointer, numofcon);
                    aflog((char)1, (char)8, "realm[%s]: user[%d]: KICKING...", return_value_get_realmname_533, return_value_get_username_534);
                  }

                  else
                  {
                    ServerRealm_decrease_connectedUsers(pointer);
                    ConnectClient_decrease_connected(srClientsTable[(signed long int)k]);
                    signed int *return_value_ConnectClient_get_users_535;
                    return_value_ConnectClient_get_users_535=ConnectClient_get_users(srClientsTable[(signed long int)k]);
                    return_value_ConnectClient_get_users_535[(signed long int)n] = -1;
                    char return_value_ConnectUser_get_state_555;
                    return_value_ConnectUser_get_state_555=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                    if((signed int)return_value_ConnectUser_get_state_555 == 5)
                    {
                      ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)0);
                      char *return_value_get_realmname_536;
                      return_value_get_realmname_536=get_realmname(config, j);
                      signed int return_value_get_username_537;
                      return_value_get_username_537=get_username(pointer, numofcon);
                      aflog((char)1, (char)2, "realm[%s]: user[%d]: CLOSE CONFIRMED", return_value_get_realmname_536, return_value_get_username_537);
                    }

                    else
                    {
                      return_value_ConnectUser_get_state_554=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                      if((signed int)return_value_ConnectUser_get_state_554 == 7)
                      {
                        char *return_value_get_realmname_538;
                        return_value_get_realmname_538=get_realmname(config, j);
                        signed int return_value_get_username_539;
                        return_value_get_username_539=get_username(pointer, numofcon);
                        aflog((char)1, (char)8, "realm[%s]: user[%d]: KICKED", return_value_get_realmname_538, return_value_get_username_539);
                        time(&now);
                        char *return_value_get_realmname_540;
                        return_value_get_realmname_540=get_realmname(config, j);
                        signed int return_value_get_username_541;
                        return_value_get_username_541=get_username(pointer, numofcon);
                        char *return_value_ConnectUser_get_nameBuf_542;
                        return_value_ConnectUser_get_nameBuf_542=ConnectUser_get_nameBuf(srUsersTable[(signed long int)numofcon]);
                        char *return_value_ConnectUser_get_portBuf_543;
                        return_value_ConnectUser_get_portBuf_543=ConnectUser_get_portBuf(srUsersTable[(signed long int)numofcon]);
                        signed long int return_value_ConnectUser_get_connectTime_544;
                        return_value_ConnectUser_get_connectTime_544=ConnectUser_get_connectTime(srUsersTable[(signed long int)numofcon]);
                        char *return_value_timeperiod_545;
                        return_value_timeperiod_545=timeperiod(now - return_value_ConnectUser_get_connectTime_544);
                        aflog((char)1, (char)16, "REALM: %s USER: %d IP: %s PORT: %s DURATION: %s", return_value_get_realmname_540, return_value_get_username_541, return_value_ConnectUser_get_nameBuf_542, return_value_ConnectUser_get_portBuf_543, return_value_timeperiod_545);
                        signed int return_value_ConnectUser_get_connFd_546;
                        return_value_ConnectUser_get_connFd_546=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        close(return_value_ConnectUser_get_connFd_546);
                        signed int return_value_ConnectUser_get_connFd_547;
                        return_value_ConnectUser_get_connFd_547=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        signed int return_value_ConnectUser_get_connFd_548;
                        return_value_ConnectUser_get_connFd_548=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_547 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_547 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_548 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                        signed int return_value_ConnectUser_get_connFd_549;
                        return_value_ConnectUser_get_connFd_549=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        signed int return_value_ConnectUser_get_connFd_550;
                        return_value_ConnectUser_get_connFd_550=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_549 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_549 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_550 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                        ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)0);
                        struct buflist *return_value_ConnectUser_get_bufList_551;
                        return_value_ConnectUser_get_bufList_551=ConnectUser_get_bufList(srUsersTable[(signed long int)numofcon]);
                        BufList_clear(return_value_ConnectUser_get_bufList_551);
                        buff[(signed long int)0] = (unsigned char)1;
                        buff[(signed long int)1] = (unsigned char)(n >> 8);
                        buff[(signed long int)2] = (unsigned char)n;
                        char return_value_ServerRealm_get_realmType_552;
                        return_value_ServerRealm_get_realmType_552=ServerRealm_get_realmType(pointer);
                        struct anonymous_1 *return_value_ConnectClient_get_sslFd_553;
                        return_value_ConnectClient_get_sslFd_553=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                        SslFd_send_message(return_value_ServerRealm_get_realmType_552, return_value_ConnectClient_get_sslFd_553, buff, 5);
                      }

                    }
                  }
                }

                else
                  remove_client(pointer, k, &allset, &wset, scheduler);
                break;
              }
              case 2:
              {
                n = numofcon;
                numofcon=eval_numofcon(pointer, k, numofcon);
                if(numofcon >= 0)
                {
                  return_value_ServerRealm_get_usersLimit_574=ServerRealm_get_usersLimit(pointer);
                  tmp_if_expr_575 = numofcon < return_value_ServerRealm_get_usersLimit_574 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_575 = (_Bool)0;
                if(tmp_if_expr_575)
                {
                  return_value_ConnectClient_get_state_576=ConnectClient_get_state(srClientsTable[(signed long int)k]);
                  tmp_if_expr_577 = (signed int)return_value_ConnectClient_get_state_576 == 3 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_577 = (_Bool)0;
                if(tmp_if_expr_577)
                {
                  char return_value_ConnectUser_get_state_568;
                  return_value_ConnectUser_get_state_568=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                  if((signed int)return_value_ConnectUser_get_state_568 == 6)
                  {
                    char *return_value_get_realmname_561;
                    return_value_get_realmname_561=get_realmname(config, j);
                    signed int return_value_get_username_562;
                    return_value_get_username_562=get_username(pointer, numofcon);
                    aflog((char)1, (char)8, "realm[%s]: user[%d]: NEW", return_value_get_realmname_561, return_value_get_username_562);
                    signed int return_value_ConnectUser_get_connFd_563;
                    return_value_ConnectUser_get_connFd_563=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                    signed int return_value_ConnectUser_get_connFd_564;
                    return_value_ConnectUser_get_connFd_564=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                    (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_563 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_563 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd_564 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                    signed int return_value_ConnectUser_get_connFd_565;
                    return_value_ConnectUser_get_connFd_565=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                    if(!(1 + return_value_ConnectUser_get_connFd_565 >= maxfdp1))
                      tmp_if_expr_567 = maxfdp1;

                    else
                    {
                      return_value_ConnectUser_get_connFd_566=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                      tmp_if_expr_567 = return_value_ConnectUser_get_connFd_566 + 1;
                    }
                    maxfdp1 = tmp_if_expr_567;
                    ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)7);
                  }

                  char return_value_ConnectUser_get_state_573;
                  return_value_ConnectUser_get_state_573=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                  if((signed int)return_value_ConnectUser_get_state_573 == 17)
                  {
                    char *return_value_get_realmname_569;
                    return_value_get_realmname_569=get_realmname(config, j);
                    signed int return_value_get_username_570;
                    return_value_get_username_570=get_username(pointer, numofcon);
                    aflog((char)1, (char)8, "realm[%s]: user[%d]: delayed CLOSING", return_value_get_realmname_569, return_value_get_username_570);
                    ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)5);
                    buff[(signed long int)0] = (unsigned char)1;
                    buff[(signed long int)1] = (unsigned char)(n >> 8);
                    buff[(signed long int)2] = (unsigned char)n;
                    char return_value_ServerRealm_get_realmType_571;
                    return_value_ServerRealm_get_realmType_571=ServerRealm_get_realmType(pointer);
                    struct anonymous_1 *return_value_ConnectClient_get_sslFd_572;
                    return_value_ConnectClient_get_sslFd_572=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                    SslFd_send_message(return_value_ServerRealm_get_realmType_571, return_value_ConnectClient_get_sslFd_572, buff, 5);
                  }

                }

                else
                  remove_client(pointer, k, &allset, &wset, scheduler);
                break;
              }
              case 12:
              {
                n = numofcon;
                numofcon=eval_numofcon(pointer, k, numofcon);
                if(numofcon >= 0)
                {
                  return_value_ServerRealm_get_usersLimit_586=ServerRealm_get_usersLimit(pointer);
                  tmp_if_expr_587 = numofcon < return_value_ServerRealm_get_usersLimit_586 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_587 = (_Bool)0;
                if(tmp_if_expr_587)
                {
                  return_value_ConnectClient_get_state_588=ConnectClient_get_state(srClientsTable[(signed long int)k]);
                  tmp_if_expr_589 = (signed int)return_value_ConnectClient_get_state_588 == 3 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_589 = (_Bool)0;
                if(tmp_if_expr_589)
                {
                  char return_value_ConnectUser_get_state_583;
                  return_value_ConnectUser_get_state_583=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                  if((signed int)return_value_ConnectUser_get_state_583 == 6)
                    tmp_if_expr_585 = (_Bool)1;

                  else
                  {
                    return_value_ConnectUser_get_state_584=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                    tmp_if_expr_585 = (signed int)return_value_ConnectUser_get_state_584 == 17 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_585)
                  {
                    char *return_value_get_realmname_578;
                    return_value_get_realmname_578=get_realmname(config, j);
                    signed int return_value_get_username_579;
                    return_value_get_username_579=get_username(pointer, numofcon);
                    aflog((char)1, (char)8, "realm[%s]: user[%d]: DROPPED", return_value_get_realmname_578, return_value_get_username_579);
                    ServerRealm_decrease_connectedUsers(pointer);
                    ConnectClient_decrease_connected(srClientsTable[(signed long int)k]);
                    signed int *return_value_ConnectClient_get_users_580;
                    return_value_ConnectClient_get_users_580=ConnectClient_get_users(srClientsTable[(signed long int)k]);
                    return_value_ConnectClient_get_users_580[(signed long int)n] = -1;
                    char return_value_ConnectUser_get_state_582;
                    return_value_ConnectUser_get_state_582=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                    if((signed int)return_value_ConnectUser_get_state_582 == 6)
                    {
                      signed int return_value_ConnectUser_get_connFd_581;
                      return_value_ConnectUser_get_connFd_581=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                      close(return_value_ConnectUser_get_connFd_581);
                    }

                    ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)0);
                  }

                }

                else
                  remove_client(pointer, k, &allset, &wset, scheduler);
                break;
              }
              case 3:
              {
                return_value_ConnectClient_get_state_590=ConnectClient_get_state(srClientsTable[(signed long int)k]);
                if(!((signed int)return_value_ConnectClient_get_state_590 == 3))
                {
                  remove_client(pointer, k, &allset, &wset, scheduler);
                  break;
                }

                return_value_ServerRealm_get_realmType_595=ServerRealm_get_realmType(pointer);
                if(!((1 & (signed int)return_value_ServerRealm_get_realmType_595) == 0))
                {
                  return_value_ServerRealm_get_realmType_596=ServerRealm_get_realmType(pointer);
                  tmp_if_expr_597 = ((signed int)return_value_ServerRealm_get_realmType_596 & 2) != 0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_597 = (_Bool)0;
                if(tmp_if_expr_597)
                {
                  char return_value_ServerRealm_get_realmType_591;
                  return_value_ServerRealm_get_realmType_591=ServerRealm_get_realmType(pointer);
                  struct anonymous_1 *return_value_ConnectClient_get_sslFd_592;
                  return_value_ConnectClient_get_sslFd_592=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                  n=SslFd_get_message(return_value_ServerRealm_get_realmType_591, return_value_ConnectClient_get_sslFd_592, &buff[(signed long int)5], length);
                }

                else
                {
                  char return_value_ServerRealm_get_realmType_593;
                  return_value_ServerRealm_get_realmType_593=ServerRealm_get_realmType(pointer);
                  struct anonymous_1 *return_value_ConnectClient_get_sslFd_594;
                  return_value_ConnectClient_get_sslFd_594=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                  n=SslFd_get_message(return_value_ServerRealm_get_realmType_593, return_value_ConnectClient_get_sslFd_594, buff, length);
                }
                temp = numofcon;
                numofcon=eval_numofcon(pointer, k, numofcon);
                if(numofcon >= 0)
                {
                  return_value_ServerRealm_get_usersLimit_675=ServerRealm_get_usersLimit(pointer);
                  tmp_if_expr_676 = numofcon < return_value_ServerRealm_get_usersLimit_675 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_676 = (_Bool)0;
                if(tmp_if_expr_676)
                {
                  char return_value_ConnectUser_get_state_673;
                  return_value_ConnectUser_get_state_673=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                  if((signed int)return_value_ConnectUser_get_state_673 == 7)
                  {
                    char *return_value_get_realmname_598;
                    return_value_get_realmname_598=get_realmname(config, j);
                    signed int return_value_get_username_599;
                    return_value_get_username_599=get_username(pointer, numofcon);
                    aflog((char)1, (char)2, "realm[%s]: TO user[%d]: MESSAGE length=%d", return_value_get_realmname_598, return_value_get_username_599, n);
                    struct anonymous_6 *return_value_ConnectUser_get_stats_600;
                    return_value_ConnectUser_get_stats_600=ConnectUser_get_stats(srUsersTable[(signed long int)numofcon]);
                    UserStats_add_download(return_value_ConnectUser_get_stats_600, n);
                    char return_value_ServerRealm_get_realmType_655;
                    return_value_ServerRealm_get_realmType_655=ServerRealm_get_realmType(pointer);
                    if(!((1 & (signed int)return_value_ServerRealm_get_realmType_655) == 0))
                    {
                      return_value_ServerRealm_get_realmType_656=ServerRealm_get_realmType(pointer);
                      tmp_if_expr_657 = ((signed int)return_value_ServerRealm_get_realmType_656 & 2) != 0 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_657 = (_Bool)0;
                    if(tmp_if_expr_657)
                    {
                      buff[(signed long int)1] = (unsigned char)8;
                      buff[(signed long int)2] = (unsigned char)3;
                      buff[(signed long int)3] = (unsigned char)(n >> 8);
                      buff[(signed long int)4] = (unsigned char)n;
                      signed int return_value_ConnectUser_get_connFd_601;
                      return_value_ConnectUser_get_connFd_601=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                      signed long int return_value_write_602;
                      return_value_write_602=write(return_value_ConnectUser_get_connFd_601, (const void *)buff, (unsigned long int)(n + 5));
                      sent = (signed int)return_value_write_602;
                      if(sent == -1)
                      {
                        char *return_value_get_realmname_603;
                        return_value_get_realmname_603=get_realmname(config, j);
                        signed int return_value_get_username_604;
                        return_value_get_username_604=get_username(pointer, numofcon);
                        aflog((char)1, (char)8, "realm[%s]: user[%d]: CLOSED (write-udp)", return_value_get_realmname_603, return_value_get_username_604);
                        time(&now);
                        char *return_value_get_realmname_605;
                        return_value_get_realmname_605=get_realmname(config, j);
                        signed int return_value_get_username_606;
                        return_value_get_username_606=get_username(pointer, numofcon);
                        char *return_value_ConnectUser_get_nameBuf_607;
                        return_value_ConnectUser_get_nameBuf_607=ConnectUser_get_nameBuf(srUsersTable[(signed long int)numofcon]);
                        char *return_value_ConnectUser_get_portBuf_608;
                        return_value_ConnectUser_get_portBuf_608=ConnectUser_get_portBuf(srUsersTable[(signed long int)numofcon]);
                        signed long int return_value_ConnectUser_get_connectTime_609;
                        return_value_ConnectUser_get_connectTime_609=ConnectUser_get_connectTime(srUsersTable[(signed long int)numofcon]);
                        char *return_value_timeperiod_610;
                        return_value_timeperiod_610=timeperiod(now - return_value_ConnectUser_get_connectTime_609);
                        aflog((char)1, (char)16, "REALM: %s USER: %d IP: %s PORT: %s DURATION: %s", return_value_get_realmname_605, return_value_get_username_606, return_value_ConnectUser_get_nameBuf_607, return_value_ConnectUser_get_portBuf_608, return_value_timeperiod_610);
                        signed int return_value_ConnectUser_get_connFd_611;
                        return_value_ConnectUser_get_connFd_611=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        close(return_value_ConnectUser_get_connFd_611);
                        signed int return_value_ConnectUser_get_connFd_612;
                        return_value_ConnectUser_get_connFd_612=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        signed int return_value_ConnectUser_get_connFd_613;
                        return_value_ConnectUser_get_connFd_613=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_612 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_612 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_613 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                        signed int return_value_ConnectUser_get_connFd_614;
                        return_value_ConnectUser_get_connFd_614=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        signed int return_value_ConnectUser_get_connFd_615;
                        return_value_ConnectUser_get_connFd_615=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_614 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_614 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_615 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                        ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)5);
                        struct buflist *return_value_ConnectUser_get_bufList_616;
                        return_value_ConnectUser_get_bufList_616=ConnectUser_get_bufList(srUsersTable[(signed long int)numofcon]);
                        BufList_clear(return_value_ConnectUser_get_bufList_616);
                        buff[(signed long int)0] = (unsigned char)1;
                        buff[(signed long int)1] = (unsigned char)(temp >> 8);
                        buff[(signed long int)2] = (unsigned char)temp;
                        char return_value_ServerRealm_get_realmType_617;
                        return_value_ServerRealm_get_realmType_617=ServerRealm_get_realmType(pointer);
                        struct anonymous_1 *return_value_ConnectClient_get_sslFd_618;
                        return_value_ConnectClient_get_sslFd_618=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                        SslFd_send_message(return_value_ServerRealm_get_realmType_617, return_value_ConnectClient_get_sslFd_618, buff, 5);
                      }

                    }

                    else
                    {
                      signed int return_value_ConnectUser_get_connFd_619;
                      return_value_ConnectUser_get_connFd_619=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                      signed long int return_value_write_620;
                      return_value_write_620=write(return_value_ConnectUser_get_connFd_619, (const void *)buff, (unsigned long int)n);
                      sent = (signed int)return_value_write_620;
                      if(sent >= 1 && !(sent == n))
                      {
                        struct buflist *return_value_ConnectUser_get_bufList_621;
                        return_value_ConnectUser_get_bufList_621=ConnectUser_get_bufList(srUsersTable[(signed long int)numofcon]);
                        struct blnode *return_value_BufListNode_new_message_622;
                        return_value_BufListNode_new_message_622=BufListNode_new_message(sent, n, buff);
                        BufList_insert_back(return_value_ConnectUser_get_bufList_621, return_value_BufListNode_new_message_622);
                        ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)11);
                        signed int return_value_ConnectUser_get_connFd_623;
                        return_value_ConnectUser_get_connFd_623=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        signed int return_value_ConnectUser_get_connFd_624;
                        return_value_ConnectUser_get_connFd_624=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_623 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_623 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd_624 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                        buff[(signed long int)0] = (unsigned char)9;
                        buff[(signed long int)1] = (unsigned char)(temp >> 8);
                        buff[(signed long int)2] = (unsigned char)temp;
                        char *return_value_get_realmname_625;
                        return_value_get_realmname_625=get_realmname(config, j);
                        signed int return_value_get_username_626;
                        return_value_get_username_626=get_username(pointer, numofcon);
                        aflog((char)1, (char)4, "realm[%s]: TO user[%d]: BUFFERING MESSAGE STARTED (%d/%d)", return_value_get_realmname_625, return_value_get_username_626, sent, n);
                        char return_value_ServerRealm_get_realmType_627;
                        return_value_ServerRealm_get_realmType_627=ServerRealm_get_realmType(pointer);
                        struct anonymous_1 *return_value_ConnectClient_get_sslFd_628;
                        return_value_ConnectClient_get_sslFd_628=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                        SslFd_send_message(return_value_ServerRealm_get_realmType_627, return_value_ConnectClient_get_sslFd_628, buff, 5);
                      }

                      else
                      {
                        if(sent == -1)
                        {
                          return_value___errno_location_653=__errno_location();
                          tmp_if_expr_654 = *return_value___errno_location_653 == 11 ? (_Bool)1 : (_Bool)0;
                        }

                        else
                          tmp_if_expr_654 = (_Bool)0;
                        if(tmp_if_expr_654)
                        {
                          struct buflist *return_value_ConnectUser_get_bufList_629;
                          return_value_ConnectUser_get_bufList_629=ConnectUser_get_bufList(srUsersTable[(signed long int)numofcon]);
                          struct blnode *return_value_BufListNode_new_message_630;
                          return_value_BufListNode_new_message_630=BufListNode_new_message(0, n, buff);
                          BufList_insert_back(return_value_ConnectUser_get_bufList_629, return_value_BufListNode_new_message_630);
                          ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)11);
                          signed int return_value_ConnectUser_get_connFd_631;
                          return_value_ConnectUser_get_connFd_631=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                          signed int return_value_ConnectUser_get_connFd_632;
                          return_value_ConnectUser_get_connFd_632=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                          (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_631 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_631 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd_632 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                          buff[(signed long int)0] = (unsigned char)9;
                          buff[(signed long int)1] = (unsigned char)(temp >> 8);
                          buff[(signed long int)2] = (unsigned char)temp;
                          char *return_value_get_realmname_633;
                          return_value_get_realmname_633=get_realmname(config, j);
                          signed int return_value_get_username_634;
                          return_value_get_username_634=get_username(pointer, numofcon);
                          aflog((char)1, (char)4, "realm[%s]: TO user[%d]: BUFFERING MESSAGE STARTED (%d/%d)", return_value_get_realmname_633, return_value_get_username_634, sent, n);
                          char return_value_ServerRealm_get_realmType_635;
                          return_value_ServerRealm_get_realmType_635=ServerRealm_get_realmType(pointer);
                          struct anonymous_1 *return_value_ConnectClient_get_sslFd_636;
                          return_value_ConnectClient_get_sslFd_636=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                          SslFd_send_message(return_value_ServerRealm_get_realmType_635, return_value_ConnectClient_get_sslFd_636, buff, 5);
                        }

                        else
                          if(sent == -1)
                          {
                            char *return_value_get_realmname_637;
                            return_value_get_realmname_637=get_realmname(config, j);
                            signed int return_value_get_username_638;
                            return_value_get_username_638=get_username(pointer, numofcon);
                            aflog((char)1, (char)8, "realm[%s]: user[%d]: CLOSED (write-tcp)", return_value_get_realmname_637, return_value_get_username_638);
                            time(&now);
                            char *return_value_get_realmname_639;
                            return_value_get_realmname_639=get_realmname(config, j);
                            signed int return_value_get_username_640;
                            return_value_get_username_640=get_username(pointer, numofcon);
                            char *return_value_ConnectUser_get_nameBuf_641;
                            return_value_ConnectUser_get_nameBuf_641=ConnectUser_get_nameBuf(srUsersTable[(signed long int)numofcon]);
                            char *return_value_ConnectUser_get_portBuf_642;
                            return_value_ConnectUser_get_portBuf_642=ConnectUser_get_portBuf(srUsersTable[(signed long int)numofcon]);
                            signed long int return_value_ConnectUser_get_connectTime_643;
                            return_value_ConnectUser_get_connectTime_643=ConnectUser_get_connectTime(srUsersTable[(signed long int)numofcon]);
                            char *return_value_timeperiod_644;
                            return_value_timeperiod_644=timeperiod(now - return_value_ConnectUser_get_connectTime_643);
                            aflog((char)1, (char)16, "REALM: %s USER: %d IP: %s PORT: %s DURATION: %s", return_value_get_realmname_639, return_value_get_username_640, return_value_ConnectUser_get_nameBuf_641, return_value_ConnectUser_get_portBuf_642, return_value_timeperiod_644);
                            signed int return_value_ConnectUser_get_connFd_645;
                            return_value_ConnectUser_get_connFd_645=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                            close(return_value_ConnectUser_get_connFd_645);
                            signed int return_value_ConnectUser_get_connFd_646;
                            return_value_ConnectUser_get_connFd_646=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                            signed int return_value_ConnectUser_get_connFd_647;
                            return_value_ConnectUser_get_connFd_647=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                            (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_646 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_646 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_647 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                            signed int return_value_ConnectUser_get_connFd_648;
                            return_value_ConnectUser_get_connFd_648=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                            signed int return_value_ConnectUser_get_connFd_649;
                            return_value_ConnectUser_get_connFd_649=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                            (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_648 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_648 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_649 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                            ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)5);
                            struct buflist *return_value_ConnectUser_get_bufList_650;
                            return_value_ConnectUser_get_bufList_650=ConnectUser_get_bufList(srUsersTable[(signed long int)numofcon]);
                            BufList_clear(return_value_ConnectUser_get_bufList_650);
                            buff[(signed long int)0] = (unsigned char)1;
                            buff[(signed long int)1] = (unsigned char)(temp >> 8);
                            buff[(signed long int)2] = (unsigned char)temp;
                            char return_value_ServerRealm_get_realmType_651;
                            return_value_ServerRealm_get_realmType_651=ServerRealm_get_realmType(pointer);
                            struct anonymous_1 *return_value_ConnectClient_get_sslFd_652;
                            return_value_ConnectClient_get_sslFd_652=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                            SslFd_send_message(return_value_ServerRealm_get_realmType_651, return_value_ConnectClient_get_sslFd_652, buff, 5);
                          }

                      }
                    }
                  }

                  else
                  {
                    return_value_ConnectUser_get_state_672=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                    if((signed int)return_value_ConnectUser_get_state_672 == 11)
                    {
                      char *return_value_get_realmname_658;
                      return_value_get_realmname_658=get_realmname(config, j);
                      signed int return_value_get_username_659;
                      return_value_get_username_659=get_username(pointer, numofcon);
                      aflog((char)1, (char)4, "realm[%s]: TO user[%d]: BUFFERING MESSAGE (%d)", return_value_get_realmname_658, return_value_get_username_659, n);
                      char return_value_ServerRealm_get_realmType_664;
                      return_value_ServerRealm_get_realmType_664=ServerRealm_get_realmType(pointer);
                      if(!((1 & (signed int)return_value_ServerRealm_get_realmType_664) == 0))
                      {
                        return_value_ServerRealm_get_realmType_665=ServerRealm_get_realmType(pointer);
                        tmp_if_expr_666 = ((signed int)return_value_ServerRealm_get_realmType_665 & 2) != 0 ? (_Bool)1 : (_Bool)0;
                      }

                      else
                        tmp_if_expr_666 = (_Bool)0;
                      if(tmp_if_expr_666)
                      {
                        buff[(signed long int)1] = (unsigned char)8;
                        buff[(signed long int)2] = (unsigned char)3;
                        buff[(signed long int)3] = (unsigned char)(n >> 8);
                        buff[(signed long int)4] = (unsigned char)n;
                        struct buflist *return_value_ConnectUser_get_bufList_660;
                        return_value_ConnectUser_get_bufList_660=ConnectUser_get_bufList(srUsersTable[(signed long int)numofcon]);
                        struct blnode *return_value_BufListNode_new_message_661;
                        return_value_BufListNode_new_message_661=BufListNode_new_message(0, n + 5, buff);
                        BufList_insert_back(return_value_ConnectUser_get_bufList_660, return_value_BufListNode_new_message_661);
                      }

                      else
                      {
                        struct buflist *return_value_ConnectUser_get_bufList_662;
                        return_value_ConnectUser_get_bufList_662=ConnectUser_get_bufList(srUsersTable[(signed long int)numofcon]);
                        struct blnode *return_value_BufListNode_new_message_663;
                        return_value_BufListNode_new_message_663=BufListNode_new_message(0, n, buff);
                        BufList_insert_back(return_value_ConnectUser_get_bufList_662, return_value_BufListNode_new_message_663);
                      }
                    }

                    else
                    {
                      return_value_ConnectUser_get_state_671=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                      if((signed int)return_value_ConnectUser_get_state_671 == 5)
                      {
                        char *return_value_get_realmname_667;
                        return_value_get_realmname_667=get_realmname(config, j);
                        signed int return_value_get_username_668;
                        return_value_get_username_668=get_username(pointer, numofcon);
                        aflog((char)1, (char)32, "realm[%s]: TO user[%d]: IGNORED message length=%d", return_value_get_realmname_667, return_value_get_username_668, n);
                      }

                      else
                      {
                        char *return_value_get_realmname_669;
                        return_value_get_realmname_669=get_realmname(config, j);
                        signed int return_value_get_username_670;
                        return_value_get_username_670=get_username(pointer, numofcon);
                        aflog((char)1, (char)32, "realm[%s]: TO user[%d]: user in wrong state - IGNORED", return_value_get_realmname_669, return_value_get_username_670);
                      }
                    }
                  }
                }

                else
                {
                  char *return_value_get_realmname_674;
                  return_value_get_realmname_674=get_realmname(config, j);
                  aflog((char)1, (char)32, "realm[%s]: message to non-existing user - IGNORED", return_value_get_realmname_674);
                }
                break;
              }
              case 8:
              {
                return_value_ConnectClient_get_state_725=ConnectClient_get_state(srClientsTable[(signed long int)k]);
                if((signed int)return_value_ConnectClient_get_state_725 == 2)
                {
                  return_value_ServerRealm_get_password_726=ServerRealm_get_password(pointer);
                  return_value_ServerRealm_get_password_727=ServerRealm_get_password(pointer);
                  tmp_if_expr_728 = numofcon == (signed int)return_value_ServerRealm_get_password_726[(signed long int)0] * 256 + (signed int)return_value_ServerRealm_get_password_727[(signed long int)1] ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_728 = (_Bool)0;
                if(tmp_if_expr_728)
                {
                  return_value_ServerRealm_get_password_729=ServerRealm_get_password(pointer);
                  return_value_ServerRealm_get_password_730=ServerRealm_get_password(pointer);
                  tmp_if_expr_731 = length == (signed int)return_value_ServerRealm_get_password_729[(signed long int)2] * 256 + (signed int)return_value_ServerRealm_get_password_730[(signed long int)3] ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_731 = (_Bool)0;
                if(tmp_if_expr_731)
                {
                  ConnectClient_set_multi(srClientsTable[(signed long int)k], (char)0);
                  signed int return_value_ServerRealm_get_clientsLimit_715;
                  return_value_ServerRealm_get_clientsLimit_715=ServerRealm_get_clientsLimit(pointer);
                  if(!(k == return_value_ServerRealm_get_clientsLimit_715))
                  {
                    ConnectClient_set_state(srClientsTable[(signed long int)k], (char)3);
                    char *return_value_get_realmname_677;
                    return_value_get_realmname_677=get_realmname(config, j);
                    char *return_value_get_clientname_678;
                    return_value_get_clientname_678=get_clientname(pointer, k);
                    aflog((char)2, (char)8, "realm[%s]: Client[%s]: pass ok - ACCESS GRANTED", return_value_get_realmname_677, return_value_get_clientname_678);
                    buff[(signed long int)0] = (unsigned char)8;
                    signed int return_value_ConnectClient_get_limit_679;
                    return_value_ConnectClient_get_limit_679=ConnectClient_get_limit(srClientsTable[(signed long int)k]);
                    buff[(signed long int)1] = (unsigned char)(return_value_ConnectClient_get_limit_679 >> 8);
                    signed int return_value_ConnectClient_get_limit_680;
                    return_value_ConnectClient_get_limit_680=ConnectClient_get_limit(srClientsTable[(signed long int)k]);
                    buff[(signed long int)2] = (unsigned char)return_value_ConnectClient_get_limit_680;
                    char return_value_ServerRealm_get_realmType_681;
                    return_value_ServerRealm_get_realmType_681=ServerRealm_get_realmType(pointer);
                    buff[(signed long int)3] = (unsigned char)return_value_ServerRealm_get_realmType_681;
                    char return_value_ServerRealm_get_realmType_682;
                    return_value_ServerRealm_get_realmType_682=ServerRealm_get_realmType(pointer);
                    struct anonymous_1 *return_value_ConnectClient_get_sslFd_683;
                    return_value_ConnectClient_get_sslFd_683=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                    SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType_682 | 4 | 8), return_value_ConnectClient_get_sslFd_683, buff, 5);
                    task=ConnectClient_get_task(srClientsTable[(signed long int)k]);
                    if(!(task == ((struct anonymous_13 *)NULL)))
                    {
                      TaskScheduler_removeTask(scheduler, task);
                      ConnectClient_set_task(srClientsTable[(signed long int)k], (struct anonymous_13 *)(void *)0);
                    }

                    signed int return_value_ServerRealm_get_maxIdle_688;
                    return_value_ServerRealm_get_maxIdle_688=ServerRealm_get_maxIdle(pointer);
                    if(!(return_value_ServerRealm_get_maxIdle_688 == 0))
                    {
                      signed int return_value_ServerRealm_get_maxIdle_684;
                      return_value_ServerRealm_get_maxIdle_684=ServerRealm_get_maxIdle(pointer);
                      struct timeval return_value_timeval_create_685;
                      return_value_timeval_create_685=timeval_create((signed long int)return_value_ServerRealm_get_maxIdle_684, (signed long int)0);
                      ConnectClient_set_timer(srClientsTable[(signed long int)k], return_value_timeval_create_685);
                      struct timeval *return_value_ConnectClient_get_timerp_686;
                      return_value_ConnectClient_get_timerp_686=ConnectClient_get_timerp(srClientsTable[(signed long int)k]);
                      struct anonymous_25 *return_value_RCTdata_new_687;
                      return_value_RCTdata_new_687=RCTdata_new(config, j, k, (char)0, (char)1, &allset, &wset);
                      task=Task_new(return_value_ConnectClient_get_timerp_686, RCTfunction, (void *)return_value_RCTdata_new_687, RCTdata_free);
                      ConnectClient_set_task(srClientsTable[(signed long int)k], task);
                      TaskScheduler_addTask(scheduler, task);
                    }

                    char return_value_ServerRealm_get_basePortOn_711;
                    return_value_ServerRealm_get_basePortOn_711=ServerRealm_get_basePortOn(pointer);
                    if((signed int)return_value_ServerRealm_get_basePortOn_711 == 1)
                    {
                      signed long int tmp_val;
                      char tmp_tab[6l];
                      signed int return_value_ConnectClient_get_usrCliPair_691;
                      return_value_ConnectClient_get_usrCliPair_691=ConnectClient_get_usrCliPair(srClientsTable[(signed long int)k]);
                      char *return_value_UsrCli_get_listenPortName_692;
                      return_value_UsrCli_get_listenPortName_692=UsrCli_get_listenPortName(srUsersClientsTable[(signed long int)return_value_ConnectClient_get_usrCliPair_691]);
                      signed int return_value_check_long_693;
                      return_value_check_long_693=check_long(return_value_UsrCli_get_listenPortName_692, &tmp_val);
                      if(!(return_value_check_long_693 == 0))
                      {
                        char *return_value_get_realmname_689;
                        return_value_get_realmname_689=get_realmname(config, j);
                        char *return_value_get_clientname_690;
                        return_value_get_clientname_690=get_clientname(pointer, k);
                        aflog((char)2, (char)64, "realm[%s]: INVALID listenport - removing Client[%s]", return_value_get_realmname_689, return_value_get_clientname_690);
                        remove_client(pointer, k, &allset, &wset, scheduler);
                        break;
                      }

                      tmp_val = tmp_val % (signed long int)65536;
                      memset((void *)tmp_tab, 0, (unsigned long int)6);
                      sprintf(tmp_tab, "%d", (signed int)tmp_val);
                      ipfam = (char)0x01;
                      char return_value_ServerRealm_get_realmType_695;
                      return_value_ServerRealm_get_realmType_695=ServerRealm_get_realmType(pointer);
                      if(!((16 & (signed int)return_value_ServerRealm_get_realmType_695) == 0))
                        ipfam = ipfam | (char)0x02;

                      else
                      {
                        return_value_ServerRealm_get_realmType_694=ServerRealm_get_realmType(pointer);
                        if(!((32 & (signed int)return_value_ServerRealm_get_realmType_694) == 0))
                          ipfam = ipfam | (char)0x04;

                      }
                      do
                      {
                        return_value_ConnectClient_get_listenFdp_696=ConnectClient_get_listenFdp(srClientsTable[(signed long int)k]);
                        return_value_ConnectClient_get_usrCliPair_697=ConnectClient_get_usrCliPair(srClientsTable[(signed long int)k]);
                        return_value_UsrCli_get_listenHostName_698=UsrCli_get_listenHostName(srUsersClientsTable[(signed long int)return_value_ConnectClient_get_usrCliPair_697]);
                        if(!(return_value_UsrCli_get_listenHostName_698 == ((char *)NULL)))
                        {
                          return_value_ConnectClient_get_usrCliPair_699=ConnectClient_get_usrCliPair(srClientsTable[(signed long int)k]);
                          return_value_UsrCli_get_listenHostName_700=UsrCli_get_listenHostName(srUsersClientsTable[(signed long int)return_value_ConnectClient_get_usrCliPair_699]);
                          tmp_if_expr_702 = return_value_UsrCli_get_listenHostName_700;
                        }

                        else
                        {
                          return_value_ServerRealm_get_hostName_701=ServerRealm_get_hostName(pointer);
                          tmp_if_expr_702 = return_value_ServerRealm_get_hostName_701;
                        }
                        return_value_ip_listen_703=ip_listen(return_value_ConnectClient_get_listenFdp_696, tmp_if_expr_702, tmp_tab, &len, ipfam);
                        if(return_value_ip_listen_703 == 0)
                          break;

                        tmp_val = (tmp_val + (signed long int)1) % (signed long int)65536;
                        memset((void *)tmp_tab, 0, (unsigned long int)6);
                        sprintf(tmp_tab, "%d", (signed int)tmp_val);
                      }
                      while((_Bool)1);
                      ServerRealm_set_addressLength(pointer, len);
                      signed int return_value_ConnectClient_get_listenFd_704;
                      return_value_ConnectClient_get_listenFd_704=ConnectClient_get_listenFd(srClientsTable[(signed long int)k]);
                      signed int return_value_ConnectClient_get_listenFd_705;
                      return_value_ConnectClient_get_listenFd_705=ConnectClient_get_listenFd(srClientsTable[(signed long int)k]);
                      (&allset)->__fds_bits[(signed long int)(return_value_ConnectClient_get_listenFd_704 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectClient_get_listenFd_704 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectClient_get_listenFd_705 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                      signed int return_value_ConnectClient_get_listenFd_706;
                      return_value_ConnectClient_get_listenFd_706=ConnectClient_get_listenFd(srClientsTable[(signed long int)k]);
                      if(!(1 + return_value_ConnectClient_get_listenFd_706 >= maxfdp1))
                        tmp_if_expr_708 = maxfdp1;

                      else
                      {
                        return_value_ConnectClient_get_listenFd_707=ConnectClient_get_listenFd(srClientsTable[(signed long int)k]);
                        tmp_if_expr_708 = return_value_ConnectClient_get_listenFd_707 + 1;
                      }
                      maxfdp1 = tmp_if_expr_708;
                      char *return_value_get_realmname_709;
                      return_value_get_realmname_709=get_realmname(config, j);
                      char *return_value_get_clientname_710;
                      return_value_get_clientname_710=get_clientname(pointer, k);
                      aflog((char)2, (char)8, "realm[%s]: Client[%s]: listenport=%s", return_value_get_realmname_709, return_value_get_clientname_710, (const void *)tmp_tab);
                    }

                  }

                  else
                  {
                    char *return_value_get_realmname_712;
                    return_value_get_realmname_712=get_realmname(config, j);
                    aflog((char)2, (char)32, "realm[%s]: client limit EXCEEDED", return_value_get_realmname_712);
                    buff[(signed long int)0] = (unsigned char)12;
                    char return_value_ServerRealm_get_realmType_713;
                    return_value_ServerRealm_get_realmType_713=ServerRealm_get_realmType(pointer);
                    struct anonymous_1 *return_value_ConnectClient_get_sslFd_714;
                    return_value_ConnectClient_get_sslFd_714=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                    SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType_713 | 4), return_value_ConnectClient_get_sslFd_714, buff, 5);
                    remove_client(pointer, k, &allset, &wset, scheduler);
                  }
                }

                else
                {
                  return_value_ConnectClient_get_state_724=ConnectClient_get_state(srClientsTable[(signed long int)k]);
                  if(numofcon == 0 && (signed int)return_value_ConnectClient_get_state_724 == 3)
                  {
                    char return_value_ServerRealm_get_realmType_716;
                    return_value_ServerRealm_get_realmType_716=ServerRealm_get_realmType(pointer);
                    struct anonymous_1 *return_value_ConnectClient_get_sslFd_717;
                    return_value_ConnectClient_get_sslFd_717=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                    n=SslFd_get_message(return_value_ServerRealm_get_realmType_716, return_value_ConnectClient_get_sslFd_717, buff, length);
                    buff[(signed long int)n] = (unsigned char)0;
                    char *return_value_get_realmname_718;
                    return_value_get_realmname_718=get_realmname(config, j);
                    char *return_value_get_clientname_719;
                    return_value_get_clientname_719=get_clientname(pointer, k);
                    aflog((char)2, (char)8, "realm[%s]: Client[%s]: ID received: %s", return_value_get_realmname_718, return_value_get_clientname_719, (const void *)buff);
                    ConnectClient_set_sClientId(srClientsTable[(signed long int)k], (char *)buff);
                  }

                  else
                  {
                    char *return_value_get_realmname_720;
                    return_value_get_realmname_720=get_realmname(config, j);
                    char *return_value_get_clientname_721;
                    return_value_get_clientname_721=get_clientname(pointer, k);
                    aflog((char)2, (char)64, "realm[%s]: Client[%s]: Wrong password - CLOSING", return_value_get_realmname_720, return_value_get_clientname_721);
                    buff[(signed long int)0] = (unsigned char)13;
                    char return_value_ServerRealm_get_realmType_722;
                    return_value_ServerRealm_get_realmType_722=ServerRealm_get_realmType(pointer);
                    struct anonymous_1 *return_value_ConnectClient_get_sslFd_723;
                    return_value_ConnectClient_get_sslFd_723=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                    SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType_722 | 4), return_value_ConnectClient_get_sslFd_723, buff, 5);
                    remove_client(pointer, k, &allset, &wset, scheduler);
                  }
                }
                break;
              }
              case 9:
              {
                return_value_ConnectUser_get_state_738=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                if((signed int)return_value_ConnectUser_get_state_738 == 7)
                  tmp_if_expr_740 = (_Bool)1;

                else
                {
                  return_value_ConnectUser_get_state_739=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                  tmp_if_expr_740 = (signed int)return_value_ConnectUser_get_state_739 == 11 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_740)
                {
                  char *return_value_get_realmname_732;
                  return_value_get_realmname_732=get_realmname(config, j);
                  signed int return_value_get_username_733;
                  return_value_get_username_733=get_username(pointer, numofcon);
                  aflog((char)2, (char)2, "realm[%s]: user[%d]: STOP READING", return_value_get_realmname_732, return_value_get_username_733);
                  signed int return_value_ConnectUser_get_connFd_734;
                  return_value_ConnectUser_get_connFd_734=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                  signed int return_value_ConnectUser_get_connFd_735;
                  return_value_ConnectUser_get_connFd_735=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                  (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_734 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_734 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_735 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                }

                else
                {
                  char *return_value_get_realmname_736;
                  return_value_get_realmname_736=get_realmname(config, j);
                  signed int return_value_get_username_737;
                  return_value_get_username_737=get_username(pointer, numofcon);
                  aflog((char)2, (char)4, "realm[%s]: user[%d]: STOP READING - ignored", return_value_get_realmname_736, return_value_get_username_737);
                }
                break;
              }
              case 10:
              {
                return_value_ConnectUser_get_state_747=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                if((signed int)return_value_ConnectUser_get_state_747 == 7)
                  tmp_if_expr_749 = (_Bool)1;

                else
                {
                  return_value_ConnectUser_get_state_748=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                  tmp_if_expr_749 = (signed int)return_value_ConnectUser_get_state_748 == 11 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_749)
                {
                  char *return_value_get_realmname_741;
                  return_value_get_realmname_741=get_realmname(config, j);
                  signed int return_value_get_username_742;
                  return_value_get_username_742=get_username(pointer, numofcon);
                  aflog((char)2, (char)2, "realm[%s]: user[%d]: START READING", return_value_get_realmname_741, return_value_get_username_742);
                  signed int return_value_ConnectUser_get_connFd_743;
                  return_value_ConnectUser_get_connFd_743=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                  signed int return_value_ConnectUser_get_connFd_744;
                  return_value_ConnectUser_get_connFd_744=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                  (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_743 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_743 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd_744 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                }

                else
                {
                  char *return_value_get_realmname_745;
                  return_value_get_realmname_745=get_realmname(config, j);
                  signed int return_value_get_username_746;
                  return_value_get_username_746=get_username(pointer, numofcon);
                  aflog((char)2, (char)4, "realm[%s]: user[%d]: START READING - ignored", return_value_get_realmname_745, return_value_get_username_746);
                }
                break;
              }
              case 13:
              {
                return_value_get_realmname_750=get_realmname(config, j);
                return_value_get_clientname_751=get_clientname(pointer, k);
                aflog((char)2, (char)64, "realm[%s]: Client[%s]: Wrong message - CLOSING", return_value_get_realmname_750, return_value_get_clientname_751);
                remove_client(pointer, k, &allset, &wset, scheduler);
                break;
              }
              case 14:
              {
                return_value_ConnectClient_get_state_783=ConnectClient_get_state(srClientsTable[(signed long int)k]);
                if((signed int)return_value_ConnectClient_get_state_783 == 2)
                {
                  return_value_ServerRealm_get_password_781=ServerRealm_get_password(pointer);
                  return_value_ServerRealm_get_password_782=ServerRealm_get_password(pointer);
                  if(numofcon == 256 * (signed int)*return_value_ServerRealm_get_password_781 + (signed int)return_value_ServerRealm_get_password_782[1l])
                  {
                    return_value_ServerRealm_get_password_779=ServerRealm_get_password(pointer);
                    return_value_ServerRealm_get_password_780=ServerRealm_get_password(pointer);
                    if(length == 256 * (signed int)return_value_ServerRealm_get_password_779[2l] + (signed int)return_value_ServerRealm_get_password_780[3l])
                    {
                      char *return_value_get_realmname_752;
                      return_value_get_realmname_752=get_realmname(config, j);
                      char *return_value_get_clientname_753;
                      return_value_get_clientname_753=get_clientname(pointer, k);
                      aflog((char)8, (char)8, "realm[%s]: Client[%s]: NEW remote admin -- pass OK", return_value_get_realmname_752, return_value_get_clientname_753);
                      l = 0;
                      do
                      {
                        return_value_ServerRealm_get_raClientsLimit_754=ServerRealm_get_raClientsLimit(pointer);
                        if(l >= return_value_ServerRealm_get_raClientsLimit_754)
                          break;

                        char return_value_ConnectClient_get_state_769;
                        return_value_ConnectClient_get_state_769=ConnectClient_get_state(srRaClientsTable[(signed long int)l]);
                        if((signed int)return_value_ConnectClient_get_state_769 == 0)
                        {
                          struct anonymous_1 *return_value_ConnectClient_get_sslFd_755;
                          return_value_ConnectClient_get_sslFd_755=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)l]);
                          struct anonymous_1 *return_value_ConnectClient_get_sslFd_756;
                          return_value_ConnectClient_get_sslFd_756=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                          signed int return_value_SslFd_get_fd_757;
                          return_value_SslFd_get_fd_757=SslFd_get_fd(return_value_ConnectClient_get_sslFd_756);
                          SslFd_set_fd(return_value_ConnectClient_get_sslFd_755, return_value_SslFd_get_fd_757);
                          signed long int return_value_ConnectClient_get_connectTime_758;
                          return_value_ConnectClient_get_connectTime_758=ConnectClient_get_connectTime(srClientsTable[(signed long int)k]);
                          ConnectClient_set_connectTime(srRaClientsTable[(signed long int)l], return_value_ConnectClient_get_connectTime_758);
                          signed long int return_value_ConnectClient_get_lastActivity_759;
                          return_value_ConnectClient_get_lastActivity_759=ConnectClient_get_lastActivity(srClientsTable[(signed long int)k]);
                          ConnectClient_set_lastActivity(srRaClientsTable[(signed long int)l], return_value_ConnectClient_get_lastActivity_759);
                          char return_value_ConnectClient_get_tunnelType_760;
                          return_value_ConnectClient_get_tunnelType_760=ConnectClient_get_tunnelType(srClientsTable[(signed long int)k]);
                          ConnectClient_set_tunnelType(srRaClientsTable[(signed long int)l], return_value_ConnectClient_get_tunnelType_760);
                          signed int return_value_ConnectClient_get_clientId_761;
                          return_value_ConnectClient_get_clientId_761=ConnectClient_get_clientId(srClientsTable[(signed long int)k]);
                          ConnectClient_set_clientId(srRaClientsTable[(signed long int)l], return_value_ConnectClient_get_clientId_761);
                          char *return_value_ConnectClient_get_nameBuf_762;
                          return_value_ConnectClient_get_nameBuf_762=ConnectClient_get_nameBuf(srClientsTable[(signed long int)k]);
                          ConnectClient_set_nameBuf(srRaClientsTable[(signed long int)l], return_value_ConnectClient_get_nameBuf_762);
                          char *return_value_ConnectClient_get_portBuf_763;
                          return_value_ConnectClient_get_portBuf_763=ConnectClient_get_portBuf(srClientsTable[(signed long int)k]);
                          ConnectClient_set_portBuf(srRaClientsTable[(signed long int)l], return_value_ConnectClient_get_portBuf_763);
                          struct anonymous_1 *return_value_ConnectClient_get_sslFd_764;
                          return_value_ConnectClient_get_sslFd_764=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)l]);
                          tmp_ssl=SslFd_get_ssl(return_value_ConnectClient_get_sslFd_764);
                          struct anonymous_1 *return_value_ConnectClient_get_sslFd_765;
                          return_value_ConnectClient_get_sslFd_765=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)l]);
                          struct anonymous_1 *return_value_ConnectClient_get_sslFd_766;
                          return_value_ConnectClient_get_sslFd_766=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                          struct ssl_st *return_value_SslFd_get_ssl_767;
                          return_value_SslFd_get_ssl_767=SslFd_get_ssl(return_value_ConnectClient_get_sslFd_766);
                          SslFd_set_ssl_nf(return_value_ConnectClient_get_sslFd_765, return_value_SslFd_get_ssl_767);
                          struct anonymous_1 *return_value_ConnectClient_get_sslFd_768;
                          return_value_ConnectClient_get_sslFd_768=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                          SslFd_set_ssl_nf(return_value_ConnectClient_get_sslFd_768, tmp_ssl);
                          ConnectClient_set_state(srClientsTable[(signed long int)k], (char)0);
                          break;
                        }

                        l = l + 1;
                      }
                      while((_Bool)1);
                      signed int return_value_ServerRealm_get_raClientsLimit_778;
                      return_value_ServerRealm_get_raClientsLimit_778=ServerRealm_get_raClientsLimit(pointer);
                      if(!(l == return_value_ServerRealm_get_raClientsLimit_778))
                      {
                        ConnectClient_set_state(srRaClientsTable[(signed long int)l], (char)3);
                        ServerRealm_increase_connectedRaClients(pointer);
                        task=ConnectClient_get_task(srClientsTable[(signed long int)k]);
                        if(!(task == ((struct anonymous_13 *)NULL)))
                        {
                          TaskScheduler_removeTask(scheduler, task);
                          ConnectClient_set_task(srClientsTable[(signed long int)k], (struct anonymous_13 *)(void *)0);
                        }

                        sprintf((char *)&buff[(signed long int)5], "AFSERVER v0.8.4");
                        unsigned long int return_value_strlen_770;
                        return_value_strlen_770=strlen((char *)&buff[(signed long int)5]);
                        n = (signed int)return_value_strlen_770;
                        buff[(signed long int)0] = (unsigned char)14;
                        char return_value_ServerRealm_get_realmType_771;
                        return_value_ServerRealm_get_realmType_771=ServerRealm_get_realmType(pointer);
                        buff[(signed long int)1] = (unsigned char)return_value_ServerRealm_get_realmType_771;
                        buff[(signed long int)2] = (unsigned char)0;
                        buff[(signed long int)3] = (unsigned char)(n >> 8);
                        buff[(signed long int)4] = (unsigned char)n;
                        char return_value_ServerRealm_get_realmType_772;
                        return_value_ServerRealm_get_realmType_772=ServerRealm_get_realmType(pointer);
                        struct anonymous_1 *return_value_ConnectClient_get_sslFd_773;
                        return_value_ConnectClient_get_sslFd_773=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)l]);
                        SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType_772 | 4), return_value_ConnectClient_get_sslFd_773, buff, n + 5);
                      }

                      else
                      {
                        char *return_value_get_realmname_774;
                        return_value_get_realmname_774=get_realmname(config, j);
                        char *return_value_get_clientname_775;
                        return_value_get_clientname_775=get_clientname(pointer, k);
                        aflog((char)8, (char)32, "realm[%s]: Client[%s]: remote admin -- limit EXCEEDED", return_value_get_realmname_774, return_value_get_clientname_775);
                        buff[(signed long int)0] = (unsigned char)12;
                        char return_value_ServerRealm_get_realmType_776;
                        return_value_ServerRealm_get_realmType_776=ServerRealm_get_realmType(pointer);
                        struct anonymous_1 *return_value_ConnectClient_get_sslFd_777;
                        return_value_ConnectClient_get_sslFd_777=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                        SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType_776 | 4 | 8), return_value_ConnectClient_get_sslFd_777, buff, 5);
                        remove_client(pointer, k, &allset, &wset, scheduler);
                      }
                    }

                  }

                }

                break;
              }
              case 16:
              {
                return_value_get_realmname_784=get_realmname(config, j);
                return_value_get_clientname_785=get_clientname(pointer, k);
                aflog((char)2, (char)2, "realm[%s]: Client[%s]: Keep alive packet", return_value_get_realmname_784, return_value_get_clientname_785);
                break;
              }
              case 18:
              {
                return_value_get_realmname_786=get_realmname(config, j);
                return_value_get_clientname_787=get_clientname(pointer, k);
                aflog((char)2, (char)8, "realm[%s]: Client[%s]: MULTI enabled: %d", return_value_get_realmname_786, return_value_get_clientname_787, buff[(signed long int)1]);
                ConnectClient_set_multi(srClientsTable[(signed long int)k], (char)1);
                break;
              }
              default:
              {
                char *return_value_get_realmname_788;
                return_value_get_realmname_788=get_realmname(config, j);
                char *return_value_get_clientname_789;
                return_value_get_clientname_789=get_clientname(pointer, k);
                aflog((char)2, (char)64, "realm[%s]: Client[%s]: Unrecognized message - CLOSING", return_value_get_realmname_788, return_value_get_clientname_789);
                remove_client(pointer, k, &allset, &wset, scheduler);
              }
            }
          }

        }


      __CPROVER_DUMP_L389:
        ;
        k = k + 1;
      }
      while((_Bool)1);
      k = 0;
      do
      {
        return_value_ServerRealm_get_raClientsLimit_795=ServerRealm_get_raClientsLimit(pointer);
        if(k >= return_value_ServerRealm_get_raClientsLimit_795)
          break;

        return_value_ConnectClient_get_state_971=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
        if((signed int)return_value_ConnectClient_get_state_971 >= 1)
        {
          return_value_ConnectClient_get_sslFd_967=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
          return_value_SslFd_get_fd_968=SslFd_get_fd(return_value_ConnectClient_get_sslFd_967);
          return_value_ConnectClient_get_sslFd_969=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
          return_value_SslFd_get_fd_970=SslFd_get_fd(return_value_ConnectClient_get_sslFd_969);
          if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd_968 / 8)] & 1l << return_value_SslFd_get_fd_970 % 8) == 0l))
          {
            char return_value_ConnectClient_get_state_813;
            return_value_ConnectClient_get_state_813=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
            if((signed int)return_value_ConnectClient_get_state_813 == 1)
            {
              struct anonymous_1 *return_value_ConnectClient_get_sslFd_796;
              return_value_ConnectClient_get_sslFd_796=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
              make_ssl_initialize(return_value_ConnectClient_get_sslFd_796);
              char *return_value_get_realmname_797;
              return_value_get_realmname_797=get_realmname(config, j);
              char *return_value_get_raclientname_798;
              return_value_get_raclientname_798=get_raclientname(pointer, k);
              aflog((char)8, (char)4, "realm[%s]: new Client[%s] (ra): SSL_accept", return_value_get_realmname_797, return_value_get_raclientname_798);
              struct anonymous_1 *return_value_ConnectClient_get_sslFd_799;
              return_value_ConnectClient_get_sslFd_799=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
              signed int return_value_make_ssl_accept_800;
              return_value_make_ssl_accept_800=make_ssl_accept(return_value_ConnectClient_get_sslFd_799);
              switch(return_value_make_ssl_accept_800)
              {
                case 2:
                {
                  struct anonymous_1 *return_value_ConnectClient_get_sslFd_801;
                  return_value_ConnectClient_get_sslFd_801=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                  signed int return_value_SslFd_get_fd_802;
                  return_value_SslFd_get_fd_802=SslFd_get_fd(return_value_ConnectClient_get_sslFd_801);
                  close(return_value_SslFd_get_fd_802);
                  struct anonymous_1 *return_value_ConnectClient_get_sslFd_803;
                  return_value_ConnectClient_get_sslFd_803=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                  signed int return_value_SslFd_get_fd_804;
                  return_value_SslFd_get_fd_804=SslFd_get_fd(return_value_ConnectClient_get_sslFd_803);
                  struct anonymous_1 *return_value_ConnectClient_get_sslFd_805;
                  return_value_ConnectClient_get_sslFd_805=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                  signed int return_value_SslFd_get_fd_806;
                  return_value_SslFd_get_fd_806=SslFd_get_fd(return_value_ConnectClient_get_sslFd_805);
                  (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd_804 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd_804 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_SslFd_get_fd_806 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  struct anonymous_1 *return_value_ConnectClient_get_sslFd_807;
                  return_value_ConnectClient_get_sslFd_807=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                  struct ssl_st *return_value_SslFd_get_ssl_808;
                  return_value_SslFd_get_ssl_808=SslFd_get_ssl(return_value_ConnectClient_get_sslFd_807);
                  SSL_clear(return_value_SslFd_get_ssl_808);
                  ConnectClient_set_state(srRaClientsTable[(signed long int)k], (char)0);
                  task=ConnectClient_get_task(srRaClientsTable[(signed long int)k]);
                  if(!(task == ((struct anonymous_13 *)NULL)))
                  {
                    TaskScheduler_removeTask(scheduler, task);
                    ConnectClient_set_task(srRaClientsTable[(signed long int)k], (struct anonymous_13 *)(void *)0);
                  }

                  ServerRealm_decrease_connectedClients(pointer);
                  char *return_value_get_realmname_809;
                  return_value_get_realmname_809=get_realmname(config, j);
                  char *return_value_get_raclientname_810;
                  return_value_get_raclientname_810=get_raclientname(pointer, k);
                  aflog((char)8, (char)64, "realm[%s]: new Client[%s] (ra): DENIED by SSL_accept", return_value_get_realmname_809, return_value_get_raclientname_810);
                }
                case 1:
                  goto __CPROVER_DUMP_L448;
                default:
                {
                  return_value_get_realmname_811=get_realmname(config, j);
                  return_value_get_raclientname_812=get_raclientname(pointer, k);
                  aflog((char)8, (char)2, "realm[%s]: new Client[%s] (ra): ACCEPTED by SSL_accept", return_value_get_realmname_811, return_value_get_raclientname_812);
                  ConnectClient_set_state(srRaClientsTable[(signed long int)k], (char)2);
                  goto __CPROVER_DUMP_L448;
                }
              }
            }

            char *return_value_get_realmname_814;
            return_value_get_realmname_814=get_realmname(config, j);
            char *return_value_get_raclientname_815;
            return_value_get_raclientname_815=get_raclientname(pointer, k);
            aflog((char)8, (char)4, "realm[%s]: Client[%s] (ra): commfd: FD_ISSET", return_value_get_realmname_814, return_value_get_raclientname_815);
            char return_value_ServerRealm_get_realmType_816;
            return_value_ServerRealm_get_realmType_816=ServerRealm_get_realmType(pointer);
            struct anonymous_1 *return_value_ConnectClient_get_sslFd_817;
            return_value_ConnectClient_get_sslFd_817=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
            struct anonymous_8 *return_value_ConnectClient_get_header_818;
            return_value_ConnectClient_get_header_818=ConnectClient_get_header(srRaClientsTable[(signed long int)k]);
            signed int return_value_HeaderBuffer_to_read_819;
            return_value_HeaderBuffer_to_read_819=HeaderBuffer_to_read(return_value_ConnectClient_get_header_818);
            n=SslFd_get_message((char)((signed int)return_value_ServerRealm_get_realmType_816 | 4 | 8), return_value_ConnectClient_get_sslFd_817, buff, -1 * return_value_HeaderBuffer_to_read_819);
            if(n == -1)
            {
              signed int *return_value___errno_location_825;
              return_value___errno_location_825=__errno_location();
              if(*return_value___errno_location_825 == 11)
              {
                char *return_value_get_realmname_820;
                return_value_get_realmname_820=get_realmname(config, j);
                char *return_value_get_raclientname_821;
                return_value_get_raclientname_821=get_raclientname(pointer, k);
                aflog((char)8, (char)4, "realm[%s]: Client[%s] (ra): commfd: EAGAIN", return_value_get_realmname_820, return_value_get_raclientname_821);
                goto __CPROVER_DUMP_L448;
              }

              else
              {
                char *return_value_get_realmname_822;
                return_value_get_realmname_822=get_realmname(config, j);
                char *return_value_get_raclientname_823;
                return_value_get_raclientname_823=get_raclientname(pointer, k);
                signed int *return_value___errno_location_824;
                return_value___errno_location_824=__errno_location();
                aflog((char)8, (char)64, "realm[%s]: Client[%s] (ra): commfd: ERROR: %d", return_value_get_realmname_822, return_value_get_raclientname_823, *return_value___errno_location_824);
                n = 0;
              }
            }

            else
              if(!(n == 5))
              {
                if(!(n == 0))
                {
                  char *return_value_get_realmname_826;
                  return_value_get_realmname_826=get_realmname(config, j);
                  char *return_value_get_raclientname_827;
                  return_value_get_raclientname_827=get_raclientname(pointer, k);
                  aflog((char)8, (char)32, "realm[%s]: Client[%s] (ra): header length = %d --> buffering", return_value_get_realmname_826, return_value_get_raclientname_827, n);
                  struct anonymous_8 *return_value_ConnectClient_get_header_828;
                  return_value_ConnectClient_get_header_828=ConnectClient_get_header(srRaClientsTable[(signed long int)k]);
                  HeaderBuffer_store(return_value_ConnectClient_get_header_828, buff, n);
                  struct anonymous_8 *return_value_ConnectClient_get_header_830;
                  return_value_ConnectClient_get_header_830=ConnectClient_get_header(srRaClientsTable[(signed long int)k]);
                  signed int return_value_HeaderBuffer_to_read_831;
                  return_value_HeaderBuffer_to_read_831=HeaderBuffer_to_read(return_value_ConnectClient_get_header_830);
                  if(return_value_HeaderBuffer_to_read_831 == 0)
                  {
                    struct anonymous_8 *return_value_ConnectClient_get_header_829;
                    return_value_ConnectClient_get_header_829=ConnectClient_get_header(srRaClientsTable[(signed long int)k]);
                    HeaderBuffer_restore(return_value_ConnectClient_get_header_829, buff);
                    n = 5;
                  }

                  else
                    goto __CPROVER_DUMP_L448;
                }

              }

            if(n == 0)
            {
              remove_raclient(pointer, k, &allset, &wset, scheduler);
              char *return_value_get_realmname_832;
              return_value_get_realmname_832=get_realmname(config, j);
              char *return_value_get_raclientname_833;
              return_value_get_raclientname_833=get_raclientname(pointer, k);
              aflog((char)8, (char)8, "realm[%s]: Client[%s] (ra): commfd: CLOSED", return_value_get_realmname_832, return_value_get_raclientname_833);
              goto __CPROVER_DUMP_L448;
            }

            numofcon = (signed int)buff[(signed long int)1];
            numofcon = numofcon << 8;
            numofcon = numofcon + (signed int)buff[(signed long int)2];
            length = (signed int)buff[(signed long int)3];
            length = length << 8;
            length = length + (signed int)buff[(signed long int)4];
            char return_value_ConnectClient_get_state_836;
            return_value_ConnectClient_get_state_836=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
            if(!((signed int)return_value_ConnectClient_get_state_836 >= 2))
            {
              char *return_value_get_realmname_834;
              return_value_get_realmname_834=get_realmname(config, j);
              char *return_value_get_raclientname_835;
              return_value_get_raclientname_835=get_raclientname(pointer, k);
              aflog((char)8, (char)32, "realm[%s]: Client[%s] (ra): Impossible behaviour --> ignoring", return_value_get_realmname_834, return_value_get_raclientname_835);
              goto __CPROVER_DUMP_L448;
            }

            char return_value_ConnectClient_get_state_837;
            return_value_ConnectClient_get_state_837=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
            if((signed int)return_value_ConnectClient_get_state_837 == 2)
            {
              if(!((signed int)buff[0l] == 8))
              {
                if(!((signed int)buff[0l] == 14))
                  buff[(signed long int)0] = (unsigned char)13;

              }

            }

            time(&now);
            ConnectClient_set_lastActivity(srRaClientsTable[(signed long int)k], now);
            switch((signed int)buff[(signed long int)0])
            {
              case 8:
              {
                return_value_ConnectClient_get_state_904=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
                if((signed int)return_value_ConnectClient_get_state_904 == 2)
                {
                  return_value_ServerRealm_get_password_905=ServerRealm_get_password(pointer);
                  return_value_ServerRealm_get_password_906=ServerRealm_get_password(pointer);
                  tmp_if_expr_907 = numofcon == (signed int)return_value_ServerRealm_get_password_905[(signed long int)0] * 256 + (signed int)return_value_ServerRealm_get_password_906[(signed long int)1] ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_907 = (_Bool)0;
                if(tmp_if_expr_907)
                {
                  return_value_ServerRealm_get_password_908=ServerRealm_get_password(pointer);
                  return_value_ServerRealm_get_password_909=ServerRealm_get_password(pointer);
                  tmp_if_expr_910 = length == (signed int)return_value_ServerRealm_get_password_908[(signed long int)2] * 256 + (signed int)return_value_ServerRealm_get_password_909[(signed long int)3] ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_910 = (_Bool)0;
                if(tmp_if_expr_910)
                {
                  ConnectClient_set_multi(srRaClientsTable[(signed long int)k], (char)0);
                  l = 0;
                  do
                  {
                    return_value_ServerRealm_get_clientsLimit_838=ServerRealm_get_clientsLimit(pointer);
                    if(l >= return_value_ServerRealm_get_clientsLimit_838)
                      break;

                    char return_value_ConnectClient_get_state_857;
                    return_value_ConnectClient_get_state_857=ConnectClient_get_state(srClientsTable[(signed long int)l]);
                    if((signed int)return_value_ConnectClient_get_state_857 == 0)
                    {
                      char *return_value_get_realmname_839;
                      return_value_get_realmname_839=get_realmname(config, j);
                      char *return_value_get_raclientname_840;
                      return_value_get_raclientname_840=get_raclientname(pointer, k);
                      char *return_value_get_clientname_841;
                      return_value_get_clientname_841=get_clientname(pointer, l);
                      aflog((char)(8 | 2), (char)8, "realm[%s]: Client[%s] (ra) --> Client[%s]", return_value_get_realmname_839, return_value_get_raclientname_840, return_value_get_clientname_841);
                      struct anonymous_1 *return_value_ConnectClient_get_sslFd_842;
                      return_value_ConnectClient_get_sslFd_842=ConnectClient_get_sslFd(srClientsTable[(signed long int)l]);
                      struct anonymous_1 *return_value_ConnectClient_get_sslFd_843;
                      return_value_ConnectClient_get_sslFd_843=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                      signed int return_value_SslFd_get_fd_844;
                      return_value_SslFd_get_fd_844=SslFd_get_fd(return_value_ConnectClient_get_sslFd_843);
                      SslFd_set_fd(return_value_ConnectClient_get_sslFd_842, return_value_SslFd_get_fd_844);
                      signed long int return_value_ConnectClient_get_connectTime_845;
                      return_value_ConnectClient_get_connectTime_845=ConnectClient_get_connectTime(srRaClientsTable[(signed long int)k]);
                      ConnectClient_set_connectTime(srClientsTable[(signed long int)l], return_value_ConnectClient_get_connectTime_845);
                      signed long int return_value_ConnectClient_get_lastActivity_846;
                      return_value_ConnectClient_get_lastActivity_846=ConnectClient_get_lastActivity(srRaClientsTable[(signed long int)k]);
                      ConnectClient_set_lastActivity(srClientsTable[(signed long int)l], return_value_ConnectClient_get_lastActivity_846);
                      char return_value_ConnectClient_get_tunnelType_847;
                      return_value_ConnectClient_get_tunnelType_847=ConnectClient_get_tunnelType(srRaClientsTable[(signed long int)k]);
                      ConnectClient_set_tunnelType(srClientsTable[(signed long int)l], return_value_ConnectClient_get_tunnelType_847);
                      signed int return_value_ConnectClient_get_clientId_848;
                      return_value_ConnectClient_get_clientId_848=ConnectClient_get_clientId(srRaClientsTable[(signed long int)k]);
                      ConnectClient_set_clientId(srClientsTable[(signed long int)l], return_value_ConnectClient_get_clientId_848);
                      char *return_value_ConnectClient_get_nameBuf_849;
                      return_value_ConnectClient_get_nameBuf_849=ConnectClient_get_nameBuf(srRaClientsTable[(signed long int)k]);
                      ConnectClient_set_nameBuf(srClientsTable[(signed long int)l], return_value_ConnectClient_get_nameBuf_849);
                      char *return_value_ConnectClient_get_portBuf_850;
                      return_value_ConnectClient_get_portBuf_850=ConnectClient_get_portBuf(srRaClientsTable[(signed long int)k]);
                      ConnectClient_set_portBuf(srClientsTable[(signed long int)l], return_value_ConnectClient_get_portBuf_850);
                      struct anonymous_1 *return_value_ConnectClient_get_sslFd_851;
                      return_value_ConnectClient_get_sslFd_851=ConnectClient_get_sslFd(srClientsTable[(signed long int)l]);
                      tmp_ssl=SslFd_get_ssl(return_value_ConnectClient_get_sslFd_851);
                      struct anonymous_1 *return_value_ConnectClient_get_sslFd_852;
                      return_value_ConnectClient_get_sslFd_852=ConnectClient_get_sslFd(srClientsTable[(signed long int)l]);
                      struct anonymous_1 *return_value_ConnectClient_get_sslFd_853;
                      return_value_ConnectClient_get_sslFd_853=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                      struct ssl_st *return_value_SslFd_get_ssl_854;
                      return_value_SslFd_get_ssl_854=SslFd_get_ssl(return_value_ConnectClient_get_sslFd_853);
                      SslFd_set_ssl_nf(return_value_ConnectClient_get_sslFd_852, return_value_SslFd_get_ssl_854);
                      struct anonymous_1 *return_value_ConnectClient_get_sslFd_855;
                      return_value_ConnectClient_get_sslFd_855=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                      SslFd_set_ssl_nf(return_value_ConnectClient_get_sslFd_855, tmp_ssl);
                      signed int return_value_ConnectClient_get_usrCliPair_856;
                      return_value_ConnectClient_get_usrCliPair_856=ConnectClient_get_usrCliPair(srRaClientsTable[(signed long int)k]);
                      ConnectClient_set_usrCliPair(srClientsTable[(signed long int)l], return_value_ConnectClient_get_usrCliPair_856);
                      ConnectClient_set_state(srRaClientsTable[(signed long int)k], (char)0);
                      break;
                    }

                    l = l + 1;
                  }
                  while((_Bool)1);
                  signed int return_value_ServerRealm_get_clientsLimit_896;
                  return_value_ServerRealm_get_clientsLimit_896=ServerRealm_get_clientsLimit(pointer);
                  if(!(l == return_value_ServerRealm_get_clientsLimit_896))
                  {
                    ConnectClient_set_state(srClientsTable[(signed long int)l], (char)3);
                    char *return_value_get_realmname_858;
                    return_value_get_realmname_858=get_realmname(config, j);
                    char *return_value_get_clientname_859;
                    return_value_get_clientname_859=get_clientname(pointer, l);
                    aflog((char)2, (char)8, "realm[%s]: Client[%s]: pass ok - ACCESS GRANTED", return_value_get_realmname_858, return_value_get_clientname_859);
                    buff[(signed long int)0] = (unsigned char)8;
                    signed int return_value_ConnectClient_get_limit_860;
                    return_value_ConnectClient_get_limit_860=ConnectClient_get_limit(srClientsTable[(signed long int)l]);
                    buff[(signed long int)1] = (unsigned char)(return_value_ConnectClient_get_limit_860 >> 8);
                    signed int return_value_ConnectClient_get_limit_861;
                    return_value_ConnectClient_get_limit_861=ConnectClient_get_limit(srClientsTable[(signed long int)l]);
                    buff[(signed long int)2] = (unsigned char)return_value_ConnectClient_get_limit_861;
                    char return_value_ServerRealm_get_realmType_862;
                    return_value_ServerRealm_get_realmType_862=ServerRealm_get_realmType(pointer);
                    buff[(signed long int)3] = (unsigned char)return_value_ServerRealm_get_realmType_862;
                    char return_value_ServerRealm_get_realmType_863;
                    return_value_ServerRealm_get_realmType_863=ServerRealm_get_realmType(pointer);
                    struct anonymous_1 *return_value_ConnectClient_get_sslFd_864;
                    return_value_ConnectClient_get_sslFd_864=ConnectClient_get_sslFd(srClientsTable[(signed long int)l]);
                    SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType_863 | 4 | 8), return_value_ConnectClient_get_sslFd_864, buff, 5);
                    task=ConnectClient_get_task(srRaClientsTable[(signed long int)k]);
                    if(!(task == ((struct anonymous_13 *)NULL)))
                    {
                      TaskScheduler_removeTask(scheduler, task);
                      ConnectClient_set_task(srRaClientsTable[(signed long int)k], (struct anonymous_13 *)(void *)0);
                    }

                    signed int return_value_ServerRealm_get_maxIdle_869;
                    return_value_ServerRealm_get_maxIdle_869=ServerRealm_get_maxIdle(pointer);
                    if(!(return_value_ServerRealm_get_maxIdle_869 == 0))
                    {
                      signed int return_value_ServerRealm_get_maxIdle_865;
                      return_value_ServerRealm_get_maxIdle_865=ServerRealm_get_maxIdle(pointer);
                      struct timeval return_value_timeval_create_866;
                      return_value_timeval_create_866=timeval_create((signed long int)return_value_ServerRealm_get_maxIdle_865, (signed long int)0);
                      ConnectClient_set_timer(srClientsTable[(signed long int)l], return_value_timeval_create_866);
                      struct timeval *return_value_ConnectClient_get_timerp_867;
                      return_value_ConnectClient_get_timerp_867=ConnectClient_get_timerp(srClientsTable[(signed long int)l]);
                      struct anonymous_25 *return_value_RCTdata_new_868;
                      return_value_RCTdata_new_868=RCTdata_new(config, j, l, (char)0, (char)1, &allset, &wset);
                      task=Task_new(return_value_ConnectClient_get_timerp_867, RCTfunction, (void *)return_value_RCTdata_new_868, RCTdata_free);
                      ConnectClient_set_task(srClientsTable[(signed long int)l], task);
                      TaskScheduler_addTask(scheduler, task);
                    }

                    char return_value_ServerRealm_get_basePortOn_892;
                    return_value_ServerRealm_get_basePortOn_892=ServerRealm_get_basePortOn(pointer);
                    if((signed int)return_value_ServerRealm_get_basePortOn_892 == 1)
                    {
                      signed long int main__1__17__3__6__7__1__1__2__3__tmp_val;
                      char main__1__17__3__6__7__1__1__2__3__tmp_tab[6l];
                      signed int return_value_ConnectClient_get_usrCliPair_872;
                      return_value_ConnectClient_get_usrCliPair_872=ConnectClient_get_usrCliPair(srClientsTable[(signed long int)l]);
                      char *return_value_UsrCli_get_listenPortName_873;
                      return_value_UsrCli_get_listenPortName_873=UsrCli_get_listenPortName(srUsersClientsTable[(signed long int)return_value_ConnectClient_get_usrCliPair_872]);
                      signed int return_value_check_long_874;
                      return_value_check_long_874=check_long(return_value_UsrCli_get_listenPortName_873, &main__1__17__3__6__7__1__1__2__3__tmp_val);
                      if(!(return_value_check_long_874 == 0))
                      {
                        char *return_value_get_realmname_870;
                        return_value_get_realmname_870=get_realmname(config, j);
                        char *return_value_get_clientname_871;
                        return_value_get_clientname_871=get_clientname(pointer, l);
                        aflog((char)2, (char)64, "realm[%s]: INVALID listenport - removing Client[%s]", return_value_get_realmname_870, return_value_get_clientname_871);
                        remove_client(pointer, l, &allset, &wset, scheduler);
                        break;
                      }

                      main__1__17__3__6__7__1__1__2__3__tmp_val = main__1__17__3__6__7__1__1__2__3__tmp_val % (signed long int)65536;
                      memset((void *)main__1__17__3__6__7__1__1__2__3__tmp_tab, 0, (unsigned long int)6);
                      sprintf(main__1__17__3__6__7__1__1__2__3__tmp_tab, "%d", (signed int)main__1__17__3__6__7__1__1__2__3__tmp_val);
                      ipfam = (char)0x01;
                      char return_value_ServerRealm_get_realmType_876;
                      return_value_ServerRealm_get_realmType_876=ServerRealm_get_realmType(pointer);
                      if(!((16 & (signed int)return_value_ServerRealm_get_realmType_876) == 0))
                        ipfam = ipfam | (char)0x02;

                      else
                      {
                        return_value_ServerRealm_get_realmType_875=ServerRealm_get_realmType(pointer);
                        if(!((32 & (signed int)return_value_ServerRealm_get_realmType_875) == 0))
                          ipfam = ipfam | (char)0x04;

                      }
                      do
                      {
                        return_value_ConnectClient_get_listenFdp_877=ConnectClient_get_listenFdp(srClientsTable[(signed long int)l]);
                        return_value_ConnectClient_get_usrCliPair_878=ConnectClient_get_usrCliPair(srClientsTable[(signed long int)l]);
                        return_value_UsrCli_get_listenHostName_879=UsrCli_get_listenHostName(srUsersClientsTable[(signed long int)return_value_ConnectClient_get_usrCliPair_878]);
                        if(!(return_value_UsrCli_get_listenHostName_879 == ((char *)NULL)))
                        {
                          return_value_ConnectClient_get_usrCliPair_880=ConnectClient_get_usrCliPair(srClientsTable[(signed long int)l]);
                          return_value_UsrCli_get_listenHostName_881=UsrCli_get_listenHostName(srUsersClientsTable[(signed long int)return_value_ConnectClient_get_usrCliPair_880]);
                          tmp_if_expr_883 = return_value_UsrCli_get_listenHostName_881;
                        }

                        else
                        {
                          return_value_ServerRealm_get_hostName_882=ServerRealm_get_hostName(pointer);
                          tmp_if_expr_883 = return_value_ServerRealm_get_hostName_882;
                        }
                        return_value_ip_listen_884=ip_listen(return_value_ConnectClient_get_listenFdp_877, tmp_if_expr_883, main__1__17__3__6__7__1__1__2__3__tmp_tab, &len, ipfam);
                        if(return_value_ip_listen_884 == 0)
                          break;

                        main__1__17__3__6__7__1__1__2__3__tmp_val = (main__1__17__3__6__7__1__1__2__3__tmp_val + (signed long int)1) % (signed long int)65536;
                        memset((void *)main__1__17__3__6__7__1__1__2__3__tmp_tab, 0, (unsigned long int)6);
                        sprintf(main__1__17__3__6__7__1__1__2__3__tmp_tab, "%d", (signed int)main__1__17__3__6__7__1__1__2__3__tmp_val);
                      }
                      while((_Bool)1);
                      ServerRealm_set_addressLength(pointer, len);
                      signed int return_value_ConnectClient_get_listenFd_885;
                      return_value_ConnectClient_get_listenFd_885=ConnectClient_get_listenFd(srClientsTable[(signed long int)l]);
                      signed int return_value_ConnectClient_get_listenFd_886;
                      return_value_ConnectClient_get_listenFd_886=ConnectClient_get_listenFd(srClientsTable[(signed long int)l]);
                      (&allset)->__fds_bits[(signed long int)(return_value_ConnectClient_get_listenFd_885 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectClient_get_listenFd_885 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectClient_get_listenFd_886 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                      signed int return_value_ConnectClient_get_listenFd_887;
                      return_value_ConnectClient_get_listenFd_887=ConnectClient_get_listenFd(srClientsTable[(signed long int)l]);
                      if(!(1 + return_value_ConnectClient_get_listenFd_887 >= maxfdp1))
                        tmp_if_expr_889 = maxfdp1;

                      else
                      {
                        return_value_ConnectClient_get_listenFd_888=ConnectClient_get_listenFd(srClientsTable[(signed long int)l]);
                        tmp_if_expr_889 = return_value_ConnectClient_get_listenFd_888 + 1;
                      }
                      maxfdp1 = tmp_if_expr_889;
                      char *return_value_get_realmname_890;
                      return_value_get_realmname_890=get_realmname(config, j);
                      char *return_value_get_clientname_891;
                      return_value_get_clientname_891=get_clientname(pointer, l);
                      aflog((char)2, (char)8, "realm[%s]: Client[%s]: listenport=%s", return_value_get_realmname_890, return_value_get_clientname_891, (const void *)main__1__17__3__6__7__1__1__2__3__tmp_tab);
                    }

                  }

                  else
                  {
                    char *return_value_get_realmname_893;
                    return_value_get_realmname_893=get_realmname(config, j);
                    aflog((char)2, (char)32, "realm[%s]: client limit EXCEEDED", return_value_get_realmname_893);
                    buff[(signed long int)0] = (unsigned char)12;
                    char return_value_ServerRealm_get_realmType_894;
                    return_value_ServerRealm_get_realmType_894=ServerRealm_get_realmType(pointer);
                    struct anonymous_1 *return_value_ConnectClient_get_sslFd_895;
                    return_value_ConnectClient_get_sslFd_895=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                    SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType_894 | 4 | 8), return_value_ConnectClient_get_sslFd_895, buff, 5);
                    remove_raclient(pointer, k, &allset, &wset, scheduler);
                  }
                }

                else
                {
                  return_value_ConnectClient_get_state_903=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
                  if(numofcon == 0 && (signed int)return_value_ConnectClient_get_state_903 == 3)
                  {
                    char return_value_ServerRealm_get_realmType_897;
                    return_value_ServerRealm_get_realmType_897=ServerRealm_get_realmType(pointer);
                    struct anonymous_1 *return_value_ConnectClient_get_sslFd_898;
                    return_value_ConnectClient_get_sslFd_898=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                    n=SslFd_get_message(return_value_ServerRealm_get_realmType_897, return_value_ConnectClient_get_sslFd_898, buff, length);
                    buff[(signed long int)n] = (unsigned char)0;
                    char *return_value_get_realmname_899;
                    return_value_get_realmname_899=get_realmname(config, j);
                    char *return_value_get_raclientname_900;
                    return_value_get_raclientname_900=get_raclientname(pointer, k);
                    aflog((char)8, (char)8, "realm[%s]: Client[%s] (ra): ID received: %s", return_value_get_realmname_899, return_value_get_raclientname_900, (const void *)buff);
                    ConnectClient_set_sClientId(srRaClientsTable[(signed long int)k], (char *)buff);
                  }

                  else
                  {
                    char *return_value_get_realmname_901;
                    return_value_get_realmname_901=get_realmname(config, j);
                    char *return_value_get_raclientname_902;
                    return_value_get_raclientname_902=get_raclientname(pointer, k);
                    aflog((char)8, (char)64, "realm[%s]: Client[%s] (ra): Wrong password - CLOSING", return_value_get_realmname_901, return_value_get_raclientname_902);
                    remove_raclient(pointer, k, &allset, &wset, scheduler);
                  }
                }
                break;
              }
              case 13:
              {
                return_value_get_realmname_911=get_realmname(config, j);
                return_value_get_raclientname_912=get_raclientname(pointer, k);
                aflog((char)8, (char)64, "realm[%s]: Client[%s] (ra): Wrong message - CLOSING", return_value_get_realmname_911, return_value_get_raclientname_912);
                remove_raclient(pointer, k, &allset, &wset, scheduler);
                break;
              }
              case 14:
              {
                return_value_ConnectClient_get_state_923=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
                if((signed int)return_value_ConnectClient_get_state_923 == 2)
                {
                  return_value_ServerRealm_get_password_921=ServerRealm_get_password(pointer);
                  return_value_ServerRealm_get_password_922=ServerRealm_get_password(pointer);
                  if(numofcon == 256 * (signed int)*return_value_ServerRealm_get_password_921 + (signed int)return_value_ServerRealm_get_password_922[1l])
                  {
                    return_value_ServerRealm_get_password_919=ServerRealm_get_password(pointer);
                    return_value_ServerRealm_get_password_920=ServerRealm_get_password(pointer);
                    if(length == 256 * (signed int)return_value_ServerRealm_get_password_919[2l] + (signed int)return_value_ServerRealm_get_password_920[3l])
                    {
                      char *return_value_get_realmname_913;
                      return_value_get_realmname_913=get_realmname(config, j);
                      char *return_value_get_raclientname_914;
                      return_value_get_raclientname_914=get_raclientname(pointer, k);
                      aflog((char)8, (char)8, "realm[%s]: Client[%s] (ra): NEW remote admin -- pass OK", return_value_get_realmname_913, return_value_get_raclientname_914);
                      ConnectClient_set_state(srRaClientsTable[(signed long int)k], (char)3);
                      ServerRealm_increase_connectedRaClients(pointer);
                      task=ConnectClient_get_task(srRaClientsTable[(signed long int)k]);
                      if(!(task == ((struct anonymous_13 *)NULL)))
                      {
                        TaskScheduler_removeTask(scheduler, task);
                        ConnectClient_set_task(srRaClientsTable[(signed long int)k], (struct anonymous_13 *)(void *)0);
                      }

                      sprintf((char *)&buff[(signed long int)5], "AFSERVER v0.8.4");
                      unsigned long int return_value_strlen_915;
                      return_value_strlen_915=strlen((char *)&buff[(signed long int)5]);
                      n = (signed int)return_value_strlen_915;
                      buff[(signed long int)0] = (unsigned char)14;
                      char return_value_ServerRealm_get_realmType_916;
                      return_value_ServerRealm_get_realmType_916=ServerRealm_get_realmType(pointer);
                      buff[(signed long int)1] = (unsigned char)return_value_ServerRealm_get_realmType_916;
                      buff[(signed long int)2] = (unsigned char)0;
                      buff[(signed long int)3] = (unsigned char)(n >> 8);
                      buff[(signed long int)4] = (unsigned char)n;
                      char return_value_ServerRealm_get_realmType_917;
                      return_value_ServerRealm_get_realmType_917=ServerRealm_get_realmType(pointer);
                      struct anonymous_1 *return_value_ConnectClient_get_sslFd_918;
                      return_value_ConnectClient_get_sslFd_918=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                      SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType_917 | 4 | 8), return_value_ConnectClient_get_sslFd_918, buff, n + 5);
                    }

                  }

                }

                break;
              }
              case 15:
              {
                return_value_ConnectClient_get_state_962=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
                if((signed int)return_value_ConnectClient_get_state_962 == 3)
                {
                  n=serve_admin(config, j, k, buff);
                  if(!(n == 0))
                  {
                    if(n == 1)
                    {
                      char *return_value_get_realmname_924;
                      return_value_get_realmname_924=get_realmname(config, j);
                      char *return_value_get_raclientname_925;
                      return_value_get_raclientname_925=get_raclientname(pointer, k);
                      aflog((char)8, (char)16, "realm[%s]: Client[%s] (ra): remote admin -- closing", return_value_get_realmname_924, return_value_get_raclientname_925);
                      remove_raclient(pointer, k, &allset, &wset, scheduler);
                    }

                    else
                    {
                      i = 0;
                      do
                      {
                        return_value_ServerConfiguration_get_realmsNumber_926=ServerConfiguration_get_realmsNumber(config);
                        if(i >= return_value_ServerConfiguration_get_realmsNumber_926)
                          break;

                        srClientsTable=ServerRealm_get_clientsTable(scRealmsTable[(signed long int)i]);
                        l=get_clientnumber(scRealmsTable[(signed long int)i], n - 2);
                        if(!(l == -1))
                        {
                          char *return_value_get_realmname_927;
                          return_value_get_realmname_927=get_realmname(config, j);
                          char *return_value_get_raclientname_928;
                          return_value_get_raclientname_928=get_raclientname(pointer, k);
                          char *return_value_get_realmname_929;
                          return_value_get_realmname_929=get_realmname(config, i);
                          char *return_value_get_clientname_930;
                          return_value_get_clientname_930=get_clientname(scRealmsTable[(signed long int)i], l);
                          aflog((char)8, (char)16, "realm[%s]: Client[%s] (ra): remote admin: KICKING realm[%s]: Client[%s]", return_value_get_realmname_927, return_value_get_raclientname_928, return_value_get_realmname_929, return_value_get_clientname_930);
                          buff[(signed long int)0] = (unsigned char)4;
                          char return_value_ServerRealm_get_realmType_931;
                          return_value_ServerRealm_get_realmType_931=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
                          struct anonymous_1 *return_value_ConnectClient_get_sslFd_932;
                          return_value_ConnectClient_get_sslFd_932=ConnectClient_get_sslFd(srClientsTable[(signed long int)l]);
                          SslFd_send_message(return_value_ServerRealm_get_realmType_931, return_value_ConnectClient_get_sslFd_932, buff, 5);
                          time(&now);
                          char *return_value_get_realmname_933;
                          return_value_get_realmname_933=get_realmname(config, j);
                          char *return_value_get_clientname_934;
                          return_value_get_clientname_934=get_clientname(scRealmsTable[(signed long int)i], l);
                          char *return_value_ConnectClient_get_nameBuf_935;
                          return_value_ConnectClient_get_nameBuf_935=ConnectClient_get_nameBuf(srClientsTable[(signed long int)l]);
                          char *return_value_ConnectClient_get_portBuf_936;
                          return_value_ConnectClient_get_portBuf_936=ConnectClient_get_portBuf(srClientsTable[(signed long int)l]);
                          signed long int return_value_ConnectClient_get_connectTime_937;
                          return_value_ConnectClient_get_connectTime_937=ConnectClient_get_connectTime(srClientsTable[(signed long int)l]);
                          char *return_value_timeperiod_938;
                          return_value_timeperiod_938=timeperiod(now - return_value_ConnectClient_get_connectTime_937);
                          aflog((char)2, (char)16, "REALM: %s CLIENT: %s IP: %s PORT: %s DURATION: %s", return_value_get_realmname_933, return_value_get_clientname_934, return_value_ConnectClient_get_nameBuf_935, return_value_ConnectClient_get_portBuf_936, return_value_timeperiod_938);
                          char return_value_ServerRealm_get_auditOn_959;
                          return_value_ServerRealm_get_auditOn_959=ServerRealm_get_auditOn(scRealmsTable[(signed long int)i]);
                          if(!(return_value_ServerRealm_get_auditOn_959 == 0))
                            do
                            {
                              return_value_ConnectClient_get_auditList_939=ConnectClient_get_auditList(srClientsTable[(signed long int)l]);
                              return_value_AuditList_get_first_940=AuditList_get_first(return_value_ConnectClient_get_auditList_939);
                              if(return_value_AuditList_get_first_940 == ((struct alnode *)NULL))
                                break;

                              struct auditlist *return_value_ConnectClient_get_auditList_941;
                              return_value_ConnectClient_get_auditList_941=ConnectClient_get_auditList(srClientsTable[(signed long int)l]);
                              struct alnode *return_value_AuditList_get_first_942;
                              return_value_AuditList_get_first_942=AuditList_get_first(return_value_ConnectClient_get_auditList_941);
                              signed int return_value_AuditListNode_get_userId_943;
                              return_value_AuditListNode_get_userId_943=AuditListNode_get_userId(return_value_AuditList_get_first_942);
                              struct auditlist *return_value_ConnectClient_get_auditList_944;
                              return_value_ConnectClient_get_auditList_944=ConnectClient_get_auditList(srClientsTable[(signed long int)l]);
                              struct alnode *return_value_AuditList_get_first_945;
                              return_value_AuditList_get_first_945=AuditList_get_first(return_value_ConnectClient_get_auditList_944);
                              char *return_value_AuditListNode_get_nameBuf_946;
                              return_value_AuditListNode_get_nameBuf_946=AuditListNode_get_nameBuf(return_value_AuditList_get_first_945);
                              struct auditlist *return_value_ConnectClient_get_auditList_947;
                              return_value_ConnectClient_get_auditList_947=ConnectClient_get_auditList(srClientsTable[(signed long int)l]);
                              struct alnode *return_value_AuditList_get_first_948;
                              return_value_AuditList_get_first_948=AuditList_get_first(return_value_ConnectClient_get_auditList_947);
                              char *return_value_AuditListNode_get_portBuf_949;
                              return_value_AuditListNode_get_portBuf_949=AuditListNode_get_portBuf(return_value_AuditList_get_first_948);
                              struct auditlist *return_value_ConnectClient_get_auditList_950;
                              return_value_ConnectClient_get_auditList_950=ConnectClient_get_auditList(srClientsTable[(signed long int)l]);
                              struct alnode *return_value_AuditList_get_first_951;
                              return_value_AuditList_get_first_951=AuditList_get_first(return_value_ConnectClient_get_auditList_950);
                              signed long int *return_value_AuditListNode_get_connectTimep_952;
                              return_value_AuditListNode_get_connectTimep_952=AuditListNode_get_connectTimep(return_value_AuditList_get_first_951);
                              char *return_value_localdate_953;
                              return_value_localdate_953=localdate(return_value_AuditListNode_get_connectTimep_952);
                              struct auditlist *return_value_ConnectClient_get_auditList_954;
                              return_value_ConnectClient_get_auditList_954=ConnectClient_get_auditList(srClientsTable[(signed long int)l]);
                              struct alnode *return_value_AuditList_get_first_955;
                              return_value_AuditList_get_first_955=AuditList_get_first(return_value_ConnectClient_get_auditList_954);
                              signed long int return_value_AuditListNode_get_duration_956;
                              return_value_AuditListNode_get_duration_956=AuditListNode_get_duration(return_value_AuditList_get_first_955);
                              char *return_value_timeperiod_957;
                              return_value_timeperiod_957=timeperiod(return_value_AuditListNode_get_duration_956);
                              aflog((char)2, (char)16, "USERID: %d IP: %s PORT: %s CONNECTED: %s DURATION: %s", return_value_AuditListNode_get_userId_943, return_value_AuditListNode_get_nameBuf_946, return_value_AuditListNode_get_portBuf_949, return_value_localdate_953, return_value_timeperiod_957);
                              struct auditlist *return_value_ConnectClient_get_auditList_958;
                              return_value_ConnectClient_get_auditList_958=ConnectClient_get_auditList(srClientsTable[(signed long int)l]);
                              AuditList_delete_first(return_value_ConnectClient_get_auditList_958);
                            }
                            while((_Bool)1);

                          remove_client(scRealmsTable[(signed long int)i], l, &allset, &wset, scheduler);
                          break;
                        }

                        i = i + 1;
                      }
                      while((_Bool)1);
                    }
                  }

                }

                else
                {
                  char *return_value_get_realmname_960;
                  return_value_get_realmname_960=get_realmname(config, j);
                  char *return_value_get_raclientname_961;
                  return_value_get_raclientname_961=get_raclientname(pointer, k);
                  aflog((char)8, (char)64, "realm[%s]: Client[%s] (ra): remote admin -- security VIOLATION", return_value_get_realmname_960, return_value_get_raclientname_961);
                  remove_raclient(pointer, k, &allset, &wset, scheduler);
                }
                break;
              }
              case 16:
              {
                return_value_get_realmname_963=get_realmname(config, j);
                return_value_get_raclientname_964=get_raclientname(pointer, k);
                aflog((char)8, (char)2, "realm[%s]: Client[%s] (ra): Keep alive packet", return_value_get_realmname_963, return_value_get_raclientname_964);
                break;
              }
              default:
              {
                char *return_value_get_realmname_965;
                return_value_get_realmname_965=get_realmname(config, j);
                char *return_value_get_raclientname_966;
                return_value_get_raclientname_966=get_raclientname(pointer, k);
                aflog((char)8, (char)64, "realm[%s]: Client[%s] (ra): Unrecognized message - CLOSING", return_value_get_realmname_965, return_value_get_raclientname_966);
                remove_raclient(pointer, k, &allset, &wset, scheduler);
              }
            }
          }

        }


      __CPROVER_DUMP_L448:
        ;
        k = k + 1;
      }
      while((_Bool)1);
      l = 0;
      do
      {
        return_value_ServerRealm_get_userClientPairs_972=ServerRealm_get_userClientPairs(pointer);
        if(l >= return_value_ServerRealm_get_userClientPairs_972)
          break;

        signed int return_value_UsrCli_get_manageFd_1036;
        return_value_UsrCli_get_manageFd_1036=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)l]);
        signed int return_value_UsrCli_get_manageFd_1037;
        return_value_UsrCli_get_manageFd_1037=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)l]);
        if(!((rset.__fds_bits[(signed long int)(return_value_UsrCli_get_manageFd_1036 / 8)] & 1l << return_value_UsrCli_get_manageFd_1037 % 8) == 0l))
        {
          char *return_value_get_realmname_973;
          return_value_get_realmname_973=get_realmname(config, j);
          aflog((char)2, (char)4, "realm[%s]: managefd: FD_ISSET", return_value_get_realmname_973);
          len=ServerRealm_get_addressLength(pointer);
          signed int return_value_UsrCli_get_manageFd_974;
          return_value_UsrCli_get_manageFd_974=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)l]);
          char return_value_ServerRealm_get_tunnelType_975;
          return_value_ServerRealm_get_tunnelType_975=ServerRealm_get_tunnelType(pointer);
          struct sockaddr *return_value_ServerRealm_get_clientAddress_976;
          return_value_ServerRealm_get_clientAddress_976=ServerRealm_get_clientAddress(pointer);
          sent=get_new_socket(return_value_UsrCli_get_manageFd_974, return_value_ServerRealm_get_tunnelType_975, return_value_ServerRealm_get_clientAddress_976, &len, &tunneltype);
          if(sent == -1)
          {
            signed int *return_value___errno_location_980;
            return_value___errno_location_980=__errno_location();
            if(*return_value___errno_location_980 == 11)
            {
              char *return_value_get_realmname_977;
              return_value_get_realmname_977=get_realmname(config, j);
              aflog((char)1, (char)4, "realm[%s]: managefd: FD_ISSET --> EAGAIN", return_value_get_realmname_977);
            }

            else
            {
              char *return_value_get_realmname_978;
              return_value_get_realmname_978=get_realmname(config, j);
              signed int *return_value___errno_location_979;
              return_value___errno_location_979=__errno_location();
              aflog((char)1, (char)4, "realm[%s]: managefd: FD_ISSET --> errno=%d", return_value_get_realmname_978, *return_value___errno_location_979);
            }
            break;
          }

          flags=fcntl(sent, 3, 0);
          fcntl(sent, 4, flags | 04000);
          k = 0;
          do
          {
            return_value_ServerRealm_get_clientsLimit_981=ServerRealm_get_clientsLimit(pointer);
            if(k >= return_value_ServerRealm_get_clientsLimit_981)
              break;

            char return_value_ConnectClient_get_state_1006;
            return_value_ConnectClient_get_state_1006=ConnectClient_get_state(srClientsTable[(signed long int)k]);
            if((signed int)return_value_ConnectClient_get_state_1006 == 0)
            {
              signed int return_value_ServerRealm_get_clientsCounter_982;
              return_value_ServerRealm_get_clientsCounter_982=ServerRealm_get_clientsCounter(pointer);
              ConnectClient_set_clientId(srClientsTable[(signed long int)k], return_value_ServerRealm_get_clientsCounter_982);
              ServerRealm_increase_clientsCounter(pointer);
              char *return_value_get_realmname_983;
              return_value_get_realmname_983=get_realmname(config, j);
              char *return_value_get_clientname_984;
              return_value_get_clientname_984=get_clientname(pointer, k);
              aflog((char)2, (char)8, "realm[%s]: new Client[%s]: CONNECTING", return_value_get_realmname_983, return_value_get_clientname_984);
              struct anonymous_1 *return_value_ConnectClient_get_sslFd_985;
              return_value_ConnectClient_get_sslFd_985=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
              SslFd_set_fd(return_value_ConnectClient_get_sslFd_985, sent);
              ConnectClient_set_usrCliPair(srClientsTable[(signed long int)k], l);
              time(&now);
              ConnectClient_set_connectTime(srClientsTable[(signed long int)k], now);
              ConnectClient_set_lastActivity(srClientsTable[(signed long int)k], now);
              ConnectClient_set_tunnelType(srClientsTable[(signed long int)k], tunneltype);
              char *return_value_get_realmname_986;
              return_value_get_realmname_986=get_realmname(config, j);
              char *return_value_get_clientname_987;
              return_value_get_clientname_987=get_clientname(pointer, k);
              struct sockaddr *return_value_ServerRealm_get_clientAddress_988;
              return_value_ServerRealm_get_clientAddress_988=ServerRealm_get_clientAddress(pointer);
              char *return_value_ConnectClient_get_nameBuf_989;
              return_value_ConnectClient_get_nameBuf_989=ConnectClient_get_nameBuf(srClientsTable[(signed long int)k]);
              char *return_value_ConnectClient_get_portBuf_990;
              return_value_ConnectClient_get_portBuf_990=ConnectClient_get_portBuf(srClientsTable[(signed long int)k]);
              char return_value_ServerRealm_get_dnsLookupsOn_991;
              return_value_ServerRealm_get_dnsLookupsOn_991=ServerRealm_get_dnsLookupsOn(pointer);
              char *return_value_sock_ntop_992;
              return_value_sock_ntop_992=sock_ntop(return_value_ServerRealm_get_clientAddress_988, len, return_value_ConnectClient_get_nameBuf_989, return_value_ConnectClient_get_portBuf_990, return_value_ServerRealm_get_dnsLookupsOn_991);
              aflog((char)2, (char)8, "realm[%s]: new Client[%s] IP:%s", return_value_get_realmname_986, return_value_get_clientname_987, return_value_sock_ntop_992);
              struct anonymous_1 *return_value_ConnectClient_get_sslFd_993;
              return_value_ConnectClient_get_sslFd_993=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
              signed int return_value_SslFd_get_fd_994;
              return_value_SslFd_get_fd_994=SslFd_get_fd(return_value_ConnectClient_get_sslFd_993);
              struct anonymous_1 *return_value_ConnectClient_get_sslFd_995;
              return_value_ConnectClient_get_sslFd_995=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
              signed int return_value_SslFd_get_fd_996;
              return_value_SslFd_get_fd_996=SslFd_get_fd(return_value_ConnectClient_get_sslFd_995);
              (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd_994 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd_994 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_SslFd_get_fd_996 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
              struct anonymous_1 *return_value_ConnectClient_get_sslFd_997;
              return_value_ConnectClient_get_sslFd_997=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
              signed int return_value_SslFd_get_fd_998;
              return_value_SslFd_get_fd_998=SslFd_get_fd(return_value_ConnectClient_get_sslFd_997);
              if(!(1 + return_value_SslFd_get_fd_998 >= maxfdp1))
                tmp_if_expr_1001 = maxfdp1;

              else
              {
                return_value_ConnectClient_get_sslFd_999=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                return_value_SslFd_get_fd_1000=SslFd_get_fd(return_value_ConnectClient_get_sslFd_999);
                tmp_if_expr_1001 = return_value_SslFd_get_fd_1000 + 1;
              }
              maxfdp1 = tmp_if_expr_1001;
              ServerRealm_increase_connectedClients(pointer);
              signed int return_value_ServerRealm_get_timeout_1002;
              return_value_ServerRealm_get_timeout_1002=ServerRealm_get_timeout(pointer);
              struct timeval return_value_timeval_create_1003;
              return_value_timeval_create_1003=timeval_create((signed long int)return_value_ServerRealm_get_timeout_1002, (signed long int)0);
              ConnectClient_set_timer(srClientsTable[(signed long int)k], return_value_timeval_create_1003);
              struct timeval *return_value_ConnectClient_get_timerp_1004;
              return_value_ConnectClient_get_timerp_1004=ConnectClient_get_timerp(srClientsTable[(signed long int)k]);
              struct anonymous_25 *return_value_RCTdata_new_1005;
              return_value_RCTdata_new_1005=RCTdata_new(config, j, k, (char)0, (char)0, &allset, &wset);
              task=Task_new(return_value_ConnectClient_get_timerp_1004, RCTfunction, (void *)return_value_RCTdata_new_1005, RCTdata_free);
              ConnectClient_set_task(srClientsTable[(signed long int)k], task);
              TaskScheduler_addTask(scheduler, task);
              ConnectClient_set_state(srClientsTable[(signed long int)k], (char)1);
              break;
            }

            k = k + 1;
          }
          while((_Bool)1);
          signed int return_value_ServerRealm_get_clientsLimit_1035;
          return_value_ServerRealm_get_clientsLimit_1035=ServerRealm_get_clientsLimit(pointer);
          if(k == return_value_ServerRealm_get_clientsLimit_1035)
          {
            k = 0;
            do
            {
              return_value_ServerRealm_get_raClientsLimit_1007=ServerRealm_get_raClientsLimit(pointer);
              if(k >= return_value_ServerRealm_get_raClientsLimit_1007)
                break;

              char return_value_ConnectClient_get_state_1032;
              return_value_ConnectClient_get_state_1032=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
              if((signed int)return_value_ConnectClient_get_state_1032 == 0)
              {
                signed int return_value_ServerRealm_get_clientsCounter_1008;
                return_value_ServerRealm_get_clientsCounter_1008=ServerRealm_get_clientsCounter(pointer);
                ConnectClient_set_clientId(srRaClientsTable[(signed long int)k], return_value_ServerRealm_get_clientsCounter_1008);
                ServerRealm_increase_clientsCounter(pointer);
                char *return_value_get_realmname_1009;
                return_value_get_realmname_1009=get_realmname(config, j);
                char *return_value_get_raclientname_1010;
                return_value_get_raclientname_1010=get_raclientname(pointer, k);
                aflog((char)8, (char)8, "realm[%s]: new Client[%s] (ra): CONNECTING", return_value_get_realmname_1009, return_value_get_raclientname_1010);
                struct anonymous_1 *return_value_ConnectClient_get_sslFd_1011;
                return_value_ConnectClient_get_sslFd_1011=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                SslFd_set_fd(return_value_ConnectClient_get_sslFd_1011, sent);
                ConnectClient_set_usrCliPair(srRaClientsTable[(signed long int)k], l);
                time(&now);
                ConnectClient_set_connectTime(srRaClientsTable[(signed long int)k], now);
                ConnectClient_set_lastActivity(srRaClientsTable[(signed long int)k], now);
                ConnectClient_set_tunnelType(srRaClientsTable[(signed long int)k], tunneltype);
                char *return_value_get_realmname_1012;
                return_value_get_realmname_1012=get_realmname(config, j);
                char *return_value_get_raclientname_1013;
                return_value_get_raclientname_1013=get_raclientname(pointer, k);
                struct sockaddr *return_value_ServerRealm_get_clientAddress_1014;
                return_value_ServerRealm_get_clientAddress_1014=ServerRealm_get_clientAddress(pointer);
                char *return_value_ConnectClient_get_nameBuf_1015;
                return_value_ConnectClient_get_nameBuf_1015=ConnectClient_get_nameBuf(srRaClientsTable[(signed long int)k]);
                char *return_value_ConnectClient_get_portBuf_1016;
                return_value_ConnectClient_get_portBuf_1016=ConnectClient_get_portBuf(srRaClientsTable[(signed long int)k]);
                char return_value_ServerRealm_get_dnsLookupsOn_1017;
                return_value_ServerRealm_get_dnsLookupsOn_1017=ServerRealm_get_dnsLookupsOn(pointer);
                char *return_value_sock_ntop_1018;
                return_value_sock_ntop_1018=sock_ntop(return_value_ServerRealm_get_clientAddress_1014, len, return_value_ConnectClient_get_nameBuf_1015, return_value_ConnectClient_get_portBuf_1016, return_value_ServerRealm_get_dnsLookupsOn_1017);
                aflog((char)8, (char)8, "realm[%s]: new Client[%s] (ra) IP:%s", return_value_get_realmname_1012, return_value_get_raclientname_1013, return_value_sock_ntop_1018);
                struct anonymous_1 *return_value_ConnectClient_get_sslFd_1019;
                return_value_ConnectClient_get_sslFd_1019=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                signed int return_value_SslFd_get_fd_1020;
                return_value_SslFd_get_fd_1020=SslFd_get_fd(return_value_ConnectClient_get_sslFd_1019);
                struct anonymous_1 *return_value_ConnectClient_get_sslFd_1021;
                return_value_ConnectClient_get_sslFd_1021=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                signed int return_value_SslFd_get_fd_1022;
                return_value_SslFd_get_fd_1022=SslFd_get_fd(return_value_ConnectClient_get_sslFd_1021);
                (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd_1020 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd_1020 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_SslFd_get_fd_1022 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                struct anonymous_1 *return_value_ConnectClient_get_sslFd_1023;
                return_value_ConnectClient_get_sslFd_1023=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                signed int return_value_SslFd_get_fd_1024;
                return_value_SslFd_get_fd_1024=SslFd_get_fd(return_value_ConnectClient_get_sslFd_1023);
                if(!(1 + return_value_SslFd_get_fd_1024 >= maxfdp1))
                  tmp_if_expr_1027 = maxfdp1;

                else
                {
                  return_value_ConnectClient_get_sslFd_1025=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                  return_value_SslFd_get_fd_1026=SslFd_get_fd(return_value_ConnectClient_get_sslFd_1025);
                  tmp_if_expr_1027 = return_value_SslFd_get_fd_1026 + 1;
                }
                maxfdp1 = tmp_if_expr_1027;
                ServerRealm_increase_connectedClients(pointer);
                signed int return_value_ServerRealm_get_timeout_1028;
                return_value_ServerRealm_get_timeout_1028=ServerRealm_get_timeout(pointer);
                struct timeval return_value_timeval_create_1029;
                return_value_timeval_create_1029=timeval_create((signed long int)return_value_ServerRealm_get_timeout_1028, (signed long int)0);
                ConnectClient_set_timer(srRaClientsTable[(signed long int)k], return_value_timeval_create_1029);
                struct timeval *return_value_ConnectClient_get_timerp_1030;
                return_value_ConnectClient_get_timerp_1030=ConnectClient_get_timerp(srRaClientsTable[(signed long int)k]);
                struct anonymous_25 *return_value_RCTdata_new_1031;
                return_value_RCTdata_new_1031=RCTdata_new(config, j, k, (char)1, (char)0, &allset, &wset);
                task=Task_new(return_value_ConnectClient_get_timerp_1030, RCTfunction, (void *)return_value_RCTdata_new_1031, RCTdata_free);
                ConnectClient_set_task(srRaClientsTable[(signed long int)k], task);
                TaskScheduler_addTask(scheduler, task);
                ConnectClient_set_state(srRaClientsTable[(signed long int)k], (char)1);
                break;
              }

              k = k + 1;
            }
            while((_Bool)1);
            signed int return_value_ServerRealm_get_raClientsLimit_1034;
            return_value_ServerRealm_get_raClientsLimit_1034=ServerRealm_get_raClientsLimit(pointer);
            if(k == return_value_ServerRealm_get_raClientsLimit_1034)
            {
              char *return_value_get_realmname_1033;
              return_value_get_realmname_1033=get_realmname(config, j);
              aflog((char)(2 | 8), (char)32, "realm[%s]: client limit EXCEEDED", return_value_get_realmname_1033);
              close(sent);
            }

          }

          break;
        }

        l = l + 1;
      }
      while((_Bool)1);
      j = j + 1;
    }
    while((_Bool)1);
  }
  while((_Bool)1);
}

// make_ssl_accept
// file make_ssl_handshake.h line 28
signed int make_ssl_accept(struct anonymous_1 *sf)
{
  signed int result;
  struct ssl_st *return_value_SslFd_get_ssl_2;
  return_value_SslFd_get_ssl_2=SslFd_get_ssl(sf);
  result=SSL_accept(return_value_SslFd_get_ssl_2);
  if(!(result == 1))
  {
    signed int return_value_get_ssl_error_1;
    return_value_get_ssl_error_1=get_ssl_error(sf, "SSL_accept has failed", result);
    return return_value_get_ssl_error_1;
  }

  return 0;
}

// make_ssl_initialize
// file make_ssl_handshake.h line 27
void make_ssl_initialize(struct anonymous_1 *sf)
{
  struct ssl_st *return_value_SslFd_get_ssl_1;
  return_value_SslFd_get_ssl_1=SslFd_get_ssl(sf);
  signed int return_value_SslFd_get_fd_2;
  return_value_SslFd_get_fd_2=SslFd_get_fd(sf);
  signed int return_value_SSL_set_fd_3;
  return_value_SSL_set_fd_3=SSL_set_fd(return_value_SslFd_get_ssl_1, return_value_SslFd_get_fd_2);
  if(!(return_value_SSL_set_fd_3 == 1))
  {
    aflog((char)4, (char)1, "Problem with initializing ssl... exiting");
    exit(1);
  }

}

// myrand
// file http_proxy_functions.c line 42
signed int myrand(signed int down, signed int up)
{
  struct timeval tv;
  if(isseed == 0)
  {
    gettimeofday(&tv, ((struct timezone *)NULL));
    srand((unsigned int)tv.tv_sec);
    isseed = (char)1;
  }

  signed int return_value_rand_1;
  return_value_rand_1=rand();
  return down + return_value_rand_1 % ((up - down) + 1);
}

// mysleep
// file http_proxy_functions.c line 60
void mysleep(double time)
{
  struct timeval tv;
  tv.tv_sec = (signed long int)(signed int)time;
  tv.tv_usec = (signed long int)((signed int)(time * (double)1000000) % 1000000);
  select(0, (struct anonymous_22 *)(void *)0, (struct anonymous_22 *)(void *)0, (struct anonymous_22 *)(void *)0, &tv);
}

// parse_cmd
// file server_remoteadmin.c line 89
static signed int parse_cmd(unsigned char *buff, signed int *ret)
{
  signed int i;
  signed int j;
  signed int state;
  char cmd[31l];
  state = 0;
  j = state;
  i = j;
  newmessage = (char)1;
  for( ; !((signed int)buff[(signed long int)i] == 0); i = i + 1)
  {
    if(state == 1)
    {
      const unsigned short int **return_value___ctype_b_loc_1;
      return_value___ctype_b_loc_1=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)buff[(signed long int)i]]) == 0))
        break;

      else
      {
        if(j == 30)
          return 0;

        cmd[(signed long int)j] = (char)buff[(signed long int)i];
        j = j + 1;
      }
    }

    if(state == 0)
    {
      const unsigned short int **return_value___ctype_b_loc_2;
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
      {
        cmd[(signed long int)j] = (char)buff[(signed long int)i];
        j = 1;
        state = 1;
      }

    }

  }
  const unsigned short int **return_value___ctype_b_loc_3;
  signed int tmp_statement_expression_4;
  signed int tmp_statement_expression_6;
  signed int tmp_statement_expression_8;
  signed int tmp_statement_expression_10;
  signed int tmp_statement_expression_12;
  signed int tmp_statement_expression_14;
  signed int tmp_statement_expression_16;
  signed int tmp_statement_expression_18;
  signed int tmp_statement_expression_20;
  signed int tmp_statement_expression_22;
  signed int tmp_statement_expression_24;
  signed int tmp_statement_expression_26;
  signed int tmp_statement_expression_28;
  if(state == 0)
    return 0;

  else
  {
    do
    {
      return_value___ctype_b_loc_3=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
        break;

      i = i + 1;
    }
    while((_Bool)1);
    if((signed int)buff[(signed long int)i] == 46)
      i = i + 1;

    *ret = i;
    cmd[(signed long int)j] = (char)0;
    unsigned long int parse_cmd__1__5____s1_len;
    unsigned long int parse_cmd__1__5____s2_len;
    signed int return_value___builtin_strcmp_5;
    return_value___builtin_strcmp_5=__builtin_strcmp(cmd, "help");
    tmp_statement_expression_4 = return_value___builtin_strcmp_5;
    if(tmp_statement_expression_4 == 0)
      return 1;

    else
    {
      unsigned long int parse_cmd__1__7____s1_len;
      unsigned long int parse_cmd__1__7____s2_len;
      signed int return_value___builtin_strcmp_7;
      return_value___builtin_strcmp_7=__builtin_strcmp(cmd, "lcmd");
      tmp_statement_expression_6 = return_value___builtin_strcmp_7;
      if(tmp_statement_expression_6 == 0)
        return 2;

      else
      {
        unsigned long int parse_cmd__1__9____s1_len;
        unsigned long int parse_cmd__1__9____s2_len;
        signed int return_value___builtin_strcmp_9;
        return_value___builtin_strcmp_9=__builtin_strcmp(cmd, "info");
        tmp_statement_expression_8 = return_value___builtin_strcmp_9;
        if(tmp_statement_expression_8 == 0)
          return 3;

        else
        {
          unsigned long int parse_cmd__1__11____s1_len;
          unsigned long int parse_cmd__1__11____s2_len;
          signed int return_value___builtin_strcmp_11;
          return_value___builtin_strcmp_11=__builtin_strcmp(cmd, "rshow");
          tmp_statement_expression_10 = return_value___builtin_strcmp_11;
          if(tmp_statement_expression_10 == 0)
            return 4;

          else
          {
            unsigned long int parse_cmd__1__13____s1_len;
            unsigned long int parse_cmd__1__13____s2_len;
            signed int return_value___builtin_strcmp_13;
            return_value___builtin_strcmp_13=__builtin_strcmp(cmd, "cshow");
            tmp_statement_expression_12 = return_value___builtin_strcmp_13;
            if(tmp_statement_expression_12 == 0)
              return 5;

            else
            {
              unsigned long int __s1_len;
              unsigned long int __s2_len;
              signed int return_value___builtin_strcmp_15;
              return_value___builtin_strcmp_15=__builtin_strcmp(cmd, "ushow");
              tmp_statement_expression_14 = return_value___builtin_strcmp_15;
              if(tmp_statement_expression_14 == 0)
                return 6;

              else
              {
                unsigned long int parse_cmd__1__17____s1_len;
                unsigned long int parse_cmd__1__17____s2_len;
                signed int return_value___builtin_strcmp_17;
                return_value___builtin_strcmp_17=__builtin_strcmp(cmd, "quit");
                tmp_statement_expression_16 = return_value___builtin_strcmp_17;
                if(tmp_statement_expression_16 == 0)
                  return 7;

                else
                {
                  unsigned long int parse_cmd__1__19____s1_len;
                  unsigned long int parse_cmd__1__19____s2_len;
                  signed int return_value___builtin_strcmp_19;
                  return_value___builtin_strcmp_19=__builtin_strcmp(cmd, "timeout");
                  tmp_statement_expression_18 = return_value___builtin_strcmp_19;
                  if(tmp_statement_expression_18 == 0)
                    return 8;

                  else
                  {
                    unsigned long int parse_cmd__1__21____s1_len;
                    unsigned long int parse_cmd__1__21____s2_len;
                    signed int return_value___builtin_strcmp_21;
                    return_value___builtin_strcmp_21=__builtin_strcmp(cmd, "audit");
                    tmp_statement_expression_20 = return_value___builtin_strcmp_21;
                    if(tmp_statement_expression_20 == 0)
                      return 9;

                    else
                    {
                      unsigned long int parse_cmd__1__23____s1_len;
                      unsigned long int parse_cmd__1__23____s2_len;
                      signed int return_value___builtin_strcmp_23;
                      return_value___builtin_strcmp_23=__builtin_strcmp(cmd, "dnslookups");
                      tmp_statement_expression_22 = return_value___builtin_strcmp_23;
                      if(tmp_statement_expression_22 == 0)
                        return 10;

                      else
                      {
                        unsigned long int parse_cmd__1__25____s1_len;
                        unsigned long int parse_cmd__1__25____s2_len;
                        signed int return_value___builtin_strcmp_25;
                        return_value___builtin_strcmp_25=__builtin_strcmp(cmd, "dateformat");
                        tmp_statement_expression_24 = return_value___builtin_strcmp_25;
                        if(tmp_statement_expression_24 == 0)
                          return 11;

                        else
                        {
                          unsigned long int parse_cmd__1__27____s1_len;
                          unsigned long int parse_cmd__1__27____s2_len;
                          signed int return_value___builtin_strcmp_27;
                          return_value___builtin_strcmp_27=__builtin_strcmp(cmd, "kuser");
                          tmp_statement_expression_26 = return_value___builtin_strcmp_27;
                          if(tmp_statement_expression_26 == 0)
                            return 12;

                          else
                          {
                            unsigned long int parse_cmd__1__29____s1_len;
                            unsigned long int parse_cmd__1__29____s2_len;
                            signed int return_value___builtin_strcmp_29;
                            return_value___builtin_strcmp_29=__builtin_strcmp(cmd, "kclient");
                            tmp_statement_expression_28 = return_value___builtin_strcmp_29;
                            if(tmp_statement_expression_28 == 0)
                              return 13;

                            else
                              return 0;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// parse_header
// file http_proxy_functions.c line 105
signed int parse_header(struct anonymous_1 *sf, char *tab, struct anonymous_26 *hdr, char https)
{
  signed int n;
  signed int i;
  signed int j;
  signed int state = 0;
  char tmpt[100l];
  if(!(https == 0))
  {
    struct ssl_st *return_value_SslFd_get_ssl_1;
    return_value_SslFd_get_ssl_1=SslFd_get_ssl(sf);
    n=SSL_read(return_value_SslFd_get_ssl_1, (void *)tab, 9000);
  }

  else
  {
    signed int return_value_SslFd_get_fd_2;
    return_value_SslFd_get_fd_2=SslFd_get_fd(sf);
    signed long int return_value_read_3;
    return_value_read_3=read(return_value_SslFd_get_fd_2, (void *)tab, (unsigned long int)9000);
    n = (signed int)return_value_read_3;
  }
  hdr->allreaded = n;
  j = 0;
  i = j;
  memset((void *)tmpt, 0, (unsigned long int)100);
  hdr->ptr = 0;
  hdr->length = 0;
  _Bool tmp_if_expr_13;
  signed int tmp_statement_expression_4;
  signed int tmp_statement_expression_6;
  signed int tmp_statement_expression_8;
  _Bool tmp_if_expr_12;
  signed int tmp_statement_expression_10;
  signed int tmp_statement_expression_14;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_19;
  signed int tmp_statement_expression_17;
  for( ; !(i >= n); i = i + 1)
  {
    if(j == 99)
      return 1;

    switch(state)
    {
      case 0:
      {
        if(!((signed int)tab[(signed long int)i] == 32))
          tmp_if_expr_13 = (signed int)tab[(signed long int)i] != 9 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_13 = (_Bool)0;
        if(tmp_if_expr_13)
        {
          tmpt[(signed long int)j] = tab[(signed long int)i];
          j = j + 1;
        }

        else
        {
          tmpt[(signed long int)j] = (char)0;
          unsigned long int parse_header__1__3__1__2__1____s1_len;
          unsigned long int parse_header__1__3__1__2__1____s2_len;
          signed int return_value___builtin_strcmp_5;
          return_value___builtin_strcmp_5=__builtin_strcmp(tmpt, "GET");
          tmp_statement_expression_4 = return_value___builtin_strcmp_5;
          if(tmp_statement_expression_4 == 0)
          {
            hdr->type = (char)0;
            state = 1;
            break;
          }

          unsigned long int parse_header__1__3__1__2__3____s1_len;
          unsigned long int parse_header__1__3__1__2__3____s2_len;
          signed int return_value___builtin_strcmp_7;
          return_value___builtin_strcmp_7=__builtin_strcmp(tmpt, "POST");
          tmp_statement_expression_6 = return_value___builtin_strcmp_7;
          if(tmp_statement_expression_6 == 0)
          {
            hdr->type = (char)1;
            state = 1;
            break;
          }

          unsigned long int parse_header__1__3__1__2__5____s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp_9;
          return_value___builtin_strcmp_9=__builtin_strcmp(tmpt, "HTTP/1.0");
          tmp_statement_expression_8 = return_value___builtin_strcmp_9;
          if(tmp_statement_expression_8 == 0)
            tmp_if_expr_12 = (_Bool)1;

          else
          {
            unsigned long int parse_header__1__3__1__2__6____s1_len;
            unsigned long int parse_header__1__3__1__2__6____s2_len;
            signed int return_value___builtin_strcmp_11;
            return_value___builtin_strcmp_11=__builtin_strcmp(tmpt, "HTTP/1.1");
            tmp_statement_expression_10 = return_value___builtin_strcmp_11;
            tmp_if_expr_12 = tmp_statement_expression_10 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_12)
          {
            hdr->type = (char)2;
            state = 6;
            break;
          }

          return 1;
        }
        break;
      }
      case 1:
      {
        if(!((signed int)tab[(signed long int)i] == 32))
        {
          if(!((signed int)tab[(signed long int)i] == 9))
          {
            tmpt[(signed long int)0] = tab[(signed long int)i];
            j = 1;
            state = 2;
          }

        }

        break;
      }
      case 2:
      {
        if(!((signed int)tab[(signed long int)i] == 61))
        {
          tmpt[(signed long int)j] = tab[(signed long int)i];
          j = j + 1;
        }

        else
        {
          tmpt[(signed long int)j] = (char)0;
          unsigned long int parse_header__1__3__1__5__1____s1_len;
          unsigned long int parse_header__1__3__1__5__1____s2_len;
          signed int return_value___builtin_strcmp_15;
          return_value___builtin_strcmp_15=__builtin_strcmp(tmpt, "/yahpt.html?id");
          tmp_statement_expression_14 = return_value___builtin_strcmp_15;
          if(!(tmp_statement_expression_14 == 0))
            return 1;

          j = 0;
          state = 3;
        }
        break;
      }
      case 3:
      {
        if(!((signed int)tab[(signed long int)i] == 32))
          tmp_if_expr_16 = (signed int)tab[(signed long int)i] != 9 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_16 = (_Bool)0;
        if(tmp_if_expr_16)
        {
          if(j == 9)
            return 1;

          hdr->id[(signed long int)j] = tab[(signed long int)i];
          j = j + 1;
        }

        else
        {
          if(!(j == 9))
            return 1;

          hdr->id[(signed long int)j] = (char)0;
          state = 4;
        }
        break;
      }
      case 4:
      {
        if((signed int)tab[(signed long int)i] == 10)
          state = 5;

        break;
      }
      case 5:
      {
        if((signed int)tab[(signed long int)i] == 10)
        {
          hdr->ptr = i + 1;
          hdr->length = n - hdr->ptr;
          return 0;
        }

        if(!((signed int)tab[(signed long int)i] == 13))
          state = 4;

        break;
      }
      case 6:
      {
        if(!((signed int)tab[(signed long int)i] == 32))
        {
          if(!((signed int)tab[(signed long int)i] == 9))
          {
            tmpt[(signed long int)0] = tab[(signed long int)i];
            j = 1;
            state = 7;
          }

        }

        break;
      }
      case 7:
      {
        if((signed int)tab[(signed long int)i] == 32)
          tmp_if_expr_19 = (_Bool)1;

        else
          tmp_if_expr_19 = (signed int)tab[(signed long int)i] == 9 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_19)
        {
          tmpt[(signed long int)j] = (char)0;
          unsigned long int __s1_len;
          unsigned long int parse_header__1__3__1__11__1____s2_len;
          signed int return_value___builtin_strcmp_18;
          return_value___builtin_strcmp_18=__builtin_strcmp(tmpt, "200");
          tmp_statement_expression_17 = return_value___builtin_strcmp_18;
          if(!(tmp_statement_expression_17 == 0))
            return 1;

          state = 4;
        }

        else
        {
          tmpt[(signed long int)j] = tab[(signed long int)i];
          j = j + 1;
        }
      }
    }
  }
  return 1;
}

// parse_int
// file server_remoteadmin.c line 38
static signed int parse_int(unsigned char *buff, signed int *ret)
{
  signed int intarg;
  signed int i;
  char guard;
  i=sscanf((char *)&buff[(signed long int)*ret], "%d%c", &intarg, &guard);
  if(i == 1 || i == 2)
  {
    if(i == 1)
      guard = (char)32;

    const unsigned short int **return_value___ctype_b_loc_1;
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)guard]) == 0)
      return -1;

    guard = (char)0;
    i = *ret;
    for( ; !((signed int)buff[(signed long int)i] == 0); i = i + 1)
      if((signed int)guard == 0)
      {
        const unsigned short int **return_value___ctype_b_loc_2;
        return_value___ctype_b_loc_2=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)buff[(signed long int)i]]) == 0))
          guard = (char)1;

      }

      else
      {
        const unsigned short int **return_value___ctype_b_loc_3;
        return_value___ctype_b_loc_3=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
          break;

      }
    if((signed int)buff[(signed long int)i] == 46)
      i = i + 1;

    *ret = i;
    return intarg;
  }

  else
    return -1;
}

// parse_line
// file file.c line 45
signed int parse_line(char *buff, char *tab1, char *tab2)
{
  signed int state;
  signed int i;
  signed int j;
  signed int lastDot;
  j = 0;
  i = j;
  state = i;
  lastDot = -1;
  _Bool tmp_if_expr_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  const unsigned short int **return_value___ctype_b_loc_3;
  const unsigned short int **return_value___ctype_b_loc_4;
  const unsigned short int **return_value___ctype_b_loc_5;
  for( ; !((signed int)buff[(signed long int)i] == 0); i = i + 1)
  {
    if((signed int)buff[(signed long int)i] == 35)
    {
      if(i >= 1)
        tmp_if_expr_1 = (signed int)buff[(signed long int)(i - 1)] == 92 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        j = j - 1;

      else
        break;
    }

    switch(state)
    {
      case 0:
      {
        return_value___ctype_b_loc_2=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
        {
          tab1[(signed long int)j] = buff[(signed long int)i];
          j = 1;
          state = 1;
        }

        break;
      }
      case 1:
      {
        return_value___ctype_b_loc_3=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)buff[(signed long int)i]]) == 0))
        {
          tab1[(signed long int)j] = (char)0;
          state = 2;
          j = 0;
        }

        else
        {
          tab1[(signed long int)j] = buff[(signed long int)i];
          j = j + 1;
        }
        break;
      }
      case 2:
      {
        return_value___ctype_b_loc_4=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
        {
          if(!((signed int)buff[(signed long int)i] == 46))
          {
            tab2[(signed long int)j] = buff[(signed long int)i];
            j = 1;
          }

          state = 3;
        }

        break;
      }
      case 3:
      {
        if((signed int)buff[(signed long int)i] == 46)
          lastDot = j;

        else
        {
          return_value___ctype_b_loc_5=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
            lastDot = -1;

          else
            if(lastDot == -1)
              lastDot = j;

        }
        tab2[(signed long int)j] = buff[(signed long int)i];
        j = j + 1;
      }
    }
  }
  if(!(lastDot == -1))
    tab2[(signed long int)lastDot] = (char)0;

  if(state == 3)
    return 2;

  else
    if(state == 0)
      return 0;

    else
      return 1;
}

// parsefile
// file file.h line 37
struct anonymous_2 * parsefile(char *name, signed int *status)
{
  struct anonymous_2 *cfg;
  struct _IO_FILE *file = (struct _IO_FILE *)(void *)0;
  signed int state;
  signed int i;
  signed int j;
  signed int n;
  signed int listencount;
  signed int managecount;
  signed int temp;
  char buff[256l];
  char helpbuf1[256l];
  char helpbuf2[256l];
  char *tmpbuf;
  unsigned char pass[4l] = { (unsigned char)1, (unsigned char)2, (unsigned char)3, (unsigned char)4 };
  *status = 1;
  memset((void *)buff, 0, (unsigned long int)256);
  cfg=ServerConfiguration_new();
  if(cfg == ((struct anonymous_2 *)NULL))
  {
    printf("Can't allocate memory for server configuration... exiting\n");
    exit(1);
  }

  state = 1;
  file=fopen(name, "r");
  char *return_value_fgets_1;
  signed int tmp_statement_expression_3;
  signed int return_value_ServerConfiguration_get_realmsNumber_8;
  char *return_value_fgets_12;
  signed int tmp_statement_expression_31;
  signed int tmp_statement_expression_26;
  _Bool tmp_if_expr_30;
  signed int tmp_statement_expression_28;
  signed int tmp_statement_expression_21;
  _Bool tmp_if_expr_25;
  signed int tmp_statement_expression_23;
  signed int return_value_ServerConfiguration_get_realmsNumber_33;
  struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_40;
  signed int return_value_ServerRealm_get_userClientPairs_41;
  char *return_value_fgets_46;
  signed int tmp_statement_expression_107;
  signed int return_value_ServerConfiguration_get_realmsNumber_106;
  signed int tmp_statement_expression_104;
  signed int tmp_statement_expression_102;
  signed int tmp_statement_expression_100;
  signed int tmp_statement_expression_98;
  signed int tmp_statement_expression_96;
  signed int tmp_statement_expression_94;
  signed int tmp_statement_expression_92;
  signed int tmp_statement_expression_90;
  signed int tmp_statement_expression_210;
  signed int tmp_statement_expression_205;
  _Bool tmp_if_expr_209;
  signed int tmp_statement_expression_207;
  signed int tmp_statement_expression_203;
  signed int tmp_statement_expression_201;
  signed int tmp_statement_expression_196;
  _Bool tmp_if_expr_200;
  signed int tmp_statement_expression_198;
  signed int tmp_statement_expression_194;
  signed int tmp_statement_expression_192;
  signed int return_value_ServerConfiguration_get_realmsNumber_191;
  signed int tmp_statement_expression_189;
  signed int tmp_statement_expression_184;
  _Bool tmp_if_expr_188;
  signed int tmp_statement_expression_186;
  signed int tmp_statement_expression_182;
  signed int tmp_statement_expression_177;
  _Bool tmp_if_expr_181;
  signed int tmp_statement_expression_179;
  signed int tmp_statement_expression_175;
  signed int tmp_statement_expression_173;
  signed int tmp_statement_expression_171;
  signed int tmp_statement_expression_169;
  signed int tmp_statement_expression_167;
  signed int tmp_statement_expression_165;
  signed int tmp_statement_expression_163;
  signed int tmp_statement_expression_161;
  signed int tmp_statement_expression_159;
  signed int tmp_statement_expression_157;
  if(file == ((struct _IO_FILE *)NULL))
    return cfg;

  else
  {
    do
    {
      return_value_fgets_1=fgets(buff, 256, file);
      if(return_value_fgets_1 == ((char *)NULL))
        break;

      helpbuf1[(signed long int)0] = (char)0;
      parse_line(buff, helpbuf1, helpbuf2);
      unsigned long int parsefile__1__3__1____s1_len;
      unsigned long int parsefile__1__3__1____s2_len;
      signed int return_value___builtin_strcmp_4;
      return_value___builtin_strcmp_4=__builtin_strcmp(helpbuf1, "realm");
      tmp_statement_expression_3 = return_value___builtin_strcmp_4;
      if(tmp_statement_expression_3 == 0)
      {
        signed int return_value_ServerConfiguration_get_realmsNumber_2;
        return_value_ServerConfiguration_get_realmsNumber_2=ServerConfiguration_get_realmsNumber(cfg);
        ServerConfiguration_set_realmsNumber(cfg, return_value_ServerConfiguration_get_realmsNumber_2 + 1);
      }

    }
    while((_Bool)1);
    rewind(file);
    signed int return_value_ServerConfiguration_get_realmsNumber_5;
    return_value_ServerConfiguration_get_realmsNumber_5=ServerConfiguration_get_realmsNumber(cfg);
    void *return_value_calloc_6;
    return_value_calloc_6=calloc((unsigned long int)return_value_ServerConfiguration_get_realmsNumber_5, sizeof(struct anonymous_5 *) /*8ul*/ );
    ServerConfiguration_set_realmsTable(cfg, (struct anonymous_5 **)return_value_calloc_6);
    struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_7;
    return_value_ServerConfiguration_get_realmsTable_7=ServerConfiguration_get_realmsTable(cfg);
    if(return_value_ServerConfiguration_get_realmsTable_7 == ((struct anonymous_5 **)NULL))
    {
      printf("Can't allocate memory for ServerRealm* table... exiting\n");
      exit(1);
    }

    i = 0;
    do
    {
      return_value_ServerConfiguration_get_realmsNumber_8=ServerConfiguration_get_realmsNumber(cfg);
      if(i >= return_value_ServerConfiguration_get_realmsNumber_8)
        break;

      struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_9;
      return_value_ServerConfiguration_get_realmsTable_9=ServerConfiguration_get_realmsTable(cfg);
      return_value_ServerConfiguration_get_realmsTable_9[(signed long int)i]=ServerRealm_new();
      struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_10;
      return_value_ServerConfiguration_get_realmsTable_10=ServerConfiguration_get_realmsTable(cfg);
      if(return_value_ServerConfiguration_get_realmsTable_10[(signed long int)i] == ((struct anonymous_5 *)NULL))
      {
        printf("Problem with allocating memory for ServerRealm structure... exiting");
        exit(1);
      }

      struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_11;
      return_value_ServerConfiguration_get_realmsTable_11=ServerConfiguration_get_realmsTable(cfg);
      ServerRealm_set_password(return_value_ServerConfiguration_get_realmsTable_11[(signed long int)i], pass);
      i = i + 1;
    }
    while((_Bool)1);
    ServerConfiguration_set_realmsNumber(cfg, 0);
    *status = 0;
    managecount = 0;
    listencount = managecount;
    do
    {
      return_value_fgets_12=fgets(buff, 256, file);
      if(return_value_fgets_12 == ((char *)NULL))
        break;

      *status = *status + 1;
      state=parse_line(buff, helpbuf1, helpbuf2);
      if(!(state == 0))
      {
        unsigned long int parsefile__1__6__1__1____s1_len;
        unsigned long int parsefile__1__6__1__1____s2_len;
        signed int return_value___builtin_strcmp_32;
        return_value___builtin_strcmp_32=__builtin_strcmp(helpbuf1, "realm");
        tmp_statement_expression_31 = return_value___builtin_strcmp_32;
        if(tmp_statement_expression_31 == 0)
        {
          signed int return_value_ServerConfiguration_get_realmsNumber_13;
          return_value_ServerConfiguration_get_realmsNumber_13=ServerConfiguration_get_realmsNumber(cfg);
          ServerConfiguration_set_realmsNumber(cfg, return_value_ServerConfiguration_get_realmsNumber_13 + 1);
          if(!(listencount == managecount))
            return cfg;

          managecount = 0;
          listencount = managecount;
        }

        else
        {
          unsigned long int parsefile__1__6__1__3____s1_len;
          unsigned long int parsefile__1__6__1__3____s2_len;
          signed int return_value___builtin_strcmp_27;
          return_value___builtin_strcmp_27=__builtin_strcmp(helpbuf1, "listen");
          tmp_statement_expression_26 = return_value___builtin_strcmp_27;
          if(tmp_statement_expression_26 == 0)
            tmp_if_expr_30 = (_Bool)1;

          else
          {
            unsigned long int parsefile__1__6__1__4____s1_len;
            unsigned long int parsefile__1__6__1__4____s2_len;
            signed int return_value___builtin_strcmp_29;
            return_value___builtin_strcmp_29=__builtin_strcmp(helpbuf1, "listenport");
            tmp_statement_expression_28 = return_value___builtin_strcmp_29;
            tmp_if_expr_30 = tmp_statement_expression_28 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_30)
          {
            signed int return_value_ServerConfiguration_get_realmsNumber_14;
            return_value_ServerConfiguration_get_realmsNumber_14=ServerConfiguration_get_realmsNumber(cfg);
            if(return_value_ServerConfiguration_get_realmsNumber_14 == 0)
              return cfg;

            struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_15;
            return_value_ServerConfiguration_get_realmsTable_15=ServerConfiguration_get_realmsTable(cfg);
            signed int return_value_ServerConfiguration_get_realmsNumber_16;
            return_value_ServerConfiguration_get_realmsNumber_16=ServerConfiguration_get_realmsNumber(cfg);
            struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_17;
            return_value_ServerConfiguration_get_realmsTable_17=ServerConfiguration_get_realmsTable(cfg);
            signed int return_value_ServerConfiguration_get_realmsNumber_18;
            return_value_ServerConfiguration_get_realmsNumber_18=ServerConfiguration_get_realmsNumber(cfg);
            signed int return_value_ServerRealm_get_userClientPairs_19;
            return_value_ServerRealm_get_userClientPairs_19=ServerRealm_get_userClientPairs(return_value_ServerConfiguration_get_realmsTable_17[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_18 - 1)]);
            ServerRealm_set_userClientPairs(return_value_ServerConfiguration_get_realmsTable_15[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_16 - 1)], return_value_ServerRealm_get_userClientPairs_19 + 1);
            listencount = listencount + 1;
          }

          else
          {
            unsigned long int parsefile__1__6__1__6____s1_len;
            unsigned long int parsefile__1__6__1__6____s2_len;
            signed int return_value___builtin_strcmp_22;
            return_value___builtin_strcmp_22=__builtin_strcmp(helpbuf1, "manage");
            tmp_statement_expression_21 = return_value___builtin_strcmp_22;
            if(tmp_statement_expression_21 == 0)
              tmp_if_expr_25 = (_Bool)1;

            else
            {
              unsigned long int parsefile__1__6__1__7____s1_len;
              unsigned long int parsefile__1__6__1__7____s2_len;
              signed int return_value___builtin_strcmp_24;
              return_value___builtin_strcmp_24=__builtin_strcmp(helpbuf1, "manageport");
              tmp_statement_expression_23 = return_value___builtin_strcmp_24;
              tmp_if_expr_25 = tmp_statement_expression_23 == 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_25)
            {
              signed int return_value_ServerConfiguration_get_realmsNumber_20;
              return_value_ServerConfiguration_get_realmsNumber_20=ServerConfiguration_get_realmsNumber(cfg);
              if(return_value_ServerConfiguration_get_realmsNumber_20 == 0)
                return cfg;

              managecount = managecount + 1;
            }

          }
        }
      }

    }
    while((_Bool)1);
    rewind(file);
    if(!(listencount == managecount))
      return cfg;

    else
    {
      i = 0;
      do
      {
        return_value_ServerConfiguration_get_realmsNumber_33=ServerConfiguration_get_realmsNumber(cfg);
        if(i >= return_value_ServerConfiguration_get_realmsNumber_33)
          break;

        struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_34;
        return_value_ServerConfiguration_get_realmsTable_34=ServerConfiguration_get_realmsTable(cfg);
        struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_35;
        return_value_ServerConfiguration_get_realmsTable_35=ServerConfiguration_get_realmsTable(cfg);
        signed int return_value_ServerRealm_get_userClientPairs_36;
        return_value_ServerRealm_get_userClientPairs_36=ServerRealm_get_userClientPairs(return_value_ServerConfiguration_get_realmsTable_35[(signed long int)i]);
        void *return_value_calloc_37;
        return_value_calloc_37=calloc((unsigned long int)return_value_ServerRealm_get_userClientPairs_36, sizeof(struct anonymous_7 *) /*8ul*/ );
        ServerRealm_set_usersClientsTable(return_value_ServerConfiguration_get_realmsTable_34[(signed long int)i], (struct anonymous_7 **)return_value_calloc_37);
        struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_38;
        return_value_ServerConfiguration_get_realmsTable_38=ServerConfiguration_get_realmsTable(cfg);
        struct anonymous_7 **return_value_ServerRealm_get_usersClientsTable_39;
        return_value_ServerRealm_get_usersClientsTable_39=ServerRealm_get_usersClientsTable(return_value_ServerConfiguration_get_realmsTable_38[(signed long int)i]);
        if(return_value_ServerRealm_get_usersClientsTable_39 == ((struct anonymous_7 **)NULL))
        {
          printf("Problem with allocating memory for UsrCli* table... exiting");
          return cfg;
        }

        j = 0;
        do
        {
          return_value_ServerConfiguration_get_realmsTable_40=ServerConfiguration_get_realmsTable(cfg);
          return_value_ServerRealm_get_userClientPairs_41=ServerRealm_get_userClientPairs(return_value_ServerConfiguration_get_realmsTable_40[(signed long int)i]);
          if(j >= return_value_ServerRealm_get_userClientPairs_41)
            break;

          struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_42;
          return_value_ServerConfiguration_get_realmsTable_42=ServerConfiguration_get_realmsTable(cfg);
          struct anonymous_7 **return_value_ServerRealm_get_usersClientsTable_43;
          return_value_ServerRealm_get_usersClientsTable_43=ServerRealm_get_usersClientsTable(return_value_ServerConfiguration_get_realmsTable_42[(signed long int)i]);
          return_value_ServerRealm_get_usersClientsTable_43[(signed long int)j]=UsrCli_new();
          struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_44;
          return_value_ServerConfiguration_get_realmsTable_44=ServerConfiguration_get_realmsTable(cfg);
          struct anonymous_7 **return_value_ServerRealm_get_usersClientsTable_45;
          return_value_ServerRealm_get_usersClientsTable_45=ServerRealm_get_usersClientsTable(return_value_ServerConfiguration_get_realmsTable_44[(signed long int)i]);
          if(return_value_ServerRealm_get_usersClientsTable_45[(signed long int)j] == ((struct anonymous_7 *)NULL))
          {
            printf("Problem with allocating memory for UsrCli structure... exiting");
            return cfg;
          }

          j = j + 1;
        }
        while((_Bool)1);
        i = i + 1;
      }
      while((_Bool)1);
      ServerConfiguration_set_realmsNumber(cfg, 0);
      *status = 0;
      do
      {
        return_value_fgets_46=fgets(buff, 256, file);
        if(return_value_fgets_46 == ((char *)NULL))
          break;

        *status = *status + 1;
        state=parse_line(buff, helpbuf1, helpbuf2);
        if((signed int)helpbuf1[0l] == 35)
          memset((void *)buff, 0, (unsigned long int)256);

        else
        {
          if(state == 1)
          {
            unsigned long int parsefile__1__9__2__1____s1_len;
            unsigned long int parsefile__1__9__2__1____s2_len;
            signed int return_value___builtin_strcmp_108;
            return_value___builtin_strcmp_108=__builtin_strcmp(helpbuf1, "realm");
            tmp_statement_expression_107 = return_value___builtin_strcmp_108;
            if(tmp_statement_expression_107 == 0)
            {
              signed int return_value_ServerConfiguration_get_realmsNumber_47;
              return_value_ServerConfiguration_get_realmsNumber_47=ServerConfiguration_get_realmsNumber(cfg);
              ServerConfiguration_set_realmsNumber(cfg, return_value_ServerConfiguration_get_realmsNumber_47 + 1);
              struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_48;
              return_value_ServerConfiguration_get_realmsTable_48=ServerConfiguration_get_realmsTable(cfg);
              signed int return_value_ServerConfiguration_get_realmsNumber_49;
              return_value_ServerConfiguration_get_realmsNumber_49=ServerConfiguration_get_realmsNumber(cfg);
              char return_value_ServerRealm_get_realmType_50;
              return_value_ServerRealm_get_realmType_50=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable_48[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_49 - 1)]);
              temp = (signed int)return_value_ServerRealm_get_realmType_50;
              temp = temp | 4;
              temp = temp | 8;
              temp = temp | 64;
              struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_51;
              return_value_ServerConfiguration_get_realmsTable_51=ServerConfiguration_get_realmsTable(cfg);
              signed int return_value_ServerConfiguration_get_realmsNumber_52;
              return_value_ServerConfiguration_get_realmsNumber_52=ServerConfiguration_get_realmsNumber(cfg);
              ServerRealm_set_realmType(return_value_ServerConfiguration_get_realmsTable_51[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_52 - 1)], (char)temp);
              managecount = 0;
              listencount = managecount;
            }

            else
            {
              return_value_ServerConfiguration_get_realmsNumber_106=ServerConfiguration_get_realmsNumber(cfg);
              if(return_value_ServerConfiguration_get_realmsNumber_106 == 0)
                return cfg;

              else
              {
                unsigned long int parsefile__1__9__2__4____s1_len;
                unsigned long int parsefile__1__9__2__4____s2_len;
                signed int return_value___builtin_strcmp_105;
                return_value___builtin_strcmp_105=__builtin_strcmp(helpbuf1, "nossl");
                tmp_statement_expression_104 = return_value___builtin_strcmp_105;
                if(tmp_statement_expression_104 == 0)
                {
                  struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_53;
                  return_value_ServerConfiguration_get_realmsTable_53=ServerConfiguration_get_realmsTable(cfg);
                  signed int return_value_ServerConfiguration_get_realmsNumber_54;
                  return_value_ServerConfiguration_get_realmsNumber_54=ServerConfiguration_get_realmsNumber(cfg);
                  char return_value_ServerRealm_get_realmType_55;
                  return_value_ServerRealm_get_realmType_55=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable_53[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_54 - 1)]);
                  temp = (signed int)return_value_ServerRealm_get_realmType_55;
                  temp = temp & ~4;
                  struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_56;
                  return_value_ServerConfiguration_get_realmsTable_56=ServerConfiguration_get_realmsTable(cfg);
                  signed int return_value_ServerConfiguration_get_realmsNumber_57;
                  return_value_ServerConfiguration_get_realmsNumber_57=ServerConfiguration_get_realmsNumber(cfg);
                  ServerRealm_set_realmType(return_value_ServerConfiguration_get_realmsTable_56[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_57 - 1)], (char)temp);
                }

                else
                {
                  unsigned long int parsefile__1__9__2__6____s1_len;
                  unsigned long int parsefile__1__9__2__6____s2_len;
                  signed int return_value___builtin_strcmp_103;
                  return_value___builtin_strcmp_103=__builtin_strcmp(helpbuf1, "nozlib");
                  tmp_statement_expression_102 = return_value___builtin_strcmp_103;
                  if(tmp_statement_expression_102 == 0)
                  {
                    struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_58;
                    return_value_ServerConfiguration_get_realmsTable_58=ServerConfiguration_get_realmsTable(cfg);
                    signed int return_value_ServerConfiguration_get_realmsNumber_59;
                    return_value_ServerConfiguration_get_realmsNumber_59=ServerConfiguration_get_realmsNumber(cfg);
                    char return_value_ServerRealm_get_realmType_60;
                    return_value_ServerRealm_get_realmType_60=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable_58[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_59 - 1)]);
                    temp = (signed int)return_value_ServerRealm_get_realmType_60;
                    temp = temp & ~8;
                    struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_61;
                    return_value_ServerConfiguration_get_realmsTable_61=ServerConfiguration_get_realmsTable(cfg);
                    signed int return_value_ServerConfiguration_get_realmsNumber_62;
                    return_value_ServerConfiguration_get_realmsNumber_62=ServerConfiguration_get_realmsNumber(cfg);
                    ServerRealm_set_realmType(return_value_ServerConfiguration_get_realmsTable_61[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_62 - 1)], (char)temp);
                  }

                  else
                  {
                    unsigned long int parsefile__1__9__2__8____s1_len;
                    unsigned long int parsefile__1__9__2__8____s2_len;
                    signed int return_value___builtin_strcmp_101;
                    return_value___builtin_strcmp_101=__builtin_strcmp(helpbuf1, "baseport");
                    tmp_statement_expression_100 = return_value___builtin_strcmp_101;
                    if(tmp_statement_expression_100 == 0)
                    {
                      struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_63;
                      return_value_ServerConfiguration_get_realmsTable_63=ServerConfiguration_get_realmsTable(cfg);
                      signed int return_value_ServerConfiguration_get_realmsNumber_64;
                      return_value_ServerConfiguration_get_realmsNumber_64=ServerConfiguration_get_realmsNumber(cfg);
                      ServerRealm_set_basePortOn(return_value_ServerConfiguration_get_realmsTable_63[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_64 - 1)], (char)1);
                    }

                    else
                    {
                      unsigned long int parsefile__1__9__2__10____s1_len;
                      unsigned long int parsefile__1__9__2__10____s2_len;
                      signed int return_value___builtin_strcmp_99;
                      return_value___builtin_strcmp_99=__builtin_strcmp(helpbuf1, "audit");
                      tmp_statement_expression_98 = return_value___builtin_strcmp_99;
                      if(tmp_statement_expression_98 == 0)
                      {
                        struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_65;
                        return_value_ServerConfiguration_get_realmsTable_65=ServerConfiguration_get_realmsTable(cfg);
                        signed int return_value_ServerConfiguration_get_realmsNumber_66;
                        return_value_ServerConfiguration_get_realmsNumber_66=ServerConfiguration_get_realmsNumber(cfg);
                        ServerRealm_set_auditOn(return_value_ServerConfiguration_get_realmsTable_65[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_66 - 1)], (char)1);
                      }

                      else
                      {
                        unsigned long int parsefile__1__9__2__12____s1_len;
                        unsigned long int parsefile__1__9__2__12____s2_len;
                        signed int return_value___builtin_strcmp_97;
                        return_value___builtin_strcmp_97=__builtin_strcmp(helpbuf1, "dnslookups");
                        tmp_statement_expression_96 = return_value___builtin_strcmp_97;
                        if(tmp_statement_expression_96 == 0)
                        {
                          struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_67;
                          return_value_ServerConfiguration_get_realmsTable_67=ServerConfiguration_get_realmsTable(cfg);
                          signed int return_value_ServerConfiguration_get_realmsNumber_68;
                          return_value_ServerConfiguration_get_realmsNumber_68=ServerConfiguration_get_realmsNumber(cfg);
                          ServerRealm_set_dnsLookupsOn(return_value_ServerConfiguration_get_realmsTable_67[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_68 - 1)], (char)1);
                        }

                        else
                        {
                          unsigned long int parsefile__1__9__2__14____s1_len;
                          unsigned long int parsefile__1__9__2__14____s2_len;
                          signed int return_value___builtin_strcmp_95;
                          return_value___builtin_strcmp_95=__builtin_strcmp(helpbuf1, "enableproxy");
                          tmp_statement_expression_94 = return_value___builtin_strcmp_95;
                          if(tmp_statement_expression_94 == 0)
                          {
                            struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_71;
                            return_value_ServerConfiguration_get_realmsTable_71=ServerConfiguration_get_realmsTable(cfg);
                            signed int return_value_ServerConfiguration_get_realmsNumber_72;
                            return_value_ServerConfiguration_get_realmsNumber_72=ServerConfiguration_get_realmsNumber(cfg);
                            char return_value_ServerRealm_get_tunnelType_73;
                            return_value_ServerRealm_get_tunnelType_73=ServerRealm_get_tunnelType(return_value_ServerConfiguration_get_realmsTable_71[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_72 - 1)]);
                            if((signed int)return_value_ServerRealm_get_tunnelType_73 == 0)
                            {
                              struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_69;
                              return_value_ServerConfiguration_get_realmsTable_69=ServerConfiguration_get_realmsTable(cfg);
                              signed int return_value_ServerConfiguration_get_realmsNumber_70;
                              return_value_ServerConfiguration_get_realmsNumber_70=ServerConfiguration_get_realmsNumber(cfg);
                              ServerRealm_set_tunnelType(return_value_ServerConfiguration_get_realmsTable_69[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_70 - 1)], (char)1);
                            }

                            else
                              return cfg;
                          }

                          else
                          {
                            unsigned long int parsefile__1__9__2__16____s1_len;
                            unsigned long int parsefile__1__9__2__16____s2_len;
                            signed int return_value___builtin_strcmp_93;
                            return_value___builtin_strcmp_93=__builtin_strcmp(helpbuf1, "ipv4");
                            tmp_statement_expression_92 = return_value___builtin_strcmp_93;
                            if(tmp_statement_expression_92 == 0)
                            {
                              struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_79;
                              return_value_ServerConfiguration_get_realmsTable_79=ServerConfiguration_get_realmsTable(cfg);
                              signed int return_value_ServerConfiguration_get_realmsNumber_80;
                              return_value_ServerConfiguration_get_realmsNumber_80=ServerConfiguration_get_realmsNumber(cfg);
                              char return_value_ServerRealm_get_realmType_81;
                              return_value_ServerRealm_get_realmType_81=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable_79[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_80 - 1)]);
                              if((48 & (signed int)return_value_ServerRealm_get_realmType_81) == 0)
                              {
                                struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_74;
                                return_value_ServerConfiguration_get_realmsTable_74=ServerConfiguration_get_realmsTable(cfg);
                                signed int return_value_ServerConfiguration_get_realmsNumber_75;
                                return_value_ServerConfiguration_get_realmsNumber_75=ServerConfiguration_get_realmsNumber(cfg);
                                char return_value_ServerRealm_get_realmType_76;
                                return_value_ServerRealm_get_realmType_76=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable_74[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_75 - 1)]);
                                temp = (signed int)return_value_ServerRealm_get_realmType_76;
                                temp = temp | 16;
                                struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_77;
                                return_value_ServerConfiguration_get_realmsTable_77=ServerConfiguration_get_realmsTable(cfg);
                                signed int return_value_ServerConfiguration_get_realmsNumber_78;
                                return_value_ServerConfiguration_get_realmsNumber_78=ServerConfiguration_get_realmsNumber(cfg);
                                ServerRealm_set_realmType(return_value_ServerConfiguration_get_realmsTable_77[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_78 - 1)], (char)temp);
                              }

                              else
                                return cfg;
                            }

                            else
                            {
                              unsigned long int parsefile__1__9__2__18____s1_len;
                              unsigned long int parsefile__1__9__2__18____s2_len;
                              signed int return_value___builtin_strcmp_91;
                              return_value___builtin_strcmp_91=__builtin_strcmp(helpbuf1, "ipv6");
                              tmp_statement_expression_90 = return_value___builtin_strcmp_91;
                              if(tmp_statement_expression_90 == 0)
                              {
                                struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_87;
                                return_value_ServerConfiguration_get_realmsTable_87=ServerConfiguration_get_realmsTable(cfg);
                                signed int return_value_ServerConfiguration_get_realmsNumber_88;
                                return_value_ServerConfiguration_get_realmsNumber_88=ServerConfiguration_get_realmsNumber(cfg);
                                char return_value_ServerRealm_get_realmType_89;
                                return_value_ServerRealm_get_realmType_89=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable_87[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_88 - 1)]);
                                if((48 & (signed int)return_value_ServerRealm_get_realmType_89) == 0)
                                {
                                  struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_82;
                                  return_value_ServerConfiguration_get_realmsTable_82=ServerConfiguration_get_realmsTable(cfg);
                                  signed int return_value_ServerConfiguration_get_realmsNumber_83;
                                  return_value_ServerConfiguration_get_realmsNumber_83=ServerConfiguration_get_realmsNumber(cfg);
                                  char return_value_ServerRealm_get_realmType_84;
                                  return_value_ServerRealm_get_realmType_84=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable_82[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_83 - 1)]);
                                  temp = (signed int)return_value_ServerRealm_get_realmType_84;
                                  temp = temp | 32;
                                  struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_85;
                                  return_value_ServerConfiguration_get_realmsTable_85=ServerConfiguration_get_realmsTable(cfg);
                                  signed int return_value_ServerConfiguration_get_realmsNumber_86;
                                  return_value_ServerConfiguration_get_realmsNumber_86=ServerConfiguration_get_realmsNumber(cfg);
                                  ServerRealm_set_realmType(return_value_ServerConfiguration_get_realmsTable_85[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_86 - 1)], (char)temp);
                                }

                                else
                                  return cfg;
                              }

                              else
                                return cfg;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          else
            if(state == 2)
            {
              unsigned long int parsefile__1__9__3__1____s1_len;
              unsigned long int parsefile__1__9__3__1____s2_len;
              signed int return_value___builtin_strcmp_211;
              return_value___builtin_strcmp_211=__builtin_strcmp(helpbuf1, "realm");
              tmp_statement_expression_210 = return_value___builtin_strcmp_211;
              if(tmp_statement_expression_210 == 0)
              {
                signed int return_value_ServerConfiguration_get_realmsNumber_109;
                return_value_ServerConfiguration_get_realmsNumber_109=ServerConfiguration_get_realmsNumber(cfg);
                ServerConfiguration_set_realmsNumber(cfg, return_value_ServerConfiguration_get_realmsNumber_109 + 1);
                struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_110;
                return_value_ServerConfiguration_get_realmsTable_110=ServerConfiguration_get_realmsTable(cfg);
                signed int return_value_ServerConfiguration_get_realmsNumber_111;
                return_value_ServerConfiguration_get_realmsNumber_111=ServerConfiguration_get_realmsNumber(cfg);
                char return_value_ServerRealm_get_realmType_112;
                return_value_ServerRealm_get_realmType_112=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable_110[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_111 - 1)]);
                temp = (signed int)return_value_ServerRealm_get_realmType_112;
                temp = temp | 4;
                temp = temp | 8;
                temp = temp | 64;
                struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_113;
                return_value_ServerConfiguration_get_realmsTable_113=ServerConfiguration_get_realmsTable(cfg);
                signed int return_value_ServerConfiguration_get_realmsNumber_114;
                return_value_ServerConfiguration_get_realmsNumber_114=ServerConfiguration_get_realmsNumber(cfg);
                ServerRealm_set_realmType(return_value_ServerConfiguration_get_realmsTable_113[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_114 - 1)], (char)temp);
                managecount = 0;
                listencount = managecount;
                struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_115;
                return_value_ServerConfiguration_get_realmsTable_115=ServerConfiguration_get_realmsTable(cfg);
                signed int return_value_ServerConfiguration_get_realmsNumber_116;
                return_value_ServerConfiguration_get_realmsNumber_116=ServerConfiguration_get_realmsNumber(cfg);
                ServerRealm_set_realmName(return_value_ServerConfiguration_get_realmsTable_115[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_116 - 1)], helpbuf2);
              }

              else
              {
                unsigned long int parsefile__1__9__3__3____s1_len;
                unsigned long int parsefile__1__9__3__3____s2_len;
                signed int return_value___builtin_strcmp_206;
                return_value___builtin_strcmp_206=__builtin_strcmp(helpbuf1, "certificate");
                tmp_statement_expression_205 = return_value___builtin_strcmp_206;
                if(tmp_statement_expression_205 == 0)
                  tmp_if_expr_209 = (_Bool)1;

                else
                {
                  unsigned long int parsefile__1__9__3__4____s1_len;
                  unsigned long int parsefile__1__9__3__4____s2_len;
                  signed int return_value___builtin_strcmp_208;
                  return_value___builtin_strcmp_208=__builtin_strcmp(helpbuf1, "cerfile");
                  tmp_statement_expression_207 = return_value___builtin_strcmp_208;
                  tmp_if_expr_209 = tmp_statement_expression_207 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_209)
                  ServerConfiguration_set_certificateFile(cfg, helpbuf2);

                else
                {
                  unsigned long int parsefile__1__9__3__6____s1_len;
                  unsigned long int parsefile__1__9__3__6____s2_len;
                  signed int return_value___builtin_strcmp_204;
                  return_value___builtin_strcmp_204=__builtin_strcmp(helpbuf1, "cacerfile");
                  tmp_statement_expression_203 = return_value___builtin_strcmp_204;
                  if(tmp_statement_expression_203 == 0)
                    ServerConfiguration_set_cacertificateFile(cfg, helpbuf2);

                  else
                  {
                    unsigned long int parsefile__1__9__3__8____s1_len;
                    unsigned long int parsefile__1__9__3__8____s2_len;
                    signed int return_value___builtin_strcmp_202;
                    return_value___builtin_strcmp_202=__builtin_strcmp(helpbuf1, "cerdepth");
                    tmp_statement_expression_201 = return_value___builtin_strcmp_202;
                    if(tmp_statement_expression_201 == 0)
                      ServerConfiguration_set_sCertificateDepth(cfg, helpbuf2);

                    else
                    {
                      unsigned long int parsefile__1__9__3__10____s1_len;
                      unsigned long int parsefile__1__9__3__10____s2_len;
                      signed int return_value___builtin_strcmp_197;
                      return_value___builtin_strcmp_197=__builtin_strcmp(helpbuf1, "key");
                      tmp_statement_expression_196 = return_value___builtin_strcmp_197;
                      if(tmp_statement_expression_196 == 0)
                        tmp_if_expr_200 = (_Bool)1;

                      else
                      {
                        unsigned long int parsefile__1__9__3__11____s1_len;
                        unsigned long int parsefile__1__9__3__11____s2_len;
                        signed int return_value___builtin_strcmp_199;
                        return_value___builtin_strcmp_199=__builtin_strcmp(helpbuf1, "keyfile");
                        tmp_statement_expression_198 = return_value___builtin_strcmp_199;
                        tmp_if_expr_200 = tmp_statement_expression_198 == 0 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr_200)
                        ServerConfiguration_set_keysFile(cfg, helpbuf2);

                      else
                      {
                        unsigned long int parsefile__1__9__3__13____s1_len;
                        unsigned long int parsefile__1__9__3__13____s2_len;
                        signed int return_value___builtin_strcmp_195;
                        return_value___builtin_strcmp_195=__builtin_strcmp(helpbuf1, "log");
                        tmp_statement_expression_194 = return_value___builtin_strcmp_195;
                        if(tmp_statement_expression_194 == 0)
                        {
                          unsigned long int return_value_strlen_117;
                          return_value_strlen_117=strlen(helpbuf2);
                          void *return_value_calloc_118;
                          return_value_calloc_118=calloc(return_value_strlen_117 + (unsigned long int)1, sizeof(char) /*1ul*/ );
                          tmpbuf = (char *)return_value_calloc_118;
                          strcpy(tmpbuf, helpbuf2);
                          addlogtarget(tmpbuf);
                        }

                        else
                        {
                          unsigned long int parsefile__1__9__3__15____s1_len;
                          unsigned long int parsefile__1__9__3__15____s2_len;
                          signed int return_value___builtin_strcmp_193;
                          return_value___builtin_strcmp_193=__builtin_strcmp(helpbuf1, "dateformat");
                          tmp_statement_expression_192 = return_value___builtin_strcmp_193;
                          if(tmp_statement_expression_192 == 0)
                            ServerConfiguration_set_dateFormat(cfg, helpbuf2);

                          else
                          {
                            return_value_ServerConfiguration_get_realmsNumber_191=ServerConfiguration_get_realmsNumber(cfg);
                            if(return_value_ServerConfiguration_get_realmsNumber_191 == 0)
                              return cfg;

                            else
                            {
                              unsigned long int parsefile__1__9__3__18____s1_len;
                              unsigned long int parsefile__1__9__3__18____s2_len;
                              signed int return_value___builtin_strcmp_190;
                              return_value___builtin_strcmp_190=__builtin_strcmp(helpbuf1, "hostname");
                              tmp_statement_expression_189 = return_value___builtin_strcmp_190;
                              if(tmp_statement_expression_189 == 0)
                              {
                                struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_119;
                                return_value_ServerConfiguration_get_realmsTable_119=ServerConfiguration_get_realmsTable(cfg);
                                signed int return_value_ServerConfiguration_get_realmsNumber_120;
                                return_value_ServerConfiguration_get_realmsNumber_120=ServerConfiguration_get_realmsNumber(cfg);
                                ServerRealm_set_hostName(return_value_ServerConfiguration_get_realmsTable_119[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_120 - 1)], helpbuf2);
                              }

                              else
                              {
                                unsigned long int parsefile__1__9__3__20____s1_len;
                                unsigned long int parsefile__1__9__3__20____s2_len;
                                signed int return_value___builtin_strcmp_185;
                                return_value___builtin_strcmp_185=__builtin_strcmp(helpbuf1, "listen");
                                tmp_statement_expression_184 = return_value___builtin_strcmp_185;
                                if(tmp_statement_expression_184 == 0)
                                  tmp_if_expr_188 = (_Bool)1;

                                else
                                {
                                  unsigned long int parsefile__1__9__3__21____s1_len;
                                  unsigned long int parsefile__1__9__3__21____s2_len;
                                  signed int return_value___builtin_strcmp_187;
                                  return_value___builtin_strcmp_187=__builtin_strcmp(helpbuf1, "listenport");
                                  tmp_statement_expression_186 = return_value___builtin_strcmp_187;
                                  tmp_if_expr_188 = tmp_statement_expression_186 == 0 ? (_Bool)1 : (_Bool)0;
                                }
                                if(tmp_if_expr_188)
                                {
                                  struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_121;
                                  return_value_ServerConfiguration_get_realmsTable_121=ServerConfiguration_get_realmsTable(cfg);
                                  signed int return_value_ServerConfiguration_get_realmsNumber_122;
                                  return_value_ServerConfiguration_get_realmsNumber_122=ServerConfiguration_get_realmsNumber(cfg);
                                  struct anonymous_7 **return_value_ServerRealm_get_usersClientsTable_123;
                                  return_value_ServerRealm_get_usersClientsTable_123=ServerRealm_get_usersClientsTable(return_value_ServerConfiguration_get_realmsTable_121[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_122 - 1)]);
                                  UsrCli_set_listenPortName(return_value_ServerRealm_get_usersClientsTable_123[(signed long int)listencount], helpbuf2);
                                  listencount = listencount + 1;
                                }

                                else
                                {
                                  unsigned long int parsefile__1__9__3__23____s1_len;
                                  unsigned long int parsefile__1__9__3__23____s2_len;
                                  signed int return_value___builtin_strcmp_183;
                                  return_value___builtin_strcmp_183=__builtin_strcmp(helpbuf1, "pass");
                                  tmp_statement_expression_182 = return_value___builtin_strcmp_183;
                                  if(tmp_statement_expression_182 == 0)
                                  {
                                    unsigned long int return_value_strlen_124;
                                    return_value_strlen_124=strlen(helpbuf2);
                                    n = (signed int)return_value_strlen_124;
                                    memset((void *)pass, 0, (unsigned long int)4);
                                    i = 0;
                                    for( ; !(i >= n); i = i + 1)
                                      pass[(signed long int)(i % 4)] = pass[(signed long int)(i % 4)] + (unsigned char)helpbuf2[(signed long int)i];
                                    struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_125;
                                    return_value_ServerConfiguration_get_realmsTable_125=ServerConfiguration_get_realmsTable(cfg);
                                    signed int return_value_ServerConfiguration_get_realmsNumber_126;
                                    return_value_ServerConfiguration_get_realmsNumber_126=ServerConfiguration_get_realmsNumber(cfg);
                                    ServerRealm_set_password(return_value_ServerConfiguration_get_realmsTable_125[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_126 - 1)], pass);
                                  }

                                  else
                                  {
                                    unsigned long int parsefile__1__9__3__25____s1_len;
                                    unsigned long int parsefile__1__9__3__25____s2_len;
                                    signed int return_value___builtin_strcmp_178;
                                    return_value___builtin_strcmp_178=__builtin_strcmp(helpbuf1, "manage");
                                    tmp_statement_expression_177 = return_value___builtin_strcmp_178;
                                    if(tmp_statement_expression_177 == 0)
                                      tmp_if_expr_181 = (_Bool)1;

                                    else
                                    {
                                      unsigned long int parsefile__1__9__3__26____s1_len;
                                      unsigned long int parsefile__1__9__3__26____s2_len;
                                      signed int return_value___builtin_strcmp_180;
                                      return_value___builtin_strcmp_180=__builtin_strcmp(helpbuf1, "manageport");
                                      tmp_statement_expression_179 = return_value___builtin_strcmp_180;
                                      tmp_if_expr_181 = tmp_statement_expression_179 == 0 ? (_Bool)1 : (_Bool)0;
                                    }
                                    if(tmp_if_expr_181)
                                    {
                                      struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_127;
                                      return_value_ServerConfiguration_get_realmsTable_127=ServerConfiguration_get_realmsTable(cfg);
                                      signed int return_value_ServerConfiguration_get_realmsNumber_128;
                                      return_value_ServerConfiguration_get_realmsNumber_128=ServerConfiguration_get_realmsNumber(cfg);
                                      struct anonymous_7 **return_value_ServerRealm_get_usersClientsTable_129;
                                      return_value_ServerRealm_get_usersClientsTable_129=ServerRealm_get_usersClientsTable(return_value_ServerConfiguration_get_realmsTable_127[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_128 - 1)]);
                                      UsrCli_set_managePortName(return_value_ServerRealm_get_usersClientsTable_129[(signed long int)managecount], helpbuf2);
                                      managecount = managecount + 1;
                                    }

                                    else
                                    {
                                      unsigned long int parsefile__1__9__3__28____s1_len;
                                      unsigned long int parsefile__1__9__3__28____s2_len;
                                      signed int return_value___builtin_strcmp_176;
                                      return_value___builtin_strcmp_176=__builtin_strcmp(helpbuf1, "users");
                                      tmp_statement_expression_175 = return_value___builtin_strcmp_176;
                                      if(tmp_statement_expression_175 == 0)
                                      {
                                        struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_130;
                                        return_value_ServerConfiguration_get_realmsTable_130=ServerConfiguration_get_realmsTable(cfg);
                                        signed int return_value_ServerConfiguration_get_realmsNumber_131;
                                        return_value_ServerConfiguration_get_realmsNumber_131=ServerConfiguration_get_realmsNumber(cfg);
                                        ServerRealm_set_sUsersLimit(return_value_ServerConfiguration_get_realmsTable_130[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_131 - 1)], helpbuf2);
                                      }

                                      else
                                      {
                                        unsigned long int parsefile__1__9__3__30____s1_len;
                                        unsigned long int parsefile__1__9__3__30____s2_len;
                                        signed int return_value___builtin_strcmp_174;
                                        return_value___builtin_strcmp_174=__builtin_strcmp(helpbuf1, "timeout");
                                        tmp_statement_expression_173 = return_value___builtin_strcmp_174;
                                        if(tmp_statement_expression_173 == 0)
                                        {
                                          struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_132;
                                          return_value_ServerConfiguration_get_realmsTable_132=ServerConfiguration_get_realmsTable(cfg);
                                          signed int return_value_ServerConfiguration_get_realmsNumber_133;
                                          return_value_ServerConfiguration_get_realmsNumber_133=ServerConfiguration_get_realmsNumber(cfg);
                                          ServerRealm_set_sTimeout(return_value_ServerConfiguration_get_realmsTable_132[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_133 - 1)], helpbuf2);
                                        }

                                        else
                                        {
                                          unsigned long int parsefile__1__9__3__32____s1_len;
                                          unsigned long int parsefile__1__9__3__32____s2_len;
                                          signed int return_value___builtin_strcmp_172;
                                          return_value___builtin_strcmp_172=__builtin_strcmp(helpbuf1, "maxidle");
                                          tmp_statement_expression_171 = return_value___builtin_strcmp_172;
                                          if(tmp_statement_expression_171 == 0)
                                          {
                                            struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_134;
                                            return_value_ServerConfiguration_get_realmsTable_134=ServerConfiguration_get_realmsTable(cfg);
                                            signed int return_value_ServerConfiguration_get_realmsNumber_135;
                                            return_value_ServerConfiguration_get_realmsNumber_135=ServerConfiguration_get_realmsNumber(cfg);
                                            ServerRealm_set_sMaxIdle(return_value_ServerConfiguration_get_realmsTable_134[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_135 - 1)], helpbuf2);
                                          }

                                          else
                                          {
                                            unsigned long int parsefile__1__9__3__34____s1_len;
                                            unsigned long int parsefile__1__9__3__34____s2_len;
                                            signed int return_value___builtin_strcmp_170;
                                            return_value___builtin_strcmp_170=__builtin_strcmp(helpbuf1, "clients");
                                            tmp_statement_expression_169 = return_value___builtin_strcmp_170;
                                            if(tmp_statement_expression_169 == 0)
                                            {
                                              struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_136;
                                              return_value_ServerConfiguration_get_realmsTable_136=ServerConfiguration_get_realmsTable(cfg);
                                              signed int return_value_ServerConfiguration_get_realmsNumber_137;
                                              return_value_ServerConfiguration_get_realmsNumber_137=ServerConfiguration_get_realmsNumber(cfg);
                                              ServerRealm_set_sClientsLimit(return_value_ServerConfiguration_get_realmsTable_136[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_137 - 1)], helpbuf2);
                                            }

                                            else
                                            {
                                              unsigned long int parsefile__1__9__3__36____s1_len;
                                              unsigned long int parsefile__1__9__3__36____s2_len;
                                              signed int return_value___builtin_strcmp_168;
                                              return_value___builtin_strcmp_168=__builtin_strcmp(helpbuf1, "raclients");
                                              tmp_statement_expression_167 = return_value___builtin_strcmp_168;
                                              if(tmp_statement_expression_167 == 0)
                                              {
                                                struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_138;
                                                return_value_ServerConfiguration_get_realmsTable_138=ServerConfiguration_get_realmsTable(cfg);
                                                signed int return_value_ServerConfiguration_get_realmsNumber_139;
                                                return_value_ServerConfiguration_get_realmsNumber_139=ServerConfiguration_get_realmsNumber(cfg);
                                                ServerRealm_set_sRaClientsLimit(return_value_ServerConfiguration_get_realmsTable_138[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_139 - 1)], helpbuf2);
                                              }

                                              else
                                              {
                                                unsigned long int parsefile__1__9__3__38____s1_len;
                                                unsigned long int parsefile__1__9__3__38____s2_len;
                                                signed int return_value___builtin_strcmp_166;
                                                return_value___builtin_strcmp_166=__builtin_strcmp(helpbuf1, "usrpcli");
                                                tmp_statement_expression_165 = return_value___builtin_strcmp_166;
                                                if(tmp_statement_expression_165 == 0)
                                                {
                                                  struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_140;
                                                  return_value_ServerConfiguration_get_realmsTable_140=ServerConfiguration_get_realmsTable(cfg);
                                                  signed int return_value_ServerConfiguration_get_realmsNumber_141;
                                                  return_value_ServerConfiguration_get_realmsNumber_141=ServerConfiguration_get_realmsNumber(cfg);
                                                  ServerRealm_set_sUsersPerClient(return_value_ServerConfiguration_get_realmsTable_140[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_141 - 1)], helpbuf2);
                                                }

                                                else
                                                {
                                                  unsigned long int parsefile__1__9__3__40____s1_len;
                                                  unsigned long int parsefile__1__9__3__40____s2_len;
                                                  signed int return_value___builtin_strcmp_164;
                                                  return_value___builtin_strcmp_164=__builtin_strcmp(helpbuf1, "climode");
                                                  tmp_statement_expression_163 = return_value___builtin_strcmp_164;
                                                  if(tmp_statement_expression_163 == 0)
                                                  {
                                                    struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_142;
                                                    return_value_ServerConfiguration_get_realmsTable_142=ServerConfiguration_get_realmsTable(cfg);
                                                    signed int return_value_ServerConfiguration_get_realmsNumber_143;
                                                    return_value_ServerConfiguration_get_realmsNumber_143=ServerConfiguration_get_realmsNumber(cfg);
                                                    ServerRealm_set_sClientMode(return_value_ServerConfiguration_get_realmsTable_142[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_143 - 1)], helpbuf2);
                                                  }

                                                  else
                                                  {
                                                    unsigned long int parsefile__1__9__3__42____s1_len;
                                                    unsigned long int parsefile__1__9__3__42____s2_len;
                                                    signed int return_value___builtin_strcmp_162;
                                                    return_value___builtin_strcmp_162=__builtin_strcmp(helpbuf1, "proto");
                                                    tmp_statement_expression_161 = return_value___builtin_strcmp_162;
                                                    if(tmp_statement_expression_161 == 0)
                                                    {
                                                      struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_144;
                                                      return_value_ServerConfiguration_get_realmsTable_144=ServerConfiguration_get_realmsTable(cfg);
                                                      signed int return_value_ServerConfiguration_get_realmsNumber_145;
                                                      return_value_ServerConfiguration_get_realmsNumber_145=ServerConfiguration_get_realmsNumber(cfg);
                                                      char return_value_ServerRealm_get_realmType_146;
                                                      return_value_ServerRealm_get_realmType_146=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable_144[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_145 - 1)]);
                                                      if(!((1 & (signed int)return_value_ServerRealm_get_realmType_146) == 0))
                                                        return cfg;

                                                      unsigned long int parsefile__1__9__3__43__2____s1_len;
                                                      unsigned long int parsefile__1__9__3__43__2____s2_len;
                                                      signed int return_value___builtin_strcmp_160;
                                                      return_value___builtin_strcmp_160=__builtin_strcmp(helpbuf2, "tcp");
                                                      tmp_statement_expression_159 = return_value___builtin_strcmp_160;
                                                      if(tmp_statement_expression_159 == 0)
                                                      {
                                                        struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_147;
                                                        return_value_ServerConfiguration_get_realmsTable_147=ServerConfiguration_get_realmsTable(cfg);
                                                        signed int return_value_ServerConfiguration_get_realmsNumber_148;
                                                        return_value_ServerConfiguration_get_realmsNumber_148=ServerConfiguration_get_realmsNumber(cfg);
                                                        char return_value_ServerRealm_get_realmType_149;
                                                        return_value_ServerRealm_get_realmType_149=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable_147[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_148 - 1)]);
                                                        temp = (signed int)return_value_ServerRealm_get_realmType_149;
                                                        temp = temp | 1;
                                                        struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_150;
                                                        return_value_ServerConfiguration_get_realmsTable_150=ServerConfiguration_get_realmsTable(cfg);
                                                        signed int return_value_ServerConfiguration_get_realmsNumber_151;
                                                        return_value_ServerConfiguration_get_realmsNumber_151=ServerConfiguration_get_realmsNumber(cfg);
                                                        ServerRealm_set_realmType(return_value_ServerConfiguration_get_realmsTable_150[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_151 - 1)], (char)temp);
                                                      }

                                                      else
                                                      {
                                                        unsigned long int __s1_len;
                                                        unsigned long int __s2_len;
                                                        signed int return_value___builtin_strcmp_158;
                                                        return_value___builtin_strcmp_158=__builtin_strcmp(helpbuf2, "udp");
                                                        tmp_statement_expression_157 = return_value___builtin_strcmp_158;
                                                        if(tmp_statement_expression_157 == 0)
                                                        {
                                                          struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_152;
                                                          return_value_ServerConfiguration_get_realmsTable_152=ServerConfiguration_get_realmsTable(cfg);
                                                          signed int return_value_ServerConfiguration_get_realmsNumber_153;
                                                          return_value_ServerConfiguration_get_realmsNumber_153=ServerConfiguration_get_realmsNumber(cfg);
                                                          char return_value_ServerRealm_get_realmType_154;
                                                          return_value_ServerRealm_get_realmType_154=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable_152[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_153 - 1)]);
                                                          temp = (signed int)return_value_ServerRealm_get_realmType_154;
                                                          temp = temp | 3;
                                                          struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_155;
                                                          return_value_ServerConfiguration_get_realmsTable_155=ServerConfiguration_get_realmsTable(cfg);
                                                          signed int return_value_ServerConfiguration_get_realmsNumber_156;
                                                          return_value_ServerConfiguration_get_realmsNumber_156=ServerConfiguration_get_realmsNumber(cfg);
                                                          ServerRealm_set_realmType(return_value_ServerConfiguration_get_realmsTable_155[(signed long int)(return_value_ServerConfiguration_get_realmsNumber_156 - 1)], (char)temp);
                                                        }

                                                        else
                                                          return cfg;
                                                      }
                                                    }

                                                    else
                                                      return cfg;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }

          memset((void *)buff, 0, (unsigned long int)256);
        }
      }
      while((_Bool)1);
      fclose(file);
      *status = 0;
      return cfg;
    }
  }
}

// read_message
// file http_proxy_functions.c line 281
signed int read_message(signed int fd, signed int length, struct anonymous_27 *client, char *tab, signed int ptr)
{
  signed int j = 0;
  signed int tmp = 0;
  while(!(j >= length))
    if(!(client->toreceive >= client->curreceived + length + -j))
    {
      if(client->toreceive + -client->curreceived >= 1)
      {
        writen(fd, (unsigned char *)(tab + (signed long int)ptr + (signed long int)j), client->toreceive - client->curreceived);
        j = j + (client->toreceive - client->curreceived);
        client->curreceived = client->curreceived + (client->toreceive - client->curreceived);
      }

      if((signed int)client->read_state == 0)
        switch((signed int)tab[(signed long int)(ptr + j)])
        {
          case 77:
          {
            if(length >= 5 + j)
            {
              memcpy((void *)&tmp, (const void *)&tab[(signed long int)(ptr + j + 1)], (unsigned long int)4);
              unsigned int return_value___bswap_32_1;
              return_value___bswap_32_1=__bswap_32((unsigned int)tmp);
              client->toreceive = (signed int)return_value___bswap_32_1;
              client->curreceived = 0;
              j = j + 5;
            }

            else
              if(!(1 + j >= length))
              {
                memcpy((void *)client->readed_length, (const void *)&tab[(signed long int)(ptr + j + 1)], (unsigned long int)((length - j) - 1));
                client->read_state = (char)(length - j);
                j = j + (length - j);
              }

              else
              {
                j = j + 1;
                client->read_state = (char)1;
              }
            break;
          }
          case 84:
          {
            j = j + 1;
            break;
          }
          case 65:
          {
            j = j + 1;
            if((signed int)client->state == 0)
              client->state = (char)4;

            break;
          }
          default:
            return 1;
        }

      else
        if(length >= 5 + j + -((signed int)client->read_state))
        {
          memcpy((void *)&client->readed_length[(signed long int)((signed int)client->read_state - 1)], (const void *)&tab[(signed long int)(ptr + j)], (unsigned long int)(5 - (signed int)client->read_state));
          memcpy((void *)&tmp, (const void *)client->readed_length, (unsigned long int)4);
          unsigned int return_value___bswap_32_2;
          return_value___bswap_32_2=__bswap_32((unsigned int)tmp);
          client->toreceive = (signed int)return_value___bswap_32_2;
          client->curreceived = 0;
          j = j + (5 - (signed int)client->read_state);
          client->read_state = (char)0;
        }

        else
        {
          memcpy((void *)&client->readed_length[(signed long int)((signed int)client->read_state - 1)], (const void *)&tab[(signed long int)(ptr + j)], (unsigned long int)(length - j));
          client->read_state = client->read_state + (char)(length - j);
          j = j + (length - j);
        }
    }

    else
      if(length + -j >= 1)
      {
        client->curreceived = client->curreceived + (length - j);
        writen(fd, (unsigned char *)(tab + (signed long int)ptr + (signed long int)j), length - j);
        j = j + (length - j);
      }

  return 0;
}

// readn
// file network.h line 47
signed int readn(signed int fd, unsigned char *buf, signed int amount)
{
  signed int sent;
  signed int n;
  sent = 0;
  while(!(sent >= amount))
  {
    signed long int return_value_read_1;
    return_value_read_1=read(fd, (void *)(buf + (signed long int)sent), (unsigned long int)(amount - sent));
    n = (signed int)return_value_read_1;
    if(!(n == -1))
      sent = sent + n;

    if(n == 0)
      return 0;

    if(n == -1)
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      if(!(*return_value___errno_location_2 == 11))
        return 0;

    }

  }
  return amount;
}

// remember_mainthread
// file thread_management.h line 26
void remember_mainthread(void)
{
  mainthread=pthread_self();
}

// remove_client
// file server_remove.h line 27
void remove_client(struct anonymous_5 *ptr, signed int client, struct anonymous_22 *set, struct anonymous_22 *wset, struct anonymous_16 *scheduler)
{
  signed int i;
  struct anonymous_13 *task;
  struct anonymous_3 **return_value_ServerRealm_get_clientsTable_17;
  return_value_ServerRealm_get_clientsTable_17=ServerRealm_get_clientsTable(ptr);
  char return_value_ConnectClient_get_state_18;
  return_value_ConnectClient_get_state_18=ConnectClient_get_state(return_value_ServerRealm_get_clientsTable_17[(signed long int)client]);
  signed int return_value_ServerRealm_get_usersLimit_1;
  if((signed int)return_value_ConnectClient_get_state_18 == 3)
  {
    i = 0;
    do
    {
      return_value_ServerRealm_get_usersLimit_1=ServerRealm_get_usersLimit(ptr);
      if(i >= return_value_ServerRealm_get_usersLimit_1)
        break;

      struct anonymous_4 **return_value_ServerRealm_get_usersTable_15;
      return_value_ServerRealm_get_usersTable_15=ServerRealm_get_usersTable(ptr);
      signed int return_value_ConnectUser_get_whatClient_16;
      return_value_ConnectUser_get_whatClient_16=ConnectUser_get_whatClient(return_value_ServerRealm_get_usersTable_15[(signed long int)i]);
      if(return_value_ConnectUser_get_whatClient_16 == client)
      {
        struct anonymous_4 **return_value_ServerRealm_get_usersTable_13;
        return_value_ServerRealm_get_usersTable_13=ServerRealm_get_usersTable(ptr);
        char return_value_ConnectUser_get_state_14;
        return_value_ConnectUser_get_state_14=ConnectUser_get_state(return_value_ServerRealm_get_usersTable_13[(signed long int)i]);
        if(!((signed int)return_value_ConnectUser_get_state_14 == 0))
        {
          struct anonymous_4 **return_value_ServerRealm_get_usersTable_2;
          return_value_ServerRealm_get_usersTable_2=ServerRealm_get_usersTable(ptr);
          ConnectUser_set_state(return_value_ServerRealm_get_usersTable_2[(signed long int)i], (char)0);
          struct anonymous_4 **return_value_ServerRealm_get_usersTable_3;
          return_value_ServerRealm_get_usersTable_3=ServerRealm_get_usersTable(ptr);
          signed int return_value_ConnectUser_get_connFd_4;
          return_value_ConnectUser_get_connFd_4=ConnectUser_get_connFd(return_value_ServerRealm_get_usersTable_3[(signed long int)i]);
          struct anonymous_4 **return_value_ServerRealm_get_usersTable_5;
          return_value_ServerRealm_get_usersTable_5=ServerRealm_get_usersTable(ptr);
          signed int return_value_ConnectUser_get_connFd_6;
          return_value_ConnectUser_get_connFd_6=ConnectUser_get_connFd(return_value_ServerRealm_get_usersTable_5[(signed long int)i]);
          set->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_4 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = set->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_4 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_6 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
          struct anonymous_4 **return_value_ServerRealm_get_usersTable_7;
          return_value_ServerRealm_get_usersTable_7=ServerRealm_get_usersTable(ptr);
          signed int return_value_ConnectUser_get_connFd_8;
          return_value_ConnectUser_get_connFd_8=ConnectUser_get_connFd(return_value_ServerRealm_get_usersTable_7[(signed long int)i]);
          struct anonymous_4 **return_value_ServerRealm_get_usersTable_9;
          return_value_ServerRealm_get_usersTable_9=ServerRealm_get_usersTable(ptr);
          signed int return_value_ConnectUser_get_connFd_10;
          return_value_ConnectUser_get_connFd_10=ConnectUser_get_connFd(return_value_ServerRealm_get_usersTable_9[(signed long int)i]);
          wset->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_8 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = wset->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd_8 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd_10 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
          struct anonymous_4 **return_value_ServerRealm_get_usersTable_11;
          return_value_ServerRealm_get_usersTable_11=ServerRealm_get_usersTable(ptr);
          signed int return_value_ConnectUser_get_connFd_12;
          return_value_ConnectUser_get_connFd_12=ConnectUser_get_connFd(return_value_ServerRealm_get_usersTable_11[(signed long int)i]);
          close(return_value_ConnectUser_get_connFd_12);
          ServerRealm_decrease_connectedUsers(ptr);
        }

      }

      i = i + 1;
    }
    while((_Bool)1);
  }

  i = 0;
  struct anonymous_3 **return_value_ServerRealm_get_clientsTable_19;
  signed int return_value_ConnectClient_get_limit_20;
  do
  {
    return_value_ServerRealm_get_clientsTable_19=ServerRealm_get_clientsTable(ptr);
    return_value_ConnectClient_get_limit_20=ConnectClient_get_limit(return_value_ServerRealm_get_clientsTable_19[(signed long int)client]);
    if(i >= return_value_ConnectClient_get_limit_20)
      break;

    struct anonymous_3 **return_value_ServerRealm_get_clientsTable_21;
    return_value_ServerRealm_get_clientsTable_21=ServerRealm_get_clientsTable(ptr);
    signed int *return_value_ConnectClient_get_users_22;
    return_value_ConnectClient_get_users_22=ConnectClient_get_users(return_value_ServerRealm_get_clientsTable_21[(signed long int)client]);
    return_value_ConnectClient_get_users_22[(signed long int)i] = -1;
    i = i + 1;
  }
  while((_Bool)1);
  signed int return_value_ServerRealm_get_clientsLimit_30;
  return_value_ServerRealm_get_clientsLimit_30=ServerRealm_get_clientsLimit(ptr);
  char return_value_ServerRealm_get_basePortOn_29;
  if(!(return_value_ServerRealm_get_clientsLimit_30 == client))
  {
    return_value_ServerRealm_get_basePortOn_29=ServerRealm_get_basePortOn(ptr);
    if((signed int)return_value_ServerRealm_get_basePortOn_29 == 1)
    {
      struct anonymous_3 **return_value_ServerRealm_get_clientsTable_23;
      return_value_ServerRealm_get_clientsTable_23=ServerRealm_get_clientsTable(ptr);
      signed int return_value_ConnectClient_get_listenFd_24;
      return_value_ConnectClient_get_listenFd_24=ConnectClient_get_listenFd(return_value_ServerRealm_get_clientsTable_23[(signed long int)client]);
      close(return_value_ConnectClient_get_listenFd_24);
      struct anonymous_3 **return_value_ServerRealm_get_clientsTable_25;
      return_value_ServerRealm_get_clientsTable_25=ServerRealm_get_clientsTable(ptr);
      signed int return_value_ConnectClient_get_listenFd_26;
      return_value_ConnectClient_get_listenFd_26=ConnectClient_get_listenFd(return_value_ServerRealm_get_clientsTable_25[(signed long int)client]);
      struct anonymous_3 **return_value_ServerRealm_get_clientsTable_27;
      return_value_ServerRealm_get_clientsTable_27=ServerRealm_get_clientsTable(ptr);
      signed int return_value_ConnectClient_get_listenFd_28;
      return_value_ConnectClient_get_listenFd_28=ConnectClient_get_listenFd(return_value_ServerRealm_get_clientsTable_27[(signed long int)client]);
      set->__fds_bits[(signed long int)(return_value_ConnectClient_get_listenFd_26 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = set->__fds_bits[(signed long int)(return_value_ConnectClient_get_listenFd_26 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectClient_get_listenFd_28 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    }

  }

  struct anonymous_3 **return_value_ServerRealm_get_clientsTable_31;
  return_value_ServerRealm_get_clientsTable_31=ServerRealm_get_clientsTable(ptr);
  ConnectClient_set_sClientId(return_value_ServerRealm_get_clientsTable_31[(signed long int)client], (char *)(void *)0);
  struct anonymous_3 **return_value_ServerRealm_get_clientsTable_32;
  return_value_ServerRealm_get_clientsTable_32=ServerRealm_get_clientsTable(ptr);
  ConnectClient_set_connected(return_value_ServerRealm_get_clientsTable_32[(signed long int)client], 0);
  struct anonymous_3 **return_value_ServerRealm_get_clientsTable_33;
  return_value_ServerRealm_get_clientsTable_33=ServerRealm_get_clientsTable(ptr);
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_34;
  return_value_ConnectClient_get_sslFd_34=ConnectClient_get_sslFd(return_value_ServerRealm_get_clientsTable_33[(signed long int)client]);
  signed int return_value_SslFd_get_fd_35;
  return_value_SslFd_get_fd_35=SslFd_get_fd(return_value_ConnectClient_get_sslFd_34);
  close(return_value_SslFd_get_fd_35);
  struct anonymous_3 **return_value_ServerRealm_get_clientsTable_36;
  return_value_ServerRealm_get_clientsTable_36=ServerRealm_get_clientsTable(ptr);
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_37;
  return_value_ConnectClient_get_sslFd_37=ConnectClient_get_sslFd(return_value_ServerRealm_get_clientsTable_36[(signed long int)client]);
  signed int return_value_SslFd_get_fd_38;
  return_value_SslFd_get_fd_38=SslFd_get_fd(return_value_ConnectClient_get_sslFd_37);
  struct anonymous_3 **return_value_ServerRealm_get_clientsTable_39;
  return_value_ServerRealm_get_clientsTable_39=ServerRealm_get_clientsTable(ptr);
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_40;
  return_value_ConnectClient_get_sslFd_40=ConnectClient_get_sslFd(return_value_ServerRealm_get_clientsTable_39[(signed long int)client]);
  signed int return_value_SslFd_get_fd_41;
  return_value_SslFd_get_fd_41=SslFd_get_fd(return_value_ConnectClient_get_sslFd_40);
  set->__fds_bits[(signed long int)(return_value_SslFd_get_fd_38 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = set->__fds_bits[(signed long int)(return_value_SslFd_get_fd_38 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_SslFd_get_fd_41 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  if(!(scheduler == ((struct anonymous_16 *)NULL)))
  {
    struct anonymous_3 **return_value_ServerRealm_get_clientsTable_43;
    return_value_ServerRealm_get_clientsTable_43=ServerRealm_get_clientsTable(ptr);
    task=ConnectClient_get_task(return_value_ServerRealm_get_clientsTable_43[(signed long int)client]);
    if(!(task == ((struct anonymous_13 *)NULL)))
    {
      TaskScheduler_removeTask(scheduler, task);
      struct anonymous_3 **return_value_ServerRealm_get_clientsTable_42;
      return_value_ServerRealm_get_clientsTable_42=ServerRealm_get_clientsTable(ptr);
      ConnectClient_set_task(return_value_ServerRealm_get_clientsTable_42[(signed long int)client], (struct anonymous_13 *)(void *)0);
    }

  }

  struct anonymous_3 **return_value_ServerRealm_get_clientsTable_44;
  return_value_ServerRealm_get_clientsTable_44=ServerRealm_get_clientsTable(ptr);
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_45;
  return_value_ConnectClient_get_sslFd_45=ConnectClient_get_sslFd(return_value_ServerRealm_get_clientsTable_44[(signed long int)client]);
  struct ssl_st *return_value_SslFd_get_ssl_46;
  return_value_SslFd_get_ssl_46=SslFd_get_ssl(return_value_ConnectClient_get_sslFd_45);
  SSL_clear(return_value_SslFd_get_ssl_46);
  struct anonymous_3 **return_value_ServerRealm_get_clientsTable_47;
  return_value_ServerRealm_get_clientsTable_47=ServerRealm_get_clientsTable(ptr);
  ConnectClient_set_state(return_value_ServerRealm_get_clientsTable_47[(signed long int)client], (char)0);
  ServerRealm_decrease_connectedClients(ptr);
}

// remove_raclient
// file server_remove.h line 28
void remove_raclient(struct anonymous_5 *ptr, signed int client, struct anonymous_22 *set, struct anonymous_22 *wset, struct anonymous_16 *scheduler)
{
  signed int i;
  struct anonymous_13 *task;
  i = 0;
  struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_1;
  signed int return_value_ConnectClient_get_limit_2;
  do
  {
    return_value_ServerRealm_get_raClientsTable_1=ServerRealm_get_raClientsTable(ptr);
    return_value_ConnectClient_get_limit_2=ConnectClient_get_limit(return_value_ServerRealm_get_raClientsTable_1[(signed long int)client]);
    if(i >= return_value_ConnectClient_get_limit_2)
      break;

    struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_3;
    return_value_ServerRealm_get_raClientsTable_3=ServerRealm_get_raClientsTable(ptr);
    signed int *return_value_ConnectClient_get_users_4;
    return_value_ConnectClient_get_users_4=ConnectClient_get_users(return_value_ServerRealm_get_raClientsTable_3[(signed long int)client]);
    return_value_ConnectClient_get_users_4[(signed long int)i] = -1;
    i = i + 1;
  }
  while((_Bool)1);
  struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_5;
  return_value_ServerRealm_get_raClientsTable_5=ServerRealm_get_raClientsTable(ptr);
  ConnectClient_set_sClientId(return_value_ServerRealm_get_raClientsTable_5[(signed long int)client], (char *)(void *)0);
  struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_6;
  return_value_ServerRealm_get_raClientsTable_6=ServerRealm_get_raClientsTable(ptr);
  ConnectClient_set_connected(return_value_ServerRealm_get_raClientsTable_6[(signed long int)client], 0);
  struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_7;
  return_value_ServerRealm_get_raClientsTable_7=ServerRealm_get_raClientsTable(ptr);
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_8;
  return_value_ConnectClient_get_sslFd_8=ConnectClient_get_sslFd(return_value_ServerRealm_get_raClientsTable_7[(signed long int)client]);
  signed int return_value_SslFd_get_fd_9;
  return_value_SslFd_get_fd_9=SslFd_get_fd(return_value_ConnectClient_get_sslFd_8);
  close(return_value_SslFd_get_fd_9);
  struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_10;
  return_value_ServerRealm_get_raClientsTable_10=ServerRealm_get_raClientsTable(ptr);
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_11;
  return_value_ConnectClient_get_sslFd_11=ConnectClient_get_sslFd(return_value_ServerRealm_get_raClientsTable_10[(signed long int)client]);
  signed int return_value_SslFd_get_fd_12;
  return_value_SslFd_get_fd_12=SslFd_get_fd(return_value_ConnectClient_get_sslFd_11);
  struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_13;
  return_value_ServerRealm_get_raClientsTable_13=ServerRealm_get_raClientsTable(ptr);
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_14;
  return_value_ConnectClient_get_sslFd_14=ConnectClient_get_sslFd(return_value_ServerRealm_get_raClientsTable_13[(signed long int)client]);
  signed int return_value_SslFd_get_fd_15;
  return_value_SslFd_get_fd_15=SslFd_get_fd(return_value_ConnectClient_get_sslFd_14);
  set->__fds_bits[(signed long int)(return_value_SslFd_get_fd_12 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = set->__fds_bits[(signed long int)(return_value_SslFd_get_fd_12 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_SslFd_get_fd_15 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  if(!(scheduler == ((struct anonymous_16 *)NULL)))
  {
    struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_17;
    return_value_ServerRealm_get_raClientsTable_17=ServerRealm_get_raClientsTable(ptr);
    task=ConnectClient_get_task(return_value_ServerRealm_get_raClientsTable_17[(signed long int)client]);
    if(!(task == ((struct anonymous_13 *)NULL)))
    {
      TaskScheduler_removeTask(scheduler, task);
      struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_16;
      return_value_ServerRealm_get_raClientsTable_16=ServerRealm_get_raClientsTable(ptr);
      ConnectClient_set_task(return_value_ServerRealm_get_raClientsTable_16[(signed long int)client], (struct anonymous_13 *)(void *)0);
    }

  }

  struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_18;
  return_value_ServerRealm_get_raClientsTable_18=ServerRealm_get_raClientsTable(ptr);
  struct anonymous_1 *return_value_ConnectClient_get_sslFd_19;
  return_value_ConnectClient_get_sslFd_19=ConnectClient_get_sslFd(return_value_ServerRealm_get_raClientsTable_18[(signed long int)client]);
  struct ssl_st *return_value_SslFd_get_ssl_20;
  return_value_SslFd_get_ssl_20=SslFd_get_ssl(return_value_ConnectClient_get_sslFd_19);
  SSL_clear(return_value_SslFd_get_ssl_20);
  ServerRealm_decrease_connectedClients(ptr);
  struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_21;
  return_value_ServerRealm_get_raClientsTable_21=ServerRealm_get_raClientsTable(ptr);
  char return_value_ConnectClient_get_state_22;
  return_value_ConnectClient_get_state_22=ConnectClient_get_state(return_value_ServerRealm_get_raClientsTable_21[(signed long int)client]);
  if((signed int)return_value_ConnectClient_get_state_22 == 3)
    ServerRealm_decrease_connectedRaClients(ptr);

  struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_23;
  return_value_ServerRealm_get_raClientsTable_23=ServerRealm_get_raClientsTable(ptr);
  ConnectClient_set_state(return_value_ServerRealm_get_raClientsTable_23[(signed long int)client], (char)0);
}

// resetcg
// file stats.c line 84
void resetcg(void)
{
  compressgained = (signed long int)0;
}

// send_adm_message
// file server_remoteadmin.c line 158
static void send_adm_message(char type, struct anonymous_1 *master, unsigned char *buff, unsigned char st)
{
  signed int n;
  if(newmessage == 0)
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen((char *)&buff[(signed long int)5]);
    n = (signed int)return_value_strlen_1;
  }

  else
    n = 0;
  buff[(signed long int)0] = (unsigned char)15;
  buff[(signed long int)1] = st;
  buff[(signed long int)2] = (unsigned char)0;
  buff[(signed long int)3] = (unsigned char)(n >> 8);
  buff[(signed long int)4] = (unsigned char)n;
  SslFd_send_message(type, master, buff, n + 5);
}

// serve_admin
// file server_remoteadmin.h line 35
signed int serve_admin(struct anonymous_2 *config, signed int realm, signed int client, unsigned char *buff)
{
  signed int length;
  signed int n;
  signed int i;
  signed int j;
  signed int ret;
  signed long int now;
  signed long int tmp;
  struct llnode *llptr;
  struct alnode *alptr;
  char olddf[51l];
  char newdf[51l];
  struct anonymous_3 *cpointer;
  struct anonymous_4 *upointer;
  struct anonymous_5 *pointer;
  struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_1;
  return_value_ServerConfiguration_get_realmsTable_1=ServerConfiguration_get_realmsTable(config);
  pointer = return_value_ServerConfiguration_get_realmsTable_1[(signed long int)realm];
  char type;
  char return_value_ServerRealm_get_realmType_2;
  return_value_ServerRealm_get_realmType_2=ServerRealm_get_realmType(pointer);
  type = (char)((signed int)return_value_ServerRealm_get_realmType_2 | 4 | 8);
  struct anonymous_1 *master;
  struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_3;
  return_value_ServerRealm_get_raClientsTable_3=ServerRealm_get_raClientsTable(pointer);
  master=ConnectClient_get_sslFd(return_value_ServerRealm_get_raClientsTable_3[(signed long int)client]);
  newdf[(signed long int)50] = (char)0;
  olddf[(signed long int)50] = newdf[(signed long int)50];
  length = (signed int)buff[(signed long int)3];
  length = length << 8;
  length = length + (signed int)buff[(signed long int)4];
  time(&now);
  char *return_value_get_realmname_4;
  signed int return_value_parse_cmd_5;
  signed int return_value_ServerConfiguration_get_realmsNumber_6;
  char *return_value_ServerConfiguration_get_certificateFile_7;
  char *return_value_ServerConfiguration_get_keysFile_8;
  signed long int return_value_ServerConfiguration_get_startTime_9;
  signed long int return_value_getcg_10;
  char *return_value_getdateformat_11;
  signed int return_value_ServerConfiguration_get_realmsNumber_12;
  signed int return_value_ServerRealm_get_userClientPairs_25;
  _Bool tmp_if_expr_41;
  char return_value_ServerRealm_get_realmType_40;
  signed int return_value_ServerConfiguration_get_realmsNumber_70;
  signed int return_value_ServerRealm_get_clientsLimit_44;
  char *tmp_if_expr_55;
  char *return_value_ConnectClient_get_sClientId_54;
  signed int return_value_ServerConfiguration_get_realmsNumber_92;
  signed int return_value_ServerRealm_get_usersLimit_72;
  char *return_value_get_realmname_93;
  char *return_value_get_raclientname_94;
  signed int return_value_ServerConfiguration_get_realmsNumber_98;
  signed int return_value_ServerConfiguration_get_realmsNumber_107;
  struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_102;
  signed int return_value_ServerRealm_get_clientsLimit_103;
  signed int return_value_ServerConfiguration_get_realmsNumber_111;
  char *return_value_getdateformat_112;
  signed int return_value_ServerConfiguration_get_realmsNumber_113;
  _Bool tmp_if_expr_122;
  char return_value_ConnectUser_get_state_121;
  _Bool tmp_if_expr_124;
  char return_value_ConnectUser_get_state_123;
  signed int return_value_ServerConfiguration_get_realmsNumber_125;
  switch((signed int)buff[(signed long int)1])
  {
    case 1:
    {
      n=SslFd_get_message(type, master, buff, length);
      buff[(signed long int)n] = (unsigned char)0;
      return_value_get_realmname_4=get_realmname(config, realm);
      aflog((char)8, (char)8, "realm[%s]: admin: message length = %d [%s]", return_value_get_realmname_4, n, buff);
      return_value_parse_cmd_5=parse_cmd(buff, &ret);
      switch(return_value_parse_cmd_5)
      {
        case 1:
        {
          add_to_message(buff, "AFSERVER v0.8.4");
          add_to_message(buff, "\nValid commands are:");
          add_to_message(buff, "  help                 display help");
          add_to_message(buff, "  lcmd                 lists available commands");
          add_to_message(buff, "  info                 prints info about server");
          add_to_message(buff, "  rshow                display realms");
          add_to_message(buff, "  cshow X              display clients in X realm");
          add_to_message(buff, "  ushow X              display users in X realm");
          add_to_message(buff, "  quit                 quit connection");
          add_to_message(buff, "  timeout N X          set timeout value in X realm");
          add_to_message(buff, "  audit {0|1} X        set audit mode in X realm");
          add_to_message(buff, "  dnslookups {0|1} X   set dnslookups mode in X realm");
          add_to_message(buff, "  dateformat S         set dateformat");
          add_to_message(buff, "  kuser S              kick user named S");
          add_to_message(buff, "  kclient N            kick client with number N");
          send_adm_message(type, master, buff, (unsigned char)3);
          break;
        }
        case 2:
        {
          add_to_message(buff, "help");
          add_to_message(buff, "lcmd");
          add_to_message(buff, "info");
          add_to_message(buff, "rshow");
          add_to_message(buff, "cshow");
          add_to_message(buff, "ushow");
          add_to_message(buff, "quit");
          add_to_message(buff, "timeout");
          add_to_message(buff, "audit");
          add_to_message(buff, "dnslookups");
          add_to_message(buff, "dateformat");
          add_to_message(buff, "kuser");
          add_to_message(buff, "kclient");
          send_adm_message(type, master, buff, (unsigned char)3);
          break;
        }
        case 3:
        {
          add_to_message(buff, "Version: v0.8.4");
          return_value_ServerConfiguration_get_realmsNumber_6=ServerConfiguration_get_realmsNumber(config);
          add_to_message(buff, "Realms: %d", return_value_ServerConfiguration_get_realmsNumber_6);
          return_value_ServerConfiguration_get_certificateFile_7=ServerConfiguration_get_certificateFile(config);
          add_to_message(buff, "Certificate: %s", return_value_ServerConfiguration_get_certificateFile_7);
          return_value_ServerConfiguration_get_keysFile_8=ServerConfiguration_get_keysFile(config);
          add_to_message(buff, "Key: %s", return_value_ServerConfiguration_get_keysFile_8);
          llptr=getloglisthead();
          i = 0;
          for( ; !(llptr == ((struct llnode *)NULL)); i = i + 1)
          {
            add_to_message(buff, "log[%d]: %s", i, llptr->cmdline);
            llptr = llptr->next;
          }
          return_value_ServerConfiguration_get_startTime_9=ServerConfiguration_get_startTime(config);
          tmp = now - return_value_ServerConfiguration_get_startTime_9;
          add_uptime_to_message(buff, "Uptime", tmp);
          return_value_getcg_10=getcg();
          add_to_message(buff, "Cg: %ld B", return_value_getcg_10);
          return_value_getdateformat_11=getdateformat();
          add_to_message(buff, "Dateformat: %s", return_value_getdateformat_11);
          send_adm_message(type, master, buff, (unsigned char)3);
          break;
        }
        case 4:
        {
          i = 0;
          do
          {
            return_value_ServerConfiguration_get_realmsNumber_12=ServerConfiguration_get_realmsNumber(config);
            if(i >= return_value_ServerConfiguration_get_realmsNumber_12)
              break;

            struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_13;
            return_value_ServerConfiguration_get_realmsTable_13=ServerConfiguration_get_realmsTable(config);
            pointer = return_value_ServerConfiguration_get_realmsTable_13[(signed long int)i];
            char *return_value_get_realmname_14;
            return_value_get_realmname_14=get_realmname(config, i);
            add_to_message(buff, "\nRealm[%s]:", return_value_get_realmname_14);
            char *return_value_ServerRealm_get_hostName_15;
            return_value_ServerRealm_get_hostName_15=ServerRealm_get_hostName(pointer);
            add_to_message(buff, "hostname: %s", return_value_ServerRealm_get_hostName_15);
            signed int return_value_ServerRealm_get_connectedUsers_16;
            return_value_ServerRealm_get_connectedUsers_16=ServerRealm_get_connectedUsers(pointer);
            signed int return_value_ServerRealm_get_usersLimit_17;
            return_value_ServerRealm_get_usersLimit_17=ServerRealm_get_usersLimit(pointer);
            add_to_message(buff, "users: %d (max: %d)", return_value_ServerRealm_get_connectedUsers_16, return_value_ServerRealm_get_usersLimit_17);
            signed int return_value_ServerRealm_get_connectedClients_18;
            return_value_ServerRealm_get_connectedClients_18=ServerRealm_get_connectedClients(pointer);
            signed int return_value_ServerRealm_get_connectedRaClients_19;
            return_value_ServerRealm_get_connectedRaClients_19=ServerRealm_get_connectedRaClients(pointer);
            signed int return_value_ServerRealm_get_clientsLimit_20;
            return_value_ServerRealm_get_clientsLimit_20=ServerRealm_get_clientsLimit(pointer);
            add_to_message(buff, "clients: %d (max: %d)", return_value_ServerRealm_get_connectedClients_18 - return_value_ServerRealm_get_connectedRaClients_19, return_value_ServerRealm_get_clientsLimit_20);
            signed int return_value_ServerRealm_get_connectedRaClients_21;
            return_value_ServerRealm_get_connectedRaClients_21=ServerRealm_get_connectedRaClients(pointer);
            signed int return_value_ServerRealm_get_raClientsLimit_22;
            return_value_ServerRealm_get_raClientsLimit_22=ServerRealm_get_raClientsLimit(pointer);
            add_to_message(buff, "raclients: %d (max: %d)", return_value_ServerRealm_get_connectedRaClients_21, return_value_ServerRealm_get_raClientsLimit_22);
            char *return_value_ServerRealm_get_sUsersPerClient_23;
            return_value_ServerRealm_get_sUsersPerClient_23=ServerRealm_get_sUsersPerClient(pointer);
            add_to_message(buff, "users per client: %s", return_value_ServerRealm_get_sUsersPerClient_23);
            signed int return_value_ServerRealm_get_userClientPairs_24;
            return_value_ServerRealm_get_userClientPairs_24=ServerRealm_get_userClientPairs(pointer);
            add_to_message(buff, "user-client pairs: %d", return_value_ServerRealm_get_userClientPairs_24);
            j = 0;
            do
            {
              return_value_ServerRealm_get_userClientPairs_25=ServerRealm_get_userClientPairs(pointer);
              if(j >= return_value_ServerRealm_get_userClientPairs_25)
                break;

              struct anonymous_7 **return_value_ServerRealm_get_usersClientsTable_26;
              return_value_ServerRealm_get_usersClientsTable_26=ServerRealm_get_usersClientsTable(pointer);
              char *return_value_UsrCli_get_listenPortName_27;
              return_value_UsrCli_get_listenPortName_27=UsrCli_get_listenPortName(return_value_ServerRealm_get_usersClientsTable_26[(signed long int)j]);
              struct anonymous_7 **return_value_ServerRealm_get_usersClientsTable_28;
              return_value_ServerRealm_get_usersClientsTable_28=ServerRealm_get_usersClientsTable(pointer);
              char *return_value_UsrCli_get_managePortName_29;
              return_value_UsrCli_get_managePortName_29=UsrCli_get_managePortName(return_value_ServerRealm_get_usersClientsTable_28[(signed long int)j]);
              add_to_message(buff, " pair[%d]: listenport: %s, manageport: %s", j, return_value_UsrCli_get_listenPortName_27, return_value_UsrCli_get_managePortName_29);
              j = j + 1;
            }
            while((_Bool)1);
            char *return_value_ServerRealm_get_sClientMode_30;
            return_value_ServerRealm_get_sClientMode_30=ServerRealm_get_sClientMode(pointer);
            add_to_message(buff, "climode: %s", return_value_ServerRealm_get_sClientMode_30);
            signed int return_value_ServerRealm_get_timeout_31;
            return_value_ServerRealm_get_timeout_31=ServerRealm_get_timeout(pointer);
            add_to_message(buff, "timeout: %d", return_value_ServerRealm_get_timeout_31);
            signed int return_value_ServerRealm_get_maxIdle_33;
            return_value_ServerRealm_get_maxIdle_33=ServerRealm_get_maxIdle(pointer);
            if(!(return_value_ServerRealm_get_maxIdle_33 == 0))
            {
              signed int return_value_ServerRealm_get_maxIdle_32;
              return_value_ServerRealm_get_maxIdle_32=ServerRealm_get_maxIdle(pointer);
              add_to_message(buff, "max idle: %d", return_value_ServerRealm_get_maxIdle_32);
            }

            else
              add_to_message(buff, "max idle: disabled");
            char return_value_ServerRealm_get_basePortOn_34;
            return_value_ServerRealm_get_basePortOn_34=ServerRealm_get_basePortOn(pointer);
            add_to_message(buff, "baseport: %s", return_value_ServerRealm_get_basePortOn_34 != 0 ? "yes" : "no");
            char return_value_ServerRealm_get_auditOn_35;
            return_value_ServerRealm_get_auditOn_35=ServerRealm_get_auditOn(pointer);
            add_to_message(buff, "audit: %s", return_value_ServerRealm_get_auditOn_35 != 0 ? "yes" : "no");
            char return_value_ServerRealm_get_dnsLookupsOn_36;
            return_value_ServerRealm_get_dnsLookupsOn_36=ServerRealm_get_dnsLookupsOn(pointer);
            add_to_message(buff, "dnslookups: %s", return_value_ServerRealm_get_dnsLookupsOn_36 != 0 ? "yes" : "no");
            char return_value_ServerRealm_get_realmType_37;
            return_value_ServerRealm_get_realmType_37=ServerRealm_get_realmType(pointer);
            char return_value_ServerRealm_get_realmType_38;
            return_value_ServerRealm_get_realmType_38=ServerRealm_get_realmType(pointer);
            char return_value_ServerRealm_get_realmType_39;
            return_value_ServerRealm_get_realmType_39=ServerRealm_get_realmType(pointer);
            if(!((1 & (signed int)return_value_ServerRealm_get_realmType_39) == 0))
            {
              return_value_ServerRealm_get_realmType_40=ServerRealm_get_realmType(pointer);
              tmp_if_expr_41 = !(((signed int)return_value_ServerRealm_get_realmType_40 & 2) != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_41 = (_Bool)0;
            add_to_message(buff, "ssl: %s, zlib: %s, mode: %s", ((signed int)return_value_ServerRealm_get_realmType_37 & 4) != 0 ? "yes" : "no", ((signed int)return_value_ServerRealm_get_realmType_38 & 8) != 0 ? "yes" : "no", tmp_if_expr_41 ? "tcp" : "udp");
            char return_value_ServerRealm_get_tunnelType_42;
            return_value_ServerRealm_get_tunnelType_42=ServerRealm_get_tunnelType(pointer);
            switch((signed int)return_value_ServerRealm_get_tunnelType_42)
            {
              case 0:
              {
                add_to_message(buff, "tunneltype: direct");
                break;
              }
              case 1:
              {
                add_to_message(buff, "tunneltype: http proxy");
                break;
              }
              case 2:
              {
                add_to_message(buff, "tunneltype: https proxy");
                break;
              }
              default:
                add_to_message(buff, "tunneltype: UNKNOWN");
            }
            i = i + 1;
          }
          while((_Bool)1);
          send_adm_message(type, master, buff, (unsigned char)3);
          break;
        }
        case 5:
        {
          n=get_realmnumber(config, (char *)&buff[(signed long int)ret]);
          if(n >= 0)
          {
            return_value_ServerConfiguration_get_realmsNumber_70=ServerConfiguration_get_realmsNumber(config);
            if(!(n >= return_value_ServerConfiguration_get_realmsNumber_70))
            {
              struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_43;
              return_value_ServerConfiguration_get_realmsTable_43=ServerConfiguration_get_realmsTable(config);
              pointer = return_value_ServerConfiguration_get_realmsTable_43[(signed long int)n];
              i = 0;
              do
              {
                return_value_ServerRealm_get_clientsLimit_44=ServerRealm_get_clientsLimit(pointer);
                if(i >= return_value_ServerRealm_get_clientsLimit_44)
                  break;

                struct anonymous_3 **return_value_ServerRealm_get_clientsTable_45;
                return_value_ServerRealm_get_clientsTable_45=ServerRealm_get_clientsTable(pointer);
                cpointer = return_value_ServerRealm_get_clientsTable_45[(signed long int)i];
                char return_value_ConnectClient_get_state_69;
                return_value_ConnectClient_get_state_69=ConnectClient_get_state(cpointer);
                if(!((signed int)return_value_ConnectClient_get_state_69 == 0))
                {
                  char *return_value_get_clientname_46;
                  return_value_get_clientname_46=get_clientname(pointer, i);
                  add_to_message(buff, "\nClient[%s]:", return_value_get_clientname_46);
                  char return_value_ConnectClient_get_state_47;
                  return_value_ConnectClient_get_state_47=ConnectClient_get_state(cpointer);
                  switch((signed int)return_value_ConnectClient_get_state_47)
                  {
                    case 1:
                    {
                      add_to_message(buff, "state: ssl handshake");
                      break;
                    }
                    case 2:
                    {
                      add_to_message(buff, "state: authorization");
                      break;
                    }
                    case 3:
                    {
                      add_to_message(buff, "state: running");
                      break;
                    }
                    default:
                      add_to_message(buff, "state: unknown");
                  }
                  signed int return_value_ConnectClient_get_connected_48;
                  return_value_ConnectClient_get_connected_48=ConnectClient_get_connected(cpointer);
                  signed int return_value_ConnectClient_get_limit_49;
                  return_value_ConnectClient_get_limit_49=ConnectClient_get_limit(cpointer);
                  add_to_message(buff, "users: %d (max: %d)", return_value_ConnectClient_get_connected_48, return_value_ConnectClient_get_limit_49);
                  signed int return_value_ConnectClient_get_usrCliPair_50;
                  return_value_ConnectClient_get_usrCliPair_50=ConnectClient_get_usrCliPair(cpointer);
                  add_to_message(buff, "user-client pair: %d", return_value_ConnectClient_get_usrCliPair_50);
                  signed long int return_value_ConnectClient_get_connectTime_51;
                  return_value_ConnectClient_get_connectTime_51=ConnectClient_get_connectTime(cpointer);
                  tmp = now - return_value_ConnectClient_get_connectTime_51;
                  add_uptime_to_message(buff, "Connection time", tmp);
                  signed long int return_value_ConnectClient_get_lastActivity_52;
                  return_value_ConnectClient_get_lastActivity_52=ConnectClient_get_lastActivity(cpointer);
                  tmp = now - return_value_ConnectClient_get_lastActivity_52;
                  add_uptime_to_message(buff, "Idle time", tmp);
                  char *return_value_ConnectClient_get_sClientId_53;
                  return_value_ConnectClient_get_sClientId_53=ConnectClient_get_sClientId(cpointer);
                  if(return_value_ConnectClient_get_sClientId_53 == ((char *)NULL))
                    tmp_if_expr_55 = "";

                  else
                  {
                    return_value_ConnectClient_get_sClientId_54=ConnectClient_get_sClientId(cpointer);
                    tmp_if_expr_55 = return_value_ConnectClient_get_sClientId_54;
                  }
                  add_to_message(buff, "Id: %s", tmp_if_expr_55);
                  signed int return_value_ConnectClient_get_clientId_56;
                  return_value_ConnectClient_get_clientId_56=ConnectClient_get_clientId(cpointer);
                  add_to_message(buff, "Number: %d", return_value_ConnectClient_get_clientId_56);
                  char *return_value_ConnectClient_get_nameBuf_57;
                  return_value_ConnectClient_get_nameBuf_57=ConnectClient_get_nameBuf(cpointer);
                  char *return_value_ConnectClient_get_portBuf_58;
                  return_value_ConnectClient_get_portBuf_58=ConnectClient_get_portBuf(cpointer);
                  add_to_message(buff, "IP: %s, port: %s", return_value_ConnectClient_get_nameBuf_57, return_value_ConnectClient_get_portBuf_58);
                  char return_value_ConnectClient_get_tunnelType_59;
                  return_value_ConnectClient_get_tunnelType_59=ConnectClient_get_tunnelType(cpointer);
                  switch((signed int)return_value_ConnectClient_get_tunnelType_59)
                  {
                    case 0:
                    {
                      add_to_message(buff, "tunneltype: direct");
                      break;
                    }
                    case 1:
                    {
                      add_to_message(buff, "tunneltype: http proxy");
                      break;
                    }
                    case 2:
                    {
                      add_to_message(buff, "tunneltype: https proxy");
                      break;
                    }
                    default:
                      add_to_message(buff, "tunneltype: UNKNOWN");
                  }
                  char return_value_ServerRealm_get_auditOn_68;
                  return_value_ServerRealm_get_auditOn_68=ServerRealm_get_auditOn(pointer);
                  if(!(return_value_ServerRealm_get_auditOn_68 == 0))
                  {
                    add_to_message(buff, "auditlog:");
                    struct auditlist *return_value_ConnectClient_get_auditList_60;
                    return_value_ConnectClient_get_auditList_60=ConnectClient_get_auditList(cpointer);
                    alptr=AuditList_get_first(return_value_ConnectClient_get_auditList_60);
                    while(!(alptr == ((struct alnode *)NULL)))
                    {
                      signed int return_value_AuditListNode_get_userId_61;
                      return_value_AuditListNode_get_userId_61=AuditListNode_get_userId(alptr);
                      char *return_value_AuditListNode_get_nameBuf_62;
                      return_value_AuditListNode_get_nameBuf_62=AuditListNode_get_nameBuf(alptr);
                      char *return_value_AuditListNode_get_portBuf_63;
                      return_value_AuditListNode_get_portBuf_63=AuditListNode_get_portBuf(alptr);
                      signed long int *return_value_AuditListNode_get_connectTimep_64;
                      return_value_AuditListNode_get_connectTimep_64=AuditListNode_get_connectTimep(alptr);
                      char *return_value_localdate_65;
                      return_value_localdate_65=localdate(return_value_AuditListNode_get_connectTimep_64);
                      signed long int return_value_AuditListNode_get_duration_66;
                      return_value_AuditListNode_get_duration_66=AuditListNode_get_duration(alptr);
                      char *return_value_timeperiod_67;
                      return_value_timeperiod_67=timeperiod(return_value_AuditListNode_get_duration_66);
                      add_to_message(buff, "userid: %d ip: %s port: %s connected: %s duration: %s", return_value_AuditListNode_get_userId_61, return_value_AuditListNode_get_nameBuf_62, return_value_AuditListNode_get_portBuf_63, return_value_localdate_65, return_value_timeperiod_67);
                      alptr=AuditListNode_get_nextNode(alptr);
                    }
                  }

                }

                i = i + 1;
              }
              while((_Bool)1);
              send_adm_message(type, master, buff, (unsigned char)3);
              break;
            }

          }

          add_to_message(buff, "Wrong realm name");
          add_to_message(buff, "Usage: cshow X      , X - realm name");
          send_adm_message(type, master, buff, (unsigned char)5);
          break;
        }
        case 6:
        {
          n=get_realmnumber(config, (char *)&buff[(signed long int)ret]);
          if(n >= 0)
          {
            return_value_ServerConfiguration_get_realmsNumber_92=ServerConfiguration_get_realmsNumber(config);
            if(!(n >= return_value_ServerConfiguration_get_realmsNumber_92))
            {
              struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_71;
              return_value_ServerConfiguration_get_realmsTable_71=ServerConfiguration_get_realmsTable(config);
              pointer = return_value_ServerConfiguration_get_realmsTable_71[(signed long int)n];
              i = 0;
              do
              {
                return_value_ServerRealm_get_usersLimit_72=ServerRealm_get_usersLimit(pointer);
                if(i >= return_value_ServerRealm_get_usersLimit_72)
                  break;

                struct anonymous_4 **return_value_ServerRealm_get_usersTable_73;
                return_value_ServerRealm_get_usersTable_73=ServerRealm_get_usersTable(pointer);
                upointer = return_value_ServerRealm_get_usersTable_73[(signed long int)i];
                char return_value_ConnectUser_get_state_91;
                return_value_ConnectUser_get_state_91=ConnectUser_get_state(upointer);
                if(!((signed int)return_value_ConnectUser_get_state_91 == 0))
                {
                  signed int return_value_get_username_74;
                  return_value_get_username_74=get_username(pointer, i);
                  add_to_message(buff, "\nUser[%d]:", return_value_get_username_74);
                  char return_value_ConnectUser_get_state_75;
                  return_value_ConnectUser_get_state_75=ConnectUser_get_state(upointer);
                  switch((signed int)return_value_ConnectUser_get_state_75)
                  {
                    case 5:
                    {
                      add_to_message(buff, "state: closing");
                      break;
                    }
                    case 6:
                    {
                      add_to_message(buff, "state: opening");
                      break;
                    }
                    case 17:
                    {
                      add_to_message(buff, "state: opening (closed)");
                      break;
                    }
                    case 7:
                    {
                      add_to_message(buff, "state: running");
                      break;
                    }
                    case 11:
                    {
                      add_to_message(buff, "state: stopped");
                      break;
                    }
                    default:
                      add_to_message(buff, "state: unknown");
                  }
                  signed int return_value_ConnectUser_get_whatClient_76;
                  return_value_ConnectUser_get_whatClient_76=ConnectUser_get_whatClient(upointer);
                  char *return_value_get_clientname_77;
                  return_value_get_clientname_77=get_clientname(pointer, return_value_ConnectUser_get_whatClient_76);
                  add_to_message(buff, "connected to: Client[%s]", return_value_get_clientname_77);
                  signed long int return_value_ConnectUser_get_connectTime_78;
                  return_value_ConnectUser_get_connectTime_78=ConnectUser_get_connectTime(upointer);
                  tmp = now - return_value_ConnectUser_get_connectTime_78;
                  add_uptime_to_message(buff, "Connection time", tmp);
                  struct anonymous_6 *return_value_ConnectUser_get_stats_79;
                  return_value_ConnectUser_get_stats_79=ConnectUser_get_stats(upointer);
                  signed long int return_value_UserStats_get_lastActivity_80;
                  return_value_UserStats_get_lastActivity_80=UserStats_get_lastActivity(return_value_ConnectUser_get_stats_79);
                  tmp = now - return_value_UserStats_get_lastActivity_80;
                  add_uptime_to_message(buff, "Idle time", tmp);
                  char *return_value_ConnectUser_get_nameBuf_81;
                  return_value_ConnectUser_get_nameBuf_81=ConnectUser_get_nameBuf(upointer);
                  char *return_value_ConnectUser_get_portBuf_82;
                  return_value_ConnectUser_get_portBuf_82=ConnectUser_get_portBuf(upointer);
                  add_to_message(buff, "IP: %s, port: %s", return_value_ConnectUser_get_nameBuf_81, return_value_ConnectUser_get_portBuf_82);
                  struct anonymous_6 *return_value_ConnectUser_get_stats_83;
                  return_value_ConnectUser_get_stats_83=ConnectUser_get_stats(upointer);
                  signed int return_value_UserStats_get_totalDownloadedBytes_84;
                  return_value_UserStats_get_totalDownloadedBytes_84=UserStats_get_totalDownloadedBytes(return_value_ConnectUser_get_stats_83);
                  add_to_message(buff, "Downloaded: %d bytes", return_value_UserStats_get_totalDownloadedBytes_84);
                  struct anonymous_6 *return_value_ConnectUser_get_stats_85;
                  return_value_ConnectUser_get_stats_85=ConnectUser_get_stats(upointer);
                  double return_value_UserStats_get_downloadSpeed_86;
                  return_value_UserStats_get_downloadSpeed_86=UserStats_get_downloadSpeed(return_value_ConnectUser_get_stats_85);
                  add_to_message(buff, "download speed: %.2f B/s", return_value_UserStats_get_downloadSpeed_86);
                  struct anonymous_6 *return_value_ConnectUser_get_stats_87;
                  return_value_ConnectUser_get_stats_87=ConnectUser_get_stats(upointer);
                  signed int return_value_UserStats_get_totalUploadedBytes_88;
                  return_value_UserStats_get_totalUploadedBytes_88=UserStats_get_totalUploadedBytes(return_value_ConnectUser_get_stats_87);
                  add_to_message(buff, "Uploaded: %d bytes", return_value_UserStats_get_totalUploadedBytes_88);
                  struct anonymous_6 *return_value_ConnectUser_get_stats_89;
                  return_value_ConnectUser_get_stats_89=ConnectUser_get_stats(upointer);
                  double return_value_UserStats_get_uploadSpeed_90;
                  return_value_UserStats_get_uploadSpeed_90=UserStats_get_uploadSpeed(return_value_ConnectUser_get_stats_89);
                  add_to_message(buff, "upload speed: %.2f B/s", return_value_UserStats_get_uploadSpeed_90);
                }

                i = i + 1;
              }
              while((_Bool)1);
              send_adm_message(type, master, buff, (unsigned char)3);
              break;
            }

          }

          add_to_message(buff, "Wrong realm name");
          add_to_message(buff, "Usage: ushow X      , X - realm name");
          send_adm_message(type, master, buff, (unsigned char)5);
          break;
        }
        case 7:
        {
          return_value_get_realmname_93=get_realmname(config, realm);
          return_value_get_raclientname_94=get_raclientname(pointer, client);
          aflog((char)8, (char)8, "realm[%s]: Client[%s] (ra): commfd: CLOSED", return_value_get_realmname_93, return_value_get_raclientname_94);
          send_adm_message(type, master, buff, (unsigned char)6);
          return 1;
        }
        case 8:
        {
          i=parse_int(buff, &ret);
          if(!(i >= 1))
          {
            add_to_message(buff, "Invalid timeout value");
            add_to_message(buff, "Usage: timeout N X      , N - new timeout value, X - realm name");
            send_adm_message(type, master, buff, (unsigned char)5);
            break;
          }

          n=get_realmnumber(config, (char *)&buff[(signed long int)ret]);
          if(n >= 0)
          {
            return_value_ServerConfiguration_get_realmsNumber_98=ServerConfiguration_get_realmsNumber(config);
            if(!(n >= return_value_ServerConfiguration_get_realmsNumber_98))
            {
              struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_95;
              return_value_ServerConfiguration_get_realmsTable_95=ServerConfiguration_get_realmsTable(config);
              signed int return_value_ServerRealm_get_timeout_96;
              return_value_ServerRealm_get_timeout_96=ServerRealm_get_timeout(return_value_ServerConfiguration_get_realmsTable_95[(signed long int)n]);
              add_to_message(buff, "changed timeout: %d --> %d", return_value_ServerRealm_get_timeout_96, i);
              struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_97;
              return_value_ServerConfiguration_get_realmsTable_97=ServerConfiguration_get_realmsTable(config);
              ServerRealm_set_timeout(return_value_ServerConfiguration_get_realmsTable_97[(signed long int)n], i);
              send_adm_message(type, master, buff, (unsigned char)3);
              break;
            }

          }

          add_to_message(buff, "Wrong realm name");
          add_to_message(buff, "Usage: timeout N X      , N - new timeout value, X - realm name");
          send_adm_message(type, master, buff, (unsigned char)5);
          break;
        }
        case 9:
        {
          i=parse_int(buff, &ret);
          if(!(i == 0) && !(i == 1))
          {
            add_to_message(buff, "Invalid audit value");
            add_to_message(buff, "Usage: audit {0|1} X      , N=0 off, N=1 on, X - realm name");
            send_adm_message(type, master, buff, (unsigned char)5);
            break;
          }

          n=get_realmnumber(config, (char *)&buff[(signed long int)ret]);
          if(n >= 0)
          {
            return_value_ServerConfiguration_get_realmsNumber_107=ServerConfiguration_get_realmsNumber(config);
            if(!(n >= return_value_ServerConfiguration_get_realmsNumber_107))
            {
              struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_99;
              return_value_ServerConfiguration_get_realmsTable_99=ServerConfiguration_get_realmsTable(config);
              char return_value_ServerRealm_get_auditOn_100;
              return_value_ServerRealm_get_auditOn_100=ServerRealm_get_auditOn(return_value_ServerConfiguration_get_realmsTable_99[(signed long int)n]);
              add_to_message(buff, "changed audit: %s --> %s", return_value_ServerRealm_get_auditOn_100 != 0 ? "yes" : "no", i != 0 ? "yes" : "no");
              struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_101;
              return_value_ServerConfiguration_get_realmsTable_101=ServerConfiguration_get_realmsTable(config);
              ServerRealm_set_auditOn(return_value_ServerConfiguration_get_realmsTable_101[(signed long int)n], (char)i);
              if(i == 0)
              {
                i = 0;
                do
                {
                  return_value_ServerConfiguration_get_realmsTable_102=ServerConfiguration_get_realmsTable(config);
                  return_value_ServerRealm_get_clientsLimit_103=ServerRealm_get_clientsLimit(return_value_ServerConfiguration_get_realmsTable_102[(signed long int)n]);
                  if(i >= return_value_ServerRealm_get_clientsLimit_103)
                    break;

                  struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_104;
                  return_value_ServerConfiguration_get_realmsTable_104=ServerConfiguration_get_realmsTable(config);
                  struct anonymous_3 **return_value_ServerRealm_get_clientsTable_105;
                  return_value_ServerRealm_get_clientsTable_105=ServerRealm_get_clientsTable(return_value_ServerConfiguration_get_realmsTable_104[(signed long int)n]);
                  struct auditlist *return_value_ConnectClient_get_auditList_106;
                  return_value_ConnectClient_get_auditList_106=ConnectClient_get_auditList(return_value_ServerRealm_get_clientsTable_105[(signed long int)i]);
                  AuditList_clear(return_value_ConnectClient_get_auditList_106);
                  i = i + 1;
                }
                while((_Bool)1);
              }

              send_adm_message(type, master, buff, (unsigned char)3);
              break;
            }

          }

          add_to_message(buff, "Wrong realm name");
          add_to_message(buff, "Usage: audit {0|1} X      , N=0 off, N=1 on, X - realm name");
          send_adm_message(type, master, buff, (unsigned char)5);
          break;
        }
        case 10:
        {
          i=parse_int(buff, &ret);
          if(!(i == 0) && !(i == 1))
          {
            add_to_message(buff, "Invalid dnslookups value");
            add_to_message(buff, "Usage: dnslookups {0|1} X      , N=0 off, N=1 on, X - realm name");
            send_adm_message(type, master, buff, (unsigned char)5);
            break;
          }

          n=get_realmnumber(config, (char *)&buff[(signed long int)ret]);
          if(n >= 0)
          {
            return_value_ServerConfiguration_get_realmsNumber_111=ServerConfiguration_get_realmsNumber(config);
            if(!(n >= return_value_ServerConfiguration_get_realmsNumber_111))
            {
              struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_108;
              return_value_ServerConfiguration_get_realmsTable_108=ServerConfiguration_get_realmsTable(config);
              char return_value_ServerRealm_get_dnsLookupsOn_109;
              return_value_ServerRealm_get_dnsLookupsOn_109=ServerRealm_get_dnsLookupsOn(return_value_ServerConfiguration_get_realmsTable_108[(signed long int)n]);
              add_to_message(buff, "changed dnslookups: %s --> %s", return_value_ServerRealm_get_dnsLookupsOn_109 != 0 ? "yes" : "no", i != 0 ? "yes" : "no");
              struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_110;
              return_value_ServerConfiguration_get_realmsTable_110=ServerConfiguration_get_realmsTable(config);
              ServerRealm_set_dnsLookupsOn(return_value_ServerConfiguration_get_realmsTable_110[(signed long int)n], (char)i);
              send_adm_message(type, master, buff, (unsigned char)3);
              break;
            }

          }

          add_to_message(buff, "Wrong realm name");
          add_to_message(buff, "Usage: dnslookups {0|1} X      , N=0 off, N=1 on, X - realm name");
          send_adm_message(type, master, buff, (unsigned char)5);
          break;
        }
        case 11:
        {
          return_value_getdateformat_112=getdateformat();
          __builtin_strncpy(olddf, return_value_getdateformat_112, (unsigned long int)50);
          __builtin_strncpy(newdf, (char *)&buff[(signed long int)ret], (unsigned long int)50);
          add_to_message(buff, "changed dateformat: %s --> %s", (const void *)olddf, (const void *)newdf);
          setdateformat(newdf);
          send_adm_message(type, master, buff, (unsigned char)3);
          break;
        }
        case 12:
        {
          i=parse_int(buff, &ret);
          if(!((signed int)buff[(signed long int)ret] == 0))
          {
            add_to_message(buff, "Invalid user name");
            add_to_message(buff, "Usage: kuser S      , S - user name");
            send_adm_message(type, master, buff, (unsigned char)5);
            break;
          }

          j = -1;
          n = 0;
          do
          {
            return_value_ServerConfiguration_get_realmsNumber_113=ServerConfiguration_get_realmsNumber(config);
            if(n >= return_value_ServerConfiguration_get_realmsNumber_113)
              break;

            struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_114;
            return_value_ServerConfiguration_get_realmsTable_114=ServerConfiguration_get_realmsTable(config);
            pointer = return_value_ServerConfiguration_get_realmsTable_114[(signed long int)n];
            j=get_usernumber(pointer, i);
            if(!(j == -1))
            {
              struct anonymous_4 **return_value_ServerRealm_get_usersTable_115;
              return_value_ServerRealm_get_usersTable_115=ServerRealm_get_usersTable(pointer);
              upointer = return_value_ServerRealm_get_usersTable_115[(signed long int)j];
              char return_value_ConnectUser_get_state_120;
              return_value_ConnectUser_get_state_120=ConnectUser_get_state(upointer);
              if((signed int)return_value_ConnectUser_get_state_120 == 7)
                tmp_if_expr_122 = (_Bool)1;

              else
              {
                return_value_ConnectUser_get_state_121=ConnectUser_get_state(upointer);
                tmp_if_expr_122 = (signed int)return_value_ConnectUser_get_state_121 == 6 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_122)
                tmp_if_expr_124 = (_Bool)1;

              else
              {
                return_value_ConnectUser_get_state_123=ConnectUser_get_state(upointer);
                tmp_if_expr_124 = (signed int)return_value_ConnectUser_get_state_123 == 11 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_124)
              {
                char *return_value_get_realmname_116;
                return_value_get_realmname_116=get_realmname(config, n);
                signed int return_value_get_username_117;
                return_value_get_username_117=get_username(pointer, j);
                add_to_message(buff, "kicked: realm[%s] user[%d]", return_value_get_realmname_116, return_value_get_username_117);
                char return_value_ConnectUser_get_state_119;
                return_value_ConnectUser_get_state_119=ConnectUser_get_state(upointer);
                if((signed int)return_value_ConnectUser_get_state_119 == 6)
                  ConnectUser_set_state(upointer, (char)17);

                else
                {
                  signed int return_value_ConnectUser_get_connFd_118;
                  return_value_ConnectUser_get_connFd_118=ConnectUser_get_connFd(upointer);
                  close(return_value_ConnectUser_get_connFd_118);
                }
                send_adm_message(type, master, buff, (unsigned char)3);
              }

              else
              {
                add_to_message(buff, "Invalid user");
                add_to_message(buff, "Usage: kuser S      , S - user name");
                send_adm_message(type, master, buff, (unsigned char)5);
              }
              break;
            }

            n = n + 1;
          }
          while((_Bool)1);
          if(j == -1)
          {
            add_to_message(buff, "Invalid user name");
            add_to_message(buff, "Usage: kuser S      , S - user name");
            send_adm_message(type, master, buff, (unsigned char)5);
          }

          break;
        }
        case 13:
        {
          i=parse_int(buff, &ret);
          if(!((signed int)buff[(signed long int)ret] == 0))
          {
            add_to_message(buff, "Invalid client number");
            add_to_message(buff, "Usage: kclient N      , N - client number");
            send_adm_message(type, master, buff, (unsigned char)5);
            break;
          }

          j = -1;
          n = 0;
          do
          {
            return_value_ServerConfiguration_get_realmsNumber_125=ServerConfiguration_get_realmsNumber(config);
            if(n >= return_value_ServerConfiguration_get_realmsNumber_125)
              break;

            struct anonymous_5 **return_value_ServerConfiguration_get_realmsTable_126;
            return_value_ServerConfiguration_get_realmsTable_126=ServerConfiguration_get_realmsTable(config);
            pointer = return_value_ServerConfiguration_get_realmsTable_126[(signed long int)n];
            j=get_clientnumber(pointer, i);
            if(!(j == -1))
            {
              struct anonymous_3 **return_value_ServerRealm_get_clientsTable_129;
              return_value_ServerRealm_get_clientsTable_129=ServerRealm_get_clientsTable(pointer);
              char return_value_ConnectClient_get_state_130;
              return_value_ConnectClient_get_state_130=ConnectClient_get_state(return_value_ServerRealm_get_clientsTable_129[(signed long int)j]);
              if((signed int)return_value_ConnectClient_get_state_130 >= 1)
              {
                char *return_value_get_realmname_127;
                return_value_get_realmname_127=get_realmname(config, n);
                char *return_value_get_clientname_128;
                return_value_get_clientname_128=get_clientname(pointer, j);
                add_to_message(buff, "kicked: realm[%s] client[%s]", return_value_get_realmname_127, return_value_get_clientname_128);
                send_adm_message(type, master, buff, (unsigned char)3);
                return i + 2;
              }

              else
              {
                add_to_message(buff, "Invalid client");
                add_to_message(buff, "Usage: kclient N      , N - client number");
                send_adm_message(type, master, buff, (unsigned char)5);
              }
              break;
            }

            n = n + 1;
          }
          while((_Bool)1);
          if(j == -1)
          {
            add_to_message(buff, "Invalid client number");
            add_to_message(buff, "Usage: kclient N      , N - client number");
            send_adm_message(type, master, buff, (unsigned char)5);
          }

          break;
        }
        default:
        {
          char *return_value_get_realmname_131;
          return_value_get_realmname_131=get_realmname(config, realm);
          aflog((char)8, (char)32, "realm[%s]: admin: cmd ignored", return_value_get_realmname_131);
          send_adm_message(type, master, buff, (unsigned char)0);
        }
      }
      break;
    }
    case 2:
      break;
    default:
    {
      aflog((char)8, (char)64, "Unrecognized message from remote admin --> closing");
      return 1;
    }
  }
  return 0;
}

// server_long_usage
// file usage.h line 25
void server_long_usage(char *info)
{
  printf("\n%s\n\n\n", info);
  printf(" Basic options:\n\n");
  printf("  -n, --hostname      - it's used when creating listening sockets\n");
  printf("                        (default: '')\n");
  printf("  -l, --listenport    - listening [host:]port - users connect to it\n");
  printf("                        (default: 50127)\n");
  printf("  -m, --manageport    - manage [host:]port - afclient connects to it\n");
  printf("                        (default: 50126)\n");
  printf("  -V, --version       - display version number\n");
  printf("  -h, --help          - prints this help\n\n");
  printf(" Authorization:\n\n");
  printf("  --pass              - set the password used for client identification\n");
  printf("                        (default: no password)\n\n");
  printf(" Configuration:\n\n");
  printf("  -c, --cerfile       - the name of the file with certificate\n");
  printf("                        (default: server-cert.pem)\n");
  printf("  -A, --cacerfile     - the name of the file with CA certificates\n");
  printf("                        (if used, require clients to have valid certificates)\n");
  printf("  -d, --cerdepth      - the maximum depth of valid certificate-chains\n");
  printf("  -k, --keyfile       - the name of the file with RSA key (default: server.rsa)\n");
  printf("  -f, --cfgfile       - the name of the file with the configuration for the\n");
  printf("                        active forwarder (server)\n");
  printf("  -D, --dateformat    - format of the date printed in logs (see 'man strftime'\n");
  printf("                        for details) (default: %%Y-%%m-%%d %%H:%%M:%%S)\n");
  printf("  -t, --timeout       - the timeout value for the client's connection\n");
  printf("                        (default: 5)\n");
  printf("  --maxidle           - the maximum idle time for the client's connection\n");
  printf("                        (default: disabled)\n");
  printf("  -u, --users         - the amount of users allowed to use this server\n");
  printf("                        (default: 5)\n");
  printf("  -C, --clients       - the number of allowed clients to use this server\n");
  printf("                        (default: 1)\n");
  printf("  -r, --realm         - set the realm name (default: none)\n");
  printf("  -R, --raclients     - the number of allowed clients in remote administration\n");
  printf("                        mode to use this server (default: 1)\n");
  printf("  -U, --usrpcli       - the number of allowed users per client (default: _users)\n");
  printf("  -M, --climode       - strategy used to connect users with clients (default: 1)\n");
  printf("                      Available strategies:\n");
  printf("                        1. fill first client before go to next\n\n");
  printf("  -p, --proto         - type of server (tcp|udp) - what protocol it will be\n");
  printf("                        operating for (default: tcp)\n");
  printf("  -b, --baseport      - listenports are temporary and differ for each client\n");
  printf("  -a, --audit         - additional information about connections are logged\n");
  printf("  --nossl             - ssl is not used to transfer data (but it's still used\n");
  printf("                        to establish a connection) (default: ssl is used)\n");
  printf("  --nozlib            - zlib is not used to compress data (default: zlib is\n");
  printf("                        used)\n");
  printf("  --dnslookups        - try to obtain dns names of the computers rather than\n");
  printf("                        their numeric IP\n\n");
  printf(" Logging:\n\n");
  printf("  -o, --log           - log choosen information to file/socket\n");
  printf("  -v, --verbose       - to be verbose - program won't enter the daemon mode\n");
  printf("                        (use several times for greater effect)\n\n");
  printf(" IP family:\n\n");
  printf("  -4, --ipv4          - use ipv4 only\n");
  printf("  -6, --ipv6          - use ipv6 only\n\n");
  printf(" HTTP PROXY:\n\n");
  printf("  -P, --enableproxy   - enable http proxy mode\n\n");
  exit(0);
}

// server_short_usage
// file usage.h line 24
void server_short_usage(char *info)
{
  printf("\n%s\n\n\n", info);
  printf("Try `afserver --help' for more information.\n");
  exit(1);
}

// server_sig_int
// file server_signals.h line 24
void server_sig_int(signed int signo)
{
  signed int i;
  signed int j;
  unsigned char buff[5l];
  struct anonymous_5 **scRealmsTable;
  signed int return_value_is_this_a_mainthread_1;
  return_value_is_this_a_mainthread_1=is_this_a_mainthread();
  signed int return_value_ServerConfiguration_get_realmsNumber_2;
  signed int return_value_ServerRealm_get_clientsLimit_3;
  signed int return_value_ServerRealm_get_raClientsLimit_12;
  if(!(return_value_is_this_a_mainthread_1 == 0))
  {
    j = 0;
    do
    {
      return_value_ServerConfiguration_get_realmsNumber_2=ServerConfiguration_get_realmsNumber(config);
      if(j >= return_value_ServerConfiguration_get_realmsNumber_2)
        break;

      scRealmsTable=ServerConfiguration_get_realmsTable(config);
      buff[(signed long int)0] = (unsigned char)4;
      i = 0;
      do
      {
        return_value_ServerRealm_get_clientsLimit_3=ServerRealm_get_clientsLimit(scRealmsTable[(signed long int)j]);
        if(i >= return_value_ServerRealm_get_clientsLimit_3)
          break;

        struct anonymous_3 **return_value_ServerRealm_get_clientsTable_10;
        return_value_ServerRealm_get_clientsTable_10=ServerRealm_get_clientsTable(scRealmsTable[(signed long int)j]);
        char return_value_ConnectClient_get_state_11;
        return_value_ConnectClient_get_state_11=ConnectClient_get_state(return_value_ServerRealm_get_clientsTable_10[(signed long int)i]);
        if((signed int)return_value_ConnectClient_get_state_11 == 3)
        {
          char return_value_ServerRealm_get_realmType_4;
          return_value_ServerRealm_get_realmType_4=ServerRealm_get_realmType(scRealmsTable[(signed long int)j]);
          struct anonymous_3 **return_value_ServerRealm_get_clientsTable_5;
          return_value_ServerRealm_get_clientsTable_5=ServerRealm_get_clientsTable(scRealmsTable[(signed long int)j]);
          struct anonymous_1 *return_value_ConnectClient_get_sslFd_6;
          return_value_ConnectClient_get_sslFd_6=ConnectClient_get_sslFd(return_value_ServerRealm_get_clientsTable_5[(signed long int)i]);
          SslFd_send_message(return_value_ServerRealm_get_realmType_4, return_value_ConnectClient_get_sslFd_6, buff, 5);
          struct anonymous_3 **return_value_ServerRealm_get_clientsTable_7;
          return_value_ServerRealm_get_clientsTable_7=ServerRealm_get_clientsTable(scRealmsTable[(signed long int)j]);
          struct anonymous_1 *return_value_ConnectClient_get_sslFd_8;
          return_value_ConnectClient_get_sslFd_8=ConnectClient_get_sslFd(return_value_ServerRealm_get_clientsTable_7[(signed long int)i]);
          signed int return_value_SslFd_get_fd_9;
          return_value_SslFd_get_fd_9=SslFd_get_fd(return_value_ConnectClient_get_sslFd_8);
          close(return_value_SslFd_get_fd_9);
        }

        i = i + 1;
      }
      while((_Bool)1);
      i = 0;
      do
      {
        return_value_ServerRealm_get_raClientsLimit_12=ServerRealm_get_raClientsLimit(scRealmsTable[(signed long int)j]);
        if(i >= return_value_ServerRealm_get_raClientsLimit_12)
          break;

        struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_19;
        return_value_ServerRealm_get_raClientsTable_19=ServerRealm_get_raClientsTable(scRealmsTable[(signed long int)j]);
        char return_value_ConnectClient_get_state_20;
        return_value_ConnectClient_get_state_20=ConnectClient_get_state(return_value_ServerRealm_get_raClientsTable_19[(signed long int)i]);
        if((signed int)return_value_ConnectClient_get_state_20 == 3)
        {
          char return_value_ServerRealm_get_realmType_13;
          return_value_ServerRealm_get_realmType_13=ServerRealm_get_realmType(scRealmsTable[(signed long int)j]);
          struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_14;
          return_value_ServerRealm_get_raClientsTable_14=ServerRealm_get_raClientsTable(scRealmsTable[(signed long int)j]);
          struct anonymous_1 *return_value_ConnectClient_get_sslFd_15;
          return_value_ConnectClient_get_sslFd_15=ConnectClient_get_sslFd(return_value_ServerRealm_get_raClientsTable_14[(signed long int)i]);
          SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType_13 | 4), return_value_ConnectClient_get_sslFd_15, buff, 5);
          struct anonymous_3 **return_value_ServerRealm_get_raClientsTable_16;
          return_value_ServerRealm_get_raClientsTable_16=ServerRealm_get_raClientsTable(scRealmsTable[(signed long int)j]);
          struct anonymous_1 *return_value_ConnectClient_get_sslFd_17;
          return_value_ConnectClient_get_sslFd_17=ConnectClient_get_sslFd(return_value_ServerRealm_get_raClientsTable_16[(signed long int)i]);
          signed int return_value_SslFd_get_fd_18;
          return_value_SslFd_get_fd_18=SslFd_get_fd(return_value_ConnectClient_get_sslFd_17);
          close(return_value_SslFd_get_fd_18);
        }

        i = i + 1;
      }
      while((_Bool)1);
      j = j + 1;
    }
    while((_Bool)1);
    mysleep(0.1);
    signed long int return_value_getcg_21;
    return_value_getcg_21=getcg();
    aflog((char)16, (char)16, "SERVER CLOSED cg: %ld bytes", return_value_getcg_21);
    exit(0);
  }

}

// set_fd
// file http_proxy_functions.c line 235
void set_fd(signed int fd, signed int *maxfdp1, struct anonymous_22 *allset)
{
  allset->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = allset->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
  signed int tmp_if_expr_1;
  if(!(fd >= *maxfdp1))
    tmp_if_expr_1 = *maxfdp1;

  else
    tmp_if_expr_1 = fd + 1;
  *maxfdp1 = tmp_if_expr_1;
}

// set_value
// file server_set.h line 24
void set_value(char **dest, char *from, char *def)
{
  if(*dest == ((char *)NULL))
  {
    if(!(from == ((char *)NULL)))
      string_cp(dest, from);

    else
      *dest = def;
  }

}

// setdateformat
// file logging.h line 63
void setdateformat(char *dateformat)
{
  if(!(dateformat == ((char *)NULL)))
    __builtin_strncpy(format, dateformat, (unsigned long int)50);

}

// sock_ntop
// file network.h line 42
char * sock_ntop(struct sockaddr *sa, unsigned int salen, char *namebuf, char *portbuf, char type)
{
  char portstr[7l];
  struct sockaddr_in *sin;
  unsigned short int tmp_statement_expression_5;
  unsigned short int tmp_statement_expression_3;
  unsigned short int tmp_statement_expression_4;
  struct sockaddr_in6 *sin6;
  unsigned short int tmp_statement_expression_10;
  unsigned short int tmp_statement_expression_8;
  unsigned short int tmp_statement_expression_9;
  switch((signed int)sa->sa_family)
  {    static char str[136l];
    case 2:
    {
      sin = (struct sockaddr_in *)sa;
      if(!(type == 0))
      {
        signed int return_value_getnameinfo_1;
        return_value_getnameinfo_1=getnameinfo(sa, salen, str, (unsigned int)128, (char *)(void *)0, (unsigned int)0, 0);
        if(!(return_value_getnameinfo_1 == 0))
          return (char *)(void *)0;

      }

      else
      {
        const char *return_value_inet_ntop_2;
        return_value_inet_ntop_2=inet_ntop(2, (void *)&sin->sin_addr, str, (unsigned int)sizeof(char [136l]) /*136ul*/ );
        if(return_value_inet_ntop_2 == ((const char *)NULL))
          return (char *)(void *)0;

      }
      if(!(namebuf == ((char *)NULL)))
        memcpy((void *)namebuf, (const void *)str, (unsigned long int)128);

      unsigned short int sock_ntop__1__1__1__4____v;
      unsigned short int sock_ntop__1__1__1__4____x = (unsigned short int)sin->sin_port;
      asm("rorw _8, %w0" : "=r"(sock_ntop__1__1__1__4____v) : "0"(sock_ntop__1__1__1__4____x) : "cc");
      tmp_statement_expression_5 = sock_ntop__1__1__1__4____v;
      if(!((signed int)tmp_statement_expression_5 == 0))
      {
        unsigned short int sock_ntop__1__1__1__5__1____v;
        unsigned short int sock_ntop__1__1__1__5__1____x = (unsigned short int)sin->sin_port;
        asm("rorw _8, %w0" : "=r"(sock_ntop__1__1__1__5__1____v) : "0"(sock_ntop__1__1__1__5__1____x) : "cc");
        tmp_statement_expression_3 = sock_ntop__1__1__1__5__1____v;
        snprintf(portstr, sizeof(char [7l]) /*7ul*/ , ".%d", tmp_statement_expression_3);
        if(!(portbuf == ((char *)NULL)))
        {
          unsigned short int sock_ntop__1__1__1__5__2__1____v;
          unsigned short int sock_ntop__1__1__1__5__2__1____x = (unsigned short int)sin->sin_port;
          asm("rorw _8, %w0" : "=r"(sock_ntop__1__1__1__5__2__1____v) : "0"(sock_ntop__1__1__1__5__2__1____x) : "cc");
          tmp_statement_expression_4 = sock_ntop__1__1__1__5__2__1____v;
          snprintf(portbuf, (unsigned long int)7, "%d", tmp_statement_expression_4);
        }

        strcat(str, portstr);
      }

      return str;
    }
    case 10:
    {
      sin6 = (struct sockaddr_in6 *)sa;
      if(!(type == 0))
      {
        signed int return_value_getnameinfo_6;
        return_value_getnameinfo_6=getnameinfo(sa, salen, str, (unsigned int)128, (char *)(void *)0, (unsigned int)0, 0);
        if(!(return_value_getnameinfo_6 == 0))
          return (char *)(void *)0;

      }

      else
      {
        const char *return_value_inet_ntop_7;
        return_value_inet_ntop_7=inet_ntop(10, (const void *)&sin6->sin6_addr, str, (unsigned int)sizeof(char [136l]) /*136ul*/ );
        if(return_value_inet_ntop_7 == ((const char *)NULL))
          return (char *)(void *)0;

      }
      if(!(namebuf == ((char *)NULL)))
        memcpy((void *)namebuf, (const void *)str, (unsigned long int)128);

      unsigned short int __v;
      unsigned short int __x = (unsigned short int)sin6->sin6_port;
      asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression_10 = __v;
      if(!((signed int)tmp_statement_expression_10 == 0))
      {
        unsigned short int sock_ntop__1__1__2__5__1____v;
        unsigned short int sock_ntop__1__1__2__5__1____x = (unsigned short int)sin6->sin6_port;
        asm("rorw _8, %w0" : "=r"(sock_ntop__1__1__2__5__1____v) : "0"(sock_ntop__1__1__2__5__1____x) : "cc");
        tmp_statement_expression_8 = sock_ntop__1__1__2__5__1____v;
        snprintf(portstr, sizeof(char [7l]) /*7ul*/ , ".%d", tmp_statement_expression_8);
        if(!(portbuf == ((char *)NULL)))
        {
          unsigned short int sock_ntop__1__1__2__5__2__1____v;
          unsigned short int sock_ntop__1__1__2__5__2__1____x = (unsigned short int)sin6->sin6_port;
          asm("rorw _8, %w0" : "=r"(sock_ntop__1__1__2__5__2__1____v) : "0"(sock_ntop__1__1__2__5__2__1____x) : "cc");
          tmp_statement_expression_9 = sock_ntop__1__1__2__5__2__1____v;
          snprintf(portbuf, (unsigned long int)7, "%d", tmp_statement_expression_9);
        }

        strcat(str, portstr);
      }

      return str;
    }
    default:
    {
      snprintf(str, sizeof(char [136l]) /*136ul*/ , "sock_ntop: unknown AF_xxx: %d, len %d", sa->sa_family, salen);
      return str;
    }
  }
  return (char *)(void *)0;
}

// start_critical_section
// file thread_management.h line 28
void start_critical_section(void)
{
  pthread_mutex_lock(&mainmutex);
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 453
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat_1;
  return_value___xstat_1=__xstat(1, __path, __statbuf);
  return return_value___xstat_1;
}

// string_cp
// file string_functions.h line 24
char * string_cp(char **dest, char *src)
{
  char *tmp;
  signed int len = 0;
  if(!(dest == ((char **)NULL)))
  {
    if(!(*dest == ((char *)NULL)))
    {
      if(*dest == src)
        return *dest;

      free((void *)*dest);
      *dest = (char *)(void *)0;
    }

  }

  if(src == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(src);
    len = (signed int)return_value_strlen_1;
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)1, (unsigned long int)(len + 1));
    tmp = (char *)return_value_calloc_2;
    if(tmp == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      __builtin_strncpy(tmp, src, (unsigned long int)len);
      if(!(dest == ((char **)NULL)))
        *dest = tmp;

      return tmp;
    }
  }
}

// timeperiod
// file stats.h line 29
char * timeperiod(signed long int period)
{
  signed int hours;
  signed int minutes;
  signed int seconds;
  static char timeper[41l];
  memset((void *)timeper, 0, (unsigned long int)41);
  hours = (signed int)(period / (signed long int)3600);
  minutes = (signed int)((period / (signed long int)60) % (signed long int)60);
  seconds = (signed int)(period % (signed long int)60);
  if(!(hours == 0))
    sprintf(timeper, "%d:%02d:%02d", hours, minutes, seconds);

  else
    sprintf(timeper, "%d:%02d", minutes, seconds);
  return timeper;
}

// timeval_compare
// file timeval_functions.c line 56
signed int timeval_compare(struct timeval *first, struct timeval *second)
{
  if(first == ((struct timeval *)NULL))
  {
    if(second == ((struct timeval *)NULL))
      return 0;

    return -1;
  }

  else
    if(second == ((struct timeval *)NULL))
      return 1;

    else
      if(!(first->tv_sec >= second->tv_sec))
        return -1;

      else
        if(!(second->tv_sec >= first->tv_sec))
          return 1;

        else
          if(!(first->tv_usec >= second->tv_usec))
            return -1;

          else
            if(!(second->tv_usec >= first->tv_usec))
              return 1;

            else
              return 0;
}

// timeval_create
// file timeval_functions.h line 26
struct timeval timeval_create(signed long int tv_sec, signed long int tv_usec)
{
  struct timeval tmp;
  tmp.tv_sec = tv_sec;
  tmp.tv_usec = tv_usec;
  return tmp;
}

// timeval_lq_zero
// file timeval_functions.c line 121
signed int timeval_lq_zero(struct timeval *timer)
{
  if(timer == ((struct timeval *)NULL))
    return 0;

  else
    if(!(timer->tv_sec >= 0l))
      return 1;

    else
      if(timer->tv_sec == 0l)
      {
        if(!(timer->tv_usec == 0l))
          goto __CPROVER_DUMP_L3;

        return 1;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        return 0;
      }
}

// timeval_subtract
// file timeval_functions.c line 94
signed int timeval_subtract(struct timeval *first, struct timeval *second)
{
  if(first == ((struct timeval *)NULL) || second == ((struct timeval *)NULL))
    return 1;

  else
  {
    if(!(first->tv_usec >= second->tv_usec))
    {
      first->tv_sec = first->tv_sec - (signed long int)1;
      first->tv_usec = ((signed long int)1000000 - second->tv_usec) + first->tv_usec;
    }

    else
      first->tv_usec = first->tv_usec - second->tv_usec;
    first->tv_sec = first->tv_sec - second->tv_sec;
    return 0;
  }
}

// wait_for_condition
// file thread_management.h line 30
void wait_for_condition(void)
{
  pthread_cond_wait(&maincond, &mainmutex);
}

// writen
// file network.c line 513
signed int writen(signed int fd, unsigned char *buf, signed int amount)
{
  signed int sent;
  signed int n;
  sent = 0;
  while(!(sent >= amount))
  {
    signed long int return_value_write_1;
    return_value_write_1=write(fd, (const void *)(buf + (signed long int)sent), (unsigned long int)(amount - sent));
    n = (signed int)return_value_write_1;
    if(!(n == -1))
      sent = sent + n;

    if(n == -1)
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      if(!(*return_value___errno_location_2 == 11))
        return 0;

    }

  }
  return amount;
}

