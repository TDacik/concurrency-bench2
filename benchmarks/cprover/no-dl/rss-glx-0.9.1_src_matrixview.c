// #anon_enum$MagickFalse=0$MagickTrue=1
// file /usr/include/ImageMagick-6/magick/magick-type.h line 211
enum anonymous$59 { MagickFalse=0, MagickTrue=1 };

// #anon_enum$UndefinedChannel=0$RedChannel=1$GrayChannel=1$CyanChannel=1$GreenChannel=2$MagentaChannel=2$BlueChannel=4$YellowChannel=4$AlphaChannel=8$OpacityChannel=8$MatteChannel=8$BlackChannel=32$IndexChannel=32$CompositeChannels=47$AllChannels=134217727$TrueAlphaChannel=64$RGBChannels=128$GrayChannels=128$SyncChannels=256$DefaultChannels=134217719
// file /usr/include/ImageMagick-6/magick/magick-type.h line 177
enum anonymous$60 { UndefinedChannel=0, RedChannel=1, GrayChannel=1, CyanChannel=1, GreenChannel=2, MagentaChannel=2, BlueChannel=4, YellowChannel=4, AlphaChannel=8, OpacityChannel=8, MatteChannel=8, BlackChannel=32, IndexChannel=32, CompositeChannels=47, AllChannels=134217727, TrueAlphaChannel=64, RGBChannels=128, GrayChannels=128, SyncChannels=256, DefaultChannels=134217719 };

// #anon_enum$UndefinedClass=0$DirectClass=1$PseudoClass=2
// file /usr/include/ImageMagick-6/magick/magick-type.h line 204
enum anonymous$12 { UndefinedClass=0, DirectClass=1, PseudoClass=2 };

// #anon_enum$UndefinedColorspace=0$RGBColorspace=1$GRAYColorspace=2$TransparentColorspace=3$OHTAColorspace=4$LabColorspace=5$XYZColorspace=6$YCbCrColorspace=7$YCCColorspace=8$YIQColorspace=9$YPbPrColorspace=10$YUVColorspace=11$CMYKColorspace=12$sRGBColorspace=13$HSBColorspace=14$HSLColorspace=15$HWBColorspace=16$Rec601LumaColorspace=17$Rec601YCbCrColorspace=18$Rec709LumaColorspace=19$Rec709YCbCrColorspace=20$LogColorspace=21$CMYColorspace=22$LuvColorspace=23$HCLColorspace=24$LCHColorspace=25$LMSColorspace=26$LCHabColorspace=27$LCHuvColorspace=28$scRGBColorspace=29$HSIColorspace=30$HSVColorspace=31$HCLpColorspace=32$YDbDrColorspace=33$xyYColorspace=34
// file /usr/include/ImageMagick-6/magick/colorspace.h line 25
enum anonymous$13 { UndefinedColorspace=0, RGBColorspace=1, GRAYColorspace=2, TransparentColorspace=3, OHTAColorspace=4, LabColorspace=5, XYZColorspace=6, YCbCrColorspace=7, YCCColorspace=8, YIQColorspace=9, YPbPrColorspace=10, YUVColorspace=11, CMYKColorspace=12, sRGBColorspace=13, HSBColorspace=14, HSLColorspace=15, HWBColorspace=16, Rec601LumaColorspace=17, Rec601YCbCrColorspace=18, Rec709LumaColorspace=19, Rec709YCbCrColorspace=20, LogColorspace=21, CMYColorspace=22, LuvColorspace=23, HCLColorspace=24, LCHColorspace=25, LMSColorspace=26, LCHabColorspace=27, LCHuvColorspace=28, scRGBColorspace=29, HSIColorspace=30, HSVColorspace=31, HCLpColorspace=32, YDbDrColorspace=33, xyYColorspace=34 };

// #anon_enum$UndefinedCompositeOp=0$NoCompositeOp=1$ModulusAddCompositeOp=2$AtopCompositeOp=3$BlendCompositeOp=4$BumpmapCompositeOp=5$ChangeMaskCompositeOp=6$ClearCompositeOp=7$ColorBurnCompositeOp=8$ColorDodgeCompositeOp=9$ColorizeCompositeOp=10$CopyBlackCompositeOp=11$CopyBlueCompositeOp=12$CopyCompositeOp=13$CopyCyanCompositeOp=14$CopyGreenCompositeOp=15$CopyMagentaCompositeOp=16$CopyOpacityCompositeOp=17$CopyRedCompositeOp=18$CopyYellowCompositeOp=19$DarkenCompositeOp=20$DstAtopCompositeOp=21$DstCompositeOp=22$DstInCompositeOp=23$DstOutCompositeOp=24$DstOverCompositeOp=25$DifferenceCompositeOp=26$DisplaceCompositeOp=27$DissolveCompositeOp=28$ExclusionCompositeOp=29$HardLightCompositeOp=30$HueCompositeOp=31$InCompositeOp=32$LightenCompositeOp=33$LinearLightCompositeOp=34$LuminizeCompositeOp=35$MinusDstCompositeOp=36$ModulateCompositeOp=37$MultiplyCompositeOp=38$OutCompositeOp=39$OverCompositeOp=40$OverlayCompositeOp=41$PlusCompositeOp=42$ReplaceCompositeOp=43$SaturateCompositeOp=44$ScreenCompositeOp=45$SoftLightCompositeOp=46$SrcAtopCompositeOp=47$SrcCompositeOp=48$SrcInCompositeOp=49$SrcOutCompositeOp=50$SrcOverCompositeOp=51$ModulusSubtractCompositeOp=52$ThresholdCompositeOp=53$XorCompositeOp=54$DivideDstCompositeOp=55$DistortCompositeOp=56$BlurCompositeOp=57$PegtopLightCompositeOp=58$VividLightCompositeOp=59$PinLightCompositeOp=60$LinearDodgeCompositeOp=61$LinearBurnCompositeOp=62$MathematicsCompositeOp=63$DivideSrcCompositeOp=64$MinusSrcCompositeOp=65$DarkenIntensityCompositeOp=66$LightenIntensityCompositeOp=67$HardMixCompositeOp=68
// file /usr/include/ImageMagick-6/magick/composite.h line 25
enum anonymous$21 { UndefinedCompositeOp=0, NoCompositeOp=1, ModulusAddCompositeOp=2, AtopCompositeOp=3, BlendCompositeOp=4, BumpmapCompositeOp=5, ChangeMaskCompositeOp=6, ClearCompositeOp=7, ColorBurnCompositeOp=8, ColorDodgeCompositeOp=9, ColorizeCompositeOp=10, CopyBlackCompositeOp=11, CopyBlueCompositeOp=12, CopyCompositeOp=13, CopyCyanCompositeOp=14, CopyGreenCompositeOp=15, CopyMagentaCompositeOp=16, CopyOpacityCompositeOp=17, CopyRedCompositeOp=18, CopyYellowCompositeOp=19, DarkenCompositeOp=20, DstAtopCompositeOp=21, DstCompositeOp=22, DstInCompositeOp=23, DstOutCompositeOp=24, DstOverCompositeOp=25, DifferenceCompositeOp=26, DisplaceCompositeOp=27, DissolveCompositeOp=28, ExclusionCompositeOp=29, HardLightCompositeOp=30, HueCompositeOp=31, InCompositeOp=32, LightenCompositeOp=33, LinearLightCompositeOp=34, LuminizeCompositeOp=35, MinusDstCompositeOp=36, ModulateCompositeOp=37, MultiplyCompositeOp=38, OutCompositeOp=39, OverCompositeOp=40, OverlayCompositeOp=41, PlusCompositeOp=42, ReplaceCompositeOp=43, SaturateCompositeOp=44, ScreenCompositeOp=45, SoftLightCompositeOp=46, SrcAtopCompositeOp=47, SrcCompositeOp=48, SrcInCompositeOp=49, SrcOutCompositeOp=50, SrcOverCompositeOp=51, ModulusSubtractCompositeOp=52, ThresholdCompositeOp=53, XorCompositeOp=54, DivideDstCompositeOp=55, DistortCompositeOp=56, BlurCompositeOp=57, PegtopLightCompositeOp=58, VividLightCompositeOp=59, PinLightCompositeOp=60, LinearDodgeCompositeOp=61, LinearBurnCompositeOp=62, MathematicsCompositeOp=63, DivideSrcCompositeOp=64, MinusSrcCompositeOp=65, DarkenIntensityCompositeOp=66, LightenIntensityCompositeOp=67, HardMixCompositeOp=68 };

// #anon_enum$UndefinedCompression=0$NoCompression=1$BZipCompression=2$DXT1Compression=3$DXT3Compression=4$DXT5Compression=5$FaxCompression=6$Group4Compression=7$JPEGCompression=8$JPEG2000Compression=9$LosslessJPEGCompression=10$LZWCompression=11$RLECompression=12$ZipCompression=13$ZipSCompression=14$PizCompression=15$Pxr24Compression=16$B44Compression=17$B44ACompression=18$LZMACompression=19$JBIG1Compression=20$JBIG2Compression=21
// file /usr/include/ImageMagick-6/magick/compress.h line 25
enum anonymous$14 { UndefinedCompression=0, NoCompression=1, BZipCompression=2, DXT1Compression=3, DXT3Compression=4, DXT5Compression=5, FaxCompression=6, Group4Compression=7, JPEGCompression=8, JPEG2000Compression=9, LosslessJPEGCompression=10, LZWCompression=11, RLECompression=12, ZipCompression=13, ZipSCompression=14, PizCompression=15, Pxr24Compression=16, B44Compression=17, B44ACompression=18, LZMACompression=19, JBIG1Compression=20, JBIG2Compression=21 };

// #anon_enum$UndefinedEndian=0$LSBEndian=1$MSBEndian=2
// file /usr/include/ImageMagick-6/magick/quantum.h line 30
enum anonymous$30 { UndefinedEndian=0, LSBEndian=1, MSBEndian=2 };

// #anon_enum$UndefinedException=0$WarningException=300$ResourceLimitWarning=300$TypeWarning=305$OptionWarning=310$DelegateWarning=315$MissingDelegateWarning=320$CorruptImageWarning=325$FileOpenWarning=330$BlobWarning=335$StreamWarning=340$CacheWarning=345$CoderWarning=350$FilterWarning=352$ModuleWarning=355$DrawWarning=360$ImageWarning=365$WandWarning=370$RandomWarning=375$XServerWarning=380$MonitorWarning=385$RegistryWarning=390$ConfigureWarning=395$PolicyWarning=399$ErrorException=400$ResourceLimitError=400$TypeError=405$OptionError=410$DelegateError=415$MissingDelegateError=420$CorruptImageError=425$FileOpenError=430$BlobError=435$StreamError=440$CacheError=445$CoderError=450$FilterError=452$ModuleError=455$DrawError=460$ImageError=465$WandError=470$RandomError=475$XServerError=480$MonitorError=485$RegistryError=490$ConfigureError=495$PolicyError=499$FatalErrorException=700$ResourceLimitFatalError=700$TypeFatalError=705$OptionFatalError=710$DelegateFatalError=715$MissingDelegateFatalError=720$CorruptImageFatalError=725$FileOpenFatalError=730$BlobFatalError=735$StreamFatalError=740$CacheFatalError=745$CoderFatalError=750$FilterFatalError=752$ModuleFatalError=755$DrawFatalError=760$ImageFatalError=765$WandFatalError=770$RandomFatalError=775$XServerFatalError=780$MonitorFatalError=785$RegistryFatalError=790$ConfigureFatalError=795$PolicyFatalError=799
// file /usr/include/ImageMagick-6/magick/exception.h line 28
enum anonymous$31 { UndefinedException=0, WarningException=300, ResourceLimitWarning=300, TypeWarning=305, OptionWarning=310, DelegateWarning=315, MissingDelegateWarning=320, CorruptImageWarning=325, FileOpenWarning=330, BlobWarning=335, StreamWarning=340, CacheWarning=345, CoderWarning=350, FilterWarning=352, ModuleWarning=355, DrawWarning=360, ImageWarning=365, WandWarning=370, RandomWarning=375, XServerWarning=380, MonitorWarning=385, RegistryWarning=390, ConfigureWarning=395, PolicyWarning=399, ErrorException=400, ResourceLimitError=400, TypeError=405, OptionError=410, DelegateError=415, MissingDelegateError=420, CorruptImageError=425, FileOpenError=430, BlobError=435, StreamError=440, CacheError=445, CoderError=450, FilterError=452, ModuleError=455, DrawError=460, ImageError=465, WandError=470, RandomError=475, XServerError=480, MonitorError=485, RegistryError=490, ConfigureError=495, PolicyError=499, FatalErrorException=700, ResourceLimitFatalError=700, TypeFatalError=705, OptionFatalError=710, DelegateFatalError=715, MissingDelegateFatalError=720, CorruptImageFatalError=725, FileOpenFatalError=730, BlobFatalError=735, StreamFatalError=740, CacheFatalError=745, CoderFatalError=750, FilterFatalError=752, ModuleFatalError=755, DrawFatalError=760, ImageFatalError=765, WandFatalError=770, RandomFatalError=775, XServerFatalError=780, MonitorFatalError=785, RegistryFatalError=790, ConfigureFatalError=795, PolicyFatalError=799 };

// #anon_enum$UndefinedFilter=0$PointFilter=1$BoxFilter=2$TriangleFilter=3$HermiteFilter=4$HanningFilter=5$HammingFilter=6$BlackmanFilter=7$GaussianFilter=8$QuadraticFilter=9$CubicFilter=10$CatromFilter=11$MitchellFilter=12$JincFilter=13$SincFilter=14$SincFastFilter=15$KaiserFilter=16$WelshFilter=17$ParzenFilter=18$BohmanFilter=19$BartlettFilter=20$LagrangeFilter=21$LanczosFilter=22$LanczosSharpFilter=23$Lanczos2Filter=24$Lanczos2SharpFilter=25$RobidouxFilter=26$RobidouxSharpFilter=27$CosineFilter=28$SplineFilter=29$LanczosRadiusFilter=30$SentinelFilter=31
// file /usr/include/ImageMagick-6/magick/resample.h line 32
enum anonymous$24 { UndefinedFilter=0, PointFilter=1, BoxFilter=2, TriangleFilter=3, HermiteFilter=4, HanningFilter=5, HammingFilter=6, BlackmanFilter=7, GaussianFilter=8, QuadraticFilter=9, CubicFilter=10, CatromFilter=11, MitchellFilter=12, JincFilter=13, SincFilter=14, SincFastFilter=15, KaiserFilter=16, WelshFilter=17, ParzenFilter=18, BohmanFilter=19, BartlettFilter=20, LagrangeFilter=21, LanczosFilter=22, LanczosSharpFilter=23, Lanczos2Filter=24, Lanczos2SharpFilter=25, RobidouxFilter=26, RobidouxSharpFilter=27, CosineFilter=28, SplineFilter=29, LanczosRadiusFilter=30, SentinelFilter=31 };

// #anon_enum$UndefinedGravity=0$ForgetGravity=0$NorthWestGravity=1$NorthGravity=2$NorthEastGravity=3$WestGravity=4$CenterGravity=5$EastGravity=6$SouthWestGravity=7$SouthGravity=8$SouthEastGravity=9$StaticGravity=10
// file /usr/include/ImageMagick-6/magick/geometry.h line 77
enum anonymous$19 { UndefinedGravity=0, ForgetGravity=0, NorthWestGravity=1, NorthGravity=2, NorthEastGravity=3, WestGravity=4, CenterGravity=5, EastGravity=6, SouthWestGravity=7, SouthGravity=8, SouthEastGravity=9, StaticGravity=10 };

// #anon_enum$UndefinedIntent=0$SaturationIntent=1$PerceptualIntent=2$AbsoluteIntent=3$RelativeIntent=4
// file /usr/include/ImageMagick-6/magick/profile.h line 42
enum anonymous$11 { UndefinedIntent=0, SaturationIntent=1, PerceptualIntent=2, AbsoluteIntent=3, RelativeIntent=4 };

// #anon_enum$UndefinedInterlace=0$NoInterlace=1$LineInterlace=2$PlaneInterlace=3$PartitionInterlace=4$GIFInterlace=5$JPEGInterlace=6$PNGInterlace=7
// file /usr/include/ImageMagick-6/magick/image.h line 65
enum anonymous$18 { UndefinedInterlace=0, NoInterlace=1, LineInterlace=2, PlaneInterlace=3, PartitionInterlace=4, GIFInterlace=5, JPEGInterlace=6, PNGInterlace=7 };

// #anon_enum$UndefinedInterpolatePixel=0$AverageInterpolatePixel=1$BicubicInterpolatePixel=2$BilinearInterpolatePixel=3$FilterInterpolatePixel=4$IntegerInterpolatePixel=5$MeshInterpolatePixel=6$NearestNeighborInterpolatePixel=7$SplineInterpolatePixel=8$Average9InterpolatePixel=9$Average16InterpolatePixel=10$BlendInterpolatePixel=11$BackgroundInterpolatePixel=12$CatromInterpolatePixel=13
// file /usr/include/ImageMagick-6/magick/pixel.h line 31
enum anonymous$25 { UndefinedInterpolatePixel=0, AverageInterpolatePixel=1, BicubicInterpolatePixel=2, BilinearInterpolatePixel=3, FilterInterpolatePixel=4, IntegerInterpolatePixel=5, MeshInterpolatePixel=6, NearestNeighborInterpolatePixel=7, SplineInterpolatePixel=8, Average9InterpolatePixel=9, Average16InterpolatePixel=10, BlendInterpolatePixel=11, BackgroundInterpolatePixel=12, CatromInterpolatePixel=13 };

// #anon_enum$UndefinedOrientation=0$TopLeftOrientation=1$TopRightOrientation=2$BottomRightOrientation=3$BottomLeftOrientation=4$LeftTopOrientation=5$RightTopOrientation=6$RightBottomOrientation=7$LeftBottomOrientation=8
// file /usr/include/ImageMagick-6/magick/image.h line 77
enum anonymous$15 { UndefinedOrientation=0, TopLeftOrientation=1, TopRightOrientation=2, BottomRightOrientation=3, BottomLeftOrientation=4, LeftTopOrientation=5, RightTopOrientation=6, RightBottomOrientation=7, LeftBottomOrientation=8 };

// #anon_enum$UndefinedPixel=0$CharPixel=1$DoublePixel=2$FloatPixel=3$IntegerPixel=4$LongPixel=5$QuantumPixel=6$ShortPixel=7
// file /usr/include/ImageMagick-6/magick/constitute.h line 25
enum anonymous$29 { UndefinedPixel=0, CharPixel=1, DoublePixel=2, FloatPixel=3, IntegerPixel=4, LongPixel=5, QuantumPixel=6, ShortPixel=7 };

// #anon_enum$UndefinedPixelIntensityMethod=0$AveragePixelIntensityMethod=1$BrightnessPixelIntensityMethod=2$LightnessPixelIntensityMethod=3$Rec601LumaPixelIntensityMethod=4$Rec601LuminancePixelIntensityMethod=5$Rec709LumaPixelIntensityMethod=6$Rec709LuminancePixelIntensityMethod=7$RMSPixelIntensityMethod=8$MSPixelIntensityMethod=9
// file /usr/include/ImageMagick-6/magick/pixel.h line 67
enum anonymous$27 { UndefinedPixelIntensityMethod=0, AveragePixelIntensityMethod=1, BrightnessPixelIntensityMethod=2, LightnessPixelIntensityMethod=3, Rec601LumaPixelIntensityMethod=4, Rec601LuminancePixelIntensityMethod=5, Rec709LumaPixelIntensityMethod=6, Rec709LuminancePixelIntensityMethod=7, RMSPixelIntensityMethod=8, MSPixelIntensityMethod=9 };

// #anon_enum$UndefinedPreview=0$RotatePreview=1$ShearPreview=2$RollPreview=3$HuePreview=4$SaturationPreview=5$BrightnessPreview=6$GammaPreview=7$SpiffPreview=8$DullPreview=9$GrayscalePreview=10$QuantizePreview=11$DespecklePreview=12$ReduceNoisePreview=13$AddNoisePreview=14$SharpenPreview=15$BlurPreview=16$ThresholdPreview=17$EdgeDetectPreview=18$SpreadPreview=19$SolarizePreview=20$ShadePreview=21$RaisePreview=22$SegmentPreview=23$SwirlPreview=24$ImplodePreview=25$WavePreview=26$OilPaintPreview=27$CharcoalDrawingPreview=28$JPEGPreview=29
// file /usr/include/ImageMagick-6/magick/effect.h line 27
enum anonymous$66 { UndefinedPreview=0, RotatePreview=1, ShearPreview=2, RollPreview=3, HuePreview=4, SaturationPreview=5, BrightnessPreview=6, GammaPreview=7, SpiffPreview=8, DullPreview=9, GrayscalePreview=10, QuantizePreview=11, DespecklePreview=12, ReduceNoisePreview=13, AddNoisePreview=14, SharpenPreview=15, BlurPreview=16, ThresholdPreview=17, EdgeDetectPreview=18, SpreadPreview=19, SolarizePreview=20, ShadePreview=21, RaisePreview=22, SegmentPreview=23, SwirlPreview=24, ImplodePreview=25, WavePreview=26, OilPaintPreview=27, CharcoalDrawingPreview=28, JPEGPreview=29 };

// #anon_enum$UndefinedResolution=0$PixelsPerInchResolution=1$PixelsPerCentimeterResolution=2
// file /usr/include/ImageMagick-6/magick/image.h line 90
enum anonymous$17 { UndefinedResolution=0, PixelsPerInchResolution=1, PixelsPerCentimeterResolution=2 };

// #anon_enum$UndefinedTimerState=0$StoppedTimerState=1$RunningTimerState=2
// file /usr/include/ImageMagick-6/magick/timer.h line 25
enum anonymous$50 { UndefinedTimerState=0, StoppedTimerState=1, RunningTimerState=2 };

// #anon_enum$UndefinedType=0$BilevelType=1$GrayscaleType=2$GrayscaleMatteType=3$PaletteType=4$PaletteMatteType=5$TrueColorType=6$TrueColorMatteType=7$ColorSeparationType=8$ColorSeparationMatteType=9$OptimizeType=10$PaletteBilevelMatteType=11
// file /usr/include/ImageMagick-6/magick/image.h line 49
enum anonymous$26 { UndefinedType=0, BilevelType=1, GrayscaleType=2, GrayscaleMatteType=3, PaletteType=4, PaletteMatteType=5, TrueColorType=6, TrueColorMatteType=7, ColorSeparationType=8, ColorSeparationMatteType=9, OptimizeType=10, PaletteBilevelMatteType=11 };

// #anon_enum$UndefinedVirtualPixelMethod=0$BackgroundVirtualPixelMethod=1$ConstantVirtualPixelMethod=2$DitherVirtualPixelMethod=3$EdgeVirtualPixelMethod=4$MirrorVirtualPixelMethod=5$RandomVirtualPixelMethod=6$TileVirtualPixelMethod=7$TransparentVirtualPixelMethod=8$MaskVirtualPixelMethod=9$BlackVirtualPixelMethod=10$GrayVirtualPixelMethod=11$WhiteVirtualPixelMethod=12$HorizontalTileVirtualPixelMethod=13$VerticalTileVirtualPixelMethod=14$HorizontalTileEdgeVirtualPixelMethod=15$VerticalTileEdgeVirtualPixelMethod=16$CheckerTileVirtualPixelMethod=17
// file /usr/include/ImageMagick-6/magick/cache-view.h line 27
enum anonymous$76 { UndefinedVirtualPixelMethod=0, BackgroundVirtualPixelMethod=1, ConstantVirtualPixelMethod=2, DitherVirtualPixelMethod=3, EdgeVirtualPixelMethod=4, MirrorVirtualPixelMethod=5, RandomVirtualPixelMethod=6, TileVirtualPixelMethod=7, TransparentVirtualPixelMethod=8, MaskVirtualPixelMethod=9, BlackVirtualPixelMethod=10, GrayVirtualPixelMethod=11, WhiteVirtualPixelMethod=12, HorizontalTileVirtualPixelMethod=13, VerticalTileVirtualPixelMethod=14, HorizontalTileEdgeVirtualPixelMethod=15, VerticalTileEdgeVirtualPixelMethod=16, CheckerTileVirtualPixelMethod=17 };

// #anon_enum$UnrecognizedDispose=0$UndefinedDispose=0$NoneDispose=1$BackgroundDispose=2$PreviousDispose=3
// file /usr/include/ImageMagick-6/magick/layer.h line 25
enum anonymous$53 { UnrecognizedDispose=0, UndefinedDispose=0, NoneDispose=1, BackgroundDispose=2, PreviousDispose=3 };

// tag-#anon#ST[*{S8}$S8$'res_name'||*{S8}$S8$'res_class'|]
// file /usr/include/X11/Xutil.h line 189
struct anonymous$74;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visual'||U64'visualid'||S32'screen'||S32'depth'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'colormap_size'||S32'bits_per_rgb'|]
// file /usr/include/X11/Xutil.h line 287
struct anonymous$73;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]
// file /usr/include/X11/Xlib.h line 257
struct anonymous$64;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private1'||S32'fd'||S32'private2'||S32'proto_major_version'||S32'proto_minor_version'||*{S8}$S8$'vendor'||U64'private3'||U64'private4'||U64'private5'||S32'private6'||U32'$pad0'||*{U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64}$U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64$'resource_alloc'||S32'byte_order'||S32'bitmap_unit'||S32'bitmap_pad'||S32'bitmap_bit_order'||S32'nformats'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#$'pixmap_format'||S32'private8'||S32'release'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private9'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private10'||S32'qlen'||U32'$pad2'||U64'last_request_read'||U64'request'||*{S8}$S8$'private11'||*{S8}$S8$'private12'||*{S8}$S8$'private13'||*{S8}$S8$'private14'||U32'max_request_size'||U32'$pad3'||*{SYM#tag-_XrmHashBucketRec#}$SYM#tag-_XrmHashBucketRec#$'db'||*{S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32}$S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32$'private15'||*{S8}$S8$'display_name'||S32'default_screen'||S32'nscreens'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#$'screens'||U64'motion_buffer'||U64'private16'||S32'min_keycode'||S32'max_keycode'||*{S8}$S8$'private17'||*{S8}$S8$'private18'||S32'private19'||U32'$pad4'||*{S8}$S8$'xdefaults'|]
// file /usr/include/X11/Xlib.h line 493
struct anonymous$56;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]
// file /usr/include/X11/Xlib.h line 280
struct anonymous$62;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]
// file /usr/include/X11/Xlib.h line 227
struct anonymous$61;

// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$68;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$58;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$55;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$51;

// tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]
// file /usr/include/X11/Xlib.h line 243
struct anonymous$9;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$1;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$57;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$34;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$4;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$28;

// tag-#anon#ST[S32'type'||U32'$pad0'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'resourceid'||U64'serial'||U8'error_code'||U8'request_code'||U8'minor_code'||U40'$pad1'|]
// file /usr/include/X11/Xlib.h line 924
struct anonymous$16;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||S32'extension'||S32'evtype'|]
// file /usr/include/X11/Xlib.h line 948
struct anonymous$22;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||S32'extension'||S32'evtype'||U32'cookie'||U32'$pad2'||*{V}$V$'data'|]
// file /usr/include/X11/Xlib.h line 958
struct anonymous$23;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'drawable'||S32'major_code'||S32'minor_code'|]
// file /usr/include/X11/Xlib.h line 686
struct anonymous$41;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'drawable'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||S32'major_code'||S32'minor_code'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 673
struct anonymous$40;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'|]
// file /usr/include/X11/Xlib.h line 718
struct anonymous$44;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'from_configure'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 727
struct anonymous$45;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'override_redirect'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 737
struct anonymous$46;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'place'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 816
struct anonymous$80;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'x'||S32'y'|]
// file /usr/include/X11/Xlib.h line 782
struct anonymous$70;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'$pad2'||U64'above'||S32'override_redirect'||U32'$pad3'|]
// file /usr/include/X11/Xlib.h line 768
struct anonymous$49;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||U64'parent'||S32'x'||S32'y'||S32'override_redirect'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 756
struct anonymous$48;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'owner'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 857
struct anonymous$3;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'|]
// file /usr/include/X11/Xlib.h line 747
struct anonymous$47;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'place'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 826
struct anonymous;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||S32'override_redirect'|]
// file /usr/include/X11/Xlib.h line 705
struct anonymous$43;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'$pad2'||U64'above'||S32'detail'||U32'$pad3'||U64'value_mask'|]
// file /usr/include/X11/Xlib.h line 801
struct anonymous$77;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 870
struct anonymous$5;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'|]
// file /usr/include/X11/Xlib.h line 934
struct anonymous$32;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||ARR32{S8}$S8$'key_vector'|]
// file /usr/include/X11/Xlib.h line 653
struct anonymous$20;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'mode'||S32'detail'|]
// file /usr/include/X11/Xlib.h line 634
struct anonymous$38;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'request'||S32'first_keycode'||S32'count'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 912
struct anonymous$10;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 696
struct anonymous$42;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'width'||S32'height'|]
// file /usr/include/X11/Xlib.h line 792
struct anonymous$75;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 662
struct anonymous$39;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'atom'||U64'time'||S32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 836
struct anonymous$0;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'colormap'||S32'new'||S32'state'|]
// file /usr/include/X11/Xlib.h line 882
struct anonymous$6;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'message_type'||S32'format'||U32'$pad2'||SYM#tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]#'data'|]
// file /usr/include/X11/Xlib.h line 897
struct anonymous$8;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||S32'mode'||S32'detail'||S32'same_screen'||S32'focus'||U32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 610
struct anonymous$37;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||S8'is_hint'||U24'$pad2'||S32'same_screen'||U32'$pad3'|]
// file /usr/include/X11/Xlib.h line 593
struct anonymous$36;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'button'||S32'same_screen'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 575
struct anonymous$35;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'keycode'||S32'same_screen'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 557
struct anonymous$33;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'selection'||U64'time'|]
// file /usr/include/X11/Xlib.h line 847
struct anonymous$2;

// tag-#anon#ST[S32'x'||S32'y'|]
// file /usr/include/X11/Xutil.h line 88
struct anonymous$69;

// tag-#anon#ST[S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||S32'depth'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visual'||U64'root'||S32'class'||S32'bit_gravity'||S32'win_gravity'||S32'backing_store'||U64'backing_planes'||U64'backing_pixel'||S32'save_under'||U32'$pad0'||U64'colormap'||S32'map_installed'||S32'map_state'||S64'all_event_masks'||S64'your_event_mask'||S64'do_not_propagate_mask'||S32'override_redirect'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#$'screen'|]
// file /usr/include/X11/Xlib.h line 308
struct anonymous$65;

// tag-#anon#ST[S64'flags'||S32'input'||S32'initial_state'||U64'icon_pixmap'||U64'icon_window'||S32'icon_x'||S32'icon_y'||U64'icon_mask'||U64'window_group'|]
// file /usr/include/X11/Xutil.h line 119
struct anonymous$72;

// tag-#anon#ST[S64'flags'||S32'x'||S32'y'||S32'width'||S32'height'||S32'min_width'||S32'min_height'||S32'max_width'||S32'max_height'||S32'width_inc'||S32'height_inc'||SYM#tag-#anon#ST[S32'x'||S32'y'|]#'min_aspect'||SYM#tag-#anon#ST[S32'x'||S32'y'|]#'max_aspect'||S32'base_width'||S32'base_height'||S32'win_gravity'||U32'$pad0'|]
// file /usr/include/X11/Xutil.h line 81
struct anonymous$71;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$63;

// tag-#anon#ST[U64'background_pixmap'||U64'background_pixel'||U64'border_pixmap'||U64'border_pixel'||S32'bit_gravity'||S32'win_gravity'||S32'backing_store'||U32'$pad0'||U64'backing_planes'||U64'backing_pixel'||S32'save_under'||U32'$pad1'||S64'event_mask'||S64'do_not_propagate_mask'||S32'override_redirect'||U32'$pad2'||U64'colormap'||U64'cursor'|]
// file /usr/include/X11/Xlib.h line 290
struct anonymous$67;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$54;

// tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]
// file /usr/include/X11/Xlib.h line 905
union anonymous$7;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$78;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$81;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$52;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$79;

// tag-SemaphoreInfo
// file /usr/include/ImageMagick-6/magick/semaphore.h line 25
struct SemaphoreInfo;

// tag-_Ascii85Info
// file /usr/include/ImageMagick-6/magick/compress.h line 51
struct _Ascii85Info;

// tag-_BlobInfo
// file /usr/include/ImageMagick-6/magick/magick-type.h line 217
struct _BlobInfo;

// tag-_ChromaticityInfo
// file /usr/include/ImageMagick-6/magick/image.h line 123
struct _ChromaticityInfo;

// tag-_ErrorInfo
// file /usr/include/ImageMagick-6/magick/color.h line 62
struct _ErrorInfo;

// tag-_ExceptionInfo
// file /usr/include/ImageMagick-6/magick/magick-type.h line 219
struct _ExceptionInfo;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_Image
// file /usr/include/ImageMagick-6/magick/magick-type.h line 221
struct _Image;

// tag-_ImageInfo
// file /usr/include/ImageMagick-6/magick/magick-type.h line 223
struct _ImageInfo;

// tag-_MagickWand
// file /usr/include/ImageMagick-6/wand/MagickWand.h line 68
struct _MagickWand;

// tag-_PixelPacket
// file /usr/include/ImageMagick-6/magick/pixel.h line 131
struct _PixelPacket;

// tag-_PrimaryInfo
// file /usr/include/ImageMagick-6/magick/image.h line 97
struct _PrimaryInfo;

// tag-_ProfileInfo
// file /usr/include/ImageMagick-6/magick/profile.h line 27
struct _ProfileInfo;

// tag-_RectangleInfo
// file /usr/include/ImageMagick-6/magick/geometry.h line 121
struct _RectangleInfo;

// tag-_Timer
// file /usr/include/ImageMagick-6/magick/timer.h line 32
struct _Timer;

// tag-_TimerInfo
// file /usr/include/ImageMagick-6/magick/timer.h line 40
struct _TimerInfo;

// tag-_XComposeStatus
// file /usr/include/X11/Xutil.h line 231
struct _XComposeStatus;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XEvent
// file /usr/include/X11/Xlib.h line 973
union _XEvent;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-__GLXcontextRec
// file /usr/include/GL/glxew.h line 142
struct __GLXcontextRec;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-xstuff
// file driver.h line 23
struct xstuff;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// AcquireImage
// file /usr/include/ImageMagick-6/magick/image.h line 508
extern struct _Image * AcquireImage(const struct _ImageInfo *);
// AcquireMagickMemory
// file /usr/include/ImageMagick-6/magick/memory_.h line 40
extern void * AcquireMagickMemory(const unsigned long int);
// BZ2_bzBuffToBuffDecompress
// file /usr/include/bzlib.h line 214
extern signed int BZ2_bzBuffToBuffDecompress(char *, unsigned int *, char *, unsigned int, signed int, signed int);
// CloneImageInfo
// file /usr/include/ImageMagick-6/magick/image.h line 523
extern struct _ImageInfo * CloneImageInfo(const struct _ImageInfo *);
// DPMSCapable
// file /usr/include/X11/extensions/dpms.h line 41
extern signed int DPMSCapable(struct _XDisplay *);
// DPMSInfo
// file /usr/include/X11/extensions/dpms.h line 47
extern signed int DPMSInfo(struct _XDisplay *, unsigned short int *, unsigned char *);
// DPMSQueryExtension
// file /usr/include/X11/extensions/dpms.h line 39
extern signed int DPMSQueryExtension(struct _XDisplay *, signed int *, signed int *);
// DestroyImage
// file /usr/include/ImageMagick-6/magick/image.h line 512
extern struct _Image * DestroyImage(struct _Image *);
// DestroyMagickWand
// file /usr/include/ImageMagick-6/wand/MagickWand.h line 106
extern struct _MagickWand * DestroyMagickWand(struct _MagickWand *);
// ExportImagePixels
// file /usr/include/ImageMagick-6/magick/pixel.h line 167
extern enum anonymous$59 ExportImagePixels(const struct _Image *, const signed long int, const signed long int, const unsigned long int, const unsigned long int, const char *, const enum anonymous$29, void *, struct _ExceptionInfo *);
// GetExceptionInfo
// file /usr/include/ImageMagick-6/magick/deprecate.h line 336
extern void GetExceptionInfo(struct _ExceptionInfo *);
// GetImageFromMagickWand
// file /usr/include/ImageMagick-6/wand/magick-image.h line 65
extern struct _Image * GetImageFromMagickWand(const struct _MagickWand *);
// ImportImagePixels
// file /usr/include/ImageMagick-6/magick/pixel.h line 169
extern enum anonymous$59 ImportImagePixels(struct _Image *, const signed long int, const signed long int, const unsigned long int, const unsigned long int, const char *, const enum anonymous$29, const void *);
// MagickContrastImage
// file /usr/include/ImageMagick-6/wand/magick-image.h line 127
extern enum anonymous$59 MagickContrastImage(struct _MagickWand *, const enum anonymous$59);
// MagickGetException
// file /usr/include/ImageMagick-6/wand/MagickWand.h line 93
extern char * MagickGetException(const struct _MagickWand *, enum anonymous$31 *);
// MagickNegateImage
// file /usr/include/ImageMagick-6/wand/magick-image.h line 229
extern enum anonymous$59 MagickNegateImage(struct _MagickWand *, const enum anonymous$59);
// MagickNormalizeImage
// file /usr/include/ImageMagick-6/wand/magick-image.h line 234
extern enum anonymous$59 MagickNormalizeImage(struct _MagickWand *);
// MagickReadImage
// file /usr/include/ImageMagick-6/wand/magick-image.h line 262
extern enum anonymous$59 MagickReadImage(struct _MagickWand *, const char *);
// MagickRelinquishMemory
// file /usr/include/ImageMagick-6/wand/MagickWand.h line 117
extern void * MagickRelinquishMemory(void *);
// MagickScaleImage
// file /usr/include/ImageMagick-6/wand/magick-image.h line 279
extern enum anonymous$59 MagickScaleImage(struct _MagickWand *, const unsigned long int, const unsigned long int);
// MagickWandGenesis
// file /usr/include/ImageMagick-6/wand/MagickWand.h line 115
extern void MagickWandGenesis(void);
// NewMagickWand
// file /usr/include/ImageMagick-6/wand/MagickWand.h line 107
extern struct _MagickWand * NewMagickWand(void);
// ScaleImage
// file /usr/include/ImageMagick-6/magick/resize.h line 41
extern struct _Image * ScaleImage(const struct _Image *, const unsigned long int, const unsigned long int, struct _ExceptionInfo *);
// VirtualRootWindowOfScreen
// file vroot.h line 81
static unsigned long int VirtualRootWindowOfScreen(struct anonymous$64 *screen);
// XCloseDisplay
// file /usr/include/X11/Xlib.h line 2160
extern signed int XCloseDisplay(struct _XDisplay *);
// XCreateColormap
// file /usr/include/X11/Xlib.h line 1552
extern unsigned long int XCreateColormap(struct _XDisplay *, unsigned long int, struct anonymous$61 *, signed int);
// XCreateWindow
// file /usr/include/X11/Xlib.h line 1636
extern unsigned long int XCreateWindow(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, unsigned int, signed int, unsigned int, struct anonymous$61 *, unsigned long int, struct anonymous$67 *);
// XDestroyWindow
// file /usr/include/X11/Xlib.h line 2243
extern signed int XDestroyWindow(struct _XDisplay *, unsigned long int);
// XDisplayName
// file /usr/include/X11/Xlib.h line 1515
extern char * XDisplayName(const char *);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XGetVisualInfo
// file /usr/include/X11/Xutil.h line 471
extern struct anonymous$73 * XGetVisualInfo(struct _XDisplay *, signed long int, struct anonymous$73 *, signed int *);
// XGetWindowAttributes
// file /usr/include/X11/Xlib.h line 2691
extern signed int XGetWindowAttributes(struct _XDisplay *, unsigned long int, struct anonymous$65 *);
// XGetWindowProperty
// file /usr/include/X11/Xlib.h line 2676
extern signed int XGetWindowProperty(struct _XDisplay *, unsigned long int, unsigned long int, signed long int, signed long int, signed int, unsigned long int, unsigned long int *, signed int *, unsigned long int *, unsigned long int *, unsigned char **);
// XInternAtom
// file /usr/include/X11/Xlib.h line 1536
extern unsigned long int XInternAtom(struct _XDisplay *, const char *, signed int);
// XLookupString
// file /usr/include/X11/Xutil.h line 534
extern signed int XLookupString(struct anonymous$33 *, char *, signed int, unsigned long int *, struct _XComposeStatus *);
// XMapWindow
// file /usr/include/X11/Xlib.h line 2806
extern signed int XMapWindow(struct _XDisplay *, unsigned long int);
// XNextEvent
// file /usr/include/X11/Xlib.h line 2841
extern signed int XNextEvent(struct _XDisplay *, union _XEvent *);
// XOpenDisplay
// file /usr/include/X11/Xlib.h line 1483
extern struct _XDisplay * XOpenDisplay(const char *);
// XPending
// file /usr/include/X11/Xlib.h line 2881
extern signed int XPending(struct _XDisplay *);
// XQueryTree
// file /usr/include/X11/Xlib.h line 3017
extern signed int XQueryTree(struct _XDisplay *, unsigned long int, unsigned long int *, unsigned long int *, unsigned long int **, unsigned int *);
// XSetWMProtocols
// file /usr/include/X11/Xlib.h line 1888
extern signed int XSetWMProtocols(struct _XDisplay *, unsigned long int, unsigned long int *, signed int);
// XVisualIDFromVisual
// file /usr/include/X11/Xlib.h line 1728
extern unsigned long int XVisualIDFromVisual(struct anonymous$61 *);
// XmbSetWMProperties
// file /usr/include/X11/Xutil.h line 677
extern void XmbSetWMProperties(struct _XDisplay *, unsigned long int, const char *, const char *, char **, signed int, struct anonymous$71 *, struct anonymous$72 *, struct anonymous$74 *);
// __glewXSwapIntervalSGI$object
//
signed int __glewXSwapIntervalSGI$object(signed int);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 400
extern signed int __xstat(signed int, const char *, struct stat *);
// clearBuffers
// file driver.c line 158
void clearBuffers();
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// createWindow
// file driver.c line 71
void createWindow(signed int argc, char **argv);
// deltaus
// file driver.c line 172
signed int deltaus(struct timeval now, struct timeval then);
// draw_flare
// file matrixview.c line 271
void draw_flare(float x, float y, float z);
// draw_flares
// file matrixview.c line 381
void draw_flares(void);
// draw_illuminatedchar
// file matrixview.c line 249
void draw_illuminatedchar(signed long int num, float x, float y, float z);
// draw_illuminatedtext
// file matrixview.c line 366
void draw_illuminatedtext(void);
// draw_text
// file matrixview.c line 286
void draw_text();
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// glBegin
// file /usr/include/GL/gl.h line 929
void glBegin(unsigned int);
// glBindTexture
// file /usr/include/GL/gl.h line 1311
void glBindTexture(unsigned int, unsigned int);
// glBlendFunc
// file /usr/include/GL/gl.h line 760
void glBlendFunc(unsigned int, unsigned int);
// glClear
// file /usr/include/GL/gl.h line 752
void glClear(unsigned int);
// glClearColor
// file /usr/include/GL/gl.h line 750
void glClearColor(float, float, float, float);
// glClearDepth
// file /usr/include/GL/gl.h line 844
void glClearDepth(double);
// glColor4f
// file /usr/include/GL/gl.h line 1003
void glColor4f(float, float, float, float);
// glColorMaterial
// file /usr/include/GL/gl.h line 1184
void glColorMaterial(unsigned int, unsigned int);
// glColorPointer
// file /usr/include/GL/gl.h line 1130
void glColorPointer(signed int, unsigned int, signed int, const void *);
// glDepthFunc
// file /usr/include/GL/gl.h line 846
void glDepthFunc(unsigned int);
// glDisable
// file /usr/include/GL/gl.h line 798
void glDisable(unsigned int);
// glDrawArrays
// file /usr/include/GL/gl.h line 1145
void glDrawArrays(unsigned int, signed int, signed int);
// glEnable
// file /usr/include/GL/gl.h line 796
void glEnable(unsigned int);
// glEnableClientState
// file /usr/include/GL/gl.h line 803
void glEnableClientState(unsigned int);
// glEnd
// file /usr/include/GL/gl.h line 931
void glEnd(void);
// glFrustum
// file /usr/include/GL/gl.h line 872
void glFrustum(double, double, double, double, double, double);
// glLightfv
// file /usr/include/GL/gl.h line 1161
void glLightfv(unsigned int, unsigned int, const float *);
// glLoadIdentity
// file /usr/include/GL/gl.h line 883
void glLoadIdentity(void);
// glMatrixMode
// file /usr/include/GL/gl.h line 866
void glMatrixMode(unsigned int);
// glNormal3f
// file /usr/include/GL/gl.h line 967
void glNormal3f(float, float, float);
// glRotatef
// file /usr/include/GL/gl.h line 893
void glRotatef(float, float, float, float);
// glShadeModel
// file /usr/include/GL/gl.h line 1157
void glShadeModel(unsigned int);
// glTexCoord2f
// file /usr/include/GL/gl.h line 1042
void glTexCoord2f(float, float);
// glTexCoordPointer
// file /usr/include/GL/gl.h line 1136
void glTexCoordPointer(signed int, unsigned int, signed int, const void *);
// glTexEnvf
// file /usr/include/GL/gl.h line 1259
void glTexEnvf(unsigned int, unsigned int, float);
// glTexParameterf
// file /usr/include/GL/gl.h line 1269
void glTexParameterf(unsigned int, unsigned int, float);
// glTranslatef
// file /usr/include/GL/gl.h line 900
void glTranslatef(float, float, float);
// glVertex3f
// file /usr/include/GL/gl.h line 940
void glVertex3f(float, float, float);
// glVertexPointer
// file /usr/include/GL/gl.h line 1124
void glVertexPointer(signed int, unsigned int, signed int, const void *);
// glViewport
// file /usr/include/GL/gl.h line 876
void glViewport(signed int, signed int, signed int, signed int);
// glXChooseVisual
// file /usr/include/GL/glxew.h line 150
extern struct anonymous$73 * glXChooseVisual(struct _XDisplay *, signed int, signed int *);
// glXCreateContext
// file /usr/include/GL/glxew.h line 153
extern struct __GLXcontextRec * glXCreateContext(struct _XDisplay *, struct anonymous$73 *, struct __GLXcontextRec *, signed int);
// glXMakeCurrent
// file /usr/include/GL/glxew.h line 157
extern signed int glXMakeCurrent(struct _XDisplay *, unsigned long int, struct __GLXcontextRec *);
// glXSwapBuffers
// file /usr/include/GL/glxew.h line 162
extern void glXSwapBuffers(struct _XDisplay *, unsigned long int);
// glewInit
// file /usr/include/GL/glew.h line 19717
extern unsigned int glewInit(void);
// gluBuild2DMipmaps
// file /usr/include/GL/glu.h line 296
signed int gluBuild2DMipmaps(unsigned int, signed int, signed int, signed int, unsigned int, unsigned int, const void *);
// gluErrorString
// file /usr/include/GL/glu.h line 309
const unsigned char * gluErrorString(unsigned int);
// hack_cleanup
// file driver.h line 55
void hack_cleanup(struct xstuff *XStuff);
// hack_draw
// file driver.h line 54
void hack_draw(struct xstuff *XStuff, double currentTime, float frameTime);
// hack_handle_opts
// file driver.h line 51
void hack_handle_opts(signed int argc, char **argv);
// hack_init
// file driver.h line 52
void hack_init(struct xstuff *XStuff);
// hack_reshape
// file driver.h line 53
void hack_reshape(struct xstuff *XStuff);
// handle_global_opts
// file driver.c line 340
void handle_global_opts(signed int c);
// imageLoadingThreadMain
// file matrixview.c line 173
void * imageLoadingThreadMain(void *arg);
// loadNextImage
// file matrixview.c line 185
void loadNextImage();
// loadNextImageFromDisk
// file matrixview.c line 100
void loadNextImageFromDisk();
// load_texture
// file matrixview.c line 495
void load_texture();
// mainLoop
// file driver.c line 176
void mainLoop(void);
// make_change
// file matrixview.c line 466
void make_change(double dCurrentTime);
// make_text
// file matrixview.c line 509
void make_text();
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// ourBuildTextures
// file matrixview.c line 523
void ourBuildTextures();
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$52 *, const union anonymous$81 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$52 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$52 *, union anonymous$79 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$79 *, const union anonymous$81 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$79 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$79 *);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// scroll
// file matrixview.c line 396
void scroll(double dCurrentTime);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// signalHandler
// file driver.c line 397
void signalHandler(signed int sig);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srandom
// file /usr/include/stdlib.h line 324
extern void srandom(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtol_minmaxdef
// file driver.c line 374
signed int strtol_minmaxdef(const char *optarg, const signed int base, const signed int min, const signed int max, const signed int type, const signed int def, const char *errmsg);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);

struct anonymous$74
{
  // res_name
  char *res_name;
  // res_class
  char *res_class;
};

struct anonymous$73
{
  // visual
  struct anonymous$61 *visual;
  // visualid
  unsigned long int visualid;
  // screen
  signed int screen;
  // depth
  signed int depth;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
};

struct anonymous$64
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous$9 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous$61 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous$56
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous$62 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous$64 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous$62
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous$61
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous$68
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$58
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$55
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$51
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$9
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous$61 *visuals;
};

struct anonymous$1
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$57
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$34
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$28
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$63
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$78
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$1 _kill;
  // _timer
  struct anonymous$28 _timer;
  // _rt
  struct anonymous$34 _rt;
  // _sigchld
  struct anonymous$57 _sigchld;
  // _sigfault
  struct anonymous$58 _sigfault;
  // _sigpoll
  struct anonymous$63 _sigpoll;
  // _sigsys
  struct anonymous$68 _sigsys;
};

struct anonymous$4
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$78 _sifields;
};

struct anonymous$16
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous$22
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
};

struct anonymous$23
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
  // cookie
  unsigned int cookie;
  // data
  void *data;
};

struct anonymous$41
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$40
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$44
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
};

struct anonymous$45
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // from_configure
  signed int from_configure;
};

struct anonymous$46
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$80
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$70
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous$49
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$48
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // parent
  unsigned long int parent;
  // x
  signed int x;
  // y
  signed int y;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$3
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // owner
  unsigned long int owner;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$47
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
};

struct anonymous
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$43
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$77
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // detail
  signed int detail;
  // value_mask
  unsigned long int value_mask;
};

struct anonymous$5
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$32
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
};

struct anonymous$20
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // key_vector
  char key_vector[32l];
};

struct anonymous$38
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // mode
  signed int mode;
  // detail
  signed int detail;
};

struct anonymous$10
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // request
  signed int request;
  // first_keycode
  signed int first_keycode;
  // count
  signed int count;
};

struct anonymous$42
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // state
  signed int state;
};

struct anonymous$75
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous$39
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
};

struct anonymous$0
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // atom
  unsigned long int atom;
  // time
  unsigned long int time;
  // state
  signed int state;
};

struct anonymous$6
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // colormap
  unsigned long int colormap;
  // new
  signed int new;
  // state
  signed int state;
};

union anonymous$7
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

struct anonymous$8
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // message_type
  unsigned long int message_type;
  // format
  signed int format;
  // data
  union anonymous$7 data;
};

struct anonymous$37
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // mode
  signed int mode;
  // detail
  signed int detail;
  // same_screen
  signed int same_screen;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct anonymous$36
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // is_hint
  char is_hint;
  // same_screen
  signed int same_screen;
};

struct anonymous$35
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // same_screen
  signed int same_screen;
};

struct anonymous$33
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // keycode
  unsigned int keycode;
  // same_screen
  signed int same_screen;
};

struct anonymous$2
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // selection
  unsigned long int selection;
  // time
  unsigned long int time;
};

struct anonymous$69
{
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous$65
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // depth
  signed int depth;
  // visual
  struct anonymous$61 *visual;
  // root
  unsigned long int root;
  // class
  signed int class;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // colormap
  unsigned long int colormap;
  // map_installed
  signed int map_installed;
  // map_state
  signed int map_state;
  // all_event_masks
  signed long int all_event_masks;
  // your_event_mask
  signed long int your_event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // screen
  struct anonymous$64 *screen;
};

struct anonymous$72
{
  // flags
  signed long int flags;
  // input
  signed int input;
  // initial_state
  signed int initial_state;
  // icon_pixmap
  unsigned long int icon_pixmap;
  // icon_window
  unsigned long int icon_window;
  // icon_x
  signed int icon_x;
  // icon_y
  signed int icon_y;
  // icon_mask
  unsigned long int icon_mask;
  // window_group
  unsigned long int window_group;
};

struct anonymous$71
{
  // flags
  signed long int flags;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // min_width
  signed int min_width;
  // min_height
  signed int min_height;
  // max_width
  signed int max_width;
  // max_height
  signed int max_height;
  // width_inc
  signed int width_inc;
  // height_inc
  signed int height_inc;
  // min_aspect
  struct anonymous$69 min_aspect;
  // max_aspect
  struct anonymous$69 max_aspect;
  // base_width
  signed int base_width;
  // base_height
  signed int base_height;
  // win_gravity
  signed int win_gravity;
};

struct anonymous$67
{
  // background_pixmap
  unsigned long int background_pixmap;
  // background_pixel
  unsigned long int background_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // border_pixel
  unsigned long int border_pixel;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // event_mask
  signed long int event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // colormap
  unsigned long int colormap;
  // cursor
  unsigned long int cursor;
};

union anonymous$54
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$4 *, void *);
};

union anonymous$81
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$52
{
  // __data
  struct anonymous$51 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$79
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _PrimaryInfo
{
  // x
  double x;
  // y
  double y;
  // z
  double z;
};

struct _ChromaticityInfo
{
  // red_primary
  struct _PrimaryInfo red_primary;
  // green_primary
  struct _PrimaryInfo green_primary;
  // blue_primary
  struct _PrimaryInfo blue_primary;
  // white_point
  struct _PrimaryInfo white_point;
};

struct _ErrorInfo
{
  // mean_error_per_pixel
  double mean_error_per_pixel;
  // normalized_mean_error
  double normalized_mean_error;
  // normalized_maximum_error
  double normalized_maximum_error;
};

struct _ExceptionInfo
{
  // severity
  enum anonymous$31 severity;
  // error_number
  signed int error_number;
  // reason
  char *reason;
  // description
  char *description;
  // exceptions
  void *exceptions;
  // relinquish
  enum anonymous$59 relinquish;
  // semaphore
  struct SemaphoreInfo *semaphore;
  // signature
  unsigned long int signature;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _PixelPacket
{
  // blue
  unsigned short int blue;
  // green
  unsigned short int green;
  // red
  unsigned short int red;
  // opacity
  unsigned short int opacity;
};

struct _RectangleInfo
{
  // width
  unsigned long int width;
  // height
  unsigned long int height;
  // x
  signed long int x;
  // y
  signed long int y;
};

struct _Timer
{
  // start
  double start;
  // stop
  double stop;
  // total
  double total;
};

struct _TimerInfo
{
  // user
  struct _Timer user;
  // elapsed
  struct _Timer elapsed;
  // state
  enum anonymous$50 state;
  // signature
  unsigned long int signature;
};

struct _ProfileInfo
{
  // name
  char *name;
  // length
  unsigned long int length;
  // info
  unsigned char *info;
  // signature
  unsigned long int signature;
};

struct _Image
{
  // storage_class
  enum anonymous$12 storage_class;
  // colorspace
  enum anonymous$13 colorspace;
  // compression
  enum anonymous$14 compression;
  // quality
  unsigned long int quality;
  // orientation
  enum anonymous$15 orientation;
  // taint
  enum anonymous$59 taint;
  // matte
  enum anonymous$59 matte;
  // columns
  unsigned long int columns;
  // rows
  unsigned long int rows;
  // depth
  unsigned long int depth;
  // colors
  unsigned long int colors;
  // colormap
  struct _PixelPacket *colormap;
  // background_color
  struct _PixelPacket background_color;
  // border_color
  struct _PixelPacket border_color;
  // matte_color
  struct _PixelPacket matte_color;
  // gamma
  double gamma;
  // chromaticity
  struct _ChromaticityInfo chromaticity;
  // rendering_intent
  enum anonymous$11 rendering_intent;
  // profiles
  void *profiles;
  // units
  enum anonymous$17 units;
  // montage
  char *montage;
  // directory
  char *directory;
  // geometry
  char *geometry;
  // offset
  signed long int offset;
  // x_resolution
  double x_resolution;
  // y_resolution
  double y_resolution;
  // page
  struct _RectangleInfo page;
  // extract_info
  struct _RectangleInfo extract_info;
  // tile_info
  struct _RectangleInfo tile_info;
  // bias
  double bias;
  // blur
  double blur;
  // fuzz
  double fuzz;
  // filter
  enum anonymous$24 filter;
  // interlace
  enum anonymous$18 interlace;
  // endian
  enum anonymous$30 endian;
  // gravity
  enum anonymous$19 gravity;
  // compose
  enum anonymous$21 compose;
  // dispose
  enum anonymous$53 dispose;
  // clip_mask
  struct _Image *clip_mask;
  // scene
  unsigned long int scene;
  // delay
  unsigned long int delay;
  // ticks_per_second
  signed long int ticks_per_second;
  // iterations
  unsigned long int iterations;
  // total_colors
  unsigned long int total_colors;
  // start_loop
  signed long int start_loop;
  // error
  struct _ErrorInfo error;
  // timer
  struct _TimerInfo timer;
  // progress_monitor
  enum anonymous$59 (*progress_monitor)(const char *, const signed long long int, const unsigned long long int, void *);
  // client_data
  void *client_data;
  // cache
  void *cache;
  // attributes
  void *attributes;
  // ascii85
  struct _Ascii85Info *ascii85;
  // blob
  struct _BlobInfo *blob;
  // filename
  char filename[4096l];
  // magick_filename
  char magick_filename[4096l];
  // magick
  char magick[4096l];
  // magick_columns
  unsigned long int magick_columns;
  // magick_rows
  unsigned long int magick_rows;
  // exception
  struct _ExceptionInfo exception;
  // debug
  enum anonymous$59 debug;
  // reference_count
  volatile signed long int reference_count;
  // semaphore
  struct SemaphoreInfo *semaphore;
  // color_profile
  struct _ProfileInfo color_profile;
  // iptc_profile
  struct _ProfileInfo iptc_profile;
  // generic_profile
  struct _ProfileInfo *generic_profile;
  // generic_profiles
  unsigned long int generic_profiles;
  // signature
  unsigned long int signature;
  // previous
  struct _Image *previous;
  // list
  struct _Image *list;
  // next
  struct _Image *next;
  // interpolate
  enum anonymous$25 interpolate;
  // black_point_compensation
  enum anonymous$59 black_point_compensation;
  // transparent_color
  struct _PixelPacket transparent_color;
  // mask
  struct _Image *mask;
  // tile_offset
  struct _RectangleInfo tile_offset;
  // properties
  void *properties;
  // artifacts
  void *artifacts;
  // type
  enum anonymous$26 type;
  // dither
  enum anonymous$59 dither;
  // extent
  unsigned long long int extent;
  // ping
  enum anonymous$59 ping;
  // channels
  unsigned long int channels;
  // timestamp
  signed long int timestamp;
  // intensity
  enum anonymous$27 intensity;
  // duration
  unsigned long int duration;
};

struct _ImageInfo
{
  // compression
  enum anonymous$14 compression;
  // orientation
  enum anonymous$15 orientation;
  // temporary
  enum anonymous$59 temporary;
  // adjoin
  enum anonymous$59 adjoin;
  // affirm
  enum anonymous$59 affirm;
  // antialias
  enum anonymous$59 antialias;
  // size
  char *size;
  // extract
  char *extract;
  // page
  char *page;
  // scenes
  char *scenes;
  // scene
  unsigned long int scene;
  // number_scenes
  unsigned long int number_scenes;
  // depth
  unsigned long int depth;
  // interlace
  enum anonymous$18 interlace;
  // endian
  enum anonymous$30 endian;
  // units
  enum anonymous$17 units;
  // quality
  unsigned long int quality;
  // sampling_factor
  char *sampling_factor;
  // server_name
  char *server_name;
  // font
  char *font;
  // texture
  char *texture;
  // density
  char *density;
  // pointsize
  double pointsize;
  // fuzz
  double fuzz;
  // background_color
  struct _PixelPacket background_color;
  // border_color
  struct _PixelPacket border_color;
  // matte_color
  struct _PixelPacket matte_color;
  // dither
  enum anonymous$59 dither;
  // monochrome
  enum anonymous$59 monochrome;
  // colors
  unsigned long int colors;
  // colorspace
  enum anonymous$13 colorspace;
  // type
  enum anonymous$26 type;
  // preview_type
  enum anonymous$66 preview_type;
  // group
  signed long int group;
  // ping
  enum anonymous$59 ping;
  // verbose
  enum anonymous$59 verbose;
  // view
  char *view;
  // authenticate
  char *authenticate;
  // channel
  enum anonymous$60 channel;
  // attributes
  struct _Image *attributes;
  // options
  void *options;
  // progress_monitor
  enum anonymous$59 (*progress_monitor)(const char *, const signed long long int, const unsigned long long int, void *);
  // client_data
  void *client_data;
  // cache
  void *cache;
  // stream
  unsigned long int (*stream)(const struct _Image *, const void *, const unsigned long int);
  // file
  struct _IO_FILE *file;
  // blob
  void *blob;
  // length
  unsigned long int length;
  // magick
  char magick[4096l];
  // unique
  char unique[4096l];
  // zero
  char zero[4096l];
  // filename
  char filename[4096l];
  // debug
  enum anonymous$59 debug;
  // tile
  char *tile;
  // subimage
  unsigned long int subimage;
  // subrange
  unsigned long int subrange;
  // pen
  struct _PixelPacket pen;
  // signature
  unsigned long int signature;
  // virtual_pixel_method
  enum anonymous$76 virtual_pixel_method;
  // transparent_color
  struct _PixelPacket transparent_color;
  // profile
  void *profile;
  // synchronize
  enum anonymous$59 synchronize;
};

struct _XComposeStatus
{
  // compose_ptr
  char *compose_ptr;
  // chars_matched
  signed int chars_matched;
};

union _XEvent
{
  // type
  signed int type;
  // xany
  struct anonymous$32 xany;
  // xkey
  struct anonymous$33 xkey;
  // xbutton
  struct anonymous$35 xbutton;
  // xmotion
  struct anonymous$36 xmotion;
  // xcrossing
  struct anonymous$37 xcrossing;
  // xfocus
  struct anonymous$38 xfocus;
  // xexpose
  struct anonymous$39 xexpose;
  // xgraphicsexpose
  struct anonymous$40 xgraphicsexpose;
  // xnoexpose
  struct anonymous$41 xnoexpose;
  // xvisibility
  struct anonymous$42 xvisibility;
  // xcreatewindow
  struct anonymous$43 xcreatewindow;
  // xdestroywindow
  struct anonymous$44 xdestroywindow;
  // xunmap
  struct anonymous$45 xunmap;
  // xmap
  struct anonymous$46 xmap;
  // xmaprequest
  struct anonymous$47 xmaprequest;
  // xreparent
  struct anonymous$48 xreparent;
  // xconfigure
  struct anonymous$49 xconfigure;
  // xgravity
  struct anonymous$70 xgravity;
  // xresizerequest
  struct anonymous$75 xresizerequest;
  // xconfigurerequest
  struct anonymous$77 xconfigurerequest;
  // xcirculate
  struct anonymous$80 xcirculate;
  // xcirculaterequest
  struct anonymous xcirculaterequest;
  // xproperty
  struct anonymous$0 xproperty;
  // xselectionclear
  struct anonymous$2 xselectionclear;
  // xselectionrequest
  struct anonymous$3 xselectionrequest;
  // xselection
  struct anonymous$5 xselection;
  // xcolormap
  struct anonymous$6 xcolormap;
  // xclient
  struct anonymous$8 xclient;
  // xmapping
  struct anonymous$10 xmapping;
  // xerror
  struct anonymous$16 xerror;
  // xkeymap
  struct anonymous$20 xkeymap;
  // xgeneric
  struct anonymous$22 xgeneric;
  // xcookie
  struct anonymous$23 xcookie;
  // pad
  signed long int pad[24l];
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$54 __sigaction_handler;
  // sa_mask
  struct anonymous$55 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct xstuff
{
  // commandLineName
  char *commandLineName;
  // display
  struct _XDisplay *display;
  // screen_num
  signed int screen_num;
  // rootWindow
  unsigned long int rootWindow;
  // window
  unsigned long int window;
  // existingWindow
  unsigned long int existingWindow;
  // windowWidth
  unsigned int windowWidth;
  // windowHeight
  unsigned int windowHeight;
  // gc
  struct _XGC *gc;
  // colourMap
  unsigned long int colourMap;
  // hackstuff
  void *hackstuff;
};


// Light_Ambient
// file matrixview.c line 43
float Light_Ambient[4l] = { 0.1f, 0.1f, 0.1f, 1.0f };
// Light_Diffuse
// file matrixview.c line 44
float Light_Diffuse[4l] = { 1.2f, 1.2f, 1.2f, 1.0f };
// Light_Position
// file matrixview.c line 45
float Light_Position[4l] = { 2.0f, 2.0f, 0.0f, 1.0f };
// XStuff
// file driver.c line 52
struct xstuff *XStuff;
// __GLXEW_SGI_swap_control
// file /usr/include/GL/glxew.h line 1733
extern unsigned char __GLXEW_SGI_swap_control;
// __glewXSwapIntervalSGI
// file /usr/include/GL/glxew.h line 1652
extern signed int (*__glewXSwapIntervalSGI)(signed int);
// bump_pic
// file matrixview.c line 73
float bump_pic[77120l];
// cfont
// file matrixview_textures.c line 3
unsigned char *cfont = "BZh91AY&SY\020\0 k\177&S\ta2L&\023(d2\031\fS!#@\017[\002mlmdZLml0.Jmf\005TXl4V\001JVAjBR[bl\024\022H\0\016:\n]RMZJU\\\004U!Jj]+Z{n(SU^\rI\n)x\0>\n\036m\017}yt\003u\036_w\016``\033=\027+n] \021\003AEe::^\036\024\032\t@\005M\005\033k\036w\022S\vo{G}}Gw\034buUfkO.<\0\0\0\0)\002\002\002\004\006\0&\0@h{I\032\030FS \b\020\002\001\002diL\f$\032\th\0\003@\0\b\0022\0hLa\032h\025=?LLLOQ\0\r=\022A\n\f*=\tzj{MSjh\006\001\006\032\0\0\020\020\002\032TOJ~bh14F\003A\021hh\fM$S\023\r\023\002h2L\006)z%=OP\032?T\021\0\0\001\016\aLd\026\005$\t;, )\0`Aa!1%HO{t\036!\aE!B+}'MPy&USMH+ \001\025}Y@\031\0y\036\022sX\025F~~g(P\177 _hA/\006\027\177\030\177t[h\025SP\020H\017W\020\ry\bR\a\031K\017\030\037{\0\023\022Id[\t!\031>{@\"\",~h7\033 }_u&\017[}!_\0\035\016\016hm-](Q\002U]O^P@a\024:d\017J\020CY?:?\037G;I$o?\f\tg\032IvI6=4\tH\023l\003C \0\a>t\t\017P+-<v`)Y\f\0\025#\003\0J\v![\023\023a+\t(VC-\035\016vQS\a|<\023|)<FI{)\rl\024 \031%@\036Q\0\017$1$\022B@?*Hy\020|>\\!C_\005<\t+\023\035|\027\037w*x'c)'_\002\037F|$\037i\0C$s\002CI'VI$;Y'}!\022'B\006x\031d=\a{k]qw!B~@;l\003{\v{9\t@\020zlRB|\t\016=I\t$'s'j\005tJI\026\035O\016q\0\r\001@\\\001\030\037T\177\035rY\"C\r\036B<VW\032\034E<\0352Gl=:m\aI+YPGvCy\027d\bVQR\026:OUB/8{,\ac\034q\0\026e\006\022A\023/oXn[_\001\0355\177sj\"4\030;;\031K\005T\025\"+!&~^'}\026\020\002\fufr\030O\tii\\^O.\033ko\002Wdk*wUMLf\023`Y@eAD\025\016t=7rvb\nyC\023)K\035\022q4C\036.m-dT|'\017,Z{O6.\\y}M'\003G\\\032!>MHH5rS\"\033E\027T\036\020dmD{ZVOy'\025\020U\005UE\032\002'sUUTH^\033;ZwrSUvCo\0*yE(+\003\004mWW:'\ajXdQeN\024Cd\001k\021':\034\031%\033'BP%IO}\026Eiz\033SPh\vsy\r\v\0\024s\021kE.0!UDUYV\017+Y\a\021A:H'9\001Sb|dE$*=r[\by\034Hm;VEoI(\023f\022'4\"EzO\002A\032\037{L\024\nU\003w^\016\036\022\020]\004&*LM2V\003\027P E7o\027OV\032LF+JR\026\016x'X@rE@U>\024\027{'&J\001\003\023I%tIPx,\004AM^\005\017W#^7Dx\\[7W\034WU(\034kH9S*\035=\003\rRt}ANH\006n~|mw\n]fCY\026Du\004{&FHEM`\v\022$\005ELkhS*w^Ez,Z;\023\023KW\tZ\026\027.CN>rW\004{7-z6LL'\033&\\\002\r\034\026TM!\036))k'HAyhH%\036O\fklh\027^R.G}\0C&p2\037k?\\\020\034l\t<\004qD(DR\025~\005K+\031Yh\031Px\016w-\030,@n\0\023wlKaSh[b)xrA,ZFrbWxvViR\004\021fa)<JK\021L=\003m|_\t\0\026^ZI_/\002<\"CUT\031K\033!yX*\003G\v/2\023\002hIi*:\004\036oi`m\022\t@\b\036#.8<:/5\177BkNO\016}\024\"\"DW<%\001-\004\001SEhUG\016MqJRj:$\022,G\021\025Xlz\033\026Gm,5\006p]\036-E\016s)]b\a\032b\001\vng\001>\r|\021\001Htg9F)#\t\a\024c&#MHF`\021zTA.#%(\n(\002O&S\fB6\031\004scDmp\031i\022N)}Md\032%d\003\032m\024\f:m\n^\t&j\006NS\021r!I\002((cO!X\031J;OVoI(@&Xmpm+\024*pz\024,\aLN/)\020Dml)\032mM&x@|\t\",cF5\024ME+e:s+m\0312\020H>*5\\p\v\035b\020_5,86\asgJ'?Hba)c)ZGVM5\016)H'\033\023=-\017s2t\aZk\006Q\n\024\026yc\016FZJT4}\036\033dr\nYc[jX\020XB'cc6\017PK&PX\001\"ZE$\a}\031\027_\030x:CR;?$|\032,\020g;;\034q\b\020bY^\033]\021_Kd_\006`Wqq%W@pl\f\016n\0(\0TaV)\024\031\004Gyj|e,de,F\016}FE)\0;m\035e,\021M[\034RE\024Rs{\021J \035r!\vjGV'\005 .Lr6QoI\v\034C\026,r]\"$J\0\001i\021Od\021\005-pb\004vc}A\016@\"I\0350@=M\021LM7Ccu\036AOHWrc\\*\n.et\024X%KJ\020k\026@F\036Mm!&@\004b\030L\031hQ+s(Z\b\022UQ\025lIIY\005XME\033l\0 Z[I\021e-\002Am*K{\026@\"\026B4iJ'5'\rBa\nZH]qeh[QP\006\022Q8@zNH\01;{^Lco\n] \030_F\031N#@Z|w%\ve\037\002V\".QJ+\024SmV';M}\023A]VvK\\b6H\n\017[^{H\n\"N(<wD\026TKcJ-\030PEEP\023Ei~[EbBFEe\006%e\006;#%1\rYl\177\004\022B\".\002T1Xx)\031;Pb\016\"_bE$\bD>\n*/JZU+'hrm\035aWtA1$IBE\021EEi#\004QHE*,\002\\:6.l\031DP\b\nAewE\016\025J_]+(p}f\021Q\026DkMTabA\034\"Fg\025BGTA\0253FHsj\b\"\n)4%.\024\fuSr&&puLFA1\bULk%\n>y\004Q\021S\022\n\025\004\024\003l\"*\"*D\004\033\004\024^\rg\bp\003.HPPb(L:@Br\rTk2\021#Snm-\021^de0r,YVH\022R1\a=l\026_9s#B\"B4\\\b\n*L^V*C#\bpKZ\025ED\\\022MAHQ\r\035c2\031q\026\vmJ[e\022(T\030\002\035\nYEhxj\026$!h\001\032={{f2\025MQ/q\025~W'vKl\025DJ2EmfcB,!F$Y\002Ofrd2\\+KZZW\006TUDXUT\023\023&\020,\021$\020%D \021#^)K},J(Xf#rFDF\025J\025gUY\026,(zP-e`\033JR\027JJ5Y\005-\024qh6RR)j'>Y\027JPRPRseR\020\"(wm^NWImb\032(m\017M!X\034R\v (**\025U\026(WV\025\024\"CI(_\004\"j\033me-J\002A\021\023\nQ\026Cs*@- U\024sAp@!\031$\021iXRs12T\"\024xLh1y!r\aWuTD\002+\004xeu+\005\006n\\R(m,ME\022.JEkt%z^M1QF\bl\0n;Vm'd\024`W\032\\\032>(v\\e;\"h-(b4*+,A+U\024\022MNqh#`S\004Rb\001Q/\nm*,%\026*e\bXQ\006D)Qj D\021\026,QVGi4J*aj5VZW.rQ8:7B1Lb\b(\032\020J~?\031\021DU\023i)\005\024EE'XA:jKZTUPU##\004E\035.e\vb2E|X!HHADgI\036\re\005\fQMn%\033\020 F\026#u\\hY\034@<sR$\b4\032Du\024seTN(1l7y\v\024\026c(\026\"ET1gEUQzME\021N.PA\005\bM*[,ADiiS\b*8dEG i\024\025rE\025^LFT\027\027V[\031Q]\033\002\" \025\"#\004A`\033H<.CK+iY\fx\016m\034\034Wfb/\026]%aDR(\020i\021\b\\\b*-%\033\024EE\b\b bk\034\004\bCZ\025R$E\026\031\"\005#i\020 k\022\004Ee\0363\vuY[N\033\031\016#\034-)e\tH\bV#$m\033N)0\nlM8Km\"\027\034\tZ5fTR+\025\b\002`w\tP\022jERG>\016 ETS\022\026(\025Xh=t1V*EGNe)\025\0303t1VEZ\\b\021Kj0E\001Eb1k\v[\024\021\025x5\021Vi\005Uh3oW\030KPV\006{RV6^EU\025aw80U\025j(\\\025\021EiU\027s\021\b_K,BIG\026[*]elPzv<-E\001vh&\026(T\r+\003QTb]\006&$G}XmJ\005Ub3rWH(KUU!.i\021,9\033J#mYAU\022\026XW{>m(`EP\025\020JY\r,z5\026\002$Q][[g;\021\031\v \004\024\"\026tPVyGAU\027`iWT\0|$\006\t}F*trI\005\t\030#J\r\"*w5\025@FZ\024m,\024WXb#*m\025\";`Et()S\021S\034+c1\001.\024b)P/&\025|lX\"1q\fTwMZB\rT|Xi7u -Pd\021&7L\026*\024AUcjzM\031aiErUF\"\f`GLo%\006\024d! *1\"\035wy\026**\r* E\005A{K*T+bEFE\"\025\021z+\001E\034lC\020YP\\S*\025VFc\v\rj_\026\rR\" *;\f\025u]3V\viXLq\026VPQV\vX(\021XE*\005(\n\005E\033e\vR!\002\"\025\024SOm\003\020D`J\035+TTkM!M)\001WSh\025EtQdX\n@Zs2\025X\033LEkfY\005d\021XK\026B\020:I\001aDWI_\022S(T\016J\vJ\002A6ecmHVX[DE\002^\002lX\004\024\033G2e--\016Q\034Cd\023)$i`I\"JJVE\"\001X\b*-\fE mATY \nWR:Z\003x\021t+d\021QY,\033?#X\nmN\0373Ws\nc\t~\017?\006\037\004!\t\b\035\020}l_O~t}!\a\023N|n&\034$k\177j\a?{\021;T\036g(@h\177oT\177a\\r\025zRJRa\fPZ'?I-%DL\032N%A{x\037\025\024X/k,7\025=w'\034\\='W2\177^#Am*J|SF2H#\006RT0\016o\004\036[5x.\vRH\022ilb\006q-t'^Wy\bh=}\036^BP\030Lq2`D\bbzV\035;l\023\nB\005\"j\037qT\022'S\006HU&Q\001\033YkB\032~h\006\016C^\024\bs\037Ju9\024\035n+y\016bbVr\027G\032\0\004\177<<\033&(Z}<eM|!\023_b<\"\026\t|\\)\\\b{m>\017~,=_^/EQjoOTFGW\030b\024W6\"\v\032+\"M24E(\177-DN\035c\034\\\023;\036_t)\017wK\022>Z4\".%9\ft-iZs\005\016R\005x\020\002\036S=pC^\vjsv`\031SK\036Y!v\025`\023\b\026c~L}N6gL\035r&\037usMU\aE\\TD\026BLkN1AuLyz\035\004%\033\faCu[Zv'\003zeZN=[Gm\005ki=%\v\036/KZhMseVC\031\024tRk\nl\032x\004\034\017wP1#I\033-\035\033KK]D+#~\036)\016gn==@4\006EI1kuX\025C;v6d5fwbF;IB=jSo%a\bolO9P4*of94\032\"\027cv\177V\026\033\r\024\022.L\033@uMDASZ\032\026~[\033iY\v\026._\001GRVS\023naV\033M^\016\004\023fK\036d\005\b\nXrf\001)\006r\031\032t(\v\020MbN+!2$b?s.#-50Tox\\v\\_\036XdLYI\004ZJa5\037/KV\006#f!$\005\022'\004]m,I\\`yM\t!\030)[\0\vv[\026\b\017.j\027l\bp\004n.[CeRN\030%PN\\p\027X~jbhFA*\aF=\023[\033.J%vlot\020q\035\006\021H!^t*SbHp`-+\032\017%g\027\027$$q\f?<\bZ\an\a\037\035\t\\\033wC\020%16k_Ch3cm\003++.\006&\rWsAf\004%\v'AV85,l\\\032,\023S.fBX\\\023f\\# q\bwBhhKLy-\025TslGt3\aA\004wU\f:L(&O\006<\bi{#>bzfB\tlG/$+M6\t\bjtV\f@~.9z\np^qv\fG IeZL\035[]x]S\025|!@}\021o\023-| ])fr\034\032 \nc\003V!6WlM\a/{lk(/U/l{.(\032\\\003#\"P>\021n\002FC\002>\016\005$:CK06]\035&:)k=\034g\033Hhimju\v9GAz)qtr/D \022/,o.be:%\021n~\027\002Q\031&4\001\f=!~{\"D\032\005\006%\034k\035N{)\001TNi\034Yn<<3;:\r$bDIy\b;\023\017)S\026Fk$\021\032sd}W\006\006]E\035!!\032\031q[x4\026O\f*bK\025C\b\027\021\036r).A\017\b\022@\017\022i3\0J\037[\020h2\fxU\bY\004\030\037\027i\026K\002V\030BK\021fR\nvpuw\t`e;vZ\021l$/>G6Z[n'iep\025Up\"\022\036\033,I\037\005\031W4!!w\fp\036Js#,1;\re[I.I\034fTS:-`\006Q>(G\022\021UUK\001z>\023\022\004\020G\026#\006_WsPQ<hx\035!A~xEBA:\032\n\037^U\023Fc|RBb{rT\003v_w.l\0cm_ii\005\0\001\024%i\n*\"EHd\021'}YG/RX^D\034I'YM9)nes\024qpUK\006[w~A1d_\036fH\025d,m\024<%>{J\004\\h-\b\001(%(\032Vnq \"h\025w|Tgl0AQ%!o\033\001mT0\031'~\tg\\\022&\035\035\"/7\034a&P(wdcN\035Wl0i\001\005vC>]6qIW&'Y\f{e\006d/?]Lv!x\\vm-I0J$3 'L\tPmhSnW\026\005&\026eu\036?j\020R\004\fh\002zLGzC\annP6`dOts_>L)R7 $.gt[\002\031q\020uB\026J$\024am+gMXO&My:\\2\",\005cS'A<v=;\006>\"+o\034xg\004+9.c,\025\004{GyJ\001d\005#nUC)?+j!e+Z?1VKt-M\n\002I\0279m\003ta\003B\tTCz$9\025[ZNa]H*`)UT\n{<-\nm$@\tGav\031,n|\032HV&uT\023v,\n\035^\bzm@Pb|fu\037u\023Zw$+|v\026d1w\vuX,Ly\027mS'A\024\021<!\006\a\"\t`pB\0\005\031\tcvYy4\006xN+G\027,wy\006=XLKt\027n\\Ow5\006_\006SVn_\021;i+DvfF{2}Wp\tV7\177/0\\c\020Pa1\030|]gy]e<\035vL\031\031BB\004\003&(s(D\037z\ak*#qK\026Yx1{Y\vo:XTY\020UDr\037\030W\035$uD8j\022\bT{|j-0;Ojd\021\ty\016\027ogm\nBQD$Q,zj]\020FaTaM\027b\006\\@N!HV\025@\t@bq69\036\022e\0HR <\004SO\032\003Ew7)\021I\002`!6&CCk]S#mloC}A&q!uzI\033\016\004b;\004\004x\027+B\027\003hG-\025\002f\030YQp)F\003LDnn{'v$0#V\022#\022\005\a\025R\026,l\034w\026'(pj(R3)0t.Qz\030Y.^$+4 lVx<t\rXbarmapp\006xsN\034WB5`\022 =5jlP-M V,W\033at<\006Y\006\\\bf\033\\7f\026\005\026!\023]nG\023-r\vh\004b*]\003{H\n\016Mi):X\024}@EWf`^IGL]$pZaf^k\bm\027F2Z\033w^%\v\023CC!u^6LWc`\v!?FnU\037\030)u\026j\021!\027\001\032\003(\nY\r\"\":{\026\003urtaRz\003\034IL4VbHio\f#p\022g\001T\023\001kFAo(m\033\177\017\001\003I<U\017CaCy~|;\016Z(\020;Dh@\003a>dRmd\017{?}'el\\\004o\032\003#DV\035qpJg{\177\030\004+( sK%\001G\001\037)\aQm[\005\031Sd{\vri\034\vRYatOu?2\002\021^5Axd9\034\030\037:L7p#Q\020=2?\035\016 ]];A\036\024\022EV=\016\fqHs\020]P\016\024p/\027{/\0Mi\021Mk(GLK\n[HX;\fmAz\003#qh\tj>N(tM j-U\177=\026CNR\035b;M\026W!3jT\amN{\\*\rzQ(&\031v$@F\a{\"/z>}U`\177\035b_w\017Qm\025\025y}']\016yhAQ\\;V g=:;T:GE\" a{YOR!\032E\030CWDiONv\034\026V$nQlp>\026#\004<r{5x%<U^^u~<{\016;W4\021<py~z&\n`B0T;x=I\bl \t$\004R!qn\"=+<N&MnfI\026nyoyMI\a&i_:t\tno\016/p:o,ZRa\032y=k|Y\n@m\017k%n\t\016.\024ME\021QS5nF\016(\023p>CKFcuwV@tD\031\032\021\021\002(lCyL34\033dv/.t\031\037uk8\036s</E:Gao.\016\a\037Uu \004`z\177\ne\032<F/S,p:yV\0f\016/CQK'c\003E5\020;l\003\f]\"Z~5{\004\033\r\037\017T#\035*=]H\031\031\neW\b\f\021y4{7e~\021\nl2/\003`t\026^\005knR\ft[z\a#\022nTm(\016?@\030G\021\"_vnE,[#:5&B\003D\v\024Q\032\b\fFm\016.l>scZuD\b`=i`E~z#,`\030\035vr\nmUb\017&\021Xx\032mhB}wV\\&d60L\016'M<\034n\006G6\035>\001G=\020~\001<\ng\177D+^!F}nzIJ%\ro}\027<a\"a\027Kq=\t-*\brrLrg!HyB_N;]xu^G\023\vPmA1/'8a\031UMP\031\021]V\002\036\030\020\006/j\034\005Yq`\\\005}[\034O\aL-&A$h|R\vF\016\031\rgfeN\032|rP+gOwNQ\b\\l\030o)$1 [_vy\035/kO\017$D\0a\"`m/z(/\nG\031\032v>{\031\030\t{`+:oy\027 \r(^\001y>ah/\004Dc\032U.,\005I)!\025CuiwziXr?o)!^KKn{D5\020 x\031im=?\023K\034,\036\033X\0\036\031SYc\036PH['\016s\0\177\035+> \006,`\024=!r#\035_\033+\023?\nz^Q-X\022K\n`M\031\177^X S\031A\n\006[_j9\f\016\nHQ=BYE\006\0G\"/\\a\002\017\024z\003o\037i.\0#fB\\`<Ua\a|\024l<{v/%Q\032\034$qq\036\00487B\022\023\022p Y1\031`hqHr\035N^dz*>i$CD?Y\005yVw\022xHi|x'u?b\032!d}nB\a\031@J\"\003XUB)uo\037\rH[vy:\ax\037\006j\022+_U3T\177i]a\0325LGy\n\b-\006/\017y`wOe\020O\aA\f\n\a{\033\bU5mb=.+y\002\020,\024.\030M\027\032UnYeg`\t\t\035@Me\023_\027pfyEr\032:`#hE\035[,\017=6\\~Bn\030\016(8\002\"`,\tEExl\016,kF\020\a\016+i` ~{Qd\t\rr|XiFV'j~(#iZ6\001)#i\004\fVq>\0\036?<a<\026\035\\\002(|kHS\006Gw&\bzYay-&\005+|\rOA\030=$4[\0:c\\p\027 ?QeK\002:]_\177\021J\0=\023o\031$\001\004\017!RoG#4.(&\036Ii\032$E\024}v\024!pV6\020\036oq \rsXvkEJ\023?K\001[}%X=\031\tgJke/!y]\034\fu:k7fi\034a\034\037)_=_2BP$$a1e\bohRgi(.\004l,v{{K!}L=\005l\t\035&}#1ED#Q\036.kz\036`%r\035!G=.T1+4t5I-#,\001dX\023\nFaunF{wZ\001e/Wa\aDq\002\177Seg~Wx\022\033[\030\003\030vM-S1\"\030\027>]zR\035N~!\006m\023r@]f-~\026go\v1Y\033c3\\J;Q\023\035md9oOS6n:\"\016H\n\016B\"iR 7ya.Z\021W+\0[\022%\034p\032YE\006\004#Y%%8\027C\023\027f\016\023+>\026\027*T4H I8\021<W\004 ,g'\fAk@\b@\024\006\033KU\034S/#\022\034WaB\032/\b\020\bIWNf7k\033eOAssw\004\032!}I+\002\004\030!\037pq\034\023\022\032N:\034\\\177Hj''\003ZO\032x\t\005xAU#\r\035b\026(k^$M\006S\005\030h{}VtGE#=($\037[]2z\tgH\aG\006Gk&;X>Sgu I&S$\017RVo]-D\033\027??h\n\177~\025w=\0((\b\032{J\177R\nZ\002Px\027{\001^?\f?\v_-OrF\177?=\034]%!\016:C0b7hd|!0Lt5>rQ&p\002v\036ZC[s+cny_\r\031GFQ_z<cM+z\022s),3MyEFV\177ka\\\021\bfd~Rg\031\017}\027:]s[wMvQ\r\034W\006zO\037$[\027\022w\016\025ti{9.taInT,J-2N*\n(#<-f5i\006c\fjhBV\"\021[t\"\035\fJB\"\v\016.;g4/UA\033\035`\004\003=#6m`#C#0Rr*\031kz7GW\037_\001\t*\r\033\n$d;\\KV_imjX~\037k\034`(PsSY{n!MG/d\022%[\f\032$c^kMQ#7@\vXdv>\036-kl~\016&f_)R/Z (\020P\004\001(\002\"P\033*W\027\021K\005F@D@EZ\024\027'\036\b\035\031vh=\vqE<yd\004\027Kw\005DHP,p}r\025~\"k\021,p:-z|>\021L|I\0\033k^F+!f\037,Y)b\tL=0>D\004j==_.j>-xqB\177mW\016s,\017fNz{3{\026k2\026py[x.eg>'\"j\037!\001nti@S.,\b\022F J!m\002\004 SYC+}\177\034s_\r\031\004yZQ\006\034};\"bR\030b'\"w|l\017w5s/r\031(\020\031><^^[^>BrsGf\003\"/t\033Y\033\003\027fT#Q>\024Ky\032hX\023i|orFSdgvebw&oc{XX%MlL{}\022x\rv\002\v\024wm}\027<\006Q\030E +G\030=/{-U|Gqb\027h\177x\020C`$<Kl\" ~\v\027\v\n\003zy]ED3\006`-DE%gH\024S+H6|\\%%[M-;p\036wM\024~+B6\"AUBZ\r&\036+R\002KWONmnno#\021\032By;nw(, Gg\\[YyV/E\035c\\wGYkt.\017?\020l\037FEzqi\177ciW\016!}\030q\032%kY,\\\"]l\tJ6n\020_\030\001ibC\036\tkZn\037k\023~\026l;Q|\tq&{6G\032S\177Nlow\fQL`TP/~v\030edk\"\001\033\025Z)ghsND\amdC/T2\004\bc4K~\003Doqe\"q6\003\\|6\rtEf\022s+I~6R^\033bN\021\005!!\"[0H\004VEZ\002JC\003-z\022\003J DKw\017qp5\rg`g.(\f+\032V3@s\036 M2\020C'\033/\027\004\035F\024L1L[\tz\022E\004rc\034Kf\027on\032*9+\021 \032\021R!\bo.\020\021F\016\031\030\"\tmX={LDD+\b>\022XGTg\031\b\v\017XRi\035};\fLyn<\034==\af[m~mm_\003\032.7T\001`rk\033-T_v+o\002\t$\004Z\023lmo\r=L \034 \177\aXvO.n^!\026L^\036kv\034{BH\av#\a,\034T%\027^cZj@8)ZX\002\004\a*/kjt71\031\025t{P{\022\030&\024a\001\r.k,qV|e\030\b\a\021, k\027s9\\\024\021\003>H@\002zN.\032\\dqLJ}GNpw\032_v$s:\003\vn\177\006\022/=<\035BxEt!^\035v\006|5nb\031}DzX><?.\025\nfR\"\034P`\021@msV\027\0O=w\vd=5/P\016p\036)YbN\023zZ<\"Y\031sh\004)\002^N\020\022 DMS\020$>\026\003\bs\005r\017][a\005\023L(s`['N%E\020i^\005)[\027i.]\037I\"\021r\025\t \n\bD\niM'1K\030k\006o\006\002\025\025QihK\026B[\022j ^YXfrq;9$\177lt&dg>\033S_\006/;F1I\\\"8<>S\v&E/J\\,;\fC|H$\023$\"(\027/\022|UAA\022\n\034f\004aJGs?6wTD'XQ\004|\020l8uau\034\002\nET%ya.&\004\f|.'\0174KLR \tR'<]a&p\017!ZqD\006DUj;jyi\0330\030U\036TpmWdj^iJ\177w>C\002Oy^Km+\032q )\036-d\020n3\025\nIW]%\006,\032!.N\024\037\bT\024ksP\021\035'${\021Om\035&C!b+k\036}p)f}U:_WC6.zcN}oq\006L%w'[%2+g;\002f\034u(z\v\004Kf~k^x<x[z\032\030c\027}=`=\032=2SZ$y\016\022q\005WZ\003cd\004jN{+.\031OD\031g\020\0s\031nty\177\035/\001\vyS\022\\R..TF%=_m?\037e?k\v\023?\tJ6n\001\033\034_g>l',vBg,\026;,\034\177@\003Ypuoat3=\n\aS&Lw9\002\021\003K>x\004j\b\n\t:;K(\003geJT(zWo\017N\035DTi\021\024S_\027&w\001<@\002z\025\\dg;Lxg{\020BSH\032\b^-S\006.)\022\002\002\025\023\022hZ6X\002Hw_'\f(LG2p\"ch?\037z\017.\fozR)|__ :Q}j-~W\r~\033u$MiW-\030,h<\022YF#cZ~\033Sg\030=gsKvy\177GBG#1W~}lP\025;S9V\032nf]f\tk \033fMZ#_&j3:\017Yq\037\002\b[[\025i\\\032$Y\037-V{t.\a\032=r M,@\026\022dG5X7y<\024/I\023Na%E}\177mj\016)T\177\f)\006w\\\017\026'I.H}\030y\022Ts,jqdRc<^dEe>E|\017_8G9\004C\030\033+|FmG,YY\036\036w/9*Jz\t\027^x\005H\ny/E/>3N^\020{\021\nO5\034bA:\025\025C@a)lZ\f?\b~\031a:E*Qv6\027vB\177W&!hs%G<\v})\022\025s+B\027*;\0>\v\026(d\177TX7YnksjVe\b{tX%V%\026wF6AZx\030rL64\031\026/o\022J>J[:/J;v,Vwz}LRK\v?oH`]KC~&\022$>t==\036\"\036E\017\017\027_Yt~\030A'\r\022wI:Ry>;%\005aj0\017ct;\033KG+=F PUp&D\034P2.@@Ph\0Axd?#FGJh\004)>6\002h%>iD\030\017>9-mIOgT>l2}qsg\006=pmk\\'N6&\030\034*W\025f;S?Q?#Gad\024\022JFL&CCm:Pl\027Y\aU>mn\037\022\026e!\016\fo\b\003ZZz^c\006<\v>]XcK_-\b_5\005\034m=eM\032\fk\037{\004.etvpZ\033\031\v\001\026s\032\001Og*E\005+PG|^$e;z\"\030Z\"&\022\002-F&l\037\026z}\031b\030m-}OKmQ\036SI\034F<Dx$_6\021x\027O:d_s*M`Fh'My(22Puo?\023X\034vG;Xzpd'&G\177Fyy\v,$Mx^I#/\177\n^:k\035.}\037w}N[9\031V5V\036b.|$]\023wtv,]_o)k8c)a\021\001\b\033\006\f A\a5M+\"\r\002vaO[~\036Xep\030:EF\032\006\"uF@\177\033FN|sld=\"d/\032\016Lv\023I\fF$sB)\002WX\rd}!c\003HP\036?$h$o\002W~E\016D\035@\025\034)f\016\001DdP\v>8x]N\r\agZ\033\v\\z~S>mn&\\\b\001uL-\002\005H:/zW\026tb+[w-1*6\030T*y;<)/\032\f\027fS\035\024vQ;t3Wsg0~AK\023a[#_\027 cX?\022g+cN8(\027s^\032t'o/&C\032v\\=Q0t$=v _'kZ{*\002~\177f]';\035$\033Z\023(\f\034beMdmi\031\177\032I&]?F\021\034<\016~ioQ~Z_n_vfkN~(Gmz(i\017\r+Qd`q\003a\017A.\n,@C/:m\002\r\031#`|/\177\036;l@A\037~cNP\016' G*?]6s=C<]\032o-\025u7\034=>|(c=YA\001BZ\t\bPy~\037!\036\025]v\030r_@\v\001#\"`~\022\b%)A:C\022inZ&|GGt\021\026C/XLS!kh\034#Ub]g%\023:zeS\f|\022v\033&:gu~\026\021W\f{cVM\003a]Z-VZ^db\036\034\004Z\b'\0=P\020/Cv\vdB${g{ \177GODd:ZmJt0C)z\t z\177R;\023FE\021\bLh}\024^z)ek;.%BTQW~Kv\to6\023b{//Ls.\023Bq\026\v\004@iYC&aMeY!\027Z\fnu\030d\030m-\034wP\034\ac<w\avu\002f2Bg~D\ra\t\020BQEk 2\006;so\\h\031f,>;LD/rlyh\v\037\ay\027~<\027;tfM\036\033I\177\025B\bz=\024\tAA\rJ\0\0\fT\032,\022\006&H VNHsPI[6b\021H&vA\032,Zli9j\n\t._\031~V,.@V}\030c\t9}FQ\030C\034KU^\v\0A\n__=igR!atycB{c\035SY_<M\017NO\027?\034-C\006KE/rEgN\036D_\017\rki/\020!\022Z#E\0 Rq<5i\034&If\025\030#Vz/vVb\004aq\"!}\031t\037bop\026A}\037#a\003b~&?[Z-E?{w&r\035)/`MkQ\031Cm1v\002j+p\034\023//|\017k/@\b@W\0221*iF2,y|y.g\001|H\002?&MyM\aV&`[TWLCk+=\030:\030D\023*\025(P7V\026d3!\021#\025(H\033\017\005VP+O3\f:\vTOCk-\020%P..[,JY\034ujIk9xuV|j;bm\035ed~/\177\003);){Ob~G'Qh7\"dH\b\021}U]^>ou4'ZKh \006\n\037\037bCFW eLqh\vyT\177\021\",#&D[h{Z@\030HoFzW3TTBU%eg>.nR<Af|?_e\017Iqc\v\022cN\f,\003#\177_\016p=M\025!:\030ufyE%$[\021\005c?\fsj)&zf\032{;`\017oAh]\\&ua'k\033ebgfm/C $\017\0YdZb\026\0g\024'J^\004\vQw\027y  \026~e\030a@KYD}\r~\020EQ\\\vZif\177-O\177\003\017'/B{\f{/r\006Z\030]\034Dd{\177~\177AI\035\002X0D]\006i\002-+3\026WM\023QT\004a&jL]ZEH+2A}\020?E\016ec\023g\t@w$XYcY#Z|#<CksR~;_\023?G\r\nZ|\rUAV\n/\177M>noc\027|^\0hDF\\d!\033\023l+C\0\031&=smm6zy9.\177\a7*\020==D`\004S`i\\Kt\016zc\017+W.\v^kOj\t\022,YoL\026QCle\020'\026\004>\006A\f.5qF&\fzb%\020;\020b\f\bJ2a/d\030;,mk\020\023\017\fE\0\037:_*4u\037c\"{)~6,Or5?j\aIH}\bb~(V\002)fdCsVEWHz:tkA,\025E\024\006H dUz\nq\024\021xBCn-;-A~b\031Nv6I0d!h1*\025z\031lgUf\030v}1,C*\036\034+\005FR\031\020&IE5a#\032h'H$$Vayv/4^LO\001;D:\003|\036,TC\n\016\036^.Er F\vH\a\035aFw\030TH\032l/D&^|E2\" q{\031\021\aH#\023\006Z\003\ra$1\rDo{\rUa;fv\bX&\004ne:-]bjk*\"W{\036\033\022r;&+\016>\021\030%\004\f{X\005l\016_\b\t\021|c\b\025]xG}!\034=H\027CRlc:\024MDM\fTfVBQ\002 \025\021-\001(\\r\n$FJ\"HT\fZ)Zvcvsl\025,\0&Pc+CawK\v\001\026.WL[\")sz2v=CwB\030[Uu\002-\020/h\tj\030]#iRcY\a\001vu!uttKF\001?\r\031'\\\np]\021V\veY/x,\034_iwLP\nL@kL3\v'GxE=~s]\f\021pkha\021n\036oj[m)\006\034Cm\036@^\036\030}O\006!;b\020G\033!\021I!d}\036oeqjyn\005\\>\031qQ3d\002%n\020C#\022\001#\025R%/\026\001y\033gCEc]PUr?Fvk\005+S=\020\024\026\b\020Tq\035C&\030G\b\025:aB3*s,z6;Q\t_tR\033\032aZu_b\016s\027WN\024bMzr\177\026Wo:WG\021$Q\002\031\017!\nf\f\026w{\rCKo[lK\033tjpkZA\006\025\023\004\005<K\177\b\"A+^\"\030\f\021\030d_]efi\004d\026\005IO\006;hr\020\003P#\177Fv\004K\033\r[:Df\177\v/mI)af\021A:\027TP@7\n\b\025zOr6xx\027d[Mt$SrkaC0\032\021\016#nr{\001K\t\tq'o\030S[<=\033[|\030^tlk-m\006\031}{^\034\021YIP=<N&MV(\037Nt\"1|#sxaa\b~E\032jL]}\034}\034t\v\bZCEx\031M\036Y$\0[\nQ}\n\005\036'\017T7[0-vxa;xb]\\}>d\020\024u)Z:Wf\r/Jmm/;%\017Wt\"|\034]\022L\031My*_]\0b\005:\005>.]}Dpegr*\\_]\020knErJVR\a+U\016;LTgNP|\0x|iW3*wR!Z\026\035ZmUWG\032\rDu\\ET\024G@oK7R\027W%W6f\022<\177.ca,#\021j\034TH\006]\fqB~.\017~7z>RbT\0W)\027\021OEU\003\031*\021D\021yZyN\004i'\003pJg\177%oK \023](R)_x\036Oa6)\006_lO|G\b]\024nVC\001HD/\0d\002W\002\rZB2\n.RUigy\bu0u&r\tx't}m\aNg{\b`rcJ.Dq}`/T]Jzf\004\vwz\aba\021a\bd\003v?o@w\\\021xp\177~I\\Z\004K=OL_([MT\026|sFPUk/\001Z\037Q\027&Ta\036@qw!z`s'-z\027?x[\")\b*Gmz 8cF+sKS\021t\030>)^K\004wgX\a\037@\026\017xW*!\023\"\005t\016M=~\026l\006\f?\026`#oy|q%ehMxJ\017}z.N\001kYtKE\024M]k\035\\\001L\004tY=\tY`y`\025c\031\nZ.)\nu\026N^O\033F=#\022{\"\f\v\023q\020V\026l\020\021@I_\016N\025,\005Xw72JeK\037\r\030\026?\\\027\177~m>\021_Lr[\\\027Jm2>\vmeM\002dZwzM2ne:]'kh-\\y6z_m08LLN;\021P\031N/\005\025\017g:X[t'I[\033'Cg\005\n\001}\017\002\031\023S\006[;Mkr\036&bO\027\002x{\032F|A\003n<6]l>7V ,@yHefTVp\030J\034\006\177|qoqUkb\022s2/DnK)@$\027\"$#.i\021\f{>\021=cF\fUA^-E\tJ@1!%w_S]zT\024D!RW~\002\021]\037p/\033\vV\031%?\035<\006jw\177W\177Sy+U \"xE%xku=\020\t\022O\022\177\037[Mh\033-^\b\032?9m$gw\036\032JxS7-u7A/y?Tgc\177K@Lb@\031)m/O}+{n\025\\\ndelk\a\f}\026({}/\002y>/\\Y\005 RaH\032\"\n|g\"eCXdQ\031e^^<J%\034}\tL- S\"\031}j~!\aT?O?@\033/m8YUi(M\",}GD\f'm\026\035f5*\027\001|@*S]^?br\004IfBdR$G;B,l7:otb\020P\034YU}dse\036(N'\r-:\033k\036(\026\"*JJ\0\026ezy}ngOgy,Hrgb:\032\037%YVT[\017x4jm~\032nn&TV?v)n{]\177yvcWvrtjw}[p\0V\005mW^!^\030\027<v\017M[\177b^h}s\r\tE}X3s\026gf&riQ\006R\023kr#|kG!)cqtSV\"\036:V\022\n\002qP\001\020>4AwWwgTaY\rJ>(A\033g\037\004\177\177~\006f`\032\t\b\027X\"\002\030gJ~VI\tpto0w,<\016!r\vL\006vc\003&@~\022*</UTPaX-aJV\033\016`&kV)L[\027B-A+p~\034z#'tB+;\vf\"mwqZ@\017\021tY\021}o`x&-H\006\f$LZ!\036\0305 D~mq|<?\032u2{\a } Ayxku!SKkgp+Z/Z\001GV\003ZV;\032WdEf\033!\027r\017\026<'B@G`\017`V!iAC\027\005)#c\004D\003\vi)v#K\027,eg+Y\\AM)Aaa\003Bzz\034a\027RtlT|]ia(s\026&v\b\031 q\"Sfa\n\003Vj\003 d\001\"\"*\fRJ\002\027I\021dQYQF(04\026;WI}Vx\020?\v>rtHE\027'2L0j.|:eEZyNCQ$V$@<VCYTcO$M\033MY\022HO87\0348da\037yrB\002Dw\032c\003.i%\tDI9niJ~,\002PG6:7\001F\020\017?2g\024+d2:zBd\032\aoqV\v|zgN\vd\tE!\030D[:\016\033y\b\"A\026J\017\022b\\s18ix$$e.B@~LZt$A\035!\033[G\021\026l\t\0~e$ocq80\016&D\002m]mWB'oygG>-\031Z;\036>:\002\002d\017;\021=9\035WSea\022@vebu\021ts^`j$m\027w|\0CuV\017/7>,~;.=k_t{wV|\016e(\005sB.lev:up z\023\036i\023\020N\035@\177wmM*Q\031x\034tx\025+\vc=NmwY`D\"\002U*?uf]\031\033G,BMY&gqMA}+2\0%G7^2[\025\026!]W2?t[I\023\001\002@V\036B6YnBS]7N\031\021m|\v\026K\033-Z_\023\0p&oi\177\006z#?DT_MX\\)Ej\177\v{IZ<\022*\"0D\005nN\016DB(/O__?~]F}S/A\025qa\002CyrQ?L\023prjve`\\bC\036S\005]vJyCKoI\"Q][%c]r0~\035Hu\004\027pp\022{_sMzy\034\017J\004\001\022Wj`CQMdsd\\os\\\034X\016e.}E+WkMe{\021\002b\025\vs9\004\\\v\033m\026\177[G\027Y3snodv>d^)qAEC~\aty%LT?~w:}KUJ&\f\020\0U\b\033TI\0\aIF\031uzEgBy\027,/xy=\\;[l.au\"g\023$I2{\026\024\032\033edQLi\005+rWU.~J|rPq(\021\0BHL\r`\020%luCTAIVcX\177;jXW_\020V;O\001\022!\003s9\032\023\"I \021\023s-IO[u\037\033+\030\022\n,#K\017>,D\fNR. M$ m_%{g:VS\004}\\\005T\017Hat\020N+\035\023l[\003 je\033VZf]=\024\005_L\020FHx8\004\0#\017QMu}\003o\177C-\0$`?yXI_q[c}~[\017\a\002\017n\035W|:\006\016U8\003\020Q\004vet)!B\037c\\^;(\003%>c{&U8T\n\\Ty'>,B\001\022Zrxgtk[rX+%\027<(\026\030\033kp\027\002.nu\031N\003\r\002Pc\021Jq*\t\004\004+'\004\024\020#w_\033qI\006HoR)W\004\026\025\t+m \016\037\027:\021(@\f\t*.\026o[\036G$u:\033\taUj[W<QrF\021's{\035\001\rqzyD8lfpe\016Z\"U} \003\003ovOU\021RHd\177cQAc&\025V#\020T%9VNS*\034q5~Kit6\v=\033\aq4\aw\022\020Zz\032\tm\006\0~^\024\002\016rz\bZ`(B.1P\034\024*+_Y>q?$([^k5Zb-FI\004VJhiNoY(l\031<kg?\035|k\002cik\rH\034\006T}+d?\021\026e(o.\003N;6\020edha^,YfC>{\"+\021\022kU,[AT*,\v{IL\"\"Q\v+2\020AcG?\r>=jdW\nP\037:@qRmyQV,SrY\f\002tu:#A_z}^\021Y]!_yxl\b\005dt\021\031\034$!C\024pG\026vWk9#\004\005c\t>#;+oP\b\":-N\025\033;qBvB<\0\r\031gr\ni\005m'quH\0z\020v){>{\rCl^Xm\034bo[\fugv;\030XcuK%kbYZH^\033G (`KI<i}G)\aa*AEk\016\nUG7\024\005G\003TRTw?!;Z;_?AC'\027@|\036\037`sD\016-\177rEMCK\037[N\f]s[\033\030\032_F\016:\t\blk\033e<D+=\024\023}1S\030&~*>\023mq>o!roHKfVR\027olz\026/'\n\001!`%\006,E\031\017%L\177$\021\023%=\b^}\002\005v?u\030';d\021BZ\026+uW\016))nE\177NPo :+\bJ\f\017\033\031+OiYCE\034>{k|R\026zM\017e\t%W\032u1E\006H\bv\022\b\b ] Pot=C~^\021b\025pj\001\025E\036X\031*0Tz\002\035\nju~\023r@\"|S|zck\0\025ncwfUW\nt}/l86\006PEV$\035!!Aa\031\twJ`p! \"U#p|A\020b\036ws\n\\M>\024N`\035k&H6\030,\021GOV2/\023w~z{8xojf-u$\025$hF[,\036<\\d\036Xy,\030|II%\027k\036\n+g(;z\021&\017i\022UR\rCns 2'+1\bt(DpRi%I\n9\025\"@T\rt\tDuY&PJkxBZ\017\030\005{\016T-mYI={H\177X\017Y\036bj_\f\vY&I*s,k#H+6g)@\r\t6 W\n\004\fed#FH\027j;<{\031\037-N-N| @;O\004\002wK;iHuBc\003\006uK\a!q}\023=\004<.\026U@OyZ<k\bd&;\016$\021:Z\027F\\N=3Y\033\020**GuxH@L@!CIjm\036\034\006l15:C/,E0%iN,w0\001\t\"B1*&\bUDU\021US.\177@;{XVl\034|\033\025\023\031=n\t\004A5zTBk\001c\033\n>n\fYo\vpvf;\f\"<\036A+3,Fd`VGd{I\002V\001{eJc6aUJZ\"\b-E.|IYw\004)S]\026[\031k\f\034Q'1F\fE\017qw\005c_\003s\"\001\027\016\027I\022}~}l\ah`+4mkw\006`}[b\004G\001<MA\026a-!d(\033c<fwY]\vg\031/b-}rF/kur\016\026#cI\005V~G\t:(`\026:SV\a\004[\vb#<\006u\006\r}.\023}#x7\027\002.cX\vC\0T\004NS\fc\002,\006o:tdt\006aW, I\rM}5|\036*dynP\035P}xjfy8*'\f\002\\\bG1\aPmZ\006l;M)\t\002f?7\016u)\003\f\022h\005\v\a*D&>\030Zt-\017gsPu\031[\fqrC0\035\n\fQ3**H+6]E-dUq,\031LL\030pdQ=t\035\"2}$A\035}u\036Worv\017\033qcBVe#~GxiUZGF6n\024_`i\aiLaL.DH_\177N\vX+4:\027f\022\rjw&\tn\032;[$ydnC;SiZ\f\t\\NR\021-j\017REr<\006\023i\0\"\034 t\a\\\020\b)PDMb5^x+sU\017-g(-!+yXFud\030Re\031G\026\vq\\Rud_\031pan9 3[{\003;;N\035|[\033vvI\030t\v~\030&]{1WHEr.'Wu\020#.S]dC@,dk\025\003x\035qw_\aAh_\016Qn\fT(\0G\002\004OMx\032l(s[-nkC\\&\037.\t\002W<o'I~stemD\buWA\033\thK$waglw#rq=,f\026^H\034/X\030ZsEBvJh\023:v0ff$KEn\005m\020^2\177j\\Q\004m|`Z.~U\f\001\\u;7j\021&\027N\024$7L\004+@";
// cfont_compressedsize
// file matrixview_textures.c line 1426
unsigned int cfont_compressedsize = (unsigned int)30746;
// cfont_size
// file matrixview_textures.c line 1425
unsigned int cfont_size = (unsigned int)131072;
// colors
// file matrixview.c line 85
unsigned char *colors;
// contrast
// file matrixview.c line 40
float contrast = (float)-1;
// cpics
// file matrixview_textures.c line 1429
unsigned char *cpics = "BZh91AY&SYnB\0G\177_\0\0\0\003\0\0WZI :Agm;q\rnq{yN\016y\a\016{<\\ugtv\0q\t:=}w}>{\002^]v1qw{\t{kw7w\033wngww;b`Fff%A:`IJK[\032mcM-bA[4Me\002A)\004l:\003B@bAf\026RmY>dg[s,fs\036}3*.g_y<`>+\036}{/9\023}}uW!wy+<{|w>}\020u\\;\026sr\035w\033[ry.\025yt6*L\001T\n:\0\036\177L\0\0\t#F\006i&@\0\t\004\006\032\032\002`\0\004\tiC@\004a2ldH\005S\0\0\004\0\0\0&&\032h\0\002dd\0\023\023&\031\r\002i\0&b4)=\023i\032j<\n{E7M'\032bCRz\001\031\0\004M4\0 \032\006i\001)d\003S\032f=Sm\tT\025?SjzOLOhcTSTMM=&\r\036\003\b\003A\025?&\0\001\0\0BcF@&\001')O@d\023zS<(a4zSD\0GF\036\f\020\017PC\020)\004\b\002\032\021#L~<Jz\006<A\030M=OPd#$zS@\0D\036z\004\017P\006\032\r\036j\020\024\023@L@M\nh\032\031\0\002a4MIjm\t!ObjJ~MI<\036z=@\032z<\001i\030dP T \002.^|^[\n\024\034x3}\037mk'>\017\a\003\006\"j>w\036\022(\021 \025\026\fR>o{Sk\035\001y`\025H\0E\fg\035kXPt.\025@]8P#\024\ve\b\027g.0M~\032\017@NH'1\003<x$#>w\002Y\004,$f:L#)\005\032\025=K}no\ax\016\v\022\v\032\b\022C\022\t @@ \031\024In\031Ba\t\0177R\034P \031LH\016X9e\017DA\032\005]9\036N<O6)Uy$\016b\001\034\ah%\020C\"\036A\f\026fEf\0xE\030r@\re@nqf`\027.R\033\003C{\r\a8,\002p\016xs])\003x\016]1!\024T8N)(B%\024\020|\016\003}f\v}\0\rS\f\t,\021fk@\001y\f\006\033\001\033\020\rH%\\gL\031y\001\016\"f\033A:LkU\rzoX\aX\006xXnf\r@\f:d3r\026,@\027?d~/'-`.,:\023\fYH=\035O\020B,\020\\\r\034$\005w\tsS\020E\002!0Ne|$r=\004R}Ut\bH \005g0ye\021=\020tK0$T!?o\v\v\016iabTF`9\001f\026 \fv\030\030h\b>gP8\036\027m\0I`:o\002\034jCxY\016Hg*! \001zn-4A\003sf\020`k\034`\037Pd:\001\036t\021}G/k\031?6d8\027\025}MQ\023 XQ/u\001\f=eqpNDQM\\X \024\036NZ\f\030>\f\035WH\036\031\034E\036\aX2\017\034\006nb<\030s=\030{\0\0\025\032.@\017[qlw\aZ#\016Z\017IOcqs?\033nu~\006_~O\177B-\037\034\177@\177oe3}Y1Y~g\177KqC\027#\r\030\022w\024LX28WV\"mP+\004>\027\003}\002\004\016\177d\005xg,\033{MD\aS)AW\003/\0v\035$?\001]\024\021\004\022LHb\bp`xzDI\b\",Iv$YJ)\022H#~r\006n_.\021\004L\024*Y:\"q\n\f\021$D\004(%`\027H\020j\fTA!;vQ\004UQR\024\021`\032>zE\020L#\030'\001*!\r\v\004\021\004 \037;CZoH\177AkS6\r$_\037yYo\017Tx\0\r$Y*);otcg\002\035\032\005\030\020@\027/\033RVVb\nUS//~\005\t\023\ns/\022C\r\030`\031\t\016yfDXo n\021`='\003\177\r\032n{\037\tv`\033s\v\037\0T$H\036Cq\v^{{\003V?\a{\030*bA,m(\177\026u\004\021:\016,OZ(\026eJ Nn[*g<s_\020I<z~d!9=\vf\025\031VmPgJ\035{y|\036l\031M\003d\"P\005SRu@\\ySGT\\~tY\020\020AUT k\020\032\0X^\021\022*\026W[\027Je/TO\031v/a\003juFp\" pgX/\037jq\001m{$%Ubc#\002R;>\037\031_AC?M\v\r\022\ni}%\a#.\035\034u<\021c\a{K\017a{DH=z\005L$d\\0@9!\09\035\003-\022L%w;M\b&g!\024\0G\023\035!4_oKIzr;\031 \025?Sjw<\"K\\i}\031VM\022\024\0P\002\031eq\177R\002\fZiHY\016y~\026Sj~a\bdi\016\021 T -\a/y\027\036X\177::0tC\033f<\005\031>YbeDg\025+\b\\!; \vkrYA{#%Fg;/i/b3G\"eg&\033\034,#m \\g#{eDz\"q>9IN\023\"gp=\024\002+\026Er=2'\037wzE\006H{U\001\022KBe'\017\035K%t;;Wz#,\025\005E\027!Bj\0\0\001%\005\027%TH**S/=\017\006y%u\"z\025\021@d|S\035\036BSSAs(tR.@?,\023Mh:c\r*\aBFV9^w\vD>H\034oWSB:/f\032\177\fA\bXmmqc9\\\\\025M~\020\017\001L\027\b=w%Qu~>\177sg%\aX|d\003-B!p\t#o[d\033\033{\030$y\177}\002,\016y4B=\177\027XOL>!F\177\fb\tIh)\"\003WfUBo=:7~\017\017\035x,U-\\\024G\"F\002\020p=K#?gj\034}^!U)/x8zv,s!8]oi'7L]vWtz\nZN\016\025S3&A=k\031I9\025\006k!k\035\034J\035fS2((Il*s=T\\(\024\tS\0\bC+\0E@x\r\032%s\b\016b+lEKQ9MzM:_q7<\021B\024h8>g\\,Iq\vX$Jr=#={Go\016\027gt!\f;M0bDnyz=3_\0\020Hk}poR9\036O<\nps\"ch4sc\002IA\004\020\020\027g$\001%ZkFL\016hZ-x\006YF$a+}6 R\026\177Z*\f\030O,y\\ti_j#BR8A2#bKlS\030T/|n\a\003gyXd\023s8Ehd\001\022Z\nJ\034\b\024hh!nCCr\001\003/<qXe\002\020(@|oF\024GO\021Jg\\\035\035\027\\2m*;K,=\031MKr\005\177W\027t,yo_#.C\037(&a9\177i\031m\vTr)P\001\t/\021d& (J(\034\0273\vdV;Er/:n`qzbz;gKbt<9~f>\031\006;]'\022\b\b\025J V<\021\021#urkdetT\022j(@\bw\006/\a**BY\030/G\030Q@u\005E_(_++\025XgI-*oQ?:sB\vcJm:0km`\003HMk)HF\016D\025\026KD+'b\035\035\vrVC&\0).\017^|Q'c\apn\n[\021Z\al\177b\asD4\021?Q\026\f\r\177_\020pEi\017_p+;\016qO=\"\bkAIh\f\002\004w\a\002!$;\005\004\035<I6Y\016\001\032xj\t\032P!\"\024\b\006{I\005+*Qc\030\032\024XIBA]H.\033\"_|.g\031\001`_\025\f\020H<V^hN\020(\036#\004j=ud(\f\a]\037\001\001xn@\004\004'<\r<\026=/\fHM\034~Cr\\\vI>{u\030c/xZ\b\031\vs*LO}/\031Z\021T\"HT\r\023.L\te \024#\033/\027?;}eP\023\031d04:%&9iMD\"\031\017a\032\005\005+Zh\033!;rd&\017-&\024{J&U\vf\036\002,N&\\Y?`<7fz+\031\006w&^wh@g{\\\005\016\023_bN;#,gx\024!;\024`}\032H\033\024w,0\017\006S}\\7kk^D\004 \033ucUUej]\"\033x{#1~\024\032&C9go@\022cP-HNnY\002!\b!T!`d<YKH|gCIg\020/\fX>Pg ?!`\004^xV;c\0252jMG`\023/HVS|\001[{\022n\030\032B`\v!e'N\036,oXS\032]=>sp\b=s~eC\b\004\020<\030\031:F\026w~O\aV`\035)w.\035&\177\021\0\035\f/\031\035~kV/.>_:\024R\0331.#x\023\034JFD\030&b!*\025M\020Egq\034TB\036\f\026!n\002f@vuA\004|\017tqnF\020\035\017\005<Q-\002f)=,^\024 /; L@>i3=K\030=\004%M+\020/*\006FWn)aK\"\a\001c\032c/Me\003\027R\027KB\n{\001\025}NV\033\b\"\a%mB$\016qEFQ\037\031W-b@\020r\t\0ifV!'I^F\035@VRnQI)@C\026E\0\036\027H\a\004\017bv@-'\023E]\ni_\036\026Rnv\003IK\a tB@\005\025~Iu\003\036Ig@md\025/m[g{\036;Nq\t\016\004G(I/%,Nq\001\rV\023S\024i\"\033sT`\031d<\026%\025hs7gr\bNdZ\016 J\023W=UO(*\031rcVxP\021{\032Rv\0237UEA30AT\021~B|\006Q4\n\037A\020fDXIG\024Q\034oZgY :T!GVmkDf\004P\016\016Q\025 *;))iem)=\b\020 /%DIb+V\023f*\034a|B I\t)`o@\004d(\004[FX&NjA\024abd&ON^V\\\034;PAe`Ou\0c8A(Tyz\001\baBynx*g\034@\f&s\0\023cqksWkC\004\0\006\017a\aRT+u4/{zxy]\016o)R%\032d\nj\"#+\025\026!pD/=mu\"*e-.\026\034H^\036C\fN\027r\021>\n\030aK\n\001,*[qo\037\002i\r\"H5CD\023i\017D\\\177'm\034)\r}/nl&]\005O\032W\bS>z.\034_p_p #U\033ex!8x(!\022Y\016\035dH\004v]y\\4\024X|n&\177a|u;r<F6N\t\035S\006|\024bm\177\023gu\"FCL,&&[j \002sPvoZ`E\036p;&^?#|fo\024\025\"AE|3)kS~\034}^-]/q4(\037jAeBSg\022&\"(\r\021\025#x\020\026\023J\a<g&DaXT\004\003aCZ\034\004u\020^Wm,Z`\027\022E-D\001\026-\002p\020\016T:hRGlM5&Rx\020]2/7%.t1A\001\032!E33\022_]yqTZLZ3\032Yp[H\\H:Vl.\nh7u5@Y[(i;DR\bWOW\027qp>tL~_\026Yjc\177\r\\{\001l\001K\027'\a\r`Z_\004H\027\030+v\006PH'D`\031aQJyX^\032\030-\vy\037\032q0V{ \0\006Q^\f`ijS0x!X\033O|\017*^w\016J\b>\016\001_7aH<78u\017w=F@+pU#SXpS\030C>Bx5UgUd\f\020LKZ\025\003\032\032\\^m+{8|\r\001#\006,\003;kKu,\021+@A\031\032\021E\005&asDH\032\032\037\aF&H=\025G}T+FoW\r\033\026\a_;/!8})o%i$'.)6\fanV-`\n\006\nS\006h^)BGu^\004}OM ?`LV\030|^\016uKtA%.\bz3\004kXdR~\030Nz@HZI\\jYt{Cm]jjss#re\023\b>\n-\024d\t]X\030)T]XYPus}$w\037~[\022;\031eS/K<UF~\031E\020XoxG\037\030`b\020\004%\tm\026)\rXP\fB\035\022\001$CWV\fmXvq.Zt\tX\aZctF\aW?J!\006X8E\030hcV`a:cWby\\f};#$cRm\f!#\031&KzdB!*\022HGS2KK:@Zs\0\nh)vw`\0\\k8\017.0T$\vf{D=U\021Z|<4\004\rHD$#^*zXh.,k\001\025\003\016c,IPCU\a\"Fr0qH\001s\031B\036\001+H\032%\023M{a\aW\nc2\v\016\r5vX66Uu\031\004\006\036@4{\026;]\020\n\030:kJ\004\004\t\025t.Idz%!g\016 S?\020B\vM2=\031\bd2tz#\026c-@dNkV\026{\021D;<nC\v(X\n+ynu\f\024w,h/t|mzv\fpYQP\024t)b\f@ yQfaY)\020SU0}C\022Z\001\a\0\005\004< s_eJ\022ZWMr\"v\177--B\026LqcIAO!\032g qp\006}T?-oYayTvM5/i*E\001\177!R\006\r#\030l\027wE\032\v{t\016\037D\0|\035\001\001-#zADEwoWBC\001+\017X\ra\177(\035Qu49W\031/\033\004y) 0R\022#z\034k``W;\t<\016\027YPCj\022FGYp\035$zz\003\030wyV\022\0\023[\001C;\036\016\004M/\b&H\022@\036z\t*\024\020\021&\024H\022\t\0Z\026\016\034A\"\")C\036m\021\020-~\016c{\031\034\024ID\024@q4`lDSs}h\026kAAzSUhv\tZ\016=\0036\031\t\rwSk{}\032\tDD\027_/\031K\017\005\022d:\177#\036S\006\037\024n =B;\031rt|L)e{?:\n\036\036\\\020X<k!rFI\001Q|r\020ZY\0\030a\026\023^Y\025|*-jaF++`\033\026;Tbz\035W&\020W;sC6$\023yrv\037\bwbK\0`EH#\005$w\"\t\017\034\a\"D\022#)$h ?N/7=\001\" n\036ZV zFIs\vqv\024gcx&gB*\032%^FCskm\031.\v&'`0ZF\035\tX\"d\024P\024th\021\017{=i\003G-^``Hm/XA\005&(Jq*w|n7\031\034%d=\023>~(d'{=C0%\rJ\fe+~-mE\034R\\q$\036C\017\rAD*Gs\005HU0u(Y\003KK\001T\nS\030\vM$,#'\0\031t\024!T\002)Kdu\025\t&9jK\020n\b%uQ*:7]g\rv\024(c[CLR\b#\023R*`\020wMI\036ukhcZ\016~T\036}\027*=+\027K;C\006`\035\035V'ILtW:\b[%\025\016\005E[o2\017Xy\aU:KS\030d`+H\002\"u<\a\035m\030n;#\002evth\032\016pb|t\0oB\a@\027@\a=\rAS\b\001ulTG\004\025P,wQRy?\023o\022P&#oo3o+TV1r\025j\032e,9T\004T3^fY\027x\026/x\v\026F\023H@^ M!XB\aj\016X\006\026\030\a\be`\a@r[@CT]bC`B E&D;D\\\t\"\bC(;hR\024\006(f0n\034O$\023D;o_\033M\024uGB;D\001Xz\005\rV'T8j}e<1Y\n]#)Z\177is\004\005\035$\f(r[f&j\034oU\vF+\004vUJ9\f\023\004\001\003EE\t*Pwd\003w1\034\v\002\016\a^\023n$B3:r{X\036e\0\026xq\032\vx|kuJMh=|`M\0Bjo\026\b\020@,sn\021(!@}\005\004\017cVit\031C\031\002PP\026i#+zEYGRg}.tR\021vl\027MsT\004\a%E\177mp\006aRk{\034KQ\f.+F/\177\023nmCD(P`\032N\002LJD\032RTOT`tp\034Q\032O\021cK\032M9\017sfQd[s5U\034M_>fA\vGO!\005\001u%NK/sv\apgfN\0]:\v\0<\004#\t/\030Y:gF]V\\F{l%G,x4\004_tsH\t\025`i= \"'ZKuDV\n`\003z \026\001NXA\004\n.R.+\001v(/,>\016yf{|n\035)\027z\f:]=j 3)\037Gg\004\034]&\031$[\020M(\tpINW/r\006 `h\a\024bI MCy\\\034Tp$%\bp\016\177v\023UD\001-\033+\020b\021mI\006,luJ\\G_[\032IvG$?B n[*SD\024'n\037Qm\006ko[\035\n\\{B{\022y\t\003f\036wB!W-o`\031\f+\030*t\r`a<\001\0\016\002\002+c6_\npw\032\036SRiv\006Vw\027;Gxmvz.\002n\026m\001-\020\fz\032C|\021)NX\036#K\177\\{$%\022<t\006p\020s\"N\016;A)%\021.^\n;IP\031~:.k'd]AC@E\021L\023n7kZ`R[\031\b\031T/Kx!CR\006\005IS\"&@wL(F\b\\xrfLf\026\022&hz\002*K\016\020vqo>\030A\001!suXg0\020F.\rPi\fo\030[\016F|@IlK8\035s\034\036\033&H\0356}d,J\033|\002Fu?/*\004ath\024\bjnLyb@xtB.H3_~>b\0\035\002\017\tkw;\020\0wq\001\020\001\004\036&\a\034 \033QkTi\v+MB#\026&eos\025@`\002\003nP=`\022 \v/ $ehWo*\021\0 %+\tk<\016\002Ixxoz`\" $_A\017\\3l\031|\vwv^<.>\016\035\"7X_\034mL~;\nD`f8p\t\035xB$\021+x7\036\023\034\b;wH> 0nafo]\032~V+G2\b?'>\024 Dr%@@\07_\\~',\bQ\003;Q%W`F\v\030\031\025t5\021]\"w\b\006&&\025xW&}o\0253ZK$ Q#\a%*NW3/\024E\022\\/<\031s|\017%d\177Cy[eKCp\003,\021\004\025/v\030\a[\037Y\032t;;v([{RlDD'`\031.y\002:@Cz\005\b\001\001z/!\034xX?rMuAdC\030R\v\020V$o\v\b:\032lN\016NJG@lk?H\032\axph\f dfl\022]7\034\002\r\026$\004mn\034\004cF:\002\036E\005c=\031mxsL(x(T|a,<D^\036\004\"KuB\027w,\023\023`\006\036\ra\030o\0b,?SBgZXw-j9\027_\020\006.;YFcG:C;7R^vI]F%no\031M\032\vyYw\006YmU07U0DF\020Yw0BvP_$H)XgA`I @\027l\001;\022\026cH\025\034\003iEkV1QBC\023&h\004^$P\002`I\036<!\027(RP\t'\002.n+\002q|\"5\vup{)#PX<sLHCA\b\a\037W|>Ey\030z Gxf!,Ng\005\005\023q\035 vn4\030\005\n>Q<*M\036M\026\024GU,Kr\022/\032p\n@12\016!\024Lq\n,%P'M;+G.N+*\a\033an`c\0q!\004g@\a NaL\016\027k>>^[L5@\030/fUz\026I\aI+l\vZ\005\003c g\031\037/Bg\b.~\f_J,.Fk\037*;\027g\177OP\027hlQqi\020e_4\026\n\035D\026rJJ0$@WdF(-\004,\031<\016yD\021\036@Uspou=h_I\005;\006zsz\025&w%\027&NVW'$~xK>r\016E\021l>`B\vA_IH{#\031Ls4'\033^y riY\023O;,bC%:;8j6E\n\005\036D$\aC[c$\\\003YvC&p\0D.\b&v\017\003k\037?J]/\037_iyHb\v\f*?VGOi\\ xmzX P3U\037\024K\aAK}+@,@\027kC2\0PF$f>*Kd\022M\027O\016p+:$|MUc\0\020]!`h\\\b\005v$\fH01(jRnl/Q\b|<\bw\016\021 M\037\003j\v\v\002\020D\020M\v_\177\a,,no4eY-3\001r\016\"%\024\0L9\b\036\024Z\027\003\016\036R^yvM&!\035\fO;|^o\016\t\016oK\003\033(~#b?a8g\017\020\vf\005P9QTrf]j\024[\002\016x\004n1uTW[\030+SV\b\aMO\004\aPxT* ^rF|[]kp \016\002]\026b-{GYA\023=Z,\032};-TNQ\001\020BD\033\016bXq\001\bw\a\nPJ\004\005V,\034\024%6-\025^;*}Hj\036L$\003)H\025rF\027A{\021\020 6d\017HIA3\0hwF\037F&Y\036\r\032(\032\036\021$\030\b\tPd\031V\006\0c:\b`\005\034gyi\t}\r+z>\\;/-QaIz{[k\177\021(\177\005oAH3yh/,dPj\026\021[\033flmRI\017Cuj\033g;0\030s:\016Q#\"\002`a\016\031\004lXII\r\023+O\001M{ <l\034w{c!\004o\023l59Az8sd}`$\022\020\032 k!TKt3\023gkx\n\035D\nVwKr%St\032s}+~:ztUz\027\0\017+OS^*OT)Y\017s[fy\033C\023x\022Uq}Cfji.BIa!\\J\n\022}\020#z\001\001tHsgz\036\027\0u>\177n;4e0\r+RkQ\017\022x4\003\004px)\t]^v\0Wz\025@0\005\003}9N\020Hz-\035\aoq(\032\004\005\022s\024~XC\032\nDDr]^h&N0ul\fRT(4j\006\004\006N`D\001\030gTI\b\026X]\020\026UlL5~I#/uRv\025\fT7|?\teMy/v\030x\034\031.\0\035nxW^v]lL\035)Kg=\025\bTDT\017:f\030D:\0\v;\025?V\017\003\024Z\177U[m_lA,\020^\023\035\n~(\003x\fL({$Q\024\006f\030^&0KF`#lSHta\030\034\r=fNT\f\017CwnqR\005\016n3\031\0,bE+\n@BFE\v\v|\"x\017;o48t\022p1;ws\001[UOP_iP\016ht\030{/u#n\025\bT \ryIO\016!7A\016J>ZE,E\036\036tAd\020pmUAum[\0Ae\rS,@\036vr\016E\024=^^)\\YQ8\023x\024'\bu\"jcrcJU\030:i<PJN\030[[3C.\f?=oJUA#\023R\021!\021}mTF]ic\035seOry\r\034x<\0y@O|Ofn7fw)\026lxN)\"Gw2\035\033\037(pOZ\aX\v$P`2`J\nZ(hm;~tCT\004F#XSy+*a<[lr&>]g\177c\025\tSS;{\\\r\034gP]lWn4'q\nwYjhOp?A\016py\002CL\nA\"\020&$\022\027:b\037\177\031bQ:O+\020H,G[},{\035xWvN\0iO\0/\r\026R]<kB\v\031w\020eB\036##Q\004#T\rENw\026+\\dxNR\004\003Spc\002=7yf;Vhc`Y*\031m5v -e\035s[\005( %&r>I\023>j\023|(\025fQV\026HMv7sI\031^\025,\005x\020|ksq\022z\031ci>W\021A5-sY\t\"2\020A<K\v\032y\f^_\\`I%oG\026t{Ja\024izql(\021\"\033.\037L:iD{Gu[n}U*OX]_\036db\b[?\025fo \020[Q\032prEEY&y-G\033T\002_'\n\025\035\031pbOi(\030cFxt;1F\034[iO\022\0310l*p,uWW\005UPkI\v\033/\037\177K(o\023N:[\0[*T\vzNt\006HF,\vr?\035\001V\006-f\024wS5-|\006\020\0\am\022sq,Z\023p(o:\004Pcq\v~>}\032\002)6^\024/ou,|E>XC,gXs\002z\\H=\035\003w\003l\bG\030R\027\030Q.:\035\t_qj\034I\fmN.kx\n\021~OQ1S)nF\fENUF\rv|G#\020^\027=UV\033dvo(j\027}3;Cu}\177F\031p\026!\0Octyt1\0\r]c&y\f[;J8sP>\b\030Knan}CFH\005\004P,\a;\a\023LNgA,Zw\016-\031d\am `8\030V)}\v[1*b\\|i\035\tl\"_\002\037!GJ\021\0213\001\\\017 \n\027F;\005\027\033\004\030_5J|$Sq\022\027Y\r#XzPT2:\\O\021\bS#M\vM}q\0347\vM5*]pU\b#\ng\fw*h)F7cC{rmu\037^ K&f3P,\032kpuy\001>\031\021\"r.T\\\b#3s\030.k\004f\t,]1]c\003T[&\r\026zR*j\004#q\001BXn\021\006g\\Mr\036]]G\026\034o\\,\a\fb\031t\036\024#C^lYyj=A\030:\022Kc\035lO\"K \025R\0tv\002dhMGkPB\005\a\034$L#\ftiW\016\034H`6Lui6\b\023\177J\aIW\rlZ>\037\tsC\t8\\hsL+]%\024\035\"\nn+oSg'\022.\vV?v>bVIE?n\030w\b\034bG\031\032\"\b-J,)k\006Qvk~(CQ^\033\\Y x\032M~\022T\034Y5kq$AD-I\n\031aD9\0{P;a\030\v\004\016(\t\027:?Q\001 e\021vn\023\r\021f*\rF\bkd&tBn\nB&,\034\037\027V\017/llNg_enxM=y\"\"A-D}b\035\036d$T/-GjZZ)MU\t\026\\Ova7o\003\037O\003(k]w[\f^>?]Vhx\020'g\f\024\031\005>&qJ;\026\005Bi\030\a\026\b^}\026EyE_c jC\025bp?FAEcg[+2dsG\030\024=>vn\t\001k\027\\dQ\024O\037:\035x_0'x#{FNv\\m*W`\b\a_\0~W\002*&\005\0\033u\0\0\016r7\033\030V\\9nXTX2_}F\bK\024M\"`Y-c-\004\030;\003^\177c:\035/\006wsRz'QJpb 9?\0S!\004R-\002#w\031_R);\"7*AJz+G%\025t\003=F\025lKr\024>\ftao,\016\026E\024{ pP\037VF1l\002{@`\\\031c\027\177+L9uIfdSO*.\amkNsy=Pbf\\c9#\n6pA\022mzKjN,\\KwzCm\022\vIP\026Dq\031p*M\a\ri\b\"@!y\017zU3\026,.\003@\rK{K=PCxjJ?Bh/k,{GS\v\177\036kG\"\v>Z\031\027+\025:7Q:#d\023\177\022d_K SwFXiSooGy\\\034\nB\020\023O\004,`xs$n?wz\021dlXkSrD)`5r&.Ca\005(rk1Ho\n}3Ypzk`S\0X1\004mV\033XX\023\020Egb\001XhD_\022\027=e W-&\f\033r\rAr/5cc\0\022\002NSEmra7L||IKJv\024%)q@nwOgZZ\021\f\ty$lTlHp^\ni\b=>Ioo'o\nW'e\\\a!\032\006\032\030\020B/6T\005bY@&\vMwh$!;\fR#\036\177p\034\027\002*1\004n:*\022?\025\tUPF^\005q<[,\\dM\034GC|zGUI\023\004`J\0@\003_}Ru8CVC,wnVa`.\035$\004-(Vqe<\t\024cKH\001:\030&$O>.u4j&.*1\026k?s<\016.\021\002/'ND1\v\036#\023gt`\024\v\b\rqiO^-rRqJV\\}4&~\np\004==Blc':pi@aVpuc[&u\006t%\025gv'\003H4oioJ\037k\027z\036{ \0@\a?Nno|\035#\vnX=\bWLd\a\024O\f\v\nkHk\\Tj\023SG81E\023)_.F{T\037Z=\027\023B_~\022\0\f-;\003IsZJD\025\021cj^L:eVhp\030fN;_\035\031&-\004\033BN:Zm_CV o)hOEfj\037:p\vV\025s%ZK D\020\026\177s\003M4\003/\031\034W@r,A{$XDvh\al*\006F\031L\022\v- [31L\003\\0QAO>91#P:^;\0!\rs_ursy!\034I}\021G;RZf<oq\0378iZkQ\035d\beamP'vpN|\002q\025d0=s e}\021\034\a;mo\nIy\021&\002!XwD\0_n@\022)\017\035_odi`y1\021ZJ$dKh`\b\0\033\016\003m\005EC+a{\037!O&\017b\035\005VJ5\031\177]&$.M\034\024\030c1\022upaXY#\035\"\031kyH\\yO\vg:\006}\032).+)z\005Sk*]!_\017\002reXA\nd+}|\026G\024S\037vB\016\016Xh{T\034\005cx~\030}Q\021}=XGmeha\005\b~(\022Ul\006okHsk\027MB8\022~x?^.%?\027S\016HCKTg)|p{G\n\030n\0\fx6F\001\032~c\025\177/E\177,I ,n\"\006\rj'\030\016au6{.z@E\031|~T\035^I)cE^>`yA\033\177\035;\tP/+(nCUofu5\aM\037N\017PZf,5\017)\004L|\t\034\n)\025.i~\033\r+\020\0271N\006:\037*\026TQ.\035V\032f\035,v\r^ed5vnhK\027u\004e\001C\\uhdigg/\001o2u\022%O\tB*Ps]\rQ \020\023$d(oEj}\027\036Fne8o\021\036:2\023\\\bS\005&K\035?:?\016\b^a=\024\033\017itn`{Nv'@\aQH=q'RU\fCJ\006 y\"}\017v\033\\\"m>es'wL&\006,PM7@u|=oF\003vJc'\\jP\017I\032u\"~\034&}B}HpC\026!ZN*\022J&[>\f@ P/J@MxPh;?a~>E:kBtMr[\025~n\030Z}ZS*\032D\\Na&-)\r\035\020ky)xXl\027o/O\031\022nFZx\031UI\003Y[8q\026p\\ko a\030k\177_1\btT\027LOIT\\T5\035Yk;$#\036u\004%bPw|\aD2\005#\023hi<\034\033b\021\037D^\016\006\v\0\ngbGNOs)Ek;RZ.Nb9B\001-Nb,5\035\017\030a\002r!C\034F|'z\021\vH~9y\017C6i\027\vW\016\022If5\006\026\b^\017\024 t\006d\025\002B&\027\n-U\033L\006D\022M\003u(]}\027\003a[m\"q_R+&ml(aPb\020\004\t\r=\020\0s&-yc}b[+\022eH\021=5S\b\177\016+q\020B/\t\033.-W\\\001nh\036/\tf\016IW\0375+d`\033\033(F`pH\f\035[[fHh\020SD^{s\" \026@\016t@7,YMW|M|,\bWk XiPpIu\037jC5#-p\036bGT1?rra'\003)\ap\026\borq;.UT{i\024n\021'S/}C\027\002N#|tQ\twNT\b}HFoE<Y\017#\"xi(Ul]cz{\\\022apw<\a\fj;QR\a)C\005\003~2{\023:\t<b\023\035+z+exi\036\034>W\026\024jv_GM)gCN@\036'?l.ZY\020e\002)\f-\a~-l\033*'\026CpQ\\\016\022\004U\024o{|$j\034VD\b\024\\CkvbD\004<,\031jK\b\004.=D\023\031Q\025\027%na/\006t&aDR\020&^$&9\017w\vH9/hO\003Wgn\033Nle@#y\"\ne\005yYU\"\005/\"&K;&\020\017uP\034?Rt\001W\035uM\\\030h\024\bcJ?%hqg\\?/'I{\"IM6\037\026obRP,|KG\017L\026/{=}R\016yH4\aa\tedy=\0O\033\177!Wpg(`^U\\vUB\033n\033TnH\bn/\037:^mVoRV\r#4\002zv\032\"hT\026)_WAy$\004z8=u{|M\035y19I\027\byer\034\tv;\035$xhF!\005\034>Xgdx{<czP&L\032<[=@\004\"\020\002HA\020G\006\037\nv$sZ'\004h^\023].Lg#/Ib\034D\001\tk twrxfy5Pa-pR;v|h\021HBQ'\030\r\004A\026\b\037lh\td4\\b\\\022ofD\006\006f@?ZZa'C_\033\fO/UI.#\asI \022H{\177^Ss=jT\016WX:y+}D{<\n\\]F\027w|IE\034\032BLJ<N$\026Gby\v\006ha.TZG-\177$su(~Bz:\037@(\016'V\003P!f`\034,$Q{\t.\030ED2(T\003zpJ@C\0p_b&\177M` \bfCt\n|$^h{\034&\005LqA\022y2??q\027bS\035\001We6\nT.'b\r=ncG}\026\036\006$v~\t\v\027\033\"G\022mE\003S9\033A'7lKke<W9sCh Ru\035)\035cU.0 Bsy\027n{'\vl\003\033MED\032\037Z\016\"X\032Yy\020ff-\037)V\022'P]RM}G\026LdgH\f$w{*\020w\021SS\\Kb]77EU_m\031H\\S$o&\177tw\034\021HV\f<b&O\t$!RBgs{v$?\036G\017'-s\016jf{\024\034C>a\032\005\001nR\023;~SZt*k]\036h?R8\002~]w\005V&o\017<R[l=V\003\031_\177(&,s\b\005~\032-N\\;rmNe}>&Sy&'J\035J\\jB\023\032\025\0S\037G\036\002^\020Y?lo\024L{eR\006UaU?\004A\"\026\006\032z\027/{\003\vI\t\035SdWk;r(u(6Z\032m\034G\033G\001\001\032\t\034pqOP\"BCU\034vI!K\n(\022\033Z>~\f~\031t}xds\003B\026Jq|4H\034mz(H'j\020\027\023k}\"6F`$\177VQb!Fl5\032\rW\026B#\030]&\037J}OI[S:5>\020\"uTa*e'W|>R\006V\"d\"Y\004bZw4I\001/\f\001U\027C*6!Se\034XkGJ\032Ii<BQ\016\017]$W9nmYr\f~ a\032*<|pfwS2h\b> \034\r\031\032j\017+%\032\033;'FQ{Li'\030E\002\016iO\034\0c\004~ppzg/Gs;}v\027s\av\023\177\033@ OFSR\boSH?Ht\\\022\037\177vKm(\006bW~@!\033\023L$|)p)\031~Qo:bT9Sx\026=S-q;sy'NiI\036Q6\r\032NC\177\036*Z\nWr`X\\UfLPr\025\036f]d\021]\002F\027\n\034qs\bZWICQ$d'^M\026\tC\032|pr\023\003<\023Ap2fO\035\nK\vY\022}z8bX\025mka8V[zy\023y\"`$Yoi\020e\020X\002Zv~*\vl%dP9K{r\036\026P\023KxsZ\t{I\t+Ue6Jsk_n\\\037]\004\f\n\v=\034sW8nR*\001\023\026hPX;\030US;v\177EFNq\017A\037:c\f\024O\rRXj}l\0!#\034] \006\t\005`5I\r\023c1t\a\"=\003\001N\033u!\f$JI%]nGkW\017 ?\003nC\026{\004M6T\023R\\??t\034\nx\177wF.\005NP ^>\177K\022o\\e@\001\003puLehLDj \002\003'Q,I>\031_`+\032/\031|\037_',rD|K%|I!Ob=!teHQQ\036Nqm)\fDRr\016\177j_qnc<h@Ru'\032%\fyC%\001m$xav8uupbsk`i\027\025\003xw\021kP\rsWmwj\r\016\006u\030pn)?\b\032,{HL[\022su+\022(\\\vX.z|\022ju~-Gm\021\033gr\001\016\002dw&x\"d.Bj\b)MgYv\034ViTn\023hCCat*f\022V6zr\032\rM/fSla\035dy\023Z'\v!ne t\022h\021/n\034.\177UEpwt'cb5_/JSFstMnt3\017\027)h\n=ie\017\b\024#:J\030\037\031sCB\025~23\025\024j\n:n*~h\004?\025\025\034Y#P9\023o\017|E\017'\foe-S\\A\003\t%{\027wf\036\025F\fIH%!2i(!e\r\t\fZg21<\036-;}a^J;nHQ\006a0\017Y;$\032(\030izoN\025oC\033nV\005\017Mf\177G<Kc\022z7\v\017m#\016kIXp\\\b+\037%qN\\+_Jq}/\r'O\aiu\027*G|'}dI>g|\022)M5\025X[` ;g#pm>-\035%oZh\023 0n\001OdVHBXQ\027c:*\\eCW\002\034VADcH@\036\vo`~\036zX\035~;I\006&BP=K$=BI\021\\N[L\nnK%n?(1\022\021 \037\rT\177\035\026L\022f\021v@y\022E.Z}q\017\002X\021>\016'^\003~0\036{qi6\004U\0172\031nF3sO$fQYS[\trK)2\033(/hI\024So_h7,o)W\032 )R~lg'\v-/\f\004b1O$LaM%\n#0Y\006vL\tw\024LF}1M\022y-\033\035'^F4\005/Cs\177M\016\031'\016\v:'nb:b\023Kj\005-f^i\006n \0}8Py(\\\\\"h\001Crx\022\037{\037\005\021'Re\r<\\\025\034TU%V\026\001 e\035\024\017\fSR<\177\037{^z,]>\005\031B,\020\n*C^,g}|Q\031OU>QA*\\/w\nmRB/\004/R.q'\0\022No}\f\035i9]e;\033md\006ico]xuOwrp/\005n&{\035=\016Srm~FqzE\r:pv;[O+ad\030A7|\r\\\025)w\027U\bV0\022w&\016\027\036MI/[{ri\b>]A\177tWA~\025\tx\022I+hgp\037rc\fc\177.\027\r*\020pgX\005\036vIDk`{bWesq\a,YYq\n\004b_ #\177u \033\023**ajYDNg\032t~*n'^\b\026o~*-!A\a\005\nYf#\016sjud=TS(\023\006oq\177\017d\035|_:\031G\024Sr\025?B[y6w-Ew_ ~\033\024W}~\034\020x~\030j\rs\022mtI\177ooP4C0\004p\005yd/\027\023}HU\r\aVt\fZ/Rc_E>\r'Rh\006$aIVIqT.e\tw\001\004A\037bTP(rM(NK9\026Z(Hln\036l\033\177lM7Gy\037\025J\006vc*\036\001u\020;07\033lv.jjS\004\020\035\024\aJcg9%IX@p\b\026f\037'oTD)\024vd5\005k\016$\026C=BD\002ANxq2~D&'s,Z`Xz`j\004\rHQ\037}\002~r=\t='fBq\r)dd&P|\024\036/\006#\034E\b&|}\031BVGwgj2\a;wFU\035\030Auk\"rM\b\"l,\026sy]9hH\020KVeCkI>\024MeA\002\003EKJ\0\006G\006w\003\032\vle~\023%%]\v0;\036\036aq!t\"\nDU|l\032X3Dya\003;q%+2\022n%zaBX3Vc>A\003JgRMa-ENe\002j\003V\003\"9P\f\030\bI\fW\031w 9yDs`g\031Tfzt1\024;\004RBrtO\034a\0258\004NH}O\037TR\n\"+7|[\026Z\031v|.~}\027ejOB?\"S\a\005Nep\037UJ\nMzX\021ra\021d@\0326\017-86p\035\022\025zAtA~Zx=<\017\033'\"\022\vajw%~:zjq\002=\021<g\027M~)\004]Pqa\030\032!\026Z;\n(W+8Dsq\037qeIZ\005\017\r\035g\035g\035GV\177&\006\035\036_@W\017k5x\027#\016nu'trp%\035\f\016YJ\022\033z\021Q{\a,v\002y\025X\v\006\"r`0`=i\n\fE\006\001DA\030|z\021f^rA\024bdL\021h;\v\t|w)\022dHQI\036#eFdz\aoL\r\025g\030{\021|B\036{lDp;!\004\021,V'z|*[E/Pf,j:I\0;h\031\"E-0I\f\026-l\005E\034i7a(K=o-\032\036cTp\001%ng.\017_\022g\001(#B\023a!gxB.DoH}>Nj#0>Nf\022<\031}H9aw&DEq4uE.-(&\022f8~x 6\030C\026M`\033\017K}QK5c_%\v/l\003Y\rVF~\021j\003&Sk^X\020$v+9\016`G'By;XS'#Y4\"D>59+aYE~\f\035jg'aJ\006*W#g\037\001v\0322Gj|R$stM\001\022f_Um4\037B\fTm\v,?eUZ\020\006\001\001u\004\006*CVx[3\r+\\\004j\036\004\004$\004$\020e$Am,\034\177r\022 NV\vA4--;2\004-wJP*On\005cv}fe\v\034R5`\"Lu\023Rk|\036w}\006\017\005?\026\032a#yUb\twk\021N<Yh$2/&\006YO%\a\vk\016KMl5y\026<t\021}\"l\004A\017dn/%r\026P\027=\032\023<\"\020a\022\031m8:e\f1TpEQn\020#<7\030,%NQky}]ip/QdNk\027\023X\b\002\003N)\027g!\024EJ\016; \003~%Z\006;\030JdR\021E\177Mch4k1$%\026\r*DNO\006;1\n<]&}{v[1.\\~{])e\"q}`-!-KpXT\033\re]1\bF\031\024\026\f\v\005fxmRZ\006sanp;g\026thJ6j!\026 \v\006\031X{ZHSub2yLBP},C&\rhGF\001{\033zs{`\033\177M%oZgJ?=m&f{UR\r}th].,-V\035\016}~\030y\031c\0U\001X\036ia^]UZ\t~\024\003t!b\006\177ls:@\022xCLX0\0\006\006(~T/R*ac\033\026f/t\033ft:USV\031ciEB\v\037-}_\002w\aVr\032MG\021\005ncE\bz>p\025\026V=\035ac/\030=(b94k\034?!~\020\020v\\t/a\006\\\020\022\004\024\022\016Wj1\003R'(bTgoS\016bOMY{\023\031~\177BB/)&.gK,s(\016\017ediy\003ux\rXz-.Ktal+\tnIwvd\021\027d :\005*\024d%$c<\037s8\030\036 \026\0a\004XD\006lPB@[hq+%U5NlZUjxV?+^mHuiJ\025\177o`ZHRN\032[r\001\034?:tTy(\036J>\025'\0&N~Y\006u\001\001j'\rO<LR\020\fJ\v\003\003ys\ni>d\t .:FL\021\"1}lYMf,FL!lE\025\005VCmP||\016vE\024p*\005g|eXV>Jlb.j[\v&^0\nF\004]\"\036\031v\v@ %i\026DOmj&Er-()qM, PXm\fU\023\003>\037AWAUt}G+KD\021E\n\036cIuEC\tg{?'\n#y@jk<c}{Nw\aZ\001x?G~fc>\0\016u2Ao\031aD1R\004MXJ\003y\030[P\ayu\022tsdWi\tSdR}bj5U#(wUKYP>O]wKfdPy\016v\023=b<\036\022\023=ie\v\004-\002ff!h[]NJu\177K\t/u/g;r6n>>\177I\177\016)nA\026=pW9p?)ae\rZ&gZ~E4U<>ge$fv#\033'\037^p`\023O\\q$*\036n\003{o\026<N*~n*\034zB\\\035&mxIa\030O[}(\023\n)\037X:^xtc!\005f\032\035&vIyL2$\a<H\004\n\t\024G\025\033Q\nJ3E\035l\0Cxd1\020~T$G\027%[\023\f\f\023\"}\035^0\023w:'\034\023\035sZ`>:\005q\ngsN\036W\030.4T}\035;6z$\005\\C$\030\"\032_`z*\001()\030V/\006\b\b (\031-aOO(\002n^/9\020\017\017ZX&\003=i&n\\N_\026Y\006\032{jE%\005@\002Z+IeG+Z\aA'_BdYwS|&s0\016B\035O\030tw3YY\030=Bu0`t2_iKG\005J\v\016$W\fqkw~Z*\006}\035!:%.FS$5t\006'\035\031#8\017U\037:y\027\rd$\026.?&I\rs{Z\034\b\002$t\004t11M'\023<\a-z\aM*D\016+\032O[\037hbgt+/~U<=:e[j-;< ML\0\034By^EgjRlN\t?\001\017#\030RN`V\"x(!\030TZ[\033TLH)Q\017sI\v\004HYge\001kC(@-6\025\v&wYK\a\022\027i\v>/\003+v4\017\rQa>l\tywI9y:~\034efY\027Oj5F\036XId\001Cb{2\016hOV\034C\v&\005$T\001gmt=OHJ\ro=\032e\037VG+LPrOMbVH\rn:R34l\027GP\b;iF;L\r)Ps\034\\:&o\037Ugs\003th\"/ac#}Me\035\016+lz~QXdO+3fV$2fU\036!<9)Hz6.g9\bZ~4$Z\177?eP\"PWK\025=W'F,j*%RQJ\034[b?e[VOW\021i?\016\004l\004\036sLeZ+S\021L\034%\027\004W-\031]ON\"HC\001(\002^)SLTPz\020\023o#M)$\001w6\aB'\036r\032\021M8o$\\c\rt)gP\033\016\nG\025[(\002\026q\034gT\026i@}G{\f\034}d~\"T\033F\f\003i!^C~i)v$\031#\020qh\037F\f\033\035Ser; s\033_A\v)c/kv\024\"T$yvi_\r='@Ea\177HT\006\031\026\a\033%\036\r\"jF/g|k\035\031m\r\035#x:?o\0rNYc/j\032jd1\032j1c\026tWNEF E\037DY\v|tsD\026\006m\0256{u[=q(\0tk-vxYvODW'M\006c-I\027aSl4\rh&\006^yETN>&{\017()\0\025PC $\002,\020y\016~\030z:\005H0\nGd>[P{=Vj|I\av\006b7'\024CW@KnQA\036kuP{\036\017G\017FHY\037Uj\005?\to[lvkL,\035>?q*}v\023\030S7\033Xo\r\030\177\rn?f\004\\\024qq\022/l\027uC\026 i{X\001\002[\\l)\035,\037\033@CP\\QHi7o_jg,I\t\032VE\0B\n+N-?_;}o}!\003m[|\037?!\002=^t\177\036IaA\033M{\021Pa7kt4o.\034=\016aPR\\\005{$]>'g2\006Pu=?!u(9\016]}c3_{]w2}\031\005Cw\004Yn\ah\005'}\033\020sQ\t\025%pd\005Vnk\031=rYGZX!M_\004hswL_O\023!X7\035MC+'hnH|iJ\\AN82n\am\020J*H\026\022:>eH\022Htbh\036\tjs#v\002L=\021\024_#\027\017u\027V\037xt5\f xsK\023T#%>\003Y]\016\036k/\002V>f)>~\006 ed{bI\037\034\034kkkr^Lw (F\030w`\a\a<hM).\030\023Gxw%2\fc;3\bG]\026XJ/'Hs7sg\016`[0\016]k+{\023DNkkAUN)<R6}B\006\177.BI-XhSY>\003e,(b86\"v\\PnW&fd@w}e^\032I;\035Do(sH \0\024cfW(\0ehhox}\001B\017~wu\016=[L-d5U]h|\035Pls\030n\\[:\001\002Tz=,q[6m?L[z_XJ!8QZP8.f{#Q\017Z6;d\016MPh\033C\037v0\005Ciq\0K.Q]c\tUM\005\027\035d(`\f?lSeYx!G\023\034&-,\rDC!\006{\034\002]\020`\021\017Fm!\031bLxs%xc;_*\021o#&}\027>*uvI\020\024*ba\027\036\tc8m3!TS)?3\v>qrpA\001\022\020\txRP\r@<BBG^\032SUH:*\030\f\032FHQlrsO\v|s\017\031m\016ku{<J\030\037fo\a?Pj\023\0\037\08\037Y1\017Ks=\016]Ur4?\016fb\003!\016\n .\023\b-uI$inT\0((w[I\001eettCR\035\036z+w;\nuG\034'W\003.*mqzt1\177D)\021|{.\016>\t?\001\aun6\036~%Ut}zM\n\001x\025d\"\006v\017+=9\021JH\034_5'e<[\001g\\s\030(y{.\nIqCLf\022e\025vg3c\036sU>\001zF^\024\\\n\tfx*/w*V6k\005?>{U{sL!_S\035\025NH(]#\177wqr]{\023|LM:\033\016xQBBz)?\005\b\017\001*Zh\001\001P6;Ha\031\034/YQy(d\036\016\017.^#\025!%;{{;x<`n\177vsE\036l`?&`WIg,ige>![\003\026\003pu&\036>\001c\023aJ'\004\"\023@zk\021*,a*\030\021N\0\033|\n~$\021&z\034\177}2/\tu_y\020.WC\aI#E\v\006a,f\t\037syg\003\"c\022z\031nDm\"ZnA?\025s\rrmF){V6\035f^\025vw[jj$g L*|p,y;;\033\a\036/\024\003\003\031\003kS\003\"M'\t)f,\004Y\030{\030]{1jR\nWK:{1XB\020\020^b\b\034\036.;fIZwT\177.~1\020O>A&\002pd'\031<B\030_?/F\032>\"<z'\022?rs\033qV>]\0\001\tw5R-e\"\177-MNp\016FM;h\036\031ga4s\027_\026\\;\026r7\021Q|+o5>\024\024w\037\037\032\026a:_Zm\b*gnXq\031\033\035u\003l'=M}+I\177G!\005P=]nk\r\033\002qjFX\026h364VUJ'NzqZ/;\034E\035A\fUY\023(OI;e%~\020EJ!\"\020\003c.Z$]\036tT:l*\v\024[zS@\b+Obv).\017P\005{KZ,4n(\004kex$dc\022e)vH$z\027t@\\oN\004X}Rr9/;(\030\026f-Em\022n\034\003}{y'U\036+H[I\031\vy\177qA\0S*e~`n\\!FkP[\003|B\026m%)f\035Byn*\032g'\027)Ii\nY#/W!o_\024_{\036oO/b\016uS9.)5\"SRK8ud\035=3r\r}[L\024\021KjY\017\024:k=e\002>\036\022M\t)[DDn{)\b\0g]i#k)!r\006m*[\022@@!>~Iii\rX\017^&!Q6GGR}>F\026xx/DUWK\"\030#~e|f.\021M~Chs\030FSY\r/V\f\033OF\006{M}?\034l\024\017u6I\177P<}\033\020m\bnL\032e!(\002T\002\fl\004[ [\020\033@c+p\fz7Hx\026\034v\034sCip\003Qab[MK\016\031Bp\r\bhXo[.\035yM0\031\b f*xG|ubY{|#~Y*e\022\027PNlzZDH+\035<oh\004P|ra[c\004\bp\025\025\033\037;K\031cS\030 \006%rbwH\0}Q@\030\"\b\004'G2\031\020\rZ<\001k:t\tpsk}.7L>BIRR9@@'h\0354'\026.}\032\001m\016^\rN\f]\vwa;\b@\r\b_g\001\\P\031^U`Ie\036l-iS\032\aEo/]gNCkP\005puh0Z+e>\037\\Gs\024+\001kz`?\006\025`aap_U\004\026c~\016HCzTVXk\004ZxaPs\026.\177t\026\026H\002\"\177b'\002c,\177A\034\034A{q^\177\023\027\023#\035\020\006'L%Lw\037$#@\017FV:\003YI?\t\026e\031f5\022}Bb\003\034f\024bq_O!?~J/\026a\022\021Zf\rU>|ygm3._x;%uYF\\~yIe6(fmvm5YT~hshd;\022Gb^;\177,>9l^MJM'=\fJ\036L\v'br`\017RU\vYZ28\017:\036\021D;4v\037W8wS\025y\\w]-Gmd\030\016-9/S\036DI:r~\"reS\aA|pens[V)\036\001\025V\003I\ax>\023KYa\005\a]U$qcF%$1U\"\baIP\034z\177\002|V+O$%\017^dyL7m\030M$\002x\036\033^peH\027>HO\006bGs{3|l\037R\a\003+)Lx\177Ku.\034MqcDGb0\001+@\003fW\026|\rR\023C\030iz@r^h\037dA+iL$:HJ\b|P\002\006&\023hu~hbmBe?M\002^~\023?z$_J\006j \037&Jju=8}+vC+t\t1&\016EnbV)M<m\"z#\r\022-\"B>\017k[KAbZ7=\036h=0]e\v\031k~A%z{\030\016~gW2OAt\017\v|\177\027CZ\r<\005\037B~|/I\177\036(&\a\006q8v\005[WGI\b\fK'@>Jt\f:\t\037AOq\vK]\\\r}l;MZ\177\0r\037\004l\b^%l<~y~}I\023\017\023XF{J\nny\033O\005BV\fnqN7+ PH[#;_\004PJ\0j\024|8\t\035GJ\033\037-)\006\033dec\003k*YTrO\037\vl$t\033'\017u]b?e\n*a\177~Cjj\t\016SzJr\023h@U\001v9n\004]\001\005\001da\022\025A(\021\f?udU\\\aCy\023\033\\\017USu8[\036\033=\036K'y\020\\\021BSn\030,?y;S?V\0\034l\037\035E\\uoHP?Yr\017(q\n\036\akwMC7k\033KN/d.y\rZ\024P&\0ys\037t.od-=L?\034\035\0q\n\";E!\020\035j\016\"8!%\034\003*\n\177#xx\024\017\004iryT3G``\0271bwFZD\005fMQrpQ@5e%>tT\033\026s\023\021/'w.'\027\t\016\016k:M{zL-wias::m[Mwq6kN L\005(\177\031\t\037>bi/ \030,RZ%`{`\0\v\r\tz\037\031Uyix/,\005\035\017Lr\0@H&s0{]y<hgP0GU\005/\026@$C\036j|&\020Y\0\034md\031A-\002\t\016P*VvE\t]U$4/\n\f\\&c\ae9q\"W#\034i\017U2F\023;d\004u\037B}o\022m|O?v]uPf>\ff\v\024\177he\\\025\b\005g^I{\034\034Sc\037\\m;.W?Y(.\004?bo:\032\030\f\032\030a\t\021U\rL}\bG\fmk\027)X8%\bpBZB.}sE^g\030\030'K%\a\024A!]jH|\030\021xL\035_{O!qZ\177y\020p\037_?\nn.\033j]fxrz\034\033E\024<Y/\027\021vk\033isJ\006\033Y\0 ,\017D\020\004Q(J=*=-yWYv-ah*p&:\177.}\017\006.\036Ou\021r_=</vT\031qI\005%]\035K\f\025c\002\004\004\003jxL&&pU\037\bczha[W]\022\\D<f\034\r:;G\025}_{\032\026\033=x\agO2&)TJ?6Eg\001\027a~A\032OGn'8_\024IC'(\006i^c\021/'@'eeX2\177g=n\024G#\003\"g\"\005S{\n\022\036E] Bs<?EWV(\a\036E\016$\005BSI{N\023}l\v\025\021z\034NDY'(eAf\024xeA%|$of#]\036\001\002\021xNvz*\f(D]<\\\023}BtF?I;!O0\033\vlVg<i\0hyS?K^\\#:,\034F&mR{K2U\021gr-%T'\033x7\fqy^z;\024[.\v\v\n\006a>$qYaze\021/\020)GZT$\001~$=t}\024:\tPEvf7d\031\002~n\035\034 \004@EP/_@l^9\\xbz]\001zM\003hA\025\032ui7-\025ZBhd\nu!'\a@\023-6&~\\+kQ\tQ\017!0/2/e\002g&:?YzLb\aj\021GH|$z\022As5\r\002^cQ\177k#\022\032AiF\037d\024j\020s}\025\002Q\037\023`To[s~bv\037q\004S\006\003B'wU%(C~\021\021\0x\031\005|Ed?OC\"\033(r9?\bu`5;o\tY\\ar:xzZ\023s\0GD+{r\031\030\vFzgR[\021#I|S0H\021K\004_'}-$\036=0Il+td\035_QWgs]\0iWsA\037jSh\005C`\t!\177&q\023|T5U\005s\"d@\033Zc\017B/\033;\037p5jE\022Y|k\020'\n|\033a[\035\vIHI!Gmf;\fw\021j{/~\026\f@+\034CJoTU\0173\177;[\rt!\020r)>V\035\020jgUg\002G\005y0\033\016:Q&6y\002qyV\177\034>9*Al]S~.\022e\vYB$eC&$v!BS}\003Yz\0G/NoO\001&ibv\001\006\0qW;_-B\030Gd@\023R\004}lPi|\024\tn\a\177kA\034{3\"\"CB\\Q\033su8\001\017Es.|VNBtb\005Z:BdP*R8|sO\tKfX%P#J\0\a.g\a=\033Br\fV\030Zxf7}x\017\026ce\035i6\f-sf\aK\037///@>l|Z\ns\031r\017q[eZB\n\tf\032\020P)MN&[\031A\032VBk\024%vsAj\025_`D\020<\a\023>_'nhNxf\020\036&1y\033G\036afcQqtcn;\001l8\036\aY\025)'JnE1\037lV\a\017y?+?H#`\035n\020~/\027\002\036$,\\Hx{%\n#D~YJUEe\036[%0M\034|Q\037\034sJTDai\032w}Y?3m]Vmu\177\035Vj.fx0j)p\0PN\ndI=\030\fe2VO`SXl]oN\003x rB='G\022`\022\016\032(F;h^NlA$(\a3?@\022Q%\nMvM|FHTM~=ms\034Hlvn\001\037ojW}tIg&B'\016o\020d\177c[8K\003\020\030J&z\vA'\035\037/\006,+\026K0\001(y\032l `(#&)\0Pk#\033\ay~C??q\v\037\\\"|s\024>|P{U&{\vY\017?\033i'1N\026-ef4(dl)\001B\f.x}\030\022i\b\021HxQc\023y7*J\030M\177\t\035\b\017y9O\tRH\006O}Q\025\t;C<\002!qLav/|M*z\037r\001\nGlV+1xfLMfoI|Pn\001\026M\177\027\bg uIOG'\001N\003\f/{QDCd\t C\001\\%uNp\bB.\006\020!\017\023{\037YA~geUXY/h\023:@\r\004!Ml\tY`_cQ|5E/\031\021(f^T\017\0Z\t+:~hb;1\001~`\\\022+B(VP\002fPJr\037<N N3YCy6h*ayk\022\004Z\005c^B1/5g\026le`\002QJ?|Cv\177n3\002]\017O/./P$x~paeRED\003m\v^<k\b\ncP\033/Bwy\177?\034\022\021\034Lh\025,\177a[Nf\020>\003\035\0l,1\027^\030RL\0Ha\020\032X,\b_\t(\022O\004{ \033xKMw{?i:;>oe\025Y^>bODZ\r[;$\032.\022Uu*Z\031,\004\0\026-DNzuv=N\024q_\036\034h|d.?p{\003T#`H9y%{R\a \004woHb Z^\021\017\023ELz\016!# cJ\030N,W\026;'(D\034\032\027p[CE?\023\033*%Zs*sdA;\\BIx`\021>S4*(V>d\026\177\a\0\026\002I\037X!Gh$\fz\\NP`\033`!q\035AQQJA\0\017V\005O Wc|\027\024.QYmf\177*m<_fSg\035q<l<yR\027k\\LZO5o1|U\006T\024d\\\at\a\034-U~$u\001JlA\001QC\bp\a\030kF $#D5:=S\035dt\035^w*`\bn>N#?Kc\016x?\177iE_\vj\037V\025EITqku(($@\b\\X\033m\\\001\016Cxln\017s3'\fd\037`\020^\032E\002yH\"_\030A'\016C_+yx\032\022\001/.\022}\002\004KZgC$+B/h\035V\nfe\037VePb!\026*[I\030Ir\024m1<u\004oy\037Ap\021\a_\r\026`X\033\022\022Zq\030\bMQI lI\va.D)j\0\a\034+m\006\022xuM2JR/q\006Ph%\022z\vs(hC1c;{qQ\025%Y\036z\020-\020AB\006ksj^\037x\004\ve]=t\tN[RTWq~\0RDBOi;?qy\004P\026,`\021\016m=z?)o\023`O\016Y\021oJ_\032\003\017D\002\030\0%p\031P++X)\\{[M{_$RuMDmlz\035GK{Y[yi\r`4G\016U M\"\022{\037OR#hl\fhD-f(deCPNx\024[\017~\027D\f&8DVmve*\v{uw~)]8\003pRH:z]Lpu%\022\002\032/:u(tfGzBG\036*9\023<\023E2\177OU\036\026~\002S\"FUO_r^QoHD<w#]m7^\002'\017wM\033!*I,\020\016?^kS\036hF\"\020\026\034yS\035IrC;\035\004\023\"fl$&IF*#f;\021\177s+@A&rEh\017w|@~i\fl\002y{O~v*^\030\f\031K\031<\031a )(s%\"P$P@\026\0M\002[hvvV\037?L\tLe\031\032\016\001v\036p\023c\036M2&7]\"k\037\017mrgs_s\017Kg\177S\016LqI\005ms\rw\034x=|?p-qg%\031qDJ'Xb\003\035\a\027,N\016dRQ%||(\002G%qcf?\006\toc\rX&\036e\vzB\004'\024(@<\0g|\v\004g\006vhg\020V\n\tXI\002\bVG\006\tE\\XJEOa5\b\017QW<\005\035^n#xtlU\004j\r*j\006U$=\fwW\022V.\rD]fHv+\f`/\bT`Z\037tqK\034y\035IcJ\022Rg\032\177Kw\035RT%8b<}\027@h\017B\023\026-o\tOYSR'78`H\026vz\027OB\b}o`o.:zLiU2b6\020\023\001%Il`vE\177#\032`>\rka\005|\005QX\034'\004Q>$TFG\f(\016OL@A]~JIK/m@j\nZ\"\006y(\002\005L1gk/; \017m\024$pm\005\002zI=c`@/\036\tXEa*UG6\0\032\034O\bZ='Hl{$.!}\022[V=\177K\016\020lLSH*//\\<A`)\nHN\tpf\036rL\017\fl0!\005o(m\t^(\f\023\037M\002\177Bz\016[I{61I\177-\030\036\016@``;:Y@1g,\016X0UJ|In=\177\037^;EV\bq\030\016%wLh@wW\020e\003g-DVoYs%x6D\024\030GH[XB!q\025c`vr\001#|q&/\a\034rK!O\vy}'N\033%w\033}nB?q\027nI\aC0\005F\024X\025,m-;gbsu!sFzCA*\036\003\016?Y\bxQ\021/KF\036a!\022u1\rK\177\024-\n\027n;@\031wU\027\026\017G\b[:da>Hq\033|\"B\001o\005\030\"\020\t\025\0029k>B`^\017|\032]\035HBuC:w~TIh2\\\177Y\v`^<\016+\np\r\003So\036\001X\026.uC+pr|{wK\033r\"U\006}vbpF)\031\032\"S/z\037\005WcL\001y5\177|\030\017HTqXBzq\020\030\005_\035=El'$~\025Fc}KMR{e\024^\b\177[\"M/XWy_TCj\016>]LT`j\177\017/\017\025X\020\017\aOC_UMy'\a{\022S\a<:F\nr)\003?jk\031\rl! \ao*\a8'Ub\b\033\034\004\035R2,>\023K\017Y\035n\025N:hZm\037\agv#q=<\022'+1\027N\032\002mjQMY<\016L(\v<!AOUQeu\t\032\aQ\022`?4<+in\016\024\003E\n]\b\024\005?njD:hXVM~h\001\b\"T\bc\bR;\020{\025\016Oxj\"Mx39oaDJ'z\022N yR\v\023\023F!\030.\020|l#\031p1\"J+\026\031Trct\177Cb?5dT:\025djtTa\004~\\#Kt{XJ;h\003,\"\177\037f,\0H?RZcpu\034 `elU|:.;Q-Zlw\017Km{\024\003qO\034x\fTG\177M31\017>\002\026\a\036\031?\v=~^Vy((U\027r\036u\001\027XD\0jYXW{a6\177\025o\017\024(\024u\027LJv!b=\027n\016R9A{yu\017)E7FUu&m\024\r\fk.n\002ilz\037'\025o)$\"mQe\016hM@\033\vGl`Vw[h8ywY*F6\035{A/P]\035\003V\v_m#0!~)\034ME3ep\vE/(o9\024\004\027\003\021f(\025N\001\a\032\0310\027`\020@#P\026{\020\003D)r/\006Q!\005Qo\a~\037Aw\004fS\005Z>\003P8IQvC5t\020=:CnAmc\037Wm\n.,\036\fYI<\033\023T\034$\023Ke5SyZB\037\t|(}}\177d\006\037'FU\177e\017u{\021\004=dtg@h6\021|@Mfa1n)Q9\001fv!FE\034Qz2L&ki \0@By\037-\024\\x9\030\033_\033)tK3\006a\bU\r\\X`VuT^D P\bZgRF9o%[\037w6xD=&\r!DBJ.I^&Rz.V\035W>w4xq\001{W\033{X\n0\022&\aXygo>@/\005d\036wFR-MM9Js\f:\016U`smHh\005Hph\032\n\026oe\006;\033_EG\032L\004G\021\034:RY]\023}8kS,\031fB)JQ1@\002iCX/c\005Lyp&$\004CD\026t4Zx~Ki\023Oj:;\022\030Jq\031\005z\031zG5O9\0m\r\n\004H%{\032c=\026qZ,\\kj\016\022j\023\026\nN\030g=\005,>\021O1M&xoX}9i\034 h\nTff\031\021/5Q'\006.\020\r.PD\037\002\003.R\002e}o7\004\027Vt\005%\032pE#x\0)!V\033_Ks.GfO\027\"fc\033deZew2\006H)\024!4=?\002m\037B5\vF\036)][\027\026\003C(bFDN@Ml~PwANny/d\023\177PVOLs9\022\fK\005\027ciH+{\020\0040'I`T>:~r\002\016Dc\025F\021RL{zj\f*Za\0304Q^we:\030K\\s\tC,\017*:\0\003.8;\"w.\0Y?]UhGBdu\003\025_go\034tS\aRaM3Iz\atbsc%f\"{\f\rD\004\001+]i+$R\0e\a\036\020S)/\027DQ+6Fi \a{u/w<D&J@\177fm<ao\004iCZ\022l<'G!H|t2!$)\"\003;|H(:02K L%J\032\004\b|cJQ\017S\v9^\0L_4<(H\"M\032\002@2\031`%Z\aE*eE\n]\031ibY\034|,\020B\023es\f\f\034^Q\031#\033V[7' \0z\030j@\027\024\\aUR%\\Eg\020*o`-+\030KH\032Hu\006'a W\035\024Y\037\005\0\0n:\nw8QW-\177,(EG 8PU\035x[HQ\033on`\002X<!\002TA\034<J?G|;b\v_,\fv\016R2x\002(oX4YtqVZo\016\001-\024 #HHAy\0@D0I/uDj\0379BP|;\177\0E>IV\001]=\034\030&Ua-cvR*Q\037<\177\031\027fHL^\036\001B 2\037\177\030b{\031\034JS\\RiLA?U#\rWxh\003\024\rd%|\a\002Z@~zC\177`A\tj{iu\024\bK/m?Dtz$\b'mFY_hrE\035\023n\"e_.fY;\0o;gUoD\003Y1m\002er`\032X\024g;F\002\036m8\a\033\fJ\r?\"\005\024CZ\023:O/RU1\rrZhZNM<\017\177}~)*\024^\177\021,+Pac@!8[\031\020m~}\030zJtC!w\001\003,r\001vSYtElB#\177eorH\034cO:mlf\177g/#\002\024@7P/\r~\035`\032\030cZM\amFt]=~>CKKOJ\004a\020cx\bm\034mE!nNRj|\177/Om%({\001cz\021\003S>\017\036v:>'\0c'[wdIE\025>'6?RLo9wI<UT\f~B\0h?}\021$\031B\"d\030\030\r$a&q\033{\005u_(\002}vRoQd'r\bD#D#{X\022\005\002$Ic*vZ\033e:\"~\020Y|M#8H\033 \f^~V\002_\177\006\003qbEdq 8}$3\024i\rx\004i+\027s {Q\025G\\\177s\022/\001\002\016\\\023\023Qg\"9\030\026J$?\bE\031y*UBX?A+GeL\031B|+9[\\\"e\003vbh9yZ\032cF\035ZY*\002\036\021R\\dnH/vN\bWgsMeKe&\022?\016;\001:M\032/e\022_G\003\0d\004?JV\024nI1_Xq'\021W\v||\b[@B|\035:\005\005\026.%8Dgm\0338)\0\035`&\002\023^|\005O]E\005]4kJ<_\036\006\177\035Oo(&m4\030*\026\033}$ggInx6c+[:\024\001\032vzZ~\024L6\a\020K\006|\032\rcztgNle\002tQYJ\036z\024\004$\027\036\005_TI\"2gN,?O\vj]k\"\036=\025B\006hd]l-c\025aN$\tc\f*Yd8e\t_$YkY\017G\032QLHP#\v;;\036\n\022b\vo\nq:v4@B\bK\fY(\030z)c/Sy\016H!;&.O\020R0i,\r\024<.W\027kLV/.\036\031EBdRB`R`Z.\001X@yH\017?Cs;m^m* {?&s3bO\025\016`9\a\022bdSV%+r\fK$ +fa\n\006Q6*\037w*hm,\032 @v\023Y@lq\032.i\017`]`\031xG]6PhoJzWmilf[>jZy^[}0`\bi\v*w\003S$v\"~^_\023S\0-8]S\017>&MHBb\026vLc\036A\021N\034>Q\022T\025G&;Z-td_b\nl3dv\021U\016\023c\017?\022\037~[Q~\020+ k\003CS\vX\031it#)]uyb+X.H\177cY>nF&i\027p\017,2H!\005+!/yz$Lk\026R\036(\b\\FeoG/hW\f@\024(Am\030`,a$\030IV\003ZRm*U\017\n\001f\036}pE\0^>\017\177Ya\\7\016UH\032<\"\\\rrj@UD>\001,lTe\177u.|PTe`\016\027|)~\033\031P~M\005B@iB-\004,5x\025#\016\a\021\027fNsM\030h\033-(\006feDf\003iz-b:)e\035o\033d\\``.oQF#LIdU,+6Wg?$)w\001M<+C^}u|\005\177*\027SP+ZWWe# KF^#.\"\017A\033\a\003\036oIO!ctcB\0-4\004G1CS\\\n_\177!\034=>\0033~B<28j;e`|gE?e\003A%\016C_S\036b\"ub0w\003w:>GO,<E/tYJMh\034\032zn*Hb2s Z!qm\a#a\017Bv<\rp\022\\ZDf<u\\R<\b FXH\023(#'\016J@\037\bSTu\020}Y\f\025l\023`\033N(?\027T\vCo^E\035m?Y#y=\006i|\023FS\020h{\033iZ]#fS0,o|z\006s%N=[f}Q.9^kSo\037\022\016Sfp\003\034\006\033_wf\022n'QF%b~GT\037Z\020QUnIwaL0\001b0\\>=Q!\006;3\036&B!Wm1gU\036(\\\002\027h \037l\rgLVMg\v\034w\033(e\001|\036\031O\005\v}LyaF\033%2L\004 C|j5\016%\ffBdel[0 SgFm2}g\0`ngqf\034){\0\026\rzH+ERsu\037m>+6wP\004XT_\030rG32\006Z\037s\001\030-\031\022\024\021\004l\030(%jit(W]\004\n^Ibl^mM7@m4\006=\006YuZ\031 XJLXd)K#e0JL3X\025Y\0i,YxclM\032e$M\034\016 H\t@q2Yq\rGhM\017\177:=}4i@=@[>^^+D\f\020Cv'AJ+Qh\031h\017j7G\024:0d\v\020_<<WH\t\033`\001DB\rt\004'a\027y_JP@ /bzq!X\005\035&&3S\005\rbC,\025\026b\030S\bE!q!)r)\t\025]J\tPc%\006p(c\034r20Z<a\004\004gRH\"\bl\0*\023<\003H\006X\t\005(A HA\022yp\vy\024m.%\003=\0\016e_\r\r\017j#|[{\017_\177W\vON\n\036Nt\001IT\tG\rM8\0*%OH.1M\020Zm.u\036\017\177TN\003\"!_4C\005IX:: \037J\005=\002G\025\020~Af\v\034 bEhRD|rX_y.zE\033\016\024Q!l+\0)\aZ;PR&T&h%Ov\002\016P\n:R[Z|\023%\177Yn;fnM\020yg\030?X2\f\004D2q\021\024A\023LLh\fej\034t-1zTA\021q2,\004@\177\r\034\016c?\001!Vji:.8\t\020E>\022Yg\034\025rz\030{Q!>.rl1\a\006\005lhS<ys.\034$&\br\0\bT?,Gm+.\023G\022Jc.3Pb\0_\021\a,\033\002`)d\tl?!H\025\fa\032^&hRG&Q\037\f;,-\024Y\002q}GP[:tq\006~Wg\fK\005r\005#AFG\036\036_J{P=b\036t$cUgBWj\034R\n\0[\023&\034qZB\036f\030B\030+T +K\n|H\025NZ\025H\022|RFhc:E\020FcY\a+\032po/v-\004\v\032y\022NXnr,\rV6$cH,`:>\023u_;kp:3p\035n} 1ugA!D6El\005\0\020~e0\016Ql\f'\031\037\n|*IaP\016\aA&kBrbm]l\t%`Odk\030YUZW\t\033\033\036\023\\o%\a\002V]vN\026V\t\025q\027=FKG!\016:\n[\" h)S $#\016D\t(lKjY~QEY_\021\003ckK\035qL\016\020q+T|dt\026\0\035tv>Q;\025*p&Ic^\v]{\b^:\r\004^b\001H\v\n@`P7LgN)K\a!\003t!\177|BwS!\034Z\036_MJ>;PM@rj]\t\033VB\033_L\002U\021d`Q\026K\016D\f\005\0062\023Z\005\021\020\aZv>\024QFg\021Y\032%T\026SzxMh\023x.D)\031aPr=\fw\\U\022\baXz\v\t \n\002\032nl\034\r[\033^]\033\005\035LChC;\021\016Kf%!\022D:n\t-\\T] A+\aw)j`@J9;,\016t~\bs\016\016\177ZbYawr(p'EL]\030y\026\024\020i\")\"z\030pgS\031x9%;-[y\004\a\033\002\bw>[&\024S\024<YD\022z\025f\034\031\"}\021z\0%>@ En,\t\017CyX\024]Y>cueK#q\b{d+>,\177\016\a\r>\n\036w_GWJ\020'\few\r f/<?Rg\v \017\177}$])\bz(KFe}gP\026(!Z@gDS\nKf\034\0\003 Ny))9}\033\022\017{{#E\036yINn\001~Mc+M#\fR\021\024Ol\177i\r-'b\020tw\"\005Rn<B\fLY^\021rq-ljvLLy+e\021N\001N3D[m\026AE\t}\033nbJuo\003m!1E\0e$\f+\023>\fi\r:SH(K&\032(Iw\021TV\bR<\002aJAR\037\031\026w$WJBJ\026Ewyuu\035\027tqD\005\t/4*\036@=js*C\036;or\020\t\020\rg?\004Hq\006H\004x\002M\001\fM,x\033$[y|EZf_lsyo\017?\016\025VD.I\030B\b\034\017^$\032hg|\nbRSBs$,8\021E\021$.\021&t|i/\n\"aWN\032^v\016T\"%\024bs\a[B5\033x>T6D\021v\033\030bHI^rVyZ\023l+Zb{j\005-\177_a6\021\021\020\0\034\021\005s\"Q/Ma\037T\030z01KW;R\v\031RG\030wDY,\vwA\024\032Nk0\v\vaX*x\017\006\016\001:eGw.|b\025`ks\016!=f~YdtiRyO&P|g\004r:S\025RO~w7\001\fMyZE[>`\v|\030v\020\v\031;z\ty?G/Hp\021\"WG\024\024,rgRlQ1UP\017S}Eune9\vU\031\036n[\035^\036[S\027\025g|\nz~$:6a<+w\021^J]H\033\023lJqMX\bvO`\027w\032C}|) \025O%X\036`\005:#\003\amQ\bA\vXW~\020\r\026\0~)M\035M\bx=\nJmH{iD\020\nuU{\\\035iq-O\034vi\\&FrW:\017_\002lsG\001oT U\006$D[\177_\006M{9c0\003L2\005E\030\f\027\027CT\024\001\035\tm&\003GV\004\017!}f/uE\026\v/:d\020%M({Q\025+~E!h>Nv4%eqn\032Lfol\006o\033\006,P,u\177\"\vz\002U\024m*+'V\021]bE\005\032_`4_\022Ne*\033t(&o;=\026Lx%\006\032IV,WbxD\016+o\bky\026*)b.\037FXSUB\" re+\026>liG[H:`\\/\b qKrU3(iD>\003V<KQbde\"e\002%\f&S<!Rb\017-Hw%\036O\027\030?g\027g\006g\0\005d<j%7B\b<?%hrLXg8\025!\022\0/|?C3\"\021-\003FgJ\020\0\b\017Ut?Z\b\002S46\0\030\027qrjO\004j\f&q*q)rf\020e7`y?=H\035\002|ks\016>}Z9xLi\025HTS\0\177*\030\004^V\b\n!qd.\030/j\\)hza\020\004\0`)I(\017]\020s%[jq<\177\v$:-\0A\033\t\022rqm\027\030@\005T@U*B\f\021mUH\vj,y&!L\022xh!&\f\025CO\b*JX>\034i\024k!!5LA\bT}r,%#YE\bhE\032@b'\r\021\037\003M<\034l>q_\034B\\\033PS\027kY\005ne\r%\020Om\025G\032E\\-IFaEJM\\(\020\v@~W$o\036,qJWkd=@\v\001\021$\0>q}e\020\027*wg\001B\034m\003#N({\036De[Z(H\031z.cJZZsN\005R\nM\035voTTwe\020gA\"cD<T\021x&\033N}gU\022UiNh-l,UQ\023\034\023\027U\030!\035\004hW$\030uD7\r]\004\021=\024xY}z'N\f\006\"aM{x^Rt\b#6Dhk\"[v?VDr$\034\"Df(\f_\023\002K\005X~\001\027j<TU2k\fFC\fC\005\016W$\vP&<p*\022F\032<&<\027\027SOk,t(\f\002*!N4tCRI0[B\005\023stX\\M\030m\001\022\034\025a\032\022,@PdqZT\"JpRardYRp[>g\030Kzg^B\r\030F`!zV\024':J@v/uUd\177\033\020XN\026qJ]Le\"S\022oOn\026MDqu\022AV,\025F\022op9z\aXC\006\027O?d\032\0UiI(\003QL\004\001\022[\016[\tC((t\003\a]1tha,UXT\177\033`:&\004L^1\024\t\024V\nRoQ\005p6\025Y!,NzkVh+z\021\021\034\004\n~\\\fd,z\031d\005m\020\032J!,}hS\177jJFC9G\"\f\017a'OFH;W^J\023\032?thVtHE/m~\016^\033}dhn\037@N}\177C5[\020\177>UY7\005\024I^/U\023Y\033\030/ZW\tMOY]x\030A)\0\\9H\f\b/'\b\033kY(\002\005~B\024Bj2x\017X.[lZLKBW\002fl\025j[D/\aw{\016^\016\021rE^:4z=qm~ @\a'_\003\004FZ\n=Y\023>B+\021\\b\035\"v$~\017FR%\027P\023y)QuIb\001DZ!Bl \n=T~\vcDyQ\n\034\027yY\024]\031C}<E~<]\002\a\024A)tZ]A\030\004R\0022\026\005;l\006k\035\022)Z<^,s:\"B$& m\033JK\026Li2E2!0q\023\004\027zZpg+\034\005\005 a\021\001EJ>o:\v#r`\022\032z\v\024}5uu>|CV\002\"\0FZd \002ZIn\ft<8P\b\177r.\023\vC_eG\001\t@\032S\027^\032*z\"n\001x\031,~GY~uj\001\034\030\\a\a\f\016\026g\r\f)i=J!GEc\023\030&]\025/\016\036@af9\016\027\027{L\005!\035-\tHu.7>9Vm\016\023Rlw-\\k{NNg!~:GP\017CMAw\017'f\v_FU|AYCV1J&\021/>^\002\f{D\003\022J/BM\026:F~%fOz\026C\023j\bd\022P\003\a\004|'&\nMPp#\017E/I,JU\n\\(5\035#JC\nQOS \bXXPNoCpzZ\n\034\035E`Mbw<\016{}Kw}5=U2\024r-]9memdx<\001\005;\032\034\024\\68bQ>L;\017hVqs{p\017d[Y\"\023TB:+\037G\r`dG\003.X-P-OEzA\003\037^~T}>\026A\016v\003\030]i#\023Y\004}?ISh(d`a.R\001\033fHwTv^&7\rSH2n(!Fg\026_\003mM\027 \n\002O7Y@\177\feA\001\023=Pf\aMa$2L@3.!\024-\031n\v\016\004je\022i(\bm\\V@P\017qSB\032f\031\0)\022\003'\bC1psz\021_d\027r2`r$`\023\nObp~AdXaPy!:O\026?js\016[l\177\026\001}\003J\032yi\030\002^NlL:slJ~\0163?eV<?\t:\033Y 4\016f(DK'[G\f\0J\rP\rHmk\020FG0\035j\023g\034+S`k\026NM)\bg(l\t\a\016q\024\aIZ\023\024)Gh}\006(,\021f\003\177V)W\024bEL\v\005\037s*B\veQ\032(Y\030\002T\020^|}l[yVqIdi7]\021w\036zqL\025@n\026,\0\020<J\026iz.kB\033\004J[@\034#z_Mu\022PwHV+a\032\033H~(\026\020\002\"l.bSb*xj3\vF\024\bDg\027\034:*\003^>\032dcjyW8[ bevn)\\.$-lP\004y\bdxJ`o>:\024D\177qt0;y\022\006@\026\nT\"8y!>P4YM\b9yq]\\)f\177f\025%O+u|7MJ\005\"\"DZ\031Xv&6\030\025d{\003\030\031 \016V\032C\006%dw%ly],\016o\b{nWk\004TL?vi\003g\034wP~\n\vA\027s\rLxX\tpf,>z~\v-d<!W\032\030< }\017) '\027\001b>/N'\177giU.,5\023\030\020&\rhJ\005\005\034\023\001KP\023\bv*@}\rz\034MNyG\f>z \b\032\023\030(y6\031[\027*Y\005Vn)E$j\023_\024\ti_tOcd<.\005@h'\016rgfv!\002{\026\031@q\020E;Mu\025\021Ji\v\032\0S\031=d\aL\003c=^L*W.$\024\\c\as\037\nf\034\003~<YLf\005SB#hdkqT\027HQ~\005\177:}u\006}<U*\032.\\ \034y\021YP\036t$:\005\r\027 '\016bFzF\ncpBF\026\001^Jj\vf&\022\027S&sj\0E\tkH\030E\021LY\027pzJ\035n\025J *e\025s\005\177\027\037>z\002_c\004G\036\004f#%C\"wG\027y}14\027).b-lH\b\005\tdGD\030\033$Yxpqwv\037fSQ4\021\037=R_Jcue_\nnYrGd=t~\r{+gA\023(\027/_uN]1mr*\r\020Ddh-hZ\t#F^>j\020w=L;(A{\027^,Pmli\024>CSAQT]\"`\003\030!A\035?\017*_^4D\022Car\t%\025t3(wdw?;\nO\\o(3\032vZiEaf\aY?\037:z:\aVF9Y 6|YN\\s3+e\006~QX[+Te\033_ZqAD\"tE\023G&-m1(hrx:dL\023I\025\021jZ\006\035RMF\030\tx\"FA5yn{\005>iFj-/\023\032KBT\rj*$\fP(@]\021\003\027JPMl2\001n\030)kf.\002U$\023\033\002=lm+bI\fBI{~lK\f \023p+OK\037B3\"+\033\006:\031\030bK=@-h\002E*\026@WLQW\aGh\030})R*?;[o\n}\016IxiW\026=\003=r@nWHXP532g\016kl$hW|h\034\006\034~]l\001_7\037\035\020|t(skhi=&\002\032e\030{\\\v:P\0]ERCvV_n\031BD\r\fdRh0Ojz\026\016S\177yx\023&Jp1p\006}\036Iy\fJCH]h_\177u+SJX,Q\017%QEZO3\031\002ZH'3cxHe\vq\177\026%\036\027tr-#6[6\\\fDAXYk\017*acXv>\001w\016\020IV^\034gScZP0XJ\006{\034.t)%\"`gXXNaixOl\f\036\0245\t\f\n:b\b\031bON\t\0\003\022\177\030\027G\017^!\017\003\\+E\003H#\017oesO=xB(S;\177R\027p\002\017$ToB^-H\v*KX\001q,\006\a\031OO|R%nI`i\026U\025\n:\023\t\037\037,@F0\001\a\025\004p\036P\a\001p[\023\033?X\026YD\020Jb$s\001'\035c\b\037)bCuYN*\023Iw\0255Z\nuoQ{\035~{_\003`W\024}.\aTC\002 bNW+=-Qk]Q.\\\002=\036i0\vAn.[\024SQFR%\vr\vc5)lSi-r{wJSW!?#m\035\016\024h\036zx1hF\005jr3\027g.v1\177`dE\004%foLSSs5 \r\001\006c\bRi%Sko~@\002dSMrBQ\026J\030\177\0\al\005\0lI$BN\020\021:\t_\a:}=\r\002Xjb(\005q3+Cm\005*\0D\005\bS9}xKJ\030,P\023O\016A\031*.=\006\030\034nK,^(\035\024HRpxW\034\tM\031S\n&\025U>b+q\037z\nY\tjU\003\020]`-\025\021\b|B\032t}epU^gG\023S\031^;S=\awg\vq\035;\v\022Mcc\aHAKVT'\031*\032Tk\004C\fM%P\001/$\025KQ-R@G\023P\032x\030\032\005CVeO6k'T-mk\001.yN\016z-2)4i#\002hwtaS6\036OFWTX Ef\030NZ}U\fQ\026XWzUn.ah@f\026\rH\tMx\026t\030\axcc\023\fQ\0-\003pm\026M3;o\177n-b,'E\036q?t\032%P|5\036c>\bT=\022m \a\005ZL$'\177m\v\026\005\\\032>R)]\034Bi)\035O%:\ne\025ovhN\006\022eY\034bNS%^Po\t':\025\031Z-a\027O\004es\0$h\0,96\\;!7\\W\034n;^Y]\031#\r_:Q\020aH\023R*+&\020J\035\1778T.+nS\177\006{-(?\033esh\1779FFk\t\177s?\031vU\032bH\016>\004\f\032v*=*ss2Q`\022)>G=w5\035)\tX\006X=.(\t{\rBNY(\b\004c\177\023QyT(u |B,%v=li,4eC(#mUu\033LYy\021%%\"[\177\022\023_\aM9#NIs\177#9X\032\003;u\020)N#8}M[\024<e?\0_\016^\vkM\fg\026z\001S-Za@>H\f]#TQ\036\0(b\023e\002a@N-ix\005OiI\025Qy6ye\\+Y(\bSD2Tf\036\003j;B:|F0\006\bin#Bl\003/,3\030\n.~u\bJ^[\030w\006@^\177FokE>\f**`M W;\006%\033\034Jh+XkqfA2\"]da\n\022|\003\v\034rjFb{-Ymuf{\"<\027,YVx\017&\002k\030_\fM|<\034k])ekcY%WMH\035\020T\nVBXR[P}\\\n\\_\033wF\004BB\"/DD0,a\020\033LN\025\0\aYQ'W\005`*fjN]\\.g~\022#?_to<\036B1]\r\037\022\021\\?Ek^#tFN\005o\002qb@|\\I\020#0nQ\024Jfwb]\031\\Fwr\016~K\026^\r ;y[*M\fA\022\037/\f<v\020\020O,Ot\037ePN/\026D\b\003\032|\035z\026#d9?|r@M-:DiK\030yI\021_\023\023[U6\akM:\032ewI{\035\r&+T0gGl&WJ=\\^H\vq.lSs\f*%v\t{\f<m\tuG_|=\021\t.H\024\t/\036?o Y/\001l\f\026maQ\031* \b\t|b\024\003\023\026p\004bD gkbq-YjJ$\025L/~2\034\bJ\005FB\026U}\035,E\f\023dWL\024[#\016h\027Wo\177\017n)'c-V]c<\001\034V\036\rc%\0,\016@\033$kTp\177b\003g*;e)\004>?]4\r[\030[\026\177\037go<E@M\v\034\023\017ie}jTBV]\022$T\024KES\032/YQ\avk\006rh,I\016>;}vibA0\07OV,F%\njQFl#V?'JiJ1+YT^W\022% rX\v\017Mp;K\026\021[y]f2\030Xw}\rgty20\032\002jP\002A\022.\"Y\025\030\"D(A\021's!EmK}@u];\033+sy:!P=s:C\002viHGNPk\003P8TJ!\027.]\017\016Zx\006_Q=]qp<-f\n-Q\177Q\005n\t<&BF\022~I\030!/!{eHTP~4S`[G\031~d'Q\177fg=Pv b\026o(_f\033bT<\031$-N1\025\025K\017\nIsh\020osFR(I\nZq\f\001Jl\006w-\034}C#\\\a\001\bO>N|\033g8d3O\035b\033\021fis_c.$##\b(B\006\036pe/;a\024M \006O\030c\002/yaH\rEffd[%\004~\026MJv\020!]q++d\025QDG8$\t\n\twJ\021Y(?\021T(\177v\016u\006f[(:w'kDH{(zi|c\001\a[Y!\ns@@\f\026FKK R\t\rR ~9pP\020\004\tE\177 +x?r\025b*{xYI\\ns\022\021\005\"m|X>\vqX\031z`G^)\020\034:T\004\021}\t\0ouZ\001g\\v\037EM\021'tg D\v\033tBg\037c\037\\\025j\035\t5K+\027Wn\033zy\017^r# [,\024\177zc\035z<:{\037`~1\002zm\004\005G\033s\r+l\nWW,lqzn\037\v ua8uG=%\byznEP\030J\nQ-\035u4%5^z\a\b\"\003#!dL)B)%}\034`jGLr@BwBUuKo2\030Y^A-z\033TyPbo,u?{doSGpo*3}xf/\f}T]A\030.\004&(\036\021t\tA5#\022u,_R\003'y&!Y~H\016XJ[r\035Q\006\035j\037\005.l@qf|\035a\\\f\0A\006\031\022JyRQn\a\033)A Q\020\030.J(.Q\"4\005\0xvF}4T`JM>H)Kub/0 >&\"Rx%c{IS6kxd\003\177]~\vIa[Y>-\001\fNpaA%8b*Sp\002/\001\005+\020Q\002\002PcfH;a\022\0g+UE\032}\"&^@$!!b\0P\",M\034{p\026<t]xs\nxY\027wNzE5\025:sRbKW\004W -t/\0+oHJv0]\004n\017\016R\006Gn\030dR^\026.>,lN/3\003\016/K\035\025rY~H)\017Idu\0A@\034(p#\004O'%3v\034m|I'dyFx$)Lv>\" \nS4?\025?<\004FQ\005hdwkpM\016\017nz;*\024Hsfw\035X\t^\026q%<\n*\020OhyOVZ1\021a\035FL\037\"\002 Z\"tG\0j#.\fVx|d\neIUO5H\001(RH\031*[)\\\031%h>\aYNk\0Ff9s\002\024#B4H7\024>\032\034o\035_kGAfyhW^po\022\024\rWN'\177\005)\003c|rw:^\033;Fn%yO\005\020P\001\032dE\tK}7\032X\001N\f\003[E/Sg\"\021t|\016*nR5k\035J\025DD^xi\004MJx\016\twpH\r_JDM_\001,K\004\t\"\0\022\034\024L's\"\bpHV\006}kM~oS(\003\f\a\026\f`Ug_XdGtb\017sOH`\bt2\004=NVxPam@]\002i\017\021\v{Op]?y\026M%'\037t;U\0\031\0[b\017bJt\035\022\001xe^]\025\036\016\036Vy\022/\023Hm\024\b{G;\001J\bRNB(@\024\bd\017\0~\016eHZs\tzX\016\bMU\023\\D\f[iST\031zpp\"NdJ*a\026\"vi\006t.\023\020\005;>TYw0R>\002m`^\033\\V\034[QB\177)p^H\004&s\031aT\t!\021\002)\016\n-m\006\036P\016^:\022\t~\032^\033l\vaK,+:o}c\a\017\f'5CehEA}8\017@vdev\036\0.|L+>Z1JlA\v[!aPA%st\n,j)\017.\032E\031QLm\036\002cu0B;\020B0(A\n\031gv#|y\024L=CUwlajF(\"eB\t!\037\fio7e(n\001Zw ]\022]\016\021[Q\002&kf\fC\005%z*\177\036[\004HdI\034.\\oL`\027n.H*\002%@!QAE\027\aH?B\a\0\005\0~\022z+p;Yd\n\032Q CLo\017U{\030o\027Z~g=\nfz_\037\tX?AMHt\"\035#!B4\024!u\031cUbx3\r'Aeb\035 y@Y?yTY.\017\020#8oA9=\"\005H\022yR\"Rj%G\f~\003Dqf\033Mi\fD\030\trK\f\aJh\020]1~<J]J\\K/#<~JMB=\020%\005#W\\IAOC!\001\017<a\023!\026h\ad<u)EwN\032?`U!^$Y;S\t.\030?+?5.Wi8D\006/\025>@R\026\a,;B\nI\031[O+jn\t\0 \\nB~\030cf9Q\033\f?Oa~<G,%A_q\004r\fG/@\026Sc2gn\rBzH%\005r7 \023(x\031\vUHzN\027|]S\rm\035E\002Q\033.nPGjq-T~-+SW+POUJdp(\flj@jC\004m\021\031^iYsIpCF\\PVl'kWd{ybDYg\b$T\005+yn1k\"%\016C8\006|!/NHf({#tnlIjXE\ru\\Ll\r'-9\006ZT\006I\006\004V\004x\027\020\033\025%\"\033\031 \r(q]=|\035Og\n\177\030\006\035sb\033UwRze\001K|m<O\017\036Th*pf\004\036,tr\035\vFO!epCpK\t:#,~3^<\no[e^V\026$/\005\031Mt$B\005c'FS\032\025=S\t?z\016#\177\037\\\020\025\021L^ \004\035J{@2qYn<i\035\025Ja|\027rarauXW\022%/\034\016vi692\016S\rkkXRb!sAn,\003W\022`#5\021r3M)2O\036Ef\001WnL\024vXK+<DK(RIge\0RH\005t$[<5];g>elP !iG9jZ`;!5h?\037'|/%\003cT'\004n\tG$N\027:G\034G*\177DjrlG\037T$w\017wkxC\030\b\001>jC:\027z\002\025\f;PK/!1<\020\022\0030\016eJ\020\027D\026\bL:\005~\bwr-\\\002\001ET?E{tG\f\035\0170\033Xqmzbv,'\002\"s\0!a%\031w\002DIos:!`\027%%Ft\037>(x\006#=I\016\031\vu*%n|-\026X)(`eK\"/\naZ (\020\0HV\023\024=j]\020&\030' wi$Y\n >\004f\0\0+\037Ql\n$wC}+j\"C~y\026\004#\027w\004[c\037m\"A'\030\rx\035 og\027EMo\vr)\022\027\031\n\021LbUHc\036T`dU\031\004o\026_OS\001]9C\r\006z^\002pD`z\004;\022q!!\002M\"&L\"?B%u\031\033Eb A2EK>d?@\031H\035kh\024\006\003]w\004!\034cX\021Hr%Pk\v\022G2\034iXFHBzB\030`cWs\037q\025Nv)#\v\023C\020T\"l\032/E!#~\v\a\031\024@v<\027\016`J_J<A>,^\021F<zI\025@.A0,\037>xv%\031h\177 \\s^\016$hx\017\036\030X\001^\035se\005GC'&\177@P@\004Z\002Ux.C;\022\036S9w;\027~f\003R\022\r;;\024\035H$\020<\024\036yV-]]\026)\004Q#LK;\036Od^\025<~{cI$J?,\030\177o#Qs\177OLL\ah$?\022;=_cp?0^@uP\f?o\rB\026$\\wn9_lf\aN\"|AJ\031j\"\035\016gIf\\>\002CffAlSA^\033Y\037\037l\002\003s~\177S[\177\023P?\vv$G&]OI\034%\0X~\033~J\025K$M|_O\036\025\177@a\177+\":}\a'\035~XCo4V&06O/do\177Gu>u|\036Wrgf\020#\001\177.p!p:";
// cpics_compressedsize
// file matrixview_textures.c line 4403
unsigned int cpics_compressedsize = (unsigned int)63827;
// cpics_size
// file matrixview_textures.c line 4402
unsigned int cpics_size = (unsigned int)100800;
// cycleMatrix
// file matrixview.c line 39
signed int cycleMatrix = 5;
// cycleScene
// file matrixview.c line 38
signed int cycleScene = 5;
// dirName
// file matrixview.c line 94
char *dirName = (char *)(void *)0;
// exit_angle
// file matrixview.c line 77
float exit_angle = (float)0;
// exit_mode
// file matrixview.c line 74
signed int exit_mode = 0;
// exiting
// file matrixview.c line 171
volatile signed int exiting = 0;
// flare
// file matrixview.c line 50
unsigned char flare[16l] = { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)180, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// font
// file matrixview.c line 47
unsigned char *font;
// frameTime
// file driver.c line 62
signed int frameTime = 10000;
// glewInitialized
// file driver.c line 60
signed int glewInitialized = 0;
// hack_name
// file matrixview.c line 36
const char *hack_name = "MatrixView";
// idleOnDPMS
// file driver.c line 68
signed int idleOnDPMS = 1;
// imageDir
// file matrixview.c line 95
struct __dirstream *imageDir;
// imageLoadingThread
// file matrixview.c line 168
unsigned long int *imageLoadingThread = (unsigned long int *)(void *)0;
// next_pic
// file matrixview.c line 97
unsigned char *next_pic = (unsigned char *)(void *)0;
// next_pic_cond
// file matrixview.c line 170
union anonymous$52 *next_pic_cond;
// next_pic_mutex
// file matrixview.c line 169
union anonymous$79 *next_pic_mutex;
// one_frame
// file matrixview.c line 78
signed long int one_frame = (signed long int)60;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// pic
// file matrixview.c line 72
unsigned char *pic = (unsigned char *)(void *)0;
// pic_fade
// file matrixview.c line 81
signed int pic_fade = 0;
// pic_mode
// file matrixview.c line 80
signed int pic_mode = 0;
// pics
// file matrixview.c line 48
unsigned char *pics;
// pts
// file matrixview.c line 83
float *pts;
// r1
// file matrixview.c line 75
float r1 = (float)0.2;
// r2
// file matrixview.c line 75
float r2 = (float)1;
// r3
// file matrixview.c line 75
float r3 = (float)0.4;
// rootWindow
// file driver.c line 59
signed int rootWindow = 0;
// signalled
// file driver.c line 69
signed int signalled = 0;
// speed
// file matrixview.c line 67
unsigned char speed[320l];
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// texcoords
// file matrixview.c line 84
float *texcoords;
// text
// file matrixview.c line 68
unsigned char text[77120l];
// text_depth
// file matrixview.c line 70
float text_depth[77120l];
// text_light
// file matrixview.c line 69
unsigned char text_light[77120l];
// text_x
// file matrixview.c line 58
signed int text_x = 90;
// text_y
// file matrixview.c line 59
signed int text_y = 70;
// texture_add
// file matrixview.c line 76
float texture_add = (float)0;
// vsync
// file driver.c line 63
signed int vsync = 1;

// VirtualRootWindowOfScreen
// file vroot.h line 81
static unsigned long int VirtualRootWindowOfScreen(struct anonymous$64 *screen)
{
  _Bool tmp_if_expr$3;
  signed int return_value_sscanf$2;
  static unsigned long int root = (unsigned long int)0;
  static struct anonymous$64 *save_screen = (struct anonymous$64 *)0;
  if(!(screen == save_screen))
  {
    struct _XDisplay *dpy = screen->display;
    unsigned long int __SWM_VROOT = (unsigned long int)0L;
    unsigned int i;
    unsigned long int rootReturn;
    unsigned long int parentReturn;
    unsigned long int *children;
    unsigned int numChildren;
    const char *xss_id;
    xss_id=getenv("XSCREENSAVER_WINDOW");
    if(!(xss_id == ((const char *)NULL)))
    {
      if(!(*xss_id == 0))
      {
        unsigned long int id = (unsigned long int)0;
        char c;
        signed int return_value_sscanf$1;
        return_value_sscanf$1=sscanf(xss_id, " 0x%lx %c", &id, &c);
        if(return_value_sscanf$1 == 1)
          tmp_if_expr$3 = (_Bool)1;

        else
        {
          return_value_sscanf$2=sscanf(xss_id, " %lu %c", &id, &c);
          tmp_if_expr$3 = 1 == return_value_sscanf$2 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$3)
        {
          root = (unsigned long int)id;
          save_screen = screen;
          return root;
        }

      }

    }

    root = screen->root;
    __SWM_VROOT=XInternAtom(dpy, "__SWM_VROOT", 0);
    signed int return_value_XQueryTree$5;
    return_value_XQueryTree$5=XQueryTree(dpy, root, &rootReturn, &parentReturn, &children, &numChildren);
    if(!(return_value_XQueryTree$5 == 0))
    {
      i = (unsigned int)0;
      for( ; !(i >= numChildren); i = i + 1u)
      {
        unsigned long int actual_type;
        signed int actual_format;
        unsigned long int nitems;
        unsigned long int bytesafter;
        unsigned long int *newRoot = (unsigned long int *)0;
        signed int return_value_XGetWindowProperty$4;
        return_value_XGetWindowProperty$4=XGetWindowProperty(dpy, children[(signed long int)i], __SWM_VROOT, (signed long int)0, (signed long int)1, 0, (unsigned long int)33, &actual_type, &actual_format, &nitems, &bytesafter, (unsigned char **)(void *)&newRoot);
        if(return_value_XGetWindowProperty$4 == 0)
        {
          if(!(newRoot == ((unsigned long int *)NULL)))
          {
            root = *newRoot;
            break;
          }

        }

      }
      if(!(children == ((unsigned long int *)NULL)))
        XFree((void *)(char *)children);

    }

    save_screen = screen;
  }

  return root;
}

// clearBuffers
// file driver.c line 158
void clearBuffers()
{
  signed int i;
  union _XEvent event;
  i = 0;
  signed int return_value_XPending$1;
  for( ; !(i >= 4); i = i + 1)
  {
    glClear((unsigned int)(0x00004000 | 0x00000100 | 0x00000200 | 0x00000400));
    glXSwapBuffers(XStuff->display, XStuff->window);
    do
    {
      return_value_XPending$1=XPending(XStuff->display);
      if(return_value_XPending$1 == 0)
        break;

      XNextEvent(XStuff->display, &event);
    }
    while((_Bool)1);
  }
}

// createWindow
// file driver.c line 71
void createWindow(signed int argc, char **argv)
{
  struct anonymous$73 *visualInfo;
  struct __GLXcontextRec *context;
  XStuff->screen_num = ((struct anonymous$56 *)XStuff->display)->default_screen;
  XStuff->rootWindow=VirtualRootWindowOfScreen(&((struct anonymous$56 *)XStuff->display)->screens[(signed long int)XStuff->screen_num]);
  _Bool tmp_if_expr$2;
  if(!(rootWindow == 0))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = XStuff->existingWindow != 0ul ? (_Bool)1 : (_Bool)0;
  unsigned long int tmp_if_expr$1;
  if(tmp_if_expr$2)
  {
    struct anonymous$65 gwa;
    struct anonymous$61 *visual;
    struct anonymous$73 templ;
    signed int outCount;
    if(!(XStuff->existingWindow == 0ul))
      tmp_if_expr$1 = XStuff->existingWindow;

    else
      tmp_if_expr$1 = XStuff->rootWindow;
    XStuff->window = tmp_if_expr$1;
    XGetWindowAttributes(XStuff->display, XStuff->window, &gwa);
    visual = gwa.visual;
    XStuff->windowWidth = (unsigned int)gwa.width;
    XStuff->windowHeight = (unsigned int)gwa.height;
    templ.screen = XStuff->screen_num;
    templ.visualid=XVisualIDFromVisual(visual);
    visualInfo=XGetVisualInfo(XStuff->display, (signed long int)(0x2 | 0x1), &templ, &outCount);
    if(visualInfo == ((struct anonymous$73 *)NULL))
    {
      fprintf(stderr, "%s: can't get GL visual for window 0x%lx.\n", XStuff->commandLineName, (unsigned long int)XStuff->window);
      exit(1);
    }

  }

  else
  {
    signed int attributeList[11l] = { 4, 8, 1, 9, 1, 10, 1, 12, 1, 5, 0 };
    struct anonymous$67 swa;
    struct anonymous$71 hints;
    struct anonymous$72 wmHints;
    visualInfo = (struct anonymous$73 *)(void *)0;
    visualInfo=glXChooseVisual(XStuff->display, XStuff->screen_num, attributeList);
    if(visualInfo == ((struct anonymous$73 *)NULL))
    {
      fprintf(stderr, "%s: can't open GL visual.\n", XStuff->commandLineName);
      exit(1);
    }

    swa.colormap=XCreateColormap(XStuff->display, XStuff->rootWindow, visualInfo->visual, 0);
    swa.backing_pixel = (&((struct anonymous$56 *)XStuff->display)->screens[(signed long int)XStuff->screen_num])->black_pixel;
    swa.background_pixel = swa.backing_pixel;
    swa.border_pixel = swa.background_pixel;
    swa.event_mask = 1L << 0 | 1L << 17;
    XStuff->windowWidth = (unsigned int)((&((struct anonymous$56 *)XStuff->display)->screens[(signed long int)XStuff->screen_num])->width / 2);
    XStuff->windowHeight = (unsigned int)((&((struct anonymous$56 *)XStuff->display)->screens[(signed long int)XStuff->screen_num])->height / 2);
    XStuff->window=XCreateWindow(XStuff->display, XStuff->rootWindow, 0, 0, XStuff->windowWidth, XStuff->windowHeight, (unsigned int)0, visualInfo->depth, (unsigned int)1, visualInfo->visual, (unsigned long int)(1L << 3 | 1L << 1 | 1L << 8 | 1L << 13 | 1L << 11), &swa);
    hints.flags = 1L << 1;
    hints.width = (signed int)XStuff->windowWidth;
    hints.height = (signed int)XStuff->windowHeight;
    wmHints.flags = 1L << 0;
    wmHints.input = 1;
    XmbSetWMProperties(XStuff->display, XStuff->window, hack_name, hack_name, argv, argc, &hints, &wmHints, (struct anonymous$74 *)(void *)0);
  }
  context=glXCreateContext(XStuff->display, visualInfo, ((struct __GLXcontextRec *)NULL), 1);
  if(context == ((struct __GLXcontextRec *)NULL))
  {
    fprintf(stderr, "%s: can't open GLX context.\n", XStuff->commandLineName);
    exit(1);
  }

  signed int return_value_glXMakeCurrent$3;
  return_value_glXMakeCurrent$3=glXMakeCurrent(XStuff->display, XStuff->window, context);
  if(return_value_glXMakeCurrent$3 == 0)
  {
    fprintf(stderr, "%s: can't set GL context.\n", XStuff->commandLineName);
    exit(1);
  }

  XFree((void *)visualInfo);
  XMapWindow(XStuff->display, XStuff->window);
}

// deltaus
// file driver.c line 172
signed int deltaus(struct timeval now, struct timeval then)
{
  return (signed int)(((now.tv_sec - then.tv_sec) * (signed long int)1000000 + now.tv_usec) - then.tv_usec);
}

// draw_flare
// file matrixview.c line 271
void draw_flare(float x, float y, float z)
{
  glNormal3f(0.0f, 0.0f, 1.0f);
  glColor4f((float)0.9, (float)0.4, (float)0.3, (float).8);
  glTexCoord2f((float)0, (float)0);
  glVertex3f(x - (float)1, y + (float)1, z);
  glTexCoord2f((float)0.75, (float)0);
  glVertex3f(x + (float)2, y + (float)1, z);
  glTexCoord2f((float)0.75, (float)0.75);
  glVertex3f(x + (float)2, y - (float)2, z);
  glTexCoord2f((float)0, (float)0.75);
  glVertex3f(x - (float)1, y - (float)2, z);
}

// draw_flares
// file matrixview.c line 381
void draw_flares(void)
{
  float x;
  float y;
  signed long int p = (signed long int)0;
  y = (float)(text_y / 2);
  for( ; y > (float)(-text_y / 2); y = y - 1.000000f)
  {
    x = (float)(-text_x / 2);
    for( ; x < (float)(text_x / 2); x = x + 1.000000f)
    {
      if((signed int)text_light[p] >= 129)
      {
        if(!((signed int)text_light[p + (signed long int)text_x] >= 10))
          draw_flare(x, y, text_depth[p] + bump_pic[p]);

      }

      p = p + 1l;
    }
  }
}

// draw_illuminatedchar
// file matrixview.c line 249
void draw_illuminatedchar(signed long int num, float x, float y, float z)
{
  float tx;
  float ty;
  signed long int num2;
  signed long int num3;
  num2 = num / (signed long int)10;
  num3 = num - num2 * (signed long int)10;
  ty = (float)num2 / (float)7;
  tx = (float)num3 / (float)10;
  glNormal3f(0.0f, 0.0f, 1.0f);
  glColor4f((float)0.9, (float)0.4, (float)0.3, (float).5);
  glTexCoord2f(tx, ty);
  glVertex3f(x, y, z);
  glTexCoord2f((float)((double)tx + 0.1), ty);
  glVertex3f(x + (float)1, y, z);
  glTexCoord2f((float)((double)tx + 0.1), (float)((double)ty + 0.166));
  glVertex3f(x + (float)1, y - (float)1, z);
  glTexCoord2f(tx, (float)((double)ty + 0.166));
  glVertex3f(x, y - (float)1, z);
}

// draw_illuminatedtext
// file matrixview.c line 366
void draw_illuminatedtext(void)
{
  float x;
  float y;
  signed long int p = (signed long int)0;
  y = (float)(text_y / 2);
  for( ; y > (float)(-text_y / 2); y = y - 1.000000f)
  {
    x = (float)(-text_x / 2);
    for( ; x < (float)(text_x / 2); x = x + 1.000000f)
    {
      if((signed int)text_light[p] >= 129)
      {
        if(!((signed int)text_light[p + (signed long int)text_x] >= 10))
          draw_illuminatedchar((signed long int)((signed int)text[p] + 1), x, y, text_depth[p] + bump_pic[p]);

      }

      p = p + 1l;
    }
  }
}

// draw_text
// file matrixview.c line 286
void draw_text()
{
  signed int x;
  signed int y;
  signed long int p = (signed long int)0;
  signed int c;
  signed int c_pic;
  if(pic_mode == 1)
  {
    if(!(pic_fade >= 255))
      pic_fade = pic_fade + 1;

  }

  if(pic_mode == 2)
  {
    if(pic_fade >= 1)
      pic_fade = pic_fade - 1;

  }

  signed int vp = 0;
  signed int tp = 0;
  signed int cp = 0;
  y = text_y / 2;
  signed int tmp_post$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  signed int tmp_post$6;
  signed int tmp_post$7;
  signed int tmp_post$8;
  signed int tmp_post$9;
  signed int tmp_post$10;
  signed int tmp_post$11;
  signed int tmp_post$12;
  signed int tmp_post$13;
  signed int tmp_post$14;
  signed int tmp_post$15;
  signed int tmp_post$16;
  signed int tmp_post$17;
  signed int tmp_post$18;
  signed int tmp_post$19;
  signed int tmp_post$20;
  signed int tmp_post$21;
  signed int tmp_post$22;
  signed int tmp_post$23;
  signed int tmp_post$24;
  signed int tmp_post$25;
  signed int tmp_post$26;
  signed int tmp_post$27;
  signed int tmp_post$28;
  signed int tmp_post$29;
  signed int tmp_post$30;
  signed int tmp_post$31;
  signed int tmp_post$32;
  signed int tmp_post$33;
  signed int tmp_post$34;
  signed int tmp_post$35;
  signed int tmp_post$36;
  for( ; !(-text_y / 2 >= y); y = y - 1)
  {
    x = -text_x / 2;
    for( ; !(x >= text_x / 2); x = x + 1)
    {
      c = (signed int)text_light[p] - ((signed int)text[p] >> 1);
      c = c + pic_fade;
      if(c >= 256)
        c = 255;

      if(!(pic == ((unsigned char *)NULL)))
      {
        c_pic = (signed int)((float)pic[p] * contrast - (float)(255 - pic_fade));
        if(!(c_pic >= 0))
          c_pic = 0;

        c = c - c_pic;
        if(!(c >= 0))
          c = 0;

        bump_pic[p] = (255.0f - (float)c_pic) / (float)(256 / 8);
      }

      else
        bump_pic[p] = (float)8;
      if(c >= 11)
      {
        if(!(text[p] == 0))
        {
          signed long int num = (signed long int)((signed int)text[p] + 1);
          float light = (float)c;
          const float z = text_depth[p] + bump_pic[p];
          float tx;
          float ty;
          signed long int num2;
          signed long int num3;
          num = num & (signed long int)63;
          light = light / (float)255;
          num2 = num / (signed long int)10;
          num3 = num - num2 * (signed long int)10;
          ty = (float)num2 / (float)7;
          tx = (float)num3 / (float)10;
          tmp_post$1 = cp;
          cp = cp + 1;
          colors[(signed long int)tmp_post$1] = (unsigned char)(0.9 * (double)255);
          tmp_post$2 = cp;
          cp = cp + 1;
          colors[(signed long int)tmp_post$2] = (unsigned char)(0.4 * (double)255);
          tmp_post$3 = cp;
          cp = cp + 1;
          colors[(signed long int)tmp_post$3] = (unsigned char)(0.3 * (double)255);
          tmp_post$4 = cp;
          cp = cp + 1;
          colors[(signed long int)tmp_post$4] = (unsigned char)(light * (float)255);
          tmp_post$5 = tp;
          tp = tp + 1;
          texcoords[(signed long int)tmp_post$5] = tx;
          tmp_post$6 = tp;
          tp = tp + 1;
          texcoords[(signed long int)tmp_post$6] = ty;
          tmp_post$7 = vp;
          vp = vp + 1;
          pts[(signed long int)tmp_post$7] = (float)x;
          tmp_post$8 = vp;
          vp = vp + 1;
          pts[(signed long int)tmp_post$8] = (float)y;
          tmp_post$9 = vp;
          vp = vp + 1;
          pts[(signed long int)tmp_post$9] = z;
          tmp_post$10 = cp;
          cp = cp + 1;
          colors[(signed long int)tmp_post$10] = (unsigned char)(0.9 * (double)255);
          tmp_post$11 = cp;
          cp = cp + 1;
          colors[(signed long int)tmp_post$11] = (unsigned char)(0.4 * (double)255);
          tmp_post$12 = cp;
          cp = cp + 1;
          colors[(signed long int)tmp_post$12] = (unsigned char)(0.3 * (double)255);
          tmp_post$13 = cp;
          cp = cp + 1;
          colors[(signed long int)tmp_post$13] = (unsigned char)(light * (float)255);
          tmp_post$14 = tp;
          tp = tp + 1;
          texcoords[(signed long int)tmp_post$14] = (float)((double)tx + 0.1);
          tmp_post$15 = tp;
          tp = tp + 1;
          texcoords[(signed long int)tmp_post$15] = ty;
          tmp_post$16 = vp;
          vp = vp + 1;
          pts[(signed long int)tmp_post$16] = (float)(x + 1);
          tmp_post$17 = vp;
          vp = vp + 1;
          pts[(signed long int)tmp_post$17] = (float)y;
          tmp_post$18 = vp;
          vp = vp + 1;
          pts[(signed long int)tmp_post$18] = z;
          tmp_post$19 = cp;
          cp = cp + 1;
          colors[(signed long int)tmp_post$19] = (unsigned char)(0.9 * (double)255);
          tmp_post$20 = cp;
          cp = cp + 1;
          colors[(signed long int)tmp_post$20] = (unsigned char)(0.4 * (double)255);
          tmp_post$21 = cp;
          cp = cp + 1;
          colors[(signed long int)tmp_post$21] = (unsigned char)(0.3 * (double)255);
          tmp_post$22 = cp;
          cp = cp + 1;
          colors[(signed long int)tmp_post$22] = (unsigned char)(light * (float)255);
          tmp_post$23 = tp;
          tp = tp + 1;
          texcoords[(signed long int)tmp_post$23] = (float)((double)tx + 0.1);
          tmp_post$24 = tp;
          tp = tp + 1;
          texcoords[(signed long int)tmp_post$24] = (float)((double)ty + 0.166);
          tmp_post$25 = vp;
          vp = vp + 1;
          pts[(signed long int)tmp_post$25] = (float)(x + 1);
          tmp_post$26 = vp;
          vp = vp + 1;
          pts[(signed long int)tmp_post$26] = (float)(y - 1);
          tmp_post$27 = vp;
          vp = vp + 1;
          pts[(signed long int)tmp_post$27] = z;
          tmp_post$28 = cp;
          cp = cp + 1;
          colors[(signed long int)tmp_post$28] = (unsigned char)(0.9 * (double)255);
          tmp_post$29 = cp;
          cp = cp + 1;
          colors[(signed long int)tmp_post$29] = (unsigned char)(0.4 * (double)255);
          tmp_post$30 = cp;
          cp = cp + 1;
          colors[(signed long int)tmp_post$30] = (unsigned char)(0.3 * (double)255);
          tmp_post$31 = cp;
          cp = cp + 1;
          colors[(signed long int)tmp_post$31] = (unsigned char)(light * (float)255);
          tmp_post$32 = tp;
          tp = tp + 1;
          texcoords[(signed long int)tmp_post$32] = tx;
          tmp_post$33 = tp;
          tp = tp + 1;
          texcoords[(signed long int)tmp_post$33] = (float)((double)ty + 0.166);
          tmp_post$34 = vp;
          vp = vp + 1;
          pts[(signed long int)tmp_post$34] = (float)x;
          tmp_post$35 = vp;
          vp = vp + 1;
          pts[(signed long int)tmp_post$35] = (float)(y - 1);
          tmp_post$36 = vp;
          vp = vp + 1;
          pts[(signed long int)tmp_post$36] = z;
        }

      }

      if(!(exit_mode == 0))
        text_depth[p] = text_depth[p] + ((float)text[p] - (float)128) / (float)2000;

      else
        if((double)text_depth[p] < 0.1)
          text_depth[p] = (float)0;

        else
          text_depth[p] = text_depth[p] / (float)1.1;
      p = p + 1l;
    }
  }
  glNormal3f(0.0f, 0.0f, 1.0f);
  glDrawArrays((unsigned int)0x0007, 0, tp >> 1);
}

// hack_cleanup
// file driver.h line 55
void hack_cleanup(struct xstuff *XStuff)
{
  if(!(imageLoadingThread == ((unsigned long int *)NULL)))
  {
    pthread_mutex_lock(next_pic_mutex);
    exiting = 1;
    pthread_cond_signal(next_pic_cond);
    pthread_mutex_unlock(next_pic_mutex);
    pthread_join(*imageLoadingThread, (void **)(void *)0);
  }

  free((void *)pts);
  free((void *)texcoords);
  free((void *)colors);
}

// hack_draw
// file driver.h line 54
void hack_draw(struct xstuff *XStuff, double currentTime, float frameTime)
{
  glBindTexture((unsigned int)0x0DE1, (unsigned int)1);
  glEnable((unsigned int)0x0BE2);
  glEnable((unsigned int)0x0DE1);
  glDisable((unsigned int)0x0B50);
  glBlendFunc((unsigned int)0x0302, (unsigned int)1);
  glDisable((unsigned int)0x0B71);
  glTexParameterf((unsigned int)0x0DE1, (unsigned int)0x2801, (float)0x2702);
  glTexParameterf((unsigned int)0x0DE1, (unsigned int)0x2800, (float)0x2600);
  glMatrixMode((unsigned int)0x1700);
  glLoadIdentity();
  glTranslatef(0.0f, 0.0f, -128.0f);
  glClear((unsigned int)(0x00004000 | 0x00000100));
  if(!(exit_mode == 0))
    exit_angle = exit_angle + (float)0.08;

  else
    exit_angle = exit_angle / (float)1.1;
  if(texture_add > 0.000000f)
    texture_add = texture_add / (float)1.05;

  glRotatef(exit_angle, r1, r2, r3);
  draw_text();
  glBindTexture((unsigned int)0x0DE1, (unsigned int)2);
  glBegin((unsigned int)0x0007);
  draw_illuminatedtext();
  glEnd();
  glBindTexture((unsigned int)0x0DE1, (unsigned int)3);
  glBegin((unsigned int)0x0007);
  draw_flares();
  glEnd();
  make_change(currentTime);
  glLoadIdentity();
  glMatrixMode((unsigned int)0x1701);
}

// hack_handle_opts
// file driver.h line 51
void hack_handle_opts(signed int argc, char **argv)
{
  signed int return_value_strtol_minmaxdef$4;
  while((_Bool)1)
  {
    signed int c;
    static struct option long_options[12l] = { { .name="help", .has_arg=0, .flag=((signed int *)NULL), .val=104 },
    { .name="root", .has_arg=0, .flag=((signed int *)NULL), .val=114 },
    { .name="maxfps", .has_arg=1, .flag=((signed int *)NULL), .val=120 },
    { .name="vsync", .has_arg=1, .flag=((signed int *)NULL), .val=121 },
    { .name="dpms", .has_arg=1, .flag=((signed int *)NULL), .val=77 },
    { .name="images", .has_arg=1, .flag=((signed int *)NULL), .val=105 },
    { .name="scene_interval", .has_arg=1, .flag=((signed int *)NULL), .val=115 },
    { .name="matrix_interval", .has_arg=1, .flag=((signed int *)NULL), .val=109 },
    { .name="matrix_width", .has_arg=1, .flag=((signed int *)NULL), .val=88 },
    { .name="matrix_height", .has_arg=1, .flag=((signed int *)NULL), .val=89 },
    { .name="contrast", .has_arg=1, .flag=((signed int *)NULL), .val=99 },
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
    c=getopt_long(argc, argv, "rx:y:M:hs:m:X:Y:c:i:", long_options, (signed int *)(void *)0);
    if(c == -1)
      break;

    switch(c)
    {
      case 114:

      case 120:

      case 121:

      case 77:
      {
        handle_global_opts(c);
        break;
      }
      case 104:
      {
        printf("%s:\n\t--root/-r\n\t--maxfps/-x <arg>\n\t--vsync/-y <arg>\n\t--dpms/-M <arg>\n\t--images/-i <arg>\n\t--scene_interval/-s <arg>\n\t--matrix_interval/-m <arg>\n\t--matrix_width/-X <arg>\n\t--matrix_height/-Y <arg>\n\t--contrast/-c <arg>\n", argv[(signed long int)0]);
        exit(1);
      }
      case 105:
      {
        struct stat fileStat;
        signed int return_value_stat$3;
        return_value_stat$3=stat(optarg, (struct stat *)&fileStat);
        if(return_value_stat$3 == 0)
        {
          if((61440u & fileStat.st_mode) == 16384u)
          {
            imageDir=opendir(optarg);
            if(!(imageDir == ((struct __dirstream *)NULL)))
            {
              unsigned long int return_value_strlen$1;
              return_value_strlen$1=strlen(optarg);
              void *return_value_malloc$2;
              return_value_malloc$2=malloc(return_value_strlen$1 + (unsigned long int)1);
              dirName = (char *)return_value_malloc$2;
              strcpy(dirName, optarg);
            }

            else
              fprintf(stderr, "--images: Could not open %s\n", optarg);
          }

          else
            fprintf(stderr, "--images: %s is not a directory\n", optarg);
        }

        else
          fprintf(stderr, "--images: Could not stat %s\n", optarg);
        break;
      }
      case 115:
      {
        cycleScene=strtol_minmaxdef(optarg, 10, 0, 120, 1, 5, "--scene_interval: ");
        break;
      }
      case 109:
      {
        cycleMatrix=strtol_minmaxdef(optarg, 10, 3, 120, 1, 5, "--matrix_interval: ");
        break;
      }
      case 88:
      {
        text_x=strtol_minmaxdef(optarg, 10, 40, 320, 1, 90, "--matrix_width: ");
        break;
      }
      case 89:
      {
        text_y=strtol_minmaxdef(optarg, 10, 30, 240, 1, 70, "--matrix_height: ");
        break;
      }
      case 99:
      {
        return_value_strtol_minmaxdef$4=strtol_minmaxdef(optarg, 10, 0, 100, 1, 75, "--contrast: ");
        contrast = (float)return_value_strtol_minmaxdef$4 / 100.0f;
      }
    }
  }
  if(IEEE_FLOAT_EQUAL(contrast, -1.000000f))
    contrast = (float)1;

  if(cycleScene >= 1)
  {
    if(!(text_x == 90) || !(text_y == 70))
    {
      printf("%s: Not built with ImageMagick, can not scale images. Resetting matrix resolution to 90x70.\n", argv[(signed long int)0]);
      text_x = 90;
      text_y = 70;
    }

  }

}

// hack_init
// file driver.h line 52
void hack_init(struct xstuff *XStuff)
{
  load_texture();
  make_text();
  MagickWandGenesis();
  ourBuildTextures();
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(text_y * text_x * 3 * 4) * sizeof(float) /*4ul*/ );
  pts = (float *)return_value_malloc$1;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)(text_y * text_x * 2 * 4) * sizeof(float) /*4ul*/ );
  texcoords = (float *)return_value_malloc$2;
  void *return_value_malloc$3;
  return_value_malloc$3=malloc((unsigned long int)(text_y * text_x * 4 * 4) * sizeof(unsigned char) /*1ul*/ );
  colors = (unsigned char *)return_value_malloc$3;
  glVertexPointer(3, (unsigned int)0x1406, 0, (const void *)pts);
  glEnableClientState((unsigned int)0x8074);
  glColorPointer(4, (unsigned int)0x1401, 0, (const void *)colors);
  glEnableClientState((unsigned int)0x8076);
  glTexCoordPointer(2, (unsigned int)0x1406, 0, (const void *)texcoords);
  glEnableClientState((unsigned int)0x8078);
  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
  glClearDepth(1.0);
  glDepthFunc((unsigned int)0x0201);
  glShadeModel((unsigned int)0x1D01);
  glLightfv((unsigned int)0x4001, (unsigned int)0x1203, Light_Position);
  glLightfv((unsigned int)0x4001, (unsigned int)0x1200, Light_Ambient);
  glLightfv((unsigned int)0x4001, (unsigned int)0x1201, Light_Diffuse);
  glEnable((unsigned int)0x4001);
  glColorMaterial((unsigned int)0x0408, (unsigned int)0x1602);
  glEnable((unsigned int)0x0B57);
  hack_reshape(XStuff);
}

// hack_reshape
// file driver.h line 53
void hack_reshape(struct xstuff *XStuff)
{
  glViewport(0, 0, (signed int)XStuff->windowWidth, (signed int)XStuff->windowHeight);
  glMatrixMode((unsigned int)0x1701);
  glLoadIdentity();
  glFrustum((double)(-text_x / 2), (double)(text_x / 2), (double)(-text_y / 2), (double)(text_y / 2), (double)(-(-128.0f) - (float)8), (double)-(-128.0f));
  glMatrixMode((unsigned int)0x1700);
}

// handle_global_opts
// file driver.c line 340
void handle_global_opts(signed int c)
{
  switch(c)
  {
    case 114:
    {
      rootWindow = 1;
      break;
    }
    case 120:
    {
      c=strtol_minmaxdef(optarg, 10, 0, 10000, 1, 100, "--maxfps: ");
      frameTime = c > 0 ? 1000000 / c : 0;
      break;
    }
    case 121:
    {
      vsync=strtol_minmaxdef(optarg, 10, 0, 100, 1, 2, "--vsync: ");
      break;
    }
    case 77:
      idleOnDPMS=strtol_minmaxdef(optarg, 10, 0, 1, 0, 1, "--dpms: ");
  }
}

// imageLoadingThreadMain
// file matrixview.c line 173
void * imageLoadingThreadMain(void *arg)
{
  do
  {
    loadNextImageFromDisk();
    pthread_cond_wait(next_pic_cond, next_pic_mutex);
  }
  while(exiting == 0);
  pthread_exit((void *)0);
  return (void *)0;
}

// loadNextImage
// file matrixview.c line 185
void loadNextImage()
{
  void *return_value_malloc$4;
  void *return_value_malloc$5;
  void *return_value_malloc$8;
  if(!(dirName == ((char *)NULL)))
  {
    if(imageLoadingThread == ((unsigned long int *)NULL))
    {
      void *return_value_malloc$1;
      return_value_malloc$1=malloc(sizeof(union anonymous$79) /*40ul*/ );
      next_pic_mutex = (union anonymous$79 *)return_value_malloc$1;
      pthread_mutex_init(next_pic_mutex, (const union anonymous$81 *)(void *)0);
      pthread_mutex_lock(next_pic_mutex);
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(union anonymous$52) /*48ul*/ );
      next_pic_cond = (union anonymous$52 *)return_value_malloc$2;
      pthread_cond_init(next_pic_cond, (const union anonymous$81 *)(void *)0);
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(unsigned long int) /*8ul*/ );
      imageLoadingThread = (unsigned long int *)return_value_malloc$3;
      pthread_create(imageLoadingThread, (const union pthread_attr_t *)(void *)0, imageLoadingThreadMain, (void *)0);
    }

    else
    {
      pthread_mutex_lock(next_pic_mutex);
      if(!(pic == ((unsigned char *)NULL)))
      {
        unsigned char *tmp = next_pic;
        next_pic = pic;
        pic = tmp;
      }

      else
      {
        pic = next_pic;
        next_pic = (unsigned char *)(void *)0;
      }
      pthread_mutex_unlock(next_pic_mutex);
      pthread_cond_signal(next_pic_cond);
    }
  }

  else
  {
    struct _ExceptionInfo exception;
    struct _Image *image = (struct _Image *)(void *)0;
    struct _Image *scaled_image;
    struct _ImageInfo *image_info;
    GetExceptionInfo(&exception);
    if(pics == ((unsigned char *)NULL))
    {
      return_value_malloc$4=malloc((unsigned long int)cpics_size);
      pics = (unsigned char *)return_value_malloc$4;
    }

    BZ2_bzBuffToBuffDecompress((char *)pics, &cpics_size, (char *)cpics, cpics_compressedsize, 0, 0);
    if(!(text_x == 90) || !(text_y == 70))
    {
      if(pic == ((unsigned char *)NULL))
      {
        return_value_malloc$5=malloc((unsigned long int)(text_x * text_y));
        pic = (unsigned char *)return_value_malloc$5;
      }

      image_info=CloneImageInfo((struct _ImageInfo *)(void *)0);
      void *return_value_AcquireMagickMemory$6;
      return_value_AcquireMagickMemory$6=AcquireMagickMemory(sizeof(char [6l]) /*6ul*/ );
      image_info->size = (char *)return_value_AcquireMagickMemory$6;
      strcpy(image_info->size, "90x70");
      image=AcquireImage(image_info);
      signed long int return_value_random$7;
      return_value_random$7=random();
      ImportImagePixels(image, (const signed long int)0, (const signed long int)0, (const unsigned long int)90, (const unsigned long int)70, "I", (const enum anonymous$29)CharPixel, (const void *)(unsigned char *)(pics + (return_value_random$7 & (signed long int)15) * (signed long int)(90 * 70)));
      scaled_image=ScaleImage(image, (const unsigned long int)text_x, (const unsigned long int)text_y, &exception);
      ExportImagePixels(scaled_image, (const signed long int)0, (const signed long int)0, (const unsigned long int)text_x, (const unsigned long int)text_y, "I", (const enum anonymous$29)CharPixel, (void *)pic, &exception);
      DestroyImage(image);
      DestroyImage(scaled_image);
    }

    else
    {
      if(pics == ((unsigned char *)NULL))
      {
        return_value_malloc$8=malloc((unsigned long int)cpics_size);
        pics = (unsigned char *)return_value_malloc$8;
      }

      BZ2_bzBuffToBuffDecompress((char *)pics, &cpics_size, (char *)cpics, cpics_compressedsize, 0, 0);
      signed long int return_value_random$9;
      return_value_random$9=random();
      pic = (unsigned char *)(pics + (return_value_random$9 & (signed long int)15) * (signed long int)(text_x * text_y));
    }
  }
}

// loadNextImageFromDisk
// file matrixview.c line 100
void loadNextImageFromDisk()
{
  struct _MagickWand *magick_wand;
  magick_wand=NewMagickWand();
  struct _ExceptionInfo exception;
  signed int dirLoop = 0;
  GetExceptionInfo(&exception);
  signed int imageLoaded = 0;
  do
  {
    struct dirent *file;
    if(imageDir == ((struct __dirstream *)NULL))
    {
      if(!(dirLoop == 0))
      {
        dirName = (char *)(void *)0;
        goto __CPROVER_DUMP_L12;
      }

      imageDir=opendir(dirName);
      dirLoop = 1;
    }

    file=readdir(imageDir);
    if(!(file == ((struct dirent *)NULL)))
    {
      struct stat fileStat;
      char *full_path_and_name;
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(dirName);
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(file->d_name);
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(return_value_strlen$1 + (unsigned long int)1 + return_value_strlen$2 + (unsigned long int)1);
      full_path_and_name = (char *)return_value_malloc$3;
      if(!(full_path_and_name == ((char *)NULL)))
      {
        sprintf(full_path_and_name, "%s/%s", dirName, (const void *)file->d_name);
        signed int return_value_stat$6;
        return_value_stat$6=stat(full_path_and_name, (struct stat *)&fileStat);
        if(return_value_stat$6 == 0)
        {
          if((61440u & fileStat.st_mode) == 32768u)
          {
            enum anonymous$59 return_value_MagickReadImage$5;
            return_value_MagickReadImage$5=MagickReadImage(magick_wand, full_path_and_name);
            if((signed int)return_value_MagickReadImage$5 == MagickFalse)
            {
              char *description;
              enum anonymous$31 severity;
              description=MagickGetException(magick_wand, &severity);
              fprintf(stderr, "Error loading %s: %s\n", full_path_and_name, description);
              void *return_value_MagickRelinquishMemory$4;
              return_value_MagickRelinquishMemory$4=MagickRelinquishMemory((void *)description);
              description = (char *)return_value_MagickRelinquishMemory$4;
            }

            else
              imageLoaded = 1;
          }

        }

        free((void *)full_path_and_name);
      }

      else
        fprintf(stderr, "Out of memory\n");
    }

    else
    {
      closedir(imageDir);
      imageDir = (struct __dirstream *)(void *)0;
    }
  }
  while(imageLoaded == 0);
  MagickScaleImage(magick_wand, (const unsigned long int)text_x, (const unsigned long int)text_y);
  MagickNormalizeImage(magick_wand);
  MagickContrastImage(magick_wand, (const enum anonymous$59)MagickTrue);
  MagickNegateImage(magick_wand, (const enum anonymous$59)MagickFalse);
  void *return_value_malloc$7;
  if(next_pic == ((unsigned char *)NULL))
  {
    return_value_malloc$7=malloc((unsigned long int)(text_x * text_y));
    next_pic = (unsigned char *)return_value_malloc$7;
  }

  struct _Image *return_value_GetImageFromMagickWand$8;
  return_value_GetImageFromMagickWand$8=GetImageFromMagickWand(magick_wand);
  ExportImagePixels(return_value_GetImageFromMagickWand$8, (const signed long int)0, (const signed long int)0, (const unsigned long int)text_x, (const unsigned long int)text_y, "I", (const enum anonymous$29)CharPixel, (void *)next_pic, &exception);
  magick_wand=DestroyMagickWand(magick_wand);

__CPROVER_DUMP_L12:
  ;
}

// load_texture
// file matrixview.c line 495
void load_texture()
{
  signed long int a;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)cfont_size);
  font = (unsigned char *)return_value_malloc$1;
  BZ2_bzBuffToBuffDecompress((char *)font, &cfont_size, (char *)cfont, cfont_compressedsize, 0, 0);
  a = (signed long int)0;
  for( ; !(a >= 131072l); a = a + 1l)
    if(!((a >> 9 & 2l) == 0l))
      font[a] = font[a];

    else
      font[a] = (unsigned char)((signed int)font[a] >> 1);
}

// main
// file driver.c line 402
signed int main(signed int argc, char **argv)
{
  struct sigaction sa;
  char *display_name = (char *)(void *)0;
  signed int i;
  signed int j;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct xstuff) /*80ul*/ );
  XStuff = (struct xstuff *)return_value_malloc$1;
  XStuff->commandLineName = argv[(signed long int)0];
  signed long int return_value_time$2;
  return_value_time$2=time((signed long int *)(void *)0);
  srandom((unsigned int)return_value_time$2);
  XStuff->existingWindow = (unsigned long int)0;
  i = 0;
  signed int tmp_statement_expression$7;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  for( ; !(i >= argc); i = i + 1)
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$8;
    return_value___builtin_strcmp$8=__builtin_strcmp(argv[(signed long int)i], "-window-id");
    tmp_statement_expression$7 = return_value___builtin_strcmp$8;
    if(tmp_statement_expression$7 == 0)
    {
      if((signed int)*argv[(signed long int)(1 + i)] == 48)
      {
        if((signed int)argv[(signed long int)(1 + i)][1l] == 120)
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = (signed int)argv[(signed long int)(i + 1)][(signed long int)1] == 88 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      if(tmp_if_expr$6)
      {
        signed long int return_value_strtol$3;
        return_value_strtol$3=strtol((char *)(argv[(signed long int)(i + 1)] + (signed long int)2), (char **)(void *)0, 16);
        XStuff->existingWindow = (unsigned long int)return_value_strtol$3;
      }

      else
      {
        signed long int return_value_strtol$4;
        return_value_strtol$4=strtol((char *)argv[(signed long int)(i + 1)], (char **)(void *)0, 10);
        XStuff->existingWindow = (unsigned long int)return_value_strtol$4;
      }
      j = i + 2;
      for( ; !(j >= argc); j = j + 1)
        argv[(signed long int)(j - 2)] = argv[(signed long int)j];
      argc = argc - 2;
      break;
    }

  }
  hack_handle_opts(argc, argv);
  XStuff->display = (struct _XDisplay *)(void *)0;
  XStuff->window = (unsigned long int)0;
  memset((void *)&sa, 0, sizeof(struct sigaction) /*152ul*/ );
  sa.__sigaction_handler.sa_handler = signalHandler;
  sigaction(2, &sa, ((struct sigaction *)NULL));
  sigaction(13, &sa, ((struct sigaction *)NULL));
  sigaction(3, &sa, ((struct sigaction *)NULL));
  sigaction(15, &sa, ((struct sigaction *)NULL));
  XStuff->display=XOpenDisplay(display_name);
  if(XStuff->display == ((struct _XDisplay *)NULL))
  {
    char *return_value_XDisplayName$9;
    return_value_XDisplayName$9=XDisplayName(display_name);
    fprintf(stderr, "%s: can't connect to X server %s\n", XStuff->commandLineName, return_value_XDisplayName$9);
    exit(1);
  }

  createWindow(argc, argv);
  unsigned int return_value_glewInit$10;
  return_value_glewInit$10=glewInit();
  if(return_value_glewInit$10 == 0u)
    glewInitialized = 1;

  hack_init(XStuff);
  mainLoop();
  _Bool tmp_if_expr$11;
  if(!(XStuff->display == ((struct _XDisplay *)NULL)))
  {
    if(!(XStuff->window == 0ul))
    {
      hack_cleanup(XStuff);
      if(!(rootWindow == 0))
        tmp_if_expr$11 = (_Bool)1;

      else
        tmp_if_expr$11 = XStuff->existingWindow != 0ul ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$11)
        XDestroyWindow(XStuff->display, XStuff->window);

    }

    XCloseDisplay(XStuff->display);
  }

  return 0;
}

// mainLoop
// file driver.c line 176
void mainLoop(void)
{
  signed int bFPS = 0;
  union _XEvent event;
  unsigned long int XA_WM_PROTOCOLS;
  XA_WM_PROTOCOLS=XInternAtom(XStuff->display, "WM_PROTOCOLS", 0);
  unsigned long int XA_WM_DELETE_WINDOW;
  XA_WM_DELETE_WINDOW=XInternAtom(XStuff->display, "WM_DELETE_WINDOW", 0);
  struct timeval cycleStart;
  struct timeval now;
  struct timeval fps_time;
  signed int fps = 0;
  signed int drawEnabled = 1;
  if(rootWindow == 0)
    XSetWMProtocols(XStuff->display, XStuff->window, &XA_WM_DELETE_WINDOW, 1);

  clearBuffers();
  if(!(glewInitialized == 0))
  {
    if(vsync >= 1)
    {
      if(!(__GLXEW_SGI_swap_control == 0))
        __glewXSwapIntervalSGI(vsync);

    }

  }

  signed int dpmsAvailable = 0;
  signed int event_number;
  signed int error_number;
  signed int return_value_DPMSQueryExtension$2;
  return_value_DPMSQueryExtension$2=DPMSQueryExtension(XStuff->display, &event_number, &error_number);
  if(!(return_value_DPMSQueryExtension$2 == 0))
  {
    signed int return_value_DPMSCapable$1;
    return_value_DPMSCapable$1=DPMSCapable(XStuff->display);
    if(!(return_value_DPMSCapable$1 == 0))
      dpmsAvailable = 1;

  }

  gettimeofday(&cycleStart, (struct timezone *)(void *)0);
  fps_time = cycleStart;
  now = fps_time;
  signed int frameTimeSoFar = 0;
  signed int sinceLastDPMSPoll = 0;
  signed int return_value_XPending$5;
  _Bool tmp_if_expr$6;
  while(signalled == 0)
  {
    sinceLastDPMSPoll = sinceLastDPMSPoll + frameTimeSoFar;
    if(sinceLastDPMSPoll >= 1000001 && !(idleOnDPMS == 0) && !(dpmsAvailable == 0))
    {
      unsigned short int state;
      unsigned char onoff;
      sinceLastDPMSPoll = 0;
      drawEnabled = 1;
      signed int return_value_DPMSInfo$3;
      return_value_DPMSInfo$3=DPMSInfo(XStuff->display, &state, &onoff);
      if(!(return_value_DPMSInfo$3 == 0))
      {
        if(!(onoff == 0) && !((signed int)state == 0))
          drawEnabled = 0;

      }

      if(drawEnabled == 0)
        sleep((unsigned int)1);

    }

    if(!(drawEnabled == 0))
    {
      hack_draw(XStuff, (double)now.tv_sec + (double)((float)now.tv_usec / 1000000.0f), (float)frameTimeSoFar / 1000000.0f);
      glXSwapBuffers(XStuff->display, XStuff->window);
    }

    if(!(bFPS == 0))
    {
      if(!(fps == -1))
        fps = fps + 1;

      if(!(fps_time.tv_sec >= now.tv_sec))
      {
        if(!(fps == -1))
        {
          signed int return_value_deltaus$4;
          return_value_deltaus$4=deltaus(now, fps_time);
          printf("%.4f fps\n", (double)fps / ((double)return_value_deltaus$4 / 1000000.0));
        }

        fps = 0;
        fps_time.tv_sec = now.tv_sec;
        fps_time.tv_usec = now.tv_usec;
      }

    }

    do
    {
      return_value_XPending$5=XPending(XStuff->display);
      if(return_value_XPending$5 == 0)
        break;

      unsigned long int keysym;
      char c = (char)0;
      XNextEvent(XStuff->display, &event);
      switch(event.type)
      {
        case 22:
        {
          if(!((signed int)XStuff->windowWidth == event.xconfigure.width))
            tmp_if_expr$6 = (_Bool)1;

          else
            tmp_if_expr$6 = (signed int)XStuff->windowHeight != event.xconfigure.height ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$6)
          {
            XStuff->windowWidth = (unsigned int)event.xconfigure.width;
            XStuff->windowHeight = (unsigned int)event.xconfigure.height;
            clearBuffers();
            hack_reshape(XStuff);
          }

          goto __CPROVER_DUMP_L23;
        }
        case 2:
        {
          XLookupString(&event.xkey, &c, 1, &keysym, ((struct _XComposeStatus *)NULL));
          if((signed int)c == 102)
          {
            bFPS = (signed int)!(bFPS != 0);
            if(!(bFPS == 0))
            {
              fps = -1;
              gettimeofday(&fps_time, (struct timezone *)(void *)0);
            }

          }

          if((signed int)c == 3 || (signed int)c == 27 || (signed int)c == 81 || (signed int)c == 113)
            goto __CPROVER_DUMP_L32;

          goto __CPROVER_DUMP_L23;
        }
        case 33:
        {
          if(event.xclient.message_type == XA_WM_PROTOCOLS)
          {
            if(event.xclient.data.l[0l] == (signed long int)(signed int)XA_WM_DELETE_WINDOW)
              goto __CPROVER_DUMP_L32;

          }

          goto __CPROVER_DUMP_L23;
        }
        case 17:
          goto __CPROVER_DUMP_L32;
        default:

          __CPROVER_DUMP_L23:
            ;
      }
    }
    while((_Bool)1);
    gettimeofday(&now, (struct timezone *)(void *)0);
    frameTimeSoFar=deltaus(now, cycleStart);
    if(!(frameTime == 0))
    {
      while(!(frameTimeSoFar >= frameTime))
      {
        struct timespec hundreth;
        hundreth.tv_sec = (signed long int)0;
        hundreth.tv_nsec = (signed long int)((frameTime - frameTimeSoFar) * 1000);
        nanosleep(&hundreth, (struct timespec *)(void *)0);
        gettimeofday(&now, (struct timezone *)(void *)0);
        frameTimeSoFar=deltaus(now, cycleStart);
      }
      signed int delta = 0;
      do
      {
        cycleStart.tv_usec = cycleStart.tv_usec + (signed long int)frameTime;
        if(cycleStart.tv_usec >= 1000001l)
        {
          cycleStart.tv_sec = cycleStart.tv_sec + 1l;
          cycleStart.tv_usec = cycleStart.tv_usec - (signed long int)1000000;
        }

        delta=deltaus(now, cycleStart);
      }
      while(!(frameTime >= delta));
    }

    else
      cycleStart = now;
  }

__CPROVER_DUMP_L32:
  ;
}

// make_change
// file matrixview.c line 466
void make_change(double dCurrentTime)
{
  unsigned int r;
  signed long int return_value_random$1;
  return_value_random$1=random();
  r = (unsigned int)(return_value_random$1 & (signed long int)0xFFFF);
  r = r >> 3;
  if(!(r >= (unsigned int)text_x * (unsigned int)text_y))
    text[(signed long int)r] = text[(signed long int)r] + (unsigned char)133;

  signed long int return_value_random$2;
  return_value_random$2=random();
  r = (unsigned int)(return_value_random$2 & (signed long int)0xFFFF);
  r = r >> 7;
  if(!(r >= (unsigned int)text_x))
  {
    if(!((signed int)text_light[(signed long int)r] == 0))
      text_light[(signed long int)r] = (unsigned char)255;

  }

  scroll(dCurrentTime);
}

// make_text
// file matrixview.c line 509
void make_text()
{
  signed long int a;
  unsigned int r;
  a = (signed long int)0;
  for( ; !(a >= (signed long int)(text_x * text_y)); a = a + 1l)
  {
    signed long int return_value_random$1;
    return_value_random$1=random();
    r = (unsigned int)(return_value_random$1 & (signed long int)0xFFFF);
    text[a] = (unsigned char)r;
  }
  a = (signed long int)0;
  signed long int return_value_random$2;
  for( ; !(a >= (signed long int)text_x); a = a + 1l)
  {
    return_value_random$2=random();
    speed[a] = (unsigned char)(return_value_random$2 & (signed long int)1);
  }
}

// ourBuildTextures
// file matrixview.c line 523
void ourBuildTextures()
{
  unsigned int gluerr;
  glBindTexture((unsigned int)0x0DE1, (unsigned int)1);
  signed int return_value_gluBuild2DMipmaps$2;
  return_value_gluBuild2DMipmaps$2=gluBuild2DMipmaps((unsigned int)0x0DE1, 0x8058, 512, 256, (unsigned int)0x1904, (unsigned int)0x1401, (void *)font);
  gluerr = (unsigned int)return_value_gluBuild2DMipmaps$2;
  if(!(gluerr == 0u))
  {
    const unsigned char *return_value_gluErrorString$1;
    return_value_gluErrorString$1=gluErrorString(gluerr);
    fprintf(stderr, "GLULib%s\n", return_value_gluErrorString$1);
    exit(-1);
  }

  glBindTexture((unsigned int)0x0DE1, (unsigned int)2);
  signed int return_value_gluBuild2DMipmaps$4;
  return_value_gluBuild2DMipmaps$4=gluBuild2DMipmaps((unsigned int)0x0DE1, 0x8058, 512, 256, (unsigned int)0x1909, (unsigned int)0x1401, (void *)font);
  gluerr = (unsigned int)return_value_gluBuild2DMipmaps$4;
  if(!(gluerr == 0u))
  {
    const unsigned char *return_value_gluErrorString$3;
    return_value_gluErrorString$3=gluErrorString(gluerr);
    fprintf(stderr, "GLULib%s\n", return_value_gluErrorString$3);
    exit(-1);
  }

  free((void *)font);
  glBindTexture((unsigned int)0x0DE1, (unsigned int)3);
  signed int return_value_gluBuild2DMipmaps$6;
  return_value_gluBuild2DMipmaps$6=gluBuild2DMipmaps((unsigned int)0x0DE1, 0x8058, 4, 4, (unsigned int)0x1909, (unsigned int)0x1401, (void *)flare);
  gluerr = (unsigned int)return_value_gluBuild2DMipmaps$6;
  if(!(gluerr == 0u))
  {
    const unsigned char *return_value_gluErrorString$5;
    return_value_gluErrorString$5=gluErrorString(gluerr);
    fprintf(stderr, "GLULib%s\n", return_value_gluErrorString$5);
    exit(-1);
  }

  glTexParameterf((unsigned int)0x0DE1, (unsigned int)0x2802, (float)0x2901);
  glTexParameterf((unsigned int)0x0DE1, (unsigned int)0x2803, (float)0x2901);
  glTexEnvf((unsigned int)0x2300, (unsigned int)0x2200, (float)0x2101);
}

// scroll
// file matrixview.c line 396
void scroll(double dCurrentTime)
{
  unsigned int a;
  unsigned int s;
  unsigned int polovina;
  if(cycleScene >= 1)
  {
    static double dLastCycle = (double)-1;
    if(pic_mode == 1)
    {
      if(dCurrentTime + -dLastCycle > (double)cycleScene)
      {
        pic_mode = 2;
        signed long int return_value_random$1;
        return_value_random$1=random();
        if((63l & return_value_random$1) == 63l)
          exit_mode = 1;

      }

    }

    if(dCurrentTime + -dLastCycle > (double)(cycleMatrix + cycleScene))
      dLastCycle = dCurrentTime;

    if(IEEE_FLOAT_EQUAL(dCurrentTime, dLastCycle))
    {
      loadNextImage();
      if(!(pic == ((unsigned char *)NULL)))
        pic_mode = 1;

      else
        dLastCycle = dLastCycle - (double)cycleScene;
      signed long int return_value_random$2;
      return_value_random$2=random();
      if((3l & return_value_random$2) == 3l)
        exit_mode = 0;

    }

  }

  static double dLastMove = (double)-1;
  if(dCurrentTime + -dLastMove > 1.0 / ((double)text_y / 1.5))
  {
    dLastMove = dCurrentTime;
    polovina = (unsigned int)((text_x * text_y) / 2);
    s = (unsigned int)0;
    a = (unsigned int)((text_x * text_y + text_x) - 1);
    for( ; !((unsigned int)text_x >= a); a = a - 1u)
    {
      if(!(speed[(signed long int)s] == 0))
        text_light[(signed long int)a] = text_light[(signed long int)(a - (unsigned int)text_x)];

      s = s + 1u;
      if(s >= (unsigned int)text_x)
        s = (unsigned int)0;

    }
    memmove((void *)(&text_light[(signed long int)0] + (signed long int)text_x), (void *)&text_light, (unsigned long int)(text_x * text_y - 1));
    memset((void *)&text_light, 253, (unsigned long int)text_x);
    s = (unsigned int)0;
    a = polovina;
    for( ; !(a >= (unsigned int)text_x * (unsigned int)text_y); a = a + 1u)
    {
      if((signed int)text_light[(signed long int)a] == 255)
        text_light[(signed long int)s] = (unsigned char)((signed int)text_light[(signed long int)(s + (unsigned int)text_x)] >> 1);

      s = s + 1u;
      if(s >= (unsigned int)text_x)
        s = (unsigned int)0;

    }
  }

}

// signalHandler
// file driver.c line 397
void signalHandler(signed int sig)
{
  signalled = 1;
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat$1;
  return_value___xstat$1=__xstat(1, __path, __statbuf);
  return return_value___xstat$1;
}

// strtol_minmaxdef
// file driver.c line 374
signed int strtol_minmaxdef(const char *optarg, const signed int base, const signed int min, const signed int max, const signed int type, const signed int def, const char *errmsg)
{
  signed int result;
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(optarg, (char **)(void *)0, base);
  result = (const signed int)return_value_strtol$1;
  if(!(result >= min))
  {
    if(!(errmsg == ((const char *)NULL)))
      fprintf(stderr, "%s %d < %d, using %d instead.\n", errmsg, result, min, type != 0 ? min : def);

    return type != 0 ? min : def;
  }

  else
    if(!(max >= result))
    {
      if(!(errmsg == ((const char *)NULL)))
        fprintf(stderr, "%s %d > %d, using %d instead.\n", errmsg, result, max, type != 0 ? max : def);

      return type != 0 ? max : def;
    }

    else
      return result;
}

