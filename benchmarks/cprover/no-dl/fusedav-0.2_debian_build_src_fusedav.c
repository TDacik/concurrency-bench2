// tag-#anon#ST[*{S8}_S8_'scheme'||*{S8}_S8_'host'||*{S8}_S8_'userinfo'||U32'port'||U32'_pad0'||*{S8}_S8_'path'||*{S8}_S8_'query'||*{S8}_S8_'fragment'|]
// file /usr/include/neon/ne_uri.h line 58
struct anonymous_13;

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_5;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_3;

// tag-#anon#ST[*{cS8}_cS8_'nspace'||*{cS8}_cS8_'name'|]
// file /usr/include/neon/ne_props.h line 56
struct anonymous_14;

// tag-#anon#ST[*{cSYM#tag-#anon#ST[*{cS8}_cS8_'nspace'||*{cS8}_cS8_'name'|]#}_cSYM#tag-#anon#ST[*{cS8}_cS8_'nspace'||*{cS8}_cS8_'name'|]#_'name'||ENtag-ne_proppatch_optype#{U32}_U32_'type'||U32'_pad0'||*{cS8}_cS8_'value'|]
// file /usr/include/neon/ne_props.h line 146
struct anonymous_15;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_17;

// tag-#anon#ST[S32'major_version'||S32'minor_version'||S32'code'||S32'klass'||*{S8}_S8_'reason_phrase'|]
// file /usr/include/neon/ne_utils.h line 98
struct anonymous_16;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_2;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_1;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_7;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_0;

// tag-#anon#ST[S32'valid'||S32'filling'||S32'in_use'||S32'valid2'||U32'hash'||U32'_pad0'||*{S8}_S8_'filename'||*{SYM#tag-dir_entry#}_SYM#tag-dir_entry#_'entries'||*{SYM#tag-dir_entry#}_SYM#tag-dir_entry#_'entries2'||S64'dead'||S64'dead2'|]
// file ../../../src/statcache.c line 56
struct anonymous_9;

// tag-#anon#ST[S32'valid'||U32'hash'||*{S8}_S8_'filename'||S64'dead'||SYM#tag-stat#'st'|]
// file ../../../src/statcache.c line 48
struct anonymous_8;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_4;

// tag-#anon#ST[S64'start'||S64'end'||S64'total'|]
// file /usr/include/neon/ne_basic.h line 130
struct anonymous_11;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_18;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_6;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_10;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_12;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-cache_entry
// file ../../../src/statcache.c line 47
struct cache_entry;

// tag-dir_entry
// file ../../../src/statcache.c line 42
struct dir_entry;

// tag-file_info
// file ../../../src/filecache.c line 50
struct file_info;

// tag-fill_info
// file ../../../src/fusedav.c line 78
struct fill_info;

// tag-fuse
// file /usr/include/fuse/fuse.h line 45
struct fuse;

// tag-fuse_args
// file /usr/include/fuse/fuse_opt.h line 108
struct fuse_args;

// tag-fuse_dirhandle
// file /usr/include/fuse/fuse.h line 62
struct fuse_dirhandle;

// tag-fuse_file_info
// file /usr/include/fuse/fuse_common.h line 45
struct fuse_file_info;

// tag-fuse_operations_compat25
// file /usr/include/fuse/fuse_compat.h line 12
struct fuse_operations_compat25;

// tag-getxattr_info
// file ../../../src/fusedav.c line 848
struct getxattr_info;

// tag-listxattr_info
// file ../../../src/fusedav.c line 749
struct listxattr_info;

// tag-ne_lock
// file /usr/include/neon/ne_locks.h line 42
struct ne_lock;

// tag-ne_lock_scope
// file /usr/include/neon/ne_locks.h line 31
enum ne_lock_scope { ne_lockscope_exclusive=0, ne_lockscope_shared=1 };

// tag-ne_lock_store_s
// file /usr/include/neon/ne_locks.h line 79
struct ne_lock_store_s;

// tag-ne_lock_type
// file /usr/include/neon/ne_locks.h line 37
enum ne_lock_type { ne_locktype_write=0 };

// tag-ne_prop_result_set_s
// file /usr/include/neon/ne_props.h line 60
struct ne_prop_result_set_s;

// tag-ne_proppatch_optype
// file /usr/include/neon/ne_props.h line 142
enum ne_proppatch_optype { ne_propset=0, ne_propremove=1 };

// tag-ne_request_s
// file /usr/include/neon/ne_request.h line 43
struct ne_request_s;

// tag-ne_session_s
// file /usr/include/neon/ne_session.h line 34
struct ne_session_s;

// tag-ne_ssl_certificate_s
// file /usr/include/neon/ne_ssl.h line 48
struct ne_ssl_certificate_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 309
union pthread_attr_t;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-statvfs
// file /usr/include/x86_64-linux-gnu/bits/statvfs.h line 29
struct statvfs;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-utimbuf
// file /usr/include/utime.h line 37
struct utimbuf;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// ask_user
// file ../../../src/session.c line 58
static char * ask_user(const char *p, signed int hidden);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atoll
// file /usr/include/stdlib.h line 157
extern signed long long int atoll(const char *);
// cache_alloc
// file ../../../src/statcache.h line 38
void cache_alloc(void);
// cache_free
// file ../../../src/statcache.h line 37
void cache_free(void);
// calc_hash
// file ../../../src/statcache.c line 69
static unsigned int calc_hash(const char *s);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// create_lock
// file ../../../src/fusedav.c line 1235
static signed int create_lock(void);
// dav_chmod
// file ../../../src/fusedav.c line 1105
static signed int dav_chmod(const char *path, unsigned int mode);
// dav_fsync
// file ../../../src/fusedav.c line 530
static signed int dav_fsync(const char *path, signed int isdatasync, struct fuse_file_info *info);
// dav_getattr
// file ../../../src/fusedav.c line 357
static signed int dav_getattr(const char *path, struct stat *stbuf);
// dav_getxattr
// file ../../../src/fusedav.c line 931
static signed int dav_getxattr(const char *path, const char *name, char *value, unsigned long int size);
// dav_listxattr
// file ../../../src/fusedav.c line 798
static signed int dav_listxattr(const char *path, char *list, unsigned long int size);
// dav_mkdir
// file ../../../src/fusedav.c line 427
static signed int dav_mkdir(const char *path, unsigned int mode);
// dav_mknod
// file ../../../src/fusedav.c line 563
static signed int dav_mknod(const char *path, unsigned int mode, unsigned long int rdev);
// dav_open
// file ../../../src/fusedav.c line 598
static signed int dav_open(const char *path, struct fuse_file_info *info);
// dav_read
// file ../../../src/fusedav.c line 614
static signed int dav_read(const char *path, char *buf, unsigned long int size, signed long int offset, struct fuse_file_info *info);
// dav_readdir
// file ../../../src/fusedav.c line 276
static signed int dav_readdir(const char *path, void *buf, signed int (*filler)(void *, const char *, struct stat *, signed long int), signed long int offset, struct fuse_file_info *fi);
// dav_readdir::filler_object
//
signed int filler_object(void *, const char *, struct stat *, signed long int);
// dav_release
// file ../../../src/fusedav.c line 497
static signed int dav_release(const char *path, struct fuse_file_info *info);
// dav_removexattr
// file ../../../src/fusedav.c line 1057
static signed int dav_removexattr(const char *path, const char *name);
// dav_rename
// file ../../../src/fusedav.c line 452
static signed int dav_rename(const char *from, const char *to);
// dav_rmdir
// file ../../../src/fusedav.c line 394
static signed int dav_rmdir(const char *path);
// dav_setxattr
// file ../../../src/fusedav.c line 984
static signed int dav_setxattr(const char *path, const char *name, const char *value, unsigned long int size, signed int flags);
// dav_truncate
// file ../../../src/fusedav.c line 669
static signed int dav_truncate(const char *path, signed long int size);
// dav_unlink
// file ../../../src/fusedav.c line 364
static signed int dav_unlink(const char *path);
// dav_utime
// file ../../../src/fusedav.c line 701
static signed int dav_utime(const char *path, struct utimbuf *buf);
// dav_write
// file ../../../src/fusedav.c line 641
static signed int dav_write(const char *path, const char *buf, unsigned long int size, signed long int offset, struct fuse_file_info *info);
// dir_cache_add
// file ../../../src/statcache.h line 34
void dir_cache_add(const char *fn, const char *subdir);
// dir_cache_begin
// file ../../../src/statcache.h line 32
void dir_cache_begin(const char *fn);
// dir_cache_enumerate
// file ../../../src/statcache.h line 35
signed int dir_cache_enumerate(const char *fn, void (*f)(const char *, const char *, void *), void *user);
// dir_cache_enumerate::f_object
//
void f_object(const char *, const char *, void *);
// dir_cache_finish
// file ../../../src/statcache.h line 33
void dir_cache_finish(const char *fn, signed int success);
// dir_cache_invalidate
// file ../../../src/statcache.c line 326
void dir_cache_invalidate(const char *fn);
// dir_cache_invalidate_parent
// file ../../../src/statcache.h line 31
void dir_cache_invalidate_parent(const char *fn);
// empty_handler
// file ../../../src/fusedav.c line 1190
static void empty_handler(signed int sig);
// exit_handler
// file ../../../src/fusedav.c line 1183
static void exit_handler(signed int sig);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// file_cache_close
// file ../../../src/filecache.h line 32
signed int file_cache_close(void *f);
// file_cache_close_all
// file ../../../src/filecache.h line 38
signed int file_cache_close_all(void);
// file_cache_free_unlocked
// file ../../../src/filecache.c line 95
static void file_cache_free_unlocked(struct file_info *fi);
// file_cache_get
// file ../../../src/filecache.h line 29
void * file_cache_get(const char *path);
// file_cache_get_size
// file ../../../src/filecache.h line 40
signed long int file_cache_get_size(void *f);
// file_cache_open
// file ../../../src/filecache.h line 28
void * file_cache_open(const char *path, signed int flags);
// file_cache_read
// file ../../../src/filecache.h line 34
signed int file_cache_read(void *f, char *buf, unsigned long int size, signed long int offset);
// file_cache_sync
// file ../../../src/filecache.h line 37
signed int file_cache_sync(void *f);
// file_cache_sync_unlocked
// file ../../../src/filecache.c line 346
static signed int file_cache_sync_unlocked(struct file_info *fi);
// file_cache_truncate
// file ../../../src/filecache.h line 36
signed int file_cache_truncate(void *f, signed long int s);
// file_cache_unlink
// file ../../../src/filecache.c line 124
static void file_cache_unlink(struct file_info *fi);
// file_cache_unref
// file ../../../src/filecache.h line 30
void file_cache_unref(void *f);
// file_cache_write
// file ../../../src/filecache.h line 35
signed int file_cache_write(void *f, const char *buf, unsigned long int size, signed long int offset);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// fill_stat
// file ../../../src/fusedav.c line 177
static void fill_stat(struct stat *st, const struct ne_prop_result_set_s *results, signed int is_dir);
// fix_xattr
// file ../../../src/fusedav.c line 740
static const char * fix_xattr(const char *name);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_dir_entries
// file ../../../src/statcache.c line 161
static void free_dir_entries(struct dir_entry *de);
// ftruncate
// file /usr/include/unistd.h line 1019
extern signed int ftruncate(signed int, signed long int);
// fuse_destroy
// file /usr/include/fuse/fuse.h line 679
void fuse_destroy(struct fuse *);
// fuse_exit
// file /usr/include/fuse/fuse.h line 697
void fuse_exit(struct fuse *);
// fuse_loop_mt
// file /usr/include/fuse/fuse.h line 712
signed int fuse_loop_mt(struct fuse *);
// fuse_mount_compat25
// file /usr/include/fuse/fuse_common_compat.h line 20
signed int fuse_mount_compat25(const char *, struct fuse_args *);
// fuse_new_compat25
// file /usr/include/fuse/fuse_compat.h line 53
struct fuse * fuse_new_compat25(signed int, struct fuse_args *, struct fuse_operations_compat25 *, unsigned long int);
// fuse_unmount_compat22
// file /usr/include/fuse/fuse_common_compat.h line 26
void fuse_unmount_compat22(const char *);
// get_current_dir_name
// file /usr/include/unistd.h line 517
extern char * get_current_dir_name(void);
// get_stat
// file ../../../src/fusedav.c line 335
static signed int get_stat(const char *path, struct stat *stbuf);
// getattr_propfind_callback
// file ../../../src/fusedav.c line 320
static void getattr_propfind_callback(void *userdata, const struct anonymous_13 *u, const struct ne_prop_result_set_s *results);
// getdir_cache_callback
// file ../../../src/fusedav.c line 259
static void getdir_cache_callback(const char *root, const char *fn, void *user);
// getdir_propfind_callback
// file ../../../src/fusedav.c line 230
static void getdir_propfind_callback(void *userdata, const struct anonymous_13 *u, const struct ne_prop_result_set_s *results);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getgid
// file /usr/include/unistd.h line 681
extern unsigned int getgid(void);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// getxattr_iterator
// file ../../../src/fusedav.c line 854
static signed int getxattr_iterator(void *userdata, const struct anonymous_14 *pname, const char *value, const struct anonymous_16 *status);
// getxattr_propfind_callback
// file ../../../src/fusedav.c line 891
static void getxattr_propfind_callback(void *userdata, const struct anonymous_13 *u, const struct ne_prop_result_set_s *results);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// listxattr_iterator
// file ../../../src/fusedav.c line 754
static signed int listxattr_iterator(void *userdata, const struct anonymous_14 *pname, const char *value, const struct anonymous_16 *status);
// listxattr_propfind_callback
// file ../../../src/fusedav.c line 793
static void listxattr_propfind_callback(void *userdata, const struct anonymous_13 *u, const struct ne_prop_result_set_s *results);
// load_up_to_unlocked
// file ../../../src/filecache.c line 235
static signed int load_up_to_unlocked(struct file_info *fi, signed long int l);
// lock_thread_func
// file ../../../src/fusedav.c line 1317
static void * lock_thread_func(void *p);
// lseek
// file /usr/include/unistd.h line 337
extern signed long int lseek(signed int, signed long int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkstemp
// file /usr/include/stdlib.h line 622
extern signed int mkstemp(char *);
// ne_auth_creds_cb
// file ../../../src/session.c line 97
static signed int ne_auth_creds_cb(void *userdata, const char *realm, signed int attempt, char *u, char *p);
// ne_delete
// file /usr/include/neon/ne_basic.h line 64
signed int ne_delete(struct ne_session_s *, const char *);
// ne_fill_server_uri
// file /usr/include/neon/ne_session.h line 330
void ne_fill_server_uri(struct ne_session_s *, struct anonymous_13 *);
// ne_get_error
// file /usr/include/neon/ne_session.h line 346
const char * ne_get_error(struct ne_session_s *);
// ne_get_range
// file /usr/include/neon/ne_basic.h line 148
signed int ne_get_range(struct ne_session_s *, const char *, struct anonymous_11 *, signed int);
// ne_get_response_header
// file /usr/include/neon/ne_request.h line 134
const char * ne_get_response_header(struct ne_request_s *, const char *);
// ne_has_support
// file /usr/include/neon/ne_utils.h line 61
signed int ne_has_support(signed int);
// ne_iso8601_parse
// file /usr/include/neon/ne_dates.h line 39
signed long int ne_iso8601_parse(const char *);
// ne_lock
// file /usr/include/neon/ne_locks.h line 125
signed int ne_lock(struct ne_session_s *, struct ne_lock *);
// ne_lock_create
// file /usr/include/neon/ne_locks.h line 61
struct ne_lock * ne_lock_create(void);
// ne_lock_destroy
// file /usr/include/neon/ne_locks.h line 75
void ne_lock_destroy(struct ne_lock *);
// ne_lock_refresh
// file /usr/include/neon/ne_locks.h line 131
signed int ne_lock_refresh(struct ne_session_s *, struct ne_lock *);
// ne_lockstore_add
// file /usr/include/neon/ne_locks.h line 98
void ne_lockstore_add(struct ne_lock_store_s *, struct ne_lock *);
// ne_lockstore_create
// file /usr/include/neon/ne_locks.h line 82
struct ne_lock_store_s * ne_lockstore_create(void);
// ne_lockstore_destroy
// file /usr/include/neon/ne_locks.h line 90
void ne_lockstore_destroy(struct ne_lock_store_s *);
// ne_lockstore_register
// file /usr/include/neon/ne_locks.h line 87
void ne_lockstore_register(struct ne_lock_store_s *, struct ne_session_s *);
// ne_mkcol
// file /usr/include/neon/ne_basic.h line 68
signed int ne_mkcol(struct ne_session_s *, const char *);
// ne_move
// file /usr/include/neon/ne_basic.h line 60
signed int ne_move(struct ne_session_s *, signed int, const char *, const char *);
// ne_path_escape
// file /usr/include/neon/ne_uri.h line 33
char * ne_path_escape(const char *);
// ne_path_parent
// file /usr/include/neon/ne_uri.h line 42
char * ne_path_parent(const char *);
// ne_path_unescape
// file /usr/include/neon/ne_uri.h line 38
char * ne_path_unescape(const char *);
// ne_proppatch
// file /usr/include/neon/ne_props.h line 155
signed int ne_proppatch(struct ne_session_s *, const char *, const struct anonymous_15 *);
// ne_propset_iterate
// file /usr/include/neon/ne_props.h line 101
signed int ne_propset_iterate(const struct ne_prop_result_set_s *, signed int (*)(void *, const struct anonymous_14 *, const char *, const struct anonymous_16 *), void *);
// ne_propset_value
// file /usr/include/neon/ne_props.h line 65
const char * ne_propset_value(const struct ne_prop_result_set_s *, const struct anonymous_14 *);
// ne_put
// file /usr/include/neon/ne_basic.h line 37
signed int ne_put(struct ne_session_s *, const char *, signed int);
// ne_redirect_location
// file /usr/include/neon/ne_redirect.h line 38
const struct anonymous_13 * ne_redirect_location(struct ne_session_s *);
// ne_redirect_register
// file /usr/include/neon/ne_redirect.h line 33
void ne_redirect_register(struct ne_session_s *);
// ne_request_create
// file /usr/include/neon/ne_request.h line 50
struct ne_request_s * ne_request_create(struct ne_session_s *, const char *, const char *);
// ne_request_destroy
// file /usr/include/neon/ne_request.h line 179
void ne_request_destroy(struct ne_request_s *);
// ne_request_dispatch
// file /usr/include/neon/ne_request.h line 169
signed int ne_request_dispatch(struct ne_request_s *);
// ne_rfc1123_date
// file /usr/include/neon/ne_dates.h line 34
char * ne_rfc1123_date(signed long int);
// ne_rfc1123_parse
// file /usr/include/neon/ne_dates.h line 42
signed long int ne_rfc1123_parse(const char *);
// ne_session_create
// file /usr/include/neon/ne_session.h line 39
struct ne_session_s * ne_session_create(const char *, const char *, unsigned int);
// ne_session_destroy
// file /usr/include/neon/ne_session.h line 43
void ne_session_destroy(struct ne_session_s *);
// ne_set_server_auth
// file /usr/include/neon/ne_auth.h line 56
void ne_set_server_auth(struct ne_session_s *, signed int (*)(void *, const char *, signed int, char *, char *), void *);
// ne_simple_propfind
// file /usr/include/neon/ne_props.h line 127
signed int ne_simple_propfind(struct ne_session_s *, const char *, signed int, const struct anonymous_14 *, void (*)(void *, const struct anonymous_13 *, const struct ne_prop_result_set_s *), void *);
// ne_sock_init
// file /usr/include/neon/ne_socket.h line 58
signed int ne_sock_init(void);
// ne_ssl_set_verify
// file /usr/include/neon/ne_session.h line 266
void ne_ssl_set_verify(struct ne_session_s *, signed int (*)(void *, signed int, const struct ne_ssl_certificate_s *), void *);
// ne_unlock
// file /usr/include/neon/ne_locks.h line 128
signed int ne_unlock(struct ne_session_s *, struct ne_lock *);
// ne_uri_defaultport
// file /usr/include/neon/ne_uri.h line 56
unsigned int ne_uri_defaultport(const char *);
// ne_uri_free
// file /usr/include/neon/ne_uri.h line 98
void ne_uri_free(struct anonymous_13 *);
// ne_uri_parse
// file /usr/include/neon/ne_uri.h line 71
signed int ne_uri_parse(const char *, struct anonymous_13 *);
// parse_xattr
// file ../../../src/fusedav.c line 896
static signed int parse_xattr(const char *name, char *dnspace, unsigned long int dnspace_length, char *dname, unsigned long int dname_length);
// path_cvt
// file ../../../src/fusedav.c line 93
static const char * path_cvt(const char *path);
// path_cvt_tsd_key_init
// file ../../../src/fusedav.c line 89
static void path_cvt_tsd_key_init(void);
// pread
// file /usr/include/unistd.h line 388
extern signed long int pread(signed int, void *, unsigned long int, signed long int);
// proppatch_with_redirect
// file ../../../src/fusedav.c line 148
static signed int proppatch_with_redirect(struct ne_session_s *session, const char *path, const struct anonymous_15 *ops);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_getspecific
// file /usr/include/pthread.h line 1121
extern void * pthread_getspecific(unsigned int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_key_create
// file /usr/include/pthread.h line 1113
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_kill
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 35
extern signed int pthread_kill(unsigned long int, signed int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_12 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_12 *, const union anonymous_10 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_12 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_12 *);
// pthread_once
// file /usr/include/pthread.h line 496
extern signed int pthread_once(signed int *, void (*)(void));
// pthread_setspecific
// file /usr/include/pthread.h line 1124
extern signed int pthread_setspecific(unsigned int, const void *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_17 *, struct anonymous_17 *);
// pwrite
// file /usr/include/unistd.h line 391
extern signed long int pwrite(signed int, const void *, unsigned long int, signed long int);
// remove_lock
// file ../../../src/fusedav.c line 1298
static signed int remove_lock(void);
// session_destroy
// file ../../../src/session.c line 154
static void session_destroy(void *s);
// session_free
// file ../../../src/session.h line 29
void session_free(void);
// session_get
// file ../../../src/session.h line 27
struct ne_session_s * session_get(signed int with_lock);
// session_is_local
// file ../../../src/session.h line 31
signed int session_is_local(const struct anonymous_13 *u);
// session_open
// file ../../../src/session.c line 128
static struct ne_session_s * session_open(signed int with_lock);
// session_set_uri
// file ../../../src/session.h line 28
signed int session_set_uri(const char *s, const char *u, const char *p);
// session_tsd_key_init
// file ../../../src/session.c line 160
static void session_tsd_key_init(void);
// setup_signal_handlers
// file ../../../src/fusedav.c line 1192
static signed int setup_signal_handlers(void);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_17 *, signed int);
// sigdelset
// file /usr/include/signal.h line 224
extern signed int sigdelset(struct anonymous_17 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_17 *);
// simple_propfind_with_redirect
// file ../../../src/fusedav.c line 117
static signed int simple_propfind_with_redirect(struct ne_session_s *session, const char *path, signed int depth, const struct anonymous_14 *props, void (*results)(void *, const struct anonymous_13 *, const struct ne_prop_result_set_s *), void *userdata);
// simple_propfind_with_redirect::results_object
//
void results_object(void *, const struct anonymous_13 *, const struct ne_prop_result_set_s *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// ssl_verify_cb
// file ../../../src/session.c line 93
static signed int ssl_verify_cb(void *userdata, signed int failures, const struct ne_ssl_certificate_s *cert);
// stat_cache_get
// file ../../../src/statcache.h line 26
signed int stat_cache_get(const char *fn, struct stat *st);
// stat_cache_invalidate
// file ../../../src/statcache.h line 28
void stat_cache_invalidate(const char *fn);
// stat_cache_set
// file ../../../src/statcache.h line 27
void stat_cache_set(const char *fn, struct stat *st);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strip_trailing_slash
// file ../../../src/fusedav.c line 218
static char * strip_trailing_slash(char *fn, signed int *is_dir);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usage
// file ../../../src/fusedav.c line 1163
static void usage(char *argv0);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_13
{
  // scheme
  char *scheme;
  // host
  char *host;
  // userinfo
  char *userinfo;
  // port
  unsigned int port;
  // path
  char *path;
  // query
  char *query;
  // fragment
  char *fragment;
};

struct anonymous_5
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_3
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_14
{
  // nspace
  const char *nspace;
  // name
  const char *name;
};

struct anonymous_15
{
  // name
  const struct anonymous_14 *name;
  // type
  enum ne_proppatch_optype type;
  // value
  const char *value;
};

struct anonymous_17
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_16
{
  // major_version
  signed int major_version;
  // minor_version
  signed int minor_version;
  // code
  signed int code;
  // klass
  signed int klass;
  // reason_phrase
  char *reason_phrase;
};

struct anonymous
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_2
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_1
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_0
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_4
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_6
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous _kill;
  // _timer
  struct anonymous_0 _timer;
  // _rt
  struct anonymous_1 _rt;
  // _sigchld
  struct anonymous_2 _sigchld;
  // _sigfault
  struct anonymous_3 _sigfault;
  // _sigpoll
  struct anonymous_4 _sigpoll;
  // _sigsys
  struct anonymous_5 _sigsys;
};

struct anonymous_7
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_6 _sifields;
};

struct anonymous_9
{
  // valid
  signed int valid;
  // filling
  signed int filling;
  // in_use
  signed int in_use;
  // valid2
  signed int valid2;
  // hash
  unsigned int hash;
  // filename
  char *filename;
  // entries
  struct dir_entry *entries;
  // entries2
  struct dir_entry *entries2;
  // dead
  signed long int dead;
  // dead2
  signed long int dead2;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct anonymous_8
{
  // valid
  signed int valid;
  // hash
  unsigned int hash;
  // filename
  char *filename;
  // dead
  signed long int dead;
  // st
  struct stat st;
};

struct anonymous_11
{
  // start
  signed long int start;
  // end
  signed long int end;
  // total
  signed long int total;
};

union anonymous_18
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_7 *, void *);
};

union anonymous_10
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_12
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct cache_entry
{
  // stat_info
  struct anonymous_8 stat_info;
  // dir_info
  struct anonymous_9 dir_info;
};

struct dir_entry
{
  // next
  struct dir_entry *next;
  // filename
  char filename[0l];
};

struct file_info
{
  // filename
  char *filename;
  // fd
  signed int fd;
  // server_length
  signed long int server_length;
  // length
  signed long int length;
  // present
  signed long int present;
  // readable
  signed int readable;
  // writable
  signed int writable;
  // modified
  signed int modified;
  // ref
  signed int ref;
  // dead
  signed int dead;
  // mutex
  union anonymous_12 mutex;
  // next
  struct file_info *next;
};

struct fill_info
{
  // buf
  void *buf;
  // filler
  signed int (*filler)(void *, const char *, struct stat *, signed long int);
  // root
  const char *root;
};

struct fuse_args
{
  // argc
  signed int argc;
  // argv
  char **argv;
  // allocated
  signed int allocated;
};

struct fuse_file_info
{
  // flags
  signed int flags;
  // fh_old
  unsigned long int fh_old;
  // writepage
  signed int writepage;
  // direct_io
  unsigned int direct_io : 1;
  // keep_cache
  unsigned int keep_cache : 1;
  // flush
  unsigned int flush : 1;
  // nonseekable
  unsigned int nonseekable : 1;
  // flock_release
  unsigned int flock_release : 1;
  // padding
  unsigned int padding : 27;
  // fh
  unsigned long int fh;
  // lock_owner
  unsigned long int lock_owner;
};

struct fuse_operations_compat25
{
  // getattr
  signed int (*getattr)(const char *, struct stat *);
  // readlink
  signed int (*readlink)(const char *, char *, unsigned long int);
  // getdir
  signed int (*getdir)(const char *, struct fuse_dirhandle *, signed int (*)(struct fuse_dirhandle *, const char *, signed int, unsigned long int));
  // mknod
  signed int (*mknod)(const char *, unsigned int, unsigned long int);
  // mkdir
  signed int (*mkdir)(const char *, unsigned int);
  // unlink
  signed int (*unlink)(const char *);
  // rmdir
  signed int (*rmdir)(const char *);
  // symlink
  signed int (*symlink)(const char *, const char *);
  // rename
  signed int (*rename)(const char *, const char *);
  // link
  signed int (*link)(const char *, const char *);
  // chmod
  signed int (*chmod)(const char *, unsigned int);
  // chown
  signed int (*chown)(const char *, unsigned int, unsigned int);
  // truncate
  signed int (*truncate)(const char *, signed long int);
  // utime
  signed int (*utime)(const char *, struct utimbuf *);
  // open
  signed int (*open)(const char *, struct fuse_file_info *);
  // read
  signed int (*read)(const char *, char *, unsigned long int, signed long int, struct fuse_file_info *);
  // write
  signed int (*write)(const char *, const char *, unsigned long int, signed long int, struct fuse_file_info *);
  // statfs
  signed int (*statfs)(const char *, struct statvfs *);
  // flush
  signed int (*flush)(const char *, struct fuse_file_info *);
  // release
  signed int (*release)(const char *, struct fuse_file_info *);
  // fsync
  signed int (*fsync)(const char *, signed int, struct fuse_file_info *);
  // setxattr
  signed int (*setxattr)(const char *, const char *, const char *, unsigned long int, signed int);
  // getxattr
  signed int (*getxattr)(const char *, const char *, char *, unsigned long int);
  // listxattr
  signed int (*listxattr)(const char *, char *, unsigned long int);
  // removexattr
  signed int (*removexattr)(const char *, const char *);
  // opendir
  signed int (*opendir)(const char *, struct fuse_file_info *);
  // readdir
  signed int (*readdir)(const char *, void *, signed int (*)(void *, const char *, struct stat *, signed long int), signed long int, struct fuse_file_info *);
  // releasedir
  signed int (*releasedir)(const char *, struct fuse_file_info *);
  // fsyncdir
  signed int (*fsyncdir)(const char *, signed int, struct fuse_file_info *);
  // init
  void * (*init)(void);
  // destroy
  void (*destroy)(void *);
  // access
  signed int (*access)(const char *, signed int);
  // create
  signed int (*create)(const char *, unsigned int, struct fuse_file_info *);
  // ftruncate
  signed int (*ftruncate)(const char *, signed long int, struct fuse_file_info *);
  // fgetattr
  signed int (*fgetattr)(const char *, struct stat *, struct fuse_file_info *);
};

struct getxattr_info
{
  // propname
  struct anonymous_14 propname;
  // value
  char *value;
  // space
  unsigned long int space;
  // size
  unsigned long int size;
};

struct listxattr_info
{
  // list
  char *list;
  // space
  unsigned long int space;
  // size
  unsigned long int size;
};

struct ne_lock
{
  // uri
  struct anonymous_13 uri;
  // depth
  signed int depth;
  // type
  enum ne_lock_type type;
  // scope
  enum ne_lock_scope scope;
  // token
  char *token;
  // owner
  char *owner;
  // timeout
  signed long int timeout;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_18 __sigaction_handler;
  // sa_mask
  struct anonymous_17 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct statvfs
{
  // f_bsize
  unsigned long int f_bsize;
  // f_frsize
  unsigned long int f_frsize;
  // f_blocks
  unsigned long int f_blocks;
  // f_bfree
  unsigned long int f_bfree;
  // f_bavail
  unsigned long int f_bavail;
  // f_files
  unsigned long int f_files;
  // f_ffree
  unsigned long int f_ffree;
  // f_favail
  unsigned long int f_favail;
  // f_fsid
  unsigned long int f_fsid;
  // f_flag
  unsigned long int f_flag;
  // f_namemax
  unsigned long int f_namemax;
  // __f_spare
  signed int __f_spare[6l];
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct utimbuf
{
  // actime
  signed long int actime;
  // modtime
  signed long int modtime;
};


// b_uri
// file ../../../src/session.c line 50
static signed int b_uri = 0;
// base_directory
// file ../../../src/session.c line 54
char *base_directory = (char *)(void *)0;
// cache
// file ../../../src/statcache.c line 65
static struct cache_entry *cache = (struct cache_entry *)(void *)0;
// credential_mutex
// file ../../../src/session.c line 56
static union anonymous_12 credential_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// dav_oper
// file ../../../src/fusedav.c line 1141
static struct fuse_operations_compat25 dav_oper;
// dav_oper
// file ../../../src/fusedav.c line 1141
static struct fuse_operations_compat25 dav_oper = { .getattr=dav_getattr, .readlink=((signed int (*)(const char *, char *, unsigned long int))NULL), .getdir=((signed int (*)(const char *, struct fuse_dirhandle *, signed int (*)(struct fuse_dirhandle *, const char *, signed int, unsigned long int)))NULL),
    .mknod=dav_mknod,
    .mkdir=dav_mkdir, .unlink=dav_unlink, .rmdir=dav_rmdir,
    .symlink=((signed int (*)(const char *, const char *))NULL), .rename=dav_rename,
    .link=((signed int (*)(const char *, const char *))NULL), .chmod=dav_chmod,
    .chown=((signed int (*)(const char *, unsigned int, unsigned int))NULL), .truncate=dav_truncate,
    .utime=dav_utime, .open=dav_open,
    .read=dav_read, .write=dav_write, .statfs=((signed int (*)(const char *, struct statvfs *))NULL),
    .flush=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .release=dav_release,
    .fsync=dav_fsync, .setxattr=dav_setxattr,
    .getxattr=dav_getxattr, .listxattr=dav_listxattr,
    .removexattr=dav_removexattr, .opendir=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .readdir=dav_readdir,
    .releasedir=((signed int (*)(const char *, struct fuse_file_info *))NULL), .fsyncdir=((signed int (*)(const char *, signed int, struct fuse_file_info *))NULL),
    .init=((void * (*)(void))NULL),
    .destroy=((void (*)(void *))NULL), .access=((signed int (*)(const char *, signed int))NULL),
    .create=((signed int (*)(const char *, unsigned int, struct fuse_file_info *))NULL),
    .ftruncate=((signed int (*)(const char *, signed long int, struct fuse_file_info *))NULL),
    .fgetattr=((signed int (*)(const char *, struct stat *, struct fuse_file_info *))NULL) };
// debug
// file ../../../src/fusedav.c line 67
signed int debug = 0;
// dir_cache_mutex
// file ../../../src/statcache.c line 67
static union anonymous_12 dir_cache_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// files
// file ../../../src/filecache.c line 68
static struct file_info *files = (struct file_info *)(void *)0;
// files_mutex
// file ../../../src/filecache.c line 69
static union anonymous_12 files_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// fuse
// file ../../../src/fusedav.c line 68
struct fuse *fuse = (struct fuse *)(void *)0;
// lock
// file ../../../src/fusedav.c line 70
struct ne_lock *lock = (struct ne_lock *)(void *)0;
// lock_store
// file ../../../src/fusedav.c line 69
struct ne_lock_store_s *lock_store = (struct ne_lock_store_s *)(void *)0;
// lock_thread_exit
// file ../../../src/fusedav.c line 71
signed int lock_thread_exit = 0;
// lock_timeout
// file ../../../src/fusedav.c line 72
signed int lock_timeout = 60;
// mask
// file ../../../src/fusedav.c line 66
unsigned int mask = (unsigned int)0;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// password
// file ../../../src/session.c line 53
static char *password = (char *)(void *)0;
// path_cvt_once
// file ../../../src/fusedav.c line 86
static signed int path_cvt_once = 0;
// path_cvt_tsd_key
// file ../../../src/fusedav.c line 87
static unsigned int path_cvt_tsd_key;
// query_properties
// file ../../../src/fusedav.c line 57
const struct anonymous_14 query_properties[6l] = { { .nspace="DAV:", .name="resourcetype" },
    { .nspace="http://apache.org/dav/props/", .name="executable" },
    { .nspace="DAV:", .name="getcontentlength" },
    { .nspace="DAV:", .name="getlastmodified" },
    { .nspace="DAV:", .name="creationdate" },
    { .nspace=(const char *)(void *)0, .name=(const char *)(void *)0 } };
// session_once
// file ../../../src/session.c line 46
static signed int session_once = 0;
// session_tsd_key
// file ../../../src/session.c line 47
static unsigned int session_tsd_key;
// stat_cache_mutex
// file ../../../src/statcache.c line 66
static union anonymous_12 stat_cache_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// uri
// file ../../../src/session.c line 49
struct anonymous_13 uri;
// username
// file ../../../src/session.c line 52
char *username = (char *)(void *)0;

// ask_user
// file ../../../src/session.c line 58
static char * ask_user(const char *p, signed int hidden)
{
  char q[256l];
  char *r;
  struct termios t;
  signed int c = 0;
  signed int l;
  if(!(hidden == 0))
  {
    signed int return_value_fileno_5;
    return_value_fileno_5=fileno(stdin);
    signed int return_value_isatty_6;
    return_value_isatty_6=isatty(return_value_fileno_5);
    if(return_value_isatty_6 == 0)
      hidden = 0;

    else
    {
      signed int return_value_fileno_3;
      return_value_fileno_3=fileno(stdin);
      signed int return_value_tcgetattr_4;
      return_value_tcgetattr_4=tcgetattr(return_value_fileno_3, &t);
      if(!(return_value_tcgetattr_4 >= 0))
        hidden = 0;

      else
      {
        c = (signed int)t.c_lflag;
        t.c_lflag = t.c_lflag & (unsigned int)~0000010;
        signed int return_value_fileno_1;
        return_value_fileno_1=fileno(stdin);
        signed int return_value_tcsetattr_2;
        return_value_tcsetattr_2=tcsetattr(return_value_fileno_1, 0, &t);
        if(!(return_value_tcsetattr_2 >= 0))
          hidden = 0;

      }
    }
  }

  fprintf(stderr, "%s: ", p);
  r=fgets(q, (signed int)sizeof(char [256l]) /*256ul*/ , stdin);
  unsigned long int return_value_strlen_7;
  return_value_strlen_7=strlen(q);
  l = (signed int)return_value_strlen_7;
  if(!(l == 0))
  {
    if((signed int)q[(signed long int)(l + -1)] == 10)
      q[(signed long int)(l - 1)] = (char)0;

  }

  if(!(hidden == 0))
  {
    t.c_lflag = (unsigned int)c;
    signed int return_value_fileno_8;
    return_value_fileno_8=fileno(stdin);
    tcsetattr(return_value_fileno_8, 0, &t);
    fprintf(stderr, "\n");
  }

  char *tmp_if_expr_10;
  char *return_value_strdup_9;
  if(!(r == ((char *)NULL)))
  {
    return_value_strdup_9=strdup(r);
    tmp_if_expr_10 = return_value_strdup_9;
  }

  else
    tmp_if_expr_10 = (char *)(void *)0;
  return tmp_if_expr_10;
}

// cache_alloc
// file ../../../src/statcache.h line 38
void cache_alloc(void)
{
  if(cache == ((struct cache_entry *)NULL))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct cache_entry) /*232ul*/  * (unsigned long int)2049);
    cache = (struct cache_entry *)return_value_malloc_1;
    /* assertion cache */
    assert(cache != ((struct cache_entry *)NULL));
    memset((void *)cache, 0, sizeof(struct cache_entry) /*232ul*/  * (unsigned long int)2049);
  }

}

// cache_free
// file ../../../src/statcache.h line 37
void cache_free(void)
{
  unsigned int h;
  struct cache_entry *ce;
  if(!(cache == ((struct cache_entry *)NULL)))
  {
    h = (unsigned int)0;
    ce = cache;
    for( ; !(h >= 2049u); ce = ce + 1l)
    {
      free((void *)ce->stat_info.filename);
      free((void *)ce->dir_info.filename);
      free_dir_entries(ce->dir_info.entries);
      free_dir_entries(ce->dir_info.entries2);
      h = h + 1u;
    }
    memset((void *)cache, 0, sizeof(struct cache_entry) /*232ul*/  * (unsigned long int)2049);
  }

}

// calc_hash
// file ../../../src/statcache.c line 69
static unsigned int calc_hash(const char *s)
{
  unsigned int h = (unsigned int)0;
  for( ; !(*s == 0); s = s + 1l)
  {
    h = h ^ (unsigned int)*((const unsigned char *)s);
    h = h << 8 | h >> 24;
  }
  return h;
}

// create_lock
// file ../../../src/fusedav.c line 1235
static signed int create_lock(void)
{
  struct ne_session_s *session;
  char _owner[64l];
  char *owner;
  signed int i;
  signed int ret;
  lock=ne_lock_create();
  /* assertion lock */
  assert(lock != ((struct ne_lock *)NULL));
  session=session_get(0);
  if(session == ((struct ne_session_s *)NULL))
    return -1;

  else
  {
    owner = username;
    if(owner == ((char *)NULL))
    {
      owner=getenv("USER");
      if(owner == ((char *)NULL))
      {
        owner=getenv("LOGNAME");
        if(owner == ((char *)NULL))
        {
          unsigned int return_value_getuid_1;
          return_value_getuid_1=getuid();
          snprintf(_owner, sizeof(char [64l]) /*64ul*/ , "%lu", (unsigned long int)return_value_getuid_1);
          owner = owner;
        }

      }

    }

    ne_fill_server_uri(session, &lock->uri);
    lock->uri.path=strdup(base_directory);
    lock->depth = 2;
    lock->timeout = (signed long int)lock_timeout;
    lock->owner=strdup(owner);
    if(!(debug == 0))
      fprintf(stderr, "Acquiring lock...\n");

    i = 0;
    for( ; !(i >= 10); i = i + 1)
    {
      const struct anonymous_13 *u;
      ret=ne_lock(session, lock);
      if(!(ret == 9))
        break;

      u=ne_redirect_location(session);
      if(u == ((const struct anonymous_13 *)NULL))
        break;

      signed int return_value_session_is_local_2;
      return_value_session_is_local_2=session_is_local(u);
      if(return_value_session_is_local_2 == 0)
        break;

      if(!(debug == 0))
        fprintf(stderr, "REDIRECT FROM '%s' to '%s'\n", lock->uri.path, u->path);

      free((void *)lock->uri.path);
      lock->uri.path=strdup(u->path);
    }
    if(!(ret == 0))
    {
      const char *return_value_ne_get_error_3;
      return_value_ne_get_error_3=ne_get_error(session);
      fprintf(stderr, "LOCK failed: %s\n", return_value_ne_get_error_3);
      ne_lock_destroy(lock);
      lock = (struct ne_lock *)(void *)0;
      return -1;
    }

    lock_store=ne_lockstore_create();
    /* assertion lock_store */
    assert(lock_store != ((struct ne_lock_store_s *)NULL));
    ne_lockstore_add(lock_store, lock);
    return 0;
  }
}

// dav_chmod
// file ../../../src/fusedav.c line 1105
static signed int dav_chmod(const char *path, unsigned int mode)
{
  struct ne_session_s *session;
  const struct anonymous_14 executable = { .nspace="http://apache.org/dav/props/", .name="executable" };
  struct anonymous_15 ops[2l];
  signed int r = 0;
  /* assertion path */
  assert(path != ((const char *)NULL));
  path=path_cvt(path);
  if(!(debug == 0))
    fprintf(stderr, "chmod(%s, %04o)\n", path, mode);

  ops[(signed long int)0].name = &executable;
  ops[(signed long int)0].type = (enum ne_proppatch_optype)ne_propset;
  ops[(signed long int)0].value = (mode & (unsigned int)0111) != 0u ? "T" : "F";
  ops[(signed long int)1].name = (const struct anonymous_14 *)(void *)0;
  session=session_get(1);
  signed int return_value_proppatch_with_redirect_2;
  if(session == ((struct ne_session_s *)NULL))
    r = -5;

  else
  {
    return_value_proppatch_with_redirect_2=proppatch_with_redirect(session, path, ops);
    if(!(return_value_proppatch_with_redirect_2 == 0))
    {
      const char *return_value_ne_get_error_1;
      return_value_ne_get_error_1=ne_get_error(session);
      fprintf(stderr, "PROPPATCH failed: %s\n", return_value_ne_get_error_1);
      r = -95;
      goto finish;
    }

    stat_cache_invalidate(path);
  }

finish:
  ;
  return r;
}

// dav_fsync
// file ../../../src/fusedav.c line 530
static signed int dav_fsync(const char *path, signed int isdatasync, struct fuse_file_info *info)
{
  void *f = (void *)0;
  signed int r = 0;
  struct ne_session_s *session;
  path=path_cvt(path);
  if(!(debug == 0))
    fprintf(stderr, "fsync(%s)\n", path);

  session=session_get(1);
  signed int return_value_file_cache_sync_2;
  if(session == ((struct ne_session_s *)NULL))
    r = -5;

  else
  {
    f=file_cache_get(path);
    if(f == NULL)
    {
      fprintf(stderr, "fsync() called for closed file\n");
      r = -14;
    }

    else
    {
      return_value_file_cache_sync_2=file_cache_sync(f);
      if(!(return_value_file_cache_sync_2 >= 0))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        r = -(*return_value___errno_location_1);
        goto finish;
      }

    }
  }

finish:
  ;
  if(!(f == NULL))
    file_cache_unref(f);

  return r;
}

// dav_getattr
// file ../../../src/fusedav.c line 357
static signed int dav_getattr(const char *path, struct stat *stbuf)
{
  path=path_cvt(path);
  if(!(debug == 0))
    fprintf(stderr, "getattr(%s)\n", path);

  signed int return_value_get_stat_1;
  return_value_get_stat_1=get_stat(path, stbuf);
  return return_value_get_stat_1;
}

// dav_getxattr
// file ../../../src/fusedav.c line 931
static signed int dav_getxattr(const char *path, const char *name, char *value, unsigned long int size)
{
  struct ne_session_s *session;
  struct getxattr_info g;
  struct anonymous_14 props[2l];
  char dnspace[128l];
  char dname[128l];
  /* assertion path */
  assert(path != ((const char *)NULL));
  path=path_cvt(path);
  name=fix_xattr(name);
  if(!(debug == 0))
    fprintf(stderr, "getxattr(%s, %s, .., %lu)\n", path, name, (unsigned long int)size);

  signed int return_value_parse_xattr_1;
  return_value_parse_xattr_1=parse_xattr(name, dnspace, sizeof(char [128l]) /*128ul*/ , dname, sizeof(char [128l]) /*128ul*/ );
  if(!(return_value_parse_xattr_1 >= 0))
    return -61;

  else
  {
    props[(signed long int)0].nspace = dnspace;
    props[(signed long int)0].name = dname;
    props[(signed long int)1].nspace = (const char *)(void *)0;
    props[(signed long int)1].name = (const char *)(void *)0;
    if(!(value == ((char *)NULL)))
    {
      g.value = value;
      g.space = size;
      g.size = (unsigned long int)-1;
    }

    else
    {
      g.value = (char *)(void *)0;
      g.space = (unsigned long int)0;
      g.size = (unsigned long int)-1;
    }
    g.propname = props[(signed long int)0];
    session=session_get(1);
    if(session == ((struct ne_session_s *)NULL))
      return -5;

    else
    {
      signed int return_value_simple_propfind_with_redirect_3;
      return_value_simple_propfind_with_redirect_3=simple_propfind_with_redirect(session, path, 0, props, getxattr_propfind_callback, (void *)&g);
      if(!(return_value_simple_propfind_with_redirect_3 == 0))
      {
        const char *return_value_ne_get_error_2;
        return_value_ne_get_error_2=ne_get_error(session);
        fprintf(stderr, "PROPFIND failed: %s\n", return_value_ne_get_error_2);
        return -5;
      }

      if(g.size == 18446744073709551615ul)
        return -61;

      else
        return (signed int)g.size;
    }
  }
}

// dav_listxattr
// file ../../../src/fusedav.c line 798
static signed int dav_listxattr(const char *path, char *list, unsigned long int size)
{
  struct ne_session_s *session;
  struct listxattr_info l;
  /* assertion path */
  assert(path != ((const char *)NULL));
  path=path_cvt(path);
  if(!(debug == 0))
    fprintf(stderr, "listxattr(%s, .., %lu)\n", path, (unsigned long int)size);

  if(!(list == ((char *)NULL)))
  {
    l.list = list;
    l.space = size - (unsigned long int)1;
    l.size = (unsigned long int)0;
    if(l.space >= sizeof(char [15l]) /*15ul*/ )
    {
      memcpy((void *)l.list, (const void *)"user.mime_type", sizeof(char [15l]) /*15ul*/ );
      l.list = l.list + (signed long int)sizeof(char [15l]) /*15ul*/ ;
      l.space = l.space - sizeof(char [15l]) /*15ul*/ ;
      l.size = l.size + sizeof(char [15l]) /*15ul*/ ;
    }

  }

  else
  {
    l.list = (char *)(void *)0;
    l.space = (unsigned long int)0;
    l.size = sizeof(char [15l]) /*15ul*/ ;
  }
  session=session_get(1);
  if(session == ((struct ne_session_s *)NULL))
    return -5;

  else
  {
    signed int return_value_simple_propfind_with_redirect_2;
    return_value_simple_propfind_with_redirect_2=simple_propfind_with_redirect(session, path, 0, (const struct anonymous_14 *)(void *)0, listxattr_propfind_callback, (void *)&l);
    if(!(return_value_simple_propfind_with_redirect_2 == 0))
    {
      const char *return_value_ne_get_error_1;
      return_value_ne_get_error_1=ne_get_error(session);
      fprintf(stderr, "PROPFIND failed: %s\n", return_value_ne_get_error_1);
      return -5;
    }

    if(!(l.list == ((char *)NULL)))
    {
      /* assertion l.space > 0 */
      assert(l.space > (unsigned long int)0);
      *l.list = (char)0;
    }

    return (signed int)(l.size + (unsigned long int)1);
  }
}

// dav_mkdir
// file ../../../src/fusedav.c line 427
static signed int dav_mkdir(const char *path, unsigned int mode)
{
  char fn[4096l];
  struct ne_session_s *session;
  path=path_cvt(path);
  if(!(debug == 0))
    fprintf(stderr, "mkdir(%s)\n", path);

  session=session_get(1);
  if(session == ((struct ne_session_s *)NULL))
    return -5;

  else
  {
    snprintf(fn, sizeof(char [4096l]) /*4096ul*/ , "%s/", path);
    signed int return_value_ne_mkcol_2;
    return_value_ne_mkcol_2=ne_mkcol(session, fn);
    if(!(return_value_ne_mkcol_2 == 0))
    {
      const char *return_value_ne_get_error_1;
      return_value_ne_get_error_1=ne_get_error(session);
      fprintf(stderr, "MKCOL failed: %s\n", return_value_ne_get_error_1);
      return -2;
    }

    stat_cache_invalidate(path);
    dir_cache_invalidate_parent(path);
    return 0;
  }
}

// dav_mknod
// file ../../../src/fusedav.c line 563
static signed int dav_mknod(const char *path, unsigned int mode, unsigned long int rdev)
{
  char tempfile[4096l];
  signed int fd;
  struct ne_session_s *session;
  path=path_cvt(path);
  if(!(debug == 0))
    fprintf(stderr, "mknod(%s)\n", path);

  session=session_get(1);
  signed int *return_value___errno_location_1;
  if(session == ((struct ne_session_s *)NULL))
    return -5;

  else
    if(!((61440u & mode) == 32768u))
      return -95;

    else
    {
      snprintf(tempfile, sizeof(char [4096l]) /*4096ul*/ , "%s/fusedav-empty-XXXXXX", (const void *)"/tmp");
      fd=mkstemp(tempfile);
      if(!(fd >= 0))
      {
        return_value___errno_location_1=__errno_location();
        return -(*return_value___errno_location_1);
      }

      else
      {
        unlink(tempfile);
        signed int return_value_ne_put_3;
        return_value_ne_put_3=ne_put(session, path, fd);
        if(!(return_value_ne_put_3 == 0))
        {
          const char *return_value_ne_get_error_2;
          return_value_ne_get_error_2=ne_get_error(session);
          fprintf(stderr, "mknod:PUT failed: %s\n", return_value_ne_get_error_2);
          close(fd);
          return -13;
        }

        close(fd);
        stat_cache_invalidate(path);
        dir_cache_invalidate_parent(path);
        return 0;
      }
    }
}

// dav_open
// file ../../../src/fusedav.c line 598
static signed int dav_open(const char *path, struct fuse_file_info *info)
{
  void *f;
  if(!(debug == 0))
    fprintf(stderr, "open(%s)\n", path);

  path=path_cvt(path);
  f=file_cache_open(path, info->flags);
  signed int *return_value___errno_location_1;
  if(f == NULL)
  {
    return_value___errno_location_1=__errno_location();
    return -(*return_value___errno_location_1);
  }

  else
  {
    file_cache_unref(f);
    return 0;
  }
}

// dav_read
// file ../../../src/fusedav.c line 614
static signed int dav_read(const char *path, char *buf, unsigned long int size, signed long int offset, struct fuse_file_info *info)
{
  void *f = (void *)0;
  signed long int r;
  path=path_cvt(path);
  if(!(debug == 0))
    fprintf(stderr, "read(%s, %lu+%lu)\n", path, (unsigned long int)offset, (unsigned long int)size);

  f=file_cache_get(path);
  signed int return_value_file_cache_read_2;
  if(f == NULL)
  {
    fprintf(stderr, "read() called for closed file\n");
    r = (signed long int)-14;
  }

  else
  {
    return_value_file_cache_read_2=file_cache_read(f, buf, size, offset);
    r = (signed long int)return_value_file_cache_read_2;
    if(!(r >= 0l))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      r = (signed long int)-(*return_value___errno_location_1);
      goto finish;
    }

  }

finish:
  ;
  if(!(f == NULL))
    file_cache_unref(f);

  return (signed int)r;
}

// dav_readdir
// file ../../../src/fusedav.c line 276
static signed int dav_readdir(const char *path, void *buf, signed int (*filler)(void *, const char *, struct stat *, signed long int), signed long int offset, struct fuse_file_info *fi)
{
  struct fill_info f;
  struct ne_session_s *session;
  path=path_cvt(path);
  if(!(debug == 0))
    fprintf(stderr, "getdir(%s)\n", path);

  f.buf = buf;
  f.filler = filler;
  f.root = path;
  filler(buf, ".", (struct stat *)(void *)0, (signed long int)0);
  filler(buf, "..", (struct stat *)(void *)0, (signed long int)0);
  signed int return_value_dir_cache_enumerate_3;
  return_value_dir_cache_enumerate_3=dir_cache_enumerate(path, getdir_cache_callback, (void *)&f);
  if(!(return_value_dir_cache_enumerate_3 >= 0))
  {
    if(!(debug == 0))
      fprintf(stderr, "DIR-CACHE-MISS\n");

    session=session_get(1);
    if(session == ((struct ne_session_s *)NULL))
      return -5;

    dir_cache_begin(path);
    signed int return_value_simple_propfind_with_redirect_2;
    return_value_simple_propfind_with_redirect_2=simple_propfind_with_redirect(session, path, 1, query_properties, getdir_propfind_callback, (void *)&f);
    if(!(return_value_simple_propfind_with_redirect_2 == 0))
    {
      dir_cache_finish(path, 2);
      const char *return_value_ne_get_error_1;
      return_value_ne_get_error_1=ne_get_error(session);
      fprintf(stderr, "PROPFIND failed: %s\n", return_value_ne_get_error_1);
      return -2;
    }

    dir_cache_finish(path, 1);
  }

  return 0;
}

// dav_release
// file ../../../src/fusedav.c line 497
static signed int dav_release(const char *path, struct fuse_file_info *info)
{
  void *f = (void *)0;
  signed int r = 0;
  struct ne_session_s *session;
  path=path_cvt(path);
  if(!(debug == 0))
    fprintf(stderr, "release(%s)\n", path);

  session=session_get(1);
  signed int return_value_file_cache_close_2;
  if(session == ((struct ne_session_s *)NULL))
    r = -5;

  else
  {
    f=file_cache_get(path);
    if(f == NULL)
    {
      fprintf(stderr, "release() called for closed file\n");
      r = -14;
    }

    else
    {
      return_value_file_cache_close_2=file_cache_close(f);
      if(!(return_value_file_cache_close_2 >= 0))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        r = -(*return_value___errno_location_1);
        goto finish;
      }

    }
  }

finish:
  ;
  if(!(f == NULL))
    file_cache_unref(f);

  return r;
}

// dav_removexattr
// file ../../../src/fusedav.c line 1057
static signed int dav_removexattr(const char *path, const char *name)
{
  struct ne_session_s *session;
  struct anonymous_14 propname;
  struct anonymous_15 ops[2l];
  signed int r = 0;
  char dnspace[128l];
  char dname[128l];
  /* assertion path */
  assert(path != ((const char *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  path=path_cvt(path);
  name=fix_xattr(name);
  if(!(debug == 0))
    fprintf(stderr, "removexattr(%s, %s)\n", path, name);

  signed int return_value_parse_xattr_1;
  return_value_parse_xattr_1=parse_xattr(name, dnspace, sizeof(char [128l]) /*128ul*/ , dname, sizeof(char [128l]) /*128ul*/ );
  signed int return_value_proppatch_with_redirect_3;
  if(!(return_value_parse_xattr_1 >= 0))
    r = -61;

  else
  {
    propname.nspace = dnspace;
    propname.name = dname;
    ops[(signed long int)0].name = &propname;
    ops[(signed long int)0].type = (enum ne_proppatch_optype)ne_propremove;
    ops[(signed long int)0].value = (const char *)(void *)0;
    ops[(signed long int)1].name = (const struct anonymous_14 *)(void *)0;
    session=session_get(1);
    if(session == ((struct ne_session_s *)NULL))
      r = -5;

    else
    {
      return_value_proppatch_with_redirect_3=proppatch_with_redirect(session, path, ops);
      if(!(return_value_proppatch_with_redirect_3 == 0))
      {
        const char *return_value_ne_get_error_2;
        return_value_ne_get_error_2=ne_get_error(session);
        fprintf(stderr, "PROPPATCH failed: %s\n", return_value_ne_get_error_2);
        r = -95;
        goto finish;
      }

      stat_cache_invalidate(path);
    }
  }

finish:
  ;
  return r;
}

// dav_rename
// file ../../../src/fusedav.c line 452
static signed int dav_rename(const char *from, const char *to)
{
  struct ne_session_s *session;
  signed int r = 0;
  struct stat st;
  char fn[4096l];
  char *_from;
  const char *return_value_path_cvt_1;
  return_value_path_cvt_1=path_cvt(from);
  _from=strdup(return_value_path_cvt_1);
  from = _from;
  /* assertion from */
  assert(from != ((const char *)NULL));
  to=path_cvt(to);
  if(!(debug == 0))
    fprintf(stderr, "rename(%s, %s)\n", from, to);

  session=session_get(1);
  signed int return_value_ne_move_3;
  if(session == ((struct ne_session_s *)NULL))
    r = -5;

  else
  {
    r=get_stat(from, &st);
    if(r >= 0)
    {
      if((61440u & st.st_mode) == 16384u)
      {
        snprintf(fn, sizeof(char [4096l]) /*4096ul*/ , "%s/", from);
        from = fn;
      }

      return_value_ne_move_3=ne_move(session, 1, from, to);
      if(!(return_value_ne_move_3 == 0))
      {
        const char *return_value_ne_get_error_2;
        return_value_ne_get_error_2=ne_get_error(session);
        fprintf(stderr, "MOVE failed: %s\n", return_value_ne_get_error_2);
        r = -2;
        goto finish;
      }

      stat_cache_invalidate(from);
      stat_cache_invalidate(to);
      dir_cache_invalidate_parent(from);
      dir_cache_invalidate_parent(to);
    }

  }

finish:
  ;
  free((void *)_from);
  return r;
}

// dav_rmdir
// file ../../../src/fusedav.c line 394
static signed int dav_rmdir(const char *path)
{
  char fn[4096l];
  signed int r;
  struct stat st;
  struct ne_session_s *session;
  path=path_cvt(path);
  if(!(debug == 0))
    fprintf(stderr, "rmdir(%s)\n", path);

  session=session_get(1);
  if(session == ((struct ne_session_s *)NULL))
    return -5;

  else
  {
    r=get_stat(path, &st);
    if(!(r >= 0))
      return r;

    else
      if(!((61440u & st.st_mode) == 16384u))
        return -20;

      else
      {
        snprintf(fn, sizeof(char [4096l]) /*4096ul*/ , "%s/", path);
        signed int return_value_ne_delete_2;
        return_value_ne_delete_2=ne_delete(session, fn);
        if(!(return_value_ne_delete_2 == 0))
        {
          const char *return_value_ne_get_error_1;
          return_value_ne_get_error_1=ne_get_error(session);
          fprintf(stderr, "DELETE failed: %s\n", return_value_ne_get_error_1);
          return -2;
        }

        stat_cache_invalidate(path);
        dir_cache_invalidate_parent(path);
        return 0;
      }
  }
}

// dav_setxattr
// file ../../../src/fusedav.c line 984
static signed int dav_setxattr(const char *path, const char *name, const char *value, unsigned long int size, signed int flags)
{
  struct ne_session_s *session;
  struct anonymous_14 propname;
  struct anonymous_15 ops[2l];
  signed int r = 0;
  char dnspace[128l];
  char dname[128l];
  char *value_fixed = (char *)(void *)0;
  /* assertion path */
  assert(path != ((const char *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion value */
  assert(value != ((const char *)NULL));
  path=path_cvt(path);
  name=fix_xattr(name);
  if(!(debug == 0))
    fprintf(stderr, "setxattr(%s, %s)\n", path, name);

  signed int return_value_parse_xattr_1;
  void *return_value_memchr_3;
  signed int return_value_proppatch_with_redirect_5;
  if(!(flags == 0))
    r = 95;

  else
  {
    return_value_parse_xattr_1=parse_xattr(name, dnspace, sizeof(char [128l]) /*128ul*/ , dname, sizeof(char [128l]) /*128ul*/ );
    if(!(return_value_parse_xattr_1 >= 0))
      r = -61;

    else
    {
      propname.nspace = dnspace;
      propname.name = dname;
      return_value_memchr_3=memchr((const void *)value, 0, size);
      if(return_value_memchr_3 == NULL)
      {
        void *return_value_malloc_2;
        return_value_malloc_2=malloc(size + (unsigned long int)1);
        value_fixed = (char *)return_value_malloc_2;
        /* assertion value_fixed */
        assert(value_fixed != ((char *)NULL));
        memcpy((void *)value_fixed, (const void *)value, size);
        value_fixed[(signed long int)size] = (char)0;
        value = value_fixed;
      }

      ops[(signed long int)0].name = &propname;
      ops[(signed long int)0].type = (enum ne_proppatch_optype)ne_propset;
      ops[(signed long int)0].value = value;
      ops[(signed long int)1].name = (const struct anonymous_14 *)(void *)0;
      session=session_get(1);
      if(session == ((struct ne_session_s *)NULL))
        r = -5;

      else
      {
        return_value_proppatch_with_redirect_5=proppatch_with_redirect(session, path, ops);
        if(!(return_value_proppatch_with_redirect_5 == 0))
        {
          const char *return_value_ne_get_error_4;
          return_value_ne_get_error_4=ne_get_error(session);
          fprintf(stderr, "PROPPATCH failed: %s\n", return_value_ne_get_error_4);
          r = -95;
          goto finish;
        }

        stat_cache_invalidate(path);
      }
    }
  }

finish:
  ;
  free((void *)value_fixed);
  return r;
}

// dav_truncate
// file ../../../src/fusedav.c line 669
static signed int dav_truncate(const char *path, signed long int size)
{
  void *f = (void *)0;
  signed int r = 0;
  struct ne_session_s *session;
  path=path_cvt(path);
  if(!(debug == 0))
    fprintf(stderr, "truncate(%s, %lu)\n", path, (unsigned long int)size);

  session=session_get(1);
  if(session == ((struct ne_session_s *)NULL))
    r = -5;

  goto finish;
  f=file_cache_get(path);
  signed int return_value_file_cache_truncate_2;
  if(f == NULL)
  {
    fprintf(stderr, "truncate() called for closed file\n");
    r = -14;
  }

  else
  {
    return_value_file_cache_truncate_2=file_cache_truncate(f, size);
    if(!(return_value_file_cache_truncate_2 >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      r = -(*return_value___errno_location_1);
    }

  }

finish:
  ;
  if(!(f == NULL))
    file_cache_unref(f);

  return r;
}

// dav_unlink
// file ../../../src/fusedav.c line 364
static signed int dav_unlink(const char *path)
{
  signed int r;
  struct stat st;
  struct ne_session_s *session;
  path=path_cvt(path);
  if(!(debug == 0))
    fprintf(stderr, "unlink(%s)\n", path);

  session=session_get(1);
  if(session == ((struct ne_session_s *)NULL))
    return -5;

  else
  {
    r=get_stat(path, &st);
    if(!(r >= 0))
      return r;

    else
      if(!((61440u & st.st_mode) == 32768u))
        return -21;

      else
      {
        signed int return_value_ne_delete_2;
        return_value_ne_delete_2=ne_delete(session, path);
        if(!(return_value_ne_delete_2 == 0))
        {
          const char *return_value_ne_get_error_1;
          return_value_ne_get_error_1=ne_get_error(session);
          fprintf(stderr, "DELETE failed: %s\n", return_value_ne_get_error_1);
          return -2;
        }

        stat_cache_invalidate(path);
        dir_cache_invalidate_parent(path);
        return 0;
      }
  }
}

// dav_utime
// file ../../../src/fusedav.c line 701
static signed int dav_utime(const char *path, struct utimbuf *buf)
{
  struct ne_session_s *session;
  const struct anonymous_14 getlastmodified = { .nspace="DAV:", .name="getlastmodified" };
  struct anonymous_15 ops[2l];
  signed int r = 0;
  char *date;
  /* assertion path */
  assert(path != ((const char *)NULL));
  /* assertion buf */
  assert(buf != ((struct utimbuf *)NULL));
  path=path_cvt(path);
  if(!(debug == 0))
    fprintf(stderr, "utime(%s, %lu, %lu)\n", path, (unsigned long int)buf->actime, (unsigned long int)buf->modtime);

  ops[(signed long int)0].name = &getlastmodified;
  ops[(signed long int)0].type = (enum ne_proppatch_optype)ne_propset;
  date=ne_rfc1123_date(buf->modtime);
  ops[(signed long int)0].value = date;
  ops[(signed long int)1].name = (const struct anonymous_14 *)(void *)0;
  session=session_get(1);
  signed int return_value_proppatch_with_redirect_2;
  if(session == ((struct ne_session_s *)NULL))
    r = -5;

  else
  {
    return_value_proppatch_with_redirect_2=proppatch_with_redirect(session, path, ops);
    if(!(return_value_proppatch_with_redirect_2 == 0))
    {
      const char *return_value_ne_get_error_1;
      return_value_ne_get_error_1=ne_get_error(session);
      fprintf(stderr, "PROPPATCH failed: %s\n", return_value_ne_get_error_1);
      r = -95;
      goto finish;
    }

    stat_cache_invalidate(path);
  }

finish:
  ;
  free((void *)date);
  return r;
}

// dav_write
// file ../../../src/fusedav.c line 641
static signed int dav_write(const char *path, const char *buf, unsigned long int size, signed long int offset, struct fuse_file_info *info)
{
  void *f = (void *)0;
  signed long int r;
  path=path_cvt(path);
  if(!(debug == 0))
    fprintf(stderr, "write(%s, %lu+%lu)\n", path, (unsigned long int)offset, (unsigned long int)size);

  f=file_cache_get(path);
  signed int return_value_file_cache_write_2;
  if(f == NULL)
  {
    fprintf(stderr, "write() called for closed file\n");
    r = (signed long int)-14;
  }

  else
  {
    return_value_file_cache_write_2=file_cache_write(f, buf, size, offset);
    r = (signed long int)return_value_file_cache_write_2;
    if(!(r >= 0l))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      r = (signed long int)-(*return_value___errno_location_1);
      goto finish;
    }

  }

finish:
  ;
  if(!(f == NULL))
    file_cache_unref(f);

  return (signed int)r;
}

// dir_cache_add
// file ../../../src/statcache.h line 34
void dir_cache_add(const char *fn, const char *subdir)
{
  unsigned int h;
  struct cache_entry *ce;
  /* assertion cache */
  assert(cache != ((struct cache_entry *)NULL));
  h=calc_hash(fn);
  ce = cache + (signed long int)(h % (unsigned int)2049);
  pthread_mutex_lock(&dir_cache_mutex);
  signed int return_value_strcmp_3;
  if(!(ce->dir_info.filling == 0))
  {
    if(!(ce->dir_info.filename == ((char *)NULL)))
    {
      if(ce->dir_info.hash == h)
      {
        return_value_strcmp_3=strcmp(ce->dir_info.filename, fn);
        if(return_value_strcmp_3 == 0)
        {
          struct dir_entry *n;
          /* assertion !ce->dir_info.valid2 */
          assert(!(ce->dir_info.valid2 != 0));
          unsigned long int return_value_strlen_1;
          return_value_strlen_1=strlen(subdir);
          void *return_value_malloc_2;
          return_value_malloc_2=malloc(sizeof(struct dir_entry) /*8ul*/  + return_value_strlen_1 + (unsigned long int)1);
          n = (struct dir_entry *)return_value_malloc_2;
          /* assertion n */
          assert(n != ((struct dir_entry *)NULL));
          strcpy(n->filename, subdir);
          n->next = ce->dir_info.entries2;
          ce->dir_info.entries2 = n;
        }

      }

    }

  }

  pthread_mutex_unlock(&dir_cache_mutex);
}

// dir_cache_begin
// file ../../../src/statcache.h line 32
void dir_cache_begin(const char *fn)
{
  unsigned int h;
  struct cache_entry *ce;
  struct dir_entry *de = (struct dir_entry *)(void *)0;
  struct dir_entry *de2 = (struct dir_entry *)(void *)0;
  /* assertion cache */
  assert(cache != ((struct cache_entry *)NULL));
  h=calc_hash(fn);
  ce = cache + (signed long int)(h % (unsigned int)2049);
  pthread_mutex_lock(&dir_cache_mutex);
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(ce->dir_info.filling == 0)
  {
    if(ce->dir_info.filename == ((char *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = ce->dir_info.hash != h ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_strcmp_2=strcmp(ce->dir_info.filename, fn);
      tmp_if_expr_3 = return_value_strcmp_2 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
    {
      free((void *)ce->dir_info.filename);
      ce->dir_info.filename=strdup(fn);
      ce->dir_info.hash = h;
      de = ce->dir_info.entries;
      ce->dir_info.entries = (struct dir_entry *)(void *)0;
      ce->dir_info.valid = 0;
    }

    de2 = ce->dir_info.entries2;
    ce->dir_info.entries2 = (struct dir_entry *)(void *)0;
    ce->dir_info.valid2 = 0;
    ce->dir_info.filling = 1;
  }

  pthread_mutex_unlock(&dir_cache_mutex);
  free_dir_entries(de);
  free_dir_entries(de2);
}

// dir_cache_enumerate
// file ../../../src/statcache.h line 35
signed int dir_cache_enumerate(const char *fn, void (*f)(const char *, const char *, void *), void *user)
{
  unsigned int h;
  struct cache_entry *ce;
  struct dir_entry *de = (struct dir_entry *)(void *)0;
  signed int r = -1;
  /* assertion cache && f */
  assert(cache != ((struct cache_entry *)NULL) && f != ((void (*)(const char *, const char *, void *))NULL));
  h=calc_hash(fn);
  ce = cache + (signed long int)(h % (unsigned int)2049);
  pthread_mutex_lock(&dir_cache_mutex);
  signed int return_value_strcmp_2;
  signed long int return_value_time_1;
  if(!(ce->dir_info.valid == 0))
  {
    if(!(ce->dir_info.filename == ((char *)NULL)))
    {
      if(ce->dir_info.hash == h)
      {
        return_value_strcmp_2=strcmp(ce->dir_info.filename, fn);
        if(return_value_strcmp_2 == 0)
        {
          return_value_time_1=time((signed long int *)(void *)0);
          if(ce->dir_info.dead >= return_value_time_1)
          {
            ce->dir_info.in_use = 1;
            pthread_mutex_unlock(&dir_cache_mutex);
            de = ce->dir_info.entries;
            if(!(de == ((struct dir_entry *)NULL)))
            {
              f(fn, de->filename, user);
              de = de->next;
            }

            pthread_mutex_lock(&dir_cache_mutex);
            ce->dir_info.in_use = 0;
            if(!(ce->dir_info.valid2 == 0))
            {
              de = ce->dir_info.entries;
              ce->dir_info.entries = ce->dir_info.entries2;
              ce->dir_info.entries2 = (struct dir_entry *)(void *)0;
              ce->dir_info.dead = ce->dir_info.dead2;
              ce->dir_info.valid2 = 0;
              ce->dir_info.valid = 1;
            }

            r = 0;
          }

        }

      }

    }

  }

  pthread_mutex_unlock(&dir_cache_mutex);
  free_dir_entries(de);
  return r;
}

// dir_cache_finish
// file ../../../src/statcache.h line 33
void dir_cache_finish(const char *fn, signed int success)
{
  unsigned int h;
  struct cache_entry *ce;
  struct dir_entry *de = (struct dir_entry *)(void *)0;
  /* assertion cache */
  assert(cache != ((struct cache_entry *)NULL));
  h=calc_hash(fn);
  ce = cache + (signed long int)(h % (unsigned int)2049);
  pthread_mutex_lock(&dir_cache_mutex);
  signed int return_value_strcmp_2;
  if(!(ce->dir_info.filling == 0))
  {
    if(!(ce->dir_info.filename == ((char *)NULL)))
    {
      if(ce->dir_info.hash == h)
      {
        return_value_strcmp_2=strcmp(ce->dir_info.filename, fn);
        if(return_value_strcmp_2 == 0)
        {
          /* assertion !ce->dir_info.valid2 */
          assert(!(ce->dir_info.valid2 != 0));
          if(!(success == 0))
          {
            ce->dir_info.valid2 = 1;
            ce->dir_info.filling = 0;
            signed long int return_value_time_1;
            return_value_time_1=time((signed long int *)(void *)0);
            ce->dir_info.dead2 = return_value_time_1 + (signed long int)60;
            if(ce->dir_info.in_use == 0)
            {
              de = ce->dir_info.entries;
              ce->dir_info.entries = ce->dir_info.entries2;
              ce->dir_info.entries2 = (struct dir_entry *)(void *)0;
              ce->dir_info.dead = ce->dir_info.dead2;
              ce->dir_info.valid2 = 0;
              ce->dir_info.valid = 1;
            }

          }

          else
          {
            ce->dir_info.filling = 0;
            de = ce->dir_info.entries2;
            ce->dir_info.entries2 = (struct dir_entry *)(void *)0;
          }
        }

      }

    }

  }

  pthread_mutex_unlock(&dir_cache_mutex);
  free_dir_entries(de);
}

// dir_cache_invalidate
// file ../../../src/statcache.c line 326
void dir_cache_invalidate(const char *fn)
{
  unsigned int h;
  struct cache_entry *ce;
  struct dir_entry *de = (struct dir_entry *)(void *)0;
  /* assertion cache && fn */
  assert(cache != ((struct cache_entry *)NULL) && fn != ((const char *)NULL));
  h=calc_hash(fn);
  ce = cache + (signed long int)(h % (unsigned int)2049);
  pthread_mutex_lock(&dir_cache_mutex);
  signed int return_value_strcmp_1;
  if(!(ce->dir_info.valid == 0))
  {
    if(!(ce->dir_info.filename == ((char *)NULL)))
    {
      if(ce->dir_info.hash == h)
      {
        return_value_strcmp_1=strcmp(ce->dir_info.filename, fn);
        if(return_value_strcmp_1 == 0)
        {
          ce->dir_info.valid = 0;
          de = ce->dir_info.entries;
          ce->dir_info.entries = (struct dir_entry *)(void *)0;
        }

      }

    }

  }

  pthread_mutex_unlock(&dir_cache_mutex);
  free_dir_entries(de);
}

// dir_cache_invalidate_parent
// file ../../../src/statcache.h line 31
void dir_cache_invalidate_parent(const char *fn)
{
  char *p;
  p=ne_path_parent(fn);
  if(!(p == ((char *)NULL)))
  {
    signed int l;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(p);
    l = (signed int)return_value_strlen_1;
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(p, "/");
    if(!(return_value_strcmp_2 == 0))
    {
      if(!(l == 0))
      {
        if((signed int)p[(signed long int)(l + -1)] == 47)
          p[(signed long int)(l - 1)] = (char)0;

      }

    }

    dir_cache_invalidate(p);
    free((void *)p);
  }

  else
    dir_cache_invalidate(fn);
}

// empty_handler
// file ../../../src/fusedav.c line 1190
static void empty_handler(signed int sig)
{
  ;
}

// exit_handler
// file ../../../src/fusedav.c line 1183
static void exit_handler(signed int sig)
{
  if(!(fuse == ((struct fuse *)NULL)))
    fuse_exit(fuse);

  unsigned long int return_value_strlen_1;
  static const char m[23l] = { '*', '*', '*', ' ', 'C', 'a', 'u', 'g', 'h', 't', ' ', 's', 'i', 'g', 'n', 'a', 'l', ' ', '*', '*', '*', '\n', 0 };
  return_value_strlen_1=strlen(m);
  write(2, (const void *)m, return_value_strlen_1);
}

// file_cache_close
// file ../../../src/filecache.h line 32
signed int file_cache_close(void *f)
{
  struct file_info *fi = (struct file_info *)f;
  signed int r = 0;
  /* assertion fi */
  assert(fi != ((struct file_info *)NULL));
  file_cache_unlink((struct file_info *)f);
  pthread_mutex_lock(&fi->mutex);
  fi->dead = 1;
  pthread_mutex_unlock(&fi->mutex);
  return r;
}

// file_cache_close_all
// file ../../../src/filecache.h line 38
signed int file_cache_close_all(void)
{
  signed int r = 0;
  pthread_mutex_lock(&files_mutex);
  while(!(files == ((struct file_info *)NULL)))
  {
    struct file_info *fi = files;
    pthread_mutex_lock(&fi->mutex);
    fi->ref = fi->ref + 1;
    pthread_mutex_unlock(&fi->mutex);
    pthread_mutex_unlock(&files_mutex);
    file_cache_close((void *)fi);
    file_cache_unref((void *)fi);
    pthread_mutex_lock(&files_mutex);
  }
  pthread_mutex_unlock(&files_mutex);
  return r;
}

// file_cache_free_unlocked
// file ../../../src/filecache.c line 95
static void file_cache_free_unlocked(struct file_info *fi)
{
  _Bool tmp_if_expr_1;
  if(!(fi == ((struct file_info *)NULL)))
    tmp_if_expr_1 = fi->dead != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = fi->ref == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  /* assertion fi && fi->dead && fi->ref == 0 */
  assert(tmp_if_expr_2);
  free((void *)fi->filename);
  if(fi->fd >= 0)
    close(fi->fd);

  pthread_mutex_destroy(&fi->mutex);
  free((void *)fi);
}

// file_cache_get
// file ../../../src/filecache.h line 29
void * file_cache_get(const char *path)
{
  struct file_info *f;
  struct file_info *r = (struct file_info *)(void *)0;
  pthread_mutex_lock(&files_mutex);
  f = files;
  signed int return_value_strcmp_1;
  for( ; !(f == ((struct file_info *)NULL)); f = f->next)
  {
    pthread_mutex_lock(&f->mutex);
    if(f->dead == 0)
    {
      if(!(f->filename == ((char *)NULL)))
      {
        return_value_strcmp_1=strcmp(path, f->filename);
        if(return_value_strcmp_1 == 0)
        {
          f->ref = f->ref + 1;
          r = f;
        }

      }

    }

    pthread_mutex_unlock(&f->mutex);
    if(!(r == ((struct file_info *)NULL)))
      break;

  }
  pthread_mutex_unlock(&files_mutex);
  return (void *)f;
}

// file_cache_get_size
// file ../../../src/filecache.h line 40
signed long int file_cache_get_size(void *f)
{
  struct file_info *fi = (struct file_info *)f;
  /* assertion fi */
  assert(fi != ((struct file_info *)NULL));
  return fi->length;
}

// file_cache_open
// file ../../../src/filecache.h line 28
void * file_cache_open(const char *path, signed int flags)
{
  struct file_info *fi = (struct file_info *)(void *)0;
  char tempfile[4096l];
  const char *length = (const char *)(void *)0;
  struct ne_request_s *req = (struct ne_request_s *)(void *)0;
  struct ne_session_s *session;
  session=session_get(1);
  if(session == ((struct ne_session_s *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 5;
    goto fail;
  }

  void *return_value_file_cache_get_2;
  return_value_file_cache_get_2=file_cache_get(path);
  fi = (struct file_info *)return_value_file_cache_get_2;
  signed int return_value_ne_request_dispatch_6;
  signed int return_value_atoi_7;
  if(!(fi == ((struct file_info *)NULL)))
  {
    if(!((00 & flags) == 0) || !((02 & flags) == 0))
      fi->readable = 1;

    if(!((01 & flags) == 0) || !((02 & flags) == 0))
      fi->writable = 1;

    return (void *)fi;
  }

  else
  {
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(sizeof(struct file_info) /*112ul*/ );
    fi = (struct file_info *)return_value_malloc_3;
    memset((void *)fi, 0, sizeof(struct file_info) /*112ul*/ );
    fi->fd = -1;
    fi->filename=strdup(path);
    snprintf(tempfile, sizeof(char [4096l]) /*4096ul*/ , "%s/fusedav-cache-XXXXXX", (const void *)"/tmp");
    fi->fd=mkstemp(tempfile);
    if(fi->fd >= 0)
    {
      unlink(tempfile);
      req=ne_request_create(session, "HEAD", path);
      /* assertion req */
      assert(req != ((struct ne_request_s *)NULL));
      return_value_ne_request_dispatch_6=ne_request_dispatch(req);
      if(!(return_value_ne_request_dispatch_6 == 0))
      {
        const char *return_value_ne_get_error_4;
        return_value_ne_get_error_4=ne_get_error(session);
        fprintf(stderr, "HEAD failed: %s\n", return_value_ne_get_error_4);
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        *return_value___errno_location_5 = 2;
        goto fail;
      }

      length=ne_get_response_header(req, "Content-Length");
      if(length == ((const char *)NULL))
      {
        fi->length = (signed long int)0;
        fi->server_length = fi->length;
      }

      else
      {
        return_value_atoi_7=atoi(length);
        fi->length = (signed long int)return_value_atoi_7;
        fi->server_length = fi->length;
      }
      ne_request_destroy(req);
      if(!((00 & flags) == 0) || !((02 & flags) == 0))
        fi->readable = 1;

      if(!((01 & flags) == 0) || !((02 & flags) == 0))
        fi->writable = 1;

      pthread_mutex_init(&fi->mutex, (const union anonymous_10 *)(void *)0);
      pthread_mutex_lock(&files_mutex);
      fi->next = files;
      files = fi;
      pthread_mutex_unlock(&files_mutex);
      fi->ref = 1;
      return (void *)fi;
    }

    else
    {

    fail:
      ;
      if(!(req == ((struct ne_request_s *)NULL)))
        ne_request_destroy(req);

      if(!(fi == ((struct file_info *)NULL)))
      {
        if(fi->fd >= 0)
          close(fi->fd);

        free((void *)fi->filename);
        free((void *)fi);
      }

      return (void *)0;
    }
  }
}

// file_cache_read
// file ../../../src/filecache.h line 34
signed int file_cache_read(void *f, char *buf, unsigned long int size, signed long int offset)
{
  struct file_info *fi = (struct file_info *)f;
  signed long int r = (signed long int)-1;
  /* assertion fi && buf && size */
  assert(fi != ((struct file_info *)NULL) && buf != ((char *)NULL) && size != 0ul);
  pthread_mutex_lock(&fi->mutex);
  signed int return_value_load_up_to_unlocked_1;
  return_value_load_up_to_unlocked_1=load_up_to_unlocked(fi, (signed long int)((unsigned long int)offset + size));
  if(return_value_load_up_to_unlocked_1 >= 0)
    r=pread(fi->fd, (void *)buf, size, offset);


finish:
  ;
  pthread_mutex_unlock(&fi->mutex);
  return (signed int)r;
}

// file_cache_sync
// file ../../../src/filecache.h line 37
signed int file_cache_sync(void *f)
{
  struct file_info *fi = (struct file_info *)f;
  signed int r = -1;
  /* assertion fi */
  assert(fi != ((struct file_info *)NULL));
  pthread_mutex_lock(&fi->mutex);
  r=file_cache_sync_unlocked(fi);
  pthread_mutex_unlock(&fi->mutex);
  return r;
}

// file_cache_sync_unlocked
// file ../../../src/filecache.c line 346
static signed int file_cache_sync_unlocked(struct file_info *fi)
{
  signed int r = -1;
  struct ne_session_s *session;
  /* assertion fi */
  assert(fi != ((struct file_info *)NULL));
  if(fi->writable == 0)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 9;
    goto finish;
  }

  signed int return_value_load_up_to_unlocked_2;
  signed long int return_value_lseek_3;
  signed int return_value_ne_put_7;
  if(fi->modified == 0)
    r = 0;

  else
  {
    return_value_load_up_to_unlocked_2=load_up_to_unlocked(fi, (signed long int)-1);
    if(return_value_load_up_to_unlocked_2 >= 0)
    {
      return_value_lseek_3=lseek(fi->fd, (signed long int)0, 0);
      if(!(return_value_lseek_3 == -1l))
      {
        session=session_get(1);
        if(session == ((struct ne_session_s *)NULL))
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          *return_value___errno_location_4 = 5;
          goto finish;
        }

        return_value_ne_put_7=ne_put(session, fi->filename, fi->fd);
        if(!(return_value_ne_put_7 == 0))
        {
          const char *return_value_ne_get_error_5;
          return_value_ne_get_error_5=ne_get_error(session);
          fprintf(stderr, "PUT failed: %s\n", return_value_ne_get_error_5);
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          *return_value___errno_location_6 = 2;
          goto finish;
        }

        stat_cache_invalidate(fi->filename);
        dir_cache_invalidate_parent(fi->filename);
        r = 0;
      }

    }

  }

finish:
  ;
  return r;
}

// file_cache_truncate
// file ../../../src/filecache.h line 36
signed int file_cache_truncate(void *f, signed long int s)
{
  struct file_info *fi = (struct file_info *)f;
  signed int r;
  /* assertion fi */
  assert(fi != ((struct file_info *)NULL));
  pthread_mutex_lock(&fi->mutex);
  fi->length = s;
  r=ftruncate(fi->fd, fi->length);
  pthread_mutex_unlock(&fi->mutex);
  return r;
}

// file_cache_unlink
// file ../../../src/filecache.c line 124
static void file_cache_unlink(struct file_info *fi)
{
  struct file_info *s;
  struct file_info *prev;
  /* assertion fi */
  assert(fi != ((struct file_info *)NULL));
  pthread_mutex_lock(&files_mutex);
  s = files;
  prev = (struct file_info *)(void *)0;
  for( ; !(s == ((struct file_info *)NULL)); s = s->next)
  {
    if(s == fi)
    {
      if(!(prev == ((struct file_info *)NULL)))
        prev->next = s->next;

      else
        files = s->next;
      break;
    }

    prev = s;
  }
  pthread_mutex_unlock(&files_mutex);
}

// file_cache_unref
// file ../../../src/filecache.h line 30
void file_cache_unref(void *f)
{
  struct file_info *fi = (struct file_info *)f;
  /* assertion fi */
  assert(fi != ((struct file_info *)NULL));
  pthread_mutex_lock(&fi->mutex);
  /* assertion fi->ref >= 1 */
  assert(fi->ref >= 1);
  fi->ref = fi->ref - 1;
  if(fi->ref == 0)
  {
    if(!(fi->dead == 0))
    {
      file_cache_sync_unlocked(fi);
      file_cache_free_unlocked(fi);
    }

  }

  pthread_mutex_unlock(&fi->mutex);
}

// file_cache_write
// file ../../../src/filecache.h line 35
signed int file_cache_write(void *f, const char *buf, unsigned long int size, signed long int offset)
{
  struct file_info *fi = (struct file_info *)f;
  signed long int r = (signed long int)-1;
  /* assertion fi */
  assert(fi != ((struct file_info *)NULL));
  pthread_mutex_lock(&fi->mutex);
  if(fi->writable == 0)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 9;
    goto finish;
  }

  signed int return_value_load_up_to_unlocked_2;
  return_value_load_up_to_unlocked_2=load_up_to_unlocked(fi, offset);
  if(return_value_load_up_to_unlocked_2 >= 0)
  {
    r=pwrite(fi->fd, (const void *)buf, size, offset);
    if(r >= 0l)
    {
      if(!((unsigned long int)fi->present >= size + (unsigned long int)offset))
        fi->present = (signed long int)((unsigned long int)offset + size);

      if(!((unsigned long int)fi->length >= size + (unsigned long int)offset))
        fi->length = (signed long int)((unsigned long int)offset + size);

      fi->modified = 1;
    }

  }


finish:
  ;
  pthread_mutex_unlock(&fi->mutex);
  return (signed int)r;
}

// fill_stat
// file ../../../src/fusedav.c line 177
static void fill_stat(struct stat *st, const struct ne_prop_result_set_s *results, signed int is_dir)
{
  const char *rt;
  const char *e;
  const char *gcl;
  const char *glm;
  const char *cd;
  const struct anonymous_14 resourcetype = { .nspace="DAV:", .name="resourcetype" };
  const struct anonymous_14 executable = { .nspace="http://apache.org/dav/props/", .name="executable" };
  const struct anonymous_14 getcontentlength = { .nspace="DAV:", .name="getcontentlength" };
  const struct anonymous_14 getlastmodified = { .nspace="DAV:", .name="getlastmodified" };
  const struct anonymous_14 creationdate = { .nspace="DAV:", .name="creationdate" };
  /* assertion st && results */
  assert(st != ((struct stat *)NULL) && results != ((const struct ne_prop_result_set_s *)NULL));
  rt=ne_propset_value(results, &resourcetype);
  e=ne_propset_value(results, &executable);
  gcl=ne_propset_value(results, &getcontentlength);
  glm=ne_propset_value(results, &getlastmodified);
  cd=ne_propset_value(results, &creationdate);
  memset((void *)st, 0, sizeof(struct stat) /*144ul*/ );
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  signed long long int tmp_if_expr_4;
  signed long long int return_value_atoll_3;
  if(!(is_dir == 0))
  {
    st->st_mode = (unsigned int)(0040000 | 0777);
    st->st_nlink = (unsigned long int)3;
    st->st_size = (signed long int)4096;
  }

  else
  {
    if(!(e == ((const char *)NULL)))
    {
      if((signed int)*e == 84)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = (signed int)*e == 116 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    st->st_mode = (unsigned int)(0100000 | (tmp_if_expr_2 ? 0777 : 0666));
    st->st_nlink = (unsigned long int)1;
    if(!(gcl == ((const char *)NULL)))
    {
      return_value_atoll_3=atoll(gcl);
      tmp_if_expr_4 = return_value_atoll_3;
    }

    else
      tmp_if_expr_4 = (signed long int)0;
    st->st_size = tmp_if_expr_4;
  }
  st->st_atim.tv_sec=time((signed long int *)(void *)0);
  signed long int tmp_if_expr_6;
  signed long int return_value_ne_rfc1123_parse_5;
  if(!(glm == ((const char *)NULL)))
  {
    return_value_ne_rfc1123_parse_5=ne_rfc1123_parse(glm);
    tmp_if_expr_6 = return_value_ne_rfc1123_parse_5;
  }

  else
    tmp_if_expr_6 = (signed long int)0;
  st->st_mtim.tv_sec = tmp_if_expr_6;
  signed long int tmp_if_expr_8;
  signed long int return_value_ne_iso8601_parse_7;
  if(!(cd == ((const char *)NULL)))
  {
    return_value_ne_iso8601_parse_7=ne_iso8601_parse(cd);
    tmp_if_expr_8 = return_value_ne_iso8601_parse_7;
  }

  else
    tmp_if_expr_8 = (signed long int)0;
  st->st_ctim.tv_sec = tmp_if_expr_8;
  st->st_blocks = (st->st_size + (signed long int)511) / (signed long int)512;
  st->st_mode = st->st_mode & ~mask;
  st->st_uid=getuid();
  st->st_gid=getgid();
}

// fix_xattr
// file ../../../src/fusedav.c line 740
static const char * fix_xattr(const char *name)
{
  /* assertion name */
  assert(name != ((const char *)NULL));
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(name, "user.mime_type");
  if(return_value_strcmp_1 == 0)
    return "user.webdav(DAV:;getcontenttype)";

  else
    return name;
}

// free_dir_entries
// file ../../../src/statcache.c line 161
static void free_dir_entries(struct dir_entry *de)
{
  while(!(de == ((struct dir_entry *)NULL)))
  {
    struct dir_entry *next = de->next;
    free((void *)de);
    de = next;
  }
}

// get_stat
// file ../../../src/fusedav.c line 335
static signed int get_stat(const char *path, struct stat *stbuf)
{
  struct ne_session_s *session;
  session=session_get(1);
  if(session == ((struct ne_session_s *)NULL))
    return -5;

  else
  {
    signed int return_value_stat_cache_get_3;
    return_value_stat_cache_get_3=stat_cache_get(path, stbuf);
    if(return_value_stat_cache_get_3 == 0)
      return stbuf->st_mode == (unsigned int)0 ? -2 : 0;

    else
    {
      if(!(debug == 0))
        fprintf(stderr, "STAT-CACHE-MISS\n");

      signed int return_value_simple_propfind_with_redirect_2;
      return_value_simple_propfind_with_redirect_2=simple_propfind_with_redirect(session, path, 0, query_properties, getattr_propfind_callback, (void *)stbuf);
      if(!(return_value_simple_propfind_with_redirect_2 == 0))
      {
        stat_cache_invalidate(path);
        const char *return_value_ne_get_error_1;
        return_value_ne_get_error_1=ne_get_error(session);
        fprintf(stderr, "PROPFIND failed: %s\n", return_value_ne_get_error_1);
        return -2;
      }

      return 0;
    }
  }
}

// getattr_propfind_callback
// file ../../../src/fusedav.c line 320
static void getattr_propfind_callback(void *userdata, const struct anonymous_13 *u, const struct ne_prop_result_set_s *results)
{
  struct stat *st = (struct stat *)userdata;
  char fn[4096l];
  signed int is_dir;
  /* assertion st */
  assert(st != ((struct stat *)NULL));
  strncpy(fn, u->path, sizeof(char [4096l]) /*4096ul*/ );
  fn[(signed long int)(sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1)] = (char)0;
  strip_trailing_slash(fn, &is_dir);
  fill_stat(st, results, is_dir);
  stat_cache_set(fn, st);
}

// getdir_cache_callback
// file ../../../src/fusedav.c line 259
static void getdir_cache_callback(const char *root, const char *fn, void *user)
{
  struct fill_info *f = (struct fill_info *)user;
  char path[4096l];
  char *h;
  /* assertion f */
  assert(f != ((struct fill_info *)NULL));
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(root, "/");
  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", !(return_value_strcmp_1 != 0) ? "" : root, fn);
  h=ne_path_unescape(fn);
  f->filler(f->buf, h, (struct stat *)(void *)0, (signed long int)0);
  free((void *)h);
}

// getdir_propfind_callback
// file ../../../src/fusedav.c line 230
static void getdir_propfind_callback(void *userdata, const struct anonymous_13 *u, const struct ne_prop_result_set_s *results)
{
  struct fill_info *f = (struct fill_info *)userdata;
  struct stat st;
  char fn[4096l];
  char *t;
  signed int is_dir = 0;
  /* assertion f */
  assert(f != ((struct fill_info *)NULL));
  strncpy(fn, u->path, sizeof(char [4096l]) /*4096ul*/ );
  fn[(signed long int)(sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1)] = (char)0;
  strip_trailing_slash(fn, &is_dir);
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(fn, f->root);
  if(!(return_value_strcmp_1 == 0))
  {
    if(!(fn[0l] == 0))
    {
      char *h;
      t=strrchr(fn, 47);
      if(!(t == ((char *)NULL)))
        t = t + 1l;

      else
        t = fn;
      dir_cache_add(f->root, t);
      h=ne_path_unescape(t);
      f->filler(f->buf, h, (struct stat *)(void *)0, (signed long int)0);
      free((void *)h);
    }

  }

  fill_stat(&st, results, is_dir);
  stat_cache_set(fn, &st);
}

// getxattr_iterator
// file ../../../src/fusedav.c line 854
static signed int getxattr_iterator(void *userdata, const struct anonymous_14 *pname, const char *value, const struct anonymous_16 *status)
{
  struct getxattr_info *g = (struct getxattr_info *)userdata;
  /* assertion g */
  assert(g != ((struct getxattr_info *)NULL));
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(value == ((const char *)NULL) || pname == ((const struct anonymous_14 *)NULL))
    return -1;

  else
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(pname->nspace, g->propname.nspace);
    if(!(return_value_strcmp_1 == 0))
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_strcmp_2=strcmp(pname->name, g->propname.name);
      tmp_if_expr_3 = return_value_strcmp_2 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      return 0;

    else
    {
      if(!(g->value == ((char *)NULL)))
      {
        unsigned long int l;
        l=strlen(value);
        if(!(g->space >= l))
          l = g->space;

        memcpy((void *)g->value, (const void *)value, l);
        g->size = l;
      }

      else
      {
        g->size=strlen(value);
        return 0;
      }
      return 0;
    }
  }
}

// getxattr_propfind_callback
// file ../../../src/fusedav.c line 891
static void getxattr_propfind_callback(void *userdata, const struct anonymous_13 *u, const struct ne_prop_result_set_s *results)
{
  struct getxattr_info *g = (struct getxattr_info *)userdata;
  ne_propset_iterate(results, getxattr_iterator, (void *)g);
}

// listxattr_iterator
// file ../../../src/fusedav.c line 754
static signed int listxattr_iterator(void *userdata, const struct anonymous_14 *pname, const char *value, const struct anonymous_16 *status)
{
  struct listxattr_info *l = (struct listxattr_info *)userdata;
  signed int n;
  /* assertion l */
  assert(l != ((struct listxattr_info *)NULL));
  if(value == ((const char *)NULL) || pname == ((const struct anonymous_14 *)NULL))
    return -1;

  else
    if(!(l->list == ((char *)NULL)))
    {
      signed int return_value_snprintf_1;
      return_value_snprintf_1=snprintf(l->list, l->space, "user.webdav(%s;%s)", pname->nspace, pname->name);
      n = return_value_snprintf_1 + 1;
      if(n >= (signed int)l->space)
      {
        l->size = l->size + l->space;
        l->space = (unsigned long int)0;
        return 1;
      }

      else
      {
        l->size = l->size + (unsigned long int)n;
        l->space = l->space - (unsigned long int)n;
        if(!(l->list == ((char *)NULL)))
          l->list = l->list + (signed long int)n;

        return 0;
      }
    }

    else
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(pname->nspace);
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(pname->name);
      l->size = l->size + return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)15;
      return 0;
    }
}

// listxattr_propfind_callback
// file ../../../src/fusedav.c line 793
static void listxattr_propfind_callback(void *userdata, const struct anonymous_13 *u, const struct ne_prop_result_set_s *results)
{
  struct listxattr_info *l = (struct listxattr_info *)userdata;
  ne_propset_iterate(results, listxattr_iterator, (void *)l);
}

// load_up_to_unlocked
// file ../../../src/filecache.c line 235
static signed int load_up_to_unlocked(struct file_info *fi, signed long int l)
{
  struct anonymous_11 range;
  struct ne_session_s *session;
  /* assertion fi */
  assert(fi != ((struct file_info *)NULL));
  session=session_get(1);
  if(session == ((struct ne_session_s *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 5;
    return -1;
  }

  if(!(fi->server_length >= l))
    l = fi->server_length;

  if(fi->present >= l)
    return 0;

  else
  {
    signed long int return_value_lseek_2;
    return_value_lseek_2=lseek(fi->fd, fi->present, 0);
    if(!(return_value_lseek_2 == fi->present))
      return -1;

    else
    {
      range.start = fi->present;
      range.end = l - (signed long int)1;
      range.total = (signed long int)0;
      signed int return_value_ne_get_range_5;
      return_value_ne_get_range_5=ne_get_range(session, fi->filename, &range, fi->fd);
      if(!(return_value_ne_get_range_5 == 0))
      {
        const char *return_value_ne_get_error_3;
        return_value_ne_get_error_3=ne_get_error(session);
        fprintf(stderr, "GET failed: %s\n", return_value_ne_get_error_3);
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        *return_value___errno_location_4 = 2;
        return -1;
      }

      fi->present = l;
      return 0;
    }
  }
}

// lock_thread_func
// file ../../../src/fusedav.c line 1317
static void * lock_thread_func(void *p)
{
  struct ne_session_s *session;
  struct anonymous_17 block;
  if(!(debug == 0))
    fprintf(stderr, "lock_thread entering\n");

  session=session_get(1);
  if(session == ((struct ne_session_s *)NULL))
    return (void *)0;

  else
  {
    sigemptyset(&block);
    sigaddset(&block, 10);
    /* assertion lock */
    assert(lock != ((struct ne_lock *)NULL));
    while(lock_thread_exit == 0)
    {
      signed int r;
      signed int t;
      lock->timeout = (signed long int)lock_timeout;
      pthread_sigmask(0, &block, (struct anonymous_17 *)(void *)0);
      r=ne_lock_refresh(session, lock);
      pthread_sigmask(1, &block, (struct anonymous_17 *)(void *)0);
      if(!(r == 0))
      {
        const char *return_value_ne_get_error_1;
        return_value_ne_get_error_1=ne_get_error(session);
        fprintf(stderr, "LOCK refresh failed: %s\n", return_value_ne_get_error_1);
        break;
      }

      if(!(lock_thread_exit == 0))
        break;

      t = lock_timeout / 2;
      if(!(t >= 1))
        t = 1;

      sleep((unsigned int)t);
    }
    if(!(debug == 0))
      fprintf(stderr, "lock_thread exiting\n");

    return (void *)0;
  }
}

// main
// file ../../../src/fusedav.c line 1361
signed int main(signed int argc, char **argv)
{
  signed int c;
  char *u = (char *)(void *)0;
  char *p = (char *)(void *)0;
  char *o = (char *)(void *)0;
  signed int fuse_fd = -1;
  signed int ret = 1;
  char mountpoint[4096l];
  unsigned long int lock_thread;
  signed int lock_thread_running = 0;
  signed int enable_locking = 0;
  static char *mount_args_strings[4l] = { (char *)(void *)0, (char *)(void *)0, (char *)(void *)0, (char *)(void *)0 };
  struct fuse_args mount_args = { .argc=1, .argv=mount_args_strings, .allocated=0 };
  signed int return_value_ne_sock_init_1;
  return_value_ne_sock_init_1=ne_sock_init();
  signed int return_value_ne_has_support_2;
  _Bool tmp_if_expr_4;
  signed int return_value_ne_has_support_3;
  _Bool tmp_if_expr_5;
  signed int return_value_setup_signal_handlers_6;
  signed int return_value_session_set_uri_7;
  signed int return_value_create_lock_9;
  if(!(return_value_ne_sock_init_1 == 0))
    fprintf(stderr, "Failed to initialize libneon.\n");

  else
  {
    return_value_ne_has_support_2=ne_has_support(1);
    if(return_value_ne_has_support_2 == 0)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_ne_has_support_3=ne_has_support(6);
      tmp_if_expr_4 = !(return_value_ne_has_support_3 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !((_Bool)1) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      fprintf(stderr, "fusedav requires libneon built with SSL, SSL thread safety and LFS enabled.\n");

    else
    {
      mask=umask((unsigned int)0);
      umask(mask);
      cache_alloc();
      return_value_setup_signal_handlers_6=setup_signal_handlers();
      if(return_value_setup_signal_handlers_6 >= 0)
      {
        do
        {
          c=getopt(argc, argv, "hu:p:Do:Lt:");
          if(c == -1)
            break;

          switch(c)
          {
            case 117:
            {
              u = optarg;
              break;
            }
            case 112:
            {
              p = optarg;
              break;
            }
            case 68:
            {
              debug = (signed int)!(debug != 0);
              break;
            }
            case 111:
            {
              o = optarg;
              break;
            }
            case 76:
            {
              enable_locking = 1;
              break;
            }
            case 116:
            {
              lock_timeout=atoi(optarg);
              if(!(lock_timeout >= 0))
              {
                fprintf(stderr, "Invalid lock timeout '%s'\n", optarg);
                goto finish;
              }

              break;
            }
            case 104:
              ret = 0;
            default:
            {
              usage(argv[(signed long int)0]);
              goto finish;
            }
          }
        }
        while((_Bool)1);
        if(!(optind == argc + -2))
          usage(argv[(signed long int)0]);

        else
        {
          return_value_session_set_uri_7=session_set_uri(argv[(signed long int)optind], u, p);
          if(!(return_value_session_set_uri_7 >= 0))
            usage(argv[(signed long int)0]);

          else
          {
            if((signed int)*argv[(signed long int)(1 + optind)] == 47)
              snprintf(mountpoint, sizeof(char [4096l]) /*4096ul*/ , "%s", argv[(signed long int)(optind + 1)]);

            else
            {
              char *pwd;
              pwd=get_current_dir_name();
              snprintf(mountpoint, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", pwd, argv[(signed long int)(optind + 1)]);
              free((void *)pwd);
            }
            mount_args_strings[(signed long int)0] = argv[(signed long int)optind];
            if(!(o == ((char *)NULL)))
            {
              mount_args_strings[(signed long int)1] = (char *)"-o";
              mount_args_strings[(signed long int)2] = o;
              mount_args.argc = mount_args.argc + 2;
            }

            fuse_fd=fuse_mount_compat25(mountpoint, &mount_args);
            if(!(fuse_fd >= 0))
              fprintf(stderr, "Failed to mount FUSE file system.\n");

            else
            {
              fuse=fuse_new_compat25(fuse_fd, &mount_args, &dav_oper, sizeof(struct fuse_operations_compat25) /*280ul*/ );
              if(fuse == ((struct fuse *)NULL))
                fprintf(stderr, "Failed to create FUSE object.\n");

              else
              {
                if(!(enable_locking == 0))
                {
                  return_value_create_lock_9=create_lock();
                  if(return_value_create_lock_9 >= 0)
                  {
                    signed int r;
                    r=pthread_create(&lock_thread, (const union pthread_attr_t *)(void *)0, lock_thread_func, (void *)0);
                    if(!(r >= 0))
                    {
                      char *return_value_strerror_8;
                      return_value_strerror_8=strerror(r);
                      fprintf(stderr, "pthread_create(): %s\n", return_value_strerror_8);
                      goto finish;
                    }

                    lock_thread_running = 1;
                  }

                }

                fuse_loop_mt(fuse);
                if(!(debug == 0))
                  fprintf(stderr, "Exiting cleanly.\n");

                ret = 0;
              }
            }
          }
        }
      }

    }
  }

finish:
  ;
  if(!(lock_thread_running == 0))
  {
    lock_thread_exit = 1;
    pthread_kill(lock_thread, 10);
    pthread_join(lock_thread, (void **)(void *)0);
    remove_lock();
    ne_lockstore_destroy(lock_store);
  }

  if(!(fuse == ((struct fuse *)NULL)))
    fuse_destroy(fuse);

  if(fuse_fd >= 0)
    fuse_unmount_compat22(mountpoint);

  file_cache_close_all();
  cache_free();
  session_free();
  return ret;
}

// ne_auth_creds_cb
// file ../../../src/session.c line 97
static signed int ne_auth_creds_cb(void *userdata, const char *realm, signed int attempt, char *u, char *p)
{
  signed int r = -1;
  pthread_mutex_lock(&credential_mutex);
  if(!(attempt == 0))
  {
    fprintf(stderr, "Authentication failure!\n");
    free((void *)username);
    free((void *)password);
    password = (char *)(void *)0;
    username = password;
  }

  if(password == ((char *)NULL) || username == ((char *)NULL))
    fprintf(stderr, "Realm '%s' requires authentication.\n", realm);

  if(username == ((char *)NULL))
    username=ask_user("Username", 0);

  if(password == ((char *)NULL) && !(username == ((char *)NULL)))
    password=ask_user("Password", 1);

  if(!(password == ((char *)NULL)) && !(username == ((char *)NULL)))
  {
    snprintf(u, (unsigned long int)256, "%s", username);
    snprintf(p, (unsigned long int)256, "%s", password);
    r = 0;
  }

  pthread_mutex_unlock(&credential_mutex);
  return r;
}

// parse_xattr
// file ../../../src/fusedav.c line 896
static signed int parse_xattr(const char *name, char *dnspace, unsigned long int dnspace_length, char *dname, unsigned long int dname_length)
{
  char *e;
  unsigned long int k;
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion dnspace */
  assert(dnspace != ((char *)NULL));
  /* assertion dnspace_length */
  assert(dnspace_length != 0ul);
  /* assertion dname */
  assert(dname != ((char *)NULL));
  /* assertion dname_length */
  assert(dname_length != 0ul);
  signed int return_value_strncmp_1;
  return_value_strncmp_1=strncmp(name, "user.webdav(", (unsigned long int)12);
  _Bool tmp_if_expr_3;
  unsigned long int return_value_strlen_2;
  if(!(return_value_strncmp_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strlen_2=strlen(name);
    tmp_if_expr_3 = (signed int)name[(signed long int)(return_value_strlen_2 - (unsigned long int)1)] != 41 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    e=strchr(name + (signed long int)12, 59);
    tmp_if_expr_4 = !(e != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_4)
    return -1;

  else
  {
    k=strcspn(name + (signed long int)12, ";");
    if(!(dnspace_length + 18446744073709551615ul >= k))
      return -1;

    else
    {
      memcpy((void *)dnspace, (const void *)(name + (signed long int)12), k);
      dnspace[(signed long int)k] = (char)0;
      e = e + 1l;
      k=strlen(e);
      if(!(dname_length + 18446744073709551615ul >= k))
        return -1;

      else
      {
        /* assertion k > 0 */
        assert(k > (unsigned long int)0);
        k = k - 1ul;
        memcpy((void *)dname, (const void *)e, k);
        dname[(signed long int)k] = (char)0;
        return 0;
      }
    }
  }
}

// path_cvt
// file ../../../src/fusedav.c line 93
static const char * path_cvt(const char *path)
{
  char *r;
  char *t;
  signed int l;
  pthread_once(&path_cvt_once, path_cvt_tsd_key_init);
  void *return_value_pthread_getspecific_1;
  return_value_pthread_getspecific_1=pthread_getspecific(path_cvt_tsd_key);
  r = (char *)return_value_pthread_getspecific_1;
  if(!(r == ((char *)NULL)))
    free((void *)r);

  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(base_directory);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(path);
  l = (signed int)(return_value_strlen_2 + return_value_strlen_3);
  void *return_value_malloc_4;
  return_value_malloc_4=malloc((unsigned long int)(l + 1));
  t = (char *)return_value_malloc_4;
  /* assertion t */
  assert(t != ((char *)NULL));
  sprintf(t, "%s%s", base_directory, path);
  if(l >= 2)
  {
    if((signed int)t[(signed long int)(l + -1)] == 47)
      t[(signed long int)(l - 1)] = (char)0;

  }

  r=ne_path_escape(t);
  free((void *)t);
  pthread_setspecific(path_cvt_tsd_key, (const void *)r);
  return r;
}

// path_cvt_tsd_key_init
// file ../../../src/fusedav.c line 89
static void path_cvt_tsd_key_init(void)
{
  pthread_key_create(&path_cvt_tsd_key, free);
}

// proppatch_with_redirect
// file ../../../src/fusedav.c line 148
static signed int proppatch_with_redirect(struct ne_session_s *session, const char *path, const struct anonymous_15 *ops)
{
  signed int i;
  signed int ret;
  i = 0;
  for( ; !(i >= 10); i = i + 1)
  {
    const struct anonymous_13 *u;
    ret=ne_proppatch(session, path, ops);
    if(!(ret == 9))
      return ret;

    u=ne_redirect_location(session);
    if(u == ((const struct anonymous_13 *)NULL))
      break;

    signed int return_value_session_is_local_1;
    return_value_session_is_local_1=session_is_local(u);
    if(return_value_session_is_local_1 == 0)
      break;

    if(!(debug == 0))
      fprintf(stderr, "REDIRECT FROM '%s' to '%s'\n", path, u->path);

    path = u->path;
  }
  return ret;
}

// remove_lock
// file ../../../src/fusedav.c line 1298
static signed int remove_lock(void)
{
  struct ne_session_s *session;
  /* assertion lock */
  assert(lock != ((struct ne_lock *)NULL));
  session=session_get(0);
  if(session == ((struct ne_session_s *)NULL))
    return -1;

  else
  {
    if(!(debug == 0))
      fprintf(stderr, "Removing lock...\n");

    signed int return_value_ne_unlock_2;
    return_value_ne_unlock_2=ne_unlock(session, lock);
    if(!(return_value_ne_unlock_2 == 0))
    {
      const char *return_value_ne_get_error_1;
      return_value_ne_get_error_1=ne_get_error(session);
      fprintf(stderr, "UNLOCK failed: %s\n", return_value_ne_get_error_1);
      return -1;
    }

    return 0;
  }
}

// session_destroy
// file ../../../src/session.c line 154
static void session_destroy(void *s)
{
  struct ne_session_s *session = (struct ne_session_s *)s;
  /* assertion s */
  assert(s != NULL);
  ne_session_destroy(session);
}

// session_free
// file ../../../src/session.h line 29
void session_free(void)
{
  if(!(b_uri == 0))
  {
    ne_uri_free(&uri);
    b_uri = 0;
  }

  free((void *)(char *)username);
  free((void *)(char *)password);
  free((void *)(char *)base_directory);
  base_directory = (char *)(void *)0;
  password = base_directory;
  username = password;
}

// session_get
// file ../../../src/session.h line 27
struct ne_session_s * session_get(signed int with_lock)
{
  struct ne_session_s *session;
  pthread_once(&session_once, session_tsd_key_init);
  void *return_value_pthread_getspecific_1;
  return_value_pthread_getspecific_1=pthread_getspecific(session_tsd_key);
  session = (struct ne_session_s *)return_value_pthread_getspecific_1;
  if(!(session == ((struct ne_session_s *)NULL)))
    return session;

  else
  {
    session=session_open(with_lock);
    pthread_setspecific(session_tsd_key, (const void *)session);
    return session;
  }
}

// session_is_local
// file ../../../src/session.h line 31
signed int session_is_local(const struct anonymous_13 *u)
{
  /* assertion u */
  assert(u != ((const struct anonymous_13 *)NULL));
  /* assertion b_uri */
  assert(b_uri != 0);
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(u->scheme, uri.scheme);
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(return_value_strcmp_1 == 0)
  {
    return_value_strcmp_2=strcmp(u->host, uri.host);
    tmp_if_expr_3 = return_value_strcmp_2 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = u->port == uri.port ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  return (signed int)tmp_if_expr_4;
}

// session_open
// file ../../../src/session.c line 128
static struct ne_session_s * session_open(signed int with_lock)
{
  const char *scheme = (const char *)(void *)0;
  struct ne_session_s *session;
  unsigned int tmp_if_expr_2;
  unsigned int return_value_ne_uri_defaultport_1;
  if(b_uri == 0)
    return (struct ne_session_s *)(void *)0;

  else
  {
    scheme = uri.scheme != ((char *)NULL) ? uri.scheme : "http";
    if(!(uri.port == 0u))
      tmp_if_expr_2 = uri.port;

    else
    {
      return_value_ne_uri_defaultport_1=ne_uri_defaultport(scheme);
      tmp_if_expr_2 = return_value_ne_uri_defaultport_1;
    }
    session=ne_session_create(scheme, uri.host, tmp_if_expr_2);
    if(session == ((struct ne_session_s *)NULL))
    {
      fprintf(stderr, "Failed to create session\n");
      return (struct ne_session_s *)(void *)0;
    }

    else
    {
      ne_ssl_set_verify(session, ssl_verify_cb, (void *)0);
      ne_set_server_auth(session, ne_auth_creds_cb, (void *)0);
      ne_redirect_register(session);
      if(!(lock_store == ((struct ne_lock_store_s *)NULL)) && !(with_lock == 0))
        ne_lockstore_register(lock_store, session);

      return session;
    }
  }
}

// session_set_uri
// file ../../../src/session.h line 28
signed int session_set_uri(const char *s, const char *u, const char *p)
{
  signed int l;
  /* assertion !b_uri */
  assert(!(b_uri != 0));
  /* assertion !username */
  assert(!(username != ((char *)NULL)));
  /* assertion !password */
  assert(!(password != ((char *)NULL)));
  signed int return_value_ne_uri_parse_1;
  return_value_ne_uri_parse_1=ne_uri_parse(s, &uri);
  unsigned long int return_value_strlen_2;
  if(!(return_value_ne_uri_parse_1 == 0))
    fprintf(stderr, "Invalid URI <%s>\n", s);

  else
  {
    b_uri = 1;
    if(uri.host == ((char *)NULL))
      fprintf(stderr, "Missing host part in URI <%s>\n", s);

    else
    {
      base_directory=strdup(uri.path);
      return_value_strlen_2=strlen(base_directory);
      l = (signed int)return_value_strlen_2;
      if((signed int)base_directory[(signed long int)(l + -1)] == 47)
        ((char *)base_directory)[(signed long int)(l - 1)] = (char)0;

      if(!(u == ((const char *)NULL)))
        username=strdup(u);

      if(!(p == ((const char *)NULL)))
        password=strdup(p);

      return 0;
    }
  }

finish:
  ;
  if(!(b_uri == 0))
  {
    ne_uri_free(&uri);
    b_uri = 0;
  }

  return -1;
}

// session_tsd_key_init
// file ../../../src/session.c line 160
static void session_tsd_key_init(void)
{
  pthread_key_create(&session_tsd_key, session_destroy);
}

// setup_signal_handlers
// file ../../../src/fusedav.c line 1192
static signed int setup_signal_handlers(void)
{
  struct sigaction sa;
  struct anonymous_17 m;
  sa.__sigaction_handler.sa_handler = exit_handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = 0;
  signed int return_value_sigaction_3;
  return_value_sigaction_3=sigaction(1, &sa, (struct sigaction *)(void *)0);
  _Bool tmp_if_expr_5;
  signed int return_value_sigaction_4;
  if(return_value_sigaction_3 == -1)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_sigaction_4=sigaction(2, &sa, (struct sigaction *)(void *)0);
    tmp_if_expr_5 = return_value_sigaction_4 == -1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_7;
  signed int return_value_sigaction_6;
  if(tmp_if_expr_5)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_sigaction_6=sigaction(15, &sa, (struct sigaction *)(void *)0);
    tmp_if_expr_7 = return_value_sigaction_6 == -1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_7)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "Cannot set exit signal handlers: %s\n", return_value_strerror_2);
    return -1;
  }

  sa.__sigaction_handler.sa_handler = (void (*)(signed int))1;
  signed int return_value_sigaction_10;
  return_value_sigaction_10=sigaction(13, &sa, (struct sigaction *)(void *)0);
  if(return_value_sigaction_10 == -1)
  {
    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    char *return_value_strerror_9;
    return_value_strerror_9=strerror(*return_value___errno_location_8);
    fprintf(stderr, "Cannot set ignored signals: %s\n", return_value_strerror_9);
    return -1;
  }

  sa.__sigaction_handler.sa_handler = empty_handler;
  signed int return_value_sigaction_13;
  return_value_sigaction_13=sigaction(10, &sa, (struct sigaction *)(void *)0);
  if(return_value_sigaction_13 == -1)
  {
    signed int *return_value___errno_location_11;
    return_value___errno_location_11=__errno_location();
    char *return_value_strerror_12;
    return_value_strerror_12=strerror(*return_value___errno_location_11);
    fprintf(stderr, "Cannot set user signals: %s\n", return_value_strerror_12);
    return -1;
  }

  sigemptyset(&m);
  pthread_sigmask(0, &m, &m);
  sigdelset(&m, 1);
  sigdelset(&m, 2);
  sigdelset(&m, 15);
  sigaddset(&m, 13);
  sigaddset(&m, 10);
  pthread_sigmask(2, &m, (struct anonymous_17 *)(void *)0);
  return 0;
}

// simple_propfind_with_redirect
// file ../../../src/fusedav.c line 117
static signed int simple_propfind_with_redirect(struct ne_session_s *session, const char *path, signed int depth, const struct anonymous_14 *props, void (*results)(void *, const struct anonymous_13 *, const struct ne_prop_result_set_s *), void *userdata)
{
  signed int i;
  signed int ret;
  i = 0;
  for( ; !(i >= 10); i = i + 1)
  {
    const struct anonymous_13 *u;
    ret=ne_simple_propfind(session, path, depth, props, results, userdata);
    if(!(ret == 9))
      return ret;

    u=ne_redirect_location(session);
    if(u == ((const struct anonymous_13 *)NULL))
      break;

    signed int return_value_session_is_local_1;
    return_value_session_is_local_1=session_is_local(u);
    if(return_value_session_is_local_1 == 0)
      break;

    if(!(debug == 0))
      fprintf(stderr, "REDIRECT FROM '%s' to '%s'\n", path, u->path);

    path = u->path;
  }
  return ret;
}

// ssl_verify_cb
// file ../../../src/session.c line 93
static signed int ssl_verify_cb(void *userdata, signed int failures, const struct ne_ssl_certificate_s *cert)
{
  return 0;
}

// stat_cache_get
// file ../../../src/statcache.h line 26
signed int stat_cache_get(const char *fn, struct stat *st)
{
  unsigned int h;
  struct cache_entry *ce;
  signed int r = -1;
  void *f;
  if(!(debug == 0))
    fprintf(stderr, "CGET: %s\n", fn);

  /* assertion cache */
  assert(cache != ((struct cache_entry *)NULL));
  h=calc_hash(fn);
  ce = cache + (signed long int)(h % (unsigned int)2049);
  pthread_mutex_lock(&stat_cache_mutex);
  signed int return_value_strcmp_2;
  signed long int return_value_time_1;
  if(!(ce->stat_info.valid == 0))
  {
    if(!(ce->stat_info.filename == ((char *)NULL)))
    {
      if(ce->stat_info.hash == h)
      {
        return_value_strcmp_2=strcmp(ce->stat_info.filename, fn);
        if(return_value_strcmp_2 == 0)
        {
          return_value_time_1=time((signed long int *)(void *)0);
          if(ce->stat_info.dead >= return_value_time_1)
          {
            *st = ce->stat_info.st;
            f=file_cache_get(fn);
            if(!(f == NULL))
            {
              st->st_size=file_cache_get_size(f);
              file_cache_unref(f);
            }

            r = 0;
          }

        }

      }

    }

  }

  pthread_mutex_unlock(&stat_cache_mutex);
  return r;
}

// stat_cache_invalidate
// file ../../../src/statcache.h line 28
void stat_cache_invalidate(const char *fn)
{
  unsigned int h;
  struct cache_entry *ce;
  /* assertion cache */
  assert(cache != ((struct cache_entry *)NULL));
  h=calc_hash(fn);
  ce = cache + (signed long int)(h % (unsigned int)2049);
  pthread_mutex_lock(&stat_cache_mutex);
  ce->stat_info.valid = 0;
  free((void *)ce->stat_info.filename);
  ce->stat_info.filename = (char *)(void *)0;
  pthread_mutex_unlock(&stat_cache_mutex);
}

// stat_cache_set
// file ../../../src/statcache.h line 27
void stat_cache_set(const char *fn, struct stat *st)
{
  unsigned int h;
  struct cache_entry *ce;
  if(!(debug == 0))
    fprintf(stderr, "CSET: %s\n", fn);

  /* assertion cache */
  assert(cache != ((struct cache_entry *)NULL));
  h=calc_hash(fn);
  ce = cache + (signed long int)(h % (unsigned int)2049);
  pthread_mutex_lock(&stat_cache_mutex);
  _Bool tmp_if_expr_1;
  if(ce->stat_info.filename == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ce->stat_info.hash != h ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(tmp_if_expr_1)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strcmp_2=strcmp(ce->stat_info.filename, fn);
    tmp_if_expr_3 = return_value_strcmp_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
  {
    free((void *)ce->stat_info.filename);
    ce->stat_info.filename=strdup(fn);
    ce->stat_info.hash = h;
  }

  ce->stat_info.st = *st;
  signed long int return_value_time_4;
  return_value_time_4=time((signed long int *)(void *)0);
  ce->stat_info.dead = return_value_time_4 + (signed long int)60;
  ce->stat_info.valid = 1;
  pthread_mutex_unlock(&stat_cache_mutex);
}

// strip_trailing_slash
// file ../../../src/fusedav.c line 218
static char * strip_trailing_slash(char *fn, signed int *is_dir)
{
  unsigned long int l;
  l=strlen(fn);
  /* assertion fn */
  assert(fn != ((char *)NULL));
  /* assertion is_dir */
  assert(is_dir != ((signed int *)NULL));
  /* assertion l > 0 */
  assert(l > (unsigned long int)0);
  *is_dir = (signed int)((signed int)fn[(signed long int)(l - (unsigned long int)1)] == 47);
  if(!(*is_dir == 0))
    fn[(signed long int)(l - (unsigned long int)1)] = (char)0;

  return fn;
}

// usage
// file ../../../src/fusedav.c line 1163
static void usage(char *argv0)
{
  char *e;
  e=strrchr(argv0, 47);
  if(!(e == ((char *)NULL)))
    e = e + 1l;

  else
    e = argv0;
  fprintf(stderr, "%s [-hDL] [-t SECS] [-u USERNAME] [-p PASSWORD] [-o OPTIONS] URL MOUNTPOINT\n\t-h Show this help\n\t-D Enable debug mode\n\t-u Username if required\n\t-p Password if required\n\t-o Additional FUSE mount options\n\t-L Locking the repository during mount\n\t-t Set lock timeout\n", e);
}

