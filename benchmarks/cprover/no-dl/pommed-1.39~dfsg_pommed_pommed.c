// #anon_enum$DBUS_BUS_SESSION=0$DBUS_BUS_SYSTEM=1$DBUS_BUS_STARTER=2
// file /usr/include/dbus-1.0/dbus/dbus-shared.h line 56
enum anonymous$2 { DBUS_BUS_SESSION=0, DBUS_BUS_SYSTEM=1, DBUS_BUS_STARTER=2 };

// #anon_enum$DBUS_DISPATCH_DATA_REMAINS=0$DBUS_DISPATCH_COMPLETE=1$DBUS_DISPATCH_NEED_MEMORY=2
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 79
enum anonymous$1 { DBUS_DISPATCH_DATA_REMAINS=0, DBUS_DISPATCH_COMPLETE=1, DBUS_DISPATCH_NEED_MEMORY=2 };

// #anon_enum$DBUS_HANDLER_RESULT_HANDLED=0$DBUS_HANDLER_RESULT_NOT_YET_HANDLED=1$DBUS_HANDLER_RESULT_NEED_MEMORY=2
// file /usr/include/dbus-1.0/dbus/dbus-shared.h line 66
enum anonymous { DBUS_HANDLER_RESULT_HANDLED=0, DBUS_HANDLER_RESULT_NOT_YET_HANDLED=1, DBUS_HANDLER_RESULT_NEED_MEMORY=2 };

// #anon_enum$MACHINE_ERROR=-3$MACHINE_UNKNOWN=-2$MACHINE_MAC_UNKNOWN=-1$MACHINE_MACBOOKPRO_1=0$MACHINE_MACBOOKPRO_2=1$MACHINE_MACBOOKPRO_3=2$MACHINE_MACBOOKPRO_4=3$MACHINE_MACBOOKPRO_5=4$MACHINE_MACBOOKPRO_6=5$MACHINE_MACBOOKPRO_7=6$MACHINE_MACBOOKPRO_8=7$MACHINE_MACBOOKPRO_9=8$MACHINE_MACBOOK_1=9$MACHINE_MACBOOK_2=10$MACHINE_MACBOOK_3=11$MACHINE_MACBOOK_4=12$MACHINE_MACBOOK_5=13$MACHINE_MACBOOK_6=14$MACHINE_MACBOOK_7=15$MACHINE_MACBOOKAIR_1=16$MACHINE_MACBOOKAIR_2=17$MACHINE_MACBOOKAIR_3=18$MACHINE_LAST=19
// file pommed.h line 27
enum anonymous$3 { MACHINE_ERROR=-3, MACHINE_UNKNOWN=-2, MACHINE_MAC_UNKNOWN=-1, MACHINE_MACBOOKPRO_1=0, MACHINE_MACBOOKPRO_2=1, MACHINE_MACBOOKPRO_3=2, MACHINE_MACBOOKPRO_4=3, MACHINE_MACBOOKPRO_5=4, MACHINE_MACBOOKPRO_6=5, MACHINE_MACBOOKPRO_7=6, MACHINE_MACBOOKPRO_8=7, MACHINE_MACBOOKPRO_9=8, MACHINE_MACBOOK_1=9, MACHINE_MACBOOK_2=10, MACHINE_MACBOOK_3=11, MACHINE_MACBOOK_4=12, MACHINE_MACBOOK_5=13, MACHINE_MACBOOK_6=14, MACHINE_MACBOOK_7=15, MACHINE_MACBOOKAIR_1=16, MACHINE_MACBOOKAIR_2=17, MACHINE_MACBOOKAIR_3=18, MACHINE_LAST=19 };

// #anon_enum$cfg_false=0$cfg_true=1
// file /usr/include/confuse.h line 205
enum anonymous$8 { cfg_false=0, cfg_true=1 };

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$6;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$5;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$7;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$4;

// tag-DBusConnection
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 51
struct DBusConnection;

// tag-DBusError
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 43
struct DBusError;

// tag-DBusMessage
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 44
struct DBusMessage;

// tag-DBusMessageIter
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 46
struct DBusMessageIter;

// tag-DBusWatch
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 43
struct DBusWatch;

// tag-_AFfilehandle
// file /usr/include/audiofile.h line 51
struct _AFfilehandle;

// tag-_AFfilesetup
// file /usr/include/audiofile.h line 50
struct _AFfilesetup;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_ambient_info
// file ambient.h line 29
struct _ambient_info;

// tag-_appleir_cfg
// file conffile.h line 71
struct _appleir_cfg;

// tag-_audio_cfg
// file conffile.h line 39
struct _audio_cfg;

// tag-_audio_info
// file audio.h line 9
struct _audio_info;

// tag-_beep_cfg
// file conffile.h line 65
struct _beep_cfg;

// tag-_eject_cfg
// file conffile.h line 60
struct _eject_cfg;

// tag-_general_cfg
// file conffile.h line 8
struct _general_cfg;

// tag-_kbd_bck_info
// file kbd_backlight.h line 28
struct _kbd_bck_info;

// tag-_kbd_cfg
// file conffile.h line 50
struct _kbd_cfg;

// tag-_lcd_bck_info
// file lcd_backlight.h line 9
struct _lcd_bck_info;

// tag-_lcd_gma950_cfg
// file conffile.h line 26
struct _lcd_gma950_cfg;

// tag-_lcd_nv8600mgt_cfg
// file conffile.h line 32
struct _lcd_nv8600mgt_cfg;

// tag-_lcd_sysfs_cfg
// file conffile.h line 12
struct _lcd_sysfs_cfg;

// tag-_lcd_x1600_cfg
// file conffile.h line 20
struct _lcd_x1600_cfg;

// tag-_snd_mixer
// file /usr/include/alsa/mixer.h line 42
struct _snd_mixer;

// tag-_snd_mixer_class
// file /usr/include/alsa/mixer.h line 44
struct _snd_mixer_class;

// tag-_snd_mixer_elem
// file /usr/include/alsa/mixer.h line 46
struct _snd_mixer_elem;

// tag-_snd_mixer_selem_channel_id
// file /usr/include/alsa/mixer.h line 170
enum _snd_mixer_selem_channel_id { SND_MIXER_SCHN_UNKNOWN=-1, SND_MIXER_SCHN_FRONT_LEFT=0, SND_MIXER_SCHN_FRONT_RIGHT=1, SND_MIXER_SCHN_REAR_LEFT=2, SND_MIXER_SCHN_REAR_RIGHT=3, SND_MIXER_SCHN_FRONT_CENTER=4, SND_MIXER_SCHN_WOOFER=5, SND_MIXER_SCHN_SIDE_LEFT=6, SND_MIXER_SCHN_SIDE_RIGHT=7, SND_MIXER_SCHN_REAR_CENTER=8, SND_MIXER_SCHN_LAST=31, SND_MIXER_SCHN_MONO=0 };

// tag-_snd_mixer_selem_id
// file /usr/include/alsa/mixer.h line 219
struct _snd_mixer_selem_id;

// tag-_snd_pcm
// file /usr/include/alsa/pcm.h line 354
struct _snd_pcm;

// tag-_snd_pcm_access
// file /usr/include/alsa/pcm.h line 108
enum _snd_pcm_access { SND_PCM_ACCESS_MMAP_INTERLEAVED=0, SND_PCM_ACCESS_MMAP_NONINTERLEAVED=1, SND_PCM_ACCESS_MMAP_COMPLEX=2, SND_PCM_ACCESS_RW_INTERLEAVED=3, SND_PCM_ACCESS_RW_NONINTERLEAVED=4, SND_PCM_ACCESS_LAST=4 };

// tag-_snd_pcm_format
// file /usr/include/alsa/pcm.h line 123
enum _snd_pcm_format { SND_PCM_FORMAT_UNKNOWN=-1, SND_PCM_FORMAT_S8=0, SND_PCM_FORMAT_U8=1, SND_PCM_FORMAT_S16_LE=2, SND_PCM_FORMAT_S16_BE=3, SND_PCM_FORMAT_U16_LE=4, SND_PCM_FORMAT_U16_BE=5, SND_PCM_FORMAT_S24_LE=6, SND_PCM_FORMAT_S24_BE=7, SND_PCM_FORMAT_U24_LE=8, SND_PCM_FORMAT_U24_BE=9, SND_PCM_FORMAT_S32_LE=10, SND_PCM_FORMAT_S32_BE=11, SND_PCM_FORMAT_U32_LE=12, SND_PCM_FORMAT_U32_BE=13, SND_PCM_FORMAT_FLOAT_LE=14, SND_PCM_FORMAT_FLOAT_BE=15, SND_PCM_FORMAT_FLOAT64_LE=16, SND_PCM_FORMAT_FLOAT64_BE=17, SND_PCM_FORMAT_IEC958_SUBFRAME_LE=18, SND_PCM_FORMAT_IEC958_SUBFRAME_BE=19, SND_PCM_FORMAT_MU_LAW=20, SND_PCM_FORMAT_A_LAW=21, SND_PCM_FORMAT_IMA_ADPCM=22, SND_PCM_FORMAT_MPEG=23, SND_PCM_FORMAT_GSM=24, SND_PCM_FORMAT_SPECIAL=31, SND_PCM_FORMAT_S24_3LE=32, SND_PCM_FORMAT_S24_3BE=33, SND_PCM_FORMAT_U24_3LE=34, SND_PCM_FORMAT_U24_3BE=35, SND_PCM_FORMAT_S20_3LE=36, SND_PCM_FORMAT_S20_3BE=37, SND_PCM_FORMAT_U20_3LE=38, SND_PCM_FORMAT_U20_3BE=39, SND_PCM_FORMAT_S18_3LE=40, SND_PCM_FORMAT_S18_3BE=41, SND_PCM_FORMAT_U18_3LE=42, SND_PCM_FORMAT_U18_3BE=43, SND_PCM_FORMAT_G723_24=44, SND_PCM_FORMAT_G723_24_1B=45, SND_PCM_FORMAT_G723_40=46, SND_PCM_FORMAT_G723_40_1B=47, SND_PCM_FORMAT_DSD_U8=48, SND_PCM_FORMAT_DSD_U16_LE=49, SND_PCM_FORMAT_DSD_U32_LE=50, SND_PCM_FORMAT_DSD_U16_BE=51, SND_PCM_FORMAT_DSD_U32_BE=52, SND_PCM_FORMAT_LAST=52, SND_PCM_FORMAT_S16=2, SND_PCM_FORMAT_U16=4, SND_PCM_FORMAT_S24=6, SND_PCM_FORMAT_U24=8, SND_PCM_FORMAT_S32=10, SND_PCM_FORMAT_U32=12, SND_PCM_FORMAT_FLOAT=14, SND_PCM_FORMAT_FLOAT64=16, SND_PCM_FORMAT_IEC958_SUBFRAME=18 };

// tag-_snd_pcm_hw_params
// file /usr/include/alsa/pcm.h line 62
struct _snd_pcm_hw_params;

// tag-_snd_pcm_stream
// file /usr/include/alsa/pcm.h line 99
enum _snd_pcm_stream { SND_PCM_STREAM_PLAYBACK=0, SND_PCM_STREAM_CAPTURE=1, SND_PCM_STREAM_LAST=1 };

// tag-cfg_defvalue_t
// file /usr/include/confuse.h line 102
struct cfg_defvalue_t;

// tag-cfg_opt_t
// file /usr/include/confuse.h line 100
struct cfg_opt_t;

// tag-cfg_t
// file /usr/include/confuse.h line 101
struct cfg_t;

// tag-cfg_type_t
// file /usr/include/confuse.h line 68
enum cfg_type_t { CFGT_NONE=0, CFGT_INT=1, CFGT_FLOAT=2, CFGT_STR=3, CFGT_BOOL=4, CFGT_SEC=5, CFGT_FUNC=6, CFGT_PTR=7 };

// tag-cfg_value_t
// file /usr/include/confuse.h line 99
union cfg_value_t;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-dspdata
// file beep.h line 45
struct dspdata;

// tag-epoll_data
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 79
union epoll_data;

// tag-epoll_event
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 87
struct epoll_event;

// tag-id_bucket
// file /usr/include/pci/pci.h line 73
struct id_bucket;

// tag-id_entry
// file /usr/include/pci/pci.h line 72
struct id_entry;

// tag-inotify_event
// file /usr/include/x86_64-linux-gnu/sys/inotify.h line 28
struct inotify_event;

// tag-input_event
// file /usr/include/linux/input.h line 22
struct input_event;

// tag-input_id
// file /usr/include/linux/input.h line 39
struct input_id;

// tag-itimerspec
// file /usr/include/time.h line 161
struct itimerspec;

// tag-machine_ops
// file pommed.h line 81
struct machine_ops;

// tag-pci_access
// file /usr/include/pci/pci.h line 47
struct pci_access;

// tag-pci_cap
// file /usr/include/pci/pci.h line 134
struct pci_cap;

// tag-pci_dev
// file /usr/include/pci/pci.h line 67
struct pci_dev;

// tag-pci_methods
// file /usr/include/pci/pci.h line 29
struct pci_methods;

// tag-pci_param
// file /usr/include/pci/pci.h line 71
struct pci_param;

// tag-pommed_event
// file evloop.h line 13
struct pommed_event;

// tag-pommed_timer
// file evloop.h line 30
struct pommed_timer;

// tag-pommed_timer_job
// file evloop.h line 22
struct pommed_timer_job;

// tag-pommed_watch
// file dbus.c line 855
struct pommed_watch;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sample
// file beep.h line 26
struct sample;

// tag-snd_mixer_selem_regopt
// file /usr/include/alsa/mixer.h line 205
struct snd_mixer_selem_regopt;

// tag-snd_mixer_selem_regopt_abstract
// file /usr/include/alsa/mixer.h line 197
enum snd_mixer_selem_regopt_abstract { SND_MIXER_SABSTRACT_NONE=0, SND_MIXER_SABSTRACT_BASIC=1 };

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-udev
// file /usr/include/pci/pci.h line 76
struct udev;

// tag-udev_hwdb
// file /usr/include/pci/pci.h line 77
struct udev_hwdb;

// tag-uinput_user_dev
// file /usr/include/linux/uinput.h line 148
struct uinput_user_dev;

// tag-utsname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 48
struct utsname;

// tag-vt_stat
// file /usr/include/linux/vt.h line 32
struct vt_stat;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 400
extern signed int __xstat(signed int, const char *, struct stat *);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// afCloseFile
// file /usr/include/audiofile.h line 448
signed int afCloseFile(struct _AFfilehandle *);
// afGetChannels
// file /usr/include/audiofile.h line 481
signed int afGetChannels(struct _AFfilehandle *, signed int);
// afGetFrameCount
// file /usr/include/audiofile.h line 549
signed long int afGetFrameCount(struct _AFfilehandle *, signed int);
// afGetFrameSize
// file /usr/include/audiofile.h line 463
float afGetFrameSize(struct _AFfilehandle *, signed int, signed int);
// afGetRate
// file /usr/include/audiofile.h line 498
double afGetRate(struct _AFfilehandle *, signed int);
// afGetSampleFormat
// file /usr/include/audiofile.h line 489
void afGetSampleFormat(struct _AFfilehandle *, signed int, signed int *, signed int *);
// afGetVirtualByteOrder
// file /usr/include/audiofile.h line 477
signed int afGetVirtualByteOrder(struct _AFfilehandle *, signed int);
// afOpenFile
// file /usr/include/audiofile.h line 437
struct _AFfilehandle * afOpenFile(const char *, const char *, struct _AFfilesetup *);
// afReadFrames
// file /usr/include/audiofile.h line 458
signed int afReadFrames(struct _AFfilehandle *, signed int, void *, signed int);
// ambient_get
// file mactel/../ambient.h line 40
void ambient_get(signed int *r, signed int *l);
// ambient_init
// file mactel/../ambient.h line 43
void ambient_init(signed int *r, signed int *l);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// atoi$link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi$link1(const char *__nptr$link1);
// atoi$link2
// file /usr/include/stdlib.h line 278
static inline signed int atoi$link2(const char *__nptr$link2);
// audio_cleanup
// file audio.c line 272
void audio_cleanup(void);
// audio_fix_config
// file audio.h line 32
void audio_fix_config(void);
// audio_init
// file audio.h line 26
signed int audio_init(void);
// audio_set_mute_elem
// file audio.c line 104
static void audio_set_mute_elem(struct _snd_mixer_elem *elem);
// audio_step
// file audio.h line 20
void audio_step(signed int dir);
// audio_toggle_mute
// file audio.h line 23
void audio_toggle_mute(void);
// beep_audio
// file beep.h line 13
void beep_audio(void);
// beep_beep
// file beep.c line 76
static void beep_beep(void);
// beep_cleanup
// file beep.h line 19
void beep_cleanup(void);
// beep_close_device
// file beep.c line 188
static void beep_close_device(void);
// beep_fix_config
// file beep.h line 22
void beep_fix_config(void);
// beep_init
// file beep.h line 16
signed int beep_init(void);
// beep_load_sample
// file beep.c line 329
static struct sample * beep_load_sample(char *filename);
// beep_open_device
// file beep.c line 98
static signed int beep_open_device(void);
// beep_play_sample
// file beep.c line 409
static void beep_play_sample(struct dspdata *dsp, signed int cmd);
// beep_process_events
// file beep.c line 204
void beep_process_events(signed int fd, unsigned int events);
// beep_thread
// file beep.c line 501
void * beep_thread(void *arg);
// beep_thread_cleanup
// file beep.c line 549
static void beep_thread_cleanup(void);
// beep_thread_command
// file beep.c line 533
static void beep_thread_command(signed int command);
// beep_thread_init
// file beep.c line 574
static signed int beep_thread_init(void);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// cd_eject
// file cd_eject.c line 44
void cd_eject(void);
// cd_eject_fix_config
// file cd_eject.c line 128
void cd_eject_fix_config(void);
// cfg_error
// file /usr/include/confuse.h line 598
void cfg_error(struct cfg_t *, const char *, ...);
// cfg_free
// file /usr/include/confuse.h line 587
void cfg_free(struct cfg_t *);
// cfg_getbool
// file /usr/include/confuse.h line 704
enum anonymous$8 cfg_getbool(struct cfg_t *, const char *);
// cfg_getint
// file /usr/include/confuse.h line 625
signed long int cfg_getint(struct cfg_t *, const char *);
// cfg_getsec
// file /usr/include/confuse.h line 770
struct cfg_t * cfg_getsec(struct cfg_t *, const char *);
// cfg_getstr
// file /usr/include/confuse.h line 677
char * cfg_getstr(struct cfg_t *, const char *);
// cfg_init
// file /usr/include/confuse.h line 538
struct cfg_t * cfg_init(struct cfg_opt_t *, signed int);
// cfg_opt_getnint
// file /usr/include/confuse.h line 605
signed long int cfg_opt_getnint(struct cfg_opt_t *, unsigned int);
// cfg_opt_getnstr
// file /usr/include/confuse.h line 658
char * cfg_opt_getnstr(struct cfg_opt_t *, unsigned int);
// cfg_opt_size
// file /usr/include/confuse.h line 777
unsigned int cfg_opt_size(struct cfg_opt_t *);
// cfg_parse
// file /usr/include/confuse.h line 553
signed int cfg_parse(struct cfg_t *, const char *);
// cfg_set_validate_func
// file /usr/include/confuse.h line 1108
signed int (*cfg_set_validate_func(struct cfg_t *, const char *, signed int (*)(struct cfg_t *, struct cfg_opt_t *)))(struct cfg_t *, struct cfg_opt_t *);
// check_ac_state
// file power.c line 74
static signed int check_ac_state(void);
// check_machine_dmi
// file pommed.c line 649
static enum anonymous$3 check_machine_dmi(void);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// config_cleanup
// file conffile.h line 97
void config_cleanup(void);
// config_load
// file conffile.h line 94
signed int config_load(void);
// config_print
// file conffile.c line 193
static void config_print(void);
// config_validate_positive_integer
// file conffile.c line 164
static signed int config_validate_positive_integer(struct cfg_t *cfg, struct cfg_opt_t *opt);
// config_validate_string
// file conffile.c line 178
static signed int config_validate_string(struct cfg_t *cfg, struct cfg_opt_t *opt);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// dbus_bus_get
// file /usr/include/dbus-1.0/dbus/dbus-bus.h line 40
struct DBusConnection * dbus_bus_get(enum anonymous$2, struct DBusError *);
// dbus_bus_request_name
// file /usr/include/dbus-1.0/dbus/dbus-bus.h line 62
signed int dbus_bus_request_name(struct DBusConnection *, const char *, unsigned int, struct DBusError *);
// dbus_connection_add_filter
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 295
unsigned int dbus_connection_add_filter(struct DBusConnection *, enum anonymous (*)(struct DBusConnection *, struct DBusMessage *, void *), void *, void (*)(void *));
// dbus_connection_dispatch
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 220
enum anonymous$1 dbus_connection_dispatch(struct DBusConnection *);
// dbus_connection_flush
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 200
void dbus_connection_flush(struct DBusConnection *);
// dbus_connection_send
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 224
unsigned int dbus_connection_send(struct DBusConnection *, struct DBusMessage *, unsigned int *);
// dbus_connection_set_exit_on_disconnect
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 197
void dbus_connection_set_exit_on_disconnect(struct DBusConnection *, unsigned int);
// dbus_connection_set_watch_functions
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 238
unsigned int dbus_connection_set_watch_functions(struct DBusConnection *, unsigned int (*)(struct DBusWatch *, void *), void (*)(struct DBusWatch *, void *), void (*)(struct DBusWatch *, void *), void *, void (*)(void *));
// dbus_connection_unref
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 181
void dbus_connection_unref(struct DBusConnection *);
// dbus_error_free
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 67
void dbus_error_free(struct DBusError *);
// dbus_error_init
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 65
void dbus_error_init(struct DBusError *);
// dbus_error_is_set
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 84
unsigned int dbus_error_is_set(const struct DBusError *);
// dbus_message_append_args
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 189
unsigned int dbus_message_append_args(struct DBusMessage *, signed int, ...);
// dbus_message_get_args
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 197
unsigned int dbus_message_get_args(struct DBusMessage *, struct DBusError *, signed int, ...);
// dbus_message_is_method_call
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 148
unsigned int dbus_message_is_method_call(struct DBusMessage *, const char *, const char *);
// dbus_message_is_signal
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 152
unsigned int dbus_message_is_signal(struct DBusMessage *, const char *, const char *);
// dbus_message_iter_init
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 211
unsigned int dbus_message_iter_init(struct DBusMessage *, struct DBusMessageIter *);
// dbus_message_new_method_return
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 77
struct DBusMessage * dbus_message_new_method_return(struct DBusMessage *);
// dbus_message_new_signal
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 79
struct DBusMessage * dbus_message_new_signal(const char *, const char *, const char *);
// dbus_message_unref
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 98
void dbus_message_unref(struct DBusMessage *);
// dbus_to_epoll
// file dbus.c line 870
static unsigned int dbus_to_epoll(signed int flags);
// dbus_watch_get_enabled
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 470
unsigned int dbus_watch_get_enabled(struct DBusWatch *);
// dbus_watch_get_flags
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 459
unsigned int dbus_watch_get_flags(struct DBusWatch *);
// dbus_watch_get_unix_fd
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 455
signed int dbus_watch_get_unix_fd(struct DBusWatch *);
// dbus_watch_handle
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 467
unsigned int dbus_watch_handle(struct DBusWatch *, unsigned int);
// epoll_create
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 100
extern signed int epoll_create(signed int);
// epoll_ctl
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 113
extern signed int epoll_ctl(signed int, signed int, signed int, struct epoll_event *);
// epoll_to_dbus
// file dbus.c line 886
static signed int epoll_to_dbus(unsigned int events);
// epoll_wait
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 127
extern signed int epoll_wait(signed int, struct epoll_event *, signed int, signed int);
// evdev_cleanup
// file evdev.h line 135
void evdev_cleanup(void);
// evdev_init
// file evdev.h line 132
signed int evdev_init(void);
// evdev_inotify_init
// file evdev.c line 1133
static signed int evdev_inotify_init(void);
// evdev_inotify_process
// file evdev.c line 234
void evdev_inotify_process(signed int fd, unsigned int events);
// evdev_is_appleir
// file evdev.c line 840
static signed int evdev_is_appleir(unsigned short int *id);
// evdev_is_extkbd
// file evdev.c line 1014
static signed int evdev_is_extkbd(unsigned short int *id);
// evdev_is_extkbd_alu
// file evdev.c line 936
static signed int evdev_is_extkbd_alu(unsigned short int *id);
// evdev_is_extkbd_alu_wl
// file evdev.c line 962
static signed int evdev_is_extkbd_alu_wl(unsigned short int *id);
// evdev_is_extkbd_alu_wl_2
// file evdev.c line 988
static signed int evdev_is_extkbd_alu_wl_2(unsigned short int *id);
// evdev_is_extkbd_mini_alu
// file evdev.c line 910
static signed int evdev_is_extkbd_mini_alu(unsigned short int *id);
// evdev_is_extkbd_white
// file evdev.c line 886
static signed int evdev_is_extkbd_white(unsigned short int *id);
// evdev_is_geyser3
// file evdev.c line 451
static signed int evdev_is_geyser3(unsigned short int *id);
// evdev_is_geyser4
// file evdev.c line 477
static signed int evdev_is_geyser4(unsigned short int *id);
// evdev_is_geyser4hf
// file evdev.c line 504
static signed int evdev_is_geyser4hf(unsigned short int *id);
// evdev_is_internal
// file evdev.c line 819
static signed int evdev_is_internal(unsigned short int *id);
// evdev_is_lidswitch
// file evdev.c line 863
static signed int evdev_is_lidswitch(unsigned short int *id);
// evdev_is_mouseemu
// file evdev.c line 1025
static signed int evdev_is_mouseemu(unsigned short int *id);
// evdev_is_wellspring
// file evdev.c line 530
static signed int evdev_is_wellspring(unsigned short int *id);
// evdev_is_wellspring2
// file evdev.c line 556
static signed int evdev_is_wellspring2(unsigned short int *id);
// evdev_is_wellspring3
// file evdev.c line 584
static signed int evdev_is_wellspring3(unsigned short int *id);
// evdev_is_wellspring4
// file evdev.c line 610
static signed int evdev_is_wellspring4(unsigned short int *id);
// evdev_is_wellspring4a
// file evdev.c line 636
static signed int evdev_is_wellspring4a(unsigned short int *id);
// evdev_is_wellspring5
// file evdev.c line 665
static signed int evdev_is_wellspring5(unsigned short int *id);
// evdev_is_wellspring5a
// file evdev.c line 693
static signed int evdev_is_wellspring5a(unsigned short int *id);
// evdev_is_wellspring6
// file evdev.c line 718
static signed int evdev_is_wellspring6(unsigned short int *id);
// evdev_is_wellspring6a
// file evdev.c line 743
static signed int evdev_is_wellspring6a(unsigned short int *id);
// evdev_is_wellspring7
// file evdev.c line 768
static signed int evdev_is_wellspring7(unsigned short int *id);
// evdev_is_wellspring7a
// file evdev.c line 793
static signed int evdev_is_wellspring7a(unsigned short int *id);
// evdev_process_events
// file evdev.c line 70
void evdev_process_events(signed int fd, unsigned int events);
// evdev_try_add
// file evdev.c line 1047
static signed int evdev_try_add(signed int fd);
// evloop_add
// file evloop.h line 41
signed int evloop_add(signed int fd, unsigned int events, void (*cb)(signed int, unsigned int));
// evloop_add::cb$object
//
void cb$object(signed int, unsigned int);
// evloop_add_timer
// file evloop.c line 218
signed int evloop_add_timer(signed int timeout, void (*cb)(signed int, unsigned long int));
// evloop_add_timer::cb$object
//
void cb$object(signed int, unsigned long int);
// evloop_cleanup
// file evloop.h line 62
void evloop_cleanup(void);
// evloop_create_timer
// file evloop.c line 163
static signed int evloop_create_timer(signed int timeout);
// evloop_init
// file evloop.h line 59
signed int evloop_init(void);
// evloop_iteration
// file evloop.h line 53
signed int evloop_iteration(void);
// evloop_remove
// file evloop.h line 44
signed int evloop_remove(signed int fd);
// evloop_remove_timer
// file evloop.c line 272
signed int evloop_remove_timer(signed int id);
// evloop_stop
// file evloop.h line 56
void evloop_stop(void);
// evloop_timer_callback
// file evloop.c line 133
static void evloop_timer_callback(signed int fd, unsigned int events);
// execve
// file /usr/include/unistd.h line 551
extern signed int execve(const char *, char * const *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gma950_backlight_fix_config
// file mactel/gma950_backlight.c line 280
static void gma950_backlight_fix_config(void);
// gma950_backlight_get
// file mactel/gma950_backlight.c line 103
static unsigned int gma950_backlight_get(void);
// gma950_backlight_get_max
// file mactel/gma950_backlight.c line 109
static unsigned int gma950_backlight_get_max(void);
// gma950_backlight_map
// file mactel/gma950_backlight.c line 122
static signed int gma950_backlight_map(void);
// gma950_backlight_probe
// file lcd_backlight.h line 55
signed int gma950_backlight_probe(void);
// gma950_backlight_set
// file mactel/gma950_backlight.c line 115
static void gma950_backlight_set(unsigned int value);
// gma950_backlight_step
// file lcd_backlight.h line 49
void gma950_backlight_step(signed int dir);
// gma950_backlight_toggle
// file lcd_backlight.h line 52
void gma950_backlight_toggle(signed int lvl);
// gma950_backlight_unmap
// file mactel/gma950_backlight.c line 154
static void gma950_backlight_unmap(void);
// has_kbd_backlight
// file kbd_backlight.h line 64
static inline signed int has_kbd_backlight(void);
// has_kbd_backlight$link1
// file mactel/../kbd_backlight.h line 64
static inline signed int has_kbd_backlight$link1(void);
// inb
// file /usr/include/x86_64-linux-gnu/sys/io.h line 43
static inline unsigned char inb(unsigned short int __port);
// inotify_add_watch
// file /usr/include/x86_64-linux-gnu/sys/inotify.h line 91
extern signed int inotify_add_watch(signed int, const char *, unsigned int);
// inotify_init
// file /usr/include/x86_64-linux-gnu/sys/inotify.h line 84
extern signed int inotify_init(void);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// iopl
// file /usr/include/x86_64-linux-gnu/sys/io.h line 38
extern signed int iopl(signed int);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// kbd_auto_cleanup
// file mactel/../kbd_auto.c line 171
static void kbd_auto_cleanup(void);
// kbd_auto_init
// file mactel/../kbd_auto.c line 161
static signed int kbd_auto_init(void);
// kbd_auto_process
// file mactel/../kbd_auto.c line 149
static void kbd_auto_process(signed int id, unsigned long int ticks);
// kbd_backlight_ambient_check
// file mactel/../kbd_auto.c line 103
void kbd_backlight_ambient_check(void);
// kbd_backlight_cleanup
// file kbd_backlight.h line 89
void kbd_backlight_cleanup(void);
// kbd_backlight_fix_config
// file kbd_backlight.h line 92
void kbd_backlight_fix_config(void);
// kbd_backlight_get
// file mactel/kbd_backlight.c line 76
static signed int kbd_backlight_get(void);
// kbd_backlight_inhibit_clear
// file kbd_backlight.h line 103
void kbd_backlight_inhibit_clear(signed int mask);
// kbd_backlight_inhibit_set
// file kbd_backlight.h line 100
void kbd_backlight_inhibit_set(signed int mask);
// kbd_backlight_inhibit_toggle
// file kbd_backlight.h line 106
void kbd_backlight_inhibit_toggle(signed int mask);
// kbd_backlight_init
// file kbd_backlight.h line 86
void kbd_backlight_init(void);
// kbd_backlight_open
// file mactel/kbd_backlight.c line 46
static signed int kbd_backlight_open(signed int flags);
// kbd_backlight_set
// file mactel/kbd_backlight.c line 106
static void kbd_backlight_set(signed int val, signed int who);
// kbd_backlight_step
// file kbd_backlight.h line 83
void kbd_backlight_step(signed int dir);
// kbd_backlight_toggle
// file kbd_backlight.h line 97
void kbd_backlight_toggle(void);
// kbd_set_fnmode
// file pommed.c line 474
void kbd_set_fnmode(void);
// logdebug
// file pommed.c line 460
void logdebug(char *fmt, ...);
// logmsg
// file pommed.c line 421
void logmsg(signed int level, char *fmt, ...);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mbp_sysfs_backlight_probe
// file lcd_backlight.h line 102
signed int mbp_sysfs_backlight_probe(void);
// mbpdbus_add_watch
// file dbus.c line 951
static unsigned int mbpdbus_add_watch(struct DBusWatch *watch, void *data);
// mbpdbus_cleanup
// file dbus.h line 37
void mbpdbus_cleanup(void);
// mbpdbus_data_free
// file dbus.c line 1103
static void mbpdbus_data_free(void *data);
// mbpdbus_init
// file dbus.h line 34
signed int mbpdbus_init(void);
// mbpdbus_process_requests
// file dbus.c line 805
static enum anonymous mbpdbus_process_requests(struct DBusConnection *lconn, struct DBusMessage *msg, void *data);
// mbpdbus_process_watch
// file dbus.c line 908
static void mbpdbus_process_watch(signed int fd, unsigned int events);
// mbpdbus_reconnect
// file dbus.c line 792
static void mbpdbus_reconnect(signed int id, unsigned long int ticks);
// mbpdbus_remove_watch
// file dbus.c line 1013
static void mbpdbus_remove_watch(struct DBusWatch *watch, void *data);
// mbpdbus_send_ambient_light
// file dbus.c line 153
void mbpdbus_send_ambient_light(signed int l, signed int l_prev, signed int r, signed int r_prev);
// mbpdbus_send_audio_mute
// file dbus.h line 24
void mbpdbus_send_audio_mute(signed int mute);
// mbpdbus_send_audio_volume
// file dbus.h line 21
void mbpdbus_send_audio_volume(signed int cur, signed int prev);
// mbpdbus_send_cd_eject
// file dbus.h line 27
void mbpdbus_send_cd_eject(void);
// mbpdbus_send_kbd_backlight
// file dbus.c line 101
void mbpdbus_send_kbd_backlight(signed int cur, signed int prev, signed int who);
// mbpdbus_send_lcd_backlight
// file dbus.c line 49
void mbpdbus_send_lcd_backlight(signed int cur, signed int prev, signed int who);
// mbpdbus_send_video_switch
// file dbus.c line 343
void mbpdbus_send_video_switch(void);
// mbpdbus_toggle_watch
// file dbus.c line 1058
static void mbpdbus_toggle_watch(struct DBusWatch *watch, void *data);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// nv8600mgt_backlight_fix_config
// file lcd_backlight.h line 72
void nv8600mgt_backlight_fix_config(void);
// nv8600mgt_backlight_get
// file mactel/nv8600mgt_backlight.c line 59
static unsigned char nv8600mgt_backlight_get();
// nv8600mgt_backlight_probe
// file lcd_backlight.h line 69
signed int nv8600mgt_backlight_probe(void);
// nv8600mgt_backlight_set
// file mactel/nv8600mgt_backlight.c line 75
static void nv8600mgt_backlight_set(unsigned char value);
// nv8600mgt_backlight_step
// file lcd_backlight.h line 63
void nv8600mgt_backlight_step(signed int dir);
// nv8600mgt_backlight_toggle
// file lcd_backlight.h line 66
void nv8600mgt_backlight_toggle(signed int lvl);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// outb
// file /usr/include/x86_64-linux-gnu/sys/io.h line 96
static inline void outb(unsigned char __value, unsigned short int __port);
// pci_alloc
// file /usr/include/pci/pci.h line 86
struct pci_access * pci_alloc(void);
// pci_cleanup
// file /usr/include/pci/pci.h line 88
void pci_cleanup(struct pci_access *);
// pci_fill_info
// file /usr/include/pci/pci.h line 162
signed int pci_fill_info(struct pci_dev *, signed int);
// pci_init
// file /usr/include/pci/pci.h line 87
void pci_init(struct pci_access *);
// pci_scan_bus
// file /usr/include/pci/pci.h line 91
void pci_scan_bus(struct pci_access *);
// power_check_ac_state
// file power.c line 87
static void power_check_ac_state(signed int id, unsigned long int ticks);
// power_cleanup
// file power.h line 28
void power_cleanup(void);
// power_init
// file power.h line 25
void power_init(void);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_ambient_getlevel_call
// file dbus.c line 473
static void process_ambient_getlevel_call(struct DBusMessage *req);
// process_audio_getmute_call
// file dbus.c line 564
static void process_audio_getmute_call(struct DBusMessage *req);
// process_audio_getvolume_call
// file dbus.c line 519
static void process_audio_getvolume_call(struct DBusMessage *req);
// process_audio_toggle_mute_call
// file dbus.c line 739
static void process_audio_toggle_mute_call(struct DBusMessage *req);
// process_audio_volume_step_call
// file dbus.c line 713
static void process_audio_volume_step_call(struct DBusMessage *req, signed int dir);
// process_cd_eject_call
// file dbus.c line 765
static void process_cd_eject_call(struct DBusMessage *req);
// process_kbd_backlight_inhibit_call
// file dbus.c line 684
static void process_kbd_backlight_inhibit_call(struct DBusMessage *req, signed int inhibit);
// process_kbd_getlevel_call
// file dbus.c line 427
static void process_kbd_getlevel_call(struct DBusMessage *req);
// process_lcd_backlight_step_call
// file dbus.c line 658
static void process_lcd_backlight_step_call(struct DBusMessage *req, signed int dir);
// process_lcd_getlevel_call
// file dbus.c line 381
static void process_lcd_getlevel_call(struct DBusMessage *req);
// process_video_getvtstate_call
// file dbus.c line 608
static void process_video_getvtstate_call(struct DBusMessage *req);
// procfs_check_ac_state
// file power.c line 36
signed int procfs_check_ac_state(void);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$7 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$7 *, const union anonymous$5 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$7 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$7 *, union anonymous$4 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$4 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$4 *, const union anonymous$5 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$4 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$4 *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// readl
// file mactel/x1600_backlight.c line 56
static inline unsigned int readl(const volatile void *addr);
// readl$link1
// file mactel/gma950_backlight.c line 87
static inline unsigned int readl$link1(const volatile void *addr$link1);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// realpath
// file /usr/include/stdlib.h line 733
extern char * realpath(const char *, char *);
// sig_int_term_handler
// file pommed.c line 831
void sig_int_term_handler(signed int signal);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// snd_mixer_attach
// file /usr/include/alsa/mixer.h line 101
signed int snd_mixer_attach(struct _snd_mixer *, const char *);
// snd_mixer_close
// file /usr/include/alsa/mixer.h line 97
signed int snd_mixer_close(struct _snd_mixer *);
// snd_mixer_detach
// file /usr/include/alsa/mixer.h line 103
signed int snd_mixer_detach(struct _snd_mixer *, const char *);
// snd_mixer_elem_next
// file /usr/include/alsa/mixer.h line 119
struct _snd_mixer_elem * snd_mixer_elem_next(struct _snd_mixer_elem *);
// snd_mixer_first_elem
// file /usr/include/alsa/mixer.h line 98
struct _snd_mixer_elem * snd_mixer_first_elem(struct _snd_mixer *);
// snd_mixer_handle_events
// file /usr/include/alsa/mixer.h line 100
signed int snd_mixer_handle_events(struct _snd_mixer *);
// snd_mixer_load
// file /usr/include/alsa/mixer.h line 109
signed int snd_mixer_load(struct _snd_mixer *);
// snd_mixer_open
// file /usr/include/alsa/mixer.h line 96
signed int snd_mixer_open(struct _snd_mixer **, signed int);
// snd_mixer_selem_get_id
// file /usr/include/alsa/mixer.h line 226
void snd_mixer_selem_get_id(struct _snd_mixer_elem *, struct _snd_mixer_selem_id *);
// snd_mixer_selem_get_playback_volume
// file /usr/include/alsa/mixer.h line 255
signed int snd_mixer_selem_get_playback_volume(struct _snd_mixer_elem *, enum _snd_mixer_selem_channel_id, signed long int *);
// snd_mixer_selem_get_playback_volume_range
// file /usr/include/alsa/mixer.h line 273
signed int snd_mixer_selem_get_playback_volume_range(struct _snd_mixer_elem *, signed long int *, signed long int *);
// snd_mixer_selem_has_playback_switch
// file /usr/include/alsa/mixer.h line 245
signed int snd_mixer_selem_has_playback_switch(struct _snd_mixer_elem *);
// snd_mixer_selem_id_get_name
// file /usr/include/alsa/mixer.h line 303
const char * snd_mixer_selem_id_get_name(const struct _snd_mixer_selem_id *);
// snd_mixer_selem_id_sizeof
// file /usr/include/alsa/mixer.h line 294
unsigned long int snd_mixer_selem_id_sizeof(void);
// snd_mixer_selem_is_active
// file /usr/include/alsa/mixer.h line 233
signed int snd_mixer_selem_is_active(struct _snd_mixer_elem *);
// snd_mixer_selem_is_playback_mono
// file /usr/include/alsa/mixer.h line 234
signed int snd_mixer_selem_is_playback_mono(struct _snd_mixer_elem *);
// snd_mixer_selem_register
// file /usr/include/alsa/mixer.h line 223
signed int snd_mixer_selem_register(struct _snd_mixer *, struct snd_mixer_selem_regopt *, struct _snd_mixer_class **);
// snd_mixer_selem_set_playback_switch
// file /usr/include/alsa/mixer.h line 269
signed int snd_mixer_selem_set_playback_switch(struct _snd_mixer_elem *, enum _snd_mixer_selem_channel_id, signed int);
// snd_mixer_selem_set_playback_volume
// file /usr/include/alsa/mixer.h line 261
signed int snd_mixer_selem_set_playback_volume(struct _snd_mixer_elem *, enum _snd_mixer_selem_channel_id, signed long int);
// snd_pcm_close
// file /usr/include/alsa/pcm.h line 459
signed int snd_pcm_close(struct _snd_pcm *);
// snd_pcm_drop
// file /usr/include/alsa/pcm.h line 481
signed int snd_pcm_drop(struct _snd_pcm *);
// snd_pcm_hw_params
// file /usr/include/alsa/pcm.h line 473
signed int snd_pcm_hw_params(struct _snd_pcm *, struct _snd_pcm_hw_params *);
// snd_pcm_hw_params_any
// file /usr/include/alsa/pcm.h line 657
signed int snd_pcm_hw_params_any(struct _snd_pcm *, struct _snd_pcm_hw_params *);
// snd_pcm_hw_params_set_access
// file /usr/include/alsa/pcm.h line 718
signed int snd_pcm_hw_params_set_access(struct _snd_pcm *, struct _snd_pcm_hw_params *, enum _snd_pcm_access);
// snd_pcm_hw_params_set_buffer_size_near
// file /usr/include/alsa/pcm.h line 828
signed int snd_pcm_hw_params_set_buffer_size_near(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned long int *);
// snd_pcm_hw_params_set_channels_near
// file /usr/include/alsa/pcm.h line 748
signed int snd_pcm_hw_params_set_channels_near(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned int *);
// snd_pcm_hw_params_set_format
// file /usr/include/alsa/pcm.h line 726
signed int snd_pcm_hw_params_set_format(struct _snd_pcm *, struct _snd_pcm_hw_params *, enum _snd_pcm_format);
// snd_pcm_hw_params_set_periods_near
// file /usr/include/alsa/pcm.h line 803
signed int snd_pcm_hw_params_set_periods_near(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned int *, signed int *);
// snd_pcm_hw_params_set_rate_near
// file /usr/include/alsa/pcm.h line 760
signed int snd_pcm_hw_params_set_rate_near(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned int *, signed int *);
// snd_pcm_hw_params_sizeof
// file /usr/include/alsa/pcm.h line 704
unsigned long int snd_pcm_hw_params_sizeof(void);
// snd_pcm_open
// file /usr/include/alsa/pcm.h line 450
signed int snd_pcm_open(struct _snd_pcm **, const char *, enum _snd_pcm_stream, signed int);
// snd_pcm_prepare
// file /usr/include/alsa/pcm.h line 477
signed int snd_pcm_prepare(struct _snd_pcm *);
// snd_pcm_writei
// file /usr/include/alsa/pcm.h line 496
signed long int snd_pcm_writei(struct _snd_pcm *, const void *, unsigned long int);
// snd_strerror
// file /usr/include/alsa/error.h line 45
const char * snd_strerror(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf);
// stat$link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat$link1(const char *__path$link1, struct stat *__statbuf$link1);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// sysfs_backlight_fix_config
// file sysfs_backlight.c line 330
static void sysfs_backlight_fix_config(void);
// sysfs_backlight_get
// file sysfs_backlight.c line 121
static signed int sysfs_backlight_get(void);
// sysfs_backlight_get_max
// file sysfs_backlight.c line 153
static signed int sysfs_backlight_get_max(void);
// sysfs_backlight_probe
// file sysfs_backlight.c line 352
static signed int sysfs_backlight_probe(signed int driver);
// sysfs_backlight_set
// file sysfs_backlight.c line 186
static void sysfs_backlight_set(signed int value);
// sysfs_backlight_step
// file lcd_backlight.h line 80
void sysfs_backlight_step(signed int dir);
// sysfs_backlight_toggle
// file lcd_backlight.h line 83
void sysfs_backlight_toggle(signed int lvl);
// sysfs_check_ac_state
// file power.c line 45
static signed int sysfs_check_ac_state(void);
// timerfd_create
// file /usr/include/x86_64-linux-gnu/sys/timerfd.h line 38
extern signed int timerfd_create(signed int, signed int);
// timerfd_settime
// file /usr/include/x86_64-linux-gnu/sys/timerfd.h line 43
extern signed int timerfd_settime(signed int, signed int, struct itimerspec *, struct itimerspec *);
// uname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 81
extern signed int uname(struct utsname *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usage
// file pommed.c line 817
static void usage(void);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// video_switch
// file video.h line 10
void video_switch(void);
// video_vt_active
// file video.h line 13
signed int video_vt_active(signed int vt);
// vsyslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 200
extern void vsyslog(signed int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// writel
// file mactel/x1600_backlight.c line 62
static inline void writel(unsigned int b, volatile void *addr);
// writel$link1
// file mactel/gma950_backlight.c line 93
static inline void writel$link1(unsigned int b$link1, volatile void *addr$link1);
// x1600_backlight_fix_config
// file lcd_backlight.h line 41
void x1600_backlight_fix_config(void);
// x1600_backlight_get
// file mactel/x1600_backlight.c line 72
static unsigned char x1600_backlight_get();
// x1600_backlight_map
// file mactel/x1600_backlight.c line 85
static signed int x1600_backlight_map(void);
// x1600_backlight_probe
// file lcd_backlight.h line 38
signed int x1600_backlight_probe(void);
// x1600_backlight_set
// file mactel/x1600_backlight.c line 78
static void x1600_backlight_set(unsigned char value);
// x1600_backlight_step
// file lcd_backlight.h line 32
void x1600_backlight_step(signed int dir);
// x1600_backlight_toggle
// file lcd_backlight.h line 35
void x1600_backlight_toggle(signed int lvl);
// x1600_backlight_unmap
// file mactel/x1600_backlight.c line 124
static void x1600_backlight_unmap(void);

struct anonymous$6
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union anonymous$5
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$7
{
  // __data
  struct anonymous$6 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$4
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct DBusError
{
  // name
  const char *name;
  // message
  const char *message;
  // dummy1
  unsigned int dummy1 : 1;
  // dummy2
  unsigned int dummy2 : 1;
  // dummy3
  unsigned int dummy3 : 1;
  // dummy4
  unsigned int dummy4 : 1;
  // dummy5
  unsigned int dummy5 : 1;
  // padding1
  void *padding1;
};

struct DBusMessageIter
{
  // dummy1
  void *dummy1;
  // dummy2
  void *dummy2;
  // dummy3
  unsigned int dummy3;
  // dummy4
  signed int dummy4;
  // dummy5
  signed int dummy5;
  // dummy6
  signed int dummy6;
  // dummy7
  signed int dummy7;
  // dummy8
  signed int dummy8;
  // dummy9
  signed int dummy9;
  // dummy10
  signed int dummy10;
  // dummy11
  signed int dummy11;
  // pad1
  signed int pad1;
  // pad2
  signed int pad2;
  // pad3
  void *pad3;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _ambient_info
{
  // left
  signed int left;
  // right
  signed int right;
  // max
  signed int max;
};

struct _appleir_cfg
{
  // enabled
  signed int enabled;
};

struct _audio_cfg
{
  // disabled
  signed int disabled;
  // card
  char *card;
  // init
  signed int init;
  // step
  signed int step;
  // beep
  signed int beep;
  // vol
  char *vol;
  // spkr
  char *spkr;
  // head
  char *head;
};

struct _audio_info
{
  // level
  signed int level;
  // max
  signed int max;
  // muted
  signed int muted;
};

struct _beep_cfg
{
  // enabled
  signed int enabled;
  // beepfile
  char *beepfile;
};

struct _eject_cfg
{
  // enabled
  signed int enabled;
  // device
  char *device;
};

struct _general_cfg
{
  // fnmode
  signed int fnmode;
};

struct _kbd_bck_info
{
  // level
  signed int level;
  // max
  signed int max;
  // inhibit
  signed int inhibit;
  // inhibit_lvl
  signed int inhibit_lvl;
  // toggle_lvl
  signed int toggle_lvl;
  // auto_on
  signed int auto_on;
  // idle
  signed int idle;
  // r_sens
  signed int r_sens;
  // l_sens
  signed int l_sens;
};

struct _kbd_cfg
{
  // auto_lvl
  signed int auto_lvl;
  // step
  signed int step;
  // on_thresh
  signed int on_thresh;
  // off_thresh
  signed int off_thresh;
  // auto_on
  signed int auto_on;
  // idle
  signed int idle;
  // idle_lvl
  signed int idle_lvl;
};

struct _lcd_bck_info
{
  // level
  signed int level;
  // ac_lvl
  signed int ac_lvl;
  // max
  signed int max;
};

struct _lcd_gma950_cfg
{
  // init
  unsigned int init;
  // step
  unsigned int step;
  // on_batt
  unsigned int on_batt;
};

struct _lcd_nv8600mgt_cfg
{
  // init
  signed int init;
  // step
  signed int step;
  // on_batt
  signed int on_batt;
};

struct _lcd_sysfs_cfg
{
  // init
  signed int init;
  // step
  signed int step;
  // on_batt
  signed int on_batt;
};

struct _lcd_x1600_cfg
{
  // init
  signed int init;
  // step
  signed int step;
  // on_batt
  signed int on_batt;
};

struct cfg_defvalue_t
{
  // number
  signed long int number;
  // fpnumber
  double fpnumber;
  // boolean
  enum anonymous$8 boolean;
  // string
  char *string;
  // parsed
  char *parsed;
};

struct cfg_opt_t
{
  // name
  char *name;
  // type
  enum cfg_type_t type;
  // nvalues
  unsigned int nvalues;
  // values
  union cfg_value_t **values;
  // flags
  signed int flags;
  // subopts
  struct cfg_opt_t *subopts;
  // def
  struct cfg_defvalue_t def;
  // func
  signed int (*func)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **);
  // simple_value
  void *simple_value;
  // parsecb
  signed int (*parsecb)(struct cfg_t *, struct cfg_opt_t *, const char *, void *);
  // validcb
  signed int (*validcb)(struct cfg_t *, struct cfg_opt_t *);
  // pf
  void (*pf)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *);
  // freecb
  void (*freecb)(void *);
};

struct cfg_t
{
  // flags
  signed int flags;
  // name
  char *name;
  // opts
  struct cfg_opt_t *opts;
  // title
  char *title;
  // filename
  char *filename;
  // line
  signed int line;
  // errfunc
  void (*errfunc)(struct cfg_t *, const char *, void **);
};

union cfg_value_t
{
  // number
  signed long int number;
  // fpnumber
  double fpnumber;
  // boolean
  enum anonymous$8 boolean;
  // string
  char *string;
  // section
  struct cfg_t *section;
  // ptr
  void *ptr;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct sample
{
  // audiodata
  char *audiodata;
  // audiodatalen
  signed int audiodatalen;
  // format
  signed int format;
  // channels
  unsigned int channels;
  // speed
  unsigned int speed;
  // framesize
  unsigned int framesize;
  // framecount
  signed int framecount;
  // periods
  unsigned int periods;
  // buffersize
  unsigned long int buffersize;
};

struct dspdata
{
  // command
  signed int command;
  // mutex
  union anonymous$4 mutex;
  // cond
  union anonymous$7 cond;
  // thread
  unsigned long int thread;
  // sample
  struct sample *sample[1l];
};

union epoll_data
{
  // ptr
  void *ptr;
  // fd
  signed int fd;
  // u32
  unsigned int u32;
  // u64
  unsigned long int u64;
};

struct epoll_event
{
  // events
  unsigned int events;
  // data
  union epoll_data data;
} __attribute__ ((__packed__));

struct inotify_event
{
  // wd
  signed int wd;
  // mask
  unsigned int mask;
  // cookie
  unsigned int cookie;
  // len
  unsigned int len;
  // name
  char name[0l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct input_event
{
  // time
  struct timeval time;
  // type
  unsigned short int type;
  // code
  unsigned short int code;
  // value
  signed int value;
};

struct input_id
{
  // bustype
  unsigned short int bustype;
  // vendor
  unsigned short int vendor;
  // product
  unsigned short int product;
  // version
  unsigned short int version;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct itimerspec
{
  // it_interval
  struct timespec it_interval;
  // it_value
  struct timespec it_value;
};

struct machine_ops
{
  // type
  enum anonymous$3 type;
  // lcd_backlight_probe
  signed int (*lcd_backlight_probe)(void);
  // lcd_backlight_step
  void (*lcd_backlight_step)(signed int);
  // lcd_backlight_toggle
  void (*lcd_backlight_toggle)(signed int);
};

struct pci_access
{
  // method
  unsigned int method;
  // writeable
  signed int writeable;
  // buscentric
  signed int buscentric;
  // id_file_name
  char *id_file_name;
  // free_id_name
  signed int free_id_name;
  // numeric_ids
  signed int numeric_ids;
  // id_lookup_mode
  unsigned int id_lookup_mode;
  // debugging
  signed int debugging;
  // error
  void (*error)(char *, ...);
  // warning
  void (*warning)(char *, ...);
  // debug
  void (*debug)(char *, ...);
  // devices
  struct pci_dev *devices;
  // methods
  struct pci_methods *methods;
  // params
  struct pci_param *params;
  // id_hash
  struct id_entry **id_hash;
  // current_id_bucket
  struct id_bucket *current_id_bucket;
  // id_load_failed
  signed int id_load_failed;
  // id_cache_status
  signed int id_cache_status;
  // id_udev
  struct udev *id_udev;
  // id_udev_hwdb
  struct udev_hwdb *id_udev_hwdb;
  // fd
  signed int fd;
  // fd_rw
  signed int fd_rw;
  // fd_pos
  signed int fd_pos;
  // fd_vpd
  signed int fd_vpd;
  // cached_dev
  struct pci_dev *cached_dev;
};

struct pci_cap
{
  // next
  struct pci_cap *next;
  // id
  unsigned short int id;
  // type
  unsigned short int type;
  // addr
  unsigned int addr;
};

struct pci_dev
{
  // next
  struct pci_dev *next;
  // domain
  unsigned short int domain;
  // bus
  unsigned char bus;
  // dev
  unsigned char dev;
  // func
  unsigned char func;
  // known_fields
  signed int known_fields;
  // vendor_id
  unsigned short int vendor_id;
  // device_id
  unsigned short int device_id;
  // device_class
  unsigned short int device_class;
  // irq
  signed int irq;
  // base_addr
  unsigned long int base_addr[6l];
  // size
  unsigned long int size[6l];
  // rom_base_addr
  unsigned long int rom_base_addr;
  // rom_size
  unsigned long int rom_size;
  // first_cap
  struct pci_cap *first_cap;
  // phy_slot
  char *phy_slot;
  // module_alias
  char *module_alias;
  // label
  char *label;
  // access
  struct pci_access *access;
  // methods
  struct pci_methods *methods;
  // cache
  unsigned char *cache;
  // cache_len
  signed int cache_len;
  // hdrtype
  signed int hdrtype;
  // aux
  void *aux;
};

struct pci_param
{
  // next
  struct pci_param *next;
  // param
  char *param;
  // value
  char *value;
  // value_malloced
  signed int value_malloced;
  // help
  char *help;
};

struct pommed_event
{
  // fd
  signed int fd;
  // cb
  void (*cb)(signed int, unsigned int);
  // next
  struct pommed_event *next;
};

struct pommed_timer
{
  // fd
  signed int fd;
  // timeout
  signed int timeout;
  // jobs
  struct pommed_timer_job *jobs;
  // next
  struct pommed_timer *next;
};

struct pommed_timer_job
{
  // id
  signed int id;
  // cb
  void (*cb)(signed int, unsigned long int);
  // next
  struct pommed_timer_job *next;
};

struct pommed_watch
{
  // watch
  struct DBusWatch *watch;
  // fd
  signed int fd;
  // events
  unsigned int events;
  // enabled
  signed int enabled;
  // next
  struct pommed_watch *next;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct snd_mixer_selem_regopt
{
  // ver
  signed int ver;
  // abstract
  enum snd_mixer_selem_regopt_abstract abstract;
  // device
  const char *device;
  // playback_pcm
  struct _snd_pcm *playback_pcm;
  // capture_pcm
  struct _snd_pcm *capture_pcm;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct uinput_user_dev
{
  // name
  char name[80l];
  // id
  struct input_id id;
  // ff_effects_max
  unsigned int ff_effects_max;
  // absmax
  signed int absmax[64l];
  // absmin
  signed int absmin[64l];
  // absfuzz
  signed int absfuzz[64l];
  // absflat
  signed int absflat[64l];
};

struct utsname
{
  // sysname
  char sysname[65l];
  // nodename
  char nodename[65l];
  // release
  char release[65l];
  // version
  char version[65l];
  // machine
  char machine[65l];
  // __domainname
  char __domainname[65l];
};

struct vt_stat
{
  // v_active
  unsigned short int v_active;
  // v_signal
  unsigned short int v_signal;
  // v_state
  unsigned short int v_state;
};


// GMA950_BACKLIGHT_MAX
// file mactel/gma950_backlight.c line 71
static unsigned int GMA950_BACKLIGHT_MAX;
// _dsp
// file beep.c line 325
struct dspdata _dsp;
// actual_brightness
// file sysfs_backlight.c line 60
static char *actual_brightness[7l] = { "/dev/null", "/sys/class/backlight/mbp_backlight/actual_brightness",
    "/sys/class/backlight/apple_backlight/actual_brightness",
    "/sys/class/backlight/gmux_backlight/actual_brightness",
    "/sys/class/backlight/nvidia_backlight/actual_brightness",
    "/sys/class/backlight/nv_backlight/actual_brightness",
    "/sys/class/backlight/acpi_video0/actual_brightness" };
// ambient_info
// file mactel/ambient.c line 40
struct _ambient_info ambient_info;
// appleir_cfg
// file conffile.c line 49
struct _appleir_cfg appleir_cfg;
// appleir_opts
// file conffile.c line 136
static struct cfg_opt_t appleir_opts[2l] = { { .name="enabled", .type=(enum cfg_type_t)4, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)0,
    .string=((char *)NULL), .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name=((char *)NULL), .type=(enum cfg_type_t)0, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) } };
// audio_cfg
// file conffile.c line 44
struct _audio_cfg audio_cfg;
// audio_info
// file audio.c line 34
struct _audio_info audio_info;
// audio_opts
// file conffile.c line 96
static struct cfg_opt_t audio_opts[9l] = { { .name="disabled", .type=(enum cfg_type_t)4, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)0,
    .string=((char *)NULL), .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="card", .type=(enum cfg_type_t)3, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string="default",
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="init", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)-1, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="step", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)10, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="beep", .type=(enum cfg_type_t)4, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)1,
    .string=((char *)NULL), .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="volume", .type=(enum cfg_type_t)3, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string="PCM",
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="speakers", .type=(enum cfg_type_t)3, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string="Front",
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="headphones", .type=(enum cfg_type_t)3, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string="Headphone",
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name=((char *)NULL), .type=(enum cfg_type_t)0, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) } };
// bck_driver
// file sysfs_backlight.c line 57
static signed int bck_driver = 0;
// beep_cfg
// file conffile.c line 47
struct _beep_cfg beep_cfg;
// beep_fd
// file beep.c line 60
static signed int beep_fd;
// beep_opts
// file conffile.c line 128
static struct cfg_opt_t beep_opts[3l] = { { .name="enabled", .type=(enum cfg_type_t)4, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)0,
    .string=((char *)NULL), .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="beepfile", .type=(enum cfg_type_t)3, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string="/usr/share/pommed/goutte.wav",
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name=((char *)NULL), .type=(enum cfg_type_t)0, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) } };
// beep_thread_running
// file beep.c line 61
static signed int beep_thread_running = 0;
// bl_port
// file mactel/nv8600mgt_backlight.c line 55
static unsigned int bl_port;
// brightness
// file sysfs_backlight.c line 79
static char *brightness[7l] = { "/dev/null", "/sys/class/backlight/mbp_backlight/brightness",
    "/sys/class/backlight/apple_backlight/brightness",
    "/sys/class/backlight/gmux_backlight/brightness",
    "/sys/class/backlight/nvidia_backlight/brightness",
    "/sys/class/backlight/nv_backlight/brightness",
    "/sys/class/backlight/acpi_video0/brightness" };
// conn
// file dbus.c line 43
static struct DBusConnection *conn;
// console
// file pommed.c line 417
signed int console = 0;
// dbus_timer
// file dbus.c line 45
static signed int dbus_timer;
// debug
// file pommed.c line 416
signed int debug = 0;
// eject_cfg
// file conffile.c line 46
struct _eject_cfg eject_cfg;
// eject_opts
// file conffile.c line 121
static struct cfg_opt_t eject_opts[3l] = { { .name="enabled", .type=(enum cfg_type_t)4, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)1,
    .string=((char *)NULL), .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="device", .type=(enum cfg_type_t)3, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string="/dev/dvd",
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name=((char *)NULL), .type=(enum cfg_type_t)0, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) } };
// epfd
// file evloop.c line 45
static signed int epfd;
// err
// file dbus.c line 42
static struct DBusError err;
// fd
// file mactel/x1600_backlight.c line 50
static signed int fd = -1;
// fd$link1
// file mactel/gma950_backlight.c line 73
static signed int fd$link1 = -1;
// general_cfg
// file conffile.c line 37
struct _general_cfg general_cfg;
// general_opts
// file conffile.c line 54
static struct cfg_opt_t general_opts[2l] = { { .name="fnmode", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)1, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name=((char *)NULL), .type=(enum cfg_type_t)0, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) } };
// head_elem
// file audio.c line 39
static struct _snd_mixer_elem *head_elem;
// internal_kbd_fd
// file evdev.c line 67
static signed int internal_kbd_fd;
// kbd_bck_info
// file mactel/kbd_backlight.c line 42
struct _kbd_bck_info kbd_bck_info;
// kbd_cfg
// file conffile.c line 45
struct _kbd_cfg kbd_cfg;
// kbd_opts
// file conffile.c line 109
static struct cfg_opt_t kbd_opts[8l] = { { .name="default", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)100, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="step", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)10, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="on_threshold", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)20, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="off_threshold", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)40, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="auto", .type=(enum cfg_type_t)4, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)1,
    .string=((char *)NULL), .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="idle_timer", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)60, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="idle_level", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name=((char *)NULL), .type=(enum cfg_type_t)0, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) } };
// kbd_timer
// file mactel/../kbd_auto.c line 21
static signed int kbd_timer;
// lcd_bck_info
// file sysfs_backlight.c line 117
struct _lcd_bck_info lcd_bck_info;
// lcd_gma950_cfg
// file conffile.c line 41
struct _lcd_gma950_cfg lcd_gma950_cfg;
// lcd_gma950_opts
// file conffile.c line 78
static struct cfg_opt_t lcd_gma950_opts[4l] = { { .name="init", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)-1, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="step", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0x0f, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="on_batt", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name=((char *)NULL), .type=(enum cfg_type_t)0, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) } };
// lcd_nv8600mgt_cfg
// file conffile.c line 42
struct _lcd_nv8600mgt_cfg lcd_nv8600mgt_cfg;
// lcd_nv8600mgt_opts
// file conffile.c line 86
static struct cfg_opt_t lcd_nv8600mgt_opts[4l] = { { .name="init", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)-1, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="step", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)1, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="on_batt", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name=((char *)NULL), .type=(enum cfg_type_t)0, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) } };
// lcd_sysfs_cfg
// file conffile.c line 38
struct _lcd_sysfs_cfg lcd_sysfs_cfg;
// lcd_sysfs_opts
// file conffile.c line 60
static struct cfg_opt_t lcd_sysfs_opts[4l] = { { .name="init", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)-1, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="step", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)8, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="on_batt", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name=((char *)NULL), .type=(enum cfg_type_t)0, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) } };
// lcd_x1600_cfg
// file conffile.c line 40
struct _lcd_x1600_cfg lcd_x1600_cfg;
// lcd_x1600_opts
// file conffile.c line 70
static struct cfg_opt_t lcd_x1600_opts[4l] = { { .name="init", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)-1, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="step", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)10, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="on_batt", .type=(enum cfg_type_t)1, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name=((char *)NULL), .type=(enum cfg_type_t)0, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) } };
// length
// file mactel/x1600_backlight.c line 53
static signed long int length = (signed long int)0;
// length$link1
// file mactel/gma950_backlight.c line 76
static signed long int length$link1 = (signed long int)0;
// max_brightness
// file sysfs_backlight.c line 98
static char *max_brightness[7l] = { "/dev/null", "/sys/class/backlight/mbp_backlight/max_brightness",
    "/sys/class/backlight/apple_backlight/max_brightness",
    "/sys/class/backlight/gmux_backlight/max_brightness",
    "/sys/class/backlight/nvidia_backlight/max_brightness",
    "/sys/class/backlight/nv_backlight/max_brightness",
    "/sys/class/backlight/acpi_video0/max_brightness" };
// mb_mops
// file pommed.c line 243
struct machine_ops mb_mops[19l];
// mb_mops
// file pommed.c line 243
struct machine_ops mb_mops[19l] = { { .type=(enum anonymous$3)MACHINE_MACBOOKPRO_1, .lcd_backlight_probe=x1600_backlight_probe,
    .lcd_backlight_step=x1600_backlight_step,
    .lcd_backlight_toggle=x1600_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOKPRO_2, .lcd_backlight_probe=x1600_backlight_probe,
    .lcd_backlight_step=x1600_backlight_step,
    .lcd_backlight_toggle=x1600_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOKPRO_3, .lcd_backlight_probe=mbp_sysfs_backlight_probe,
    .lcd_backlight_step=sysfs_backlight_step,
    .lcd_backlight_toggle=sysfs_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOKPRO_4, .lcd_backlight_probe=mbp_sysfs_backlight_probe,
    .lcd_backlight_step=sysfs_backlight_step,
    .lcd_backlight_toggle=sysfs_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOKPRO_5, .lcd_backlight_probe=mbp_sysfs_backlight_probe,
    .lcd_backlight_step=sysfs_backlight_step,
    .lcd_backlight_toggle=sysfs_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOKPRO_6, .lcd_backlight_probe=mbp_sysfs_backlight_probe,
    .lcd_backlight_step=sysfs_backlight_step,
    .lcd_backlight_toggle=sysfs_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOKPRO_7, .lcd_backlight_probe=mbp_sysfs_backlight_probe,
    .lcd_backlight_step=sysfs_backlight_step,
    .lcd_backlight_toggle=sysfs_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOKPRO_8, .lcd_backlight_probe=mbp_sysfs_backlight_probe,
    .lcd_backlight_step=sysfs_backlight_step,
    .lcd_backlight_toggle=sysfs_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOKPRO_9, .lcd_backlight_probe=mbp_sysfs_backlight_probe,
    .lcd_backlight_step=sysfs_backlight_step,
    .lcd_backlight_toggle=sysfs_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOK_1, .lcd_backlight_probe=gma950_backlight_probe,
    .lcd_backlight_step=gma950_backlight_step,
    .lcd_backlight_toggle=gma950_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOK_2, .lcd_backlight_probe=gma950_backlight_probe,
    .lcd_backlight_step=gma950_backlight_step,
    .lcd_backlight_toggle=gma950_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOK_3, .lcd_backlight_probe=gma950_backlight_probe,
    .lcd_backlight_step=gma950_backlight_step,
    .lcd_backlight_toggle=gma950_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOK_4, .lcd_backlight_probe=gma950_backlight_probe,
    .lcd_backlight_step=gma950_backlight_step,
    .lcd_backlight_toggle=gma950_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOK_5, .lcd_backlight_probe=mbp_sysfs_backlight_probe,
    .lcd_backlight_step=sysfs_backlight_step,
    .lcd_backlight_toggle=sysfs_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOK_6, .lcd_backlight_probe=mbp_sysfs_backlight_probe,
    .lcd_backlight_step=sysfs_backlight_step,
    .lcd_backlight_toggle=sysfs_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOK_7, .lcd_backlight_probe=mbp_sysfs_backlight_probe,
    .lcd_backlight_step=sysfs_backlight_step,
    .lcd_backlight_toggle=sysfs_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOKAIR_1, .lcd_backlight_probe=gma950_backlight_probe,
    .lcd_backlight_step=gma950_backlight_step,
    .lcd_backlight_toggle=gma950_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOKAIR_2, .lcd_backlight_probe=mbp_sysfs_backlight_probe,
    .lcd_backlight_step=sysfs_backlight_step,
    .lcd_backlight_toggle=sysfs_backlight_toggle },
    { .type=(enum anonymous$3)MACHINE_MACBOOKAIR_3, .lcd_backlight_probe=mbp_sysfs_backlight_probe,
    .lcd_backlight_step=sysfs_backlight_step,
    .lcd_backlight_toggle=sysfs_backlight_toggle } };
// memory
// file mactel/x1600_backlight.c line 51
static char *memory = (char *)(void *)0;
// memory$link1
// file mactel/gma950_backlight.c line 74
static char *memory$link1 = (char *)(void *)0;
// mixer_hdl
// file audio.c line 36
static struct _snd_mixer *mixer_hdl;
// mops
// file pommed.c line 60
struct machine_ops *mops;
// nv8600mgt_inited
// file mactel/nv8600mgt_backlight.c line 54
static signed int nv8600mgt_inited = 0;
// opts
// file conffile.c line 143
static struct cfg_opt_t opts[11l];
// opts
// file conffile.c line 143
static struct cfg_opt_t opts[11l] = { { .name="general", .type=(enum cfg_type_t)5, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=general_opts, .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) }, .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="lcd_sysfs", .type=(enum cfg_type_t)5, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=lcd_sysfs_opts, .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) }, .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="lcd_x1600", .type=(enum cfg_type_t)5, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=lcd_x1600_opts, .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) }, .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="lcd_gma950", .type=(enum cfg_type_t)5, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=lcd_gma950_opts, .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) }, .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="lcd_nv8600mgt", .type=(enum cfg_type_t)5, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=lcd_nv8600mgt_opts, .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="audio", .type=(enum cfg_type_t)5, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=audio_opts, .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) }, .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="kbd", .type=(enum cfg_type_t)5, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=kbd_opts, .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) }, .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="eject", .type=(enum cfg_type_t)5, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=eject_opts, .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) }, .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="beep", .type=(enum cfg_type_t)5, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=beep_opts, .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) }, .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name="appleir", .type=(enum cfg_type_t)5, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=appleir_opts, .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) }, .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) },
    { .name=((char *)NULL), .type=(enum cfg_type_t)0, .nvalues=(unsigned int)0,
    .values=((union cfg_value_t **)NULL), .flags=0,
    .subopts=((struct cfg_opt_t *)NULL), .def={ .number=(signed long int)0, .fpnumber=(double)0, .boolean=(enum anonymous$8)cfg_false,
    .string=((char *)NULL),
    .parsed=((char *)NULL) },
    .func=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, signed int, const char **))NULL),
    .simple_value=NULL,
    .parsecb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *, const char *, void *))NULL), .validcb=((signed int (*)(struct cfg_t *, struct cfg_opt_t *))NULL),
    .pf=((void (*)(struct cfg_opt_t *, unsigned int, struct _IO_FILE *))NULL),
    .freecb=((void (*)(void *))NULL) } };
// play
// file audio.c line 44
static signed int play;
// power_timer
// file power.c line 40
static signed int power_timer;
// prev_state
// file power.c line 39
static signed int prev_state;
// running
// file evloop.c line 54
static signed int running;
// smcpath
// file mactel/ambient.c line 37
static char *smcpath;
// sources
// file evloop.c line 48
static struct pommed_event *sources;
// spkr_elem
// file audio.c line 38
static struct _snd_mixer_elem *spkr_elem;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// sysfs_resource
// file mactel/x1600_backlight.c line 52
static char sysfs_resource[64l];
// sysfs_resource$link1
// file mactel/gma950_backlight.c line 75
static char sysfs_resource$link1[64l];
// timer_job_id
// file evloop.c line 52
static signed int timer_job_id;
// timers
// file evloop.c line 51
static struct pommed_timer *timers;
// vol_elem
// file audio.c line 37
static struct _snd_mixer_elem *vol_elem;
// vol_max
// file audio.c line 42
static signed long int vol_max;
// vol_min
// file audio.c line 41
static signed long int vol_min;
// vol_step
// file audio.c line 43
static signed long int vol_step;
// watches
// file dbus.c line 866
static struct pommed_watch *watches;

// ambient_get
// file mactel/../ambient.h line 40
void ambient_get(signed int *r, signed int *l)
{
  signed int ambient_get$$1$$fd;
  signed int ret;
  char buf[16l];
  char *p;
  signed long int return_value_read$1;
  unsigned long int return_value_strlen$2;
  char *return_value___builtin_strchr$3;
  char *tmp_post$4;
  if(!(smcpath == ((char *)NULL)))
  {
    ambient_get$$1$$fd=open(smcpath, 00);
    if(!(ambient_get$$1$$fd >= 0))
      goto out_error;

    return_value_read$1=read(ambient_get$$1$$fd, (void *)buf, (unsigned long int)16);
    ret = (signed int)return_value_read$1;
    close(ambient_get$$1$$fd);
    if(ret >= 16 || !(ret >= 1))
      goto out_error;

    return_value_strlen$2=strlen(buf);
    buf[(signed long int)return_value_strlen$2] = (char)0;
    return_value___builtin_strchr$3=__builtin_strchr(buf, 44);
    p = return_value___builtin_strchr$3;
    tmp_post$4 = p;
    p = p + 1l;
    *tmp_post$4 = (char)0;
    *r=atoi$link2(p);
    p = buf + (signed long int)1;
    *l=atoi$link2(p);
    logdebug("Ambient light: right %d, left %d\n", *r, *l);
    ambient_info.right = *r;
    ambient_info.left = *l;
  }

  else
  {

  out_error:
    ;
    *r = -1;
    *l = -1;
    ambient_info.right = 0;
    ambient_info.left = 0;
  }
}

// ambient_init
// file mactel/../ambient.h line 43
void ambient_init(signed int *r, signed int *l)
{
  char devpath[4096l];
  char devname[9l];
  char *p;
  struct __dirstream *pdev;
  struct dirent *pdevent;
  signed int ambient_init$$1$$fd;
  signed int ret;
  smcpath = (char *)(void *)0;
  pdev=opendir("/sys/class/hwmon");
  signed int tmp_statement_expression$8;
  if(!(pdev == ((struct __dirstream *)NULL)))
  {
    do
    {
      pdevent=readdir(pdev);
      if(pdevent == ((struct dirent *)NULL))
        break;

      if(!((signed int)pdevent->d_name[0l] == 46))
      {
        ret=snprintf(devpath, sizeof(char [4096l]) /*4096ul*/ , "/sys/class/hwmon/%s/device/name", (const void *)pdevent->d_name);
        if((unsigned long int)ret >= sizeof(char [4096l]) /*4096ul*/  || !(ret >= 0))
          logmsg(4, "Failed to build hwmon probe path");

        else
        {
          ambient_init$$1$$fd=open(devpath, 00);
          if(!(ambient_init$$1$$fd >= 0))
          {
            signed int *return_value___errno_location$1;
            return_value___errno_location$1=__errno_location();
            char *return_value_strerror$2;
            return_value_strerror$2=strerror(*return_value___errno_location$1);
            logmsg(3, "Could not open %s: %s", (const void *)devpath, return_value_strerror$2);
            continue;
          }

          memset((void *)devname, 0, sizeof(char [9l]) /*9ul*/ );
          signed long int return_value_read$3;
          return_value_read$3=read(ambient_init$$1$$fd, (void *)devname, sizeof(char [9l]) /*9ul*/  - (unsigned long int)1);
          ret = (signed int)return_value_read$3;
          close(ambient_init$$1$$fd);
          if((unsigned long int)ret == 8ul)
          {
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp$9;
            return_value___builtin_strcmp$9=__builtin_strcmp(devname, "applesmc");
            tmp_statement_expression$8 = return_value___builtin_strcmp$9;
            if(tmp_statement_expression$8 == 0)
            {
              p=strrchr(devpath, 47);
              *p = (char)0;
              logmsg(6, "Found applesmc at %s", (const void *)devpath);
              smcpath=realpath(devpath, (char *)(void *)0);
              if(smcpath == ((char *)NULL))
              {
                signed int *return_value___errno_location$4;
                return_value___errno_location$4=__errno_location();
                char *return_value_strerror$5;
                return_value_strerror$5=strerror(*return_value___errno_location$4);
                logmsg(3, "Could not dereference applesmc device path: %s\n", return_value_strerror$5);
                break;
              }

              logmsg(6, "Dereferenced applesmc to %s", smcpath);
              unsigned long int return_value_strlen$6;
              return_value_strlen$6=strlen(smcpath);
              void *return_value_realloc$7;
              return_value_realloc$7=realloc((void *)smcpath, return_value_strlen$6 + (unsigned long int)1 + (unsigned long int)6);
              smcpath = (char *)return_value_realloc$7;
              if(smcpath == ((char *)NULL))
                break;

              strcat(smcpath, "/light");
              break;
            }

          }

        }
      }

    }
    while((_Bool)1);
    closedir(pdev);
  }

  ambient_get(r, l);
  ambient_info.max = 255;
  ambient_info.left = *l;
  ambient_info.right = *r;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1;
}

// atoi$link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi$link1(const char *__nptr$link1)
{
  signed long int return_value_strtol$1$link1;
  return_value_strtol$1$link1=strtol(__nptr$link1, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1$link1;
}

// atoi$link2
// file /usr/include/stdlib.h line 278
static inline signed int atoi$link2(const char *__nptr$link2)
{
  signed long int return_value_strtol$1$link2;
  return_value_strtol$1$link2=strtol(__nptr$link2, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1$link2;
}

// audio_cleanup
// file audio.c line 272
void audio_cleanup(void)
{
  if(!(mixer_hdl == ((struct _snd_mixer *)NULL)))
  {
    snd_mixer_detach(mixer_hdl, audio_cfg.card);
    snd_mixer_close(mixer_hdl);
    mixer_hdl = (struct _snd_mixer *)(void *)0;
  }

}

// audio_fix_config
// file audio.h line 32
void audio_fix_config(void)
{
  if(!(audio_cfg.init >= 0))
    audio_cfg.init = -1;

  if(audio_cfg.init >= 101)
    audio_cfg.init = 100;

  if(!(audio_cfg.step >= 1))
    audio_cfg.step = 1;

  if(audio_cfg.step >= 51)
    audio_cfg.step = 50;

}

// audio_init
// file audio.h line 26
signed int audio_init(void)
{
  struct _snd_mixer_elem *elem;
  struct _snd_mixer_selem_id *sid;
  double dvol;
  signed long int vol;
  signed int ret;
  vol_elem = (struct _snd_mixer_elem *)(void *)0;
  spkr_elem = (struct _snd_mixer_elem *)(void *)0;
  head_elem = (struct _snd_mixer_elem *)(void *)0;
  signed int tmp_statement_expression$8;
  signed int tmp_statement_expression$11;
  signed int tmp_statement_expression$14;
  if(!(audio_cfg.disabled == 0))
  {
    audio_info.level = 0;
    audio_info.max = 0;
    audio_info.muted = 1;
    return 0;
  }

  else
  {
    play = 1;
    ret=snd_mixer_open(&mixer_hdl, 0);
    if(!(ret >= 0))
    {
      const char *return_value_snd_strerror$1;
      return_value_snd_strerror$1=snd_strerror(ret);
      logdebug("Failed to open mixer: %s\n", return_value_snd_strerror$1);
      mixer_hdl = (struct _snd_mixer *)(void *)0;
      return -1;
    }

    ret=snd_mixer_attach(mixer_hdl, audio_cfg.card);
    if(!(ret >= 0))
    {
      const char *return_value_snd_strerror$2;
      return_value_snd_strerror$2=snd_strerror(ret);
      logdebug("Failed to attach mixer: %s\n", return_value_snd_strerror$2);
      snd_mixer_close(mixer_hdl);
      return -1;
    }

    ret=snd_mixer_selem_register(mixer_hdl, (struct snd_mixer_selem_regopt *)(void *)0, (struct _snd_mixer_class **)(void *)0);
    if(!(ret >= 0))
    {
      const char *return_value_snd_strerror$3;
      return_value_snd_strerror$3=snd_strerror(ret);
      logdebug("Failed to register mixer: %s\n", return_value_snd_strerror$3);
      snd_mixer_detach(mixer_hdl, audio_cfg.card);
      snd_mixer_close(mixer_hdl);
      return -1;
    }

    ret=snd_mixer_load(mixer_hdl);
    if(!(ret >= 0))
    {
      const char *return_value_snd_strerror$4;
      return_value_snd_strerror$4=snd_strerror(ret);
      logdebug("Failed to load mixer: %s\n", return_value_snd_strerror$4);
      snd_mixer_detach(mixer_hdl, audio_cfg.card);
      snd_mixer_close(mixer_hdl);
      return -1;
    }

    do
    {
      unsigned long int return_value_snd_mixer_selem_id_sizeof$5;
      return_value_snd_mixer_selem_id_sizeof$5=snd_mixer_selem_id_sizeof();
      void *return_value___builtin_alloca$6;
      return_value___builtin_alloca$6=__builtin_alloca(return_value_snd_mixer_selem_id_sizeof$5);
      *(&sid) = (struct _snd_mixer_selem_id *)return_value___builtin_alloca$6;
      unsigned long int return_value_snd_mixer_selem_id_sizeof$7;
      return_value_snd_mixer_selem_id_sizeof$7=snd_mixer_selem_id_sizeof();
      memset((void *)*(&sid), 0, return_value_snd_mixer_selem_id_sizeof$7);
    }
    while((_Bool)0);
    elem=snd_mixer_first_elem(mixer_hdl);
    while(!(elem == ((struct _snd_mixer_elem *)NULL)))
    {
      snd_mixer_selem_get_id(elem, sid);
      unsigned long int audio_init$$1$$7$$1$$1$$__s1_len;
      unsigned long int audio_init$$1$$7$$1$$1$$__s2_len;
      const char *return_value_snd_mixer_selem_id_get_name$9;
      return_value_snd_mixer_selem_id_get_name$9=snd_mixer_selem_id_get_name(sid);
      signed int return_value___builtin_strcmp$10;
      return_value___builtin_strcmp$10=__builtin_strcmp(return_value_snd_mixer_selem_id_get_name$9, audio_cfg.vol);
      tmp_statement_expression$8 = return_value___builtin_strcmp$10;
      if(tmp_statement_expression$8 == 0)
        vol_elem = elem;

      unsigned long int __s1_len;
      unsigned long int __s2_len;
      const char *return_value_snd_mixer_selem_id_get_name$12;
      return_value_snd_mixer_selem_id_get_name$12=snd_mixer_selem_id_get_name(sid);
      signed int return_value___builtin_strcmp$13;
      return_value___builtin_strcmp$13=__builtin_strcmp(return_value_snd_mixer_selem_id_get_name$12, audio_cfg.spkr);
      tmp_statement_expression$11 = return_value___builtin_strcmp$13;
      if(tmp_statement_expression$11 == 0)
        spkr_elem = elem;

      unsigned long int audio_init$$1$$7$$1$$3$$__s1_len;
      unsigned long int audio_init$$1$$7$$1$$3$$__s2_len;
      const char *return_value_snd_mixer_selem_id_get_name$15;
      return_value_snd_mixer_selem_id_get_name$15=snd_mixer_selem_id_get_name(sid);
      signed int return_value___builtin_strcmp$16;
      return_value___builtin_strcmp$16=__builtin_strcmp(return_value_snd_mixer_selem_id_get_name$15, audio_cfg.head);
      tmp_statement_expression$14 = return_value___builtin_strcmp$16;
      if(tmp_statement_expression$14 == 0)
        head_elem = elem;

      elem=snd_mixer_elem_next(elem);
    }
    logdebug("Audio init: volume %s, speakers %s, headphones %s\n", vol_elem == (struct _snd_mixer_elem *)(void *)0 ? "NOK" : "OK", spkr_elem == (struct _snd_mixer_elem *)(void *)0 ? "NOK" : "OK", head_elem == (struct _snd_mixer_elem *)(void *)0 ? "NOK" : "OK");
    if(vol_elem == ((struct _snd_mixer_elem *)NULL) || head_elem == ((struct _snd_mixer_elem *)NULL) && spkr_elem == ((struct _snd_mixer_elem *)NULL))
    {
      logdebug("Failed to open required mixer elements\n");
      audio_cleanup();
      return -1;
    }

    else
    {
      snd_mixer_selem_get_playback_volume_range(vol_elem, &vol_min, &vol_max);
      dvol = (double)(vol_max - vol_min) / 100.0;
      vol_step = (signed long int)(dvol * (double)audio_cfg.step);
      logdebug("Audio init: min %ld, max %ld, step %ld\n", vol_min, vol_max, vol_step);
      if(audio_cfg.init >= 0)
      {
        dvol = dvol * (double)audio_cfg.init;
        vol = (signed long int)dvol;
        if(!(vol_max >= vol))
          vol = vol_max;

        snd_mixer_selem_set_playback_volume(vol_elem, (enum _snd_mixer_selem_channel_id)0, vol);
        signed int return_value_snd_mixer_selem_is_playback_mono$17;
        return_value_snd_mixer_selem_is_playback_mono$17=snd_mixer_selem_is_playback_mono(vol_elem);
        if(return_value_snd_mixer_selem_is_playback_mono$17 == 0)
          snd_mixer_selem_set_playback_volume(vol_elem, (enum _snd_mixer_selem_channel_id)1, vol);

      }

      snd_mixer_handle_events(mixer_hdl);
      snd_mixer_selem_get_playback_volume(vol_elem, (enum _snd_mixer_selem_channel_id)0, &vol);
      audio_info.level = (signed int)vol;
      audio_info.max = (signed int)vol_max;
      audio_info.muted = (signed int)!(play != 0);
      return 0;
    }
  }
}

// audio_set_mute_elem
// file audio.c line 104
static void audio_set_mute_elem(struct _snd_mixer_elem *elem)
{
  signed int return_value_snd_mixer_selem_is_active$3;
  return_value_snd_mixer_selem_is_active$3=snd_mixer_selem_is_active(elem);
  signed int return_value_snd_mixer_selem_has_playback_switch$2;
  if(!(return_value_snd_mixer_selem_is_active$3 == 0))
  {
    return_value_snd_mixer_selem_has_playback_switch$2=snd_mixer_selem_has_playback_switch(elem);
    if(!(return_value_snd_mixer_selem_has_playback_switch$2 == 0))
    {
      snd_mixer_selem_set_playback_switch(elem, (enum _snd_mixer_selem_channel_id)0, play);
      signed int return_value_snd_mixer_selem_is_playback_mono$1;
      return_value_snd_mixer_selem_is_playback_mono$1=snd_mixer_selem_is_playback_mono(elem);
      if(return_value_snd_mixer_selem_is_playback_mono$1 == 0)
        snd_mixer_selem_set_playback_switch(elem, (enum _snd_mixer_selem_channel_id)1, play);

    }

  }

}

// audio_step
// file audio.h line 20
void audio_step(signed int dir)
{
  signed long int vol;
  signed long int newvol;
  if(!(mixer_hdl == ((struct _snd_mixer *)NULL)))
  {
    if(!(vol_elem == ((struct _snd_mixer_elem *)NULL)))
    {
      snd_mixer_handle_events(mixer_hdl);
      signed int return_value_snd_mixer_selem_is_active$1;
      return_value_snd_mixer_selem_is_active$1=snd_mixer_selem_is_active(vol_elem);
      if(!(return_value_snd_mixer_selem_is_active$1 == 0))
      {
        snd_mixer_selem_get_playback_volume(vol_elem, (enum _snd_mixer_selem_channel_id)0, &vol);
        logdebug("Mixer volume: %ld\n", vol);
        if(dir == 1)
        {
          newvol = vol + vol_step;
          if(!(vol_max >= newvol))
            newvol = vol_max;

          logdebug("Audio stepping +%ld -> %ld\n", vol_step, newvol);
        }

        else
          if(dir == -1)
          {
            newvol = vol - vol_step;
            if(!(newvol >= vol_min))
              newvol = vol_min;

            logdebug("Audio stepping -%ld -> %ld\n", vol_step, newvol);
          }

          else
            goto __CPROVER_DUMP_L11;
        snd_mixer_selem_set_playback_volume(vol_elem, (enum _snd_mixer_selem_channel_id)0, newvol);
        signed int return_value_snd_mixer_selem_is_playback_mono$2;
        return_value_snd_mixer_selem_is_playback_mono$2=snd_mixer_selem_is_playback_mono(vol_elem);
        if(return_value_snd_mixer_selem_is_playback_mono$2 == 0)
          snd_mixer_selem_set_playback_volume(vol_elem, (enum _snd_mixer_selem_channel_id)1, newvol);

        if(!(audio_cfg.beep == 0))
          beep_audio();

        mbpdbus_send_audio_volume((signed int)newvol, (signed int)vol);
        audio_info.level = (signed int)newvol;
      }

    }

  }


__CPROVER_DUMP_L11:
  ;
}

// audio_toggle_mute
// file audio.h line 23
void audio_toggle_mute(void)
{
  if(!(mixer_hdl == ((struct _snd_mixer *)NULL)))
  {
    snd_mixer_handle_events(mixer_hdl);
    play = (signed int)!(play != 0);
    if(!(spkr_elem == ((struct _snd_mixer_elem *)NULL)))
      audio_set_mute_elem(spkr_elem);

    if(!(head_elem == ((struct _snd_mixer_elem *)NULL)))
      audio_set_mute_elem(head_elem);

    mbpdbus_send_audio_mute((signed int)!(play != 0));
    audio_info.muted = (signed int)!(play != 0);
  }

}

// beep_audio
// file beep.h line 13
void beep_audio(void)
{
  if(audio_info.muted == 0)
    beep_thread_command(0);

}

// beep_beep
// file beep.c line 76
static void beep_beep(void)
{
  if(!(beep_cfg.enabled == 0))
  {
    if(audio_info.muted == 0)
      beep_thread_command(0);

  }

}

// beep_cleanup
// file beep.h line 19
void beep_cleanup(void)
{
  if(!(beep_thread_running == 0))
  {
    beep_thread_command(-1);
    beep_thread_cleanup();
  }

  beep_close_device();
}

// beep_close_device
// file beep.c line 188
static void beep_close_device(void)
{
  if(!(beep_cfg.enabled == 0) && !(beep_fd == -1))
  {
    evloop_remove(beep_fd);
    ioctl(beep_fd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(85 << 0 + 8) | (unsigned int)(2 << 0) | (unsigned int)(0 << 0 + 8 + 8)), (void *)0);
    close(beep_fd);
    beep_fd = -1;
  }

}

// beep_fix_config
// file beep.h line 22
void beep_fix_config(void)
{
  char *return_value___strdup$1;
  if(!(beep_cfg.enabled == 0))
  {
    if(beep_cfg.beepfile == ((char *)NULL))
    {
      return_value___strdup$1=__strdup("/usr/share/pommed/goutte.wav");
      beep_cfg.beepfile = return_value___strdup$1;
    }

    signed int return_value_access$8;
    return_value_access$8=access(beep_cfg.beepfile, 4);
    if(!(return_value_access$8 == 0))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      logmsg(4, "beep: cannot access WAV file %s: %s", beep_cfg.beepfile, return_value_strerror$3);
      signed int return_value_access$7;
      return_value_access$7=access("/usr/share/pommed/goutte.wav", 4);
      if(return_value_access$7 == 0)
      {
        logmsg(4, "beep: falling back to default file %s", (const void *)"/usr/share/pommed/goutte.wav");
        free((void *)beep_cfg.beepfile);
        char *return_value___strdup$4;
        return_value___strdup$4=__strdup("/usr/share/pommed/goutte.wav");
        beep_cfg.beepfile = return_value___strdup$4;
      }

      else
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        logmsg(3, "beep: cannot access default file %s: %s", (const void *)"/usr/share/pommed/goutte.wav", return_value_strerror$6);
        logmsg(3, "beep: disabling beeper");
        beep_cfg.enabled = 0;
      }
    }

  }

}

// beep_init
// file beep.h line 16
signed int beep_init(void)
{
  signed int ret;
  beep_fd = -1;
  ret=beep_thread_init();
  if(!(ret >= 0))
  {
    logmsg(3, "beep: thread init failed, disabling");
    beep_cfg.enabled = 0;
    return -1;
  }

  else
  {
    beep_thread_running = 1;
    ret=beep_open_device();
    if(!(ret >= 0))
      return -1;

    else
    {
      ret=evloop_add(beep_fd, (unsigned int)1, beep_process_events);
      if(!(ret >= 0))
      {
        logmsg(3, "Could not add device to event loop");
        beep_cfg.enabled = 0;
        beep_close_device();
        return -1;
      }

      else
        return 0;
    }
  }
}

// beep_load_sample
// file beep.c line 329
static struct sample * beep_load_sample(char *filename)
{
  struct _AFfilehandle *affd;
  signed long int framecount;
  signed int dummy;
  signed int channels;
  signed int byteorder;
  signed int framesize;
  signed int precision;
  struct sample *sample;
  signed int ret;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct sample) /*48ul*/ );
  sample = (struct sample *)return_value_malloc$1;
  if(sample == ((struct sample *)NULL))
    return (struct sample *)(void *)0;

  else
  {
    affd=afOpenFile(filename, "r", ((struct _AFfilesetup *)NULL));
    if(affd == ((struct _AFfilehandle *)NULL))
    {
      free((void *)sample);
      return (struct sample *)(void *)0;
    }

    else
    {
      afGetSampleFormat(affd, 1001, &dummy, &precision);
      channels=afGetChannels(affd, 1001);
      byteorder=afGetVirtualByteOrder(affd, 1001);
      float return_value_afGetFrameSize$2;
      return_value_afGetFrameSize$2=afGetFrameSize(affd, 1001, 0);
      framesize = (signed int)return_value_afGetFrameSize$2;
      framecount=afGetFrameCount(affd, 1001);
      double return_value_afGetRate$3;
      return_value_afGetRate$3=afGetRate(affd, 1001);
      sample->speed = (unsigned int)(signed int)return_value_afGetRate$3;
      if(!(channels >= 3))
        sample->channels = (unsigned int)channels;

      else
        goto error_out;
      switch(precision)
      {
        case 8:
        {
          sample->format = SND_PCM_FORMAT_S8;
          break;
        }
        case 16:
        {
          if(byteorder == 502)
            sample->format = SND_PCM_FORMAT_S16_LE;

          else
            sample->format = SND_PCM_FORMAT_S16_BE;
          break;
        }
        default:
          goto error_out;
      }
      sample->framesize = (unsigned int)framesize;
      sample->periods = sample->framesize;
      sample->buffersize = (unsigned long int)(sample->periods * (unsigned int)8192 >> 2);
      sample->framecount = (signed int)framecount;
      sample->audiodatalen = (signed int)(framecount * (signed long int)framesize);
      void *return_value_malloc$4;
      return_value_malloc$4=malloc((unsigned long int)sample->audiodatalen);
      sample->audiodata = (char *)return_value_malloc$4;
      if(!(sample->audiodata == ((char *)NULL)))
      {
        ret=afReadFrames(affd, 1001, (void *)sample->audiodata, (signed int)framecount);
        if(!((signed long int)ret == framecount))
        {
          free((void *)sample->audiodata);
          goto error_out;
        }

      }

      else
        goto error_out;
      afCloseFile(affd);
      return sample;

    error_out:
      ;
      afCloseFile(affd);
      free((void *)sample);
      return (struct sample *)(void *)0;
    }
  }
}

// beep_open_device
// file beep.c line 98
static signed int beep_open_device(void)
{
  char *uinput_dev[3l] = { "/dev/input/uinput", "/dev/uinput", "/dev/misc/uinput" };
  struct uinput_user_dev dv;
  signed int beep_open_device$$1$$fd;
  signed int i;
  signed int ret;
  if(beep_cfg.enabled == 0)
    return -1;

  else
  {
    i = 0;
    for( ; !((unsigned long int)i >= 3ul); i = i + 1)
    {
      beep_open_device$$1$$fd=open(uinput_dev[(signed long int)i], 02, 0);
      if(beep_open_device$$1$$fd >= 0)
        break;

    }
    if(!(beep_open_device$$1$$fd >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      logmsg(3, "beep: could not open uinput: %s", return_value_strerror$2);
      logmsg(3, "beep: Do you have the uinput module loaded?");
      return -1;
    }

    memset((void *)&dv, 0, sizeof(struct uinput_user_dev) /*1116ul*/ );
    strcpy(dv.name, "Pommed beeper device");
    dv.id.bustype = (unsigned short int)0x06;
    dv.id.vendor = (unsigned short int)0;
    dv.id.product = (unsigned short int)0;
    dv.id.version = (unsigned short int)1;
    signed long int return_value_write$3;
    return_value_write$3=write(beep_open_device$$1$$fd, (const void *)&dv, sizeof(struct uinput_user_dev) /*1116ul*/ );
    ret = (signed int)return_value_write$3;
    if(!((unsigned long int)ret == sizeof(struct uinput_user_dev) /*1116ul*/ ))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      logmsg(3, "beep: could not set device name: %s", return_value_strerror$5);
      close(beep_open_device$$1$$fd);
      return -1;
    }

    ret=ioctl(beep_open_device$$1$$fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(85 << 0 + 8) | (unsigned int)(100 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, 0x12);
    if(!(ret == 0))
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      char *return_value_strerror$7;
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      logmsg(3, "beep: could not request EV_SND: %s", return_value_strerror$7);
      close(beep_open_device$$1$$fd);
      return -1;
    }

    ret=ioctl(beep_open_device$$1$$fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(85 << 0 + 8) | (unsigned int)(106 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, 0x01);
    if(!(ret == 0))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      char *return_value_strerror$9;
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      logmsg(3, "beep: could not request SND_BELL: %s", return_value_strerror$9);
      close(beep_open_device$$1$$fd);
      return -1;
    }

    ret=ioctl(beep_open_device$$1$$fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(85 << 0 + 8) | (unsigned int)(106 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, 0x02);
    if(!(ret == 0))
    {
      signed int *return_value___errno_location$10;
      return_value___errno_location$10=__errno_location();
      char *return_value_strerror$11;
      return_value_strerror$11=strerror(*return_value___errno_location$10);
      logmsg(3, "beep: could not request SND_TONE: %s", return_value_strerror$11);
      close(beep_open_device$$1$$fd);
      return -1;
    }

    ret=ioctl(beep_open_device$$1$$fd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(85 << 0 + 8) | (unsigned int)(1 << 0) | (unsigned int)(0 << 0 + 8 + 8)), (void *)0);
    if(!(ret == 0))
    {
      signed int *return_value___errno_location$12;
      return_value___errno_location$12=__errno_location();
      char *return_value_strerror$13;
      return_value_strerror$13=strerror(*return_value___errno_location$12);
      logmsg(3, "beep: could not create uinput device: %s", return_value_strerror$13);
      close(beep_open_device$$1$$fd);
      return -1;
    }

    beep_fd = beep_open_device$$1$$fd;
    return 0;
  }
}

// beep_play_sample
// file beep.c line 409
static void beep_play_sample(struct dspdata *dsp, signed int cmd)
{
  struct _snd_pcm *pcm_handle;
  struct _snd_pcm_hw_params *hwparams;
  char *pcm_name = "default";
  struct sample *s = dsp->sample[(signed long int)cmd];
  do
  {
    unsigned long int return_value_snd_pcm_hw_params_sizeof$1;
    return_value_snd_pcm_hw_params_sizeof$1=snd_pcm_hw_params_sizeof();
    void *return_value___builtin_alloca$2;
    return_value___builtin_alloca$2=__builtin_alloca(return_value_snd_pcm_hw_params_sizeof$1);
    *(&hwparams) = (struct _snd_pcm_hw_params *)return_value___builtin_alloca$2;
    unsigned long int return_value_snd_pcm_hw_params_sizeof$3;
    return_value_snd_pcm_hw_params_sizeof$3=snd_pcm_hw_params_sizeof();
    memset((void *)*(&hwparams), 0, return_value_snd_pcm_hw_params_sizeof$3);
  }
  while((_Bool)0);
  signed int return_value_snd_pcm_open$4;
  return_value_snd_pcm_open$4=snd_pcm_open(&pcm_handle, pcm_name, (enum _snd_pcm_stream)SND_PCM_STREAM_PLAYBACK, 0);
  signed long int return_value_snd_pcm_writei$13;
  if(!(return_value_snd_pcm_open$4 >= 0))
    logmsg(4, "beep: error opening PCM device %s", pcm_name);

  else
  {
    signed int return_value_snd_pcm_hw_params_any$5;
    return_value_snd_pcm_hw_params_any$5=snd_pcm_hw_params_any(pcm_handle, hwparams);
    if(!(return_value_snd_pcm_hw_params_any$5 >= 0))
      logmsg(4, "beep: cannot configure PCM device");

    else
    {
      signed int return_value_snd_pcm_hw_params_set_access$6;
      return_value_snd_pcm_hw_params_set_access$6=snd_pcm_hw_params_set_access(pcm_handle, hwparams, (enum _snd_pcm_access)SND_PCM_ACCESS_RW_INTERLEAVED);
      if(!(return_value_snd_pcm_hw_params_set_access$6 >= 0))
        logmsg(4, "beep: error setting access");

      else
      {
        signed int return_value_snd_pcm_hw_params_set_format$7;
        return_value_snd_pcm_hw_params_set_format$7=snd_pcm_hw_params_set_format(pcm_handle, hwparams, (enum _snd_pcm_format)s->format);
        if(!(return_value_snd_pcm_hw_params_set_format$7 >= 0))
          logmsg(4, "beep: error setting format");

        else
        {
          signed int return_value_snd_pcm_hw_params_set_rate_near$8;
          return_value_snd_pcm_hw_params_set_rate_near$8=snd_pcm_hw_params_set_rate_near(pcm_handle, hwparams, &s->speed, ((signed int *)NULL));
          if(!(return_value_snd_pcm_hw_params_set_rate_near$8 >= 0))
            logmsg(4, "beep: error setting rate");

          else
          {
            signed int return_value_snd_pcm_hw_params_set_channels_near$9;
            return_value_snd_pcm_hw_params_set_channels_near$9=snd_pcm_hw_params_set_channels_near(pcm_handle, hwparams, &s->channels);
            if(!(return_value_snd_pcm_hw_params_set_channels_near$9 >= 0))
              logmsg(4, "beep: error setting channels");

            else
            {
              signed int return_value_snd_pcm_hw_params_set_periods_near$10;
              return_value_snd_pcm_hw_params_set_periods_near$10=snd_pcm_hw_params_set_periods_near(pcm_handle, hwparams, &s->periods, ((signed int *)NULL));
              if(!(return_value_snd_pcm_hw_params_set_periods_near$10 >= 0))
                logmsg(4, "beep: error setting periods");

              else
              {
                signed int return_value_snd_pcm_hw_params_set_buffer_size_near$11;
                return_value_snd_pcm_hw_params_set_buffer_size_near$11=snd_pcm_hw_params_set_buffer_size_near(pcm_handle, hwparams, &s->buffersize);
                if(!(return_value_snd_pcm_hw_params_set_buffer_size_near$11 >= 0))
                  logmsg(4, "beep: error setting buffersize");

                else
                {
                  signed int return_value_snd_pcm_hw_params$12;
                  return_value_snd_pcm_hw_params$12=snd_pcm_hw_params(pcm_handle, hwparams);
                  if(!(return_value_snd_pcm_hw_params$12 >= 0))
                    logmsg(4, "beep: error setting HW params");

                  else
                  {
                    signed int pcmreturn;
                    do
                    {
                      return_value_snd_pcm_writei$13=snd_pcm_writei(pcm_handle, (const void *)s->audiodata, (unsigned long int)s->framecount);
                      pcmreturn = (signed int)return_value_snd_pcm_writei$13;
                      if(pcmreturn >= 0)
                        break;

                      snd_pcm_prepare(pcm_handle);
                    }
                    while((_Bool)1);
                    snd_pcm_drop(pcm_handle);
                    snd_pcm_close(pcm_handle);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// beep_process_events
// file beep.c line 204
void beep_process_events(signed int fd, unsigned int events)
{
  signed int ret;
  struct input_event ev;
  if(!((24u & events) == 0u))
  {
    logmsg(4, "Beeper device lost; this should not happen");
    ret=evloop_remove(fd);
    if(!(ret >= 0))
      logmsg(3, "Could not remove beeper device from event loop");

    beep_close_device();
  }

  else
  {
    signed long int return_value_read$1;
    return_value_read$1=read(fd, (void *)&ev, sizeof(struct input_event) /*24ul*/ );
    ret = (signed int)return_value_read$1;
    if((unsigned long int)ret == sizeof(struct input_event) /*24ul*/ )
    {
      if((signed int)ev.type == 0x12)
      {
        if((signed int)ev.code == 0x02 && ev.value >= 1)
        {
          logdebug("\nBEEP: BEEP!\n");
          beep_beep();
        }

      }

    }

  }
}

// beep_thread
// file beep.c line 501
void * beep_thread(void *arg)
{
  struct dspdata *dsp = (struct dspdata *)arg;
  do
  {
    pthread_mutex_lock(&dsp->mutex);
    pthread_cond_wait(&dsp->cond, &dsp->mutex);
    pthread_mutex_unlock(&dsp->mutex);
    switch(dsp->command)
    {
      case 0:
      {
        dsp->command = -2;
        beep_play_sample(dsp, 0);
        break;
      }
      case -1:
        pthread_exit((void *)0);
      case -2:

      default:
        ;
    }
  }
  while((_Bool)1);
  return (void *)0;
}

// beep_thread_cleanup
// file beep.c line 549
static void beep_thread_cleanup(void)
{
  signed int i = 0;
  for( ; !(i >= 1); i = i + 1)
    if(!(_dsp.sample[(signed long int)i] == ((struct sample *)NULL)))
    {
      if(!(_dsp.sample[(signed long int)i]->audiodata == ((char *)NULL)))
        free((void *)_dsp.sample[(signed long int)i]->audiodata);

      free((void *)_dsp.sample[(signed long int)i]);
    }

  pthread_mutex_destroy(&_dsp.mutex);
  pthread_cond_destroy(&_dsp.cond);
}

// beep_thread_command
// file beep.c line 533
static void beep_thread_command(signed int command)
{
  if(!(beep_thread_running == 0))
  {
    pthread_mutex_lock(&_dsp.mutex);
    _dsp.command = command;
    pthread_cond_signal(&_dsp.cond);
    pthread_mutex_unlock(&_dsp.mutex);
  }

}

// beep_thread_init
// file beep.c line 574
static signed int beep_thread_init(void)
{
  union pthread_attr_t attr;
  signed int ret;
  _dsp.sample[(signed long int)0]=beep_load_sample(beep_cfg.beepfile);
  if(_dsp.sample[0l] == ((struct sample *)NULL))
    return -1;

  else
  {
    _dsp.thread = (unsigned long int)0;
    pthread_mutex_init(&_dsp.mutex, (const union anonymous$5 *)(void *)0);
    pthread_cond_init(&_dsp.cond, (const union anonymous$5 *)(void *)0);
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, 0);
    ret=pthread_create(&_dsp.thread, &attr, beep_thread, (void *)&_dsp);
    if(!(ret == 0))
    {
      beep_thread_cleanup();
      ret = -1;
    }

    pthread_attr_destroy(&attr);
    return ret;
  }
}

// cd_eject
// file cd_eject.c line 44
void cd_eject(void)
{
  char *eject_argv[3l] = { "eject", eject_cfg.device, (char *)(void *)0 };
  char *eject_envp[1l] = { (char *)(void *)0 };
  signed long int max_fd;
  signed int cd_eject$$1$$fd;
  signed int ret;
  signed int *return_value___errno_location$3;
  char *return_value_strerror$4;
  _Bool tmp_if_expr$9;
  if(!(eject_cfg.enabled == 0))
  {
    cd_eject$$1$$fd=open(eject_cfg.device, 00 | 04000);
    if(!(cd_eject$$1$$fd >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      logmsg(3, "Could not open CD/DVD device: %s", return_value_strerror$2);
      goto __CPROVER_DUMP_L18;
    }

    ret=ioctl(cd_eject$$1$$fd, (unsigned long int)0x5326);
    close(cd_eject$$1$$fd);
    switch(ret)
    {
      case 0:
        logmsg(6, "Driver does not support CDROM_DRIVE_STATUS, trying to eject anyway");
      case 4:
        break;
      case 1:
      {
        logmsg(6, "No disc in CD/DVD drive");
        goto __CPROVER_DUMP_L18;
      }
      case 3:
      {
        logmsg(6, "Drive not ready, please retry later");
        goto __CPROVER_DUMP_L18;
      }
      case 2:
      {
        logmsg(6, "Drive tray already open");
        goto __CPROVER_DUMP_L18;
      }
      default:
      {
        return_value___errno_location$3=__errno_location();
        return_value_strerror$4=strerror(*return_value___errno_location$3);
        logmsg(6, "CDROM_DRIVE_STATUS returned %d (%s)", ret, return_value_strerror$4);
        goto __CPROVER_DUMP_L18;
      }
    }
    ret=fork();
    if(ret == 0)
    {
      max_fd=sysconf(4);
      if(max_fd >= 2147483648l)
        max_fd = (signed long int)0x7fffffff;

      cd_eject$$1$$fd = 3;
      for( ; !((signed long int)cd_eject$$1$$fd >= max_fd); cd_eject$$1$$fd = cd_eject$$1$$fd + 1)
        close(cd_eject$$1$$fd);
      execve("/usr/bin/eject", eject_argv, eject_envp);
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      char *return_value_strerror$6;
      return_value_strerror$6=strerror(*return_value___errno_location$5);
      logmsg(3, "Could not execute eject: %s", return_value_strerror$6);
      exit(1);
    }

    else
      if(ret == -1)
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        char *return_value_strerror$8;
        return_value_strerror$8=strerror(*return_value___errno_location$7);
        logmsg(3, "Could not fork: %s", return_value_strerror$8);
        goto __CPROVER_DUMP_L18;
      }

      else
      {
        mbpdbus_send_cd_eject();
        waitpid(ret, &ret, 0);
        /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous$0
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
        ;
        if(!((0x7f & ret) == 0))
          tmp_if_expr$9 = (_Bool)1;

        else
          tmp_if_expr$9 = (((union anonymous$0){ .__in=ret }).__i & 0xff00) >> 8 != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$9)
        {
          logmsg(6, "eject failed");
          goto __CPROVER_DUMP_L18;
        }

      }
  }


__CPROVER_DUMP_L18:
  ;
}

// cd_eject_fix_config
// file cd_eject.c line 128
void cd_eject_fix_config(void)
{
  if(eject_cfg.device == ((char *)NULL))
    eject_cfg.enabled = 0;

}

// check_ac_state
// file power.c line 74
static signed int check_ac_state(void)
{
  signed int ret;
  ret=sysfs_check_ac_state();
  signed int return_value_procfs_check_ac_state$1;
  if(ret == -1)
  {
    return_value_procfs_check_ac_state$1=procfs_check_ac_state();
    return return_value_procfs_check_ac_state$1;
  }

  else
    return ret;
}

// check_machine_dmi
// file pommed.c line 649
static enum anonymous$3 check_machine_dmi(void)
{
  signed int ret;
  signed int check_machine_dmi$$1$$fd;
  char buf[32l];
  signed int i;
  char *vendor_node[4l] = { "/sys/class/dmi/id/sys_vendor", "/sys/class/dmi/id/board_vendor", "/sys/class/dmi/id/chassis_vendor", "/sys/class/dmi/id/bios_vendor" };
  i = 0;
  for( ; !((unsigned long int)i >= 4ul); i = i + 1)
  {
    check_machine_dmi$$1$$fd=open(vendor_node[(signed long int)i], 00);
    if(check_machine_dmi$$1$$fd >= 1)
      break;

    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    logmsg(6, "Could not open %s: %s", vendor_node[(signed long int)i], return_value_strerror$2);
  }
  signed int tmp_statement_expression$8;
  signed int tmp_statement_expression$6;
  signed int tmp_statement_expression$84;
  _Bool tmp_if_expr$88;
  signed int tmp_statement_expression$86;
  signed int tmp_statement_expression$79;
  _Bool tmp_if_expr$83;
  signed int tmp_statement_expression$81;
  signed int tmp_statement_expression$77;
  signed int tmp_statement_expression$75;
  signed int tmp_statement_expression$61;
  _Bool tmp_if_expr$65;
  signed int tmp_statement_expression$63;
  _Bool tmp_if_expr$68;
  signed int tmp_statement_expression$66;
  _Bool tmp_if_expr$71;
  signed int tmp_statement_expression$69;
  _Bool tmp_if_expr$74;
  signed int tmp_statement_expression$72;
  signed int tmp_statement_expression$56;
  _Bool tmp_if_expr$60;
  signed int tmp_statement_expression$58;
  signed int tmp_statement_expression$54;
  signed int tmp_statement_expression$46;
  _Bool tmp_if_expr$50;
  signed int tmp_statement_expression$48;
  _Bool tmp_if_expr$53;
  signed int tmp_statement_expression$51;
  signed int tmp_statement_expression$41;
  _Bool tmp_if_expr$45;
  signed int tmp_statement_expression$43;
  signed int tmp_statement_expression$39;
  signed int tmp_statement_expression$37;
  signed int tmp_statement_expression$35;
  signed int tmp_statement_expression$33;
  signed int tmp_statement_expression$28;
  _Bool tmp_if_expr$32;
  signed int tmp_statement_expression$30;
  signed int tmp_statement_expression$26;
  signed int tmp_statement_expression$24;
  signed int tmp_statement_expression$22;
  signed int tmp_statement_expression$20;
  signed int tmp_statement_expression$15;
  _Bool tmp_if_expr$19;
  signed int tmp_statement_expression$17;
  if(!(check_machine_dmi$$1$$fd >= 0))
  {
    logmsg(3, "Could not determine vendor name");
    return (enum anonymous$3)MACHINE_ERROR;
  }

  else
  {
    memset((void *)buf, 0, sizeof(char [32l]) /*32ul*/ );
    signed long int return_value_read$3;
    return_value_read$3=read(check_machine_dmi$$1$$fd, (void *)buf, sizeof(char [32l]) /*32ul*/  - (unsigned long int)1);
    ret = (signed int)return_value_read$3;
    if(!(ret >= 0))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      logmsg(3, "Could not read from %s: %s", vendor_node[(signed long int)i], return_value_strerror$5);
      close(check_machine_dmi$$1$$fd);
      return (enum anonymous$3)MACHINE_ERROR;
    }

    close(check_machine_dmi$$1$$fd);
    if((signed int)buf[(signed long int)(ret + -1)] == 10)
      buf[(signed long int)(ret - 1)] = (char)0;

    logdebug("DMI vendor name: [%s]\n", (const void *)buf);
    unsigned long int check_machine_dmi$$1$$4$$__s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$9;
    return_value___builtin_strcmp$9=__builtin_strcmp(buf, "Apple Computer, Inc.");
    tmp_statement_expression$8 = return_value___builtin_strcmp$9;
    if(!(tmp_statement_expression$8 == 0))
    {
      unsigned long int check_machine_dmi$$1$$5$$__s1_len;
      unsigned long int check_machine_dmi$$1$$5$$__s2_len;
      signed int return_value___builtin_strcmp$7;
      return_value___builtin_strcmp$7=__builtin_strcmp(buf, "Apple Inc.");
      tmp_statement_expression$6 = return_value___builtin_strcmp$7;
      if(tmp_statement_expression$6 == 0)
        goto __CPROVER_DUMP_L6;

      return (enum anonymous$3)MACHINE_UNKNOWN;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      check_machine_dmi$$1$$fd=open("/sys/class/dmi/id/product_name", 00);
      if(!(check_machine_dmi$$1$$fd >= 0))
      {
        signed int *return_value___errno_location$10;
        return_value___errno_location$10=__errno_location();
        char *return_value_strerror$11;
        return_value_strerror$11=strerror(*return_value___errno_location$10);
        logmsg(6, "Could not open /sys/class/dmi/id/product_name: %s", return_value_strerror$11);
        return (enum anonymous$3)MACHINE_MAC_UNKNOWN;
      }

      memset((void *)buf, 0, sizeof(char [32l]) /*32ul*/ );
      signed long int return_value_read$12;
      return_value_read$12=read(check_machine_dmi$$1$$fd, (void *)buf, sizeof(char [32l]) /*32ul*/  - (unsigned long int)1);
      ret = (signed int)return_value_read$12;
      if(!(ret >= 0))
      {
        signed int *return_value___errno_location$13;
        return_value___errno_location$13=__errno_location();
        char *return_value_strerror$14;
        return_value_strerror$14=strerror(*return_value___errno_location$13);
        logmsg(3, "Could not read from /sys/class/dmi/id/product_name: %s", return_value_strerror$14);
        close(check_machine_dmi$$1$$fd);
        return (enum anonymous$3)MACHINE_MAC_UNKNOWN;
      }

      close(check_machine_dmi$$1$$fd);
      if((signed int)buf[(signed long int)(ret + -1)] == 10)
        buf[(signed long int)(ret - 1)] = (char)0;

      logdebug("DMI product name: [%s]\n", (const void *)buf);
      ret = MACHINE_MAC_UNKNOWN;
      unsigned long int check_machine_dmi$$1$$8$$__s1_len;
      unsigned long int check_machine_dmi$$1$$8$$__s2_len;
      signed int return_value___builtin_strcmp$85;
      return_value___builtin_strcmp$85=__builtin_strcmp(buf, "MacBookPro1,1");
      tmp_statement_expression$84 = return_value___builtin_strcmp$85;
      if(tmp_statement_expression$84 == 0)
        tmp_if_expr$88 = (_Bool)1;

      else
      {
        unsigned long int check_machine_dmi$$1$$9$$__s1_len;
        unsigned long int check_machine_dmi$$1$$9$$__s2_len;
        signed int return_value___builtin_strcmp$87;
        return_value___builtin_strcmp$87=__builtin_strcmp(buf, "MacBookPro1,2");
        tmp_statement_expression$86 = return_value___builtin_strcmp$87;
        tmp_if_expr$88 = tmp_statement_expression$86 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$88)
        ret = MACHINE_MACBOOKPRO_1;

      else
      {
        unsigned long int check_machine_dmi$$1$$10$$__s1_len;
        unsigned long int check_machine_dmi$$1$$10$$__s2_len;
        signed int return_value___builtin_strcmp$80;
        return_value___builtin_strcmp$80=__builtin_strcmp(buf, "MacBookPro2,1");
        tmp_statement_expression$79 = return_value___builtin_strcmp$80;
        if(tmp_statement_expression$79 == 0)
          tmp_if_expr$83 = (_Bool)1;

        else
        {
          unsigned long int check_machine_dmi$$1$$11$$__s1_len;
          unsigned long int check_machine_dmi$$1$$11$$__s2_len;
          signed int return_value___builtin_strcmp$82;
          return_value___builtin_strcmp$82=__builtin_strcmp(buf, "MacBookPro2,2");
          tmp_statement_expression$81 = return_value___builtin_strcmp$82;
          tmp_if_expr$83 = tmp_statement_expression$81 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$83)
          ret = MACHINE_MACBOOKPRO_2;

        else
        {
          unsigned long int check_machine_dmi$$1$$12$$__s1_len;
          unsigned long int check_machine_dmi$$1$$12$$__s2_len;
          signed int return_value___builtin_strcmp$78;
          return_value___builtin_strcmp$78=__builtin_strcmp(buf, "MacBookPro3,1");
          tmp_statement_expression$77 = return_value___builtin_strcmp$78;
          if(tmp_statement_expression$77 == 0)
            ret = MACHINE_MACBOOKPRO_3;

          else
          {
            unsigned long int check_machine_dmi$$1$$13$$__s1_len;
            unsigned long int check_machine_dmi$$1$$13$$__s2_len;
            signed int return_value___builtin_strcmp$76;
            return_value___builtin_strcmp$76=__builtin_strcmp(buf, "MacBookPro4,1");
            tmp_statement_expression$75 = return_value___builtin_strcmp$76;
            if(tmp_statement_expression$75 == 0)
              ret = MACHINE_MACBOOKPRO_4;

            else
            {
              unsigned long int check_machine_dmi$$1$$14$$__s1_len;
              unsigned long int check_machine_dmi$$1$$14$$__s2_len;
              signed int return_value___builtin_strcmp$62;
              return_value___builtin_strcmp$62=__builtin_strcmp(buf, "MacBookPro5,1");
              tmp_statement_expression$61 = return_value___builtin_strcmp$62;
              if(tmp_statement_expression$61 == 0)
                tmp_if_expr$65 = (_Bool)1;

              else
              {
                unsigned long int check_machine_dmi$$1$$15$$__s1_len;
                unsigned long int check_machine_dmi$$1$$15$$__s2_len;
                signed int return_value___builtin_strcmp$64;
                return_value___builtin_strcmp$64=__builtin_strcmp(buf, "MacBookPro5,2");
                tmp_statement_expression$63 = return_value___builtin_strcmp$64;
                tmp_if_expr$65 = tmp_statement_expression$63 == 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$65)
                tmp_if_expr$68 = (_Bool)1;

              else
              {
                unsigned long int check_machine_dmi$$1$$16$$__s1_len;
                unsigned long int check_machine_dmi$$1$$16$$__s2_len;
                signed int return_value___builtin_strcmp$67;
                return_value___builtin_strcmp$67=__builtin_strcmp(buf, "MacBookPro5,3");
                tmp_statement_expression$66 = return_value___builtin_strcmp$67;
                tmp_if_expr$68 = tmp_statement_expression$66 == 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$68)
                tmp_if_expr$71 = (_Bool)1;

              else
              {
                unsigned long int check_machine_dmi$$1$$17$$__s1_len;
                unsigned long int check_machine_dmi$$1$$17$$__s2_len;
                signed int return_value___builtin_strcmp$70;
                return_value___builtin_strcmp$70=__builtin_strcmp(buf, "MacBookPro5,4");
                tmp_statement_expression$69 = return_value___builtin_strcmp$70;
                tmp_if_expr$71 = tmp_statement_expression$69 == 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$71)
                tmp_if_expr$74 = (_Bool)1;

              else
              {
                unsigned long int check_machine_dmi$$1$$18$$__s1_len;
                unsigned long int check_machine_dmi$$1$$18$$__s2_len;
                signed int return_value___builtin_strcmp$73;
                return_value___builtin_strcmp$73=__builtin_strcmp(buf, "MacBookPro5,5");
                tmp_statement_expression$72 = return_value___builtin_strcmp$73;
                tmp_if_expr$74 = tmp_statement_expression$72 == 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$74)
                ret = MACHINE_MACBOOKPRO_5;

              else
              {
                unsigned long int check_machine_dmi$$1$$19$$__s1_len;
                unsigned long int check_machine_dmi$$1$$19$$__s2_len;
                signed int return_value___builtin_strcmp$57;
                return_value___builtin_strcmp$57=__builtin_strcmp(buf, "MacBookPro6,1");
                tmp_statement_expression$56 = return_value___builtin_strcmp$57;
                if(tmp_statement_expression$56 == 0)
                  tmp_if_expr$60 = (_Bool)1;

                else
                {
                  unsigned long int check_machine_dmi$$1$$20$$__s1_len;
                  unsigned long int check_machine_dmi$$1$$20$$__s2_len;
                  signed int return_value___builtin_strcmp$59;
                  return_value___builtin_strcmp$59=__builtin_strcmp(buf, "MacBookPro6,2");
                  tmp_statement_expression$58 = return_value___builtin_strcmp$59;
                  tmp_if_expr$60 = tmp_statement_expression$58 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$60)
                  ret = MACHINE_MACBOOKPRO_6;

                else
                {
                  unsigned long int check_machine_dmi$$1$$21$$__s1_len;
                  unsigned long int check_machine_dmi$$1$$21$$__s2_len;
                  signed int return_value___builtin_strcmp$55;
                  return_value___builtin_strcmp$55=__builtin_strcmp(buf, "MacBookPro7,1");
                  tmp_statement_expression$54 = return_value___builtin_strcmp$55;
                  if(tmp_statement_expression$54 == 0)
                    ret = MACHINE_MACBOOKPRO_7;

                  else
                  {
                    unsigned long int check_machine_dmi$$1$$22$$__s1_len;
                    unsigned long int check_machine_dmi$$1$$22$$__s2_len;
                    signed int return_value___builtin_strcmp$47;
                    return_value___builtin_strcmp$47=__builtin_strcmp(buf, "MacBookPro8,1");
                    tmp_statement_expression$46 = return_value___builtin_strcmp$47;
                    if(tmp_statement_expression$46 == 0)
                      tmp_if_expr$50 = (_Bool)1;

                    else
                    {
                      unsigned long int check_machine_dmi$$1$$23$$__s1_len;
                      unsigned long int check_machine_dmi$$1$$23$$__s2_len;
                      signed int return_value___builtin_strcmp$49;
                      return_value___builtin_strcmp$49=__builtin_strcmp(buf, "MacBookPro8,2");
                      tmp_statement_expression$48 = return_value___builtin_strcmp$49;
                      tmp_if_expr$50 = tmp_statement_expression$48 == 0 ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr$50)
                      tmp_if_expr$53 = (_Bool)1;

                    else
                    {
                      unsigned long int check_machine_dmi$$1$$24$$__s1_len;
                      unsigned long int check_machine_dmi$$1$$24$$__s2_len;
                      signed int return_value___builtin_strcmp$52;
                      return_value___builtin_strcmp$52=__builtin_strcmp(buf, "MacBookPro8,3");
                      tmp_statement_expression$51 = return_value___builtin_strcmp$52;
                      tmp_if_expr$53 = tmp_statement_expression$51 == 0 ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr$53)
                      ret = MACHINE_MACBOOKPRO_8;

                    else
                    {
                      unsigned long int check_machine_dmi$$1$$25$$__s1_len;
                      unsigned long int check_machine_dmi$$1$$25$$__s2_len;
                      signed int return_value___builtin_strcmp$42;
                      return_value___builtin_strcmp$42=__builtin_strcmp(buf, "MacBookPro9,1");
                      tmp_statement_expression$41 = return_value___builtin_strcmp$42;
                      if(tmp_statement_expression$41 == 0)
                        tmp_if_expr$45 = (_Bool)1;

                      else
                      {
                        unsigned long int check_machine_dmi$$1$$26$$__s1_len;
                        unsigned long int check_machine_dmi$$1$$26$$__s2_len;
                        signed int return_value___builtin_strcmp$44;
                        return_value___builtin_strcmp$44=__builtin_strcmp(buf, "MacBookPro9,2");
                        tmp_statement_expression$43 = return_value___builtin_strcmp$44;
                        tmp_if_expr$45 = tmp_statement_expression$43 == 0 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr$45)
                        ret = MACHINE_MACBOOKPRO_9;

                      else
                      {
                        unsigned long int check_machine_dmi$$1$$27$$__s1_len;
                        unsigned long int check_machine_dmi$$1$$27$$__s2_len;
                        signed int return_value___builtin_strcmp$40;
                        return_value___builtin_strcmp$40=__builtin_strcmp(buf, "MacBook1,1");
                        tmp_statement_expression$39 = return_value___builtin_strcmp$40;
                        if(tmp_statement_expression$39 == 0)
                          ret = MACHINE_MACBOOK_1;

                        else
                        {
                          unsigned long int check_machine_dmi$$1$$28$$__s1_len;
                          unsigned long int check_machine_dmi$$1$$28$$__s2_len;
                          signed int return_value___builtin_strcmp$38;
                          return_value___builtin_strcmp$38=__builtin_strcmp(buf, "MacBook2,1");
                          tmp_statement_expression$37 = return_value___builtin_strcmp$38;
                          if(tmp_statement_expression$37 == 0)
                            ret = MACHINE_MACBOOK_2;

                          else
                          {
                            unsigned long int check_machine_dmi$$1$$29$$__s1_len;
                            unsigned long int check_machine_dmi$$1$$29$$__s2_len;
                            signed int return_value___builtin_strcmp$36;
                            return_value___builtin_strcmp$36=__builtin_strcmp(buf, "MacBook3,1");
                            tmp_statement_expression$35 = return_value___builtin_strcmp$36;
                            if(tmp_statement_expression$35 == 0)
                              ret = MACHINE_MACBOOK_3;

                            else
                            {
                              unsigned long int check_machine_dmi$$1$$30$$__s1_len;
                              unsigned long int check_machine_dmi$$1$$30$$__s2_len;
                              signed int return_value___builtin_strcmp$34;
                              return_value___builtin_strcmp$34=__builtin_strcmp(buf, "MacBook4,1");
                              tmp_statement_expression$33 = return_value___builtin_strcmp$34;
                              if(tmp_statement_expression$33 == 0)
                                ret = MACHINE_MACBOOK_4;

                              else
                              {
                                unsigned long int check_machine_dmi$$1$$31$$__s1_len;
                                unsigned long int check_machine_dmi$$1$$31$$__s2_len;
                                signed int return_value___builtin_strcmp$29;
                                return_value___builtin_strcmp$29=__builtin_strcmp(buf, "MacBook5,1");
                                tmp_statement_expression$28 = return_value___builtin_strcmp$29;
                                if(tmp_statement_expression$28 == 0)
                                  tmp_if_expr$32 = (_Bool)1;

                                else
                                {
                                  unsigned long int check_machine_dmi$$1$$32$$__s1_len;
                                  unsigned long int check_machine_dmi$$1$$32$$__s2_len;
                                  signed int return_value___builtin_strcmp$31;
                                  return_value___builtin_strcmp$31=__builtin_strcmp(buf, "MacBook5,2");
                                  tmp_statement_expression$30 = return_value___builtin_strcmp$31;
                                  tmp_if_expr$32 = tmp_statement_expression$30 == 0 ? (_Bool)1 : (_Bool)0;
                                }
                                if(tmp_if_expr$32)
                                  ret = MACHINE_MACBOOK_5;

                                else
                                {
                                  unsigned long int check_machine_dmi$$1$$33$$__s1_len;
                                  unsigned long int check_machine_dmi$$1$$33$$__s2_len;
                                  signed int return_value___builtin_strcmp$27;
                                  return_value___builtin_strcmp$27=__builtin_strcmp(buf, "MacBook6,1");
                                  tmp_statement_expression$26 = return_value___builtin_strcmp$27;
                                  if(tmp_statement_expression$26 == 0)
                                    ret = MACHINE_MACBOOK_6;

                                  else
                                  {
                                    unsigned long int __s1_len;
                                    unsigned long int check_machine_dmi$$1$$34$$__s2_len;
                                    signed int return_value___builtin_strcmp$25;
                                    return_value___builtin_strcmp$25=__builtin_strcmp(buf, "MacBook7,1");
                                    tmp_statement_expression$24 = return_value___builtin_strcmp$25;
                                    if(tmp_statement_expression$24 == 0)
                                      ret = MACHINE_MACBOOK_7;

                                    else
                                    {
                                      unsigned long int check_machine_dmi$$1$$35$$__s1_len;
                                      unsigned long int check_machine_dmi$$1$$35$$__s2_len;
                                      signed int return_value___builtin_strcmp$23;
                                      return_value___builtin_strcmp$23=__builtin_strcmp(buf, "MacBookAir1,1");
                                      tmp_statement_expression$22 = return_value___builtin_strcmp$23;
                                      if(tmp_statement_expression$22 == 0)
                                        ret = MACHINE_MACBOOKAIR_1;

                                      else
                                      {
                                        unsigned long int check_machine_dmi$$1$$36$$__s1_len;
                                        unsigned long int check_machine_dmi$$1$$36$$__s2_len;
                                        signed int return_value___builtin_strcmp$21;
                                        return_value___builtin_strcmp$21=__builtin_strcmp(buf, "MacBookAir2,1");
                                        tmp_statement_expression$20 = return_value___builtin_strcmp$21;
                                        if(tmp_statement_expression$20 == 0)
                                          ret = MACHINE_MACBOOKAIR_2;

                                        else
                                        {
                                          unsigned long int check_machine_dmi$$1$$37$$__s1_len;
                                          unsigned long int check_machine_dmi$$1$$37$$__s2_len;
                                          signed int return_value___builtin_strcmp$16;
                                          return_value___builtin_strcmp$16=__builtin_strcmp(buf, "MacBookAir3,1");
                                          tmp_statement_expression$15 = return_value___builtin_strcmp$16;
                                          if(tmp_statement_expression$15 == 0)
                                            tmp_if_expr$19 = (_Bool)1;

                                          else
                                          {
                                            unsigned long int check_machine_dmi$$1$$38$$__s1_len;
                                            unsigned long int check_machine_dmi$$1$$38$$__s2_len;
                                            signed int return_value___builtin_strcmp$18;
                                            return_value___builtin_strcmp$18=__builtin_strcmp(buf, "MacBookAir3,2");
                                            tmp_statement_expression$17 = return_value___builtin_strcmp$18;
                                            tmp_if_expr$19 = tmp_statement_expression$17 == 0 ? (_Bool)1 : (_Bool)0;
                                          }
                                          if(tmp_if_expr$19)
                                            ret = MACHINE_MACBOOKAIR_3;

                                          else
                                            logmsg(3, "Unknown Apple machine: %s", (const void *)buf);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if(!(ret == MACHINE_MAC_UNKNOWN))
        logmsg(6, "DMI machine check: running on a %s", (const void *)buf);

      return (enum anonymous$3)ret;
    }
  }
}

// config_cleanup
// file conffile.h line 97
void config_cleanup(void)
{
  free((void *)audio_cfg.card);
  free((void *)audio_cfg.vol);
  free((void *)audio_cfg.spkr);
  free((void *)audio_cfg.head);
  free((void *)eject_cfg.device);
  free((void *)beep_cfg.beepfile);
}

// config_load
// file conffile.h line 94
signed int config_load(void)
{
  struct cfg_t *cfg;
  struct cfg_t *sec;
  signed int ret;
  cfg=cfg_init(opts, 0);
  enum anonymous$8 return_value_cfg_getbool$36;
  if(cfg == ((struct cfg_t *)NULL))
  {
    logmsg(3, "Failed to initialize configuration parser");
    return -1;
  }

  else
  {
    cfg_set_validate_func(cfg, "general|fnmode", config_validate_positive_integer);
    cfg_set_validate_func(cfg, "lcd_sysfs|step", config_validate_positive_integer);
    cfg_set_validate_func(cfg, "lcd_sysfs|on_batt", config_validate_positive_integer);
    cfg_set_validate_func(cfg, "lcd_x1600|step", config_validate_positive_integer);
    cfg_set_validate_func(cfg, "lcd_x1600|on_batt", config_validate_positive_integer);
    cfg_set_validate_func(cfg, "lcd_gma950|step", config_validate_positive_integer);
    cfg_set_validate_func(cfg, "lcd_gma950|on_batt", config_validate_positive_integer);
    cfg_set_validate_func(cfg, "lcd_nv8600mgt|step", config_validate_positive_integer);
    cfg_set_validate_func(cfg, "lcd_nv8600mgt|on_batt", config_validate_positive_integer);
    cfg_set_validate_func(cfg, "audio|card", config_validate_string);
    cfg_set_validate_func(cfg, "audio|step", config_validate_positive_integer);
    cfg_set_validate_func(cfg, "audio|volume", config_validate_string);
    cfg_set_validate_func(cfg, "audio|speakers", config_validate_string);
    cfg_set_validate_func(cfg, "audio|headphones", config_validate_string);
    cfg_set_validate_func(cfg, "kbd|default", config_validate_positive_integer);
    cfg_set_validate_func(cfg, "kbd|step", config_validate_positive_integer);
    cfg_set_validate_func(cfg, "kbd|on_threshold", config_validate_positive_integer);
    cfg_set_validate_func(cfg, "kbd|off_threshold", config_validate_positive_integer);
    cfg_set_validate_func(cfg, "eject|device", config_validate_string);
    cfg_set_validate_func(cfg, "beep|beepfile", config_validate_string);
    ret=cfg_parse(cfg, "/etc/pommed.conf");
    if(!(ret == 0))
    {
      if(ret == -1)
      {
        logmsg(6, "Configuration file not found, using defaults");
        goto __CPROVER_DUMP_L3;
      }

      cfg_free(cfg);
      logmsg(3, "Failed to parse configuration file");
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      sec=cfg_getsec(cfg, "general");
      signed long int return_value_cfg_getint$1;
      return_value_cfg_getint$1=cfg_getint(sec, "fnmode");
      general_cfg.fnmode = (signed int)return_value_cfg_getint$1;
      sec=cfg_getsec(cfg, "lcd_sysfs");
      signed long int return_value_cfg_getint$2;
      return_value_cfg_getint$2=cfg_getint(sec, "init");
      lcd_sysfs_cfg.init = (signed int)return_value_cfg_getint$2;
      signed long int return_value_cfg_getint$3;
      return_value_cfg_getint$3=cfg_getint(sec, "step");
      lcd_sysfs_cfg.step = (signed int)return_value_cfg_getint$3;
      signed long int return_value_cfg_getint$4;
      return_value_cfg_getint$4=cfg_getint(sec, "on_batt");
      lcd_sysfs_cfg.on_batt = (signed int)return_value_cfg_getint$4;
      sec=cfg_getsec(cfg, "lcd_x1600");
      signed long int return_value_cfg_getint$5;
      return_value_cfg_getint$5=cfg_getint(sec, "init");
      lcd_x1600_cfg.init = (signed int)return_value_cfg_getint$5;
      signed long int return_value_cfg_getint$6;
      return_value_cfg_getint$6=cfg_getint(sec, "step");
      lcd_x1600_cfg.step = (signed int)return_value_cfg_getint$6;
      signed long int return_value_cfg_getint$7;
      return_value_cfg_getint$7=cfg_getint(sec, "on_batt");
      lcd_x1600_cfg.on_batt = (signed int)return_value_cfg_getint$7;
      x1600_backlight_fix_config();
      sec=cfg_getsec(cfg, "lcd_gma950");
      signed long int return_value_cfg_getint$8;
      return_value_cfg_getint$8=cfg_getint(sec, "init");
      lcd_gma950_cfg.init = (unsigned int)return_value_cfg_getint$8;
      signed long int return_value_cfg_getint$9;
      return_value_cfg_getint$9=cfg_getint(sec, "step");
      lcd_gma950_cfg.step = (unsigned int)return_value_cfg_getint$9;
      signed long int return_value_cfg_getint$10;
      return_value_cfg_getint$10=cfg_getint(sec, "on_batt");
      lcd_gma950_cfg.on_batt = (unsigned int)return_value_cfg_getint$10;
      sec=cfg_getsec(cfg, "lcd_nv8600mgt");
      signed long int return_value_cfg_getint$11;
      return_value_cfg_getint$11=cfg_getint(sec, "init");
      lcd_nv8600mgt_cfg.init = (signed int)return_value_cfg_getint$11;
      signed long int return_value_cfg_getint$12;
      return_value_cfg_getint$12=cfg_getint(sec, "step");
      lcd_nv8600mgt_cfg.step = (signed int)return_value_cfg_getint$12;
      signed long int return_value_cfg_getint$13;
      return_value_cfg_getint$13=cfg_getint(sec, "on_batt");
      lcd_nv8600mgt_cfg.on_batt = (signed int)return_value_cfg_getint$13;
      nv8600mgt_backlight_fix_config();
      sec=cfg_getsec(cfg, "audio");
      enum anonymous$8 return_value_cfg_getbool$14;
      return_value_cfg_getbool$14=cfg_getbool(sec, "disabled");
      audio_cfg.disabled = (signed int)return_value_cfg_getbool$14;
      char *return_value_cfg_getstr$15;
      return_value_cfg_getstr$15=cfg_getstr(sec, "card");
      char *return_value___strdup$16;
      return_value___strdup$16=__strdup(return_value_cfg_getstr$15);
      audio_cfg.card = return_value___strdup$16;
      signed long int return_value_cfg_getint$17;
      return_value_cfg_getint$17=cfg_getint(sec, "init");
      audio_cfg.init = (signed int)return_value_cfg_getint$17;
      signed long int return_value_cfg_getint$18;
      return_value_cfg_getint$18=cfg_getint(sec, "step");
      audio_cfg.step = (signed int)return_value_cfg_getint$18;
      enum anonymous$8 return_value_cfg_getbool$19;
      return_value_cfg_getbool$19=cfg_getbool(sec, "beep");
      audio_cfg.beep = (signed int)return_value_cfg_getbool$19;
      char *return_value_cfg_getstr$20;
      return_value_cfg_getstr$20=cfg_getstr(sec, "volume");
      char *return_value___strdup$21;
      return_value___strdup$21=__strdup(return_value_cfg_getstr$20);
      audio_cfg.vol = return_value___strdup$21;
      char *return_value_cfg_getstr$22;
      return_value_cfg_getstr$22=cfg_getstr(sec, "speakers");
      char *return_value___strdup$23;
      return_value___strdup$23=__strdup(return_value_cfg_getstr$22);
      audio_cfg.spkr = return_value___strdup$23;
      char *return_value_cfg_getstr$24;
      return_value_cfg_getstr$24=cfg_getstr(sec, "headphones");
      char *return_value___strdup$25;
      return_value___strdup$25=__strdup(return_value_cfg_getstr$24);
      audio_cfg.head = return_value___strdup$25;
      audio_fix_config();
      sec=cfg_getsec(cfg, "kbd");
      signed long int return_value_cfg_getint$26;
      return_value_cfg_getint$26=cfg_getint(sec, "default");
      kbd_cfg.auto_lvl = (signed int)return_value_cfg_getint$26;
      signed long int return_value_cfg_getint$27;
      return_value_cfg_getint$27=cfg_getint(sec, "step");
      kbd_cfg.step = (signed int)return_value_cfg_getint$27;
      signed long int return_value_cfg_getint$28;
      return_value_cfg_getint$28=cfg_getint(sec, "on_threshold");
      kbd_cfg.on_thresh = (signed int)return_value_cfg_getint$28;
      signed long int return_value_cfg_getint$29;
      return_value_cfg_getint$29=cfg_getint(sec, "off_threshold");
      kbd_cfg.off_thresh = (signed int)return_value_cfg_getint$29;
      enum anonymous$8 return_value_cfg_getbool$30;
      return_value_cfg_getbool$30=cfg_getbool(sec, "auto");
      kbd_cfg.auto_on = (signed int)return_value_cfg_getbool$30;
      signed long int return_value_cfg_getint$31;
      return_value_cfg_getint$31=cfg_getint(sec, "idle_timer");
      kbd_cfg.idle = (signed int)return_value_cfg_getint$31;
      signed long int return_value_cfg_getint$32;
      return_value_cfg_getint$32=cfg_getint(sec, "idle_level");
      kbd_cfg.idle_lvl = (signed int)return_value_cfg_getint$32;
      kbd_backlight_fix_config();
      sec=cfg_getsec(cfg, "eject");
      enum anonymous$8 return_value_cfg_getbool$33;
      return_value_cfg_getbool$33=cfg_getbool(sec, "enabled");
      eject_cfg.enabled = (signed int)return_value_cfg_getbool$33;
      char *return_value_cfg_getstr$34;
      return_value_cfg_getstr$34=cfg_getstr(sec, "device");
      char *return_value___strdup$35;
      return_value___strdup$35=__strdup(return_value_cfg_getstr$34);
      eject_cfg.device = return_value___strdup$35;
      cd_eject_fix_config();
      sec=cfg_getsec(cfg, "beep");
      if(!(audio_cfg.disabled == 0))
        beep_cfg.enabled = 0;

      else
      {
        return_value_cfg_getbool$36=cfg_getbool(sec, "enabled");
        beep_cfg.enabled = (signed int)return_value_cfg_getbool$36;
      }
      char *return_value_cfg_getstr$37;
      return_value_cfg_getstr$37=cfg_getstr(sec, "beepfile");
      char *return_value___strdup$38;
      return_value___strdup$38=__strdup(return_value_cfg_getstr$37);
      beep_cfg.beepfile = return_value___strdup$38;
      beep_fix_config();
      sec=cfg_getsec(cfg, "appleir");
      enum anonymous$8 return_value_cfg_getbool$39;
      return_value_cfg_getbool$39=cfg_getbool(sec, "enabled");
      appleir_cfg.enabled = (signed int)return_value_cfg_getbool$39;
      cfg_free(cfg);
      if(!(console == 0))
        config_print();

      return 0;
    }
  }
}

// config_print
// file conffile.c line 193
static void config_print(void)
{
  printf("pommed configuration:\n");
  printf(" + General settings:\n");
  printf("    fnmode: %d\n", general_cfg.fnmode);
  printf(" + sysfs backlight control:\n");
  printf("    initial level: %d\n", lcd_sysfs_cfg.init);
  printf("    step: %d\n", lcd_sysfs_cfg.step);
  printf("    on_batt: %d\n", lcd_sysfs_cfg.on_batt);
  printf(" + ATI X1600 backlight control:\n");
  printf("    initial level: %d\n", lcd_x1600_cfg.init);
  printf("    step: %d\n", lcd_x1600_cfg.step);
  printf("    on_batt: %d\n", lcd_x1600_cfg.on_batt);
  printf(" + Intel GMA950 backlight control:\n");
  printf("    initial level: 0x%x\n", lcd_gma950_cfg.init);
  printf("    step: 0x%x\n", lcd_gma950_cfg.step);
  printf("    on_batt: 0x%x\n", lcd_gma950_cfg.on_batt);
  printf(" + nVidia GeForce 8600M GT backlight control:\n");
  printf("    initial level: %d\n", lcd_nv8600mgt_cfg.init);
  printf("    step: %d\n", lcd_nv8600mgt_cfg.step);
  printf("    on_batt: %d\n", lcd_nv8600mgt_cfg.on_batt);
  printf(" + Audio volume control:\n");
  if(!(audio_cfg.disabled == 0))
    printf("    disabled: yes\n");

  else
  {
    printf("    card: %s\n", audio_cfg.card);
    printf("    initial volume: %d%s\n", audio_cfg.init, audio_cfg.init > -1 ? "%" : "");
    printf("    step: %d%%\n", audio_cfg.step);
    printf("    beep: %s\n", audio_cfg.beep != 0 ? "yes" : "no");
    printf("    volume element: %s\n", audio_cfg.vol);
    printf("    speaker element: %s\n", audio_cfg.spkr);
    printf("    headphones element: %s\n", audio_cfg.head);
  }
  printf(" + Keyboard backlight control:\n");
  printf("    default level: %d\n", kbd_cfg.auto_lvl);
  printf("    step: %d\n", kbd_cfg.step);
  printf("    auto on threshold: %d\n", kbd_cfg.on_thresh);
  printf("    auto off threshold: %d\n", kbd_cfg.off_thresh);
  printf("    auto enable: %s\n", kbd_cfg.auto_on != 0 ? "yes" : "no");
  printf("    idle timer: %d%s\n", kbd_cfg.idle, kbd_cfg.idle > 0 ? "s" : "");
  printf("    idle level: %d\n", kbd_cfg.idle_lvl);
  printf(" + CD eject:\n");
  printf("    enabled: %s\n", eject_cfg.enabled != 0 ? "yes" : "no");
  printf("    device: %s\n", eject_cfg.device);
  printf(" + Beep:\n");
  printf("    enabled: %s\n", beep_cfg.enabled != 0 ? "yes" : "no");
  printf("    beepfile: %s\n", beep_cfg.beepfile);
  printf(" + Apple Remote IR Receiver:\n");
  printf("    enabled: %s\n", appleir_cfg.enabled != 0 ? "yes" : "no");
}

// config_validate_positive_integer
// file conffile.c line 164
static signed int config_validate_positive_integer(struct cfg_t *cfg, struct cfg_opt_t *opt)
{
  signed int value;
  unsigned int return_value_cfg_opt_size$1;
  return_value_cfg_opt_size$1=cfg_opt_size(opt);
  signed long int return_value_cfg_opt_getnint$2;
  return_value_cfg_opt_getnint$2=cfg_opt_getnint(opt, return_value_cfg_opt_size$1 - (unsigned int)1);
  value = (signed int)return_value_cfg_opt_getnint$2;
  if(!(value >= 0))
  {
    cfg_error(cfg, "Error: Value for '%s/%s' must be positive", cfg->name, opt->name);
    return -1;
  }

  else
    return 0;
}

// config_validate_string
// file conffile.c line 178
static signed int config_validate_string(struct cfg_t *cfg, struct cfg_opt_t *opt)
{
  char *value;
  unsigned int return_value_cfg_opt_size$1;
  return_value_cfg_opt_size$1=cfg_opt_size(opt);
  value=cfg_opt_getnstr(opt, return_value_cfg_opt_size$1 - (unsigned int)1);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(value);
  if(return_value_strlen$2 == 0ul)
  {
    cfg_error(cfg, "Error: Value for '%s/%s' must be a non-zero string", cfg->name, opt->name);
    return -1;
  }

  else
    return 0;
}

// dbus_to_epoll
// file dbus.c line 870
static unsigned int dbus_to_epoll(signed int flags)
{
  unsigned int events = (unsigned int)0;
  if(!((1 & flags) == 0))
    events = events | (unsigned int)1;

  if(!((2 & flags) == 0))
    events = events | (unsigned int)(4 | -2147483648);

  return events;
}

// epoll_to_dbus
// file dbus.c line 886
static signed int epoll_to_dbus(unsigned int events)
{
  signed int flags = 0;
  if(!((1u & events) == 0u))
    flags = flags | 1;

  if(!((4u & events) == 0u))
    flags = flags | 2;

  if(!((16u & events) == 0u))
    flags = flags | 8;

  if(!((8u & events) == 0u))
    flags = flags | 4;

  return flags;
}

// evdev_cleanup
// file evdev.h line 135
void evdev_cleanup(void)
{
  ;
}

// evdev_init
// file evdev.h line 132
signed int evdev_init(void)
{
  signed int ret;
  signed int i;
  char evdev[32l];
  signed int ndevs;
  signed int evdev_init$$1$$fd;
  internal_kbd_fd = -1;
  ndevs = 0;
  i = 0;
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  for( ; !(i >= 32); i = i + 1)
  {
    ret=snprintf(evdev, (unsigned long int)32, "%s%d", (const void *)"/dev/input/event", i);
    if(ret >= 32 || !(ret >= 1))
      return -1;

    evdev_init$$1$$fd=open(evdev, 02);
    if(!(evdev_init$$1$$fd >= 0))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      if(!(*return_value___errno_location$3 == 2))
      {
        return_value___errno_location$1=__errno_location();
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        logmsg(4, "Could not open %s: %s", (const void *)evdev, return_value_strerror$2);
      }

      goto __CPROVER_DUMP_L6;
    }

    signed int return_value_evdev_try_add$4;
    return_value_evdev_try_add$4=evdev_try_add(evdev_init$$1$$fd);
    if(return_value_evdev_try_add$4 == 0)
      ndevs = ndevs + 1;


  __CPROVER_DUMP_L6:
    ;
  }
  logdebug("\nFound %d devices\n", ndevs);
  evdev_inotify_init();
  return ndevs;
}

// evdev_inotify_init
// file evdev.c line 1133
static signed int evdev_inotify_init(void)
{
  signed int ret;
  signed int evdev_inotify_init$$1$$fd;
  evdev_inotify_init$$1$$fd=inotify_init();
  if(!(evdev_inotify_init$$1$$fd >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    logmsg(3, "Failed to initialize inotify: %s", return_value_strerror$2);
    return -1;
  }

  ret=inotify_add_watch(evdev_inotify_init$$1$$fd, "/dev/input", (unsigned int)(0x00000100 | 0x01000000));
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    logmsg(3, "Failed to add inotify watch for %s: %s", (const void *)"/dev/input", return_value_strerror$4);
    close(evdev_inotify_init$$1$$fd);
    evdev_inotify_init$$1$$fd = -1;
    return -1;
  }

  ret=evloop_add(evdev_inotify_init$$1$$fd, (unsigned int)1, evdev_inotify_process);
  if(!(ret >= 0))
  {
    logmsg(3, "Failed to add inotify fd to event loop");
    close(evdev_inotify_init$$1$$fd);
    return -1;
  }

  else
    return 0;
}

// evdev_inotify_process
// file evdev.c line 234
void evdev_inotify_process(signed int fd, unsigned int events)
{
  signed int ret;
  signed int efd;
  signed int qsize;
  struct inotify_event *all_ie;
  struct inotify_event *ie;
  char evdev[32l];
  _Bool tmp_if_expr$7;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  if(!((24u & events) == 0u))
  {
    logmsg(4, "inotify fd lost; this should not happen");
    ret=evloop_remove(fd);
    if(!(ret >= 0))
      logmsg(3, "Could not remove inotify from event loop");

    close(fd);
  }

  else
  {
    ret=ioctl(fd, (unsigned long int)0x541B, &qsize);
    if(!(ret >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      logmsg(3, "Could not determine inotify queue size: %s", return_value_strerror$2);
      goto __CPROVER_DUMP_L16;
    }

    void *return_value_malloc$3;
    return_value_malloc$3=malloc((unsigned long int)qsize);
    all_ie = (struct inotify_event *)return_value_malloc$3;
    if(all_ie == ((struct inotify_event *)NULL))
      logmsg(3, "Could not allocate %d bytes for inotify events", qsize);

    else
    {
      signed long int return_value_read$4;
      return_value_read$4=read(fd, (void *)all_ie, (unsigned long int)qsize);
      ret = (signed int)return_value_read$4;
      if(!(ret >= 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        logmsg(4, "inotify read failed: %s", return_value_strerror$6);
        free((void *)all_ie);
        goto __CPROVER_DUMP_L16;
      }

      qsize = qsize / (signed int)sizeof(struct inotify_event) /*16ul*/ ;
      ie = all_ie;
      for( ; !(ie - all_ie >= (signed long int)qsize); ie = ie + (signed long int)((unsigned long int)1 + (unsigned long int)ie->len / sizeof(struct inotify_event) /*16ul*/ ))
      {
        if(ie->len == 0u)
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = ie->name == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$7)
          logdebug("inotify event with no name\n");

        else
        {
          logdebug("Found new event device %s/%s\n", (const void *)"/dev/input", (const void *)ie->name);
          signed int return_value_strncmp$8;
          return_value_strncmp$8=strncmp("event", ie->name, (unsigned long int)5);
          if(!(return_value_strncmp$8 == 0))
            logdebug("Discarding %s/%s\n", (const void *)"/dev/input", (const void *)ie->name);

          else
          {
            ret=snprintf(evdev, sizeof(char [32l]) /*32ul*/ , "%s/%s", (const void *)"/dev/input", (const void *)ie->name);
            if(!((unsigned long int)ret >= sizeof(char [32l]) /*32ul*/ ) && ret >= 1)
            {
              efd=open(evdev, 02);
              if(!(efd >= 0))
              {
                signed int *return_value___errno_location$11;
                return_value___errno_location$11=__errno_location();
                if(!(*return_value___errno_location$11 == 2))
                {
                  return_value___errno_location$9=__errno_location();
                  return_value_strerror$10=strerror(*return_value___errno_location$9);
                  logmsg(4, "Could not open %s: %s", (const void *)evdev, return_value_strerror$10);
                }

                goto __CPROVER_DUMP_L14;
              }

              evdev_try_add(efd);
            }

          }
        }

      __CPROVER_DUMP_L14:
        ;
      }
      free((void *)all_ie);
    }
  }

__CPROVER_DUMP_L16:
  ;
}

// evdev_is_appleir
// file evdev.c line 840
static signed int evdev_is_appleir(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x8240 || (signed int)product == 0x8242)
      {
        logdebug(" -> Apple IR receiver\n");
        return 1;
      }

      else
        return 0;
}

// evdev_is_extkbd
// file evdev.c line 1014
static signed int evdev_is_extkbd(unsigned short int *id)
{
  signed int return_value_evdev_is_extkbd_white$1;
  return_value_evdev_is_extkbd_white$1=evdev_is_extkbd_white(id);
  _Bool tmp_if_expr$3;
  signed int return_value_evdev_is_extkbd_mini_alu$2;
  if(!(return_value_evdev_is_extkbd_white$1 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_evdev_is_extkbd_mini_alu$2=evdev_is_extkbd_mini_alu(id);
    tmp_if_expr$3 = return_value_evdev_is_extkbd_mini_alu$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  signed int return_value_evdev_is_extkbd_alu$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_evdev_is_extkbd_alu$4=evdev_is_extkbd_alu(id);
    tmp_if_expr$5 = return_value_evdev_is_extkbd_alu$4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  signed int return_value_evdev_is_extkbd_alu_wl$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_evdev_is_extkbd_alu_wl$6=evdev_is_extkbd_alu_wl(id);
    tmp_if_expr$7 = return_value_evdev_is_extkbd_alu_wl$6 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$9;
  signed int return_value_evdev_is_extkbd_alu_wl_2$8;
  if(tmp_if_expr$7)
    tmp_if_expr$9 = (_Bool)1;

  else
  {
    return_value_evdev_is_extkbd_alu_wl_2$8=evdev_is_extkbd_alu_wl_2(id);
    tmp_if_expr$9 = return_value_evdev_is_extkbd_alu_wl_2$8 != 0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr$9;
}

// evdev_is_extkbd_alu
// file evdev.c line 936
static signed int evdev_is_extkbd_alu(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x0220 || (signed int)product == 0x0221 || (signed int)product == 0x0222)
      {
        logdebug(" -> External Apple USB keyboard (aluminium)\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_extkbd_alu_wl
// file evdev.c line 962
static signed int evdev_is_extkbd_alu_wl(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x05))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x022c || (signed int)product == 0x022d || (signed int)product == 0x022e)
      {
        logdebug(" -> External Apple wireless keyboard (aluminium)\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_extkbd_alu_wl_2
// file evdev.c line 988
static signed int evdev_is_extkbd_alu_wl_2(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x05))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x0239 || (signed int)product == 0x023a || (signed int)product == 0x023b)
      {
        logdebug(" -> External Apple wireless keyboard 2 (aluminium)\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_extkbd_mini_alu
// file evdev.c line 910
static signed int evdev_is_extkbd_mini_alu(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x021d || (signed int)product == 0x021e || (signed int)product == 0x021f)
      {
        logdebug(" -> External Apple USB mini keyboard (aluminium)\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_extkbd_white
// file evdev.c line 886
static signed int evdev_is_extkbd_white(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x020c)
      {
        logdebug(" -> External Apple USB keyboard (white)\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_geyser3
// file evdev.c line 451
static signed int evdev_is_geyser3(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x0217 || (signed int)product == 0x0218 || (signed int)product == 0x0219)
      {
        logdebug(" -> Geyser III USB assembly\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_geyser4
// file evdev.c line 477
static signed int evdev_is_geyser4(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x021a || (signed int)product == 0x021b || (signed int)product == 0x021c)
      {
        logdebug(" -> Geyser IV USB assembly\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_geyser4hf
// file evdev.c line 504
static signed int evdev_is_geyser4hf(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x0229 || (signed int)product == 0x022a || (signed int)product == 0x022b)
      {
        logdebug(" -> Geyser IV-HF USB assembly\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_internal
// file evdev.c line 819
static signed int evdev_is_internal(unsigned short int *id)
{
  signed int return_value_evdev_is_geyser3$1;
  return_value_evdev_is_geyser3$1=evdev_is_geyser3(id);
  _Bool tmp_if_expr$3;
  signed int return_value_evdev_is_geyser4$2;
  if(!(return_value_evdev_is_geyser3$1 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_evdev_is_geyser4$2=evdev_is_geyser4(id);
    tmp_if_expr$3 = return_value_evdev_is_geyser4$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  signed int return_value_evdev_is_geyser4hf$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_evdev_is_geyser4hf$4=evdev_is_geyser4hf(id);
    tmp_if_expr$5 = return_value_evdev_is_geyser4hf$4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  signed int return_value_evdev_is_wellspring$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_evdev_is_wellspring$6=evdev_is_wellspring(id);
    tmp_if_expr$7 = return_value_evdev_is_wellspring$6 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$9;
  signed int return_value_evdev_is_wellspring2$8;
  if(tmp_if_expr$7)
    tmp_if_expr$9 = (_Bool)1;

  else
  {
    return_value_evdev_is_wellspring2$8=evdev_is_wellspring2(id);
    tmp_if_expr$9 = return_value_evdev_is_wellspring2$8 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$11;
  signed int return_value_evdev_is_wellspring3$10;
  if(tmp_if_expr$9)
    tmp_if_expr$11 = (_Bool)1;

  else
  {
    return_value_evdev_is_wellspring3$10=evdev_is_wellspring3(id);
    tmp_if_expr$11 = return_value_evdev_is_wellspring3$10 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$13;
  signed int return_value_evdev_is_wellspring4$12;
  if(tmp_if_expr$11)
    tmp_if_expr$13 = (_Bool)1;

  else
  {
    return_value_evdev_is_wellspring4$12=evdev_is_wellspring4(id);
    tmp_if_expr$13 = return_value_evdev_is_wellspring4$12 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$15;
  signed int return_value_evdev_is_wellspring4a$14;
  if(tmp_if_expr$13)
    tmp_if_expr$15 = (_Bool)1;

  else
  {
    return_value_evdev_is_wellspring4a$14=evdev_is_wellspring4a(id);
    tmp_if_expr$15 = return_value_evdev_is_wellspring4a$14 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$17;
  signed int return_value_evdev_is_wellspring5$16;
  if(tmp_if_expr$15)
    tmp_if_expr$17 = (_Bool)1;

  else
  {
    return_value_evdev_is_wellspring5$16=evdev_is_wellspring5(id);
    tmp_if_expr$17 = return_value_evdev_is_wellspring5$16 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$19;
  signed int return_value_evdev_is_wellspring5a$18;
  if(tmp_if_expr$17)
    tmp_if_expr$19 = (_Bool)1;

  else
  {
    return_value_evdev_is_wellspring5a$18=evdev_is_wellspring5a(id);
    tmp_if_expr$19 = return_value_evdev_is_wellspring5a$18 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$21;
  signed int return_value_evdev_is_wellspring6$20;
  if(tmp_if_expr$19)
    tmp_if_expr$21 = (_Bool)1;

  else
  {
    return_value_evdev_is_wellspring6$20=evdev_is_wellspring6(id);
    tmp_if_expr$21 = return_value_evdev_is_wellspring6$20 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$23;
  signed int return_value_evdev_is_wellspring6a$22;
  if(tmp_if_expr$21)
    tmp_if_expr$23 = (_Bool)1;

  else
  {
    return_value_evdev_is_wellspring6a$22=evdev_is_wellspring6a(id);
    tmp_if_expr$23 = return_value_evdev_is_wellspring6a$22 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$25;
  signed int return_value_evdev_is_wellspring7$24;
  if(tmp_if_expr$23)
    tmp_if_expr$25 = (_Bool)1;

  else
  {
    return_value_evdev_is_wellspring7$24=evdev_is_wellspring7(id);
    tmp_if_expr$25 = return_value_evdev_is_wellspring7$24 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$27;
  signed int return_value_evdev_is_wellspring7a$26;
  if(tmp_if_expr$25)
    tmp_if_expr$27 = (_Bool)1;

  else
  {
    return_value_evdev_is_wellspring7a$26=evdev_is_wellspring7a(id);
    tmp_if_expr$27 = return_value_evdev_is_wellspring7a$26 != 0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr$27;
}

// evdev_is_lidswitch
// file evdev.c line 863
static signed int evdev_is_lidswitch(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x19))
    return 0;

  else
    if(!((signed int)id[1l] == 0))
      return 0;

    else
      if((signed int)product == 0x0005)
      {
        logdebug(" -> ACPI LID switch\n");
        return 1;
      }

      else
        return 0;
}

// evdev_is_mouseemu
// file evdev.c line 1025
static signed int evdev_is_mouseemu(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x06))
    return 0;

  else
    if(!((signed int)id[1l] == 0x001f))
      return 0;

    else
      if((signed int)product == 0x001f)
      {
        logdebug(" -> Mouseemu virtual keyboard\n");
        return 1;
      }

      else
        return 0;
}

// evdev_is_wellspring
// file evdev.c line 530
static signed int evdev_is_wellspring(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x0223 || (signed int)product == 0x0224 || (signed int)product == 0x0225)
      {
        logdebug(" -> WellSpring USB assembly\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_wellspring2
// file evdev.c line 556
static signed int evdev_is_wellspring2(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x0230 || (signed int)product == 0x0231 || (signed int)product == 0x0232)
      {
        logdebug(" -> WellSpring II USB assembly\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_wellspring3
// file evdev.c line 584
static signed int evdev_is_wellspring3(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x0236 || (signed int)product == 0x0237 || (signed int)product == 0x0238)
      {
        logdebug(" -> WellSpring III USB assembly\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_wellspring4
// file evdev.c line 610
static signed int evdev_is_wellspring4(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x023f || (signed int)product == 0x0240 || (signed int)product == 0x0241)
      {
        logdebug(" -> WellSpring IV USB assembly\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_wellspring4a
// file evdev.c line 636
static signed int evdev_is_wellspring4a(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x0242 || (signed int)product == 0x0243 || (signed int)product == 0x0244)
      {
        logdebug(" -> WellSpring IVa USB assembly\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_wellspring5
// file evdev.c line 665
static signed int evdev_is_wellspring5(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x0245 || (signed int)product == 0x0246 || (signed int)product == 0x0247)
      {
        logdebug(" -> WellSpring V USB assembly\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_wellspring5a
// file evdev.c line 693
static signed int evdev_is_wellspring5a(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x0252 || (signed int)product == 0x0253 || (signed int)product == 0x0254)
      {
        logdebug(" -> WellSpring VA USB assembly\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_wellspring6
// file evdev.c line 718
static signed int evdev_is_wellspring6(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x024c || (signed int)product == 0x024d || (signed int)product == 0x024e)
      {
        logdebug(" -> WellSpring VI USB assembly\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_wellspring6a
// file evdev.c line 743
static signed int evdev_is_wellspring6a(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x0249 || (signed int)product == 0x024a || (signed int)product == 0x024b)
      {
        logdebug(" -> WellSpring VIA USB assembly\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_wellspring7
// file evdev.c line 768
static signed int evdev_is_wellspring7(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x0262 || (signed int)product == 0x0263 || (signed int)product == 0x0264)
      {
        logdebug(" -> WellSpring VII USB assembly\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_is_wellspring7a
// file evdev.c line 793
static signed int evdev_is_wellspring7a(unsigned short int *id)
{
  unsigned short int product = id[(signed long int)2];
  if(!((signed int)*id == 0x03))
    return 0;

  else
    if(!((signed int)id[1l] == 0x05ac))
      return 0;

    else
      if((signed int)product == 0x0259 || (signed int)product == 0x025a || (signed int)product == 0x025b)
      {
        logdebug(" -> WellSpring VIIA USB assembly\n");
        kbd_set_fnmode();
        return 1;
      }

      else
        return 0;
}

// evdev_process_events
// file evdev.c line 70
void evdev_process_events(signed int fd, unsigned int events)
{
  signed int ret;
  struct input_event ev;
  signed int return_value_has_kbd_backlight$2;
  signed int return_value_has_kbd_backlight$3;
  signed int return_value_has_kbd_backlight$4;
  if(!((24u & events) == 0u))
  {
    logmsg(6, "Error condition signaled on event device");
    ret=evloop_remove(fd);
    if(!(ret >= 0))
      logmsg(3, "Could not remove device from event loop");

    if(fd == internal_kbd_fd)
      internal_kbd_fd = -1;

    close(fd);
  }

  else
  {
    signed long int return_value_read$1;
    return_value_read$1=read(fd, (void *)&ev, sizeof(struct input_event) /*24ul*/ );
    ret = (signed int)return_value_read$1;
    if((unsigned long int)ret == sizeof(struct input_event) /*24ul*/ )
    {
      if((signed int)ev.type == 0x01)
      {
        if(ev.value == 0)
          goto __CPROVER_DUMP_L31;

        if(fd == internal_kbd_fd)
        {
          kbd_bck_info.idle = 0;
          kbd_backlight_inhibit_clear(1 << 3);
        }

        switch((signed int)ev.code)
        {
          case 224:
          {
            logdebug("\nKEY: LCD backlight down\n");
            mops->lcd_backlight_step(-1);
          }
          case 225:
          {
            logdebug("\nKEY: LCD backlight up\n");
            mops->lcd_backlight_step(1);
          }
          case 113:
          {
            logdebug("\nKEY: audio mute\n");
            audio_toggle_mute();
            break;
          }
          case 114:
          {
            logdebug("\nKEY: audio down\n");
            audio_step(-1);
            break;
          }
          case 115:
          {
            logdebug("\nKEY: audio up\n");
            audio_step(1);
            break;
          }
          case 227:
          {
            logdebug("\nKEY: video toggle\n");
            video_switch();
            break;
          }
          case 228:
          {
            logdebug("\nKEY: keyboard backlight off\n");
            return_value_has_kbd_backlight$2=has_kbd_backlight();
            if(return_value_has_kbd_backlight$2 == 0)
              break;

            if(!(kbd_cfg.auto_on == 0))
              kbd_backlight_inhibit_toggle(1 << 0);

            else
              kbd_backlight_toggle();
            break;
          }
          case 229:
          {
            logdebug("\nKEY: keyboard backlight down\n");
            return_value_has_kbd_backlight$3=has_kbd_backlight();
            if(return_value_has_kbd_backlight$3 == 0)
              break;

            kbd_backlight_step(-1);
            if(kbd_bck_info.level == 0)
              kbd_backlight_inhibit_set(1 << 0);

            break;
          }
          case 230:
          {
            logdebug("\nKEY: keyboard backlight up\n");
            return_value_has_kbd_backlight$4=has_kbd_backlight();
            if(return_value_has_kbd_backlight$4 == 0)
              break;

            kbd_backlight_inhibit_clear(1 << 0);
            kbd_backlight_step(1);
            break;
          }
          case 161:
          {
            logdebug("\nKEY: CD eject\n");
            cd_eject();
            break;
          }
          case 163:
          {
            logdebug("\nKEY: IR fast forward\n");
            break;
          }
          case 165:
          {
            logdebug("\nKEY: IR rewind\n");
            break;
          }
          case 164:
          {
            logdebug("\nKEY: IR play/pause\n");
            break;
          }
          case 139:
          {
            logdebug("\nKEY: IR menu\n");
            break;
          }
          default:
            ;
        }
      }

      else
        if((signed int)ev.type == 0x05)
        {
          if((signed int)ev.code == 0x00)
          {
            if(!(ev.value == 0))
            {
              logdebug("\nLID: closed\n");
              kbd_backlight_inhibit_set(1 << 1);
            }

            else
            {
              logdebug("\nLID: open\n");
              kbd_backlight_inhibit_clear(1 << 1);
            }
          }

        }

    }

  }

__CPROVER_DUMP_L31:
  ;
}

// evdev_try_add
// file evdev.c line 1047
static signed int evdev_try_add(signed int fd)
{
  unsigned short int id[4l];
  unsigned long int bit[31l][12l];
  char devname[256l];
  signed int ret;
  devname[(signed long int)0] = (char)0;
  ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(69 << 0 + 8) | (unsigned int)(0x06 << 0)) | sizeof(char [256l]) /*256ul*/  << 0 + 8 + 8, (const void *)devname);
  logdebug("\nInvestigating evdev [%s]\n", (const void *)devname);
  ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(69 << 0 + 8) | (unsigned int)(0x02 << 0)) | sizeof(struct input_id) /*8ul*/  << 0 + 8 + 8, (const void *)id);
  signed int return_value_evdev_is_internal$8;
  return_value_evdev_is_internal$8=evdev_is_internal(id);
  _Bool tmp_if_expr$7;
  signed int return_value_evdev_is_appleir$6;
  signed int return_value_has_kbd_backlight$3;
  _Bool tmp_if_expr$5;
  signed int return_value_evdev_is_lidswitch$4;
  signed int return_value_evdev_is_mouseemu$2;
  signed int return_value_evdev_is_extkbd$1;
  signed int return_value_evdev_is_extkbd_alu_wl$9;
  signed int return_value_evdev_is_internal$10;
  if(return_value_evdev_is_internal$8 == 0)
  {
    if(!(appleir_cfg.enabled == 0))
    {
      return_value_evdev_is_appleir$6=evdev_is_appleir(id);
      tmp_if_expr$7 = return_value_evdev_is_appleir$6 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$7 = (_Bool)0;
    if(tmp_if_expr$7)
      goto __CPROVER_DUMP_L5;

    return_value_has_kbd_backlight$3=has_kbd_backlight();
    if(!(return_value_has_kbd_backlight$3 == 0))
    {
      return_value_evdev_is_lidswitch$4=evdev_is_lidswitch(id);
      tmp_if_expr$5 = return_value_evdev_is_lidswitch$4 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
      goto __CPROVER_DUMP_L5;

    return_value_evdev_is_mouseemu$2=evdev_is_mouseemu(id);
    if(!(return_value_evdev_is_mouseemu$2 == 0))
      goto __CPROVER_DUMP_L5;

    return_value_evdev_is_extkbd$1=evdev_is_extkbd(id);
    if(!(return_value_evdev_is_extkbd$1 == 0))
      goto __CPROVER_DUMP_L5;

    logdebug("Discarding evdev: bus 0x%04x, vid 0x%04x, pid 0x%04x\n", id[(signed long int)0], id[(signed long int)1], id[(signed long int)2]);
    close(fd);
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L5:
    ;
    memset((void *)bit, 0, sizeof(unsigned long int [31l][12l]) /*2976ul*/ );
    ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(69 << 0 + 8) | (unsigned int)(0x20 + 0 << 0) | (unsigned int)(0x1f << 0 + 8 + 8)), (const void *)bit[(signed long int)0]);
    if((1ul & bit[0l][0l] >> 1ul) == 0ul)
    {
      logdebug("evdev: no EV_KEY event type (not a keyboard)\n");
      if((1ul & bit[0l][0l] >> 5ul) == 0ul)
      {
        logdebug("Discarding evdev: no EV_SW event type (not a switch)\n");
        close(fd);
        return -1;
      }

    }

    else
      if(!((1ul & bit[0l][0l] >> 3ul) == 0ul))
      {
        return_value_evdev_is_extkbd_alu_wl$9=evdev_is_extkbd_alu_wl(id);
        if(return_value_evdev_is_extkbd_alu_wl$9 == 0)
        {
          logdebug("Discarding evdev with EV_ABS event type (mouse/trackpad)\n");
          close(fd);
          return -1;
        }

      }

    if(!((1ul & bit[0l][0l] >> 17ul) == 0ul))
    {
      return_value_evdev_is_internal$10=evdev_is_internal(id);
      if(!(return_value_evdev_is_internal$10 == 0))
      {
        logdebug(" -> Internal keyboard\n");
        internal_kbd_fd = fd;
      }

    }

    ret=evloop_add(fd, (unsigned int)1, evdev_process_events);
    if(!(ret >= 0))
    {
      logmsg(3, "Could not add device to event loop");
      if(fd == internal_kbd_fd)
        internal_kbd_fd = -1;

      close(fd);
      return -1;
    }

    else
      return 0;
  }
}

// evloop_add
// file evloop.h line 41
signed int evloop_add(signed int fd, unsigned int events, void (*cb)(signed int, unsigned int))
{
  signed int ret;
  struct epoll_event epoll_ev;
  struct pommed_event *pommed_ev;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct pommed_event) /*24ul*/ );
  pommed_ev = (struct pommed_event *)return_value_malloc$1;
  if(pommed_ev == ((struct pommed_event *)NULL))
  {
    logmsg(3, "Could not allocate memory for new source");
    return -1;
  }

  else
  {
    pommed_ev->fd = fd;
    pommed_ev->cb = cb;
    pommed_ev->next = sources;
    epoll_ev.events = events;
    epoll_ev.data.ptr = (void *)pommed_ev;
    ret=epoll_ctl(epfd, 1, fd, &epoll_ev);
    if(!(ret >= 0))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      logmsg(3, "Could not add source to epoll: %s", return_value_strerror$3);
      free((void *)pommed_ev);
      return -1;
    }

    sources = pommed_ev;
    return 0;
  }
}

// evloop_add_timer
// file evloop.c line 218
signed int evloop_add_timer(signed int timeout, void (*cb)(signed int, unsigned long int))
{
  signed int evloop_add_timer$$1$$fd;
  struct pommed_timer *t;
  struct pommed_timer_job *j;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct pommed_timer_job) /*24ul*/ );
  j = (struct pommed_timer_job *)return_value_malloc$1;
  if(j == ((struct pommed_timer_job *)NULL))
  {
    logmsg(3, "Could not allocate memory for timer job");
    return -1;
  }

  else
  {
    j->cb = cb;
    j->id = timer_job_id;
    timer_job_id = timer_job_id + 1;
    t = timers;
    for( ; !(t == ((struct pommed_timer *)NULL)); t = t->next)
      if(t->timeout == timeout)
        break;

    if(t == ((struct pommed_timer *)NULL))
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(struct pommed_timer) /*24ul*/ );
      t = (struct pommed_timer *)return_value_malloc$2;
      if(t == ((struct pommed_timer *)NULL))
      {
        logmsg(3, "Could not allocate memory for timer");
        return -1;
      }

      evloop_add_timer$$1$$fd=evloop_create_timer(timeout);
      if(!(evloop_add_timer$$1$$fd >= 0))
      {
        free((void *)t);
        return -1;
      }

      t->fd = evloop_add_timer$$1$$fd;
      t->timeout = timeout;
      t->jobs = (struct pommed_timer_job *)(void *)0;
      t->next = timers;
      timers = t;
    }

    j->next = t->jobs;
    t->jobs = j;
    return 0;
  }
}

// evloop_cleanup
// file evloop.h line 62
void evloop_cleanup(void)
{
  struct pommed_event *p;
  struct pommed_timer *t;
  struct pommed_timer_job *j;
  struct pommed_timer_job *jobs;
  close(epfd);
  while(!(sources == ((struct pommed_event *)NULL)))
  {
    p = sources;
    sources = sources->next;
    close(p->fd);
    free((void *)p);
  }
  while(!(timers == ((struct pommed_timer *)NULL)))
  {
    t = timers;
    timers = timers->next;
    jobs = t->jobs;
    while(!(jobs == ((struct pommed_timer_job *)NULL)))
    {
      j = jobs;
      jobs = jobs->next;
      free((void *)j);
    }
    free((void *)t);
  }
}

// evloop_create_timer
// file evloop.c line 163
static signed int evloop_create_timer(signed int timeout)
{
  signed int evloop_create_timer$$1$$fd;
  signed int ret;
  struct itimerspec timing;
  evloop_create_timer$$1$$fd=timerfd_create(1, 0);
  if(!(evloop_create_timer$$1$$fd >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    logmsg(3, "Could not create timer: %s", return_value_strerror$2);
    return -1;
  }

  timing.it_interval.tv_sec = (signed long int)(timeout >= 1000 ? timeout / 1000 : 0);
  timing.it_interval.tv_nsec = ((signed long int)timeout - timing.it_interval.tv_sec * (signed long int)1000) * (signed long int)1000000;
  ret=clock_gettime(1, &timing.it_value);
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    logmsg(3, "Could not get current time: %s", return_value_strerror$4);
    close(evloop_create_timer$$1$$fd);
    return -1;
  }

  timing.it_value.tv_sec = timing.it_value.tv_sec + timing.it_interval.tv_sec;
  timing.it_value.tv_nsec = timing.it_value.tv_nsec + timing.it_interval.tv_nsec;
  if(timing.it_value.tv_nsec >= 1000000001l)
  {
    timing.it_value.tv_sec = timing.it_value.tv_sec + 1l;
    timing.it_value.tv_nsec = timing.it_value.tv_nsec - (signed long int)1000000000;
  }

  ret=timerfd_settime(evloop_create_timer$$1$$fd, 1, &timing, (struct itimerspec *)(void *)0);
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    logmsg(3, "Could not setup timer: %s", return_value_strerror$6);
    close(evloop_create_timer$$1$$fd);
    return -1;
  }

  ret=evloop_add(evloop_create_timer$$1$$fd, (unsigned int)1, evloop_timer_callback);
  if(!(ret >= 0))
  {
    close(evloop_create_timer$$1$$fd);
    return -1;
  }

  else
    return evloop_create_timer$$1$$fd;
}

// evloop_init
// file evloop.h line 59
signed int evloop_init(void)
{
  sources = (struct pommed_event *)(void *)0;
  timers = (struct pommed_timer *)(void *)0;
  timer_job_id = 0;
  running = 1;
  epfd=epoll_create(8);
  if(!(epfd >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    logmsg(3, "Could not create epoll fd: %s", return_value_strerror$2);
    return -1;
  }

  return 0;
}

// evloop_iteration
// file evloop.h line 53
signed int evloop_iteration(void)
{
  signed int i;
  signed int nfds;
  struct epoll_event epoll_ev[8l];
  struct pommed_event *pommed_ev;
  if(running == 0)
    return -1;

  else
  {
    nfds=epoll_wait(epfd, epoll_ev, 8, -1);
    if(!(nfds >= 0))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      if(*return_value___errno_location$3 == 4)
        return 0;

      else
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        char *return_value_strerror$2;
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        logmsg(3, "epoll_wait() error: %s", return_value_strerror$2);
        return -1;
      }
    }

    i = 0;
    if(!(i >= nfds))
    {
      pommed_ev = (struct pommed_event *)epoll_ev[(signed long int)i].data.ptr;
      pommed_ev->cb(pommed_ev->fd, epoll_ev[(signed long int)i].events);
      i = i + 1;
    }

    return nfds;
  }
}

// evloop_remove
// file evloop.h line 44
signed int evloop_remove(signed int fd)
{
  signed int ret;
  struct pommed_event *p;
  struct pommed_event *e;
  ret=epoll_ctl(epfd, 2, fd, (struct epoll_event *)(void *)0);
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    logmsg(3, "Could not remove source from epoll: %s", return_value_strerror$2);
    return -1;
  }

  p = (struct pommed_event *)(void *)0;
  e = sources;
  for( ; !(e == ((struct pommed_event *)NULL)); e = e->next)
  {
    if(e->fd == fd)
    {
      if(!(p == ((struct pommed_event *)NULL)))
        p->next = e->next;

      else
        sources = e->next;
      free((void *)e);
      break;
    }

    p = e;
  }
  return 0;
}

// evloop_remove_timer
// file evloop.c line 272
signed int evloop_remove_timer(signed int id)
{
  signed int found;
  signed int ret;
  struct pommed_timer *t;
  struct pommed_timer *pt;
  struct pommed_timer_job *j;
  struct pommed_timer_job *pj;
  found = 0;
  pt = (struct pommed_timer *)(void *)0;
  t = timers;
  for( ; !(t == ((struct pommed_timer *)NULL)); t = t->next)
  {
    pj = (struct pommed_timer_job *)(void *)0;
    j = t->jobs;
    for( ; !(j == ((struct pommed_timer_job *)NULL)); j = j->next)
    {
      if(j->id == id)
      {
        if(!(pj == ((struct pommed_timer_job *)NULL)))
          pj->next = j->next;

        else
          t->jobs = j->next;
        free((void *)j);
        found = 1;
        break;
      }

      pj = j;
    }
    if(!(found == 0))
      break;

    pt = t;
  }
  if(t == ((struct pommed_timer *)NULL))
    return 0;

  else
  {
    if(t->jobs == ((struct pommed_timer_job *)NULL))
    {
      ret=evloop_remove(t->fd);
      if(!(ret >= 0))
        return ret;

      close(t->fd);
      if(!(pt == ((struct pommed_timer *)NULL)))
        pt->next = t->next;

      else
        timers = t->next;
      free((void *)t);
    }

    return 0;
  }
}

// evloop_stop
// file evloop.h line 56
void evloop_stop(void)
{
  running = 0;
}

// evloop_timer_callback
// file evloop.c line 133
static void evloop_timer_callback(signed int fd, unsigned int events)
{
  unsigned long int ticks;
  struct pommed_timer *t;
  struct pommed_timer_job *j;
  read(fd, (void *)&ticks, sizeof(unsigned long int) /*8ul*/ );
  j = (struct pommed_timer_job *)(void *)0;
  t = timers;
  for( ; !(t == ((struct pommed_timer *)NULL)); t = t->next)
    if(t->fd == fd)
    {
      j = t->jobs;
      break;
    }

  if(!(j == ((struct pommed_timer_job *)NULL)))
  {
    j->cb(j->id, ticks);
    j = j->next;
  }

}

// gma950_backlight_fix_config
// file mactel/gma950_backlight.c line 280
static void gma950_backlight_fix_config(void)
{
  if(!(GMA950_BACKLIGHT_MAX >= lcd_gma950_cfg.init))
    lcd_gma950_cfg.init = GMA950_BACKLIGHT_MAX;

  if(lcd_gma950_cfg.init >= 1u && !(lcd_gma950_cfg.init >= 31u))
    lcd_gma950_cfg.init = (unsigned int)0x00;

  if(!(lcd_gma950_cfg.step >= 1u))
    lcd_gma950_cfg.step = (unsigned int)1;

  if(lcd_gma950_cfg.step >= 33u)
    lcd_gma950_cfg.step = (unsigned int)0x20;

  if(!(lcd_gma950_cfg.on_batt >= 31u) || !(GMA950_BACKLIGHT_MAX >= lcd_gma950_cfg.on_batt))
    lcd_gma950_cfg.on_batt = (unsigned int)0;

}

// gma950_backlight_get
// file mactel/gma950_backlight.c line 103
static unsigned int gma950_backlight_get(void)
{
  unsigned int return_value_readl$1;
  return_value_readl$1=readl$link1((const volatile void *)(memory$link1 + (signed long int)0x00061254));
  return return_value_readl$1 >> 1 & (unsigned int)0x7fff;
}

// gma950_backlight_get_max
// file mactel/gma950_backlight.c line 109
static unsigned int gma950_backlight_get_max(void)
{
  unsigned int return_value_readl$1;
  return_value_readl$1=readl$link1((const volatile void *)(memory$link1 + (signed long int)0x00061254));
  return return_value_readl$1 >> 17;
}

// gma950_backlight_map
// file mactel/gma950_backlight.c line 122
static signed int gma950_backlight_map(void)
{
  if(length$link1 == 0l)
  {
    logdebug("No probing done !\n");
    return -1;
  }

  else
  {
    fd$link1=open(sysfs_resource$link1, 02);
    if(!(fd$link1 >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      logmsg(4, "Cannot open %s: %s", (const void *)sysfs_resource$link1, return_value_strerror$2);
      return -1;
    }

    void *return_value_mmap$3;
    return_value_mmap$3=mmap((void *)0, (unsigned long int)length$link1, 0x1 | 0x2, 0x01, fd$link1, (signed long int)0);
    memory$link1 = (char *)return_value_mmap$3;
    if(memory$link1 == (char *)-1)
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      logmsg(3, "mmap failed: %s", return_value_strerror$5);
      close(fd$link1);
      fd$link1 = -1;
      return -1;
    }

    return 0;
  }
}

// gma950_backlight_probe
// file lcd_backlight.h line 55
signed int gma950_backlight_probe(void)
{
  struct pci_access *pacc;
  struct pci_dev *dev;
  struct stat stbuf;
  signed int card;
  signed int ret;
  pacc=pci_alloc();
  _Bool tmp_if_expr$1;
  if(pacc == ((struct pci_access *)NULL))
  {
    logmsg(3, "Could not allocate PCI structs");
    return -1;
  }

  else
  {
    pci_init(pacc);
    pci_scan_bus(pacc);
    card = 0;
    dev = pacc->devices;
    for( ; !(dev == ((struct pci_dev *)NULL)); dev = dev->next)
    {
      pci_fill_info(dev, 1);
      if((signed int)dev->vendor_id == 0x8086)
      {
        if((signed int)dev->device_id == 0x27A2)
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = (signed int)dev->device_id == 0x2A02 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
        {
          card = (signed int)dev->device_id;
          ret=snprintf(sysfs_resource$link1, sizeof(char [64l]) /*64ul*/ , "/sys/bus/pci/devices/%04x:%02x:%02x.%1x/resource0", dev->domain, dev->bus, dev->dev, dev->func);
          break;
        }

      }

    }
    pci_cleanup(pacc);
    if(dev == ((struct pci_dev *)NULL))
    {
      logdebug("Failed to detect Intel GMA950 or GMA965, aborting...\n");
      return -1;
    }

    else
      if((unsigned long int)ret >= sizeof(char [64l]) /*64ul*/ )
      {
        logmsg(3, "Could not build sysfs PCI resource path");
        return -1;
      }

      else
      {
        ret=stat$link1(sysfs_resource$link1, &stbuf);
        if(!(ret >= 0))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          char *return_value_strerror$3;
          return_value_strerror$3=strerror(*return_value___errno_location$2);
          logmsg(3, "Could not determine PCI resource length: %s", return_value_strerror$3);
          return -1;
        }

        length$link1 = stbuf.st_size;
        logdebug("GMA950/GMA965 PCI resource: [%s], length %ldK\n", (const void *)sysfs_resource$link1, length$link1 / (signed long int)1024);
        ret=gma950_backlight_map();
        if(!(ret >= 0))
        {
          logmsg(3, "Could not map GMA950/GMA965 memory");
          return -1;
        }

        else
        {
          if(card == 0x27A2)
          {
            unsigned int return_value_readl$4;
            return_value_readl$4=readl$link1((const volatile void *)(memory$link1 + (signed long int)0x00061254));
            if(!((65536u & return_value_readl$4) == 0u))
            {
              logdebug("GMA950 is in legacy backlight control mode, unsupported\n");
              gma950_backlight_unmap();
              return -1;
            }

          }

          else
            if(card == 0x2A02)
            {
              unsigned int return_value_readl$5;
              return_value_readl$5=readl$link1((const volatile void *)(memory$link1 + (signed long int)0x00061250));
              if(!((1073741824u & return_value_readl$5) == 0u))
              {
                logdebug("GMA965 is in legacy backlight control mode, unsupported\n");
                gma950_backlight_unmap();
                return -1;
              }

            }

          GMA950_BACKLIGHT_MAX=gma950_backlight_get_max();
          logdebug("Max LCD backlight value is 0x%x\n", GMA950_BACKLIGHT_MAX);
          gma950_backlight_fix_config();
          lcd_bck_info.max = (signed int)GMA950_BACKLIGHT_MAX;
          unsigned int return_value_gma950_backlight_get$6;
          return_value_gma950_backlight_get$6=gma950_backlight_get();
          lcd_bck_info.level = (signed int)return_value_gma950_backlight_get$6;
          lcd_bck_info.ac_lvl = lcd_bck_info.level;
          gma950_backlight_unmap();
          return 0;
        }
      }
  }
}

// gma950_backlight_set
// file mactel/gma950_backlight.c line 115
static void gma950_backlight_set(unsigned int value)
{
  writel$link1(GMA950_BACKLIGHT_MAX << 17 | value << 1, (volatile void *)(memory$link1 + (signed long int)0x00061254));
}

// gma950_backlight_step
// file lcd_backlight.h line 49
void gma950_backlight_step(signed int dir)
{
  signed int ret;
  unsigned int val;
  unsigned int newval = (unsigned int)0;
  ret=gma950_backlight_map();
  if(ret >= 0)
  {
    val=gma950_backlight_get();
    if(dir == 1)
    {
      newval = val + lcd_gma950_cfg.step;
      if(!(newval >= 31u))
        newval = (unsigned int)0x1f;

      if(!(GMA950_BACKLIGHT_MAX >= newval))
        newval = GMA950_BACKLIGHT_MAX;

      logdebug("LCD stepping +%d -> %d\n", lcd_gma950_cfg.step, newval);
    }

    else
      if(dir == -1)
      {
        if(!(lcd_gma950_cfg.step >= val))
          newval = val - lcd_gma950_cfg.step;

        if(!(newval >= 31u))
          newval = (unsigned int)0x00;

        logdebug("LCD stepping -%d -> %d\n", lcd_gma950_cfg.step, newval);
      }

      else
        goto __CPROVER_DUMP_L9;
    gma950_backlight_set(newval);
    gma950_backlight_unmap();
    mbpdbus_send_lcd_backlight((signed int)newval, (signed int)val, 0);
    lcd_bck_info.level = (signed int)newval;
  }


__CPROVER_DUMP_L9:
  ;
}

// gma950_backlight_toggle
// file lcd_backlight.h line 52
void gma950_backlight_toggle(signed int lvl)
{
  signed int val;
  signed int ret;
  if(!(lcd_gma950_cfg.on_batt == 0u))
  {
    ret=gma950_backlight_map();
    if(ret >= 0)
    {
      unsigned int return_value_gma950_backlight_get$1;
      return_value_gma950_backlight_get$1=gma950_backlight_get();
      val = (signed int)return_value_gma950_backlight_get$1;
      if(!(val == lcd_bck_info.level))
      {
        mbpdbus_send_lcd_backlight(val, lcd_bck_info.level, 1);
        lcd_bck_info.level = val;
      }

      if(lcd_bck_info.level == 0)
        gma950_backlight_unmap();

      else
      {
        switch(lvl)
        {
          case 0:
          {
            if(lcd_bck_info.level >= lcd_bck_info.ac_lvl)
              break;

            logdebug("LCD switching to AC level\n");
            gma950_backlight_set((unsigned int)lcd_bck_info.ac_lvl);
            mbpdbus_send_lcd_backlight(lcd_bck_info.ac_lvl, lcd_bck_info.level, 1);
            lcd_bck_info.level = lcd_bck_info.ac_lvl;
            break;
          }
          case 1:
            if(!(lcd_gma950_cfg.on_batt >= (unsigned int)lcd_bck_info.level))
            {
              logdebug("LCD switching to battery level\n");
              lcd_bck_info.ac_lvl = lcd_bck_info.level;
              gma950_backlight_set(lcd_gma950_cfg.on_batt);
              mbpdbus_send_lcd_backlight((signed int)lcd_gma950_cfg.on_batt, lcd_bck_info.level, 1);
              lcd_bck_info.level = (signed int)lcd_gma950_cfg.on_batt;
            }

        }
        gma950_backlight_unmap();
      }
    }

  }

}

// gma950_backlight_unmap
// file mactel/gma950_backlight.c line 154
static void gma950_backlight_unmap(void)
{
  munmap((void *)memory$link1, (unsigned long int)length$link1);
  memory$link1 = (char *)(void *)0;
  close(fd$link1);
  fd$link1 = -1;
}

// has_kbd_backlight
// file kbd_backlight.h line 64
static inline signed int has_kbd_backlight(void)
{
  _Bool tmp_if_expr$1;
  if((signed int)mops->type == MACHINE_MACBOOKPRO_1)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)mops->type == MACHINE_MACBOOKPRO_2 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)mops->type == MACHINE_MACBOOKPRO_3 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = (signed int)mops->type == MACHINE_MACBOOKPRO_4 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = (signed int)mops->type == MACHINE_MACBOOKPRO_5 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = (signed int)mops->type == MACHINE_MACBOOKPRO_6 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$6;
  if(tmp_if_expr$5)
    tmp_if_expr$6 = (_Bool)1;

  else
    tmp_if_expr$6 = (signed int)mops->type == MACHINE_MACBOOKPRO_7 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$7;
  if(tmp_if_expr$6)
    tmp_if_expr$7 = (_Bool)1;

  else
    tmp_if_expr$7 = (signed int)mops->type == MACHINE_MACBOOKPRO_8 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$8;
  if(tmp_if_expr$7)
    tmp_if_expr$8 = (_Bool)1;

  else
    tmp_if_expr$8 = (signed int)mops->type == MACHINE_MACBOOKPRO_9 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$9;
  if(tmp_if_expr$8)
    tmp_if_expr$9 = (_Bool)1;

  else
    tmp_if_expr$9 = (signed int)mops->type == MACHINE_MACBOOK_5 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$10;
  if(tmp_if_expr$9)
    tmp_if_expr$10 = (_Bool)1;

  else
    tmp_if_expr$10 = (signed int)mops->type == MACHINE_MACBOOKAIR_1 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$11;
  if(tmp_if_expr$10)
    tmp_if_expr$11 = (_Bool)1;

  else
    tmp_if_expr$11 = (signed int)mops->type == MACHINE_MACBOOKAIR_2 ? (_Bool)1 : (_Bool)0;
  return (signed int)tmp_if_expr$11;
}

// has_kbd_backlight$link1
// file mactel/../kbd_backlight.h line 64
static inline signed int has_kbd_backlight$link1(void)
{
  _Bool tmp_if_expr$1$link1;
  if((signed int)mops->type == MACHINE_MACBOOKPRO_1)
    tmp_if_expr$1$link1 = (_Bool)1;

  else
    tmp_if_expr$1$link1 = (signed int)mops->type == MACHINE_MACBOOKPRO_2 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2$link1;
  if(tmp_if_expr$1$link1)
    tmp_if_expr$2$link1 = (_Bool)1;

  else
    tmp_if_expr$2$link1 = (signed int)mops->type == MACHINE_MACBOOKPRO_3 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3$link1;
  if(tmp_if_expr$2$link1)
    tmp_if_expr$3$link1 = (_Bool)1;

  else
    tmp_if_expr$3$link1 = (signed int)mops->type == MACHINE_MACBOOKPRO_4 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4$link1;
  if(tmp_if_expr$3$link1)
    tmp_if_expr$4$link1 = (_Bool)1;

  else
    tmp_if_expr$4$link1 = (signed int)mops->type == MACHINE_MACBOOKPRO_5 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5$link1;
  if(tmp_if_expr$4$link1)
    tmp_if_expr$5$link1 = (_Bool)1;

  else
    tmp_if_expr$5$link1 = (signed int)mops->type == MACHINE_MACBOOKPRO_6 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$6$link1;
  if(tmp_if_expr$5$link1)
    tmp_if_expr$6$link1 = (_Bool)1;

  else
    tmp_if_expr$6$link1 = (signed int)mops->type == MACHINE_MACBOOKPRO_7 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$7$link1;
  if(tmp_if_expr$6$link1)
    tmp_if_expr$7$link1 = (_Bool)1;

  else
    tmp_if_expr$7$link1 = (signed int)mops->type == MACHINE_MACBOOKPRO_8 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$8$link1;
  if(tmp_if_expr$7$link1)
    tmp_if_expr$8$link1 = (_Bool)1;

  else
    tmp_if_expr$8$link1 = (signed int)mops->type == MACHINE_MACBOOKPRO_9 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$9$link1;
  if(tmp_if_expr$8$link1)
    tmp_if_expr$9$link1 = (_Bool)1;

  else
    tmp_if_expr$9$link1 = (signed int)mops->type == MACHINE_MACBOOK_5 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$10$link1;
  if(tmp_if_expr$9$link1)
    tmp_if_expr$10$link1 = (_Bool)1;

  else
    tmp_if_expr$10$link1 = (signed int)mops->type == MACHINE_MACBOOKAIR_1 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$11$link1;
  if(tmp_if_expr$10$link1)
    tmp_if_expr$11$link1 = (_Bool)1;

  else
    tmp_if_expr$11$link1 = (signed int)mops->type == MACHINE_MACBOOKAIR_2 ? (_Bool)1 : (_Bool)0;
  return (signed int)tmp_if_expr$11$link1;
}

// inb
// file /usr/include/x86_64-linux-gnu/sys/io.h line 43
static inline unsigned char inb(unsigned short int __port)
{
  unsigned char _v;
  asm("inb %w1,%0" : "=a"(_v) : "Nd"(__port) : );
  return _v;
}

// kbd_auto_cleanup
// file mactel/../kbd_auto.c line 171
static void kbd_auto_cleanup(void)
{
  if(kbd_timer >= 1)
    evloop_remove_timer(kbd_timer);

}

// kbd_auto_init
// file mactel/../kbd_auto.c line 161
static signed int kbd_auto_init(void)
{
  kbd_timer=evloop_add_timer(200, kbd_auto_process);
  if(!(kbd_timer >= 0))
    return -1;

  else
    return 0;
}

// kbd_auto_process
// file mactel/../kbd_auto.c line 149
static void kbd_auto_process(signed int id, unsigned long int ticks)
{
  kbd_bck_info.idle = kbd_bck_info.idle + 200;
  if(kbd_cfg.idle >= 1 && !(1000 * kbd_cfg.idle >= kbd_bck_info.idle))
    kbd_backlight_inhibit_set(1 << 3);

  kbd_backlight_ambient_check();
}

// kbd_backlight_ambient_check
// file mactel/../kbd_auto.c line 103
void kbd_backlight_ambient_check(void)
{
  signed int amb_r;
  signed int amb_l;
  ambient_get(&amb_r, &amb_l);
  if(amb_l >= 0 && amb_r >= 0)
  {
    mbpdbus_send_ambient_light(amb_l, kbd_bck_info.l_sens, amb_r, kbd_bck_info.r_sens);
    kbd_bck_info.r_sens = amb_r;
    kbd_bck_info.l_sens = amb_l;
    if(kbd_bck_info.inhibit == 0)
    {
      if(!(amb_l >= kbd_cfg.on_thresh) && !(amb_r >= kbd_cfg.on_thresh))
      {
        logdebug("Ambient light lower threshold reached\n");
        signed int return_value_kbd_backlight_get$1;
        return_value_kbd_backlight_get$1=kbd_backlight_get();
        if(return_value_kbd_backlight_get$1 >= 1)
          goto __CPROVER_DUMP_L6;

        kbd_bck_info.auto_on = 1;
        kbd_backlight_set(kbd_cfg.auto_lvl, 1);
      }

      else
        if(!(kbd_bck_info.auto_on == 0))
        {
          if(!(kbd_cfg.off_thresh >= amb_l) || !(kbd_cfg.off_thresh >= amb_r))
          {
            logdebug("Ambient light upper threshold reached\n");
            kbd_bck_info.auto_on = 0;
            kbd_backlight_set(0, 1);
          }

        }

    }

  }


__CPROVER_DUMP_L6:
  ;
}

// kbd_backlight_cleanup
// file kbd_backlight.h line 89
void kbd_backlight_cleanup(void)
{
  signed int return_value_has_kbd_backlight$1;
  return_value_has_kbd_backlight$1=has_kbd_backlight$link1();
  if(!(return_value_has_kbd_backlight$1 == 0))
    kbd_auto_cleanup();

}

// kbd_backlight_fix_config
// file kbd_backlight.h line 92
void kbd_backlight_fix_config(void)
{
  if(kbd_cfg.auto_lvl >= 256)
    kbd_cfg.auto_lvl = 255;

  if(!(kbd_cfg.step >= 1))
    kbd_cfg.step = 1;

  if(kbd_cfg.step >= 128)
    kbd_cfg.step = 255 / 2;

}

// kbd_backlight_get
// file mactel/kbd_backlight.c line 76
static signed int kbd_backlight_get(void)
{
  signed int kbd_backlight_get$$1$$fd;
  signed int ret;
  char buf[8l];
  kbd_backlight_get$$1$$fd=kbd_backlight_open(00);
  if(!(kbd_backlight_get$$1$$fd >= 0))
    return -1;

  else
  {
    memset((void *)buf, 0, (unsigned long int)8);
    signed long int return_value_read$1;
    return_value_read$1=read(kbd_backlight_get$$1$$fd, (void *)buf, (unsigned long int)8);
    ret = (signed int)return_value_read$1;
    close(kbd_backlight_get$$1$$fd);
    if(ret >= 8 || !(ret >= 1))
      return -1;

    else
    {
      ret=atoi$link1(buf);
      logdebug("KBD backlight value is %d\n", ret);
      if(ret >= 256 || !(ret >= 0))
        ret = -1;

      return ret;
    }
  }
}

// kbd_backlight_inhibit_clear
// file kbd_backlight.h line 103
void kbd_backlight_inhibit_clear(signed int mask)
{
  signed int flag = kbd_bck_info.inhibit & mask;
  kbd_bck_info.inhibit = kbd_bck_info.inhibit & ~mask;
  logdebug("KBD: inhibit clear 0x%02x -> 0x%02x\n", mask, kbd_bck_info.inhibit);
  if(!(flag == 0) && kbd_bck_info.inhibit == 0)
  {
    kbd_backlight_set(kbd_bck_info.inhibit_lvl, (mask & (1 << 1 | 1 << 3)) != 0 ? 1 : 0);
    if(!(kbd_bck_info.auto_on == 0))
    {
      kbd_bck_info.auto_on = 0;
      kbd_bck_info.inhibit_lvl = 0;
    }

  }

}

// kbd_backlight_inhibit_set
// file kbd_backlight.h line 100
void kbd_backlight_inhibit_set(signed int mask)
{
  signed int lvl;
  if(kbd_bck_info.inhibit == 0)
    kbd_bck_info.inhibit_lvl = kbd_bck_info.level;

  if(!((8 & mask) == 0))
    lvl = kbd_cfg.idle_lvl < kbd_bck_info.level ? kbd_cfg.idle_lvl : kbd_bck_info.level;

  else
    lvl = 0;
  kbd_backlight_set(lvl, (mask & (1 << 1 | 1 << 3)) != 0 ? 1 : 0);
  kbd_bck_info.inhibit = kbd_bck_info.inhibit | mask;
  logdebug("KBD: inhibit set 0x%02x -> 0x%02x\n", mask, kbd_bck_info.inhibit);
}

// kbd_backlight_inhibit_toggle
// file kbd_backlight.h line 106
void kbd_backlight_inhibit_toggle(signed int mask)
{
  if(!((kbd_bck_info.inhibit & mask) == 0))
    kbd_backlight_inhibit_clear(mask);

  else
    kbd_backlight_inhibit_set(mask);
}

// kbd_backlight_init
// file kbd_backlight.h line 86
void kbd_backlight_init(void)
{
  if(!(kbd_cfg.auto_on == 0))
    kbd_bck_info.inhibit = 0;

  else
    kbd_bck_info.inhibit = 1 << 2;
  kbd_bck_info.toggle_lvl = kbd_cfg.auto_lvl;
  kbd_bck_info.inhibit_lvl = 0;
  kbd_bck_info.auto_on = 0;
  signed int return_value_has_kbd_backlight$1;
  return_value_has_kbd_backlight$1=has_kbd_backlight$link1();
  if(return_value_has_kbd_backlight$1 == 0)
  {
    kbd_bck_info.r_sens = 0;
    kbd_bck_info.l_sens = 0;
    kbd_bck_info.level = 0;
    ambient_info.left = 0;
    ambient_info.right = 0;
    ambient_info.max = 0;
  }

  else
  {
    kbd_bck_info.level=kbd_backlight_get();
    if(!(kbd_bck_info.level >= 0))
      kbd_bck_info.level = 0;

    kbd_bck_info.max = 255;
    ambient_init(&kbd_bck_info.r_sens, &kbd_bck_info.l_sens);
    kbd_auto_init();
  }
}

// kbd_backlight_open
// file mactel/kbd_backlight.c line 46
static signed int kbd_backlight_open(signed int flags)
{
  char *kbdbck_node[2l] = { "/sys/class/leds/smc::kbd_backlight/brightness",
    "/sys/class/leds/smc:kbd_backlight/brightness" };
  signed int kbd_backlight_open$$1$$fd;
  signed int i = 0;
  for( ; !((unsigned long int)i >= 2ul); i = i + 1)
  {
    logdebug("Trying %s\n", kbdbck_node[(signed long int)i]);
    kbd_backlight_open$$1$$fd=open(kbdbck_node[(signed long int)i], flags);
    if(kbd_backlight_open$$1$$fd >= 0)
      return kbd_backlight_open$$1$$fd;

    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(!(*return_value___errno_location$1 == 2))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      logmsg(4, "Could not open %s: %s", kbdbck_node[(signed long int)i], return_value_strerror$3);
      return -1;
    }

  }
  return -1;
}

// kbd_backlight_set
// file mactel/kbd_backlight.c line 106
static void kbd_backlight_set(signed int val, signed int who)
{
  signed int curval;
  signed int i;
  float fadeval;
  float step;
  struct timespec fade_step;
  signed int kbd_backlight_set$$1$$fd;
  struct _IO_FILE *fp;
  if((-5 & kbd_bck_info.inhibit) == 0)
  {
    curval=kbd_backlight_get();
    if(!(val == curval))
    {
      if(!(val >= 256) && val >= 0)
      {
        if(who == 1)
        {
          fade_step.tv_sec = (signed long int)0;
          fade_step.tv_nsec = (signed long int)((350 / 20) * 1000000);
          fadeval = (float)curval;
          step = (float)(val - curval) / (float)20;
          i = 0;
          for( ; !(i >= 20); i = i + 1)
          {
            fadeval = fadeval + step;
            kbd_backlight_set$$1$$fd=kbd_backlight_open(01);
            if(kbd_backlight_set$$1$$fd >= 0)
            {
              fp=fdopen(kbd_backlight_set$$1$$fd, "a");
              if(fp == ((struct _IO_FILE *)NULL))
              {
                signed int *return_value___errno_location$1;
                return_value___errno_location$1=__errno_location();
                char *return_value_strerror$2;
                return_value_strerror$2=strerror(*return_value___errno_location$1);
                logmsg(4, "Could not fdopen backlight fd: %s", return_value_strerror$2);
                close(kbd_backlight_set$$1$$fd);
                goto __CPROVER_DUMP_L6;
              }

              fprintf(fp, "%d", (signed int)fadeval);
              fclose(fp);
              logdebug("KBD backlight value faded to %d\n", (signed int)fadeval);
              nanosleep(&fade_step, (struct timespec *)(void *)0);
            }


          __CPROVER_DUMP_L6:
            ;
          }
        }

        kbd_backlight_set$$1$$fd=kbd_backlight_open(01);
        if(kbd_backlight_set$$1$$fd >= 0)
        {
          fp=fdopen(kbd_backlight_set$$1$$fd, "a");
          if(fp == ((struct _IO_FILE *)NULL))
          {
            signed int *return_value___errno_location$3;
            return_value___errno_location$3=__errno_location();
            char *return_value_strerror$4;
            return_value_strerror$4=strerror(*return_value___errno_location$3);
            logmsg(4, "Could not fdopen backlight fd %d: %s", kbd_backlight_set$$1$$fd, return_value_strerror$4);
            close(kbd_backlight_set$$1$$fd);
            goto __CPROVER_DUMP_L10;
          }

          fprintf(fp, "%d", val);
          fclose(fp);
          logdebug("KBD backlight value set to %d\n", val);
          mbpdbus_send_kbd_backlight(val, curval, who);
          kbd_bck_info.level = val;
        }

      }

    }

  }


__CPROVER_DUMP_L10:
  ;
}

// kbd_backlight_step
// file kbd_backlight.h line 83
void kbd_backlight_step(signed int dir)
{
  signed int val;
  signed int newval;
  if((-5 & kbd_bck_info.inhibit) == 0)
  {
    val=kbd_backlight_get();
    if(val >= 0)
    {
      if(dir == 1)
      {
        newval = val + kbd_cfg.step;
        if(newval >= 256)
          newval = 255;

        logdebug("KBD stepping +%d -> %d\n", kbd_cfg.step, newval);
      }

      else
        if(dir == -1)
        {
          newval = val - kbd_cfg.step;
          if(!(newval >= 0))
            newval = 0;

          logdebug("KBD stepping -%d -> %d\n", kbd_cfg.step, newval);
        }

        else
          goto __CPROVER_DUMP_L8;
      kbd_backlight_set(newval, 0);
    }

  }


__CPROVER_DUMP_L8:
  ;
}

// kbd_backlight_toggle
// file kbd_backlight.h line 97
void kbd_backlight_toggle(void)
{
  signed int curval;
  curval=kbd_backlight_get();
  if(!(curval == 0))
  {
    kbd_bck_info.toggle_lvl = curval;
    kbd_backlight_set(0, 0);
  }

  else
  {
    if(!(kbd_bck_info.toggle_lvl >= kbd_cfg.auto_lvl))
      kbd_bck_info.toggle_lvl = kbd_cfg.auto_lvl;

    kbd_backlight_set(kbd_bck_info.toggle_lvl, 0);
  }
}

// kbd_set_fnmode
// file pommed.c line 474
void kbd_set_fnmode(void)
{
  char *fnmode_node[3l] = { "/sys/module/hid_apple/parameters/fnmode",
    "/sys/module/hid/parameters/pb_fnmode", "/sys/module/usbhid/parameters/pb_fnmode" };
  struct _IO_FILE *fp;
  signed int i;
  if(general_cfg.fnmode >= 3 || !(general_cfg.fnmode >= 1))
    general_cfg.fnmode = 1;

  i = 0;
  for( ; !((unsigned long int)i >= 3ul); i = i + 1)
  {
    logdebug("Trying %s\n", fnmode_node[(signed long int)i]);
    fp=fopen(fnmode_node[(signed long int)i], "a");
    if(!(fp == ((struct _IO_FILE *)NULL)))
      break;

    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(!(*return_value___errno_location$1 == 2))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      logmsg(6, "Could not open %s: %s", fnmode_node[(signed long int)i], return_value_strerror$3);
      goto __CPROVER_DUMP_L6;
    }

  }
  if(fp == ((struct _IO_FILE *)NULL))
    logmsg(6, "Could not set fnmode: no sysfs node found!");

  else
  {
    fprintf(fp, "%d", general_cfg.fnmode);
    fclose(fp);
  }

__CPROVER_DUMP_L6:
  ;
}

// logdebug
// file pommed.c line 460
void logdebug(char *fmt, ...)
{
  void **ap = (void **)&fmt;
  if(!(debug == 0))
    vfprintf(stderr, fmt, ap);

  ap = ((void **)NULL);
}

// logmsg
// file pommed.c line 421
void logmsg(signed int level, char *fmt, ...)
{
  void **ap;
  struct _IO_FILE *where = stdout;
  ap = (void **)&fmt;
  if(!(console == 0))
  {
    switch(level)
    {
      case 6:
      {
        fprintf(where, "I: ");
        break;
      }
      case 4:
      {
        fprintf(where, "W: ");
        break;
      }
      case 3:
      {
        where = stderr;
        fprintf(where, "E: ");
      }
    }
    vfprintf(where, fmt, ap);
    fprintf(where, "\n");
  }

  else
    vsyslog(level | 3 << 3, fmt, ap);
  ap = ((void **)NULL);
}

// main
// file pommed.c line 837
signed int main(signed int argc, char **argv)
{
  signed int ret;
  signed int c;
  struct _IO_FILE *pidfile;
  struct utsname sysinfo;
  enum anonymous$3 machine;
  do
  {
    c=getopt(argc, argv, "fdv");
    if(c == -1)
      break;

    switch(c)
    {
      case 102:
      {
        console = 1;
        break;
      }
      case 100:
      {
        debug = 1;
        console = 1;
        break;
      }
      case 118:
      {
        printf("pommed v1.39 Apple laptops hotkeys handler\n");
        printf("Copyright (C) 2006-2011 Julien BLACHE <jb@jblache.org>\n");
        exit(0);
        break;
      }
      default:
      {
        usage();
        exit(1);
      }
    }
  }
  while((_Bool)1);
  unsigned int return_value_geteuid$1;
  return_value_geteuid$1=geteuid();
  if(!(return_value_geteuid$1 == 0u))
  {
    logmsg(3, "pommed needs root privileges to operate");
    exit(1);
  }

  if(console == 0)
    openlog("pommed", 0x01, 3 << 3);

  logmsg(6, "pommed v1.39 Apple laptops hotkeys handler");
  logmsg(6, "Copyright (C) 2006-2011 Julien BLACHE <jb@jblache.org>");
  ret=config_load();
  if(!(ret >= 0))
    exit(1);

  machine=check_machine_dmi();
  switch((signed int)machine)
  {
    case MACHINE_MAC_UNKNOWN:
    {
      logmsg(3, "Unknown Apple machine");
      exit(1);
      break;
    }
    case MACHINE_UNKNOWN:
    {
      logmsg(3, "Unknown non-Apple machine");
      exit(1);
      break;
    }
    case MACHINE_ERROR:
    {
      exit(1);
      break;
    }
    default:
      if(!((signed int)machine >= MACHINE_LAST))
        mops = &mb_mops[(signed long int)machine];

  }
  if(!(mops->type == machine))
  {
    logmsg(3, "machine_ops mismatch: expected %d, found %d", machine, mops->type);
    exit(1);
  }

  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  if(!(debug == 0))
  {
    ret=uname(&sysinfo);
    if(!(ret >= 0))
    {
      return_value___errno_location$2=__errno_location();
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      logmsg(3, "uname() failed: %s", return_value_strerror$3);
    }

    else
      logdebug("System: %s %s %s\n", (const void *)sysinfo.sysname, (const void *)sysinfo.release, (const void *)sysinfo.machine);
  }

  ret=evloop_init();
  if(!(ret >= 0))
  {
    logmsg(3, "Event loop initialization failed");
    exit(1);
  }

  ret=mops->lcd_backlight_probe();
  if(!(ret >= 0))
  {
    logmsg(3, "LCD backlight probe failed, check debug output");
    exit(1);
  }

  ret=evdev_init();
  if(!(ret >= 1))
  {
    logmsg(3, "No suitable event devices found");
    exit(1);
  }

  kbd_backlight_init();
  ret=audio_init();
  if(!(ret >= 0))
    logmsg(4, "Audio initialization failed, audio support disabled");

  ret=mbpdbus_init();
  if(!(ret >= 0))
    logmsg(4, "Could not connect to DBus system bus");

  power_init();
  if(console == 0)
  {
    signed int return_value_daemon$6;
    return_value_daemon$6=daemon(0, 0);
    if(!(return_value_daemon$6 == 0))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      logmsg(3, "daemon() failed: %s", return_value_strerror$5);
      evdev_cleanup();
      exit(1);
    }

  }

  pidfile=fopen("/var/run/pommed.pid", "w");
  if(pidfile == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    char *return_value_strerror$8;
    return_value_strerror$8=strerror(*return_value___errno_location$7);
    logmsg(4, "Could not open pidfile %s: %s", (const void *)"/var/run/pommed.pid", return_value_strerror$8);
    evdev_cleanup();
    exit(1);
  }

  signed int return_value_getpid$9;
  return_value_getpid$9=getpid();
  fprintf(pidfile, "%d\n", return_value_getpid$9);
  fclose(pidfile);
  beep_init();
  signal(2, sig_int_term_handler);
  signal(15, sig_int_term_handler);
  ret=evloop_iteration();
  evdev_cleanup();
  beep_cleanup();
  mbpdbus_cleanup();
  kbd_backlight_cleanup();
  power_cleanup();
  evloop_cleanup();
  config_cleanup();
  logmsg(6, "Exiting");
  if(console == 0)
    closelog();

  unlink("/var/run/pommed.pid");
  return 0;
}

// mbp_sysfs_backlight_probe
// file lcd_backlight.h line 102
signed int mbp_sysfs_backlight_probe(void)
{
  signed int drv;
  signed int ret;
  drv = 0 + 1;
  for( ; !(drv >= 7); drv = drv + 1)
  {
    ret=sysfs_backlight_probe(drv);
    if(ret == 0)
      return 0;

  }
  if((signed int)mops->type == MACHINE_MACBOOKPRO_3 || (signed int)mops->type == MACHINE_MACBOOKPRO_4 || (signed int)mops->type == MACHINE_MACBOOKPRO_5 || (signed int)mops->type == MACHINE_MACBOOKPRO_6 || (signed int)mops->type == MACHINE_MACBOOK_5 || (signed int)mops->type == MACHINE_MACBOOK_6 || (signed int)mops->type == MACHINE_MACBOOKAIR_2 || (signed int)mops->type == MACHINE_MACBOOKAIR_3)
  {
    logmsg(6, "sysfs backlight probe failed, falling back to nv8600mgt");
    ret=nv8600mgt_backlight_probe();
    if(ret == 0)
    {
      mops->lcd_backlight_step = nv8600mgt_backlight_step;
      mops->lcd_backlight_toggle = nv8600mgt_backlight_toggle;
    }

    return ret;
  }

  logmsg(3, "sysfs backlight probe failed, no fallback for this machine");
  return -1;
  return -1;
}

// mbpdbus_add_watch
// file dbus.c line 951
static unsigned int mbpdbus_add_watch(struct DBusWatch *watch, void *data)
{
  unsigned int events;
  signed int mbpdbus_add_watch$$1$$fd;
  signed int ret;
  struct pommed_watch *w;
  logdebug("DBus add watch\n");
  mbpdbus_add_watch$$1$$fd=dbus_watch_get_unix_fd(watch);
  events = (unsigned int)0;
  w = watches;
  for( ; !(w == ((struct pommed_watch *)NULL)); w = w->next)
    if(!(w->enabled == 0))
    {
      if(w->fd == mbpdbus_add_watch$$1$$fd)
        events = events | w->events;

    }

  if(!(events == 0u))
  {
    ret=evloop_remove(mbpdbus_add_watch$$1$$fd);
    if(ret >= 0)
      goto __CPROVER_DUMP_L4;

    logmsg(3, "Could not remove previous watch on same fd");
    return (unsigned int)0;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct pommed_watch) /*32ul*/ );
    w = (struct pommed_watch *)return_value_malloc$1;
    if(w == ((struct pommed_watch *)NULL))
    {
      logmsg(3, "Could not allocate memory for a new DBus watch");
      return (unsigned int)0;
    }

    else
    {
      w->watch = watch;
      w->fd = mbpdbus_add_watch$$1$$fd;
      w->enabled = 1;
      unsigned int return_value_dbus_watch_get_flags$2;
      return_value_dbus_watch_get_flags$2=dbus_watch_get_flags(watch);
      w->events=dbus_to_epoll((signed int)return_value_dbus_watch_get_flags$2);
      w->events = w->events | (unsigned int)(8 | 16);
      events = events | w->events;
      ret=evloop_add(mbpdbus_add_watch$$1$$fd, events, mbpdbus_process_watch);
      if(!(ret >= 0))
      {
        free((void *)w);
        return (unsigned int)0;
      }

      else
      {
        w->next = watches;
        watches = w;
        return (unsigned int)1;
      }
    }
  }
}

// mbpdbus_cleanup
// file dbus.h line 37
void mbpdbus_cleanup(void)
{
  if(dbus_timer >= 1)
    evloop_remove_timer(dbus_timer);

  if(!(conn == ((struct DBusConnection *)NULL)))
  {
    dbus_error_free(&err);
    dbus_connection_unref(conn);
    conn = (struct DBusConnection *)(void *)0;
  }

}

// mbpdbus_data_free
// file dbus.c line 1103
static void mbpdbus_data_free(void *data)
{
  ;
}

// mbpdbus_init
// file dbus.h line 34
signed int mbpdbus_init(void)
{
  signed int ret;
  watches = (struct pommed_watch *)(void *)0;
  dbus_timer = -1;
  dbus_error_init(&err);
  conn=dbus_bus_get((enum anonymous$2)DBUS_BUS_SYSTEM, &err);
  unsigned int return_value_dbus_error_is_set$1;
  return_value_dbus_error_is_set$1=dbus_error_is_set(&err);
  unsigned int return_value_dbus_error_is_set$2;
  unsigned int return_value_dbus_connection_set_watch_functions$3;
  if(!(return_value_dbus_error_is_set$1 == 0u))
  {
    logmsg(3, "DBus system bus connection failed: %s", err.message);
    dbus_error_free(&err);
    conn = (struct DBusConnection *)(void *)0;
  }

  else
  {
    dbus_connection_set_exit_on_disconnect(conn, (unsigned int)0);
    ret=dbus_bus_request_name(conn, "org.pommed", (unsigned int)0, &err);
    return_value_dbus_error_is_set$2=dbus_error_is_set(&err);
    if(!(return_value_dbus_error_is_set$2 == 0u))
    {
      logmsg(3, "Failed to request DBus name: %s", err.message);
      mbpdbus_cleanup();
    }

    else
      if(!(ret == 1))
      {
        logmsg(3, "Not primary DBus name owner");
        mbpdbus_cleanup();
      }

      else
      {
        return_value_dbus_connection_set_watch_functions$3=dbus_connection_set_watch_functions(conn, mbpdbus_add_watch, mbpdbus_remove_watch, mbpdbus_toggle_watch, (void *)0, mbpdbus_data_free);
        ret = (signed int)return_value_dbus_connection_set_watch_functions$3;
        if(ret == 0)
          mbpdbus_cleanup();

        else
        {
          dbus_connection_add_filter(conn, mbpdbus_process_requests, (void *)0, (void (*)(void *))(void *)0);
          return 0;
        }
      }
  }

init_reconnect:
  ;
  if(dbus_timer >= 1)
    return -1;

  else
  {
    dbus_timer=evloop_add_timer(200, mbpdbus_reconnect);
    if(!(dbus_timer >= 0))
    {
      logmsg(3, "Could not set up timer for DBus reconnection");
      return -1;
    }

    else
      return 0;
  }
}

// mbpdbus_process_requests
// file dbus.c line 805
static enum anonymous mbpdbus_process_requests(struct DBusConnection *lconn, struct DBusMessage *msg, void *data)
{
  unsigned int return_value_dbus_message_is_method_call$15;
  return_value_dbus_message_is_method_call$15=dbus_message_is_method_call(msg, "org.pommed.lcdBacklight", "getLevel");
  unsigned int return_value_dbus_message_is_method_call$14;
  unsigned int return_value_dbus_message_is_method_call$13;
  unsigned int return_value_dbus_message_is_method_call$12;
  unsigned int return_value_dbus_message_is_method_call$11;
  unsigned int return_value_dbus_message_is_method_call$10;
  unsigned int return_value_dbus_message_is_method_call$9;
  unsigned int return_value_dbus_message_is_method_call$8;
  unsigned int return_value_dbus_message_is_method_call$7;
  unsigned int return_value_dbus_message_is_method_call$6;
  unsigned int return_value_dbus_message_is_method_call$5;
  unsigned int return_value_dbus_message_is_method_call$4;
  unsigned int return_value_dbus_message_is_method_call$3;
  unsigned int return_value_dbus_message_is_method_call$2;
  unsigned int return_value_dbus_message_is_signal$1;
  if(!(return_value_dbus_message_is_method_call$15 == 0u))
    process_lcd_getlevel_call(msg);

  else
  {
    return_value_dbus_message_is_method_call$14=dbus_message_is_method_call(msg, "org.pommed.kbdBacklight", "getLevel");
    if(!(return_value_dbus_message_is_method_call$14 == 0u))
      process_kbd_getlevel_call(msg);

    else
    {
      return_value_dbus_message_is_method_call$13=dbus_message_is_method_call(msg, "org.pommed.ambient", "getLevel");
      if(!(return_value_dbus_message_is_method_call$13 == 0u))
        process_ambient_getlevel_call(msg);

      else
      {
        return_value_dbus_message_is_method_call$12=dbus_message_is_method_call(msg, "org.pommed.audio", "getVolume");
        if(!(return_value_dbus_message_is_method_call$12 == 0u))
          process_audio_getvolume_call(msg);

        else
        {
          return_value_dbus_message_is_method_call$11=dbus_message_is_method_call(msg, "org.pommed.audio", "getMute");
          if(!(return_value_dbus_message_is_method_call$11 == 0u))
            process_audio_getmute_call(msg);

          else
          {
            return_value_dbus_message_is_method_call$10=dbus_message_is_method_call(msg, "org.pommed.video", "getVTState");
            if(!(return_value_dbus_message_is_method_call$10 == 0u))
              process_video_getvtstate_call(msg);

            else
            {
              return_value_dbus_message_is_method_call$9=dbus_message_is_method_call(msg, "org.pommed.lcdBacklight", "levelUp");
              if(!(return_value_dbus_message_is_method_call$9 == 0u))
                process_lcd_backlight_step_call(msg, 1);

              else
              {
                return_value_dbus_message_is_method_call$8=dbus_message_is_method_call(msg, "org.pommed.lcdBacklight", "levelDown");
                if(!(return_value_dbus_message_is_method_call$8 == 0u))
                  process_lcd_backlight_step_call(msg, -1);

                else
                {
                  return_value_dbus_message_is_method_call$7=dbus_message_is_method_call(msg, "org.pommed.kbdBacklight", "inhibit");
                  if(!(return_value_dbus_message_is_method_call$7 == 0u))
                    process_kbd_backlight_inhibit_call(msg, 1);

                  else
                  {
                    return_value_dbus_message_is_method_call$6=dbus_message_is_method_call(msg, "org.pommed.kbdBacklight", "disinhibit");
                    if(!(return_value_dbus_message_is_method_call$6 == 0u))
                      process_kbd_backlight_inhibit_call(msg, 0);

                    else
                    {
                      return_value_dbus_message_is_method_call$5=dbus_message_is_method_call(msg, "org.pommed.audio", "volumeUp");
                      if(!(return_value_dbus_message_is_method_call$5 == 0u))
                        process_audio_volume_step_call(msg, 1);

                      else
                      {
                        return_value_dbus_message_is_method_call$4=dbus_message_is_method_call(msg, "org.pommed.audio", "volumeDown");
                        if(!(return_value_dbus_message_is_method_call$4 == 0u))
                          process_audio_volume_step_call(msg, -1);

                        else
                        {
                          return_value_dbus_message_is_method_call$3=dbus_message_is_method_call(msg, "org.pommed.audio", "toggleMute");
                          if(!(return_value_dbus_message_is_method_call$3 == 0u))
                            process_audio_toggle_mute_call(msg);

                          else
                          {
                            return_value_dbus_message_is_method_call$2=dbus_message_is_method_call(msg, "org.pommed.cd", "eject");
                            if(!(return_value_dbus_message_is_method_call$2 == 0u))
                              process_cd_eject_call(msg);

                            else
                            {
                              return_value_dbus_message_is_signal$1=dbus_message_is_signal(msg, "org.freedesktop.DBus.Local", "Disconnected");
                              if(!(return_value_dbus_message_is_signal$1 == 0u))
                              {
                                logmsg(6, "DBus disconnected");
                                mbpdbus_cleanup();
                                dbus_timer=evloop_add_timer(200, mbpdbus_reconnect);
                                if(!(dbus_timer >= 0))
                                  logmsg(4, "Could not set up timer for DBus reconnection");

                              }

                              else
                                return (enum anonymous)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (enum anonymous)DBUS_HANDLER_RESULT_HANDLED;
}

// mbpdbus_process_watch
// file dbus.c line 908
static void mbpdbus_process_watch(signed int fd, unsigned int events)
{
  signed int flags;
  unsigned int wanted;
  enum anonymous$1 ds;
  struct pommed_watch *w;
  logdebug("DBus process watch\n");
  w = watches;
  for( ; !(w == ((struct pommed_watch *)NULL)); w = w->next)
    if(!(w->enabled == 0))
    {
      if(w->fd == fd)
      {
        wanted = events & w->events;
        if(!(wanted == 0u))
        {
          flags=epoll_to_dbus(wanted);
          dbus_watch_handle(w->watch, (unsigned int)flags);
          do
            ds=dbus_connection_dispatch(conn);
          while((signed int)ds == DBUS_DISPATCH_DATA_REMAINS);
          if(!((24u & events) == 0u))
            break;

        }

      }

    }

}

// mbpdbus_reconnect
// file dbus.c line 792
static void mbpdbus_reconnect(signed int id, unsigned long int ticks)
{
  signed int ret;
  ret=mbpdbus_init();
  if(ret == 0)
  {
    evloop_remove_timer(id);
    dbus_timer = -1;
  }

}

// mbpdbus_remove_watch
// file dbus.c line 1013
static void mbpdbus_remove_watch(struct DBusWatch *watch, void *data)
{
  unsigned int events;
  signed int mbpdbus_remove_watch$$1$$fd;
  signed int ret;
  struct pommed_watch *w;
  struct pommed_watch *p;
  logdebug("DBus remove watch %p\n", watch);
  mbpdbus_remove_watch$$1$$fd=dbus_watch_get_unix_fd(watch);
  events = (unsigned int)0;
  p = (struct pommed_watch *)(void *)0;
  w = watches;
  for( ; !(w == ((struct pommed_watch *)NULL)); w = w->next)
  {
    if(w->watch == watch)
    {
      if(!(p == ((struct pommed_watch *)NULL)))
        p->next = w->next;

      else
        watches = w->next;
      free((void *)w);
    }

    else
      if(!(w->enabled == 0))
      {
        if(w->fd == mbpdbus_remove_watch$$1$$fd)
          events = events | w->events;

      }

    p = w;
  }
  ret=evloop_remove(mbpdbus_remove_watch$$1$$fd);
  if(ret >= 0)
  {
    if(!(events == 0u))
    {
      ret=evloop_add(mbpdbus_remove_watch$$1$$fd, events, mbpdbus_process_watch);
      if(!(ret >= 0))
        logmsg(4, "Could not re-add watch");

    }

  }

}

// mbpdbus_send_ambient_light
// file dbus.c line 153
void mbpdbus_send_ambient_light(signed int l, signed int l_prev, signed int r, signed int r_prev)
{
  struct DBusMessage *msg;
  signed int ret;
  if(!(conn == ((struct DBusConnection *)NULL)))
  {
    logdebug("DBus ambientLight: %d %d %d %d\n", l, l_prev, r, r_prev);
    msg=dbus_message_new_signal("/org/pommed/notify/ambientLight", "org.pommed.signal.ambientLight", "ambientLight");
    if(msg == ((struct DBusMessage *)NULL))
      logdebug("Failed to create DBus message\n");

    else
    {
      unsigned int return_value_dbus_message_append_args$1;
      return_value_dbus_message_append_args$1=dbus_message_append_args(msg, (signed int)117, &l, (signed int)117, &l_prev, (signed int)117, &r, (signed int)117, &r_prev, (signed int)117, &ambient_info.max, (signed int)0);
      ret = (signed int)return_value_dbus_message_append_args$1;
      if(ret == 0)
      {
        logdebug("Failed to add arguments\n");
        dbus_message_unref(msg);
      }

      else
      {
        unsigned int return_value_dbus_connection_send$2;
        return_value_dbus_connection_send$2=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
        ret = (signed int)return_value_dbus_connection_send$2;
        if(ret == 0)
        {
          logdebug("Could not send kbdBacklight signal\n");
          dbus_message_unref(msg);
        }

        else
        {
          dbus_connection_flush(conn);
          dbus_message_unref(msg);
        }
      }
    }
  }

}

// mbpdbus_send_audio_mute
// file dbus.h line 24
void mbpdbus_send_audio_mute(signed int mute)
{
  struct DBusMessage *msg;
  signed int ret;
  if(!(conn == ((struct DBusConnection *)NULL)))
  {
    logdebug("DBus audioMute: %d\n", mute);
    msg=dbus_message_new_signal("/org/pommed/notify/audioMute", "org.pommed.signal.audioMute", "audioMute");
    if(msg == ((struct DBusMessage *)NULL))
      logdebug("Failed to create DBus message\n");

    else
    {
      unsigned int return_value_dbus_message_append_args$1;
      return_value_dbus_message_append_args$1=dbus_message_append_args(msg, (signed int)98, &mute, (signed int)0);
      ret = (signed int)return_value_dbus_message_append_args$1;
      if(ret == 0)
      {
        logdebug("Failed to add arguments\n");
        dbus_message_unref(msg);
      }

      else
      {
        unsigned int return_value_dbus_connection_send$2;
        return_value_dbus_connection_send$2=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
        ret = (signed int)return_value_dbus_connection_send$2;
        if(ret == 0)
        {
          logdebug("Could not send audioMute signal\n");
          dbus_message_unref(msg);
        }

        else
        {
          dbus_connection_flush(conn);
          dbus_message_unref(msg);
        }
      }
    }
  }

}

// mbpdbus_send_audio_volume
// file dbus.h line 21
void mbpdbus_send_audio_volume(signed int cur, signed int prev)
{
  struct DBusMessage *msg;
  signed int ret;
  if(!(conn == ((struct DBusConnection *)NULL)))
  {
    logdebug("DBus audioVolume: %d %d\n", cur, prev);
    msg=dbus_message_new_signal("/org/pommed/notify/audioVolume", "org.pommed.signal.audioVolume", "audioVolume");
    if(msg == ((struct DBusMessage *)NULL))
      logdebug("Failed to create DBus message\n");

    else
    {
      unsigned int return_value_dbus_message_append_args$1;
      return_value_dbus_message_append_args$1=dbus_message_append_args(msg, (signed int)117, &cur, (signed int)117, &prev, (signed int)117, &audio_info.max, (signed int)0);
      ret = (signed int)return_value_dbus_message_append_args$1;
      if(ret == 0)
      {
        logdebug("Failed to add arguments\n");
        dbus_message_unref(msg);
      }

      else
      {
        unsigned int return_value_dbus_connection_send$2;
        return_value_dbus_connection_send$2=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
        ret = (signed int)return_value_dbus_connection_send$2;
        if(ret == 0)
        {
          logdebug("Could not send audioVolume signal\n");
          dbus_message_unref(msg);
        }

        else
        {
          dbus_connection_flush(conn);
          dbus_message_unref(msg);
        }
      }
    }
  }

}

// mbpdbus_send_cd_eject
// file dbus.h line 27
void mbpdbus_send_cd_eject(void)
{
  struct DBusMessage *msg;
  signed int ret;
  if(!(conn == ((struct DBusConnection *)NULL)))
  {
    logdebug("DBus CD eject\n");
    msg=dbus_message_new_signal("/org/pommed/notify/cdEject", "org.pommed.signal.cdEject", "cdEject");
    if(msg == ((struct DBusMessage *)NULL))
      logdebug("Failed to create DBus message\n");

    else
    {
      unsigned int return_value_dbus_connection_send$1;
      return_value_dbus_connection_send$1=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
      ret = (signed int)return_value_dbus_connection_send$1;
      if(ret == 0)
      {
        logdebug("Could not send cdEject signal\n");
        dbus_message_unref(msg);
      }

      else
      {
        dbus_connection_flush(conn);
        dbus_message_unref(msg);
      }
    }
  }

}

// mbpdbus_send_kbd_backlight
// file dbus.c line 101
void mbpdbus_send_kbd_backlight(signed int cur, signed int prev, signed int who)
{
  struct DBusMessage *msg;
  signed int ret;
  if(!(conn == ((struct DBusConnection *)NULL)))
  {
    logdebug("DBus kbdBacklight: %d %d\n", cur, prev);
    msg=dbus_message_new_signal("/org/pommed/notify/kbdBacklight", "org.pommed.signal.kbdBacklight", "kbdBacklight");
    if(msg == ((struct DBusMessage *)NULL))
      logdebug("Failed to create DBus message\n");

    else
    {
      unsigned int return_value_dbus_message_append_args$1;
      return_value_dbus_message_append_args$1=dbus_message_append_args(msg, (signed int)117, &cur, (signed int)117, &prev, (signed int)117, &kbd_bck_info.max, (signed int)117, &who, (signed int)0);
      ret = (signed int)return_value_dbus_message_append_args$1;
      if(ret == 0)
      {
        logdebug("Failed to add arguments\n");
        dbus_message_unref(msg);
      }

      else
      {
        unsigned int return_value_dbus_connection_send$2;
        return_value_dbus_connection_send$2=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
        ret = (signed int)return_value_dbus_connection_send$2;
        if(ret == 0)
        {
          logdebug("Could not send kbdBacklight signal\n");
          dbus_message_unref(msg);
        }

        else
        {
          dbus_connection_flush(conn);
          dbus_message_unref(msg);
        }
      }
    }
  }

}

// mbpdbus_send_lcd_backlight
// file dbus.c line 49
void mbpdbus_send_lcd_backlight(signed int cur, signed int prev, signed int who)
{
  struct DBusMessage *msg;
  signed int ret;
  if(!(conn == ((struct DBusConnection *)NULL)))
  {
    logdebug("DBus lcdBacklight: %d %d\n", cur, prev);
    msg=dbus_message_new_signal("/org/pommed/notify/lcdBacklight", "org.pommed.signal.lcdBacklight", "lcdBacklight");
    if(msg == ((struct DBusMessage *)NULL))
      logdebug("Failed to create DBus message\n");

    else
    {
      unsigned int return_value_dbus_message_append_args$1;
      return_value_dbus_message_append_args$1=dbus_message_append_args(msg, (signed int)117, &cur, (signed int)117, &prev, (signed int)117, &lcd_bck_info.max, (signed int)117, &who, (signed int)0);
      ret = (signed int)return_value_dbus_message_append_args$1;
      if(ret == 0)
      {
        logdebug("Failed to add arguments\n");
        dbus_message_unref(msg);
      }

      else
      {
        unsigned int return_value_dbus_connection_send$2;
        return_value_dbus_connection_send$2=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
        ret = (signed int)return_value_dbus_connection_send$2;
        if(ret == 0)
        {
          logdebug("Could not send lcdBacklight signal\n");
          dbus_message_unref(msg);
        }

        else
        {
          dbus_connection_flush(conn);
          dbus_message_unref(msg);
        }
      }
    }
  }

}

// mbpdbus_send_video_switch
// file dbus.c line 343
void mbpdbus_send_video_switch(void)
{
  struct DBusMessage *msg;
  signed int ret;
  if(!(conn == ((struct DBusConnection *)NULL)))
  {
    logdebug("DBus video switch\n");
    msg=dbus_message_new_signal("/org/pommed/notify/videoSwitch", "org.pommed.signal.videoSwitch", "videoSwitch");
    if(msg == ((struct DBusMessage *)NULL))
      logdebug("Failed to create DBus message\n");

    else
    {
      unsigned int return_value_dbus_connection_send$1;
      return_value_dbus_connection_send$1=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
      ret = (signed int)return_value_dbus_connection_send$1;
      if(ret == 0)
      {
        logdebug("Could not send videoSwitch signal\n");
        dbus_message_unref(msg);
      }

      else
      {
        dbus_connection_flush(conn);
        dbus_message_unref(msg);
      }
    }
  }

}

// mbpdbus_toggle_watch
// file dbus.c line 1058
static void mbpdbus_toggle_watch(struct DBusWatch *watch, void *data)
{
  unsigned int events;
  signed int mbpdbus_toggle_watch$$1$$fd;
  signed int ret;
  struct pommed_watch *w;
  logdebug("DBus toggle watch\n");
  mbpdbus_toggle_watch$$1$$fd=dbus_watch_get_unix_fd(watch);
  events = (unsigned int)0;
  w = watches;
  for( ; !(w == ((struct pommed_watch *)NULL)); w = w->next)
  {
    if(w->watch == watch)
    {
      unsigned int return_value_dbus_watch_get_enabled$1;
      return_value_dbus_watch_get_enabled$1=dbus_watch_get_enabled(watch);
      if(return_value_dbus_watch_get_enabled$1 == 0u)
        w->enabled = 0;

      else
      {
        w->enabled = 1;
        events = events | w->events;
      }
      goto __CPROVER_DUMP_L5;
    }

    if(!(w->enabled == 0))
    {
      if(w->fd == mbpdbus_toggle_watch$$1$$fd)
        events = events | events;

    }


  __CPROVER_DUMP_L5:
    ;
  }
  ret=evloop_remove(mbpdbus_toggle_watch$$1$$fd);
  if(ret >= 0)
  {
    if(!(events == 0u))
    {
      ret=evloop_add(mbpdbus_toggle_watch$$1$$fd, events, mbpdbus_process_watch);
      if(!(ret >= 0))
        logmsg(4, "Could not re-add watch");

    }

  }

}

// nv8600mgt_backlight_fix_config
// file lcd_backlight.h line 72
void nv8600mgt_backlight_fix_config(void)
{
  if(!(lcd_nv8600mgt_cfg.init >= 0))
    lcd_nv8600mgt_cfg.init = -1;

  if(lcd_nv8600mgt_cfg.init >= 16)
    lcd_nv8600mgt_cfg.init = 15;

  if(!(lcd_nv8600mgt_cfg.step >= 1))
    lcd_nv8600mgt_cfg.step = 1;

  if(lcd_nv8600mgt_cfg.step >= 4)
    lcd_nv8600mgt_cfg.step = 15 / 4;

  if(lcd_nv8600mgt_cfg.on_batt >= 16 || !(lcd_nv8600mgt_cfg.on_batt >= 0))
    lcd_nv8600mgt_cfg.on_batt = 0;

}

// nv8600mgt_backlight_get
// file mactel/nv8600mgt_backlight.c line 59
static unsigned char nv8600mgt_backlight_get()
{
  unsigned char value;
  if(nv8600mgt_inited == 0)
    return (unsigned char)0;

  else
  {
    outb((unsigned char)0x03, (unsigned short int)(bl_port + (unsigned int)1));
    outb((unsigned char)0xbf, (unsigned short int)bl_port);
    unsigned char return_value_inb$1;
    return_value_inb$1=inb((unsigned short int)(bl_port + (unsigned int)1));
    value = (unsigned char)((signed int)return_value_inb$1 >> 4);
    return value;
  }
}

// nv8600mgt_backlight_probe
// file lcd_backlight.h line 69
signed int nv8600mgt_backlight_probe(void)
{
  signed int ret;
  switch((signed int)mops->type)
  {
    case MACHINE_MACBOOKPRO_3:

    case MACHINE_MACBOOKPRO_4:
    {
      bl_port = (unsigned int)0xb2;
      break;
    }
    case MACHINE_MACBOOKPRO_5:

    case MACHINE_MACBOOKPRO_6:

    case MACHINE_MACBOOK_5:

    case MACHINE_MACBOOK_6:

    case MACHINE_MACBOOKAIR_2:

    case MACHINE_MACBOOKAIR_3:
    {
      bl_port = (unsigned int)0x52e;
      break;
    }
    default:
    {
      logmsg(3, "nv8600mgt LCD backlight support not supported on this hardware");
      return -1;
    }
  }
  lcd_bck_info.max = 15;
  ret=iopl(3);
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    logmsg(3, "iopl() failed: %s", return_value_strerror$2);
    lcd_bck_info.level = 0;
    return -1;
  }

  nv8600mgt_inited = 1;
  if(lcd_nv8600mgt_cfg.init >= 0)
    nv8600mgt_backlight_set((unsigned char)lcd_nv8600mgt_cfg.init);

  unsigned char return_value_nv8600mgt_backlight_get$3;
  return_value_nv8600mgt_backlight_get$3=nv8600mgt_backlight_get();
  lcd_bck_info.level = (signed int)return_value_nv8600mgt_backlight_get$3;
  lcd_bck_info.ac_lvl = lcd_bck_info.level;
  return 0;
}

// nv8600mgt_backlight_set
// file mactel/nv8600mgt_backlight.c line 75
static void nv8600mgt_backlight_set(unsigned char value)
{
  if(!(nv8600mgt_inited == 0))
  {
    outb((unsigned char)(0x04 | (signed int)value << 4), (unsigned short int)(bl_port + (unsigned int)1));
    outb((unsigned char)0xbf, (unsigned short int)bl_port);
  }

}

// nv8600mgt_backlight_step
// file lcd_backlight.h line 63
void nv8600mgt_backlight_step(signed int dir)
{
  signed int val;
  signed int newval;
  if(!(nv8600mgt_inited == 0))
  {
    unsigned char return_value_nv8600mgt_backlight_get$1;
    return_value_nv8600mgt_backlight_get$1=nv8600mgt_backlight_get();
    val = (signed int)return_value_nv8600mgt_backlight_get$1;
    if(dir == 1)
    {
      newval = val + lcd_nv8600mgt_cfg.step;
      if(newval >= 16)
        newval = 15;

      logdebug("LCD stepping +%d -> %d\n", lcd_nv8600mgt_cfg.step, newval);
    }

    else
      if(dir == -1)
      {
        newval = val - lcd_nv8600mgt_cfg.step;
        if(!(newval >= 0))
          newval = 0;

        logdebug("LCD stepping -%d -> %d\n", lcd_nv8600mgt_cfg.step, newval);
      }

      else
        goto __CPROVER_DUMP_L7;
    nv8600mgt_backlight_set((unsigned char)newval);
    mbpdbus_send_lcd_backlight(newval, val, 0);
    lcd_bck_info.level = newval;
  }


__CPROVER_DUMP_L7:
  ;
}

// nv8600mgt_backlight_toggle
// file lcd_backlight.h line 66
void nv8600mgt_backlight_toggle(signed int lvl)
{
  signed int val;
  if(!(lcd_nv8600mgt_cfg.on_batt == 0))
  {
    if(!(nv8600mgt_inited == 0))
    {
      unsigned char return_value_nv8600mgt_backlight_get$1;
      return_value_nv8600mgt_backlight_get$1=nv8600mgt_backlight_get();
      val = (signed int)return_value_nv8600mgt_backlight_get$1;
      if(!(val == lcd_bck_info.level))
      {
        mbpdbus_send_lcd_backlight(val, lcd_bck_info.level, 1);
        lcd_bck_info.level = val;
      }

      if(!(lcd_bck_info.level == 0))
        switch(lvl)
        {
          case 0:
          {
            if(lcd_bck_info.level >= lcd_bck_info.ac_lvl)
              break;

            logdebug("LCD switching to AC level\n");
            nv8600mgt_backlight_set((unsigned char)lcd_bck_info.ac_lvl);
            mbpdbus_send_lcd_backlight(lcd_bck_info.ac_lvl, lcd_bck_info.level, 1);
            lcd_bck_info.level = lcd_bck_info.ac_lvl;
            break;
          }
          case 1:
            if(!(lcd_nv8600mgt_cfg.on_batt >= lcd_bck_info.level))
            {
              logdebug("LCD switching to battery level\n");
              lcd_bck_info.ac_lvl = lcd_bck_info.level;
              nv8600mgt_backlight_set((unsigned char)lcd_nv8600mgt_cfg.on_batt);
              mbpdbus_send_lcd_backlight(lcd_nv8600mgt_cfg.on_batt, lcd_bck_info.level, 1);
              lcd_bck_info.level = lcd_nv8600mgt_cfg.on_batt;
            }

        }

    }

  }

}

// outb
// file /usr/include/x86_64-linux-gnu/sys/io.h line 96
static inline void outb(unsigned char __value, unsigned short int __port)
{
  asm("outb %b0,%w1" :  : "a"(__value), "Nd"(__port) : );
}

// power_check_ac_state
// file power.c line 87
static void power_check_ac_state(signed int id, unsigned long int ticks)
{
  signed int ac_state;
  ac_state=check_ac_state();
  if(ac_state == prev_state)
    goto __CPROVER_DUMP_L8;

  else
    prev_state = ac_state;
  if(!(ac_state == 1))
  {
    if(ac_state == 0)
      goto __CPROVER_DUMP_L4;

    if(ac_state == -1)
      goto __CPROVER_DUMP_L5;

    if(ac_state == -2)
      goto __CPROVER_DUMP_L6;

  }

  else
  {
    logdebug("power: switched to AC\n");
    mops->lcd_backlight_toggle(0);

  __CPROVER_DUMP_L4:
    ;
    logdebug("power: switched to battery\n");
    mops->lcd_backlight_toggle(1);

  __CPROVER_DUMP_L5:
    ;
    logmsg(3, "power: error reading AC state");
    goto __CPROVER_DUMP_L7;

  __CPROVER_DUMP_L6:
    ;
    logmsg(6, "power: unknown AC state");
  }

__CPROVER_DUMP_L7:
  ;

__CPROVER_DUMP_L8:
  ;
}

// power_cleanup
// file power.h line 28
void power_cleanup(void)
{
  if(power_timer >= 1)
    evloop_remove_timer(power_timer);

}

// power_init
// file power.h line 25
void power_init(void)
{
  prev_state=check_ac_state();
  power_timer=evloop_add_timer(200, power_check_ac_state);
}

// process_ambient_getlevel_call
// file dbus.c line 473
static void process_ambient_getlevel_call(struct DBusMessage *req)
{
  struct DBusMessage *msg;
  struct DBusMessageIter args;
  signed int ret;
  logdebug("Got ambient getLevel call\n");
  unsigned int return_value_dbus_message_iter_init$1;
  return_value_dbus_message_iter_init$1=dbus_message_iter_init(req, &args);
  if(!(return_value_dbus_message_iter_init$1 == 0u))
    logdebug("ambient getLevel call with arguments ?!\n");

  else
  {
    msg=dbus_message_new_method_return(req);
    unsigned int return_value_dbus_message_append_args$2;
    return_value_dbus_message_append_args$2=dbus_message_append_args(msg, (signed int)117, &ambient_info.left, (signed int)117, &ambient_info.right, (signed int)117, &ambient_info.max, (signed int)0);
    ret = (signed int)return_value_dbus_message_append_args$2;
    if(ret == 0)
    {
      logdebug("Failed to add arguments\n");
      dbus_message_unref(msg);
    }

    else
    {
      unsigned int return_value_dbus_connection_send$3;
      return_value_dbus_connection_send$3=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
      ret = (signed int)return_value_dbus_connection_send$3;
      if(ret == 0)
      {
        logdebug("Could not send ambient getLevel reply\n");
        dbus_message_unref(msg);
      }

      else
        dbus_message_unref(msg);
    }
  }
}

// process_audio_getmute_call
// file dbus.c line 564
static void process_audio_getmute_call(struct DBusMessage *req)
{
  struct DBusMessage *msg;
  struct DBusMessageIter args;
  signed int ret;
  logdebug("Got audio getMute call\n");
  unsigned int return_value_dbus_message_iter_init$1;
  return_value_dbus_message_iter_init$1=dbus_message_iter_init(req, &args);
  if(!(return_value_dbus_message_iter_init$1 == 0u))
    logdebug("audio getMute call with arguments ?!\n");

  else
  {
    msg=dbus_message_new_method_return(req);
    unsigned int return_value_dbus_message_append_args$2;
    return_value_dbus_message_append_args$2=dbus_message_append_args(msg, (signed int)98, &audio_info.muted, (signed int)0);
    ret = (signed int)return_value_dbus_message_append_args$2;
    if(ret == 0)
    {
      logdebug("Failed to add arguments\n");
      dbus_message_unref(msg);
    }

    else
    {
      unsigned int return_value_dbus_connection_send$3;
      return_value_dbus_connection_send$3=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
      ret = (signed int)return_value_dbus_connection_send$3;
      if(ret == 0)
      {
        logdebug("Could not send audio getMute reply\n");
        dbus_message_unref(msg);
      }

      else
        dbus_message_unref(msg);
    }
  }
}

// process_audio_getvolume_call
// file dbus.c line 519
static void process_audio_getvolume_call(struct DBusMessage *req)
{
  struct DBusMessage *msg;
  struct DBusMessageIter args;
  signed int ret;
  logdebug("Got audio getVolume call\n");
  unsigned int return_value_dbus_message_iter_init$1;
  return_value_dbus_message_iter_init$1=dbus_message_iter_init(req, &args);
  if(!(return_value_dbus_message_iter_init$1 == 0u))
    logdebug("audio getVolume call with arguments ?!\n");

  else
  {
    msg=dbus_message_new_method_return(req);
    unsigned int return_value_dbus_message_append_args$2;
    return_value_dbus_message_append_args$2=dbus_message_append_args(msg, (signed int)117, &audio_info.level, (signed int)117, &audio_info.max, (signed int)0);
    ret = (signed int)return_value_dbus_message_append_args$2;
    if(ret == 0)
    {
      logdebug("Failed to add arguments\n");
      dbus_message_unref(msg);
    }

    else
    {
      unsigned int return_value_dbus_connection_send$3;
      return_value_dbus_connection_send$3=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
      ret = (signed int)return_value_dbus_connection_send$3;
      if(ret == 0)
      {
        logdebug("Could not send audio getVolume reply\n");
        dbus_message_unref(msg);
      }

      else
        dbus_message_unref(msg);
    }
  }
}

// process_audio_toggle_mute_call
// file dbus.c line 739
static void process_audio_toggle_mute_call(struct DBusMessage *req)
{
  struct DBusMessage *msg;
  signed int ret;
  logdebug("Got audio toggleMute call\n");
  audio_toggle_mute();
  msg=dbus_message_new_method_return(req);
  unsigned int return_value_dbus_connection_send$1;
  return_value_dbus_connection_send$1=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
  ret = (signed int)return_value_dbus_connection_send$1;
  if(ret == 0)
  {
    logdebug("Could not send audio toggleMute reply\n");
    dbus_message_unref(msg);
  }

  else
    dbus_message_unref(msg);
}

// process_audio_volume_step_call
// file dbus.c line 713
static void process_audio_volume_step_call(struct DBusMessage *req, signed int dir)
{
  struct DBusMessage *msg;
  signed int ret;
  logdebug("Got audio volumeUp/volumeDown call\n");
  audio_step(dir);
  msg=dbus_message_new_method_return(req);
  unsigned int return_value_dbus_connection_send$1;
  return_value_dbus_connection_send$1=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
  ret = (signed int)return_value_dbus_connection_send$1;
  if(ret == 0)
  {
    logdebug("Could not send audio volumeUp/volumeDown reply\n");
    dbus_message_unref(msg);
  }

  else
    dbus_message_unref(msg);
}

// process_cd_eject_call
// file dbus.c line 765
static void process_cd_eject_call(struct DBusMessage *req)
{
  struct DBusMessage *msg;
  signed int ret;
  logdebug("Got cd eject call\n");
  cd_eject();
  msg=dbus_message_new_method_return(req);
  unsigned int return_value_dbus_connection_send$1;
  return_value_dbus_connection_send$1=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
  ret = (signed int)return_value_dbus_connection_send$1;
  if(ret == 0)
  {
    logdebug("Could not send cd eject reply\n");
    dbus_message_unref(msg);
  }

  else
    dbus_message_unref(msg);
}

// process_kbd_backlight_inhibit_call
// file dbus.c line 684
static void process_kbd_backlight_inhibit_call(struct DBusMessage *req, signed int inhibit)
{
  struct DBusMessage *msg;
  signed int ret;
  logdebug("Got kbdBacklight inhibit call\n");
  if(!(inhibit == 0))
    kbd_backlight_inhibit_set(1 << 0);

  else
    kbd_backlight_inhibit_clear(1 << 0);
  msg=dbus_message_new_method_return(req);
  unsigned int return_value_dbus_connection_send$1;
  return_value_dbus_connection_send$1=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
  ret = (signed int)return_value_dbus_connection_send$1;
  if(ret == 0)
  {
    logdebug("Could not send kbdBacklight inhibit reply\n");
    dbus_message_unref(msg);
  }

  else
    dbus_message_unref(msg);
}

// process_kbd_getlevel_call
// file dbus.c line 427
static void process_kbd_getlevel_call(struct DBusMessage *req)
{
  struct DBusMessage *msg;
  struct DBusMessageIter args;
  signed int ret;
  logdebug("Got kbdBacklight getLevel call\n");
  unsigned int return_value_dbus_message_iter_init$1;
  return_value_dbus_message_iter_init$1=dbus_message_iter_init(req, &args);
  if(!(return_value_dbus_message_iter_init$1 == 0u))
    logdebug("kbdBacklight getLevel call with arguments ?!\n");

  else
  {
    msg=dbus_message_new_method_return(req);
    unsigned int return_value_dbus_message_append_args$2;
    return_value_dbus_message_append_args$2=dbus_message_append_args(msg, (signed int)117, &kbd_bck_info.level, (signed int)117, &kbd_bck_info.max, (signed int)0);
    ret = (signed int)return_value_dbus_message_append_args$2;
    if(ret == 0)
    {
      logdebug("Failed to add arguments\n");
      dbus_message_unref(msg);
    }

    else
    {
      unsigned int return_value_dbus_connection_send$3;
      return_value_dbus_connection_send$3=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
      ret = (signed int)return_value_dbus_connection_send$3;
      if(ret == 0)
      {
        logdebug("Could not send kbdBacklight getLevel reply\n");
        dbus_message_unref(msg);
      }

      else
        dbus_message_unref(msg);
    }
  }
}

// process_lcd_backlight_step_call
// file dbus.c line 658
static void process_lcd_backlight_step_call(struct DBusMessage *req, signed int dir)
{
  struct DBusMessage *msg;
  signed int ret;
  logdebug("Got lcdBacklight levelUp/levelDown call\n");
  mops->lcd_backlight_step(dir);
  msg=dbus_message_new_method_return(req);
  unsigned int return_value_dbus_connection_send$1;
  return_value_dbus_connection_send$1=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
  ret = (signed int)return_value_dbus_connection_send$1;
  if(ret == 0)
  {
    logdebug("Could not send lcdBacklight levelUp/levelDown reply\n");
    dbus_message_unref(msg);
  }

  else
    dbus_message_unref(msg);
}

// process_lcd_getlevel_call
// file dbus.c line 381
static void process_lcd_getlevel_call(struct DBusMessage *req)
{
  struct DBusMessage *msg;
  struct DBusMessageIter args;
  signed int ret;
  logdebug("Got lcdBacklight getLevel call\n");
  unsigned int return_value_dbus_message_iter_init$1;
  return_value_dbus_message_iter_init$1=dbus_message_iter_init(req, &args);
  if(!(return_value_dbus_message_iter_init$1 == 0u))
    logdebug("lcdBacklight getLevel call with arguments ?!\n");

  else
  {
    msg=dbus_message_new_method_return(req);
    unsigned int return_value_dbus_message_append_args$2;
    return_value_dbus_message_append_args$2=dbus_message_append_args(msg, (signed int)117, &lcd_bck_info.level, (signed int)117, &lcd_bck_info.max, (signed int)0);
    ret = (signed int)return_value_dbus_message_append_args$2;
    if(ret == 0)
    {
      logdebug("Failed to add arguments\n");
      dbus_message_unref(msg);
    }

    else
    {
      unsigned int return_value_dbus_connection_send$3;
      return_value_dbus_connection_send$3=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
      ret = (signed int)return_value_dbus_connection_send$3;
      if(ret == 0)
      {
        logdebug("Could not send lcdBacklight getLevel reply\n");
        dbus_message_unref(msg);
      }

      else
        dbus_message_unref(msg);
    }
  }
}

// process_video_getvtstate_call
// file dbus.c line 608
static void process_video_getvtstate_call(struct DBusMessage *req)
{
  struct DBusMessage *msg;
  signed int vtnum;
  signed int vtstate;
  signed int ret;
  logdebug("Got video getVTState call\n");
  unsigned int return_value_dbus_message_get_args$1;
  return_value_dbus_message_get_args$1=dbus_message_get_args(req, &err, (signed int)117, &vtnum, (signed int)0);
  ret = (signed int)return_value_dbus_message_get_args$1;
  if(ret == 0)
    logdebug("video getVTState call with no/inappropriate arguments ?!\n");

  else
  {
    vtstate=video_vt_active(vtnum);
    msg=dbus_message_new_method_return(req);
    unsigned int return_value_dbus_message_append_args$2;
    return_value_dbus_message_append_args$2=dbus_message_append_args(msg, (signed int)98, &vtstate, (signed int)0);
    ret = (signed int)return_value_dbus_message_append_args$2;
    if(ret == 0)
    {
      logdebug("Failed to add arguments\n");
      dbus_message_unref(msg);
    }

    else
    {
      unsigned int return_value_dbus_connection_send$3;
      return_value_dbus_connection_send$3=dbus_connection_send(conn, msg, (unsigned int *)(void *)0);
      ret = (signed int)return_value_dbus_connection_send$3;
      if(ret == 0)
      {
        logdebug("Could not send video getVTState reply\n");
        dbus_message_unref(msg);
      }

      else
        dbus_message_unref(msg);
    }
  }
}

// procfs_check_ac_state
// file power.c line 36
signed int procfs_check_ac_state(void)
{
  struct _IO_FILE *fp;
  char buf[128l];
  signed int ret;
  fp=fopen("/proc/acpi/ac_adapter/ADP1/state", "r");
  if(fp == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    unsigned long int return_value_fread$1;
    return_value_fread$1=fread((void *)buf, (unsigned long int)1, (unsigned long int)127, fp);
    ret = (signed int)return_value_fread$1;
    signed int return_value_ferror$4;
    return_value_ferror$4=ferror(fp);
    if(!(return_value_ferror$4 == 0))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      logdebug("acpi: Error reading proc AC state: %s\n", return_value_strerror$3);
      return -1;
    }

    signed int return_value_feof$5;
    return_value_feof$5=feof(fp);
    if(return_value_feof$5 == 0)
    {
      logdebug("acpi: Error reading proc AC state: buffer too small\n");
      return -1;
    }

    else
    {
      fclose(fp);
      buf[(signed long int)ret] = (char)0;
      char *return_value_strstr$6;
      return_value_strstr$6=strstr(buf, "on-line\n");
      if(!(return_value_strstr$6 == ((char *)NULL)))
        return 1;

      else
      {
        char *return_value_strstr$7;
        return_value_strstr$7=strstr(buf, "off-line\n");
        if(!(return_value_strstr$7 == ((char *)NULL)))
          return 0;

        else
          return -2;
      }
    }
  }
}

// readl
// file mactel/x1600_backlight.c line 56
static inline unsigned int readl(const volatile void *addr)
{
  return *((volatile unsigned int *)addr);
}

// readl$link1
// file mactel/gma950_backlight.c line 87
static inline unsigned int readl$link1(const volatile void *addr$link1)
{
  return *((volatile unsigned int *)addr$link1);
}

// sig_int_term_handler
// file pommed.c line 831
void sig_int_term_handler(signed int signal)
{
  evloop_stop();
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat$1;
  return_value___xstat$1=__xstat(1, __path, __statbuf);
  return return_value___xstat$1;
}

// stat$link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat$link1(const char *__path$link1, struct stat *__statbuf$link1)
{
  signed int return_value___xstat$1$link1;
  return_value___xstat$1$link1=__xstat(1, __path$link1, __statbuf$link1);
  return return_value___xstat$1$link1;
}

// sysfs_backlight_fix_config
// file sysfs_backlight.c line 330
static void sysfs_backlight_fix_config(void)
{
  if(!(lcd_sysfs_cfg.init >= 0))
    lcd_sysfs_cfg.init = -1;

  if(!(lcd_bck_info.max >= lcd_sysfs_cfg.init))
    lcd_sysfs_cfg.init = lcd_bck_info.max;

  if(!(lcd_sysfs_cfg.step >= 1))
    lcd_sysfs_cfg.step = 1;

  if(!(lcd_bck_info.max / 2 >= lcd_sysfs_cfg.step))
    lcd_sysfs_cfg.step = lcd_bck_info.max / 2;

  if(!(lcd_bck_info.max >= lcd_sysfs_cfg.on_batt) || !(lcd_sysfs_cfg.on_batt >= 0))
    lcd_sysfs_cfg.on_batt = 0;

}

// sysfs_backlight_get
// file sysfs_backlight.c line 121
static signed int sysfs_backlight_get(void)
{
  signed int sysfs_backlight_get$$1$$fd;
  signed int n;
  char buffer[8l];
  if(bck_driver == 0)
    return 0;

  else
  {
    sysfs_backlight_get$$1$$fd=open(actual_brightness[(signed long int)bck_driver], 00);
    if(!(sysfs_backlight_get$$1$$fd >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      logmsg(4, "Could not open sysfs actual_brightness node: %s", return_value_strerror$2);
      return 0;
    }

    memset((void *)buffer, 0, sizeof(char [8l]) /*8ul*/ );
    signed long int return_value_read$3;
    return_value_read$3=read(sysfs_backlight_get$$1$$fd, (void *)buffer, sizeof(char [8l]) /*8ul*/  - (unsigned long int)1);
    n = (signed int)return_value_read$3;
    if(!(n >= 1))
    {
      logmsg(4, "Could not read sysfs actual_brightness node");
      close(sysfs_backlight_get$$1$$fd);
      return 0;
    }

    else
    {
      close(sysfs_backlight_get$$1$$fd);
      signed int return_value_atoi$4;
      return_value_atoi$4=atoi(buffer);
      return return_value_atoi$4;
    }
  }
}

// sysfs_backlight_get_max
// file sysfs_backlight.c line 153
static signed int sysfs_backlight_get_max(void)
{
  signed int sysfs_backlight_get_max$$1$$fd;
  signed int n;
  char buffer[8l];
  if(bck_driver == 0)
    return 0;

  else
  {
    sysfs_backlight_get_max$$1$$fd=open(max_brightness[(signed long int)bck_driver], 00);
    if(!(sysfs_backlight_get_max$$1$$fd >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      logmsg(4, "Could not open sysfs max_brightness node: %s", return_value_strerror$2);
      return 0;
    }

    memset((void *)buffer, 0, sizeof(char [8l]) /*8ul*/ );
    signed long int return_value_read$3;
    return_value_read$3=read(sysfs_backlight_get_max$$1$$fd, (void *)buffer, sizeof(char [8l]) /*8ul*/  - (unsigned long int)1);
    n = (signed int)return_value_read$3;
    if(!(n >= 1))
    {
      logmsg(4, "Could not read sysfs max_brightness node");
      close(sysfs_backlight_get_max$$1$$fd);
      return 0;
    }

    else
    {
      close(sysfs_backlight_get_max$$1$$fd);
      signed int return_value_atoi$4;
      return_value_atoi$4=atoi(buffer);
      return return_value_atoi$4;
    }
  }
}

// sysfs_backlight_probe
// file sysfs_backlight.c line 352
static signed int sysfs_backlight_probe(signed int driver)
{
  signed int return_value_access$3;
  return_value_access$3=access(brightness[(signed long int)driver], 2);
  if(!(return_value_access$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    logdebug("Failed to access brightness node: %s\n", return_value_strerror$2);
    return -1;
  }

  signed int return_value_access$6;
  return_value_access$6=access(actual_brightness[(signed long int)driver], 4);
  if(!(return_value_access$6 == 0))
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(*return_value___errno_location$4);
    logdebug("Failed to access actual_brightness node: %s\n", return_value_strerror$5);
    return -1;
  }

  signed int return_value_access$9;
  return_value_access$9=access(max_brightness[(signed long int)driver], 4);
  if(!(return_value_access$9 == 0))
  {
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    char *return_value_strerror$8;
    return_value_strerror$8=strerror(*return_value___errno_location$7);
    logdebug("Failed to access max_brightness node: %s\n", return_value_strerror$8);
    return -1;
  }

  bck_driver = driver;
  lcd_bck_info.max=sysfs_backlight_get_max();
  sysfs_backlight_fix_config();
  if(lcd_sysfs_cfg.init >= 0)
    sysfs_backlight_set(lcd_sysfs_cfg.init);

  lcd_bck_info.level=sysfs_backlight_get();
  lcd_bck_info.ac_lvl = lcd_bck_info.level;
  return 0;
}

// sysfs_backlight_set
// file sysfs_backlight.c line 186
static void sysfs_backlight_set(signed int value)
{
  struct _IO_FILE *fp;
  if(!(bck_driver == 0))
  {
    fp=fopen(brightness[(signed long int)bck_driver], "a");
    if(fp == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      logmsg(4, "Could not open sysfs brightness node: %s", return_value_strerror$2);
      goto __CPROVER_DUMP_L3;
    }

    fprintf(fp, "%d", value);
    fclose(fp);
  }


__CPROVER_DUMP_L3:
  ;
}

// sysfs_backlight_step
// file lcd_backlight.h line 80
void sysfs_backlight_step(signed int dir)
{
  signed int val;
  signed int newval;
  if(!(bck_driver == 0))
  {
    val=sysfs_backlight_get();
    if(dir == 1)
    {
      newval = val + lcd_sysfs_cfg.step;
      if(!(lcd_bck_info.max >= newval))
        newval = lcd_bck_info.max;

      logdebug("LCD stepping +%d -> %d\n", lcd_sysfs_cfg.step, newval);
    }

    else
      if(dir == -1)
      {
        newval = val - lcd_sysfs_cfg.step;
        if(!(newval >= 0))
          newval = 0;

        logdebug("LCD stepping -%d -> %d\n", lcd_sysfs_cfg.step, newval);
      }

      else
        goto __CPROVER_DUMP_L7;
    sysfs_backlight_set(newval);
    mbpdbus_send_lcd_backlight(newval, val, 0);
    lcd_bck_info.level = newval;
  }


__CPROVER_DUMP_L7:
  ;
}

// sysfs_backlight_toggle
// file lcd_backlight.h line 83
void sysfs_backlight_toggle(signed int lvl)
{
  signed int val;
  if(!(bck_driver == 0))
  {
    if(!(lcd_sysfs_cfg.on_batt == 0))
    {
      val=sysfs_backlight_get();
      if(!(val == lcd_bck_info.level))
      {
        mbpdbus_send_lcd_backlight(val, lcd_bck_info.level, 1);
        lcd_bck_info.level = val;
      }

      if(!(lcd_bck_info.level == 0))
        switch(lvl)
        {
          case 0:
          {
            if(lcd_bck_info.level >= lcd_bck_info.ac_lvl)
              break;

            logdebug("LCD switching to AC level\n");
            sysfs_backlight_set(lcd_bck_info.ac_lvl);
            mbpdbus_send_lcd_backlight(lcd_bck_info.ac_lvl, lcd_bck_info.level, 1);
            lcd_bck_info.level = lcd_bck_info.ac_lvl;
            break;
          }
          case 1:
            if(!(lcd_sysfs_cfg.on_batt >= lcd_bck_info.level))
            {
              logdebug("LCD switching to battery level\n");
              lcd_bck_info.ac_lvl = lcd_bck_info.level;
              sysfs_backlight_set(lcd_sysfs_cfg.on_batt);
              mbpdbus_send_lcd_backlight(lcd_sysfs_cfg.on_batt, lcd_bck_info.level, 1);
              lcd_bck_info.level = lcd_sysfs_cfg.on_batt;
            }

        }

    }

  }

}

// sysfs_check_ac_state
// file power.c line 45
static signed int sysfs_check_ac_state(void)
{
  struct _IO_FILE *fp;
  char ac_state;
  fp=fopen("/sys/class/power_supply/ADP1/online", "r");
  if(fp == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    fread((void *)&ac_state, (unsigned long int)1, (unsigned long int)1, fp);
    signed int return_value_ferror$3;
    return_value_ferror$3=ferror(fp);
    if(!(return_value_ferror$3 == 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      logdebug("power: Error reading sysfs AC state: %s\n", return_value_strerror$2);
      return -1;
    }

    fclose(fp);
    if((signed int)ac_state == 49)
      return 1;

    else
      if((signed int)ac_state == 48)
        return 0;

      else
        return -2;
  }
}

// usage
// file pommed.c line 817
static void usage(void)
{
  printf("pommed v1.39 Apple laptops hotkeys handler\n");
  printf("Copyright (C) 2006-2011 Julien BLACHE <jb@jblache.org>\n");
  printf("Usage:\n");
  printf("\tpommed\t-- start pommed as a daemon\n");
  printf("\tpommed -v\t-- print version and exit\n");
  printf("\tpommed -f\t-- run in the foreground with log messages\n");
  printf("\tpommed -d\t-- run in the foreground with debug messages\n");
}

// video_switch
// file video.h line 10
void video_switch(void)
{
  mbpdbus_send_video_switch();
}

// video_vt_active
// file video.h line 13
signed int video_vt_active(signed int vt)
{
  signed int video_vt_active$$1$$fd;
  char buf[16l];
  struct vt_stat vtstat;
  signed int ret;
  ret=snprintf(buf, sizeof(char [16l]) /*16ul*/ , "/dev/tty%d", vt);
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  if((unsigned long int)ret >= sizeof(char [16l]) /*16ul*/  || !(ret >= 0))
    return 1;

  else
  {
    video_vt_active$$1$$fd=open(buf, 02);
    if(!(video_vt_active$$1$$fd >= 0))
    {
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 13)
        video_vt_active$$1$$fd=open(buf, 00);

    }

    if(!(video_vt_active$$1$$fd >= 0))
    {
      return_value___errno_location$2=__errno_location();
      if(*return_value___errno_location$2 == 13)
        video_vt_active$$1$$fd=open(buf, 01);

    }

    if(!(video_vt_active$$1$$fd >= 0))
      return 0;

    else
    {
      signed int return_value_isatty$3;
      return_value_isatty$3=isatty(video_vt_active$$1$$fd);
      if(return_value_isatty$3 == 0)
      {
        close(video_vt_active$$1$$fd);
        return 0;
      }

      else
      {
        ret=ioctl(video_vt_active$$1$$fd, (unsigned long int)0x5603, &vtstat);
        close(video_vt_active$$1$$fd);
        if(!(ret >= 0))
          return 1;

        else
          return (signed int)(vt == (signed int)vtstat.v_active);
      }
    }
  }
}

// writel
// file mactel/x1600_backlight.c line 62
static inline void writel(unsigned int b, volatile void *addr)
{
  *((volatile unsigned int *)addr) = b;
}

// writel$link1
// file mactel/gma950_backlight.c line 93
static inline void writel$link1(unsigned int b$link1, volatile void *addr$link1)
{
  *((volatile unsigned int *)addr$link1) = b$link1;
}

// x1600_backlight_fix_config
// file lcd_backlight.h line 41
void x1600_backlight_fix_config(void)
{
  if(!(lcd_x1600_cfg.init >= 0))
    lcd_x1600_cfg.init = -1;

  if(lcd_x1600_cfg.init >= 256)
    lcd_x1600_cfg.init = 255;

  if(!(lcd_x1600_cfg.step >= 1))
    lcd_x1600_cfg.step = 1;

  if(lcd_x1600_cfg.step >= 128)
    lcd_x1600_cfg.step = 255 / 2;

  if(lcd_x1600_cfg.on_batt >= 256 || !(lcd_x1600_cfg.on_batt >= 0))
    lcd_x1600_cfg.on_batt = 0;

}

// x1600_backlight_get
// file mactel/x1600_backlight.c line 72
static unsigned char x1600_backlight_get()
{
  unsigned int return_value_readl$1;
  return_value_readl$1=readl((const volatile void *)(memory + (signed long int)0x7af8));
  return (unsigned char)(return_value_readl$1 >> 8);
}

// x1600_backlight_map
// file mactel/x1600_backlight.c line 85
static signed int x1600_backlight_map(void)
{
  unsigned int state;
  if(length == 0l)
  {
    logdebug("No probing done!\n");
    return -1;
  }

  else
  {
    fd=open(sysfs_resource, 02);
    if(!(fd >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      logmsg(4, "Cannot open %s: %s", (const void *)sysfs_resource, return_value_strerror$2);
      close(fd);
      fd = -1;
      return -1;
    }

    void *return_value_mmap$3;
    return_value_mmap$3=mmap((void *)0, (unsigned long int)length, 0x1 | 0x2, 0x01, fd, (signed long int)0);
    memory = (char *)return_value_mmap$3;
    if(memory == (char *)-1)
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      logmsg(3, "mmap failed: %s", return_value_strerror$5);
      return -1;
    }

    writel((unsigned int)0x00000005, (volatile void *)(memory + (signed long int)0x4dc));
    state=readl((const volatile void *)(memory + (signed long int)0x7ae4));
    writel(state, (volatile void *)(memory + (signed long int)0x7ae4));
    return 0;
  }
}

// x1600_backlight_probe
// file lcd_backlight.h line 38
signed int x1600_backlight_probe(void)
{
  struct pci_access *pacc;
  struct pci_dev *dev;
  struct stat stbuf;
  signed int ret;
  pacc=pci_alloc();
  if(pacc == ((struct pci_access *)NULL))
  {
    logmsg(3, "Could not allocate PCI structs");
    return -1;
  }

  else
  {
    pci_init(pacc);
    pci_scan_bus(pacc);
    dev = pacc->devices;
    for( ; !(dev == ((struct pci_dev *)NULL)); dev = dev->next)
    {
      pci_fill_info(dev, 1);
      if((signed int)dev->vendor_id == 0x1002)
      {
        if((signed int)dev->device_id == 0x71c5)
        {
          ret=snprintf(sysfs_resource, sizeof(char [64l]) /*64ul*/ , "/sys/bus/pci/devices/%04x:%02x:%02x.%1x/resource2", dev->domain, dev->bus, dev->dev, dev->func);
          break;
        }

      }

    }
    pci_cleanup(pacc);
    if(dev == ((struct pci_dev *)NULL))
    {
      logdebug("Failed to detect ATI X1600, aborting...\n");
      return -1;
    }

    else
      if((unsigned long int)ret >= sizeof(char [64l]) /*64ul*/ )
      {
        logmsg(3, "Could not build sysfs PCI resource path");
        return -1;
      }

      else
      {
        ret=stat(sysfs_resource, &stbuf);
        if(!(ret >= 0))
        {
          signed int *return_value___errno_location$1;
          return_value___errno_location$1=__errno_location();
          char *return_value_strerror$2;
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          logmsg(3, "Could not determine PCI resource length: %s", return_value_strerror$2);
          return -1;
        }

        length = stbuf.st_size;
        logdebug("ATI X1600 PCI resource: [%s], length %ldK\n", (const void *)sysfs_resource, length / (signed long int)1024);
        lcd_bck_info.max = 255;
        ret=x1600_backlight_map();
        if(!(ret >= 0))
        {
          lcd_bck_info.level = 0;
          return 0;
        }

        else
        {
          if(lcd_x1600_cfg.init >= 0)
            x1600_backlight_set((unsigned char)lcd_x1600_cfg.init);

          unsigned char return_value_x1600_backlight_get$3;
          return_value_x1600_backlight_get$3=x1600_backlight_get();
          lcd_bck_info.level = (signed int)return_value_x1600_backlight_get$3;
          lcd_bck_info.ac_lvl = lcd_bck_info.level;
          x1600_backlight_unmap();
          return 0;
        }
      }
  }
}

// x1600_backlight_set
// file mactel/x1600_backlight.c line 78
static void x1600_backlight_set(unsigned char value)
{
  writel((unsigned int)0x00000001 | (unsigned int)value << 8, (volatile void *)(memory + (signed long int)0x7af8));
}

// x1600_backlight_step
// file lcd_backlight.h line 32
void x1600_backlight_step(signed int dir)
{
  signed int ret;
  signed int val;
  signed int newval;
  ret=x1600_backlight_map();
  if(ret >= 0)
  {
    unsigned char return_value_x1600_backlight_get$1;
    return_value_x1600_backlight_get$1=x1600_backlight_get();
    val = (signed int)return_value_x1600_backlight_get$1;
    if(dir == 1)
    {
      newval = val + lcd_x1600_cfg.step;
      if(newval >= 256)
        newval = 255;

      logdebug("LCD stepping +%d -> %d\n", lcd_x1600_cfg.step, newval);
    }

    else
      if(dir == -1)
      {
        newval = val - lcd_x1600_cfg.step;
        if(!(newval >= 0))
          newval = 0;

        logdebug("LCD stepping -%d -> %d\n", lcd_x1600_cfg.step, newval);
      }

      else
        goto __CPROVER_DUMP_L7;
    x1600_backlight_set((unsigned char)newval);
    x1600_backlight_unmap();
    mbpdbus_send_lcd_backlight(newval, val, 0);
    lcd_bck_info.level = newval;
  }


__CPROVER_DUMP_L7:
  ;
}

// x1600_backlight_toggle
// file lcd_backlight.h line 35
void x1600_backlight_toggle(signed int lvl)
{
  signed int val;
  signed int ret;
  if(!(lcd_x1600_cfg.on_batt == 0))
  {
    ret=x1600_backlight_map();
    if(ret >= 0)
    {
      unsigned char return_value_x1600_backlight_get$1;
      return_value_x1600_backlight_get$1=x1600_backlight_get();
      val = (signed int)return_value_x1600_backlight_get$1;
      if(!(val == lcd_bck_info.level))
      {
        mbpdbus_send_lcd_backlight(val, lcd_bck_info.level, 1);
        lcd_bck_info.level = val;
      }

      if(lcd_bck_info.level == 0)
        x1600_backlight_unmap();

      else
      {
        switch(lvl)
        {
          case 0:
          {
            if(lcd_bck_info.level >= lcd_bck_info.ac_lvl)
              break;

            logdebug("LCD switching to AC level\n");
            x1600_backlight_set((unsigned char)lcd_bck_info.ac_lvl);
            mbpdbus_send_lcd_backlight(lcd_bck_info.ac_lvl, lcd_bck_info.level, 1);
            lcd_bck_info.level = lcd_bck_info.ac_lvl;
            break;
          }
          case 1:
            if(!(lcd_x1600_cfg.on_batt >= lcd_bck_info.level))
            {
              logdebug("LCD switching to battery level\n");
              lcd_bck_info.ac_lvl = lcd_bck_info.level;
              x1600_backlight_set((unsigned char)lcd_x1600_cfg.on_batt);
              mbpdbus_send_lcd_backlight(lcd_x1600_cfg.on_batt, lcd_bck_info.level, 1);
              lcd_bck_info.level = lcd_x1600_cfg.on_batt;
            }

        }
        x1600_backlight_unmap();
      }
    }

  }

}

// x1600_backlight_unmap
// file mactel/x1600_backlight.c line 124
static void x1600_backlight_unmap(void)
{
  munmap((void *)memory, (unsigned long int)length);
  memory = (char *)(void *)0;
  close(fd);
  fd = -1;
}

