// #anon_enum$DBUS_BUS_SESSION=0$DBUS_BUS_SYSTEM=1$DBUS_BUS_STARTER=2
// file /usr/include/dbus-1.0/dbus/dbus-shared.h line 56
enum anonymous$34 { DBUS_BUS_SESSION=0, DBUS_BUS_SYSTEM=1, DBUS_BUS_STARTER=2 };

// tag-#anon#ST[*{S8}$S8$'name'|*{S8}$S8$'incFile'|S32'valueSize'|U32'$pad0'|*{S8}$S8$'value'|SYM#tag-list_head#'list']
// file io/hpmud/model.c line 44
struct anonymous$32;

// tag-#anon#ST[*{SYM#tag-libusb_device_handle#}$SYM#tag-libusb_device_handle#$'hd'|SYM#tag-FD_ID#'fd'|S32'config'|S32'interface'|S32'alt_setting'|S32'write_active'|U32'$pad0'|*{cV}$cV$'write_buf'|S32'write_size'|S32'write_return'|U64'tid'|SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']#'mutex'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}$S8$'__size'|S64'__align']#'write_done_cond'|ARR16384{U8}$U8$'ubuf'|S32'uindex'|S32'ucnt']
// file io/hpmud/musb.h line 69
struct anonymous$20;

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$37;

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$13;

// tag-#anon#ST[ARR2{SYM#tag-_mud_device#}$SYM#tag-_mud_device#$'device'|SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']#'mutex']
// file io/hpmud/hpmudi.h line 198
struct anonymous$28;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$35;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'hsid'|U8'psid'|U16'length'|U8'credit'|U8'status']#'h'|U8'cmd']
// file io/hpmud/mlc.h line 67
struct anonymous$29;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'hsid'|U8'psid'|U16'length'|U8'credit'|U8'status']#'h'|U8'cmd'|U8'hsocket'|U8'psocket']
// file io/hpmud/mlc.h line 117
struct anonymous$27;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'hsid'|U8'psid'|U16'length'|U8'credit'|U8'status']#'h'|U8'cmd'|U8'hsocket'|U8'psocket'|U16'credit']
// file io/hpmud/mlc.h line 100
struct anonymous$25;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'hsid'|U8'psid'|U16'length'|U8'credit'|U8'status']#'h'|U8'cmd'|U8'result']
// file io/hpmud/mlc.h line 73
struct anonymous$22;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'hsid'|U8'psid'|U16'length'|U8'credit'|U8'status']#'h'|U8'cmd'|U8'result'|U16'credit']
// file io/hpmud/mlc.h line 109
struct anonymous$26;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'hsid'|U8'psid'|U16'length'|U8'credit'|U8'status']#'h'|U8'cmd'|U8'result'|U16'h2psize'|U16'p2hsize'|U8'status']
// file io/hpmud/mlc.h line 90
struct anonymous$24;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'hsid'|U8'psid'|U16'length'|U8'credit'|U8'status']#'h'|U8'cmd'|U8'result'|U8'rev']
// file io/hpmud/mlc.h line 59
struct anonymous$31;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'hsid'|U8'psid'|U16'length'|U8'credit'|U8'status']#'h'|U8'cmd'|U8'rev']
// file io/hpmud/mlc.h line 52
struct anonymous$30;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'hsid'|U8'psid'|U16'length'|U8'credit'|U8'status']#'h'|U8'cmd'|U8'socket'|U16'h2psize'|U16'p2hsize'|U8'status']
// file io/hpmud/mlc.h line 80
struct anonymous$23;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'psid'|U8'ssid'|U16'length'|U8'credit'|U8'control']#'h'|U8'cmd']
// file io/hpmud/dot4.h line 72
struct anonymous$2;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'psid'|U8'ssid'|U16'length'|U8'credit'|U8'control']#'h'|U8'cmd'|U8'psocket'|U8'ssocket']
// file io/hpmud/dot4.h line 109
struct anonymous$6;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'psid'|U8'ssid'|U16'length'|U8'credit'|U8'control']#'h'|U8'cmd'|U8'psocket'|U8'ssocket'|U16'credit']
// file io/hpmud/dot4.h line 134
struct anonymous$9;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'psid'|U8'ssid'|U16'length'|U8'credit'|U8'control']#'h'|U8'cmd'|U8'psocket'|U8'ssocket'|U16'maxcredit']
// file io/hpmud/dot4.h line 143
struct anonymous$10;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'psid'|U8'ssid'|U16'length'|U8'credit'|U8'control']#'h'|U8'cmd'|U8'psocket'|U8'ssocket'|U16'maxp2s'|U16'maxs2p'|U16'maxcredit']
// file io/hpmud/dot4.h line 85
struct anonymous$4;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'psid'|U8'ssid'|U16'length'|U8'credit'|U8'control']#'h'|U8'cmd'|U8'psocket'|U8'ssocket'|U8'error']
// file io/hpmud/dot4.h line 162
struct anonymous$12;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'psid'|U8'ssid'|U16'length'|U8'credit'|U8'control']#'h'|U8'cmd'|U8'result']
// file io/hpmud/dot4.h line 78
struct anonymous$3;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'psid'|U8'ssid'|U16'length'|U8'credit'|U8'control']#'h'|U8'cmd'|U8'result'|U8'psocket'|U8'ssocket']
// file io/hpmud/dot4.h line 117
struct anonymous$7;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'psid'|U8'ssid'|U16'length'|U8'credit'|U8'control']#'h'|U8'cmd'|U8'result'|U8'psocket'|U8'ssocket'|U16'credit']
// file io/hpmud/dot4.h line 152
struct anonymous$11;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'psid'|U8'ssid'|U16'length'|U8'credit'|U8'control']#'h'|U8'cmd'|U8'result'|U8'psocket'|U8'ssocket'|U16'maxp2s'|U16'maxs2p'|U16'maxcredit'|U16'credit']
// file io/hpmud/dot4.h line 96
struct anonymous$5;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'psid'|U8'ssid'|U16'length'|U8'credit'|U8'control']#'h'|U8'cmd'|U8'result'|U8'rev']
// file io/hpmud/dot4.h line 64
struct anonymous$1;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'psid'|U8'ssid'|U16'length'|U8'credit'|U8'control']#'h'|U8'cmd'|U8'result'|U8'socket']
// file io/hpmud/dot4.h line 126
struct anonymous$8;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'psid'|U8'ssid'|U16'length'|U8'credit'|U8'control']#'h'|U8'cmd'|U8'rev']
// file io/hpmud/dot4.h line 57
struct anonymous$0;

// tag-#anon#ST[U16'h2pcredit'|U16'p2hcredit'|U16'h2psize'|U16'p2hsize']
// file io/hpmud/hpmudi.h line 124
struct anonymous$16;

// tag-#anon#ST[U8'hsid'|U8'psid'|U16'length'|U8'credit'|U8'status']
// file io/hpmud/mlc.h line 43
struct anonymous$21;

// tag-#anon#ST[U8'psid'|U8'ssid'|U16'length'|U8'credit'|U8'control']
// file io/hpmud/dot4.h line 48
struct anonymous;

// tag-#anon#UN[*{S64}$S64$'integer'|*{U8}$U8$'string'|*{U64}$U64$'objid'|*{U8}$U8$'bitstring'|*{SYM#tag-counter64#}$SYM#tag-counter64#$'counter64'|*{F32}$F32$'floatVal'|*{F64}$F64$'doubleVal']
// file /usr/include/net-snmp/types.h line 114
union anonymous$36;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'|ARR8{U16}$U16$'__u6_addr16'|ARR4{U32}$U32$'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous$14;

// tag-#anon#UN[ARR4{S8}$S8$'__size'|S32'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$33;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$19;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$18;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'|r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__']
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$15;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'|r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__']$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$17;

// tag-DBusConnection
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 51
struct DBusConnection;

// tag-DBusError
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 43
struct DBusError;

// tag-DBusMessage
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 44
struct DBusMessage;

// tag-FD_ID
// file io/hpmud/musb.h line 42
enum FD_ID { FD_NA=0, FD_7_1_2=1, FD_7_1_3=2, FD_7_1_4=3, FD_ff_1_1=4, FD_ff_2_1=5, FD_ff_3_1=6, FD_ff_ff_ff=7, FD_ff_d4_0=8, FD_ff_4_1=9, FD_ff_1_0=10, FD_ff_cc_0=11, FD_ff_2_10=12, FD_ff_9_1=13, MAX_FD=14 };

// tag-HPMUD_BUS_ID
// file io/hpmud/hpmud.h line 63
enum HPMUD_BUS_ID { HPMUD_BUS_NA=0, HPMUD_BUS_USB=1, HPMUD_BUS_PARALLEL=2, HPMUD_BUS_ALL=3 };

// tag-HPMUD_DEVICE_TYPE
// file io/hpmud/hpmud.h line 71
enum HPMUD_DEVICE_TYPE { HPMUD_AIO=0, HPMUD_PRINTER=1, HPMUD_SCANNER=2 };

// tag-HPMUD_IO_MODE
// file io/hpmud/hpmud.h line 52
enum HPMUD_IO_MODE { HPMUD_UNI_MODE=0, HPMUD_RAW_MODE=1, HPMUD_DOT4_MODE=3, HPMUD_DOT4_PHOENIX_MODE=4, HPMUD_DOT4_BRIDGE_MODE=5, HPMUD_MLC_GUSHER_MODE=6, HPMUD_MLC_MISER_MODE=7 };

// tag-HPMUD_PLUGIN_TYPE
// file io/hpmud/hpmud.h line 118
enum HPMUD_PLUGIN_TYPE { HPMUD_PLUGIN_TYPE_NONE=0, HPMUD_PLUGIN_TYPE_REQUIRED=1, HPMUD_PLUGIN_TYPE_OPTIONAL=2 };

// tag-HPMUD_RESULT
// file io/hpmud/hpmud.h line 30
enum HPMUD_RESULT { HPMUD_R_OK=0, HPMUD_R_INVALID_DEVICE=2, HPMUD_R_INVALID_DESCRIPTOR=3, HPMUD_R_INVALID_URI=4, HPMUD_R_INVALID_LENGTH=8, HPMUD_R_IO_ERROR=12, HPMUD_R_DEVICE_BUSY=21, HPMUD_R_INVALID_SN=28, HPMUD_R_INVALID_CHANNEL_ID=30, HPMUD_R_INVALID_STATE=31, HPMUD_R_INVALID_DEVICE_OPEN=37, HPMUD_R_INVALID_DEVICE_NODE=38, HPMUD_R_INVALID_IP=45, HPMUD_R_INVALID_IP_PORT=46, HPMUD_R_INVALID_TIMEOUT=47, HPMUD_R_DATFILE_ERROR=48, HPMUD_R_IO_TIMEOUT=49, HPMUD_R_INVALID_MDNS=50 };

// tag-HPMUD_SCANSRC
// file io/hpmud/hpmud.h line 92
enum HPMUD_SCANSRC { HPMUD_SCANSRC_NA=0, HPMUD_SCANSRC_FLATBED=1, HPMUD_SCANSRC_ADF=2, HPMUD_SCANSRC_CAMERA=4 };

// tag-HPMUD_SCANTYPE
// file io/hpmud/hpmud.h line 78
enum HPMUD_SCANTYPE { HPMUD_SCANTYPE_NA=0, HPMUD_SCANTYPE_SCL=1, HPMUD_SCANTYPE_PML=2, HPMUD_SCANTYPE_SOAP=3, HPMUD_SCANTYPE_MARVELL=4, HPMUD_SCANTYPE_SOAPHT=5, HPMUD_SCANTYPE_SCL_DUPLEX=6, HPMUD_SCANTYPE_LEDM=7, HPMUD_SCANTYPE_MARVELL2=8, HPMUD_SCANTYPE_ESCL=9 };

// tag-HPMUD_STATUSTYPE
// file io/hpmud/hpmud.h line 100
enum HPMUD_STATUSTYPE { HPMUD_STATUSTYPE_NA=0, HPMUD_STATUSTYPE_VSTATUS=1, HPMUD_STATUSTYPE_SFIELD=2, HPMUD_STATUSTYPE_PML=3, HPMUD_STATUSTYPE_EWS=6, HPMUD_STATUSTYPE_PJL=8, HPMUD_STATUSTYPE_PJLPML=9 };

// tag-HPMUD_SUPPORT_TYPE
// file io/hpmud/hpmud.h line 111
enum HPMUD_SUPPORT_TYPE { HPMUD_SUPPORT_TYPE_NONE=0, HPMUD_SUPPORT_TYPE_HPIJS=1, HPMUD_SUPPORT_TYPE_HPLIP=2 };

// tag-UTILS_CONF_RESULT
// file common/utils.h line 30
enum UTILS_CONF_RESULT { UTILS_CONF_OK=0, UTILS_CONF_FILE_NOT_FOUND=1, UTILS_CONF_SECTION_NOT_FOUND=2, UTILS_CONF_KEY_NOT_FOUND=3, UTILS_CONF_DATFILE_ERROR=4 };

// tag-UTILS_PLUGIN_LIBRARY_TYPE
// file common/utils.h line 47
enum UTILS_PLUGIN_LIBRARY_TYPE { UTILS_PRINT_PLUGIN_LIBRARY=0, UTILS_SCAN_PLUGIN_LIBRARY=1, UTILS_FAX_PLUGIN_LIBRARY=2 };

// tag-UTILS_PLUGIN_STATUS
// file common/utils.h line 40
enum UTILS_PLUGIN_STATUS { UTILS_PLUGIN_STATUS_OK=0, UTILS_PLUGIN_STATUS_MISMATCH=1, UTILS_PLUGIN_STATUS_NOT_INSTALLED=2 };

// tag-_DNS_PKT_HEADER
// file protocol/discovery/mdns.h line 62
struct _DNS_PKT_HEADER;

// tag-_DNS_RECORD
// file protocol/discovery/mdns.h line 54
struct _DNS_RECORD;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_mud_channel
// file io/hpmud/musb.h line 97
struct _mud_channel;

// tag-_mud_channel_vf
// file io/hpmud/hpmudi.h line 132
struct _mud_channel_vf;

// tag-_mud_device
// file io/hpmud/musb.h line 96
struct _mud_device;

// tag-_mud_device_vf
// file io/hpmud/musb.h line 99
struct _mud_device_vf;

// tag-counter64
// file /usr/include/net-snmp/types.h line 119
struct counter64;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-hpmud_dstat
// file io/hpmud/hpmud.h line 157
struct hpmud_dstat;

// tag-hpmud_model_attributes
// file io/hpmud/hpmud.h line 166
struct hpmud_model_attributes;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-ip_mreq
// file /usr/include/netinet/in.h line 264
struct ip_mreq;

// tag-libusb_config_descriptor
// file /usr/include/libusb-1.0/libusb.h line 643
struct libusb_config_descriptor;

// tag-libusb_context
// file /usr/include/libusb-1.0/libusb.h line 898
struct libusb_context;

// tag-libusb_device
// file /usr/include/libusb-1.0/libusb.h line 899
struct libusb_device;

// tag-libusb_device_descriptor
// file /usr/include/libusb-1.0/libusb.h line 477
struct libusb_device_descriptor;

// tag-libusb_device_handle
// file /usr/include/libusb-1.0/libusb.h line 900
struct libusb_device_handle;

// tag-libusb_endpoint_descriptor
// file /usr/include/libusb-1.0/libusb.h line 531
struct libusb_endpoint_descriptor;

// tag-libusb_endpoint_direction
// file /usr/include/libusb-1.0/libusb.h line 318
enum libusb_endpoint_direction { LIBUSB_ENDPOINT_IN=128, LIBUSB_ENDPOINT_OUT=0 };

// tag-libusb_interface
// file /usr/include/libusb-1.0/libusb.h line 629
struct libusb_interface;

// tag-libusb_interface_descriptor
// file /usr/include/libusb-1.0/libusb.h line 581
struct libusb_interface_descriptor;

// tag-libusb_transfer_type
// file /usr/include/libusb-1.0/libusb.h line 332
enum libusb_transfer_type { LIBUSB_TRANSFER_TYPE_CONTROL=0, LIBUSB_TRANSFER_TYPE_ISOCHRONOUS=1, LIBUSB_TRANSFER_TYPE_BULK=2, LIBUSB_TRANSFER_TYPE_INTERRUPT=3, LIBUSB_TRANSFER_TYPE_BULK_STREAM=4 };

// tag-list_head
// file io/hpmud/list.h line 9
struct list_head;

// tag-netsnmp_container_s
// file /usr/include/net-snmp/types.h line 284
struct netsnmp_container_s;

// tag-netsnmp_iterator_s
// file /usr/include/net-snmp/library/container.h line 42
struct netsnmp_iterator_s;

// tag-netsnmp_void_array_s
// file /usr/include/net-snmp/library/types.h line 17
struct netsnmp_void_array_s;

// tag-pjl_attributes
// file prnt/backend/hp.c line 62
struct pjl_attributes;

// tag-ppdev_frob_struct
// file /usr/include/linux/ppdev.h line 30
struct ppdev_frob_struct;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-snmp_pdu
// file /usr/include/net-snmp/types.h line 168
struct snmp_pdu;

// tag-snmp_session
// file /usr/include/net-snmp/types.h line 273
struct snmp_session;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-variable_list
// file /usr/include/net-snmp/types.h line 138
struct variable_list;

#ifndef NULL
#define NULL ((void*)0)
#endif

// CopyLabel
// file io/hpmud/model.c line 157
static signed int CopyLabel(char *label, char *buf, signed int bufSize);
// DelList
// file io/hpmud/model.c line 338
static signed int DelList();
// Dot4CloseChannel
// file io/hpmud/dot4.c line 630
signed int Dot4CloseChannel(struct _mud_channel *pc, signed int fd);
// Dot4Credit
// file io/hpmud/dot4.c line 668
signed int Dot4Credit(struct _mud_channel *pc, signed int fd, unsigned short int credit);
// Dot4CreditRequest
// file io/hpmud/dot4.c line 709
signed int Dot4CreditRequest(struct _mud_channel *pc, signed int fd, unsigned short int credit);
// Dot4ExecReverseCmd
// file io/hpmud/dot4.c line 47
static signed int Dot4ExecReverseCmd(struct _mud_channel *pc, signed int fd, unsigned char *buf);
// Dot4Exit
// file io/hpmud/dot4.c line 341
signed int Dot4Exit(struct _mud_channel *pc, signed int fd);
// Dot4ForwardData
// file io/hpmud/dot4.c line 422
signed int Dot4ForwardData(struct _mud_channel *pc, signed int fd, const void *buf, signed int size, signed int usec_timeout);
// Dot4ForwardReply
// file io/hpmud/dot4.c line 34
static signed int Dot4ForwardReply(struct _mud_channel *pc, signed int fd, unsigned char *buf, signed int size);
// Dot4GetSocket
// file io/hpmud/dot4.c line 377
signed int Dot4GetSocket(struct _mud_channel *pc, signed int fd);
// Dot4Init
// file io/hpmud/dot4.c line 277
signed int Dot4Init(struct _mud_channel *pc, signed int fd);
// Dot4OpenChannel
// file io/hpmud/dot4.c line 585
signed int Dot4OpenChannel(struct _mud_channel *pc, signed int fd);
// Dot4ReverseCmd
// file io/hpmud/dot4.c line 153
signed int Dot4ReverseCmd(struct _mud_channel *pc, signed int fd);
// Dot4ReverseData
// file io/hpmud/dot4.c line 453
signed int Dot4ReverseData(struct _mud_channel *pc, signed int fd, void *buf, signed int length, signed int usec_timeout);
// Dot4ReverseReply
// file io/hpmud/dot4.c line 212
static signed int Dot4ReverseReply(struct _mud_channel *pc, signed int fd, unsigned char *buf, signed int bufsize);
// GetPair
// file io/hpmud/model.c line 56
static signed int GetPair(char *buf, signed int buf_len, char *key, char *value, char **tail);
// GetPair$link1
// file common/utils.c line 10
static signed int GetPair$link1(char *buf$link1, signed int buf_len$link1, char *key$link1, char *value$link1, char **tail$link1);
// GetSnmp
// file io/hpmud/pml.c line 212
signed int GetSnmp(const char *ip, signed int port, const char *szoid, void *buffer, unsigned int size, signed int *type, signed int *pml_result, signed int *result);
// MlcCloseChannel
// file io/hpmud/mlc.c line 654
signed int MlcCloseChannel(struct _mud_channel *pc, signed int fd);
// MlcConfigSocket
// file io/hpmud/mlc.c line 403
signed int MlcConfigSocket(struct _mud_channel *pc, signed int fd);
// MlcCredit
// file io/hpmud/mlc.c line 691
signed int MlcCredit(struct _mud_channel *pc, signed int fd, unsigned short int credit);
// MlcCreditRequest
// file io/hpmud/mlc.c line 731
signed int MlcCreditRequest(struct _mud_channel *pc, signed int fd, unsigned short int credit);
// MlcExecReverseCmd
// file io/hpmud/mlc.c line 66
static signed int MlcExecReverseCmd(struct _mud_channel *pc, signed int fd, unsigned char *buf);
// MlcExit
// file io/hpmud/mlc.c line 368
signed int MlcExit(struct _mud_channel *pc, signed int fd);
// MlcForwardData
// file io/hpmud/mlc.c line 449
signed int MlcForwardData(struct _mud_channel *pc, signed int fd, const void *buf, signed int size, signed int usec_timeout);
// MlcForwardReply
// file io/hpmud/mlc.c line 53
static signed int MlcForwardReply(struct _mud_channel *pc, signed int fd, unsigned char *buf, signed int size);
// MlcInit
// file io/hpmud/mlc.c line 306
signed int MlcInit(struct _mud_channel *pc, signed int fd);
// MlcOpenChannel
// file io/hpmud/mlc.c line 613
signed int MlcOpenChannel(struct _mud_channel *pc, signed int fd);
// MlcReverseCmd
// file io/hpmud/mlc.c line 160
signed int MlcReverseCmd(struct _mud_channel *pc, signed int fd);
// MlcReverseData
// file io/hpmud/mlc.c line 480
signed int MlcReverseData(struct _mud_channel *pc, signed int fd, void *buf, signed int length, signed int usec_timeout);
// MlcReverseReply
// file io/hpmud/mlc.c line 219
static signed int MlcReverseReply(struct _mud_channel *pc, signed int fd, unsigned char *buf, signed int bufsize);
// ParseFile
// file io/hpmud/model.c line 402
static signed int ParseFile(char *datFile, char *model, char *attr, signed int attrSize, signed int *bytes_read);
// ParseInc
// file io/hpmud/model.c line 353
static signed int ParseInc(char *incFile);
// PmlOidToHex
// file io/hpmud/pml.c line 49
static signed int PmlOidToHex(const char *szoid, unsigned char *oid, signed int oidSize);
// ReadConfig
// file io/hpmud/model.c line 94
static signed int ReadConfig();
// ReadReply
// file io/hpmud/jd.c line 66
static signed int ReadReply(struct _mud_channel *pc);
// RegisterLabel
// file io/hpmud/model.c line 249
static signed int RegisterLabel(struct _IO_FILE *fp, char *incFile, char *label);
// ResolveAttributes
// file io/hpmud/model.c line 193
static signed int ResolveAttributes(struct _IO_FILE *fp, char *attr, signed int attrSize);
// SetSnmp
// file io/hpmud/pml.c line 145
static signed int SetSnmp(const char *ip, signed int port, const char *szoid, signed int type, void *buffer, unsigned int size, signed int *pml_result, signed int *result);
// SnmpErrorToPml
// file io/hpmud/pml.c line 115
static signed int SnmpErrorToPml(signed int snmp_error);
// SnmpToPml
// file io/hpmud/pml.c line 79
static signed int SnmpToPml(const char *snmp_oid, unsigned char *oid, signed int oidSize);
// UnRegisterLabel
// file io/hpmud/model.c line 325
static signed int UnRegisterLabel(struct anonymous$32 *pl);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __list_add
// file io/hpmud/list.h line 23
static inline void __list_add(struct list_head *new_entry, struct list_head *prev, struct list_head *next);
// __list_del
// file io/hpmud/list.h line 66
static inline void __list_del(struct list_head *prev, struct list_head *next);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// bridge_chip_down
// file io/hpmud/musb.c line 319
static signed int bridge_chip_down(struct anonymous$20 *pfd);
// bridge_chip_up
// file io/hpmud/musb.c line 221
static signed int bridge_chip_up(struct anonymous$20 *pfd);
// bug
// file prnt/backend/hp.c line 162
static signed int bug(const char *fmt, ...);
// bzero
// file /usr/include/string.h line 458
extern void bzero(void *, unsigned long int);
// chmod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 283
extern signed int chmod(const char *, unsigned int);
// claim_id_interface
// file io/hpmud/musb.c line 567
static signed int claim_id_interface(struct libusb_device *dev);
// claim_interface
// file io/hpmud/musb.c line 496
static signed int claim_interface(struct libusb_device *dev, struct anonymous$20 *pfd);
// claim_pp
// file io/hpmud/pp.c line 578
static signed int claim_pp(signed int fd);
// close
// file protocol/discovery/mdns.c line 123 function mdns_open_socket
signed int close(signed int);
// compat_write
// file io/hpmud/pp.c line 543
static signed int compat_write(signed int fd, const void *buffer, signed int size);
// compat_write_data
// file io/hpmud/pp.c line 510
static signed int compat_write_data(signed int fd, unsigned char data);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous$17, unsigned int);
// createTempFile
// file common/utils.h line 156
signed int createTempFile(char *szFileName, struct _IO_FILE **pFilePtr);
// create_out_file
// file prnt/backend/hp.c line 642
static struct _IO_FILE * create_out_file(char *job_id, char *user_name);
// cut_buf
// file io/hpmud/mlc.c line 29
signed int cut_buf(struct _mud_channel *pc, char *buf, signed int size);
// dbus_bus_get
// file /usr/include/dbus-1.0/dbus/dbus-bus.h line 40
struct DBusConnection * dbus_bus_get(enum anonymous$34, struct DBusError *);
// dbus_connection_flush
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 200
void dbus_connection_flush(struct DBusConnection *);
// dbus_connection_send
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 224
unsigned int dbus_connection_send(struct DBusConnection *, struct DBusMessage *, unsigned int *);
// dbus_error_free
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 67
void dbus_error_free(struct DBusError *);
// dbus_error_init
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 65
void dbus_error_init(struct DBusError *);
// dbus_error_is_set
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 84
unsigned int dbus_error_is_set(const struct DBusError *);
// dbus_message_append_args
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 189
unsigned int dbus_message_append_args(struct DBusMessage *, signed int, ...);
// dbus_message_new_signal
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 79
struct DBusMessage * dbus_message_new_signal(const char *, const char *, const char *);
// dbus_message_unref
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 98
void dbus_message_unref(struct DBusMessage *);
// del_channel
// file io/hpmud/jd.c line 140
static signed int del_channel(struct _mud_device *pd, struct _mud_channel *pc);
// del_channel$link1
// file io/hpmud/pp.c line 711
static signed int del_channel$link1(struct _mud_device *pd$link1, struct _mud_channel *pc$link1);
// del_channel$link2
// file io/hpmud/musb.c line 967
static signed int del_channel$link2(struct _mud_device *pd$link2, struct _mud_channel *pc$link2);
// del_device
// file io/hpmud/hpmud.c line 352
static signed int del_device(signed int index);
// detach
// file io/hpmud/musb.c line 384
static signed int detach(struct libusb_device_handle *hd, signed int interface);
// device_cleanup
// file io/hpmud/hpmud.c line 364
signed int device_cleanup(struct anonymous$28 *ps);
// device_discovery
// file prnt/backend/hp.c line 492
static signed int device_discovery();
// device_event
// file prnt/backend/hp.c line 519
static signed int device_event(const char *dev, const char *printer, signed int code, const char *username, const char *jobid, const char *title);
// device_id
// file io/hpmud/jd.c line 82
static signed int device_id(const char *iporhostname, signed int port, char *buffer, signed int size);
// device_id$link1
// file io/hpmud/pp.c line 618
static signed int device_id$link1(signed int fd, char *buffer$link1, signed int size$link1);
// device_id$link2
// file io/hpmud/musb.c line 741
static signed int device_id$link2(signed int fd$link1, unsigned char *buffer$link2, signed int size$link2);
// device_status
// file io/hpmud/pp.c line 644
static signed int device_status(signed int fd, unsigned int *status);
// device_status$link1
// file io/hpmud/musb.c line 786
static signed int device_status$link1(signed int fd$link1, unsigned int *status$link1);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// ecp_fwd_to_rev
// file io/hpmud/pp.c line 187
static signed int ecp_fwd_to_rev(signed int fd);
// ecp_is_fwd
// file io/hpmud/pp.c line 146
static signed int ecp_is_fwd(signed int fd);
// ecp_is_rev
// file io/hpmud/pp.c line 156
static signed int ecp_is_rev(signed int fd);
// ecp_read
// file io/hpmud/pp.c line 362
static signed int ecp_read(signed int fd, void *buffer, signed int size, signed int usec);
// ecp_read_data
// file io/hpmud/pp.c line 332
static signed int ecp_read_data(signed int fd, unsigned char *data);
// ecp_rev_to_fwd
// file io/hpmud/pp.c line 166
static signed int ecp_rev_to_fwd(signed int fd);
// ecp_write
// file io/hpmud/pp.c line 385
static signed int ecp_write(signed int fd, const void *buffer, signed int size);
// ecp_write_addr
// file io/hpmud/pp.c line 211
static signed int ecp_write_addr(signed int fd, unsigned char data);
// ecp_write_data
// file io/hpmud/pp.c line 272
static signed int ecp_write_data(signed int fd, unsigned char data);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file protocol/discovery/mdns.c line 411 function mdns_rr_cleanup
void free(void *);
// frob_control
// file io/hpmud/pp.c line 70
static signed int frob_control(signed int fd, unsigned char mask, unsigned char val);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// generalize_model
// file io/hpmud/hpmud.c line 107
signed int generalize_model(const char *sz, char *buf, signed int bufSize);
// generalize_serial
// file io/hpmud/hpmud.c line 143
signed int generalize_serial(const char *sz, char *buf, signed int bufSize);
// getHPLogLevel
// file common/utils.h line 157
signed int getHPLogLevel();
// get_conf
// file common/utils.c line 50
enum UTILS_CONF_RESULT get_conf(const char *section, const char *key, char *value, signed int value_size);
// get_ep
// file io/hpmud/musb.c line 441
static signed int get_ep(struct libusb_device *dev, signed int config, signed int interface, signed int altset, enum libusb_transfer_type type, enum libusb_endpoint_direction epdir);
// get_in_ep
// file io/hpmud/musb.c line 485
static signed int get_in_ep(struct libusb_device *dev, signed int config, signed int interface, signed int altset, enum libusb_transfer_type type);
// get_interface
// file io/hpmud/musb.c line 401
static signed int get_interface(struct libusb_device *dev, enum FD_ID index, struct anonymous$20 *pfd);
// get_key_value
// file common/utils.c line 56
enum UTILS_CONF_RESULT get_key_value(const char *file, const char *section, const char *key, char *value, signed int value_size);
// get_library_symbol
// file common/utils.c line 193
void * get_library_symbol(void *pLibHandler, const char *szSymbol);
// get_libusb_device
// file io/hpmud/musb.c line 688
static struct libusb_device * get_libusb_device(const char *uri);
// get_out_ep
// file io/hpmud/musb.c line 490
static signed int get_out_ep(struct libusb_device *dev, signed int config, signed int interface, signed int altset, enum libusb_transfer_type type);
// get_pjl_input
// file prnt/backend/hp.c line 279
static enum HPMUD_RESULT get_pjl_input(signed int dd, signed int cd, char *buf, signed int buf_size, signed int sec_timeout, signed int *bytes_read);
// get_printer_status
// file prnt/backend/hp.c line 403
static signed int get_printer_status(signed int dd, signed int cd, struct pjl_attributes *pa);
// get_string_descriptor
// file io/hpmud/musb.c line 128
static signed int get_string_descriptor(struct libusb_device_handle *dev_handle, signed int index, char *buf, unsigned long int buflen);
// get_uri_serial
// file io/hpmud/hpmud.c line 166
signed int get_uri_serial(const char *uri, char *buf, signed int bufSize);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// hpmud_close_channel
// file io/hpmud/hpmud.h line 289
enum HPMUD_RESULT hpmud_close_channel(signed int dd, signed int cd);
// hpmud_close_device
// file io/hpmud/hpmud.h line 204
enum HPMUD_RESULT hpmud_close_device(signed int dd);
// hpmud_get_device_id
// file io/hpmud/hpmud.h line 220
enum HPMUD_RESULT hpmud_get_device_id(signed int dd, char *buf, signed int size, signed int *bytes_read);
// hpmud_get_device_status
// file io/hpmud/hpmud.h line 232
enum HPMUD_RESULT hpmud_get_device_status(signed int dd, unsigned int *status);
// hpmud_get_dstat
// file io/hpmud/hpmud.c line 749
enum HPMUD_RESULT hpmud_get_dstat(signed int dd, struct hpmud_dstat *ds);
// hpmud_get_model
// file io/hpmud/hpmud.c line 408
signed int hpmud_get_model(const char *id, char *buf, signed int buf_size);
// hpmud_get_model_attributes
// file io/hpmud/model.c line 510
enum HPMUD_RESULT hpmud_get_model_attributes(char *uri, char *attr, signed int attrSize, signed int *bytes_read);
// hpmud_get_pml
// file io/hpmud/pml.c line 408
enum HPMUD_RESULT hpmud_get_pml(signed int device, signed int channel, const char *snmp_oid, void *buf, signed int buf_size, signed int *bytes_read, signed int *type, signed int *pml_result);
// hpmud_get_raw_model
// file io/hpmud/hpmud.c line 428
signed int hpmud_get_raw_model(char *id, char *raw, signed int rawSize);
// hpmud_get_uri_datalink
// file io/hpmud/hpmud.c line 478
signed int hpmud_get_uri_datalink(const char *uri, char *buf, signed int buf_size);
// hpmud_get_uri_model
// file io/hpmud/hpmud.c line 453
signed int hpmud_get_uri_model(const char *uri, char *buf, signed int buf_size);
// hpmud_make_mdns_uri
// file io/hpmud/jd.c line 740
enum HPMUD_RESULT hpmud_make_mdns_uri(const char *host, signed int port, char *uri, signed int uri_size, signed int *bytes_read);
// hpmud_make_net_uri
// file io/hpmud/jd.c line 700
enum HPMUD_RESULT hpmud_make_net_uri(const char *ip, signed int port, char *uri, signed int uri_size, signed int *bytes_read);
// hpmud_make_par_uri
// file io/hpmud/pp.c line 1266
enum HPMUD_RESULT hpmud_make_par_uri(const char *dnode, char *uri, signed int uri_size, signed int *bytes_read);
// hpmud_make_usb_serial_uri
// file io/hpmud/musb.c line 2299
enum HPMUD_RESULT hpmud_make_usb_serial_uri(const char *sn, char *uri, signed int uri_size, signed int *bytes_read);
// hpmud_make_usb_uri
// file io/hpmud/musb.c line 2166
enum HPMUD_RESULT hpmud_make_usb_uri(const char *busnum, const char *devnum, char *uri, signed int uri_size, signed int *bytes_read);
// hpmud_open_channel
// file io/hpmud/hpmud.h line 277
enum HPMUD_RESULT hpmud_open_channel(signed int dd, const char *channel_name, signed int *cd);
// hpmud_open_device
// file io/hpmud/hpmud.h line 193
enum HPMUD_RESULT hpmud_open_device(const char *uri, enum HPMUD_IO_MODE iomode, signed int *dd);
// hpmud_probe_devices
// file io/hpmud/hpmud.c line 616
enum HPMUD_RESULT hpmud_probe_devices(enum HPMUD_BUS_ID bus, char *buf, signed int buf_size, signed int *cnt, signed int *bytes_read);
// hpmud_probe_printers
// file io/hpmud/hpmud.h line 262
enum HPMUD_RESULT hpmud_probe_printers(enum HPMUD_BUS_ID bus, char *buf, signed int buf_size, signed int *cnt, signed int *bytes_read);
// hpmud_query_model
// file io/hpmud/hpmud.h line 471
enum HPMUD_RESULT hpmud_query_model(char *uri, struct hpmud_model_attributes *ma);
// hpmud_read_channel
// file io/hpmud/hpmud.h line 325
enum HPMUD_RESULT hpmud_read_channel(signed int dd, signed int cd, void *buf, signed int size, signed int sec_timeout, signed int *bytes_read);
// hpmud_set_pml
// file io/hpmud/pml.c line 316
enum HPMUD_RESULT hpmud_set_pml(signed int device, signed int channel, const char *snmp_oid, signed int type, void *data, signed int data_size, signed int *pml_result);
// hpmud_write_channel
// file io/hpmud/hpmud.h line 307
enum HPMUD_RESULT hpmud_write_channel(signed int dd, signed int cd, const void *buf, signed int size, signed int sec_timeout, signed int *bytes_wrote);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// init_dbus
// file prnt/backend/hp.c line 557
signed int init_dbus(void);
// init_snmp
// file /usr/include/net-snmp/library/snmp_api.h line 366
extern void init_snmp(const char *);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// is_hp
// file io/hpmud/hpmud.c line 86
signed int is_hp(const char *id);
// is_serial
// file io/hpmud/musb.c line 640
static signed int is_serial(struct libusb_device *dev, const char *sn, char *model, signed int model_size);
// is_uri
// file io/hpmud/musb.c line 585
static signed int is_uri(struct libusb_device *dev, const char *uri);
// jd_channel_close
// file io/hpmud/jd.c line 319
enum HPMUD_RESULT jd_channel_close(struct _mud_device *pd, struct _mud_channel *pc);
// jd_channel_open
// file io/hpmud/jd.c line 290
enum HPMUD_RESULT jd_channel_open(struct _mud_device *pd, const char *sn, signed int *cd);
// jd_channel_read
// file io/hpmud/jd.c line 274
enum HPMUD_RESULT jd_channel_read(struct _mud_device *pd, struct _mud_channel *pc, void *buf, signed int length, signed int sec_timeout, signed int *bytes_read);
// jd_channel_write
// file io/hpmud/jd.c line 264
enum HPMUD_RESULT jd_channel_write(struct _mud_device *pd, struct _mud_channel *pc, const void *buf, signed int length, signed int sec_timeout, signed int *bytes_wrote);
// jd_close
// file io/hpmud/jd.c line 227
enum HPMUD_RESULT jd_close(struct _mud_device *pd);
// jd_get_device_id
// file io/hpmud/jd.c line 238
enum HPMUD_RESULT jd_get_device_id(struct _mud_device *pd, char *buf, signed int size, signed int *len);
// jd_get_device_status
// file io/hpmud/jd.c line 258
enum HPMUD_RESULT jd_get_device_status(struct _mud_device *pd, unsigned int *status);
// jd_open
// file io/hpmud/jd.c line 156
enum HPMUD_RESULT jd_open(struct _mud_device *pd);
// jd_s_channel_close
// file io/hpmud/jd.c line 567
enum HPMUD_RESULT jd_s_channel_close(struct _mud_channel *pc);
// jd_s_channel_open
// file io/hpmud/jd.c line 335
enum HPMUD_RESULT jd_s_channel_open(struct _mud_channel *pc);
// jd_s_channel_read
// file io/hpmud/jd.c line 642
enum HPMUD_RESULT jd_s_channel_read(struct _mud_channel *pc, void *buf, signed int length, signed int sec_timeout, signed int *bytes_read);
// jd_s_channel_write
// file io/hpmud/jd.c line 582
enum HPMUD_RESULT jd_s_channel_write(struct _mud_channel *pc, const void *buf, signed int length, signed int sec_timeout, signed int *bytes_wrote);
// libusb_bulk_read
// file io/hpmud/musb.c line 905
static signed int libusb_bulk_read(struct libusb_device_handle *dev, signed int ep, char *bytes, signed int size, signed int timeout);
// libusb_bulk_transfer
// file /usr/include/libusb-1.0/libusb.h line 1744
signed int libusb_bulk_transfer(struct libusb_device_handle *, unsigned char, unsigned char *, signed int, signed int *, unsigned int);
// libusb_bulk_write
// file io/hpmud/musb.c line 913
static signed int libusb_bulk_write(struct libusb_device_handle *dev, signed int ep, char *bytes, signed int size, signed int timeout);
// libusb_claim_interface
// file /usr/include/libusb-1.0/libusb.h line 1376
signed int libusb_claim_interface(struct libusb_device_handle *, signed int);
// libusb_close
// file /usr/include/libusb-1.0/libusb.h line 1371
void libusb_close(struct libusb_device_handle *);
// libusb_control_transfer
// file /usr/include/libusb-1.0/libusb.h line 1740
signed int libusb_control_transfer(struct libusb_device_handle *, unsigned char, unsigned char, unsigned short int, unsigned short int, unsigned char *, unsigned short int, unsigned int);
// libusb_detach_kernel_driver
// file /usr/include/libusb-1.0/libusb.h line 1397
signed int libusb_detach_kernel_driver(struct libusb_device_handle *, signed int);
// libusb_exit
// file /usr/include/libusb-1.0/libusb.h line 1304
void libusb_exit(struct libusb_context *);
// libusb_free_config_descriptor
// file /usr/include/libusb-1.0/libusb.h line 1329
void libusb_free_config_descriptor(struct libusb_config_descriptor *);
// libusb_free_device_list
// file /usr/include/libusb-1.0/libusb.h line 1314
void libusb_free_device_list(struct libusb_device **, signed int);
// libusb_get_bus_number
// file /usr/include/libusb-1.0/libusb.h line 1357
unsigned char libusb_get_bus_number(struct libusb_device *);
// libusb_get_config_descriptor
// file /usr/include/libusb-1.0/libusb.h line 1325
signed int libusb_get_config_descriptor(struct libusb_device *, unsigned char, struct libusb_config_descriptor **);
// libusb_get_device_address
// file /usr/include/libusb-1.0/libusb.h line 1363
unsigned char libusb_get_device_address(struct libusb_device *);
// libusb_get_device_descriptor
// file /usr/include/libusb-1.0/libusb.h line 1321
signed int libusb_get_device_descriptor(struct libusb_device *, struct libusb_device_descriptor *);
// libusb_get_device_list
// file /usr/include/libusb-1.0/libusb.h line 1312
signed long int libusb_get_device_list(struct libusb_context *, struct libusb_device ***);
// libusb_init
// file /usr/include/libusb-1.0/libusb.h line 1303
signed int libusb_init(struct libusb_context **);
// libusb_kernel_driver_active
// file /usr/include/libusb-1.0/libusb.h line 1395
signed int libusb_kernel_driver_active(struct libusb_device_handle *, signed int);
// libusb_open
// file /usr/include/libusb-1.0/libusb.h line 1370
signed int libusb_open(struct libusb_device *, struct libusb_device_handle **);
// libusb_release_interface
// file /usr/include/libusb-1.0/libusb.h line 1378
signed int libusb_release_interface(struct libusb_device_handle *, signed int);
// libusb_set_interface_alt_setting
// file /usr/include/libusb-1.0/libusb.h line 1384
signed int libusb_set_interface_alt_setting(struct libusb_device_handle *, signed int, signed int);
// list_add
// file io/hpmud/list.h line 41
static inline void list_add(struct list_head *new_entry, struct list_head *head);
// list_del
// file io/hpmud/list.h line 78
static inline void list_del(struct list_head *entry);
// load_library
// file common/utils.c line 177
void * load_library(const char *szLibraryFile);
// load_plugin_library
// file common/utils.c line 137
void * load_plugin_library(enum UTILS_PLUGIN_LIBRARY_TYPE eLibraryType, const char *szPluginName);
// loop_test
// file prnt/backend/hp.c line 588
static signed int loop_test(signed int dd, signed int cd, struct pjl_attributes *pa, const char *dev, const char *printer, const char *username, const char *jobid, const char *title);
// lseek
// file /usr/include/unistd.h line 334
extern signed long int lseek(signed int, signed long int, signed int);
// malloc
// file protocol/discovery/mdns.c line 346 function mdns_read_responses
void * malloc(unsigned long int);
// map_ipp_printer_state_reason
// file prnt/backend/hp.c line 231
static signed int map_ipp_printer_state_reason(signed int status, const char **state_msg);
// mdns_convert_name_to_dns
// file protocol/discovery/mdns.c line 37
static signed int mdns_convert_name_to_dns(const char *name, signed int name_size, char *dns_name);
// mdns_create_query_packet
// file protocol/discovery/mdns.c line 135
static void mdns_create_query_packet(char *fqdn, signed int query_type, char *querybuf, signed int *length);
// mdns_lookup
// file protocol/discovery/mdns.h line 87
signed int mdns_lookup(char *hostname, unsigned char *ip);
// mdns_open_socket
// file protocol/discovery/mdns.c line 70
static signed int mdns_open_socket(signed int *psocket);
// mdns_parse_respponse
// file protocol/discovery/mdns.c line 250
static void mdns_parse_respponse(unsigned char *Response, struct _DNS_RECORD *rr);
// mdns_probe_nw_scanners
// file protocol/discovery/mdns.c line 416
signed int mdns_probe_nw_scanners(char *uris_buf, signed int buf_size, signed int *count);
// mdns_readMDL
// file protocol/discovery/mdns.c line 204
static unsigned char * mdns_readMDL(unsigned char *p, unsigned char *normalized_mdl, signed int len);
// mdns_readName
// file protocol/discovery/mdns.c line 177
static signed int mdns_readName(unsigned char *start, unsigned char *Response, char *buf);
// mdns_read_header
// file protocol/discovery/mdns.c line 236
static void mdns_read_header(char *Response, struct _DNS_PKT_HEADER *h);
// mdns_read_responses
// file protocol/discovery/mdns.c line 326
static struct _DNS_RECORD * mdns_read_responses(signed int udp_socket, signed int mode);
// mdns_read_single_response
// file protocol/discovery/mdns.c line 295
static signed int mdns_read_single_response(signed int udp_socket, char *recvbuffer, signed int recvbufsize);
// mdns_rr_cleanup
// file protocol/discovery/mdns.c line 403
static void mdns_rr_cleanup(struct _DNS_RECORD *rr);
// mdns_send_query
// file protocol/discovery/mdns.c line 155
static signed int mdns_send_query(signed int udp_socket, char *fqdn, signed int query_type);
// mdns_update_uris
// file protocol/discovery/mdns.c line 371
static signed int mdns_update_uris(struct _DNS_RECORD *rr, char *uris_buf, signed int buf_size, signed int *count);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkstemp
// file /usr/include/stdlib.h line 619
extern signed int mkstemp(char *);
// musb_channel_close
// file io/hpmud/musb.c line 1380
enum HPMUD_RESULT musb_channel_close(struct _mud_device *pd, struct _mud_channel *pc);
// musb_channel_open
// file io/hpmud/musb.c line 1351
enum HPMUD_RESULT musb_channel_open(struct _mud_device *pd, const char *sn, signed int *cd);
// musb_channel_read
// file io/hpmud/musb.h line 110
enum HPMUD_RESULT musb_channel_read(struct _mud_device *pd, struct _mud_channel *pc, void *buf, signed int length, signed int sec_timeout, signed int *bytes_read);
// musb_channel_write
// file io/hpmud/musb.h line 109
enum HPMUD_RESULT musb_channel_write(struct _mud_device *pd, struct _mud_channel *pc, const void *buf, signed int length, signed int sec_timeout, signed int *bytes_wrote);
// musb_close
// file io/hpmud/musb.c line 1188
enum HPMUD_RESULT musb_close(struct _mud_device *pd);
// musb_comp_channel_open
// file io/hpmud/musb.c line 1512
enum HPMUD_RESULT musb_comp_channel_open(struct _mud_channel *pc);
// musb_dot4_channel_close
// file io/hpmud/musb.c line 1871
enum HPMUD_RESULT musb_dot4_channel_close(struct _mud_channel *pc);
// musb_dot4_channel_open
// file io/hpmud/musb.c line 1791
enum HPMUD_RESULT musb_dot4_channel_open(struct _mud_channel *pc);
// musb_dot4_channel_read
// file io/hpmud/musb.h line 127
enum HPMUD_RESULT musb_dot4_channel_read(struct _mud_channel *pc, void *buf, signed int length, signed int sec_timeout, signed int *bytes_read);
// musb_dot4_channel_write
// file io/hpmud/musb.h line 126
enum HPMUD_RESULT musb_dot4_channel_write(struct _mud_channel *pc, const void *buf, signed int length, signed int sec_timeout, signed int *bytes_wrote);
// musb_get_device_id
// file io/hpmud/musb.c line 1217
enum HPMUD_RESULT musb_get_device_id(struct _mud_device *pd, char *buf, signed int size, signed int *len);
// musb_get_device_status
// file io/hpmud/musb.c line 1273
enum HPMUD_RESULT musb_get_device_status(struct _mud_device *pd, unsigned int *status);
// musb_mlc_channel_close
// file io/hpmud/musb.c line 1639
enum HPMUD_RESULT musb_mlc_channel_close(struct _mud_channel *pc);
// musb_mlc_channel_open
// file io/hpmud/musb.c line 1580
enum HPMUD_RESULT musb_mlc_channel_open(struct _mud_channel *pc);
// musb_mlc_channel_read
// file io/hpmud/musb.h line 122
enum HPMUD_RESULT musb_mlc_channel_read(struct _mud_channel *pc, void *buf, signed int length, signed int sec_timeout, signed int *bytes_read);
// musb_mlc_channel_write
// file io/hpmud/musb.h line 121
enum HPMUD_RESULT musb_mlc_channel_write(struct _mud_channel *pc, const void *buf, signed int length, signed int sec_timeout, signed int *bytes_wrote);
// musb_open
// file io/hpmud/musb.c line 1143
enum HPMUD_RESULT musb_open(struct _mud_device *pd);
// musb_probe_devices
// file io/hpmud/musb.h line 129
signed int musb_probe_devices(char *lst, signed int lst_size, signed int *cnt, enum HPMUD_DEVICE_TYPE devtype);
// musb_raw_channel_close
// file io/hpmud/musb.c line 1414
enum HPMUD_RESULT musb_raw_channel_close(struct _mud_channel *pc);
// musb_raw_channel_open
// file io/hpmud/musb.c line 1396
enum HPMUD_RESULT musb_raw_channel_open(struct _mud_channel *pc);
// musb_raw_channel_read
// file io/hpmud/musb.h line 115
enum HPMUD_RESULT musb_raw_channel_read(struct _mud_channel *pc, void *buf, signed int length, signed int sec_timeout, signed int *bytes_read);
// musb_raw_channel_write
// file io/hpmud/musb.h line 114
enum HPMUD_RESULT musb_raw_channel_write(struct _mud_channel *pc, const void *buf, signed int length, signed int sec_timeout, signed int *bytes_wrote);
// musb_read
// file io/hpmud/musb.c line 1083
signed int musb_read(signed int fd, void *buf, signed int size, signed int usec);
// musb_write
// file io/hpmud/musb.c line 1009
signed int musb_write(signed int fd, const void *buf, signed int size, signed int usec);
// new_channel
// file io/hpmud/jd.c line 101
static signed int new_channel(struct _mud_device *pd, signed int index, const char *sn);
// new_channel$link1
// file io/hpmud/pp.c line 667
static signed int new_channel$link1(struct _mud_device *pd$link1, signed int index$link1, const char *sn$link1);
// new_channel$link2
// file io/hpmud/musb.c line 922
static signed int new_channel$link2(struct _mud_device *pd$link2, signed int index$link2, const char *sn$link2);
// new_device
// file io/hpmud/hpmud.c line 296
static signed int new_device(const char *uri, enum HPMUD_IO_MODE mode, signed int *result);
// nibble_read
// file io/hpmud/pp.c line 467
static signed int nibble_read(signed int fd, signed int flag, void *buffer, signed int size, signed int usec);
// nibble_read_data
// file io/hpmud/pp.c line 413
static signed int nibble_read_data(signed int fd, unsigned char *data);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// parse_key_value_pair
// file io/hpmud/model.c line 450
static signed int parse_key_value_pair(char *buf, signed int len, struct hpmud_model_attributes *ma);
// parse_pjl_device_status
// file prnt/backend/hp.c line 326
static signed int parse_pjl_device_status(char *buf, signed int *status);
// parse_pjl_job_end
// file prnt/backend/hp.c line 304
static signed int parse_pjl_job_end(char *buf, signed int *pages);
// pjl_read_thread
// file prnt/backend/hp.c line 344
static void pjl_read_thread(struct pjl_attributes *pa);
// power_up
// file io/hpmud/musb.h line 130
signed int power_up(struct _mud_device *pd, signed int fd);
// pp_channel_close
// file io/hpmud/pp.c line 990
enum HPMUD_RESULT pp_channel_close(struct _mud_device *pd, struct _mud_channel *pc);
// pp_channel_open
// file io/hpmud/pp.c line 961
enum HPMUD_RESULT pp_channel_open(struct _mud_device *pd, const char *sn, signed int *cd);
// pp_close
// file io/hpmud/pp.c line 830
enum HPMUD_RESULT pp_close(struct _mud_device *pd);
// pp_dot4_channel_close
// file io/hpmud/pp.c line 1171
enum HPMUD_RESULT pp_dot4_channel_close(struct _mud_channel *pc);
// pp_dot4_channel_open
// file io/hpmud/pp.c line 1119
enum HPMUD_RESULT pp_dot4_channel_open(struct _mud_channel *pc);
// pp_get_device_id
// file io/hpmud/pp.c line 847
enum HPMUD_RESULT pp_get_device_id(struct _mud_device *pd, char *buf, signed int size, signed int *len);
// pp_get_device_status
// file io/hpmud/pp.c line 905
enum HPMUD_RESULT pp_get_device_status(struct _mud_device *pd, unsigned int *status);
// pp_mlc_channel_close
// file io/hpmud/pp.c line 1079
enum HPMUD_RESULT pp_mlc_channel_close(struct _mud_channel *pc);
// pp_mlc_channel_open
// file io/hpmud/pp.c line 1027
enum HPMUD_RESULT pp_mlc_channel_open(struct _mud_channel *pc);
// pp_open
// file io/hpmud/pp.c line 770
enum HPMUD_RESULT pp_open(struct _mud_device *pd);
// pp_probe_devices
// file io/hpmud/pp.h line 97
signed int pp_probe_devices(char *lst, signed int lst_size, signed int *cnt);
// pp_raw_channel_close
// file io/hpmud/pp.c line 1015
enum HPMUD_RESULT pp_raw_channel_close(struct _mud_channel *pc);
// pp_raw_channel_open
// file io/hpmud/pp.c line 1006
enum HPMUD_RESULT pp_raw_channel_open(struct _mud_channel *pc);
// pp_read
// file io/hpmud/pp.c line 748
signed int pp_read(signed int fd, void *buf, signed int size, signed int usec);
// pp_write
// file io/hpmud/pp.c line 727
signed int pp_write(signed int fd, const void *buf, signed int size, signed int usec);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$19 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$19 *, const union anonymous$33 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$19 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous$19 *, union anonymous$18 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$19 *, union anonymous$18 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$18 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$18 *, const union anonymous$33 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$18 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$18 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_objid
// file /usr/include/net-snmp/mib_api.h line 57
extern signed int read_objid(const char *, unsigned long int *, unsigned long int *);
// read_status
// file io/hpmud/pp.c line 81
static unsigned char read_status(signed int fd);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, struct sockaddr *, unsigned int *);
// release_interface
// file io/hpmud/musb.c line 543
static signed int release_interface(struct anonymous$20 *pfd);
// release_pp
// file io/hpmud/pp.c line 597
static signed int release_pp(signed int fd);
// save_out_file
// file prnt/backend/hp.c line 662
static void save_out_file(signed int fd, signed int copies, struct _IO_FILE *temp_fp);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$13 *, struct anonymous$13 *, struct anonymous$13 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int, struct sockaddr *, unsigned int);
// service_to_channel
// file io/hpmud/hpmud.c line 189
enum HPMUD_RESULT service_to_channel(struct _mud_device *pd, const char *sn, signed int *index);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// sfield_printer_state
// file io/hpmud/musb.c line 824
static signed int sfield_printer_state(const char *id);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snmp_add_null_var
// file /usr/include/net-snmp/varbind_api.h line 29
extern struct variable_list * snmp_add_null_var(struct snmp_pdu *, const unsigned long int *, unsigned long int);
// snmp_close
// file /usr/include/net-snmp/session_api.h line 42
extern signed int snmp_close(struct snmp_session *);
// snmp_free_pdu
// file /usr/include/net-snmp/pdu_api.h line 21
extern void snmp_free_pdu(struct snmp_pdu *);
// snmp_open
// file /usr/include/net-snmp/session_api.h line 29
extern struct snmp_session * snmp_open(struct snmp_session *);
// snmp_pdu_add_variable
// file /usr/include/net-snmp/varbind_api.h line 17
extern struct variable_list * snmp_pdu_add_variable(struct snmp_pdu *, const unsigned long int *, unsigned long int, unsigned char, const void *, unsigned long int);
// snmp_pdu_create
// file /usr/include/net-snmp/pdu_api.h line 15
extern struct snmp_pdu * snmp_pdu_create(signed int);
// snmp_sess_init
// file /usr/include/net-snmp/session_api.h line 16
extern void snmp_sess_init(struct snmp_session *);
// snmp_synch_response
// file /usr/include/net-snmp/session_api.h line 107
extern signed int snmp_synch_response(struct snmp_session *, struct snmp_pdu *, struct snmp_pdu **);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file protocol/discovery/mdns.c line 279 function mdns_parse_respponse
signed int sprintf(char *, const char *, ...);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcasestr
// file /usr/include/string.h line 372
extern char * strcasestr(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrstr
// file io/hpmud/model.c line 142
static char * strrstr(const char *x, const char *y);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtol
// file io/hpmud/jd.c line 77 function ReadReply
signed long int strtol(const char *, char ** restrict , signed int);
// sysdump
// file io/hpmud/hpmud.c line 38
void sysdump(const void *data, signed int size);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// tolower
// file protocol/discovery/mdns.c line 223 function mdns_readMDL
signed int tolower(void);
// ungetc
// file /usr/include/stdio.h line 702
extern signed int ungetc(signed int, struct _IO_FILE *);
// unload_library
// file common/utils.c line 215
void unload_library(void *pLibHandler);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// validate_plugin_version
// file common/utils.c line 109
enum UTILS_PLUGIN_STATUS validate_plugin_version();
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// wait
// file io/hpmud/pp.c line 125
static signed int wait(signed int usec);
// wait_status
// file io/hpmud/pp.c line 91
static signed int wait_status(signed int fd, unsigned char mask, unsigned char val, signed int usec);
// write_ecp_channel
// file io/hpmud/musb.c line 186
static signed int write_ecp_channel(struct anonymous$20 *pfd, signed int value);
// write_phoenix_setup
// file io/hpmud/musb.c line 351
static signed int write_phoenix_setup(struct anonymous$20 *pfd);
// write_thread
// file io/hpmud/musb.c line 979
static void write_thread(struct anonymous$20 *pfd);

struct list_head
{
  // next
  struct list_head *next;
  // prev
  struct list_head *prev;
};

struct anonymous$32
{
  // name
  char *name;
  // incFile
  char *incFile;
  // valueSize
  signed int valueSize;
  // value
  char *value;
  // list
  struct list_head list;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$18
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous$35
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union anonymous$19
{
  // __data
  struct anonymous$35 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct anonymous$20
{
  // hd
  struct libusb_device_handle *hd;
  // fd
  enum FD_ID fd;
  // config
  signed int config;
  // interface
  signed int interface;
  // alt_setting
  signed int alt_setting;
  // write_active
  signed int write_active;
  // write_buf
  const void *write_buf;
  // write_size
  signed int write_size;
  // write_return
  signed int write_return;
  // tid
  unsigned long int tid;
  // mutex
  union anonymous$18 mutex;
  // write_done_cond
  union anonymous$19 write_done_cond;
  // ubuf
  unsigned char ubuf[16384l];
  // uindex
  signed int uindex;
  // ucnt
  signed int ucnt;
};

struct anonymous$37
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$13
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$16
{
  // h2pcredit
  unsigned short int h2pcredit;
  // p2hcredit
  unsigned short int p2hcredit;
  // h2psize
  unsigned short int h2psize;
  // p2hsize
  unsigned short int p2hsize;
};

struct _mud_channel_vf
{
  // open
  enum HPMUD_RESULT (*open)(struct _mud_channel *);
  // close
  enum HPMUD_RESULT (*close)(struct _mud_channel *);
  // channel_write
  enum HPMUD_RESULT (*channel_write)(struct _mud_channel *, const void *, signed int, signed int, signed int *);
  // channel_read
  enum HPMUD_RESULT (*channel_read)(struct _mud_channel *, void *, signed int, signed int, signed int *);
};

struct _mud_channel
{
  // sn
  char sn[256l];
  // sockid
  unsigned char sockid;
  // client_cnt
  signed int client_cnt;
  // index
  signed int index;
  // fd
  signed int fd;
  // pid
  signed int pid;
  // dindex
  signed int dindex;
  // ta
  struct anonymous$16 ta;
  // rbuf
  unsigned char rbuf[16384l];
  // rindex
  signed int rindex;
  // rcnt
  signed int rcnt;
  // socket
  signed int socket;
  // vf
  struct _mud_channel_vf vf;
};

struct _mud_device_vf
{
  // write
  signed int (*write)(signed int, const void *, signed int, signed int);
  // read
  signed int (*read)(signed int, void *, signed int, signed int);
  // open
  enum HPMUD_RESULT (*open)(struct _mud_device *);
  // close
  enum HPMUD_RESULT (*close)(struct _mud_device *);
  // get_device_id
  enum HPMUD_RESULT (*get_device_id)(struct _mud_device *, char *, signed int, signed int *);
  // get_device_status
  enum HPMUD_RESULT (*get_device_status)(struct _mud_device *, unsigned int *);
  // channel_open
  enum HPMUD_RESULT (*channel_open)(struct _mud_device *, const char *, signed int *);
  // channel_close
  enum HPMUD_RESULT (*channel_close)(struct _mud_device *, struct _mud_channel *);
  // channel_write
  enum HPMUD_RESULT (*channel_write)(struct _mud_device *, struct _mud_channel *, const void *, signed int, signed int, signed int *);
  // channel_read
  enum HPMUD_RESULT (*channel_read)(struct _mud_device *, struct _mud_channel *, void *, signed int, signed int, signed int *);
};

struct _mud_device
{
  // uri
  char uri[256l];
  // id
  char id[1024l];
  // index
  signed int index;
  // io_mode
  enum HPMUD_IO_MODE io_mode;
  // channel
  struct _mud_channel channel[47l];
  // channel_cnt
  signed int channel_cnt;
  // open_fd
  signed int open_fd;
  // mlc_up
  signed int mlc_up;
  // mlc_fd
  signed int mlc_fd;
  // ip
  char ip[256l];
  // port
  signed int port;
  // vf
  struct _mud_device_vf vf;
  // mutex
  union anonymous$18 mutex;
};

struct anonymous$28
{
  // device
  struct _mud_device device[2l];
  // mutex
  union anonymous$18 mutex;
};

struct anonymous$21
{
  // hsid
  unsigned char hsid;
  // psid
  unsigned char psid;
  // length
  unsigned short int length;
  // credit
  unsigned char credit;
  // status
  unsigned char status;
} __attribute__ ((__packed__));

struct anonymous$29
{
  // h
  struct anonymous$21 h;
  // cmd
  unsigned char cmd;
} __attribute__ ((__packed__));

struct anonymous$27
{
  // h
  struct anonymous$21 h;
  // cmd
  unsigned char cmd;
  // hsocket
  unsigned char hsocket;
  // psocket
  unsigned char psocket;
} __attribute__ ((__packed__));

struct anonymous$25
{
  // h
  struct anonymous$21 h;
  // cmd
  unsigned char cmd;
  // hsocket
  unsigned char hsocket;
  // psocket
  unsigned char psocket;
  // credit
  unsigned short int credit;
} __attribute__ ((__packed__));

struct anonymous$22
{
  // h
  struct anonymous$21 h;
  // cmd
  unsigned char cmd;
  // result
  unsigned char result;
} __attribute__ ((__packed__));

struct anonymous$26
{
  // h
  struct anonymous$21 h;
  // cmd
  unsigned char cmd;
  // result
  unsigned char result;
  // credit
  unsigned short int credit;
} __attribute__ ((__packed__));

struct anonymous$24
{
  // h
  struct anonymous$21 h;
  // cmd
  unsigned char cmd;
  // result
  unsigned char result;
  // h2psize
  unsigned short int h2psize;
  // p2hsize
  unsigned short int p2hsize;
  // status
  unsigned char status;
} __attribute__ ((__packed__));

struct anonymous$31
{
  // h
  struct anonymous$21 h;
  // cmd
  unsigned char cmd;
  // result
  unsigned char result;
  // rev
  unsigned char rev;
} __attribute__ ((__packed__));

struct anonymous$30
{
  // h
  struct anonymous$21 h;
  // cmd
  unsigned char cmd;
  // rev
  unsigned char rev;
} __attribute__ ((__packed__));

struct anonymous$23
{
  // h
  struct anonymous$21 h;
  // cmd
  unsigned char cmd;
  // socket
  unsigned char socket;
  // h2psize
  unsigned short int h2psize;
  // p2hsize
  unsigned short int p2hsize;
  // status
  unsigned char status;
} __attribute__ ((__packed__));

struct anonymous
{
  // psid
  unsigned char psid;
  // ssid
  unsigned char ssid;
  // length
  unsigned short int length;
  // credit
  unsigned char credit;
  // control
  unsigned char control;
} __attribute__ ((__packed__));

struct anonymous$2
{
  // h
  struct anonymous h;
  // cmd
  unsigned char cmd;
} __attribute__ ((__packed__));

struct anonymous$6
{
  // h
  struct anonymous h;
  // cmd
  unsigned char cmd;
  // psocket
  unsigned char psocket;
  // ssocket
  unsigned char ssocket;
} __attribute__ ((__packed__));

struct anonymous$9
{
  // h
  struct anonymous h;
  // cmd
  unsigned char cmd;
  // psocket
  unsigned char psocket;
  // ssocket
  unsigned char ssocket;
  // credit
  unsigned short int credit;
} __attribute__ ((__packed__));

struct anonymous$10
{
  // h
  struct anonymous h;
  // cmd
  unsigned char cmd;
  // psocket
  unsigned char psocket;
  // ssocket
  unsigned char ssocket;
  // maxcredit
  unsigned short int maxcredit;
} __attribute__ ((__packed__));

struct anonymous$4
{
  // h
  struct anonymous h;
  // cmd
  unsigned char cmd;
  // psocket
  unsigned char psocket;
  // ssocket
  unsigned char ssocket;
  // maxp2s
  unsigned short int maxp2s;
  // maxs2p
  unsigned short int maxs2p;
  // maxcredit
  unsigned short int maxcredit;
} __attribute__ ((__packed__));

struct anonymous$12
{
  // h
  struct anonymous h;
  // cmd
  unsigned char cmd;
  // psocket
  unsigned char psocket;
  // ssocket
  unsigned char ssocket;
  // error
  unsigned char error;
} __attribute__ ((__packed__));

struct anonymous$3
{
  // h
  struct anonymous h;
  // cmd
  unsigned char cmd;
  // result
  unsigned char result;
} __attribute__ ((__packed__));

struct anonymous$7
{
  // h
  struct anonymous h;
  // cmd
  unsigned char cmd;
  // result
  unsigned char result;
  // psocket
  unsigned char psocket;
  // ssocket
  unsigned char ssocket;
} __attribute__ ((__packed__));

struct anonymous$11
{
  // h
  struct anonymous h;
  // cmd
  unsigned char cmd;
  // result
  unsigned char result;
  // psocket
  unsigned char psocket;
  // ssocket
  unsigned char ssocket;
  // credit
  unsigned short int credit;
} __attribute__ ((__packed__));

struct anonymous$5
{
  // h
  struct anonymous h;
  // cmd
  unsigned char cmd;
  // result
  unsigned char result;
  // psocket
  unsigned char psocket;
  // ssocket
  unsigned char ssocket;
  // maxp2s
  unsigned short int maxp2s;
  // maxs2p
  unsigned short int maxs2p;
  // maxcredit
  unsigned short int maxcredit;
  // credit
  unsigned short int credit;
} __attribute__ ((__packed__));

struct anonymous$1
{
  // h
  struct anonymous h;
  // cmd
  unsigned char cmd;
  // result
  unsigned char result;
  // rev
  unsigned char rev;
} __attribute__ ((__packed__));

struct anonymous$8
{
  // h
  struct anonymous h;
  // cmd
  unsigned char cmd;
  // result
  unsigned char result;
  // socket
  unsigned char socket;
} __attribute__ ((__packed__));

struct anonymous$0
{
  // h
  struct anonymous h;
  // cmd
  unsigned char cmd;
  // rev
  unsigned char rev;
} __attribute__ ((__packed__));

union anonymous$36
{
  // integer
  signed long int *integer;
  // string
  unsigned char *string;
  // objid
  unsigned long int *objid;
  // bitstring
  unsigned char *bitstring;
  // counter64
  struct counter64 *counter64;
  // floatVal
  float *floatVal;
  // doubleVal
  double *doubleVal;
};

union anonymous$14
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$33
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$15
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$17
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct DBusError
{
  // name
  const char *name;
  // message
  const char *message;
  // dummy1
  unsigned int dummy1 : 1;
  // dummy2
  unsigned int dummy2 : 1;
  // dummy3
  unsigned int dummy3 : 1;
  // dummy4
  unsigned int dummy4 : 1;
  // dummy5
  unsigned int dummy5 : 1;
  // padding1
  void *padding1;
};

struct _DNS_PKT_HEADER
{
  // id
  unsigned short int id;
  // flags
  unsigned short int flags;
  // questions
  unsigned short int questions;
  // answers
  unsigned short int answers;
  // authorities
  unsigned short int authorities;
  // additionals
  unsigned short int additionals;
};

struct _DNS_RECORD
{
  // ip
  char ip[16l];
  // mdl
  char mdl[256l];
  // name
  char name[256l];
  // next
  struct _DNS_RECORD *next;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct counter64
{
  // high
  unsigned long int high;
  // low
  unsigned long int low;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct hpmud_dstat
{
  // uri
  char uri[256l];
  // client_cnt
  signed int client_cnt;
  // io_mode
  enum HPMUD_IO_MODE io_mode;
  // channel_cnt
  signed int channel_cnt;
  // mlc_up
  signed int mlc_up;
};

struct hpmud_model_attributes
{
  // prt_mode
  enum HPMUD_IO_MODE prt_mode;
  // mfp_mode
  enum HPMUD_IO_MODE mfp_mode;
  // scantype
  enum HPMUD_SCANTYPE scantype;
  // statustype
  enum HPMUD_STATUSTYPE statustype;
  // support
  enum HPMUD_SUPPORT_TYPE support;
  // plugin
  enum HPMUD_PLUGIN_TYPE plugin;
  // reserved
  enum HPMUD_SUPPORT_TYPE reserved[5l];
  // scansrc
  enum HPMUD_SCANSRC scansrc;
};

struct in6_addr
{
  // __in6_u
  union anonymous$14 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct ip_mreq
{
  // imr_multiaddr
  struct in_addr imr_multiaddr;
  // imr_interface
  struct in_addr imr_interface;
};

struct libusb_config_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // wTotalLength
  unsigned short int wTotalLength;
  // bNumInterfaces
  unsigned char bNumInterfaces;
  // bConfigurationValue
  unsigned char bConfigurationValue;
  // iConfiguration
  unsigned char iConfiguration;
  // bmAttributes
  unsigned char bmAttributes;
  // MaxPower
  unsigned char MaxPower;
  // interface
  struct libusb_interface *interface;
  // extra
  const unsigned char *extra;
  // extra_length
  signed int extra_length;
};

struct libusb_device_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bcdUSB
  unsigned short int bcdUSB;
  // bDeviceClass
  unsigned char bDeviceClass;
  // bDeviceSubClass
  unsigned char bDeviceSubClass;
  // bDeviceProtocol
  unsigned char bDeviceProtocol;
  // bMaxPacketSize0
  unsigned char bMaxPacketSize0;
  // idVendor
  unsigned short int idVendor;
  // idProduct
  unsigned short int idProduct;
  // bcdDevice
  unsigned short int bcdDevice;
  // iManufacturer
  unsigned char iManufacturer;
  // iProduct
  unsigned char iProduct;
  // iSerialNumber
  unsigned char iSerialNumber;
  // bNumConfigurations
  unsigned char bNumConfigurations;
};

struct libusb_endpoint_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bEndpointAddress
  unsigned char bEndpointAddress;
  // bmAttributes
  unsigned char bmAttributes;
  // wMaxPacketSize
  unsigned short int wMaxPacketSize;
  // bInterval
  unsigned char bInterval;
  // bRefresh
  unsigned char bRefresh;
  // bSynchAddress
  unsigned char bSynchAddress;
  // extra
  const unsigned char *extra;
  // extra_length
  signed int extra_length;
};

struct libusb_interface
{
  // altsetting
  struct libusb_interface_descriptor *altsetting;
  // num_altsetting
  signed int num_altsetting;
};

struct libusb_interface_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bInterfaceNumber
  unsigned char bInterfaceNumber;
  // bAlternateSetting
  unsigned char bAlternateSetting;
  // bNumEndpoints
  unsigned char bNumEndpoints;
  // bInterfaceClass
  unsigned char bInterfaceClass;
  // bInterfaceSubClass
  unsigned char bInterfaceSubClass;
  // bInterfaceProtocol
  unsigned char bInterfaceProtocol;
  // iInterface
  unsigned char iInterface;
  // endpoint
  struct libusb_endpoint_descriptor *endpoint;
  // extra
  const unsigned char *extra;
  // extra_length
  signed int extra_length;
};

struct netsnmp_container_s
{
  // container_data
  void *container_data;
  // get_size
  unsigned long int (*get_size)(struct netsnmp_container_s *);
  // init
  signed int (*init)(struct netsnmp_container_s *);
  // cfree
  signed int (*cfree)(struct netsnmp_container_s *);
  // insert
  signed int (*insert)(struct netsnmp_container_s *, const void *);
  // remove
  signed int (*remove)(struct netsnmp_container_s *, const void *);
  // release
  signed int (*release)(struct netsnmp_container_s *, const void *);
  // free_item
  void (*free_item)(void *, void *);
  // find
  void * (*find)(struct netsnmp_container_s *, const void *);
  // find_next
  void * (*find_next)(struct netsnmp_container_s *, const void *);
  // get_subset
  struct netsnmp_void_array_s * (*get_subset)(struct netsnmp_container_s *, void *);
  // get_iterator
  struct netsnmp_iterator_s * (*get_iterator)(struct netsnmp_container_s *);
  // for_each
  void (*for_each)(struct netsnmp_container_s *, void (*)(void *, void *), void *);
  // clear
  void (*clear)(struct netsnmp_container_s *, void (*)(void *, void *), void *);
  // insert_filter
  signed int (*insert_filter)(struct netsnmp_container_s *, const void *);
  // duplicate
  struct netsnmp_container_s * (*duplicate)(struct netsnmp_container_s *, void *, unsigned int);
  // compare
  signed int (*compare)(const void *, const void *);
  // ncompare
  signed int (*ncompare)(const void *, const void *);
  // options
  signed int (*options)(struct netsnmp_container_s *, signed int, unsigned int);
  // container_name
  char *container_name;
  // sync
  unsigned long int sync;
  // flags
  unsigned int flags;
  // next
  struct netsnmp_container_s *next;
  // prev
  struct netsnmp_container_s *prev;
};

struct netsnmp_iterator_s
{
  // container
  struct netsnmp_container_s *container;
  // sync
  unsigned long int sync;
  // reset
  signed int (*reset)(struct netsnmp_iterator_s *);
  // release
  signed int (*release)(struct netsnmp_iterator_s *);
  // first
  void * (*first)(struct netsnmp_iterator_s *);
  // curr
  void * (*curr)(struct netsnmp_iterator_s *);
  // last
  void * (*last)(struct netsnmp_iterator_s *);
  // next
  void * (*next)(struct netsnmp_iterator_s *);
  // remove
  signed int (*remove)(struct netsnmp_iterator_s *);
};

struct netsnmp_void_array_s
{
  // size
  unsigned long int size;
  // array
  void **array;
};

struct pjl_attributes
{
  // pjl_device
  signed int pjl_device;
  // current_status
  signed int current_status;
  // eoj_pages
  signed int eoj_pages;
  // abort
  signed int abort;
  // done
  signed int done;
  // dd
  signed int dd;
  // cd
  signed int cd;
  // tid
  unsigned long int tid;
  // mutex
  union anonymous$18 mutex;
  // done_cond
  union anonymous$19 done_cond;
};

struct ppdev_frob_struct
{
  // mask
  unsigned char mask;
  // val
  unsigned char val;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct snmp_pdu
{
  // version
  signed long int version;
  // command
  signed int command;
  // reqid
  signed long int reqid;
  // msgid
  signed long int msgid;
  // transid
  signed long int transid;
  // sessid
  signed long int sessid;
  // errstat
  signed long int errstat;
  // errindex
  signed long int errindex;
  // time
  unsigned long int time;
  // flags
  unsigned long int flags;
  // securityModel
  signed int securityModel;
  // securityLevel
  signed int securityLevel;
  // msgParseModel
  signed int msgParseModel;
  // transport_data
  void *transport_data;
  // transport_data_length
  signed int transport_data_length;
  // tDomain
  const unsigned long int *tDomain;
  // tDomainLen
  unsigned long int tDomainLen;
  // variables
  struct variable_list *variables;
  // community
  unsigned char *community;
  // community_len
  unsigned long int community_len;
  // enterprise
  unsigned long int *enterprise;
  // enterprise_length
  unsigned long int enterprise_length;
  // trap_type
  signed long int trap_type;
  // specific_type
  signed long int specific_type;
  // agent_addr
  unsigned char agent_addr[4l];
  // contextEngineID
  unsigned char *contextEngineID;
  // contextEngineIDLen
  unsigned long int contextEngineIDLen;
  // contextName
  char *contextName;
  // contextNameLen
  unsigned long int contextNameLen;
  // securityEngineID
  unsigned char *securityEngineID;
  // securityEngineIDLen
  unsigned long int securityEngineIDLen;
  // securityName
  char *securityName;
  // securityNameLen
  unsigned long int securityNameLen;
  // priority
  signed int priority;
  // range_subid
  signed int range_subid;
  // securityStateRef
  void *securityStateRef;
};

struct snmp_session
{
  // version
  signed long int version;
  // retries
  signed int retries;
  // timeout
  signed long int timeout;
  // flags
  unsigned long int flags;
  // subsession
  struct snmp_session *subsession;
  // next
  struct snmp_session *next;
  // peername
  char *peername;
  // remote_port
  unsigned short int remote_port;
  // localname
  char *localname;
  // local_port
  unsigned short int local_port;
  // authenticator
  unsigned char * (*authenticator)(unsigned char *, unsigned long int *, unsigned char *, unsigned long int);
  // callback
  signed int (*callback)(signed int, struct snmp_session *, signed int, struct snmp_pdu *, void *);
  // callback_magic
  void *callback_magic;
  // s_errno
  signed int s_errno;
  // s_snmp_errno
  signed int s_snmp_errno;
  // sessid
  signed long int sessid;
  // community
  unsigned char *community;
  // community_len
  unsigned long int community_len;
  // rcvMsgMaxSize
  unsigned long int rcvMsgMaxSize;
  // sndMsgMaxSize
  unsigned long int sndMsgMaxSize;
  // isAuthoritative
  unsigned char isAuthoritative;
  // contextEngineID
  unsigned char *contextEngineID;
  // contextEngineIDLen
  unsigned long int contextEngineIDLen;
  // engineBoots
  unsigned int engineBoots;
  // engineTime
  unsigned int engineTime;
  // contextName
  char *contextName;
  // contextNameLen
  unsigned long int contextNameLen;
  // securityEngineID
  unsigned char *securityEngineID;
  // securityEngineIDLen
  unsigned long int securityEngineIDLen;
  // securityName
  char *securityName;
  // securityNameLen
  unsigned long int securityNameLen;
  // securityAuthProto
  unsigned long int *securityAuthProto;
  // securityAuthProtoLen
  unsigned long int securityAuthProtoLen;
  // securityAuthKey
  unsigned char securityAuthKey[32l];
  // securityAuthKeyLen
  unsigned long int securityAuthKeyLen;
  // securityAuthLocalKey
  unsigned char *securityAuthLocalKey;
  // securityAuthLocalKeyLen
  unsigned long int securityAuthLocalKeyLen;
  // securityPrivProto
  unsigned long int *securityPrivProto;
  // securityPrivProtoLen
  unsigned long int securityPrivProtoLen;
  // securityPrivKey
  unsigned char securityPrivKey[32l];
  // securityPrivKeyLen
  unsigned long int securityPrivKeyLen;
  // securityPrivLocalKey
  unsigned char *securityPrivLocalKey;
  // securityPrivLocalKeyLen
  unsigned long int securityPrivLocalKeyLen;
  // securityModel
  signed int securityModel;
  // securityLevel
  signed int securityLevel;
  // paramName
  char *paramName;
  // securityInfo
  void *securityInfo;
  // transport_configuration
  struct netsnmp_container_s *transport_configuration;
  // myvoid
  void *myvoid;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct variable_list
{
  // next_variable
  struct variable_list *next_variable;
  // name
  unsigned long int *name;
  // name_length
  unsigned long int name_length;
  // type
  unsigned char type;
  // val
  union anonymous$36 val;
  // val_len
  unsigned long int val_len;
  // name_loc
  unsigned long int name_loc[128l];
  // buf
  unsigned char buf[40l];
  // data
  void *data;
  // dataFreeHook
  void (*dataFreeHook)(void *);
  // index
  signed int index;
};


// GenericPort
// file io/hpmud/jd.c line 60
static const signed int GenericPort[5l] = { 0, 9220, 9220, 9221, 9222 };
// GenericPort1
// file io/hpmud/jd.c line 62
static const signed int GenericPort1[5l] = { 0, 8292, 8292, 0, 0 };
// PrintPort
// file io/hpmud/jd.c line 58
static const signed int PrintPort[5l] = { 0, 9100, 9100, 9101, 9102 };
// ScanPort0
// file io/hpmud/jd.c line 59
static const signed int ScanPort0[5l] = { 0, 9290, 9290, 9291, 9292 };
// ScanPort1
// file io/hpmud/jd.c line 61
static const signed int ScanPort1[5l] = { 0, 8290, 8290, 0, 0 };
// SnmpPort
// file io/hpmud/hpmudi.h line 219
static const char *SnmpPort[5l] = { "", "public", "public.1", "public.2", "public.3" };
// dbus_conn
// file prnt/backend/hp.c line 159
static struct DBusConnection *dbus_conn;
// dbus_err
// file prnt/backend/hp.c line 158
static struct DBusError dbus_err;
// fd_class
// file io/hpmud/musb.c line 103
static signed int fd_class[14l] = { 0, 0x7, 0x7, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
// fd_name
// file io/hpmud/musb.c line 85
static char *fd_name[14l] = { "na", "7/1/2", "7/1/3", "7/1/4", "ff/1/1", "ff/2/1", "ff/3/1", "ff/ff/ff", "ff/d4/0", "ff/4/1", "ff/1/0", "ff/cc/0", "ff/2/10", "ff/9/1" };
// fd_protocol
// file io/hpmud/musb.c line 113
static signed int fd_protocol[14l] = { 0, 0x2, 0x3, 0x4, 0x1, 0x1, 0x1, 0xff, 0, 0x1, 0, 0, 0x10, 0x1 };
// fd_subclass
// file io/hpmud/musb.c line 108
static signed int fd_subclass[14l] = { 0, 0x1, 0x1, 0x1, 0x1, 0x2, 0x3, 0xff, 0xd4, 0x4, 0x1, 0xcc, 0x2, 0x9 };
// fd_table
// file io/hpmud/musb.c line 125
static struct anonymous$20 fd_table[14l];
// head
// file io/hpmud/model.c line 53
static struct anonymous$32 head;
// homedir
// file io/hpmud/model.c line 54
static char homedir[255l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// jd_channel_vf
// file io/hpmud/jd.c line 50
static struct _mud_channel_vf jd_channel_vf;
// jd_channel_vf
// file io/hpmud/jd.c line 50
static struct _mud_channel_vf jd_channel_vf = { .open=jd_s_channel_open, .close=jd_s_channel_close, .channel_write=jd_s_channel_write,
    .channel_read=jd_s_channel_read };
// jd_mud_device_vf
// file io/hpmud/jd.c line 38
struct _mud_device_vf jd_mud_device_vf;
// jd_mud_device_vf
// file io/hpmud/jd.c line 38
struct _mud_device_vf jd_mud_device_vf = { .write=((signed int (*)(signed int, const void *, signed int, signed int))NULL), .read=((signed int (*)(signed int, void *, signed int, signed int))NULL),
    .open=jd_open,
    .close=jd_close, .get_device_id=jd_get_device_id, .get_device_status=jd_get_device_status,
    .channel_open=jd_channel_open,
    .channel_close=jd_channel_close, .channel_write=jd_channel_write,
    .channel_read=jd_channel_read };
// kStatusOID
// file io/hpmud/jd.c line 64
const char *kStatusOID = "1.3.6.1.4.1.11.2.3.9.1.1.7.0";
// libusb_ctx
// file io/hpmud/musb.c line 122
static struct libusb_context *libusb_ctx = (struct libusb_context *)(void *)0;
// libusb_dev
// file io/hpmud/musb.c line 121
static struct libusb_device *libusb_dev = (struct libusb_device *)(void *)0;
// libusb_dev_list
// file io/hpmud/musb.c line 123
static struct libusb_device **libusb_dev_list = (struct libusb_device **)(void *)0;
// ms
// file io/hpmud/hpmud.c line 32
struct anonymous$28 ms;
// msp
// file io/hpmud/hpmud.c line 33
struct anonymous$28 *msp;
// msp
// file io/hpmud/hpmud.c line 33
struct anonymous$28 *msp = &ms;
// musb_comp_channel_vf
// file io/hpmud/musb.c line 57
static struct _mud_channel_vf musb_comp_channel_vf;
// musb_comp_channel_vf
// file io/hpmud/musb.c line 57
static struct _mud_channel_vf musb_comp_channel_vf = { .open=musb_comp_channel_open, .close=musb_raw_channel_close, .channel_write=musb_raw_channel_write,
    .channel_read=musb_raw_channel_read };
// musb_dot4_channel_vf
// file io/hpmud/musb.c line 73
static struct _mud_channel_vf musb_dot4_channel_vf;
// musb_dot4_channel_vf
// file io/hpmud/musb.c line 73
static struct _mud_channel_vf musb_dot4_channel_vf = { .open=musb_dot4_channel_open, .close=musb_dot4_channel_close, .channel_write=musb_dot4_channel_write,
    .channel_read=musb_dot4_channel_read };
// musb_mlc_channel_vf
// file io/hpmud/musb.c line 65
static struct _mud_channel_vf musb_mlc_channel_vf;
// musb_mlc_channel_vf
// file io/hpmud/musb.c line 65
static struct _mud_channel_vf musb_mlc_channel_vf = { .open=musb_mlc_channel_open, .close=musb_mlc_channel_close, .channel_write=musb_mlc_channel_write,
    .channel_read=musb_mlc_channel_read };
// musb_mud_device_vf
// file io/hpmud/musb.c line 35
struct _mud_device_vf musb_mud_device_vf;
// musb_mud_device_vf
// file io/hpmud/musb.c line 35
struct _mud_device_vf musb_mud_device_vf = { .write=musb_write, .read=musb_read, .open=musb_open, .close=musb_close,
    .get_device_id=musb_get_device_id, .get_device_status=musb_get_device_status,
    .channel_open=musb_channel_open,
    .channel_close=musb_channel_close, .channel_write=musb_channel_write,
    .channel_read=musb_channel_read };
// musb_raw_channel_vf
// file io/hpmud/musb.c line 49
static struct _mud_channel_vf musb_raw_channel_vf;
// musb_raw_channel_vf
// file io/hpmud/musb.c line 49
static struct _mud_channel_vf musb_raw_channel_vf = { .open=musb_raw_channel_open, .close=musb_raw_channel_close, .channel_write=musb_raw_channel_write,
    .channel_read=musb_raw_channel_read };
// pjl_job_end_cmd
// file prnt/backend/hp.c line 152
static const char pjl_job_end_cmd[30l] = { 'e', '%', '-', '1', '2', '3', '4', '5', 'X', '@', 'P', 'J', 'L', ' ', 'E', 'O', 'J', ' ', '\r', '\n', 'e', '%', '-', '1', '2', '3', '4', '5', 'X', 0 };
// pjl_ustatus_cmd
// file prnt/backend/hp.c line 151
static const char pjl_ustatus_cmd[81l] = { 'e', '%', '-', '1', '2', '3', '4', '5', 'X', '@', 'P', 'J', 'L', ' ', 'U', 'S', 'T', 'A', 'T', 'U', 'S', ' ', 'D', 'E', 'V', 'I', 'C', 'E', ' ', '=', ' ', 'O', 'N', ' ', '\r', '\n', '@', 'P', 'J', 'L', ' ', 'U', 'S', 'T', 'A', 'T', 'U', 'S', ' ', 'J', 'O', 'B', ' ', '=', ' ', 'O', 'N', ' ', '\r', '\n', '@', 'P', 'J', 'L', ' ', 'J', 'O', 'B', ' ', '\r', '\n', 'e', '%', '-', '1', '2', '3', '4', '5', 'X', 0 };
// pjl_ustatus_off_cmd
// file prnt/backend/hp.c line 153
static const char pjl_ustatus_off_cmd[37l] = { 'e', '%', '-', '1', '2', '3', '4', '5', 'X', '@', 'P', 'J', 'L', ' ', 'U', 'S', 'T', 'A', 'T', 'U', 'S', 'O', 'F', 'F', ' ', '\r', '\n', 'e', '%', '-', '1', '2', '3', '4', '5', 'X', 0 };
// pp_dot4_channel_vf
// file io/hpmud/pp.c line 62
static struct _mud_channel_vf pp_dot4_channel_vf;
// pp_dot4_channel_vf
// file io/hpmud/pp.c line 62
static struct _mud_channel_vf pp_dot4_channel_vf = { .open=pp_dot4_channel_open, .close=pp_dot4_channel_close, .channel_write=musb_dot4_channel_write,
    .channel_read=musb_dot4_channel_read };
// pp_mlc_channel_vf
// file io/hpmud/pp.c line 54
static struct _mud_channel_vf pp_mlc_channel_vf;
// pp_mlc_channel_vf
// file io/hpmud/pp.c line 54
static struct _mud_channel_vf pp_mlc_channel_vf = { .open=pp_mlc_channel_open, .close=pp_mlc_channel_close, .channel_write=musb_mlc_channel_write,
    .channel_read=musb_mlc_channel_read };
// pp_mud_device_vf
// file io/hpmud/pp.c line 32
struct _mud_device_vf pp_mud_device_vf;
// pp_mud_device_vf
// file io/hpmud/pp.c line 32
struct _mud_device_vf pp_mud_device_vf = { .write=pp_write, .read=pp_read, .open=pp_open, .close=pp_close,
    .get_device_id=pp_get_device_id, .get_device_status=pp_get_device_status,
    .channel_open=pp_channel_open,
    .channel_close=pp_channel_close, .channel_write=musb_channel_write,
    .channel_read=musb_channel_read };
// pp_raw_channel_vf
// file io/hpmud/pp.c line 46
static struct _mud_channel_vf pp_raw_channel_vf;
// pp_raw_channel_vf
// file io/hpmud/pp.c line 46
static struct _mud_channel_vf pp_raw_channel_vf = { .open=pp_raw_channel_open, .close=pp_raw_channel_close, .channel_write=musb_raw_channel_write,
    .channel_read=musb_raw_channel_read };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// venice_power_on
// file io/hpmud/musb.c line 118
static const unsigned char venice_power_on[34l] = { (const unsigned char)0x1b, (const unsigned char)37, (const unsigned char)80, (const unsigned char)117, (const unsigned char)105, (const unsigned char)102, (const unsigned char)112, (const unsigned char)46, (const unsigned char)112, (const unsigned char)111, (const unsigned char)119, (const unsigned char)101, (const unsigned char)114, (const unsigned char)32, (const unsigned char)49, (const unsigned char)59, (const unsigned char)117, (const unsigned char)100, (const unsigned char)119, (const unsigned char)46, (const unsigned char)113, (const unsigned char)117, (const unsigned char)105, (const unsigned char)116, (const unsigned char)59, (const unsigned char)0x1b, (const unsigned char)37, (const unsigned char)45, (const unsigned char)49, (const unsigned char)50, (const unsigned char)51, (const unsigned char)52, (const unsigned char)53, (const unsigned char)88 };

// CopyLabel
// file io/hpmud/model.c line 157
static signed int CopyLabel(char *label, char *buf, signed int bufSize)
{
  struct list_head *p;
  struct anonymous$32 *pl;
  signed int i = 0;
  signed int found = 0;
  p = (&head.list)->next;
  for( ; !(p == &head.list); p = p->next)
  {
    pl = (struct anonymous$32 *)((char *)p - (signed long int)(unsigned long int)&((struct anonymous$32 *)0)->list);
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp(pl->name, label);
    if(return_value_strcasecmp$1 == 0)
    {
      found = 1;
      break;
    }

  }
  if(found == 0)
    syslog(3, "io/hpmud/model.c 176: error undefined label %s\n", label);

  else
    if(!(bufSize >= pl->valueSize))
      syslog(3, "io/hpmud/model.c 182: error label %s size=%d buf=%d\n", label, pl->valueSize, bufSize);

    else
    {
      memcpy((void *)buf, (const void *)pl->value, (unsigned long int)pl->valueSize);
      i = pl->valueSize;
    }

bugout:
  ;
  return i;
}

// DelList
// file io/hpmud/model.c line 338
static signed int DelList()
{
  struct list_head *p;
  struct list_head *n;
  struct anonymous$32 *pl;
  p = (&head.list)->next;
  n = p->next;
  for( ; !(p == &head.list); n = p->next)
  {
    pl = (struct anonymous$32 *)((char *)p - (signed long int)(unsigned long int)&((struct anonymous$32 *)0)->list);
    UnRegisterLabel(pl);
    p = n;
  }
  return 0;
}

// Dot4CloseChannel
// file io/hpmud/dot4.c line 630
signed int Dot4CloseChannel(struct _mud_channel *pc, signed int fd)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char buf[16384l];
  signed int stat = 0;
  signed int len;
  signed int n;
  struct anonymous$6 *pCmd;
  struct anonymous$7 *pReply;
  memset((void *)buf, 0, sizeof(struct anonymous$6) /*9ul*/ );
  pCmd = (struct anonymous$6 *)buf;
  n = (signed int)sizeof(struct anonymous$6) /*9ul*/ ;
  pCmd->h.length=htons((unsigned short int)n);
  pCmd->h.credit = (unsigned char)1;
  pCmd->cmd = (unsigned char)2;
  pCmd->psocket = pc->sockid;
  pCmd->ssocket = pc->sockid;
  len=pd->vf.write(fd, (const void *)pCmd, n, 45000000);
  if(!(len == n))
  {
    syslog(3, "io/hpmud/dot4.c 649: unable to write Dot4CloseChannel: %m\n");
    stat = 1;
  }

  else
  {
    stat=Dot4ReverseReply(pc, fd, buf, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ );
    pReply = (struct anonymous$7 *)buf;
    _Bool tmp_if_expr$1;
    if(!(stat == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)pReply->cmd != (0x80 | 2) ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)pReply->result != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      syslog(3, "io/hpmud/dot4.c 659: invalid Dot4CloseChannelReply: cmd=%x, result=%x\n", pReply->cmd, pReply->result);
      stat = 1;
    }

  }

bugout:
  ;
  return stat;
}

// Dot4Credit
// file io/hpmud/dot4.c line 668
signed int Dot4Credit(struct _mud_channel *pc, signed int fd, unsigned short int credit)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char buf[16384l];
  signed int stat = 0;
  signed int len;
  signed int n;
  struct anonymous$9 *pCmd;
  struct anonymous$7 *pReply;
  memset((void *)buf, 0, sizeof(struct anonymous$9) /*11ul*/ );
  pCmd = (struct anonymous$9 *)buf;
  n = (signed int)sizeof(struct anonymous$9) /*11ul*/ ;
  pCmd->h.length=htons((unsigned short int)n);
  pCmd->h.credit = (unsigned char)1;
  pCmd->cmd = (unsigned char)3;
  pCmd->psocket = pc->sockid;
  pCmd->ssocket = pc->sockid;
  pCmd->credit=htons(credit);
  len=pd->vf.write(fd, (const void *)pCmd, n, 45000000);
  if(!(len == n))
  {
    syslog(3, "io/hpmud/dot4.c 688: unable to write Dot4Credit: %m\n");
    stat = 1;
  }

  else
  {
    stat=Dot4ReverseReply(pc, fd, buf, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ );
    pReply = (struct anonymous$7 *)buf;
    _Bool tmp_if_expr$1;
    if(!(stat == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)pReply->cmd != (0x80 | 3) ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)pReply->result != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      syslog(3, "io/hpmud/dot4.c 698: invalid Dot4CreditReply: cmd=%x, result=%x\n", pReply->cmd, pReply->result);
      stat = 1;
    }

    else
      pc->ta.p2hcredit = pc->ta.p2hcredit + credit;
  }

bugout:
  ;
  return stat;
}

// Dot4CreditRequest
// file io/hpmud/dot4.c line 709
signed int Dot4CreditRequest(struct _mud_channel *pc, signed int fd, unsigned short int credit)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char buf[16384l];
  signed int stat = 0;
  signed int len;
  signed int n;
  struct anonymous$10 *pCmd;
  struct anonymous$11 *pReply;
  memset((void *)buf, 0, sizeof(struct anonymous$10) /*11ul*/ );
  pCmd = (struct anonymous$10 *)buf;
  n = (signed int)sizeof(struct anonymous$10) /*11ul*/ ;
  pCmd->h.length=htons((unsigned short int)n);
  pCmd->h.credit = (unsigned char)1;
  pCmd->cmd = (unsigned char)4;
  pCmd->psocket = pc->sockid;
  pCmd->ssocket = pc->sockid;
  pCmd->maxcredit=htons((unsigned short int)0xffff);
  len=pd->vf.write(fd, (const void *)pCmd, n, 45000000);
  unsigned short int return_value_ntohs$3;
  if(!(len == n))
  {
    syslog(3, "io/hpmud/dot4.c 730: unable to write Dot4CreditRequest: %m\n");
    stat = 1;
  }

  else
  {
    stat=Dot4ReverseReply(pc, fd, buf, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ );
    pReply = (struct anonymous$11 *)buf;
    _Bool tmp_if_expr$1;
    if(!(stat == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)pReply->cmd != (0x80 | 4) ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)pReply->result != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      syslog(3, "io/hpmud/dot4.c 740: invalid Dot4CreditRequestReply: cmd=%x, result=%x\n", pReply->cmd, pReply->result);
      stat = 1;
    }

    else
    {
      return_value_ntohs$3=ntohs(pReply->credit);
      pc->ta.h2pcredit = pc->ta.h2pcredit + return_value_ntohs$3;
    }
  }

bugout:
  ;
  return stat;
}

// Dot4ExecReverseCmd
// file io/hpmud/dot4.c line 47
static signed int Dot4ExecReverseCmd(struct _mud_channel *pc, signed int fd, unsigned char *buf)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  struct _mud_channel *out_of_bound_channel;
  struct anonymous$2 *pCmd;
  struct anonymous$3 *pReply;
  struct anonymous$9 *pCredit;
  struct anonymous$7 *pCreditReply;
  struct anonymous$10 *pCreditReq;
  struct anonymous$11 *pCreditReqReply;
  struct anonymous$12 *pError;
  signed int len;
  signed int size;
  unsigned char Dot4ExecReverseCmd$$1$$socket;
  pCmd = (struct anonymous$2 *)buf;
  _Bool tmp_if_expr$3;
  if((signed int)pCmd->h.psid == 0)
    tmp_if_expr$3 = (signed int)pCmd->h.ssid == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  unsigned short int return_value_ntohs$4;
  unsigned short int return_value_ntohs$5;
  if(!tmp_if_expr$3)
  {
    if(pCmd->h.psid == pCmd->h.ssid)
    {
      out_of_bound_channel = &pd->channel[(signed long int)pCmd->h.psid];
      if(!((signed int)out_of_bound_channel->ta.p2hcredit >= 1))
      {
        syslog(3, "io/hpmud/dot4.c 74: invalid data packet credit=%d\n", out_of_bound_channel->ta.p2hcredit);
        return 0;
      }

      unsigned short int return_value_ntohs$1;
      return_value_ntohs$1=ntohs(pCmd->h.length);
      size = (signed int)((unsigned long int)return_value_ntohs$1 - sizeof(struct anonymous) /*6ul*/ );
      if(!(16384 + -out_of_bound_channel->rcnt >= size))
      {
        syslog(3, "io/hpmud/dot4.c 81: invalid data packet size=%d\n", size);
        return 0;
      }

      memcpy((void *)&out_of_bound_channel->rbuf[(signed long int)out_of_bound_channel->rcnt], (const void *)(buf + (signed long int)sizeof(struct anonymous$21) /*6ul*/ ), (unsigned long int)size);
      out_of_bound_channel->rcnt = out_of_bound_channel->rcnt + size;
      if(!(pCmd->h.credit == 0))
        out_of_bound_channel->ta.h2pcredit = out_of_bound_channel->ta.h2pcredit + (unsigned short int)pCmd->h.credit;

      out_of_bound_channel->ta.p2hcredit = out_of_bound_channel->ta.p2hcredit - 1;
    }

    else
    {
      unsigned short int return_value_ntohs$2;
      return_value_ntohs$2=ntohs(pCmd->h.length);
      len = (signed int)return_value_ntohs$2;
      syslog(3, "io/hpmud/dot4.c 94: unsolicited data packet: psid=%x, ssid=%x, length=%d, credit=%d, status=%x\n", pCmd->h.psid, pCmd->h.ssid, len, pCmd->h.credit, pCmd->h.control);
    }
    return 0;
  }

  else
  {
    switch((signed int)pCmd->cmd)
    {
      case 3:
      {
        pCredit = (struct anonymous$9 *)buf;
        out_of_bound_channel = &pd->channel[(signed long int)pCredit->psocket];
        return_value_ntohs$4=ntohs(pCredit->credit);
        out_of_bound_channel->ta.h2pcredit = out_of_bound_channel->ta.h2pcredit + return_value_ntohs$4;
        pCreditReply = (struct anonymous$7 *)buf;
        pCreditReply->h.length=htons((unsigned short int)sizeof(struct anonymous$7) /*10ul*/ );
        pCreditReply->h.credit = (unsigned char)1;
        pCreditReply->h.control = (unsigned char)0;
        pCreditReply->cmd = pCreditReply->cmd | (unsigned char)0x80;
        pCreditReply->result = (unsigned char)0;
        pCreditReply->psocket = out_of_bound_channel->sockid;
        pCreditReply->ssocket = out_of_bound_channel->sockid;
        Dot4ForwardReply(pc, fd, (unsigned char *)pCreditReply, (signed int)sizeof(struct anonymous$7) /*10ul*/ );
        break;
      }
      case 4:
      {
        pCreditReq = (struct anonymous$10 *)buf;
        static signed int cnt;
        signed int tmp_post$6 = cnt;
        cnt = cnt + 1;
        if(!(tmp_post$6 >= 5))
        {
          return_value_ntohs$5=ntohs(pCreditReq->maxcredit);
          syslog(3, "io/hpmud/dot4.c 121: unexpected DOT4CreditRequest: cmd=%x, hid=%x, pid=%x, maxcredit=%d\n", pCreditReq->cmd, pCreditReq->psocket, pCreditReq->ssocket, return_value_ntohs$5);
        }

        Dot4ExecReverseCmd$$1$$socket = pCreditReq->ssocket;
        pCreditReqReply = (struct anonymous$11 *)buf;
        pCreditReqReply->h.length=htons((unsigned short int)sizeof(struct anonymous$11) /*12ul*/ );
        pCreditReqReply->h.credit = (unsigned char)1;
        pCreditReqReply->h.control = (unsigned char)0;
        pCreditReqReply->cmd = pCreditReqReply->cmd | (unsigned char)0x80;
        pCreditReqReply->result = (unsigned char)0;
        pCreditReqReply->psocket = Dot4ExecReverseCmd$$1$$socket;
        pCreditReqReply->ssocket = Dot4ExecReverseCmd$$1$$socket;
        pCreditReqReply->credit = (unsigned short int)0;
        Dot4ForwardReply(pc, fd, (unsigned char *)pCreditReqReply, (signed int)sizeof(struct anonymous$11) /*12ul*/ );
        break;
      }
      case 127:
      {
        pError = (struct anonymous$12 *)buf;
        syslog(3, "io/hpmud/dot4.c 136: unexpected DOT4Error: cmd=%x, psocket=%d, ssocket=%d, error=%x\n", pError->cmd, pError->psocket, pError->ssocket, pError->error);
        return 1;
      }
      default:
      {
        pReply = (struct anonymous$3 *)buf;
        syslog(3, "io/hpmud/dot4.c 140: unexpected command: cmd=%x, result=%x\n", pReply->cmd, pReply->result);
        pReply->h.length=htons((unsigned short int)sizeof(struct anonymous$3) /*8ul*/ );
        pReply->h.credit = (unsigned char)1;
        pReply->h.control = (unsigned char)0;
        pReply->cmd = pReply->cmd | (unsigned char)0x80;
        pReply->result = (unsigned char)1;
        Dot4ForwardReply(pc, fd, (unsigned char *)pReply, (signed int)sizeof(struct anonymous$3) /*8ul*/ );
      }
    }
    return 0;
  }
}

// Dot4Exit
// file io/hpmud/dot4.c line 341
signed int Dot4Exit(struct _mud_channel *pc, signed int fd)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char buf[16384l];
  signed int stat = 0;
  signed int len;
  signed int n;
  struct anonymous$2 *pCmd;
  struct anonymous$3 *pReply;
  memset((void *)buf, 0, sizeof(struct anonymous$2) /*7ul*/ );
  pCmd = (struct anonymous$2 *)buf;
  n = (signed int)sizeof(struct anonymous$2) /*7ul*/ ;
  pCmd->h.length=htons((unsigned short int)n);
  pCmd->h.credit = (unsigned char)1;
  pCmd->cmd = (unsigned char)8;
  len=pd->vf.write(fd, (const void *)pCmd, n, 45000000);
  if(!(len == n))
  {
    syslog(3, "io/hpmud/dot4.c 358: unable to write DOT4Exit: %m\n");
    stat = 1;
  }

  else
  {
    stat=Dot4ReverseReply(pc, fd, buf, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ );
    pReply = (struct anonymous$3 *)buf;
    _Bool tmp_if_expr$1;
    if(!(stat == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)pReply->cmd != (0x80 | 8) ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)pReply->result != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      syslog(3, "io/hpmud/dot4.c 368: invalid DOT4ExitReply: cmd=%x, result=%x\n", pReply->cmd, pReply->result);
      stat = 1;
    }

  }

bugout:
  ;
  return stat;
}

// Dot4ForwardData
// file io/hpmud/dot4.c line 422
signed int Dot4ForwardData(struct _mud_channel *pc, signed int fd, const void *buf, signed int size, signed int usec_timeout)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  signed int stat = 0;
  signed int len;
  signed int n;
  struct anonymous h;
  memset((void *)&h, 0, sizeof(struct anonymous) /*6ul*/ );
  n = (signed int)(sizeof(struct anonymous) /*6ul*/  + (unsigned long int)size);
  h.length=htons((unsigned short int)n);
  h.psid = pc->sockid;
  h.ssid = pc->sockid;
  len=pd->vf.write(fd, (const void *)&h, (signed int)sizeof(struct anonymous) /*6ul*/ , usec_timeout);
  if(!((unsigned long int)len == sizeof(struct anonymous) /*6ul*/ ))
  {
    syslog(3, "io/hpmud/dot4.c 436: unable to write Dot4ForwardData header: %m\n");
    stat = 1;
  }

  else
  {
    len=pd->vf.write(fd, buf, size, usec_timeout);
    if(!(len == size))
    {
      syslog(3, "io/hpmud/dot4.c 443: unable to write Dot4ForwardData: %m\n");
      stat = 1;
    }

  }

bugout:
  ;
  return stat;
}

// Dot4ForwardReply
// file io/hpmud/dot4.c line 34
static signed int Dot4ForwardReply(struct _mud_channel *pc, signed int fd, unsigned char *buf, signed int size)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  signed int len = 0;
  len=pd->vf.write(fd, (const void *)buf, size, 45000000);
  if(!(len == size))
    syslog(3, "io/hpmud/dot4.c 41: unable to Dot4ForwarReply: %m\n");

  return len;
}

// Dot4GetSocket
// file io/hpmud/dot4.c line 377
signed int Dot4GetSocket(struct _mud_channel *pc, signed int fd)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char buf[16384l];
  signed int stat = 0;
  signed int len;
  signed int n;
  struct anonymous$2 *pCmd;
  struct anonymous$8 *pReply;
  memset((void *)buf, 0, sizeof(struct anonymous$2) /*7ul*/ );
  pCmd = (struct anonymous$2 *)buf;
  n = (signed int)sizeof(struct anonymous$2) /*7ul*/ ;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(pc->sn);
  len = (signed int)return_value_strlen$1;
  memcpy((void *)(buf + (signed long int)sizeof(struct anonymous$2) /*7ul*/ ), (const void *)pc->sn, (unsigned long int)len);
  n = n + len;
  pCmd->h.length=htons((unsigned short int)n);
  pCmd->h.credit = (unsigned char)1;
  pCmd->cmd = (unsigned char)9;
  len=pd->vf.write(fd, (const void *)pCmd, n, 45000000);
  if(!(len == n))
  {
    syslog(3, "io/hpmud/dot4.c 397: unable to write DOT4GetSocket: %m\n");
    stat = 1;
  }

  else
  {
    stat=Dot4ReverseReply(pc, fd, buf, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ );
    pReply = (struct anonymous$8 *)buf;
    _Bool tmp_if_expr$2;
    if(!(stat == 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)pReply->cmd != (0x80 | 9) ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$3;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)pReply->result != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      syslog(3, "io/hpmud/dot4.c 407: invalid DOT4GetSocketReply: cmd=%x, result=%x\n", pReply->cmd, pReply->result);
      stat = 1;
    }

    else
    {
      pc->sockid = pReply->socket;
      if(!((signed int)pc->sockid == pc->index))
        syslog(3, "io/hpmud/dot4.c 415: invalid sockid match sockid=%d index=%d\n", pc->sockid, pc->index);

    }
  }

bugout:
  ;
  return stat;
}

// Dot4Init
// file io/hpmud/dot4.c line 277
signed int Dot4Init(struct _mud_channel *pc, signed int fd)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char buf[16384l];
  signed int stat = 0;
  signed int len;
  signed int n;
  signed int cnt;
  struct anonymous$0 *pCmd;
  struct anonymous$1 *pReply;
  memset((void *)buf, 0, sizeof(struct anonymous$0) /*8ul*/ );
  pCmd = (struct anonymous$0 *)buf;
  n = (signed int)sizeof(struct anonymous$0) /*8ul*/ ;
  pCmd->h.length=htons((unsigned short int)n);
  pCmd->h.credit = (unsigned char)1;
  pCmd->cmd = (unsigned char)0;
  pCmd->rev = (unsigned char)0x20;
  len=pd->vf.write(fd, (const void *)pCmd, n, 45000000);
  if(!(len == n))
  {
    syslog(3, "io/hpmud/dot4.c 295: unable to write DOT4Init: %m\n");
    stat = 1;
  }

  else
  {
    cnt = 0;
    {
      stat=Dot4ReverseReply(pc, fd, buf, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ );
      pReply = (struct anonymous$1 *)buf;
      _Bool tmp_if_expr$2;
      if(!(stat == 0))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)pReply->cmd != (0x80 | 0) ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$3;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)pReply->result != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        if(*return_value___errno_location$1 == 5)
        {
          if(!(cnt >= 1))
          {
            syslog(3, "io/hpmud/dot4.c 311: invalid DOT4InitReply retrying...\n");
            sleep((unsigned int)1);
            cnt = cnt + 1;
          }

        }

        if(stat == 2 && !(cnt >= 1))
        {
          syslog(3, "io/hpmud/dot4.c 319: invalid DOT4InitReply retrying command...\n");
          memset((void *)buf, 0, sizeof(struct anonymous$0) /*8ul*/ );
          n = (signed int)sizeof(struct anonymous$0) /*8ul*/ ;
          pCmd->h.length=htons((unsigned short int)n);
          pCmd->h.credit = (unsigned char)1;
          pCmd->cmd = (unsigned char)0;
          pCmd->rev = (unsigned char)0x20;
          pd->vf.write(fd, (const void *)pCmd, n, 45000000);
          cnt = cnt + 1;
        }

        syslog(3, "io/hpmud/dot4.c 330: invalid DOT4InitReply: cmd=%x, result=%x\n, revision=%x\n", pReply->cmd, pReply->result, pReply->rev);
        stat = 1;
      }

    }
  }

bugout:
  ;
  return stat;
}

// Dot4OpenChannel
// file io/hpmud/dot4.c line 585
signed int Dot4OpenChannel(struct _mud_channel *pc, signed int fd)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char buf[16384l];
  signed int stat = 0;
  signed int len;
  signed int n;
  struct anonymous$4 *pCmd;
  struct anonymous$5 *pReply;
  memset((void *)buf, 0, sizeof(struct anonymous$4) /*15ul*/ );
  pCmd = (struct anonymous$4 *)buf;
  n = (signed int)sizeof(struct anonymous$4) /*15ul*/ ;
  pCmd->h.length=htons((unsigned short int)n);
  pCmd->h.credit = (unsigned char)1;
  pCmd->cmd = (unsigned char)1;
  pCmd->psocket = pc->sockid;
  pCmd->ssocket = pc->sockid;
  pCmd->maxp2s=htons((unsigned short int)16384);
  pCmd->maxs2p=htons((unsigned short int)16384);
  pCmd->maxcredit=htons((unsigned short int)0xffff);
  len=pd->vf.write(fd, (const void *)pCmd, n, 45000000);
  if(!(len == n))
  {
    syslog(3, "io/hpmud/dot4.c 607: unable to write Dot4OpenChannel: %m\n");
    stat = 1;
  }

  else
  {
    stat=Dot4ReverseReply(pc, fd, buf, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ );
    pReply = (struct anonymous$5 *)buf;
    _Bool tmp_if_expr$1;
    if(!(stat == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)pReply->cmd != (0x80 | 1) ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)pReply->result != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      syslog(3, "io/hpmud/dot4.c 617: invalid Dot4OpenChannelReply: cmd=%x, result=%x\n", pReply->cmd, pReply->result);
      stat = 1;
    }

    else
    {
      pc->ta.h2psize=ntohs(pReply->maxp2s);
      pc->ta.p2hsize=ntohs(pReply->maxs2p);
      pc->ta.h2pcredit=ntohs(pReply->credit);
    }
  }

bugout:
  ;
  return stat;
}

// Dot4ReverseCmd
// file io/hpmud/dot4.c line 153
signed int Dot4ReverseCmd(struct _mud_channel *pc, signed int fd)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char buf[16384l];
  signed int stat = 0;
  signed int len;
  signed int size;
  unsigned int pklen;
  unsigned char *pBuf;
  struct anonymous$3 *pPk = (struct anonymous$3 *)buf;
  pBuf = buf;
  size = (signed int)sizeof(struct anonymous) /*6ul*/ ;
  if(size >= 1)
  {
    len=pd->vf.read(fd, (void *)pBuf, size, 45000000);
    if(!(len >= 0))
    {
      syslog(3, "io/hpmud/dot4.c 172: unable to read Dot4ReverseCmd header: %m\n");
      stat = 1;
    }

    size = size - len;
    pBuf = pBuf + (signed long int)len;
  }

  unsigned short int return_value_ntohs$1;
  return_value_ntohs$1=ntohs(pPk->h.length);
  pklen = (unsigned int)return_value_ntohs$1;
  if((unsigned long int)pklen >= 16385ul)
  {
    syslog(3, "io/hpmud/dot4.c 183: invalid Dot4ReverseCmd packet size: size=%d\n", pklen);
    stat = 1;
  }

  else
  {
    size = (signed int)((unsigned long int)pklen - sizeof(struct anonymous) /*6ul*/ );
    if(size >= 1)
    {
      len=pd->vf.read(fd, (void *)pBuf, size, 45000000);
      if(!(len >= 0))
      {
        syslog(3, "io/hpmud/dot4.c 194: unable to read Dot4ReverseCmd data: %m exp=%zd act=%zd\n", (unsigned long int)pklen - sizeof(struct anonymous) /*6ul*/ , ((unsigned long int)pklen - sizeof(struct anonymous) /*6ul*/ ) - (unsigned long int)size);
        stat = 1;
      }

      size = size - len;
      pBuf = pBuf + (signed long int)len;
    }

    stat=Dot4ExecReverseCmd(pc, fd, buf);
  }

bugout:
  ;
  return stat;
}

// Dot4ReverseData
// file io/hpmud/dot4.c line 453
signed int Dot4ReverseData(struct _mud_channel *pc, signed int fd, void *buf, signed int length, signed int usec_timeout)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  struct _mud_channel *out_of_bound_channel;
  signed int len;
  signed int size;
  signed int total;
  struct anonymous *pPk = (struct anonymous *)buf;
  while((_Bool)1)
  {
    total = 0;
    size = (signed int)sizeof(struct anonymous) /*6ul*/ ;
    if(size >= 1)
    {
      if(total == 0)
        len=pd->vf.read(fd, buf + (signed long int)total, size, usec_timeout);

      else
        len=pd->vf.read(fd, buf + (signed long int)total, size, 45000000);
      if(!(len >= 0))
      {
        if(total >= 1 || usec_timeout >= 45000000)
          syslog(3, "io/hpmud/dot4.c 480: unable to read Dot4ReverseData header: %m %s\n", (const void *)pd->uri);

        break;
      }

      size = size - len;
      total = total + len;
    }

    unsigned short int return_value_ntohs$1;
    return_value_ntohs$1=ntohs(pPk->length);
    size = (signed int)((unsigned long int)return_value_ntohs$1 - sizeof(struct anonymous) /*6ul*/ );
    if(!(length >= size))
    {
      syslog(3, "io/hpmud/dot4.c 492: invalid Dot4ReverseData size: size=%d, buf=%d\n", size, length);
      break;
    }

    if(!(pPk->psid == pc->sockid))
    {
      if(!(pPk->ssid == pc->sockid))
      {
        _Bool tmp_if_expr$2;
        if((signed int)pPk->psid == 0)
          tmp_if_expr$2 = (signed int)pPk->ssid == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
        {
          if(size >= 1)
          {
            len=pd->vf.read(fd, buf + (signed long int)total, size, 45000000);
            if(!(len >= 0))
            {
              syslog(3, "io/hpmud/dot4.c 506: unable to read Dot4ReverseData command: %m\n");
              break;
            }

            size = size - len;
            total = len;
          }

          Dot4ExecReverseCmd(pc, fd, (unsigned char *)buf);
          continue;
        }

        else
          if(pPk->psid == pPk->ssid)
          {
            out_of_bound_channel = &pd->channel[(signed long int)pPk->psid];
            unsigned char *pBuf;
            if(!((signed int)out_of_bound_channel->ta.p2hcredit >= 1))
            {
              syslog(3, "io/hpmud/dot4.c 523: invalid data packet credit=%d\n", out_of_bound_channel->ta.p2hcredit);
              break;
            }

            if(!(16384 + -out_of_bound_channel->rcnt >= size))
            {
              syslog(3, "io/hpmud/dot4.c 529: invalid data packet size=%d\n", size);
              break;
            }

            total = 0;
            pBuf = &out_of_bound_channel->rbuf[(signed long int)out_of_bound_channel->rcnt];
            if(size >= 1)
            {
              len=pd->vf.read(fd, (void *)(pBuf + (signed long int)total), size, 45000000);
              if(!(len >= 0))
              {
                syslog(3, "io/hpmud/dot4.c 539: unable to read MlcReverseData: %m\n");
                break;
              }

              size = size - len;
              total = total + len;
            }

            out_of_bound_channel->rcnt = out_of_bound_channel->rcnt + total;
            if(!(pPk->credit == 0))
              out_of_bound_channel->ta.h2pcredit = out_of_bound_channel->ta.h2pcredit + (unsigned short int)pPk->credit;

            out_of_bound_channel->ta.p2hcredit = out_of_bound_channel->ta.p2hcredit - 1;
            continue;
          }

          else
          {
            struct anonymous$2 *pCmd = (struct anonymous$2 *)buf;
            syslog(3, "io/hpmud/dot4.c 555: invalid Dot4ReverseData state: unexpected packet psid=%x, ssid=%x, cmd=%x\n", pPk->psid, pPk->ssid, pCmd->cmd);
            break;
          }
      }

    }

    if(!(pPk->credit == 0))
      pc->ta.h2pcredit = pc->ta.h2pcredit + (unsigned short int)pPk->credit;

    total = 0;
    if(size >= 1)
    {
      len=pd->vf.read(fd, buf + (signed long int)total, size, 45000000);
      if(!(len >= 0))
      {
        syslog(3, "io/hpmud/dot4.c 572: unable to read Dot4ReverseData: %m\n");
        break;
      }

      size = size - len;
      total = total + len;
    }

    break;
  }

bugout:
  ;
  return total;
}

// Dot4ReverseReply
// file io/hpmud/dot4.c line 212
static signed int Dot4ReverseReply(struct _mud_channel *pc, signed int fd, unsigned char *buf, signed int bufsize)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  signed int stat = 0;
  signed int len;
  signed int size;
  signed int pklen;
  unsigned char *pBuf;
  struct anonymous$3 *pPk = (struct anonymous$3 *)buf;
  while((_Bool)1)
  {
    pBuf = buf;
    size = (signed int)sizeof(struct anonymous) /*6ul*/ ;
    if(size >= 1)
    {
      len=pd->vf.read(fd, (void *)pBuf, size, 4000000);
      if(!(len >= 0))
      {
        syslog(3, "io/hpmud/dot4.c 231: unable to read Dot4ReverseReply header: %m bytesRead=%zd\n", sizeof(struct anonymous) /*6ul*/  - (unsigned long int)size);
        stat = 2;
        break;
      }

      size = size - len;
      pBuf = pBuf + (signed long int)len;
    }

    unsigned short int return_value_ntohs$1;
    return_value_ntohs$1=ntohs(pPk->h.length);
    pklen = (signed int)return_value_ntohs$1;
    if(!(pklen >= 1) || !(bufsize >= pklen))
    {
      syslog(3, "io/hpmud/dot4.c 243: invalid Dot4ReverseReply packet size: size=%d, buf=%d\n", pklen, bufsize);
      stat = 1;
      break;
    }

    size = (signed int)((unsigned long int)pklen - sizeof(struct anonymous) /*6ul*/ );
    if(size >= 1)
    {
      len=pd->vf.read(fd, (void *)pBuf, size, 45000000);
      if(!(len >= 0))
      {
        syslog(3, "io/hpmud/dot4.c 254: unable to read Dot4ReverseReply data: %m exp=%zd act=%zd\n", (unsigned long int)pklen - sizeof(struct anonymous) /*6ul*/ , ((unsigned long int)pklen - sizeof(struct anonymous) /*6ul*/ ) - (unsigned long int)size);
        stat = 1;
        break;
      }

      size = size - len;
      pBuf = pBuf + (signed long int)len;
    }

    if(!((0x80 & (signed int)pPk->cmd) == 0))
      break;

    stat=Dot4ExecReverseCmd(pc, fd, buf);
    if(!(stat == 0))
      break;

  }

bugout:
  ;
  return stat;
}

// GetPair
// file io/hpmud/model.c line 56
static signed int GetPair(char *buf, signed int buf_len, char *key, char *value, char **tail)
{
  signed int i = 0;
  signed int j;
  key[(signed long int)0] = (char)0;
  value[(signed long int)0] = (char)0;
  if((signed int)buf[(signed long int)i] == 35)
  {
    for( ; !((signed int)buf[(signed long int)i] == 10) && !(i >= buf_len); i = i + 1)
      ;
    if((signed int)buf[(signed long int)i] == 10)
      i = i + 1;

  }

  j = 0;
  while(!((signed int)buf[(signed long int)i] == 61))
  {
    if(i >= buf_len)
      break;

    if(j >= 256)
      break;

    signed int tmp_post$1 = j;
    j = j + 1;
    signed int tmp_post$2 = i;
    i = i + 1;
    key[(signed long int)tmp_post$1] = buf[(signed long int)tmp_post$2];
  }
  j = j - 1;
  for( ; (signed int)key[(signed long int)j] == 32 && j >= 1; j = j - 1)
    ;
  j = j + 1;
  key[(signed long int)j] = (char)0;
  if((signed int)buf[(signed long int)i] == 61)
  {
    i = i + 1;
    for( ; (signed int)buf[(signed long int)i] == 32 && !(i >= buf_len); i = i + 1)
      ;
  }

  j = 0;
  while(!((signed int)buf[(signed long int)i] == 10))
  {
    if(i >= buf_len)
      break;

    if(j >= 256)
      break;

    signed int tmp_post$3 = j;
    j = j + 1;
    signed int tmp_post$4 = i;
    i = i + 1;
    value[(signed long int)tmp_post$3] = buf[(signed long int)tmp_post$4];
  }
  j = j - 1;
  for( ; (signed int)value[(signed long int)j] == 32 && j >= 1; j = j - 1)
    ;
  j = j + 1;
  value[(signed long int)j] = (char)0;
  if((signed int)buf[(signed long int)i] == 10)
    i = i + 1;

  if(!(tail == ((char **)NULL)))
    *tail = buf + (signed long int)i;

  return i;
}

// GetPair$link1
// file common/utils.c line 10
static signed int GetPair$link1(char *buf$link1, signed int buf_len$link1, char *key$link1, char *value$link1, char **tail$link1)
{
  signed int i$link1 = 0;
  signed int j$link1;
  key$link1[(signed long int)0] = (char)0;
  value$link1[(signed long int)0] = (char)0;
  if((signed int)buf$link1[(signed long int)i$link1] == 35)
  {
    for( ; !((signed int)buf$link1[(signed long int)i$link1] == 10) && !(i$link1 >= buf_len$link1); i$link1 = i$link1 + 1)
      ;
    if((signed int)buf$link1[(signed long int)i$link1] == 10)
      i$link1 = i$link1 + 1;

  }

  j$link1 = 0;
  while(!((signed int)buf$link1[(signed long int)i$link1] == 61))
  {
    if(i$link1 >= buf_len$link1)
      break;

    if(j$link1 >= 256)
      break;

    signed int tmp_post$1$link1 = j$link1;
    j$link1 = j$link1 + 1;
    signed int tmp_post$2$link1 = i$link1;
    i$link1 = i$link1 + 1;
    key$link1[(signed long int)tmp_post$1$link1] = buf$link1[(signed long int)tmp_post$2$link1];
  }
  j$link1 = j$link1 - 1;
  for( ; (signed int)key$link1[(signed long int)j$link1] == 32 && j$link1 >= 1; j$link1 = j$link1 - 1)
    ;
  j$link1 = j$link1 + 1;
  key$link1[(signed long int)j$link1] = (char)0;
  if((signed int)buf$link1[(signed long int)i$link1] == 61)
  {
    i$link1 = i$link1 + 1;
    for( ; (signed int)buf$link1[(signed long int)i$link1] == 32 && !(i$link1 >= buf_len$link1); i$link1 = i$link1 + 1)
      ;
  }

  j$link1 = 0;
  while(!((signed int)buf$link1[(signed long int)i$link1] == 10))
  {
    if(i$link1 >= buf_len$link1)
      break;

    if(j$link1 >= 256)
      break;

    signed int tmp_post$3$link1 = j$link1;
    j$link1 = j$link1 + 1;
    signed int tmp_post$4$link1 = i$link1;
    i$link1 = i$link1 + 1;
    value$link1[(signed long int)tmp_post$3$link1] = buf$link1[(signed long int)tmp_post$4$link1];
  }
  j$link1 = j$link1 - 1;
  for( ; (signed int)value$link1[(signed long int)j$link1] == 32 && j$link1 >= 1; j$link1 = j$link1 - 1)
    ;
  j$link1 = j$link1 + 1;
  value$link1[(signed long int)j$link1] = (char)0;
  if((signed int)buf$link1[(signed long int)i$link1] == 10)
    i$link1 = i$link1 + 1;

  if(!(tail$link1 == ((char **)NULL)))
    *tail$link1 = buf$link1 + (signed long int)i$link1;

  return i$link1;
}

// GetSnmp
// file io/hpmud/pml.c line 212
signed int GetSnmp(const char *ip, signed int port, const char *szoid, void *buffer, unsigned int size, signed int *type, signed int *pml_result, signed int *result)
{
  struct snmp_session session;
  struct snmp_session *ss = (struct snmp_session *)(void *)0;
  struct snmp_pdu *pdu = (struct snmp_pdu *)(void *)0;
  struct snmp_pdu *response = (struct snmp_pdu *)(void *)0;
  unsigned int i;
  unsigned int len = (unsigned int)0;
  unsigned long int anOID[128l];
  unsigned long int anOID_len = (unsigned long int)128;
  struct variable_list *vars;
  unsigned int val;
  unsigned char tmp[(signed long int)sizeof(unsigned int) /*4l*/ ];
  *result = HPMUD_R_IO_ERROR;
  *type = 28;
  *pml_result = 128;
  init_snmp("snmpapp");
  snmp_sess_init(&session);
  session.peername = (char *)ip;
  session.version = (signed long int)0;
  session.community = (unsigned char *)SnmpPort[(signed long int)port];
  session.community_len=strlen((const char *)session.community);
  session.retries = 1;
  session.timeout = (signed long int)1000000;
  ss=snmp_open(&session);
  signed int return_value_snmp_synch_response$1;
  if(!(ss == ((struct snmp_session *)NULL)))
  {
    pdu=snmp_pdu_create((signed int)(unsigned char)0x80 | (signed int)(unsigned char)0x20 | 0x0);
    read_objid(szoid, anOID, &anOID_len);
    snmp_add_null_var(pdu, anOID, anOID_len);
    return_value_snmp_synch_response$1=snmp_synch_response(ss, pdu, &response);
    if(return_value_snmp_synch_response$1 == 0)
    {
      if(response->errstat == 0l)
      {
        vars = response->variables;
        switch((signed int)vars->type)
        {
          case (signed int)(unsigned char)0x02:
          {
            *type = 8;
            len = (unsigned int)(sizeof(unsigned int) /*4ul*/  < (unsigned long int)size ? sizeof(unsigned int) /*4ul*/  : (unsigned long int)size);
            val = (unsigned int)*vars->val.integer;
            i = len;
            for( ; i >= 1u; i = i - 1u)
            {
              tmp[(signed long int)(i - (unsigned int)1)] = (unsigned char)(val & (unsigned int)0xff);
              val = val >> 8;
            }
            for( ; (signed int)tmp[(signed long int)i] == 0 && !(i >= len); i = i + 1u)
              ;
            len = len - i;
            memcpy(buffer, (const void *)(tmp + (signed long int)i), (unsigned long int)len);
            goto __CPROVER_DUMP_L10;
          }
          case (signed int)(unsigned char)0x05:
          {
            *type = 28;
            goto __CPROVER_DUMP_L10;
          }
          case (signed int)(unsigned char)0x04:
          {
            *type = 16;
            unsigned long int tmp_if_expr$2;
            if(!(vars->val_len >= (unsigned long int)size))
              tmp_if_expr$2 = vars->val_len;

            else
              tmp_if_expr$2 = (unsigned long int)size;
            len = (unsigned int)tmp_if_expr$2;
            memcpy(buffer, (const void *)vars->val.string, (unsigned long int)len);
            goto __CPROVER_DUMP_L10;
          }
          default:
            syslog(3, "io/hpmud/pml.c 282: unable to GetSnmp: data type=%d\n", vars->type);
        }
      }

      else
      {

      __CPROVER_DUMP_L10:
        ;
        *pml_result=SnmpErrorToPml((signed int)response->errstat);
        *result = HPMUD_R_OK;
      }
    }

  }


bugout:
  ;
  if(!(response == ((struct snmp_pdu *)NULL)))
    snmp_free_pdu(response);

  if(!(ss == ((struct snmp_session *)NULL)))
    snmp_close(ss);

  return (signed int)len;
}

// MlcCloseChannel
// file io/hpmud/mlc.c line 654
signed int MlcCloseChannel(struct _mud_channel *pc, signed int fd)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char buf[16384l];
  signed int stat = 0;
  signed int len;
  signed int n;
  struct anonymous$27 *pCmd;
  struct anonymous$22 *pReply;
  memset((void *)buf, 0, sizeof(struct anonymous$27) /*9ul*/ );
  pCmd = (struct anonymous$27 *)buf;
  n = (signed int)sizeof(struct anonymous$27) /*9ul*/ ;
  pCmd->h.length=htons((unsigned short int)n);
  pCmd->cmd = (unsigned char)2;
  pCmd->hsocket = pc->sockid;
  pCmd->psocket = pc->sockid;
  len=pd->vf.write(fd, (const void *)pCmd, n, 45000000);
  if(!(len == n))
  {
    syslog(3, "io/hpmud/mlc.c 672: unable to write MlcCloseChannel: %m\n");
    stat = 1;
  }

  else
  {
    stat=MlcReverseReply(pc, fd, buf, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ );
    pReply = (struct anonymous$22 *)buf;
    _Bool tmp_if_expr$1;
    if(!(stat == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)pReply->cmd != (0x80 | 2) ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)pReply->result != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      syslog(3, "io/hpmud/mlc.c 682: invalid MlcCloseChannelReply: cmd=%x, result=%x\n", pReply->cmd, pReply->result);
      stat = 1;
    }

  }

bugout:
  ;
  return stat;
}

// MlcConfigSocket
// file io/hpmud/mlc.c line 403
signed int MlcConfigSocket(struct _mud_channel *pc, signed int fd)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char buf[16384l];
  signed int stat = 0;
  signed int len;
  signed int n;
  struct anonymous$23 *pCmd;
  struct anonymous$24 *pReply;
  if((signed int)pc->ta.h2psize >= 1)
    return stat;

  else
  {
    memset((void *)buf, 0, sizeof(struct anonymous$23) /*13ul*/ );
    pCmd = (struct anonymous$23 *)buf;
    n = (signed int)sizeof(struct anonymous$23) /*13ul*/ ;
    pCmd->h.length=htons((unsigned short int)n);
    pCmd->cmd = (unsigned char)7;
    pCmd->socket = pc->sockid;
    pCmd->h2psize=htons((unsigned short int)16384);
    pCmd->p2hsize=htons((unsigned short int)16384);
    pCmd->status = (unsigned char)0;
    len=pd->vf.write(fd, (const void *)pCmd, n, 45000000);
    if(!(len == n))
    {
      syslog(3, "io/hpmud/mlc.c 426: unable to write MLCConfigSocket: %m\n");
      stat = 1;
    }

    else
    {
      stat=MlcReverseReply(pc, fd, buf, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ );
      pReply = (struct anonymous$24 *)buf;
      _Bool tmp_if_expr$1;
      if(!(stat == 0))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)pReply->cmd != (0x80 | 7) ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$2;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)pReply->result != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
      {
        syslog(3, "io/hpmud/mlc.c 436: invalid MLCConfigSocketReply: cmd=%x, result=%x\n", pReply->cmd, pReply->result);
        stat = 1;
      }

      else
      {
        pc->ta.h2psize=ntohs(pReply->h2psize);
        pc->ta.p2hsize=ntohs(pReply->p2hsize);
      }
    }

  bugout:
    ;
    return stat;
  }
}

// MlcCredit
// file io/hpmud/mlc.c line 691
signed int MlcCredit(struct _mud_channel *pc, signed int fd, unsigned short int credit)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char buf[16384l];
  signed int stat = 0;
  signed int len;
  signed int n;
  struct anonymous$25 *pCmd;
  struct anonymous$22 *pReply;
  memset((void *)buf, 0, sizeof(struct anonymous$25) /*11ul*/ );
  pCmd = (struct anonymous$25 *)buf;
  n = (signed int)sizeof(struct anonymous$25) /*11ul*/ ;
  pCmd->h.length=htons((unsigned short int)n);
  pCmd->cmd = (unsigned char)3;
  pCmd->hsocket = pc->sockid;
  pCmd->psocket = pc->sockid;
  pCmd->credit=htons(credit);
  len=pd->vf.write(fd, (const void *)pCmd, n, 45000000);
  if(!(len == n))
  {
    syslog(3, "io/hpmud/mlc.c 710: unable to write MlcCredit: %m\n");
    stat = 1;
  }

  else
  {
    stat=MlcReverseReply(pc, fd, buf, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ );
    pReply = (struct anonymous$22 *)buf;
    _Bool tmp_if_expr$1;
    if(!(stat == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)pReply->cmd != (0x80 | 3) ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)pReply->result != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      syslog(3, "io/hpmud/mlc.c 720: invalid MlcCreditReply: cmd=%x, result=%x\n", pReply->cmd, pReply->result);
      stat = 1;
    }

    else
      pc->ta.p2hcredit = pc->ta.p2hcredit + credit;
  }

bugout:
  ;
  return stat;
}

// MlcCreditRequest
// file io/hpmud/mlc.c line 731
signed int MlcCreditRequest(struct _mud_channel *pc, signed int fd, unsigned short int credit)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char buf[16384l];
  signed int stat = 0;
  signed int len;
  signed int n;
  struct anonymous$25 *pCmd;
  struct anonymous$26 *pReply;
  memset((void *)buf, 0, sizeof(struct anonymous$25) /*11ul*/ );
  pCmd = (struct anonymous$25 *)buf;
  n = (signed int)sizeof(struct anonymous$25) /*11ul*/ ;
  pCmd->h.length=htons((unsigned short int)n);
  pCmd->cmd = (unsigned char)4;
  pCmd->hsocket = pc->sockid;
  pCmd->psocket = pc->sockid;
  pCmd->credit=htons(credit);
  len=pd->vf.write(fd, (const void *)pCmd, n, 45000000);
  unsigned short int return_value_ntohs$3;
  if(!(len == n))
  {
    syslog(3, "io/hpmud/mlc.c 750: unable to write MlcCreditRequest: %m\n");
    stat = 1;
  }

  else
  {
    stat=MlcReverseReply(pc, fd, buf, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ );
    pReply = (struct anonymous$26 *)buf;
    _Bool tmp_if_expr$1;
    if(!(stat == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)pReply->cmd != (0x80 | 4) ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)pReply->result != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      syslog(3, "io/hpmud/mlc.c 760: invalid MlcCreditRequestReply: cmd=%x, result=%x\n", pReply->cmd, pReply->result);
      stat = 1;
    }

    else
    {
      return_value_ntohs$3=ntohs(pReply->credit);
      pc->ta.h2pcredit = pc->ta.h2pcredit + return_value_ntohs$3;
    }
  }

bugout:
  ;
  return stat;
}

// MlcExecReverseCmd
// file io/hpmud/mlc.c line 66
static signed int MlcExecReverseCmd(struct _mud_channel *pc, signed int fd, unsigned char *buf)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  struct _mud_channel *out_of_bound_channel;
  struct anonymous$29 *pCmd;
  struct anonymous$22 *pReply;
  struct anonymous$25 *pCredit;
  struct anonymous$22 *pCreditReply;
  struct anonymous$25 *pCreditReq;
  struct anonymous$26 *pCreditReqReply;
  struct anonymous$22 *pError;
  signed int len;
  signed int size;
  pCmd = (struct anonymous$29 *)buf;
  _Bool tmp_if_expr$3;
  if((signed int)pCmd->h.hsid == 0)
    tmp_if_expr$3 = (signed int)pCmd->h.psid == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  unsigned short int return_value_ntohs$4;
  unsigned short int return_value_ntohs$5;
  if(!tmp_if_expr$3)
  {
    if(pCmd->h.hsid == pCmd->h.psid)
    {
      out_of_bound_channel = &pd->channel[(signed long int)pCmd->h.hsid];
      if(!((signed int)out_of_bound_channel->ta.p2hcredit >= 1))
      {
        syslog(3, "io/hpmud/mlc.c 92: invalid data packet credit=%d\n", out_of_bound_channel->ta.p2hcredit);
        return 0;
      }

      unsigned short int return_value_ntohs$1;
      return_value_ntohs$1=ntohs(pCmd->h.length);
      size = (signed int)((unsigned long int)return_value_ntohs$1 - sizeof(struct anonymous$21) /*6ul*/ );
      if(!(16384 + -out_of_bound_channel->rcnt >= size))
      {
        syslog(3, "io/hpmud/mlc.c 99: invalid data packet size=%d\n", size);
        return 0;
      }

      memcpy((void *)&out_of_bound_channel->rbuf[(signed long int)out_of_bound_channel->rcnt], (const void *)(buf + (signed long int)sizeof(struct anonymous$21) /*6ul*/ ), (unsigned long int)size);
      out_of_bound_channel->rcnt = out_of_bound_channel->rcnt + size;
      if(!(pCmd->h.credit == 0))
        out_of_bound_channel->ta.h2pcredit = out_of_bound_channel->ta.h2pcredit + (unsigned short int)pCmd->h.credit;

      out_of_bound_channel->ta.p2hcredit = out_of_bound_channel->ta.p2hcredit - 1;
    }

    else
    {
      unsigned short int return_value_ntohs$2;
      return_value_ntohs$2=ntohs(pCmd->h.length);
      len = (signed int)return_value_ntohs$2;
      syslog(3, "io/hpmud/mlc.c 112: unsolicited data packet: hsid=%x, psid=%x, length=%d, credit=%d, status=%x\n", pCmd->h.hsid, pCmd->h.psid, len, pCmd->h.credit, pCmd->h.status);
    }
    return 0;
  }

  else
  {
    switch((signed int)pCmd->cmd)
    {
      case 3:
      {
        pCredit = (struct anonymous$25 *)buf;
        out_of_bound_channel = &pd->channel[(signed long int)pCredit->hsocket];
        return_value_ntohs$4=ntohs(pCredit->credit);
        out_of_bound_channel->ta.h2pcredit = out_of_bound_channel->ta.h2pcredit + return_value_ntohs$4;
        pCreditReply = (struct anonymous$22 *)buf;
        pCreditReply->h.length=htons((unsigned short int)sizeof(struct anonymous$22) /*8ul*/ );
        pCreditReply->cmd = pCreditReply->cmd | (unsigned char)0x80;
        pCreditReply->result = (unsigned char)0;
        MlcForwardReply(pc, fd, (unsigned char *)pCreditReply, (signed int)sizeof(struct anonymous$22) /*8ul*/ );
        break;
      }
      case 4:
      {
        pCreditReq = (struct anonymous$25 *)buf;
        static signed int cnt;
        signed int tmp_post$6 = cnt;
        cnt = cnt + 1;
        if(!(tmp_post$6 >= 5))
        {
          return_value_ntohs$5=ntohs(pCreditReq->credit);
          syslog(3, "io/hpmud/mlc.c 135: unexpected MLCCreditRequest: cmd=%x, hid=%x, pid=%x, credit=%d\n", pCreditReq->cmd, pCreditReq->hsocket, pCreditReq->psocket, return_value_ntohs$5);
        }

        pCreditReqReply = (struct anonymous$26 *)buf;
        pCreditReqReply->h.length=htons((unsigned short int)sizeof(struct anonymous$26) /*10ul*/ );
        pCreditReqReply->cmd = pCreditReqReply->cmd | (unsigned char)0x80;
        pCreditReqReply->result = (unsigned char)0;
        pCreditReqReply->credit = (unsigned short int)0;
        MlcForwardReply(pc, fd, (unsigned char *)pCreditReqReply, (signed int)sizeof(struct anonymous$26) /*10ul*/ );
        break;
      }
      case 127:
      {
        pError = (struct anonymous$22 *)buf;
        syslog(3, "io/hpmud/mlc.c 145: unexpected MLCError: cmd=%x, result=%x\n", pError->cmd, pError->result);
        return 1;
      }
      default:
      {
        pReply = (struct anonymous$22 *)buf;
        syslog(3, "io/hpmud/mlc.c 149: unexpected command: cmd=%x, result=%x\n", pReply->cmd, pReply->result);
        pReply->h.length=htons((unsigned short int)sizeof(struct anonymous$22) /*8ul*/ );
        pReply->cmd = pReply->cmd | (unsigned char)0x80;
        pReply->result = (unsigned char)1;
        MlcForwardReply(pc, fd, (unsigned char *)pReply, (signed int)sizeof(struct anonymous$22) /*8ul*/ );
      }
    }
    return 0;
  }
}

// MlcExit
// file io/hpmud/mlc.c line 368
signed int MlcExit(struct _mud_channel *pc, signed int fd)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char buf[16384l];
  signed int stat = 0;
  signed int len;
  signed int n;
  struct anonymous$29 *pCmd;
  struct anonymous$22 *pReply;
  memset((void *)buf, 0, sizeof(struct anonymous$29) /*7ul*/ );
  pCmd = (struct anonymous$29 *)buf;
  n = (signed int)sizeof(struct anonymous$29) /*7ul*/ ;
  pCmd->h.length=htons((unsigned short int)n);
  pCmd->cmd = (unsigned char)8;
  len=pd->vf.write(fd, (const void *)pCmd, n, 45000000);
  if(!(len == n))
  {
    syslog(3, "io/hpmud/mlc.c 384: unable to write MLCExit: %m\n");
    stat = 1;
  }

  else
  {
    stat=MlcReverseReply(pc, fd, buf, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ );
    pReply = (struct anonymous$22 *)buf;
    _Bool tmp_if_expr$1;
    if(!(stat == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)pReply->cmd != (0x80 | 8) ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)pReply->result != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      syslog(3, "io/hpmud/mlc.c 394: invalid MLCExitReply: cmd=%x, result=%x\n", pReply->cmd, pReply->result);
      stat = 1;
    }

  }

bugout:
  ;
  return stat;
}

// MlcForwardData
// file io/hpmud/mlc.c line 449
signed int MlcForwardData(struct _mud_channel *pc, signed int fd, const void *buf, signed int size, signed int usec_timeout)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  signed int stat = 0;
  signed int len;
  signed int n;
  struct anonymous$21 h;
  memset((void *)&h, 0, sizeof(struct anonymous$21) /*6ul*/ );
  n = (signed int)(sizeof(struct anonymous$21) /*6ul*/  + (unsigned long int)size);
  h.length=htons((unsigned short int)n);
  h.hsid = pc->sockid;
  h.psid = pc->sockid;
  len=pd->vf.write(fd, (const void *)&h, (signed int)sizeof(struct anonymous$21) /*6ul*/ , usec_timeout);
  if(!((unsigned long int)len == sizeof(struct anonymous$21) /*6ul*/ ))
  {
    syslog(3, "io/hpmud/mlc.c 463: unable to write MlcForwardData header: %m\n");
    stat = 1;
  }

  else
  {
    len=pd->vf.write(fd, buf, size, usec_timeout);
    if(!(len == size))
    {
      syslog(3, "io/hpmud/mlc.c 470: unable to write MlcForwardData: %m\n");
      stat = 1;
    }

  }

bugout:
  ;
  return stat;
}

// MlcForwardReply
// file io/hpmud/mlc.c line 53
static signed int MlcForwardReply(struct _mud_channel *pc, signed int fd, unsigned char *buf, signed int size)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  signed int len = 0;
  len=pd->vf.write(fd, (const void *)buf, size, 45000000);
  if(!(len == size))
    syslog(3, "io/hpmud/mlc.c 60: unable to MlcForwarReply: %m\n");

  return len;
}

// MlcInit
// file io/hpmud/mlc.c line 306
signed int MlcInit(struct _mud_channel *pc, signed int fd)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char buf[16384l];
  signed int stat = 0;
  signed int len;
  signed int n;
  signed int cnt;
  struct anonymous$30 *pCmd;
  struct anonymous$31 *pReply;
  memset((void *)buf, 0, sizeof(struct anonymous$30) /*8ul*/ );
  pCmd = (struct anonymous$30 *)buf;
  n = (signed int)sizeof(struct anonymous$30) /*8ul*/ ;
  pCmd->h.length=htons((unsigned short int)n);
  pCmd->cmd = (unsigned char)0;
  pCmd->rev = (unsigned char)3;
  len=pd->vf.write(fd, (const void *)pCmd, n, 45000000);
  if(!(len == n))
  {
    syslog(3, "io/hpmud/mlc.c 323: unable to write MLCInit: %m\n");
    stat = 1;
  }

  else
  {
    cnt = 0;
    {
      stat=MlcReverseReply(pc, fd, buf, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ );
      pReply = (struct anonymous$31 *)buf;
      _Bool tmp_if_expr$2;
      if(!(stat == 0))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)pReply->cmd != (0x80 | 0) ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$3;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)pReply->result != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        if(*return_value___errno_location$1 == 5)
        {
          if(!(cnt >= 1))
          {
            syslog(3, "io/hpmud/mlc.c 339: invalid MLCInitReply retrying...\n");
            sleep((unsigned int)1);
            cnt = cnt + 1;
          }

        }

        if(stat == 2 && !(cnt >= 1))
        {
          syslog(3, "io/hpmud/mlc.c 347: invalid MLCInitReply retrying command...\n");
          memset((void *)buf, 0, sizeof(struct anonymous$30) /*8ul*/ );
          n = (signed int)sizeof(struct anonymous$30) /*8ul*/ ;
          pCmd->h.length=htons((unsigned short int)n);
          pCmd->cmd = (unsigned char)0;
          pCmd->rev = (unsigned char)3;
          pd->vf.write(fd, (const void *)pCmd, n, 45000000);
          cnt = cnt + 1;
        }

        syslog(3, "io/hpmud/mlc.c 357: invalid MLCInitReply: cmd=%x, result=%x\n, revision=%x\n", pReply->cmd, pReply->result, pReply->rev);
        stat = 1;
      }

    }
  }

bugout:
  ;
  return stat;
}

// MlcOpenChannel
// file io/hpmud/mlc.c line 613
signed int MlcOpenChannel(struct _mud_channel *pc, signed int fd)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char buf[16384l];
  signed int stat = 0;
  signed int len;
  signed int n;
  struct anonymous$25 *pCmd;
  struct anonymous$26 *pReply;
  memset((void *)buf, 0, sizeof(struct anonymous$25) /*11ul*/ );
  pCmd = (struct anonymous$25 *)buf;
  n = (signed int)sizeof(struct anonymous$25) /*11ul*/ ;
  pCmd->h.length=htons((unsigned short int)n);
  pCmd->cmd = (unsigned char)1;
  pCmd->hsocket = pc->sockid;
  pCmd->psocket = pc->sockid;
  pCmd->credit=htons((unsigned short int)0);
  len=pd->vf.write(fd, (const void *)pCmd, n, 45000000);
  if(!(len == n))
  {
    syslog(3, "io/hpmud/mlc.c 633: unable to write MlcOpenChannel: %m\n");
    stat = 1;
  }

  else
  {
    stat=MlcReverseReply(pc, fd, buf, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ );
    pReply = (struct anonymous$26 *)buf;
    _Bool tmp_if_expr$1;
    if(!(stat == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)pReply->cmd != (0x80 | 1) ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)pReply->result != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      syslog(3, "io/hpmud/mlc.c 643: invalid MlcOpenChannelReply: cmd=%x, result=%x\n", pReply->cmd, pReply->result);
      stat = 1;
    }

    else
      pc->ta.h2pcredit=ntohs(pReply->credit);
  }

bugout:
  ;
  return stat;
}

// MlcReverseCmd
// file io/hpmud/mlc.c line 160
signed int MlcReverseCmd(struct _mud_channel *pc, signed int fd)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char buf[16384l];
  signed int stat = 0;
  signed int len;
  signed int size;
  unsigned int pklen;
  unsigned char *pBuf;
  struct anonymous$22 *pPk = (struct anonymous$22 *)buf;
  pBuf = buf;
  size = (signed int)sizeof(struct anonymous$21) /*6ul*/ ;
  if(size >= 1)
  {
    len=pd->vf.read(fd, (void *)pBuf, size, 45000000);
    if(!(len >= 0))
    {
      syslog(3, "io/hpmud/mlc.c 179: unable to read MlcReverseCmd header: %m\n");
      stat = 1;
    }

    size = size - len;
    pBuf = pBuf + (signed long int)len;
  }

  unsigned short int return_value_ntohs$1;
  return_value_ntohs$1=ntohs(pPk->h.length);
  pklen = (unsigned int)return_value_ntohs$1;
  if((unsigned long int)pklen >= 16385ul)
  {
    syslog(3, "io/hpmud/mlc.c 190: invalid MlcReverseCmd packet size: size=%d\n", pklen);
    stat = 1;
  }

  else
  {
    size = (signed int)((unsigned long int)pklen - sizeof(struct anonymous$21) /*6ul*/ );
    if(size >= 1)
    {
      len=pd->vf.read(fd, (void *)pBuf, size, 45000000);
      if(!(len >= 0))
      {
        syslog(3, "io/hpmud/mlc.c 201: unable to read MlcReverseCmd data: %m\n");
        stat = 1;
      }

      size = size - len;
      pBuf = pBuf + (signed long int)len;
    }

    stat=MlcExecReverseCmd(pc, fd, buf);
  }

bugout:
  ;
  return stat;
}

// MlcReverseData
// file io/hpmud/mlc.c line 480
signed int MlcReverseData(struct _mud_channel *pc, signed int fd, void *buf, signed int length, signed int usec_timeout)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  struct _mud_channel *out_of_bound_channel;
  signed int len;
  signed int size;
  signed int total;
  struct anonymous$21 *pPk = (struct anonymous$21 *)buf;
  while((_Bool)1)
  {
    total = 0;
    size = (signed int)sizeof(struct anonymous$21) /*6ul*/ ;
    if(size >= 1)
    {
      if(total == 0)
        len=pd->vf.read(fd, buf + (signed long int)total, size, usec_timeout);

      else
        len=pd->vf.read(fd, buf + (signed long int)total, size, 45000000);
      if(!(len >= 0))
      {
        if(total >= 1 || usec_timeout >= 45000000)
          syslog(3, "io/hpmud/mlc.c 507: unable to read MlcReverseData header: %m %s\n", (const void *)pd->uri);

        break;
      }

      size = size - len;
      total = total + len;
    }

    unsigned short int return_value_ntohs$1;
    return_value_ntohs$1=ntohs(pPk->length);
    size = (signed int)((unsigned long int)return_value_ntohs$1 - sizeof(struct anonymous$21) /*6ul*/ );
    if(!(length >= size))
    {
      syslog(3, "io/hpmud/mlc.c 519: invalid MlcReverseData size: size=%d, buf=%d\n", size, length);
      break;
    }

    if(!(pPk->hsid == pc->sockid))
    {
      if(!(pPk->psid == pc->sockid))
      {
        _Bool tmp_if_expr$3;
        if((signed int)pPk->hsid == 0)
          tmp_if_expr$3 = (signed int)pPk->psid == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
        {
          if(size >= 1)
          {
            len=pd->vf.read(fd, buf + (signed long int)total, size, 45000000);
            if(!(len >= 0))
            {
              syslog(3, "io/hpmud/mlc.c 533: unable to read MlcReverseData command: %m\n");
              break;
            }

            size = size - len;
            total = len;
          }

          MlcExecReverseCmd(pc, fd, (unsigned char *)buf);
          continue;
        }

        else
          if(pPk->hsid == pPk->psid)
          {
            out_of_bound_channel = &pd->channel[(signed long int)pPk->hsid];
            unsigned char *pBuf;
            if(!((signed int)out_of_bound_channel->ta.p2hcredit >= 1))
            {
              syslog(3, "io/hpmud/mlc.c 550: invalid data packet credit=%d\n", out_of_bound_channel->ta.p2hcredit);
              break;
            }

            if(!(16384 + -out_of_bound_channel->rcnt >= size))
            {
              syslog(3, "io/hpmud/mlc.c 556: invalid data packet size=%d\n", size);
              break;
            }

            total = 0;
            pBuf = &out_of_bound_channel->rbuf[(signed long int)out_of_bound_channel->rcnt];
            if(size >= 1)
            {
              len=pd->vf.read(fd, (void *)(pBuf + (signed long int)total), size, 45000000);
              if(!(len >= 0))
              {
                syslog(3, "io/hpmud/mlc.c 566: unable to read MlcReverseData: %m\n");
                break;
              }

              size = size - len;
              total = total + len;
            }

            out_of_bound_channel->rcnt = out_of_bound_channel->rcnt + total;
            if(!(pPk->credit == 0))
              out_of_bound_channel->ta.h2pcredit = out_of_bound_channel->ta.h2pcredit + (unsigned short int)pPk->credit;

            out_of_bound_channel->ta.p2hcredit = out_of_bound_channel->ta.p2hcredit - 1;
            continue;
          }

          else
          {
            struct anonymous$29 *pCmd = (struct anonymous$29 *)buf;
            unsigned short int return_value_ntohs$2;
            return_value_ntohs$2=ntohs(pPk->length);
            syslog(3, "io/hpmud/mlc.c 583: invalid MlcReverseData state: exp hsid=%x, act hsid=%x, psid=%x, length=%d, credit=%d, status=%x, cmd=%x\n", pc->sockid, pPk->hsid, pPk->psid, return_value_ntohs$2, pPk->credit, pPk->status, pCmd->cmd);
            break;
          }
      }

    }

    if(!(pPk->credit == 0))
      pc->ta.h2pcredit = pc->ta.h2pcredit + (unsigned short int)pPk->credit;

    total = 0;
    if(size >= 1)
    {
      len=pd->vf.read(fd, buf + (signed long int)total, size, 45000000);
      if(!(len >= 0))
      {
        syslog(3, "io/hpmud/mlc.c 600: unable to read MlcReverseData: %m\n");
        break;
      }

      size = size - len;
      total = total + len;
    }

    break;
  }

bugout:
  ;
  return total;
}

// MlcReverseReply
// file io/hpmud/mlc.c line 219
static signed int MlcReverseReply(struct _mud_channel *pc, signed int fd, unsigned char *buf, signed int bufsize)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  signed int stat = 0;
  signed int len;
  signed int size;
  signed int pklen;
  unsigned char *pBuf;
  struct anonymous$22 *pPk = (struct anonymous$22 *)buf;
  while((_Bool)1)
  {
    pBuf = buf;
    size = (signed int)sizeof(struct anonymous$21) /*6ul*/ ;
    if(size >= 1)
    {
      len=pd->vf.read(fd, (void *)pBuf, size, 4000000);
      if(!(len >= 0))
      {
        syslog(3, "io/hpmud/mlc.c 238: unable to read MlcReverseReply header: %m bytesRead=%zd\n", sizeof(struct anonymous$21) /*6ul*/  - (unsigned long int)size);
        stat = 2;
        break;
      }

      size = size - len;
      pBuf = pBuf + (signed long int)len;
    }

    unsigned short int return_value_ntohs$1;
    return_value_ntohs$1=ntohs(pPk->h.length);
    pklen = (signed int)return_value_ntohs$1;
    if(!(pklen >= 0) || !(bufsize >= pklen))
    {
      syslog(3, "io/hpmud/mlc.c 250: invalid MlcReverseReply packet size: size=%d, buf=%d\n", pklen, bufsize);
      stat = 1;
      break;
    }

    if(pklen == 0)
    {
      syslog(3, "io/hpmud/mlc.c 258: trying MlcReverseReply firmware hack\n");
      memcpy((void *)buf, (const void *)&buf[(signed long int)1], sizeof(struct anonymous$21) /*6ul*/  - (unsigned long int)1);
      unsigned short int return_value_ntohs$2;
      return_value_ntohs$2=ntohs(pPk->h.length);
      pklen = (signed int)return_value_ntohs$2;
      if(!(pklen >= 1) || !(bufsize >= pklen))
      {
        syslog(3, "io/hpmud/mlc.c 263: invalid MlcReverseReply packet size: size=%d, buf=%d\n", pklen, bufsize);
        stat = 1;
        break;
      }

      pBuf = pBuf - 1l;
      len=pd->vf.read(fd, (void *)pBuf, 1, 1000000);
      if(!(len >= 0))
      {
        syslog(3, "io/hpmud/mlc.c 269: unable to read MlcReverseReply header: %m\n");
        stat = 1;
        break;
      }

      pBuf = pBuf + 1l;
    }

    size = (signed int)((unsigned long int)pklen - sizeof(struct anonymous$21) /*6ul*/ );
    if(size >= 1)
    {
      len=pd->vf.read(fd, (void *)pBuf, size, 45000000);
      if(!(len >= 0))
      {
        syslog(3, "io/hpmud/mlc.c 283: unable to read MlcReverseReply data: %m exp=%zd act=%zd\n", (unsigned long int)pklen - sizeof(struct anonymous$21) /*6ul*/ , ((unsigned long int)pklen - sizeof(struct anonymous$21) /*6ul*/ ) - (unsigned long int)size);
        stat = 1;
        break;
      }

      size = size - len;
      pBuf = pBuf + (signed long int)len;
    }

    if(!((0x80 & (signed int)pPk->cmd) == 0))
      break;

    stat=MlcExecReverseCmd(pc, fd, buf);
    if(!(stat == 0))
      break;

  }

bugout:
  ;
  return stat;
}

// ParseFile
// file io/hpmud/model.c line 402
static signed int ParseFile(char *datFile, char *model, char *attr, signed int attrSize, signed int *bytes_read)
{
  struct _IO_FILE *fp;
  char rcbuf[255l];
  char section[128l];
  char file[128l];
  signed int found = 0;
  signed int n;
  fp=fopen(datFile, "r");
  char *return_value_fgets$1;
  signed int return_value_strncmp$6;
  if(!(fp == ((struct _IO_FILE *)NULL)))
  {
    section[(signed long int)0] = (char)0;
    do
    {
      return_value_fgets$1=fgets(rcbuf, (signed int)sizeof(char [255l]) /*255ul*/ , fp);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      if((signed int)rcbuf[0l] == 91)
      {
        strncpy(section, rcbuf + (signed long int)1, sizeof(char [128l]) /*128ul*/ );
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(section);
        n = (signed int)return_value_strlen$2;
        section[(signed long int)(n - 2)] = (char)0;
        signed int return_value_strcasecmp$3;
        return_value_strcasecmp$3=strcasecmp(model, section);
        if(return_value_strcasecmp$3 == 0)
        {
          *bytes_read=ResolveAttributes(fp, attr, attrSize);
          found = 1;
          break;
        }

      }

      else
      {
        return_value_strncmp$6=strncmp(rcbuf, "%include", (unsigned long int)8);
        if(return_value_strncmp$6 == 0)
        {
          strncpy(file, datFile, sizeof(char [128l]) /*128ul*/ );
          char *return_value_strrstr$4;
          return_value_strrstr$4=strrstr(file, "/");
          n = (signed int)((return_value_strrstr$4 - file) + (signed long int)1);
          strncpy(file + (signed long int)n, rcbuf + (signed long int)9, sizeof(char [128l]) /*128ul*/  - (unsigned long int)n);
          unsigned long int return_value_strlen$5;
          return_value_strlen$5=strlen(file);
          n = (signed int)return_value_strlen$5;
          file[(signed long int)(n - 1)] = (char)0;
          ParseInc(file);
        }

      }
    }
    while((_Bool)1);
  }


bugout:
  ;
  if(!(fp == ((struct _IO_FILE *)NULL)))
    fclose(fp);

  return found;
}

// ParseInc
// file io/hpmud/model.c line 353
static signed int ParseInc(char *incFile)
{
  struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  struct list_head *p;
  struct anonymous$32 *pl;
  char rcbuf[255l];
  char section[128l];
  signed int stat = 1;
  signed int n;
  p = (&head.list)->next;
  for( ; !(p == &head.list); p = p->next)
  {
    pl = (struct anonymous$32 *)((char *)p - (signed long int)(unsigned long int)&((struct anonymous$32 *)0)->list);
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(pl->incFile, incFile);
    if(return_value_strcmp$1 == 0)
    {
      syslog(3, "io/hpmud/model.c 368: error duplicate include file %s\n", incFile);
      goto bugout;
    }

  }
  fp=fopen(incFile, "r");
  char *return_value_fgets$2;
  if(fp == ((struct _IO_FILE *)NULL))
    syslog(3, "io/hpmud/model.c 375: open %s failed: %m\n", incFile);

  else
  {
    section[(signed long int)0] = (char)0;
    do
    {
      return_value_fgets$2=fgets(rcbuf, (signed int)sizeof(char [255l]) /*255ul*/ , fp);
      if(return_value_fgets$2 == ((char *)NULL))
        break;

      if((signed int)rcbuf[0l] == 91)
      {
        strncpy(section, rcbuf + (signed long int)1, sizeof(char [128l]) /*128ul*/ );
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(section);
        n = (signed int)return_value_strlen$3;
        section[(signed long int)(n - 2)] = (char)0;
        RegisterLabel(fp, incFile, section);
      }

    }
    while((_Bool)1);
    stat = 0;
  }

bugout:
  ;
  if(!(fp == ((struct _IO_FILE *)NULL)))
    fclose(fp);

  return stat;
}

// PmlOidToHex
// file io/hpmud/pml.c line 49
static signed int PmlOidToHex(const char *szoid, unsigned char *oid, signed int oidSize)
{
  char *tail;
  signed int i = 0;
  signed int val;
  signed long int return_value_strtol$1;
  if(!((signed int)*szoid == 0))
  {
    return_value_strtol$1=strtol(szoid, &tail, 10);
    val = (signed int)return_value_strtol$1;
    while(!(i >= oidSize))
    {
      if(val >= 129)
      {
        syslog(3, "io/hpmud/pml.c 63: invalid oid size: oid=%s\n", szoid);
        break;
      }

      signed int tmp_post$2 = i;
      i = i + 1;
      oid[(signed long int)tmp_post$2] = (unsigned char)val;
      if((signed int)*tail == 0)
        break;

      signed long int return_value_strtol$3;
      return_value_strtol$3=strtol(tail + (signed long int)1, &tail, 10);
      val = (signed int)return_value_strtol$3;
    }
  }


bugout:
  ;
  return i;
}

// ReadConfig
// file io/hpmud/model.c line 94
static signed int ReadConfig()
{
  char key[256l];
  char value[256l];
  char rcbuf[255l];
  char section[32l];
  char *tail;
  struct _IO_FILE *inFile = (struct _IO_FILE *)(void *)0;
  signed int stat = 1;
  homedir[(signed long int)0] = (char)0;
  inFile=fopen("/etc/hp/hplip.conf", "r");
  char *return_value_fgets$1;
  signed int return_value_strcasecmp$3;
  if(inFile == ((struct _IO_FILE *)NULL))
    syslog(3, "io/hpmud/model.c 108: unable to open %s: %m\n", (const void *)"/etc/hp/hplip.conf");

  else
  {
    section[(signed long int)0] = (char)0;
    do
    {
      return_value_fgets$1=fgets(rcbuf, (signed int)sizeof(char [255l]) /*255ul*/ , inFile);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      if((signed int)rcbuf[0l] == 91)
        strncpy(section, rcbuf, sizeof(char [32l]) /*32ul*/ );

      else
      {
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(rcbuf);
        GetPair(rcbuf, (signed int)return_value_strlen$2, key, value, &tail);
        signed int return_value_strncasecmp$4;
        return_value_strncasecmp$4=strncasecmp(section, "[dirs]", (unsigned long int)6);
        if(return_value_strncasecmp$4 == 0)
        {
          return_value_strcasecmp$3=strcasecmp(key, "home");
          if(return_value_strcasecmp$3 == 0)
          {
            strncpy(homedir, value, sizeof(char [255l]) /*255ul*/ );
            break;
          }

        }

      }
    }
    while((_Bool)1);
    stat = 0;
  }

bugout:
  ;
  if(!(inFile == ((struct _IO_FILE *)NULL)))
    fclose(inFile);

  return stat;
}

// ReadReply
// file io/hpmud/jd.c line 66
static signed int ReadReply(struct _mud_channel *pc)
{
  char buf[256l];
  signed int len = 0;
  signed int num = 0;
  char *tail;
  enum HPMUD_RESULT stat;
  stat=jd_s_channel_read(pc, (void *)buf, (signed int)sizeof(char [256l]) /*256ul*/ , 2, &len);
  buf[(signed long int)len] = (char)0;
  if((signed int)stat == HPMUD_R_OK)
    num=strtol((char *)buf, &tail, 10);

  return num;
}

// RegisterLabel
// file io/hpmud/model.c line 249
static signed int RegisterLabel(struct _IO_FILE *fp, char *incFile, char *label)
{
  struct list_head *p;
  struct anonymous$32 *pl;
  char buf[4096l];
  signed int i = 0;
  signed int stat = 1;
  signed int ch;
  p = (&head.list)->next;
  for( ; !(p == &head.list); p = p->next)
  {
    pl = (struct anonymous$32 *)((char *)p - (signed long int)(unsigned long int)&((struct anonymous$32 *)0)->list);
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp(pl->name, label);
    if(return_value_strcasecmp$1 == 0)
    {
      syslog(3, "io/hpmud/model.c 262: error duplicate label %s\n", label);
      goto bugout;
    }

  }
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct anonymous$32) /*48ul*/ );
  pl = (struct anonymous$32 *)return_value_malloc$2;
  if(pl == ((struct anonymous$32 *)NULL))
    syslog(3, "io/hpmud/model.c 269: unable to creat label record: %m\n");

  else
  {
    pl->incFile=strdup(incFile);
    pl->name=strdup(label);
    ch=fgetc(fp);
    while(!(ch == -1))
    {
      if(ch == 91)
      {
        ungetc(ch, fp);
        break;
      }

      if(ch == 32 || ch == 35)
        do
        {
          ch=fgetc(fp);
          if(ch == 10)
            break;

          if(ch == -1)
            break;

        }
        while((_Bool)1);

      else
        if(!(ch == 10))
        {
          if(!(i >= 4096))
          {
            signed int tmp_post$3 = i;
            i = i + 1;
            buf[(signed long int)tmp_post$3] = (char)ch;
          }

          do
          {
            ch=fgetc(fp);
            if(ch == 10)
              break;

            if(ch == -1)
              break;

            if(!(i >= 4096))
            {
              signed int tmp_post$4 = i;
              i = i + 1;
              buf[(signed long int)tmp_post$4] = (char)ch;
            }

          }
          while((_Bool)1);
          if(!(i >= 4096))
          {
            signed int tmp_post$5 = i;
            i = i + 1;
            buf[(signed long int)tmp_post$5] = (char)10;
          }

        }

      if(ch == 10)
        ch=fgetc(fp);

    }
    buf[(signed long int)i] = (char)0;
    pl->value=strdup(buf);
    pl->valueSize = i;
    list_add(&pl->list, &head.list);
    stat = 0;
  }

bugout:
  ;
  return stat;
}

// ResolveAttributes
// file io/hpmud/model.c line 193
static signed int ResolveAttributes(struct _IO_FILE *fp, char *attr, signed int attrSize)
{
  char label[128l];
  signed int i = 0;
  signed int j;
  signed int ch;
  ch=fgetc(fp);
  while(!(ch == -1))
  {
    if(ch == 91)
    {
      ungetc(ch, fp);
      break;
    }

    if(ch == 32 || ch == 35)
      do
      {
        ch=fgetc(fp);
        if(ch == 10)
          break;

        if(ch == -1)
          break;

      }
      while((_Bool)1);

    else
      if(!(ch == 10))
      {
        if(ch == 37)
        {
          j = 0;
          do
          {
            ch=fgetc(fp);
            if(ch == 10)
              break;

            if(ch == -1)
              break;

            if(!((unsigned long int)j >= 127ul))
            {
              signed int tmp_post$1 = j;
              j = j + 1;
              label[(signed long int)tmp_post$1] = (char)ch;
            }

          }
          while((_Bool)1);
          label[(signed long int)(j - 1)] = (char)0;
          signed int return_value_CopyLabel$2;
          return_value_CopyLabel$2=CopyLabel(label, attr + (signed long int)i, attrSize - i);
          i = i + return_value_CopyLabel$2;
        }

        else
        {
          if(!(i >= attrSize + -1))
          {
            signed int tmp_post$3 = i;
            i = i + 1;
            attr[(signed long int)tmp_post$3] = (char)ch;
          }

          do
          {
            ch=fgetc(fp);
            if(ch == 10)
              break;

            if(ch == -1)
              break;

            if(!(i >= attrSize + -1))
            {
              signed int tmp_post$4 = i;
              i = i + 1;
              attr[(signed long int)tmp_post$4] = (char)ch;
            }

          }
          while((_Bool)1);
          if(!(i >= attrSize + -1))
          {
            signed int tmp_post$5 = i;
            i = i + 1;
            attr[(signed long int)tmp_post$5] = (char)10;
          }

        }
      }

    if(ch == 10)
      ch=fgetc(fp);

  }
  attr[(signed long int)i] = (char)0;
  return i;
}

// SetSnmp
// file io/hpmud/pml.c line 145
static signed int SetSnmp(const char *ip, signed int port, const char *szoid, signed int type, void *buffer, unsigned int size, signed int *pml_result, signed int *result)
{
  struct snmp_session session;
  struct snmp_session *ss = (struct snmp_session *)(void *)0;
  struct snmp_pdu *pdu = (struct snmp_pdu *)(void *)0;
  struct snmp_pdu *response = (struct snmp_pdu *)(void *)0;
  unsigned long int anOID[128l];
  unsigned long int anOID_len = (unsigned long int)128;
  unsigned int i;
  unsigned int len = (unsigned int)0;
  unsigned int val;
  *result = HPMUD_R_IO_ERROR;
  *pml_result = 128;
  init_snmp("snmpapp");
  snmp_sess_init(&session);
  session.peername = (char *)ip;
  session.version = (signed long int)0;
  session.community = (unsigned char *)SnmpPort[(signed long int)port];
  session.community_len=strlen((const char *)session.community);
  ss=snmp_open(&session);
  signed int return_value_snmp_synch_response$1;
  if(!(ss == ((struct snmp_session *)NULL)))
  {
    pdu=snmp_pdu_create((signed int)(unsigned char)0x80 | (signed int)(unsigned char)0x20 | 0x3);
    read_objid(szoid, anOID, &anOID_len);
    if(!(type == 4) && !(type == 8))
    {
      if(type == 12 || type == 16 || type == 20 || type == 28 || type == 32)
        goto __CPROVER_DUMP_L4;

    }

    else
    {
      i = (unsigned int)0;
      val = (unsigned int)0;
      for( ; !(i >= size) && !((unsigned long int)i >= sizeof(unsigned int) /*4ul*/ ); i = i + 1u)
        val = val << 8 | (unsigned int)((unsigned char *)buffer)[(signed long int)i];
      snmp_pdu_add_variable(pdu, anOID, anOID_len, (unsigned char)0x02, (const void *)(unsigned char *)&val, sizeof(unsigned int) /*4ul*/ );
      goto __CPROVER_DUMP_L5;
    }

  __CPROVER_DUMP_L4:
    ;
    snmp_pdu_add_variable(pdu, anOID, anOID_len, (unsigned char)0x04, buffer, (unsigned long int)size);

  __CPROVER_DUMP_L5:
    ;
    return_value_snmp_synch_response$1=snmp_synch_response(ss, pdu, &response);
    if(return_value_snmp_synch_response$1 == 0)
    {
      if(response->errstat == 0l)
        len = size;

      *pml_result=SnmpErrorToPml((signed int)response->errstat);
      *result = HPMUD_R_OK;
    }

  }


bugout:
  ;
  if(!(response == ((struct snmp_pdu *)NULL)))
    snmp_free_pdu(response);

  if(!(ss == ((struct snmp_session *)NULL)))
    snmp_close(ss);

  return (signed int)len;
}

// SnmpErrorToPml
// file io/hpmud/pml.c line 115
static signed int SnmpErrorToPml(signed int snmp_error)
{
  signed int err;
  switch(snmp_error)
  {
    case 0:
    {
      err = 0;
      break;
    }
    case 1:
    {
      err = 129;
      break;
    }
    case 2:
    {
      err = 131;
      break;
    }
    case 3:
    {
      err = 133;
      break;
    }
    case 4:
    {
      err = 132;
      break;
    }
    case 5:

    default:
      err = 128;
  }
  return err;
}

// SnmpToPml
// file io/hpmud/pml.c line 79
static signed int SnmpToPml(const char *snmp_oid, unsigned char *oid, signed int oidSize)
{
  signed int len = 0;
  signed int return_value_strncmp$6;
  static const char hp_pml_mib_prefix[25l] = { '1', '.', '3', '.', '6', '.', '1', '.', '4', '.', '1', '.', '1', '1', '.', '2', '.', '3', '.', '9', '.', '4', '.', '2', 0 };
  return_value_strncmp$6=strncmp(snmp_oid, hp_pml_mib_prefix, sizeof(const char [25l]) /*25ul*/  - (unsigned long int)1);
  signed int return_value_strncmp$5;
  signed int return_value_strncmp$4;
  if(return_value_strncmp$6 == 0)
  {
    len = 0;
    signed int return_value_PmlOidToHex$1;
    return_value_PmlOidToHex$1=PmlOidToHex(&snmp_oid[(signed long int)sizeof(const char [25l]) /*25ul*/ ], &oid[(signed long int)0], oidSize);
    len = len + return_value_PmlOidToHex$1;
    len = len - 1;
  }

  else
  {
    static const char standard_printer_mib_prefix[15l] = { '1', '.', '3', '.', '6', '.', '1', '.', '2', '.', '1', '.', '4', '3', 0 };
    return_value_strncmp$5=strncmp(snmp_oid, standard_printer_mib_prefix, sizeof(const char [15l]) /*15ul*/  - (unsigned long int)1);
    if(return_value_strncmp$5 == 0)
    {
      len = 1;
      oid[(signed long int)0] = (unsigned char)0x2;
      signed int return_value_PmlOidToHex$2;
      return_value_PmlOidToHex$2=PmlOidToHex(&snmp_oid[(signed long int)sizeof(const char [15l]) /*15ul*/ ], &oid[(signed long int)1], oidSize);
      len = len + return_value_PmlOidToHex$2;
    }

    else
    {
      static const char host_resource_mib_prefix[15l] = { '1', '.', '3', '.', '6', '.', '1', '.', '2', '.', '1', '.', '2', '5', 0 };
      return_value_strncmp$4=strncmp(snmp_oid, host_resource_mib_prefix, sizeof(const char [15l]) /*15ul*/  - (unsigned long int)1);
      if(return_value_strncmp$4 == 0)
      {
        len = 1;
        oid[(signed long int)0] = (unsigned char)0x3;
        signed int return_value_PmlOidToHex$3;
        return_value_PmlOidToHex$3=PmlOidToHex(&snmp_oid[(signed long int)sizeof(const char [15l]) /*15ul*/ ], &oid[(signed long int)1], oidSize);
        len = len + return_value_PmlOidToHex$3;
      }

      else
        syslog(3, "io/hpmud/pml.c 108: SnmpToPml failed snmp oid=%s\n", snmp_oid);
    }
  }
  return len;
}

// UnRegisterLabel
// file io/hpmud/model.c line 325
static signed int UnRegisterLabel(struct anonymous$32 *pl)
{
  if(!(pl->incFile == ((char *)NULL)))
    free((void *)pl->incFile);

  if(!(pl->name == ((char *)NULL)))
    free((void *)pl->name);

  if(!(pl->value == ((char *)NULL)))
    free((void *)pl->value);

  list_del(&pl->list);
  free((void *)pl);
  return 0;
}

// __list_add
// file io/hpmud/list.h line 23
static inline void __list_add(struct list_head *new_entry, struct list_head *prev, struct list_head *next)
{
  next->prev = new_entry;
  new_entry->next = next;
  new_entry->prev = prev;
  prev->next = new_entry;
}

// __list_del
// file io/hpmud/list.h line 66
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
  next->prev = prev;
  prev->next = next;
}

// bridge_chip_down
// file io/hpmud/musb.c line 319
static signed int bridge_chip_down(struct anonymous$20 *pfd)
{
  struct libusb_device_handle *hd;
  signed int len;
  signed int stat = 1;
  if(pfd->hd == ((struct libusb_device_handle *)NULL))
    syslog(3, "io/hpmud/musb.c 326: invalid bridge_chip_down state\n");

  else
  {
    hd = pfd->hd;
    len=libusb_control_transfer(hd, (unsigned char)(LIBUSB_ENDPOINT_OUT | 64 | 0), (unsigned char)0x04, (unsigned short int)0x080f, (unsigned short int)0, (unsigned char *)(void *)0, (unsigned short int)0, (unsigned int)5000);
    if(!(len >= 0))
      syslog(3, "io/hpmud/musb.c 340: invalid write_bridge_up: %m\n");

    else
      stat = 0;
  }

bugout:
  ;
  return stat;
}

// bridge_chip_up
// file io/hpmud/musb.c line 221
static signed int bridge_chip_up(struct anonymous$20 *pfd)
{
  struct libusb_device_handle *hd;
  signed int len;
  signed int stat = 1;
  unsigned char buf[9l];
  char nullByte = (char)0;
  if(pfd->hd == ((struct libusb_device_handle *)NULL))
    syslog(3, "io/hpmud/musb.c 230: invalid bridge_chip_up state\n");

  else
  {
    hd = pfd->hd;
    memset((void *)buf, 0, sizeof(unsigned char [9l]) /*9ul*/ );
    len=libusb_control_transfer(hd, (unsigned char)(LIBUSB_ENDPOINT_IN | 64 | 0), (unsigned char)3, (unsigned short int)0, (unsigned short int)0, buf, (unsigned short int)sizeof(unsigned char [9l]) /*9ul*/ , (unsigned int)5000);
    if(!(len >= 0))
      syslog(3, "io/hpmud/musb.c 247: invalid write_bridge_up: %m\n");

    else
    {
      if(!((signed int)buf[2l] == 0x43))
      {
        len=libusb_control_transfer(hd, (unsigned char)(LIBUSB_ENDPOINT_OUT | 64 | 0), (unsigned char)0x04, (unsigned short int)0x0758, (unsigned short int)0, (unsigned char *)(void *)0, (unsigned short int)0, (unsigned int)5000);
        len=libusb_control_transfer(hd, (unsigned char)(LIBUSB_ENDPOINT_OUT | 64 | 0), (unsigned char)0x04, (unsigned short int)0x0a1d, (unsigned short int)0, (unsigned char *)(void *)0, (unsigned short int)0, (unsigned int)5000);
        len=libusb_control_transfer(hd, (unsigned char)(LIBUSB_ENDPOINT_OUT | 64 | 0), (unsigned char)0x04, (unsigned short int)0x0759, (unsigned short int)0, (unsigned char *)(void *)0, (unsigned short int)0, (unsigned int)5000);
        len=libusb_control_transfer(hd, (unsigned char)(LIBUSB_ENDPOINT_OUT | 64 | 0), (unsigned char)0x04, (unsigned short int)0x0817, (unsigned short int)0, (unsigned char *)(void *)0, (unsigned short int)0, (unsigned int)5000);
        len=libusb_control_transfer(hd, (unsigned char)(LIBUSB_ENDPOINT_IN | 64 | 0), (unsigned char)3, (unsigned short int)0, (unsigned short int)0, buf, (unsigned short int)sizeof(unsigned char [9l]) /*9ul*/ , (unsigned int)5000);
        if(!((signed int)buf[2l] == 0x43))
          syslog(3, "io/hpmud/musb.c 291: invalid auto ecp mode mode=%d\n", buf[(signed long int)2]);

      }

      len=libusb_control_transfer(hd, (unsigned char)(LIBUSB_ENDPOINT_OUT | 64 | 0), (unsigned char)0x04, (unsigned short int)0x05ce, (unsigned short int)0, (unsigned char *)(void *)0, (unsigned short int)0, (unsigned int)5000);
      musb_write((signed int)pfd->fd, (const void *)&nullByte, 1, 45000000);
      len=libusb_control_transfer(hd, (unsigned char)(LIBUSB_ENDPOINT_OUT | 64 | 0), (unsigned char)0x04, (unsigned short int)0x05cd, (unsigned short int)0, (unsigned char *)(void *)0, (unsigned short int)0, (unsigned int)5000);
      stat = 0;
    }
  }

bugout:
  ;
  return stat;
}

// bug
// file prnt/backend/hp.c line 162
static signed int bug(const char *fmt, ...)
{
  char buf[256l];
  void **args;
  signed int n;
  args = (void **)&fmt;
  n=vsnprintf(buf, (unsigned long int)256, fmt, args);
  if(n == -1)
    buf[(signed long int)255] = (char)0;

  fprintf(stderr, "%s", (const void *)buf);
  syslog(3, "%s", (const void *)buf);
  fflush(stderr);
  args = ((void **)NULL);
  return n;
}

// claim_id_interface
// file io/hpmud/musb.c line 567
static signed int claim_id_interface(struct libusb_device *dev)
{
  enum FD_ID i = (enum FD_ID)FD_7_1_2;
  for( ; !((signed int)i == MAX_FD); i = (enum FD_ID)((signed int)i + 1))
  {
    signed int return_value_get_interface$2;
    return_value_get_interface$2=get_interface(dev, i, &fd_table[(signed long int)i]);
    if(return_value_get_interface$2 == 0)
    {
      signed int return_value_claim_interface$1;
      return_value_claim_interface$1=claim_interface(dev, &fd_table[(signed long int)i]);
      if(!(return_value_claim_interface$1 == 0))
        goto __CPROVER_DUMP_L3;

      break;
    }


  __CPROVER_DUMP_L3:
    ;
  }
  return (signed int)i;
}

// claim_interface
// file io/hpmud/musb.c line 496
static signed int claim_interface(struct libusb_device *dev, struct anonymous$20 *pfd)
{
  signed int stat = 1;
  signed int return_value_libusb_claim_interface$1;
  if(!(pfd->hd == ((struct libusb_device_handle *)NULL)))
    return 0;

  else
  {
    libusb_open(dev, &pfd->hd);
    if(pfd->hd == ((struct libusb_device_handle *)NULL))
      syslog(3, "io/hpmud/musb.c 506: invalid usb_open: %m\n");

    else
    {
      detach(pfd->hd, pfd->interface);
      return_value_libusb_claim_interface$1=libusb_claim_interface(pfd->hd, pfd->interface);
      if(!(return_value_libusb_claim_interface$1 == 0))
      {
        libusb_close(pfd->hd);
        pfd->hd = (struct libusb_device_handle *)(void *)0;
        syslog(6, "io/hpmud/musb.c 515: invalid claim_interface %s: %m\n", fd_name[(signed long int)pfd->fd]);
      }

      else
      {
        if(!(pfd->alt_setting == 0))
        {
          signed int return_value_libusb_set_interface_alt_setting$2;
          return_value_libusb_set_interface_alt_setting$2=libusb_set_interface_alt_setting(pfd->hd, pfd->interface, pfd->alt_setting);
          if(!(return_value_libusb_set_interface_alt_setting$2 == 0))
          {
            libusb_release_interface(pfd->hd, pfd->interface);
            libusb_close(pfd->hd);
            pfd->hd = (struct libusb_device_handle *)(void *)0;
            syslog(3, "io/hpmud/musb.c 526: invalid set_altinterface %s altset=%d: %m\n", fd_name[(signed long int)pfd->fd], pfd->alt_setting);
            goto bugout;
          }

        }

        pfd->write_active = 0;
        pthread_mutex_init(&pfd->mutex, (const union anonymous$33 *)(void *)0);
        pthread_cond_init(&pfd->write_done_cond, (const union anonymous$33 *)(void *)0);
        syslog(6, "io/hpmud/musb.c 535: claimed %s interface\n", fd_name[(signed long int)pfd->fd]);
        stat = 0;
      }
    }

  bugout:
    ;
    return stat;
  }
}

// claim_pp
// file io/hpmud/pp.c line 578
static signed int claim_pp(signed int fd)
{
  signed int stat = 1;
  signed int return_value_ioctl$1;
  return_value_ioctl$1=ioctl(fd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x8b << 0) | (unsigned int)(0 << 0 + 8 + 8)));
  if(!(return_value_ioctl$1 == 0))
    syslog(3, "io/hpmud/pp.c 585: failed claim_pp fd=%d: %m\n", fd);

  else
    stat = 0;

bugout:
  ;
  return stat;
}

// compat_write
// file io/hpmud/pp.c line 543
static signed int compat_write(signed int fd, const void *buffer, signed int size)
{
  signed int i = 0;
  unsigned char *p = (unsigned char *)buffer;
  signed int m = 1 << 8;
  static signed int timeout = 0;
  if(!(timeout == 0))
  {
    timeout = 0;
    return -1;
  }

  else
  {
    signed int return_value_ioctl$1;
    return_value_ioctl$1=ioctl(fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x91 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &m);
    if(!(return_value_ioctl$1 == 0))
      syslog(3, "io/hpmud/pp.c 558: compat_write failed: %m\n");

    else
    {
      i = 0;
      for( ; !(i >= size); i = i + 1)
      {
        signed int return_value_compat_write_data$2;
        return_value_compat_write_data$2=compat_write_data(fd, p[(signed long int)i]);
        if(!(return_value_compat_write_data$2 == 1))
        {
          if(!(i == 0))
            timeout = 1;

          else
            i = -1;
          break;
        }

      }
    }

  bugout:
    ;
    return i;
  }
}

// compat_write_data
// file io/hpmud/pp.c line 510
static signed int compat_write_data(signed int fd, unsigned char data)
{
  signed int len = 0;
  signed int return_value_wait_status$1;
  return_value_wait_status$1=wait_status(fd, (unsigned char)0x80, (unsigned char)0, 30000000);
  signed int return_value_wait_status$2;
  if(!(return_value_wait_status$1 == 0))
    syslog(3, "io/hpmud/pp.c 517: compat_write_data transfer stalled\n");

  else
  {
    ioctl(fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x86 << 0)) | sizeof(unsigned char) /*1ul*/  << 0 + 8 + 8, &data);
    wait(10);
    frob_control(fd, (unsigned char)0x1, (unsigned char)0);
    return_value_wait_status$2=wait_status(fd, (unsigned char)0x80, (unsigned char)0x80, 100000);
    if(!(return_value_wait_status$2 == 0))
      syslog(3, "io/hpmud/pp.c 530: compat_write_data transfer stalled\n");

    else
    {
      frob_control(fd, (unsigned char)0x1, (unsigned char)0x1);
      len = 1;
    }
  }

bugout:
  ;
  return len;
}

// createTempFile
// file common/utils.h line 156
signed int createTempFile(char *szFileName, struct _IO_FILE **pFilePtr)
{
  signed int iFD = -1;
  _Bool tmp_if_expr$1;
  if(szFileName == ((char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)szFileName[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  if(pFilePtr == ((struct _IO_FILE **)NULL) || tmp_if_expr$1)
  {
    syslog(3, "common/utils.c 229: Invalid Filename/ pointer\n");
    return 0;
  }

  else
  {
    char *return_value_strstr$2;
    return_value_strstr$2=strstr(szFileName, "XXXXXX");
    if(return_value_strstr$2 == ((char *)NULL))
      strcat(szFileName, "_XXXXXX");

    iFD=mkstemp(szFileName);
    if(iFD == -1)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      syslog(3, "common/utils.c 239: Failed to create the temp file Name[%s] errno[%d : %s]\n", szFileName, *return_value___errno_location$3, return_value_strerror$5);
      return 0;
    }

    else
      *pFilePtr=fdopen(iFD, "w+");
    return iFD;
  }
}

// create_out_file
// file prnt/backend/hp.c line 642
static struct _IO_FILE * create_out_file(char *job_id, char *user_name)
{
  char fname[256l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct _IO_FILE *temp_fp = (struct _IO_FILE *)(void *)0;
  char *return_value_getenv$1;
  return_value_getenv$1=getenv("TMPDIR");
  char *tmp_if_expr$3;
  char *return_value_getenv$2;
  if(!(return_value_getenv$1 == ((char *)NULL)))
    tmp_if_expr$3 = return_value_getenv$1;

  else
  {
    return_value_getenv$2=getenv("HOME");
    tmp_if_expr$3 = (_Bool)return_value_getenv$2 ? return_value_getenv$2 : "/tmp";
  }
  snprintf(fname, sizeof(char [256l]) /*256ul*/ , "%s/hp_%s_out_%s_XXXXXX", tmp_if_expr$3, user_name, job_id);
  createTempFile(fname, &temp_fp);
  if(!(temp_fp == ((struct _IO_FILE *)NULL)))
    chmod(fname, (unsigned int)(0400 | 0200 | 0400 >> 3 | 0200 >> 3 | (0400 >> 3) >> 3));

  else
    bug("prnt/backend/hp.c 656: ERROR: unable to create Temporary file %s: %m\n", (const void *)fname);
  return temp_fp;
}

// cut_buf
// file io/hpmud/mlc.c line 29
signed int cut_buf(struct _mud_channel *pc, char *buf, signed int size)
{
  signed int len;
  if(!(size >= pc->rcnt))
  {
    len = size;
    memcpy((void *)buf, (const void *)&pc->rbuf[(signed long int)pc->rindex], (unsigned long int)len);
    pc->rindex = pc->rindex + len;
    pc->rcnt = pc->rcnt - len;
  }

  else
  {
    len = pc->rcnt;
    memcpy((void *)buf, (const void *)&pc->rbuf[(signed long int)pc->rindex], (unsigned long int)len);
    pc->rcnt = 0;
    pc->rindex = pc->rcnt;
  }
  return len;
}

// del_channel
// file io/hpmud/jd.c line 140
static signed int del_channel(struct _mud_device *pd, struct _mud_channel *pc)
{
  pc->client_cnt = pc->client_cnt - 1;
  if(!(pc->client_cnt >= 1))
    pd->channel_cnt = pd->channel_cnt - 1;

  return 0;
}

// del_channel$link1
// file io/hpmud/pp.c line 711
static signed int del_channel$link1(struct _mud_device *pd$link1, struct _mud_channel *pc$link1)
{
  pc$link1->client_cnt = pc$link1->client_cnt - 1;
  if(!(pc$link1->client_cnt >= 1))
    pd$link1->channel_cnt = pd$link1->channel_cnt - 1;

  return 0;
}

// del_channel$link2
// file io/hpmud/musb.c line 967
static signed int del_channel$link2(struct _mud_device *pd$link2, struct _mud_channel *pc$link2)
{
  pc$link2->client_cnt = pc$link2->client_cnt - 1;
  if(!(pc$link2->client_cnt >= 1))
    pd$link2->channel_cnt = pd$link2->channel_cnt - 1;

  syslog(6, "io/hpmud/musb.c 975: removed %s channel=%d clientCnt=%d channelCnt=%d\n", (const void *)pc$link2->sn, pc$link2->index, pc$link2->client_cnt, pd$link2->channel_cnt);
  return 0;
}

// del_device
// file io/hpmud/hpmud.c line 352
static signed int del_device(signed int index)
{
  pthread_mutex_lock(&msp->mutex);
  msp->device[(signed long int)index].index = 0;
  pthread_mutex_unlock(&msp->mutex);
  return 0;
}

// detach
// file io/hpmud/musb.c line 384
static signed int detach(struct libusb_device_handle *hd, signed int interface)
{
  signed int ret;
  ret=libusb_kernel_driver_active(hd, interface);
  syslog(6, "io/hpmud/musb.c 389: Active kernel driver on interface=%d ret=%d\n", interface, ret);
  if(ret == 1)
  {
    ret=libusb_detach_kernel_driver(hd, interface);
    syslog(6, "io/hpmud/musb.c 393: Detaching kernel driver on interface=%d ret=%d\n", interface, ret);
    if(!(ret >= 0))
      syslog(3, "io/hpmud/musb.c 395: could not remove kernel driver interface=%d: %m\n", interface);

  }

  return 0;
}

// device_cleanup
// file io/hpmud/hpmud.c line 364
signed int device_cleanup(struct anonymous$28 *ps)
{
  signed int i;
  signed int dd = 1;
  if(ps == ((struct anonymous$28 *)NULL))
    return 0;

  else
    if(ps->device[(signed long int)dd].index == 0)
      return 0;

    else
    {
      syslog(3, "io/hpmud/hpmud.c 373: device_cleanup: device uri=%s\n", (const void *)ps->device[(signed long int)dd].uri);
      i = 0;
      for( ; !(i >= 47); i = i + 1)
        if(!(ps->device[(signed long int)dd].channel[(signed long int)i].client_cnt == 0))
        {
          syslog(3, "io/hpmud/hpmud.c 379: device_cleanup: close channel %d...\n", i);
          hpmud_close_channel(dd, ps->device[(signed long int)dd].channel[(signed long int)i].index);
          syslog(3, "io/hpmud/hpmud.c 381: device_cleanup: done closing channel %d\n", i);
        }

      syslog(3, "io/hpmud/hpmud.c 385: device_cleanup: close device dd=%d...\n", dd);
      hpmud_close_device(dd);
      syslog(3, "io/hpmud/hpmud.c 387: device_cleanup: done closing device dd=%d\n", dd);
      return 0;
    }
}

// device_discovery
// file prnt/backend/hp.c line 492
static signed int device_discovery()
{
  char buf[16384l];
  signed int cnt = 0;
  signed int bytes_read;
  signed int r = 1;
  enum HPMUD_RESULT stat;
  stat=hpmud_probe_printers((enum HPMUD_BUS_ID)HPMUD_BUS_ALL, buf, (signed int)sizeof(char [16384l]) /*16384ul*/ , &cnt, &bytes_read);
  if((signed int)stat == HPMUD_R_OK)
  {
    if(cnt == 0)
      fprintf(stdout, "direct hp \"Unknown\" \"HP Printer (HPLIP)\"\n");

    else
      fprintf(stdout, "%s", (const void *)buf);
    r = 0;
  }


bugout:
  ;
  return r;
}

// device_event
// file prnt/backend/hp.c line 519
static signed int device_event(const char *dev, const char *printer, signed int code, const char *username, const char *jobid, const char *title)
{
  struct DBusMessage *msg = (struct DBusMessage *)(void *)0;
  signed int id;
  id=atoi(jobid);
  if(dbus_conn == ((struct DBusConnection *)NULL))
    return 0;

  else
  {
    msg=dbus_message_new_signal("/", "com.hplip.StatusService", "Event");
    if(msg == ((struct DBusMessage *)NULL))
    {
      bug("prnt/backend/hp.c 532: dbus message is NULL!\n");
      return 0;
    }

    else
    {
      dbus_message_append_args(msg, (signed int)115, &dev, (signed int)115, &printer, (signed int)117, &code, (signed int)115, &username, (signed int)117, &id, (signed int)115, &title, (signed int)0);
      unsigned int return_value_dbus_connection_send$1;
      return_value_dbus_connection_send$1=dbus_connection_send(dbus_conn, msg, (unsigned int *)(void *)0);
      if(return_value_dbus_connection_send$1 == 0u)
      {
        bug("prnt/backend/hp.c 547: dbus message send failed!\n");
        return 0;
      }

      else
      {
        dbus_connection_flush(dbus_conn);
        dbus_message_unref(msg);
        return 1;
      }
    }
  }
}

// device_id
// file io/hpmud/jd.c line 82
static signed int device_id(const char *iporhostname, signed int port, char *buffer, signed int size)
{
  signed int len = 0;
  signed int maxSize;
  signed int result;
  signed int dt;
  signed int status;
  maxSize = size > 1024 ? 1024 : size;
  len=GetSnmp(iporhostname, port, (char *)kStatusOID, (void *)(unsigned char *)buffer, (unsigned int)maxSize, &dt, &status, &result);
  if(len == 0)
  {
    len=GetSnmp(iporhostname, 2, (char *)kStatusOID, (void *)(unsigned char *)buffer, (unsigned int)maxSize, &dt, &status, &result);
    if(len == 0)
      syslog(3, "io/hpmud/jd.c 93: unable to read device-id\n");

  }

  return len;
}

// device_id$link1
// file io/hpmud/pp.c line 618
static signed int device_id$link1(signed int fd, char *buffer$link1, signed int size$link1)
{
  signed int len$link1 = 0;
  signed int maxSize$link1 = size$link1 > 1024 ? 1024 : size$link1;
  len$link1=nibble_read(fd, 1 << 2, (void *)buffer$link1, maxSize$link1, 0);
  if(!(len$link1 >= 0))
  {
    syslog(3, "io/hpmud/pp.c 627: unable to read device-id ret=%d\n", len$link1);
    len$link1 = 0;
  }

  else
  {
    if(!(size$link1 + -1 >= len$link1))
      len$link1 = size$link1 - 1;

    if(len$link1 >= 3)
      len$link1 = len$link1 - 2;

    memcpy((void *)buffer$link1, (const void *)(buffer$link1 + (signed long int)2), (unsigned long int)len$link1);
    buffer$link1[(signed long int)len$link1] = (char)0;
  }

bugout:
  ;
  return len$link1;
}

// device_id$link2
// file io/hpmud/musb.c line 741
static signed int device_id$link2(signed int fd$link1, unsigned char *buffer$link2, signed int size$link2)
{
  struct libusb_device_handle *hd;
  signed int config;
  signed int interface;
  signed int alt;
  signed int len$link2 = 0;
  signed int rlen;
  signed int maxSize$link2;
  hd = fd_table[(signed long int)fd$link1].hd;
  config = fd_table[(signed long int)fd$link1].config;
  interface = fd_table[(signed long int)fd$link1].interface;
  alt = fd_table[(signed long int)fd$link1].alt_setting;
  unsigned short int return_value_ntohs$1;
  if(hd == ((struct libusb_device_handle *)NULL))
    syslog(3, "io/hpmud/musb.c 754: invalid device_id state\n");

  else
  {
    maxSize$link2 = size$link2 > 1024 ? 1024 : size$link2;
    rlen=libusb_control_transfer(hd, (unsigned char)(LIBUSB_ENDPOINT_IN | 32 | 1), (unsigned char)0, (unsigned short int)config, (unsigned short int)interface, buffer$link2, (unsigned short int)maxSize$link2, (unsigned int)5000);
    if(!(rlen >= 0))
      syslog(3, "io/hpmud/musb.c 769: invalid deviceid ret=%d: %m\n", rlen);

    else
    {
      return_value_ntohs$1=ntohs((unsigned short int)*((signed short int *)buffer$link2));
      len$link2 = (signed int)return_value_ntohs$1;
      if(!(size$link2 + -1 >= len$link2))
        len$link2 = size$link2 - 1;

      if(len$link2 >= 3)
        len$link2 = len$link2 - 2;

      memcpy((void *)buffer$link2, (const void *)(buffer$link2 + (signed long int)2), (unsigned long int)len$link2);
      buffer$link2[(signed long int)len$link2] = (unsigned char)0;
      syslog(6, "io/hpmud/musb.c 780: read actual device_id successfully fd=%d len=%d\n", fd$link1, len$link2);
    }
  }

bugout:
  ;
  return len$link2;
}

// device_status
// file io/hpmud/pp.c line 644
static signed int device_status(signed int fd, unsigned int *status)
{
  signed int m;
  signed int stat = 1;
  unsigned char byte = (unsigned char)0x08;
  m = 1 << 8;
  signed int return_value_ioctl$1;
  return_value_ioctl$1=ioctl(fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x91 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &m);
  if(!(return_value_ioctl$1 == 0))
  {
    syslog(3, "io/hpmud/pp.c 652: unable to read device_status: %m\n");
    stat = HPMUD_R_IO_ERROR;
  }

  else
  {
    byte=read_status(fd);
    *status = (unsigned int)byte;
    stat = 0;
  }

bugout:
  ;
  return stat;
}

// device_status$link1
// file io/hpmud/musb.c line 786
static signed int device_status$link1(signed int fd$link1, unsigned int *status$link1)
{
  struct libusb_device_handle *hd;
  signed int interface;
  signed int len;
  signed int stat$link1 = 1;
  unsigned char byte$link1;
  hd = fd_table[(signed long int)fd$link1].hd;
  interface = fd_table[(signed long int)fd$link1].interface;
  if(hd == ((struct libusb_device_handle *)NULL))
    syslog(3, "io/hpmud/musb.c 798: invalid device_status state\n");

  else
  {
    len=libusb_control_transfer(hd, (unsigned char)(LIBUSB_ENDPOINT_IN | 32 | 1), (unsigned char)1, (unsigned short int)0, (unsigned short int)interface, &byte$link1, (unsigned short int)1, (unsigned int)5000);
    if(!(len >= 0))
      syslog(3, "io/hpmud/musb.c 811: invalid device_status: %m\n");

    else
    {
      *status$link1 = (unsigned int)byte$link1;
      stat$link1 = 0;
      syslog(6, "io/hpmud/musb.c 817: read actual device_status successfully fd=%d\n", fd$link1);
    }
  }

bugout:
  ;
  return stat$link1;
}

// ecp_fwd_to_rev
// file io/hpmud/pp.c line 187
static signed int ecp_fwd_to_rev(signed int fd)
{
  signed int dir = 1;
  signed int return_value_ecp_is_rev$1;
  return_value_ecp_is_rev$1=ecp_is_rev(fd);
  if(!(return_value_ecp_is_rev$1 == 0))
    return 0;

  else
  {
    wait_status(fd, (unsigned char)(0x80 | 0x8), (unsigned char)0, 30000000);
    ioctl(fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x90 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &dir);
    frob_control(fd, (unsigned char)0x2, (unsigned char)0);
    wait(10);
    frob_control(fd, (unsigned char)0x4, (unsigned char)0);
    wait_status(fd, (unsigned char)0x20, (unsigned char)0, 100000);
    return 0;
  }
}

// ecp_is_fwd
// file io/hpmud/pp.c line 146
static signed int ecp_is_fwd(signed int fd)
{
  unsigned char status;
  status=read_status(fd);
  if((0x20 & (signed int)status) == 0x20)
    return 1;

  else
    return 0;
}

// ecp_is_rev
// file io/hpmud/pp.c line 156
static signed int ecp_is_rev(signed int fd)
{
  unsigned char status;
  status=read_status(fd);
  if((0x20 & (signed int)status) == 0)
    return 1;

  else
    return 0;
}

// ecp_read
// file io/hpmud/pp.c line 362
static signed int ecp_read(signed int fd, void *buffer, signed int size, signed int usec)
{
  signed int i = 0;
  unsigned char *p = (unsigned char *)buffer;
  ecp_fwd_to_rev(fd);
  while(!(i >= size))
  {
    signed int return_value_ecp_read_data$1;
    return_value_ecp_read_data$1=ecp_read_data(fd, p + (signed long int)i);
    if(!(return_value_ecp_read_data$1 == 1))
    {
      usec = usec - 100000;
      if(usec >= 1)
        continue;

      return -110;
    }

    i = i + 1;
  }
  return i;
}

// ecp_read_data
// file io/hpmud/pp.c line 332
static signed int ecp_read_data(signed int fd, unsigned char *data)
{
  signed int len = 0;
  signed int return_value_wait_status$1;
  return_value_wait_status$1=wait_status(fd, (unsigned char)0x40, (unsigned char)0, 100000);
  if(!(return_value_wait_status$1 == 0))
    len = -1;

  else
  {
    ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x85 << 0)) | sizeof(unsigned char) /*1ul*/  << 0 + 8 + 8, data);
    frob_control(fd, (unsigned char)0x2, (unsigned char)0x2);
    wait_status(fd, (unsigned char)0x40, (unsigned char)0x40, 100000);
    frob_control(fd, (unsigned char)0x2, (unsigned char)0);
    len = 1;
  }

bugout:
  ;
  return len;
}

// ecp_rev_to_fwd
// file io/hpmud/pp.c line 166
static signed int ecp_rev_to_fwd(signed int fd)
{
  signed int dir = 0;
  signed int return_value_ecp_is_fwd$1;
  return_value_ecp_is_fwd$1=ecp_is_fwd(fd);
  if(!(return_value_ecp_is_fwd$1 == 0))
    return 0;

  else
  {
    frob_control(fd, (unsigned char)0x4, (unsigned char)0x4);
    wait_status(fd, (unsigned char)0x20, (unsigned char)0x20, 100000);
    ioctl(fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x90 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &dir);
    return 0;
  }
}

// ecp_write
// file io/hpmud/pp.c line 385
static signed int ecp_write(signed int fd, const void *buffer, signed int size)
{
  signed int i;
  unsigned char *p = (unsigned char *)buffer;
  static signed int timeout = 0;
  if(!(timeout == 0))
  {
    timeout = 0;
    return -1;
  }

  else
  {
    ecp_rev_to_fwd(fd);
    i = 0;
    for( ; !(i >= size); i = i + 1)
    {
      signed int return_value_ecp_write_data$1;
      return_value_ecp_write_data$1=ecp_write_data(fd, p[(signed long int)i]);
      if(!(return_value_ecp_write_data$1 == 1))
      {
        if(!(i == 0))
          timeout = 1;

        else
          i = -1;
        break;
      }

    }
    return i;
  }
}

// ecp_write_addr
// file io/hpmud/pp.c line 211
static signed int ecp_write_addr(signed int fd, unsigned char data)
{
  signed int cnt = 0;
  signed int len = 0;
  unsigned int d = (unsigned int)((signed int)data | 0x80);
  ecp_rev_to_fwd(fd);
  signed int return_value_wait_status$1;
  return_value_wait_status$1=wait_status(fd, (unsigned char)0x80, (unsigned char)0, 100000);
  if(!(return_value_wait_status$1 == 0))
    syslog(3, "io/hpmud/pp.c 221: ecp_write_addr transfer stalled\n");

  else
  {
    while((_Bool)1)
    {
      frob_control(fd, (unsigned char)0x2, (unsigned char)0);
      ioctl(fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x86 << 0)) | sizeof(unsigned char) /*1ul*/  << 0 + 8 + 8, &d);
      frob_control(fd, (unsigned char)0x1, (unsigned char)0);
      signed int return_value_wait_status$2;
      return_value_wait_status$2=wait_status(fd, (unsigned char)0x80, (unsigned char)0x80, 100000);
      if(!(return_value_wait_status$2 == 0))
      {
        frob_control(fd, (unsigned char)0x4, (unsigned char)0);
        wait_status(fd, (unsigned char)0x20, (unsigned char)0, 100000);
        frob_control(fd, (unsigned char)0x4, (unsigned char)0x4);
        wait_status(fd, (unsigned char)0x20, (unsigned char)0x20, 100000);
        cnt = cnt + 1;
        if(cnt >= 5)
        {
          syslog(3, "io/hpmud/pp.c 253: ecp_write_addr transfer stalled\n");
          goto bugout;
        }

        syslog(3, "io/hpmud/pp.c 256: ecp_write_addr host transfer recovery cnt=%d\n", cnt);
      }

      else
        break;
    }
    len = 1;
  }

bugout:
  ;
  frob_control(fd, (unsigned char)0x1, (unsigned char)0x1);
  return len;
}

// ecp_write_data
// file io/hpmud/pp.c line 272
static signed int ecp_write_data(signed int fd, unsigned char data)
{
  signed int cnt = 0;
  signed int len = 0;
  signed int return_value_wait_status$1;
  return_value_wait_status$1=wait_status(fd, (unsigned char)0x80, (unsigned char)0, 100000);
  if(!(return_value_wait_status$1 == 0))
    syslog(3, "io/hpmud/pp.c 281: ecp_write_data transfer stalled\n");

  else
  {
    while((_Bool)1)
    {
      frob_control(fd, (unsigned char)0x2, (unsigned char)0x2);
      ioctl(fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x86 << 0)) | sizeof(unsigned char) /*1ul*/  << 0 + 8 + 8, &data);
      frob_control(fd, (unsigned char)0x1, (unsigned char)0);
      signed int return_value_wait_status$2;
      return_value_wait_status$2=wait_status(fd, (unsigned char)0x80, (unsigned char)0x80, 100000);
      if(!(return_value_wait_status$2 == 0))
      {
        frob_control(fd, (unsigned char)0x4, (unsigned char)0);
        wait_status(fd, (unsigned char)0x20, (unsigned char)0, 100000);
        frob_control(fd, (unsigned char)0x4, (unsigned char)0x4);
        wait_status(fd, (unsigned char)0x20, (unsigned char)0x20, 100000);
        cnt = cnt + 1;
        if(cnt >= 5)
        {
          syslog(3, "io/hpmud/pp.c 313: ecp_write_data transfer stalled\n");
          goto bugout;
        }

        syslog(3, "io/hpmud/pp.c 316: ecp_write_data host transfer recovery cnt=%d\n", cnt);
      }

      else
        break;
    }
    len = 1;
  }

bugout:
  ;
  frob_control(fd, (unsigned char)0x1, (unsigned char)0x1);
  return len;
}

// frob_control
// file io/hpmud/pp.c line 70
static signed int frob_control(signed int fd, unsigned char mask, unsigned char val)
{
  struct ppdev_frob_struct frob;
  frob.val = (unsigned char)((signed int)val ^ (signed int)mask & (0x1 | 0x2 | 0x8));
  frob.mask = mask;
  signed int return_value_ioctl$1;
  return_value_ioctl$1=ioctl(fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x8e << 0)) | sizeof(struct ppdev_frob_struct) /*2ul*/  << 0 + 8 + 8, &frob);
  return return_value_ioctl$1;
}

// generalize_model
// file io/hpmud/hpmud.c line 107
signed int generalize_model(const char *sz, char *buf, signed int bufSize)
{
  const char *pMd = sz;
  signed int i;
  signed int j;
  signed int dd = 0;
  _Bool tmp_if_expr$1;
  if(sz == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)sz[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    i = 0;
    for( ; (signed int)pMd[(signed long int)i] == 32 && !(i >= bufSize); i = i + 1)
      ;
    j = 0;
    do
    {
      if(!((signed int)pMd[(signed long int)i] == 0))
        tmp_if_expr$2 = (signed int)pMd[(signed long int)i] != 59 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(j >= bufSize || !tmp_if_expr$2)
        break;

      _Bool tmp_if_expr$5;
      if((signed int)pMd[(signed long int)i] == 32)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)pMd[(signed long int)i] == 47 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
      {
        if(dd == 0)
        {
          signed int tmp_post$3 = j;
          j = j + 1;
          buf[(signed long int)tmp_post$3] = (char)95;
          dd = 1;
        }

      }

      else
      {
        signed int tmp_post$4 = j;
        j = j + 1;
        buf[(signed long int)tmp_post$4] = pMd[(signed long int)i];
        dd = 0;
      }
      i = i + 1;
    }
    while((_Bool)1);
    j = j - 1;
    for( ; (signed int)buf[(signed long int)j] == 95 && j >= 1; j = j - 1)
      ;
    j = j + 1;
    buf[(signed long int)j] = (char)0;
    return j;
  }
}

// generalize_serial
// file io/hpmud/hpmud.c line 143
signed int generalize_serial(const char *sz, char *buf, signed int bufSize)
{
  const char *pMd = sz;
  signed int i;
  signed int j;
  _Bool tmp_if_expr$1;
  if(sz == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)sz[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    i = 0;
    for( ; (signed int)pMd[(signed long int)i] == 32 && !(i >= bufSize); i = i + 1)
      ;
    j = 0;
    for( ; !((signed int)pMd[(signed long int)i] == 0) && !(i >= bufSize); i = i + 1)
    {
      signed int tmp_post$2 = j;
      j = j + 1;
      buf[(signed long int)tmp_post$2] = pMd[(signed long int)i];
    }
    i = i - 1;
    for( ; (signed int)buf[(signed long int)i] == 32 && i >= 1; i = i - 1)
      ;
    i = i + 1;
    buf[(signed long int)i] = (char)0;
    return i;
  }
}

// getHPLogLevel
// file common/utils.h line 157
signed int getHPLogLevel()
{
  struct _IO_FILE *fp;
  char str[258l];
  char *p;
  signed int iLogLevel = 0;
  fp=fopen("/etc/cups/cupsd.conf", "r");
  signed int return_value_feof$1;
  if(fp == ((struct _IO_FILE *)NULL))
    return 0;

  else
  {
    do
    {
      return_value_feof$1=feof(fp);
      if(!(return_value_feof$1 == 0))
        break;

      char *return_value_fgets$2;
      return_value_fgets$2=fgets(str, 256, fp);
      if(return_value_fgets$2 == ((char *)NULL))
        break;

      p=strstr(str, "hpLogLevel");
      if(!(p == ((char *)NULL)))
      {
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen("hpLogLevel");
        p = p + (signed long int)(return_value_strlen$3 + (unsigned long int)1);
        iLogLevel=atoi(p);
        break;
      }

    }
    while((_Bool)1);
    fclose(fp);
    return iLogLevel;
  }
}

// get_conf
// file common/utils.c line 50
enum UTILS_CONF_RESULT get_conf(const char *section, const char *key, char *value, signed int value_size)
{
  enum UTILS_CONF_RESULT return_value_get_key_value$1;
  return_value_get_key_value$1=get_key_value("/etc/hp/hplip.conf", section, key, value, value_size);
  return return_value_get_key_value$1;
}

// get_ep
// file io/hpmud/musb.c line 441
static signed int get_ep(struct libusb_device *dev, signed int config, signed int interface, signed int altset, enum libusb_transfer_type type, enum libusb_endpoint_direction epdir)
{
  struct libusb_config_descriptor *confptr = (struct libusb_config_descriptor *)(void *)0;
  struct libusb_interface_descriptor *pi;
  signed int i;
  signed int endpoint = -1;
  signed int return_value_libusb_get_config_descriptor$1;
  return_value_libusb_get_config_descriptor$1=libusb_get_config_descriptor(dev, (unsigned char)config, &confptr);
  if(return_value_libusb_get_config_descriptor$1 == 0)
  {
    _Bool tmp_if_expr$2;
    if(confptr == ((struct libusb_config_descriptor *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = confptr->interface == (struct libusb_interface *)(void *)0 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$3;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (confptr->interface + (signed long int)interface)->altsetting == (struct libusb_interface_descriptor *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$3)
    {
      pi = &(confptr->interface + (signed long int)interface)->altsetting[(signed long int)altset];
      i = 0;
      for( ; !(i >= (signed int)pi->bNumEndpoints); i = i + 1)
      {
        if(pi->endpoint == ((struct libusb_endpoint_descriptor *)NULL))
          break;

        if((signed int)(pi->endpoint + (signed long int)i)->bmAttributes == (signed int)type)
        {
          if((signed int)epdir == LIBUSB_ENDPOINT_IN)
          {
            if(!((LIBUSB_ENDPOINT_IN & (signed int)(pi->endpoint + (signed long int)i)->bEndpointAddress) == 0))
            {
              endpoint = (signed int)(pi->endpoint + (signed long int)i)->bEndpointAddress;
              break;
            }

          }

          else
            if((signed int)epdir == LIBUSB_ENDPOINT_OUT)
            {
              if((LIBUSB_ENDPOINT_IN & (signed int)(pi->endpoint + (signed long int)i)->bEndpointAddress) == 0)
              {
                endpoint = (signed int)(pi->endpoint + (signed long int)i)->bEndpointAddress;
                break;
              }

            }

        }

      }
    }

  }


bugout:
  ;
  libusb_free_config_descriptor(confptr);
  if(endpoint == -1)
    syslog(6, "io/hpmud/musb.c 481: get_ep: ERROR! returning -1\n");

  return endpoint;
}

// get_in_ep
// file io/hpmud/musb.c line 485
static signed int get_in_ep(struct libusb_device *dev, signed int config, signed int interface, signed int altset, enum libusb_transfer_type type)
{
  signed int return_value_get_ep$1;
  return_value_get_ep$1=get_ep(dev, config, interface, altset, type, (enum libusb_endpoint_direction)LIBUSB_ENDPOINT_IN);
  return return_value_get_ep$1;
}

// get_interface
// file io/hpmud/musb.c line 401
static signed int get_interface(struct libusb_device *dev, enum FD_ID index, struct anonymous$20 *pfd)
{
  struct libusb_device_descriptor device_desc;
  struct libusb_config_descriptor *confptr = (struct libusb_config_descriptor *)(void *)0;
  struct libusb_interface *ifaceptr = (struct libusb_interface *)(void *)0;
  struct libusb_interface_descriptor *altptr = (struct libusb_interface_descriptor *)(void *)0;
  signed int conf;
  signed int iface;
  signed int altset;
  libusb_get_device_descriptor(dev, &device_desc);
  conf = 0;
  for( ; !(conf >= (signed int)device_desc.bNumConfigurations); conf = conf + 1)
  {
    signed int return_value_libusb_get_config_descriptor$1;
    return_value_libusb_get_config_descriptor$1=libusb_get_config_descriptor(dev, (unsigned char)conf, &confptr);
    if(return_value_libusb_get_config_descriptor$1 == 0)
    {
      iface = 0;
      ifaceptr = confptr->interface;
      for( ; !(iface >= (signed int)confptr->bNumInterfaces); ifaceptr = ifaceptr + 1l)
      {
        altset = 0;
        altptr = ifaceptr->altsetting;
        for( ; !(altset >= ifaceptr->num_altsetting); altptr = altptr + 1l)
        {
          if(!(altptr == ((struct libusb_interface_descriptor *)NULL)))
          {
            if((signed int)altptr->bInterfaceClass == fd_class[(signed long int)index])
            {
              if((signed int)altptr->bInterfaceSubClass == fd_subclass[(signed long int)index])
              {
                if((signed int)altptr->bInterfaceProtocol == fd_protocol[(signed long int)index])
                {
                  pfd->config = conf;
                  pfd->interface = iface;
                  pfd->alt_setting = altset;
                  pfd->fd = index;
                  syslog(6, "io/hpmud/musb.c 427: Found interface conf=%d, iface=%d, altset=%d, index=%d\n", conf, iface, altset, index);
                  libusb_free_config_descriptor(confptr);
                  return 0;
                }

              }

            }

          }

          altset = altset + 1;
        }
        iface = iface + 1;
      }
      libusb_free_config_descriptor(confptr);
    }

  }
  return 1;
}

// get_key_value
// file common/utils.c line 56
enum UTILS_CONF_RESULT get_key_value(const char *file, const char *section, const char *key, char *value, signed int value_size)
{
  char new_key[256l];
  char new_value[256l];
  char rcbuf[255l];
  char new_section[32l];
  char *tail;
  struct _IO_FILE *inFile;
  enum UTILS_CONF_RESULT stat = (enum UTILS_CONF_RESULT)UTILS_CONF_DATFILE_ERROR;
  signed int i;
  signed int j;
  inFile=fopen(file, "r");
  char *return_value_fgets$1;
  signed int return_value_strcasecmp$7;
  if(inFile == ((struct _IO_FILE *)NULL))
    syslog(3, "common/utils.c 69: unable to open %s: %m\n", file);

  else
  {
    new_section[(signed long int)0] = (char)0;
    do
    {
      return_value_fgets$1=fgets(rcbuf, (signed int)sizeof(char [255l]) /*255ul*/ , inFile);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      if((signed int)rcbuf[0l] == 91)
      {
        j = 0;
        i = j;
        while(!((signed int)rcbuf[(signed long int)i] == 93))
        {
          if((unsigned long int)j >= 30ul)
            break;

          signed int tmp_post$2 = j;
          j = j + 1;
          signed int tmp_post$3 = i;
          i = i + 1;
          new_section[(signed long int)tmp_post$2] = rcbuf[(signed long int)tmp_post$3];
        }
        signed int tmp_post$4 = j;
        j = j + 1;
        signed int tmp_post$5 = i;
        i = i + 1;
        new_section[(signed long int)tmp_post$4] = rcbuf[(signed long int)tmp_post$5];
        new_section[(signed long int)j] = (char)0;
      }

      else
      {
        unsigned long int return_value_strlen$6;
        return_value_strlen$6=strlen(rcbuf);
        GetPair$link1(rcbuf, (signed int)return_value_strlen$6, new_key, new_value, &tail);
        signed int return_value_strcasecmp$8;
        return_value_strcasecmp$8=strcasecmp(new_section, section);
        if(return_value_strcasecmp$8 == 0)
        {
          return_value_strcasecmp$7=strcasecmp(new_key, key);
          if(return_value_strcasecmp$7 == 0)
          {
            strncpy(value, new_value, (unsigned long int)value_size);
            stat = (enum UTILS_CONF_RESULT)UTILS_CONF_OK;
            break;
          }

        }

      }
    }
    while((_Bool)1);
    if(!((signed int)stat == UTILS_CONF_OK))
      syslog(3, "common/utils.c 99: unable to find %s %s in %s\n", section, key, file);

  }

bugout:
  ;
  if(!(inFile == ((struct _IO_FILE *)NULL)))
    fclose(inFile);

  return stat;
}

// get_library_symbol
// file common/utils.c line 193
void * get_library_symbol(void *pLibHandler, const char *szSymbol)
{
  void *pSymHandler = (void *)0;
  char *return_value_dlerror$2;
  if(pLibHandler == NULL)
  {
    syslog(3, "common/utils.c 198: Invalid Library hanlder\n");
    return (void *)0;
  }

  else
  {
    _Bool tmp_if_expr$1;
    if(szSymbol == ((const char *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)szSymbol[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      syslog(3, "common/utils.c 204: Invalid Library symbol\n");
      return (void *)0;
    }

    else
    {
      pSymHandler=dlsym(pLibHandler, szSymbol);
      if(pSymHandler == NULL)
      {
        return_value_dlerror$2=dlerror();
        syslog(3, "common/utils.c 210: Can't find %s symbol in Library:%s\n", szSymbol, return_value_dlerror$2);
      }

      return pSymHandler;
    }
  }
}

// get_libusb_device
// file io/hpmud/musb.c line 688
static struct libusb_device * get_libusb_device(const char *uri)
{
  struct libusb_device *dev = (struct libusb_device *)(void *)0;
  struct libusb_device_descriptor devdesc;
  struct libusb_config_descriptor *confptr = (struct libusb_config_descriptor *)(void *)0;
  struct libusb_interface *ifaceptr = (struct libusb_interface *)(void *)0;
  struct libusb_interface_descriptor *altptr = (struct libusb_interface_descriptor *)(void *)0;
  signed int numdevs = 0;
  signed int i;
  signed int conf;
  signed int iface;
  signed int altset;
  i=libusb_init(&libusb_ctx);
  signed long int return_value_libusb_get_device_list$1;
  if(i == 0)
  {
    return_value_libusb_get_device_list$1=libusb_get_device_list(libusb_ctx, &libusb_dev_list);
    numdevs = (signed int)return_value_libusb_get_device_list$1;
    i = 0;
    for( ; !(i >= numdevs); i = i + 1)
    {
      dev = libusb_dev_list[(signed long int)i];
      memset((void *)&devdesc, 0, sizeof(struct libusb_device_descriptor) /*18ul*/ );
      libusb_get_device_descriptor(dev, &devdesc);
      if(!(devdesc.idProduct == 0) && !(devdesc.idVendor == 0) && !(devdesc.bNumConfigurations == 0))
      {
        if((signed int)devdesc.idVendor == 0x3f0)
        {
          conf = 0;
          for( ; !(conf >= (signed int)devdesc.bNumConfigurations); conf = conf + 1)
          {
            signed int return_value_libusb_get_config_descriptor$2;
            return_value_libusb_get_config_descriptor$2=libusb_get_config_descriptor(dev, (unsigned char)conf, &confptr);
            if(return_value_libusb_get_config_descriptor$2 >= 0)
            {
              iface = 0;
              ifaceptr = confptr->interface;
              for( ; !(iface >= (signed int)confptr->bNumInterfaces); ifaceptr = ifaceptr + 1l)
              {
                altset = 0;
                altptr = ifaceptr->altsetting;
                for( ; !(altset >= ifaceptr->num_altsetting); altptr = altptr + 1l)
                {
                  if((signed int)altptr->bInterfaceClass == 7)
                  {
                    if((signed int)altptr->bInterfaceSubClass == 1)
                    {
                      signed int return_value_is_uri$3;
                      return_value_is_uri$3=is_uri(dev, uri);
                      if(!(return_value_is_uri$3 == 0))
                      {
                        libusb_free_config_descriptor(confptr);
                        return dev;
                      }

                    }

                  }

                  altset = altset + 1;
                }
                iface = iface + 1;
              }
              libusb_free_config_descriptor(confptr);
              confptr = (struct libusb_config_descriptor *)(void *)0;
            }

          }
        }

      }

    }
  }


bugout:
  ;
  if(!(confptr == ((struct libusb_config_descriptor *)NULL)))
    libusb_free_config_descriptor(confptr);

  return (struct libusb_device *)(void *)0;
}

// get_out_ep
// file io/hpmud/musb.c line 490
static signed int get_out_ep(struct libusb_device *dev, signed int config, signed int interface, signed int altset, enum libusb_transfer_type type)
{
  signed int return_value_get_ep$1;
  return_value_get_ep$1=get_ep(dev, config, interface, altset, type, (enum libusb_endpoint_direction)LIBUSB_ENDPOINT_OUT);
  return return_value_get_ep$1;
}

// get_pjl_input
// file prnt/backend/hp.c line 279
static enum HPMUD_RESULT get_pjl_input(signed int dd, signed int cd, char *buf, signed int buf_size, signed int sec_timeout, signed int *bytes_read)
{
  enum HPMUD_RESULT stat;
  signed int len;
  *bytes_read = 0;
  stat=hpmud_read_channel(dd, cd, (void *)buf, buf_size, sec_timeout, &len);
  if((signed int)stat == HPMUD_R_OK)
  {
    buf[(signed long int)len] = (char)0;
    *bytes_read = len;
    stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  }


bugout:
  ;
  return stat;
}

// get_printer_status
// file prnt/backend/hp.c line 403
static signed int get_printer_status(signed int dd, signed int cd, struct pjl_attributes *pa)
{
  char id[1024l];
  char *pSf;
  signed int status;
  signed int ver;
  signed int len;
  enum HPMUD_RESULT r;
  if(!(pa->pjl_device == 0))
  {
    pthread_mutex_lock(&pa->mutex);
    status = pa->current_status;
    pthread_mutex_unlock(&pa->mutex);
  }

  else
  {
    status = 1000;
    r=hpmud_get_device_id(dd, id, (signed int)sizeof(char [1024l]) /*1024ul*/ , &len);
    if(!((signed int)r == HPMUD_R_OK))
      status = 5000 + (signed int)r;

    else
    {
      pSf=strstr(id, ";S:");
      if(pSf == ((char *)NULL))
      {
        unsigned int bit_status;
        r=hpmud_get_device_status(dd, &bit_status);
        if(!((signed int)r == HPMUD_R_OK))
        {
          status = 5000 + (signed int)r;
          goto bugout;
        }

        if((40u & bit_status) == 40u)
          status = 1009;

        else
          if((40u & bit_status) == 32u)
            status = 1014;

          else
            if((40u & bit_status) == 0u)
              status = 1015;

      }

      else
      {
        pSf = pSf + (signed long int)3;
        ver = 0;
        _Bool tmp_if_expr$2;
        if((signed int)*pSf >= 48)
          tmp_if_expr$2 = (signed int)*pSf <= 57 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          ver = ver | (signed int)*pSf - 48;

        else
        {
          _Bool tmp_if_expr$1;
          if((signed int)*pSf >= 65)
            tmp_if_expr$1 = (signed int)*pSf <= 70 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          if(tmp_if_expr$1)
            ver = ver | (0xA + (signed int)*pSf) - 65;

          else
            if((signed int)*pSf >= 97)
            {
              if(!((signed int)*pSf >= 103))
                ver = ver | (0xA + (signed int)*pSf) - 97;

            }

        }
        pSf = pSf + 1l;
        ver = ver << 4;
        _Bool tmp_if_expr$4;
        if((signed int)*pSf >= 48)
          tmp_if_expr$4 = (signed int)*pSf <= 57 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(tmp_if_expr$4)
          ver = ver | (signed int)*pSf - 48;

        else
        {
          _Bool tmp_if_expr$3;
          if((signed int)*pSf >= 65)
            tmp_if_expr$3 = (signed int)*pSf <= 70 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          if(tmp_if_expr$3)
            ver = ver | (0xA + (signed int)*pSf) - 65;

          else
            if((signed int)*pSf >= 97)
            {
              if(!((signed int)*pSf >= 103))
                ver = ver | (0xA + (signed int)*pSf) - 97;

            }

        }
        pSf = pSf + 1l;
        switch(ver)
        {
          case 0:

          case 1:

          case 2:
          {
            pSf = pSf + (signed long int)12;
            break;
          }
          case 3:
          {
            pSf = pSf + (signed long int)14;
            break;
          }
          case 4:
          {
            pSf = pSf + (signed long int)18;
            break;
          }
          default:
          {
            bug("prnt/backend/hp.c 473: WARNING: unknown S-field version=%d\n", ver);
            pSf = pSf + (signed long int)12;
          }
        }
        status = 0;
        _Bool tmp_if_expr$6;
        if((signed int)*pSf >= 48)
          tmp_if_expr$6 = (signed int)*pSf <= 57 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$6 = (_Bool)0;
        if(tmp_if_expr$6)
          status = status | (signed int)*pSf - 48;

        else
        {
          _Bool tmp_if_expr$5;
          if((signed int)*pSf >= 65)
            tmp_if_expr$5 = (signed int)*pSf <= 70 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$5 = (_Bool)0;
          if(tmp_if_expr$5)
            status = status | (0xA + (signed int)*pSf) - 65;

          else
            if((signed int)*pSf >= 97)
            {
              if(!((signed int)*pSf >= 103))
                status = status | (0xA + (signed int)*pSf) - 97;

            }

        }
        pSf = pSf + 1l;
        status = status << 4;
        _Bool tmp_if_expr$8;
        if((signed int)*pSf >= 48)
          tmp_if_expr$8 = (signed int)*pSf <= 57 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$8 = (_Bool)0;
        if(tmp_if_expr$8)
          status = status | (signed int)*pSf - 48;

        else
        {
          _Bool tmp_if_expr$7;
          if((signed int)*pSf >= 65)
            tmp_if_expr$7 = (signed int)*pSf <= 70 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$7 = (_Bool)0;
          if(tmp_if_expr$7)
            status = status | (0xA + (signed int)*pSf) - 65;

          else
            if((signed int)*pSf >= 97)
            {
              if(!((signed int)*pSf >= 103))
                status = status | (0xA + (signed int)*pSf) - 97;

            }

        }
        status = status + 1000;
      }
    }
  }

bugout:
  ;
  return status;
}

// get_string_descriptor
// file io/hpmud/musb.c line 128
static signed int get_string_descriptor(struct libusb_device_handle *dev_handle, signed int index, char *buf, unsigned long int buflen)
{
  unsigned char tbuf[255l] = { (unsigned char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int ret;
  signed int si;
  signed int di;
  signed int cnt = 5;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = cnt;
    cnt = cnt - 1;
    if(tmp_post$1 == 0)
      break;

    ret=libusb_control_transfer(dev_handle, (unsigned char)LIBUSB_ENDPOINT_IN, (unsigned char)6, (unsigned short int)((3 << 8) + index), (unsigned short int)0x409, tbuf, (unsigned short int)sizeof(unsigned char [255l]) /*255ul*/ , (unsigned int)5000);
    if(ret == 0)
      syslog(3, "io/hpmud/musb.c 145: get_string_descriptor zero result, retrying...");

    else
      break;
  }
  while((_Bool)1);
  if(!(ret >= 0))
  {
    syslog(3, "io/hpmud/musb.c 153: unable get_string_descriptor %d: %m\n", ret);
    return ret;
  }

  else
    if(!((signed int)tbuf[1l] == 3))
    {
      syslog(3, "io/hpmud/musb.c 159: invalid get_string_descriptor tag act=%d exp=%d\n", tbuf[(signed long int)1], 3);
      return -5;
    }

    else
      if(!(ret >= (signed int)tbuf[0l]))
      {
        syslog(3, "io/hpmud/musb.c 165: invalid get_string_descriptor size act=%d exp=%d\n", tbuf[(signed long int)0], ret);
        return -27;
      }

      else
      {
        di = 0;
        si = 2;
        for( ; !(si >= (signed int)tbuf[0l]); si = si + 2)
        {
          if((unsigned long int)di >= buflen + 18446744073709551615ul)
            break;

          if(!(tbuf[(signed long int)(1 + si)] == 0))
          {
            signed int tmp_post$2 = di;
            di = di + 1;
            buf[(signed long int)tmp_post$2] = (char)48;
          }

          else
          {
            signed int tmp_post$3 = di;
            di = di + 1;
            buf[(signed long int)tmp_post$3] = (char)tbuf[(signed long int)si];
          }
        }
        buf[(signed long int)di] = (char)0;
        return di;
      }
}

// get_uri_serial
// file io/hpmud/hpmud.c line 166
signed int get_uri_serial(const char *uri, char *buf, signed int bufSize)
{
  char *p;
  signed int i;
  _Bool tmp_if_expr$1;
  if(uri == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)uri[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    buf[(signed long int)0] = (char)0;
    p=strcasestr(uri, "serial=");
    if(!(p == ((char *)NULL)))
      p = p + (signed long int)7;

    else
      return 0;
    i = 0;
    do
    {
      if(!((signed int)p[(signed long int)i] == 0))
        tmp_if_expr$2 = (signed int)p[(signed long int)i] != 43 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(i >= bufSize || !tmp_if_expr$2)
        break;

      buf[(signed long int)i] = p[(signed long int)i];
      i = i + 1;
    }
    while((_Bool)1);
    buf[(signed long int)i] = (char)0;
    return i;
  }
}

// hpmud_close_channel
// file io/hpmud/hpmud.h line 289
enum HPMUD_RESULT hpmud_close_channel(signed int dd, signed int cd)
{
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_STATE;
  _Bool tmp_if_expr$1;
  if(dd >= 3 || !(dd >= 1))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = msp->device[(signed long int)dd].index != dd ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(cd >= 48 || !(cd >= 1) || tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = msp->device[(signed long int)dd].channel[(signed long int)cd].client_cnt == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    syslog(3, "io/hpmud/hpmud.c 702: invalid channel_close state\n");

  else
    stat=msp->device[(signed long int)dd].vf.channel_close(&msp->device[(signed long int)dd], &msp->device[(signed long int)dd].channel[(signed long int)cd]);

bugout:
  ;
  return stat;
}

// hpmud_close_device
// file io/hpmud/hpmud.h line 204
enum HPMUD_RESULT hpmud_close_device(signed int dd)
{
  enum HPMUD_RESULT stat;
  _Bool tmp_if_expr$1;
  if(dd >= 3 || !(dd >= 1))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = msp->device[(signed long int)dd].index != dd ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    syslog(3, "io/hpmud/hpmud.c 569: invalid device_close state\n");
    stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_STATE;
  }

  else
  {
    stat=msp->device[(signed long int)dd].vf.close(&msp->device[(signed long int)dd]);
    del_device(dd);
  }
  return stat;
}

// hpmud_get_device_id
// file io/hpmud/hpmud.h line 220
enum HPMUD_RESULT hpmud_get_device_id(signed int dd, char *buf, signed int size, signed int *bytes_read)
{
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_STATE;
  _Bool tmp_if_expr$1;
  if(dd >= 3 || !(dd >= 1))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = msp->device[(signed long int)dd].index != dd ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    syslog(3, "io/hpmud/hpmud.c 588: invalid get_device_id state\n");

  else
    stat=msp->device[(signed long int)dd].vf.get_device_id(&msp->device[(signed long int)dd], buf, size, bytes_read);

bugout:
  ;
  return stat;
}

// hpmud_get_device_status
// file io/hpmud/hpmud.h line 232
enum HPMUD_RESULT hpmud_get_device_status(signed int dd, unsigned int *status)
{
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_STATE;
  _Bool tmp_if_expr$1;
  if(dd >= 3 || !(dd >= 1))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = msp->device[(signed long int)dd].index != dd ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    syslog(3, "io/hpmud/hpmud.c 606: invalid get_device_status state\n");

  else
    stat=msp->device[(signed long int)dd].vf.get_device_status(&msp->device[(signed long int)dd], status);

bugout:
  ;
  return stat;
}

// hpmud_get_dstat
// file io/hpmud/hpmud.c line 749
enum HPMUD_RESULT hpmud_get_dstat(signed int dd, struct hpmud_dstat *ds)
{
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_STATE;
  if(dd >= 3 || !(dd >= 1))
    syslog(3, "io/hpmud/hpmud.c 757: invalid dstat state\n");

  else
  {
    strncpy(ds->uri, msp->device[(signed long int)dd].uri, sizeof(char [256l]) /*256ul*/ );
    ds->io_mode = msp->device[(signed long int)dd].io_mode;
    ds->channel_cnt = msp->device[(signed long int)dd].channel_cnt;
    ds->mlc_up = msp->device[(signed long int)dd].mlc_up;
    stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  }

bugout:
  ;
  return stat;
}

// hpmud_get_model
// file io/hpmud/hpmud.c line 408
signed int hpmud_get_model(const char *id, char *buf, signed int buf_size)
{
  char *pMd;
  _Bool tmp_if_expr$1;
  if(id == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)id[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    buf[(signed long int)0] = (char)0;
    pMd=strstr(id, "MDL:");
    if(!(pMd == ((char *)NULL)))
      pMd = pMd + (signed long int)4;

    else
    {
      pMd=strstr(id, "MODEL:");
      if(!(pMd == ((char *)NULL)))
        pMd = pMd + (signed long int)6;

      else
        return 0;
    }
    signed int return_value_generalize_model$2;
    return_value_generalize_model$2=generalize_model(pMd, buf, buf_size);
    return return_value_generalize_model$2;
  }
}

// hpmud_get_model_attributes
// file io/hpmud/model.c line 510
enum HPMUD_RESULT hpmud_get_model_attributes(char *uri, char *attr, signed int attrSize, signed int *bytes_read)
{
  char sz[256l];
  char model[256l];
  signed int found;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_DATFILE_ERROR;
  memset((void *)attr, 0, (unsigned long int)attrSize);
  do
  {
    (&head.list)->next = &head.list;
    (&head.list)->prev = &head.list;
  }
  while((_Bool)0);
  if((signed int)homedir[0l] == 0)
    ReadConfig();

  hpmud_get_uri_model(uri, model, (signed int)sizeof(char [256l]) /*256ul*/ );
  snprintf(sz, sizeof(char [256l]) /*256ul*/ , "%s/data/models/models.dat", (const void *)homedir);
  found=ParseFile(sz, model, attr, attrSize, bytes_read);
  if(found == 0)
  {
    syslog(3, "io/hpmud/model.c 532: no %s attributes found in %s\n", (const void *)model, (const void *)sz);
    DelList();
    snprintf(sz, sizeof(char [256l]) /*256ul*/ , "%s/data/models/unreleased/unreleased.dat", (const void *)homedir);
    found=ParseFile(sz, model, attr, attrSize, bytes_read);
  }

  if(found == 0)
    syslog(3, "io/hpmud/model.c 543: no %s attributes found in %s\n", (const void *)model, (const void *)sz);

  else
    stat = (enum HPMUD_RESULT)HPMUD_R_OK;

bugout:
  ;
  DelList();
  return stat;
}

// hpmud_get_pml
// file io/hpmud/pml.c line 408
enum HPMUD_RESULT hpmud_get_pml(signed int device, signed int channel, const char *snmp_oid, void *buf, signed int buf_size, signed int *bytes_read, signed int *type, signed int *pml_result)
{
  unsigned char message[16384l];
  unsigned char oid[256l];
  char ip[256l];
  char *psz;
  char *tail;
  unsigned char *p = message;
  signed int len;
  signed int dLen;
  signed int result;
  signed int reply;
  signed int status;
  signed int dt;
  signed int port;
  struct hpmud_dstat ds;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  enum HPMUD_RESULT return_value_hpmud_get_dstat$1;
  return_value_hpmud_get_dstat$1=hpmud_get_dstat(device, &ds);
  result = (signed int)return_value_hpmud_get_dstat$1;
  char *return_value_strcasestr$13;
  signed long int return_value_strtol$2;
  if(!(result == HPMUD_R_OK))
    stat = (enum HPMUD_RESULT)result;

  else
  {
    return_value_strcasestr$13=strcasestr(ds.uri, "net/");
    if(!(return_value_strcasestr$13 == ((char *)NULL)))
    {
      hpmud_get_uri_datalink(ds.uri, ip, (signed int)sizeof(char [256l]) /*256ul*/ );
      psz=strstr(ds.uri, "port=");
      if(!(psz == ((char *)NULL)))
      {
        return_value_strtol$2=strtol(psz + (signed long int)5, &tail, 10);
        port = (signed int)return_value_strtol$2;
      }

      else
        port = 1;
      dLen=GetSnmp(ip, port, snmp_oid, (void *)message, (unsigned int)sizeof(unsigned char [16384l]) /*16384ul*/ , &dt, &status, &result);
      if(!(result == HPMUD_R_OK))
      {
        dLen=GetSnmp(ip, 2, snmp_oid, (void *)message, (unsigned int)sizeof(unsigned char [16384l]) /*16384ul*/ , &dt, &status, &result);
        if(!(result == HPMUD_R_OK))
        {
          syslog(3, "io/hpmud/pml.c 444: GetPml failed ret=%d\n", result);
          stat = (enum HPMUD_RESULT)result;
          goto bugout;
        }

      }

      p = message;
    }

    else
    {
      dLen=SnmpToPml(snmp_oid, oid, (signed int)sizeof(unsigned char [256l]) /*256ul*/ );
      unsigned char *tmp_post$3 = p;
      p = p + 1l;
      *tmp_post$3 = (unsigned char)0;
      unsigned char *tmp_post$4 = p;
      p = p + 1l;
      *tmp_post$4 = (unsigned char)0;
      unsigned char *tmp_post$5 = p;
      p = p + 1l;
      *tmp_post$5 = (unsigned char)dLen;
      memcpy((void *)p, (const void *)oid, (unsigned long int)dLen);
      enum HPMUD_RESULT return_value_hpmud_write_channel$6;
      return_value_hpmud_write_channel$6=hpmud_write_channel(device, channel, (const void *)message, dLen + 3, 45, &len);
      result = (signed int)return_value_hpmud_write_channel$6;
      if(!(result == HPMUD_R_OK))
      {
        syslog(3, "io/hpmud/pml.c 466: GetPml channel_write failed ret=%d\n", result);
        stat = (enum HPMUD_RESULT)result;
        goto bugout;
      }

      enum HPMUD_RESULT return_value_hpmud_read_channel$7;
      return_value_hpmud_read_channel$7=hpmud_read_channel(device, channel, (void *)message, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ , 45, &len);
      result = (signed int)return_value_hpmud_read_channel$7;
      if(len == 0 || !(result == HPMUD_R_OK))
      {
        syslog(3, "io/hpmud/pml.c 474: GetPml channel_read failed ret=%d len=%d\n", result, len);
        goto bugout;
      }

      p = message;
      unsigned char *tmp_post$8 = p;
      p = p + 1l;
      reply = (signed int)*tmp_post$8;
      unsigned char *tmp_post$9 = p;
      p = p + 1l;
      status = (signed int)*tmp_post$9;
      if(!((0x80 & status) == 0) && !(reply == 128))
      {
        syslog(3, "io/hpmud/pml.c 484: GetPml failed reply=%x outcome=%x\n", reply, status);
        goto bugout;
      }

      unsigned char *tmp_post$10 = p;
      p = p + 1l;
      dt = (signed int)*tmp_post$10;
      if(dt == 24)
      {
        p = p + (signed long int)2;
        unsigned char *tmp_post$11 = p;
        p = p + 1l;
        dt = (signed int)*tmp_post$11;
      }

      if(!(dt == 0))
      {
        syslog(3, "io/hpmud/pml.c 500: GetPml failed data type=%x\n", dt);
        goto bugout;
      }

      unsigned char *tmp_post$12 = p;
      p = p + 1l;
      dLen = (signed int)*tmp_post$12;
      p = p + (signed long int)dLen;
      dt = (signed int)*p;
      dLen = ((signed int)*p & 0x3) << 8 | (signed int)p[(signed long int)1];
      p = p + (signed long int)2;
    }
    if(!(buf_size >= dLen))
      dLen = buf_size;

    memcpy(buf, (const void *)p, (unsigned long int)dLen);
    *bytes_read = dLen;
    *type = dt;
    *pml_result = status;
    stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  }

bugout:
  ;
  return stat;
}

// hpmud_get_raw_model
// file io/hpmud/hpmud.c line 428
signed int hpmud_get_raw_model(char *id, char *raw, signed int rawSize)
{
  char *pMd;
  signed int i;
  _Bool tmp_if_expr$1;
  if(id == ((char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)id[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    raw[(signed long int)0] = (char)0;
    pMd=strstr(id, "MDL:");
    if(!(pMd == ((char *)NULL)))
      pMd = pMd + (signed long int)4;

    else
    {
      pMd=strstr(id, "MODEL:");
      if(!(pMd == ((char *)NULL)))
        pMd = pMd + (signed long int)6;

      else
        return 0;
    }
    i = 0;
    for( ; !((signed int)pMd[(signed long int)i] == 59) && !(i >= rawSize); i = i + 1)
      raw[(signed long int)i] = pMd[(signed long int)i];
    raw[(signed long int)i] = (char)0;
    return i;
  }
}

// hpmud_get_uri_datalink
// file io/hpmud/hpmud.c line 478
signed int hpmud_get_uri_datalink(const char *uri, char *buf, signed int buf_size)
{
  char *p;
  signed int i;
  signed int zc = 0;
  char ip[256l];
  _Bool tmp_if_expr$1;
  if(uri == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)uri[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    buf[(signed long int)0] = (char)0;
    p=strcasestr(uri, "device=");
    if(!(p == ((char *)NULL)))
      p = p + (signed long int)7;

    else
    {
      p=strcasestr(uri, "ip=");
      if(!(p == ((char *)NULL)))
        p = p + (signed long int)3;

      else
      {
        p=strcasestr(uri, "hostname=");
        if(!(p == ((char *)NULL)))
          p = p + (signed long int)9;

        else
        {
          p=strcasestr(uri, "zc=");
          if(!(p == ((char *)NULL)))
          {
            p = p + (signed long int)3;
            zc = 1;
          }

          else
            return 0;
        }
      }
    }
    if(!(zc == 0))
    {
      signed int return_value_mdns_lookup$2;
      return_value_mdns_lookup$2=mdns_lookup(p, (unsigned char *)ip);
      if(!(return_value_mdns_lookup$2 == 0))
        return 0;

      i = 0;
      for( ; !((signed int)ip[(signed long int)i] == 0) && !(i >= buf_size); i = i + 1)
        buf[(signed long int)i] = ip[(signed long int)i];
    }

    else
    {
      i = 0;
      do
      {
        if(!((signed int)p[(signed long int)i] == 0))
          tmp_if_expr$3 = (signed int)p[(signed long int)i] != 38 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(i >= buf_size || !tmp_if_expr$3)
          break;

        buf[(signed long int)i] = p[(signed long int)i];
        i = i + 1;
      }
      while((_Bool)1);
    }
    buf[(signed long int)i] = (char)0;
    return i;
  }
}

// hpmud_get_uri_model
// file io/hpmud/hpmud.c line 453
signed int hpmud_get_uri_model(const char *uri, char *buf, signed int buf_size)
{
  char *p;
  signed int i;
  _Bool tmp_if_expr$1;
  if(uri == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)uri[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    buf[(signed long int)0] = (char)0;
    p=strstr(uri, "/");
    if(p == ((char *)NULL))
      return 0;

    else
    {
      p=strstr(p + (signed long int)1, "/");
      if(p == ((char *)NULL))
        return 0;

      else
      {
        p = p + 1l;
        i = 0;
        for( ; !((signed int)p[(signed long int)i] == 63) && !(i >= buf_size); i = i + 1)
          buf[(signed long int)i] = p[(signed long int)i];
        buf[(signed long int)i] = (char)0;
        return i;
      }
    }
  }
}

// hpmud_make_mdns_uri
// file io/hpmud/jd.c line 740
enum HPMUD_RESULT hpmud_make_mdns_uri(const char *host, signed int port, char *uri, signed int uri_size, signed int *bytes_read)
{
  char id[1024l];
  char model[128l];
  char ip[256l];
  enum HPMUD_RESULT stat;
  *bytes_read = 0;
  uri[(signed long int)0] = (char)0;
  _Bool tmp_if_expr$1;
  if(host == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)host[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_mdns_lookup$2;
  signed int return_value_device_id$3;
  signed int return_value_is_hp$4;
  if(tmp_if_expr$1)
  {
    syslog(3, "io/hpmud/jd.c 755: invalid host %s\n", host);
    stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_MDNS;
  }

  else
  {
    return_value_mdns_lookup$2=mdns_lookup(host, (unsigned char *)ip);
    if(!(return_value_mdns_lookup$2 == 0))
    {
      syslog(3, "io/hpmud/jd.c 762: invalid host %s, check firewall UDP/5353 or try using IP\n", host);
      stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_MDNS;
    }

    else
    {
      return_value_device_id$3=device_id(ip, port, id, (signed int)sizeof(char [1024l]) /*1024ul*/ );
      _Bool tmp_if_expr$5;
      if(return_value_device_id$3 >= 1)
      {
        return_value_is_hp$4=is_hp(id);
        tmp_if_expr$5 = return_value_is_hp$4 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
      {
        hpmud_get_model(id, model, (signed int)sizeof(char [128l]) /*128ul*/ );
        if(port == 1)
          *bytes_read=snprintf(uri, (unsigned long int)uri_size, "hp:/net/%s?zc=%s", (const void *)model, host);

        else
          *bytes_read=snprintf(uri, (unsigned long int)uri_size, "hp:/net/%s?zc=%s&port=%d", (const void *)model, host, port);
      }

      else
      {
        syslog(3, "io/hpmud/jd.c 777: invalid host %s, or try using IP\n", host);
        stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_MDNS;
        goto bugout;
      }
      stat = (enum HPMUD_RESULT)HPMUD_R_OK;
    }
  }

bugout:
  ;
  return stat;
}

// hpmud_make_net_uri
// file io/hpmud/jd.c line 700
enum HPMUD_RESULT hpmud_make_net_uri(const char *ip, signed int port, char *uri, signed int uri_size, signed int *bytes_read)
{
  char id[1024l];
  char model[128l];
  enum HPMUD_RESULT stat;
  *bytes_read = 0;
  uri[(signed long int)0] = (char)0;
  _Bool tmp_if_expr$1;
  if(ip == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)ip[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_device_id$2;
  signed int return_value_is_hp$3;
  if(tmp_if_expr$1)
  {
    syslog(3, "io/hpmud/jd.c 714: invalid ip %s\n", ip);
    stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_IP;
  }

  else
  {
    return_value_device_id$2=device_id(ip, port, id, (signed int)sizeof(char [1024l]) /*1024ul*/ );
    _Bool tmp_if_expr$4;
    if(return_value_device_id$2 >= 1)
    {
      return_value_is_hp$3=is_hp(id);
      tmp_if_expr$4 = return_value_is_hp$3 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
    {
      hpmud_get_model(id, model, (signed int)sizeof(char [128l]) /*128ul*/ );
      if(port == 1)
        *bytes_read=snprintf(uri, (unsigned long int)uri_size, "hp:/net/%s?ip=%s", (const void *)model, ip);

      else
        *bytes_read=snprintf(uri, (unsigned long int)uri_size, "hp:/net/%s?ip=%s&port=%d", (const void *)model, ip, port);
    }

    else
    {
      syslog(3, "io/hpmud/jd.c 729: invalid ip %s\n", ip);
      stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_IP;
      goto bugout;
    }
    stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  }

bugout:
  ;
  return stat;
}

// hpmud_make_par_uri
// file io/hpmud/pp.c line 1266
enum HPMUD_RESULT hpmud_make_par_uri(const char *dnode, char *uri, signed int uri_size, signed int *bytes_read)
{
  char model[128l];
  char id[1024l];
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  signed int fd = -1;
  signed int m;
  *bytes_read = 0;
  uri[(signed long int)0] = (char)0;
  fd=open(dnode, 00 | 0400);
  signed int return_value_ioctl$1;
  signed int return_value_claim_pp$2;
  signed int return_value_device_id$4;
  signed int return_value_is_hp$3;
  if(!(fd >= 0))
    syslog(3, "io/hpmud/pp.c 1281: unable to open %s: %m\n", dnode);

  else
  {
    return_value_ioctl$1=ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x97 << 0)) | sizeof(unsigned int) /*4ul*/  << 0 + 8 + 8, &m);
    if(!(return_value_ioctl$1 == 0))
      syslog(3, "io/hpmud/pp.c 1287: unable to make uri %s: %m\n", dnode);

    else
    {
      return_value_claim_pp$2=claim_pp(fd);
      if(!(return_value_claim_pp$2 == 0))
        syslog(3, "io/hpmud/pp.c 1293: unable to make uri %s: %m\n", dnode);

      else
      {
        return_value_device_id$4=device_id$link1(fd, id, (signed int)sizeof(char [1024l]) /*1024ul*/ );
        if(return_value_device_id$4 >= 1)
        {
          return_value_is_hp$3=is_hp(id);
          if(!(return_value_is_hp$3 == 0))
          {
            hpmud_get_model(id, model, (signed int)sizeof(char [128l]) /*128ul*/ );
            *bytes_read=snprintf(uri, (unsigned long int)uri_size, "hp:/par/%s?device=%s", (const void *)model, dnode);
          }

        }

        release_pp(fd);
        stat = (enum HPMUD_RESULT)HPMUD_R_OK;
      }
    }
  }

bugout:
  ;
  if(fd >= 0)
    close(fd);

  return stat;
}

// hpmud_make_usb_serial_uri
// file io/hpmud/musb.c line 2299
enum HPMUD_RESULT hpmud_make_usb_serial_uri(const char *sn, char *uri, signed int uri_size, signed int *bytes_read)
{
  struct libusb_context *ctx = (struct libusb_context *)(void *)0;
  struct libusb_device **list;
  struct libusb_device *dev = (struct libusb_device *)(void *)0;
  struct libusb_device *found_dev = (struct libusb_device *)(void *)0;
  char model[128l];
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_DEVICE_NODE;
  signed int i;
  signed int numdevs;
  signed int return_value_getpid$1;
  return_value_getpid$1=getpid();
  syslog(6, "io/hpmud/musb.c 2309: [%d] hpmud_make_usb_serial_uri() sn=%s\n", return_value_getpid$1, sn);
  *bytes_read = 0;
  i=libusb_init(&ctx);
  signed long int return_value_libusb_get_device_list$2;
  if(i == 0)
  {
    return_value_libusb_get_device_list$2=libusb_get_device_list(ctx, &list);
    numdevs = (signed int)return_value_libusb_get_device_list$2;
    if(numdevs >= 1)
    {
      i = 0;
      for( ; !(i >= numdevs); i = i + 1)
      {
        dev = list[(signed long int)i];
        signed int return_value_is_serial$3;
        return_value_is_serial$3=is_serial(dev, sn, model, (signed int)sizeof(char [128l]) /*128ul*/ );
        if(!(return_value_is_serial$3 == 0))
        {
          found_dev = dev;
          break;
        }

      }
      if(found_dev == ((struct libusb_device *)NULL))
        syslog(3, "io/hpmud/musb.c 2332: invalid sn %s\n", sn);

      else
      {
        *bytes_read=snprintf(uri, (unsigned long int)uri_size, "hp:/usb/%s?serial=%s", (const void *)model, sn);
        stat = (enum HPMUD_RESULT)HPMUD_R_OK;
      }
    }

  }


bugout:
  ;
  if(!(list == ((struct libusb_device **)NULL)))
    libusb_free_device_list(list, 1);

  if(!(ctx == ((struct libusb_context *)NULL)))
    libusb_exit(ctx);

  return stat;
}

// hpmud_make_usb_uri
// file io/hpmud/musb.c line 2166
enum HPMUD_RESULT hpmud_make_usb_uri(const char *busnum, const char *devnum, char *uri, signed int uri_size, signed int *bytes_read)
{
  struct libusb_context *ctx = (struct libusb_context *)(void *)0;
  struct libusb_device **list;
  struct libusb_device *dev = (struct libusb_device *)(void *)0;
  struct libusb_device *found_dev = (struct libusb_device *)(void *)0;
  struct libusb_device_handle *hd = (struct libusb_device_handle *)(void *)0;
  struct libusb_device_descriptor devdesc;
  struct libusb_config_descriptor *confptr = (struct libusb_config_descriptor *)(void *)0;
  struct libusb_interface *ifaceptr = (struct libusb_interface *)(void *)0;
  struct libusb_interface_descriptor *altptr = (struct libusb_interface_descriptor *)(void *)0;
  char model[128l];
  char serial[128l];
  char sz[256l];
  signed int r;
  signed int numdevs;
  signed int i;
  signed int conf;
  signed int iface;
  signed int altset;
  signed int bus_num;
  signed int dev_num;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_DEVICE_NODE;
  signed int isSmartInstall_enabled = 0;
  signed int isPrinter = 0;
  signed int return_value_getpid$1;
  return_value_getpid$1=getpid();
  syslog(6, "io/hpmud/musb.c 2183: [%d] hpmud_make_usb_uri() bus=%s dev=%s\n", return_value_getpid$1, busnum, devnum);
  *bytes_read = 0;
  i=libusb_init(&ctx);
  signed long int return_value_libusb_get_device_list$2;
  if(i == 0)
  {
    return_value_libusb_get_device_list$2=libusb_get_device_list(ctx, &list);
    numdevs = (signed int)return_value_libusb_get_device_list$2;
    if(numdevs >= 1)
    {
      i = 0;
      for( ; !(i >= numdevs); i = i + 1)
      {
        dev = list[(signed long int)i];
        unsigned char return_value_libusb_get_bus_number$3;
        return_value_libusb_get_bus_number$3=libusb_get_bus_number(dev);
        bus_num = (signed int)return_value_libusb_get_bus_number$3;
        signed int return_value_atoi$4;
        return_value_atoi$4=atoi(busnum);
        if(bus_num == return_value_atoi$4)
        {
          unsigned char return_value_libusb_get_device_address$5;
          return_value_libusb_get_device_address$5=libusb_get_device_address(dev);
          dev_num = (signed int)return_value_libusb_get_device_address$5;
          signed int return_value_atoi$6;
          return_value_atoi$6=atoi(devnum);
          if(dev_num == return_value_atoi$6)
            found_dev = dev;

        }

      }
      if(found_dev == ((struct libusb_device *)NULL))
        syslog(3, "io/hpmud/musb.c 2210: invalid busnum:devnum %s:%s\n", busnum, devnum);

      else
      {
        dev = found_dev;
        libusb_open(dev, &hd);
        if(hd == ((struct libusb_device_handle *)NULL))
          syslog(3, "io/hpmud/musb.c 2219: invalid libusb_open: %m\n");

        else
        {
          sz[(signed long int)0] = (char)0;
          serial[(signed long int)0] = sz[(signed long int)0];
          model[(signed long int)0] = serial[(signed long int)0];
          libusb_get_device_descriptor(dev, &devdesc);
          if((signed int)devdesc.idVendor == 0x3f0)
          {
            r=get_string_descriptor(hd, (signed int)devdesc.iProduct, sz, sizeof(char [256l]) /*256ul*/ );
            if(!(r >= 0))
              syslog(3, "io/hpmud/musb.c 2231: invalid product id string ret=%d\n", r);

            else
              generalize_model(sz, model, (signed int)sizeof(char [128l]) /*128ul*/ );
            r=get_string_descriptor(hd, (signed int)devdesc.iSerialNumber, sz, sizeof(char [256l]) /*256ul*/ );
            if(!(r >= 0))
              syslog(3, "io/hpmud/musb.c 2236: invalid serial id string ret=%d\n", r);

            else
              generalize_serial(sz, serial, (signed int)sizeof(char [128l]) /*128ul*/ );
            if(serial[0l] == 0)
              strcpy(serial, "0");

            conf = 0;
            for( ; !(conf >= (signed int)devdesc.bNumConfigurations); conf = conf + 1)
            {
              signed int return_value_libusb_get_config_descriptor$7;
              return_value_libusb_get_config_descriptor$7=libusb_get_config_descriptor(dev, (unsigned char)conf, &confptr);
              if(return_value_libusb_get_config_descriptor$7 >= 0)
              {
                iface = 0;
                ifaceptr = confptr->interface;
                for( ; !(iface >= (signed int)confptr->bNumInterfaces); ifaceptr = ifaceptr + 1l)
                {
                  altset = 0;
                  altptr = ifaceptr->altsetting;
                  for( ; !(altset >= ifaceptr->num_altsetting); altptr = altptr + 1l)
                  {
                    _Bool tmp_if_expr$8;
                    if((signed int)confptr->bNumInterfaces == 1)
                      tmp_if_expr$8 = (signed int)altptr->bInterfaceClass == 8 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$8 = (_Bool)0;
                    if(tmp_if_expr$8)
                    {
                      strcpy(serial, "SMART_INSTALL_ENABLED");
                      isSmartInstall_enabled = 1;
                      break;
                    }

                    else
                      if((signed int)altptr->bInterfaceClass == 7)
                      {
                        isPrinter = 1;
                        break;
                      }

                    altset = altset + 1;
                  }
                  iface = iface + 1;
                }
                libusb_free_config_descriptor(confptr);
                confptr = (struct libusb_config_descriptor *)(void *)0;
              }

            }
          }

          else
          {
            syslog(3, "io/hpmud/musb.c 2271: invalid vendor id: %d\n", devdesc.idVendor);
            goto bugout;
          }
          _Bool tmp_if_expr$9;
          if(model[0l] == 0)
            tmp_if_expr$9 = (_Bool)1;

          else
            tmp_if_expr$9 = !(serial[(signed long int)0] != 0) ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr$9)
          {
            if(isPrinter == 1 || isSmartInstall_enabled == 1)
            {
              *bytes_read=snprintf(uri, (unsigned long int)uri_size, "hp:/usb/%s?serial=%s", (const void *)model, (const void *)serial);
              syslog(6, "io/hpmud/musb.c 2281: hpmud_make_usb_uri() uri=%s bytes_read=%d\n", uri, *bytes_read);
              stat = (enum HPMUD_RESULT)HPMUD_R_OK;
            }

            else
              syslog(6, "io/hpmud/musb.c 2285: hpmud_make_usb_uri() Invalid Device =%s\n", (const void *)model);
          }

        }
      }
    }

  }


bugout:
  ;
  if(!(hd == ((struct libusb_device_handle *)NULL)))
    libusb_close(hd);

  if(!(list == ((struct libusb_device **)NULL)))
    libusb_free_device_list(list, 1);

  if(!(ctx == ((struct libusb_context *)NULL)))
    libusb_exit(ctx);

  return stat;
}

// hpmud_open_channel
// file io/hpmud/hpmud.h line 277
enum HPMUD_RESULT hpmud_open_channel(signed int dd, const char *channel_name, signed int *cd)
{
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_STATE;
  _Bool tmp_if_expr$1;
  if(dd >= 3 || !(dd >= 1))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = msp->device[(signed long int)dd].index != dd ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    syslog(3, "io/hpmud/hpmud.c 683: invalid channel_open state\n");

  else
    stat=msp->device[(signed long int)dd].vf.channel_open(&msp->device[(signed long int)dd], channel_name, cd);

bugout:
  ;
  return stat;
}

// hpmud_open_device
// file io/hpmud/hpmud.h line 193
enum HPMUD_RESULT hpmud_open_device(const char *uri, enum HPMUD_IO_MODE iomode, signed int *dd)
{
  signed int index = 0;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_URI;
  signed int result;
  index=new_device(uri, iomode, &result);
  if(index == 0)
  {
    stat = (enum HPMUD_RESULT)result;
    goto bugout;
  }

  else
  {
    stat=msp->device[(signed long int)index].vf.open(&msp->device[(signed long int)index]);
    if(!((signed int)stat == HPMUD_R_OK))
    {
      msp->device[(signed long int)index].vf.close(&msp->device[(signed long int)index]);
      del_device(index);
    }

  }
  *dd = index;
  stat = (enum HPMUD_RESULT)HPMUD_R_OK;

bugout:
  ;
  return stat;
}

// hpmud_probe_devices
// file io/hpmud/hpmud.c line 616
enum HPMUD_RESULT hpmud_probe_devices(enum HPMUD_BUS_ID bus, char *buf, signed int buf_size, signed int *cnt, signed int *bytes_read)
{
  signed int len = 0;
  if(buf == ((char *)NULL) || !(buf_size >= 1))
    return (enum HPMUD_RESULT)HPMUD_R_INVALID_LENGTH;

  else
  {
    buf[(signed long int)0] = (char)0;
    *cnt = 0;
    if((signed int)bus == HPMUD_BUS_USB)
      len=musb_probe_devices(buf, buf_size, cnt, (enum HPMUD_DEVICE_TYPE)HPMUD_AIO);

    else
      if((signed int)bus == HPMUD_BUS_PARALLEL)
        len=pp_probe_devices(buf, buf_size, cnt);

      else
        if((signed int)bus == HPMUD_BUS_ALL)
        {
          len=musb_probe_devices(buf, buf_size, cnt, (enum HPMUD_DEVICE_TYPE)HPMUD_AIO);
          signed int return_value_pp_probe_devices$1;
          return_value_pp_probe_devices$1=pp_probe_devices(buf + (signed long int)len, buf_size - len, cnt);
          len = len + return_value_pp_probe_devices$1;
        }

    *bytes_read = len;
    return (enum HPMUD_RESULT)HPMUD_R_OK;
  }
}

// hpmud_probe_printers
// file io/hpmud/hpmud.h line 262
enum HPMUD_RESULT hpmud_probe_printers(enum HPMUD_BUS_ID bus, char *buf, signed int buf_size, signed int *cnt, signed int *bytes_read)
{
  signed int len = 0;
  if(buf == ((char *)NULL) || !(buf_size >= 1))
    return (enum HPMUD_RESULT)HPMUD_R_INVALID_LENGTH;

  else
  {
    buf[(signed long int)0] = (char)0;
    *cnt = 0;
    if((signed int)bus == HPMUD_BUS_ALL)
    {
      len=musb_probe_devices(buf, buf_size, cnt, (enum HPMUD_DEVICE_TYPE)HPMUD_PRINTER);
      signed int return_value_pp_probe_devices$1;
      return_value_pp_probe_devices$1=pp_probe_devices(buf + (signed long int)len, buf_size - len, cnt);
      len = len + return_value_pp_probe_devices$1;
    }

    *bytes_read = len;
    return (enum HPMUD_RESULT)HPMUD_R_OK;
  }
}

// hpmud_query_model
// file io/hpmud/hpmud.h line 471
enum HPMUD_RESULT hpmud_query_model(char *uri, struct hpmud_model_attributes *ma)
{
  char buf[4096l];
  signed int len;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_DATFILE_ERROR;
  parse_key_value_pair((char *)(void *)0, 0, ma);
  enum HPMUD_RESULT return_value_hpmud_get_model_attributes$1;
  return_value_hpmud_get_model_attributes$1=hpmud_get_model_attributes(uri, buf, (signed int)sizeof(char [4096l]) /*4096ul*/ , &len);
  if((signed int)return_value_hpmud_get_model_attributes$1 == 0)
  {
    parse_key_value_pair(buf, len, ma);
    stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  }


bugout:
  ;
  return stat;
}

// hpmud_read_channel
// file io/hpmud/hpmud.h line 325
enum HPMUD_RESULT hpmud_read_channel(signed int dd, signed int cd, void *buf, signed int size, signed int sec_timeout, signed int *bytes_read)
{
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_STATE;
  _Bool tmp_if_expr$1;
  if(dd >= 3 || !(dd >= 1))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = msp->device[(signed long int)dd].index != dd ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(cd >= 48 || !(cd >= 1) || tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = msp->device[(signed long int)dd].channel[(signed long int)cd].client_cnt == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    syslog(3, "io/hpmud/hpmud.c 739: invalid channel_read state\n");

  else
    stat=msp->device[(signed long int)dd].vf.channel_read(&msp->device[(signed long int)dd], &msp->device[(signed long int)dd].channel[(signed long int)cd], buf, size, sec_timeout, bytes_read);

bugout:
  ;
  return stat;
}

// hpmud_set_pml
// file io/hpmud/pml.c line 316
enum HPMUD_RESULT hpmud_set_pml(signed int device, signed int channel, const char *snmp_oid, signed int type, void *data, signed int data_size, signed int *pml_result)
{
  unsigned char message[16384l];
  unsigned char oid[256l];
  char ip[256l];
  char *psz;
  char *tail;
  unsigned char *p = message;
  signed int len;
  signed int dLen;
  signed int result;
  signed int reply;
  signed int status;
  signed int port;
  struct hpmud_dstat ds;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  enum HPMUD_RESULT return_value_hpmud_get_dstat$1;
  return_value_hpmud_get_dstat$1=hpmud_get_dstat(device, &ds);
  result = (signed int)return_value_hpmud_get_dstat$1;
  char *return_value_strcasestr$10;
  signed long int return_value_strtol$2;
  if(!(result == HPMUD_R_OK))
    stat = (enum HPMUD_RESULT)result;

  else
  {
    return_value_strcasestr$10=strcasestr(ds.uri, "net/");
    if(!(return_value_strcasestr$10 == ((char *)NULL)))
    {
      hpmud_get_uri_datalink(ds.uri, ip, (signed int)sizeof(char [256l]) /*256ul*/ );
      psz=strstr(ds.uri, "port=");
      if(!(psz == ((char *)NULL)))
      {
        return_value_strtol$2=strtol(psz + (signed long int)5, &tail, 10);
        port = (signed int)return_value_strtol$2;
      }

      else
        port = 1;
      SetSnmp(ip, port, snmp_oid, type, data, (unsigned int)data_size, &status, &result);
      if(!(result == HPMUD_R_OK))
      {
        syslog(3, "io/hpmud/pml.c 348: SetPml failed ret=%d\n", result);
        stat = (enum HPMUD_RESULT)result;
        goto bugout;
      }

    }

    else
    {
      dLen=SnmpToPml(snmp_oid, oid, (signed int)sizeof(unsigned char [256l]) /*256ul*/ );
      unsigned char *tmp_post$3 = p;
      p = p + 1l;
      *tmp_post$3 = (unsigned char)4;
      unsigned char *tmp_post$4 = p;
      p = p + 1l;
      *tmp_post$4 = (unsigned char)0;
      unsigned char *tmp_post$5 = p;
      p = p + 1l;
      *tmp_post$5 = (unsigned char)dLen;
      memcpy((void *)p, (const void *)oid, (unsigned long int)dLen);
      p = p + (signed long int)dLen;
      *p = (unsigned char)type;
      *p = *p | (unsigned char)(data_size >> 8);
      p[(signed long int)1] = (unsigned char)(data_size & 0xff);
      p = p + (signed long int)2;
      memcpy((void *)p, data, (unsigned long int)data_size);
      enum HPMUD_RESULT return_value_hpmud_write_channel$6;
      return_value_hpmud_write_channel$6=hpmud_write_channel(device, channel, (const void *)message, dLen + data_size + 3 + 2, 45, &len);
      result = (signed int)return_value_hpmud_write_channel$6;
      if(!(result == HPMUD_R_OK))
      {
        syslog(3, "io/hpmud/pml.c 374: SetPml channel_write failed ret=%d\n", result);
        stat = (enum HPMUD_RESULT)result;
        goto bugout;
      }

      enum HPMUD_RESULT return_value_hpmud_read_channel$7;
      return_value_hpmud_read_channel$7=hpmud_read_channel(device, channel, (void *)message, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ , 45, &len);
      result = (signed int)return_value_hpmud_read_channel$7;
      if(len == 0 || !(result == HPMUD_R_OK))
      {
        syslog(3, "io/hpmud/pml.c 382: SetPml channel_read failed ret=%d len=%d\n", result, len);
        goto bugout;
      }

      p = message;
      unsigned char *tmp_post$8 = p;
      p = p + 1l;
      reply = (signed int)*tmp_post$8;
      unsigned char *tmp_post$9 = p;
      p = p + 1l;
      status = (signed int)*tmp_post$9;
      if(!((0x80 & status) == 0) && !(reply == 132))
      {
        syslog(3, "io/hpmud/pml.c 392: SetPml failed reply=%x outcome=%x\n", reply, status);
        goto bugout;
      }

    }
    *pml_result = status;
    stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  }

bugout:
  ;
  return stat;
}

// hpmud_write_channel
// file io/hpmud/hpmud.h line 307
enum HPMUD_RESULT hpmud_write_channel(signed int dd, signed int cd, const void *buf, signed int size, signed int sec_timeout, signed int *bytes_wrote)
{
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_STATE;
  _Bool tmp_if_expr$1;
  if(dd >= 3 || !(dd >= 1))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = msp->device[(signed long int)dd].index != dd ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(cd >= 48 || !(cd >= 1) || tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = msp->device[(signed long int)dd].channel[(signed long int)cd].client_cnt == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    syslog(3, "io/hpmud/hpmud.c 721: invalid channel_write state\n");

  else
    stat=msp->device[(signed long int)dd].vf.channel_write(&msp->device[(signed long int)dd], &msp->device[(signed long int)dd].channel[(signed long int)cd], buf, size, sec_timeout, bytes_wrote);

bugout:
  ;
  return stat;
}

// init_dbus
// file prnt/backend/hp.c line 557
signed int init_dbus(void)
{
  dbus_error_init(&dbus_err);
  dbus_conn=dbus_bus_get((enum anonymous$34)DBUS_BUS_SYSTEM, &dbus_err);
  unsigned int return_value_dbus_error_is_set$1;
  return_value_dbus_error_is_set$1=dbus_error_is_set(&dbus_err);
  if(!(return_value_dbus_error_is_set$1 == 0u))
  {
    bug("prnt/backend/hp.c 564: dBus Connection Error (%s)!\n", dbus_err.message);
    dbus_error_free(&dbus_err);
  }

  if(dbus_conn == ((struct DBusConnection *)NULL))
    return 0;

  else
    return 1;
}

// is_hp
// file io/hpmud/hpmud.c line 86
signed int is_hp(const char *id)
{
  char *pMf;
  _Bool tmp_if_expr$1;
  if(id == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)id[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_strncasecmp$3;
  signed int return_value_strncasecmp$5;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    pMf=strstr(id, "MFG:");
    if(!(pMf == ((char *)NULL)))
      pMf = pMf + (signed long int)4;

    else
    {
      pMf=strstr(id, "MANUFACTURER:");
      if(!(pMf == ((char *)NULL)))
        pMf = pMf + (signed long int)13;

      else
        return 0;
    }
    signed int return_value_strncasecmp$2;
    return_value_strncasecmp$2=strncasecmp(pMf, "HEWLETT-PACKARD", (unsigned long int)15);
    _Bool tmp_if_expr$4;
    if(return_value_strncasecmp$2 == 0)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_strncasecmp$3=strncasecmp(pMf, "APOLLO", (unsigned long int)6);
      tmp_if_expr$4 = return_value_strncasecmp$3 == 0 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$6;
    if(tmp_if_expr$4)
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      return_value_strncasecmp$5=strncasecmp(pMf, "HP", (unsigned long int)2);
      tmp_if_expr$6 = return_value_strncasecmp$5 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
      return 1;

    else
      return 0;
  }
}

// is_serial
// file io/hpmud/musb.c line 640
static signed int is_serial(struct libusb_device *dev, const char *sn, char *model, signed int model_size)
{
  struct libusb_device_handle *hd = (struct libusb_device_handle *)(void *)0;
  struct libusb_device_descriptor devdesc;
  char sz[128l];
  char gen[128l];
  signed int r;
  signed int stat = 0;
  libusb_open(dev, &hd);
  signed int return_value_strncmp$1;
  if(hd == ((struct libusb_device_handle *)NULL))
    syslog(3, "io/hpmud/musb.c 651: invalid usb_open: %m\n");

  else
  {
    libusb_get_device_descriptor(dev, &devdesc);
    if((signed int)devdesc.idVendor == 0x3f0)
    {
      r=get_string_descriptor(hd, (signed int)devdesc.iSerialNumber, sz, sizeof(char [128l]) /*128ul*/ );
      if(!(r >= 0))
        syslog(3, "io/hpmud/musb.c 661: invalid serial id string ret=%d\n", r);

      else
      {
        if(!(sz[0l] == 0))
          generalize_serial(sz, gen, (signed int)sizeof(char [128l]) /*128ul*/ );

        else
          strcpy(gen, "0");
        return_value_strncmp$1=strncmp(sn, gen, sizeof(char [128l]) /*128ul*/ );
        if(return_value_strncmp$1 == 0)
        {
          r=get_string_descriptor(hd, (signed int)devdesc.iProduct, sz, sizeof(char [128l]) /*128ul*/ );
          if(!(r >= 0))
            syslog(3, "io/hpmud/musb.c 674: invalid product id string ret=%d\n", r);

          else
          {
            generalize_model(sz, model, model_size);
            stat = 1;
          }
        }

      }
    }

  }

bugout:
  ;
  if(!(hd == ((struct libusb_device_handle *)NULL)))
    libusb_close(hd);

  return stat;
}

// is_uri
// file io/hpmud/musb.c line 585
static signed int is_uri(struct libusb_device *dev, const char *uri)
{
  struct libusb_device_handle *hd = (struct libusb_device_handle *)(void *)0;
  struct libusb_device_descriptor devdesc;
  char sz[128l];
  char uriModel[128l];
  char uriSerial[128l];
  char gen[128l];
  signed int r;
  signed int stat = 0;
  libusb_open(dev, &hd);
  signed int return_value_strcasecmp$1;
  signed int return_value_strcmp$2;
  if(hd == ((struct libusb_device_handle *)NULL))
    syslog(3, "io/hpmud/musb.c 595: invalid usb_open: %m\n");

  else
  {
    libusb_get_device_descriptor(dev, &devdesc);
    if((signed int)devdesc.idVendor == 0x3f0)
    {
      r=get_string_descriptor(hd, (signed int)devdesc.iProduct, sz, sizeof(char [128l]) /*128ul*/ );
      if(!(r >= 0))
        syslog(3, "io/hpmud/musb.c 605: invalid product id string ret=%d\n", r);

      else
      {
        generalize_model(sz, gen, (signed int)sizeof(char [128l]) /*128ul*/ );
        hpmud_get_uri_model(uri, uriModel, (signed int)sizeof(char [128l]) /*128ul*/ );
        return_value_strcasecmp$1=strcasecmp(uriModel, gen);
        if(return_value_strcasecmp$1 == 0)
        {
          r=get_string_descriptor(hd, (signed int)devdesc.iSerialNumber, sz, sizeof(char [128l]) /*128ul*/ );
          if(!(r >= 0))
            syslog(3, "io/hpmud/musb.c 617: invalid serial id string ret=%d\n", r);

          else
          {
            if(!(sz[0l] == 0))
              generalize_serial(sz, gen, (signed int)sizeof(char [128l]) /*128ul*/ );

            else
              strcpy(gen, "0");
            get_uri_serial(uri, uriSerial, (signed int)sizeof(char [128l]) /*128ul*/ );
            return_value_strcmp$2=strcmp(uriSerial, gen);
            if(return_value_strcmp$2 == 0)
              stat = 1;

          }
        }

      }
    }

  }

bugout:
  ;
  if(!(hd == ((struct libusb_device_handle *)NULL)))
    libusb_close(hd);

  return stat;
}

// jd_channel_close
// file io/hpmud/jd.c line 319
enum HPMUD_RESULT jd_channel_close(struct _mud_device *pd, struct _mud_channel *pc)
{
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  pthread_mutex_lock(&pd->mutex);
  stat=pc->vf.close(pc);
  del_channel(pd, pc);
  pthread_mutex_unlock(&pd->mutex);
  return stat;
}

// jd_channel_open
// file io/hpmud/jd.c line 290
enum HPMUD_RESULT jd_channel_open(struct _mud_device *pd, const char *sn, signed int *cd)
{
  signed int index;
  enum HPMUD_RESULT stat;
  stat=service_to_channel(pd, sn, &index);
  signed int return_value_new_channel$1;
  if((signed int)stat == HPMUD_R_OK)
  {
    pthread_mutex_lock(&pd->mutex);
    return_value_new_channel$1=new_channel(pd, index, sn);
    if(!(return_value_new_channel$1 == 0))
      stat = (enum HPMUD_RESULT)HPMUD_R_DEVICE_BUSY;

    else
    {
      stat=pd->channel[(signed long int)index].vf.open(&pd->channel[(signed long int)index]);
      if(!((signed int)stat == HPMUD_R_OK))
        del_channel(pd, &pd->channel[(signed long int)index]);

      else
        *cd = index;
    }
    pthread_mutex_unlock(&pd->mutex);
  }


bugout:
  ;
  return stat;
}

// jd_channel_read
// file io/hpmud/jd.c line 274
enum HPMUD_RESULT jd_channel_read(struct _mud_device *pd, struct _mud_channel *pc, void *buf, signed int length, signed int sec_timeout, signed int *bytes_read)
{
  enum HPMUD_RESULT stat;
  if((signed int)pd->io_mode == HPMUD_UNI_MODE)
  {
    stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_STATE;
    syslog(3, "io/hpmud/jd.c 281: invalid channel_read io_mode=%d\n", pd->io_mode);
  }

  pthread_mutex_lock(&pd->mutex);
  stat=pc->vf.channel_read(pc, buf, length, sec_timeout, bytes_read);
  pthread_mutex_unlock(&pd->mutex);
  return stat;
}

// jd_channel_write
// file io/hpmud/jd.c line 264
enum HPMUD_RESULT jd_channel_write(struct _mud_device *pd, struct _mud_channel *pc, const void *buf, signed int length, signed int sec_timeout, signed int *bytes_wrote)
{
  enum HPMUD_RESULT stat;
  pthread_mutex_lock(&pd->mutex);
  stat=pc->vf.channel_write(pc, buf, length, sec_timeout, bytes_wrote);
  pthread_mutex_unlock(&pd->mutex);
  return stat;
}

// jd_close
// file io/hpmud/jd.c line 227
enum HPMUD_RESULT jd_close(struct _mud_device *pd)
{
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  pthread_mutex_lock(&pd->mutex);
  pd->id[(signed long int)0] = (char)0;
  pthread_mutex_unlock(&pd->mutex);
  return stat;
}

// jd_get_device_id
// file io/hpmud/jd.c line 238
enum HPMUD_RESULT jd_get_device_id(struct _mud_device *pd, char *buf, signed int size, signed int *len)
{
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  *len = 0;
  pthread_mutex_lock(&pd->mutex);
  *len=device_id(pd->ip, pd->port, pd->id, (signed int)sizeof(char [1024l]) /*1024ul*/ );
  if(!(*len == 0))
  {
    signed int tmp_if_expr$1;
    if(!(size >= *len))
      tmp_if_expr$1 = size;

    else
      tmp_if_expr$1 = *len;
    memcpy((void *)buf, (const void *)pd->id, (unsigned long int)tmp_if_expr$1);
    stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  }

  pthread_mutex_unlock(&pd->mutex);
  return stat;
}

// jd_get_device_status
// file io/hpmud/jd.c line 258
enum HPMUD_RESULT jd_get_device_status(struct _mud_device *pd, unsigned int *status)
{
  *status = (unsigned int)0x08;
  return (enum HPMUD_RESULT)HPMUD_R_OK;
}

// jd_open
// file io/hpmud/jd.c line 156
enum HPMUD_RESULT jd_open(struct _mud_device *pd)
{
  char uri_model[128l];
  char model[128l];
  char *p;
  char *tail;
  signed int len = 0;
  signed int printqueue = 0;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  pthread_mutex_lock(&pd->mutex);
  char *return_value_strstr$1;
  return_value_strstr$1=strstr(pd->uri, "queue=false");
  printqueue = return_value_strstr$1 != ((char *)NULL) ? 0 : 1;
  char *return_value_strstr$2;
  return_value_strstr$2=strstr(pd->uri, "scanjet");
  if(!(return_value_strstr$2 == ((char *)NULL)))
    printqueue = 0;

  if((signed int)pd->id[0l] == 0)
  {
    hpmud_get_uri_datalink(pd->uri, pd->ip, (signed int)sizeof(char [256l]) /*256ul*/ );
    p=strcasestr(pd->uri, "port=");
    if(!(p == ((char *)NULL)))
      pd->port=strtol(p + (signed long int)5, &tail, 10);

    else
      pd->port = 1;
    if(pd->port >= 5)
    {
      stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_IP_PORT;
      syslog(3, "io/hpmud/jd.c 191: invalid ip port=%d\n", pd->port);
      goto blackout;
    }

    if(printqueue == 0)
      goto __CPROVER_DUMP_L5;

    len=device_id(pd->ip, pd->port, pd->id, (signed int)sizeof(char [1024l]) /*1024ul*/ );
    if(!(len == 0))
      goto __CPROVER_DUMP_L5;

    stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  }

  else
  {

  __CPROVER_DUMP_L5:
    ;
    if(!(printqueue == 0))
    {
      hpmud_get_uri_model(pd->uri, uri_model, (signed int)sizeof(char [128l]) /*128ul*/ );
      hpmud_get_model(pd->id, model, (signed int)sizeof(char [128l]) /*128ul*/ );
      signed int return_value_strcasecmp$3;
      return_value_strcasecmp$3=strcasecmp(uri_model, model);
      if(!(return_value_strcasecmp$3 == 0))
      {
        stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_URI;
        syslog(3, "io/hpmud/jd.c 214: invalid uri model %s != %s\n", (const void *)uri_model, (const void *)model);
        goto blackout;
      }

    }

    stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  }

blackout:
  ;
  pthread_mutex_unlock(&pd->mutex);
  return stat;
}

// jd_s_channel_close
// file io/hpmud/jd.c line 567
enum HPMUD_RESULT jd_s_channel_close(struct _mud_channel *pc)
{
  if(pc->socket >= 0)
  {
    close(pc->socket);
    usleep((unsigned int)100000);
  }

  pc->socket = -1;
  return (enum HPMUD_RESULT)HPMUD_R_OK;
}

// jd_s_channel_open
// file io/hpmud/jd.c line 335
enum HPMUD_RESULT jd_s_channel_open(struct _mud_channel *pc)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  struct sockaddr_in pin;
  struct sockaddr_in tmp_pin;
  struct hostent *he;
  char buf[256l];
  signed int r;
  signed int len;
  signed int port;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  bzero((void *)&tmp_pin, sizeof(struct sockaddr_in) /*16ul*/ );
  bzero((void *)&pin, sizeof(struct sockaddr_in) /*16ul*/ );
  pin.sin_family = (unsigned short int)2;
  signed int return_value_inet_pton$1;
  return_value_inet_pton$1=inet_pton(2, pd->ip, (void *)&tmp_pin.sin_addr);
  if(!(return_value_inet_pton$1 == 0))
    pin.sin_addr.s_addr=inet_addr(pd->ip);

  else
  {
    he=gethostbyname(pd->ip);
    if(he == ((struct hostent *)NULL))
    {
      syslog(3, "io/hpmud/jd.c 354: gethostbyname() returned NULL\n");
      goto bugout;
    }

    pin.sin_addr = *((struct in_addr *)he->h_addr_list[(signed long int)0]);
  }
  signed int return_value_connect$2;
  signed int return_value_connect$4;
  signed int return_value_connect$5;
  signed int return_value_connect$6;
  signed int return_value_connect$7;
  signed int return_value_connect$8;
  signed int return_value_connect$9;
  signed int return_value_connect$10;
  signed int return_value_connect$11;
  signed int return_value_connect$12;
  switch(pc->index)
  {
    case 2:
    {
      port = PrintPort[(signed long int)pd->port];
      pin.sin_port=htons((unsigned short int)port);
      pc->socket=socket(2, 1, 0);
      if(pc->socket == -1)
      {
        syslog(3, "io/hpmud/jd.c 368: unable to open print port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      return_value_connect$2=connect(pc->socket, (struct sockaddr *)&pin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(return_value_connect$2 == -1)
      {
        syslog(3, "io/hpmud/jd.c 373: unable to connect to print port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      break;
    }
    case 4:
    {
      if((signed int)pd->io_mode == HPMUD_DOT4_PHOENIX_MODE)
        port = ScanPort1[(signed long int)pd->port];

      else
        port = ScanPort0[(signed long int)pd->port];
      pin.sin_port=htons((unsigned short int)port);
      pc->socket=socket(2, 1, 0);
      if(pc->socket == -1)
      {
        syslog(3, "io/hpmud/jd.c 386: unable to open scan port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      return_value_connect$4=connect(pc->socket, (struct sockaddr *)&pin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(return_value_connect$4 == -1)
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        syslog(3, "io/hpmud/jd.c 391: unable to connect to scan err=%d port %d: %m %s\n", *return_value___errno_location$3, port, (const void *)pd->uri);
        goto bugout;
      }

      if(!((signed int)pd->io_mode == HPMUD_DOT4_PHOENIX_MODE))
      {
        r=ReadReply(pc);
        if(!(r == 0))
        {
          syslog(3, "io/hpmud/jd.c 399: invalid scan response %d port %d %s\n", r, port, (const void *)pd->uri);
          goto bugout;
        }

      }

      break;
    }
    case 17:

    case 7:

    case 14:

    case 15:
    {
      if((signed int)pd->io_mode == HPMUD_DOT4_PHOENIX_MODE)
        port = GenericPort1[(signed long int)pd->port];

      else
        port = GenericPort[(signed long int)pd->port];
      pin.sin_port=htons((unsigned short int)port);
      pc->socket=socket(2, 1, 0);
      if(pc->socket == -1)
      {
        syslog(3, "io/hpmud/jd.c 415: unable to open port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      return_value_connect$5=connect(pc->socket, (struct sockaddr *)&pin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(return_value_connect$5 == -1)
      {
        syslog(3, "io/hpmud/jd.c 420: unable to connect to port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      if(!((signed int)pd->io_mode == HPMUD_DOT4_PHOENIX_MODE))
      {
        r=ReadReply(pc);
        if(!(r == 220))
        {
          syslog(3, "io/hpmud/jd.c 429: invalid response %d port %d %s\n", r, port, (const void *)pd->uri);
          goto bugout;
        }

        len=sprintf(buf, "open %d\n", pc->index);
        send(pc->socket, (const void *)buf, (unsigned long int)len, 0);
        r=ReadReply(pc);
        if(!(r == 200))
        {
          syslog(3, "io/hpmud/jd.c 437: invalid response %d port %d %s\n", r, port, (const void *)pd->uri);
          goto bugout;
        }

        len=sprintf(buf, "data\n");
        send(pc->socket, (const void *)"data\n", (unsigned long int)len, 0);
        r=ReadReply(pc);
        if(!(r == 200))
        {
          syslog(3, "io/hpmud/jd.c 445: invalid response %d port %d %s\n", r, port, (const void *)pd->uri);
          goto bugout;
        }

      }

      break;
    }
    case 18:
    {
      port = 80;
      pin.sin_port=htons((unsigned short int)port);
      pc->socket=socket(2, 1, 0);
      if(pc->socket == -1)
      {
        syslog(3, "io/hpmud/jd.c 456: unable to open ews port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      return_value_connect$6=connect(pc->socket, (struct sockaddr *)&pin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(return_value_connect$6 == -1)
      {
        syslog(3, "io/hpmud/jd.c 461: unable to connect to ews port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      break;
    }
    case 19:
    {
      port = 8289;
      pin.sin_port=htons((unsigned short int)port);
      pc->socket=socket(2, 1, 0);
      if(pc->socket == -1)
      {
        syslog(3, "io/hpmud/jd.c 470: unable to open soap-scan port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      return_value_connect$7=connect(pc->socket, (struct sockaddr *)&pin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(return_value_connect$7 == -1)
      {
        syslog(3, "io/hpmud/jd.c 475: unable to connect to soap-scan port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      break;
    }
    case 20:
    {
      port = 8295;
      pin.sin_port=htons((unsigned short int)port);
      pc->socket=socket(2, 1, 0);
      if(pc->socket == -1)
      {
        syslog(3, "io/hpmud/jd.c 484: unable to open soap-fax port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      return_value_connect$8=connect(pc->socket, (struct sockaddr *)&pin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(return_value_connect$8 == -1)
      {
        syslog(3, "io/hpmud/jd.c 489: unable to connect to soap-fax port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      break;
    }
    case 21:
    {
      port = 8290;
      pin.sin_port=htons((unsigned short int)port);
      pc->socket=socket(2, 1, 0);
      if(pc->socket == -1)
      {
        syslog(3, "io/hpmud/jd.c 498: unable to open marvell-scan port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      return_value_connect$9=connect(pc->socket, (struct sockaddr *)&pin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(return_value_connect$9 == -1)
      {
        syslog(3, "io/hpmud/jd.c 503: unable to connect to marvell-scan port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      break;
    }
    case 24:

    case 23:

    case 26:
    {
      port = 8080;
      pin.sin_port=htons((unsigned short int)port);
      pc->socket=socket(2, 1, 0);
      if(pc->socket == -1)
      {
        syslog(3, "io/hpmud/jd.c 514: unable to open ledm-scan port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      return_value_connect$10=connect(pc->socket, (struct sockaddr *)&pin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(return_value_connect$10 == -1)
      {
        syslog(3, "io/hpmud/jd.c 519: unable to connect to ledm-scan port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      break;
    }
    case 45:
    {
      port = 631;
      pin.sin_port=htons((unsigned short int)port);
      pc->socket=socket(2, 1, 0);
      if(pc->socket == -1)
      {
        syslog(3, "io/hpmud/jd.c 528: unable to open ipp port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      return_value_connect$11=connect(pc->socket, (struct sockaddr *)&pin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(return_value_connect$11 == -1)
      {
        syslog(3, "io/hpmud/jd.c 533: unable to connect to ipp port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      break;
    }
    case 22:
    {
      port = 8285;
      pin.sin_port=htons((unsigned short int)port);
      pc->socket=socket(2, 1, 0);
      if(pc->socket == -1)
      {
        syslog(3, "io/hpmud/jd.c 542: unable to open marvell-fax port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      return_value_connect$12=connect(pc->socket, (struct sockaddr *)&pin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(return_value_connect$12 == -1)
      {
        syslog(3, "io/hpmud/jd.c 547: unable to connect to marvell-fax port %d: %m %s\n", port, (const void *)pd->uri);
        goto bugout;
      }

      break;
    }
    case 1:
      break;
    default:
    {
      syslog(3, "io/hpmud/jd.c 555: unsupported service %d %s\n", pc->index, (const void *)pd->uri);
      stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_SN;
      goto bugout;
    }
  }
  stat = (enum HPMUD_RESULT)HPMUD_R_OK;

bugout:
  ;
  return stat;
}

// jd_s_channel_read
// file io/hpmud/jd.c line 642
enum HPMUD_RESULT jd_s_channel_read(struct _mud_channel *pc, void *buf, signed int length, signed int sec_timeout, signed int *bytes_read)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  signed int len = 0;
  struct timeval tmo;
  struct anonymous$13 master;
  struct anonymous$13 readfd;
  signed int maxfd;
  signed int ret;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  *bytes_read = 0;
  if(!(pc->socket >= 0))
  {
    stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_STATE;
    syslog(3, "io/hpmud/jd.c 657: invalid data link socket=%d %s\n", pc->socket, (const void *)pd->uri);
  }

  else
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$13) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&master)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&master)->fds_bits[(signed long int)(pc->socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&master)->fds_bits[(signed long int)(pc->socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << pc->socket % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    maxfd = pc->socket;
    tmo.tv_sec = (signed long int)sec_timeout;
    tmo.tv_usec = (signed long int)0;
    readfd = master;
    ret=select(maxfd + 1, &readfd, (struct anonymous$13 *)(void *)0, (struct anonymous$13 *)(void *)0, &tmo);
    if(!(ret >= 0))
      syslog(3, "io/hpmud/jd.c 671: unable to read_channel: %m %s\n", (const void *)pd->uri);

    else
    {
      if(ret == 0)
      {
        stat = (enum HPMUD_RESULT)HPMUD_R_IO_TIMEOUT;
        syslog(3, "io/hpmud/jd.c 678: timeout read_channel sec=%d %s\n", sec_timeout, (const void *)pd->uri);
        goto bugout;
      }

      else
      {
        signed long int return_value_recv$1;
        return_value_recv$1=recv(pc->socket, buf, (unsigned long int)length, 0);
        len = (signed int)return_value_recv$1;
        if(!(len >= 0))
        {
          syslog(3, "io/hpmud/jd.c 685: unable to read_channel: %m %s\n", (const void *)pd->uri);
          goto bugout;
        }

      }
      *bytes_read = len;
      stat = (enum HPMUD_RESULT)HPMUD_R_OK;
    }
  }

bugout:
  ;
  return stat;
}

// jd_s_channel_write
// file io/hpmud/jd.c line 582
enum HPMUD_RESULT jd_s_channel_write(struct _mud_channel *pc, const void *buf, signed int length, signed int sec_timeout, signed int *bytes_wrote)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  signed int len;
  signed int size;
  signed int total = 0;
  struct timeval tmo;
  struct anonymous$13 master;
  struct anonymous$13 writefd;
  signed int maxfd;
  signed int ret;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  *bytes_wrote = 0;
  size = length;
  if(!(pc->socket >= 0))
  {
    stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_STATE;
    syslog(3, "io/hpmud/jd.c 598: invalid data link socket=%d %s\n", pc->socket, (const void *)pd->uri);
  }

  else
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$13) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&master)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&master)->fds_bits[(signed long int)(pc->socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&master)->fds_bits[(signed long int)(pc->socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << pc->socket % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    maxfd = pc->socket;
    size = length;
    while(size >= 1)
    {
      tmo.tv_sec = (signed long int)45;
      tmo.tv_usec = (signed long int)0;
      writefd = master;
      ret=select(maxfd + 1, (struct anonymous$13 *)(void *)0, &writefd, (struct anonymous$13 *)(void *)0, &tmo);
      if(ret == 0)
      {
        stat = (enum HPMUD_RESULT)HPMUD_R_IO_TIMEOUT;
        syslog(3, "io/hpmud/jd.c 615: timeout write_channel %s\n", (const void *)pd->uri);
        goto bugout;
      }

      signed long int return_value_send$1;
      return_value_send$1=send(pc->socket, buf + (signed long int)total, (unsigned long int)size, 0);
      len = (signed int)return_value_send$1;
      if(!(len >= 0))
      {
        syslog(3, "io/hpmud/jd.c 621: unable to write_channel: %m %s\n", (const void *)pd->uri);
        goto bugout;
      }

      size = size - len;
      total = total + len;
      *bytes_wrote = *bytes_wrote + len;
    }
    stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  }

bugout:
  ;
  return stat;
}

// libusb_bulk_read
// file io/hpmud/musb.c line 905
static signed int libusb_bulk_read(struct libusb_device_handle *dev, signed int ep, char *bytes, signed int size, signed int timeout)
{
  signed int actual_len = 0;
  libusb_bulk_transfer(dev, (unsigned char)ep, (unsigned char *)bytes, size, &actual_len, (unsigned int)timeout);
  return actual_len;
}

// libusb_bulk_write
// file io/hpmud/musb.c line 913
static signed int libusb_bulk_write(struct libusb_device_handle *dev, signed int ep, char *bytes, signed int size, signed int timeout)
{
  signed int actual_len = 0;
  libusb_bulk_transfer(dev, (unsigned char)ep, (unsigned char *)bytes, size, &actual_len, (unsigned int)timeout);
  return actual_len;
}

// list_add
// file io/hpmud/list.h line 41
static inline void list_add(struct list_head *new_entry, struct list_head *head)
{
  __list_add(new_entry, head, head->next);
}

// list_del
// file io/hpmud/list.h line 78
static inline void list_del(struct list_head *entry)
{
  __list_del(entry->prev, entry->next);
  entry->prev = ((struct list_head *)NULL);
  entry->next = entry->prev;
}

// load_library
// file common/utils.c line 177
void * load_library(const char *szLibraryFile)
{
  void *pHandler = (void *)0;
  _Bool tmp_if_expr$1;
  if(szLibraryFile == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)szLibraryFile[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  char *return_value_dlerror$2;
  if(tmp_if_expr$1)
  {
    syslog(3, "common/utils.c 183: Invalid Library name\n");
    return pHandler;
  }

  else
  {
    pHandler=dlopen(szLibraryFile, 0x00002 | 0x00100);
    if(pHandler == NULL)
    {
      return_value_dlerror$2=dlerror();
      syslog(3, "common/utils.c 188: unable to load library %s: %s\n", szLibraryFile, return_value_dlerror$2);
    }

    return pHandler;
  }
}

// load_plugin_library
// file common/utils.c line 137
void * load_plugin_library(enum UTILS_PLUGIN_LIBRARY_TYPE eLibraryType, const char *szPluginName)
{
  void *pHandler = (void *)0;
  char szHome[256l];
  char szLibraryFile[256l];
  _Bool tmp_if_expr$1;
  if(szPluginName == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)szPluginName[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    syslog(3, "common/utils.c 145: Invalid Library name\n");
    return pHandler;
  }

  else
  {
    enum UTILS_CONF_RESULT return_value_get_conf$2;
    return_value_get_conf$2=get_conf("[dirs]", "home", szHome, (signed int)sizeof(char [256l]) /*256ul*/ );
    if(!((signed int)return_value_get_conf$2 == UTILS_CONF_OK))
    {
      syslog(3, "common/utils.c 151: Failed to find the home directory from hplip.conf file\n");
      return pHandler;
    }

    else
    {
      enum UTILS_PLUGIN_STATUS return_value_validate_plugin_version$3;
      return_value_validate_plugin_version$3=validate_plugin_version();
      if(!((signed int)return_value_validate_plugin_version$3 == UTILS_PLUGIN_STATUS_OK))
      {
        syslog(3, "common/utils.c 157: Plugin version is not matching \n");
        return pHandler;
      }

      else
      {
        if((signed int)eLibraryType == UTILS_PRINT_PLUGIN_LIBRARY)
          snprintf(szLibraryFile, sizeof(char [256l]) /*256ul*/ , "%s/prnt/plugins/%s", (const void *)szHome, szPluginName);

        else
          if((signed int)eLibraryType == UTILS_SCAN_PLUGIN_LIBRARY)
            snprintf(szLibraryFile, sizeof(char [256l]) /*256ul*/ , "%s/scan/plugins/%s", (const void *)szHome, szPluginName);

          else
            if((signed int)eLibraryType == UTILS_FAX_PLUGIN_LIBRARY)
              snprintf(szLibraryFile, sizeof(char [256l]) /*256ul*/ , "%s/fax/plugins/%s", (const void *)szHome, szPluginName);

            else
            {
              syslog(3, "common/utils.c 169: Invalid Library Type =%d \n", eLibraryType);
              return pHandler;
            }
        void *return_value_load_library$4;
        return_value_load_library$4=load_library(szLibraryFile);
        return return_value_load_library$4;
      }
    }
  }
}

// loop_test
// file prnt/backend/hp.c line 588
static signed int loop_test(signed int dd, signed int cd, struct pjl_attributes *pa, const char *dev, const char *printer, const char *username, const char *jobid, const char *title)
{
  signed int status;
  signed int stat;
  const char *pstate;
  const char *old_state = (const char *)(void *)0;
  while((_Bool)1)
  {
    status=get_printer_status(dd, cd, pa);
    map_ipp_printer_state_reason(status, &pstate);
    char *return_value_strstr$1;
    return_value_strstr$1=strstr(pstate, "error");
    if(!(return_value_strstr$1 == ((char *)NULL)))
    {
      if(!(pstate == old_state))
      {
        if(!(old_state == ((const char *)NULL)))
          fprintf(stderr, "STATE: -%s\n", old_state);

        device_event(dev, printer, status, username, jobid, title);
        fprintf(stderr, "STATE: +%s\n", pstate);
        old_state = pstate;
      }

      bug("prnt/backend/hp.c 616: ERROR: %d %s; will retry in %d seconds...\n", status, pstate, 30);
      sleep((unsigned int)30);
    }

    else
    {
      if(!(old_state == ((const char *)NULL)))
        fprintf(stderr, "STATE: -%s\n", old_state);

      if(status >= 5000 && !(status >= 6000))
      {
        device_event(dev, printer, status, username, jobid, title);
        bug("prnt/backend/hp.c 630: ERROR: %d device communication error!\n", status);
        stat = 1;
      }

      else
        stat = 0;
      break;
    }
  }
  return stat;
}

// main
// file prnt/backend/hp.c line 690
signed int main(signed int argc, char **argv)
{
  signed int fd;
  signed int copies;
  signed int len;
  signed int status;
  signed int cnt;
  signed int exit_stat = 1;
  char buf[16384l];
  struct hpmud_model_attributes ma;
  struct pjl_attributes pa;
  signed int hd = -1;
  signed int cd = -1;
  signed int n;
  signed int total = 0;
  signed int retry = 0;
  signed int size;
  signed int pages;
  enum HPMUD_RESULT stat;
  char *printer;
  printer=getenv("PRINTER");
  signed int iLogLevel = 0;
  struct _IO_FILE *temp_fp = (struct _IO_FILE *)(void *)0;
  signed int saveoutfile = 0;
  openlog("hp", 0x01, 3 << 3);
  pa.tid = (unsigned long int)0;
  if(argc >= 2)
  {
    const char *arg = argv[(signed long int)1];
    if((signed int)*arg == 45)
    {
      if((signed int)arg[1l] == 104)
      {
        fprintf(stdout, "HP Linux Imaging and Printing System\nCUPS Backend %s\n", (const void *)"3.16.2");
        fprintf(stdout, "(c) 2003-2008 Copyright HP Development Company, LP\n");
        exit(0);
      }

    }

  }

  signed int return_value_device_discovery$1;
  if(argc == 1)
  {
    return_value_device_discovery$1=device_discovery();
    exit(return_value_device_discovery$1);
  }

  if(argc >= 8 || !(argc >= 6))
  {
    bug("prnt/backend/hp.c 730: ERROR: invalid usage: device_uri job-id user title copies options [file]\n");
    exit(1);
  }

  if(argc == 6)
  {
    fd = 0;
    copies = 1;
  }

  else
  {
    fd=open(argv[(signed long int)6], 00);
    if(!(fd >= 0))
    {
      bug("prnt/backend/hp.c 743: ERROR: unable to open print file %s: %m\n", argv[(signed long int)6]);
      exit(1);
    }

    copies=atoi(argv[(signed long int)4]);
  }
  iLogLevel=getHPLogLevel();
  if(!((8 & iLogLevel) == 0))
  {
    temp_fp=create_out_file(argv[(signed long int)1], argv[(signed long int)2]);
    if(!(temp_fp == ((struct _IO_FILE *)NULL)))
      saveoutfile = 1;

  }

  if(!((32 & iLogLevel) == 0))
  {
    if(!(temp_fp == ((struct _IO_FILE *)NULL)))
    {
      saveoutfile = 1;
      save_out_file(fd, copies, temp_fp);
    }

    exit(0);
  }

  signal(15, (void (*)(signed int))1);
  init_dbus();
  hpmud_query_model(argv[(signed long int)0], &ma);
  pa.pjl_device = 0;
  char *return_value_strcasestr$2;
  return_value_strcasestr$2=strcasestr(argv[(signed long int)0], ":/net");
  if(return_value_strcasestr$2 == ((char *)NULL))
  {
    if((signed int)ma.statustype == HPMUD_STATUSTYPE_PJL || (signed int)ma.statustype == HPMUD_STATUSTYPE_PJLPML)
      pa.pjl_device = 1;

  }

  device_event(argv[(signed long int)0], printer, 500, argv[(signed long int)2], argv[(signed long int)1], argv[(signed long int)3]);
  signed long int return_value_read$3;
  while(copies >= 1)
  {
    copies = copies - 1;
    if(!(fd == 0))
    {
      fputs("PAGE: 1 1\n", stderr);
      lseek(fd, (signed long int)0, 0);
    }

    do
    {
      return_value_read$3=read(fd, (void *)buf, sizeof(char [16384l]) /*16384ul*/ );
      len = (signed int)return_value_read$3;
      if(!(len >= 1))
        break;

      size = len;
      total = 0;
      for( ; size >= 1; size = size - n)
      {
        if(!(saveoutfile == 0))
          fwrite((const void *)buf, (unsigned long int)1, (unsigned long int)len, temp_fp);

        if(!(hd >= 1))
        {
          fputs("STATE: +connecting-to-device\n", stderr);
          do
          {
            stat=hpmud_open_device(argv[(signed long int)0], ma.prt_mode, &hd);
            if((signed int)stat == HPMUD_R_OK)
              break;

            char *return_value_getenv$4;
            return_value_getenv$4=getenv("CLASS");
            if(!(return_value_getenv$4 == ((char *)NULL)))
            {
              bug("prnt/backend/hp.c 817: INFO: open device failed stat=%d: %s; trying next printer in class...\n", stat, argv[(signed long int)0]);
              sleep((unsigned int)5);
              goto bugout;
            }

            if(!((signed int)stat == HPMUD_R_DEVICE_BUSY))
            {
              bug("prnt/backend/hp.c 824: ERROR: open device failed stat=%d: %s\n", stat, argv[(signed long int)0]);
              goto bugout;
            }

            device_event(argv[(signed long int)0], printer, 5000 + (signed int)stat, argv[(signed long int)2], argv[(signed long int)1], argv[(signed long int)3]);
            bug("prnt/backend/hp.c 831: INFO: open device failed stat=%d: %s; will retry in %d seconds...\n", stat, argv[(signed long int)0], 30);
            sleep((unsigned int)30);
            retry = 1;
          }
          while((_Bool)1);
          if(!(retry == 0))
          {
            device_event(argv[(signed long int)0], printer, 1002, argv[(signed long int)2], argv[(signed long int)1], argv[(signed long int)3]);
            retry = 0;
          }

          do
          {
            stat=hpmud_open_channel(hd, "PRINT", &cd);
            if((signed int)stat == HPMUD_R_OK)
              break;

            if(!((signed int)stat == HPMUD_R_DEVICE_BUSY))
            {
              bug("prnt/backend/hp.c 847: ERROR: cannot open channel %s\n", (const void *)"PRINT");
              goto bugout;
            }

            device_event(argv[(signed long int)0], printer, 5000 + (signed int)stat, argv[(signed long int)2], argv[(signed long int)1], argv[(signed long int)3]);
            bug("prnt/backend/hp.c 851: INFO: open print channel failed stat=%d; will retry in %d seconds...\n", stat, 30);
            sleep((unsigned int)30);
            retry = 1;
          }
          while((_Bool)1);
          if(!(retry == 0))
          {
            device_event(argv[(signed long int)0], printer, 1002, argv[(signed long int)2], argv[(signed long int)1], argv[(signed long int)3]);
            retry = 0;
          }

          fputs("STATE: -connecting-to-device\n", stderr);
          if(!(pa.pjl_device == 0))
          {
            hpmud_write_channel(hd, cd, (const void *)pjl_ustatus_cmd, (signed int)(sizeof(const char [81l]) /*81ul*/  - (unsigned long int)1), 5, &len);
            pa.dd = hd;
            pa.cd = cd;
            pthread_mutex_init(&pa.mutex, (const union anonymous$33 *)(void *)0);
            pthread_cond_init(&pa.done_cond, (const union anonymous$33 *)(void *)0);
            pthread_create(&pa.tid, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))pjl_read_thread, (void *)&pa);
          }

          fprintf(stderr, "STATE: -%s\n", (const void *)"media-empty-error,media-jam-error,hplip.plugin-error,cover-open-error,toner-empty-error,other");
        }

        stat=hpmud_write_channel(hd, cd, (const void *)(buf + (signed long int)total), size, 45, &n);
        if(!(n == size))
        {
          signed int return_value_loop_test$5;
          return_value_loop_test$5=loop_test(hd, cd, &pa, argv[(signed long int)0], printer, argv[(signed long int)2], argv[(signed long int)1], argv[(signed long int)3]);
          if(!(return_value_loop_test$5 == 0))
          {
            exit_stat = 4;
            goto bugout;
          }

        }

        else
          if(!(pa.pjl_device == 0))
          {
            signed int return_value_loop_test$6;
            return_value_loop_test$6=loop_test(hd, cd, &pa, argv[(signed long int)0], printer, argv[(signed long int)2], argv[(signed long int)1], argv[(signed long int)3]);
            if(!(return_value_loop_test$6 == 0))
            {
              exit_stat = 4;
              goto bugout;
            }

          }

        total = total + n;
      }
    }
    while((_Bool)1);
  }
  if(total == 0)
  {
    exit_stat = 0;
    bug("prnt/backend/hp.c 919: ERROR: null print job total=%d\n", total);
  }

  else
  {
    if(!(pa.pjl_device == 0) && !(pa.tid == 0ul))
    {
      pthread_mutex_lock(&pa.mutex);
      pa.eoj_pages = 0;
      pthread_mutex_unlock(&pa.mutex);
      hpmud_write_channel(hd, cd, (const void *)pjl_job_end_cmd, (signed int)(sizeof(const char [30l]) /*30ul*/  - (unsigned long int)1), 5, &len);
      cnt = 0;
      for( ; !(cnt >= 10); cnt = cnt + 1)
      {
        signed int return_value_loop_test$7;
        return_value_loop_test$7=loop_test(hd, cd, &pa, argv[(signed long int)0], printer, argv[(signed long int)2], argv[(signed long int)1], argv[(signed long int)3]);
        if(!(return_value_loop_test$7 == 0))
        {
          exit_stat = 0;
          goto bugout;
        }

        pthread_mutex_lock(&pa.mutex);
        pages = pa.eoj_pages;
        pthread_mutex_unlock(&pa.mutex);
        if(pages >= 1)
          break;

        sleep((unsigned int)2);
      }
      hpmud_write_channel(hd, cd, (const void *)pjl_ustatus_off_cmd, (signed int)(sizeof(const char [37l]) /*37ul*/  - (unsigned long int)1), 5, &len);
    }

    else
      if((signed int)ma.statustype == HPMUD_STATUSTYPE_SFIELD && !((signed int)ma.prt_mode == HPMUD_UNI_MODE))
      {
        status=get_printer_status(hd, cd, &pa);
        if(!(status >= 5000))
        {
          cnt = 0;
          for( ; !(status == 1000) && !(cnt >= 5) && !(status >= 5000); cnt = cnt + 1)
          {
            sleep((unsigned int)2);
            status=get_printer_status(hd, cd, &pa);
          }
        }

      }

      else
        sleep((unsigned int)8);
    exit_stat = 0;
    fputs("INFO: ready to print\n", stderr);
  }

bugout:
  ;
  device_event(argv[(signed long int)0], printer, 501, argv[(signed long int)2], argv[(signed long int)1], argv[(signed long int)3]);
  if(!(pa.pjl_device == 0) && !(pa.tid == 0ul))
  {
    pthread_mutex_lock(&pa.mutex);
    pa.abort = 1;
    while(pa.done == 0)
      pthread_cond_wait(&pa.done_cond, &pa.mutex);
    pthread_mutex_unlock(&pa.mutex);
    pthread_cancel(pa.tid);
    pthread_mutex_destroy(&pa.mutex);
    pthread_cond_destroy(&pa.done_cond);
  }

  if(cd >= 0)
    hpmud_close_channel(hd, cd);

  if(hd >= 0)
    hpmud_close_device(hd);

  if(!(fd == 0))
    close(fd);

  if(!(temp_fp == ((struct _IO_FILE *)NULL)))
    fclose(temp_fp);

  exit(exit_stat);
}

// map_ipp_printer_state_reason
// file prnt/backend/hp.c line 231
static signed int map_ipp_printer_state_reason(signed int status, const char **state_msg)
{
  if(status >= 1000 && !(status >= 2000))
    switch(status)
    {
      case 1000:

      case 1002:
      {
        *state_msg = "none";
        break;
      }
      case 1009:
      {
        *state_msg = "media-empty-error";
        break;
      }
      case 1014:
      {
        *state_msg = "media-jam-error";
        break;
      }
      default:
        *state_msg = "other";
    }

  else
    if(status >= 10000 && !(status >= 56000))
    {
      if(status >= 10000 && !(status >= 11000))
        *state_msg = "none";

      else
        if(status >= 41000 && !(status >= 42000))
          *state_msg = "media-empty-error";

        else
          if(status == 40022 || status >= 42000 && !(status >= 43000) || status >= 44000 && !(status >= 45000))
            *state_msg = "media-jam-error";

          else
            if(status == 40021)
              *state_msg = "cover-open-error";

            else
              if(status == 40600)
                *state_msg = "toner-empty-error";

              else
                *state_msg = "other";
    }

    else
      *state_msg = "other";
  return 0;
}

// mdns_convert_name_to_dns
// file protocol/discovery/mdns.c line 37
static signed int mdns_convert_name_to_dns(const char *name, signed int name_size, char *dns_name)
{
  signed int i;
  signed int x = 0;
  char *p = dns_name;
  _Bool tmp_if_expr$1;
  if(name == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)name[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    i = 0;
    do
    {
      if(!(i >= name_size))
        tmp_if_expr$2 = name[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        break;

      if((signed int)name[(signed long int)i] == 46)
      {
        char *tmp_post$3 = p;
        p = p + 1l;
        *tmp_post$3 = (char)(i - x);
        for( ; !(x >= i); x = x + 1)
        {
          char *tmp_post$4 = p;
          p = p + 1l;
          *tmp_post$4 = name[(signed long int)x];
        }
        x = x + 1;
      }

      i = i + 1;
    }
    while((_Bool)1);
    if(!(i == 0))
    {
      char *tmp_post$5 = p;
      p = p + 1l;
      *tmp_post$5 = (char)(i - x);
      for( ; !(x >= i); x = x + 1)
      {
        char *tmp_post$6 = p;
        p = p + 1l;
        *tmp_post$6 = name[(signed long int)x];
      }
      x = x + 1;
    }

    signed int tmp_post$7 = x;
    x = x + 1;
    p[(signed long int)tmp_post$7] = (char)0;
    return x;
  }
}

// mdns_create_query_packet
// file protocol/discovery/mdns.c line 135
static void mdns_create_query_packet(char *fqdn, signed int query_type, char *querybuf, signed int *length)
{
  signed int n = 0;
  char header[12l] = { (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x01, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00 };
  memcpy((void *)querybuf, (const void *)header, sizeof(char [12l]) /*12ul*/ );
  n = (signed int)sizeof(char [12l]) /*12ul*/ ;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(fqdn);
  signed int return_value_mdns_convert_name_to_dns$2;
  return_value_mdns_convert_name_to_dns$2=mdns_convert_name_to_dns(fqdn, (signed int)return_value_strlen$1, querybuf + (signed long int)n);
  n = n + return_value_mdns_convert_name_to_dns$2;
  signed int tmp_post$3 = n;
  n = n + 1;
  querybuf[(signed long int)tmp_post$3] = (char)0x00;
  signed int tmp_post$4 = n;
  n = n + 1;
  querybuf[(signed long int)tmp_post$4] = (char)query_type;
  signed int tmp_post$5 = n;
  n = n + 1;
  querybuf[(signed long int)tmp_post$5] = (char)0x00;
  signed int tmp_post$6 = n;
  n = n + 1;
  querybuf[(signed long int)tmp_post$6] = (char)1;
  *length = n;
}

// mdns_lookup
// file protocol/discovery/mdns.h line 87
signed int mdns_lookup(char *hostname, unsigned char *ip)
{
  signed int udp_socket = 0;
  signed int stat = 1;
  char fqdn[256l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct _DNS_RECORD *rr_list = (struct _DNS_RECORD *)(void *)0;
  signed int return_value_mdns_open_socket$1;
  return_value_mdns_open_socket$1=mdns_open_socket(&udp_socket);
  if(return_value_mdns_open_socket$1 == 0)
  {
    sprintf((const void *)fqdn, (const void *)"%s.local", hostname);
    mdns_send_query(udp_socket, fqdn, 1);
    rr_list=mdns_read_responses(udp_socket, 1);
    if(!(rr_list == ((struct _DNS_RECORD *)NULL)))
    {
      strcpy((char *)ip, rr_list->ip);
      stat = 0;
    }

  }


bugout:
  ;
  if(udp_socket >= 0)
    close(udp_socket);

  mdns_rr_cleanup(rr_list);
  return stat;
}

// mdns_open_socket
// file protocol/discovery/mdns.c line 70
static signed int mdns_open_socket(signed int *psocket)
{
  signed int stat = 1;
  signed int udp_socket = -1;
  signed int yes = 1;
  char loop = (char)0;
  char ttl = (char)255;
  struct sockaddr_in recv_addr;
  struct sockaddr_in addr;
  struct ip_mreq mreq;
  udp_socket=socket(2, 2, 0);
  signed int return_value_setsockopt$1;
  signed int return_value_bind$2;
  signed int return_value_setsockopt$3;
  signed int return_value_setsockopt$4;
  signed int return_value_setsockopt$5;
  if(udp_socket == -1)
    syslog(3, "protocol/discovery/mdns.c 82: unable to create udp socket: %m\n");

  else
  {
    return_value_setsockopt$1=setsockopt(udp_socket, 1, 2, (const void *)&yes, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(return_value_setsockopt$1 == -1)
      syslog(3, "protocol/discovery/mdns.c 89: unable to setsockopt: %m\n");

    else
    {
      bzero((void *)&recv_addr, sizeof(struct sockaddr_in) /*16ul*/ );
      recv_addr.sin_family = (unsigned short int)2;
      recv_addr.sin_addr.s_addr=htonl((unsigned int)0x00000000);
      recv_addr.sin_port=htons((unsigned short int)5353);
      return_value_bind$2=bind(udp_socket, (struct sockaddr *)&recv_addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(return_value_bind$2 == -1)
        syslog(3, "protocol/discovery/mdns.c 100: unable to bind udp socket: %m\n");

      else
      {
        return_value_setsockopt$3=setsockopt(udp_socket, 0, 34, (const void *)&loop, (unsigned int)sizeof(char) /*1ul*/ );
        if(return_value_setsockopt$3 == -1)
          syslog(3, "protocol/discovery/mdns.c 107: unable to setsockopt: %m\n");

        else
        {
          return_value_setsockopt$4=setsockopt(udp_socket, 0, 33, (const void *)&ttl, (unsigned int)sizeof(char) /*1ul*/ );
          if(return_value_setsockopt$4 == -1)
            syslog(3, "protocol/discovery/mdns.c 114: unable to setsockopt: %m\n");

          else
          {
            mreq.imr_multiaddr.s_addr=inet_addr("224.0.0.251");
            mreq.imr_interface.s_addr=htonl((unsigned int)0x00000000);
            return_value_setsockopt$5=setsockopt(udp_socket, 0, 35, (const void *)&mreq, (unsigned int)sizeof(struct ip_mreq) /*8ul*/ );
            if(return_value_setsockopt$5 == -1)
            {
              syslog(3, "protocol/discovery/mdns.c 122: unable to add to multicast group: %m\n");
              close(udp_socket);
            }

            else
            {
              *psocket = udp_socket;
              stat = 0;
            }
          }
        }
      }
    }
  }

bugout:
  ;
  return stat;
}

// mdns_parse_respponse
// file protocol/discovery/mdns.c line 250
static void mdns_parse_respponse(unsigned char *Response, struct _DNS_RECORD *rr)
{
  unsigned char *p = Response;
  unsigned short int type = (unsigned short int)0;
  unsigned short int data_len = (unsigned short int)0;
  struct _DNS_PKT_HEADER h;
  signed int i = 0;
  mdns_read_header((char *)Response, &h);
  p = p + (signed long int)12;
  i = 0;
  for( ; !(i >= (signed int)h.questions); i = i + 1)
  {
    signed int return_value_mdns_readName$1;
    return_value_mdns_readName$1=mdns_readName(Response, p, rr->name);
    p = p + (signed long int)return_value_mdns_readName$1;
    p = p + (signed long int)4;
  }
  i = 0;
  for( ; !(i >= (signed int)h.additionals + (signed int)h.answers); i = i + 1)
  {
    signed int return_value_mdns_readName$2;
    return_value_mdns_readName$2=mdns_readName(Response, p, rr->name);
    p = p + (signed long int)return_value_mdns_readName$2;
    type = (unsigned short int)((signed int)*p << 8 | (signed int)p[(signed long int)1]);
    p = p + (signed long int)8;
    data_len = (unsigned short int)((signed int)*p << 8 | (signed int)p[(signed long int)1]);
    p = p + (signed long int)2;
    switch((signed int)type)
    {
      case 1:
      {
        sprintf((const void *)rr->ip, (const void *)"%d.%d.%d.%d", p[(signed long int)0], p[(signed long int)1], p[(signed long int)2], p[(signed long int)3]);
        break;
      }
      case 16:
        mdns_readMDL(p, (unsigned char *)rr->mdl, (signed int)data_len);
    }
    p = p + (signed long int)data_len;
  }
}

// mdns_probe_nw_scanners
// file protocol/discovery/mdns.c line 416
signed int mdns_probe_nw_scanners(char *uris_buf, signed int buf_size, signed int *count)
{
  signed int n = 0;
  signed int bytes_read = 0;
  signed int udp_socket = 0;
  signed int stat = 1;
  struct _DNS_RECORD *rr_list = (struct _DNS_RECORD *)(void *)0;
  signed int return_value_mdns_open_socket$1;
  return_value_mdns_open_socket$1=mdns_open_socket(&udp_socket);
  if(return_value_mdns_open_socket$1 == 0)
  {
    mdns_send_query(udp_socket, "_scanner._tcp.local", 12);
    rr_list=mdns_read_responses(udp_socket, 0);
    bytes_read=mdns_update_uris(rr_list, uris_buf, buf_size, count);
  }


bugout:
  ;
  if(udp_socket >= 0)
    close(udp_socket);

  mdns_rr_cleanup(rr_list);
  return bytes_read;
}

// mdns_readMDL
// file protocol/discovery/mdns.c line 204
static unsigned char * mdns_readMDL(unsigned char *p, unsigned char *normalized_mdl, signed int len)
{
  signed int i = 0;
  signed int j = 0;
  signed int size = 0;
  unsigned char *mdl = normalized_mdl;
  signed int return_value_tolower$4;
  while(!(i >= len))
  {
    unsigned char *tmp_post$1 = p;
    p = p + 1l;
    size = (signed int)*tmp_post$1;
    i = i + size + 1;
    signed int return_value_strncmp$6;
    return_value_strncmp$6=strncmp((const char *)p, "mdl=", (unsigned long int)4);
    if(return_value_strncmp$6 == 0)
    {
      j = 4;
      for( ; !(j >= size); j = j + 1)
        if((signed int)p[(signed long int)j] == 32)
        {
          unsigned char *tmp_post$2 = mdl;
          mdl = mdl + 1l;
          *tmp_post$2 = (unsigned char)95;
        }

        else
        {
          unsigned char *tmp_post$3 = mdl;
          mdl = mdl + 1l;
          return_value_tolower$4=tolower(p[(signed long int)j]);
          *tmp_post$3 = (unsigned char)return_value_tolower$4;
        }
      unsigned char *tmp_post$5 = mdl;
      mdl = mdl + 1l;
      *tmp_post$5 = (unsigned char)0;
      break;
    }

    p = p + (signed long int)size;
  }
  return p + (signed long int)4;
}

// mdns_readName
// file protocol/discovery/mdns.c line 177
static signed int mdns_readName(unsigned char *start, unsigned char *Response, char *buf)
{
  signed int size = 0;
  char *name = buf;
  unsigned char *p = Response;
  unsigned char *tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p + 1l;
    size = (signed int)*tmp_post$1;
    if(size == 0)
      break;

    if(size >= 0xC0)
    {
      p = p + 1l;
      return (signed int)(p - Response);
    }

    memcpy((void *)name, (const void *)p, (unsigned long int)size);
    name[(signed long int)size] = (char)46;
    p = p + (signed long int)size;
    name = name + (signed long int)(size + 1);
  }
  while((_Bool)1);
  *(name - (signed long int)1) = (char)0;
  return (signed int)(p - Response);
}

// mdns_read_header
// file protocol/discovery/mdns.c line 236
static void mdns_read_header(char *Response, struct _DNS_PKT_HEADER *h)
{
  h->id = (unsigned short int)((signed int)Response[(signed long int)0] << 8 | (signed int)Response[(signed long int)1]);
  h->flags = (unsigned short int)((signed int)Response[(signed long int)2] << 8 | (signed int)Response[(signed long int)3]);
  h->questions = (unsigned short int)((signed int)Response[(signed long int)4] << 8 | (signed int)Response[(signed long int)5]);
  h->answers = (unsigned short int)((signed int)Response[(signed long int)6] << 8 | (signed int)Response[(signed long int)7]);
  h->authorities = (unsigned short int)((signed int)Response[(signed long int)8] << 8 | (signed int)Response[(signed long int)9]);
  h->additionals = (unsigned short int)((signed int)Response[(signed long int)10] << 8 | (signed int)Response[(signed long int)11]);
}

// mdns_read_responses
// file protocol/discovery/mdns.c line 326
static struct _DNS_RECORD * mdns_read_responses(signed int udp_socket, signed int mode)
{
  signed int retries = 3;
  signed int ret = 0;
  char recvbuffer[2048l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct _DNS_RECORD *rr = (struct _DNS_RECORD *)(void *)0;
  struct _DNS_RECORD *mdns_read_responses$$1$$head = (struct _DNS_RECORD *)(void *)0;
  struct _DNS_RECORD *temp = (struct _DNS_RECORD *)(void *)0;
  signed int tmp_post$1;
  while((_Bool)1)
  {
    memset((void *)recvbuffer, 0, sizeof(char [2048l]) /*2048ul*/ );
    ret=mdns_read_single_response(udp_socket, recvbuffer, (signed int)sizeof(char [2048l]) /*2048ul*/ );
    if(!(ret >= 1))
    {
      _Bool tmp_if_expr$2;
      if(ret == 0)
      {
        tmp_post$1 = retries;
        retries = retries - 1;
        tmp_if_expr$2 = tmp_post$1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        continue;

      else
        break;
    }

    else
    {
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct _DNS_RECORD) /*536ul*/ );
      temp = (struct _DNS_RECORD *)return_value_malloc$3;
      if(!(temp == ((struct _DNS_RECORD *)NULL)))
      {
        temp->next = (struct _DNS_RECORD *)(void *)0;
        if(mdns_read_responses$$1$$head == ((struct _DNS_RECORD *)NULL))
        {
          mdns_read_responses$$1$$head = temp;
          rr = mdns_read_responses$$1$$head;
        }

        else
        {
          rr->next = temp;
          rr = rr->next;
        }
        memset((void *)rr, 0, sizeof(struct _DNS_RECORD) /*536ul*/ );
        mdns_parse_respponse((unsigned char *)recvbuffer, rr);
        if(mode == 1)
          break;

      }

    }
  }
  return mdns_read_responses$$1$$head;
}

// mdns_read_single_response
// file protocol/discovery/mdns.c line 295
static signed int mdns_read_single_response(signed int udp_socket, char *recvbuffer, signed int recvbufsize)
{
  struct timeval tmo;
  struct sockaddr_in addr;
  unsigned int addrlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  struct anonymous$37 master;
  struct anonymous$37 readfd;
  signed int len = 0;
  signed int maxfd = 0;
  signed int ret = 0;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$37) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&master)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&master)->__fds_bits[(signed long int)(udp_socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&master)->__fds_bits[(signed long int)(udp_socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << udp_socket % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  maxfd = udp_socket;
  tmo.tv_sec = (signed long int)0;
  tmo.tv_usec = (signed long int)300000;
  readfd = master;
  ret=select(maxfd + 1, &readfd, (struct anonymous$37 *)(void *)0, (struct anonymous$37 *)(void *)0, &tmo);
  if(ret >= 1)
  {
    bzero((void *)&addr, sizeof(struct sockaddr_in) /*16ul*/ );
    signed long int return_value_recvfrom$1;
    return_value_recvfrom$1=recvfrom(udp_socket, (void *)recvbuffer, (unsigned long int)recvbufsize, 0, (struct sockaddr *)&addr, &addrlen);
    len = (signed int)return_value_recvfrom$1;
    if(!(len >= 0))
    {
      syslog(3, "protocol/discovery/mdns.c 317: recvfrom error: (%m)\n");
      ret = -1;
    }

  }

  return ret;
}

// mdns_rr_cleanup
// file protocol/discovery/mdns.c line 403
static void mdns_rr_cleanup(struct _DNS_RECORD *rr)
{
  struct _DNS_RECORD *temp = (struct _DNS_RECORD *)(void *)0;
  for( ; !(rr == ((struct _DNS_RECORD *)NULL)); rr = temp)
  {
    temp = rr->next;
    free(rr);
  }
}

// mdns_send_query
// file protocol/discovery/mdns.c line 155
static signed int mdns_send_query(signed int udp_socket, char *fqdn, signed int query_type)
{
  char querybuf[256l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int length = 0;
  signed int stat = 0;
  struct sockaddr_in send_addr;
  mdns_create_query_packet(fqdn, query_type, querybuf, &length);
  bzero((void *)&send_addr, sizeof(struct sockaddr_in) /*16ul*/ );
  send_addr.sin_family = (unsigned short int)2;
  send_addr.sin_addr.s_addr=inet_addr("224.0.0.251");
  send_addr.sin_port=htons((unsigned short int)5353);
  signed long int return_value_sendto$1;
  return_value_sendto$1=sendto(udp_socket, (const void *)querybuf, (unsigned long int)length, 0, (struct sockaddr *)&send_addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(return_value_sendto$1 >= 0l))
    stat = 1;

  return stat;
}

// mdns_update_uris
// file protocol/discovery/mdns.c line 371
static signed int mdns_update_uris(struct _DNS_RECORD *rr, char *uris_buf, signed int buf_size, signed int *count)
{
  char tempuri[256l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int bytes_read = 0;
  *count = 0;
  memset((void *)uris_buf, 0, (unsigned long int)buf_size);
  char *return_value_strstr$2;
  for( ; !(rr == ((struct _DNS_RECORD *)NULL)); rr = rr->next)
    if(!(rr->mdl[0l] == 0))
    {
      if(!(rr->ip[0l] == 0))
      {
        memset((void *)tempuri, 0, sizeof(char [256l]) /*256ul*/ );
        sprintf((const void *)tempuri, (const void *)"hp:/net/%s?ip=%s&queue=false", (const void *)rr->mdl, (const void *)rr->ip);
        if(!(sizeof(char [256l]) /*256ul*/  + (unsigned long int)bytes_read >= (unsigned long int)buf_size))
        {
          return_value_strstr$2=strstr(uris_buf, tempuri);
          if(return_value_strstr$2 == ((char *)NULL))
          {
            signed int return_value_sprintf$1;
            return_value_sprintf$1=sprintf(uris_buf + (signed long int)bytes_read, (const void *)"%s;", (const void *)tempuri);
            bytes_read = bytes_read + return_value_sprintf$1;
            *count = *count + 1;
            uris_buf[(signed long int)bytes_read] = (char)0;
          }

        }

      }

    }

  return bytes_read;
}

// musb_channel_close
// file io/hpmud/musb.c line 1380
enum HPMUD_RESULT musb_channel_close(struct _mud_device *pd, struct _mud_channel *pc)
{
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  pthread_mutex_lock(&pd->mutex);
  stat=pc->vf.close(pc);
  del_channel$link2(pd, pc);
  pthread_mutex_unlock(&pd->mutex);
  return stat;
}

// musb_channel_open
// file io/hpmud/musb.c line 1351
enum HPMUD_RESULT musb_channel_open(struct _mud_device *pd, const char *sn, signed int *cd)
{
  signed int index;
  enum HPMUD_RESULT stat;
  stat=service_to_channel(pd, sn, &index);
  signed int return_value_new_channel$1;
  if((signed int)stat == HPMUD_R_OK)
  {
    pthread_mutex_lock(&pd->mutex);
    return_value_new_channel$1=new_channel$link2(pd, index, sn);
    if(!(return_value_new_channel$1 == 0))
      stat = (enum HPMUD_RESULT)HPMUD_R_DEVICE_BUSY;

    else
    {
      stat=pd->channel[(signed long int)index].vf.open(&pd->channel[(signed long int)index]);
      if(!((signed int)stat == HPMUD_R_OK))
        del_channel$link2(pd, &pd->channel[(signed long int)index]);

      else
        *cd = index;
    }
    pthread_mutex_unlock(&pd->mutex);
  }


bugout:
  ;
  return stat;
}

// musb_channel_read
// file io/hpmud/musb.h line 110
enum HPMUD_RESULT musb_channel_read(struct _mud_device *pd, struct _mud_channel *pc, void *buf, signed int length, signed int sec_timeout, signed int *bytes_read)
{
  enum HPMUD_RESULT stat;
  if((signed int)pd->io_mode == HPMUD_UNI_MODE)
  {
    stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_STATE;
    syslog(3, "io/hpmud/musb.c 1339: invalid channel_read io_mode=%d\n", pd->io_mode);
  }

  else
  {
    pthread_mutex_lock(&pd->mutex);
    stat=pc->vf.channel_read(pc, buf, length, sec_timeout, bytes_read);
    pthread_mutex_unlock(&pd->mutex);
  }

bugout:
  ;
  return stat;
}

// musb_channel_write
// file io/hpmud/musb.h line 109
enum HPMUD_RESULT musb_channel_write(struct _mud_device *pd, struct _mud_channel *pc, const void *buf, signed int length, signed int sec_timeout, signed int *bytes_wrote)
{
  enum HPMUD_RESULT stat;
  pthread_mutex_lock(&pd->mutex);
  stat=pc->vf.channel_write(pc, buf, length, sec_timeout, bytes_wrote);
  pthread_mutex_unlock(&pd->mutex);
  return stat;
}

// musb_close
// file io/hpmud/musb.c line 1188
enum HPMUD_RESULT musb_close(struct _mud_device *pd)
{
  signed int i;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  pthread_mutex_lock(&pd->mutex);
  i = 1;
  for( ; !(i >= MAX_FD); i = i + 1)
    if(!(fd_table[(signed long int)i].hd == ((struct libusb_device_handle *)NULL)))
      release_interface(&fd_table[(signed long int)i]);

  pd->id[(signed long int)0] = (char)0;
  if(!(libusb_dev == ((struct libusb_device *)NULL)))
  {
    libusb_free_device_list(libusb_dev_list, 1);
    libusb_exit(libusb_ctx);
    libusb_ctx = (struct libusb_context *)(void *)0;
    libusb_dev_list = (struct libusb_device **)(void *)0;
    libusb_dev = (struct libusb_device *)(void *)0;
  }

  pthread_mutex_unlock(&pd->mutex);
  return stat;
}

// musb_comp_channel_open
// file io/hpmud/musb.c line 1512
enum HPMUD_RESULT musb_comp_channel_open(struct _mud_channel *pc)
{
  signed int fd;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_DEVICE_BUSY;
  switch(pc->index)
  {
    case 18:
    {
      fd = FD_ff_1_1;
      break;
    }
    case 23:
    {
      fd = FD_ff_4_1;
      break;
    }
    case 19:
    {
      fd = FD_ff_2_1;
      break;
    }
    case 20:
    {
      fd = FD_ff_3_1;
      break;
    }
    case 21:
    {
      fd = FD_ff_ff_ff;
      break;
    }
    case 22:
    {
      fd = FD_ff_1_0;
      break;
    }
    case 24:

    case 26:
    {
      fd = FD_ff_cc_0;
      break;
    }
    case 25:
    {
      fd = FD_ff_2_10;
      break;
    }
    case 45:
    {
      fd = FD_7_1_4;
      break;
    }
    case 46:
    {
      fd = FD_ff_9_1;
      break;
    }
    default:
    {
      stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_SN;
      syslog(3, "io/hpmud/musb.c 1553: invalid %s channel=%d\n", (const void *)pc->sn, pc->index);
      goto bugout;
    }
  }
  signed int return_value_get_interface$1;
  return_value_get_interface$1=get_interface(libusb_dev, (enum FD_ID)fd, &fd_table[(signed long int)fd]);
  signed int return_value_claim_interface$2;
  if(!(return_value_get_interface$1 == 0))
  {
    stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_SN;
    syslog(3, "io/hpmud/musb.c 1561: invalid %s channel=%d\n", (const void *)pc->sn, pc->index);
  }

  else
  {
    return_value_claim_interface$2=claim_interface(libusb_dev, &fd_table[(signed long int)fd]);
    if(return_value_claim_interface$2 == 0)
    {
      pc->fd = fd;
      stat = (enum HPMUD_RESULT)HPMUD_R_OK;
    }

  }

bugout:
  ;
  return stat;
}

// musb_dot4_channel_close
// file io/hpmud/musb.c line 1871
enum HPMUD_RESULT musb_dot4_channel_close(struct _mud_channel *pc)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  if(!(pd->mlc_up == 0))
  {
    signed int return_value_Dot4CloseChannel$1;
    return_value_Dot4CloseChannel$1=Dot4CloseChannel(pc, pd->mlc_fd);
    if(!(return_value_Dot4CloseChannel$1 == 0))
      stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;

  }

  if(pd->channel_cnt == 1)
  {
    if(!(pd->mlc_up == 0))
    {
      signed int return_value_Dot4Exit$2;
      return_value_Dot4Exit$2=Dot4Exit(pc, pd->mlc_fd);
      if(!(return_value_Dot4Exit$2 == 0))
        stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;

    }

    pd->mlc_up = 0;
    if(pd->mlc_fd == FD_7_1_2)
    {
      if((signed int)pd->io_mode == HPMUD_DOT4_BRIDGE_MODE)
        bridge_chip_down(&fd_table[(signed long int)pd->mlc_fd]);

      else
      {
        write_ecp_channel(&fd_table[(signed long int)pd->mlc_fd], 78);
        write_ecp_channel(&fd_table[(signed long int)pd->mlc_fd], 0);
      }
    }

    release_interface(&fd_table[(signed long int)pd->mlc_fd]);
    sleep((unsigned int)1);
  }

  return stat;
}

// musb_dot4_channel_open
// file io/hpmud/musb.c line 1791
enum HPMUD_RESULT musb_dot4_channel_open(struct _mud_channel *pc)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  enum FD_ID fd;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  signed int return_value_claim_interface$11;
  signed int return_value_get_interface$7;
  signed int return_value_claim_interface$8;
  signed int return_value_get_interface$4;
  signed int return_value_claim_interface$5;
  signed int return_value_get_interface$1;
  signed int return_value_claim_interface$2;
  if(pd->channel_cnt == 1)
  {
    signed int return_value_get_interface$10;
    return_value_get_interface$10=get_interface(libusb_dev, (enum FD_ID)FD_7_1_3, &fd_table[(signed long int)FD_7_1_3]);
    _Bool tmp_if_expr$12;
    if(return_value_get_interface$10 == 0)
    {
      return_value_claim_interface$11=claim_interface(libusb_dev, &fd_table[(signed long int)FD_7_1_3]);
      tmp_if_expr$12 = return_value_claim_interface$11 == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$12 = (_Bool)0;
    if(tmp_if_expr$12)
      fd = (enum FD_ID)FD_7_1_3;

    else
    {
      return_value_get_interface$7=get_interface(libusb_dev, (enum FD_ID)FD_ff_ff_ff, &fd_table[(signed long int)FD_ff_ff_ff]);
      _Bool tmp_if_expr$9;
      if(return_value_get_interface$7 == 0)
      {
        return_value_claim_interface$8=claim_interface(libusb_dev, &fd_table[(signed long int)FD_ff_ff_ff]);
        tmp_if_expr$9 = return_value_claim_interface$8 == 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$9 = (_Bool)0;
      if(tmp_if_expr$9)
        fd = (enum FD_ID)FD_ff_ff_ff;

      else
      {
        return_value_get_interface$4=get_interface(libusb_dev, (enum FD_ID)FD_ff_d4_0, &fd_table[(signed long int)FD_ff_d4_0]);
        _Bool tmp_if_expr$6;
        if(return_value_get_interface$4 == 0)
        {
          return_value_claim_interface$5=claim_interface(libusb_dev, &fd_table[(signed long int)FD_ff_d4_0]);
          tmp_if_expr$6 = return_value_claim_interface$5 == 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$6 = (_Bool)0;
        if(tmp_if_expr$6)
          fd = (enum FD_ID)FD_ff_d4_0;

        else
        {
          return_value_get_interface$1=get_interface(libusb_dev, (enum FD_ID)FD_7_1_2, &fd_table[(signed long int)FD_7_1_2]);
          _Bool tmp_if_expr$3;
          if(return_value_get_interface$1 == 0)
          {
            return_value_claim_interface$2=claim_interface(libusb_dev, &fd_table[(signed long int)FD_7_1_2]);
            tmp_if_expr$3 = return_value_claim_interface$2 == 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$3 = (_Bool)0;
          if(tmp_if_expr$3)
            fd = (enum FD_ID)FD_7_1_2;

          else
          {
            stat = (enum HPMUD_RESULT)HPMUD_R_DEVICE_BUSY;
            goto bugout;
          }
        }
      }
    }
    if((signed int)fd == FD_7_1_2)
    {
      if((signed int)pd->io_mode == HPMUD_DOT4_BRIDGE_MODE)
      {
        signed int return_value_bridge_chip_up$13;
        return_value_bridge_chip_up$13=bridge_chip_up(&fd_table[(signed long int)fd]);
        if(!(return_value_bridge_chip_up$13 == 0))
          goto bugout;

      }

      else
      {
        signed int return_value_write_ecp_channel$14;
        return_value_write_ecp_channel$14=write_ecp_channel(&fd_table[(signed long int)fd], 77);
        if(!(return_value_write_ecp_channel$14 == 0))
          goto bugout;

      }
    }

    if((signed int)pd->io_mode == HPMUD_DOT4_PHOENIX_MODE)
      write_phoenix_setup(&fd_table[(signed long int)fd]);

    unsigned int i;
    signed int return_value_Dot4Init$15;
    return_value_Dot4Init$15=Dot4Init(pc, (signed int)fd);
    if(!(return_value_Dot4Init$15 == 0))
      goto bugout;

    i = (unsigned int)0;
    for( ; !(i >= 47u); i = i + 1u)
      memset((void *)&pd->channel[(signed long int)i].ta, 0, sizeof(struct anonymous$16) /*8ul*/ );
    pd->mlc_fd = (signed int)fd;
    pd->mlc_up = 1;
  }

  signed int return_value_Dot4GetSocket$16;
  return_value_Dot4GetSocket$16=Dot4GetSocket(pc, pd->mlc_fd);
  signed int return_value_Dot4OpenChannel$17;
  if(return_value_Dot4GetSocket$16 == 0)
  {
    return_value_Dot4OpenChannel$17=Dot4OpenChannel(pc, pd->mlc_fd);
    if(return_value_Dot4OpenChannel$17 == 0)
    {
      if((signed int)pd->io_mode == HPMUD_DOT4_PHOENIX_MODE)
      {
        signed int return_value_Dot4Credit$18;
        return_value_Dot4Credit$18=Dot4Credit(pc, pd->mlc_fd, (unsigned short int)2);
        if(!(return_value_Dot4Credit$18 == 0))
        {
          syslog(3, "io/hpmud/musb.c 1859: invalid Dot4Credit to peripheral\n");
          goto bugout;
        }

      }

      pc->rindex = 0;
      pc->rcnt = pc->rindex;
      stat = (enum HPMUD_RESULT)HPMUD_R_OK;
    }

  }


bugout:
  ;
  return stat;
}

// musb_dot4_channel_read
// file io/hpmud/musb.h line 127
enum HPMUD_RESULT musb_dot4_channel_read(struct _mud_channel *pc, void *buf, signed int length, signed int sec_timeout, signed int *bytes_read)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  *bytes_read = 0;
  if((signed int)pc->ta.p2hsize == 0)
    syslog(3, "io/hpmud/musb.c 1999: invalid channel_read state\n");

  else
    if(!(pc->rcnt == 0))
    {
      stat = (enum HPMUD_RESULT)HPMUD_R_OK;
      *bytes_read=cut_buf(pc, (char *)buf, length);
    }

    else
    {
      if((signed int)pc->ta.p2hcredit == 0)
      {
        signed int return_value_Dot4Credit$1;
        return_value_Dot4Credit$1=Dot4Credit(pc, pd->mlc_fd, (unsigned short int)1);
        if(!(return_value_Dot4Credit$1 == 0))
          goto bugout;

      }

      stat = (enum HPMUD_RESULT)HPMUD_R_OK;
      pc->rcnt=Dot4ReverseData(pc, pd->mlc_fd, (void *)pc->rbuf, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ , sec_timeout * 1000000);
      if(!(pc->rcnt == 0))
        pc->ta.p2hcredit = pc->ta.p2hcredit - 1;

      *bytes_read=cut_buf(pc, (char *)buf, length);
    }

bugout:
  ;
  return stat;
}

// musb_dot4_channel_write
// file io/hpmud/musb.h line 126
enum HPMUD_RESULT musb_dot4_channel_write(struct _mud_channel *pc, const void *buf, signed int length, signed int sec_timeout, signed int *bytes_wrote)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  signed int ret;
  signed int len;
  signed int size;
  signed int dlen;
  signed int total = 0;
  signed int cnt = 0;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  *bytes_wrote = 0;
  size = length;
  dlen = (signed int)((unsigned long int)pc->ta.h2psize - sizeof(struct anonymous) /*6ul*/ );
  while(size >= 1)
  {
    len = size > dlen ? dlen : size;
    if((signed int)pc->ta.h2pcredit == 0)
    {
      if((signed int)pd->io_mode == HPMUD_DOT4_PHOENIX_MODE)
      {
        signed int return_value_Dot4CreditRequest$1;
        return_value_Dot4CreditRequest$1=Dot4CreditRequest(pc, pd->mlc_fd, (unsigned short int)1);
        if(!(return_value_Dot4CreditRequest$1 == 0))
        {
          syslog(3, "io/hpmud/musb.c 1932: invalid Dot4CreditRequest from peripheral\n");
          goto bugout;
        }

        if((signed int)pc->ta.h2pcredit == 0)
        {
          signed int tmp_post$2 = cnt;
          cnt = cnt + 1;
          if(tmp_post$2 >= 46)
          {
            syslog(3, "io/hpmud/musb.c 1939: invalid Dot4CreditRequest from peripheral\n");
            goto bugout;
          }

          sleep((unsigned int)1);
          continue;
        }

      }

    }

    if((signed int)pc->ta.h2pcredit == 0)
    {
      ret=Dot4ReverseCmd(pc, pd->mlc_fd);
      if((signed int)pc->ta.h2pcredit == 0)
      {
        if(ret == 0)
          continue;

        syslog(3, "io/hpmud/musb.c 1955: invalid Dot4Credit from peripheral\n");
        goto bugout;
      }

    }

    signed int return_value_Dot4ForwardData$3;
    return_value_Dot4ForwardData$3=Dot4ForwardData(pc, pd->mlc_fd, buf + (signed long int)total, len, sec_timeout * 1000000);
    if(!(return_value_Dot4ForwardData$3 == 0))
      goto bugout;

    pc->ta.h2pcredit = pc->ta.h2pcredit - 1;
    size = size - len;
    total = total + len;
    *bytes_wrote = *bytes_wrote + len;
    cnt = 0;
  }
  stat = (enum HPMUD_RESULT)HPMUD_R_OK;

bugout:
  ;
  return stat;
}

// musb_get_device_id
// file io/hpmud/musb.c line 1217
enum HPMUD_RESULT musb_get_device_id(struct _mud_device *pd, char *buf, signed int size, signed int *len)
{
  signed int i;
  signed int fd = FD_NA;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_DEVICE_BUSY;
  *len = 0;
  pthread_mutex_lock(&pd->mutex);
  _Bool tmp_if_expr$3;
  if((signed int)pd->io_mode == HPMUD_DOT4_BRIDGE_MODE)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = (signed int)pd->io_mode == HPMUD_UNI_MODE ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(pd->id);
    *len = (signed int)return_value_strlen$1;
  }

  else
  {
    i = 1;
    for( ; !(i >= MAX_FD); i = i + 1)
      if(!(fd_table[(signed long int)i].hd == ((struct libusb_device_handle *)NULL)))
      {
        fd = i;
        break;
      }

    if(fd == FD_NA)
    {
      fd=claim_id_interface(libusb_dev);
      if(!(fd == MAX_FD))
      {
        *len=device_id$link2(fd, (unsigned char *)pd->id, (signed int)sizeof(char [1024l]) /*1024ul*/ );
        release_interface(&fd_table[(signed long int)fd]);
      }

      else
      {
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(pd->id);
        *len = (signed int)return_value_strlen$2;
      }
    }

    else
      *len=device_id$link2(fd, (unsigned char *)pd->id, (signed int)sizeof(char [1024l]) /*1024ul*/ );
  }
  if(!(*len == 0))
  {
    signed int tmp_if_expr$4;
    if(!(size >= *len))
      tmp_if_expr$4 = size;

    else
      tmp_if_expr$4 = *len;
    memcpy((void *)buf, (const void *)pd->id, (unsigned long int)tmp_if_expr$4);
    stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  }

  pthread_mutex_unlock(&pd->mutex);
  return stat;
}

// musb_get_device_status
// file io/hpmud/musb.c line 1273
enum HPMUD_RESULT musb_get_device_status(struct _mud_device *pd, unsigned int *status)
{
  signed int i;
  signed int fd = FD_NA;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_DEVICE_BUSY;
  signed int r = 1;
  pthread_mutex_lock(&pd->mutex);
  _Bool tmp_if_expr$1;
  if((signed int)pd->io_mode == HPMUD_DOT4_BRIDGE_MODE)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)pd->io_mode == HPMUD_UNI_MODE ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    *status = (unsigned int)0x08;

  else
  {
    i = 1;
    for( ; !(i >= MAX_FD); i = i + 1)
      if(!(fd_table[(signed long int)i].hd == ((struct libusb_device_handle *)NULL)))
      {
        fd = i;
        break;
      }

    if(fd == FD_NA)
    {
      fd=claim_id_interface(libusb_dev);
      if(!(fd == MAX_FD))
      {
        r=device_status$link1(fd, status);
        release_interface(&fd_table[(signed long int)fd]);
      }

    }

    else
      r=device_status$link1(fd, status);
  }
  pthread_mutex_unlock(&pd->mutex);
  if(r == 0)
    stat = (enum HPMUD_RESULT)HPMUD_R_OK;


bugout:
  ;
  return stat;
}

// musb_mlc_channel_close
// file io/hpmud/musb.c line 1639
enum HPMUD_RESULT musb_mlc_channel_close(struct _mud_channel *pc)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  unsigned char nullByte = (unsigned char)0;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  if(!(pd->mlc_up == 0))
  {
    signed int return_value_MlcCloseChannel$1;
    return_value_MlcCloseChannel$1=MlcCloseChannel(pc, pd->mlc_fd);
    if(!(return_value_MlcCloseChannel$1 == 0))
      stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;

  }

  if(pd->channel_cnt == 1)
  {
    if(!(pd->mlc_up == 0))
    {
      signed int return_value_MlcExit$2;
      return_value_MlcExit$2=MlcExit(pc, pd->mlc_fd);
      if(!(return_value_MlcExit$2 == 0))
        stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;

    }

    pd->mlc_up = 0;
    if(pd->mlc_fd == FD_7_1_2)
    {
      write_ecp_channel(&fd_table[(signed long int)pd->mlc_fd], 78);
      pd->vf.write(pd->mlc_fd, (const void *)&nullByte, 1, 45000000);
      write_ecp_channel(&fd_table[(signed long int)pd->mlc_fd], 0);
    }

    release_interface(&fd_table[(signed long int)pd->mlc_fd]);
    sleep((unsigned int)1);
  }

  return stat;
}

// musb_mlc_channel_open
// file io/hpmud/musb.c line 1580
enum HPMUD_RESULT musb_mlc_channel_open(struct _mud_channel *pc)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  enum FD_ID fd;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  signed int return_value_claim_interface$11;
  signed int return_value_get_interface$7;
  signed int return_value_claim_interface$8;
  signed int return_value_get_interface$4;
  signed int return_value_claim_interface$5;
  signed int return_value_get_interface$1;
  signed int return_value_claim_interface$2;
  if(pd->channel_cnt == 1)
  {
    signed int return_value_get_interface$10;
    return_value_get_interface$10=get_interface(libusb_dev, (enum FD_ID)FD_7_1_3, &fd_table[(signed long int)FD_7_1_3]);
    _Bool tmp_if_expr$12;
    if(return_value_get_interface$10 == 0)
    {
      return_value_claim_interface$11=claim_interface(libusb_dev, &fd_table[(signed long int)FD_7_1_3]);
      tmp_if_expr$12 = return_value_claim_interface$11 == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$12 = (_Bool)0;
    if(tmp_if_expr$12)
      fd = (enum FD_ID)FD_7_1_3;

    else
    {
      return_value_get_interface$7=get_interface(libusb_dev, (enum FD_ID)FD_ff_ff_ff, &fd_table[(signed long int)FD_ff_ff_ff]);
      _Bool tmp_if_expr$9;
      if(return_value_get_interface$7 == 0)
      {
        return_value_claim_interface$8=claim_interface(libusb_dev, &fd_table[(signed long int)FD_ff_ff_ff]);
        tmp_if_expr$9 = return_value_claim_interface$8 == 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$9 = (_Bool)0;
      if(tmp_if_expr$9)
        fd = (enum FD_ID)FD_ff_ff_ff;

      else
      {
        return_value_get_interface$4=get_interface(libusb_dev, (enum FD_ID)FD_ff_d4_0, &fd_table[(signed long int)FD_ff_d4_0]);
        _Bool tmp_if_expr$6;
        if(return_value_get_interface$4 == 0)
        {
          return_value_claim_interface$5=claim_interface(libusb_dev, &fd_table[(signed long int)FD_ff_d4_0]);
          tmp_if_expr$6 = return_value_claim_interface$5 == 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$6 = (_Bool)0;
        if(tmp_if_expr$6)
          fd = (enum FD_ID)FD_ff_d4_0;

        else
        {
          return_value_get_interface$1=get_interface(libusb_dev, (enum FD_ID)FD_7_1_2, &fd_table[(signed long int)FD_7_1_2]);
          _Bool tmp_if_expr$3;
          if(return_value_get_interface$1 == 0)
          {
            return_value_claim_interface$2=claim_interface(libusb_dev, &fd_table[(signed long int)FD_7_1_2]);
            tmp_if_expr$3 = return_value_claim_interface$2 == 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$3 = (_Bool)0;
          if(tmp_if_expr$3)
            fd = (enum FD_ID)FD_7_1_2;

          else
          {
            stat = (enum HPMUD_RESULT)HPMUD_R_DEVICE_BUSY;
            goto bugout;
          }
        }
      }
    }
    if((signed int)fd == FD_7_1_2)
    {
      signed int return_value_write_ecp_channel$13;
      return_value_write_ecp_channel$13=write_ecp_channel(&fd_table[(signed long int)fd], 77);
      if(!(return_value_write_ecp_channel$13 == 0))
        goto bugout;

    }

    unsigned int i;
    signed int return_value_MlcInit$14;
    return_value_MlcInit$14=MlcInit(pc, (signed int)fd);
    if(!(return_value_MlcInit$14 == 0))
      goto bugout;

    i = (unsigned int)0;
    for( ; !(i >= 47u); i = i + 1u)
      memset((void *)&pd->channel[(signed long int)i].ta, 0, sizeof(struct anonymous$16) /*8ul*/ );
    pd->mlc_fd = (signed int)fd;
    pd->mlc_up = 1;
  }

  signed int return_value_MlcConfigSocket$15;
  return_value_MlcConfigSocket$15=MlcConfigSocket(pc, pd->mlc_fd);
  signed int return_value_MlcOpenChannel$16;
  if(return_value_MlcConfigSocket$15 == 0)
  {
    return_value_MlcOpenChannel$16=MlcOpenChannel(pc, pd->mlc_fd);
    if(return_value_MlcOpenChannel$16 == 0)
    {
      pc->rindex = 0;
      pc->rcnt = pc->rindex;
      stat = (enum HPMUD_RESULT)HPMUD_R_OK;
    }

  }


bugout:
  ;
  return stat;
}

// musb_mlc_channel_read
// file io/hpmud/musb.h line 122
enum HPMUD_RESULT musb_mlc_channel_read(struct _mud_channel *pc, void *buf, signed int length, signed int sec_timeout, signed int *bytes_read)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  *bytes_read = 0;
  if((signed int)pc->ta.p2hsize == 0)
    syslog(3, "io/hpmud/musb.c 1758: invalid channel_read state\n");

  else
    if(!(pc->rcnt == 0))
    {
      stat = (enum HPMUD_RESULT)HPMUD_R_OK;
      *bytes_read=cut_buf(pc, (char *)buf, length);
    }

    else
    {
      if((signed int)pc->ta.p2hcredit == 0)
      {
        signed int return_value_MlcCredit$1;
        return_value_MlcCredit$1=MlcCredit(pc, pd->mlc_fd, (unsigned short int)1);
        if(!(return_value_MlcCredit$1 == 0))
          goto bugout;

      }

      stat = (enum HPMUD_RESULT)HPMUD_R_OK;
      pc->rcnt=MlcReverseData(pc, pd->mlc_fd, (void *)pc->rbuf, (signed int)sizeof(unsigned char [16384l]) /*16384ul*/ , sec_timeout * 1000000);
      if(!(pc->rcnt == 0))
        pc->ta.p2hcredit = pc->ta.p2hcredit - 1;

      *bytes_read=cut_buf(pc, (char *)buf, length);
    }

bugout:
  ;
  return stat;
}

// musb_mlc_channel_write
// file io/hpmud/musb.h line 121
enum HPMUD_RESULT musb_mlc_channel_write(struct _mud_channel *pc, const void *buf, signed int length, signed int sec_timeout, signed int *bytes_wrote)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  signed int ret;
  signed int len;
  signed int size;
  signed int dlen;
  signed int total = 0;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  *bytes_wrote = 0;
  size = length;
  dlen = (signed int)((unsigned long int)pc->ta.h2psize - sizeof(struct anonymous$21) /*6ul*/ );
  while(size >= 1)
  {
    len = size > dlen ? dlen : size;
    if((signed int)pc->ta.h2pcredit == 0)
    {
      if((signed int)pd->io_mode == HPMUD_MLC_MISER_MODE)
      {
        signed int return_value_MlcCreditRequest$1;
        return_value_MlcCreditRequest$1=MlcCreditRequest(pc, pd->mlc_fd, (unsigned short int)1);
        if(!(return_value_MlcCreditRequest$1 == 0))
        {
          syslog(3, "io/hpmud/musb.c 1694: invalid MlcCreditRequest from peripheral\n");
          goto bugout;
        }

      }

    }

    if((signed int)pc->ta.h2pcredit == 0)
    {
      ret=MlcReverseCmd(pc, pd->mlc_fd);
      if((signed int)pc->ta.h2pcredit == 0)
      {
        if(ret == 0)
          continue;

        if(!((signed int)pd->io_mode == HPMUD_MLC_MISER_MODE))
        {
          syslog(3, "io/hpmud/musb.c 1710: invalid MlcCredit from peripheral, trying miser\n");
          pd->io_mode = (enum HPMUD_IO_MODE)HPMUD_MLC_MISER_MODE;
          continue;
        }

        syslog(3, "io/hpmud/musb.c 1715: invalid MlcCredit from peripheral\n");
        goto bugout;
      }

    }

    signed int return_value_MlcForwardData$2;
    return_value_MlcForwardData$2=MlcForwardData(pc, pd->mlc_fd, buf + (signed long int)total, len, sec_timeout * 1000000);
    if(!(return_value_MlcForwardData$2 == 0))
      goto bugout;

    pc->ta.h2pcredit = pc->ta.h2pcredit - 1;
    size = size - len;
    total = total + len;
    *bytes_wrote = *bytes_wrote + len;
  }
  stat = (enum HPMUD_RESULT)HPMUD_R_OK;

bugout:
  ;
  return stat;
}

// musb_open
// file io/hpmud/musb.c line 1143
enum HPMUD_RESULT musb_open(struct _mud_device *pd)
{
  signed int len = 0;
  signed int fd = 0;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  libusb_dev=get_libusb_device(pd->uri);
  signed int return_value_is_hp$1;
  if(libusb_dev == ((struct libusb_device *)NULL))
    syslog(3, "io/hpmud/musb.c 1151: unable to open %s\n", (const void *)pd->uri);

  else
  {
    pthread_mutex_lock(&pd->mutex);
    if((signed int)pd->id[0l] == 0)
    {
      fd=claim_id_interface(libusb_dev);
      if(fd == MAX_FD)
      {
        stat = (enum HPMUD_RESULT)HPMUD_R_DEVICE_BUSY;
        goto blackout;
      }

      len=device_id$link2(fd, (unsigned char *)pd->id, (signed int)sizeof(char [1024l]) /*1024ul*/ );
      if(len >= 1)
      {
        return_value_is_hp$1=is_hp(pd->id);
        if(!(return_value_is_hp$1 == 0))
          power_up(pd, fd);

      }

      release_interface(&fd_table[(signed long int)fd]);
      if(len == 0)
        goto blackout;

      pd->open_fd = fd;
    }

    stat = (enum HPMUD_RESULT)HPMUD_R_OK;

  blackout:
    ;
    pthread_mutex_unlock(&pd->mutex);
  }

bugout:
  ;
  return stat;
}

// musb_probe_devices
// file io/hpmud/musb.h line 129
signed int musb_probe_devices(char *lst, signed int lst_size, signed int *cnt, enum HPMUD_DEVICE_TYPE devtype)
{
  struct libusb_context *ctx = (struct libusb_context *)(void *)0;
  struct libusb_device **list;
  struct libusb_device *dev = (struct libusb_device *)(void *)0;
  struct libusb_device_descriptor devdesc;
  struct libusb_config_descriptor *confptr = (struct libusb_config_descriptor *)(void *)0;
  struct libusb_interface *ifaceptr = (struct libusb_interface *)(void *)0;
  struct libusb_interface_descriptor *altptr = (struct libusb_interface_descriptor *)(void *)0;
  struct libusb_device_handle *hd = (struct libusb_device_handle *)(void *)0;
  signed int numdevs = 0;
  signed int i;
  signed int conf;
  signed int iface;
  signed int altset;
  signed int dev_already_counted = 0;
  struct hpmud_model_attributes ma;
  char rmodel[128l];
  char rserial[128l];
  char model[128l];
  char serial[128l];
  char mfg[128l];
  char sz[256l];
  signed int r;
  signed int size = 0;
  i=libusb_init(&ctx);
  signed long int return_value_libusb_get_device_list$1;
  _Bool tmp_if_expr$3;
  signed int return_value_snprintf$4;
  signed int return_value_snprintf$5;
  if(i == 0)
  {
    return_value_libusb_get_device_list$1=libusb_get_device_list(ctx, &list);
    numdevs = (signed int)return_value_libusb_get_device_list$1;
    if(numdevs >= 1)
    {
      mfg[(signed long int)0] = (char)0;
      sz[(signed long int)0] = mfg[(signed long int)0];
      rserial[(signed long int)0] = sz[(signed long int)0];
      rmodel[(signed long int)0] = rserial[(signed long int)0];
      serial[(signed long int)0] = rmodel[(signed long int)0];
      model[(signed long int)0] = serial[(signed long int)0];
      i = 0;
      for( ; !(i >= numdevs); i = i + 1)
      {
        dev = list[(signed long int)i];
        dev_already_counted = 0;
        libusb_get_device_descriptor(dev, &devdesc);
        if(!(devdesc.idProduct == 0) && !(devdesc.idVendor == 0) && !(devdesc.bNumConfigurations == 0))
        {
          if((signed int)devdesc.idVendor == 0x3f0)
          {
            conf = 0;
            for( ; dev_already_counted == 0 && !(conf >= (signed int)devdesc.bNumConfigurations); conf = conf + 1)
            {
              signed int return_value_libusb_get_config_descriptor$2;
              return_value_libusb_get_config_descriptor$2=libusb_get_config_descriptor(dev, (unsigned char)conf, &confptr);
              if(return_value_libusb_get_config_descriptor$2 >= 0)
              {
                iface = 0;
                ifaceptr = confptr->interface;
                do
                {
                  if(dev_already_counted == 0)
                    tmp_if_expr$3 = iface < (signed int)confptr->bNumInterfaces ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$3 = (_Bool)0;
                  if(!tmp_if_expr$3)
                    break;

                  altset = 0;
                  altptr = ifaceptr->altsetting;
                  for( ; !(altset >= ifaceptr->num_altsetting); altptr = altptr + 1l)
                  {
                    if((signed int)altptr->bInterfaceClass == 7)
                    {
                      if((signed int)devtype == HPMUD_PRINTER)
                      {
                        if(!((signed int)altptr->bInterfaceProtocol == 0x02))
                          goto __CPROVER_DUMP_L20;

                      }

                      libusb_open(dev, &hd);
                      if(hd == ((struct libusb_device_handle *)NULL))
                        syslog(3, "io/hpmud/musb.c 2095: Invalid usb_open: %m\n");

                      else
                      {
                        r=get_string_descriptor(hd, (signed int)devdesc.iProduct, rmodel, sizeof(char [128l]) /*128ul*/ );
                        if(!(r >= 0))
                          syslog(3, "io/hpmud/musb.c 2100: invalid product id string ret=%d\n", r);

                        else
                          generalize_model(rmodel, model, (signed int)sizeof(char [128l]) /*128ul*/ );
                        r=get_string_descriptor(hd, (signed int)devdesc.iSerialNumber, rserial, sizeof(char [128l]) /*128ul*/ );
                        if(!(r >= 0))
                          syslog(3, "io/hpmud/musb.c 2105: invalid serial id string ret=%d\n", r);

                        else
                          generalize_serial(rserial, serial, (signed int)sizeof(char [128l]) /*128ul*/ );
                        r=get_string_descriptor(hd, (signed int)devdesc.iManufacturer, sz, sizeof(char [256l]) /*256ul*/ );
                        if(!(r >= 0))
                          syslog(3, "io/hpmud/musb.c 2110: invalid manufacturer string ret=%d\n", r);

                        else
                          generalize_serial(sz, mfg, (signed int)sizeof(char [128l]) /*128ul*/ );
                        if(serial[0l] == 0)
                          strcpy(serial, "0");

                        if(!(model[0l] == 0))
                        {
                          snprintf(sz, sizeof(char [256l]) /*256ul*/ , "hp:/usb/%s?serial=%s", (const void *)model, (const void *)serial);
                          hpmud_query_model(sz, &ma);
                          if(!((signed int)ma.support == HPMUD_SUPPORT_TYPE_HPLIP))
                          {
                            syslog(3, "io/hpmud/musb.c 2125: ignoring %s support=%d\n", (const void *)sz, ma.support);
                            goto __CPROVER_DUMP_L20;
                          }

                          signed int return_value_strncasecmp$6;
                          return_value_strncasecmp$6=strncasecmp(rmodel, "hp ", (unsigned long int)3);
                          if(return_value_strncasecmp$6 == 0)
                          {
                            return_value_snprintf$4=snprintf(lst + (signed long int)size, (unsigned long int)(lst_size - size), "direct %s \"HP %s\" \"HP %s USB %s HPLIP\" \"MFG:%s;MDL:%s;CLS:PRINTER;DES:%s;SN:%s;\"\n", (const void *)sz, &rmodel[(signed long int)3], &rmodel[(signed long int)3], (const void *)serial, (const void *)mfg, (const void *)rmodel, (const void *)rmodel, (const void *)rserial);
                            size = size + return_value_snprintf$4;
                          }

                          else
                          {
                            return_value_snprintf$5=snprintf(lst + (signed long int)size, (unsigned long int)(lst_size - size), "direct %s \"HP %s\" \"HP %s USB %s HPLIP\" \"MFG:%s;MDL:%s;CLS:PRINTER;DES:%s;SN:%s;\"\n", (const void *)sz, (const void *)rmodel, (const void *)rmodel, (const void *)serial, (const void *)mfg, (const void *)rmodel, (const void *)rmodel, (const void *)rserial);
                            size = size + return_value_snprintf$5;
                          }
                          *cnt = *cnt + 1;
                        }

                        libusb_close(hd);
                        hd = (struct libusb_device_handle *)(void *)0;
                        dev_already_counted = 1;
                        break;
                      }
                    }


                  __CPROVER_DUMP_L20:
                    ;
                    altset = altset + 1;
                  }
                  iface = iface + 1;
                  ifaceptr = ifaceptr + 1l;
                }
                while((_Bool)1);
                libusb_free_config_descriptor(confptr);
                confptr = (struct libusb_config_descriptor *)(void *)0;
              }

            }
          }

        }

      }
    }

  }


bugout:
  ;
  if(!(hd == ((struct libusb_device_handle *)NULL)))
    libusb_close(hd);

  if(!(confptr == ((struct libusb_config_descriptor *)NULL)))
    libusb_free_config_descriptor(confptr);

  if(!(list == ((struct libusb_device **)NULL)))
    libusb_free_device_list(list, 1);

  if(!(ctx == ((struct libusb_context *)NULL)))
    libusb_exit(ctx);

  return size;
}

// musb_raw_channel_close
// file io/hpmud/musb.c line 1414
enum HPMUD_RESULT musb_raw_channel_close(struct _mud_channel *pc)
{
  signed int fd = pc->fd;
  signed int ep = -1;
  ep=get_in_ep(libusb_dev, fd_table[(signed long int)fd].config, fd_table[(signed long int)fd].interface, fd_table[(signed long int)fd].alt_setting, (enum libusb_transfer_type)LIBUSB_TRANSFER_TYPE_BULK);
  ep=get_out_ep(libusb_dev, fd_table[(signed long int)fd].config, fd_table[(signed long int)fd].interface, fd_table[(signed long int)fd].alt_setting, (enum libusb_transfer_type)LIBUSB_TRANSFER_TYPE_BULK);
  release_interface(&fd_table[(signed long int)fd]);
  pc->fd = 0;
  return (enum HPMUD_RESULT)HPMUD_R_OK;
}

// musb_raw_channel_open
// file io/hpmud/musb.c line 1396
enum HPMUD_RESULT musb_raw_channel_open(struct _mud_channel *pc)
{
  signed int fd = FD_7_1_2;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_DEVICE_BUSY;
  get_interface(libusb_dev, (enum FD_ID)fd, &fd_table[(signed long int)fd]);
  signed int return_value_claim_interface$1;
  return_value_claim_interface$1=claim_interface(libusb_dev, &fd_table[(signed long int)fd]);
  if(return_value_claim_interface$1 == 0)
  {
    pc->fd = fd;
    stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  }


bugout:
  ;
  return stat;
}

// musb_raw_channel_read
// file io/hpmud/musb.h line 115
enum HPMUD_RESULT musb_raw_channel_read(struct _mud_channel *pc, void *buf, signed int length, signed int sec_timeout, signed int *bytes_read)
{
  signed int len = 0;
  signed int usec;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  *bytes_read = 0;
  if(sec_timeout == 0)
    usec = 1000;

  else
    usec = sec_timeout * 1000000;
  len=msp->device[(signed long int)pc->dindex].vf.read(pc->fd, buf, length, usec);
  if(!(len >= 0))
  {
    if(len == -110)
    {
      stat = (enum HPMUD_RESULT)HPMUD_R_IO_TIMEOUT;
      if(sec_timeout >= 45)
        syslog(3, "io/hpmud/musb.c 1494: unable to read data %s: %d second io timeout\n", (const void *)msp->device[(signed long int)pc->dindex].uri, sec_timeout);

    }

    else
      syslog(3, "io/hpmud/musb.c 1497: unable to read data %s: %m\n", (const void *)msp->device[(signed long int)pc->dindex].uri);
  }

  else
  {
    *bytes_read = len;
    stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  }

bugout:
  ;
  return stat;
}

// musb_raw_channel_write
// file io/hpmud/musb.h line 114
enum HPMUD_RESULT musb_raw_channel_write(struct _mud_channel *pc, const void *buf, signed int length, signed int sec_timeout, signed int *bytes_wrote)
{
  signed int len;
  signed int size;
  signed int total = 0;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  *bytes_wrote = 0;
  size = length;
  if(size >= 1)
  {
    len=msp->device[(signed long int)pc->dindex].vf.write(pc->fd, buf + (signed long int)total, size, sec_timeout * 1000000);
    if(!(len >= 0))
    {
      if(len == -110)
      {
        stat = (enum HPMUD_RESULT)HPMUD_R_IO_TIMEOUT;
        if(sec_timeout >= 45)
          syslog(3, "io/hpmud/musb.c 1454: unable to write data %s: %d second io timeout\n", (const void *)msp->device[(signed long int)pc->dindex].uri, sec_timeout);

      }

      else
        syslog(3, "io/hpmud/musb.c 1457: unable to write data (len = %d) %s: %m\n", (const void *)msp->device[(signed long int)pc->dindex].uri, len);
    }

    size = size - len;
    total = total + len;
    *bytes_wrote = *bytes_wrote + len;
  }

  stat = (enum HPMUD_RESULT)HPMUD_R_OK;

bugout:
  ;
  return stat;
}

// musb_read
// file io/hpmud/musb.c line 1083
signed int musb_read(signed int fd, void *buf, signed int size, signed int usec)
{
  struct timeval t1;
  struct timeval t2;
  signed int total_usec;
  signed int tmo_usec = usec;
  signed int len = -5;
  signed int ep;
  if(fd_table[(signed long int)fd].hd == ((struct libusb_device_handle *)NULL))
    syslog(3, "io/hpmud/musb.c 1091: invalid musb_read state\n");

  else
  {
    gettimeofday(&t1, (struct timezone *)(void *)0);
    ep=get_in_ep(libusb_dev, fd_table[(signed long int)fd].config, fd_table[(signed long int)fd].interface, fd_table[(signed long int)fd].alt_setting, (enum libusb_transfer_type)LIBUSB_TRANSFER_TYPE_BULK);
    if(!(ep >= 0))
      syslog(3, "io/hpmud/musb.c 1100: invalid bulk in endpoint\n");

    else
      while((_Bool)1)
      {
        len=libusb_bulk_read(fd_table[(signed long int)fd].hd, ep, (char *)buf, size, tmo_usec / 1000);
        if(len == -110)
          break;

        if(!(len >= 0))
        {
          syslog(3, "io/hpmud/musb.c 1113: bulk_read failed: %m\n");
          break;
        }

        if(len == 0)
        {
          gettimeofday(&t2, (struct timezone *)(void *)0);
          total_usec = (signed int)((t2.tv_sec - t1.tv_sec) * (signed long int)1000000);
          total_usec = total_usec + (signed int)(t2.tv_usec > t1.tv_usec ? t2.tv_usec - t1.tv_usec : t1.tv_usec - t2.tv_usec);
          if(!(usec >= total_usec))
          {
            len = -110;
            break;
          }

          tmo_usec = usec - total_usec;
        }

        else
          break;
      }
  }

bugout:
  ;
  return len;
}

// musb_write
// file io/hpmud/musb.c line 1009
signed int musb_write(signed int fd, const void *buf, signed int size, signed int usec)
{
  signed int len = -5;
  struct timeval now;
  struct timespec timeout;
  signed int ret;
  if(fd_table[(signed long int)fd].hd == ((struct libusb_device_handle *)NULL))
    syslog(3, "io/hpmud/musb.c 1015: invalid musb_write state\n");

  else
  {
    if(fd_table[(signed long int)fd].write_active == 0)
    {
      fd_table[(signed long int)fd].write_active = 1;
      fd_table[(signed long int)fd].write_buf = buf;
      fd_table[(signed long int)fd].write_size = size;
      signed int return_value_pthread_create$1;
      return_value_pthread_create$1=pthread_create(&fd_table[(signed long int)fd].tid, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))write_thread, (void *)&fd_table[(signed long int)fd]);
      if(!(return_value_pthread_create$1 == 0))
      {
        syslog(3, "io/hpmud/musb.c 1033: unable to creat write_thread: %m\n");
        goto bugout;
      }

    }

    pthread_mutex_lock(&fd_table[(signed long int)fd].mutex);
    gettimeofday(&now, (struct timezone *)(void *)0);
    now.tv_usec = now.tv_usec + (signed long int)usec;
    now.tv_sec = now.tv_sec + now.tv_usec / (signed long int)1000000;
    now.tv_usec = now.tv_usec % (signed long int)1000000;
    timeout.tv_sec = now.tv_sec;
    timeout.tv_nsec = now.tv_usec * (signed long int)1000;
    ret = 0;
    while(!(fd_table[(signed long int)fd].write_buf == NULL))
    {
      if(ret == 110)
        break;

      ret=pthread_cond_timedwait(&fd_table[(signed long int)fd].write_done_cond, &fd_table[(signed long int)fd].mutex, &timeout);
    }
    pthread_mutex_unlock(&fd_table[(signed long int)fd].mutex);
    if(ret == 110)
      len = -110;

    else
    {
      fd_table[(signed long int)fd].write_active = 0;
      len = fd_table[(signed long int)fd].write_return;
      if(!(len >= 0))
        syslog(3, "io/hpmud/musb.c 1073: bulk_write failed buf=%p size=%d len=%d: %m\n", buf, size, len);

    }
  }

bugout:
  ;
  return len;
}

// new_channel
// file io/hpmud/jd.c line 101
static signed int new_channel(struct _mud_device *pd, signed int index, const char *sn)
{
  signed int stat = 1;
  if(!(pd->channel[(signed long int)index].client_cnt == 0))
    syslog(3, "io/hpmud/jd.c 117: %s channel=%d is busy, used by [%d], clientCnt=%d channelCnt=%d\n", sn, index, pd->channel[(signed long int)index].pid, pd->channel[(signed long int)index].client_cnt, pd->channel_cnt);

  else
  {
    pd->channel[(signed long int)index].vf = jd_channel_vf;
    pd->channel[(signed long int)index].index = index;
    pd->channel[(signed long int)index].client_cnt = 1;
    pd->channel[(signed long int)index].sockid = (unsigned char)index;
    pd->channel[(signed long int)index].pid=getpid();
    pd->channel[(signed long int)index].dindex = pd->index;
    pd->channel[(signed long int)index].fd = 0;
    pd->channel[(signed long int)index].socket = -1;
    strcpy(pd->channel[(signed long int)index].sn, sn);
    pd->channel_cnt = pd->channel_cnt + 1;
    stat = 0;
  }

bugout:
  ;
  return stat;
}

// new_channel$link1
// file io/hpmud/pp.c line 667
static signed int new_channel$link1(struct _mud_device *pd$link1, signed int index$link1, const char *sn$link1)
{
  signed int stat$link1 = 1;
  if(!(pd$link1->channel[(signed long int)index$link1].client_cnt == 0))
    syslog(3, "io/hpmud/pp.c 683: %s channel=%d is busy, used by [%d], clientCnt=%d channelCnt=%d\n", sn$link1, index$link1, pd$link1->channel[(signed long int)index$link1].pid, pd$link1->channel[(signed long int)index$link1].client_cnt, pd$link1->channel_cnt);

  else
  {
    _Bool tmp_if_expr$2;
    if((signed int)pd$link1->io_mode == HPMUD_RAW_MODE)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)pd$link1->io_mode == HPMUD_UNI_MODE ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      pd$link1->channel[(signed long int)index$link1].vf = pp_raw_channel_vf;

    else
    {
      _Bool tmp_if_expr$1;
      if((signed int)pd$link1->io_mode == HPMUD_MLC_GUSHER_MODE)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)pd$link1->io_mode == HPMUD_MLC_MISER_MODE ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        pd$link1->channel[(signed long int)index$link1].vf = pp_mlc_channel_vf;

      else
        pd$link1->channel[(signed long int)index$link1].vf = pp_dot4_channel_vf;
    }
    pd$link1->channel[(signed long int)index$link1].index = index$link1;
    pd$link1->channel[(signed long int)index$link1].client_cnt = 1;
    pd$link1->channel[(signed long int)index$link1].sockid = (unsigned char)index$link1;
    pd$link1->channel[(signed long int)index$link1].pid=getpid();
    pd$link1->channel[(signed long int)index$link1].dindex = pd$link1->index;
    pd$link1->channel[(signed long int)index$link1].fd = -1;
    strcpy(pd$link1->channel[(signed long int)index$link1].sn, sn$link1);
    pd$link1->channel_cnt = pd$link1->channel_cnt + 1;
    stat$link1 = 0;
  }

bugout:
  ;
  return stat$link1;
}

// new_channel$link2
// file io/hpmud/musb.c line 922
static signed int new_channel$link2(struct _mud_device *pd$link2, signed int index$link2, const char *sn$link2)
{
  signed int stat$link2 = 1;
  if(!(pd$link2->channel[(signed long int)index$link2].client_cnt == 0))
    syslog(3, "io/hpmud/musb.c 929: %s channel=%d is busy, used by [%d], clientCnt=%d channelCnt=%d\n", sn$link2, index$link2, pd$link2->channel[(signed long int)index$link2].pid, pd$link2->channel[(signed long int)index$link2].client_cnt, pd$link2->channel_cnt);

  else
  {
    if(index$link2 == 18 || index$link2 == 19 || index$link2 == 20 || index$link2 == 21 || index$link2 == 22 || index$link2 == 23 || index$link2 == 24 || index$link2 == 25 || index$link2 == 26 || index$link2 == 45 || index$link2 == 46)
      pd$link2->channel[(signed long int)index$link2].vf = musb_comp_channel_vf;

    else
    {
      _Bool tmp_if_expr$2$link1;
      if((signed int)pd$link2->io_mode == HPMUD_RAW_MODE)
        tmp_if_expr$2$link1 = (_Bool)1;

      else
        tmp_if_expr$2$link1 = (signed int)pd$link2->io_mode == HPMUD_UNI_MODE ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2$link1)
        pd$link2->channel[(signed long int)index$link2].vf = musb_raw_channel_vf;

      else
      {
        _Bool tmp_if_expr$1$link1;
        if((signed int)pd$link2->io_mode == HPMUD_MLC_GUSHER_MODE)
          tmp_if_expr$1$link1 = (_Bool)1;

        else
          tmp_if_expr$1$link1 = (signed int)pd$link2->io_mode == HPMUD_MLC_MISER_MODE ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1$link1)
          pd$link2->channel[(signed long int)index$link2].vf = musb_mlc_channel_vf;

        else
          pd$link2->channel[(signed long int)index$link2].vf = musb_dot4_channel_vf;
      }
    }
    pd$link2->channel[(signed long int)index$link2].index = index$link2;
    pd$link2->channel[(signed long int)index$link2].client_cnt = 1;
    pd$link2->channel[(signed long int)index$link2].sockid = (unsigned char)index$link2;
    pd$link2->channel[(signed long int)index$link2].pid=getpid();
    pd$link2->channel[(signed long int)index$link2].dindex = pd$link2->index;
    pd$link2->channel[(signed long int)index$link2].fd = 0;
    strcpy(pd$link2->channel[(signed long int)index$link2].sn, sn$link2);
    pd$link2->channel_cnt = pd$link2->channel_cnt + 1;
    stat$link2 = 0;
    syslog(6, "io/hpmud/musb.c 960: new %s channel=%d clientCnt=%d channelCnt=%d\n", sn$link2, index$link2, pd$link2->channel[(signed long int)index$link2].client_cnt, pd$link2->channel_cnt);
  }

bugout:
  ;
  return stat$link2;
}

// new_device
// file io/hpmud/hpmud.c line 296
static signed int new_device(const char *uri, enum HPMUD_IO_MODE mode, signed int *result)
{
  signed int index = 0;
  signed int i = 1;
  _Bool tmp_if_expr$1;
  if(uri == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)uri[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  char *return_value_strcasestr$4;
  char *return_value_strcasestr$3;
  char *return_value_strcasestr$2;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    pthread_mutex_lock(&msp->mutex);
    if(!(msp->device[(signed long int)i].index == 0))
    {
      syslog(3, "io/hpmud/hpmud.c 308: invalid device_open state\n");
      *result = HPMUD_R_INVALID_STATE;
    }

    else
    {
      index = i;
      return_value_strcasestr$4=strcasestr(uri, ":/usb");
      if(!(return_value_strcasestr$4 == ((char *)NULL)))
        msp->device[(signed long int)i].vf = musb_mud_device_vf;

      else
      {
        return_value_strcasestr$3=strcasestr(uri, ":/net");
        if(!(return_value_strcasestr$3 == ((char *)NULL)))
          msp->device[(signed long int)i].vf = jd_mud_device_vf;

        else
        {
          return_value_strcasestr$2=strcasestr(uri, ":/par");
          if(!(return_value_strcasestr$2 == ((char *)NULL)))
            msp->device[(signed long int)i].vf = pp_mud_device_vf;

          else
          {
            syslog(3, "io/hpmud/hpmud.c 334: invalid uri %s\n", uri);
            *result = HPMUD_R_INVALID_URI;
            index = 0;
            goto bugout;
          }
        }
      }
      *result = HPMUD_R_OK;
      msp->device[(signed long int)i].io_mode = mode;
      msp->device[(signed long int)i].index = index;
      msp->device[(signed long int)i].channel_cnt = 0;
      msp->device[(signed long int)i].open_fd = -1;
      strcpy(msp->device[(signed long int)i].uri, uri);
    }

  bugout:
    ;
    pthread_mutex_unlock(&msp->mutex);
    return index;
  }
}

// nibble_read
// file io/hpmud/pp.c line 467
static signed int nibble_read(signed int fd, signed int flag, void *buffer, signed int size, signed int usec)
{
  signed int i = 0;
  unsigned char *p = (unsigned char *)buffer;
  signed int m = 0 | flag;
  signed int mc = 1 << 8;
  unsigned char status;
  ioctl(fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x91 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &mc);
  signed int return_value_ioctl$1;
  return_value_ioctl$1=ioctl(fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x91 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &m);
  if(!(return_value_ioctl$1 == 0))
    return -1;

  else
  {
    while(!(i >= size))
    {
      signed int return_value_nibble_read_data$2;
      return_value_nibble_read_data$2=nibble_read_data(fd, p + (signed long int)i);
      if(!(return_value_nibble_read_data$2 == 1))
      {
        usec = usec - 100000;
        if(usec >= 1)
          continue;

        return -110;
      }

      i = i + 1;
      status=read_status(fd);
      if(!((0x8 & (signed int)status) == 0))
      {
        frob_control(fd, (unsigned char)0x2, (unsigned char)0);
        break;
      }

    }
    return i;
  }
}

// nibble_read_data
// file io/hpmud/pp.c line 413
static signed int nibble_read_data(signed int fd, unsigned char *data)
{
  signed int len = 0;
  unsigned char nibble;
  frob_control(fd, (unsigned char)0x2, (unsigned char)0);
  signed int return_value_wait_status$1;
  return_value_wait_status$1=wait_status(fd, (unsigned char)0x40, (unsigned char)0, 100000);
  unsigned char return_value_read_status$2;
  signed int return_value_wait_status$3;
  unsigned char return_value_read_status$4;
  if(!(return_value_wait_status$1 == 0))
    len = -1;

  else
  {
    return_value_read_status$2=read_status(fd);
    nibble = (unsigned char)((signed int)return_value_read_status$2 >> 3);
    nibble = (unsigned char)(((signed int)nibble & 0x10) >> 1 | (signed int)nibble & 0x7);
    *data = nibble;
    frob_control(fd, (unsigned char)0x2, (unsigned char)0x2);
    wait_status(fd, (unsigned char)0x40, (unsigned char)0x40, 100000);
    frob_control(fd, (unsigned char)0x2, (unsigned char)0);
    return_value_wait_status$3=wait_status(fd, (unsigned char)0x40, (unsigned char)0, 100000);
    if(!(return_value_wait_status$3 == 0))
      len = -1;

    else
    {
      return_value_read_status$4=read_status(fd);
      nibble = (unsigned char)((signed int)return_value_read_status$4 >> 3);
      nibble = (unsigned char)(((signed int)nibble & 0x10) >> 1 | (signed int)nibble & 0x7);
      *data = *data | (unsigned char)((signed int)nibble << 4);
      frob_control(fd, (unsigned char)0x2, (unsigned char)0x2);
      wait_status(fd, (unsigned char)0x40, (unsigned char)0x40, 100000);
      len = 1;
    }
  }

bugout:
  ;
  return len;
}

// parse_key_value_pair
// file io/hpmud/model.c line 450
static signed int parse_key_value_pair(char *buf, signed int len, struct hpmud_model_attributes *ma)
{
  char key[256l];
  char value[256l];
  char *tail;
  char *tail2;
  signed int i = 0;
  signed int ret = HPMUD_R_OK;
  ma->prt_mode = (enum HPMUD_IO_MODE)HPMUD_RAW_MODE;
  ma->mfp_mode = (enum HPMUD_IO_MODE)HPMUD_DOT4_MODE;
  ma->scantype = (enum HPMUD_SCANTYPE)0;
  ma->statustype = (enum HPMUD_STATUSTYPE)HPMUD_STATUSTYPE_SFIELD;
  ma->support = (enum HPMUD_SUPPORT_TYPE)HPMUD_SUPPORT_TYPE_NONE;
  signed int return_value_strcasecmp$14;
  signed int return_value_strcasecmp$13;
  signed int return_value_strcasecmp$12;
  signed int return_value_strcasecmp$11;
  signed int return_value_strcasecmp$10;
  signed int return_value_strcasecmp$9;
  if(buf == ((char *)NULL))
    return HPMUD_R_OK;

  else
  {
    tail = buf;
    while(!(i >= len))
    {
      signed int return_value_GetPair$1;
      return_value_GetPair$1=GetPair(tail, len - i, key, value, &tail);
      i = i + return_value_GetPair$1;
      signed int return_value_strcasecmp$15;
      return_value_strcasecmp$15=strcasecmp(key, "io-mode");
      if(return_value_strcasecmp$15 == 0)
      {
        signed long int return_value_strtol$2;
        return_value_strtol$2=strtol(value, &tail2, 10);
        ma->prt_mode = (enum HPMUD_IO_MODE)return_value_strtol$2;
      }

      else
      {
        return_value_strcasecmp$14=strcasecmp(key, "io-mfp-mode");
        if(return_value_strcasecmp$14 == 0)
        {
          signed long int return_value_strtol$3;
          return_value_strtol$3=strtol(value, &tail2, 10);
          ma->mfp_mode = (enum HPMUD_IO_MODE)return_value_strtol$3;
        }

        else
        {
          return_value_strcasecmp$13=strcasecmp(key, "scan-type");
          if(return_value_strcasecmp$13 == 0)
          {
            signed long int return_value_strtol$4;
            return_value_strtol$4=strtol(value, &tail2, 10);
            ma->scantype = (enum HPMUD_SCANTYPE)return_value_strtol$4;
          }

          else
          {
            return_value_strcasecmp$12=strcasecmp(key, "scan-src");
            if(return_value_strcasecmp$12 == 0)
            {
              signed long int return_value_strtol$5;
              return_value_strtol$5=strtol(value, &tail2, 10);
              ma->scansrc = (enum HPMUD_SCANSRC)return_value_strtol$5;
            }

            else
            {
              return_value_strcasecmp$11=strcasecmp(key, "status-type");
              if(return_value_strcasecmp$11 == 0)
              {
                signed long int return_value_strtol$6;
                return_value_strtol$6=strtol(value, &tail2, 10);
                ma->statustype = (enum HPMUD_STATUSTYPE)return_value_strtol$6;
              }

              else
              {
                return_value_strcasecmp$10=strcasecmp(key, "support-type");
                if(return_value_strcasecmp$10 == 0)
                {
                  signed long int return_value_strtol$7;
                  return_value_strtol$7=strtol(value, &tail2, 10);
                  ma->support = (enum HPMUD_SUPPORT_TYPE)return_value_strtol$7;
                }

                else
                {
                  return_value_strcasecmp$9=strcasecmp(key, "plugin");
                  if(return_value_strcasecmp$9 == 0)
                  {
                    signed long int return_value_strtol$8;
                    return_value_strtol$8=strtol(value, &tail2, 10);
                    ma->plugin = (enum HPMUD_PLUGIN_TYPE)return_value_strtol$8;
                  }

                }
              }
            }
          }
        }
      }
    }
    return ret;
  }
}

// parse_pjl_device_status
// file prnt/backend/hp.c line 326
static signed int parse_pjl_device_status(char *buf, signed int *status)
{
  char *p;
  char *tail;
  signed int stat = 0;
  if(!((signed int)*buf == 0))
  {
    p=strcasestr(buf, "code=");
    if(!(p == ((char *)NULL)))
    {
      signed long int return_value_strtol$1;
      return_value_strtol$1=strtol(p + (signed long int)5, &tail, 10);
      *status = (signed int)return_value_strtol$1;
      stat = 1;
    }

  }


bugout:
  ;
  return stat;
}

// parse_pjl_job_end
// file prnt/backend/hp.c line 304
static signed int parse_pjl_job_end(char *buf, signed int *pages)
{
  char *p;
  char *tail;
  signed int stat = 0;
  signed long int return_value_strtol$1;
  if(!((signed int)*buf == 0))
  {
    p=strcasestr(buf, "ustatus job");
    if(!(p == ((char *)NULL)))
    {
      signed int return_value_strncasecmp$2;
      return_value_strncasecmp$2=strncasecmp(p + (signed long int)13, "end", (unsigned long int)3);
      if(return_value_strncasecmp$2 == 0)
      {
        stat = 1;
        p=strcasestr(p + (signed long int)13 + (signed long int)5, "pages=");
        if(!(p == ((char *)NULL)))
        {
          return_value_strtol$1=strtol(p + (signed long int)6, &tail, 10);
          *pages = (signed int)return_value_strtol$1;
        }

      }

    }

  }


bugout:
  ;
  return stat;
}

// pjl_read_thread
// file prnt/backend/hp.c line 344
static void pjl_read_thread(struct pjl_attributes *pa)
{
  enum HPMUD_RESULT stat;
  signed int len;
  signed int new_status;
  signed int new_eoj;
  char buf[1024l];
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  pthread_detach(return_value_pthread_self$1);
  pa->current_status = 10001;
  pa->done = 0;
  pa->abort = pa->done;
  pa->eoj_pages = pa->abort;
  while(pa->abort == 0)
  {
    stat=get_pjl_input(pa->dd, pa->cd, buf, (signed int)sizeof(char [1024l]) /*1024ul*/ , 0, &len);
    if(!((signed int)stat == HPMUD_R_OK) && !((signed int)stat == HPMUD_R_IO_TIMEOUT))
    {
      bug("prnt/backend/hp.c 362: exiting thread %d error=%d\n", (signed int)pa->tid, stat);
      pthread_mutex_lock(&pa->mutex);
      pa->current_status = 5000 + (signed int)stat;
      pthread_mutex_unlock(&pa->mutex);
      break;
    }

    if((signed int)stat == HPMUD_R_OK)
    {
      pthread_mutex_lock(&pa->mutex);
      new_status=parse_pjl_device_status(buf, &pa->current_status);
      new_eoj=parse_pjl_job_end(buf, &pa->eoj_pages);
      pthread_mutex_unlock(&pa->mutex);
      if(!(new_status == 0))
        bug("prnt/backend/hp.c 376: read new pjl status: %d\n", pa->current_status);

      if(!(new_eoj == 0))
        bug("prnt/backend/hp.c 378: read pjl job_end: %d\n", pa->eoj_pages);

    }

    else
      sleep((unsigned int)1);
  }
  pa->done = 1;
  pthread_cond_signal(&pa->done_cond);
  goto __CPROVER_DUMP_L8;

__CPROVER_DUMP_L8:
  ;
}

// power_up
// file io/hpmud/musb.h line 130
signed int power_up(struct _mud_device *pd, signed int fd)
{
  const char *pSf;
  pSf=strstr(pd->id, "CMD:LDL");
  char *return_value_strstr$3;
  char *return_value_strstr$5;
  if(!(pSf == ((const char *)NULL)))
    return 0;

  else
  {
    pSf=strstr(pd->id, ";S:");
    if(!(pSf == ((const char *)NULL)))
    {
      signed int return_value_sfield_printer_state$1;
      return_value_sfield_printer_state$1=sfield_printer_state(pd->id);
      if(!(return_value_sfield_printer_state$1 == 3))
        return 0;

    }

    else
    {
      pSf=strstr(pd->id, "VSTATUS:");
      if(!(pSf == ((const char *)NULL)))
      {
        char *return_value_strstr$2;
        return_value_strstr$2=strstr(pSf + (signed long int)8, "OFFF");
        _Bool tmp_if_expr$4;
        if(!(return_value_strstr$2 == ((char *)NULL)))
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_strstr$3=strstr(pSf + (signed long int)8, "PWDN");
          tmp_if_expr$4 = return_value_strstr$3 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
        }
        _Bool tmp_if_expr$6;
        if(tmp_if_expr$4)
          tmp_if_expr$6 = (_Bool)1;

        else
        {
          return_value_strstr$5=strstr(pSf + (signed long int)8, "$X");
          tmp_if_expr$6 = return_value_strstr$5 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr$6)
          return 0;

      }

      else
        return 0;
    }
    pd->vf.write(fd, (const void *)venice_power_on, (signed int)sizeof(const unsigned char [34l]) /*34ul*/ , 45000000);
    sleep((unsigned int)2);
    return 0;
  }
}

// pp_channel_close
// file io/hpmud/pp.c line 990
enum HPMUD_RESULT pp_channel_close(struct _mud_device *pd, struct _mud_channel *pc)
{
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  pthread_mutex_lock(&pd->mutex);
  stat=pc->vf.close(pc);
  del_channel$link1(pd, pc);
  pthread_mutex_unlock(&pd->mutex);
  return stat;
}

// pp_channel_open
// file io/hpmud/pp.c line 961
enum HPMUD_RESULT pp_channel_open(struct _mud_device *pd, const char *sn, signed int *cd)
{
  signed int index;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_DEVICE_BUSY;
  stat=service_to_channel(pd, sn, &index);
  signed int return_value_new_channel$1;
  if((signed int)stat == HPMUD_R_OK)
  {
    pthread_mutex_lock(&pd->mutex);
    return_value_new_channel$1=new_channel$link1(pd, index, sn);
    if(!(return_value_new_channel$1 == 0))
      stat = (enum HPMUD_RESULT)HPMUD_R_DEVICE_BUSY;

    else
    {
      stat=pd->channel[(signed long int)index].vf.open(&pd->channel[(signed long int)index]);
      if(!((signed int)stat == HPMUD_R_OK))
        del_channel$link1(pd, &pd->channel[(signed long int)index]);

      else
        *cd = index;
    }
    pthread_mutex_unlock(&pd->mutex);
  }


bugout:
  ;
  return stat;
}

// pp_close
// file io/hpmud/pp.c line 830
enum HPMUD_RESULT pp_close(struct _mud_device *pd)
{
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  pthread_mutex_lock(&pd->mutex);
  if(pd->open_fd >= 0)
    close(pd->open_fd);

  pd->open_fd = -1;
  pd->id[(signed long int)0] = (char)0;
  pthread_mutex_unlock(&pd->mutex);
  return stat;
}

// pp_dot4_channel_close
// file io/hpmud/pp.c line 1171
enum HPMUD_RESULT pp_dot4_channel_close(struct _mud_channel *pc)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  signed int m;
  if(!(pd->mlc_up == 0))
  {
    signed int return_value_Dot4CloseChannel$1;
    return_value_Dot4CloseChannel$1=Dot4CloseChannel(pc, pd->mlc_fd);
    if(!(return_value_Dot4CloseChannel$1 == 0))
      stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;

  }

  if(pd->channel_cnt == 1)
  {
    if(!(pd->mlc_up == 0))
    {
      signed int return_value_Dot4Exit$2;
      return_value_Dot4Exit$2=Dot4Exit(pc, pd->mlc_fd);
      if(!(return_value_Dot4Exit$2 == 0))
        stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;

    }

    pd->mlc_up = 0;
    ecp_write_addr(pd->mlc_fd, (unsigned char)78);
    ecp_write(pd->mlc_fd, (const void *)"\0", 1);
    m = 0;
    ioctl(pd->mlc_fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x91 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &m);
    release_pp(pd->mlc_fd);
    sleep((unsigned int)1);
  }

  return stat;
}

// pp_dot4_channel_open
// file io/hpmud/pp.c line 1119
enum HPMUD_RESULT pp_dot4_channel_open(struct _mud_channel *pc)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  signed int i;
  signed int m;
  if(pd->channel_cnt == 1)
  {
    signed int return_value_claim_pp$1;
    return_value_claim_pp$1=claim_pp(pd->open_fd);
    if(!(return_value_claim_pp$1 == 0))
      goto bugout;

    m = 1 << 10;
    signed int return_value_ioctl$2;
    return_value_ioctl$2=ioctl(pd->open_fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x91 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &m);
    if(!(return_value_ioctl$2 == 0))
    {
      syslog(3, "io/hpmud/pp.c 1135: unable to negotiate %s ECP mode: %m\n", (const void *)pd->uri);
      goto bugout;
    }

    ecp_write_addr(pd->open_fd, (unsigned char)78);
    ecp_write(pd->open_fd, (const void *)"\0", 1);
    ecp_write_addr(pd->open_fd, (unsigned char)77);
    signed int return_value_Dot4Init$3;
    return_value_Dot4Init$3=Dot4Init(pc, pd->open_fd);
    if(!(return_value_Dot4Init$3 == 0))
      goto bugout;

    i = 0;
    for( ; !(i >= 47); i = i + 1)
      memset((void *)&pd->channel[(signed long int)i].ta, 0, sizeof(struct anonymous$16) /*8ul*/ );
    pd->mlc_fd = pd->open_fd;
    pd->mlc_up = 1;
  }

  signed int return_value_Dot4GetSocket$4;
  return_value_Dot4GetSocket$4=Dot4GetSocket(pc, pd->mlc_fd);
  signed int return_value_Dot4OpenChannel$5;
  if(return_value_Dot4GetSocket$4 == 0)
  {
    return_value_Dot4OpenChannel$5=Dot4OpenChannel(pc, pd->mlc_fd);
    if(return_value_Dot4OpenChannel$5 == 0)
    {
      pc->rindex = 0;
      pc->rcnt = pc->rindex;
      stat = (enum HPMUD_RESULT)HPMUD_R_OK;
    }

  }


bugout:
  ;
  return stat;
}

// pp_get_device_id
// file io/hpmud/pp.c line 847
enum HPMUD_RESULT pp_get_device_id(struct _mud_device *pd, char *buf, signed int size, signed int *len)
{
  signed int m;
  signed int fd = pd->open_fd;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_DEVICE_BUSY;
  *len = 0;
  pthread_mutex_lock(&pd->mutex);
  if(!(fd >= 0))
  {
    stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_STATE;
    syslog(3, "io/hpmud/pp.c 859: invalid get_device_id state\n");
  }

  else
  {
    if((signed int)pd->io_mode == HPMUD_UNI_MODE)
    {
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(pd->id);
      *len = (signed int)return_value_strlen$1;
    }

    else
    {
      ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x98 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &m);
      if(!((1040 & m) == 0))
      {
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(pd->id);
        *len = (signed int)return_value_strlen$2;
      }

      else
        if(pd->channel_cnt == 0)
        {
          signed int return_value_claim_pp$3;
          return_value_claim_pp$3=claim_pp(fd);
          if(!(return_value_claim_pp$3 == 0))
            goto bugout;

          *len=device_id$link1(fd, pd->id, (signed int)sizeof(char [1024l]) /*1024ul*/ );
          release_pp(fd);
        }

        else
          *len=device_id$link1(fd, pd->id, (signed int)sizeof(char [1024l]) /*1024ul*/ );
    }
    if(!(*len == 0))
    {
      signed int tmp_if_expr$4;
      if(!(size >= *len))
        tmp_if_expr$4 = size;

      else
        tmp_if_expr$4 = *len;
      memcpy((void *)buf, (const void *)pd->id, (unsigned long int)tmp_if_expr$4);
      stat = (enum HPMUD_RESULT)HPMUD_R_OK;
    }

  }

bugout:
  ;
  pthread_mutex_unlock(&pd->mutex);
  return stat;
}

// pp_get_device_status
// file io/hpmud/pp.c line 905
enum HPMUD_RESULT pp_get_device_status(struct _mud_device *pd, unsigned int *status)
{
  signed int fd = pd->open_fd;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_DEVICE_BUSY;
  signed int m;
  signed int r = 0;
  pthread_mutex_lock(&pd->mutex);
  if(!(fd >= 0))
  {
    stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_STATE;
    syslog(3, "io/hpmud/pp.c 916: invalid get_device_id state\n");
  }

  else
  {
    if((signed int)pd->io_mode == HPMUD_UNI_MODE)
      *status = (unsigned int)0x08;

    else
    {
      ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x98 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &m);
      if(!((1040 & m) == 0))
        *status = (unsigned int)0x08;

      else
        if(pd->channel_cnt == 0)
        {
          signed int return_value_claim_pp$1;
          return_value_claim_pp$1=claim_pp(fd);
          if(!(return_value_claim_pp$1 == 0))
            goto bugout;

          r=device_status(fd, status);
          release_pp(fd);
        }

        else
          r=device_status(fd, status);
    }
    if(r == 0)
      stat = (enum HPMUD_RESULT)HPMUD_R_OK;

  }

bugout:
  ;
  pthread_mutex_unlock(&pd->mutex);
  return stat;
}

// pp_mlc_channel_close
// file io/hpmud/pp.c line 1079
enum HPMUD_RESULT pp_mlc_channel_close(struct _mud_channel *pc)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_OK;
  signed int m;
  if(!(pd->mlc_up == 0))
  {
    signed int return_value_MlcCloseChannel$1;
    return_value_MlcCloseChannel$1=MlcCloseChannel(pc, pd->mlc_fd);
    if(!(return_value_MlcCloseChannel$1 == 0))
      stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;

  }

  if(pd->channel_cnt == 1)
  {
    if(!(pd->mlc_up == 0))
    {
      signed int return_value_MlcExit$2;
      return_value_MlcExit$2=MlcExit(pc, pd->mlc_fd);
      if(!(return_value_MlcExit$2 == 0))
        stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;

    }

    pd->mlc_up = 0;
    ecp_write_addr(pd->mlc_fd, (unsigned char)78);
    ecp_write(pd->mlc_fd, (const void *)"\0", 1);
    m = 0;
    ioctl(pd->mlc_fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x91 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &m);
    release_pp(pd->mlc_fd);
    sleep((unsigned int)1);
  }

  return stat;
}

// pp_mlc_channel_open
// file io/hpmud/pp.c line 1027
enum HPMUD_RESULT pp_mlc_channel_open(struct _mud_channel *pc)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  signed int i;
  signed int m;
  if(pd->channel_cnt == 1)
  {
    signed int return_value_claim_pp$1;
    return_value_claim_pp$1=claim_pp(pd->open_fd);
    if(!(return_value_claim_pp$1 == 0))
      goto bugout;

    m = 1 << 10;
    signed int return_value_ioctl$2;
    return_value_ioctl$2=ioctl(pd->open_fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x91 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &m);
    if(!(return_value_ioctl$2 == 0))
    {
      syslog(3, "io/hpmud/pp.c 1043: unable to negotiate %s ECP mode: %m\n", (const void *)pd->uri);
      goto bugout;
    }

    ecp_write_addr(pd->open_fd, (unsigned char)78);
    ecp_write(pd->open_fd, (const void *)"\0", 1);
    ecp_write_addr(pd->open_fd, (unsigned char)77);
    signed int return_value_MlcInit$3;
    return_value_MlcInit$3=MlcInit(pc, pd->open_fd);
    if(!(return_value_MlcInit$3 == 0))
      goto bugout;

    i = 0;
    for( ; !(i >= 47); i = i + 1)
      memset((void *)&pd->channel[(signed long int)i].ta, 0, sizeof(struct anonymous$16) /*8ul*/ );
    pd->mlc_fd = pd->open_fd;
    pd->mlc_up = 1;
  }

  signed int return_value_MlcConfigSocket$4;
  return_value_MlcConfigSocket$4=MlcConfigSocket(pc, pd->mlc_fd);
  signed int return_value_MlcOpenChannel$5;
  if(return_value_MlcConfigSocket$4 == 0)
  {
    return_value_MlcOpenChannel$5=MlcOpenChannel(pc, pd->mlc_fd);
    if(return_value_MlcOpenChannel$5 == 0)
    {
      pc->rindex = 0;
      pc->rcnt = pc->rindex;
      stat = (enum HPMUD_RESULT)HPMUD_R_OK;
    }

  }


bugout:
  ;
  return stat;
}

// pp_open
// file io/hpmud/pp.c line 770
enum HPMUD_RESULT pp_open(struct _mud_device *pd)
{
  char dev[255l];
  char uriModel[128l];
  char model[128l];
  signed int len;
  signed int m;
  signed int fd;
  enum HPMUD_RESULT stat = (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;
  pthread_mutex_lock(&pd->mutex);
  hpmud_get_uri_model(pd->uri, uriModel, (signed int)sizeof(char [128l]) /*128ul*/ );
  signed int return_value_is_hp$3;
  if((signed int)pd->id[0l] == 0)
  {
    hpmud_get_uri_datalink(pd->uri, dev, (signed int)sizeof(char [255l]) /*255ul*/ );
    fd=open(dev, 02 | 0400);
    if(!(fd >= 0))
    {
      syslog(3, "io/hpmud/pp.c 786: unable to open %s: %m\n", (const void *)pd->uri);
      goto bugout;
    }

    signed int return_value_ioctl$1;
    return_value_ioctl$1=ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x97 << 0)) | sizeof(unsigned int) /*4ul*/  << 0 + 8 + 8, &m);
    if(!(return_value_ioctl$1 == 0))
    {
      syslog(3, "io/hpmud/pp.c 793: unable to open %s: %m\n", (const void *)pd->uri);
      goto bugout;
    }

    signed int return_value_claim_pp$2;
    return_value_claim_pp$2=claim_pp(fd);
    if(!(return_value_claim_pp$2 == 0))
      goto bugout;

    len=device_id$link1(fd, pd->id, (signed int)sizeof(char [1024l]) /*1024ul*/ );
    if(len >= 1)
    {
      return_value_is_hp$3=is_hp(pd->id);
      if(!(return_value_is_hp$3 == 0))
        power_up(pd, fd);

    }

    release_pp(fd);
    if(len == 0)
      goto bugout;

    pd->open_fd = fd;
  }

  hpmud_get_model(pd->id, model, (signed int)sizeof(char [128l]) /*128ul*/ );
  signed int return_value_strcmp$4;
  return_value_strcmp$4=strcmp(uriModel, model);
  if(!(return_value_strcmp$4 == 0))
  {
    stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_DEVICE_NODE;
    syslog(3, "io/hpmud/pp.c 819: invalid model %s != %s\n", (const void *)uriModel, (const void *)model);
  }

  else
    stat = (enum HPMUD_RESULT)HPMUD_R_OK;

bugout:
  ;
  pthread_mutex_unlock(&pd->mutex);
  return stat;
}

// pp_probe_devices
// file io/hpmud/pp.h line 97
signed int pp_probe_devices(char *lst, signed int lst_size, signed int *cnt)
{
  struct hpmud_model_attributes ma;
  char dev[256l];
  char rmodel[128l];
  char model[128l];
  char id[1024l];
  signed int i;
  signed int size = 0;
  signed int fd;
  signed int m;
  i = 0;
  signed int return_value_is_hp$4;
  signed int return_value_sprintf$1;
  signed int return_value_sprintf$2;
  for( ; !(i >= 4); i = i + 1)
  {
    sprintf(dev, "/dev/parport%d", i);
    fd=open(dev, 00 | 0400);
    if(fd >= 0)
    {
      signed int return_value_ioctl$7;
      return_value_ioctl$7=ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x97 << 0)) | sizeof(unsigned int) /*4ul*/  << 0 + 8 + 8, &m);
      if(return_value_ioctl$7 == 0)
      {
        signed int return_value_claim_pp$6;
        return_value_claim_pp$6=claim_pp(fd);
        if(return_value_claim_pp$6 == 0)
        {
          signed int return_value_device_id$5;
          return_value_device_id$5=device_id$link1(fd, id, (signed int)sizeof(char [1024l]) /*1024ul*/ );
          if(return_value_device_id$5 >= 1)
          {
            return_value_is_hp$4=is_hp(id);
            if(!(return_value_is_hp$4 == 0))
            {
              hpmud_get_model(id, model, (signed int)sizeof(char [128l]) /*128ul*/ );
              hpmud_get_raw_model(id, rmodel, (signed int)sizeof(char [128l]) /*128ul*/ );
              snprintf(dev, sizeof(char [256l]) /*256ul*/ , "hp:/par/%s?device=/dev/parport%d", (const void *)model, i);
              hpmud_query_model(dev, &ma);
              if(!((signed int)ma.support == HPMUD_SUPPORT_TYPE_HPLIP))
              {
                release_pp(fd);
                close(fd);
                syslog(3, "io/hpmud/pp.c 1244: ignoring %s support=%d\n", (const void *)dev, ma.support);
                goto __CPROVER_DUMP_L10;
              }

              signed int return_value_strncasecmp$3;
              return_value_strncasecmp$3=strncasecmp(rmodel, "hp ", (unsigned long int)3);
              if(return_value_strncasecmp$3 == 0)
              {
                return_value_sprintf$1=sprintf(lst + (signed long int)size, "direct %s \"HP %s\" \"HP %s LPT parport%d HPLIP\" \"%s\"\n", (const void *)dev, &rmodel[(signed long int)3], &rmodel[(signed long int)3], i, (const void *)id);
                size = size + return_value_sprintf$1;
              }

              else
              {
                return_value_sprintf$2=sprintf(lst + (signed long int)size, "direct %s \"HP %s\" \"HP %s LPT parport%d HPLIP\" \"%s\"\n", (const void *)dev, (const void *)rmodel, (const void *)rmodel, i, (const void *)id);
                size = size + return_value_sprintf$2;
              }
              *cnt = *cnt + 1;
            }

          }

          release_pp(fd);
        }

        else
          syslog(3, "io/hpmud/pp.c 1258: unable to probe %s: %m\n", (const void *)dev);
      }

      close(fd);
    }


  __CPROVER_DUMP_L10:
    ;
  }
  return size;
}

// pp_raw_channel_close
// file io/hpmud/pp.c line 1015
enum HPMUD_RESULT pp_raw_channel_close(struct _mud_channel *pc)
{
  if(pc->fd >= 0)
    release_pp(pc->fd);

  pc->fd = -1;
  return (enum HPMUD_RESULT)HPMUD_R_OK;
}

// pp_raw_channel_open
// file io/hpmud/pp.c line 1006
enum HPMUD_RESULT pp_raw_channel_open(struct _mud_channel *pc)
{
  struct _mud_device *pd = &msp->device[(signed long int)pc->dindex];
  signed int return_value_claim_pp$1;
  return_value_claim_pp$1=claim_pp(pd->open_fd);
  if(!(return_value_claim_pp$1 == 0))
    return (enum HPMUD_RESULT)HPMUD_R_IO_ERROR;

  else
  {
    pc->fd = pd->open_fd;
    return (enum HPMUD_RESULT)HPMUD_R_OK;
  }
}

// pp_read
// file io/hpmud/pp.c line 748
signed int pp_read(signed int fd, void *buf, signed int size, signed int usec)
{
  signed int len = 0;
  signed int m;
  ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x98 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &m);
  if(!((1040 & m) == 0))
    len=ecp_read(fd, buf, size, usec);

  else
    len=nibble_read(fd, 0, buf, size, usec);
  return len;
}

// pp_write
// file io/hpmud/pp.c line 727
signed int pp_write(signed int fd, const void *buf, signed int size, signed int usec)
{
  signed int len = 0;
  signed int m;
  ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x98 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &m);
  if(!((1040 & m) == 0))
    len=ecp_write(fd, buf, size);

  else
    len=compat_write(fd, buf, size);
  return len;
}

// read_status
// file io/hpmud/pp.c line 81
static unsigned char read_status(signed int fd)
{
  unsigned char status;
  signed int return_value_ioctl$1;
  return_value_ioctl$1=ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x81 << 0)) | sizeof(unsigned char) /*1ul*/  << 0 + 8 + 8, &status);
  if(!(return_value_ioctl$1 == 0))
    syslog(3, "io/hpmud/pp.c 85: read_status error: %m\n");

  return (unsigned char)((signed int)status ^ 0x80);
}

// release_interface
// file io/hpmud/musb.c line 543
static signed int release_interface(struct anonymous$20 *pfd)
{
  if(pfd->hd == ((struct libusb_device_handle *)NULL))
    return 0;

  else
  {
    if(!(pfd->write_active == 0))
    {
      syslog(3, "io/hpmud/musb.c 550: aborting outstanding %s write\n", fd_name[(signed long int)pfd->fd]);
      pthread_cancel(pfd->tid);
      pfd->write_active = 0;
    }

    libusb_release_interface(pfd->hd, pfd->interface);
    libusb_close(pfd->hd);
    pfd->hd = (struct libusb_device_handle *)(void *)0;
    pthread_mutex_destroy(&pfd->mutex);
    pthread_cond_destroy(&pfd->write_done_cond);
    syslog(6, "io/hpmud/musb.c 561: released %s interface\n", fd_name[(signed long int)pfd->fd]);
    return 0;
  }
}

// release_pp
// file io/hpmud/pp.c line 597
static signed int release_pp(signed int fd)
{
  signed int stat = 1;
  signed int m = 1 << 8;
  signed int return_value_ioctl$1;
  return_value_ioctl$1=ioctl(fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x91 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &m);
  if(!(return_value_ioctl$1 == 0))
    syslog(3, "io/hpmud/pp.c 604: failed release_pp fd=%d: %m\n", fd);

  else
  {
    ioctl(fd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(112 << 0 + 8) | (unsigned int)(0x8c << 0) | (unsigned int)(0 << 0 + 8 + 8)));
    stat = 0;
  }

bugout:
  ;
  return 0;
}

// save_out_file
// file prnt/backend/hp.c line 662
static void save_out_file(signed int fd, signed int copies, struct _IO_FILE *temp_fp)
{
  signed int len = 0;
  char buf[16384l];
  signed long int return_value_read$1;
  if(temp_fp == ((struct _IO_FILE *)NULL))
    bug("prnt/backend/hp.c 669: ERROR: save_out_file function recieved NULL temp_fp pointer\n");

  else
    while(copies >= 1)
    {
      copies = copies - 1;
      if(!(fd == 0))
        lseek(fd, (signed long int)0, 0);

      do
      {
        return_value_read$1=read(fd, (void *)buf, sizeof(char [16384l]) /*16384ul*/ );
        len = (signed int)return_value_read$1;
        if(!(len >= 1))
          break;

        fwrite((const void *)buf, (unsigned long int)1, (unsigned long int)len, temp_fp);
      }
      while((_Bool)1);
    }
}

// service_to_channel
// file io/hpmud/hpmud.c line 189
enum HPMUD_RESULT service_to_channel(struct _mud_device *pd, const char *sn, signed int *index)
{
  enum HPMUD_RESULT stat;
  *index = -1;
  signed int return_value_strncasecmp$21;
  return_value_strncasecmp$21=strncasecmp(sn, "print", (unsigned long int)5);
  signed int return_value_strncasecmp$20;
  signed int return_value_strncasecmp$19;
  signed int return_value_strncasecmp$18;
  signed int return_value_strncasecmp$17;
  signed int return_value_strncasecmp$16;
  signed int return_value_strncasecmp$15;
  signed int return_value_strncasecmp$14;
  signed int return_value_strncasecmp$13;
  signed int return_value_strncasecmp$12;
  signed int return_value_strncasecmp$11;
  signed int return_value_strncasecmp$9;
  signed int return_value_strncasecmp$8;
  signed int return_value_strncasecmp$7;
  signed int return_value_strncasecmp$6;
  signed int return_value_strncasecmp$5;
  signed int return_value_strncasecmp$4;
  signed int return_value_strncasecmp$3;
  signed int return_value_strncasecmp$2;
  if(return_value_strncasecmp$21 == 0)
    *index = 2;

  else
  {
    return_value_strncasecmp$20=strncasecmp(sn, "hp-ews-ledm", (unsigned long int)11);
    if(return_value_strncasecmp$20 == 0)
      *index = 23;

    else
    {
      return_value_strncasecmp$19=strncasecmp(sn, "hp-ews", (unsigned long int)6);
      if(return_value_strncasecmp$19 == 0)
        *index = 18;

      else
      {
        return_value_strncasecmp$18=strncasecmp(sn, "hp-soap-scan", (unsigned long int)12);
        if(return_value_strncasecmp$18 == 0)
          *index = 19;

        else
        {
          return_value_strncasecmp$17=strncasecmp(sn, "hp-soap-fax", (unsigned long int)11);
          if(return_value_strncasecmp$17 == 0)
            *index = 20;

          else
          {
            return_value_strncasecmp$16=strncasecmp(sn, "hp-marvell-scan", (unsigned long int)15);
            if(return_value_strncasecmp$16 == 0)
              *index = 21;

            else
            {
              return_value_strncasecmp$15=strncasecmp(sn, "hp-marvell-fax", (unsigned long int)14);
              if(return_value_strncasecmp$15 == 0)
                *index = 22;

              else
              {
                return_value_strncasecmp$14=strncasecmp(sn, "hp-ledm-scan", (unsigned long int)12);
                if(return_value_strncasecmp$14 == 0)
                  *index = 24;

                else
                {
                  return_value_strncasecmp$13=strncasecmp(sn, "hp-marvell-ews", (unsigned long int)11);
                  if(return_value_strncasecmp$13 == 0)
                    *index = 25;

                  else
                  {
                    return_value_strncasecmp$12=strncasecmp(sn, "hp-ipp", (unsigned long int)6);
                    if(return_value_strncasecmp$12 == 0)
                    {
                      signed int return_value_strncasecmp$1;
                      return_value_strncasecmp$1=strncasecmp(sn, "hp-ipp2", (unsigned long int)7);
                      if(return_value_strncasecmp$1 == 0)
                        *index = 46;

                      else
                        *index = 45;
                    }

                    else
                    {
                      return_value_strncasecmp$11=strncasecmp(sn, "hp-escl-scan", (unsigned long int)12);
                      if(return_value_strncasecmp$11 == 0)
                        *index = 26;

                      else
                      {
                        _Bool tmp_if_expr$10;
                        if((signed int)pd->io_mode == HPMUD_RAW_MODE)
                          tmp_if_expr$10 = (_Bool)1;

                        else
                          tmp_if_expr$10 = (signed int)pd->io_mode == HPMUD_UNI_MODE ? (_Bool)1 : (_Bool)0;
                        if(tmp_if_expr$10)
                        {
                          syslog(3, "io/hpmud/hpmud.c 246: invalid channel_open state, current io_mode=raw/uni service=%s %s\n", sn, (const void *)pd->uri);
                          stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_STATE;
                          goto bugout;
                        }

                        else
                        {
                          return_value_strncasecmp$9=strncasecmp(sn, "hp-message", (unsigned long int)10);
                          if(return_value_strncasecmp$9 == 0)
                            *index = 1;

                          else
                          {
                            return_value_strncasecmp$8=strncasecmp(sn, "hp-scan", (unsigned long int)7);
                            if(return_value_strncasecmp$8 == 0)
                              *index = 4;

                            else
                            {
                              return_value_strncasecmp$7=strncasecmp(sn, "hp-fax-send", (unsigned long int)11);
                              if(return_value_strncasecmp$7 == 0)
                                *index = 7;

                              else
                              {
                                return_value_strncasecmp$6=strncasecmp(sn, "hp-card-access", (unsigned long int)14);
                                if(return_value_strncasecmp$6 == 0)
                                  *index = 17;

                                else
                                {
                                  return_value_strncasecmp$5=strncasecmp(sn, "hp-configuration-upload", (unsigned long int)23);
                                  if(return_value_strncasecmp$5 == 0)
                                    *index = 14;

                                  else
                                  {
                                    return_value_strncasecmp$4=strncasecmp(sn, "hp-configuration-download", (unsigned long int)25);
                                    if(return_value_strncasecmp$4 == 0)
                                      *index = 15;

                                    else
                                    {
                                      return_value_strncasecmp$3=strncasecmp(sn, "hp-devmgmt", (unsigned long int)10);
                                      if(return_value_strncasecmp$3 == 0)
                                        *index = 44;

                                      else
                                      {
                                        return_value_strncasecmp$2=strncasecmp(sn, "hp-wificonfig", (unsigned long int)13);
                                        if(return_value_strncasecmp$2 == 0)
                                          *index = 43;

                                        else
                                        {
                                          syslog(3, "io/hpmud/hpmud.c 284: invalid service=%s %s\n", sn, (const void *)pd->uri);
                                          stat = (enum HPMUD_RESULT)HPMUD_R_INVALID_SN;
                                          goto bugout;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  stat = (enum HPMUD_RESULT)HPMUD_R_OK;

bugout:
  ;
  return stat;
}

// sfield_printer_state
// file io/hpmud/musb.c line 824
static signed int sfield_printer_state(const char *id)
{
  char *pSf;
  signed int vstatus = 0;
  signed int ver;
  pSf=strstr(id, ";S:");
  if(pSf == ((char *)NULL))
  {
    syslog(3, "io/hpmud/musb.c 831: invalid S-field\n");
    return vstatus;
  }

  else
  {
    pSf = pSf + (signed long int)3;
    ver = 0;
    _Bool tmp_if_expr$2;
    if((signed int)*pSf >= 48)
      tmp_if_expr$2 = (signed int)*pSf <= 57 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      ver = ver | (signed int)*pSf - 48;

    else
    {
      _Bool tmp_if_expr$1;
      if((signed int)*pSf >= 65)
        tmp_if_expr$1 = (signed int)*pSf <= 70 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        ver = ver | (0xA + (signed int)*pSf) - 65;

      else
        if((signed int)*pSf >= 97)
        {
          if(!((signed int)*pSf >= 103))
            ver = ver | (0xA + (signed int)*pSf) - 97;

        }

    }
    pSf = pSf + 1l;
    ver = ver << 4;
    _Bool tmp_if_expr$4;
    if((signed int)*pSf >= 48)
      tmp_if_expr$4 = (signed int)*pSf <= 57 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      ver = ver | (signed int)*pSf - 48;

    else
    {
      _Bool tmp_if_expr$3;
      if((signed int)*pSf >= 65)
        tmp_if_expr$3 = (signed int)*pSf <= 70 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
        ver = ver | (0xA + (signed int)*pSf) - 65;

      else
        if((signed int)*pSf >= 97)
        {
          if(!((signed int)*pSf >= 103))
            ver = ver | (0xA + (signed int)*pSf) - 97;

        }

    }
    pSf = pSf + 1l;
    switch(ver)
    {
      case 0:

      case 1:

      case 2:
      {
        pSf = pSf + (signed long int)12;
        break;
      }
      case 3:
      {
        pSf = pSf + (signed long int)14;
        break;
      }
      case 4:
      {
        pSf = pSf + (signed long int)18;
        break;
      }
      default:
      {
        syslog(3, "io/hpmud/musb.c 859: unknown S-field version=%d\n", ver);
        pSf = pSf + (signed long int)12;
      }
    }
    vstatus = 0;
    _Bool tmp_if_expr$6;
    if((signed int)*pSf >= 48)
      tmp_if_expr$6 = (signed int)*pSf <= 57 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
      vstatus = vstatus | (signed int)*pSf - 48;

    else
    {
      _Bool tmp_if_expr$5;
      if((signed int)*pSf >= 65)
        tmp_if_expr$5 = (signed int)*pSf <= 70 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
        vstatus = vstatus | (0xA + (signed int)*pSf) - 65;

      else
        if((signed int)*pSf >= 97)
        {
          if(!((signed int)*pSf >= 103))
            vstatus = vstatus | (0xA + (signed int)*pSf) - 97;

        }

    }
    pSf = pSf + 1l;
    vstatus = vstatus << 4;
    _Bool tmp_if_expr$8;
    if((signed int)*pSf >= 48)
      tmp_if_expr$8 = (signed int)*pSf <= 57 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$8 = (_Bool)0;
    if(tmp_if_expr$8)
      vstatus = vstatus | (signed int)*pSf - 48;

    else
    {
      _Bool tmp_if_expr$7;
      if((signed int)*pSf >= 65)
        tmp_if_expr$7 = (signed int)*pSf <= 70 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$7 = (_Bool)0;
      if(tmp_if_expr$7)
        vstatus = vstatus | (0xA + (signed int)*pSf) - 65;

      else
        if((signed int)*pSf >= 97)
        {
          if(!((signed int)*pSf >= 103))
            vstatus = vstatus | (0xA + (signed int)*pSf) - 97;

        }

    }
    return vstatus;
  }
}

// strrstr
// file io/hpmud/model.c line 142
static char * strrstr(const char *x, const char *y)
{
  char *prev = (char *)(void *)0;
  char *next;
  char *return_value_strchr$1;
  if((signed int)*y == 0)
  {
    return_value_strchr$1=strchr(x, 0);
    return return_value_strchr$1;
  }

  do
  {
    next=strstr(x, y);
    if(next == ((char *)NULL))
      break;

    prev = next;
    x = next + (signed long int)1;
  }
  while((_Bool)1);
  return prev;
}

// sysdump
// file io/hpmud/hpmud.c line 38
void sysdump(const void *data, signed int size)
{
  unsigned char *p = (unsigned char *)data;
  unsigned char c;
  signed int n;
  char bytestr[4l] = { (char)0, 0, 0, 0 };
  char addrstr[10l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char hexstr[53l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char charstr[21l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  n = 1;
  for( ; size >= n; n = n + 1)
  {
    if(n % 16 == 1)
      snprintf(addrstr, sizeof(char [10l]) /*10ul*/ , "%.4d", (signed int)(p - (unsigned char *)data & (signed long int)0xffff));

    c = *p;
    const unsigned short int **return_value___ctype_b_loc$1;
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if((16384 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)c]) == 0)
      c = (unsigned char)46;

    snprintf(bytestr, sizeof(char [4l]) /*4ul*/ , "%02X ", *p);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(hexstr);
    strncat(hexstr, bytestr, (sizeof(char [53l]) /*53ul*/  - return_value_strlen$2) - (unsigned long int)1);
    snprintf(bytestr, sizeof(char [4l]) /*4ul*/ , "%c", c);
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(charstr);
    strncat(charstr, bytestr, (sizeof(char [21l]) /*21ul*/  - return_value_strlen$3) - (unsigned long int)1);
    if(n % 16 == 0)
    {
      hexstr[(signed long int)0] = (char)0;
      charstr[(signed long int)0] = (char)0;
    }

    p = p + 1l;
  }
  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(hexstr);
}

// unload_library
// file common/utils.c line 215
void unload_library(void *pLibHandler)
{
  if(!(pLibHandler == NULL))
    dlclose(pLibHandler);

  else
    syslog(3, "common/utils.c 220: Invalid Library hanlder pLibHandler = NULL.\n");
}

// validate_plugin_version
// file common/utils.c line 109
enum UTILS_PLUGIN_STATUS validate_plugin_version()
{
  char hplip_version[128l];
  char plugin_version[128l];
  enum UTILS_CONF_RESULT return_value_get_conf$1;
  return_value_get_conf$1=get_conf("[hplip]", "version", hplip_version, (signed int)sizeof(char [128l]) /*128ul*/ );
  if(!((signed int)return_value_get_conf$1 == UTILS_CONF_OK))
    return (enum UTILS_PLUGIN_STATUS)UTILS_PLUGIN_STATUS_NOT_INSTALLED;

  else
  {
    enum UTILS_CONF_RESULT return_value_get_key_value$2;
    return_value_get_key_value$2=get_key_value("/var/lib/hp/hplip.state", "[plugin]", "version", plugin_version, (signed int)sizeof(char [128l]) /*128ul*/ );
    if(!((signed int)return_value_get_key_value$2 == UTILS_CONF_OK))
    {
      syslog(3, "common/utils.c 119: validate_plugin_version() Failed to get Plugin version from [%s]\n", (const void *)"/var/lib/hp/hplip.state");
      return (enum UTILS_PLUGIN_STATUS)UTILS_PLUGIN_STATUS_NOT_INSTALLED;
    }

    else
    {
      signed int return_value_strcmp$3;
      return_value_strcmp$3=strcmp(hplip_version, plugin_version);
      if(return_value_strcmp$3 == 0)
        return (enum UTILS_PLUGIN_STATUS)UTILS_PLUGIN_STATUS_OK;

      else
      {
        syslog(3, "common/utils.c 130: validate_plugin_version() Plugin version[%s] mismatch with HPLIP version[%s]\n", (const void *)plugin_version, (const void *)hplip_version);
        return (enum UTILS_PLUGIN_STATUS)UTILS_PLUGIN_STATUS_MISMATCH;
      }
      return (enum UTILS_PLUGIN_STATUS)UTILS_PLUGIN_STATUS_NOT_INSTALLED;
    }
  }
}

// wait
// file io/hpmud/pp.c line 125
static signed int wait(signed int usec)
{
  struct timeval tmo;
  struct timeval now;
  signed int cnt = 0;
  gettimeofday(&tmo, (struct timezone *)(void *)0);
  tmo.tv_usec = tmo.tv_usec + (signed long int)usec;
  tmo.tv_sec = tmo.tv_sec + tmo.tv_usec / (signed long int)1000000;
  tmo.tv_usec = tmo.tv_usec % (signed long int)1000000;
  while((_Bool)1)
  {
    cnt = cnt + 1;
    gettimeofday(&now, (struct timezone *)(void *)0);
    if(now.tv_sec == tmo.tv_sec && !(tmo.tv_usec >= now.tv_usec) || !(tmo.tv_sec >= now.tv_sec))
      return 0;

  }
}

// wait_status
// file io/hpmud/pp.c line 91
static signed int wait_status(signed int fd, unsigned char mask, unsigned char val, signed int usec)
{
  struct timeval tmo;
  struct timeval now;
  struct timespec min;
  unsigned char status;
  signed int cnt = 0;
  gettimeofday(&tmo, (struct timezone *)(void *)0);
  tmo.tv_usec = tmo.tv_usec + (signed long int)usec;
  tmo.tv_sec = tmo.tv_sec + tmo.tv_usec / (signed long int)1000000;
  tmo.tv_usec = tmo.tv_usec % (signed long int)1000000;
  min.tv_sec = (signed long int)0;
  min.tv_nsec = (signed long int)5000000;
  while((_Bool)1)
  {
    status=read_status(fd);
    if(((signed int)status & (signed int)mask) == (signed int)val)
      return 0;

    cnt = cnt + 1;
    gettimeofday(&now, (struct timezone *)(void *)0);
    if(now.tv_sec == tmo.tv_sec && !(tmo.tv_usec >= now.tv_usec) || !(tmo.tv_sec >= now.tv_sec))
      return -1;

  }
}

// write_ecp_channel
// file io/hpmud/musb.c line 186
static signed int write_ecp_channel(struct anonymous$20 *pfd, signed int value)
{
  struct libusb_device_handle *hd;
  signed int interface = pfd->interface;
  signed int len;
  signed int stat = 1;
  unsigned char byte;
  if(pfd->hd == ((struct libusb_device_handle *)NULL))
    syslog(3, "io/hpmud/musb.c 195: invalid write_ecp_channel state\n");

  else
  {
    hd = pfd->hd;
    len=libusb_control_transfer(hd, (unsigned char)(LIBUSB_ENDPOINT_IN | 64 | 1), (unsigned char)0, (unsigned short int)value, (unsigned short int)interface, &byte, (unsigned short int)1, (unsigned int)5000);
    if(!(len == 1))
      syslog(3, "io/hpmud/musb.c 210: invalid write_ecp_channel: %m\n");

    else
      stat = 0;
  }

bugout:
  ;
  return stat;
}

// write_phoenix_setup
// file io/hpmud/musb.c line 351
static signed int write_phoenix_setup(struct anonymous$20 *pfd)
{
  struct libusb_device_handle *hd;
  signed int len;
  signed int stat = 1;
  if(pfd->hd == ((struct libusb_device_handle *)NULL))
    syslog(3, "io/hpmud/musb.c 358: invalid write_phoenix_setup state\n");

  else
  {
    hd = pfd->hd;
    len=libusb_control_transfer(hd, (unsigned char)(LIBUSB_ENDPOINT_OUT | 32 | 3), (unsigned char)0x02, (unsigned short int)0, (unsigned short int)0, (unsigned char *)(void *)0, (unsigned short int)0, (unsigned int)5000);
    if(!(len >= 0))
      syslog(3, "io/hpmud/musb.c 373: invalid write_phoenix_setup: %m\n");

    else
      stat = 0;
  }

bugout:
  ;
  return stat;
}

// write_thread
// file io/hpmud/musb.c line 979
static void write_thread(struct anonymous$20 *pfd)
{
  signed int ep = -1;
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  pthread_detach(return_value_pthread_self$1);
  ep=get_out_ep(libusb_dev, pfd->config, pfd->interface, pfd->alt_setting, (enum libusb_transfer_type)LIBUSB_TRANSFER_TYPE_BULK);
  if(!(ep >= 0))
  {
    syslog(3, "io/hpmud/musb.c 988: invalid bulk out endpoint\n");
    pfd->write_return = -107;
  }

  else
    pfd->write_return=libusb_bulk_write(pfd->hd, ep, (char *)pfd->write_buf, pfd->write_size, 72 * 3600 * 1000);

bugout:
  ;
  pthread_mutex_lock(&pfd->mutex);
  pfd->write_buf = (void *)0;
  pthread_cond_signal(&pfd->write_done_cond);
  pthread_mutex_unlock(&pfd->mutex);
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

