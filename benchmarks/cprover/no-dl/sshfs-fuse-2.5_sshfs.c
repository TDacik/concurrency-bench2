// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$0;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$5;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$7;

// tag-#anon#UN[ARR32{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 239
union anonymous$1;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$3;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$4;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$2;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$6;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous;

// tag-_GHashTable
// file /usr/include/glib-2.0/glib/ghash.h line 37
struct _GHashTable;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GPtrArray
// file /usr/include/glib-2.0/glib/garray.h line 39
struct _GPtrArray;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-buffer
// file sshfs.c line 128
struct buffer;

// tag-cache
// file cache.c line 22
struct cache;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-fuse
// file /usr/include/fuse/fuse.h line 45
struct fuse;

// tag-fuse_args
// file /usr/include/fuse/fuse_opt.h line 108
struct fuse_args;

// tag-fuse_buf
// file /usr/include/fuse/fuse_common.h line 345
struct fuse_buf;

// tag-fuse_buf_flags
// file /usr/include/fuse/fuse_common.h line 269
enum fuse_buf_flags { FUSE_BUF_IS_FD=2, FUSE_BUF_FD_SEEK=4, FUSE_BUF_FD_RETRY=8 };

// tag-fuse_bufvec
// file /usr/include/fuse/fuse_common.h line 386
struct fuse_bufvec;

// tag-fuse_cache_dirhandle
// file cache.h line 16
struct fuse_cache_dirhandle;

// tag-fuse_cache_operations
// file cache.h line 20
struct fuse_cache_operations;

// tag-fuse_chan
// file /usr/include/fuse/fuse_common.h line 193
struct fuse_chan;

// tag-fuse_conn_info
// file /usr/include/fuse/fuse_common.h line 140
struct fuse_conn_info;

// tag-fuse_dirhandle
// file /usr/include/fuse/fuse.h line 62
struct fuse_dirhandle;

// tag-fuse_file_info
// file /usr/include/fuse/fuse_common.h line 45
struct fuse_file_info;

// tag-fuse_operations
// file /usr/include/fuse/fuse.h line 88
struct fuse_operations;

// tag-fuse_opt
// file /usr/include/fuse/fuse_opt.h line 76
struct fuse_opt;

// tag-fuse_pollhandle
// file /usr/include/fuse/fuse_common.h line 194
struct fuse_pollhandle;

// tag-fuse_session
// file /usr/include/fuse/fuse_common.h line 192
struct fuse_session;

// tag-group
// file /usr/include/grp.h line 42
struct group;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-list_head
// file sshfs.c line 134
struct list_head;

// tag-node
// file cache.c line 36
struct node;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-read_chunk
// file sshfs.c line 171
struct read_chunk;

// tag-read_req
// file sshfs.c line 163
struct read_req;

// tag-request
// file sshfs.c line 139
struct request;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-sshfs
// file sshfs.c line 193
struct sshfs;

// tag-sshfs_file
// file sshfs.c line 180
struct sshfs_file;

// tag-sshfs_io
// file sshfs.c line 157
struct sshfs_io;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-statvfs
// file /usr/include/x86_64-linux-gnu/bits/statvfs.h line 29
struct statvfs;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-utimbuf
// file /usr/include/utime.h line 37
struct utimbuf;

// tag-utsname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 48
struct utsname;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// buf_add_buf
// file sshfs.c line 562
static inline void buf_add_buf(struct buffer *buf, struct buffer *bufa);
// buf_add_data
// file sshfs.c line 584
static inline void buf_add_data(struct buffer *buf, struct buffer *data);
// buf_add_mem
// file sshfs.c line 556
static inline void buf_add_mem(struct buffer *buf, const void *data, unsigned long int len);
// buf_add_path
// file sshfs.c line 598
static inline void buf_add_path(struct buffer *buf, const char *path);
// buf_add_string
// file sshfs.c line 590
static inline void buf_add_string(struct buffer *buf, const char *str);
// buf_add_uint32
// file sshfs.c line 572
static inline void buf_add_uint32(struct buffer *buf, unsigned int val);
// buf_add_uint64
// file sshfs.c line 578
static inline void buf_add_uint64(struct buffer *buf, unsigned long int val);
// buf_add_uint8
// file sshfs.c line 567
static inline void buf_add_uint8(struct buffer *buf, unsigned char val);
// buf_check_add
// file sshfs.c line 544
static inline void buf_check_add(struct buffer *buf, unsigned long int len);
// buf_check_get
// file sshfs.c line 626
static signed int buf_check_get(struct buffer *buf, unsigned long int len);
// buf_clear
// file sshfs.c line 528
static inline void buf_clear(struct buffer *buf);
// buf_finish
// file sshfs.c line 523
static inline void buf_finish(struct buffer *buf);
// buf_free
// file sshfs.c line 518
static inline void buf_free(struct buffer *buf);
// buf_get_attrs
// file sshfs.c line 694
static signed int buf_get_attrs(struct buffer *buf, struct stat *stbuf, signed int *flagsp);
// buf_get_data
// file sshfs.c line 670
static inline signed int buf_get_data(struct buffer *buf, struct buffer *data);
// buf_get_entries
// file sshfs.c line 806
static signed int buf_get_entries(struct buffer *buf, struct fuse_cache_dirhandle *h, signed int (*filler)(struct fuse_cache_dirhandle *, const char *, struct stat *));
// buf_get_entries::filler$object
//
signed int filler$object(struct fuse_cache_dirhandle *, const char *, struct stat *);
// buf_get_mem
// file sshfs.c line 635
static inline signed int buf_get_mem(struct buffer *buf, void *data, unsigned long int len);
// buf_get_statvfs
// file sshfs.c line 764
static signed int buf_get_statvfs(struct buffer *buf, struct statvfs *stbuf);
// buf_get_string
// file sshfs.c line 684
static inline signed int buf_get_string(struct buffer *buf, char **str);
// buf_get_uint32
// file sshfs.c line 649
static inline signed int buf_get_uint32(struct buffer *buf, unsigned int *val);
// buf_get_uint64
// file sshfs.c line 658
static inline signed int buf_get_uint64(struct buffer *buf, unsigned long int *val);
// buf_get_uint8
// file sshfs.c line 644
static inline signed int buf_get_uint8(struct buffer *buf, unsigned char *val);
// buf_init
// file sshfs.c line 504
static inline void buf_init(struct buffer *buf, unsigned long int size);
// buf_resize
// file sshfs.c line 534
static void buf_resize(struct buffer *buf, unsigned long int len);
// buf_to_iov
// file sshfs.c line 1185
static void buf_to_iov(struct buffer *buf, struct iovec *iov);
// cache_add_attr
// file cache.h line 27
void cache_add_attr(const char *path, struct stat *stbuf, unsigned long int wrctr);
// cache_add_dir
// file cache.c line 183
static void cache_add_dir(const char *path, char **dir);
// cache_add_link
// file cache.c line 205
static void cache_add_link(const char *path, const char *link, unsigned long int size);
// cache_chmod
// file cache.c line 412
static signed int cache_chmod(const char *path, unsigned int mode);
// cache_chown
// file cache.c line 420
static signed int cache_chown(const char *path, unsigned int uid, unsigned int gid);
// cache_clean
// file cache.c line 70
static void cache_clean(void);
// cache_clean_entry
// file cache.c line 61
static signed int cache_clean_entry(void *key_, struct node *node, signed long int *now);
// cache_create
// file cache.c line 454
static signed int cache_create(const char *path, unsigned int mode, struct fuse_file_info *fi);
// cache_del_children
// file cache.c line 132
static signed int cache_del_children(const char *key, void *val_, const char *path);
// cache_dirfill
// file cache.c line 284
static signed int cache_dirfill(struct fuse_cache_dirhandle *ch, const char *name, struct stat *stbuf);
// cache_do_rename
// file cache.c line 141
static void cache_do_rename(const char *from, const char *to);
// cache_fgetattr
// file cache.c line 472
static signed int cache_fgetattr(const char *path, struct stat *stbuf, struct fuse_file_info *fi);
// cache_fill
// file cache.c line 524
static void cache_fill(struct fuse_cache_operations *oper, struct fuse_operations *cache_oper);
// cache_ftruncate
// file cache.c line 463
static signed int cache_ftruncate(const char *path, signed long int size, struct fuse_file_info *fi);
// cache_get
// file cache.c line 153
static struct node * cache_get(const char *path);
// cache_get_attr
// file cache.c line 220
static signed int cache_get_attr(const char *path, struct stat *stbuf);
// cache_get_write_ctr
// file cache.h line 29
unsigned long int cache_get_write_ctr(void);
// cache_getattr
// file cache.c line 248
static signed int cache_getattr(const char *path, struct stat *stbuf);
// cache_getdir
// file cache.c line 302
static signed int cache_getdir(const char *path, struct fuse_dirhandle *h, signed int (*filler)(struct fuse_dirhandle *, const char *, signed int, unsigned long int));
// cache_getdir::filler$object
//
signed int filler$object(struct fuse_dirhandle *, const char *, signed int, unsigned long int);
// cache_init
// file cache.h line 25
struct fuse_operations * cache_init(struct fuse_cache_operations *oper);
// cache_invalidate
// file cache.h line 28
void cache_invalidate(const char *path);
// cache_invalidate_dir
// file cache.c line 124
static void cache_invalidate_dir(const char *path);
// cache_invalidate_write
// file cache.c line 116
void cache_invalidate_write(const char *path);
// cache_link
// file cache.c line 402
static signed int cache_link(const char *from, const char *to);
// cache_lookup
// file cache.c line 82
static struct node * cache_lookup(const char *path);
// cache_mkdir
// file cache.c line 362
static signed int cache_mkdir(const char *path, unsigned int mode);
// cache_mknod
// file cache.c line 354
static signed int cache_mknod(const char *path, unsigned int mode, unsigned long int rdev);
// cache_parse_options
// file cache.h line 26
signed int cache_parse_options(struct fuse_args *args);
// cache_purge
// file cache.c line 87
static void cache_purge(const char *path);
// cache_purge_parent
// file cache.c line 92
static void cache_purge_parent(const char *path);
// cache_readlink
// file cache.c line 260
static signed int cache_readlink(const char *path, char *buf, unsigned long int size);
// cache_rename
// file cache.c line 394
static signed int cache_rename(const char *from, const char *to);
// cache_rmdir
// file cache.c line 378
static signed int cache_rmdir(const char *path);
// cache_symlink
// file cache.c line 386
static signed int cache_symlink(const char *from, const char *to);
// cache_truncate
// file cache.c line 428
static signed int cache_truncate(const char *path, signed long int size);
// cache_unity_dirfill
// file cache.c line 338
static signed int cache_unity_dirfill(struct fuse_cache_dirhandle *ch, const char *name, struct stat *stbuf);
// cache_unity_fill
// file cache.c line 486
static void cache_unity_fill(struct fuse_cache_operations *oper, struct fuse_operations *cache_oper);
// cache_unity_getdir
// file cache.c line 345
static signed int cache_unity_getdir(const char *path, struct fuse_dirhandle *h, signed int (*filler)(struct fuse_dirhandle *, const char *, signed int, unsigned long int));
// cache_unity_getdir::filler$object
//
signed int filler$object(struct fuse_dirhandle *, const char *, signed int, unsigned long int);
// cache_unlink
// file cache.c line 370
static signed int cache_unlink(const char *path);
// cache_utime
// file cache.c line 436
static signed int cache_utime(const char *path, struct utimbuf *buf);
// cache_write
// file cache.c line 444
static signed int cache_write(const char *path, const char *buf, unsigned long int size, signed long int offset, struct fuse_file_info *fi);
// calc_buf_size
// file sshfs.c line 3109
static unsigned long int calc_buf_size(signed long int size, signed long int offset);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// check_large_read
// file sshfs.c line 3454
static void check_large_read(struct fuse_args *args);
// chunk_free
// file sshfs.c line 1277
static void chunk_free(struct read_chunk *chunk);
// chunk_put
// file sshfs.c line 1290
static void chunk_put(struct read_chunk *chunk);
// chunk_put_locked
// file sshfs.c line 1299
static void chunk_put_locked(struct read_chunk *chunk);
// clean_req
// file sshfs.c line 1306
static signed int clean_req(void *key_, struct request *req);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_conn
// file sshfs.c line 1392
static void close_conn(void);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous, unsigned int);
// connect_remote
// file sshfs.c line 1685
static signed int connect_remote(void);
// connect_slave
// file sshfs.c line 1106
static signed int connect_slave();
// connect_to
// file sshfs.c line 1113
static signed int connect_to(char *host, char *port);
// count_components
// file sshfs.c line 1935
static signed int count_components(const char *p);
// do_read
// file sshfs.c line 1227
static signed int do_read(struct buffer *buf);
// do_write
// file sshfs.c line 1152
static signed int do_write(struct iovec *iov, unsigned long int count);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// execvp
// file /usr/include/unistd.h line 578
extern signed int execvp(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// find_base_path
// file sshfs.c line 3540
static char * find_base_path(void);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_node
// file cache.c line 54
static void free_node(void *node_);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fsname_escape_commas
// file sshfs.c line 3588
static char * fsname_escape_commas(char *fsnameold);
// fsname_remove_commas
// file sshfs.c line 3573
static void fsname_remove_commas(char *fsname);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 219
extern signed int fstat(signed int, struct stat *);
// fuse_chan_fd
// file /usr/include/fuse/fuse_lowlevel.h line 1765
signed int fuse_chan_fd(struct fuse_chan *);
// fuse_daemonize
// file /usr/include/fuse/fuse_common.h line 246
signed int fuse_daemonize(signed int);
// fuse_destroy
// file /usr/include/fuse/fuse.h line 679
void fuse_destroy(struct fuse *);
// fuse_get_session
// file /usr/include/fuse/fuse.h line 1005
struct fuse_session * fuse_get_session(struct fuse *);
// fuse_is_lib_option
// file /usr/include/fuse/fuse.h line 759
signed int fuse_is_lib_option(const char *);
// fuse_loop
// file /usr/include/fuse/fuse.h line 690
signed int fuse_loop(struct fuse *);
// fuse_loop_mt
// file /usr/include/fuse/fuse.h line 712
signed int fuse_loop_mt(struct fuse *);
// fuse_main_real
// file /usr/include/fuse/fuse.h line 766
signed int fuse_main_real(signed int, char **, struct fuse_operations *, unsigned long int, void *);
// fuse_mount
// file /usr/include/fuse/fuse_common.h line 206
struct fuse_chan * fuse_mount(const char *, struct fuse_args *);
// fuse_new
// file /usr/include/fuse/fuse.h line 665
struct fuse * fuse_new(struct fuse_chan *, struct fuse_args *, struct fuse_operations *, unsigned long int, void *);
// fuse_opt_add_arg
// file /usr/include/fuse/fuse_opt.h line 230
signed int fuse_opt_add_arg(struct fuse_args *, const char *);
// fuse_opt_free_args
// file /usr/include/fuse/fuse_opt.h line 254
void fuse_opt_free_args(struct fuse_args *);
// fuse_opt_insert_arg
// file /usr/include/fuse/fuse_opt.h line 245
signed int fuse_opt_insert_arg(struct fuse_args *, signed int, const char *);
// fuse_opt_parse
// file /usr/include/fuse/fuse_opt.h line 202
signed int fuse_opt_parse(struct fuse_args *, void *, struct fuse_opt *, signed int (*)(void *, const char *, signed int, struct fuse_args *));
// fuse_parse_cmdline
// file /usr/include/fuse/fuse_common.h line 237
signed int fuse_parse_cmdline(struct fuse_args *, char **, signed int *, signed int *);
// fuse_remove_signal_handlers
// file /usr/include/fuse/fuse_common.h line 465
void fuse_remove_signal_handlers(struct fuse_session *);
// fuse_set_signal_handlers
// file /usr/include/fuse/fuse_common.h line 455
signed int fuse_set_signal_handlers(struct fuse_session *);
// fuse_unmount
// file /usr/include/fuse/fuse_common.h line 214
void fuse_unmount(const char *, struct fuse_chan *);
// fuse_version
// file /usr/include/fuse/fuse_common.h line 253
signed int fuse_version(void);
// g_free
// file /usr/include/glib-2.0/glib/gmem.h line 71
extern void g_free(void *);
// g_hash_table_foreach_remove
// file /usr/include/glib-2.0/glib/ghash.h line 107
extern unsigned int g_hash_table_foreach_remove(struct _GHashTable *, signed int (*)(void *, void *, void *), void *);
// g_hash_table_insert
// file /usr/include/glib-2.0/glib/ghash.h line 67
extern signed int g_hash_table_insert(struct _GHashTable *, void *, void *);
// g_hash_table_lookup
// file /usr/include/glib-2.0/glib/ghash.h line 88
extern void * g_hash_table_lookup(struct _GHashTable *, const void *);
// g_hash_table_lookup_extended
// file /usr/include/glib-2.0/glib/ghash.h line 94
extern signed int g_hash_table_lookup_extended(struct _GHashTable *, const void *, void **, void **);
// g_hash_table_new
// file /usr/include/glib-2.0/glib/ghash.h line 57
extern struct _GHashTable * g_hash_table_new(unsigned int (*)(const void *), signed int (*)(const void *, const void *));
// g_hash_table_new_full
// file /usr/include/glib-2.0/glib/ghash.h line 60
extern struct _GHashTable * g_hash_table_new_full(unsigned int (*)(const void *), signed int (*)(const void *, const void *), void (*)(void *), void (*)(void *));
// g_hash_table_remove
// file /usr/include/glib-2.0/glib/ghash.h line 78
extern signed int g_hash_table_remove(struct _GHashTable *, const void *);
// g_hash_table_size
// file /usr/include/glib-2.0/glib/ghash.h line 115
extern unsigned int g_hash_table_size(struct _GHashTable *);
// g_list_append
// file /usr/include/glib-2.0/glib/glist.h line 59
extern struct _GList * g_list_append(struct _GList *, void *);
// g_list_delete_link
// file /usr/include/glib-2.0/glib/glist.h line 94
extern struct _GList * g_list_delete_link(struct _GList *, struct _GList *);
// g_list_first
// file /usr/include/glib-2.0/glib/glist.h line 128
extern struct _GList * g_list_first(struct _GList *);
// g_malloc
// file /usr/include/glib-2.0/glib/gmem.h line 78
extern void * g_malloc(unsigned long int);
// g_malloc0_n
// file /usr/include/glib-2.0/glib/gmem.h line 96
extern void * g_malloc0_n(unsigned long int, unsigned long int);
// g_ptr_array_add
// file /usr/include/glib-2.0/glib/garray.h line 168
extern void g_ptr_array_add(struct _GPtrArray *, void *);
// g_ptr_array_free
// file /usr/include/glib-2.0/glib/garray.h line 139
extern void ** g_ptr_array_free(struct _GPtrArray *, signed int);
// g_ptr_array_new
// file /usr/include/glib-2.0/glib/garray.h line 130
extern struct _GPtrArray * g_ptr_array_new(void);
// g_str_equal
// file /usr/include/glib-2.0/glib/ghash.h line 154
extern signed int g_str_equal(const void *, const void *);
// g_str_hash
// file /usr/include/glib-2.0/glib/ghash.h line 157
extern unsigned int g_str_hash(const void *);
// g_strdup
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 216
extern char * g_strdup(const char *);
// g_strdup_printf
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 218
extern char * g_strdup_printf(const char *, ...);
// g_strfreev
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 281
extern void g_strfreev(char **);
// g_strndup
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 224
extern char * g_strndup(const char *, unsigned long int);
// g_thread_init
// file /usr/include/glib-2.0/glib/deprecated/gthread.h line 265
extern void g_thread_init(void *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// get_sshfs_file
// file sshfs.c line 2506
static inline struct sshfs_file * get_sshfs_file(struct fuse_file_info *fi);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getgrnam
// file /usr/include/grp.h line 110
extern struct group * getgrnam(const char *);
// getpagesize
// file /usr/include/unistd.h line 978
extern signed int getpagesize(void);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// grantpt
// file /usr/include/stdlib.h line 923
extern signed int grantpt(signed int);
// groupname_to_gid
// file sshfs.c line 3769
static unsigned int * groupname_to_gid(char *name);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// iov_length
// file sshfs.c line 1191
static unsigned long int iov_length(struct iovec *iov, unsigned long int nr_segs);
// is_ssh_opt
// file sshfs.c line 3322
static signed int is_ssh_opt(const char *arg);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// list_add
// file sshfs.c line 462
static void list_add(struct list_head *new, struct list_head *head);
// list_del
// file sshfs.c line 472
static void list_del(struct list_head *entry);
// list_empty
// file sshfs.c line 481
static signed int list_empty(struct list_head *head);
// list_init
// file sshfs.c line 456
static void list_init(struct list_head *head);
// load_gid_map
// file sshfs.c line 3796
static inline void load_gid_map(void);
// load_uid_map
// file sshfs.c line 3791
static inline void load_uid_map(void);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 61
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// my_strnlen
// file cache.c line 198
static unsigned long int my_strnlen(const char *s, unsigned long int maxsize);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// parse_idmap_line
// file sshfs.c line 3631
static void parse_idmap_line(char *line, const char *filename, const unsigned int lineno, unsigned int *ret_id, char **ret_name, const signed int eof);
// parse_workarounds
// file sshfs.c line 3417
signed int parse_workarounds(void);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_one_request
// file sshfs.c line 1321
static signed int process_one_request(void);
// process_requests
// file sshfs.c line 1409
static void * process_requests(void *data_);
// processing_init
// file sshfs.c line 3218
static signed int processing_init(void);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$4 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$4 *, const union anonymous$3 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$4 *, union anonymous$2 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$2 *, const union anonymous$3 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$2 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$2 *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$0 *, struct anonymous$0 *);
// ptsname
// file /usr/include/stdlib.h line 932
extern char * ptsname(signed int);
// pty_expect_loop
// file sshfs.c line 893
static signed int pty_expect_loop(void);
// pty_master
// file sshfs.c line 961
static signed int pty_master(char **name);
// rand_r
// file /usr/include/stdlib.h line 381
extern signed int rand_r(unsigned int *);
// random_string
// file sshfs.c line 2275
static void random_string(char *str, signed int length);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_id_map
// file sshfs.c line 3677
static void read_id_map(char *file, unsigned int * (*map_fn)(char *), const char *name_id, struct _GHashTable **idmap, struct _GHashTable **r_idmap);
// read_id_map::map_fn$object
//
unsigned int * map_fn$object(char *);
// read_password
// file sshfs.c line 3463
static signed int read_password(void);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// replace_arg
// file sshfs.c line 983
static void replace_arg(char **argp, const char *newarg);
// request_free
// file sshfs.c line 1270
static void request_free(struct request *req);
// search_read_chunk
// file sshfs.c line 2745
static struct read_chunk * search_read_chunk(struct sshfs_file *sf, signed long int offset);
// sem_destroy
// file /usr/include/semaphore.h line 39
extern signed int sem_destroy(union anonymous$1 *);
// sem_init
// file /usr/include/semaphore.h line 36
extern signed int sem_init(union anonymous$1 *, signed int, unsigned int);
// sem_post
// file /usr/include/semaphore.h line 69
extern signed int sem_post(union anonymous$1 *);
// sem_wait
// file /usr/include/semaphore.h line 54
extern signed int sem_wait(union anonymous$1 *);
// set_ssh_command
// file sshfs.c line 3503
static void set_ssh_command(void);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// sftp_check_root
// file sshfs.c line 1617
static signed int sftp_check_root(const char *base_path);
// sftp_detect_uid
// file sshfs.c line 1563
static void sftp_detect_uid();
// sftp_error_to_errno
// file sshfs.c line 1548
static signed int sftp_error_to_errno(unsigned int error);
// sftp_find_init_reply
// file sshfs.c line 1494
static signed int sftp_find_init_reply(unsigned int *version);
// sftp_get_id
// file sshfs.c line 1179
static unsigned int sftp_get_id(void);
// sftp_init
// file sshfs.c line 1520
static signed int sftp_init();
// sftp_init_reply_ok
// file sshfs.c line 1434
static signed int sftp_init_reply_ok(struct buffer *buf, unsigned int *version);
// sftp_read
// file sshfs.c line 1247
static signed int sftp_read(unsigned char *type, struct buffer *buf);
// sftp_readdir_async
// file sshfs.c line 2051
static signed int sftp_readdir_async(struct buffer *handle, struct fuse_cache_dirhandle *h, signed int (*filler)(struct fuse_cache_dirhandle *, const char *, struct stat *));
// sftp_readdir_async::filler$object
//
signed int filler$object(struct fuse_cache_dirhandle *, const char *, struct stat *);
// sftp_readdir_send
// file sshfs.c line 2034
static signed int sftp_readdir_send(struct request **req, struct buffer *handle);
// sftp_readdir_sync
// file sshfs.c line 2123
static signed int sftp_readdir_sync(struct buffer *handle, struct fuse_cache_dirhandle *h, signed int (*filler)(struct fuse_cache_dirhandle *, const char *, struct stat *));
// sftp_readdir_sync::filler$object
//
signed int filler$object(struct fuse_cache_dirhandle *, const char *, struct stat *);
// sftp_request
// file sshfs.c line 1909
static signed int sftp_request(unsigned char type, struct buffer *buf, unsigned char expect_type, struct buffer *outbuf);
// sftp_request_iov
// file sshfs.c line 1895
static signed int sftp_request_iov(unsigned char type, struct iovec *iov, unsigned long int count, unsigned char expect_type, struct buffer *outbuf);
// sftp_request_send
// file sshfs.c line 1828
static signed int sftp_request_send(unsigned char type, struct iovec *iov, unsigned long int count, void (*begin_func)(struct request *), void (*end_func)(struct request *), signed int want_reply, void *data, struct request **reqp);
// sftp_request_send::begin_func$object
//
void begin_func$object(struct request *);
// sftp_request_send::end_func$object
//
void end_func$object(struct request *);
// sftp_request_wait
// file sshfs.c line 1762
static signed int sftp_request_wait(struct request *req, unsigned char type, unsigned char expect_type, struct buffer *outbuf);
// sftp_send_iov
// file sshfs.c line 1203
static signed int sftp_send_iov(unsigned char type, unsigned int id, struct iovec *iov, unsigned long int count);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous$0 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$0 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// ssh_add_arg
// file sshfs.c line 840
static void ssh_add_arg(const char *arg);
// ssh_connect
// file sshfs.c line 3606
static signed int ssh_connect(void);
// sshfs_async_read
// file sshfs.c line 2755
static signed int sshfs_async_read(struct sshfs_file *sf, char *rbuf, unsigned long int size, signed long int offset);
// sshfs_async_write
// file sshfs.c line 2848
static signed int sshfs_async_write(struct sshfs_file *sf, const char *wbuf, unsigned long int size, signed long int offset);
// sshfs_chmod
// file sshfs.c line 2329
static signed int sshfs_chmod(const char *path, unsigned int mode);
// sshfs_chown
// file sshfs.c line 2343
static signed int sshfs_chown(const char *path, unsigned int uid, unsigned int gid);
// sshfs_create
// file sshfs.c line 3036
static signed int sshfs_create(const char *path, unsigned int mode, struct fuse_file_info *fi);
// sshfs_do_rename
// file sshfs.c line 2250
static signed int sshfs_do_rename(const char *from, const char *to);
// sshfs_ext_posix_rename
// file sshfs.c line 2262
static signed int sshfs_ext_posix_rename(const char *from, const char *to);
// sshfs_ext_statvfs
// file sshfs.c line 2968
static signed int sshfs_ext_statvfs(const char *path, struct statvfs *stbuf);
// sshfs_fgetattr
// file sshfs.c line 3069
static signed int sshfs_fgetattr(const char *path, struct stat *stbuf, struct fuse_file_info *fi);
// sshfs_file_get
// file sshfs.c line 2554
static void sshfs_file_get(struct sshfs_file *sf);
// sshfs_file_is_conn
// file sshfs.c line 2409
static inline signed int sshfs_file_is_conn(struct sshfs_file *sf);
// sshfs_file_put
// file sshfs.c line 2547
static void sshfs_file_put(struct sshfs_file *sf);
// sshfs_flush
// file sshfs.c line 2511
static signed int sshfs_flush(const char *path, struct fuse_file_info *fi);
// sshfs_fsync
// file sshfs.c line 2540
static signed int sshfs_fsync(const char *path, signed int isdatasync, struct fuse_file_info *fi);
// sshfs_ftruncate
// file sshfs.c line 3042
static signed int sshfs_ftruncate(const char *path, signed long int size, struct fuse_file_info *fi);
// sshfs_fuse_main
// file sshfs.c line 3337
static signed int sshfs_fuse_main(struct fuse_args *args);
// sshfs_getattr
// file sshfs.c line 1918
static signed int sshfs_getattr(const char *path, struct stat *stbuf);
// sshfs_getdir
// file sshfs.c line 2141
static signed int sshfs_getdir(const char *path, struct fuse_cache_dirhandle *h, signed int (*filler)(struct fuse_cache_dirhandle *, const char *, struct stat *));
// sshfs_getdir::filler$object
//
signed int filler$object(struct fuse_cache_dirhandle *, const char *, struct stat *);
// sshfs_inc_modifver
// file sshfs.c line 2370
static void sshfs_inc_modifver(void);
// sshfs_init
// file sshfs.c line 1745
static void * sshfs_init(struct fuse_conn_info *conn);
// sshfs_link
// file sshfs.c line 2310
static signed int sshfs_link(const char *from, const char *to);
// sshfs_mkdir
// file sshfs.c line 2168
static signed int sshfs_mkdir(const char *path, unsigned int mode);
// sshfs_mknod
// file sshfs.c line 2181
static signed int sshfs_mknod(const char *path, unsigned int mode, unsigned long int rdev);
// sshfs_open
// file sshfs.c line 2501
static signed int sshfs_open(const char *path, struct fuse_file_info *fi);
// sshfs_open_common
// file sshfs.c line 2420
static signed int sshfs_open_common(const char *path, unsigned int mode, struct fuse_file_info *fi);
// sshfs_opt_proc
// file sshfs.c line 3346
static signed int sshfs_opt_proc(void *data, const char *arg, signed int key, struct fuse_args *outargs);
// sshfs_read
// file sshfs.c line 2805
static signed int sshfs_read(const char *path, char *rbuf, unsigned long int size, signed long int offset, struct fuse_file_info *fi);
// sshfs_read_begin
// file sshfs.c line 2612
static void sshfs_read_begin(struct request *req);
// sshfs_read_end
// file sshfs.c line 2573
static void sshfs_read_end(struct request *req);
// sshfs_readlink
// file sshfs.c line 2001
static signed int sshfs_readlink(const char *path, char *linkbuf, unsigned long int size);
// sshfs_release
// file sshfs.c line 2559
static signed int sshfs_release(const char *path, struct fuse_file_info *fi);
// sshfs_rename
// file sshfs.c line 2283
static signed int sshfs_rename(const char *from, const char *to);
// sshfs_req_pending
// file sshfs.c line 2043
static signed int sshfs_req_pending(struct request *req);
// sshfs_rmdir
// file sshfs.c line 2239
static signed int sshfs_rmdir(const char *path);
// sshfs_send_read
// file sshfs.c line 2618
static struct read_chunk * sshfs_send_read(struct sshfs_file *sf, unsigned long int size, signed long int offset);
// sshfs_statfs
// file sshfs.c line 2989
static signed int sshfs_statfs(const char *path, struct statvfs *buf);
// sshfs_symlink
// file sshfs.c line 2210
static signed int sshfs_symlink(const char *from, const char *to);
// sshfs_sync_read
// file sshfs.c line 2722
static signed int sshfs_sync_read(struct sshfs_file *sf, char *buf, unsigned long int size, signed long int offset);
// sshfs_sync_write
// file sshfs.c line 2905
static signed int sshfs_sync_write(struct sshfs_file *sf, const char *wbuf, unsigned long int size, signed long int offset);
// sshfs_sync_write_begin
// file sshfs.c line 2878
static void sshfs_sync_write_begin(struct request *req);
// sshfs_sync_write_end
// file sshfs.c line 2884
static void sshfs_sync_write_end(struct request *req);
// sshfs_truncate
// file sshfs.c line 2377
static signed int sshfs_truncate(const char *path, signed long int size);
// sshfs_truncate_extend
// file sshfs.c line 3160
static signed int sshfs_truncate_extend(const char *path, signed long int size, struct fuse_file_info *fi);
// sshfs_truncate_shrink
// file sshfs.c line 3114
static signed int sshfs_truncate_shrink(const char *path, signed long int size);
// sshfs_truncate_workaround
// file sshfs.c line 3195
static signed int sshfs_truncate_workaround(const char *path, signed long int size, struct fuse_file_info *fi);
// sshfs_truncate_zero
// file sshfs.c line 3096
static signed int sshfs_truncate_zero(const char *path);
// sshfs_unlink
// file sshfs.c line 2228
static signed int sshfs_unlink(const char *path);
// sshfs_utime
// file sshfs.c line 2395
static signed int sshfs_utime(const char *path, struct utimbuf *ubuf);
// sshfs_write
// file sshfs.c line 2947
static signed int sshfs_write(const char *path, const char *wbuf, unsigned long int size, signed long int offset, struct fuse_file_info *fi);
// sshfs_write_begin
// file sshfs.c line 2820
static void sshfs_write_begin(struct request *req);
// sshfs_write_end
// file sshfs.c line 2828
static void sshfs_write_end(struct request *req);
// start_processing_thread
// file sshfs.c line 1706
static signed int start_processing_thread(void);
// start_ssh
// file sshfs.c line 993
static signed int start_ssh(void);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strip_common
// file sshfs.c line 1947
static void strip_common(const char **sp, const char **tp);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strsep
// file /usr/include/string.h line 556
extern char * strsep(char ** restrict , const char *);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// submit_read
// file sshfs.c line 2731
static void submit_read(struct sshfs_file *sf, unsigned long int size, signed long int offset, struct read_chunk **chunkp);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// transform_symlink
// file sshfs.c line 1960
static void transform_symlink(const char *path, char **linkp);
// translate_id
// file sshfs.c line 488
static inline signed int translate_id(unsigned int *id, struct _GHashTable *map);
// type_name
// file sshfs.c line 415
static const char * type_name(unsigned char type);
// uname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 81
extern signed int uname(struct utsname *);
// unlockpt
// file /usr/include/stdlib.h line 927
extern signed int unlockpt(signed int);
// usage
// file sshfs.c line 3265
static void usage(const char *progname);
// username_to_uid
// file sshfs.c line 3745
static unsigned int * username_to_uid(char *name);
// wait_chunk
// file sshfs.c line 2664
static signed int wait_chunk(struct read_chunk *chunk, char *buf, unsigned long int size);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// workaround_opt_proc
// file sshfs.c line 3409
static signed int workaround_opt_proc(void *data, const char *arg, signed int key, struct fuse_args *outargs);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// writev
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 50
extern signed long int writev(signed int, struct iovec *, signed int);

struct anonymous$0
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$5
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union anonymous$7
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$1
{
  // __size
  char __size[32l];
  // __align
  signed long int __align;
};

union anonymous$3
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$4
{
  // __data
  struct anonymous$5 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$2
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$6
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

struct _GPtrArray
{
  // pdata
  void **pdata;
  // len
  unsigned int len;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct buffer
{
  // p
  unsigned char *p;
  // len
  unsigned long int len;
  // size
  unsigned long int size;
};

struct cache
{
  // on
  signed int on;
  // stat_timeout
  unsigned int stat_timeout;
  // dir_timeout
  unsigned int dir_timeout;
  // link_timeout
  unsigned int link_timeout;
  // next_oper
  struct fuse_cache_operations *next_oper;
  // table
  struct _GHashTable *table;
  // lock
  union anonymous$2 lock;
  // last_cleaned
  signed long int last_cleaned;
  // write_ctr
  unsigned long int write_ctr;
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct fuse_args
{
  // argc
  signed int argc;
  // argv
  char **argv;
  // allocated
  signed int allocated;
};

struct fuse_buf
{
  // size
  unsigned long int size;
  // flags
  enum fuse_buf_flags flags;
  // mem
  void *mem;
  // fd
  signed int fd;
  // pos
  signed long int pos;
};

struct fuse_bufvec
{
  // count
  unsigned long int count;
  // idx
  unsigned long int idx;
  // off
  unsigned long int off;
  // buf
  struct fuse_buf buf[1l];
};

struct fuse_cache_dirhandle
{
  // path
  const char *path;
  // h
  struct fuse_dirhandle *h;
  // filler
  signed int (*filler)(struct fuse_dirhandle *, const char *, signed int, unsigned long int);
  // dir
  struct _GPtrArray *dir;
  // wrctr
  unsigned long int wrctr;
};

struct fuse_operations
{
  // getattr
  signed int (*getattr)(const char *, struct stat *);
  // readlink
  signed int (*readlink)(const char *, char *, unsigned long int);
  // getdir
  signed int (*getdir)(const char *, struct fuse_dirhandle *, signed int (*)(struct fuse_dirhandle *, const char *, signed int, unsigned long int));
  // mknod
  signed int (*mknod)(const char *, unsigned int, unsigned long int);
  // mkdir
  signed int (*mkdir)(const char *, unsigned int);
  // unlink
  signed int (*unlink)(const char *);
  // rmdir
  signed int (*rmdir)(const char *);
  // symlink
  signed int (*symlink)(const char *, const char *);
  // rename
  signed int (*rename)(const char *, const char *);
  // link
  signed int (*link)(const char *, const char *);
  // chmod
  signed int (*chmod)(const char *, unsigned int);
  // chown
  signed int (*chown)(const char *, unsigned int, unsigned int);
  // truncate
  signed int (*truncate)(const char *, signed long int);
  // utime
  signed int (*utime)(const char *, struct utimbuf *);
  // open
  signed int (*open)(const char *, struct fuse_file_info *);
  // read
  signed int (*read)(const char *, char *, unsigned long int, signed long int, struct fuse_file_info *);
  // write
  signed int (*write)(const char *, const char *, unsigned long int, signed long int, struct fuse_file_info *);
  // statfs
  signed int (*statfs)(const char *, struct statvfs *);
  // flush
  signed int (*flush)(const char *, struct fuse_file_info *);
  // release
  signed int (*release)(const char *, struct fuse_file_info *);
  // fsync
  signed int (*fsync)(const char *, signed int, struct fuse_file_info *);
  // setxattr
  signed int (*setxattr)(const char *, const char *, const char *, unsigned long int, signed int);
  // getxattr
  signed int (*getxattr)(const char *, const char *, char *, unsigned long int);
  // listxattr
  signed int (*listxattr)(const char *, char *, unsigned long int);
  // removexattr
  signed int (*removexattr)(const char *, const char *);
  // opendir
  signed int (*opendir)(const char *, struct fuse_file_info *);
  // readdir
  signed int (*readdir)(const char *, void *, signed int (*)(void *, const char *, struct stat *, signed long int), signed long int, struct fuse_file_info *);
  // releasedir
  signed int (*releasedir)(const char *, struct fuse_file_info *);
  // fsyncdir
  signed int (*fsyncdir)(const char *, signed int, struct fuse_file_info *);
  // init
  void * (*init)(struct fuse_conn_info *);
  // destroy
  void (*destroy)(void *);
  // access
  signed int (*access)(const char *, signed int);
  // create
  signed int (*create)(const char *, unsigned int, struct fuse_file_info *);
  // ftruncate
  signed int (*ftruncate)(const char *, signed long int, struct fuse_file_info *);
  // fgetattr
  signed int (*fgetattr)(const char *, struct stat *, struct fuse_file_info *);
  // lock
  signed int (*lock)(const char *, struct fuse_file_info *, signed int, struct flock *);
  // utimens
  signed int (*utimens)(const char *, struct timespec *);
  // bmap
  signed int (*bmap)(const char *, unsigned long int, unsigned long int *);
  // flag_nullpath_ok
  unsigned int flag_nullpath_ok : 1;
  // flag_nopath
  unsigned int flag_nopath : 1;
  // flag_utime_omit_ok
  unsigned int flag_utime_omit_ok : 1;
  // flag_reserved
  unsigned int flag_reserved : 29;
  // ioctl
  signed int (*ioctl)(const char *, signed int, void *, struct fuse_file_info *, unsigned int, void *);
  // poll
  signed int (*poll)(const char *, struct fuse_file_info *, struct fuse_pollhandle *, unsigned int *);
  // write_buf
  signed int (*write_buf)(const char *, struct fuse_bufvec *, signed long int, struct fuse_file_info *);
  // read_buf
  signed int (*read_buf)(const char *, struct fuse_bufvec **, unsigned long int, signed long int, struct fuse_file_info *);
  // flock
  signed int (*flock)(const char *, struct fuse_file_info *, signed int);
  // fallocate
  signed int (*fallocate)(const char *, signed int, signed long int, signed long int, struct fuse_file_info *);
};

struct fuse_cache_operations
{
  // oper
  struct fuse_operations oper;
  // cache_getdir
  signed int (*cache_getdir)(const char *, struct fuse_cache_dirhandle *, signed int (*)(struct fuse_cache_dirhandle *, const char *, struct stat *));
};

struct fuse_conn_info
{
  // proto_major
  unsigned int proto_major;
  // proto_minor
  unsigned int proto_minor;
  // async_read
  unsigned int async_read;
  // max_write
  unsigned int max_write;
  // max_readahead
  unsigned int max_readahead;
  // capable
  unsigned int capable;
  // want
  unsigned int want;
  // max_background
  unsigned int max_background;
  // congestion_threshold
  unsigned int congestion_threshold;
  // reserved
  unsigned int reserved[23l];
};

struct fuse_file_info
{
  // flags
  signed int flags;
  // fh_old
  unsigned long int fh_old;
  // writepage
  signed int writepage;
  // direct_io
  unsigned int direct_io : 1;
  // keep_cache
  unsigned int keep_cache : 1;
  // flush
  unsigned int flush : 1;
  // nonseekable
  unsigned int nonseekable : 1;
  // flock_release
  unsigned int flock_release : 1;
  // padding
  unsigned int padding : 27;
  // fh
  unsigned long int fh;
  // lock_owner
  unsigned long int lock_owner;
};

struct fuse_opt
{
  // templ
  const char *templ;
  // offset
  unsigned long int offset;
  // value
  signed int value;
};

struct group
{
  // gr_name
  char *gr_name;
  // gr_passwd
  char *gr_passwd;
  // gr_gid
  unsigned int gr_gid;
  // gr_mem
  char **gr_mem;
};

struct in6_addr
{
  // __in6_u
  union anonymous$7 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct list_head
{
  // prev
  struct list_head *prev;
  // next
  struct list_head *next;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct node
{
  // stat
  struct stat stat;
  // stat_valid
  signed long int stat_valid;
  // dir
  char **dir;
  // dir_valid
  signed long int dir_valid;
  // link
  char *link;
  // link_valid
  signed long int link_valid;
  // valid
  signed long int valid;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sshfs_io
{
  // num_reqs
  signed int num_reqs;
  // finished
  union anonymous$4 finished;
  // error
  signed int error;
};

struct read_chunk
{
  // offset
  signed long int offset;
  // size
  unsigned long int size;
  // refs
  signed int refs;
  // modifver
  signed long int modifver;
  // reqs
  struct list_head reqs;
  // sio
  struct sshfs_io sio;
};

struct read_req
{
  // sio
  struct sshfs_io *sio;
  // list
  struct list_head list;
  // data
  struct buffer data;
  // size
  unsigned long int size;
  // res
  signed long int res;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct request
{
  // want_reply
  unsigned int want_reply;
  // ready
  union anonymous$1 ready;
  // reply_type
  unsigned char reply_type;
  // id
  unsigned int id;
  // replied
  signed int replied;
  // error
  signed int error;
  // reply
  struct buffer reply;
  // start
  struct timeval start;
  // data
  void *data;
  // end_func
  void (*end_func)(struct request *);
  // len
  unsigned long int len;
  // list
  struct list_head list;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sshfs
{
  // directport
  char *directport;
  // ssh_command
  char *ssh_command;
  // sftp_server
  char *sftp_server;
  // ssh_args
  struct fuse_args ssh_args;
  // workarounds
  char *workarounds;
  // rename_workaround
  signed int rename_workaround;
  // nodelay_workaround
  signed int nodelay_workaround;
  // nodelaysrv_workaround
  signed int nodelaysrv_workaround;
  // truncate_workaround
  signed int truncate_workaround;
  // buflimit_workaround
  signed int buflimit_workaround;
  // fstat_workaround
  signed int fstat_workaround;
  // transform_symlinks
  signed int transform_symlinks;
  // follow_symlinks
  signed int follow_symlinks;
  // no_check_root
  signed int no_check_root;
  // detect_uid
  signed int detect_uid;
  // idmap
  signed int idmap;
  // nomap
  signed int nomap;
  // disable_hardlink
  signed int disable_hardlink;
  // uid_file
  char *uid_file;
  // gid_file
  char *gid_file;
  // uid_map
  struct _GHashTable *uid_map;
  // gid_map
  struct _GHashTable *gid_map;
  // r_uid_map
  struct _GHashTable *r_uid_map;
  // r_gid_map
  struct _GHashTable *r_gid_map;
  // max_read
  unsigned int max_read;
  // max_write
  unsigned int max_write;
  // ssh_ver
  unsigned int ssh_ver;
  // sync_write
  signed int sync_write;
  // sync_read
  signed int sync_read;
  // sync_readdir
  signed int sync_readdir;
  // debug
  signed int debug;
  // foreground
  signed int foreground;
  // reconnect
  signed int reconnect;
  // delay_connect
  signed int delay_connect;
  // slave
  signed int slave;
  // host
  char *host;
  // base_path
  char *base_path;
  // reqtab
  struct _GHashTable *reqtab;
  // lock
  union anonymous$2 lock;
  // lock_write
  union anonymous$2 lock_write;
  // processing_thread_started
  signed int processing_thread_started;
  // randseed
  unsigned int randseed;
  // rfd
  signed int rfd;
  // wfd
  signed int wfd;
  // ptyfd
  signed int ptyfd;
  // ptyslavefd
  signed int ptyslavefd;
  // connver
  signed int connver;
  // server_version
  signed int server_version;
  // remote_uid
  unsigned int remote_uid;
  // local_uid
  unsigned int local_uid;
  // remote_uid_detected
  signed int remote_uid_detected;
  // blksize
  unsigned int blksize;
  // progname
  char *progname;
  // modifver
  signed long int modifver;
  // outstanding_len
  unsigned int outstanding_len;
  // max_outstanding_len
  unsigned int max_outstanding_len;
  // outstanding_cond
  union anonymous$4 outstanding_cond;
  // password_stdin
  signed int password_stdin;
  // password
  char *password;
  // ext_posix_rename
  signed int ext_posix_rename;
  // ext_statvfs
  signed int ext_statvfs;
  // ext_hardlink
  signed int ext_hardlink;
  // mnt_mode
  unsigned int mnt_mode;
  // bytes_sent
  unsigned long int bytes_sent;
  // bytes_received
  unsigned long int bytes_received;
  // num_sent
  unsigned long int num_sent;
  // num_received
  unsigned long int num_received;
  // min_rtt
  unsigned int min_rtt;
  // max_rtt
  unsigned int max_rtt;
  // total_rtt
  unsigned long int total_rtt;
  // num_connect
  unsigned int num_connect;
};

struct sshfs_file
{
  // handle
  struct buffer handle;
  // write_reqs
  struct list_head write_reqs;
  // write_finished
  union anonymous$4 write_finished;
  // write_error
  signed int write_error;
  // readahead
  struct read_chunk *readahead;
  // next_pos
  signed long int next_pos;
  // is_seq
  signed int is_seq;
  // connver
  signed int connver;
  // modifver
  signed int modifver;
  // refs
  signed int refs;
};

struct statvfs
{
  // f_bsize
  unsigned long int f_bsize;
  // f_frsize
  unsigned long int f_frsize;
  // f_blocks
  unsigned long int f_blocks;
  // f_bfree
  unsigned long int f_bfree;
  // f_bavail
  unsigned long int f_bavail;
  // f_files
  unsigned long int f_files;
  // f_ffree
  unsigned long int f_ffree;
  // f_favail
  unsigned long int f_favail;
  // f_fsid
  unsigned long int f_fsid;
  // f_flag
  unsigned long int f_flag;
  // f_namemax
  unsigned long int f_namemax;
  // __f_spare
  signed int __f_spare[6l];
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct utimbuf
{
  // actime
  signed long int actime;
  // modtime
  signed long int modtime;
};

struct utsname
{
  // sysname
  char sysname[65l];
  // nodename
  char nodename[65l];
  // release
  char release[65l];
  // version
  char version[65l];
  // machine
  char machine[65l];
  // domainname
  char domainname[65l];
};


// cache
// file cache.c line 34
static struct cache cache;
// cache_opts
// file cache.c line 569
static struct fuse_opt cache_opts[9l] = { { .templ="cache=yes", .offset=0ul, .value=1 },
    { .templ="cache=no", .offset=0ul, .value=0 },
    { .templ="cache_timeout=%u", .offset=4ul, .value=0 },
    { .templ="cache_timeout=%u", .offset=8ul, .value=0 },
    { .templ="cache_timeout=%u", .offset=12ul, .value=0 },
    { .templ="cache_stat_timeout=%u", .offset=4ul, .value=0 },
    { .templ="cache_dir_timeout=%u", .offset=8ul, .value=0 },
    { .templ="cache_link_timeout=%u", .offset=12ul, .value=0 },
    { .templ=(const char *)(void *)0, .offset=(unsigned long int)0, .value=0 } };
// ssh_opts
// file sshfs.c line 271
static const char *ssh_opts[46l] = { "AddressFamily", "BatchMode", "BindAddress", "ChallengeResponseAuthentication", "CheckHostIP", "Cipher", "Ciphers", "Compression", "CompressionLevel", "ConnectionAttempts", "ConnectTimeout", "ControlMaster", "ControlPath", "GlobalKnownHostsFile", "GSSAPIAuthentication", "GSSAPIDelegateCredentials", "HostbasedAuthentication", "HostKeyAlgorithms", "HostKeyAlias", "HostName", "IdentitiesOnly", "IdentityFile", "KbdInteractiveAuthentication", "KbdInteractiveDevices", "LocalCommand", "LogLevel", "MACs", "NoHostAuthenticationForLocalhost", "NumberOfPasswordPrompts", "PasswordAuthentication", "Port", "PreferredAuthentications", "ProxyCommand", "PubkeyAuthentication", "RekeyLimit", "RhostsRSAAuthentication", "RSAAuthentication", "ServerAliveCountMax", "ServerAliveInterval", "SmartcardDevice", "StrictHostKeyChecking", "TCPKeepAlive", "UsePrivilegedPort", "UserKnownHostsFile", "VerifyHostKeyDNS", (const char *)(void *)0 };
// sshfs
// file sshfs.c line 269
static struct sshfs sshfs;
// sshfs_oper
// file sshfs.c line 3233
static struct fuse_cache_operations sshfs_oper;
// sshfs_oper
// file sshfs.c line 3233
static struct fuse_cache_operations sshfs_oper = { .oper={ .getattr=sshfs_getattr, .readlink=sshfs_readlink, .getdir=((signed int (*)(const char *, struct fuse_dirhandle *, signed int (*)(struct fuse_dirhandle *, const char *, signed int, unsigned long int)))NULL),
    .mknod=sshfs_mknod,
    .mkdir=sshfs_mkdir, .unlink=sshfs_unlink,
    .rmdir=sshfs_rmdir, .symlink=sshfs_symlink,
    .rename=sshfs_rename, .link=sshfs_link,
    .chmod=sshfs_chmod, .chown=sshfs_chown,
    .truncate=sshfs_truncate, .utime=sshfs_utime,
    .open=sshfs_open, .read=sshfs_read,
    .write=sshfs_write, .statfs=sshfs_statfs,
    .flush=sshfs_flush, .release=sshfs_release,
    .fsync=sshfs_fsync, .setxattr=((signed int (*)(const char *, const char *, const char *, unsigned long int, signed int))NULL),
    .getxattr=((signed int (*)(const char *, const char *, char *, unsigned long int))NULL),
    .listxattr=((signed int (*)(const char *, char *, unsigned long int))NULL),
    .removexattr=((signed int (*)(const char *, const char *))NULL),
    .opendir=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .readdir=((signed int (*)(const char *, void *, signed int (*)(void *, const char *, struct stat *, signed long int), signed long int, struct fuse_file_info *))NULL),
    .releasedir=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .fsyncdir=((signed int (*)(const char *, signed int, struct fuse_file_info *))NULL),
    .init=sshfs_init,
    .destroy=((void (*)(void *))NULL), .access=((signed int (*)(const char *, signed int))NULL),
    .create=sshfs_create,
    .ftruncate=sshfs_ftruncate, .fgetattr=sshfs_fgetattr,
    .lock=((signed int (*)(const char *, struct fuse_file_info *, signed int, struct flock *))NULL), .utimens=((signed int (*)(const char *, struct timespec *))NULL),
    .bmap=((signed int (*)(const char *, unsigned long int, unsigned long int *))NULL),
    .flag_nullpath_ok=0u,
    .flag_nopath=0u, .flag_utime_omit_ok=0u,
    .flag_reserved=0u, .ioctl=((signed int (*)(const char *, signed int, void *, struct fuse_file_info *, unsigned int, void *))NULL),
    .poll=((signed int (*)(const char *, struct fuse_file_info *, struct fuse_pollhandle *, unsigned int *))NULL),
    .write_buf=((signed int (*)(const char *, struct fuse_bufvec *, signed long int, struct fuse_file_info *))NULL),
    .read_buf=((signed int (*)(const char *, struct fuse_bufvec **, unsigned long int, signed long int, struct fuse_file_info *))NULL),
    .flock=((signed int (*)(const char *, struct fuse_file_info *, signed int))NULL),
    .fallocate=((signed int (*)(const char *, signed int, signed long int, signed long int, struct fuse_file_info *))NULL) }, .cache_getdir=sshfs_getdir };
// sshfs_opts
// file sshfs.c line 342
static struct fuse_opt sshfs_opts[38l] = { { .templ="directport=%s", .offset=0ul, .value=0 },
    { .templ="ssh_command=%s", .offset=8ul, .value=0 },
    { .templ="sftp_server=%s", .offset=16ul, .value=0 },
    { .templ="max_read=%u", .offset=160ul, .value=0 },
    { .templ="max_write=%u", .offset=164ul, .value=0 },
    { .templ="ssh_protocol=%u", .offset=168ul, .value=0 },
    { .templ="-1", .offset=168ul, .value=1 },
    { .templ="workaround=%s", .offset=48ul, .value=0 },
    { .templ="idmap=none", .offset=96ul, .value=0 },
    { .templ="idmap=user", .offset=96ul, .value=1 },
    { .templ="idmap=file", .offset=96ul, .value=2 },
    { .templ="uidfile=%s", .offset=112ul, .value=0 },
    { .templ="gidfile=%s", .offset=120ul, .value=0 },
    { .templ="nomap=ignore", .offset=100ul, .value=0 },
    { .templ="nomap=error", .offset=100ul, .value=1 },
    { .templ="sshfs_sync", .offset=172ul, .value=1 },
    { .templ="no_readahead", .offset=176ul, .value=1 },
    { .templ="sync_readdir", .offset=180ul, .value=1 },
    { .templ="sshfs_debug", .offset=184ul, .value=1 },
    { .templ="reconnect", .offset=192ul, .value=1 },
    { .templ="transform_symlinks", .offset=80ul, .value=1 },
    { .templ="follow_symlinks", .offset=84ul, .value=1 },
    { .templ="no_check_root", .offset=88ul, .value=1 },
    { .templ="password_stdin", .offset=432ul, .value=1 },
    { .templ="delay_connect", .offset=196ul, .value=1 },
    { .templ="slave", .offset=200ul, .value=1 },
    { .templ="disable_hardlink", .offset=104ul, .value=1 },
    { .templ="-p ", .offset=(unsigned long int)-1U, .value=0 },
    { .templ="-C", .offset=(unsigned long int)-1U, .value=1 },
    { .templ="-V", .offset=(unsigned long int)-1U, .value=3 },
    { .templ="--version", .offset=(unsigned long int)-1U, .value=3 },
    { .templ="-h", .offset=(unsigned long int)-1U, .value=2 },
    { .templ="--help", .offset=(unsigned long int)-1U, .value=2 },
    { .templ="debug", .offset=(unsigned long int)-1U, .value=4 },
    { .templ="-d", .offset=(unsigned long int)-1U, .value=4 },
    { .templ="-f", .offset=(unsigned long int)-1U, .value=4 },
    { .templ="-F ", .offset=(unsigned long int)-1U, .value=5 },
    { .templ=(const char *)(void *)0, .offset=(unsigned long int)0, .value=0 } };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// workaround_opts
// file sshfs.c line 384
static struct fuse_opt workaround_opts[25l] = { { .templ="none", .offset=56ul, .value=0 },
    { .templ="none", .offset=60ul, .value=0 },
    { .templ="none", .offset=64ul, .value=0 },
    { .templ="none", .offset=68ul, .value=0 },
    { .templ="none", .offset=72ul, .value=0 },
    { .templ="none", .offset=76ul, .value=0 },
    { .templ="all", .offset=56ul, .value=1 },
    { .templ="all", .offset=60ul, .value=1 },
    { .templ="all", .offset=64ul, .value=1 },
    { .templ="all", .offset=68ul, .value=1 },
    { .templ="all", .offset=72ul, .value=1 },
    { .templ="all", .offset=76ul, .value=1 },
    { .templ="rename", .offset=56ul, .value=1 },
    { .templ="norename", .offset=56ul, .value=0 },
    { .templ="nodelay", .offset=60ul, .value=1 },
    { .templ="nonodelay", .offset=60ul, .value=0 },
    { .templ="nodelaysrv", .offset=64ul, .value=1 },
    { .templ="nonodelaysrv", .offset=64ul, .value=0 },
    { .templ="truncate", .offset=68ul, .value=1 },
    { .templ="notruncate", .offset=68ul, .value=0 },
    { .templ="buflimit", .offset=72ul, .value=1 },
    { .templ="nobuflimit", .offset=72ul, .value=0 },
    { .templ="fstat", .offset=76ul, .value=1 },
    { .templ="nofstat", .offset=76ul, .value=0 },
    { .templ=(const char *)(void *)0, .offset=(unsigned long int)0, .value=0 } };

// buf_add_buf
// file sshfs.c line 562
static inline void buf_add_buf(struct buffer *buf, struct buffer *bufa)
{
  buf_check_add(buf, bufa->len);
  memcpy((void *)(buf->p + (signed long int)buf->len), (const void *)bufa->p, bufa->len);
  buf->len = buf->len + bufa->len;
}

// buf_add_data
// file sshfs.c line 584
static inline void buf_add_data(struct buffer *buf, struct buffer *data)
{
  buf_add_uint32(buf, (unsigned int)data->len);
  buf_add_mem(buf, (const void *)data->p, data->len);
}

// buf_add_mem
// file sshfs.c line 556
static inline void buf_add_mem(struct buffer *buf, const void *data, unsigned long int len)
{
  buf_check_add(buf, len);
  memcpy((void *)(buf->p + (signed long int)buf->len), data, len);
  buf->len = buf->len + len;
}

// buf_add_path
// file sshfs.c line 598
static inline void buf_add_path(struct buffer *buf, const char *path)
{
  char *realpath;
  if(!(*sshfs.base_path == 0))
  {
    if(!(path[1l] == 0))
    {
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(sshfs.base_path);
      if(!((signed int)sshfs.base_path[-1l + (signed long int)return_value_strlen$1] == 47))
        realpath=g_strdup_printf("%s/%s", sshfs.base_path, path + (signed long int)1);

      else
        realpath=g_strdup_printf("%s%s", sshfs.base_path, path + (signed long int)1);
    }

    else
      realpath=g_strdup(sshfs.base_path);
  }

  else
    if(!(path[1l] == 0))
      realpath=g_strdup(path + (signed long int)1);

    else
      realpath=g_strdup(".");
  buf_add_string(buf, realpath);
  g_free((void *)realpath);
}

// buf_add_string
// file sshfs.c line 590
static inline void buf_add_string(struct buffer *buf, const char *str)
{
  struct buffer data;
  data.p = (unsigned char *)str;
  data.len=strlen(str);
  buf_add_data(buf, &data);
}

// buf_add_uint32
// file sshfs.c line 572
static inline void buf_add_uint32(struct buffer *buf, unsigned int val)
{
  unsigned int nval;
  nval=htonl(val);
  buf_check_add(buf, (unsigned long int)4);
  memcpy((void *)(buf->p + (signed long int)buf->len), (const void *)&nval, (unsigned long int)4);
  buf->len = buf->len + (unsigned long int)4;
}

// buf_add_uint64
// file sshfs.c line 578
static inline void buf_add_uint64(struct buffer *buf, unsigned long int val)
{
  buf_add_uint32(buf, (unsigned int)(val >> 32));
  buf_add_uint32(buf, (unsigned int)(val & (unsigned long int)0xffffffff));
}

// buf_add_uint8
// file sshfs.c line 567
static inline void buf_add_uint8(struct buffer *buf, unsigned char val)
{
  buf_check_add(buf, (unsigned long int)1);
  memcpy((void *)(buf->p + (signed long int)buf->len), (const void *)&val, (unsigned long int)1);
  buf->len = buf->len + (unsigned long int)1;
}

// buf_check_add
// file sshfs.c line 544
static inline void buf_check_add(struct buffer *buf, unsigned long int len)
{
  if(!(buf->size >= buf->len + len))
    buf_resize(buf, len);

}

// buf_check_get
// file sshfs.c line 626
static signed int buf_check_get(struct buffer *buf, unsigned long int len)
{
  if(!(buf->size >= buf->len + len))
  {
    fprintf(stderr, "buffer too short\n");
    return -1;
  }

  else
    return 0;
}

// buf_clear
// file sshfs.c line 528
static inline void buf_clear(struct buffer *buf)
{
  buf_free(buf);
  buf_init(buf, (unsigned long int)0);
}

// buf_finish
// file sshfs.c line 523
static inline void buf_finish(struct buffer *buf)
{
  buf->len = buf->size;
}

// buf_free
// file sshfs.c line 518
static inline void buf_free(struct buffer *buf)
{
  free((void *)buf->p);
}

// buf_get_attrs
// file sshfs.c line 694
static signed int buf_get_attrs(struct buffer *buf, struct stat *stbuf, signed int *flagsp)
{
  unsigned int flags;
  unsigned long int size = (unsigned long int)0;
  unsigned int uid = (unsigned int)0;
  unsigned int gid = (unsigned int)0;
  unsigned int atime = (unsigned int)0;
  unsigned int mtime = (unsigned int)0;
  unsigned int mode = (unsigned int)(0100000 | 0777);
  signed int return_value_buf_get_uint32$1;
  return_value_buf_get_uint32$1=buf_get_uint32(buf, &flags);
  signed int return_value_buf_get_uint64$2;
  signed int return_value_buf_get_uint32$3;
  _Bool tmp_if_expr$5;
  signed int return_value_buf_get_uint32$4;
  signed int return_value_buf_get_uint32$6;
  _Bool tmp_if_expr$9;
  signed int return_value_buf_get_uint32$8;
  signed int return_value_translate_id$13;
  signed int return_value_translate_id$14;
  if(return_value_buf_get_uint32$1 == -1)
    return -5;

  else
  {
    if(!(flagsp == ((signed int *)NULL)))
      *flagsp = (signed int)flags;

    if(!((1u & flags) == 0u))
    {
      return_value_buf_get_uint64$2=buf_get_uint64(buf, &size);
      if(!(return_value_buf_get_uint64$2 == -1))
        goto __CPROVER_DUMP_L3;

      return -5;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      if(!((2u & flags) == 0u))
      {
        return_value_buf_get_uint32$3=buf_get_uint32(buf, &uid);
        if(return_value_buf_get_uint32$3 == -1)
          tmp_if_expr$5 = (_Bool)1;

        else
        {
          return_value_buf_get_uint32$4=buf_get_uint32(buf, &gid);
          tmp_if_expr$5 = return_value_buf_get_uint32$4 == -1 ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr$5)
          goto __CPROVER_DUMP_L6;

        return -5;
      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        if(!((4u & flags) == 0u))
        {
          return_value_buf_get_uint32$6=buf_get_uint32(buf, &mode);
          if(!(return_value_buf_get_uint32$6 == -1))
            goto __CPROVER_DUMP_L7;

          return -5;
        }

        else
        {

        __CPROVER_DUMP_L7:
          ;
          if(!((8u & flags) == 0u))
          {
            signed int return_value_buf_get_uint32$7;
            return_value_buf_get_uint32$7=buf_get_uint32(buf, &atime);
            if(return_value_buf_get_uint32$7 == -1)
              tmp_if_expr$9 = (_Bool)1;

            else
            {
              return_value_buf_get_uint32$8=buf_get_uint32(buf, &mtime);
              tmp_if_expr$9 = return_value_buf_get_uint32$8 == -1 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$9)
              return -5;

          }

          if(!((0x80000000 & flags) == 0u))
          {
            unsigned int extcount;
            unsigned int i;
            signed int return_value_buf_get_uint32$10;
            return_value_buf_get_uint32$10=buf_get_uint32(buf, &extcount);
            if(return_value_buf_get_uint32$10 == -1)
              return -5;

            i = (unsigned int)0;
            for( ; !(i >= extcount); i = i + 1u)
            {
              struct buffer tmp;
              signed int return_value_buf_get_data$11;
              return_value_buf_get_data$11=buf_get_data(buf, &tmp);
              if(return_value_buf_get_data$11 == -1)
                return -5;

              buf_free(&tmp);
              signed int return_value_buf_get_data$12;
              return_value_buf_get_data$12=buf_get_data(buf, &tmp);
              if(return_value_buf_get_data$12 == -1)
                return -5;

              buf_free(&tmp);
            }
          }

          if(uid == sshfs.remote_uid && !(sshfs.remote_uid_detected == 0))
            uid = sshfs.local_uid;

          if(sshfs.idmap == 2 && !(sshfs.uid_map == ((struct _GHashTable *)NULL)))
          {
            return_value_translate_id$13=translate_id(&uid, sshfs.uid_map);
            if(!(return_value_translate_id$13 == -1))
              goto __CPROVER_DUMP_L19;

            return -1;
          }

          else
          {

          __CPROVER_DUMP_L19:
            ;
            if(sshfs.idmap == 2 && !(sshfs.gid_map == ((struct _GHashTable *)NULL)))
            {
              return_value_translate_id$14=translate_id(&gid, sshfs.gid_map);
              if(!(return_value_translate_id$14 == -1))
                goto __CPROVER_DUMP_L20;

              return -1;
            }

            else
            {

            __CPROVER_DUMP_L20:
              ;
              memset((void *)stbuf, 0, sizeof(struct stat) /*144ul*/ );
              stbuf->st_mode = mode;
              stbuf->st_nlink = (unsigned long int)1;
              stbuf->st_size = (signed long int)size;
              if(!(sshfs.blksize == 0u))
              {
                stbuf->st_blksize = (signed long int)sshfs.blksize;
                stbuf->st_blocks = (signed long int)(((size + (unsigned long int)sshfs.blksize) - (unsigned long int)1 & ~((unsigned long long int)sshfs.blksize - (unsigned long int)1)) >> 9);
              }

              stbuf->st_uid = uid;
              stbuf->st_gid = gid;
              stbuf->st_atim.tv_sec = (signed long int)atime;
              stbuf->st_mtim.tv_sec = (signed long int)mtime;
              stbuf->st_ctim.tv_sec = stbuf->st_mtim.tv_sec;
              return 0;
            }
          }
        }
      }
    }
  }
}

// buf_get_data
// file sshfs.c line 670
static inline signed int buf_get_data(struct buffer *buf, struct buffer *data)
{
  unsigned int len;
  signed int return_value_buf_get_uint32$1;
  return_value_buf_get_uint32$1=buf_get_uint32(buf, &len);
  _Bool tmp_if_expr$2;
  if(return_value_buf_get_uint32$1 == -1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (unsigned long int)len > buf->size - buf->len ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    return -1;

  else
  {
    buf_init(data, (unsigned long int)(len + (unsigned int)1));
    data->size = (unsigned long int)len;
    signed int return_value_buf_get_mem$3;
    return_value_buf_get_mem$3=buf_get_mem(buf, (void *)data->p, data->size);
    if(return_value_buf_get_mem$3 == -1)
    {
      buf_free(data);
      return -1;
    }

    else
      return 0;
  }
}

// buf_get_entries
// file sshfs.c line 806
static signed int buf_get_entries(struct buffer *buf, struct fuse_cache_dirhandle *h, signed int (*filler)(struct fuse_cache_dirhandle *, const char *, struct stat *))
{
  unsigned int count;
  unsigned int i;
  signed int return_value_buf_get_uint32$1;
  return_value_buf_get_uint32$1=buf_get_uint32(buf, &count);
  if(return_value_buf_get_uint32$1 == -1)
    return -5;

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= count); i = i + 1u)
    {
      signed int err = -1;
      char *name;
      char *longname;
      struct stat stbuf;
      signed int return_value_buf_get_string$2;
      return_value_buf_get_string$2=buf_get_string(buf, &name);
      if(return_value_buf_get_string$2 == -1)
        return -5;

      signed int return_value_buf_get_string$3;
      return_value_buf_get_string$3=buf_get_string(buf, &longname);
      if(!(return_value_buf_get_string$3 == -1))
      {
        free((void *)longname);
        err=buf_get_attrs(buf, &stbuf, (signed int *)(void *)0);
        if(err == 0)
        {
          if((61440u & stbuf.st_mode) == 40960u && !(sshfs.follow_symlinks == 0))
            stbuf.st_mode = (unsigned int)0;

          filler(h, name, &stbuf);
        }

      }

      free((void *)name);
      if(!(err == 0))
        return err;

    }
    return 0;
  }
}

// buf_get_mem
// file sshfs.c line 635
static inline signed int buf_get_mem(struct buffer *buf, void *data, unsigned long int len)
{
  signed int return_value_buf_check_get$1;
  return_value_buf_check_get$1=buf_check_get(buf, len);
  if(return_value_buf_check_get$1 == -1)
    return -1;

  else
  {
    memcpy(data, (const void *)(buf->p + (signed long int)buf->len), len);
    buf->len = buf->len + len;
    return 0;
  }
}

// buf_get_statvfs
// file sshfs.c line 764
static signed int buf_get_statvfs(struct buffer *buf, struct statvfs *stbuf)
{
  unsigned long int bsize;
  unsigned long int frsize;
  unsigned long int blocks;
  unsigned long int bfree;
  unsigned long int bavail;
  unsigned long int files;
  unsigned long int ffree;
  unsigned long int favail;
  unsigned long int fsid;
  unsigned long int flag;
  unsigned long int namemax;
  signed int return_value_buf_get_uint64$1;
  return_value_buf_get_uint64$1=buf_get_uint64(buf, &bsize);
  _Bool tmp_if_expr$3;
  signed int return_value_buf_get_uint64$2;
  if(return_value_buf_get_uint64$1 == -1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_buf_get_uint64$2=buf_get_uint64(buf, &frsize);
    tmp_if_expr$3 = return_value_buf_get_uint64$2 == -1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  signed int return_value_buf_get_uint64$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_buf_get_uint64$4=buf_get_uint64(buf, &blocks);
    tmp_if_expr$5 = return_value_buf_get_uint64$4 == -1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  signed int return_value_buf_get_uint64$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_buf_get_uint64$6=buf_get_uint64(buf, &bfree);
    tmp_if_expr$7 = return_value_buf_get_uint64$6 == -1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$9;
  signed int return_value_buf_get_uint64$8;
  if(tmp_if_expr$7)
    tmp_if_expr$9 = (_Bool)1;

  else
  {
    return_value_buf_get_uint64$8=buf_get_uint64(buf, &bavail);
    tmp_if_expr$9 = return_value_buf_get_uint64$8 == -1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$11;
  signed int return_value_buf_get_uint64$10;
  if(tmp_if_expr$9)
    tmp_if_expr$11 = (_Bool)1;

  else
  {
    return_value_buf_get_uint64$10=buf_get_uint64(buf, &files);
    tmp_if_expr$11 = return_value_buf_get_uint64$10 == -1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$13;
  signed int return_value_buf_get_uint64$12;
  if(tmp_if_expr$11)
    tmp_if_expr$13 = (_Bool)1;

  else
  {
    return_value_buf_get_uint64$12=buf_get_uint64(buf, &ffree);
    tmp_if_expr$13 = return_value_buf_get_uint64$12 == -1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$15;
  signed int return_value_buf_get_uint64$14;
  if(tmp_if_expr$13)
    tmp_if_expr$15 = (_Bool)1;

  else
  {
    return_value_buf_get_uint64$14=buf_get_uint64(buf, &favail);
    tmp_if_expr$15 = return_value_buf_get_uint64$14 == -1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$17;
  signed int return_value_buf_get_uint64$16;
  if(tmp_if_expr$15)
    tmp_if_expr$17 = (_Bool)1;

  else
  {
    return_value_buf_get_uint64$16=buf_get_uint64(buf, &fsid);
    tmp_if_expr$17 = return_value_buf_get_uint64$16 == -1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$19;
  signed int return_value_buf_get_uint64$18;
  if(tmp_if_expr$17)
    tmp_if_expr$19 = (_Bool)1;

  else
  {
    return_value_buf_get_uint64$18=buf_get_uint64(buf, &flag);
    tmp_if_expr$19 = return_value_buf_get_uint64$18 == -1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$21;
  signed int return_value_buf_get_uint64$20;
  if(tmp_if_expr$19)
    tmp_if_expr$21 = (_Bool)1;

  else
  {
    return_value_buf_get_uint64$20=buf_get_uint64(buf, &namemax);
    tmp_if_expr$21 = return_value_buf_get_uint64$20 == -1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$21)
    return -1;

  else
  {
    memset((void *)stbuf, 0, sizeof(struct statvfs) /*112ul*/ );
    stbuf->f_bsize = bsize;
    stbuf->f_frsize = frsize;
    stbuf->f_blocks = blocks;
    stbuf->f_bfree = bfree;
    stbuf->f_bavail = bavail;
    stbuf->f_files = files;
    stbuf->f_ffree = ffree;
    stbuf->f_favail = favail;
    stbuf->f_namemax = namemax;
    return 0;
  }
}

// buf_get_string
// file sshfs.c line 684
static inline signed int buf_get_string(struct buffer *buf, char **str)
{
  struct buffer data;
  signed int return_value_buf_get_data$1;
  return_value_buf_get_data$1=buf_get_data(buf, &data);
  if(return_value_buf_get_data$1 == -1)
    return -1;

  else
  {
    data.p[(signed long int)data.size] = (unsigned char)0;
    *str = (char *)data.p;
    return 0;
  }
}

// buf_get_uint32
// file sshfs.c line 649
static inline signed int buf_get_uint32(struct buffer *buf, unsigned int *val)
{
  unsigned int nval;
  signed int return_value_buf_get_mem$1;
  return_value_buf_get_mem$1=buf_get_mem(buf, (void *)&nval, (unsigned long int)4);
  if(return_value_buf_get_mem$1 == -1)
    return -1;

  else
  {
    *val=ntohl(nval);
    return 0;
  }
}

// buf_get_uint64
// file sshfs.c line 658
static inline signed int buf_get_uint64(struct buffer *buf, unsigned long int *val)
{
  unsigned int val1;
  unsigned int val2;
  signed int return_value_buf_get_uint32$1;
  return_value_buf_get_uint32$1=buf_get_uint32(buf, &val1);
  _Bool tmp_if_expr$3;
  signed int return_value_buf_get_uint32$2;
  if(return_value_buf_get_uint32$1 == -1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_buf_get_uint32$2=buf_get_uint32(buf, &val2);
    tmp_if_expr$3 = return_value_buf_get_uint32$2 == -1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    return -1;

  else
  {
    *val = ((unsigned long int)val1 << 32) + (unsigned long int)val2;
    return 0;
  }
}

// buf_get_uint8
// file sshfs.c line 644
static inline signed int buf_get_uint8(struct buffer *buf, unsigned char *val)
{
  signed int return_value_buf_get_mem$1;
  return_value_buf_get_mem$1=buf_get_mem(buf, (void *)val, (unsigned long int)1);
  return return_value_buf_get_mem$1;
}

// buf_init
// file sshfs.c line 504
static inline void buf_init(struct buffer *buf, unsigned long int size)
{
  if(!(size == 0ul))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(size);
    buf->p = (unsigned char *)return_value_malloc$1;
    if(buf->p == ((unsigned char *)NULL))
    {
      fprintf(stderr, "sshfs: memory allocation failed\n");
      abort();
    }

  }

  else
    buf->p = (unsigned char *)(void *)0;
  buf->len = (unsigned long int)0;
  buf->size = size;
}

// buf_resize
// file sshfs.c line 534
static void buf_resize(struct buffer *buf, unsigned long int len)
{
  buf->size = buf->len + len + (unsigned long int)63 & (unsigned long int)~31;
  void *return_value_realloc$1;
  return_value_realloc$1=realloc((void *)buf->p, buf->size);
  buf->p = (unsigned char *)return_value_realloc$1;
  if(buf->p == ((unsigned char *)NULL))
  {
    fprintf(stderr, "sshfs: memory allocation failed\n");
    abort();
  }

}

// buf_to_iov
// file sshfs.c line 1185
static void buf_to_iov(struct buffer *buf, struct iovec *iov)
{
  iov->iov_base = (void *)buf->p;
  iov->iov_len = buf->len;
}

// cache_add_attr
// file cache.h line 27
void cache_add_attr(const char *path, struct stat *stbuf, unsigned long int wrctr)
{
  struct node *node;
  if(!(cache.on == 0))
  {
    pthread_mutex_lock(&cache.lock);
    if(wrctr == cache.write_ctr)
    {
      node=cache_get(path);
      node->stat = *stbuf;
      signed long int return_value_time$1;
      return_value_time$1=time((signed long int *)(void *)0);
      node->stat_valid = return_value_time$1 + (signed long int)cache.stat_timeout;
      if(!(node->valid >= node->stat_valid))
        node->valid = node->stat_valid;

      cache_clean();
    }

    pthread_mutex_unlock(&cache.lock);
  }

}

// cache_add_dir
// file cache.c line 183
static void cache_add_dir(const char *path, char **dir)
{
  struct node *node;
  pthread_mutex_lock(&cache.lock);
  node=cache_get(path);
  g_strfreev(node->dir);
  node->dir = dir;
  signed long int return_value_time$1;
  return_value_time$1=time((signed long int *)(void *)0);
  node->dir_valid = return_value_time$1 + (signed long int)cache.dir_timeout;
  if(!(node->valid >= node->dir_valid))
    node->valid = node->dir_valid;

  cache_clean();
  pthread_mutex_unlock(&cache.lock);
}

// cache_add_link
// file cache.c line 205
static void cache_add_link(const char *path, const char *link, unsigned long int size)
{
  struct node *node;
  pthread_mutex_lock(&cache.lock);
  node=cache_get(path);
  g_free((void *)node->link);
  unsigned long int return_value_my_strnlen$1;
  return_value_my_strnlen$1=my_strnlen(link, size - (unsigned long int)1);
  node->link=g_strndup(link, return_value_my_strnlen$1);
  signed long int return_value_time$2;
  return_value_time$2=time((signed long int *)(void *)0);
  node->link_valid = return_value_time$2 + (signed long int)cache.link_timeout;
  if(!(node->valid >= node->link_valid))
    node->valid = node->link_valid;

  cache_clean();
  pthread_mutex_unlock(&cache.lock);
}

// cache_chmod
// file cache.c line 412
static signed int cache_chmod(const char *path, unsigned int mode)
{
  signed int err;
  err=cache.next_oper->oper.chmod(path, mode);
  if(err == 0)
    cache_invalidate(path);

  return err;
}

// cache_chown
// file cache.c line 420
static signed int cache_chown(const char *path, unsigned int uid, unsigned int gid)
{
  signed int err;
  err=cache.next_oper->oper.chown(path, uid, gid);
  if(err == 0)
    cache_invalidate(path);

  return err;
}

// cache_clean
// file cache.c line 70
static void cache_clean(void)
{
  signed long int now;
  now=time((signed long int *)(void *)0);
  unsigned int return_value_g_hash_table_size$1;
  if(!(5l + cache.last_cleaned >= now))
  {
    return_value_g_hash_table_size$1=g_hash_table_size(cache.table);
    if(return_value_g_hash_table_size$1 >= 10001u || !(60l + cache.last_cleaned >= now))
    {
      g_hash_table_foreach_remove(cache.table, (signed int (*)(void *, void *, void *))cache_clean_entry, (void *)&now);
      cache.last_cleaned = now;
    }

  }

}

// cache_clean_entry
// file cache.c line 61
static signed int cache_clean_entry(void *key_, struct node *node, signed long int *now)
{
  (void)key_;
  if(!(node->valid >= *now))
    return (signed int)!(0 != 0);

  else
    return 0;
}

// cache_create
// file cache.c line 454
static signed int cache_create(const char *path, unsigned int mode, struct fuse_file_info *fi)
{
  signed int err;
  err=cache.next_oper->oper.create(path, mode, fi);
  if(err == 0)
    cache_invalidate_dir(path);

  return err;
}

// cache_del_children
// file cache.c line 132
static signed int cache_del_children(const char *key, void *val_, const char *path)
{
  (void)val_;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(path);
  signed int return_value_strncmp$2;
  return_value_strncmp$2=strncmp(key, path, return_value_strlen$1);
  if(return_value_strncmp$2 == 0)
    return (signed int)!(0 != 0);

  else
    return 0;
}

// cache_dirfill
// file cache.c line 284
static signed int cache_dirfill(struct fuse_cache_dirhandle *ch, const char *name, struct stat *stbuf)
{
  signed int err;
  err=ch->filler(ch->h, name, 0, (unsigned long int)0);
  char *tmp_if_expr$2;
  if(err == 0)
  {
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup(name);
    g_ptr_array_add(ch->dir, (void *)return_value_g_strdup$1);
    if(!((61440u & stbuf->st_mode) == 0u))
    {
      char *fullpath;
      const char *basepath;
      if(ch->path[1l] == 0)
        tmp_if_expr$2 = "";

      else
        tmp_if_expr$2 = ch->path;
      basepath = tmp_if_expr$2;
      fullpath=g_strdup_printf("%s/%s", basepath, name);
      cache_add_attr(fullpath, stbuf, ch->wrctr);
      g_free((void *)fullpath);
    }

  }

  return err;
}

// cache_do_rename
// file cache.c line 141
static void cache_do_rename(const char *from, const char *to)
{
  pthread_mutex_lock(&cache.lock);
  g_hash_table_foreach_remove(cache.table, (signed int (*)(void *, void *, void *))cache_del_children, (void *)(char *)from);
  cache_purge(from);
  cache_purge(to);
  cache_purge_parent(from);
  cache_purge_parent(to);
  pthread_mutex_unlock(&cache.lock);
}

// cache_fgetattr
// file cache.c line 472
static signed int cache_fgetattr(const char *path, struct stat *stbuf, struct fuse_file_info *fi)
{
  signed int err;
  err=cache_get_attr(path, stbuf);
  if(!(err == 0))
  {
    unsigned long int wrctr;
    wrctr=cache_get_write_ctr();
    err=cache.next_oper->oper.fgetattr(path, stbuf, fi);
    if(err == 0)
      cache_add_attr(path, stbuf, wrctr);

  }

  return err;
}

// cache_fill
// file cache.c line 524
static void cache_fill(struct fuse_cache_operations *oper, struct fuse_operations *cache_oper)
{
  cache_oper->getattr = oper->oper.getattr != ((signed int (*)(const char *, struct stat *))NULL) ? cache_getattr : (signed int (*)(const char *path, struct stat *stbuf))(void *)0;
  cache_oper->readlink = oper->oper.readlink != ((signed int (*)(const char *, char *, unsigned long int))NULL) ? cache_readlink : (signed int (*)(const char *path, char *buf, unsigned long int size))(void *)0;
  cache_oper->getdir = oper->cache_getdir != ((signed int (*)(const char *, struct fuse_cache_dirhandle *, signed int (*)(struct fuse_cache_dirhandle *, const char *, struct stat *)))NULL) ? cache_getdir : (signed int (*)(const char *path, struct fuse_dirhandle *h, signed int (*filler)(struct fuse_dirhandle *, const char *, signed int, unsigned long int)))(void *)0;
  cache_oper->mknod = oper->oper.mknod != ((signed int (*)(const char *, unsigned int, unsigned long int))NULL) ? cache_mknod : (signed int (*)(const char *path, unsigned int mode, unsigned long int rdev))(void *)0;
  cache_oper->mkdir = oper->oper.mkdir != ((signed int (*)(const char *, unsigned int))NULL) ? cache_mkdir : (signed int (*)(const char *path, unsigned int mode))(void *)0;
  cache_oper->symlink = oper->oper.symlink != ((signed int (*)(const char *, const char *))NULL) ? cache_symlink : (signed int (*)(const char *from, const char *to))(void *)0;
  cache_oper->unlink = oper->oper.unlink != ((signed int (*)(const char *))NULL) ? cache_unlink : (signed int (*)(const char *path))(void *)0;
  cache_oper->rmdir = oper->oper.rmdir != ((signed int (*)(const char *))NULL) ? cache_rmdir : (signed int (*)(const char *path))(void *)0;
  cache_oper->rename = oper->oper.rename != ((signed int (*)(const char *, const char *))NULL) ? cache_rename : (signed int (*)(const char *from, const char *to))(void *)0;
  cache_oper->link = oper->oper.link != ((signed int (*)(const char *, const char *))NULL) ? cache_link : (signed int (*)(const char *from, const char *to))(void *)0;
  cache_oper->chmod = oper->oper.chmod != ((signed int (*)(const char *, unsigned int))NULL) ? cache_chmod : (signed int (*)(const char *path, unsigned int mode))(void *)0;
  cache_oper->chown = oper->oper.chown != ((signed int (*)(const char *, unsigned int, unsigned int))NULL) ? cache_chown : (signed int (*)(const char *path, unsigned int uid, unsigned int gid))(void *)0;
  cache_oper->truncate = oper->oper.truncate != ((signed int (*)(const char *, signed long int))NULL) ? cache_truncate : (signed int (*)(const char *path, signed long int size))(void *)0;
  cache_oper->utime = oper->oper.utime != ((signed int (*)(const char *, struct utimbuf *))NULL) ? cache_utime : (signed int (*)(const char *path, struct utimbuf *buf))(void *)0;
  cache_oper->write = oper->oper.write != ((signed int (*)(const char *, const char *, unsigned long int, signed long int, struct fuse_file_info *))NULL) ? cache_write : (signed int (*)(const char *path, const char *buf, unsigned long int size, signed long int offset, struct fuse_file_info *fi))(void *)0;
  cache_oper->create = oper->oper.create != ((signed int (*)(const char *, unsigned int, struct fuse_file_info *))NULL) ? cache_create : (signed int (*)(const char *path, unsigned int mode, struct fuse_file_info *fi))(void *)0;
  cache_oper->ftruncate = oper->oper.ftruncate != ((signed int (*)(const char *, signed long int, struct fuse_file_info *))NULL) ? cache_ftruncate : (signed int (*)(const char *path, signed long int size, struct fuse_file_info *fi))(void *)0;
  cache_oper->fgetattr = oper->oper.fgetattr != ((signed int (*)(const char *, struct stat *, struct fuse_file_info *))NULL) ? cache_fgetattr : (signed int (*)(const char *path, struct stat *stbuf, struct fuse_file_info *fi))(void *)0;
}

// cache_ftruncate
// file cache.c line 463
static signed int cache_ftruncate(const char *path, signed long int size, struct fuse_file_info *fi)
{
  signed int err;
  err=cache.next_oper->oper.ftruncate(path, size, fi);
  if(err == 0)
    cache_invalidate(path);

  return err;
}

// cache_get
// file cache.c line 153
static struct node * cache_get(const char *path)
{
  struct node *node;
  node=cache_lookup(path);
  if(node == ((struct node *)NULL))
  {
    char *pathcopy;
    pathcopy=g_strdup(path);
    void *return_value_g_malloc0_n$1;
    return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct node) /*192ul*/ );
    node = (struct node *)return_value_g_malloc0_n$1;
    g_hash_table_insert(cache.table, (void *)pathcopy, (void *)node);
  }

  return node;
}

// cache_get_attr
// file cache.c line 220
static signed int cache_get_attr(const char *path, struct stat *stbuf)
{
  struct node *node;
  signed int err = -11;
  pthread_mutex_lock(&cache.lock);
  node=cache_lookup(path);
  if(!(node == ((struct node *)NULL)))
  {
    signed long int now;
    now=time((signed long int *)(void *)0);
    if(node->stat_valid + -now >= 0l)
    {
      *stbuf = node->stat;
      err = 0;
    }

  }

  pthread_mutex_unlock(&cache.lock);
  return err;
}

// cache_get_write_ctr
// file cache.h line 29
unsigned long int cache_get_write_ctr(void)
{
  unsigned long int res;
  pthread_mutex_lock(&cache.lock);
  res = cache.write_ctr;
  pthread_mutex_unlock(&cache.lock);
  return res;
}

// cache_getattr
// file cache.c line 248
static signed int cache_getattr(const char *path, struct stat *stbuf)
{
  signed int err;
  err=cache_get_attr(path, stbuf);
  if(!(err == 0))
  {
    unsigned long int wrctr;
    wrctr=cache_get_write_ctr();
    err=cache.next_oper->oper.getattr(path, stbuf);
    if(err == 0)
      cache_add_attr(path, stbuf, wrctr);

  }

  return err;
}

// cache_getdir
// file cache.c line 302
static signed int cache_getdir(const char *path, struct fuse_dirhandle *h, signed int (*filler)(struct fuse_dirhandle *, const char *, signed int, unsigned long int))
{
  struct fuse_cache_dirhandle ch;
  signed int err;
  char **dir;
  struct node *node;
  pthread_mutex_lock(&cache.lock);
  node=cache_lookup(path);
  if(!(node == ((struct node *)NULL)))
  {
    if(!(node->dir == ((char **)NULL)))
    {
      signed long int now;
      now=time((signed long int *)(void *)0);
      if(node->dir_valid + -now >= 0l)
      {
        dir = node->dir;
        if(!(*dir == ((char *)NULL)))
        {
          filler(h, *dir, 0, (unsigned long int)0);
          dir = dir + 1l;
        }

        pthread_mutex_unlock(&cache.lock);
        return 0;
      }

    }

  }

  pthread_mutex_unlock(&cache.lock);
  ch.path = path;
  ch.h = h;
  ch.filler = filler;
  ch.dir=g_ptr_array_new();
  ch.wrctr=cache_get_write_ctr();
  err=cache.next_oper->cache_getdir(path, &ch, cache_dirfill);
  g_ptr_array_add(ch.dir, (void *)0);
  dir = (char **)ch.dir->pdata;
  if(err == 0)
    cache_add_dir(path, dir);

  else
    g_strfreev(dir);
  g_ptr_array_free(ch.dir, 0);
  return err;
}

// cache_init
// file cache.h line 25
struct fuse_operations * cache_init(struct fuse_cache_operations *oper)
{
  cache.next_oper = oper;
  static struct fuse_operations cache_oper;
  cache_unity_fill(oper, &cache_oper);
  if(!(cache.on == 0))
  {
    cache_fill(oper, &cache_oper);
    pthread_mutex_init(&cache.lock, (const union anonymous$3 *)(void *)0);
    cache.table=g_hash_table_new_full(g_str_hash, g_str_equal, g_free, free_node);
    if(!(cache.table == ((struct _GHashTable *)NULL)))
      goto __CPROVER_DUMP_L1;

    fprintf(stderr, "failed to create cache\n");
    return (struct fuse_operations *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return &cache_oper;
  }
}

// cache_invalidate
// file cache.h line 28
void cache_invalidate(const char *path)
{
  if(!(cache.on == 0))
  {
    pthread_mutex_lock(&cache.lock);
    cache_purge(path);
    pthread_mutex_unlock(&cache.lock);
  }

}

// cache_invalidate_dir
// file cache.c line 124
static void cache_invalidate_dir(const char *path)
{
  pthread_mutex_lock(&cache.lock);
  cache_purge(path);
  cache_purge_parent(path);
  pthread_mutex_unlock(&cache.lock);
}

// cache_invalidate_write
// file cache.c line 116
void cache_invalidate_write(const char *path)
{
  pthread_mutex_lock(&cache.lock);
  cache_purge(path);
  cache.write_ctr = cache.write_ctr + 1ul;
  pthread_mutex_unlock(&cache.lock);
}

// cache_link
// file cache.c line 402
static signed int cache_link(const char *from, const char *to)
{
  signed int err;
  err=cache.next_oper->oper.link(from, to);
  if(err == 0)
  {
    cache_invalidate(from);
    cache_invalidate_dir(to);
  }

  return err;
}

// cache_lookup
// file cache.c line 82
static struct node * cache_lookup(const char *path)
{
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(cache.table, (const void *)path);
  return (struct node *)return_value_g_hash_table_lookup$1;
}

// cache_mkdir
// file cache.c line 362
static signed int cache_mkdir(const char *path, unsigned int mode)
{
  signed int err;
  err=cache.next_oper->oper.mkdir(path, mode);
  if(err == 0)
    cache_invalidate_dir(path);

  return err;
}

// cache_mknod
// file cache.c line 354
static signed int cache_mknod(const char *path, unsigned int mode, unsigned long int rdev)
{
  signed int err;
  err=cache.next_oper->oper.mknod(path, mode, rdev);
  if(err == 0)
    cache_invalidate_dir(path);

  return err;
}

// cache_parse_options
// file cache.h line 26
signed int cache_parse_options(struct fuse_args *args)
{
  cache.stat_timeout = (unsigned int)20;
  cache.dir_timeout = (unsigned int)20;
  cache.link_timeout = (unsigned int)20;
  cache.on = 1;
  signed int return_value_fuse_opt_parse$1;
  return_value_fuse_opt_parse$1=fuse_opt_parse(args, (void *)&cache, cache_opts, (signed int (*)(void *, const char *, signed int, struct fuse_args *))(void *)0);
  return return_value_fuse_opt_parse$1;
}

// cache_purge
// file cache.c line 87
static void cache_purge(const char *path)
{
  g_hash_table_remove(cache.table, (const void *)path);
}

// cache_purge_parent
// file cache.c line 92
static void cache_purge_parent(const char *path)
{
  const char *s;
  s=strrchr(path, 47);
  if(!(s == ((const char *)NULL)))
  {
    if(s == path)
      g_hash_table_remove(cache.table, (const void *)"/");

    else
    {
      char *parent;
      parent=g_strndup(path, (unsigned long int)(s - path));
      cache_purge(parent);
      g_free((void *)parent);
    }
  }

}

// cache_readlink
// file cache.c line 260
static signed int cache_readlink(const char *path, char *buf, unsigned long int size)
{
  struct node *node;
  signed int err;
  pthread_mutex_lock(&cache.lock);
  node=cache_lookup(path);
  if(!(node == ((struct node *)NULL)))
  {
    signed long int now;
    now=time((signed long int *)(void *)0);
    if(node->link_valid + -now >= 0l)
    {
      strncpy(buf, node->link, size - (unsigned long int)1);
      buf[(signed long int)(size - (unsigned long int)1)] = (char)0;
      pthread_mutex_unlock(&cache.lock);
      return 0;
    }

  }

  pthread_mutex_unlock(&cache.lock);
  err=cache.next_oper->oper.readlink(path, buf, size);
  if(err == 0)
    cache_add_link(path, buf, size);

  return err;
}

// cache_rename
// file cache.c line 394
static signed int cache_rename(const char *from, const char *to)
{
  signed int err;
  err=cache.next_oper->oper.rename(from, to);
  if(err == 0)
    cache_do_rename(from, to);

  return err;
}

// cache_rmdir
// file cache.c line 378
static signed int cache_rmdir(const char *path)
{
  signed int err;
  err=cache.next_oper->oper.rmdir(path);
  if(err == 0)
    cache_invalidate_dir(path);

  return err;
}

// cache_symlink
// file cache.c line 386
static signed int cache_symlink(const char *from, const char *to)
{
  signed int err;
  err=cache.next_oper->oper.symlink(from, to);
  if(err == 0)
    cache_invalidate_dir(to);

  return err;
}

// cache_truncate
// file cache.c line 428
static signed int cache_truncate(const char *path, signed long int size)
{
  signed int err;
  err=cache.next_oper->oper.truncate(path, size);
  if(err == 0)
    cache_invalidate(path);

  return err;
}

// cache_unity_dirfill
// file cache.c line 338
static signed int cache_unity_dirfill(struct fuse_cache_dirhandle *ch, const char *name, struct stat *stbuf)
{
  (void)stbuf;
  signed int return_value;
  return_value=ch->filler(ch->h, name, 0, (unsigned long int)0);
  return return_value;
}

// cache_unity_fill
// file cache.c line 486
static void cache_unity_fill(struct fuse_cache_operations *oper, struct fuse_operations *cache_oper)
{
  cache_oper->init = oper->oper.init;
  cache_oper->getattr = oper->oper.getattr;
  cache_oper->readlink = oper->oper.readlink;
  cache_oper->getdir = cache_unity_getdir;
  cache_oper->mknod = oper->oper.mknod;
  cache_oper->mkdir = oper->oper.mkdir;
  cache_oper->symlink = oper->oper.symlink;
  cache_oper->unlink = oper->oper.unlink;
  cache_oper->rmdir = oper->oper.rmdir;
  cache_oper->rename = oper->oper.rename;
  cache_oper->link = oper->oper.link;
  cache_oper->chmod = oper->oper.chmod;
  cache_oper->chown = oper->oper.chown;
  cache_oper->truncate = oper->oper.truncate;
  cache_oper->utime = oper->oper.utime;
  cache_oper->open = oper->oper.open;
  cache_oper->read = oper->oper.read;
  cache_oper->write = oper->oper.write;
  cache_oper->flush = oper->oper.flush;
  cache_oper->release = oper->oper.release;
  cache_oper->fsync = oper->oper.fsync;
  cache_oper->statfs = oper->oper.statfs;
  cache_oper->setxattr = oper->oper.setxattr;
  cache_oper->getxattr = oper->oper.getxattr;
  cache_oper->listxattr = oper->oper.listxattr;
  cache_oper->removexattr = oper->oper.removexattr;
  cache_oper->create = oper->oper.create;
  cache_oper->ftruncate = oper->oper.ftruncate;
  cache_oper->fgetattr = oper->oper.fgetattr;
}

// cache_unity_getdir
// file cache.c line 345
static signed int cache_unity_getdir(const char *path, struct fuse_dirhandle *h, signed int (*filler)(struct fuse_dirhandle *, const char *, signed int, unsigned long int))
{
  struct fuse_cache_dirhandle ch;
  ch.h = h;
  ch.filler = filler;
  signed int return_value;
  return_value=cache.next_oper->cache_getdir(path, &ch, cache_unity_dirfill);
  return return_value;
}

// cache_unlink
// file cache.c line 370
static signed int cache_unlink(const char *path)
{
  signed int err;
  err=cache.next_oper->oper.unlink(path);
  if(err == 0)
    cache_invalidate_dir(path);

  return err;
}

// cache_utime
// file cache.c line 436
static signed int cache_utime(const char *path, struct utimbuf *buf)
{
  signed int err;
  err=cache.next_oper->oper.utime(path, buf);
  if(err == 0)
    cache_invalidate(path);

  return err;
}

// cache_write
// file cache.c line 444
static signed int cache_write(const char *path, const char *buf, unsigned long int size, signed long int offset, struct fuse_file_info *fi)
{
  signed int res;
  res=cache.next_oper->oper.write(path, buf, size, offset, fi);
  if(res >= 0)
    cache_invalidate_write(path);

  return res;
}

// calc_buf_size
// file sshfs.c line 3109
static unsigned long int calc_buf_size(signed long int size, signed long int offset)
{
  return (unsigned long int)(offset + (signed long int)sshfs.max_read < size ? (signed long int)sshfs.max_read : size - offset);
}

// check_large_read
// file sshfs.c line 3454
static void check_large_read(struct fuse_args *args)
{
  struct utsname buf;
  signed int err;
  err=uname(&buf);
  signed int return_value_strcmp$2;
  signed int return_value_strncmp$1;
  if(err == 0)
  {
    return_value_strcmp$2=strcmp(buf.sysname, "Linux");
    if(return_value_strcmp$2 == 0)
    {
      return_value_strncmp$1=strncmp(buf.release, "2.4.", (unsigned long int)4);
      if(return_value_strncmp$1 == 0)
        fuse_opt_insert_arg(args, 1, "-olarge_read");

    }

  }

}

// chunk_free
// file sshfs.c line 1277
static void chunk_free(struct read_chunk *chunk)
{
  signed int return_value_list_empty$1;
  struct read_req *tmp_statement_expression$2;
  do
  {
    return_value_list_empty$1=list_empty(&chunk->reqs);
    if(!(return_value_list_empty$1 == 0))
      break;

    struct read_req *rreq;
    const struct list_head *__mptr = chunk->reqs.prev;
    tmp_statement_expression$2 = (struct read_req *)((char *)__mptr - (signed long int)8ul);
    rreq = tmp_statement_expression$2;
    list_del(&rreq->list);
    buf_free(&rreq->data);
    g_free((void *)rreq);
  }
  while((_Bool)1);
  g_free((void *)chunk);
}

// chunk_put
// file sshfs.c line 1290
static void chunk_put(struct read_chunk *chunk)
{
  if(!(chunk == ((struct read_chunk *)NULL)))
  {
    chunk->refs = chunk->refs - 1;
    if(chunk->refs == 0)
      chunk_free(chunk);

  }

}

// chunk_put_locked
// file sshfs.c line 1299
static void chunk_put_locked(struct read_chunk *chunk)
{
  pthread_mutex_lock(&sshfs.lock);
  chunk_put(chunk);
  pthread_mutex_unlock(&sshfs.lock);
}

// clean_req
// file sshfs.c line 1306
static signed int clean_req(void *key_, struct request *req)
{
  (void)key_;
  req->error = -5;
  if(!(req->want_reply == 0u))
    sem_post(&req->ready);

  else
  {
    if(!(req->end_func == ((void (*)(struct request *))NULL)))
      req->end_func(req);

    request_free(req);
  }
  return (signed int)!(0 != 0);
}

// close_conn
// file sshfs.c line 1392
static void close_conn(void)
{
  close(sshfs.rfd);
  if(!(sshfs.rfd == sshfs.wfd))
    close(sshfs.wfd);

  sshfs.rfd = -1;
  sshfs.wfd = -1;
  if(!(sshfs.ptyfd == -1))
  {
    close(sshfs.ptyfd);
    sshfs.ptyfd = -1;
  }

  if(!(sshfs.ptyslavefd == -1))
  {
    close(sshfs.ptyslavefd);
    sshfs.ptyslavefd = -1;
  }

}

// connect_remote
// file sshfs.c line 1685
static signed int connect_remote(void)
{
  signed int err;
  if(!(sshfs.slave == 0))
    err=connect_slave();

  else
    if(!(sshfs.directport == ((char *)NULL)))
      err=connect_to(sshfs.host, sshfs.directport);

    else
      err=start_ssh();
  if(err == 0)
    err=sftp_init();

  if(!(err == 0))
    close_conn();

  else
    sshfs.num_connect = sshfs.num_connect + 1u;
  return err;
}

// connect_slave
// file sshfs.c line 1106
static signed int connect_slave()
{
  sshfs.rfd = 0;
  sshfs.wfd = 1;
  return 0;
}

// connect_to
// file sshfs.c line 1113
static signed int connect_to(char *host, char *port)
{
  signed int err;
  signed int sock;
  signed int opt;
  struct addrinfo *ai;
  struct addrinfo hint;
  memset((void *)&hint, 0, sizeof(struct addrinfo) /*48ul*/ );
  hint.ai_family = 2;
  hint.ai_socktype = 1;
  err=getaddrinfo(host, port, &hint, &ai);
  if(!(err == 0))
  {
    const char *return_value_gai_strerror$1;
    return_value_gai_strerror$1=gai_strerror(err);
    fprintf(stderr, "failed to resolve %s:%s: %s\n", host, port, return_value_gai_strerror$1);
    return -1;
  }

  sock=socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
  if(sock == -1)
  {
    perror("failed to create socket");
    return -1;
  }

  else
  {
    err=connect(sock, ai->ai_addr, ai->ai_addrlen);
    if(err == -1)
    {
      perror("failed to connect");
      return -1;
    }

    else
    {
      opt = 1;
      err=setsockopt(sock, 6, 1, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(err == -1)
        perror("warning: failed to set TCP_NODELAY");

      freeaddrinfo(ai);
      sshfs.rfd = sock;
      sshfs.wfd = sock;
      return 0;
    }
  }
}

// count_components
// file sshfs.c line 1935
static signed int count_components(const char *p)
{
  signed int ctr;
  for( ; (signed int)*p == 47; p = p + 1l)
    ;
  ctr = 0;
  _Bool tmp_if_expr$1;
  for( ; !(*p == 0); ctr = ctr + 1)
  {
    do
    {
      if(!(*p == 0))
        tmp_if_expr$1 = (signed int)*p != 47 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
        break;

      p = p + 1l;
    }
    while((_Bool)1);
    for( ; (signed int)*p == 47; p = p + 1l)
      ;
  }
  return ctr;
}

// do_read
// file sshfs.c line 1227
static signed int do_read(struct buffer *buf)
{
  signed int res;
  unsigned char *p = buf->p;
  unsigned long int size = buf->size;
  while(!(size == 0ul))
  {
    signed long int return_value_read$1;
    return_value_read$1=read(sshfs.rfd, (void *)p, size);
    res = (signed int)return_value_read$1;
    if(res == -1)
    {
      perror("read");
      return -1;
    }

    else
      if(res == 0)
      {
        fprintf(stderr, "remote host has disconnected\n");
        return -1;
      }

    size = size - (unsigned long int)res;
    p = p + (signed long int)res;
  }
  return 0;
}

// do_write
// file sshfs.c line 1152
static signed int do_write(struct iovec *iov, unsigned long int count)
{
  signed int res;
  while(!(count == 0ul))
  {
    signed long int return_value_writev$1;
    return_value_writev$1=writev(sshfs.wfd, iov, (signed int)count);
    res = (signed int)return_value_writev$1;
    if(res == -1)
    {
      perror("write");
      return -1;
    }

    else
      if(res == 0)
      {
        fprintf(stderr, "zero write\n");
        return -1;
      }

    while((_Bool)1)
    {
      if(!((unsigned long int)(unsigned int)res >= iov->iov_len))
      {
        iov->iov_len = iov->iov_len - (unsigned long int)res;
        iov->iov_base = iov->iov_base + (signed long int)res;
        goto __CPROVER_DUMP_L6;
      }

      else
      {
        res = res - (signed int)iov->iov_len;
        count = count - 1ul;
        iov = iov + 1l;
      }
      if(count == 0ul)
        break;

    }

  __CPROVER_DUMP_L6:
    ;
  }
  return 0;
}

// find_base_path
// file sshfs.c line 3540
static char * find_base_path(void)
{
  char *s = sshfs.host;
  char *d = s;
  _Bool tmp_if_expr$1;
  char *tmp_post$2;
  char *tmp_post$3;
  do
  {
    if(!(*s == 0))
      tmp_if_expr$1 = (signed int)*s != 58 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    if((signed int)*s == 91)
    {
      s = s + 1l;
      for( ; !((signed int)*s == 93); s = s + 1l)
      {
        if(*s == 0)
        {
          fprintf(stderr, "missing ']' in hostname\n");
          exit(1);
        }

        tmp_post$2 = d;
        d = d + 1l;
        *tmp_post$2 = *s;
      }
    }

    else
    {
      tmp_post$3 = d;
      d = d + 1l;
      *tmp_post$3 = *s;
    }
    s = s + 1l;
  }
  while((_Bool)1);
  char *tmp_post$4 = d;
  d = d + 1l;
  *tmp_post$4 = (char)0;
  s = s + 1l;
  return s;
}

// free_node
// file cache.c line 54
static void free_node(void *node_)
{
  struct node *node = (struct node *)node_;
  g_strfreev(node->dir);
  g_free((void *)node);
}

// fsname_escape_commas
// file sshfs.c line 3588
static char * fsname_escape_commas(char *fsnameold)
{
  char *fsname;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(fsnameold);
  void *return_value_g_malloc$2;
  return_value_g_malloc$2=g_malloc(return_value_strlen$1 * (unsigned long int)2 + (unsigned long int)1);
  fsname = (char *)return_value_g_malloc$2;
  char *d = fsname;
  char *s = fsnameold;
  _Bool tmp_if_expr$4;
  char *tmp_post$3;
  char *tmp_post$5;
  for( ; !(*s == 0); s = s + 1l)
  {
    if((signed int)*s == 92)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)*s == 44 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
    {
      tmp_post$3 = d;
      d = d + 1l;
      *tmp_post$3 = (char)92;
    }

    tmp_post$5 = d;
    d = d + 1l;
    *tmp_post$5 = *s;
  }
  *d = (char)0;
  g_free((void *)fsnameold);
  return fsname;
}

// fsname_remove_commas
// file sshfs.c line 3573
static void fsname_remove_commas(char *fsname)
{
  char *return_value_strchr$2;
  return_value_strchr$2=strchr(fsname, 44);
  char *tmp_post$1;
  if(!(return_value_strchr$2 == ((char *)NULL)))
  {
    char *s = fsname;
    char *d = s;
    for( ; !(*s == 0); s = s + 1l)
      if(!((signed int)*s == 44))
      {
        tmp_post$1 = d;
        d = d + 1l;
        *tmp_post$1 = *s;
      }

    *d = *s;
  }

}

// get_sshfs_file
// file sshfs.c line 2506
static inline struct sshfs_file * get_sshfs_file(struct fuse_file_info *fi)
{
  return (struct sshfs_file *)(unsigned long int)fi->fh;
}

// groupname_to_gid
// file sshfs.c line 3769
static unsigned int * groupname_to_gid(char *name)
{
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  struct group *gr;
  gr=getgrnam(name);
  if(gr == ((struct group *)NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(*return_value___errno_location$2 == 0)
      return (unsigned int *)(void *)0;

    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    fprintf(stderr, "Failed to look up group '%s': %s\n", name, return_value_strerror$4);
    exit(1);
  }

  unsigned int *r;
  void *return_value_malloc$5;
  return_value_malloc$5=malloc(sizeof(unsigned int) /*4ul*/ );
  r = (unsigned int *)return_value_malloc$5;
  if(r == ((unsigned int *)NULL))
  {
    fprintf(stderr, "sshfs: memory allocation failed\n");
    abort();
  }

  *r = gr->gr_gid;
  return r;
}

// iov_length
// file sshfs.c line 1191
static unsigned long int iov_length(struct iovec *iov, unsigned long int nr_segs)
{
  unsigned long int seg;
  unsigned long int ret = (unsigned long int)0;
  seg = (unsigned long int)0;
  for( ; !(seg >= nr_segs); seg = seg + 1ul)
    ret = ret + (iov + (signed long int)seg)->iov_len;
  return ret;
}

// is_ssh_opt
// file sshfs.c line 3322
static signed int is_ssh_opt(const char *arg)
{
  signed int return_value_strncasecmp$3;
  if(!((signed int)*arg == 45))
  {
    unsigned int arglen;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(arg);
    arglen = (unsigned int)return_value_strlen$1;
    const char **o = ssh_opts;
    for( ; !(*o == ((const char *)NULL)); o = o + 1l)
    {
      unsigned int olen;
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(*o);
      olen = (unsigned int)return_value_strlen$2;
      if(!(olen >= arglen))
      {
        if((signed int)arg[(signed long int)olen] == 61)
        {
          return_value_strncasecmp$3=strncasecmp(arg, *o, (unsigned long int)olen);
          if(return_value_strncasecmp$3 == 0)
            return 1;

        }

      }

    }
  }

  return 0;
}

// list_add
// file sshfs.c line 462
static void list_add(struct list_head *new, struct list_head *head)
{
  struct list_head *prev = head;
  struct list_head *next = head->next;
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
}

// list_del
// file sshfs.c line 472
static void list_del(struct list_head *entry)
{
  struct list_head *prev = entry->prev;
  struct list_head *next = entry->next;
  next->prev = prev;
  prev->next = next;
}

// list_empty
// file sshfs.c line 481
static signed int list_empty(struct list_head *head)
{
  return (signed int)(head->next == head);
}

// list_init
// file sshfs.c line 456
static void list_init(struct list_head *head)
{
  head->next = head;
  head->prev = head;
}

// load_gid_map
// file sshfs.c line 3796
static inline void load_gid_map(void)
{
  read_id_map(sshfs.gid_file, groupname_to_gid, "gid", &sshfs.gid_map, &sshfs.r_gid_map);
}

// load_uid_map
// file sshfs.c line 3791
static inline void load_uid_map(void)
{
  read_id_map(sshfs.uid_file, username_to_uid, "uid", &sshfs.uid_map, &sshfs.r_uid_map);
}

// main
// file sshfs.c line 3801
signed int main(signed int argc, char **argv)
{
  signed int res;
  struct fuse_args args = { .argc=argc, .argv=argv, .allocated=0 };
  char *tmp;
  char *fsname;
  const char *sftp_server;
  signed int libver;
  g_thread_init((void *)0);
  sshfs.blksize = (unsigned int)4096;
  sshfs.max_read = (unsigned int)32768;
  sshfs.max_write = (unsigned int)32768;
  sshfs.nodelay_workaround = 1;
  sshfs.nodelaysrv_workaround = 0;
  sshfs.rename_workaround = 0;
  sshfs.truncate_workaround = 0;
  sshfs.buflimit_workaround = 1;
  sshfs.ssh_ver = (unsigned int)2;
  sshfs.progname = argv[(signed long int)0];
  sshfs.rfd = -1;
  sshfs.wfd = -1;
  sshfs.ptyfd = -1;
  sshfs.ptyslavefd = -1;
  sshfs.delay_connect = 0;
  sshfs.slave = 0;
  sshfs.detect_uid = 0;
  sshfs.idmap = 0;
  sshfs.nomap = 1;
  ssh_add_arg("ssh");
  ssh_add_arg("-x");
  ssh_add_arg("-a");
  ssh_add_arg("-oClearAllForwardings=yes");
  signed int return_value_fuse_opt_parse$1;
  return_value_fuse_opt_parse$1=fuse_opt_parse(&args, (void *)&sshfs, sshfs_opts, sshfs_opt_proc);
  _Bool tmp_if_expr$3;
  signed int return_value_parse_workarounds$2;
  if(return_value_fuse_opt_parse$1 == -1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_parse_workarounds$2=parse_workarounds();
    tmp_if_expr$3 = return_value_parse_workarounds$2 == -1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    exit(1);

  if(sshfs.idmap == 1)
    sshfs.detect_uid = 1;

  else
    if(sshfs.idmap == 2)
    {
      sshfs.uid_map = (struct _GHashTable *)(void *)0;
      sshfs.gid_map = (struct _GHashTable *)(void *)0;
      sshfs.r_uid_map = (struct _GHashTable *)(void *)0;
      sshfs.r_gid_map = (struct _GHashTable *)(void *)0;
      if(sshfs.gid_file == ((char *)NULL) && sshfs.uid_file == ((char *)NULL))
      {
        fprintf(stderr, "need a uidfile or gidfile with idmap=file\n");
        exit(1);
      }

      if(!(sshfs.uid_file == ((char *)NULL)))
        load_uid_map();

      if(!(sshfs.gid_file == ((char *)NULL)))
        load_gid_map();

    }

  free((void *)sshfs.uid_file);
  free((void *)sshfs.gid_file);
  do
    if(!(sshfs.debug == 0))
      fprintf(stderr, "SSHFS version %s\n", (const void *)"2.5");

  while((_Bool)0);
  if(!(sshfs.slave == 0))
    sshfs.foreground = 1;

  if(!(sshfs.password_stdin == 0) && !(sshfs.slave == 0))
  {
    fprintf(stderr, "the password_stdin and slave options cannot both be specified\n");
    exit(1);
  }

  if(!(sshfs.password_stdin == 0))
  {
    res=read_password();
    if(res == -1)
      exit(1);

  }

  if(!(sshfs.buflimit_workaround == 0))
    sshfs.max_outstanding_len = (unsigned int)8388608;

  else
    sshfs.max_outstanding_len = (unsigned int)~0;
  if(sshfs.host == ((char *)NULL))
  {
    fprintf(stderr, "missing host\n");
    fprintf(stderr, "see `%s -h' for usage\n", argv[(signed long int)0]);
    exit(1);
  }

  fsname=g_strdup(sshfs.host);
  char *return_value_find_base_path$4;
  return_value_find_base_path$4=find_base_path();
  sshfs.base_path=g_strdup(return_value_find_base_path$4);
  if(!(sshfs.ssh_command == ((char *)NULL)))
    set_ssh_command();

  tmp=g_strdup_printf("-%i", sshfs.ssh_ver);
  ssh_add_arg(tmp);
  g_free((void *)tmp);
  ssh_add_arg(sshfs.host);
  if(!(sshfs.sftp_server == ((char *)NULL)))
    sftp_server = sshfs.sftp_server;

  else
    if(sshfs.ssh_ver == 1u)
      sftp_server = "/usr/lib/sftp-server";

    else
      sftp_server = "sftp";
  char *return_value_strchr$5;
  if(!(sshfs.ssh_ver == 1u))
  {
    return_value_strchr$5=strchr(sftp_server, 47);
    if(return_value_strchr$5 == ((char *)NULL))
      ssh_add_arg("-s");

  }

  ssh_add_arg(sftp_server);
  free((void *)sshfs.sftp_server);
  res=cache_parse_options(&args);
  if(res == -1)
    exit(1);

  signed long int return_value_time$6;
  return_value_time$6=time(((signed long int *)NULL));
  sshfs.randseed = (unsigned int)return_value_time$6;
  if(sshfs.max_read >= 65537u)
    sshfs.max_read = (unsigned int)65536;

  if(sshfs.max_write >= 65537u)
    sshfs.max_write = (unsigned int)65536;

  signed int return_value_fuse_is_lib_option$7;
  return_value_fuse_is_lib_option$7=fuse_is_lib_option("ac_attr_timeout=");
  if(!(return_value_fuse_is_lib_option$7 == 0))
    fuse_opt_insert_arg(&args, 1, "-oauto_cache,ac_attr_timeout=0");

  libver=fuse_version();
  /* assertion libver >= 27 */
  assert(libver >= 27);
  if(libver >= 28)
    fsname=fsname_escape_commas(fsname);

  else
    fsname_remove_commas(fsname);
  tmp=g_strdup_printf("-osubtype=sshfs,fsname=%s", fsname);
  fuse_opt_insert_arg(&args, 1, tmp);
  g_free((void *)tmp);
  g_free((void *)fsname);
  check_large_read(&args);
  struct fuse *fuse;
  struct fuse_chan *ch;
  char *mountpoint;
  signed int multithreaded;
  signed int foreground;
  struct stat st;
  res=fuse_parse_cmdline(&args, &mountpoint, &multithreaded, &foreground);
  if(res == -1)
    exit(1);

  if(!(sshfs.slave == 0))
    foreground = 1;

  res=stat(mountpoint, &st);
  if(res == -1)
  {
    perror(mountpoint);
    exit(1);
  }

  sshfs.mnt_mode = st.st_mode;
  ch=fuse_mount(mountpoint, &args);
  if(ch == ((struct fuse_chan *)NULL))
    exit(1);

  signed int return_value_fuse_chan_fd$8;
  return_value_fuse_chan_fd$8=fuse_chan_fd(ch);
  res=fcntl(return_value_fuse_chan_fd$8, 2, 1);
  if(res == -1)
    perror("WARNING: failed to set FD_CLOEXEC on fuse device");

  struct fuse_operations *return_value_cache_init$9;
  return_value_cache_init$9=cache_init(&sshfs_oper);
  fuse=fuse_new(ch, &args, return_value_cache_init$9, sizeof(struct fuse_operations) /*360ul*/ , (void *)0);
  if(fuse == ((struct fuse *)NULL))
  {
    fuse_unmount(mountpoint, ch);
    exit(1);
  }

  res=ssh_connect();
  if(res == -1)
  {
    fuse_unmount(mountpoint, ch);
    fuse_destroy(fuse);
    exit(1);
  }

  res=fuse_daemonize(foreground);
  struct fuse_session *return_value_fuse_get_session$10;
  if(!(res == -1))
  {
    return_value_fuse_get_session$10=fuse_get_session(fuse);
    res=fuse_set_signal_handlers(return_value_fuse_get_session$10);
  }

  if(res == -1)
  {
    fuse_unmount(mountpoint, ch);
    fuse_destroy(fuse);
    exit(1);
  }

  if(!(multithreaded == 0))
    res=fuse_loop_mt(fuse);

  else
    res=fuse_loop(fuse);
  if(res == -1)
    res = 1;

  else
    res = 0;
  struct fuse_session *return_value_fuse_get_session$11;
  return_value_fuse_get_session$11=fuse_get_session(fuse);
  fuse_remove_signal_handlers(return_value_fuse_get_session$11);
  fuse_unmount(mountpoint, ch);
  fuse_destroy(fuse);
  free((void *)mountpoint);
  if(!(sshfs.debug == 0))
  {
    unsigned int avg_rtt = (unsigned int)0;
    if(!(sshfs.num_sent == 0ul))
      avg_rtt = (unsigned int)(sshfs.total_rtt / sshfs.num_sent);

    do
      if(!(sshfs.debug == 0))
        fprintf(stderr, "\nsent:               %llu messages, %llu bytes\nreceived:           %llu messages, %llu bytes\nrtt min/max/avg:    %ums/%ums/%ums\nnum connect:        %u\n", (unsigned long long int)sshfs.num_sent, (unsigned long long int)sshfs.bytes_sent, (unsigned long long int)sshfs.num_received, (unsigned long long int)sshfs.bytes_received, sshfs.min_rtt, sshfs.max_rtt, avg_rtt, sshfs.num_connect);

    while((_Bool)0);
  }

  fuse_opt_free_args(&args);
  fuse_opt_free_args(&sshfs.ssh_args);
  free((void *)sshfs.directport);
  return res;
}

// my_strnlen
// file cache.c line 198
static unsigned long int my_strnlen(const char *s, unsigned long int maxsize)
{
  const char *p = s;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(maxsize == 0ul))
      tmp_if_expr$1 = *p != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    maxsize = maxsize - 1ul;
    p = p + 1l;
  }
  while((_Bool)1);
  return (unsigned long int)(p - s);
}

// parse_idmap_line
// file sshfs.c line 3631
static void parse_idmap_line(char *line, const char *filename, const unsigned int lineno, unsigned int *ret_id, char **ret_name, const signed int eof)
{
  char *p = line;
  p=strrchr(line, 10);
  if(!(p == ((char *)NULL)))
    *p = (char)0;

  else
    if(eof == 0)
    {
      fprintf(stderr, "%s:%u: line too long\n", filename, lineno);
      exit(1);
    }

  char *tokens[3l];
  char *tok;
  signed int i = 0;
  do
  {
    tok=strsep(&line, ":");
    if(tok == ((char *)NULL) || i >= 3)
      break;

    tokens[(signed long int)i] = tok;
    i = i + 1;
  }
  while((_Bool)1);
  char *name_tok;
  char *id_tok;
  if(i == 2)
  {
    name_tok = tokens[(signed long int)0];
    id_tok = tokens[(signed long int)1];
  }

  else
    if(i >= 3)
    {
      name_tok = tokens[(signed long int)0];
      id_tok = tokens[(signed long int)2];
    }

    else
    {
      fprintf(stderr, "%s:%u: unknown format\n", filename, lineno);
      exit(1);
    }
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  unsigned int remote_id;
  unsigned long int return_value_strtoul$2;
  return_value_strtoul$2=strtoul(id_tok, (char ** restrict )(void *)0, 10);
  remote_id = (unsigned int)return_value_strtoul$2;
  signed int *return_value___errno_location$5;
  return_value___errno_location$5=__errno_location();
  if(!(*return_value___errno_location$5 == 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    fprintf(stderr, "Invalid id number on line %u of '%s': %s\n", lineno, filename, return_value_strerror$4);
    exit(1);
  }

  *ret_name=strdup(name_tok);
  *ret_id = remote_id;
}

// parse_workarounds
// file sshfs.c line 3417
signed int parse_workarounds(void)
{
  signed int res;
  char *argv[4l] = { "", "-o", sshfs.workarounds, (char *)(void *)0 };
  struct fuse_args args = { .argc=3, .argv=argv, .allocated=0 };
  char *s = sshfs.workarounds;
  if(s == ((char *)NULL))
    return 0;

  else
  {
    do
    {
      s=strchr(s, 58);
      if(s == ((char *)NULL))
        break;

      *s = (char)44;
    }
    while((_Bool)1);
    res=fuse_opt_parse(&args, (void *)&sshfs, workaround_opts, workaround_opt_proc);
    fuse_opt_free_args(&args);
    return res;
  }
}

// process_one_request
// file sshfs.c line 1321
static signed int process_one_request(void)
{
  signed int res;
  struct buffer buf;
  unsigned char type;
  struct request *req;
  unsigned int id;
  buf_init(&buf, (unsigned long int)0);
  res=sftp_read(&type, &buf);
  const char *return_value_type_name$3;
  if(res == -1)
    return -1;

  else
  {
    signed int return_value_buf_get_uint32$1;
    return_value_buf_get_uint32$1=buf_get_uint32(&buf, &id);
    if(return_value_buf_get_uint32$1 == -1)
      return -1;

    else
    {
      pthread_mutex_lock(&sshfs.lock);
      void *return_value_g_hash_table_lookup$2;
      return_value_g_hash_table_lookup$2=g_hash_table_lookup(sshfs.reqtab, (void *)(unsigned long int)id);
      req = (struct request *)return_value_g_hash_table_lookup$2;
      if(req == ((struct request *)NULL))
        fprintf(stderr, "request %i not found\n", id);

      else
      {
        signed int was_over = (signed int)(sshfs.outstanding_len > sshfs.max_outstanding_len);
        sshfs.outstanding_len = sshfs.outstanding_len - (unsigned int)req->len;
        if(sshfs.max_outstanding_len >= sshfs.outstanding_len && !(was_over == 0))
          pthread_cond_broadcast(&sshfs.outstanding_cond);

        g_hash_table_remove(sshfs.reqtab, (void *)(unsigned long int)id);
      }
      pthread_mutex_unlock(&sshfs.lock);
      if(!(req == ((struct request *)NULL)))
      {
        if(!(sshfs.debug == 0))
        {
          struct timeval now;
          unsigned int difftime;
          unsigned int msgsize = (unsigned int)(buf.size + (unsigned long int)5);
          gettimeofday(&now, (struct timezone *)(void *)0);
          difftime = (unsigned int)((now.tv_sec - req->start.tv_sec) * (signed long int)1000);
          difftime = difftime + (unsigned int)((now.tv_usec - req->start.tv_usec) / (signed long int)1000);
          do
            if(!(sshfs.debug == 0))
            {
              return_value_type_name$3=type_name(type);
              fprintf(stderr, "  [%05i] %14s %8ubytes (%ims)\n", id, return_value_type_name$3, msgsize, difftime);
            }

          while((_Bool)0);
          if(sshfs.num_received == 0ul || !(difftime >= sshfs.min_rtt))
            sshfs.min_rtt = difftime;

          if(!(sshfs.max_rtt >= difftime))
            sshfs.max_rtt = difftime;

          sshfs.total_rtt = sshfs.total_rtt + (unsigned long int)difftime;
          sshfs.num_received = sshfs.num_received + 1ul;
          sshfs.bytes_received = sshfs.bytes_received + (unsigned long int)msgsize;
        }

        req->reply = buf;
        req->reply_type = type;
        req->replied = 1;
        if(!(req->want_reply == 0u))
          sem_post(&req->ready);

        else
        {
          if(!(req->end_func == ((void (*)(struct request *))NULL)))
          {
            pthread_mutex_lock(&sshfs.lock);
            req->end_func(req);
            pthread_mutex_unlock(&sshfs.lock);
          }

          request_free(req);
        }
      }

      else
        buf_free(&buf);
      return 0;
    }
  }
}

// process_requests
// file sshfs.c line 1409
static void * process_requests(void *data_)
{
  (void)data_;
  while((_Bool)1)
  {
    signed int return_value_process_one_request$1;
    return_value_process_one_request$1=process_one_request();
    if(return_value_process_one_request$1 == -1)
      break;

  }
  pthread_mutex_lock(&sshfs.lock);
  sshfs.processing_thread_started = 0;
  close_conn();
  g_hash_table_foreach_remove(sshfs.reqtab, (signed int (*)(void *, void *, void *))clean_req, (void *)0);
  sshfs.connver = sshfs.connver + 1;
  sshfs.outstanding_len = (unsigned int)0;
  pthread_cond_broadcast(&sshfs.outstanding_cond);
  pthread_mutex_unlock(&sshfs.lock);
  if(sshfs.reconnect == 0)
  {
    signed int return_value_getpid$2;
    return_value_getpid$2=getpid();
    kill(return_value_getpid$2, 15);
  }

  return (void *)0;
}

// processing_init
// file sshfs.c line 3218
static signed int processing_init(void)
{
  signal(13, (void (*)(signed int))1);
  pthread_mutex_init(&sshfs.lock, (const union anonymous$3 *)(void *)0);
  pthread_mutex_init(&sshfs.lock_write, (const union anonymous$3 *)(void *)0);
  pthread_cond_init(&sshfs.outstanding_cond, (const union anonymous$3 *)(void *)0);
  sshfs.reqtab=g_hash_table_new((unsigned int (*)(const void *))(void *)0, (signed int (*)(const void *, const void *))(void *)0);
  if(sshfs.reqtab == ((struct _GHashTable *)NULL))
  {
    fprintf(stderr, "failed to create hash table\n");
    return -1;
  }

  else
    return 0;
}

// pty_expect_loop
// file sshfs.c line 893
static signed int pty_expect_loop(void)
{
  signed int res;
  char buf[256l];
  const char *passwd_str = "assword:";
  signed int timeout = 60 * 1000;
  signed int passwd_len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(passwd_str);
  passwd_len = (signed int)return_value_strlen$1;
  signed int len = 0;
  char c;
  while((_Bool)1)
  {
    struct pollfd fds[2l];
    fds[(signed long int)0].fd = sshfs.rfd;
    fds[(signed long int)0].events = (signed short int)0x001;
    fds[(signed long int)1].fd = sshfs.ptyfd;
    fds[(signed long int)1].events = (signed short int)0x001;
    res=poll(fds, (unsigned long int)2, timeout);
    if(res == -1)
    {
      perror("poll");
      return -1;
    }

    if(res == 0)
    {
      fprintf(stderr, "Timeout waiting for prompt\n");
      return -1;
    }

    if(!(fds[0l].revents == 0))
      break;

    signed long int return_value_read$2;
    return_value_read$2=read(sshfs.ptyfd, (void *)&c, (unsigned long int)1);
    res = (signed int)return_value_read$2;
    if(res == -1)
    {
      perror("read");
      return -1;
    }

    if(res == 0)
    {
      fprintf(stderr, "EOF while waiting for prompt\n");
      return -1;
    }

    buf[(signed long int)len] = c;
    len = len + 1;
    if(len == passwd_len)
    {
      signed int return_value_memcmp$4;
      return_value_memcmp$4=memcmp((const void *)buf, (const void *)passwd_str, (unsigned long int)passwd_len);
      if(return_value_memcmp$4 == 0)
      {
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(sshfs.password);
        write(sshfs.ptyfd, (const void *)sshfs.password, return_value_strlen$3);
      }

      memmove((void *)buf, (const void *)(buf + (signed long int)1), (unsigned long int)(passwd_len - 1));
      len = len - 1;
    }

  }
  if(sshfs.reconnect == 0)
  {
    unsigned long int size;
    signed int return_value_getpagesize$5;
    return_value_getpagesize$5=getpagesize();
    size = (unsigned long int)return_value_getpagesize$5;
    memset((void *)sshfs.password, 0, size);
    munmap((void *)sshfs.password, size);
    sshfs.password = (char *)(void *)0;
  }

  return 0;
}

// pty_master
// file sshfs.c line 961
static signed int pty_master(char **name)
{
  signed int mfd;
  mfd=open("/dev/ptmx", 02 | 0400);
  if(mfd == -1)
  {
    perror("failed to open pty");
    return -1;
  }

  else
  {
    signed int return_value_grantpt$1;
    return_value_grantpt$1=grantpt(mfd);
    if(!(return_value_grantpt$1 == 0))
    {
      perror("grantpt");
      return -1;
    }

    else
    {
      signed int return_value_unlockpt$2;
      return_value_unlockpt$2=unlockpt(mfd);
      if(!(return_value_unlockpt$2 == 0))
      {
        perror("unlockpt");
        return -1;
      }

      else
      {
        *name=ptsname(mfd);
        return mfd;
      }
    }
  }
}

// random_string
// file sshfs.c line 2275
static void random_string(char *str, signed int length)
{
  signed int i = 0;
  char *tmp_post$1;
  signed int return_value_rand_r$2;
  for( ; !(i >= length); i = i + 1)
  {
    tmp_post$1 = str;
    str = str + 1l;
    return_value_rand_r$2=rand_r(&sshfs.randseed);
    *tmp_post$1 = (char)(48 + return_value_rand_r$2 % 10);
  }
  *str = (char)0;
}

// read_id_map
// file sshfs.c line 3677
static void read_id_map(char *file, unsigned int * (*map_fn)(char *), const char *name_id, struct _GHashTable **idmap, struct _GHashTable **r_idmap)
{
  *idmap=g_hash_table_new((unsigned int (*)(const void *))(void *)0, (signed int (*)(const void *, const void *))(void *)0);
  *r_idmap=g_hash_table_new((unsigned int (*)(const void *))(void *)0, (signed int (*)(const void *, const void *))(void *)0);
  struct _IO_FILE *fp;
  char line[2048l];
  unsigned int lineno = (unsigned int)0;
  unsigned int local_uid;
  local_uid=getuid();
  fp=fopen(file, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    fprintf(stderr, "failed to open '%s': %s\n", file, return_value_strerror$2);
    exit(1);
  }

  struct stat st;
  signed int return_value_fileno$5;
  return_value_fileno$5=fileno(fp);
  signed int return_value_fstat$6;
  return_value_fstat$6=fstat(return_value_fileno$5, &st);
  if(return_value_fstat$6 == -1)
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    fprintf(stderr, "failed to stat '%s': %s\n", file, return_value_strerror$4);
    exit(1);
  }

  if(!(st.st_uid == local_uid))
  {
    fprintf(stderr, "'%s' is not owned by uid %lu\n", file, (unsigned long int)local_uid);
    exit(1);
  }

  if(!((2u & st.st_mode) == 0u) || !((16u & st.st_mode) == 0u))
  {
    fprintf(stderr, "'%s' is writable by other users\n", file);
    exit(1);
  }

  char *return_value_fgets$7;
  _Bool tmp_if_expr$8;
  do
  {
    return_value_fgets$7=fgets(line, 2048, fp);
    if(return_value_fgets$7 == ((char *)NULL))
      break;

    lineno = lineno + 1u;
    unsigned int remote_id;
    char *name;
    if((signed int)line[0l] == 10)
      tmp_if_expr$8 = (_Bool)1;

    else
      tmp_if_expr$8 = (signed int)line[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$8)
    {
      signed int return_value_feof$9;
      return_value_feof$9=feof(fp);
      parse_idmap_line(line, file, lineno, &remote_id, &name, return_value_feof$9);
      unsigned int *local_id;
      local_id=map_fn(name);
      if(local_id == ((unsigned int *)NULL))
      {
        if(!(sshfs.debug == 0))
          fprintf(stderr, "%s(%u): no local %s\n", name, remote_id, name_id);

        free((void *)name);
      }

      else
      {
        if(!(sshfs.debug == 0))
          fprintf(stderr, "%s: remote %s %u => local %s %u\n", name, name_id, remote_id, name_id, *local_id);

        g_hash_table_insert(*idmap, (void *)(unsigned long int)remote_id, (void *)(unsigned long int)*local_id);
        g_hash_table_insert(*r_idmap, (void *)(unsigned long int)*local_id, (void *)(unsigned long int)remote_id);
        free((void *)name);
        free((void *)local_id);
      }
    }

  }
  while((_Bool)1);
  signed int return_value_fclose$12;
  return_value_fclose$12=fclose(fp);
  if(return_value_fclose$12 == -1)
  {
    signed int *return_value___errno_location$10;
    return_value___errno_location$10=__errno_location();
    char *return_value_strerror$11;
    return_value_strerror$11=strerror(*return_value___errno_location$10);
    fprintf(stderr, "failed to close '%s': %s", file, return_value_strerror$11);
    exit(1);
  }

}

// read_password
// file sshfs.c line 3463
static signed int read_password(void)
{
  signed int size;
  size=getpagesize();
  signed int max_password = 64;
  signed int n;
  void *return_value_mmap$1;
  return_value_mmap$1=mmap((void *)0, (unsigned long int)size, 0x1 | 0x2, 0x02 | 0x20 | 0x02000, -1, (signed long int)0);
  sshfs.password = (char *)return_value_mmap$1;
  if(sshfs.password == (char *)-1)
  {
    perror("Failed to allocate locked page for password");
    return -1;
  }

  else
  {
    n = 0;
    for( ; !(n >= max_password); n = n + 1)
    {
      signed int res;
      signed long int return_value_read$2;
      return_value_read$2=read(0, (void *)&sshfs.password[(signed long int)n], (unsigned long int)1);
      res = (signed int)return_value_read$2;
      if(res == -1)
      {
        perror("Reading password");
        return -1;
      }

      if(res == 0)
      {
        sshfs.password[(signed long int)n] = (char)10;
        break;
      }

      if((signed int)sshfs.password[(signed long int)n] == 10)
        break;

    }
    if(n == max_password)
    {
      fprintf(stderr, "Password too long\n");
      return -1;
    }

    else
    {
      sshfs.password[(signed long int)(n + 1)] = (char)0;
      ssh_add_arg("-oNumberOfPasswordPrompts=1");
      return 0;
    }
  }
}

// replace_arg
// file sshfs.c line 983
static void replace_arg(char **argp, const char *newarg)
{
  free((void *)*argp);
  *argp=strdup(newarg);
  if(*argp == ((char *)NULL))
  {
    fprintf(stderr, "sshfs: memory allocation failed\n");
    abort();
  }

}

// request_free
// file sshfs.c line 1270
static void request_free(struct request *req)
{
  buf_free(&req->reply);
  sem_destroy(&req->ready);
  g_free((void *)req);
}

// search_read_chunk
// file sshfs.c line 2745
static struct read_chunk * search_read_chunk(struct sshfs_file *sf, signed long int offset)
{
  struct read_chunk *ch = sf->readahead;
  _Bool tmp_if_expr$1;
  if(!(ch == ((struct read_chunk *)NULL)))
    tmp_if_expr$1 = ch->offset == offset ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = ch->modifver == sshfs.modifver ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
  {
    ch->refs = ch->refs + 1;
    return ch;
  }

  else
    return (struct read_chunk *)(void *)0;
}

// set_ssh_command
// file sshfs.c line 3503
static void set_ssh_command(void)
{
  char *s;
  char *d;
  signed int i = 0;
  signed int end = 0;
  d = sshfs.ssh_command;
  s = sshfs.ssh_command;
  char *tmp_post$2;
  for( ; end == 0; s = s + 1l)
    switch((signed int)*s)
    {
      case 0:
        end = 1;
      case 32:
      {
        *d = (char)0;
        if(i == 0)
          replace_arg(&sshfs.ssh_args.argv[(signed long int)0], sshfs.ssh_command);

        else
        {
          signed int return_value_fuse_opt_insert_arg$1;
          return_value_fuse_opt_insert_arg$1=fuse_opt_insert_arg(&sshfs.ssh_args, i, sshfs.ssh_command);
          if(return_value_fuse_opt_insert_arg$1 == -1)
            _exit(1);

        }
        i = i + 1;
        d = sshfs.ssh_command;
        break;
      }
      case 92:
        if(!(s[1l] == 0))
          s = s + 1l;

      default:
      {
        tmp_post$2 = d;
        d = d + 1l;
        *tmp_post$2 = *s;
      }
    }
}

// sftp_check_root
// file sshfs.c line 1617
static signed int sftp_check_root(const char *base_path)
{
  signed int flags;
  unsigned int id;
  id=sftp_get_id();
  unsigned int replid;
  unsigned char type;
  struct buffer buf;
  struct stat stbuf;
  struct iovec iov[1l];
  signed int err = -1;
  const char *remote_dir = base_path[(signed long int)0] != 0 ? base_path : ".";
  buf_init(&buf, (unsigned long int)0);
  buf_add_string(&buf, remote_dir);
  buf_to_iov(&buf, &iov[(signed long int)0]);
  signed int return_value_sftp_send_iov$1;
  return_value_sftp_send_iov$1=sftp_send_iov((unsigned char)7, id, iov, (unsigned long int)1);
  signed int return_value_sftp_read$2;
  signed int return_value_buf_get_uint32$3;
  signed int err2;
  if(!(return_value_sftp_send_iov$1 == -1))
  {
    buf_clear(&buf);
    return_value_sftp_read$2=sftp_read(&type, &buf);
    if(!(return_value_sftp_read$2 == -1))
    {
      if(!((signed int)type == 101) && !((signed int)type == 105))
        fprintf(stderr, "protocol error\n");

      else
      {
        return_value_buf_get_uint32$3=buf_get_uint32(&buf, &replid);
        if(!(return_value_buf_get_uint32$3 == -1))
        {
          if(!(replid == id))
            fprintf(stderr, "bad reply ID\n");

          else
          {
            if((signed int)type == 101)
            {
              unsigned int serr;
              signed int return_value_buf_get_uint32$4;
              return_value_buf_get_uint32$4=buf_get_uint32(&buf, &serr);
              if(return_value_buf_get_uint32$4 == -1)
                goto out;

              signed int return_value_sftp_error_to_errno$5;
              return_value_sftp_error_to_errno$5=sftp_error_to_errno(serr);
              char *return_value_strerror$6;
              return_value_strerror$6=strerror(return_value_sftp_error_to_errno$5);
              fprintf(stderr, "%s:%s: %s\n", sshfs.host, remote_dir, return_value_strerror$6);
              goto out;
            }

            err2=buf_get_attrs(&buf, &stbuf, &flags);
            if(!(err2 == 0))
              err = err2;

            else
              if(!((0x00000004 & flags) == 0))
              {
                if((61440u & sshfs.mnt_mode) == 16384u && !((61440u & stbuf.st_mode) == 16384u))
                  fprintf(stderr, "%s:%s: Not a directory\n", sshfs.host, remote_dir);

                else
                  if(!(((sshfs.mnt_mode ^ stbuf.st_mode) & 61440u) == 0u))
                    fprintf(stderr, "%s:%s: type of file differs from mountpoint\n", sshfs.host, remote_dir);

                  else
                    err = 0;
              }

          }
        }

      }
    }

  }


out:
  ;
  buf_free(&buf);
  return err;
}

// sftp_detect_uid
// file sshfs.c line 1563
static void sftp_detect_uid()
{
  signed int flags;
  unsigned int id;
  id=sftp_get_id();
  unsigned int replid;
  unsigned char type;
  struct buffer buf;
  struct stat stbuf;
  struct iovec iov[1l];
  buf_init(&buf, (unsigned long int)5);
  buf_add_string(&buf, ".");
  buf_to_iov(&buf, &iov[(signed long int)0]);
  signed int return_value_sftp_send_iov$1;
  return_value_sftp_send_iov$1=sftp_send_iov((unsigned char)17, id, iov, (unsigned long int)1);
  signed int return_value_sftp_read$2;
  signed int return_value_buf_get_uint32$3;
  signed int return_value_buf_get_attrs$5;
  if(!(return_value_sftp_send_iov$1 == -1))
  {
    buf_clear(&buf);
    return_value_sftp_read$2=sftp_read(&type, &buf);
    if(!(return_value_sftp_read$2 == -1))
    {
      if(!((signed int)type == 101) && !((signed int)type == 105))
        fprintf(stderr, "protocol error\n");

      else
      {
        return_value_buf_get_uint32$3=buf_get_uint32(&buf, &replid);
        if(!(return_value_buf_get_uint32$3 == -1))
        {
          if(!(replid == id))
            fprintf(stderr, "bad reply ID\n");

          else
          {
            if((signed int)type == 101)
            {
              unsigned int serr;
              signed int return_value_buf_get_uint32$4;
              return_value_buf_get_uint32$4=buf_get_uint32(&buf, &serr);
              if(return_value_buf_get_uint32$4 == -1)
                goto out;

              fprintf(stderr, "failed to stat home directory (%i)\n", serr);
              goto out;
            }

            return_value_buf_get_attrs$5=buf_get_attrs(&buf, &stbuf, &flags);
            if(return_value_buf_get_attrs$5 == 0)
            {
              if(!((0x00000002 & flags) == 0))
              {
                sshfs.remote_uid = stbuf.st_uid;
                sshfs.local_uid=getuid();
                sshfs.remote_uid_detected = 1;
                do
                  if(!(sshfs.debug == 0))
                    fprintf(stderr, "remote_uid = %i\n", sshfs.remote_uid);

                while((_Bool)0);
              }

            }

          }
        }

      }
    }

  }


out:
  ;
  if(sshfs.remote_uid_detected == 0)
    fprintf(stderr, "failed to detect remote user ID\n");

  buf_free(&buf);
}

// sftp_error_to_errno
// file sshfs.c line 1548
static signed int sftp_error_to_errno(unsigned int error)
{
  switch(error)
  {
    case (unsigned int)0:
      return 0;
    case (unsigned int)2:
      return 2;
    case (unsigned int)3:
      return 13;
    case (unsigned int)4:
      return 1;
    case (unsigned int)5:
      return 74;
    case (unsigned int)6:
      return 107;
    case (unsigned int)7:
      return 103;
    case (unsigned int)8:
      return 95;
    default:
      return 5;
  }
}

// sftp_find_init_reply
// file sshfs.c line 1494
static signed int sftp_find_init_reply(unsigned int *version)
{
  signed int res;
  struct buffer buf;
  buf_init(&buf, (unsigned long int)9);
  res=do_read(&buf);
  while(!(res == -1))
  {
    struct buffer buf2;
    res=sftp_init_reply_ok(&buf, version);
    if(!(res >= 1))
      break;

    do
      if(!(sshfs.debug == 0))
        fprintf(stderr, "%c", *buf.p);

    while((_Bool)0);
    memmove((void *)buf.p, (const void *)(buf.p + (signed long int)1), buf.size - (unsigned long int)1);
    buf.len = (unsigned long int)0;
    buf2.p = (buf.p + (signed long int)buf.size) - (signed long int)1;
    buf2.size = (unsigned long int)1;
    res=do_read(&buf2);
  }
  buf_free(&buf);
  return res;
}

// sftp_get_id
// file sshfs.c line 1179
static unsigned int sftp_get_id(void)
{
  static unsigned int idctr;
  unsigned int tmp_post$1 = idctr;
  idctr = idctr + 1u;
  return tmp_post$1;
}

// sftp_init
// file sshfs.c line 1520
static signed int sftp_init()
{
  signed int res = -1;
  unsigned int version = (unsigned int)0;
  struct buffer buf;
  buf_init(&buf, (unsigned long int)0);
  signed int return_value_sftp_send_iov$1;
  return_value_sftp_send_iov$1=sftp_send_iov((unsigned char)1, (unsigned int)3, (struct iovec *)(void *)0, (unsigned long int)0);
  signed int return_value_pty_expect_loop$2;
  signed int return_value_sftp_find_init_reply$3;
  if(!(return_value_sftp_send_iov$1 == -1))
  {
    if(!(sshfs.password_stdin == 0))
    {
      return_value_pty_expect_loop$2=pty_expect_loop();
      if(return_value_pty_expect_loop$2 == -1)
        goto out;

    }

    return_value_sftp_find_init_reply$3=sftp_find_init_reply(&version);
    if(!(return_value_sftp_find_init_reply$3 == -1))
    {
      sshfs.server_version = (signed int)version;
      if(version >= 4u)
        fprintf(stderr, "Warning: server uses version: %i, we support: %i\n", version, 3);

      res = 0;
    }

  }


out:
  ;
  buf_free(&buf);
  return res;
}

// sftp_init_reply_ok
// file sshfs.c line 1434
static signed int sftp_init_reply_ok(struct buffer *buf, unsigned int *version)
{
  unsigned int len;
  unsigned char type;
  signed int return_value_buf_get_uint32$1;
  return_value_buf_get_uint32$1=buf_get_uint32(buf, &len);
  _Bool tmp_if_expr$7;
  signed int return_value_buf_get_string$6;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$10;
  signed int return_value_strcmp$12;
  if(return_value_buf_get_uint32$1 == -1)
    return -1;

  else
    if(len >= 131073u || !(len >= 5u))
      return 1;

    else
    {
      signed int return_value_buf_get_uint8$2;
      return_value_buf_get_uint8$2=buf_get_uint8(buf, &type);
      if(return_value_buf_get_uint8$2 == -1)
        return -1;

      else
        if(!((signed int)type == 2))
          return 1;

        else
        {
          signed int return_value_buf_get_uint32$3;
          return_value_buf_get_uint32$3=buf_get_uint32(buf, version);
          if(return_value_buf_get_uint32$3 == -1)
            return -1;

          else
          {
            do
              if(!(sshfs.debug == 0))
                fprintf(stderr, "Server version: %u\n", *version);

            while((_Bool)0);
            if(len >= 6u)
            {
              struct buffer buf2;
              buf_init(&buf2, (unsigned long int)(len - (unsigned int)5));
              signed int return_value_do_read$4;
              return_value_do_read$4=do_read(&buf2);
              if(return_value_do_read$4 == -1)
              {
                buf_free(&buf2);
                return -1;
              }

              do
              {
                char *ext;
                char *extdata;
                signed int return_value_buf_get_string$5;
                return_value_buf_get_string$5=buf_get_string(&buf2, &ext);
                if(return_value_buf_get_string$5 == -1)
                  tmp_if_expr$7 = (_Bool)1;

                else
                {
                  return_value_buf_get_string$6=buf_get_string(&buf2, &extdata);
                  tmp_if_expr$7 = return_value_buf_get_string$6 == -1 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$7)
                {
                  buf_free(&buf2);
                  return -1;
                }

                do
                  if(!(sshfs.debug == 0))
                    fprintf(stderr, "Extension: %s <%s>\n", ext, extdata);

                while((_Bool)0);
                signed int return_value_strcmp$9;
                return_value_strcmp$9=strcmp(ext, "posix-rename@openssh.com");
                if(return_value_strcmp$9 == 0)
                {
                  return_value_strcmp$8=strcmp(extdata, "1");
                  if(return_value_strcmp$8 == 0)
                  {
                    sshfs.ext_posix_rename = 1;
                    sshfs.rename_workaround = 0;
                  }

                }

                signed int return_value_strcmp$11;
                return_value_strcmp$11=strcmp(ext, "statvfs@openssh.com");
                if(return_value_strcmp$11 == 0)
                {
                  return_value_strcmp$10=strcmp(extdata, "2");
                  if(return_value_strcmp$10 == 0)
                    sshfs.ext_statvfs = 1;

                }

                signed int return_value_strcmp$13;
                return_value_strcmp$13=strcmp(ext, "hardlink@openssh.com");
                if(return_value_strcmp$13 == 0)
                {
                  return_value_strcmp$12=strcmp(extdata, "1");
                  if(return_value_strcmp$12 == 0)
                    sshfs.ext_hardlink = 1;

                }

              }
              while(!(buf2.len >= buf2.size));
              buf_free(&buf2);
            }

            return 0;
          }
        }
    }
}

// sftp_read
// file sshfs.c line 1247
static signed int sftp_read(unsigned char *type, struct buffer *buf)
{
  signed int res;
  struct buffer buf2;
  unsigned int len;
  buf_init(&buf2, (unsigned long int)5);
  res=do_read(&buf2);
  if(!(res == -1))
  {
    signed int return_value_buf_get_uint32$1;
    return_value_buf_get_uint32$1=buf_get_uint32(&buf2, &len);
    if(return_value_buf_get_uint32$1 == -1)
      return -1;

    if(len >= 131073u)
    {
      fprintf(stderr, "reply len too large: %u\n", len);
      return -1;
    }

    signed int return_value_buf_get_uint8$2;
    return_value_buf_get_uint8$2=buf_get_uint8(&buf2, type);
    if(return_value_buf_get_uint8$2 == -1)
      return -1;

    buf_init(buf, (unsigned long int)(len - (unsigned int)1));
    res=do_read(buf);
  }

  buf_free(&buf2);
  return res;
}

// sftp_readdir_async
// file sshfs.c line 2051
static signed int sftp_readdir_async(struct buffer *handle, struct fuse_cache_dirhandle *h, signed int (*filler)(struct fuse_cache_dirhandle *, const char *, struct stat *))
{
  signed int err = 0;
  signed int outstanding = 0;
  signed int max = 2;
  struct _GList *list = (struct _GList *)(void *)0;
  signed int done = 0;
  while(done == 0 || !(outstanding == 0))
  {
    struct request *req;
    struct buffer name;
    signed int tmperr;
    for( ; done == 0 && !(outstanding >= max); outstanding = outstanding + 1)
    {
      tmperr=sftp_readdir_send(&req, handle);
      if(done == 0 && !(tmperr == 0))
      {
        err = tmperr;
        done = 1;
        break;
      }

      list=g_list_append(list, (void *)req);
    }
    if(!(outstanding == 0))
    {
      struct _GList *first;
      first=g_list_first(list);
      req = (struct request *)first->data;
      list=g_list_delete_link(list, first);
      outstanding = outstanding - 1;
      if(!(done == 0))
      {
        pthread_mutex_lock(&sshfs.lock);
        signed int return_value_sshfs_req_pending$1;
        return_value_sshfs_req_pending$1=sshfs_req_pending(req);
        if(!(return_value_sshfs_req_pending$1 == 0))
          req->want_reply = (unsigned int)0;

        pthread_mutex_unlock(&sshfs.lock);
        if(req->want_reply == 0u)
          continue;

      }

      tmperr=sftp_request_wait(req, (unsigned char)12, (unsigned char)104, &name);
      if(done == 0 && !(tmperr == 0))
      {
        err = tmperr;
        if(err == 1)
          err = 0;

        done = 1;
      }

      if(done == 0)
      {
        err=buf_get_entries(&name, h, filler);
        buf_free(&name);
        if(!(max >= 32))
          max = max + 1;

        if(!(err == 0))
          done = 1;

      }

    }

  }
  /* assertion list == ((void *)0) */
  assert(list == (struct _GList *)(void *)0);
  return err;
}

// sftp_readdir_send
// file sshfs.c line 2034
static signed int sftp_readdir_send(struct request **req, struct buffer *handle)
{
  struct iovec iov;
  buf_to_iov(handle, &iov);
  signed int return_value_sftp_request_send$1;
  return_value_sftp_request_send$1=sftp_request_send((unsigned char)12, &iov, (unsigned long int)1, (void (*)(struct request *))(void *)0, (void (*)(struct request *))(void *)0, 104, (void *)0, req);
  return return_value_sftp_request_send$1;
}

// sftp_readdir_sync
// file sshfs.c line 2123
static signed int sftp_readdir_sync(struct buffer *handle, struct fuse_cache_dirhandle *h, signed int (*filler)(struct fuse_cache_dirhandle *, const char *, struct stat *))
{
  signed int err;
  do
  {
    struct buffer name;
    err=sftp_request((unsigned char)12, handle, (unsigned char)104, &name);
    if(err == 0)
    {
      err=buf_get_entries(&name, h, filler);
      buf_free(&name);
    }

  }
  while(err == 0);
  if(err == 1)
    err = 0;

  return err;
}

// sftp_request
// file sshfs.c line 1909
static signed int sftp_request(unsigned char type, struct buffer *buf, unsigned char expect_type, struct buffer *outbuf)
{
  struct iovec iov;
  buf_to_iov(buf, &iov);
  signed int return_value_sftp_request_iov$1;
  return_value_sftp_request_iov$1=sftp_request_iov(type, &iov, (unsigned long int)1, expect_type, outbuf);
  return return_value_sftp_request_iov$1;
}

// sftp_request_iov
// file sshfs.c line 1895
static signed int sftp_request_iov(unsigned char type, struct iovec *iov, unsigned long int count, unsigned char expect_type, struct buffer *outbuf)
{
  signed int err;
  struct request *req;
  err=sftp_request_send(type, iov, count, (void (*)(struct request *))(void *)0, (void (*)(struct request *))(void *)0, (signed int)expect_type, (void *)0, &req);
  if((signed int)expect_type == 0)
    return err;

  else
  {
    signed int return_value_sftp_request_wait$1;
    return_value_sftp_request_wait$1=sftp_request_wait(req, type, expect_type, outbuf);
    return return_value_sftp_request_wait$1;
  }
}

// sftp_request_send
// file sshfs.c line 1828
static signed int sftp_request_send(unsigned char type, struct iovec *iov, unsigned long int count, void (*begin_func)(struct request *), void (*end_func)(struct request *), signed int want_reply, void *data, struct request **reqp)
{
  signed int err;
  unsigned int id;
  struct request *req;
  void *return_value_g_malloc0_n$1;
  return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct request) /*136ul*/ );
  req = (struct request *)return_value_g_malloc0_n$1;
  req->want_reply = (unsigned int)want_reply;
  req->end_func = end_func;
  req->data = data;
  sem_init(&req->ready, 0, (unsigned int)0);
  buf_init(&req->reply, (unsigned long int)0);
  pthread_mutex_lock(&sshfs.lock);
  if(!(begin_func == ((void (*)(struct request *))NULL)))
    begin_func(req);

  id=sftp_get_id();
  req->id = id;
  err=start_processing_thread();
  unsigned long int return_value_iov_length$2;
  const char *return_value_type_name$3;
  signed int return_value_sftp_send_iov$4;
  if(!(err == 0))
    pthread_mutex_unlock(&sshfs.lock);

  else
  {
    return_value_iov_length$2=iov_length(iov, count);
    req->len = return_value_iov_length$2 + (unsigned long int)9;
    sshfs.outstanding_len = sshfs.outstanding_len + (unsigned int)req->len;
    while(!(sshfs.max_outstanding_len >= sshfs.outstanding_len))
      pthread_cond_wait(&sshfs.outstanding_cond, &sshfs.lock);
    g_hash_table_insert(sshfs.reqtab, (void *)(unsigned long int)id, (void *)req);
    if(!(sshfs.debug == 0))
    {
      gettimeofday(&req->start, (struct timezone *)(void *)0);
      sshfs.num_sent = sshfs.num_sent + 1ul;
      sshfs.bytes_sent = sshfs.bytes_sent + req->len;
    }

    do
      if(!(sshfs.debug == 0))
      {
        return_value_type_name$3=type_name(type);
        fprintf(stderr, "[%05i] %s\n", id, return_value_type_name$3);
      }

    while((_Bool)0);
    pthread_mutex_unlock(&sshfs.lock);
    err = -5;
    return_value_sftp_send_iov$4=sftp_send_iov(type, id, iov, count);
    if(return_value_sftp_send_iov$4 == -1)
    {
      signed int rmed;
      pthread_mutex_lock(&sshfs.lock);
      rmed=g_hash_table_remove(sshfs.reqtab, (void *)(unsigned long int)id);
      pthread_mutex_unlock(&sshfs.lock);
      if(rmed == 0 && want_reply == 0)
        return err;

      goto out;
    }

    if(!(want_reply == 0))
      *reqp = req;

    return 0;
  }

out:
  ;
  req->error = err;
  if(want_reply == 0)
    sftp_request_wait(req, type, (unsigned char)0, (struct buffer *)(void *)0);

  else
    *reqp = req;
  return err;
}

// sftp_request_wait
// file sshfs.c line 1762
static signed int sftp_request_wait(struct request *req, unsigned char type, unsigned char expect_type, struct buffer *outbuf)
{
  signed int err;
  signed int return_value_sem_wait$1;
  if(!(req->error == 0))
    err = req->error;

  else
  {
    do
    {
      return_value_sem_wait$1=sem_wait(&req->ready);
      if(return_value_sem_wait$1 == 0)
        break;

    }
    while((_Bool)1);
    if(!(req->error == 0))
      err = req->error;

    else
    {
      err = -5;
      if(!(req->reply_type == expect_type))
      {
        if((signed int)req->reply_type == 101)
          goto __CPROVER_DUMP_L4;

        fprintf(stderr, "protocol error\n");
      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        if((signed int)req->reply_type == 101)
        {
          unsigned int serr;
          signed int return_value_buf_get_uint32$2;
          return_value_buf_get_uint32$2=buf_get_uint32(&req->reply, &serr);
          if(return_value_buf_get_uint32$2 == -1)
            goto out;

          switch(serr)
          {
            case (unsigned int)0:
            {
              if((signed int)expect_type == 101)
                err = 0;

              else
                err = -5;
              break;
            }
            case (unsigned int)1:
            {
              if((signed int)type == 5 || (signed int)type == 12)
                err = 1;

              else
                err = -5;
              break;
            }
            case (unsigned int)4:
            {
              if((signed int)type == 15)
                err = -39;

              else
                err = -1;
              break;
            }
            default:
            {
              signed int return_value_sftp_error_to_errno$3;
              return_value_sftp_error_to_errno$3=sftp_error_to_errno(serr);
              err = -return_value_sftp_error_to_errno$3;
            }
          }
        }

        else
        {
          buf_init(outbuf, req->reply.size - req->reply.len);
          buf_get_mem(&req->reply, (void *)outbuf->p, outbuf->size);
          err = 0;
        }
      }
    }
  }

out:
  ;
  if(!(req->end_func == ((void (*)(struct request *))NULL)))
  {
    pthread_mutex_lock(&sshfs.lock);
    req->end_func(req);
    pthread_mutex_unlock(&sshfs.lock);
  }

  request_free(req);
  return err;
}

// sftp_send_iov
// file sshfs.c line 1203
static signed int sftp_send_iov(unsigned char type, unsigned int id, struct iovec *iov, unsigned long int count)
{
  signed int res;
  struct buffer buf;
  struct iovec iovout[3l];
  unsigned int i;
  unsigned int nout = (unsigned int)0;
  /* assertion count <= 3 - 1 */
  assert(count <= (unsigned long int)(3 - 1));
  buf_init(&buf, (unsigned long int)9);
  unsigned long int return_value_iov_length$1;
  return_value_iov_length$1=iov_length(iov, count);
  buf_add_uint32(&buf, (unsigned int)(return_value_iov_length$1 + (unsigned long int)5));
  buf_add_uint8(&buf, type);
  buf_add_uint32(&buf, id);
  unsigned int tmp_post$2 = nout;
  nout = nout + 1u;
  buf_to_iov(&buf, &iovout[(signed long int)tmp_post$2]);
  i = (unsigned int)0;
  unsigned int tmp_post$3;
  for( ; !((unsigned long int)i >= count); i = i + 1u)
  {
    tmp_post$3 = nout;
    nout = nout + 1u;
    iovout[(signed long int)tmp_post$3] = iov[(signed long int)i];
  }
  pthread_mutex_lock(&sshfs.lock_write);
  res=do_write(iovout, (unsigned long int)nout);
  pthread_mutex_unlock(&sshfs.lock_write);
  buf_free(&buf);
  return res;
}

// ssh_add_arg
// file sshfs.c line 840
static void ssh_add_arg(const char *arg)
{
  signed int return_value_fuse_opt_add_arg$1;
  return_value_fuse_opt_add_arg$1=fuse_opt_add_arg(&sshfs.ssh_args, arg);
  if(return_value_fuse_opt_add_arg$1 == -1)
    _exit(1);

}

// ssh_connect
// file sshfs.c line 3606
static signed int ssh_connect(void)
{
  signed int res;
  res=processing_init();
  signed int return_value_sftp_check_root$2;
  if(res == -1)
    return -1;

  else
  {
    if(sshfs.delay_connect == 0)
    {
      signed int return_value_connect_remote$1;
      return_value_connect_remote$1=connect_remote();
      if(return_value_connect_remote$1 == -1)
        return -1;

      if(sshfs.no_check_root == 0)
      {
        return_value_sftp_check_root$2=sftp_check_root(sshfs.base_path);
        if(!(return_value_sftp_check_root$2 == 0))
          return -1;

      }

    }

    return 0;
  }
}

// sshfs_async_read
// file sshfs.c line 2755
static signed int sshfs_async_read(struct sshfs_file *sf, char *rbuf, unsigned long int size, signed long int offset)
{
  signed int res = 0;
  unsigned long int total = (unsigned long int)0;
  struct read_chunk *chunk;
  struct read_chunk *chunk_prev = (struct read_chunk *)(void *)0;
  unsigned long int origsize = size;
  signed int curr_is_seq;
  pthread_mutex_lock(&sshfs.lock);
  curr_is_seq = sf->is_seq;
  _Bool tmp_if_expr$1;
  if(sf->next_pos == offset)
    tmp_if_expr$1 = (signed long int)sf->modifver == sshfs.modifver ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  sf->is_seq = (signed int)tmp_if_expr$1;
  sf->next_pos = (signed long int)((unsigned long int)offset + size);
  sf->modifver = (signed int)sshfs.modifver;
  chunk=search_read_chunk(sf, offset);
  pthread_mutex_unlock(&sshfs.lock);
  if(!(chunk == ((struct read_chunk *)NULL)))
  {
    if(!(chunk->size >= size))
    {
      chunk_prev = chunk;
      size = size - chunk->size;
      offset = offset + (signed long int)chunk->size;
      chunk = (struct read_chunk *)(void *)0;
    }

  }

  if(chunk == ((struct read_chunk *)NULL))
    submit_read(sf, size, offset, &chunk);

  if(!(chunk == ((struct read_chunk *)NULL)) && !(curr_is_seq == 0))
  {
    if(size >= chunk->size)
      submit_read(sf, origsize, (signed long int)((unsigned long int)offset + size), &sf->readahead);

  }

  if(!(chunk_prev == ((struct read_chunk *)NULL)))
  {
    unsigned long int prev_size = chunk_prev->size;
    res=wait_chunk(chunk_prev, rbuf, prev_size);
    if(!(res >= (signed int)prev_size))
    {
      chunk_put_locked(chunk);
      return res;
    }

    rbuf = rbuf + (signed long int)res;
    total = total + (unsigned long int)res;
  }

  res=wait_chunk(chunk, rbuf, size);
  if(res >= 1)
    total = total + (unsigned long int)res;

  if(!(res >= 0))
    return res;

  else
    return (signed int)total;
}

// sshfs_async_write
// file sshfs.c line 2848
static signed int sshfs_async_write(struct sshfs_file *sf, const char *wbuf, unsigned long int size, signed long int offset)
{
  signed int err = 0;
  struct buffer *handle = &sf->handle;
  while(err == 0 && !(size == 0ul))
  {
    struct buffer buf;
    struct iovec iov[2l];
    unsigned long int bsize = size < (unsigned long int)sshfs.max_write ? size : (unsigned long int)sshfs.max_write;
    buf_init(&buf, (unsigned long int)0);
    buf_add_buf(&buf, handle);
    buf_add_uint64(&buf, (unsigned long int)offset);
    buf_add_uint32(&buf, (unsigned int)bsize);
    buf_to_iov(&buf, &iov[(signed long int)0]);
    iov[(signed long int)1].iov_base = (void *)wbuf;
    iov[(signed long int)1].iov_len = bsize;
    err=sftp_request_send((unsigned char)6, iov, (unsigned long int)2, sshfs_write_begin, sshfs_write_end, 0, (void *)sf, (struct request **)(void *)0);
    buf_free(&buf);
    size = size - bsize;
    wbuf = wbuf + (signed long int)bsize;
    offset = offset + (signed long int)bsize;
  }
  return err;
}

// sshfs_chmod
// file sshfs.c line 2329
static signed int sshfs_chmod(const char *path, unsigned int mode)
{
  signed int err;
  struct buffer buf;
  buf_init(&buf, (unsigned long int)0);
  buf_add_path(&buf, path);
  buf_add_uint32(&buf, (unsigned int)0x00000004);
  buf_add_uint32(&buf, mode);
  err=sftp_request((unsigned char)9, &buf, (unsigned char)101, (struct buffer *)(void *)0);
  buf_free(&buf);
  return err;
}

// sshfs_chown
// file sshfs.c line 2343
static signed int sshfs_chown(const char *path, unsigned int uid, unsigned int gid)
{
  signed int err;
  struct buffer buf;
  if(uid == sshfs.local_uid && !(sshfs.remote_uid_detected == 0))
    uid = sshfs.remote_uid;

  signed int return_value_translate_id$1;
  signed int return_value_translate_id$2;
  if(sshfs.idmap == 2 && !(sshfs.r_uid_map == ((struct _GHashTable *)NULL)))
  {
    return_value_translate_id$1=translate_id(&uid, sshfs.r_uid_map);
    if(!(return_value_translate_id$1 == -1))
      goto __CPROVER_DUMP_L2;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    if(sshfs.idmap == 2 && !(sshfs.r_gid_map == ((struct _GHashTable *)NULL)))
    {
      return_value_translate_id$2=translate_id(&gid, sshfs.r_gid_map);
      if(!(return_value_translate_id$2 == -1))
        goto __CPROVER_DUMP_L3;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      buf_init(&buf, (unsigned long int)0);
      buf_add_path(&buf, path);
      buf_add_uint32(&buf, (unsigned int)0x00000002);
      buf_add_uint32(&buf, uid);
      buf_add_uint32(&buf, gid);
      err=sftp_request((unsigned char)9, &buf, (unsigned char)101, (struct buffer *)(void *)0);
      buf_free(&buf);
      return err;
    }
  }
}

// sshfs_create
// file sshfs.c line 3036
static signed int sshfs_create(const char *path, unsigned int mode, struct fuse_file_info *fi)
{
  signed int return_value_sshfs_open_common$1;
  return_value_sshfs_open_common$1=sshfs_open_common(path, mode, fi);
  return return_value_sshfs_open_common$1;
}

// sshfs_do_rename
// file sshfs.c line 2250
static signed int sshfs_do_rename(const char *from, const char *to)
{
  signed int err;
  struct buffer buf;
  buf_init(&buf, (unsigned long int)0);
  buf_add_path(&buf, from);
  buf_add_path(&buf, to);
  err=sftp_request((unsigned char)18, &buf, (unsigned char)101, (struct buffer *)(void *)0);
  buf_free(&buf);
  return err;
}

// sshfs_ext_posix_rename
// file sshfs.c line 2262
static signed int sshfs_ext_posix_rename(const char *from, const char *to)
{
  signed int err;
  struct buffer buf;
  buf_init(&buf, (unsigned long int)0);
  buf_add_string(&buf, "posix-rename@openssh.com");
  buf_add_path(&buf, from);
  buf_add_path(&buf, to);
  err=sftp_request((unsigned char)200, &buf, (unsigned char)101, (struct buffer *)(void *)0);
  buf_free(&buf);
  return err;
}

// sshfs_ext_statvfs
// file sshfs.c line 2968
static signed int sshfs_ext_statvfs(const char *path, struct statvfs *stbuf)
{
  signed int err;
  struct buffer buf;
  struct buffer outbuf;
  buf_init(&buf, (unsigned long int)0);
  buf_add_string(&buf, "statvfs@openssh.com");
  buf_add_path(&buf, path);
  err=sftp_request((unsigned char)200, &buf, (unsigned char)201, &outbuf);
  if(err == 0)
  {
    signed int return_value_buf_get_statvfs$1;
    return_value_buf_get_statvfs$1=buf_get_statvfs(&outbuf, stbuf);
    if(return_value_buf_get_statvfs$1 == -1)
      err = -5;

    buf_free(&outbuf);
  }

  buf_free(&buf);
  return err;
}

// sshfs_fgetattr
// file sshfs.c line 3069
static signed int sshfs_fgetattr(const char *path, struct stat *stbuf, struct fuse_file_info *fi)
{
  signed int err;
  struct buffer buf;
  struct buffer outbuf;
  struct sshfs_file *sf;
  sf=get_sshfs_file(fi);
  (void)path;
  signed int return_value_sshfs_file_is_conn$1;
  return_value_sshfs_file_is_conn$1=sshfs_file_is_conn(sf);
  signed int return_value_sshfs_getattr$2;
  if(return_value_sshfs_file_is_conn$1 == 0)
    return -5;

  else
    if(!(sshfs.fstat_workaround == 0))
    {
      return_value_sshfs_getattr$2=sshfs_getattr(path, stbuf);
      return return_value_sshfs_getattr$2;
    }

    else
    {
      buf_init(&buf, (unsigned long int)0);
      buf_add_buf(&buf, &sf->handle);
      err=sftp_request((unsigned char)8, &buf, (unsigned char)105, &outbuf);
      if(err == 0)
      {
        err=buf_get_attrs(&outbuf, stbuf, (signed int *)(void *)0);
        buf_free(&outbuf);
      }

      buf_free(&buf);
      return err;
    }
}

// sshfs_file_get
// file sshfs.c line 2554
static void sshfs_file_get(struct sshfs_file *sf)
{
  sf->refs = sf->refs + 1;
}

// sshfs_file_is_conn
// file sshfs.c line 2409
static inline signed int sshfs_file_is_conn(struct sshfs_file *sf)
{
  signed int ret;
  pthread_mutex_lock(&sshfs.lock);
  ret = (signed int)(sf->connver == sshfs.connver);
  pthread_mutex_unlock(&sshfs.lock);
  return ret;
}

// sshfs_file_put
// file sshfs.c line 2547
static void sshfs_file_put(struct sshfs_file *sf)
{
  sf->refs = sf->refs - 1;
  if(sf->refs == 0)
    g_free((void *)sf);

}

// sshfs_flush
// file sshfs.c line 2511
static signed int sshfs_flush(const char *path, struct fuse_file_info *fi)
{
  signed int err;
  struct sshfs_file *sf;
  sf=get_sshfs_file(fi);
  struct list_head write_reqs;
  struct list_head *curr_list;
  signed int return_value_sshfs_file_is_conn$1;
  return_value_sshfs_file_is_conn$1=sshfs_file_is_conn(sf);
  signed int return_value_list_empty$2;
  if(return_value_sshfs_file_is_conn$1 == 0)
    return -5;

  else
    if(!(sshfs.sync_write == 0))
      return 0;

    else
    {
      (void)path;
      pthread_mutex_lock(&sshfs.lock);
      signed int return_value_list_empty$3;
      return_value_list_empty$3=list_empty(&sf->write_reqs);
      if(return_value_list_empty$3 == 0)
      {
        curr_list = sf->write_reqs.prev;
        list_del(&sf->write_reqs);
        list_init(&sf->write_reqs);
        list_add(&write_reqs, curr_list);
        do
        {
          return_value_list_empty$2=list_empty(&write_reqs);
          if(!(return_value_list_empty$2 == 0))
            break;

          pthread_cond_wait(&sf->write_finished, &sshfs.lock);
        }
        while((_Bool)1);
      }

      err = sf->write_error;
      sf->write_error = 0;
      pthread_mutex_unlock(&sshfs.lock);
      return err;
    }
}

// sshfs_fsync
// file sshfs.c line 2540
static signed int sshfs_fsync(const char *path, signed int isdatasync, struct fuse_file_info *fi)
{
  (void)isdatasync;
  signed int return_value_sshfs_flush$1;
  return_value_sshfs_flush$1=sshfs_flush(path, fi);
  return return_value_sshfs_flush$1;
}

// sshfs_ftruncate
// file sshfs.c line 3042
static signed int sshfs_ftruncate(const char *path, signed long int size, struct fuse_file_info *fi)
{
  signed int err;
  struct buffer buf;
  struct sshfs_file *sf;
  sf=get_sshfs_file(fi);
  (void)path;
  signed int return_value_sshfs_file_is_conn$1;
  return_value_sshfs_file_is_conn$1=sshfs_file_is_conn(sf);
  signed int return_value_sshfs_truncate_workaround$2;
  if(return_value_sshfs_file_is_conn$1 == 0)
    return -5;

  else
  {
    sshfs_inc_modifver();
    if(!(sshfs.truncate_workaround == 0))
    {
      return_value_sshfs_truncate_workaround$2=sshfs_truncate_workaround(path, size, fi);
      return return_value_sshfs_truncate_workaround$2;
    }

    else
    {
      buf_init(&buf, (unsigned long int)0);
      buf_add_buf(&buf, &sf->handle);
      buf_add_uint32(&buf, (unsigned int)0x00000001);
      buf_add_uint64(&buf, (unsigned long int)size);
      err=sftp_request((unsigned char)10, &buf, (unsigned char)101, (struct buffer *)(void *)0);
      buf_free(&buf);
      return err;
    }
  }
}

// sshfs_fuse_main
// file sshfs.c line 3337
static signed int sshfs_fuse_main(struct fuse_args *args)
{
  struct fuse_operations *return_value_cache_init$1;
  return_value_cache_init$1=cache_init(&sshfs_oper);
  signed int return_value_fuse_main_real$2;
  return_value_fuse_main_real$2=fuse_main_real(args->argc, args->argv, return_value_cache_init$1, sizeof(struct fuse_operations) /*360ul*/ , (void *)0);
  return return_value_fuse_main_real$2;
}

// sshfs_getattr
// file sshfs.c line 1918
static signed int sshfs_getattr(const char *path, struct stat *stbuf)
{
  signed int err;
  struct buffer buf;
  struct buffer outbuf;
  buf_init(&buf, (unsigned long int)0);
  buf_add_path(&buf, path);
  err=sftp_request((unsigned char)(sshfs.follow_symlinks != 0 ? 17 : 7), &buf, (unsigned char)105, &outbuf);
  if(err == 0)
  {
    err=buf_get_attrs(&outbuf, stbuf, (signed int *)(void *)0);
    buf_free(&outbuf);
  }

  buf_free(&buf);
  return err;
}

// sshfs_getdir
// file sshfs.c line 2141
static signed int sshfs_getdir(const char *path, struct fuse_cache_dirhandle *h, signed int (*filler)(struct fuse_cache_dirhandle *, const char *, struct stat *))
{
  signed int err;
  struct buffer buf;
  struct buffer handle;
  buf_init(&buf, (unsigned long int)0);
  buf_add_path(&buf, path);
  err=sftp_request((unsigned char)11, &buf, (unsigned char)102, &handle);
  if(err == 0)
  {
    signed int err2;
    buf_finish(&handle);
    if(!(sshfs.sync_readdir == 0))
      err=sftp_readdir_sync(&handle, h, filler);

    else
      err=sftp_readdir_async(&handle, h, filler);
    err2=sftp_request((unsigned char)4, &handle, (unsigned char)0, (struct buffer *)(void *)0);
    if(err == 0)
      err = err2;

    buf_free(&handle);
  }

  buf_free(&buf);
  return err;
}

// sshfs_inc_modifver
// file sshfs.c line 2370
static void sshfs_inc_modifver(void)
{
  pthread_mutex_lock(&sshfs.lock);
  sshfs.modifver = sshfs.modifver + 1l;
  pthread_mutex_unlock(&sshfs.lock);
}

// sshfs_init
// file sshfs.c line 1745
static void * sshfs_init(struct fuse_conn_info *conn)
{
  if(!(conn->async_read == 0u))
    sshfs.sync_read = 1;

  if(sshfs.delay_connect == 0)
    start_processing_thread();

  return (void *)0;
}

// sshfs_link
// file sshfs.c line 2310
static signed int sshfs_link(const char *from, const char *to)
{
  signed int err = -38;
  if(sshfs.disable_hardlink == 0 && !(sshfs.ext_hardlink == 0))
  {
    struct buffer buf;
    buf_init(&buf, (unsigned long int)0);
    buf_add_string(&buf, "hardlink@openssh.com");
    buf_add_path(&buf, from);
    buf_add_path(&buf, to);
    err=sftp_request((unsigned char)200, &buf, (unsigned char)101, (struct buffer *)(void *)0);
    buf_free(&buf);
  }

  return err;
}

// sshfs_mkdir
// file sshfs.c line 2168
static signed int sshfs_mkdir(const char *path, unsigned int mode)
{
  signed int err;
  struct buffer buf;
  buf_init(&buf, (unsigned long int)0);
  buf_add_path(&buf, path);
  buf_add_uint32(&buf, (unsigned int)0x00000004);
  buf_add_uint32(&buf, mode);
  err=sftp_request((unsigned char)14, &buf, (unsigned char)101, (struct buffer *)(void *)0);
  buf_free(&buf);
  return err;
}

// sshfs_mknod
// file sshfs.c line 2181
static signed int sshfs_mknod(const char *path, unsigned int mode, unsigned long int rdev)
{
  signed int err;
  struct buffer buf;
  struct buffer handle;
  (void)rdev;
  if(!((61440u & mode) == 32768u))
    return -1;

  else
  {
    buf_init(&buf, (unsigned long int)0);
    buf_add_path(&buf, path);
    buf_add_uint32(&buf, (unsigned int)(0x00000002 | 0x00000008 | 0x00000020));
    buf_add_uint32(&buf, (unsigned int)0x00000004);
    buf_add_uint32(&buf, mode);
    err=sftp_request((unsigned char)3, &buf, (unsigned char)102, &handle);
    if(err == 0)
    {
      signed int err2;
      buf_finish(&handle);
      err2=sftp_request((unsigned char)4, &handle, (unsigned char)101, (struct buffer *)(void *)0);
      if(err == 0)
        err = err2;

      buf_free(&handle);
    }

    buf_free(&buf);
    return err;
  }
}

// sshfs_open
// file sshfs.c line 2501
static signed int sshfs_open(const char *path, struct fuse_file_info *fi)
{
  signed int return_value_sshfs_open_common$1;
  return_value_sshfs_open_common$1=sshfs_open_common(path, (unsigned int)0, fi);
  return return_value_sshfs_open_common$1;
}

// sshfs_open_common
// file sshfs.c line 2420
static signed int sshfs_open_common(const char *path, unsigned int mode, struct fuse_file_info *fi)
{
  signed int err;
  signed int err2;
  struct buffer buf;
  struct buffer outbuf;
  struct stat stbuf;
  struct sshfs_file *sf;
  struct request *open_req;
  unsigned int pflags = (unsigned int)0;
  struct iovec iov;
  unsigned char type;
  unsigned long int wrctr;
  wrctr=cache_get_write_ctr();
  if((0003 & fi->flags) == 00)
    pflags = (unsigned int)0x00000001;

  else
    if((0003 & fi->flags) == 01)
      pflags = (unsigned int)0x00000002;

    else
      if((0003 & fi->flags) == 02)
        pflags = (unsigned int)(0x00000001 | 0x00000002);

      else
        return -22;
  if(!((0100 & fi->flags) == 0))
    pflags = pflags | (unsigned int)0x00000008;

  if(!((0200 & fi->flags) == 0))
    pflags = pflags | (unsigned int)0x00000020;

  if(!((01000 & fi->flags) == 0))
    pflags = pflags | (unsigned int)0x00000010;

  void *return_value_g_malloc0_n$1;
  return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct sshfs_file) /*128ul*/ );
  sf = (struct sshfs_file *)return_value_g_malloc0_n$1;
  list_init(&sf->write_reqs);
  pthread_cond_init(&sf->write_finished, (const union anonymous$3 *)(void *)0);
  sf->is_seq = 0;
  sf->refs = 1;
  sf->next_pos = (signed long int)0;
  pthread_mutex_lock(&sshfs.lock);
  sf->modifver = (signed int)sshfs.modifver;
  sf->connver = sshfs.connver;
  pthread_mutex_unlock(&sshfs.lock);
  buf_init(&buf, (unsigned long int)0);
  buf_add_path(&buf, path);
  buf_add_uint32(&buf, pflags);
  buf_add_uint32(&buf, (unsigned int)0x00000004);
  buf_add_uint32(&buf, mode);
  buf_to_iov(&buf, &iov);
  sftp_request_send((unsigned char)3, &iov, (unsigned long int)1, (void (*)(struct request *))(void *)0, (void (*)(struct request *))(void *)0, 1, (void *)0, &open_req);
  buf_clear(&buf);
  buf_add_path(&buf, path);
  type = (unsigned char)(sshfs.follow_symlinks != 0 ? 17 : 7);
  err2=sftp_request(type, &buf, (unsigned char)105, &outbuf);
  if(err2 == 0)
  {
    err2=buf_get_attrs(&outbuf, &stbuf, (signed int *)(void *)0);
    buf_free(&outbuf);
  }

  err=sftp_request_wait(open_req, (unsigned char)3, (unsigned char)102, &sf->handle);
  if(err == 0 && !(err2 == 0))
  {
    buf_finish(&sf->handle);
    sftp_request((unsigned char)4, &sf->handle, (unsigned char)0, (struct buffer *)(void *)0);
    buf_free(&sf->handle);
    err = err2;
  }

  if(err == 0)
  {
    cache_add_attr(path, &stbuf, wrctr);
    buf_finish(&sf->handle);
    fi->fh = (unsigned long int)sf;
  }

  else
  {
    cache_invalidate(path);
    g_free((void *)sf);
  }
  buf_free(&buf);
  return err;
}

// sshfs_opt_proc
// file sshfs.c line 3346
static signed int sshfs_opt_proc(void *data, const char *arg, signed int key, struct fuse_args *outargs)
{
  char *tmp;
  (void)data;
  signed int return_value_is_ssh_opt$1;
  char *return_value_strchr$2;
  if(!(key == -1))
  {
    if(key == -2)
      goto __CPROVER_DUMP_L3;

    if(key == 0)
      goto __CPROVER_DUMP_L5;

    if(key == 1)
      goto __CPROVER_DUMP_L6;

    if(key == 5)
      goto __CPROVER_DUMP_L7;

    if(key == 2)
      goto __CPROVER_DUMP_L8;

    if(key == 3)
      goto __CPROVER_DUMP_L9;

    if(key == 4)
      goto __CPROVER_DUMP_L10;

  }

  else
  {
    return_value_is_ssh_opt$1=is_ssh_opt(arg);
    if(!(return_value_is_ssh_opt$1 == 0))
    {
      tmp=g_strdup_printf("-o%s", arg);
      ssh_add_arg(tmp);
      g_free((void *)tmp);
      return 0;
    }

    return 1;

  __CPROVER_DUMP_L3:
    ;
    if(sshfs.host == ((char *)NULL))
    {
      return_value_strchr$2=strchr(arg, 58);
      if(!(return_value_strchr$2 == ((char *)NULL)))
      {
        sshfs.host=strdup(arg);
        return 0;
      }

    }

    return 1;

  __CPROVER_DUMP_L5:
    ;
    tmp=g_strdup_printf("-oPort=%s", arg + (signed long int)2);
    ssh_add_arg(tmp);
    g_free((void *)tmp);
    return 0;

  __CPROVER_DUMP_L6:
    ;
    ssh_add_arg("-oCompression=yes");
    return 0;

  __CPROVER_DUMP_L7:
    ;
    tmp=g_strdup_printf("-F%s", arg + (signed long int)2);
    ssh_add_arg(tmp);
    g_free((void *)tmp);
    return 0;

  __CPROVER_DUMP_L8:
    ;
    usage(outargs->argv[(signed long int)0]);
    fuse_opt_add_arg(outargs, "-ho");
    sshfs_fuse_main(outargs);
    exit(1);

  __CPROVER_DUMP_L9:
    ;
    printf("SSHFS version %s\n", (const void *)"2.5");
    fuse_opt_add_arg(outargs, "--version");
    sshfs_fuse_main(outargs);
    exit(0);

  __CPROVER_DUMP_L10:
    ;
    sshfs.foreground = 1;
    return 1;
  }
  fprintf(stderr, "internal error\n");
  abort();
}

// sshfs_read
// file sshfs.c line 2805
static signed int sshfs_read(const char *path, char *rbuf, unsigned long int size, signed long int offset, struct fuse_file_info *fi)
{
  struct sshfs_file *sf;
  sf=get_sshfs_file(fi);
  (void)path;
  signed int return_value_sshfs_file_is_conn$1;
  return_value_sshfs_file_is_conn$1=sshfs_file_is_conn(sf);
  signed int return_value_sshfs_sync_read$2;
  signed int return_value_sshfs_async_read$3;
  if(return_value_sshfs_file_is_conn$1 == 0)
    return -5;

  else
    if(!(sshfs.sync_read == 0))
    {
      return_value_sshfs_sync_read$2=sshfs_sync_read(sf, rbuf, size, offset);
      return return_value_sshfs_sync_read$2;
    }

    else
    {
      return_value_sshfs_async_read$3=sshfs_async_read(sf, rbuf, size, offset);
      return return_value_sshfs_async_read$3;
    }
}

// sshfs_read_begin
// file sshfs.c line 2612
static void sshfs_read_begin(struct request *req)
{
  struct read_req *rreq = (struct read_req *)req->data;
  rreq->sio->num_reqs = rreq->sio->num_reqs + 1;
}

// sshfs_read_end
// file sshfs.c line 2573
static void sshfs_read_end(struct request *req)
{
  struct read_req *rreq = (struct read_req *)req->data;
  signed int return_value_sftp_error_to_errno$1;
  signed int return_value_buf_check_get$3;
  if(!(req->error == 0))
    rreq->res = (signed long int)req->error;

  else
    if(!(req->replied == 0))
    {
      rreq->res = (signed long int)-5;
      if((signed int)req->reply_type == 101)
      {
        unsigned int serr;
        signed int return_value_buf_get_uint32$2;
        return_value_buf_get_uint32$2=buf_get_uint32(&req->reply, &serr);
        if(!(return_value_buf_get_uint32$2 == -1))
        {
          if(serr == 1u)
            rreq->res = (signed long int)0;

          else
          {
            return_value_sftp_error_to_errno$1=sftp_error_to_errno(serr);
            rreq->res = (signed long int)-return_value_sftp_error_to_errno$1;
          }
        }

      }

      else
        if((signed int)req->reply_type == 103)
        {
          unsigned int retsize;
          signed int return_value_buf_get_uint32$4;
          return_value_buf_get_uint32$4=buf_get_uint32(&req->reply, &retsize);
          if(!(return_value_buf_get_uint32$4 == -1))
          {
            if(!(rreq->size >= (unsigned long int)retsize))
              fprintf(stderr, "long read\n");

            else
            {
              return_value_buf_check_get$3=buf_check_get(&req->reply, (unsigned long int)retsize);
              if(!(return_value_buf_check_get$3 == -1))
              {
                rreq->res = (signed long int)retsize;
                rreq->data = req->reply;
                buf_init(&req->reply, (unsigned long int)0);
              }

            }
          }

        }

        else
          fprintf(stderr, "protocol error\n");
    }

    else
      rreq->res = (signed long int)-5;
  rreq->sio->num_reqs = rreq->sio->num_reqs - 1;
  if(rreq->sio->num_reqs == 0)
    pthread_cond_broadcast(&rreq->sio->finished);

}

// sshfs_readlink
// file sshfs.c line 2001
static signed int sshfs_readlink(const char *path, char *linkbuf, unsigned long int size)
{
  signed int err;
  struct buffer buf;
  struct buffer name;
  /* assertion size > 0 */
  assert(size > (unsigned long int)0);
  signed int return_value_buf_get_string$1;
  if(!(sshfs.server_version >= 3))
    return -1;

  else
  {
    buf_init(&buf, (unsigned long int)0);
    buf_add_path(&buf, path);
    err=sftp_request((unsigned char)19, &buf, (unsigned char)104, &name);
    if(err == 0)
    {
      unsigned int count;
      char *link;
      err = -5;
      signed int return_value_buf_get_uint32$2;
      return_value_buf_get_uint32$2=buf_get_uint32(&name, &count);
      if(!(return_value_buf_get_uint32$2 == -1))
      {
        if(count == 1u)
        {
          return_value_buf_get_string$1=buf_get_string(&name, &link);
          if(!(return_value_buf_get_string$1 == -1))
          {
            if(!(sshfs.transform_symlinks == 0))
              transform_symlink(path, &link);

            strncpy(linkbuf, link, size - (unsigned long int)1);
            linkbuf[(signed long int)(size - (unsigned long int)1)] = (char)0;
            free((void *)link);
            err = 0;
          }

        }

      }

      buf_free(&name);
    }

    buf_free(&buf);
    return err;
  }
}

// sshfs_release
// file sshfs.c line 2559
static signed int sshfs_release(const char *path, struct fuse_file_info *fi)
{
  struct sshfs_file *sf;
  sf=get_sshfs_file(fi);
  struct buffer *handle = &sf->handle;
  signed int return_value_sshfs_file_is_conn$1;
  return_value_sshfs_file_is_conn$1=sshfs_file_is_conn(sf);
  if(!(return_value_sshfs_file_is_conn$1 == 0))
  {
    sshfs_flush(path, fi);
    sftp_request((unsigned char)4, handle, (unsigned char)0, (struct buffer *)(void *)0);
  }

  buf_free(handle);
  chunk_put_locked(sf->readahead);
  sshfs_file_put(sf);
  return 0;
}

// sshfs_rename
// file sshfs.c line 2283
static signed int sshfs_rename(const char *from, const char *to)
{
  signed int err;
  if(!(sshfs.ext_posix_rename == 0))
    err=sshfs_ext_posix_rename(from, to);

  else
    err=sshfs_do_rename(from, to);
  if(err == -1 && !(sshfs.rename_workaround == 0))
  {
    unsigned long int tolen;
    tolen=strlen(to);
    if(!(8ul + tolen >= 4096ul))
    {
      signed int tmperr;
      char totmp[4096l];
      strcpy(totmp, to);
      random_string(totmp + (signed long int)tolen, 8);
      tmperr=sshfs_do_rename(to, totmp);
      if(tmperr == 0)
      {
        err=sshfs_do_rename(from, to);
        if(err == 0)
          err=sshfs_unlink(totmp);

        else
          sshfs_do_rename(totmp, to);
      }

    }

  }

  return err;
}

// sshfs_req_pending
// file sshfs.c line 2043
static signed int sshfs_req_pending(struct request *req)
{
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(sshfs.reqtab, (void *)(unsigned long int)req->id);
  if(!(return_value_g_hash_table_lookup$1 == NULL))
    return 1;

  else
    return 0;
}

// sshfs_rmdir
// file sshfs.c line 2239
static signed int sshfs_rmdir(const char *path)
{
  signed int err;
  struct buffer buf;
  buf_init(&buf, (unsigned long int)0);
  buf_add_path(&buf, path);
  err=sftp_request((unsigned char)15, &buf, (unsigned char)101, (struct buffer *)(void *)0);
  buf_free(&buf);
  return err;
}

// sshfs_send_read
// file sshfs.c line 2618
static struct read_chunk * sshfs_send_read(struct sshfs_file *sf, unsigned long int size, signed long int offset)
{
  struct read_chunk *chunk;
  void *return_value_g_malloc0_n$1;
  return_value_g_malloc0_n$1=g_malloc0_n((unsigned long int)1, sizeof(struct read_chunk) /*112ul*/ );
  chunk = (struct read_chunk *)return_value_g_malloc0_n$1;
  struct buffer *handle = &sf->handle;
  pthread_cond_init(&chunk->sio.finished, (const union anonymous$3 *)(void *)0);
  list_init(&chunk->reqs);
  chunk->size = size;
  chunk->offset = offset;
  chunk->refs = 1;
  while(!(size == 0ul))
  {
    signed int err;
    struct buffer buf;
    struct iovec iov[1l];
    struct read_req *rreq;
    unsigned long int bsize = size < (unsigned long int)sshfs.max_read ? size : (unsigned long int)sshfs.max_read;
    void *return_value_g_malloc0_n$2;
    return_value_g_malloc0_n$2=g_malloc0_n((unsigned long int)1, sizeof(struct read_req) /*64ul*/ );
    rreq = (struct read_req *)return_value_g_malloc0_n$2;
    rreq->sio = &chunk->sio;
    rreq->size = bsize;
    buf_init(&rreq->data, (unsigned long int)0);
    list_add(&rreq->list, &chunk->reqs);
    buf_init(&buf, (unsigned long int)0);
    buf_add_buf(&buf, handle);
    buf_add_uint64(&buf, (unsigned long int)offset);
    buf_add_uint32(&buf, (unsigned int)bsize);
    buf_to_iov(&buf, &iov[(signed long int)0]);
    err=sftp_request_send((unsigned char)5, iov, (unsigned long int)1, sshfs_read_begin, sshfs_read_end, 0, (void *)rreq, (struct request **)(void *)0);
    buf_free(&buf);
    if(!(err == 0))
      break;

    size = size - bsize;
    offset = offset + (signed long int)bsize;
  }
  return chunk;
}

// sshfs_statfs
// file sshfs.c line 2989
static signed int sshfs_statfs(const char *path, struct statvfs *buf)
{
  signed int return_value_sshfs_ext_statvfs$1;
  if(!(sshfs.ext_statvfs == 0))
  {
    return_value_sshfs_ext_statvfs$1=sshfs_ext_statvfs(path, buf);
    return return_value_sshfs_ext_statvfs$1;
  }

  else
  {
    buf->f_namemax = (unsigned long int)255;
    buf->f_bsize = (unsigned long int)sshfs.blksize;
    buf->f_frsize = buf->f_bsize;
    buf->f_bavail = (1000ULL * (unsigned long int)1024 * (unsigned long int)1024 * (unsigned long int)1024) / buf->f_frsize;
    buf->f_bfree = buf->f_bavail;
    buf->f_blocks = buf->f_bfree;
    buf->f_ffree = (unsigned long int)1000000000;
    buf->f_files = buf->f_ffree;
    return 0;
  }
}

// sshfs_symlink
// file sshfs.c line 2210
static signed int sshfs_symlink(const char *from, const char *to)
{
  signed int err;
  struct buffer buf;
  if(!(sshfs.server_version >= 3))
    return -1;

  else
  {
    buf_init(&buf, (unsigned long int)0);
    buf_add_string(&buf, from);
    buf_add_path(&buf, to);
    err=sftp_request((unsigned char)20, &buf, (unsigned char)101, (struct buffer *)(void *)0);
    buf_free(&buf);
    return err;
  }
}

// sshfs_sync_read
// file sshfs.c line 2722
static signed int sshfs_sync_read(struct sshfs_file *sf, char *buf, unsigned long int size, signed long int offset)
{
  struct read_chunk *chunk;
  chunk=sshfs_send_read(sf, size, offset);
  signed int return_value_wait_chunk$1;
  return_value_wait_chunk$1=wait_chunk(chunk, buf, size);
  return return_value_wait_chunk$1;
}

// sshfs_sync_write
// file sshfs.c line 2905
static signed int sshfs_sync_write(struct sshfs_file *sf, const char *wbuf, unsigned long int size, signed long int offset)
{
  signed int err = 0;
  struct buffer *handle = &sf->handle;
  struct sshfs_io sio = { .num_reqs=0, .finished={ .__data={ .__lock=0, .__futex=0u, .__total_seq=0ull, .__wakeup_seq=0ull,
    .__woken_seq=0ull, .__mutex=NULL,
    .__nwaiters=0u, .__broadcast_seq=0u } }, .error=0 };
  pthread_cond_init(&sio.finished, (const union anonymous$3 *)(void *)0);
  while(err == 0 && !(size == 0ul))
  {
    struct buffer buf;
    struct iovec iov[2l];
    unsigned long int bsize = size < (unsigned long int)sshfs.max_write ? size : (unsigned long int)sshfs.max_write;
    buf_init(&buf, (unsigned long int)0);
    buf_add_buf(&buf, handle);
    buf_add_uint64(&buf, (unsigned long int)offset);
    buf_add_uint32(&buf, (unsigned int)bsize);
    buf_to_iov(&buf, &iov[(signed long int)0]);
    iov[(signed long int)1].iov_base = (void *)wbuf;
    iov[(signed long int)1].iov_len = bsize;
    err=sftp_request_send((unsigned char)6, iov, (unsigned long int)2, sshfs_sync_write_begin, sshfs_sync_write_end, 0, (void *)&sio, (struct request **)(void *)0);
    buf_free(&buf);
    size = size - bsize;
    wbuf = wbuf + (signed long int)bsize;
    offset = offset + (signed long int)bsize;
  }
  pthread_mutex_lock(&sshfs.lock);
  while(!(sio.num_reqs == 0))
    pthread_cond_wait(&sio.finished, &sshfs.lock);
  pthread_mutex_unlock(&sshfs.lock);
  if(err == 0)
    err = sio.error;

  return err;
}

// sshfs_sync_write_begin
// file sshfs.c line 2878
static void sshfs_sync_write_begin(struct request *req)
{
  struct sshfs_io *sio = (struct sshfs_io *)req->data;
  sio->num_reqs = sio->num_reqs + 1;
}

// sshfs_sync_write_end
// file sshfs.c line 2884
static void sshfs_sync_write_end(struct request *req)
{
  unsigned int serr;
  struct sshfs_io *sio = (struct sshfs_io *)req->data;
  signed int return_value_buf_get_uint32$1;
  if(!(req->error == 0))
    sio->error = req->error;

  else
    if(!(req->replied == 0))
    {
      if(!((signed int)req->reply_type == 101))
        fprintf(stderr, "protocol error\n");

      else
      {
        return_value_buf_get_uint32$1=buf_get_uint32(&req->reply, &serr);
        if(!(return_value_buf_get_uint32$1 == -1))
        {
          if(!(serr == 0u))
            sio->error = -5;

        }

      }
    }

  sio->num_reqs = sio->num_reqs - 1;
  if(sio->num_reqs == 0)
    pthread_cond_broadcast(&sio->finished);

}

// sshfs_truncate
// file sshfs.c line 2377
static signed int sshfs_truncate(const char *path, signed long int size)
{
  signed int err;
  struct buffer buf;
  sshfs_inc_modifver();
  signed int return_value_sshfs_truncate_workaround$1;
  if(size == 0l || !(sshfs.truncate_workaround == 0))
  {
    return_value_sshfs_truncate_workaround$1=sshfs_truncate_workaround(path, size, (struct fuse_file_info *)(void *)0);
    return return_value_sshfs_truncate_workaround$1;
  }

  else
  {
    buf_init(&buf, (unsigned long int)0);
    buf_add_path(&buf, path);
    buf_add_uint32(&buf, (unsigned int)0x00000001);
    buf_add_uint64(&buf, (unsigned long int)size);
    err=sftp_request((unsigned char)9, &buf, (unsigned char)101, (struct buffer *)(void *)0);
    buf_free(&buf);
    return err;
  }
}

// sshfs_truncate_extend
// file sshfs.c line 3160
static signed int sshfs_truncate_extend(const char *path, signed long int size, struct fuse_file_info *fi)
{
  signed int res;
  char c = (char)0;
  struct fuse_file_info tmpfi;
  struct fuse_file_info *openfi = fi;
  if(fi == ((struct fuse_file_info *)NULL))
  {
    openfi = &tmpfi;
    openfi->flags = 01;
    res=sshfs_open(path, openfi);
    if(res == 0)
      goto __CPROVER_DUMP_L1;

    return res;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    res=sshfs_write(path, &c, (unsigned long int)1, size - (signed long int)1, openfi);
    if(res == 1)
      res=sshfs_flush(path, openfi);

    if(fi == ((struct fuse_file_info *)NULL))
      sshfs_release(path, openfi);

    return res;
  }
}

// sshfs_truncate_shrink
// file sshfs.c line 3114
static signed int sshfs_truncate_shrink(const char *path, signed long int size)
{
  signed int res;
  char *data;
  signed long int offset;
  struct fuse_file_info fi;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)size, (unsigned long int)1);
  data = (char *)return_value_calloc$1;
  if(data == ((char *)NULL))
    return -12;

  else
  {
    fi.flags = 00;
    res=sshfs_open(path, &fi);
    if(res == 0)
    {
      offset = (signed long int)0;
      for( ; !(offset >= size); offset = offset + (signed long int)res)
      {
        unsigned long int sshfs_truncate_shrink$$1$$1$$1$$bufsize;
        sshfs_truncate_shrink$$1$$1$$1$$bufsize=calc_buf_size(size, offset);
        res=sshfs_read(path, data + offset, sshfs_truncate_shrink$$1$$1$$1$$bufsize, offset, &fi);
        if(!(res >= 1))
          break;

      }
      sshfs_release(path, &fi);
      if(res >= 0)
      {
        fi.flags = 01 | 01000;
        res=sshfs_open(path, &fi);
        if(res == 0)
        {
          offset = (signed long int)0;
          for( ; !(offset >= size); offset = offset + (signed long int)res)
          {
            unsigned long int bufsize;
            bufsize=calc_buf_size(size, offset);
            res=sshfs_write(path, data + offset, bufsize, offset, &fi);
            if(!(res >= 0))
              break;

          }
          if(res >= 0)
            res=sshfs_flush(path, &fi);

          sshfs_release(path, &fi);
        }

      }

    }


  out:
    ;
    free((void *)data);
    return res;
  }
}

// sshfs_truncate_workaround
// file sshfs.c line 3195
static signed int sshfs_truncate_workaround(const char *path, signed long int size, struct fuse_file_info *fi)
{
  signed int return_value_sshfs_truncate_zero$1;
  signed int return_value_sshfs_truncate_shrink$2;
  signed int return_value_sshfs_truncate_extend$3;
  if(size == 0l)
  {
    return_value_sshfs_truncate_zero$1=sshfs_truncate_zero(path);
    return return_value_sshfs_truncate_zero$1;
  }

  else
  {
    struct stat stbuf;
    signed int err;
    if(!(fi == ((struct fuse_file_info *)NULL)))
      err=sshfs_fgetattr(path, &stbuf, fi);

    else
      err=sshfs_getattr(path, &stbuf);
    if(!(err == 0))
      return err;

    if(stbuf.st_size == size)
      return 0;

    else
      if(!(size >= stbuf.st_size))
      {
        return_value_sshfs_truncate_shrink$2=sshfs_truncate_shrink(path, size);
        return return_value_sshfs_truncate_shrink$2;
      }

      else
      {
        return_value_sshfs_truncate_extend$3=sshfs_truncate_extend(path, size, fi);
        return return_value_sshfs_truncate_extend$3;
      }
  }
}

// sshfs_truncate_zero
// file sshfs.c line 3096
static signed int sshfs_truncate_zero(const char *path)
{
  signed int err;
  struct fuse_file_info fi;
  fi.flags = 01 | 01000;
  err=sshfs_open(path, &fi);
  if(err == 0)
    sshfs_release(path, &fi);

  return err;
}

// sshfs_unlink
// file sshfs.c line 2228
static signed int sshfs_unlink(const char *path)
{
  signed int err;
  struct buffer buf;
  buf_init(&buf, (unsigned long int)0);
  buf_add_path(&buf, path);
  err=sftp_request((unsigned char)13, &buf, (unsigned char)101, (struct buffer *)(void *)0);
  buf_free(&buf);
  return err;
}

// sshfs_utime
// file sshfs.c line 2395
static signed int sshfs_utime(const char *path, struct utimbuf *ubuf)
{
  signed int err;
  struct buffer buf;
  buf_init(&buf, (unsigned long int)0);
  buf_add_path(&buf, path);
  buf_add_uint32(&buf, (unsigned int)0x00000008);
  buf_add_uint32(&buf, (unsigned int)ubuf->actime);
  buf_add_uint32(&buf, (unsigned int)ubuf->modtime);
  err=sftp_request((unsigned char)9, &buf, (unsigned char)101, (struct buffer *)(void *)0);
  buf_free(&buf);
  return err;
}

// sshfs_write
// file sshfs.c line 2947
static signed int sshfs_write(const char *path, const char *wbuf, unsigned long int size, signed long int offset, struct fuse_file_info *fi)
{
  signed int err;
  struct sshfs_file *sf;
  sf=get_sshfs_file(fi);
  (void)path;
  signed int return_value_sshfs_file_is_conn$1;
  return_value_sshfs_file_is_conn$1=sshfs_file_is_conn(sf);
  _Bool tmp_if_expr$2;
  if(return_value_sshfs_file_is_conn$1 == 0)
    return -5;

  else
  {
    sshfs_inc_modifver();
    if(sshfs.sync_write == 0)
      tmp_if_expr$2 = !(sf->write_error != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      err=sshfs_async_write(sf, wbuf, size, offset);

    else
      err=sshfs_sync_write(sf, wbuf, size, offset);
    return err != 0 ? err : (signed int)size;
  }
}

// sshfs_write_begin
// file sshfs.c line 2820
static void sshfs_write_begin(struct request *req)
{
  struct sshfs_file *sf = (struct sshfs_file *)req->data;
  sshfs_file_get(sf);
  list_add(&req->list, &sf->write_reqs);
}

// sshfs_write_end
// file sshfs.c line 2828
static void sshfs_write_end(struct request *req)
{
  unsigned int serr;
  struct sshfs_file *sf = (struct sshfs_file *)req->data;
  signed int return_value_buf_get_uint32$1;
  if(!(req->error == 0))
    sf->write_error = req->error;

  else
    if(!(req->replied == 0))
    {
      if(!((signed int)req->reply_type == 101))
        fprintf(stderr, "protocol error\n");

      else
      {
        return_value_buf_get_uint32$1=buf_get_uint32(&req->reply, &serr);
        if(!(return_value_buf_get_uint32$1 == -1))
        {
          if(!(serr == 0u))
            sf->write_error = -5;

        }

      }
    }

  list_del(&req->list);
  pthread_cond_broadcast(&sf->write_finished);
  sshfs_file_put(sf);
}

// start_processing_thread
// file sshfs.c line 1706
static signed int start_processing_thread(void)
{
  signed int err;
  unsigned long int thread_id;
  struct anonymous$0 oldset;
  struct anonymous$0 newset;
  if(!(sshfs.processing_thread_started == 0))
    return 0;

  else
    if(sshfs.rfd == -1)
    {
      err=connect_remote();
      if(err == 0)
        goto __CPROVER_DUMP_L2;

      return -5;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(!(sshfs.detect_uid == 0))
      {
        sftp_detect_uid();
        sshfs.detect_uid = 0;
      }

      sigemptyset(&newset);
      sigaddset(&newset, 15);
      sigaddset(&newset, 2);
      sigaddset(&newset, 1);
      sigaddset(&newset, 3);
      pthread_sigmask(0, &newset, &oldset);
      err=pthread_create(&thread_id, (const union pthread_attr_t *)(void *)0, process_requests, (void *)0);
      if(!(err == 0))
      {
        char *return_value_strerror$1;
        return_value_strerror$1=strerror(err);
        fprintf(stderr, "failed to create thread: %s\n", return_value_strerror$1);
        return -5;
      }

      pthread_detach(thread_id);
      pthread_sigmask(2, &oldset, (struct anonymous$0 *)(void *)0);
      sshfs.processing_thread_started = 1;
      return 0;
    }
}

// start_ssh
// file sshfs.c line 993
static signed int start_ssh(void)
{
  char *ptyname = (char *)(void *)0;
  signed int sockpair[2l];
  signed int pid;
  _Bool tmp_if_expr$5;
  signed int return_value_dup2$4;
  if(!(sshfs.password_stdin == 0))
  {
    sshfs.ptyfd=pty_master(&ptyname);
    if(sshfs.ptyfd == -1)
      return -1;

    sshfs.ptyslavefd=open(ptyname, 02 | 0400);
    if(!(sshfs.ptyslavefd == -1))
      goto __CPROVER_DUMP_L2;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    signed int return_value_socketpair$1;
    return_value_socketpair$1=socketpair(1, 1, 0, sockpair);
    if(return_value_socketpair$1 == -1)
    {
      perror("failed to create socket pair");
      return -1;
    }

    else
    {
      sshfs.rfd = sockpair[(signed long int)0];
      sshfs.wfd = sockpair[(signed long int)0];
      pid=fork();
      if(pid == -1)
      {
        perror("failed to fork");
        close(sockpair[(signed long int)1]);
        return -1;
      }

      else
        if(pid == 0)
        {
          signed int devnull;
          if(!(sshfs.nodelaysrv_workaround == 0))
          {
            signed int i = 1;
            for( ; !(i >= sshfs.ssh_args.argc); i = i + 1)
            {
              signed int return_value_strcmp$2;
              return_value_strcmp$2=strcmp(sshfs.ssh_args.argv[(signed long int)i], "-x");
              if(return_value_strcmp$2 == 0)
              {
                replace_arg(&sshfs.ssh_args.argv[(signed long int)i], "-X");
                break;
              }

            }
          }

          devnull=open("/dev/null", 01);
          signed int return_value_dup2$3;
          return_value_dup2$3=dup2(sockpair[(signed long int)1], 0);
          if(return_value_dup2$3 == -1)
            tmp_if_expr$5 = (_Bool)1;

          else
          {
            return_value_dup2$4=dup2(sockpair[(signed long int)1], 1);
            tmp_if_expr$5 = return_value_dup2$4 == -1 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$5)
          {
            perror("failed to redirect input/output");
            _exit(1);
          }

          if(sshfs.foreground == 0 && !(devnull == -1))
            dup2(devnull, 2);

          close(devnull);
          close(sockpair[(signed long int)0]);
          close(sockpair[(signed long int)1]);
          signed int return_value_fork$6;
          return_value_fork$6=fork();
          if(!(return_value_fork$6 == -1))
          {
            if(return_value_fork$6 == 0)
              goto __CPROVER_DUMP_L14;

          }

          else
          {
            perror("failed to fork");
            _exit(1);

          __CPROVER_DUMP_L14:
            ;
            goto __CPROVER_DUMP_L16;
          }
          _exit(0);

        __CPROVER_DUMP_L16:
          ;
          chdir("/");
          if(!(sshfs.password_stdin == 0))
          {
            signed int sfd;
            setsid();
            sfd=open(ptyname, 02);
            if(sfd == -1)
            {
              perror(ptyname);
              _exit(1);
            }

            close(sfd);
            close(sshfs.ptyslavefd);
            close(sshfs.ptyfd);
          }

          if(!(sshfs.debug == 0))
          {
            signed int start_ssh$$1$$4$$5$$i;
            fprintf(stderr, "executing");
            start_ssh$$1$$4$$5$$i = 0;
            for( ; !(start_ssh$$1$$4$$5$$i >= sshfs.ssh_args.argc); start_ssh$$1$$4$$5$$i = start_ssh$$1$$4$$5$$i + 1)
              fprintf(stderr, " <%s>", sshfs.ssh_args.argv[(signed long int)start_ssh$$1$$4$$5$$i]);
            fprintf(stderr, "\n");
          }

          execvp(sshfs.ssh_args.argv[(signed long int)0], sshfs.ssh_args.argv);
          signed int *return_value___errno_location$7;
          return_value___errno_location$7=__errno_location();
          char *return_value_strerror$8;
          return_value_strerror$8=strerror(*return_value___errno_location$7);
          fprintf(stderr, "failed to execute '%s': %s\n", sshfs.ssh_args.argv[(signed long int)0], return_value_strerror$8);
          _exit(1);
        }

      waitpid(pid, (signed int *)(void *)0, 0);
      close(sockpair[(signed long int)1]);
      return 0;
    }
  }
}

// strip_common
// file sshfs.c line 1947
static void strip_common(const char **sp, const char **tp)
{
  const char *s = *sp;
  const char *t = *tp;

__CPROVER_DUMP_L1:
  ;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  while((_Bool)1)
  {
    if((signed int)*s == 47)
    {
      s = s + 1l;
      goto __CPROVER_DUMP_L1;
    }

    for( ; (signed int)*t == 47; t = t + 1l)
      ;
    *tp = t;
    *sp = s;
    do
    {
      if(*s == *t)
        tmp_if_expr$6 = *s != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (signed int)*s != 47 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$7 = (_Bool)0;
      if(!tmp_if_expr$7)
        break;

      s = s + 1l;
      t = t + 1l;
    }
    while((_Bool)1);
    if(*s == *t)
      tmp_if_expr$1 = *s != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      if(*s == 0)
        tmp_if_expr$2 = (signed int)*t == 47 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      if((signed int)*s == 47)
        tmp_if_expr$4 = !(*t != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$5)
      break;

  }
}

// submit_read
// file sshfs.c line 2731
static void submit_read(struct sshfs_file *sf, unsigned long int size, signed long int offset, struct read_chunk **chunkp)
{
  struct read_chunk *chunk;
  chunk=sshfs_send_read(sf, size, offset);
  pthread_mutex_lock(&sshfs.lock);
  chunk->modifver = sshfs.modifver;
  chunk_put(*chunkp);
  *chunkp = chunk;
  chunk->refs = chunk->refs + 1;
  pthread_mutex_unlock(&sshfs.lock);
}

// transform_symlink
// file sshfs.c line 1960
static void transform_symlink(const char *path, char **linkp)
{
  const char *l = *linkp;
  const char *b = sshfs.base_path;
  char *newlink;
  char *s;
  signed int dotdots;
  signed int i;
  _Bool tmp_if_expr$1;
  if(!((signed int)*l == 47))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)b[(signed long int)0] != 47 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
  {
    strip_common(&l, &b);
    if(*b == 0)
    {
      strip_common(&l, &path);
      dotdots=count_components(path);
      if(!(dotdots == 0))
      {
        dotdots = dotdots - 1;
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(l);
        void *return_value_malloc$3;
        return_value_malloc$3=malloc((unsigned long int)(dotdots * 3) + return_value_strlen$2 + (unsigned long int)2);
        newlink = (char *)return_value_malloc$3;
        if(newlink == ((char *)NULL))
        {
          fprintf(stderr, "sshfs: memory allocation failed\n");
          abort();
        }

        s = newlink;
        i = 0;
        for( ; !(i >= dotdots); s = s + (signed long int)3)
        {
          strcpy(s, "../");
          i = i + 1;
        }
        if(!(*l == 0))
          strcpy(s, l);

        else
          if(dotdots == 0)
            strcpy(s, ".");

          else
            s[(signed long int)0] = (char)0;
        free((void *)*linkp);
        *linkp = newlink;
      }

    }

  }

}

// translate_id
// file sshfs.c line 488
static inline signed int translate_id(unsigned int *id, struct _GHashTable *map)
{
  void *id_p;
  signed int return_value_g_hash_table_lookup_extended$1;
  return_value_g_hash_table_lookup_extended$1=g_hash_table_lookup_extended(map, (void *)(unsigned long int)*id, (void **)(void *)0, &id_p);
  if(!(return_value_g_hash_table_lookup_extended$1 == 0))
  {
    *id = (unsigned int)(unsigned long int)id_p;
    return 0;
  }

  else
    switch(sshfs.nomap)
    {
      case 1:
        return -1;
      case 0:
        return 0;
      default:
      {
        fprintf(stderr, "internal error\n");
        abort();
      }
    }
}

// type_name
// file sshfs.c line 415
static const char * type_name(unsigned char type)
{
  switch((signed int)type)
  {
    case 1:
      return "INIT";
    case 2:
      return "VERSION";
    case 3:
      return "OPEN";
    case 4:
      return "CLOSE";
    case 5:
      return "READ";
    case 6:
      return "WRITE";
    case 7:
      return "LSTAT";
    case 8:
      return "FSTAT";
    case 9:
      return "SETSTAT";
    case 10:
      return "FSETSTAT";
    case 11:
      return "OPENDIR";
    case 12:
      return "READDIR";
    case 13:
      return "REMOVE";
    case 14:
      return "MKDIR";
    case 15:
      return "RMDIR";
    case 16:
      return "REALPATH";
    case 17:
      return "STAT";
    case 18:
      return "RENAME";
    case 19:
      return "READLINK";
    case 20:
      return "SYMLINK";
    case 101:
      return "STATUS";
    case 102:
      return "HANDLE";
    case 103:
      return "DATA";
    case 104:
      return "NAME";
    case 105:
      return "ATTRS";
    case 200:
      return "EXTENDED";
    case 201:
      return "EXTENDED_REPLY";
    default:
      return "???";
  }
}

// usage
// file sshfs.c line 3265
static void usage(const char *progname)
{
  printf("usage: %s [user@]host:[dir] mountpoint [options]\n\ngeneral options:\n    -o opt,[opt...]        mount options\n    -h   --help            print help\n    -V   --version         print version\n\nSSHFS options:\n    -p PORT                equivalent to '-o port=PORT'\n    -C                     equivalent to '-o compression=yes'\n    -F ssh_configfile      specifies alternative ssh configuration file\n    -1                     equivalent to '-o ssh_protocol=1'\n    -o reconnect           reconnect to server\n    -o delay_connect       delay connection to server\n    -o sshfs_sync          synchronous writes\n    -o no_readahead        synchronous reads (no speculative readahead)\n    -o sync_readdir        synchronous readdir\n    -o sshfs_debug         print some debugging information\n    -o cache=BOOL          enable caching {yes,no} (default: yes)\n    -o cache_timeout=N     sets timeout for caches in seconds (default: 20)\n    -o cache_X_timeout=N   sets timeout for {stat,dir,link} cache\n    -o workaround=LIST     colon separated list of workarounds\n             none             no workarounds enabled\n             all              all workarounds enabled\n             [no]rename       fix renaming to existing file (default: off)\n             [no]nodelaysrv   set nodelay tcp flag in sshd (default: off)\n             [no]truncate     fix truncate for old servers (default: off)\n             [no]buflimit     fix buffer fillup bug in server (default: on)\n    -o idmap=TYPE          user/group ID mapping, possible types are:\n             none             no translation of the ID space (default)\n             user             only translate UID of connecting user\n             file             translate UIDs/GIDs contained in uidfile/gidfile\n    -o uidfile=FILE        file containing username:remote_uid mappings\n    -o gidfile=FILE        file containing groupname:remote_gid mappings\n    -o nomap=TYPE          with idmap=file, how to handle missing mappings\n             ignore           don't do any re-mapping\n             error            return an error (default)\n    -o ssh_command=CMD     execute CMD instead of 'ssh'\n    -o ssh_protocol=N      ssh protocol to use (default: 2)\n    -o sftp_server=SERV    path to sftp server or subsystem (default: sftp)\n    -o directport=PORT     directly connect to PORT bypassing ssh\n    -o slave               communicate over stdin and stdout bypassing network\n    -o disable_hardlink    link(2) will return with errno set to ENOSYS\n    -o transform_symlinks  transform absolute symlinks to relative\n    -o follow_symlinks     follow symlinks on the server\n    -o no_check_root       don't check for existence of 'dir' on server\n    -o password_stdin      read password from stdin (only for pam_mount!)\n    -o SSHOPT=VAL          ssh options (see man ssh_config)\n\n", progname);
}

// username_to_uid
// file sshfs.c line 3745
static unsigned int * username_to_uid(char *name)
{
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  struct passwd *pw;
  pw=getpwnam(name);
  if(pw == ((struct passwd *)NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(*return_value___errno_location$2 == 0)
      return (unsigned int *)(void *)0;

    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    fprintf(stderr, "Failed to look up user '%s': %s\n", name, return_value_strerror$4);
    exit(1);
  }

  unsigned int *r;
  void *return_value_malloc$5;
  return_value_malloc$5=malloc(sizeof(unsigned int) /*4ul*/ );
  r = (unsigned int *)return_value_malloc$5;
  if(r == ((unsigned int *)NULL))
  {
    fprintf(stderr, "sshfs: memory allocation failed\n");
    abort();
  }

  *r = pw->pw_uid;
  return r;
}

// wait_chunk
// file sshfs.c line 2664
static signed int wait_chunk(struct read_chunk *chunk, char *buf, unsigned long int size)
{
  signed int res = 0;
  struct read_req *rreq;
  pthread_mutex_lock(&sshfs.lock);
  while(!(chunk->sio.num_reqs == 0))
    pthread_cond_wait(&chunk->sio.finished, &sshfs.lock);
  pthread_mutex_unlock(&sshfs.lock);
  signed int return_value_list_empty$1;
  struct read_req *tmp_statement_expression$2;
  if(!(chunk->sio.error == 0))
  {
    if(!(chunk->sio.error == 1))
      res = chunk->sio.error;

  }

  else
  {
    do
    {
      return_value_list_empty$1=list_empty(&chunk->reqs);
      if(!(return_value_list_empty$1 == 0))
        break;

      if(size == 0ul)
        break;

      const struct list_head *__mptr = chunk->reqs.prev;
      tmp_statement_expression$2 = (struct read_req *)((char *)__mptr - (signed long int)8ul);
      rreq = tmp_statement_expression$2;
      if(!(rreq->res >= 0l))
      {
        chunk->sio.error = (signed int)rreq->res;
        break;
      }

      if(rreq->res == 0l)
      {
        chunk->sio.error = 1;
        break;
      }

      else
        if(!(size >= (unsigned long int)rreq->res))
        {
          buf_get_mem(&rreq->data, (void *)buf, size);
          rreq->res = rreq->res - (signed long int)size;
          rreq->size = rreq->size - size;
          res = res + (signed int)size;
          break;
        }

        else
        {
          buf_get_mem(&rreq->data, (void *)buf, (unsigned long int)rreq->res);
          res = res + (signed int)rreq->res;
          if(!((unsigned long int)rreq->res >= rreq->size))
          {
            chunk->sio.error = 1;
            break;
          }

          buf = buf + rreq->res;
          size = size - (unsigned long int)rreq->res;
          list_del(&rreq->list);
          buf_free(&rreq->data);
          g_free((void *)rreq);
        }
    }
    while((_Bool)1);
    if(res >= 1)
    {
      chunk->offset = chunk->offset + (signed long int)res;
      chunk->size = chunk->size - (unsigned long int)res;
    }

  }

out:
  ;
  chunk_put_locked(chunk);
  return res;
}

// workaround_opt_proc
// file sshfs.c line 3409
static signed int workaround_opt_proc(void *data, const char *arg, signed int key, struct fuse_args *outargs)
{
  (void)data;
  (void)key;
  (void)outargs;
  fprintf(stderr, "unknown workaround: '%s'\n", arg);
  return -1;
}

