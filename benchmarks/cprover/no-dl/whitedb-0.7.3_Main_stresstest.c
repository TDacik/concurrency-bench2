// #anon_enum_ARRAY=0_OBJECT=1
// file dbjson.c line 82
enum anonymous_2 { ARRAY=0, OBJECT=1 };

// #anon_enum_yajl_allow_comments=1_yajl_dont_validate_strings=2_yajl_allow_trailing_garbage=4_yajl_allow_multiple_values=8_yajl_allow_partial_values=16
// file ../json/yajl_api.h line 144
enum anonymous_4 { yajl_allow_comments=1, yajl_dont_validate_strings=2, yajl_allow_trailing_garbage=4, yajl_allow_multiple_values=8, yajl_allow_partial_values=16 };

// #anon_enum_yajl_gen_beautify=1_yajl_gen_indent_string=2_yajl_gen_print_callback=4_yajl_gen_validate_utf8=8_yajl_gen_escape_solidus=16
// file ../json/yajl_api.h line 294
enum anonymous_32 { yajl_gen_beautify=1, yajl_gen_indent_string=2, yajl_gen_print_callback=4, yajl_gen_validate_utf8=8, yajl_gen_escape_solidus=16 };

// #anon_enum_yajl_gen_start=0_yajl_gen_map_start=1_yajl_gen_map_key=2_yajl_gen_map_val=3_yajl_gen_array_start=4_yajl_gen_in_array=5_yajl_gen_complete=6_yajl_gen_error=7
// file yajl_all.c line 52
enum anonymous_31 { yajl_gen_start=0, yajl_gen_map_start=1, yajl_gen_map_key=2, yajl_gen_map_val=3, yajl_gen_array_start=4, yajl_gen_in_array=5, yajl_gen_complete=6, yajl_gen_error=7 };

// #anon_enum_yajl_gen_status_ok=0_yajl_gen_keys_must_be_strings=1_yajl_max_depth_exceeded=2_yajl_gen_in_error_state=3_yajl_gen_generation_complete=4_yajl_gen_invalid_number=5_yajl_gen_no_buf=6_yajl_gen_invalid_string=7
// file ../json/yajl_api.h line 257
enum anonymous_33 { yajl_gen_status_ok=0, yajl_gen_keys_must_be_strings=1, yajl_max_depth_exceeded=2, yajl_gen_in_error_state=3, yajl_gen_generation_complete=4, yajl_gen_invalid_number=5, yajl_gen_no_buf=6, yajl_gen_invalid_string=7 };

// #anon_enum_yajl_lex_e_ok=0_yajl_lex_string_invalid_utf8=1_yajl_lex_string_invalid_escaped_char=2_yajl_lex_string_invalid_json_char=3_yajl_lex_string_invalid_hex_char=4_yajl_lex_invalid_char=5_yajl_lex_invalid_string=6_yajl_lex_missing_integer_after_decimal=7_yajl_lex_missing_integer_after_exponent=8_yajl_lex_missing_integer_after_minus=9_yajl_lex_unallowed_comment=10
// file yajl_all.h line 188
enum anonymous_28 { yajl_lex_e_ok=0, yajl_lex_string_invalid_utf8=1, yajl_lex_string_invalid_escaped_char=2, yajl_lex_string_invalid_json_char=3, yajl_lex_string_invalid_hex_char=4, yajl_lex_invalid_char=5, yajl_lex_invalid_string=6, yajl_lex_missing_integer_after_decimal=7, yajl_lex_missing_integer_after_exponent=8, yajl_lex_missing_integer_after_minus=9, yajl_lex_unallowed_comment=10 };

// #anon_enum_yajl_state_start=0_yajl_state_parse_complete=1_yajl_state_parse_error=2_yajl_state_lexical_error=3_yajl_state_map_start=4_yajl_state_map_sep=5_yajl_state_map_need_val=6_yajl_state_map_got_val=7_yajl_state_map_need_key=8_yajl_state_array_start=9_yajl_state_array_got_val=10_yajl_state_array_need_val=11_yajl_state_got_value=12
// file yajl_all.h line 209
enum anonymous_30 { yajl_state_start=0, yajl_state_parse_complete=1, yajl_state_parse_error=2, yajl_state_lexical_error=3, yajl_state_map_start=4, yajl_state_map_sep=5, yajl_state_map_need_val=6, yajl_state_map_got_val=7, yajl_state_map_need_key=8, yajl_state_array_start=9, yajl_state_array_got_val=10, yajl_state_array_need_val=11, yajl_state_got_value=12 };

// #anon_enum_yajl_status_ok=0_yajl_status_client_canceled=1_yajl_status_error=2
// file ../json/yajl_api.h line 62
enum anonymous_27 { yajl_status_ok=0, yajl_status_client_canceled=1, yajl_status_error=2 };

// #anon_enum_yajl_tok_bool=0_yajl_tok_colon=1_yajl_tok_comma=2_yajl_tok_eof=3_yajl_tok_error=4_yajl_tok_left_brace=5_yajl_tok_left_bracket=6_yajl_tok_null=7_yajl_tok_right_brace=8_yajl_tok_right_bracket=9_yajl_tok_integer=10_yajl_tok_double=11_yajl_tok_string=12_yajl_tok_string_with_escapes=13_yajl_tok_comment=14
// file yajl_all.h line 128
enum anonymous_29 { yajl_tok_bool=0, yajl_tok_colon=1, yajl_tok_comma=2, yajl_tok_eof=3, yajl_tok_error=4, yajl_tok_left_brace=5, yajl_tok_left_bracket=6, yajl_tok_null=7, yajl_tok_right_brace=8, yajl_tok_right_bracket=9, yajl_tok_integer=10, yajl_tok_double=11, yajl_tok_string=12, yajl_tok_string_with_escapes=13, yajl_tok_comment=14 };

// tag-#anon#ST[*{*{V}_V_(*{V}_V_|U64)->*{V}_V_}_*{V}_V_(*{V}_V_|U64)->*{V}_V__'malloc'||*{*{V}_V_(*{V}_V_|*{V}_V_|U64)->*{V}_V_}_*{V}_V_(*{V}_V_|*{V}_V_|U64)->*{V}_V__'realloc'||*{V(*{V}_V_|*{V}_V_)->V}_V(*{V}_V_|*{V}_V_)->V_'free'||*{V}_V_'ctx'|]
// file ../json/yajl_api.h line 43
struct anonymous_3;

// tag-#anon#ST[*{S32(*{V}_V_)->S32}_S32(*{V}_V_)->S32_'yajl_null'||*{S32(*{V}_V_|S32)->S32}_S32(*{V}_V_|S32)->S32_'yajl_boolean'||*{S32(*{V}_V_|S64)->S32}_S32(*{V}_V_|S64)->S32_'yajl_integer'||*{S32(*{V}_V_|F64)->S32}_S32(*{V}_V_|F64)->S32_'yajl_double'||*{S32(*{V}_V_|*{cS8}_cS8_|U64)->S32}_S32(*{V}_V_|*{cS8}_cS8_|U64)->S32_'yajl_number'||*{S32(*{V}_V_|*{cU8}_cU8_|U64)->S32}_S32(*{V}_V_|*{cU8}_cU8_|U64)->S32_'yajl_string'||*{S32(*{V}_V_)->S32}_S32(*{V}_V_)->S32_'yajl_start_map'||*{S32(*{V}_V_|*{cU8}_cU8_|U64)->S32}_S32(*{V}_V_|*{cU8}_cU8_|U64)->S32_'yajl_map_key'||*{S32(*{V}_V_)->S32}_S32(*{V}_V_)->S32_'yajl_end_map'||*{S32(*{V}_V_)->S32}_S32(*{V}_V_)->S32_'yajl_start_array'||*{S32(*{V}_V_)->S32}_S32(*{V}_V_)->S32_'yajl_end_array'|]
// file ../json/yajl_api.h line 103
struct anonymous;

// tag-#anon#ST[*{SYM#tag-__query_result_page#}_SYM#tag-__query_result_page#_'page'||S64'pidx'|]
// file dbquery.c line 75
struct anonymous_16;

// tag-#anon#ST[*{SYM#tag-_db_memsegment_header#}_SYM#tag-_db_memsegment_header#_'db'||*{V}_V_'logdata'|]
// file dballoc.h line 511
struct anonymous_6;

// tag-#anon#ST[*{V}_V_'freeptr'||S32'cur_subarea'||S32'nrof_subareas'||ARR100{SYM#tag-_wg_mpoolsubarea_header#}_SYM#tag-_wg_mpoolsubarea_header#_'subarea_table'|]
// file dbmpool.c line 85
struct anonymous_8;

// tag-#anon#ST[*{V}_V_'mpool'||*{SYM#tag-__query_result_page#}_SYM#tag-__query_result_page#_'first_page'||SYM#tag-#anon#ST[*{SYM#tag-__query_result_page#}_SYM#tag-__query_result_page#_'page'||S64'pidx'|]#'wcursor'||SYM#tag-#anon#ST[*{SYM#tag-__query_result_page#}_SYM#tag-__query_result_page#_'page'||S64'pidx'|]#'rcursor'||S64'res_count'|]
// file dbquery.c line 80
struct anonymous_17;

// tag-#anon#ST[EN#anon_enum_ARRAY=0_OBJECT=1#{U32}_U32_'type'||U32'_pad0'||*{SYM#tag-__stack_entry_elem#}_SYM#tag-__stack_entry_elem#_'head'||*{SYM#tag-__stack_entry_elem#}_SYM#tag-__stack_entry_elem#_'tail'||ARR80{S8}_S8_'last_key'||S32'size'||U32'_pad1'|]
// file dbjson.c line 91
struct anonymous_1;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_13;

// tag-#anon#ST[S32'state'||U32'_pad0'||ARR7{SYM#tag-#anon#ST[EN#anon_enum_ARRAY=0_OBJECT=1#{U32}_U32_'type'||U32'_pad0'||*{SYM#tag-__stack_entry_elem#}_SYM#tag-__stack_entry_elem#_'head'||*{SYM#tag-__stack_entry_elem#}_SYM#tag-__stack_entry_elem#_'tail'||ARR80{S8}_S8_'last_key'||S32'size'||U32'_pad1'|]#}_SYM#tag-#anon#ST[EN#anon_enum_ARRAY=0_OBJECT=1#{U32}_U32_'type'||U32'_pad0'||*{SYM#tag-__stack_entry_elem#}_SYM#tag-__stack_entry_elem#_'head'||*{SYM#tag-__stack_entry_elem#}_SYM#tag-__stack_entry_elem#_'tail'||ARR80{S8}_S8_'last_key'||S32'size'||U32'_pad1'|]#_'stack'||S32'stack_ptr'||U32'_pad1'||*{V}_V_'db'||S32'isparam'||S32'isdocument'||*{*{V}_V_}_*{V}_V__'document'|]
// file dbjson.c line 99
struct anonymous_0;

// tag-#anon#ST[S32'threadid'||U32'_pad0'||*{V}_V_'db'||U64'pth'|]
// file stresstest.c line 75
struct anonymous_9;

// tag-#anon#ST[S64'active'||S64'dirty'||S64'serial'|]
// file dballoc.h line 432
struct anonymous_24;

// tag-#anon#ST[S64'car'||S64'cdr'|]
// file dballoc.h line 247
struct anonymous_20;

// tag-#anon#ST[S64'column'||S64'cond'||S64'value'|]
// file dbquery.h line 56
struct anonymous_12;

// tag-#anon#ST[S64'count'||ARR20{S64}_S64_'offset'||ARR20{S64}_S64_'size'|]
// file dballoc.h line 422
struct anonymous_23;

// tag-#anon#ST[S64'fixed_columns'||S64'offset_matchrec'||S64'refcount'|]
// file dballoc.h line 396
struct anonymous_22;

// tag-#anon#ST[S64'key'||S64'value'|]
// file dbquery.h line 62
struct anonymous_18;

// tag-#anon#ST[S64'level'||*{*{SYM#tag-#anon#ST[S64'level'||S64'fill'||ARR8{S64}_S64_'key'||ARR8{S64}_S64_'value'|]#}_SYM#tag-#anon#ST[S64'level'||S64'fill'||ARR8{S64}_S64_'key'||ARR8{S64}_S64_'value'|]#_}_*{SYM#tag-#anon#ST[S64'level'||S64'fill'||ARR8{S64}_S64_'key'||ARR8{S64}_S64_'value'|]#}_SYM#tag-#anon#ST[S64'level'||S64'fill'||ARR8{S64}_S64_'key'||ARR8{S64}_S64_'value'|]#__'directory'||*{V}_V_'mpool'|]
// file dbhash.c line 83
struct anonymous_35;

// tag-#anon#ST[S64'level'||S64'fill'||ARR8{S64}_S64_'key'||ARR8{S64}_S64_'value'|]
// file dbhash.c line 72
struct anonymous_34;

// tag-#anon#ST[S64'next_cell'||S64'class'||vS64'waiting'||vS64'next'||vS64'prev'|]
// file dblock.h line 56
struct anonymous_5;

// tag-#anon#ST[S64'number_of_indexes'||S64'index_list'||ARR128{S64}_S64_'index_table'||S64'index_template_list'||ARR128{S64}_S64_'index_template_table'|]
// file dballoc.h line 407
struct anonymous_19;

// tag-#anon#ST[S64'offset'||S64'size'|]
// file dballoc.h line 443
struct anonymous_25;

// tag-#anon#ST[S64'qtype'||*{SYM#tag-#anon#ST[S64'column'||S64'cond'||S64'value'|]#}_SYM#tag-#anon#ST[S64'column'||S64'cond'||S64'value'|]#_'arglist'||S64'argc'||S64'column'||S64'curr_offset'||S64'end_offset'||S64'curr_slot'||S64'end_slot'||S64'direction'||S64'curr_record'||*{V}_V_'mpool'||*{V}_V_'curr_page'||S64'curr_pidx'||U64'res_count'|]
// file dbquery.h line 68
struct anonymous_15;

// tag-#anon#ST[S64'tail'||S64'queue_lock'||S64'storage'||S64'max_nodes'||S64'freelist'|]
// file dballoc.h line 331
struct anonymous_7;

// tag-#anon#ST[S64'type'||S64'fields'||ARR10{S64}_S64_'rec_field_index'||SYM#tag-#anon#UN[SYM#tag-__wg_ttree_header#'t'||SYM#tag-__wg_hashidx_header#'h'|]#'ctl'||S64'template_offset'|]
// file dballoc.h line 380
struct anonymous_21;

// tag-#anon#ST[U64'dhash_size'||*{S64}_S64_'keys'|]
// file dbhash.c line 90
struct anonymous_36;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_11;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_14;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_10;

// tag-#anon#UN[SYM#tag-__wg_ttree_header#'t'||SYM#tag-__wg_hashidx_header#'h'|]
// file dballoc.h line 384
union anonymous_26;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__query_result_page
// file dbquery.c line 68
struct __query_result_page;

// tag-__stack_entry_elem
// file dbjson.c line 84
struct __stack_entry_elem;

// tag-__wg_hashidx_header
// file dballoc.h line 372
struct __wg_hashidx_header;

// tag-__wg_ttree_header
// file dballoc.h line 361
struct __wg_ttree_header;

// tag-_db_area_header
// file dballoc.h line 316
struct _db_area_header;

// tag-_db_hash_area_header
// file dballoc.h line 350
struct _db_hash_area_header;

// tag-_db_memsegment_header
// file dballoc.h line 464
struct _db_memsegment_header;

// tag-_db_subarea_header
// file dballoc.h line 304
struct _db_subarea_header;

// tag-_wg_mpoolsubarea_header
// file dbmpool.c line 73
struct _wg_mpoolsubarea_header;

// tag-ipc_perm
// file /usr/include/x86_64-linux-gnu/bits/ipc.h line 42
struct ipc_perm;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-shmid_ds
// file /usr/include/x86_64-linux-gnu/bits/shm.h line 49
struct shmid_ds;

// tag-timeb
// file /usr/include/x86_64-linux-gnu/sys/timeb.h line 31
struct timeb;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-uri_scheme_info
// file dbutil.c line 74
struct uri_scheme_info;

// tag-wg_tnode
// file dbindex.h line 87
struct wg_tnode;

// tag-yajl_buf_t
// file yajl_all.h line 49
struct yajl_buf_t;

// tag-yajl_bytestack_t
// file yajl_all.h line 76
struct yajl_bytestack_t;

// tag-yajl_gen_t
// file yajl_api.h line 284
struct yajl_gen_t;

// tag-yajl_handle_t
// file yajl_api.h line 76
struct yajl_handle_t;

// tag-yajl_lexer_t
// file yajl_all.h line 154
struct yajl_lexer_t;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef FENCE
#define FENCE(x) ((void)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// CharToHex
// file yajl_all.c line 346
static void CharToHex(unsigned char c, char *hexBuf);
// Utf32toUtf8
// file yajl_all.c line 412
static void Utf32toUtf8(unsigned int codepoint, char *utf8Buf);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __isinf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 192
extern signed int __isinf(double);
// __isinff
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 192
extern signed int __isinff(float);
// __isinfl
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 192
extern signed int __isinfl(long double);
// __isnan
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 230
extern signed int __isnan(double);
// __isnanf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 230
extern signed int __isnanf(float);
// __isnanl
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 230
extern signed int __isnanl(long double);
// __sync_bool_compare_and_swap
// file gcc_builtin_headers_generic.h line 105
_Bool __sync_bool_compare_and_swap();
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// add_elem
// file dbjson.c line 525
static signed int add_elem(struct anonymous_0 *ctx, signed long int enc);
// add_index_template
// file dbindex.c line 1757
static signed long int add_index_template(void *db, signed long int *matchrec, signed long int reclen);
// add_key
// file dbjson.c line 553
static signed int add_key(struct anonymous_0 *ctx, char *key);
// add_literal
// file dbjson.c line 571
static signed int add_literal(struct anonymous_0 *ctx, signed long int val);
// add_to_bucket
// file dbhash.c line 803
static signed long int add_to_bucket(struct anonymous_34 *bucket, signed long int key, signed long int value);
// alloc_db_segmentchunk
// file dballoc.c line 305
static signed long int alloc_db_segmentchunk(void *db, signed long int size);
// alloc_lock
// file dblock.c line 1379
static signed long int alloc_lock(void *db);
// append_resultset
// file dbquery.c line 1388
static signed long int append_resultset(void *db, struct anonymous_17 *set, signed long int offset);
// array_begin_cb
// file dbjson.c line 597
static signed int array_begin_cb(void *cb_ctx);
// array_end_cb
// file dbjson.c line 608
static signed int array_end_cb(void *cb_ctx);
// atol
// file /usr/include/stdlib.h line 150
extern signed long int atol(const char *);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_and_merge_by_key
// file dbquery.c line 1684
static signed long int check_and_merge_by_key(void *db, void *rec, struct anonymous_18 *arg, struct anonymous_17 *next_set);
// check_and_merge_by_kv
// file dbquery.c line 1645
static signed long int check_and_merge_by_kv(void *db, void *rec, struct anonymous_18 *arg, struct anonymous_17 *next_set);
// check_and_merge_recursively
// file dbquery.c line 1718
static signed long int check_and_merge_recursively(void *db, void *rec, struct anonymous_18 *arg, struct anonymous_17 *next_set, signed int depth);
// check_arglist
// file dbquery.c line 285
static signed long int check_arglist(void *db, void *rec, struct anonymous_12 *arglist, signed long int argc);
// check_data
// file stresstest.c line 201
void check_data(void *db, signed int wcnt);
// check_pop_cb
// file dbjson.c line 434
static signed int check_pop_cb(void *cb_ctx);
// check_push_cb
// file dbjson.c line 424
static signed int check_push_cb(void *cb_ctx);
// create_hash_index
// file dbindex.c line 1608
static signed long int create_hash_index(void *db, signed long int index_id);
// create_resultset
// file dbquery.c line 1341
static struct anonymous_17 * create_resultset(void *db);
// create_shared_memory
// file dbmem.c line 723
static void * create_shared_memory(signed int key, signed long int size, signed int mode);
// create_ttree_index
// file dbindex.c line 1370
static signed long int create_ttree_index(void *db, signed long int index_id);
// csv_escaped_str
// file dbutil.c line 310
static void csv_escaped_str(void *db, char *iptr, char *buf, signed int buflen);
// db_rotate_ttree
// file dbindex.c line 208
static signed int db_rotate_ttree(void *db, signed long int index_id, struct wg_tnode *root, signed int overw);
// db_tfqueue_rlock
// file dblock.h line 137
signed long int db_tfqueue_rlock(void *db, signed long int timeout);
// db_tfqueue_rulock
// file dblock.h line 143
signed long int db_tfqueue_rulock(void *db, signed long int lock);
// db_tfqueue_wlock
// file dblock.c line 984
signed long int db_tfqueue_wlock(void *db, signed long int timeout);
// db_tfqueue_wulock
// file dblock.c line 1053
signed long int db_tfqueue_wulock(void *db, signed long int lock);
// db_which_branch_causes_overweight
// file dbindex.c line 195
static signed int db_which_branch_causes_overweight(void *db, struct wg_tnode *root);
// delete_from_list
// file dbindex.c line 1736
static void delete_from_list(void *db, signed long int *head);
// delete_record_recursive
// file dbschema.c line 233
static signed long int delete_record_recursive(void *db, void *rec, signed int depth);
// detach_shared_memory
// file dbmem.c line 849
static signed int detach_shared_memory(void *shmptr);
// dhash_lookup
// file dbhash.c line 878
static signed long int * dhash_lookup(struct anonymous_36 *tbl, signed long int key);
// dhash_size
// file dbhash.c line 844
static unsigned long int dhash_size(unsigned long int entries);
// drop_hash_index
// file dbindex.c line 1677
static signed long int drop_hash_index(void *db, signed long int index_id);
// drop_ttree_index
// file dbindex.c line 1432
static signed long int drop_ttree_index(void *db, signed long int index_id);
// elem_double_cb
// file dbjson.c line 656
static signed int elem_double_cb(void *cb_ctx, double doubleval);
// elem_integer_cb
// file dbjson.c line 641
static signed int elem_integer_cb(void *cb_ctx, signed long long int intval);
// elem_string_cb
// file dbjson.c line 692
static signed int elem_string_cb(void *cb_ctx, const unsigned char *strval, unsigned long int strl);
// encode_query_param_unistr
// file dbquery.c line 1217
static signed long int encode_query_param_unistr(void *db, char *data, signed long int type, char *extdata, signed int length);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// extend_fixedlen_area
// file dballoc.c line 751
static signed long int extend_fixedlen_area(void *db, void *area_header);
// extend_mpool
// file dbmpool.c line 156
static signed int extend_mpool(void *db, void *mpool, signed int minbytes);
// extend_varlen_area
// file dballoc.c line 1003
static signed long int extend_varlen_area(void *db, void *area_header, signed long int minbytes);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fetch_resultset
// file dbquery.c line 1419
static signed long int fetch_resultset(void *db, struct anonymous_17 *set);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// find_create_longstr
// file dbdata.c line 2579
static signed long int find_create_longstr(void *db, char *data, char *extrastr, signed long int type, signed long int length);
// find_document_recursive
// file dbschema.c line 186
static void * find_document_recursive(void *db, signed long int *rec, signed int depth);
// find_idxhash_bucket
// file dbhash.c line 407
static signed long int find_idxhash_bucket(void *db, char *data, signed long int length, signed long int *chainoffset);
// find_index_template
// file dbindex.c line 1858
static signed long int find_index_template(void *db, signed long int *matchrec, signed long int reclen);
// find_ttree_bounds
// file dbquery.c line 445
static signed long int find_ttree_bounds(void *db, signed long int index_id, signed long int col, signed long int start_bound, signed long int end_bound, signed long int start_inclusive, signed long int end_inclusive, signed long int *curr_offset, signed long int *curr_slot, signed long int *end_offset, signed long int *end_slot);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// fread_csv
// file dbutil.c line 702
static signed long int fread_csv(void *db, struct _IO_FILE *f);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_dbhandle
// file dbmem.c line 450
static void free_dbhandle(void *dbhandle);
// free_field_encoffset
// file dbdata.c line 1221
static signed long int free_field_encoffset(void *db, signed long int encoffset);
// free_lock
// file dblock.c line 1392
static void free_lock(void *db, signed long int node);
// free_resultset
// file dbquery.c line 1368
static void free_resultset(void *db, struct anonymous_17 *set);
// free_shared_memory
// file dbmem.c line 801
static signed int free_shared_memory(signed int key);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftime
// file /usr/include/x86_64-linux-gnu/sys/timeb.h line 41
extern signed int ftime(struct timeb *);
// futex_trywait
// file dblock.c line 1411
static signed int futex_trywait(volatile signed long int *addr1, signed int val1, struct timespec *timeout);
// futex_wake
// file dblock.c line 1420
static void futex_wake(volatile signed long int *addr1, signed int val1);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// getgid
// file /usr/include/unistd.h line 681
extern unsigned int getgid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// ginthash_newbucket
// file dbhash.c line 721
static struct anonymous_34 * ginthash_newbucket(void *db, struct anonymous_35 *tbl);
// ginthash_splitbucket
// file dbhash.c line 735
static struct anonymous_34 * ginthash_splitbucket(void *db, struct anonymous_35 *tbl, struct anonymous_34 *bucket);
// grow_ginthash
// file dbhash.c line 685
static signed long int grow_ginthash(void *db, struct anonymous_35 *tbl);
// hash_add_row
// file dbindex.c line 1473
static signed long int hash_add_row(void *db, signed long int index_id, void *rec);
// hash_bytes
// file dbhash.c line 389
static unsigned long int hash_bytes(void *db, char *data, signed long int length, signed long int hashsz);
// hash_extend_prefix
// file dbindex.c line 1565
static signed long int hash_extend_prefix(void *db, struct anonymous_21 *hdr, char *prefix, signed long int prefixlen, signed long int nextval, signed long int *values, signed long int count, void *rec, signed long int op, signed long int expand);
// hash_recurse
// file dbindex.c line 1514
static signed long int hash_recurse(void *db, struct anonymous_21 *hdr, char *prefix, signed long int prefixlen, signed long int *values, signed long int count, void *rec, signed long int op, signed long int expand);
// hash_remove_row
// file dbindex.c line 1490
static signed long int hash_remove_row(void *db, signed long int index_id, void *rec);
// hexToDigit
// file yajl_all.c line 400
static void hexToDigit(unsigned int *val, const unsigned char *hex);
// init_area_buckets
// file dballoc.c line 608
static signed long int init_area_buckets(void *db, void *area_header);
// init_db_index_area_header
// file dballoc.c line 386
static signed long int init_db_index_area_header(void *db);
// init_db_recptr_bitmap
// file dballoc.c line 456
static signed long int init_db_recptr_bitmap(void *db);
// init_db_subarea
// file dballoc.c line 269
static signed long int init_db_subarea(void *db, void *area_header, signed long int index, signed long int size);
// init_dbhandle
// file dbmem.c line 433
static void * init_dbhandle(void);
// init_extdb
// file dballoc.c line 369
static signed long int init_extdb(void *db);
// init_hash_subarea
// file dballoc.c line 430
static signed long int init_hash_subarea(void *db, struct _db_hash_area_header *areah, signed long int arraylength);
// init_logging
// file dballoc.c line 403
static signed long int init_logging(void *db);
// init_strhash_area
// file dballoc.c line 415
static signed long int init_strhash_area(void *db, struct _db_hash_area_header *areah);
// init_subarea_freespace
// file dballoc.c line 632
static signed long int init_subarea_freespace(void *db, void *area_header, signed long int arrayindex);
// init_syn_vars
// file dballoc.c line 338
static signed long int init_syn_vars(void *db);
// insert_into_list
// file dbindex.c line 1718
static signed long int insert_into_list(void *db, signed long int *head, signed long int value);
// internal_build_query
// file dbquery.c line 668
static struct anonymous_15 * internal_build_query(void *db, void *matchrec, signed long int reclen, struct anonymous_12 *arglist, signed long int argc, signed long int flags, unsigned long int rowlimit);
// intersect_resultset
// file dbquery.c line 1449
static struct anonymous_17 * intersect_resultset(void *db, struct anonymous_17 *seta, struct anonymous_17 *setb);
// isleap
// file dbdata.c line 2890
static signed int isleap(unsigned int yr);
// link_shared_memory
// file dbmem.c line 665
static void * link_shared_memory(signed int key, signed int *errcode);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// lock_queue
// file dblock.c line 926
static void lock_queue(void *db);
// make_subarea_freelist
// file dballoc.c line 569
static signed long int make_subarea_freelist(void *db, void *area_header, signed long int arrayindex);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memory_stats
// file dbmem.c line 583
static signed int memory_stats(void *db, struct shmid_ds *buf);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// months_to_days
// file dbdata.c line 2894
static unsigned int months_to_days(unsigned int month);
// most_restricting_column
// file dbquery.c line 137
static signed long int most_restricting_column(void *db, struct anonymous_12 *arglist, signed long int argc, signed long int *index_id);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// normalize_perms
// file dbmem.c line 177
static signed int normalize_perms(signed int mode);
// object_begin_cb
// file dbjson.c line 619
static signed int object_begin_cb(void *cb_ctx);
// object_end_cb
// file dbjson.c line 630
static signed int object_end_cb(void *cb_ctx);
// object_key_cb
// file dbjson.c line 671
static signed int object_key_cb(void *cb_ctx, const unsigned char *strval, unsigned long int strl);
// parse_input_type
// file dbutil.c line 568
static signed long int parse_input_type(void *db, char *buf, signed long int *intdata, double *doubledata, signed long int *datetime);
// pop
// file dbjson.c line 462
static signed int pop(struct anonymous_0 *ctx);
// prepare_data
// file stresstest.c line 178
signed int prepare_data(void *db);
// prepare_json_arglist
// file dbquery.c line 1755
static signed long int prepare_json_arglist(void *db, struct anonymous_18 *arglist, struct anonymous_18 **sorted_arglist, signed long int argc, signed long int *index_id, signed long int *vindex_id, signed long int *kindex_id);
// prepare_params
// file dbquery.c line 350
static signed long int prepare_params(void *db, void *matchrec, signed long int reclen, struct anonymous_12 *arglist, signed long int argc, struct anonymous_12 **farglist, signed long int *fargc);
// pretty_print_json
// file dbjson.c line 756
static signed int pretty_print_json(void *db, struct yajl_gen_t **g, void *rec);
// pretty_print_jsonval
// file dbjson.c line 830
static signed int pretty_print_jsonval(void *db, struct yajl_gen_t **g, signed long int enc);
// print_cb
// file dbjson.c line 718
static void print_cb(void *cb_ctx, const char *str, unsigned long int len);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_14 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_14 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_14 *, const union anonymous_11 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_14 *, union anonymous_10 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_10 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_10 *, const union anonymous_11 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_10 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_10 *);
// push
// file dbjson.c line 444
static signed int push(struct anonymous_0 *ctx, enum anonymous_2 type);
// reader_thread
// file stresstest.c line 474
void * reader_thread(void *threadarg);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// rehash_gint
// file dbhash.c line 671
static signed long int rehash_gint(signed long int val);
// remove_backlink_index_entries
// file dbdata.c line 471
static signed long int remove_backlink_index_entries(void *db, signed long int *record, signed long int value, signed long int depth);
// remove_from_bucket
// file dbhash.c line 820
static signed long int remove_from_bucket(struct anonymous_34 *bucket, signed int idx);
// remove_index_template
// file dbindex.c line 1924
static signed long int remove_index_template(void *db, signed long int template_offset);
// restore_backlink_index_entries
// file dbdata.c line 529
static signed long int restore_backlink_index_entries(void *db, signed long int *record, signed long int value, signed long int depth);
// rewind_resultset
// file dbquery.c line 1378
static void rewind_resultset(void *db, struct anonymous_17 *set);
// round
// file dbdata.h line 44
extern double round(double);
// run_json_parser
// file dbjson.c line 385
static signed long int run_json_parser(void *db, char *buf, struct anonymous *cb, signed int isparam, signed int isdocument, void **document);
// run_workers
// file stresstest.c line 222
void run_workers(void *db, signed int rcnt, signed int wcnt);
// scalar_to_ymd
// file dbdata.c line 2912
static void scalar_to_ymd(signed long int scalar, unsigned int *yr, unsigned int *mo, unsigned int *day);
// shmat
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 56
extern void * shmat(signed int, const void *, signed int);
// shmctl
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 50
extern signed int shmctl(signed int, signed int, struct shmid_ds *);
// shmdt
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 60
extern signed int shmdt(const void *);
// shmget
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 53
extern signed int shmget(signed int, unsigned long int, signed int);
// show_consistency_error_nr
// file dbhash.c line 965
static signed long int show_consistency_error_nr(void *db, char *errmsg, signed long int nr);
// show_data_error
// file dbdata.c line 3165
static signed long int show_data_error(void *db, char *errmsg);
// show_data_error_double
// file dbdata.c line 3183
static signed long int show_data_error_double(void *db, char *errmsg, double nr);
// show_data_error_nr
// file dbdata.c line 3174
static signed long int show_data_error_nr(void *db, char *errmsg, signed long int nr);
// show_data_error_str
// file dbdata.c line 3192
static signed long int show_data_error_str(void *db, char *errmsg, char *str);
// show_dballoc_error
// file dballoc.c line 1427
static signed long int show_dballoc_error(void *db, char *errmsg);
// show_dballoc_error_nr
// file dballoc.c line 1441
static signed long int show_dballoc_error_nr(void *db, char *errmsg, signed long int nr);
// show_dump_error
// file dbdump.c line 360
static signed long int show_dump_error(void *db, char *errmsg);
// show_dump_error_str
// file dbdump.c line 369
static signed long int show_dump_error_str(void *db, char *errmsg, char *str);
// show_ginthash_error
// file dbhash.c line 999
static signed long int show_ginthash_error(void *db, char *errmsg);
// show_hash_error
// file dbhash.c line 991
static signed long int show_hash_error(void *db, char *errmsg);
// show_index_error
// file dbindex.c line 2992
static signed long int show_index_error(void *db, char *errmsg);
// show_index_error_nr
// file dbindex.c line 3006
static signed long int show_index_error_nr(void *db, char *errmsg, signed long int nr);
// show_io_error
// file dbutil.c line 1269
static signed long int show_io_error(void *db, char *errmsg);
// show_io_error_str
// file dbutil.c line 1277
static signed long int show_io_error_str(void *db, char *errmsg, char *str);
// show_json_error
// file dbjson.c line 869
static signed long int show_json_error(void *db, char *errmsg);
// show_json_error_byte
// file dbjson.c line 885
static signed long int show_json_error_byte(void *db, char *errmsg, signed int byte);
// show_json_error_fn
// file dbjson.c line 877
static signed long int show_json_error_fn(void *db, char *errmsg, char *filename);
// show_lock_error
// file dblock.c line 1431
static signed long int show_lock_error(void *db, char *errmsg);
// show_log_error
// file dblog.c line 1179
static signed long int show_log_error(void *db, char *errmsg);
// show_memory_error
// file dbmem.c line 873
static signed long int show_memory_error(char *errmsg);
// show_mpool_error
// file dbmpool.c line 490
static signed int show_mpool_error(void *db, char *errmsg);
// show_mpool_error_nr
// file dbmpool.c line 504
static signed int show_mpool_error_nr(void *db, char *errmsg, signed int nr);
// show_query_error
// file dbquery.c line 2279
static signed long int show_query_error(void *db, char *errmsg);
// show_schema_error
// file dbschema.c line 259
static signed long int show_schema_error(void *db, char *errmsg);
// snprint_record
// file dbutil.c line 166
static void snprint_record(void *db, signed long int *rec, char *buf, signed int buflen);
// snprint_value_csv
// file dbutil.c line 342
static void snprint_value_csv(void *db, signed long int enc, char *buf, signed int buflen);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sort_columns
// file dbindex.c line 2001
static signed long int sort_columns(signed long int *sorted_cols, signed long int *columns, signed long int col_count);
// split_free
// file dballoc.c line 1057
static signed long int split_free(void *db, void *area_header, signed long int nr, signed long int *freebuckets, signed long int i);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strnlen
// file /usr/include/string.h line 405
extern unsigned long int strnlen(const char *, unsigned long int);
// strspn
// file /usr/include/string.h line 288
extern unsigned long int strspn(const char *, const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// syscall
// file /usr/include/unistd.h line 1058
extern signed long int syscall(signed long int, ...);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// ttree_add_row
// file dbindex.c line 427
static signed long int ttree_add_row(void *db, signed long int index_id, void *rec);
// ttree_remove_row
// file dbindex.c line 762
static signed long int ttree_remove_row(void *db, signed long int index_id, void *rec);
// ungetc
// file /usr/include/stdio.h line 702
extern signed int ungetc(signed int, struct _IO_FILE *);
// unique_resultset
// file dbquery.c line 1528
static struct anonymous_17 * unique_resultset(void *db, struct anonymous_17 *set);
// unlock_queue
// file dblock.c line 970
static void unlock_queue(void *db);
// update_crc32
// file crc1.h line 83
static signed int update_crc32(char *buf, signed long int n, signed int crc);
// wg_add_int_atomic_field
// file dbdata.c line 1099
signed long int wg_add_int_atomic_field(void *db, void *record, signed long int fieldnr, signed int data);
// wg_alloc_fixlen_object
// file dballoc.c line 719
signed long int wg_alloc_fixlen_object(void *db, void *area_header);
// wg_alloc_gints
// file dballoc.c line 867
signed long int wg_alloc_gints(void *db, void *area_header, signed long int nr);
// wg_alloc_mpool
// file dbmpool.h line 46
void * wg_alloc_mpool(void *db, void *mpool, signed int bytes);
// wg_atomstr1
// file dbmpool.c line 380
char * wg_atomstr1(void *db, void *ptr);
// wg_atomstr2
// file dbmpool.c line 386
char * wg_atomstr2(void *db, void *ptr);
// wg_atomtype
// file dbmpool.c line 374
signed int wg_atomtype(void *db, void *ptr);
// wg_attach_database
// file ../Db/dbmem.h line 52
void * wg_attach_database(char *dbasename, signed long int size);
// wg_attach_database_mode
// file dbmem.c line 155
void * wg_attach_database_mode(char *dbasename, signed long int size, signed int mode);
// wg_attach_existing_database
// file dbmem.c line 132
void * wg_attach_existing_database(char *dbasename);
// wg_attach_local_database
// file dbmem.c line 376
void * wg_attach_local_database(signed long int size);
// wg_attach_logged_database
// file dbmem.c line 143
void * wg_attach_logged_database(char *dbasename, signed long int size);
// wg_attach_logged_database_mode
// file dbmem.c line 167
void * wg_attach_logged_database_mode(char *dbasename, signed long int size, signed int mode);
// wg_attach_memsegment
// file dbmem.c line 196
void * wg_attach_memsegment(char *dbasename, signed long int minsize, signed long int size, signed int create, signed int logging, signed int mode);
// wg_check_dump
// file dbdump.c line 199
signed long int wg_check_dump(void *db, char *fileName, signed long int *minsize, signed long int *maxsize);
// wg_check_header_compat
// file dbmem.h line 62
signed int wg_check_header_compat(struct _db_memsegment_header *dbh);
// wg_check_json
// file dbjson.c line 278
signed long int wg_check_json(void *db, char *buf);
// wg_cleanup_handle_logdata
// file dblog.c line 722
void wg_cleanup_handle_logdata(void *db);
// wg_column_to_index_id
// file dbindex.c line 2377
signed long int wg_column_to_index_id(void *db, signed long int column, signed long int type, signed long int *matchrec, signed long int reclen);
// wg_compare
// file dbcompare.c line 52
signed long int wg_compare(void *db, signed long int a, signed long int b, signed int depth);
// wg_compare_and_swap
// file dblock.h line 80
signed long int wg_compare_and_swap(volatile signed long int *ptr, signed long int oldv, signed long int newv);
// wg_create_array
// file dbschema.h line 46
void * wg_create_array(void *db, signed long int size, signed long int isdocument, signed long int isparam);
// wg_create_hash
// file dballoc.c line 1388
signed long int wg_create_hash(void *db, struct _db_hash_area_header *areah, signed long int size);
// wg_create_index
// file dbindex.c line 2024
signed long int wg_create_index(void *db, signed long int column, signed long int type, signed long int *matchrec, signed long int reclen);
// wg_create_mpool
// file dbmpool.h line 45
void * wg_create_mpool(void *db, signed int origbytes);
// wg_create_multi_index
// file dbindex.c line 2047
signed long int wg_create_multi_index(void *db, signed long int *columns, signed long int col_count, signed long int type, signed long int *matchrec, signed long int reclen);
// wg_create_object
// file dbschema.h line 47
void * wg_create_object(void *db, signed long int size, signed long int isdocument, signed long int isparam);
// wg_create_raw_record
// file dbdata.c line 140
void * wg_create_raw_record(void *db, signed long int length);
// wg_create_record
// file ../Db/dbdata.h line 88
void * wg_create_record(void *db, signed long int length);
// wg_create_triple
// file dbschema.h line 43
void * wg_create_triple(void *db, signed long int subj, signed long int prop, signed long int ob, signed long int isparam);
// wg_current_localdate
// file dbdata.c line 1714
signed int wg_current_localdate(void *db);
// wg_current_localtime
// file dbdata.c line 1742
signed int wg_current_localtime(void *db);
// wg_current_utcdate
// file dbdata.c line 1706
signed int wg_current_utcdate(void *db);
// wg_current_utctime
// file dbdata.c line 1726
signed int wg_current_utctime(void *db);
// wg_database_freesize
// file dballoc.c line 1404
signed long int wg_database_freesize(void *db);
// wg_database_size
// file dballoc.c line 1413
signed long int wg_database_size(void *db);
// wg_date_to_ymd
// file dbdata.c line 1815
void wg_date_to_ymd(void *db, signed int date, signed int *yr, signed int *mo, signed int *day);
// wg_decode_anonconst
// file dbdata.c line 2410
char * wg_decode_anonconst(void *db, signed long int data);
// wg_decode_blob
// file dbdata.h line 231
char * wg_decode_blob(void *db, signed long int data);
// wg_decode_blob_copy
// file dbdata.c line 2313
signed long int wg_decode_blob_copy(void *db, signed long int data, char *strbuf, signed long int buflen);
// wg_decode_blob_len
// file dbdata.h line 234
signed long int wg_decode_blob_len(void *db, signed long int data);
// wg_decode_blob_type
// file dbdata.c line 2336
char * wg_decode_blob_type(void *db, signed long int data);
// wg_decode_blob_type_copy
// file dbdata.c line 2367
signed long int wg_decode_blob_type_copy(void *db, signed long int data, char *langbuf, signed long int buflen);
// wg_decode_blob_type_len
// file dbdata.c line 2351
signed long int wg_decode_blob_type_len(void *db, signed long int data);
// wg_decode_char
// file dbdata.h line 144
char wg_decode_char(void *db, signed long int data);
// wg_decode_date
// file dbdata.h line 160
signed int wg_decode_date(void *db, signed long int data);
// wg_decode_double
// file dbdata.h line 150
double wg_decode_double(void *db, signed long int data);
// wg_decode_fixpoint
// file dbdata.h line 155
double wg_decode_fixpoint(void *db, signed long int data);
// wg_decode_for_hashing
// file dbhash.c line 292
signed long int wg_decode_for_hashing(void *db, signed long int enc, char **decbytes);
// wg_decode_int
// file ../Db/dbdata.h line 139
signed long int wg_decode_int(void *db, signed long int data);
// wg_decode_null
// file dbdata.c line 1443
char * wg_decode_null(void *db, signed long int data);
// wg_decode_record
// file dbdata.h line 182
void * wg_decode_record(void *db, signed long int data);
// wg_decode_str
// file dbdata.h line 189
char * wg_decode_str(void *db, signed long int data);
// wg_decode_str_copy
// file dbdata.c line 1929
signed long int wg_decode_str_copy(void *db, signed long int data, char *strbuf, signed long int buflen);
// wg_decode_str_lang
// file dbdata.c line 1952
char * wg_decode_str_lang(void *db, signed long int data);
// wg_decode_str_lang_copy
// file dbdata.c line 1983
signed long int wg_decode_str_lang_copy(void *db, signed long int data, char *langbuf, signed long int buflen);
// wg_decode_str_lang_len
// file dbdata.c line 1967
signed long int wg_decode_str_lang_len(void *db, signed long int data);
// wg_decode_str_len
// file dbdata.c line 1913
signed long int wg_decode_str_len(void *db, signed long int data);
// wg_decode_time
// file dbdata.h line 163
signed int wg_decode_time(void *db, signed long int data);
// wg_decode_unistr
// file dbdata.c line 2670
char * wg_decode_unistr(void *db, signed long int data, signed long int type);
// wg_decode_unistr_copy
// file dbdata.c line 2770
signed long int wg_decode_unistr_copy(void *db, signed long int data, char *strbuf, signed long int buflen, signed long int type);
// wg_decode_unistr_lang
// file dbdata.c line 2697
char * wg_decode_unistr_lang(void *db, signed long int data, signed long int type);
// wg_decode_unistr_lang_copy
// file dbdata.c line 2860
signed long int wg_decode_unistr_lang_copy(void *db, signed long int data, char *strbuf, signed long int buflen, signed long int type);
// wg_decode_unistr_lang_len
// file dbdata.c line 2839
signed long int wg_decode_unistr_lang_len(void *db, signed long int data, signed long int type);
// wg_decode_unistr_len
// file dbdata.c line 2729
signed long int wg_decode_unistr_len(void *db, signed long int data, signed long int type);
// wg_decode_uri
// file dbdata.h line 216
char * wg_decode_uri(void *db, signed long int data);
// wg_decode_uri_copy
// file dbdata.c line 2187
signed long int wg_decode_uri_copy(void *db, signed long int data, char *strbuf, signed long int buflen);
// wg_decode_uri_len
// file dbdata.c line 2171
signed long int wg_decode_uri_len(void *db, signed long int data);
// wg_decode_uri_prefix
// file dbdata.h line 217
char * wg_decode_uri_prefix(void *db, signed long int data);
// wg_decode_uri_prefix_copy
// file dbdata.c line 2241
signed long int wg_decode_uri_prefix_copy(void *db, signed long int data, char *langbuf, signed long int buflen);
// wg_decode_uri_prefix_len
// file dbdata.c line 2225
signed long int wg_decode_uri_prefix_len(void *db, signed long int data);
// wg_decode_var
// file dbdata.h line 247
signed long int wg_decode_var(void *db, signed long int data);
// wg_decode_xmlliteral
// file dbdata.h line 202
char * wg_decode_xmlliteral(void *db, signed long int data);
// wg_decode_xmlliteral_copy
// file dbdata.c line 2060
signed long int wg_decode_xmlliteral_copy(void *db, signed long int data, char *strbuf, signed long int buflen);
// wg_decode_xmlliteral_len
// file dbdata.c line 2044
signed long int wg_decode_xmlliteral_len(void *db, signed long int data);
// wg_decode_xmlliteral_xsdtype
// file dbdata.h line 203
char * wg_decode_xmlliteral_xsdtype(void *db, signed long int data);
// wg_decode_xmlliteral_xsdtype_copy
// file dbdata.c line 2114
signed long int wg_decode_xmlliteral_xsdtype_copy(void *db, signed long int data, char *langbuf, signed long int buflen);
// wg_decode_xmlliteral_xsdtype_len
// file dbdata.c line 2098
signed long int wg_decode_xmlliteral_xsdtype_len(void *db, signed long int data);
// wg_delete_database
// file ../Db/dbmem.h line 61
signed int wg_delete_database(char *dbasename);
// wg_delete_document
// file dbschema.c line 216
signed long int wg_delete_document(void *db, void *document);
// wg_delete_local_database
// file dbmem.c line 417
void wg_delete_local_database(void *dbase);
// wg_delete_record
// file dbdata.c line 203
signed long int wg_delete_record(void *db, void *rec);
// wg_detach_database
// file dbmem.c line 344
signed int wg_detach_database(void *dbase);
// wg_dhash_addkey
// file dbhash.c line 932
signed long int wg_dhash_addkey(void *db, void *tbl, signed long int key);
// wg_dhash_free
// file dbhash.c line 919
void wg_dhash_free(void *db, void *tbl);
// wg_dhash_haskey
// file dbhash.c line 947
signed long int wg_dhash_haskey(void *db, void *tbl, signed long int key);
// wg_dhash_init
// file dbhash.c line 903
void * wg_dhash_init(void *db, unsigned long int entries);
// wg_drop_index
// file dbindex.c line 2273
signed long int wg_drop_index(void *db, signed long int index_id);
// wg_dump
// file dbdump.c line 76
signed long int wg_dump(void *db, char *fileName);
// wg_dump_internal
// file dbdump.c line 84
signed long int wg_dump_internal(void *db, char *fileName, signed int locking);
// wg_encode_anonconst
// file dbdata.c line 2393
signed long int wg_encode_anonconst(void *db, char *str);
// wg_encode_blob
// file dbdata.c line 2267
signed long int wg_encode_blob(void *db, char *str, char *type, signed long int len);
// wg_encode_char
// file dbdata.c line 1513
signed long int wg_encode_char(void *db, char data);
// wg_encode_date
// file dbdata.c line 1634
signed long int wg_encode_date(void *db, signed int data);
// wg_encode_double
// file dbdata.c line 1543
signed long int wg_encode_double(void *db, double data);
// wg_encode_external_data
// file dbdata.c line 2954
signed long int wg_encode_external_data(void *db, void *extdb, signed long int encoded);
// wg_encode_fixpoint
// file dbdata.c line 1597
signed long int wg_encode_fixpoint(void *db, double data);
// wg_encode_int
// file dbdata.c line 1457
signed long int wg_encode_int(void *db, signed long int data);
// wg_encode_null
// file dbdata.c line 1421
signed long int wg_encode_null(void *db, char *data);
// wg_encode_query_param_char
// file dbquery.c line 1130
signed long int wg_encode_query_param_char(void *db, char data);
// wg_encode_query_param_date
// file dbquery.c line 1138
signed long int wg_encode_query_param_date(void *db, signed int data);
// wg_encode_query_param_double
// file dbquery.c line 1171
signed long int wg_encode_query_param_double(void *db, double data);
// wg_encode_query_param_fixpoint
// file dbquery.c line 1134
signed long int wg_encode_query_param_fixpoint(void *db, double data);
// wg_encode_query_param_int
// file dbquery.c line 1155
signed long int wg_encode_query_param_int(void *db, signed long int data);
// wg_encode_query_param_null
// file dbquery.c line 1122
signed long int wg_encode_query_param_null(void *db, char *data);
// wg_encode_query_param_record
// file dbquery.c line 1126
signed long int wg_encode_query_param_record(void *db, void *data);
// wg_encode_query_param_str
// file dbquery.c line 1183
signed long int wg_encode_query_param_str(void *db, char *data, char *lang);
// wg_encode_query_param_time
// file dbquery.c line 1142
signed long int wg_encode_query_param_time(void *db, signed int data);
// wg_encode_query_param_uri
// file dbquery.c line 1202
signed long int wg_encode_query_param_uri(void *db, char *data, char *prefix);
// wg_encode_query_param_var
// file dbquery.c line 1146
signed long int wg_encode_query_param_var(void *db, signed long int data);
// wg_encode_query_param_xmlliteral
// file dbquery.c line 1192
signed long int wg_encode_query_param_xmlliteral(void *db, char *data, char *xsdtype);
// wg_encode_record
// file dbdata.c line 1840
signed long int wg_encode_record(void *db, void *data);
// wg_encode_str
// file dbdata.c line 1882
signed long int wg_encode_str(void *db, char *str, char *lang);
// wg_encode_time
// file dbdata.c line 1670
signed long int wg_encode_time(void *db, signed int data);
// wg_encode_uniblob
// file dbdata.c line 2564
signed long int wg_encode_uniblob(void *db, char *str, char *lang, signed long int type, signed long int len);
// wg_encode_unistr
// file dbdata.c line 2476
signed long int wg_encode_unistr(void *db, char *str, char *lang, signed long int type);
// wg_encode_uri
// file dbdata.c line 2140
signed long int wg_encode_uri(void *db, char *str, char *prefix);
// wg_encode_var
// file dbdata.c line 2429
signed long int wg_encode_var(void *db, signed long int varnr);
// wg_encode_xmlliteral
// file dbdata.c line 2009
signed long int wg_encode_xmlliteral(void *db, char *str, char *xsdtype);
// wg_end_read
// file ../Db/dblock.h line 76
signed long int wg_end_read(void *db, signed long int lock);
// wg_end_write
// file ../Db/dblock.h line 74
signed long int wg_end_write(void *db, signed long int lock);
// wg_export_db_csv
// file dbutil.c line 673
void wg_export_db_csv(void *db, char *filename);
// wg_fetch
// file dbquery.c line 976
void * wg_fetch(void *db, struct anonymous_15 *query);
// wg_find_document
// file dbschema.h line 48
void * wg_find_document(void *db, void *rec);
// wg_find_record
// file dbquery.c line 2035
void * wg_find_record(void *db, signed long int fieldnr, signed long int cond, signed long int data, void *lastrecord);
// wg_find_record_char
// file dbquery.c line 2169
void * wg_find_record_char(void *db, signed long int fieldnr, signed long int cond, char data, void *lastrecord);
// wg_find_record_date
// file dbquery.c line 2189
void * wg_find_record_date(void *db, signed long int fieldnr, signed long int cond, signed int data, void *lastrecord);
// wg_find_record_double
// file dbquery.c line 2230
void * wg_find_record_double(void *db, signed long int fieldnr, signed long int cond, double data, void *lastrecord);
// wg_find_record_fixpoint
// file dbquery.c line 2179
void * wg_find_record_fixpoint(void *db, signed long int fieldnr, signed long int cond, double data, void *lastrecord);
// wg_find_record_int
// file dbquery.c line 2219
void * wg_find_record_int(void *db, signed long int fieldnr, signed long int cond, signed int data, void *lastrecord);
// wg_find_record_null
// file dbquery.c line 2149
void * wg_find_record_null(void *db, signed long int fieldnr, signed long int cond, char *data, void *lastrecord);
// wg_find_record_record
// file dbquery.c line 2159
void * wg_find_record_record(void *db, signed long int fieldnr, signed long int cond, void *data, void *lastrecord);
// wg_find_record_str
// file dbquery.c line 2241
void * wg_find_record_str(void *db, signed long int fieldnr, signed long int cond, char *data, void *lastrecord);
// wg_find_record_time
// file dbquery.c line 2199
void * wg_find_record_time(void *db, signed long int fieldnr, signed long int cond, signed int data, void *lastrecord);
// wg_find_record_uri
// file dbquery.c line 2263
void * wg_find_record_uri(void *db, signed long int fieldnr, signed long int cond, char *data, char *prefix, void *lastrecord);
// wg_find_record_var
// file dbquery.c line 2209
void * wg_find_record_var(void *db, signed long int fieldnr, signed long int cond, signed long int data, void *lastrecord);
// wg_find_record_xmlliteral
// file dbquery.c line 2252
void * wg_find_record_xmlliteral(void *db, signed long int fieldnr, signed long int cond, char *data, char *xsdtype, void *lastrecord);
// wg_find_strhash_bucket
// file dbhash.h line 51
signed long int wg_find_strhash_bucket(void *db, char *data, char *extrastr, signed long int type, signed long int size, signed long int hashchain);
// wg_first
// file dbmpool.c line 318
void * wg_first(void *db, void *ptr);
// wg_fprint_record_csv
// file dbutil.c line 641
void wg_fprint_record_csv(void *db, signed long int *rec, struct _IO_FILE *f);
// wg_free_doubleword
// file dballoc.c line 830
void wg_free_doubleword(void *db, signed long int offset);
// wg_free_encoded
// file dbdata.c line 1178
signed long int wg_free_encoded(void *db, signed long int data);
// wg_free_fixlen_object
// file dballoc.c line 852
void wg_free_fixlen_object(void *db, struct _db_area_header *hdr, signed long int offset);
// wg_free_listcell
// file dballoc.c line 794
void wg_free_listcell(void *db, signed long int offset);
// wg_free_mpool
// file dbmpool.h line 48
void wg_free_mpool(void *db, void *mpool);
// wg_free_object
// file dballoc.c line 1158
signed long int wg_free_object(void *db, void *area_header, signed long int object);
// wg_free_query
// file dbquery.c line 1108
void wg_free_query(void *db, struct anonymous_15 *query);
// wg_free_query_param
// file dbquery.c line 1294
signed long int wg_free_query_param(void *db, signed long int data);
// wg_free_shortstr
// file dballoc.c line 806
void wg_free_shortstr(void *db, signed long int offset);
// wg_free_tnode
// file dballoc.c line 841
void wg_free_tnode(void *db, signed long int offset);
// wg_free_word
// file dballoc.c line 817
void wg_free_word(void *db, signed long int offset);
// wg_freebuckets_index
// file dballoc.c line 1138
signed long int wg_freebuckets_index(void *db, signed long int size);
// wg_get_all_indexes
// file dbindex.c line 2577
void * wg_get_all_indexes(void *db, signed long int *count);
// wg_get_encoded_type
// file dbdata.h line 124
signed long int wg_get_encoded_type(void *db, signed long int data);
// wg_get_field
// file ../Db/dbdata.h line 118
signed long int wg_get_field(void *db, void *record, signed long int fieldnr);
// wg_get_field_type
// file ../Db/dbdata.h line 119
signed long int wg_get_field_type(void *db, void *record, signed long int fieldnr);
// wg_get_first_parent
// file dbdata.c line 414
void * wg_get_first_parent(void *db, void *record);
// wg_get_first_raw_record
// file dbdata.c line 314
void * wg_get_first_raw_record(void *db);
// wg_get_first_record
// file ../Db/dbdata.h line 92
void * wg_get_first_record(void *db);
// wg_get_index_template
// file dbindex.c line 2524
void * wg_get_index_template(void *db, signed long int index_id, signed long int *reclen);
// wg_get_index_type
// file dbindex.c line 2490
signed long int wg_get_index_type(void *db, signed long int index_id);
// wg_get_next_parent
// file dbdata.c line 435
void * wg_get_next_parent(void *db, void *record, void *parent);
// wg_get_next_raw_record
// file dbdata.c line 335
void * wg_get_next_raw_record(void *db, void *record);
// wg_get_next_record
// file ../Db/dbdata.h line 93
void * wg_get_next_record(void *db, void *record);
// wg_get_rec_owner
// file dbdata.c line 3068
void * wg_get_rec_owner(void *db, void *rec);
// wg_get_record_dataarray
// file dbdata.c line 590
signed long int * wg_get_record_dataarray(void *db, void *record);
// wg_get_record_len
// file ../Db/dbdata.h line 103
signed long int wg_get_record_len(void *db, void *record);
// wg_get_type_name
// file dbdata.c line 1400
char * wg_get_type_name(void *db, signed long int type);
// wg_ginthash_addkey
// file dbhash.c line 600
signed long int wg_ginthash_addkey(void *db, void *tbl, signed long int key, signed long int val);
// wg_ginthash_free
// file dbhash.c line 655
void wg_ginthash_free(void *db, void *tbl);
// wg_ginthash_getkey
// file dbhash.c line 636
signed long int wg_ginthash_getkey(void *db, void *tbl, signed long int key, signed long int *val);
// wg_ginthash_init
// file dbhash.c line 580
void * wg_ginthash_init(void *db);
// wg_hash_typedstr
// file dbhash.h line 50
signed int wg_hash_typedstr(void *db, char *data, char *extrastr, signed long int type, signed long int length);
// wg_hms_to_time
// file dbdata.c line 1808
signed int wg_hms_to_time(void *db, signed int hr, signed int min, signed int sec, signed int prt);
// wg_idxhash_find
// file dbhash.c line 548
signed long int wg_idxhash_find(void *db, struct _db_hash_area_header *ha, char *data, signed long int length);
// wg_idxhash_remove
// file dbhash.c line 501
signed long int wg_idxhash_remove(void *db, struct _db_hash_area_header *ha, char *data, signed long int length, signed long int offset);
// wg_idxhash_store
// file dbhash.c line 433
signed long int wg_idxhash_store(void *db, struct _db_hash_area_header *ha, char *data, signed long int length, signed long int offset);
// wg_import_db_csv
// file dbutil.c line 901
signed long int wg_import_db_csv(void *db, char *filename);
// wg_import_dump
// file dbdump.c line 278
signed long int wg_import_dump(void *db, char *fileName);
// wg_index_add_field
// file dbindex.h line 145
signed long int wg_index_add_field(void *db, void *rec, signed long int column);
// wg_index_add_rec
// file dbindex.h line 146
signed long int wg_index_add_rec(void *db, void *rec);
// wg_index_del_field
// file dbindex.h line 147
signed long int wg_index_del_field(void *db, void *rec, signed long int column);
// wg_index_del_rec
// file dbindex.h line 148
signed long int wg_index_del_rec(void *db, void *rec);
// wg_init_db_memsegment
// file dballoc.c line 99
signed long int wg_init_db_memsegment(void *db, signed long int key, signed long int size);
// wg_init_handle_logdata
// file dblog.c line 705
signed long int wg_init_handle_logdata(void *db);
// wg_init_locks
// file dblock.h line 81
signed long int wg_init_locks(void *db);
// wg_isatom
// file dbmpool.c line 336
signed int wg_isatom(void *db, void *ptr);
// wg_ispair
// file dbmpool.c line 301
signed int wg_ispair(void *db, void *ptr);
// wg_journal_filename
// file dblog.c line 687
void wg_journal_filename(void *db, char *buf, unsigned long int buflen);
// wg_listtreecount
// file dbmpool.c line 326
signed int wg_listtreecount(void *db, void *ptr);
// wg_log_create_record
// file dblog.c line 1012
signed long int wg_log_create_record(void *db, signed long int length);
// wg_log_delete_record
// file dblog.c line 1028
signed long int wg_log_delete_record(void *db, signed long int enc);
// wg_log_encode
// file dblog.c line 1062
signed long int wg_log_encode(void *db, signed long int type, void *data, signed long int length, void *extdata, signed long int extlength);
// wg_log_encval
// file dblog.c line 1046
signed long int wg_log_encval(void *db, signed long int enc);
// wg_log_set_field
// file dblog.c line 1143
signed long int wg_log_set_field(void *db, void *rec, signed long int col, signed long int data);
// wg_log_set_meta
// file dblog.c line 1162
signed long int wg_log_set_meta(void *db, void *rec, signed long int meta);
// wg_log_umask
// file dblog.c line 748
signed int wg_log_umask(void *db, signed int cmask);
// wg_make_json_query
// file dbquery.c line 1830
struct anonymous_15 * wg_make_json_query(void *db, struct anonymous_18 *arglist, signed long int argc);
// wg_make_query
// file dbquery.c line 953
struct anonymous_15 * wg_make_query(void *db, void *matchrec, signed long int reclen, struct anonymous_12 *arglist, signed long int argc);
// wg_make_query_rc
// file dbquery.c line 965
struct anonymous_15 * wg_make_query_rc(void *db, void *matchrec, signed long int reclen, struct anonymous_12 *arglist, signed long int argc, unsigned long int rowlimit);
// wg_match_template
// file dbindex.c line 1958
signed long int wg_match_template(void *db, struct anonymous_22 *tmpl, void *rec);
// wg_memgroup
// file dbmem.c line 646
signed int wg_memgroup(void *db);
// wg_memmode
// file dbmem.c line 610
signed int wg_memmode(void *db);
// wg_memowner
// file dbmem.c line 627
signed int wg_memowner(void *db);
// wg_mkatom
// file dbmpool.c line 341
void * wg_mkatom(void *db, void *mpool, signed int type, char *str1, char *str2);
// wg_mkpair
// file dbmpool.c line 305
void * wg_mkpair(void *db, void *mpool, void *x, void *y);
// wg_mpool_print
// file dbmpool.c line 396
void wg_mpool_print(void *db, void *ptr);
// wg_mpool_print_aux
// file dbmpool.c line 400
static void wg_mpool_print_aux(void *db, void *ptr, signed int depth, signed int pflag);
// wg_multi_column_to_index_id
// file dbindex.c line 2396
signed long int wg_multi_column_to_index_id(void *db, signed long int *columns, signed long int col_count, signed long int type, signed long int *matchrec, signed long int reclen);
// wg_parse_and_encode
// file dbutil.c line 469
signed long int wg_parse_and_encode(void *db, char *buf);
// wg_parse_and_encode_param
// file dbutil.c line 507
signed long int wg_parse_and_encode_param(void *db, char *buf);
// wg_parse_json_document
// file dbjson.c line 327
signed long int wg_parse_json_document(void *db, char *buf, void **document);
// wg_parse_json_file
// file dbjson.c line 181
signed long int wg_parse_json_file(void *db, char *filename);
// wg_parse_json_fragment
// file dbjson.c line 343
signed long int wg_parse_json_fragment(void *db, char *buf, void **document);
// wg_parse_json_param
// file dbjson.c line 361
signed long int wg_parse_json_param(void *db, char *buf, void **document);
// wg_pretty_print_memsize
// file dbutil.c line 1254
void wg_pretty_print_memsize(signed long int memsz, char *buf, unsigned long int buflen);
// wg_print_code_version
// file dbmem.h line 63
void wg_print_code_version(void);
// wg_print_db
// file dbutil.c line 116
void wg_print_db(void *db);
// wg_print_header_version
// file dbmem.h line 64
void wg_print_header_version(struct _db_memsegment_header *dbh, signed int verbose);
// wg_print_json_document
// file dbjson.c line 730
void wg_print_json_document(void *db, void *cb, void *cb_ctx, void *document);
// wg_print_record
// file dbutil.c line 130
void wg_print_record(void *db, signed long int *rec);
// wg_register_external_db
// file dballoc.c line 1353
signed long int wg_register_external_db(void *db, void *extdb);
// wg_remove_from_strhash
// file dbhash.h line 54
signed long int wg_remove_from_strhash(void *db, signed long int longstr);
// wg_replay_log
// file dblog.c line 870
signed long int wg_replay_log(void *db, char *filename);
// wg_rest
// file dbmpool.c line 322
void * wg_rest(void *db, void *ptr);
// wg_right_strhash_bucket
// file dbhash.c line 185
signed int wg_right_strhash_bucket(void *db, signed long int longstr, char *cstr, char *cextrastr, signed long int ctype, signed long int cstrsize);
// wg_search_hash
// file dbindex.c line 1692
signed long int wg_search_hash(void *db, signed long int index_id, signed long int *values, signed long int count);
// wg_search_tnode_first
// file dbindex.c line 1325
signed long int wg_search_tnode_first(void *db, signed long int nodeoffset, signed long int key, signed long int column);
// wg_search_tnode_last
// file dbindex.c line 1348
signed long int wg_search_tnode_last(void *db, signed long int nodeoffset, signed long int key, signed long int column);
// wg_search_ttree_index
// file dbindex.c line 1042
signed long int wg_search_ttree_index(void *db, signed long int index_id, signed long int key);
// wg_search_ttree_leftmost
// file dbindex.c line 1257
signed long int wg_search_ttree_leftmost(void *db, signed long int rootoffset, signed long int key, signed long int *result, struct wg_tnode *lb_node);
// wg_search_ttree_rightmost
// file dbindex.c line 1180
signed long int wg_search_ttree_rightmost(void *db, signed long int rootoffset, signed long int key, signed long int *result, struct wg_tnode *rb_node);
// wg_set_atomic_field
// file dbdata.c line 1047
signed long int wg_set_atomic_field(void *db, void *record, signed long int fieldnr, signed long int data);
// wg_set_double_field
// file dbdata.c line 938
signed long int wg_set_double_field(void *db, void *record, signed long int fieldnr, double data);
// wg_set_field
// file dbdata.c line 610
signed long int wg_set_field(void *db, void *record, signed long int fieldnr, signed long int data);
// wg_set_int_field
// file ../Db/dbdata.h line 110
signed long int wg_set_int_field(void *db, void *record, signed long int fieldnr, signed long int data);
// wg_set_new_field
// file dbdata.c line 814
signed long int wg_set_new_field(void *db, void *record, signed long int fieldnr, signed long int data);
// wg_set_rec_field
// file dbdata.c line 954
signed long int wg_set_rec_field(void *db, void *record, signed long int fieldnr, void *data);
// wg_set_str_field
// file dbdata.c line 946
signed long int wg_set_str_field(void *db, void *record, signed long int fieldnr, char *data);
// wg_snprint_value
// file dbutil.h line 61
void wg_snprint_value(void *db, signed long int enc, char *buf, signed int buflen);
// wg_start_logging
// file dblog.c line 780
signed long int wg_start_logging(void *db);
// wg_start_read
// file ../Db/dblock.h line 75
signed long int wg_start_read(void *db);
// wg_start_write
// file ../Db/dblock.h line 73
signed long int wg_start_write(void *db);
// wg_stop_logging
// file dblog.c line 843
signed long int wg_stop_logging(void *db);
// wg_strf_iso_datetime
// file dbdata.c line 1757
signed int wg_strf_iso_datetime(void *db, signed int date, signed int time, char *buf);
// wg_strp_iso_date
// file dbdata.c line 1775
signed int wg_strp_iso_date(void *db, char *inbuf);
// wg_strp_iso_time
// file dbdata.c line 1789
signed int wg_strp_iso_time(void *db, char *inbuf);
// wg_time_to_hms
// file dbdata.c line 1825
void wg_time_to_hms(void *db, signed int time, signed int *hr, signed int *min, signed int *sec, signed int *prt);
// wg_update_atomic_field
// file dbdata.c line 1000
signed long int wg_update_atomic_field(void *db, void *record, signed long int fieldnr, signed long int data, signed long int old_data);
// wg_ymd_to_date
// file dbdata.c line 1802
signed int wg_ymd_to_date(void *db, signed int yr, signed int mo, signed int day);
// writer_thread
// file stresstest.c line 371
void * writer_thread(void *threadarg);
// yajl_alloc
// file ../json/yajl_api.h line 136
struct yajl_handle_t * yajl_alloc(const struct anonymous *callbacks, struct anonymous_3 *afs, void *ctx);
// yajl_buf_alloc
// file yajl_all.c line 155
static struct yajl_buf_t * yajl_buf_alloc(struct anonymous_3 *alloc);
// yajl_buf_append
// file yajl_all.c line 170
static void yajl_buf_append(struct yajl_buf_t *buf, const void *data, unsigned long int len);
// yajl_buf_clear
// file yajl_all.c line 181
static void yajl_buf_clear(struct yajl_buf_t *buf);
// yajl_buf_data
// file yajl_all.c line 187
static const unsigned char * yajl_buf_data(struct yajl_buf_t *buf);
// yajl_buf_ensure_available
// file yajl_all.c line 132
static void yajl_buf_ensure_available(struct yajl_buf_t *buf, unsigned long int want);
// yajl_buf_free
// file yajl_all.c line 163
static void yajl_buf_free(struct yajl_buf_t *buf);
// yajl_buf_len
// file yajl_all.c line 192
static unsigned long int yajl_buf_len(struct yajl_buf_t *buf);
// yajl_complete_parse
// file ../json/yajl_api.h line 218
enum anonymous_27 yajl_complete_parse(struct yajl_handle_t *hand);
// yajl_config
// file ../json/yajl_api.h line 195
signed int yajl_config(struct yajl_handle_t *h, enum anonymous_4 opt, ...);
// yajl_do_finish
// file yajl_all.c line 1684
static enum anonymous_27 yajl_do_finish(struct yajl_handle_t *hand);
// yajl_do_parse
// file yajl_all.c line 1711
static enum anonymous_27 yajl_do_parse(struct yajl_handle_t *hand, const unsigned char *jsonText, unsigned long int jsonTextLen);
// yajl_free
// file ../json/yajl_api.h line 198
void yajl_free(struct yajl_handle_t *handle);
// yajl_free_error
// file ../json/yajl_api.h line 249
void yajl_free_error(struct yajl_handle_t *hand, unsigned char *str);
// yajl_gen_alloc
// file ../json/yajl_api.h line 342
struct yajl_gen_t * yajl_gen_alloc(const struct anonymous_3 *afs);
// yajl_gen_array_close
// file ../json/yajl_api.h line 363
enum anonymous_33 yajl_gen_array_close(struct yajl_gen_t *g);
// yajl_gen_array_open
// file ../json/yajl_api.h line 362
enum anonymous_33 yajl_gen_array_open(struct yajl_gen_t *g);
// yajl_gen_bool
// file yajl_all.c line 776
enum anonymous_33 yajl_gen_bool(struct yajl_gen_t *g, signed int boolean);
// yajl_gen_clear
// file yajl_all.c line 850
void yajl_gen_clear(struct yajl_gen_t *g);
// yajl_gen_config
// file ../json/yajl_api.h line 332
signed int yajl_gen_config(struct yajl_gen_t *g, enum anonymous_32 opt, ...);
// yajl_gen_double
// file yajl_all.c line 714
enum anonymous_33 yajl_gen_double(struct yajl_gen_t *g, double number);
// yajl_gen_free
// file ../json/yajl_api.h line 345
void yajl_gen_free(struct yajl_gen_t *g);
// yajl_gen_get_buf
// file yajl_all.c line 840
enum anonymous_33 yajl_gen_get_buf(struct yajl_gen_t *g, const unsigned char **buf, unsigned long int *len);
// yajl_gen_integer
// file yajl_all.c line 696
enum anonymous_33 yajl_gen_integer(struct yajl_gen_t *g, signed long long int number);
// yajl_gen_map_close
// file ../json/yajl_api.h line 361
enum anonymous_33 yajl_gen_map_close(struct yajl_gen_t *g);
// yajl_gen_map_open
// file ../json/yajl_api.h line 360
enum anonymous_33 yajl_gen_map_open(struct yajl_gen_t *g);
// yajl_gen_null
// file yajl_all.c line 766
enum anonymous_33 yajl_gen_null(struct yajl_gen_t *g);
// yajl_gen_number
// file ../json/yajl_api.h line 352
enum anonymous_33 yajl_gen_number(struct yajl_gen_t *g, const char *s, unsigned long int l);
// yajl_gen_string
// file ../json/yajl_api.h line 355
enum anonymous_33 yajl_gen_string(struct yajl_gen_t *g, const unsigned char *str, unsigned long int len);
// yajl_get_bytes_consumed
// file yajl_all.c line 331
unsigned long int yajl_get_bytes_consumed(struct yajl_handle_t *hand);
// yajl_get_error
// file ../json/yajl_api.h line 230
unsigned char * yajl_get_error(struct yajl_handle_t *hand, signed int verbose, const unsigned char *jsonText, unsigned long int jsonTextLen);
// yajl_internal_free
// file yajl_all.c line 117
static void yajl_internal_free(void *ctx, void *ptr);
// yajl_internal_malloc
// file yajl_all.c line 104
static void * yajl_internal_malloc(void *ctx, unsigned long int sz);
// yajl_internal_realloc
// file yajl_all.c line 110
static void * yajl_internal_realloc(void *ctx, void *previous, unsigned long int sz);
// yajl_lex_alloc
// file yajl_all.c line 906
static struct yajl_lexer_t * yajl_lex_alloc(struct anonymous_3 *alloc, unsigned int allowComments, unsigned int validateUTF8);
// yajl_lex_comment
// file yajl_all.c line 1260
static enum anonymous_29 yajl_lex_comment(struct yajl_lexer_t *lexer, const unsigned char *jsonText, unsigned long int jsonTextLen, unsigned long int *offset);
// yajl_lex_error_to_string
// file yajl_all.c line 1493
static const char * yajl_lex_error_to_string(enum anonymous_28 error);
// yajl_lex_free
// file yajl_all.c line 919
static void yajl_lex_free(struct yajl_lexer_t *lxr);
// yajl_lex_get_error
// file yajl_all.c line 1531
static enum anonymous_28 yajl_lex_get_error(struct yajl_lexer_t *lexer);
// yajl_lex_lex
// file yajl_all.c line 1301
static enum anonymous_29 yajl_lex_lex(struct yajl_lexer_t *lexer, const unsigned char *jsonText, unsigned long int jsonTextLen, unsigned long int *offset, const unsigned char **outBuf, unsigned long int *outLen);
// yajl_lex_number
// file yajl_all.c line 1173
static enum anonymous_29 yajl_lex_number(struct yajl_lexer_t *lexer, const unsigned char *jsonText, unsigned long int jsonTextLen, unsigned long int *offset);
// yajl_lex_string
// file yajl_all.c line 1070
static enum anonymous_29 yajl_lex_string(struct yajl_lexer_t *lexer, const unsigned char *jsonText, unsigned long int jsonTextLen, unsigned long int *offset);
// yajl_lex_utf8_char
// file yajl_all.c line 997
static enum anonymous_29 yajl_lex_utf8_char(struct yajl_lexer_t *lexer, const unsigned char *jsonText, unsigned long int jsonTextLen, unsigned long int *offset, unsigned char curChar);
// yajl_parse
// file ../json/yajl_api.h line 205
enum anonymous_27 yajl_parse(struct yajl_handle_t *hand, const unsigned char *jsonText, unsigned long int jsonTextLen);
// yajl_parse_integer
// file yajl_all.c line 1541
static signed long long int yajl_parse_integer(const unsigned char *number, unsigned int length);
// yajl_render_error_string
// file yajl_all.c line 1570
static unsigned char * yajl_render_error_string(struct yajl_handle_t *hand, const unsigned char *jsonText, unsigned long int jsonTextLen, signed int verbose);
// yajl_set_default_alloc_funcs
// file yajl_all.c line 123
static void yajl_set_default_alloc_funcs(struct anonymous_3 *yaf);
// yajl_status_to_string
// file yajl_all.c line 198
const char * yajl_status_to_string(enum anonymous_27 stat);
// yajl_string_decode
// file yajl_all.c line 438
static void yajl_string_decode(struct yajl_buf_t *buf, const unsigned char *str, unsigned long int len);
// yajl_string_encode
// file yajl_all.c line 354
static void yajl_string_encode(void (* const print)(void *, const char *, unsigned long int), void *ctx, const unsigned char *str, unsigned long int len, signed int escape_solidus);
// yajl_string_encode::print_object
//
void print_object(void *, const char *, unsigned long int);
// yajl_string_scan
// file yajl_all.c line 1057
static unsigned long int yajl_string_scan(const unsigned char *buf, unsigned long int len, signed int utf8check);
// yajl_string_validate_utf8
// file yajl_all.c line 504
static signed int yajl_string_validate_utf8(const unsigned char *s, unsigned long int len);
// years_to_days
// file dbdata.c line 2898
static signed long int years_to_days(unsigned int yr);
// ymd_to_scalar
// file dbdata.c line 2902
static signed long int ymd_to_scalar(unsigned int yr, unsigned int mo, unsigned int day);

struct anonymous_3
{
  // malloc
  void * (*malloc)(void *, unsigned long int);
  // realloc
  void * (*realloc)(void *, void *, unsigned long int);
  // free
  void (*free)(void *, void *);
  // ctx
  void *ctx;
};

struct anonymous
{
  // yajl_null
  signed int (*yajl_null)(void *);
  // yajl_boolean
  signed int (*yajl_boolean)(void *, signed int);
  // yajl_integer
  signed int (*yajl_integer)(void *, signed long long int);
  // yajl_double
  signed int (*yajl_double)(void *, double);
  // yajl_number
  signed int (*yajl_number)(void *, const char *, unsigned long int);
  // yajl_string
  signed int (*yajl_string)(void *, const unsigned char *, unsigned long int);
  // yajl_start_map
  signed int (*yajl_start_map)(void *);
  // yajl_map_key
  signed int (*yajl_map_key)(void *, const unsigned char *, unsigned long int);
  // yajl_end_map
  signed int (*yajl_end_map)(void *);
  // yajl_start_array
  signed int (*yajl_start_array)(void *);
  // yajl_end_array
  signed int (*yajl_end_array)(void *);
};

struct anonymous_16
{
  // page
  struct __query_result_page *page;
  // pidx
  signed long int pidx;
};

struct anonymous_6
{
  // db
  struct _db_memsegment_header *db;
  // logdata
  void *logdata;
};

struct _wg_mpoolsubarea_header
{
  // size
  signed int size;
  // area_start
  void *area_start;
  // area_end
  void *area_end;
};

struct anonymous_8
{
  // freeptr
  void *freeptr;
  // cur_subarea
  signed int cur_subarea;
  // nrof_subareas
  signed int nrof_subareas;
  // subarea_table
  struct _wg_mpoolsubarea_header subarea_table[100l];
};

struct anonymous_17
{
  // mpool
  void *mpool;
  // first_page
  struct __query_result_page *first_page;
  // wcursor
  struct anonymous_16 wcursor;
  // rcursor
  struct anonymous_16 rcursor;
  // res_count
  signed long int res_count;
};

struct anonymous_1
{
  // type
  enum anonymous_2 type;
  // head
  struct __stack_entry_elem *head;
  // tail
  struct __stack_entry_elem *tail;
  // last_key
  char last_key[80l];
  // size
  signed int size;
};

struct anonymous_13
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_0
{
  // state
  signed int state;
  // stack
  struct anonymous_1 stack[7l];
  // stack_ptr
  signed int stack_ptr;
  // db
  void *db;
  // isparam
  signed int isparam;
  // isdocument
  signed int isdocument;
  // document
  void **document;
};

struct anonymous_9
{
  // threadid
  signed int threadid;
  // db
  void *db;
  // pth
  unsigned long int pth;
};

struct anonymous_24
{
  // active
  signed long int active;
  // dirty
  signed long int dirty;
  // serial
  signed long int serial;
};

struct anonymous_20
{
  // car
  signed long int car;
  // cdr
  signed long int cdr;
};

struct anonymous_12
{
  // column
  signed long int column;
  // cond
  signed long int cond;
  // value
  signed long int value;
};

struct anonymous_23
{
  // count
  signed long int count;
  // offset
  signed long int offset[20l];
  // size
  signed long int size[20l];
};

struct anonymous_22
{
  // fixed_columns
  signed long int fixed_columns;
  // offset_matchrec
  signed long int offset_matchrec;
  // refcount
  signed long int refcount;
};

struct anonymous_18
{
  // key
  signed long int key;
  // value
  signed long int value;
};

struct anonymous_35
{
  // level
  signed long int level;
  // directory
  struct anonymous_34 **directory;
  // mpool
  void *mpool;
};

struct anonymous_34
{
  // level
  signed long int level;
  // fill
  signed long int fill;
  // key
  signed long int key[8l];
  // value
  signed long int value[8l];
};

struct anonymous_5
{
  // next_cell
  signed long int next_cell;
  // class
  signed long int class;
  // waiting
  volatile signed long int waiting;
  // next
  volatile signed long int next;
  // prev
  volatile signed long int prev;
};

struct anonymous_19
{
  // number_of_indexes
  signed long int number_of_indexes;
  // index_list
  signed long int index_list;
  // index_table
  signed long int index_table[128l];
  // index_template_list
  signed long int index_template_list;
  // index_template_table
  signed long int index_template_table[128l];
};

struct anonymous_25
{
  // offset
  signed long int offset;
  // size
  signed long int size;
};

struct anonymous_15
{
  // qtype
  signed long int qtype;
  // arglist
  struct anonymous_12 *arglist;
  // argc
  signed long int argc;
  // column
  signed long int column;
  // curr_offset
  signed long int curr_offset;
  // end_offset
  signed long int end_offset;
  // curr_slot
  signed long int curr_slot;
  // end_slot
  signed long int end_slot;
  // direction
  signed long int direction;
  // curr_record
  signed long int curr_record;
  // mpool
  void *mpool;
  // curr_page
  void *curr_page;
  // curr_pidx
  signed long int curr_pidx;
  // res_count
  unsigned long int res_count;
};

struct anonymous_7
{
  // tail
  signed long int tail;
  // queue_lock
  signed long int queue_lock;
  // storage
  signed long int storage;
  // max_nodes
  signed long int max_nodes;
  // freelist
  signed long int freelist;
};

struct __wg_ttree_header
{
  // offset_root_node
  signed long int offset_root_node;
  // offset_max_node
  signed long int offset_max_node;
  // offset_min_node
  signed long int offset_min_node;
};

struct _db_hash_area_header
{
  // size
  signed long int size;
  // offset
  signed long int offset;
  // arraysize
  signed long int arraysize;
  // arraystart
  signed long int arraystart;
  // arraylength
  signed long int arraylength;
};

struct __wg_hashidx_header
{
  // hasharea
  struct _db_hash_area_header hasharea;
};

union anonymous_26
{
  // t
  struct __wg_ttree_header t;
  // h
  struct __wg_hashidx_header h;
};

struct anonymous_21
{
  // type
  signed long int type;
  // fields
  signed long int fields;
  // rec_field_index
  signed long int rec_field_index[10l];
  // ctl
  union anonymous_26 ctl;
  // template_offset
  signed long int template_offset;
};

struct anonymous_36
{
  // dhash_size
  unsigned long int dhash_size;
  // keys
  signed long int *keys;
};

union anonymous_11
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_14
{
  // __data
  struct anonymous_13 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_10
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __query_result_page
{
  // rows
  signed long int rows[63l];
  // next
  struct __query_result_page *next;
};

struct __stack_entry_elem
{
  // enc
  signed long int enc;
  // next
  struct __stack_entry_elem *next;
};

struct _db_subarea_header
{
  // size
  signed long int size;
  // offset
  signed long int offset;
  // alignedsize
  signed long int alignedsize;
  // alignedoffset
  signed long int alignedoffset;
};

struct _db_area_header
{
  // fixedlength
  signed long int fixedlength;
  // objlength
  signed long int objlength;
  // freelist
  signed long int freelist;
  // last_subarea_index
  signed long int last_subarea_index;
  // subarea_array
  struct _db_subarea_header subarea_array[64l];
  // freebuckets
  signed long int freebuckets[290l];
};

struct _db_memsegment_header
{
  // mark
  signed int mark;
  // version
  signed int version;
  // features
  signed int features;
  // checksum
  signed int checksum;
  // size
  signed long int size;
  // free
  signed long int free;
  // initialadr
  signed long int initialadr;
  // key
  signed long int key;
  // datarec_area_header
  struct _db_area_header datarec_area_header;
  // longstr_area_header
  struct _db_area_header longstr_area_header;
  // listcell_area_header
  struct _db_area_header listcell_area_header;
  // shortstr_area_header
  struct _db_area_header shortstr_area_header;
  // word_area_header
  struct _db_area_header word_area_header;
  // doubleword_area_header
  struct _db_area_header doubleword_area_header;
  // strhash_area_header
  struct _db_hash_area_header strhash_area_header;
  // index_control_area_header
  struct anonymous_19 index_control_area_header;
  // tnode_area_header
  struct _db_area_header tnode_area_header;
  // indexhdr_area_header
  struct _db_area_header indexhdr_area_header;
  // indextmpl_area_header
  struct _db_area_header indextmpl_area_header;
  // indexhash_area_header
  struct _db_area_header indexhash_area_header;
  // logging
  struct anonymous_24 logging;
  // recptr_bitmap
  struct anonymous_25 recptr_bitmap;
  // locks
  struct anonymous_7 locks;
  // extdbs
  struct anonymous_23 extdbs;
};

struct ipc_perm
{
  // __key
  signed int __key;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // cuid
  unsigned int cuid;
  // cgid
  unsigned int cgid;
  // mode
  unsigned short int mode;
  // __pad1
  unsigned short int __pad1;
  // __seq
  unsigned short int __seq;
  // __pad2
  unsigned short int __pad2;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct shmid_ds
{
  // shm_perm
  struct ipc_perm shm_perm;
  // shm_segsz
  unsigned long int shm_segsz;
  // shm_atime
  signed long int shm_atime;
  // shm_dtime
  signed long int shm_dtime;
  // shm_ctime
  signed long int shm_ctime;
  // shm_cpid
  signed int shm_cpid;
  // shm_lpid
  signed int shm_lpid;
  // shm_nattch
  unsigned long int shm_nattch;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
  // __glibc_reserved5
  unsigned long int __glibc_reserved5;
};

struct timeb
{
  // time
  signed long int time;
  // millitm
  unsigned short int millitm;
  // timezone
  signed short int timezone;
  // dstflag
  signed short int dstflag;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct uri_scheme_info
{
  // prefix
  char *prefix;
  // length
  signed int length;
};

struct wg_tnode
{
  // parent_offset
  signed long int parent_offset;
  // current_max
  signed long int current_max;
  // current_min
  signed long int current_min;
  // number_of_elements
  signed short int number_of_elements;
  // left_subtree_height
  unsigned char left_subtree_height;
  // right_subtree_height
  unsigned char right_subtree_height;
  // array_of_values
  signed long int array_of_values[8l];
  // left_child_offset
  signed long int left_child_offset;
  // right_child_offset
  signed long int right_child_offset;
  // succ_offset
  signed long int succ_offset;
  // pred_offset
  signed long int pred_offset;
};

struct yajl_buf_t
{
  // len
  unsigned long int len;
  // used
  unsigned long int used;
  // data
  unsigned char *data;
  // alloc
  struct anonymous_3 *alloc;
};

struct yajl_bytestack_t
{
  // stack
  unsigned char *stack;
  // size
  unsigned long int size;
  // used
  unsigned long int used;
  // yaf
  struct anonymous_3 *yaf;
};

struct yajl_gen_t
{
  // flags
  unsigned int flags;
  // depth
  unsigned int depth;
  // indentString
  const char *indentString;
  // state
  enum anonymous_31 state[128l];
  // print
  void (*print)(void *, const char *, unsigned long int);
  // ctx
  void *ctx;
  // alloc
  struct anonymous_3 alloc;
};

struct yajl_handle_t
{
  // callbacks
  const struct anonymous *callbacks;
  // ctx
  void *ctx;
  // lexer
  struct yajl_lexer_t *lexer;
  // parseError
  const char *parseError;
  // bytesConsumed
  unsigned long int bytesConsumed;
  // decodeBuf
  struct yajl_buf_t *decodeBuf;
  // stateStack
  struct yajl_bytestack_t stateStack;
  // alloc
  struct anonymous_3 alloc;
  // flags
  unsigned int flags;
};

struct yajl_lexer_t
{
  // lineOff
  unsigned long int lineOff;
  // charOff
  unsigned long int charOff;
  // error
  enum anonymous_28 error;
  // buf
  struct yajl_buf_t *buf;
  // bufOff
  unsigned long int bufOff;
  // bufInUse
  unsigned int bufInUse;
  // allowComments
  unsigned int allowComments;
  // validateUTF8
  unsigned int validateUTF8;
  // alloc
  struct anonymous_3 *alloc;
};


// charLookupTable
// file yajl_all.c line 940
static const char charLookupTable[256l] = { (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0x02, (const char)0, (const char)0, (const char)(0x08 | 0x01 | 0x02), (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0x01, (const char)0x04, (const char)0x04, (const char)0x04, (const char)0x04, (const char)0x04, (const char)0x04, (const char)0x04, (const char)0x04, (const char)0x04, (const char)0x04, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0x04, (const char)0x04, (const char)0x04, (const char)0x04, (const char)0x04, (const char)0x04, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)(0x08 | 0x01 | 0x02), (const char)0, (const char)0, (const char)0, (const char)0, (const char)0x04, (const char)(0x01 | 0x04), (const char)0x04, (const char)0x04, (const char)0x04, (const char)(0x01 | 0x04), (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0x01, (const char)0, (const char)0, (const char)0, (const char)0x01, (const char)0, (const char)0x01, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10, (const char)0x10 };
// crc_table
// file crc1.h line 28
signed int crc_table[256l] = { (signed int)0x00000000L, (signed int)0x77073096L, (signed int)0xee0e612cL, (signed int)0x990951baL, (signed int)0x076dc419L, (signed int)0x706af48fL, (signed int)0xe963a535L, (signed int)0x9e6495a3L, (signed int)0x0edb8832L, (signed int)0x79dcb8a4L, (signed int)0xe0d5e91eL, (signed int)0x97d2d988L, (signed int)0x09b64c2bL, (signed int)0x7eb17cbdL, (signed int)0xe7b82d07L, (signed int)0x90bf1d91L, (signed int)0x1db71064L, (signed int)0x6ab020f2L, (signed int)0xf3b97148L, (signed int)0x84be41deL, (signed int)0x1adad47dL, (signed int)0x6ddde4ebL, (signed int)0xf4d4b551L, (signed int)0x83d385c7L, (signed int)0x136c9856L, (signed int)0x646ba8c0L, (signed int)0xfd62f97aL, (signed int)0x8a65c9ecL, (signed int)0x14015c4fL, (signed int)0x63066cd9L, (signed int)0xfa0f3d63L, (signed int)0x8d080df5L, (signed int)0x3b6e20c8L, (signed int)0x4c69105eL, (signed int)0xd56041e4L, (signed int)0xa2677172L, (signed int)0x3c03e4d1L, (signed int)0x4b04d447L, (signed int)0xd20d85fdL, (signed int)0xa50ab56bL, (signed int)0x35b5a8faL, (signed int)0x42b2986cL, (signed int)0xdbbbc9d6L, (signed int)0xacbcf940L, (signed int)0x32d86ce3L, (signed int)0x45df5c75L, (signed int)0xdcd60dcfL, (signed int)0xabd13d59L, (signed int)0x26d930acL, (signed int)0x51de003aL, (signed int)0xc8d75180L, (signed int)0xbfd06116L, (signed int)0x21b4f4b5L, (signed int)0x56b3c423L, (signed int)0xcfba9599L, (signed int)0xb8bda50fL, (signed int)0x2802b89eL, (signed int)0x5f058808L, (signed int)0xc60cd9b2L, (signed int)0xb10be924L, (signed int)0x2f6f7c87L, (signed int)0x58684c11L, (signed int)0xc1611dabL, (signed int)0xb6662d3dL, (signed int)0x76dc4190L, (signed int)0x01db7106L, (signed int)0x98d220bcL, (signed int)0xefd5102aL, (signed int)0x71b18589L, (signed int)0x06b6b51fL, (signed int)0x9fbfe4a5L, (signed int)0xe8b8d433L, (signed int)0x7807c9a2L, (signed int)0x0f00f934L, (signed int)0x9609a88eL, (signed int)0xe10e9818L, (signed int)0x7f6a0dbbL, (signed int)0x086d3d2dL, (signed int)0x91646c97L, (signed int)0xe6635c01L, (signed int)0x6b6b51f4L, (signed int)0x1c6c6162L, (signed int)0x856530d8L, (signed int)0xf262004eL, (signed int)0x6c0695edL, (signed int)0x1b01a57bL, (signed int)0x8208f4c1L, (signed int)0xf50fc457L, (signed int)0x65b0d9c6L, (signed int)0x12b7e950L, (signed int)0x8bbeb8eaL, (signed int)0xfcb9887cL, (signed int)0x62dd1ddfL, (signed int)0x15da2d49L, (signed int)0x8cd37cf3L, (signed int)0xfbd44c65L, (signed int)0x4db26158L, (signed int)0x3ab551ceL, (signed int)0xa3bc0074L, (signed int)0xd4bb30e2L, (signed int)0x4adfa541L, (signed int)0x3dd895d7L, (signed int)0xa4d1c46dL, (signed int)0xd3d6f4fbL, (signed int)0x4369e96aL, (signed int)0x346ed9fcL, (signed int)0xad678846L, (signed int)0xda60b8d0L, (signed int)0x44042d73L, (signed int)0x33031de5L, (signed int)0xaa0a4c5fL, (signed int)0xdd0d7cc9L, (signed int)0x5005713cL, (signed int)0x270241aaL, (signed int)0xbe0b1010L, (signed int)0xc90c2086L, (signed int)0x5768b525L, (signed int)0x206f85b3L, (signed int)0xb966d409L, (signed int)0xce61e49fL, (signed int)0x5edef90eL, (signed int)0x29d9c998L, (signed int)0xb0d09822L, (signed int)0xc7d7a8b4L, (signed int)0x59b33d17L, (signed int)0x2eb40d81L, (signed int)0xb7bd5c3bL, (signed int)0xc0ba6cadL, (signed int)0xedb88320L, (signed int)0x9abfb3b6L, (signed int)0x03b6e20cL, (signed int)0x74b1d29aL, (signed int)0xead54739L, (signed int)0x9dd277afL, (signed int)0x04db2615L, (signed int)0x73dc1683L, (signed int)0xe3630b12L, (signed int)0x94643b84L, (signed int)0x0d6d6a3eL, (signed int)0x7a6a5aa8L, (signed int)0xe40ecf0bL, (signed int)0x9309ff9dL, (signed int)0x0a00ae27L, (signed int)0x7d079eb1L, (signed int)0xf00f9344L, (signed int)0x8708a3d2L, (signed int)0x1e01f268L, (signed int)0x6906c2feL, (signed int)0xf762575dL, (signed int)0x806567cbL, (signed int)0x196c3671L, (signed int)0x6e6b06e7L, (signed int)0xfed41b76L, (signed int)0x89d32be0L, (signed int)0x10da7a5aL, (signed int)0x67dd4accL, (signed int)0xf9b9df6fL, (signed int)0x8ebeeff9L, (signed int)0x17b7be43L, (signed int)0x60b08ed5L, (signed int)0xd6d6a3e8L, (signed int)0xa1d1937eL, (signed int)0x38d8c2c4L, (signed int)0x4fdff252L, (signed int)0xd1bb67f1L, (signed int)0xa6bc5767L, (signed int)0x3fb506ddL, (signed int)0x48b2364bL, (signed int)0xd80d2bdaL, (signed int)0xaf0a1b4cL, (signed int)0x36034af6L, (signed int)0x41047a60L, (signed int)0xdf60efc3L, (signed int)0xa867df55L, (signed int)0x316e8eefL, (signed int)0x4669be79L, (signed int)0xcb61b38cL, (signed int)0xbc66831aL, (signed int)0x256fd2a0L, (signed int)0x5268e236L, (signed int)0xcc0c7795L, (signed int)0xbb0b4703L, (signed int)0x220216b9L, (signed int)0x5505262fL, (signed int)0xc5ba3bbeL, (signed int)0xb2bd0b28L, (signed int)0x2bb45a92L, (signed int)0x5cb36a04L, (signed int)0xc2d7ffa7L, (signed int)0xb5d0cf31L, (signed int)0x2cd99e8bL, (signed int)0x5bdeae1dL, (signed int)0x9b64c2b0L, (signed int)0xec63f226L, (signed int)0x756aa39cL, (signed int)0x026d930aL, (signed int)0x9c0906a9L, (signed int)0xeb0e363fL, (signed int)0x72076785L, (signed int)0x05005713L, (signed int)0x95bf4a82L, (signed int)0xe2b87a14L, (signed int)0x7bb12baeL, (signed int)0x0cb61b38L, (signed int)0x92d28e9bL, (signed int)0xe5d5be0dL, (signed int)0x7cdcefb7L, (signed int)0x0bdbdf21L, (signed int)0x86d3d2d4L, (signed int)0xf1d4e242L, (signed int)0x68ddb3f8L, (signed int)0x1fda836eL, (signed int)0x81be16cdL, (signed int)0xf6b9265bL, (signed int)0x6fb077e1L, (signed int)0x18b74777L, (signed int)0x88085ae6L, (signed int)0xff0f6a70L, (signed int)0x66063bcaL, (signed int)0x11010b5cL, (signed int)0x8f659effL, (signed int)0xf862ae69L, (signed int)0x616bffd3L, (signed int)0x166ccf45L, (signed int)0xa00ae278L, (signed int)0xd70dd2eeL, (signed int)0x4e048354L, (signed int)0x3903b3c2L, (signed int)0xa7672661L, (signed int)0xd06016f7L, (signed int)0x4969474dL, (signed int)0x3e6e77dbL, (signed int)0xaed16a4aL, (signed int)0xd9d65adcL, (signed int)0x40df0b66L, (signed int)0x37d83bf0L, (signed int)0xa9bcae53L, (signed int)0xdebb9ec5L, (signed int)0x47b2cf7fL, (signed int)0x30b5ffe9L, (signed int)0xbdbdf21cL, (signed int)0xcabac28aL, (signed int)0x53b39330L, (signed int)0x24b4a3a6L, (signed int)0xbad03605L, (signed int)0xcdd70693L, (signed int)0x54de5729L, (signed int)0x23d967bfL, (signed int)0xb3667a2eL, (signed int)0xc4614ab8L, (signed int)0x5d681b02L, (signed int)0x2a6f2b94L, (signed int)0xb40bbe37L, (signed int)0xc30c8ea1L, (signed int)0x5a05df1bL, (signed int)0x2d02ef8dL };
// input_cb
// file dbjson.c line 155
struct anonymous input_cb;
// input_cb
// file dbjson.c line 155
struct anonymous input_cb = { .yajl_null=(signed int (*)(void *))(void *)0, .yajl_boolean=(signed int (*)(void *, signed int))(void *)0,
    .yajl_integer=elem_integer_cb,
    .yajl_double=elem_double_cb, .yajl_number=(signed int (*)(void *, const char *, unsigned long int))(void *)0,
    .yajl_string=elem_string_cb,
    .yajl_start_map=object_begin_cb, .yajl_map_key=object_key_cb,
    .yajl_end_map=object_end_cb, .yajl_start_array=array_begin_cb,
    .yajl_end_array=array_end_cb };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// twait_cnt
// file stresstest.c line 109
volatile signed int twait_cnt;
// twait_cv
// file stresstest.c line 105
union anonymous_14 twait_cv;
// twait_mutex
// file stresstest.c line 104
union anonymous_10 twait_mutex;
// uri_scheme_table
// file dbutil.c line 77
struct uri_scheme_info uri_scheme_table[6l] = { { .prefix="urn:", .length=4 }, { .prefix="file:", .length=5 }, { .prefix="http://", .length=7 }, { .prefix="https://", .length=8 }, { .prefix="mailto:", .length=7 }, { .prefix=(char *)(void *)0, .length=0 } };
// validate_cb
// file dbjson.c line 141
struct anonymous validate_cb;
// validate_cb
// file dbjson.c line 141
struct anonymous validate_cb = { .yajl_null=(signed int (*)(void *))(void *)0, .yajl_boolean=(signed int (*)(void *, signed int))(void *)0,
    .yajl_integer=(signed int (*)(void *, signed long long int))(void *)0,
    .yajl_double=(signed int (*)(void *, double))(void *)0,
    .yajl_number=(signed int (*)(void *, const char *, unsigned long int))(void *)0,
    .yajl_string=(signed int (*)(void *, const unsigned char *, unsigned long int))(void *)0,
    .yajl_start_map=check_push_cb,
    .yajl_map_key=(signed int (*)(void *, const unsigned char *, unsigned long int))(void *)0, .yajl_end_map=check_pop_cb,
    .yajl_start_array=check_push_cb, .yajl_end_array=check_pop_cb };

// CharToHex
// file yajl_all.c line 346
static void CharToHex(unsigned char c, char *hexBuf)
{
  const char *hexchar = "0123456789ABCDEF";
  hexBuf[(signed long int)0] = hexchar[(signed long int)((signed int)c >> 4)];
  hexBuf[(signed long int)1] = hexchar[(signed long int)((signed int)c & 0x0F)];
}

// Utf32toUtf8
// file yajl_all.c line 412
static void Utf32toUtf8(unsigned int codepoint, char *utf8Buf)
{
  if(!(codepoint >= 128u))
  {
    utf8Buf[(signed long int)0] = (char)codepoint;
    utf8Buf[(signed long int)1] = (char)0;
  }

  else
    if(!(codepoint >= 2048u))
    {
      utf8Buf[(signed long int)0] = (char)(codepoint >> 6 | (unsigned int)0xC0);
      utf8Buf[(signed long int)1] = (char)(codepoint & (unsigned int)0x3F | (unsigned int)0x80);
      utf8Buf[(signed long int)2] = (char)0;
    }

    else
      if(!(codepoint >= 65536u))
      {
        utf8Buf[(signed long int)0] = (char)(codepoint >> 12 | (unsigned int)0xE0);
        utf8Buf[(signed long int)1] = (char)(codepoint >> 6 & (unsigned int)0x3F | (unsigned int)0x80);
        utf8Buf[(signed long int)2] = (char)(codepoint & (unsigned int)0x3F | (unsigned int)0x80);
        utf8Buf[(signed long int)3] = (char)0;
      }

      else
        if(!(codepoint >= 2097152u))
        {
          utf8Buf[(signed long int)0] = (char)(codepoint >> 18 | (unsigned int)0xF0);
          utf8Buf[(signed long int)1] = (char)(codepoint >> 12 & (unsigned int)0x3F | (unsigned int)0x80);
          utf8Buf[(signed long int)2] = (char)(codepoint >> 6 & (unsigned int)0x3F | (unsigned int)0x80);
          utf8Buf[(signed long int)3] = (char)(codepoint & (unsigned int)0x3F | (unsigned int)0x80);
          utf8Buf[(signed long int)4] = (char)0;
        }

        else
        {
          utf8Buf[(signed long int)0] = (char)63;
          utf8Buf[(signed long int)1] = (char)0;
        }
}

// add_elem
// file dbjson.c line 525
static signed int add_elem(struct anonymous_0 *ctx, signed long int enc)
{
  struct anonymous_1 *e;
  struct __stack_entry_elem *tmp;
  _Bool tmp_if_expr_1;
  if(!(ctx->stack_ptr >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ctx->stack_ptr >= 7 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    e = &ctx->stack[(signed long int)ctx->stack_ptr];
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct __stack_entry_elem) /*16ul*/ );
    tmp = (struct __stack_entry_elem *)return_value_malloc_2;
    if(tmp == ((struct __stack_entry_elem *)NULL))
      return 0;

    else
    {
      if(e->tail == ((struct __stack_entry_elem *)NULL))
        e->head = tmp;

      else
        e->tail->next = tmp;
      e->tail = tmp;
      e->size = e->size + 1;
      tmp->enc = enc;
      tmp->next = (struct __stack_entry_elem *)(void *)0;
      return 1;
    }
  }
}

// add_index_template
// file dbindex.c line 1757
static signed long int add_index_template(void *db, signed long int *matchrec, signed long int reclen)
{
  signed long int *ilist;
  signed long int *meta;
  void *rec;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  struct anonymous_22 *tmpl;
  signed long int fixed_columns = (signed long int)0;
  signed long int template_offset = (signed long int)0;
  signed long int last_fixed = (signed long int)0;
  signed int i = 0;
  for( ; !((signed long int)i >= reclen); i = i + 1)
  {
    signed long int type;
    type=wg_get_encoded_type(db, matchrec[(signed long int)i]);
    if(type == 2l)
    {
      show_index_error(db, "record links not allowed in index templates");
      return (signed long int)0;
    }

    if(!(type == 14l))
    {
      fixed_columns = fixed_columns + 1l;
      last_fixed = (signed long int)i;
    }

  }
  signed long int tmp_if_expr_5;
  signed long int return_value_wg_get_field_3;
  signed long int return_value_wg_compare_4;
  if(fixed_columns == 0l)
    return (signed long int)0;

  else
  {
    reclen = last_fixed + (signed long int)1;
    ilist = &dbh->index_control_area_header.index_template_list;
    while(!(*ilist == 0l))
    {
      struct anonymous_20 *ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
      if(ilistelem->car == 0l)
      {
        show_index_error(db, "Invalid header in index tempate list");
        return (signed long int)0;
      }

      tmpl = (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + ilistelem->car);
      if(tmpl->fixed_columns == fixed_columns)
      {
        rec = (void *)((char *)((struct anonymous_6 *)db)->db + tmpl->offset_matchrec);
        signed long int return_value_wg_get_record_len_1;
        return_value_wg_get_record_len_1=wg_get_record_len(db, rec);
        if(!(reclen == return_value_wg_get_record_len_1))
          goto nextelem;

        i = 0;
        for( ; !((signed long int)i >= reclen); i = i + 1)
        {
          signed long int return_value_wg_get_encoded_type_6;
          return_value_wg_get_encoded_type_6=wg_get_encoded_type(db, matchrec[(signed long int)i]);
          if(!(return_value_wg_get_encoded_type_6 == 14l))
          {
            signed long int return_value_wg_get_field_2;
            return_value_wg_get_field_2=wg_get_field(db, rec, (signed long int)i);
            if(matchrec[(signed long int)i] == return_value_wg_get_field_2)
              tmp_if_expr_5 = (signed long int)0;

            else
            {
              return_value_wg_get_field_3=wg_get_field(db, rec, (signed long int)i);
              return_value_wg_compare_4=wg_compare(db, matchrec[(signed long int)i], return_value_wg_get_field_3, 7);
              tmp_if_expr_5 = return_value_wg_compare_4;
            }
            if(!(tmp_if_expr_5 == 0l))
              goto nextelem;

          }

        }
        return ilistelem->car;
      }

      else
        if(!(tmpl->fixed_columns >= fixed_columns))
          break;


    nextelem:
      ;
      ilist = &ilistelem->cdr;
    }
    rec=wg_create_raw_record(db, reclen);
    if(rec == NULL)
      return (signed long int)0;

    else
    {
      i = 0;
      for( ; !((signed long int)i >= reclen); i = i + 1)
      {
        signed long int return_value_wg_set_new_field_7;
        return_value_wg_set_new_field_7=wg_set_new_field(db, rec, (signed long int)i, matchrec[(signed long int)i]);
        if(!(return_value_wg_set_new_field_7 >= 0l))
          return (signed long int)0;

      }
      meta = (signed long int *)rec + (signed long int)1;
      *meta = *meta | (signed long int)(0x1 | 0x2);
      template_offset=wg_alloc_fixlen_object(db, (void *)&dbh->indextmpl_area_header);
      tmpl = (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + template_offset);
      tmpl->offset_matchrec = (signed long int)((char *)rec - (char *)((struct anonymous_6 *)db)->db);
      tmpl->fixed_columns = fixed_columns;
      signed long int return_value_insert_into_list_8;
      return_value_insert_into_list_8=insert_into_list(db, ilist, template_offset);
      if(return_value_insert_into_list_8 == 0l)
        return (signed long int)0;

      else
        return template_offset;
    }
  }
}

// add_key
// file dbjson.c line 553
static signed int add_key(struct anonymous_0 *ctx, char *key)
{
  struct anonymous_1 *e;
  _Bool tmp_if_expr_1;
  if(!(ctx->stack_ptr >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ctx->stack_ptr >= 7 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    e = &ctx->stack[(signed long int)ctx->stack_ptr];
    strncpy(e->last_key, key, (unsigned long int)80);
    e->last_key[(signed long int)79] = (char)0;
    return 1;
  }
}

// add_literal
// file dbjson.c line 571
static signed int add_literal(struct anonymous_0 *ctx, signed long int val)
{
  struct anonymous_1 *e;
  _Bool tmp_if_expr_1;
  if(!(ctx->stack_ptr >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ctx->stack_ptr >= 7 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    e = &ctx->stack[(signed long int)ctx->stack_ptr];
    if((signed int)e->type == ARRAY)
    {
      signed int return_value_add_elem_2;
      return_value_add_elem_2=add_elem(ctx, val);
      return return_value_add_elem_2;
    }

    else
    {
      void *rec;
      signed long int key;
      key=wg_encode_str(ctx->db, e->last_key, (char *)(void *)0);
      if(key == 255l)
        return 0;

      rec=wg_create_triple(ctx->db, (signed long int)0, key, val, (signed long int)ctx->isparam);
      if(rec == NULL)
        return 0;

      signed long int return_value_wg_encode_record_3;
      return_value_wg_encode_record_3=wg_encode_record(ctx->db, rec);
      signed int return_value_add_elem_4;
      return_value_add_elem_4=add_elem(ctx, return_value_wg_encode_record_3);
      return return_value_add_elem_4;
    }
  }
}

// add_to_bucket
// file dbhash.c line 803
static signed long int add_to_bucket(struct anonymous_34 *bucket, signed long int key, signed long int value)
{
  if(bucket->fill >= 8l)
    return bucket->fill + (signed long int)1;

  else
  {
    bucket->key[bucket->fill] = key;
    bucket->value[bucket->fill] = value;
    bucket->fill = bucket->fill + 1l;
    return bucket->fill;
  }
}

// alloc_db_segmentchunk
// file dballoc.c line 305
static signed long int alloc_db_segmentchunk(void *db, signed long int size)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int lastfree;
  signed long int nextfree;
  signed long int i;
  lastfree = dbh->free;
  nextfree = lastfree + size;
  if(!(nextfree >= 0l))
  {
    show_dballoc_error_nr(db, "trying to allocate next segment exceeds positive int limit", size);
    return (signed long int)0;
  }

  else
  {
    i = (signed long int)8 - nextfree % (signed long int)8;
    if(i == 8l)
      i = (signed long int)0;

    nextfree = nextfree + i;
    if(nextfree >= dbh->size)
      return (signed long int)0;

    else
    {
      dbh->free = nextfree;
      return lastfree;
    }
  }
}

// alloc_lock
// file dblock.c line 1379
static signed long int alloc_lock(void *db)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int t = dbh->locks.freelist;
  struct anonymous_5 *tmp;
  if(t == 0l)
    return (signed long int)0;

  else
  {
    tmp = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + t);
    dbh->locks.freelist = tmp->next_cell;
    return t;
  }
}

// append_resultset
// file dbquery.c line 1388
static signed long int append_resultset(void *db, struct anonymous_17 *set, signed long int offset)
{
  if(set->wcursor.pidx >= 63l)
  {
    struct __query_result_page *newpage;
    void *return_value_wg_alloc_mpool_1;
    return_value_wg_alloc_mpool_1=wg_alloc_mpool(db, set->mpool, (signed int)sizeof(struct __query_result_page) /*512ul*/ );
    newpage = (struct __query_result_page *)return_value_wg_alloc_mpool_1;
    if(newpage == ((struct __query_result_page *)NULL))
    {
      signed long int return_value_show_query_error_2;
      return_value_show_query_error_2=show_query_error(db, "Failed to allocate a resultset page");
      return return_value_show_query_error_2;
    }

    memset((void *)newpage->rows, 0, sizeof(signed long int) /*8ul*/  * (unsigned long int)63);
    newpage->next = (struct __query_result_page *)(void *)0;
    if(!(set->wcursor.page == ((struct __query_result_page *)NULL)))
      set->wcursor.page->next = newpage;

    else
    {
      set->first_page = newpage;
      set->rcursor.page = newpage;
    }
    set->wcursor.page = newpage;
    set->wcursor.pidx = (signed long int)0;
  }

  signed long int tmp_post_3 = set->wcursor.pidx;
  set->wcursor.pidx = set->wcursor.pidx + 1l;
  set->wcursor.page->rows[tmp_post_3] = offset;
  set->res_count = set->res_count + 1l;
  return (signed long int)0;
}

// array_begin_cb
// file dbjson.c line 597
static signed int array_begin_cb(void *cb_ctx)
{
  struct anonymous_0 *ctx = (struct anonymous_0 *)cb_ctx;
  signed int return_value_push_1;
  return_value_push_1=push(ctx, (enum anonymous_2)ARRAY);
  if(return_value_push_1 == 0)
    return 0;

  else
    return 1;
}

// array_end_cb
// file dbjson.c line 608
static signed int array_end_cb(void *cb_ctx)
{
  struct anonymous_0 *ctx = (struct anonymous_0 *)cb_ctx;
  signed int return_value_pop_1;
  return_value_pop_1=pop(ctx);
  if(return_value_pop_1 == 0)
    return 0;

  else
    return 1;
}

// check_and_merge_by_key
// file dbquery.c line 1684
static signed long int check_and_merge_by_key(void *db, void *rec, struct anonymous_18 *arg, struct anonymous_17 *next_set)
{
  signed long int rc = (signed long int)0;
  signed long int reclen;
  reclen=wg_get_record_len(db, rec);
  signed long int tmp_if_expr_9;
  signed long int return_value_wg_compare_8;
  signed long int return_value_wg_get_encoded_type_7;
  signed long int tmp_if_expr_6;
  signed long int return_value_wg_get_field_4;
  signed long int return_value_wg_compare_5;
  if(reclen >= 3l)
  {
    signed long int k;
    k=wg_get_field(db, rec, (signed long int)(0 + 2));
    if(k == arg->value)
      tmp_if_expr_9 = (signed long int)0;

    else
    {
      return_value_wg_compare_8=wg_compare(db, k, arg->value, 7);
      tmp_if_expr_9 = return_value_wg_compare_8;
    }
    if(tmp_if_expr_9 == 0l)
    {
      void *doc;
      doc=wg_find_document(db, rec);
      if(!(doc == NULL))
      {
        signed long int return_value_append_resultset_1;
        return_value_append_resultset_1=append_resultset(db, next_set, (signed long int)((char *)doc - (char *)((struct anonymous_6 *)db)->db));
        if(return_value_append_resultset_1 == 0l)
          rc = (signed long int)1;

        else
          rc = (signed long int)-1;
      }

      else
        rc=show_query_error(db, "Failed to retrieve the document");
    }

    else
    {
      return_value_wg_get_encoded_type_7=wg_get_encoded_type(db, k);
      if(return_value_wg_get_encoded_type_7 == 2l)
      {
        void *arec;
        arec=wg_decode_record(db, k);
        if(!((64l & ((signed long int *)arec)[1l]) == 0l))
        {
          signed long int areclen;
          areclen=wg_get_record_len(db, arec);
          signed int j = 0;
          for( ; !((signed long int)j >= areclen); j = j + 1)
          {
            signed long int return_value_wg_get_field_3;
            return_value_wg_get_field_3=wg_get_field(db, arec, (signed long int)j);
            if(return_value_wg_get_field_3 == arg->value)
              tmp_if_expr_6 = (signed long int)0;

            else
            {
              return_value_wg_get_field_4=wg_get_field(db, arec, (signed long int)j);
              return_value_wg_compare_5=wg_compare(db, return_value_wg_get_field_4, arg->value, 7);
              tmp_if_expr_6 = return_value_wg_compare_5;
            }
            if(tmp_if_expr_6 == 0l)
            {
              void *check_and_merge_by_key__1__1__2__1__1__1__1__doc;
              check_and_merge_by_key__1__1__2__1__1__1__1__doc=wg_find_document(db, rec);
              if(!(check_and_merge_by_key__1__1__2__1__1__1__1__doc == NULL))
              {
                signed long int return_value_append_resultset_2;
                return_value_append_resultset_2=append_resultset(db, next_set, (signed long int)((char *)check_and_merge_by_key__1__1__2__1__1__1__1__doc - (char *)((struct anonymous_6 *)db)->db));
                if(return_value_append_resultset_2 == 0l)
                  rc = (signed long int)1;

                else
                  rc = (signed long int)-1;
              }

              else
                rc=show_query_error(db, "Failed to retrieve the document");
              break;
            }

          }
        }

      }

    }
  }

  return rc;
}

// check_and_merge_by_kv
// file dbquery.c line 1645
static signed long int check_and_merge_by_kv(void *db, void *rec, struct anonymous_18 *arg, struct anonymous_17 *next_set)
{
  signed long int rc = (signed long int)0;
  signed long int reclen;
  reclen=wg_get_record_len(db, rec);
  signed long int tmp_if_expr_13;
  signed long int return_value_wg_get_field_11;
  signed long int return_value_wg_compare_12;
  signed long int tmp_if_expr_9;
  signed long int return_value_wg_compare_8;
  signed long int return_value_wg_get_encoded_type_7;
  signed long int tmp_if_expr_6;
  signed long int return_value_wg_get_field_4;
  signed long int return_value_wg_compare_5;
  if(reclen >= 3l)
  {
    signed long int return_value_wg_get_field_10;
    return_value_wg_get_field_10=wg_get_field(db, rec, (signed long int)(0 + 1));
    if(return_value_wg_get_field_10 == arg->key)
      tmp_if_expr_13 = (signed long int)0;

    else
    {
      return_value_wg_get_field_11=wg_get_field(db, rec, (signed long int)(0 + 1));
      return_value_wg_compare_12=wg_compare(db, return_value_wg_get_field_11, arg->key, 7);
      tmp_if_expr_13 = return_value_wg_compare_12;
    }
    if(tmp_if_expr_13 == 0l)
    {
      signed long int k;
      k=wg_get_field(db, rec, (signed long int)(0 + 2));
      if(k == arg->value)
        tmp_if_expr_9 = (signed long int)0;

      else
      {
        return_value_wg_compare_8=wg_compare(db, k, arg->value, 7);
        tmp_if_expr_9 = return_value_wg_compare_8;
      }
      if(tmp_if_expr_9 == 0l)
      {
        void *doc;
        doc=wg_find_document(db, rec);
        if(!(doc == NULL))
        {
          signed long int return_value_append_resultset_1;
          return_value_append_resultset_1=append_resultset(db, next_set, (signed long int)((char *)doc - (char *)((struct anonymous_6 *)db)->db));
          if(return_value_append_resultset_1 == 0l)
            rc = (signed long int)1;

          else
            rc = (signed long int)-1;
        }

        else
          rc=show_query_error(db, "Failed to retrieve the document");
      }

      else
      {
        return_value_wg_get_encoded_type_7=wg_get_encoded_type(db, k);
        if(return_value_wg_get_encoded_type_7 == 2l)
        {
          void *arec;
          arec=wg_decode_record(db, k);
          if(!((64l & ((signed long int *)arec)[1l]) == 0l))
          {
            signed long int areclen;
            areclen=wg_get_record_len(db, arec);
            signed int j = 0;
            for( ; !((signed long int)j >= areclen); j = j + 1)
            {
              signed long int return_value_wg_get_field_3;
              return_value_wg_get_field_3=wg_get_field(db, arec, (signed long int)j);
              if(return_value_wg_get_field_3 == arg->value)
                tmp_if_expr_6 = (signed long int)0;

              else
              {
                return_value_wg_get_field_4=wg_get_field(db, arec, (signed long int)j);
                return_value_wg_compare_5=wg_compare(db, return_value_wg_get_field_4, arg->value, 7);
                tmp_if_expr_6 = return_value_wg_compare_5;
              }
              if(tmp_if_expr_6 == 0l)
              {
                void *check_and_merge_by_kv__1__1__1__2__1__1__1__1__doc;
                check_and_merge_by_kv__1__1__1__2__1__1__1__1__doc=wg_find_document(db, rec);
                if(!(check_and_merge_by_kv__1__1__1__2__1__1__1__1__doc == NULL))
                {
                  signed long int return_value_append_resultset_2;
                  return_value_append_resultset_2=append_resultset(db, next_set, (signed long int)((char *)check_and_merge_by_kv__1__1__1__2__1__1__1__1__doc - (char *)((struct anonymous_6 *)db)->db));
                  if(return_value_append_resultset_2 == 0l)
                    rc = (signed long int)1;

                  else
                    rc = (signed long int)-1;
                }

                else
                  rc=show_query_error(db, "Failed to retrieve the document");
                break;
              }

            }
          }

        }

      }
    }

  }

  return rc;
}

// check_and_merge_recursively
// file dbquery.c line 1718
static signed long int check_and_merge_recursively(void *db, void *rec, struct anonymous_18 *arg, struct anonymous_17 *next_set, signed int depth)
{
  signed long int i;
  signed long int reclen;
  signed long int rc;
  rc=check_and_merge_by_kv(db, rec, arg, next_set);
  if(!(rc == 0l))
    return rc;

  else
  {
    if(!(depth >= 1))
    {
      signed long int return_value_show_query_error_1;
      return_value_show_query_error_1=show_query_error(db, "scanning document: recursion too deep");
      return return_value_show_query_error_1;
    }

    reclen=wg_get_record_len(db, rec);
    i = (signed long int)0;
    for( ; !(i >= reclen); i = i + 1l)
    {
      signed long int enc;
      enc=wg_get_field(db, rec, i);
      signed long int type;
      type=wg_get_encoded_type(db, enc);
      if(type == 2l)
      {
        void *return_value_wg_decode_record_2;
        return_value_wg_decode_record_2=wg_decode_record(db, enc);
        rc=check_and_merge_recursively(db, return_value_wg_decode_record_2, arg, next_set, depth - 1);
        if(!(rc == 0l))
          return rc;

      }

    }
    return (signed long int)0;
  }
}

// check_arglist
// file dbquery.c line 285
static signed long int check_arglist(void *db, void *rec, struct anonymous_12 *arglist, signed long int argc)
{
  signed int i;
  signed int reclen;
  signed long int return_value_wg_get_record_len_1;
  return_value_wg_get_record_len_1=wg_get_record_len(db, rec);
  reclen = (signed int)return_value_wg_get_record_len_1;
  i = 0;
  signed long int tmp_if_expr_3;
  signed long int return_value_wg_compare_2;
  signed long int tmp_if_expr_5;
  signed long int return_value_wg_compare_4;
  signed long int tmp_if_expr_7;
  signed long int return_value_wg_compare_6;
  signed long int tmp_if_expr_9;
  signed long int return_value_wg_compare_8;
  signed long int tmp_if_expr_11;
  signed long int return_value_wg_compare_10;
  signed long int tmp_if_expr_13;
  signed long int return_value_wg_compare_12;
  for( ; !((signed long int)i >= argc); i = i + 1)
  {
    signed long int encoded;
    if(!((arglist + (signed long int)i)->column >= (signed long int)reclen))
      encoded=wg_get_field(db, rec, (arglist + (signed long int)i)->column);

    else
      return (signed long int)0;
    switch((arglist + (signed long int)i)->cond)
    {
      case (signed long int)0x0001:
      {
        if(encoded == (arglist + (signed long int)i)->value)
          tmp_if_expr_3 = (signed long int)0;

        else
        {
          return_value_wg_compare_2=wg_compare(db, encoded, (arglist + (signed long int)i)->value, 7);
          tmp_if_expr_3 = return_value_wg_compare_2;
        }
        if(!(tmp_if_expr_3 == 0l))
          return (signed long int)0;

        break;
      }
      case (signed long int)0x0004:
      {
        if(encoded == (arglist + (signed long int)i)->value)
          tmp_if_expr_5 = (signed long int)0;

        else
        {
          return_value_wg_compare_4=wg_compare(db, encoded, (arglist + (signed long int)i)->value, 7);
          tmp_if_expr_5 = return_value_wg_compare_4;
        }
        if(!(tmp_if_expr_5 == -1l))
          return (signed long int)0;

        break;
      }
      case (signed long int)0x0008:
      {
        if(encoded == (arglist + (signed long int)i)->value)
          tmp_if_expr_7 = (signed long int)0;

        else
        {
          return_value_wg_compare_6=wg_compare(db, encoded, (arglist + (signed long int)i)->value, 7);
          tmp_if_expr_7 = return_value_wg_compare_6;
        }
        if(!(tmp_if_expr_7 == 1l))
          return (signed long int)0;

        break;
      }
      case (signed long int)0x0010:
      {
        if(encoded == (arglist + (signed long int)i)->value)
          tmp_if_expr_9 = (signed long int)0;

        else
        {
          return_value_wg_compare_8=wg_compare(db, encoded, (arglist + (signed long int)i)->value, 7);
          tmp_if_expr_9 = return_value_wg_compare_8;
        }
        if(tmp_if_expr_9 == 1l)
          return (signed long int)0;

        break;
      }
      case (signed long int)0x0020:
      {
        if(encoded == (arglist + (signed long int)i)->value)
          tmp_if_expr_11 = (signed long int)0;

        else
        {
          return_value_wg_compare_10=wg_compare(db, encoded, (arglist + (signed long int)i)->value, 7);
          tmp_if_expr_11 = return_value_wg_compare_10;
        }
        if(tmp_if_expr_11 == -1l)
          return (signed long int)0;

        break;
      }
      case (signed long int)0x0002:
      {
        if(encoded == (arglist + (signed long int)i)->value)
          tmp_if_expr_13 = (signed long int)0;

        else
        {
          return_value_wg_compare_12=wg_compare(db, encoded, (arglist + (signed long int)i)->value, 7);
          tmp_if_expr_13 = return_value_wg_compare_12;
        }
        if(tmp_if_expr_13 == 0l)
          return (signed long int)0;

        break;
      }
      default:
        ;
    }
  }
  return (signed long int)1;
}

// check_data
// file stresstest.c line 201
void check_data(void *db, signed int wcnt)
{
  void *rec;
  rec=wg_get_first_record(db);
  signed int cksum;
  if(rec == NULL)
    fprintf(stderr, "Database check failed: first record not found.\n");

  else
  {
    signed long int return_value_wg_get_field_1;
    return_value_wg_get_field_1=wg_get_field(db, rec, (signed long int)0);
    signed long int return_value_wg_decode_int_2;
    return_value_wg_decode_int_2=wg_decode_int(db, return_value_wg_get_field_1);
    cksum = (signed int)return_value_wg_decode_int_2;
    if(!(cksum == 100000 * wcnt))
      fprintf(stderr, "Database check failed: bad checksum (%d != %d).\n", cksum, wcnt * 100000);

  }
}

// check_pop_cb
// file dbjson.c line 434
static signed int check_pop_cb(void *cb_ctx)
{
  signed int *depth = (signed int *)cb_ctx;
  *depth = *depth - 1;
  return 1;
}

// check_push_cb
// file dbjson.c line 424
static signed int check_push_cb(void *cb_ctx)
{
  signed int *depth = (signed int *)cb_ctx;
  if(*depth == -1)
    *depth = 0;

  *depth = *depth + 1;
  if(*depth >= 7)
    return 0;

  else
    return 1;
}

// create_hash_index
// file dbindex.c line 1608
static signed long int create_hash_index(void *db, signed long int index_id)
{
  unsigned int rowsprocessed;
  void *rec;
  struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + index_id);
  signed long int type = hdr->type;
  signed long int firstcol = hdr->rec_field_index[(signed long int)0];
  signed long int i;
  signed long int return_value_wg_create_hash_1;
  return_value_wg_create_hash_1=wg_create_hash(db, &hdr->ctl.h.hasharea, (signed long int)0);
  signed long int tmp_if_expr_4;
  signed long int return_value_wg_match_template_3;
  if(!(return_value_wg_create_hash_1 == 0l))
    return (signed long int)-1;

  else
  {
    rec=wg_get_first_record(db);
    rowsprocessed = (unsigned int)0;
    while(!(rec == NULL))
    {
      signed long int return_value_wg_get_record_len_2;
      return_value_wg_get_record_len_2=wg_get_record_len(db, rec);
      if(firstcol >= return_value_wg_get_record_len_2)
        rec=wg_get_next_record(db, rec);

      else
      {
        if(!(hdr->template_offset == 0l))
        {
          return_value_wg_match_template_3=wg_match_template(db, (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + hdr->template_offset), rec);
          tmp_if_expr_4 = return_value_wg_match_template_3;
        }

        else
          tmp_if_expr_4 = (signed long int)1;
        if(!(tmp_if_expr_4 == 0l))
        {
          if(type == 61l)
          {
            if(((signed long int *)rec)[1l] == 0l)
            {
              hash_add_row(db, index_id, rec);
              rowsprocessed = rowsprocessed + 1u;
            }

          }

          else
          {
            hash_add_row(db, index_id, rec);
            rowsprocessed = rowsprocessed + 1u;
          }
        }

        rec=wg_get_next_record(db, rec);
      }
    }
    fprintf(stderr, "new hash index created on (");
    i = (signed long int)0;
    for( ; !(i >= hdr->fields); i = i + 1l)
      fprintf(stderr, "%s%td", i != 0l ? "," : "", hdr->rec_field_index[i]);
    fprintf(stderr, ") into slot %d and %d data rows inserted\n", (signed int)index_id, rowsprocessed);
    return (signed long int)0;
  }
}

// create_resultset
// file dbquery.c line 1341
static struct anonymous_17 * create_resultset(void *db)
{
  struct anonymous_17 *set;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_17) /*56ul*/ );
  set = (struct anonymous_17 *)return_value_malloc_1;
  if(set == ((struct anonymous_17 *)NULL))
  {
    show_query_error(db, "Failed to allocate result set");
    return (struct anonymous_17 *)(void *)0;
  }

  else
  {
    set->rcursor.page = (struct __query_result_page *)(void *)0;
    set->rcursor.pidx = (signed long int)0;
    set->wcursor.page = (struct __query_result_page *)(void *)0;
    set->wcursor.pidx = (signed long int)63;
    set->first_page = (struct __query_result_page *)(void *)0;
    set->res_count = (signed long int)0;
    set->mpool=wg_create_mpool(db, (signed int)sizeof(struct __query_result_page) /*512ul*/ );
    if(set->mpool == NULL)
    {
      show_query_error(db, "Failed to allocate result memory pool");
      free((void *)set);
      return (struct anonymous_17 *)(void *)0;
    }

    else
      return set;
  }
}

// create_shared_memory
// file dbmem.c line 723
static void * create_shared_memory(signed int key, signed long int size, signed int mode)
{
  void *shm;
  signed int shmflg;
  signed int shmid;
  shmflg = 01000 | 02000 | mode;
  shmid=shmget((signed int)key, (unsigned long int)size, shmflg);
  if(!(shmid >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    switch(*return_value___errno_location_1)
    {
      case 17:
      {
        show_memory_error("creating shared memory segment: Race condition detected when initializing");
        break;
      }
      case 22:
      {
        show_memory_error("creating shared memory segment: Specified segment size too large or too small");
        break;
      }
      case 12:
      {
        show_memory_error("creating shared memory segment: Not enough physical memory");
        break;
      }
      default:
        show_memory_error("creating shared memory segment failed");
    }
    return (void *)0;
  }

  shm=shmat(shmid, (void *)0, 0);
  if((char *)shm == (char *)-1)
  {
    show_memory_error("attaching shared memory segment failed");
    return (void *)0;
  }

  else
    return (void *)shm;
}

// create_ttree_index
// file dbindex.c line 1370
static signed long int create_ttree_index(void *db, signed long int index_id)
{
  signed long int node;
  unsigned int rowsprocessed;
  struct wg_tnode *nodest;
  void *rec;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + index_id);
  signed long int column = hdr->rec_field_index[(signed long int)0];
  node=wg_alloc_fixlen_object(db, (void *)&dbh->tnode_area_header);
  nodest = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + node);
  nodest->parent_offset = (signed long int)0;
  nodest->left_subtree_height = (unsigned char)0;
  nodest->right_subtree_height = (unsigned char)0;
  nodest->current_max = (signed long int)0xff;
  nodest->current_min = (signed long int)0xff;
  nodest->number_of_elements = (signed short int)0;
  nodest->left_child_offset = (signed long int)0;
  nodest->right_child_offset = (signed long int)0;
  nodest->succ_offset = (signed long int)0;
  nodest->pred_offset = (signed long int)0;
  hdr->ctl.t.offset_root_node = node;
  hdr->ctl.t.offset_min_node = node;
  hdr->ctl.t.offset_max_node = node;
  rec=wg_get_first_record(db);
  rowsprocessed = (unsigned int)0;
  signed long int tmp_if_expr_3;
  signed long int return_value_wg_match_template_2;
  while(!(rec == NULL))
  {
    signed long int return_value_wg_get_record_len_1;
    return_value_wg_get_record_len_1=wg_get_record_len(db, rec);
    if(column >= return_value_wg_get_record_len_1)
      rec=wg_get_next_record(db, rec);

    else
    {
      if(!(hdr->template_offset == 0l))
      {
        return_value_wg_match_template_2=wg_match_template(db, (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + hdr->template_offset), rec);
        tmp_if_expr_3 = return_value_wg_match_template_2;
      }

      else
        tmp_if_expr_3 = (signed long int)1;
      if(!(tmp_if_expr_3 == 0l))
      {
        ttree_add_row(db, index_id, rec);
        rowsprocessed = rowsprocessed + 1u;
      }

      rec=wg_get_next_record(db, rec);
    }
  }
  fprintf(stderr, "new index created on rec field %d into slot %d and %d data rows inserted\n", (signed int)column, (signed int)index_id, rowsprocessed);
  return (signed long int)0;
}

// csv_escaped_str
// file dbutil.c line 310
static void csv_escaped_str(void *db, char *iptr, char *buf, signed int buflen)
{
  char *optr;
  char *tmp_post_1;
  char *tmp_post_2;
  char *tmp_post_4;
  char *tmp_post_3;
  char *tmp_post_5;
  if(!(buflen >= 3))
    show_io_error(db, "CSV field buffer too small");

  else
  {
    optr = buf;
    tmp_post_1 = optr;
    optr = optr + 1l;
    *tmp_post_1 = (char)34;
    buflen = buflen - 1;
    while(!(*iptr == 0))
    {
      signed int nextsz = 1;
      if((signed int)*iptr == 34)
        nextsz = nextsz + 1;

      if(!((signed long int)optr + (signed long int)nextsz + -((signed long int)buf) >= (signed long int)buflen))
      {
        tmp_post_2 = optr;
        optr = optr + 1l;
        *tmp_post_2 = *iptr;
        tmp_post_4 = iptr;
        iptr = iptr + 1l;
        if((signed int)*tmp_post_4 == 34)
        {
          tmp_post_3 = optr;
          optr = optr + 1l;
          *tmp_post_3 = (char)34;
        }

      }

      else
        break;
    }
    tmp_post_5 = optr;
    optr = optr + 1l;
    *tmp_post_5 = (char)34;
    *optr = (char)0;
  }
}

// db_rotate_ttree
// file dbindex.c line 208
static signed int db_rotate_ttree(void *db, signed long int index_id, struct wg_tnode *root, signed int overw)
{
  signed long int grandparent = root->parent_offset;
  signed long int initialrootoffset = (signed long int)((char *)root - (char *)((struct anonymous_6 *)db)->db);
  struct wg_tnode *r = (struct wg_tnode *)(void *)0;
  struct wg_tnode *g = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + grandparent);
  struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + index_id);
  signed long int column = hdr->rec_field_index[(signed long int)0];
  signed int tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_5;
  signed int tmp_if_expr_6;
  if(overw == 0)
  {
    signed long int offset_left_child = root->left_child_offset;
    signed long int offset_right_grandchild = ((struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + offset_left_child))->right_child_offset;
    signed long int right_grandchild_height = (signed long int)((struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + offset_left_child))->right_subtree_height;
    root->left_child_offset = offset_right_grandchild;
    root->left_subtree_height = (unsigned char)right_grandchild_height;
    if(!(offset_right_grandchild == 0l))
      ((struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + offset_right_grandchild))->parent_offset = (signed long int)((char *)root - (char *)((struct anonymous_6 *)db)->db);

    ((struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + offset_left_child))->right_child_offset = (signed long int)((char *)root - (char *)((struct anonymous_6 *)db)->db);
    if(!((signed int)root->right_subtree_height >= (signed int)root->left_subtree_height))
      tmp_if_expr_1 = (signed int)root->left_subtree_height;

    else
      tmp_if_expr_1 = (signed int)root->right_subtree_height;
    ((struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + offset_left_child))->right_subtree_height = (unsigned char)(tmp_if_expr_1 + 1);
    root->parent_offset = offset_left_child;
    r = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + offset_left_child);
  }

  else
    if(overw == 3)
    {
      signed long int db_rotate_ttree__1__2__offset_right_child = root->right_child_offset;
      signed long int db_rotate_ttree__1__2__offset_left_grandchild = ((struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + db_rotate_ttree__1__2__offset_right_child))->left_child_offset;
      signed long int left_grandchild_height = (signed long int)((struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + db_rotate_ttree__1__2__offset_right_child))->left_subtree_height;
      root->right_child_offset = db_rotate_ttree__1__2__offset_left_grandchild;
      root->right_subtree_height = (unsigned char)left_grandchild_height;
      if(!(db_rotate_ttree__1__2__offset_left_grandchild == 0l))
        ((struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + db_rotate_ttree__1__2__offset_left_grandchild))->parent_offset = (signed long int)((char *)root - (char *)((struct anonymous_6 *)db)->db);

      ((struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + db_rotate_ttree__1__2__offset_right_child))->left_child_offset = (signed long int)((char *)root - (char *)((struct anonymous_6 *)db)->db);
      if(!((signed int)root->left_subtree_height >= (signed int)root->right_subtree_height))
        tmp_if_expr_2 = (signed int)root->right_subtree_height;

      else
        tmp_if_expr_2 = (signed int)root->left_subtree_height;
      ((struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + db_rotate_ttree__1__2__offset_right_child))->left_subtree_height = (unsigned char)(tmp_if_expr_2 + 1);
      root->parent_offset = db_rotate_ttree__1__2__offset_right_child;
      r = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + db_rotate_ttree__1__2__offset_right_child);
    }

    else
      if(overw == 1)
      {
        struct wg_tnode *bb;
        struct wg_tnode *ee;
        signed long int db_rotate_ttree__1__3__offset_left_child = root->left_child_offset;
        signed long int db_rotate_ttree__1__3__offset_right_grandchild = ((struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + db_rotate_ttree__1__3__offset_left_child))->right_child_offset;
        ee = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + db_rotate_ttree__1__3__offset_right_grandchild);
        root->left_child_offset = ee->right_child_offset;
        root->left_subtree_height = ee->right_subtree_height;
        if(!(ee->right_child_offset == 0l))
          ((struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + ee->right_child_offset))->parent_offset = (signed long int)((char *)root - (char *)((struct anonymous_6 *)db)->db);

        bb = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + db_rotate_ttree__1__3__offset_left_child);
        bb->right_child_offset = ee->left_child_offset;
        bb->right_subtree_height = ee->left_subtree_height;
        if(!(ee->left_child_offset == 0l))
          ((struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + ee->left_child_offset))->parent_offset = db_rotate_ttree__1__3__offset_left_child;

        if((signed int)ee->number_of_elements == 1)
        {
          if(ee->right_child_offset == 0l)
          {
            if(ee->left_child_offset == 0l)
            {
              if((signed int)bb->number_of_elements == 8)
              {
                signed int db_rotate_ttree__1__3__3__i;
                ee->array_of_values[(signed long int)((signed int)bb->number_of_elements - 1)] = ee->array_of_values[(signed long int)0];
                db_rotate_ttree__1__3__3__i = 1;
                for( ; !(db_rotate_ttree__1__3__3__i >= (signed int)bb->number_of_elements); db_rotate_ttree__1__3__3__i = db_rotate_ttree__1__3__3__i + 1)
                  ee->array_of_values[(signed long int)(db_rotate_ttree__1__3__3__i - 1)] = bb->array_of_values[(signed long int)db_rotate_ttree__1__3__3__i];
                ee->number_of_elements = bb->number_of_elements;
                ee->current_min=wg_get_field(db, (void *)((char *)((struct anonymous_6 *)db)->db + ee->array_of_values[(signed long int)0]), column);
                bb->number_of_elements = (signed short int)1;
                bb->current_max = bb->current_min;
              }

            }

          }

        }

        ee->left_child_offset = db_rotate_ttree__1__3__offset_left_child;
        if(!((signed int)bb->left_subtree_height >= (signed int)bb->right_subtree_height))
          tmp_if_expr_3 = (signed int)bb->right_subtree_height;

        else
          tmp_if_expr_3 = (signed int)bb->left_subtree_height;
        ee->left_subtree_height = (unsigned char)(tmp_if_expr_3 + 1);
        bb->parent_offset = db_rotate_ttree__1__3__offset_right_grandchild;
        ee->right_child_offset = (signed long int)((char *)root - (char *)((struct anonymous_6 *)db)->db);
        if(!((signed int)root->left_subtree_height >= (signed int)root->right_subtree_height))
          tmp_if_expr_4 = (signed int)root->right_subtree_height;

        else
          tmp_if_expr_4 = (signed int)root->left_subtree_height;
        ee->right_subtree_height = (unsigned char)(tmp_if_expr_4 + 1);
        root->parent_offset = db_rotate_ttree__1__3__offset_right_grandchild;
        r = ee;
      }

      else
        if(overw == 2)
        {
          struct wg_tnode *db_rotate_ttree__1__4__bb;
          struct wg_tnode *db_rotate_ttree__1__4__ee;
          signed long int offset_right_child = root->right_child_offset;
          signed long int offset_left_grandchild = ((struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + offset_right_child))->left_child_offset;
          db_rotate_ttree__1__4__ee = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + offset_left_grandchild);
          root->right_child_offset = db_rotate_ttree__1__4__ee->left_child_offset;
          root->right_subtree_height = db_rotate_ttree__1__4__ee->left_subtree_height;
          if(!(db_rotate_ttree__1__4__ee->left_child_offset == 0l))
            ((struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + db_rotate_ttree__1__4__ee->left_child_offset))->parent_offset = (signed long int)((char *)root - (char *)((struct anonymous_6 *)db)->db);

          db_rotate_ttree__1__4__bb = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + offset_right_child);
          db_rotate_ttree__1__4__bb->left_child_offset = db_rotate_ttree__1__4__ee->right_child_offset;
          db_rotate_ttree__1__4__bb->left_subtree_height = db_rotate_ttree__1__4__ee->right_subtree_height;
          if(!(db_rotate_ttree__1__4__ee->right_child_offset == 0l))
            ((struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + db_rotate_ttree__1__4__ee->right_child_offset))->parent_offset = offset_right_child;

          if((signed int)db_rotate_ttree__1__4__ee->number_of_elements == 1)
          {
            if(db_rotate_ttree__1__4__ee->right_child_offset == 0l)
            {
              if(db_rotate_ttree__1__4__ee->left_child_offset == 0l)
              {
                if((signed int)db_rotate_ttree__1__4__bb->number_of_elements == 8)
                {
                  signed int i = 1;
                  for( ; !(i >= (signed int)db_rotate_ttree__1__4__bb->number_of_elements); i = i + 1)
                    db_rotate_ttree__1__4__ee->array_of_values[(signed long int)i] = db_rotate_ttree__1__4__bb->array_of_values[(signed long int)(i - 1)];
                  db_rotate_ttree__1__4__ee->number_of_elements = db_rotate_ttree__1__4__bb->number_of_elements;
                  db_rotate_ttree__1__4__ee->current_max=wg_get_field(db, (void *)((char *)((struct anonymous_6 *)db)->db + db_rotate_ttree__1__4__ee->array_of_values[(signed long int)((signed int)db_rotate_ttree__1__4__ee->number_of_elements - 1)]), column);
                  db_rotate_ttree__1__4__bb->array_of_values[(signed long int)0] = db_rotate_ttree__1__4__bb->array_of_values[(signed long int)((signed int)db_rotate_ttree__1__4__bb->number_of_elements - 1)];
                  db_rotate_ttree__1__4__bb->number_of_elements = (signed short int)1;
                  db_rotate_ttree__1__4__bb->current_min = db_rotate_ttree__1__4__bb->current_max;
                }

              }

            }

          }

          db_rotate_ttree__1__4__ee->right_child_offset = offset_right_child;
          if(!((signed int)db_rotate_ttree__1__4__bb->left_subtree_height >= (signed int)db_rotate_ttree__1__4__bb->right_subtree_height))
            tmp_if_expr_5 = (signed int)db_rotate_ttree__1__4__bb->right_subtree_height;

          else
            tmp_if_expr_5 = (signed int)db_rotate_ttree__1__4__bb->left_subtree_height;
          db_rotate_ttree__1__4__ee->right_subtree_height = (unsigned char)(tmp_if_expr_5 + 1);
          db_rotate_ttree__1__4__bb->parent_offset = offset_left_grandchild;
          db_rotate_ttree__1__4__ee->left_child_offset = (signed long int)((char *)root - (char *)((struct anonymous_6 *)db)->db);
          if(!((signed int)root->left_subtree_height >= (signed int)root->right_subtree_height))
            tmp_if_expr_6 = (signed int)root->right_subtree_height;

          else
            tmp_if_expr_6 = (signed int)root->left_subtree_height;
          db_rotate_ttree__1__4__ee->left_subtree_height = (unsigned char)(tmp_if_expr_6 + 1);
          root->parent_offset = offset_left_grandchild;
          r = db_rotate_ttree__1__4__ee;
        }

        else
        {
          show_index_error(db, "tree rotate called with invalid argument, index may have become corrupt");
          return -1;
        }
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_8;
  if(grandparent == 0l)
  {
    r->parent_offset = (signed long int)0;
    hdr->ctl.t.offset_root_node = (signed long int)((char *)r - (char *)((struct anonymous_6 *)db)->db);
  }

  else
  {
    r->parent_offset = grandparent;
    if(g->left_child_offset == initialrootoffset)
    {
      g->left_child_offset = (signed long int)((char *)r - (char *)((struct anonymous_6 *)db)->db);
      if(!((signed int)r->right_subtree_height >= (signed int)r->left_subtree_height))
        tmp_if_expr_7 = (signed int)r->left_subtree_height;

      else
        tmp_if_expr_7 = (signed int)r->right_subtree_height;
      g->left_subtree_height = (unsigned char)(tmp_if_expr_7 + 1);
    }

    else
    {
      g->right_child_offset = (signed long int)((char *)r - (char *)((struct anonymous_6 *)db)->db);
      if(!((signed int)r->right_subtree_height >= (signed int)r->left_subtree_height))
        tmp_if_expr_8 = (signed int)r->left_subtree_height;

      else
        tmp_if_expr_8 = (signed int)r->right_subtree_height;
      g->right_subtree_height = (unsigned char)(tmp_if_expr_8 + 1);
    }
  }
  return 0;
}

// db_tfqueue_rlock
// file dblock.h line 137
signed long int db_tfqueue_rlock(void *db, signed long int timeout)
{
  struct timespec ts;
  signed long int lock;
  signed long int prev;
  struct anonymous_5 *lockp;
  struct _db_memsegment_header *dbh;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
  {
    show_lock_error(db, "Invalid database pointer in db_rlock");
    return (signed long int)0;
  }

  else
  {
    dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
    lock_queue(db);
    lock=alloc_lock(db);
    if(lock == 0l)
    {
      unlock_queue(db);
      show_lock_error(db, "Failed to allocate lock");
      return (signed long int)0;
    }

    else
    {
      prev = dbh->locks.tail;
      dbh->locks.tail = lock;
      lockp = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + lock);
      lockp->class = (signed long int)0x02;
      lockp->prev = prev;
      lockp->next = (volatile signed long int)0;
      if(!(prev == 0l))
      {
        struct anonymous_5 *prevp = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + prev);
        prevp->next = lock;
        if(prevp->class == 2l)
          tmp_if_expr_2 = prevp->waiting == (signed long int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          lockp->waiting = (volatile signed long int)0;

        else
          lockp->waiting = (volatile signed long int)1;
      }

      else
        lockp->waiting = (volatile signed long int)0;
      unlock_queue(db);
      if(!(lockp->waiting == 0l))
      {
        volatile signed long int *syn_addr = (volatile signed long int *)(void *)0;
        ts.tv_sec = timeout / (signed long int)1000;
        ts.tv_nsec = timeout % (signed long int)1000;
        signed int return_value_futex_trywait_3;
        return_value_futex_trywait_3=futex_trywait(&lockp->waiting, 1, &ts);
        if(return_value_futex_trywait_3 == 110)
        {
          lock_queue(db);
          if(!(lockp->prev == 0l))
          {
            struct anonymous_5 *pp = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + lockp->prev);
            pp->next = lockp->next;
          }

          if(!(lockp->next == 0l))
          {
            struct anonymous_5 *np = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + lockp->next);
            np->prev = lockp->prev;
          }

          else
            if(dbh->locks.tail == lock)
              dbh->locks.tail = lockp->prev;

          free_lock(db, lock);
          unlock_queue(db);
          return (signed long int)0;
        }

        lock_queue(db);
        if(!(lockp->next == 0l))
        {
          struct anonymous_5 *nextp = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + lockp->next);
          if(nextp->class == 2l)
          {
            if(!(nextp->waiting == 0l))
            {
              nextp->waiting = (volatile signed long int)0;
              syn_addr = &nextp->waiting;
            }

          }

        }

        unlock_queue(db);
        if(!(syn_addr == ((volatile signed long int *)NULL)))
          futex_wake(syn_addr, 1);

      }

      return lock;
    }
  }
}

// db_tfqueue_rulock
// file dblock.h line 143
signed long int db_tfqueue_rulock(void *db, signed long int lock)
{
  struct anonymous_5 *lockp;
  struct _db_memsegment_header *dbh;
  volatile signed long int *syn_addr = (volatile signed long int *)(void *)0;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
  {
    show_lock_error(db, "Invalid database pointer in db_rulock");
    return (signed long int)0;
  }

  else
  {
    dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
    lockp = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + lock);
    lock_queue(db);
    if(!(lockp->prev == 0l))
    {
      struct anonymous_5 *prevp = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + lockp->prev);
      prevp->next = lockp->next;
    }

    if(!(lockp->next == 0l))
    {
      struct anonymous_5 *nextp = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + lockp->next);
      nextp->prev = lockp->prev;
      if(!(nextp->waiting == 0l))
      {
        if(lockp->prev == 0l)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = nextp->class == (signed long int)0x02 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
        {
          nextp->waiting = (volatile signed long int)0;
          syn_addr = &nextp->waiting;
        }

      }

    }

    else
      if(dbh->locks.tail == lock)
        dbh->locks.tail = lockp->prev;

    free_lock(db, lock);
    unlock_queue(db);
    if(!(syn_addr == ((volatile signed long int *)NULL)))
      futex_wake(syn_addr, 1);

    return (signed long int)1;
  }
}

// db_tfqueue_wlock
// file dblock.c line 984
signed long int db_tfqueue_wlock(void *db, signed long int timeout)
{
  struct timespec ts;
  signed long int lock;
  signed long int prev;
  struct anonymous_5 *lockp;
  struct _db_memsegment_header *dbh;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_lock_error(db, "Invalid database pointer in db_wlock");
    return (signed long int)0;
  }

  else
  {
    dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
    lock_queue(db);
    lock=alloc_lock(db);
    if(lock == 0l)
    {
      unlock_queue(db);
      show_lock_error(db, "Failed to allocate lock");
      return (signed long int)0;
    }

    else
    {
      prev = dbh->locks.tail;
      dbh->locks.tail = lock;
      lockp = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + lock);
      lockp->class = (signed long int)0x04;
      lockp->prev = prev;
      lockp->next = (volatile signed long int)0;
      if(!(prev == 0l))
      {
        struct anonymous_5 *prevp = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + prev);
        prevp->next = lock;
        lockp->waiting = (volatile signed long int)1;
      }

      else
        lockp->waiting = (volatile signed long int)0;
      unlock_queue(db);
      if(!(lockp->waiting == 0l))
      {
        ts.tv_sec = timeout / (signed long int)1000;
        ts.tv_nsec = timeout % (signed long int)1000;
        signed int return_value_futex_trywait_2;
        return_value_futex_trywait_2=futex_trywait(&lockp->waiting, 1, &ts);
        if(return_value_futex_trywait_2 == 110)
        {
          lock_queue(db);
          if(!(lockp->prev == 0l))
          {
            struct anonymous_5 *pp = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + lockp->prev);
            pp->next = lockp->next;
          }

          if(!(lockp->next == 0l))
          {
            struct anonymous_5 *np = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + lockp->next);
            np->prev = lockp->prev;
          }

          else
            if(dbh->locks.tail == lock)
              dbh->locks.tail = lockp->prev;

          free_lock(db, lock);
          unlock_queue(db);
          return (signed long int)0;
        }

      }

      return lock;
    }
  }
}

// db_tfqueue_wulock
// file dblock.c line 1053
signed long int db_tfqueue_wulock(void *db, signed long int lock)
{
  struct anonymous_5 *lockp;
  struct _db_memsegment_header *dbh;
  volatile signed long int *syn_addr = (volatile signed long int *)(void *)0;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_lock_error(db, "Invalid database pointer in db_wulock");
    return (signed long int)0;
  }

  else
  {
    dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
    lockp = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + lock);
    lock_queue(db);
    if(!(lockp->next == 0l))
    {
      struct anonymous_5 *nextp = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + lockp->next);
      nextp->waiting = (volatile signed long int)0;
      nextp->prev = (volatile signed long int)0;
      syn_addr = &nextp->waiting;
    }

    else
      if(dbh->locks.tail == lock)
        dbh->locks.tail = (signed long int)0;

    free_lock(db, lock);
    unlock_queue(db);
    if(!(syn_addr == ((volatile signed long int *)NULL)))
      futex_wake(syn_addr, 1);

    return (signed long int)1;
  }
}

// db_which_branch_causes_overweight
// file dbindex.c line 195
static signed int db_which_branch_causes_overweight(void *db, struct wg_tnode *root)
{
  struct wg_tnode *child;
  if(!((signed int)root->right_subtree_height >= (signed int)root->left_subtree_height))
  {
    child = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + root->left_child_offset);
    if((signed int)child->left_subtree_height >= (signed int)child->right_subtree_height)
      return 0;

    else
      return 1;
  }

  else
  {
    child = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + root->right_child_offset);
    if(!((signed int)child->right_subtree_height >= (signed int)child->left_subtree_height))
      return 2;

    else
      return 3;
  }
}

// delete_from_list
// file dbindex.c line 1736
static void delete_from_list(void *db, signed long int *head)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  struct anonymous_20 *listelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *head);
  *head = listelem->cdr;
  wg_free_fixlen_object(db, &dbh->listcell_area_header, (signed long int)((char *)listelem - (char *)((struct anonymous_6 *)db)->db));
}

// delete_record_recursive
// file dbschema.c line 233
static signed long int delete_record_recursive(void *db, void *rec, signed int depth)
{
  signed long int i;
  signed long int reclen;
  if(!(depth >= 1))
  {
    signed long int return_value_show_schema_error_1;
    return_value_show_schema_error_1=show_schema_error(db, "deleting record: recursion too deep");
    return return_value_show_schema_error_1;
  }

  reclen=wg_get_record_len(db, rec);
  i = (signed long int)0;
  for( ; !(i >= reclen); i = i + 1l)
  {
    signed long int enc;
    enc=wg_get_field(db, rec, i);
    signed long int type;
    type=wg_get_encoded_type(db, enc);
    if(type == 2l)
    {
      signed long int return_value_wg_set_field_2;
      return_value_wg_set_field_2=wg_set_field(db, rec, i, (signed long int)0);
      if(!(return_value_wg_set_field_2 == 0l))
        return (signed long int)-1;

      void *return_value_wg_decode_record_3;
      return_value_wg_decode_record_3=wg_decode_record(db, enc);
      signed long int return_value_delete_record_recursive_4;
      return_value_delete_record_recursive_4=delete_record_recursive(db, return_value_wg_decode_record_3, depth - 1);
      if(!(return_value_delete_record_recursive_4 == 0l))
        return (signed long int)-1;

    }

  }
  signed long int return_value_wg_delete_record_5;
  return_value_wg_delete_record_5=wg_delete_record(db, rec);
  if(!(return_value_wg_delete_record_5 == 0l))
    return (signed long int)-1;

  else
    return (signed long int)0;
}

// detach_shared_memory
// file dbmem.c line 849
static signed int detach_shared_memory(void *shmptr)
{
  signed int tmp;
  tmp=shmdt(shmptr);
  if(tmp == -1)
  {
    show_memory_error("detaching shared memory segment failed");
    return -2;
  }

  else
    return 0;
}

// dhash_lookup
// file dbhash.c line 878
static signed long int * dhash_lookup(struct anonymous_36 *tbl, signed long int key)
{
  signed long int h;
  h=rehash_gint(key);
  unsigned long int sz = tbl->dhash_size;
  unsigned long int h1 = (unsigned long int)h % sz;
  unsigned long int h2;
  unsigned long int i;
  signed long int *bb = tbl->keys;
  signed long int *b = bb + (signed long int)h1;
  _Bool tmp_if_expr_1;
  if(*b == key)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = *b == (signed long int)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    return b;

  else
  {
    h2 = (unsigned long int)1 + (unsigned long int)h % (sz - (unsigned long int)1);
    i = (unsigned long int)1;
    for( ; !(i >= sz); i = i + 1ul)
    {
      b = bb + (signed long int)((h1 + i * h2) % sz);
      if(*b == key)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = *b == (signed long int)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        break;

    }
    return b;
  }
}

// dhash_size
// file dbhash.c line 844
static unsigned long int dhash_size(unsigned long int entries)
{
  unsigned long int primes[25l] = { 389UL, 769UL, 1543UL, 3079UL, 6151UL, 12289UL, 24593UL, 49157UL, 98317UL, 196613UL, 393241UL, 786433UL, 1572869UL, 3145739UL, 6291469UL, 12582917UL, 25165843UL, 50331653UL, 100663319UL, 201326611UL, 402653189UL, 805306457UL, 1610612741UL, 3221225473UL, 4294967291UL };
  const unsigned long int p_count = (const unsigned long int)20;
  unsigned long int wantsize = entries << 1;
  unsigned long int i;
  if(entries >= 2147483646ul)
    return (unsigned long int)0;

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= p_count + 18446744073709551615ul); i = i + 1ul)
      if(!(wantsize >= primes[(signed long int)i]))
        break;

    return primes[(signed long int)i];
  }
}

// drop_hash_index
// file dbindex.c line 1677
static signed long int drop_hash_index(void *db, signed long int index_id)
{
  show_index_error(db, "Cannot drop hash index: not implemented");
  return (signed long int)-1;
}

// drop_ttree_index
// file dbindex.c line 1432
static signed long int drop_ttree_index(void *db, signed long int index_id)
{
  struct wg_tnode *node;
  struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + index_id);
  node = (struct wg_tnode *)(void *)0;
  if(!(hdr->ctl.t.offset_min_node == 0l))
    node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + hdr->ctl.t.offset_min_node);

  else
    if(!(hdr->ctl.t.offset_root_node == 0l))
      node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + hdr->ctl.t.offset_root_node);

  while(!(node == ((struct wg_tnode *)NULL)))
  {
    signed long int deleteme = (signed long int)((char *)node - (char *)((struct anonymous_6 *)db)->db);
    if(!(node->succ_offset == 0l))
      node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + node->succ_offset);

    else
      node = (struct wg_tnode *)(void *)0;
    wg_free_tnode(db, deleteme);
  }
  return (signed long int)0;
}

// elem_double_cb
// file dbjson.c line 656
static signed int elem_double_cb(void *cb_ctx, double doubleval)
{
  signed long int val;
  struct anonymous_0 *ctx = (struct anonymous_0 *)cb_ctx;
  val=wg_encode_double(ctx->db, doubleval);
  if(val == 255l)
    return 0;

  else
  {
    signed int return_value_add_literal_1;
    return_value_add_literal_1=add_literal(ctx, val);
    if(return_value_add_literal_1 == 0)
      return 0;

    else
      return 1;
  }
}

// elem_integer_cb
// file dbjson.c line 641
static signed int elem_integer_cb(void *cb_ctx, signed long long int intval)
{
  signed long int val;
  struct anonymous_0 *ctx = (struct anonymous_0 *)cb_ctx;
  val=wg_encode_int(ctx->db, (signed long int)intval);
  if(val == 255l)
    return 0;

  else
  {
    signed int return_value_add_literal_1;
    return_value_add_literal_1=add_literal(ctx, val);
    if(return_value_add_literal_1 == 0)
      return 0;

    else
      return 1;
  }
}

// elem_string_cb
// file dbjson.c line 692
static signed int elem_string_cb(void *cb_ctx, const unsigned char *strval, unsigned long int strl)
{
  signed int res = 1;
  signed long int val;
  struct anonymous_0 *ctx = (struct anonymous_0 *)cb_ctx;
  char *buf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(strl + (unsigned long int)1);
  buf = (char *)return_value_malloc_1;
  signed int return_value_add_literal_2;
  if(buf == ((char *)NULL))
    return 0;

  else
  {
    strncpy(buf, (char *)strval, strl);
    buf[(signed long int)strl] = (char)0;
    val=wg_encode_str(ctx->db, buf, (char *)(void *)0);
    if(val == 255l)
      res = 0;

    else
    {
      return_value_add_literal_2=add_literal(ctx, val);
      if(return_value_add_literal_2 == 0)
        res = 0;

    }
    free((void *)buf);
    return res;
  }
}

// encode_query_param_unistr
// file dbquery.c line 1217
static signed long int encode_query_param_unistr(void *db, char *data, signed long int type, char *extdata, signed int length)
{
  void *dptr;
  if(extdata == ((char *)NULL) && type == 5l)
  {
    dptr=malloc((unsigned long int)(length + 1));
    if(dptr == NULL)
    {
      show_query_error(db, "Failed to encode query parameter");
      return (signed long int)0xff;
    }

    memcpy((void *)(char *)dptr, (const void *)data, (unsigned long int)length);
    ((char *)dptr)[(signed long int)length] = (char)0;
    return (signed long int)((char *)dptr - (char *)((struct anonymous_6 *)db)->db) | (signed long int)0x6;
  }

  else
  {
    unsigned long int i;
    signed int extlen = 0;
    signed int dlen;
    signed int lengints;
    signed int lenrest;
    signed long int offset;
    signed long int meta;
    if(!(type == 8l))
      length = length + 1;

    lengints = (signed int)((unsigned long int)length / sizeof(signed long int) /*8ul*/ );
    lenrest = (signed int)((unsigned long int)length % sizeof(signed long int) /*8ul*/ );
    if(!(lenrest == 0))
      lengints = lengints + 1;

    dlen = (signed int)(sizeof(signed long int) /*8ul*/  * (unsigned long int)(6 + lengints));
    if(!((signed long int)dlen >= (signed long int)(sizeof(signed long int) * 4) /*32l*/ ))
      dlen = (signed int)((signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/ );

    if(!(dlen % 8 == 0))
      dlen = dlen + 4;

    if(!(extdata == ((char *)NULL)))
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(extdata);
      extlen = (signed int)return_value_strlen_1;
    }

    dptr=malloc((unsigned long int)(dlen + (extdata != ((char *)NULL) ? extlen + 1 : 0)));
    if(dptr == NULL)
    {
      show_query_error(db, "Failed to encode query parameter");
      return (signed long int)0xff;
    }

    offset = (signed long int)((char *)dptr - (char *)((struct anonymous_6 *)db)->db);
    memcpy((void *)((char *)dptr + (signed long int)((unsigned long int)6 * sizeof(signed long int) /*8ul*/ )), (const void *)data, (unsigned long int)length);
    i = (unsigned long int)0;
    for( ; !(lenrest == 0) && !(i >= sizeof(signed long int) /*8ul*/  + -((unsigned long int)lenrest)); i = i + 1ul)
      ((char *)dptr + (signed long int)length + (signed long int)((unsigned long int)6 * sizeof(signed long int) /*8ul*/ ))[(signed long int)i] = (char)0;
    if(!(extdata == ((char *)NULL)))
    {
      signed long int extenc;
      void *extptr = (void *)((char *)dptr + (signed long int)dlen);
      memcpy(extptr, (const void *)extdata, (unsigned long int)extlen);
      ((char *)extptr)[(signed long int)extlen] = (char)0;
      extenc = (signed long int)((char *)extptr - (char *)((struct anonymous_6 *)db)->db) | (signed long int)0x6;
      *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + (unsigned long int)5 * sizeof(signed long int) /*8ul*/ ))) = extenc;
    }

    else
      *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + (unsigned long int)5 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)0;
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + offset)) = (signed long int)dlen;
    meta = (signed long int)(dlen - length << 8);
    meta = meta | type;
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + (unsigned long int)1 * sizeof(signed long int) /*8ul*/ ))) = meta;
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)0;
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + (unsigned long int)3 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)0;
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + (unsigned long int)4 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)0;
    return offset | (signed long int)0x4;
  }
}

// extend_fixedlen_area
// file dballoc.c line 751
static signed long int extend_fixedlen_area(void *db, void *area_header)
{
  signed long int i;
  signed long int tmp;
  signed long int size;
  signed long int newsize;
  struct _db_area_header *areah = (struct _db_area_header *)area_header;
  i = areah->last_subarea_index;
  if(1l + i >= 64l)
  {
    show_dballoc_error_nr(db, " no more subarea array elements available for fixedlen of size: ", areah->objlength);
    return (signed long int)0;
  }

  else
  {
    size = areah->subarea_array[i].size;
    newsize = size << 1;
    while(newsize >= 8192l)
    {
      signed long int return_value_init_db_subarea_1;
      return_value_init_db_subarea_1=init_db_subarea(db, (void *)areah, i + (signed long int)1, newsize);
      if(return_value_init_db_subarea_1 == 0l)
        goto done;

      newsize = newsize >> 1;
    }
    show_dballoc_error_nr(db, " cannot extend datarec area with a new subarea of size: ", newsize << 1);
    return (signed long int)0;

  done:
    ;
    tmp=make_subarea_freelist(db, (void *)areah, i + (signed long int)1);
    if(!(tmp == 0l))
    {
      show_dballoc_error(db, " cannot initialize new subarea");
      return (signed long int)0;
    }

    else
      return newsize;
  }
}

// extend_mpool
// file dbmpool.c line 156
static signed int extend_mpool(void *db, void *mpool, signed int minbytes)
{
  signed int cursize;
  signed int bytes;
  void *subarea;
  struct anonymous_8 *mpoolh;
  signed int i;
  void *nextptr;
  mpoolh = (struct anonymous_8 *)mpool;
  cursize = mpoolh->subarea_table[(signed long int)mpoolh->cur_subarea].size;
  bytes = cursize;
  i = 0;
  for( ; !(i >= 100); i = i + 1)
  {
    bytes = bytes * 2;
    if(bytes >= 4 + minbytes)
      break;

  }
  subarea=malloc((unsigned long int)bytes);
  if(subarea == NULL)
  {
    show_mpool_error_nr(db, " cannot extend mpool to size: ", minbytes);
    return -1;
  }

  else
  {
    mpoolh->freeptr = subarea;
    mpoolh->cur_subarea = mpoolh->cur_subarea + 1;
    mpoolh->subarea_table[(signed long int)mpoolh->cur_subarea].size = bytes;
    nextptr = subarea;
    i = (signed int)((unsigned long int)nextptr % (unsigned long int)4);
    if(!(i == 0))
      nextptr = (void *)((char *)nextptr + (signed long int)(4 - i));

    mpoolh->freeptr = nextptr;
    mpoolh->subarea_table[(signed long int)mpoolh->cur_subarea].area_start = subarea;
    mpoolh->subarea_table[(signed long int)mpoolh->cur_subarea].area_end = (void *)((char *)subarea + (signed long int)bytes);
    return 0;
  }
}

// extend_varlen_area
// file dballoc.c line 1003
static signed long int extend_varlen_area(void *db, void *area_header, signed long int minbytes)
{
  signed long int i;
  signed long int tmp;
  signed long int size;
  signed long int minsize;
  signed long int newsize;
  struct _db_area_header *areah = (struct _db_area_header *)area_header;
  i = areah->last_subarea_index;
  if(1l + i >= 64l)
  {
    show_dballoc_error_nr(db, " no more subarea array elements available for datarec: ", i);
    return (signed long int)0;
  }

  else
  {
    size = areah->subarea_array[i].size;
    minsize = minbytes + (signed long int)8 + (signed long int)2 * (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/ ;
    if(!(minsize >= 0l))
    {
      show_dballoc_error_nr(db, "invalid number of bytes requested: ", minbytes);
      return (signed long int)0;
    }

    else
    {
      if(!(minsize >= 8192l))
        minsize = (signed long int)8192;

      newsize = size << 1;
      for( ; newsize >= 0l && !(newsize >= minsize); newsize = newsize << 1)
        ;
      while(newsize >= minsize)
      {
        signed long int return_value_init_db_subarea_1;
        return_value_init_db_subarea_1=init_db_subarea(db, (void *)areah, i + (signed long int)1, newsize);
        if(return_value_init_db_subarea_1 == 0l)
          goto done;

        newsize = newsize >> 1;
      }
      show_dballoc_error_nr(db, " cannot extend datarec area with a new subarea of size: ", newsize << 1);
      return (signed long int)0;

    done:
      ;
      tmp=init_subarea_freespace(db, (void *)areah, i + (signed long int)1);
      if(!(tmp == 0l))
      {
        show_dballoc_error(db, " cannot initialize new subarea");
        return (signed long int)0;
      }

      else
        return newsize;
    }
  }
}

// fetch_resultset
// file dbquery.c line 1419
static signed long int fetch_resultset(void *db, struct anonymous_17 *set)
{
  signed long int tmp_post_1;
  if(!(set->rcursor.page == ((struct __query_result_page *)NULL)))
  {
    signed long int offset;
    tmp_post_1 = set->rcursor.pidx;
    set->rcursor.pidx = set->rcursor.pidx + 1l;
    offset = set->rcursor.page->rows[tmp_post_1];
    if(offset == 0l)
      set->rcursor.page = (struct __query_result_page *)(void *)0;

    else
      if(set->rcursor.pidx >= 63l)
      {
        set->rcursor.page = set->rcursor.page->next;
        set->rcursor.pidx = (signed long int)0;
      }

    return offset;
  }

  return (signed long int)0;
}

// find_create_longstr
// file dbdata.c line 2579
static signed long int find_create_longstr(void *db, char *data, char *extrastr, signed long int type, signed long int length)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int offset;
  unsigned long int i;
  signed long int tmp;
  signed long int lengints;
  signed long int lenrest;
  char *lstrptr;
  signed long int old = (signed long int)0;
  signed int hash;
  signed long int hasharrel;
  signed long int res;
  signed long int tmp_if_expr_2;
  signed long int tmp_if_expr_1;
  hash=wg_hash_typedstr(db, data, extrastr, type, length);
  hasharrel = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)dbh->strhash_area_header.arraystart + sizeof(signed long int) /*8ul*/  * (unsigned long int)hash)));
  if(!(hasharrel == 0l))
    old=wg_find_strhash_bucket(db, data, extrastr, type, length, hasharrel);

  if(!(old == 0l))
    return old;

  lengints = (signed long int)((unsigned long int)length / sizeof(signed long int) /*8ul*/ );
  lenrest = (signed long int)((unsigned long int)length % sizeof(signed long int) /*8ul*/ );
  if(!(lenrest == 0l))
    lengints = lengints + 1l;

  offset=wg_alloc_gints(db, (void *)&((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->longstr_area_header, lengints + (signed long int)6);
  if(offset == 0l)
    return (signed long int)0;

  lstrptr = (char *)(void *)((char *)((struct anonymous_6 *)db)->db + offset);
  memcpy((void *)(lstrptr + (signed long int)((unsigned long int)6 * sizeof(signed long int) /*8ul*/ )), (const void *)data, (unsigned long int)length);
  i = (unsigned long int)0;
  for( ; !(lenrest == 0l) && !(i >= sizeof(signed long int) /*8ul*/  + -((unsigned long int)lenrest)); i = i + 1ul)
    (lstrptr + length + (signed long int)((unsigned long int)6 * sizeof(signed long int) /*8ul*/ ))[(signed long int)i] = (char)0;
  if(!(extrastr == ((char *)NULL)))
  {
    tmp=wg_encode_str(db, extrastr, (char *)(void *)0);
    if(tmp == 255l)
      return (signed long int)0;

    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + (unsigned long int)5 * sizeof(signed long int) /*8ul*/ ))) = tmp;
    if((7l & tmp) == 4l)
    {
      signed long int *strptr = (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + (tmp & (signed long int)~0x7));
      strptr[(signed long int)2] = strptr[(signed long int)2] + 1l;
    }

  }

  else
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + (unsigned long int)5 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)0;
  if(!((-4l & *((signed long int *)lstrptr)) >= 33l))
    tmp_if_expr_2 = (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/ ;

  else
  {
    if(!((-4l & *((signed long int *)lstrptr)) % 8l == 0l))
      tmp_if_expr_1 = (*((signed long int *)lstrptr) & (signed long int)~3) + (signed long int)4;

    else
      tmp_if_expr_1 = *((signed long int *)lstrptr) & (signed long int)~3;
    tmp_if_expr_2 = tmp_if_expr_1;
  }
  tmp = tmp_if_expr_2 - length << 8;
  tmp = tmp | type;
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + (unsigned long int)1 * sizeof(signed long int) /*8ul*/ ))) = tmp;
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)0;
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + (unsigned long int)3 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)0;
  res = offset | (signed long int)0x4;
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)dbh->strhash_area_header.arraystart + sizeof(signed long int) /*8ul*/  * (unsigned long int)hash))) = res;
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + (unsigned long int)4 * sizeof(signed long int) /*8ul*/ ))) = hasharrel;
  return res;
}

// find_document_recursive
// file dbschema.c line 186
static void * find_document_recursive(void *db, signed long int *rec, signed int depth)
{
  if(!((16l & rec[1l]) == 0l))
    return (void *)rec;

  else
  {
    if(depth >= 1)
    {
      signed long int backlink_list = rec[(signed long int)2];
      if(!(backlink_list == 0l))
      {
        struct anonymous_20 *next = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + backlink_list);
        do
        {
          void *res;
          res=find_document_recursive(db, (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + next->car), depth - 1);
          if(!(res == NULL))
            return res;

          if(next->cdr == 0l)
            break;

          next = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + next->cdr);
        }
        while((_Bool)1);
      }

    }

    return (void *)0;
  }
}

// find_idxhash_bucket
// file dbhash.c line 407
static signed long int find_idxhash_bucket(void *db, char *data, signed long int length, signed long int *chainoffset)
{
  signed long int bucket = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + *chainoffset));
  while(!(bucket == 0l))
  {
    signed long int meta = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)bucket + (unsigned long int)1 * sizeof(signed long int) /*8ul*/ )));
    if(meta == length)
    {
      char *bucket_data = (char *)(void *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)bucket + (unsigned long int)4 * sizeof(signed long int) /*8ul*/ ));
      signed int return_value_memcmp_1;
      return_value_memcmp_1=memcmp((const void *)bucket_data, (const void *)data, (unsigned long int)length);
      if(return_value_memcmp_1 == 0)
        return bucket;

    }

    *chainoffset = (signed long int)((unsigned long int)bucket + (unsigned long int)3 * sizeof(signed long int) /*8ul*/ );
    bucket = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + *chainoffset));
  }
  return (signed long int)0;
}

// find_index_template
// file dbindex.c line 1858
static signed long int find_index_template(void *db, signed long int *matchrec, signed long int reclen)
{
  signed long int *ilist;
  void *rec;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  struct anonymous_22 *tmpl;
  signed long int fixed_columns = (signed long int)0;
  signed long int last_fixed = (signed long int)0;
  signed int i = 0;
  for( ; !((signed long int)i >= reclen); i = i + 1)
  {
    signed long int type;
    type=wg_get_encoded_type(db, matchrec[(signed long int)i]);
    if(type == 2l)
    {
      show_index_error(db, "record links not allowed in index templates");
      return (signed long int)0;
    }

    if(!(type == 14l))
    {
      fixed_columns = fixed_columns + 1l;
      last_fixed = (signed long int)i;
    }

  }
  signed long int tmp_if_expr_5;
  signed long int return_value_wg_get_field_3;
  signed long int return_value_wg_compare_4;
  if(fixed_columns == 0l)
  {
    show_index_error(db, "not a legal match record");
    return (signed long int)0;
  }

  else
  {
    reclen = last_fixed + (signed long int)1;
    ilist = &dbh->index_control_area_header.index_template_list;
    while(!(*ilist == 0l))
    {
      struct anonymous_20 *ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
      if(ilistelem->car == 0l)
      {
        show_index_error(db, "Invalid header in index tempate list");
        return (signed long int)0;
      }

      tmpl = (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + ilistelem->car);
      if(tmpl->fixed_columns == fixed_columns)
      {
        rec = (void *)((char *)((struct anonymous_6 *)db)->db + tmpl->offset_matchrec);
        signed long int return_value_wg_get_record_len_1;
        return_value_wg_get_record_len_1=wg_get_record_len(db, rec);
        if(!(reclen == return_value_wg_get_record_len_1))
          goto nextelem;

        i = 0;
        for( ; !((signed long int)i >= reclen); i = i + 1)
        {
          signed long int return_value_wg_get_encoded_type_6;
          return_value_wg_get_encoded_type_6=wg_get_encoded_type(db, matchrec[(signed long int)i]);
          if(!(return_value_wg_get_encoded_type_6 == 14l))
          {
            signed long int return_value_wg_get_field_2;
            return_value_wg_get_field_2=wg_get_field(db, rec, (signed long int)i);
            if(matchrec[(signed long int)i] == return_value_wg_get_field_2)
              tmp_if_expr_5 = (signed long int)0;

            else
            {
              return_value_wg_get_field_3=wg_get_field(db, rec, (signed long int)i);
              return_value_wg_compare_4=wg_compare(db, matchrec[(signed long int)i], return_value_wg_get_field_3, 7);
              tmp_if_expr_5 = return_value_wg_compare_4;
            }
            if(!(tmp_if_expr_5 == 0l))
              goto nextelem;

          }

        }
        return ilistelem->car;
      }

      else
        if(!(tmpl->fixed_columns >= fixed_columns))
          break;


    nextelem:
      ;
      ilist = &ilistelem->cdr;
    }
    return (signed long int)0;
  }
}

// find_ttree_bounds
// file dbquery.c line 445
static signed long int find_ttree_bounds(void *db, signed long int index_id, signed long int col, signed long int start_bound, signed long int end_bound, signed long int start_inclusive, signed long int end_inclusive, signed long int *curr_offset, signed long int *curr_slot, signed long int *end_offset, signed long int *end_slot)
{
  signed long int co = *curr_offset;
  signed long int cs = *curr_slot;
  signed long int eo = *end_offset;
  signed long int es = *end_slot;
  struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + index_id);
  struct wg_tnode *node;
  if(start_bound == 255l)
  {
    co = hdr->ctl.t.offset_min_node;
    cs = (signed long int)0;
  }

  else
  {
    signed long int boundtype;
    if(!(start_inclusive == 0l))
    {
      co=wg_search_ttree_leftmost(db, hdr->ctl.t.offset_root_node, start_bound, &boundtype, (struct wg_tnode *)(void *)0);
      if(boundtype == 0l)
      {
        cs=wg_search_tnode_first(db, co, start_bound, col);
        if(cs == -1l)
        {
          show_query_error(db, "Starting index node was bad");
          return (signed long int)-1;
        }

      }

      else
        if(boundtype == 2l)
        {
          node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + co);
          co = node->succ_offset;
          cs = (signed long int)0;
        }

        else
          if(boundtype == 1l)
            cs = (signed long int)0;

    }

    else
    {
      co=wg_search_ttree_rightmost(db, hdr->ctl.t.offset_root_node, start_bound, &boundtype, (struct wg_tnode *)(void *)0);
      if(boundtype == 0l)
      {
        cs=wg_search_tnode_last(db, co, start_bound, col);
        if(cs == -1l)
        {
          show_query_error(db, "Starting index node was bad");
          return (signed long int)-1;
        }

        cs = cs + 1l;
        node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + co);
        if(cs >= (signed long int)node->number_of_elements)
        {
          co = node->succ_offset;
          cs = (signed long int)0;
        }

      }

      else
        if(boundtype == 2l)
        {
          node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + co);
          co = node->succ_offset;
          cs = (signed long int)0;
        }

        else
          if(boundtype == 1l)
            cs = (signed long int)0;

    }
  }
  if(end_bound == 255l)
  {
    eo = hdr->ctl.t.offset_max_node;
    if(!(eo == 0l))
    {
      node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + eo);
      es = (signed long int)((signed int)node->number_of_elements - 1);
    }

  }

  else
  {
    signed long int find_ttree_bounds__1__4__boundtype;
    if(!(end_inclusive == 0l))
    {
      eo=wg_search_ttree_rightmost(db, hdr->ctl.t.offset_root_node, end_bound, &find_ttree_bounds__1__4__boundtype, (struct wg_tnode *)(void *)0);
      if(find_ttree_bounds__1__4__boundtype == 0l)
      {
        es=wg_search_tnode_last(db, eo, end_bound, col);
        if(es == -1l)
        {
          show_query_error(db, "Ending index node was bad");
          return (signed long int)-1;
        }

      }

      else
        if(find_ttree_bounds__1__4__boundtype == 2l)
        {
          node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + eo);
          es = (signed long int)((signed int)node->number_of_elements - 1);
        }

        else
          if(find_ttree_bounds__1__4__boundtype == 1l)
          {
            node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + eo);
            eo = node->pred_offset;
            if(!(eo == 0l))
            {
              node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + eo);
              es = (signed long int)((signed int)node->number_of_elements - 1);
            }

          }

    }

    else
    {
      eo=wg_search_ttree_leftmost(db, hdr->ctl.t.offset_root_node, end_bound, &find_ttree_bounds__1__4__boundtype, (struct wg_tnode *)(void *)0);
      if(find_ttree_bounds__1__4__boundtype == 0l)
      {
        es=wg_search_tnode_first(db, eo, end_bound, col);
        if(es == -1l)
        {
          show_query_error(db, "Ending index node was bad");
          return (signed long int)-1;
        }

        es = es - 1l;
        if(!(es >= 0l))
        {
          node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + eo);
          eo = node->pred_offset;
          if(!(eo == 0l))
          {
            node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + eo);
            es = (signed long int)((signed int)node->number_of_elements - 1);
          }

        }

      }

      else
        if(find_ttree_bounds__1__4__boundtype == 2l)
        {
          node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + eo);
          es = (signed long int)((signed int)node->number_of_elements - 1);
        }

        else
          if(find_ttree_bounds__1__4__boundtype == 1l)
          {
            node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + eo);
            eo = node->pred_offset;
            if(!(eo == 0l))
            {
              node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + eo);
              es = (signed long int)((signed int)node->number_of_elements - 1);
            }

          }

    }
  }
  if(!(co == 0l))
  {
    if(eo == co && !(es >= cs))
    {
      co = (signed long int)0;
      eo = (signed long int)0;
    }

    else
      if(eo == 0l)
        co = (signed long int)0;

      else
      {
        node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + co);
        if(eo == node->pred_offset)
        {
          co = (signed long int)0;
          eo = (signed long int)0;
        }

      }
  }

  else
    eo = (signed long int)0;
  *curr_offset = co;
  *curr_slot = cs;
  *end_offset = eo;
  *end_slot = es;
  return (signed long int)0;
}

// fread_csv
// file dbutil.c line 702
static signed long int fread_csv(void *db, struct _IO_FILE *f)
{
  char *strbuf;
  char *ptr;
  signed long int *encdata;
  signed long int err = (signed long int)0;
  signed long int uq_field;
  signed long int quoted_field;
  signed long int esc_quote;
  signed long int eat_sep;
  signed long int commit_strbuf;
  signed long int commit_record;
  signed long int reclen;
  signed long int encdata_sz = (signed long int)10;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)4096);
  strbuf = (char *)return_value_malloc_1;
  signed int return_value_feof_3;
  char *tmp_post_6;
  char *tmp_post_7;
  char *tmp_post_8;
  signed long int tmp_post_10;
  if(strbuf == ((char *)NULL))
  {
    show_io_error(db, "Failed to allocate memory");
    return (signed long int)-1;
  }

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(signed long int) /*8ul*/  * (unsigned long int)encdata_sz);
    encdata = (signed long int *)return_value_malloc_2;
    if(strbuf == ((char *)NULL))
    {
      free((void *)strbuf);
      show_io_error(db, "Failed to allocate memory");
      return (signed long int)-1;
    }

    else
    {
      reclen = (signed long int)0;
      eat_sep = (signed long int)0;
      esc_quote = eat_sep;
      quoted_field = esc_quote;
      uq_field = quoted_field;
      commit_record = (signed long int)0;
      commit_strbuf = commit_record;
      ptr = strbuf;
      do
      {
        return_value_feof_3=feof(f);
        if(!(return_value_feof_3 == 0))
          break;

        char c;
        signed int return_value_fgetc_4;
        return_value_fgetc_4=fgetc(f);
        c = (char)return_value_fgetc_4;
        if(!(quoted_field == 0l))
        {
          if(esc_quote == 0l && (signed int)c == 34)
          {
            char nextc;
            signed int return_value_fgetc_5;
            return_value_fgetc_5=fgetc(f);
            nextc = (char)return_value_fgetc_5;
            ungetc((signed int)nextc, f);
            if(!((signed int)nextc == 34))
            {
              quoted_field = (signed long int)0;
              commit_strbuf = (signed long int)1;
              eat_sep = (signed long int)1;
            }

            else
              esc_quote = (signed long int)1;
          }

          else
          {
            esc_quote = (signed long int)0;
            if(!((signed long int)ptr + -((signed long int)strbuf) >= 4095l))
            {
              tmp_post_6 = ptr;
              ptr = ptr + 1l;
              *tmp_post_6 = c;
            }

          }
        }

        else
          if(!(uq_field == 0l))
          {
            if((signed int)c == 44)
            {
              uq_field = (signed long int)0;
              commit_strbuf = (signed long int)1;
            }

            else
              if((signed int)c == 13)
                continue;

              else
                if((signed int)c == 10)
                {
                  uq_field = (signed long int)0;
                  commit_strbuf = (signed long int)1;
                  commit_record = (signed long int)1;
                }

                else
                  if(!((signed long int)ptr + -((signed long int)strbuf) >= 4095l))
                  {
                    tmp_post_7 = ptr;
                    ptr = ptr + 1l;
                    *tmp_post_7 = c;
                  }

          }

          else
            if((signed int)c == 44)
            {
              if(!(eat_sep == 0l))
              {
                eat_sep = (signed long int)0;
                continue;
              }

              else
                commit_strbuf = (signed long int)1;
            }

            else
              if((signed int)c == 13)
                continue;

              else
                if((signed int)c == 10)
                {
                  if(!(eat_sep == 0l))
                    eat_sep = (signed long int)0;

                  else
                    if(!(reclen == 0l))
                      commit_strbuf = (signed long int)1;

                  commit_record = (signed long int)1;
                }

                else
                  if((signed int)c == 34)
                    quoted_field = (signed long int)1;

                  else
                  {
                    uq_field = (signed long int)1;
                    tmp_post_8 = ptr;
                    ptr = ptr + 1l;
                    *tmp_post_8 = c;
                  }
        if(!(commit_strbuf == 0l))
        {
          signed long int enc;
          *ptr = (char)0;
          commit_strbuf = (signed long int)0;
          ptr = strbuf;
          if(reclen >= encdata_sz)
          {
            signed long int *tmp;
            encdata_sz = encdata_sz + (signed long int)10;
            void *return_value_realloc_9;
            return_value_realloc_9=realloc((void *)encdata, sizeof(signed long int) /*8ul*/  * (unsigned long int)encdata_sz);
            tmp = (signed long int *)return_value_realloc_9;
            if(tmp == ((signed long int *)NULL))
            {
              err = (signed long int)-3;
              show_io_error(db, "Failed to allocate memory");
              break;
            }

            else
              encdata = tmp;
          }

          enc=wg_parse_and_encode(db, strbuf);
          if(enc == 255l)
          {
            show_io_error_str(db, "Warning: failed to parse", strbuf);
            enc = (signed long int)0;
          }

          tmp_post_10 = reclen;
          reclen = reclen + 1l;
          encdata[tmp_post_10] = enc;
        }

        if(!(commit_record == 0l))
        {
          signed int i;
          void *rec;
          commit_record = (signed long int)0;
          if(reclen == 0l)
            continue;

          rec=wg_create_record(db, reclen);
          if(rec == NULL)
          {
            err = (signed long int)-2;
            show_io_error(db, "Failed to create record");
            break;
          }

          i = 0;
          for( ; !((signed long int)i >= reclen); i = i + 1)
          {
            signed long int return_value_wg_set_field_11;
            return_value_wg_set_field_11=wg_set_field(db, rec, (signed long int)i, encdata[(signed long int)i]);
            if(!(return_value_wg_set_field_11 == 0l))
            {
              err = (signed long int)-2;
              show_io_error(db, "Failed to save field data");
              break;
            }

          }
          reclen = (signed long int)0;
        }

      }
      while((_Bool)1);
      free((void *)encdata);
      free((void *)strbuf);
      return err;
    }
  }
}

// free_dbhandle
// file dbmem.c line 450
static void free_dbhandle(void *dbhandle)
{
  free(dbhandle);
}

// free_field_encoffset
// file dbdata.c line 1221
static signed long int free_field_encoffset(void *db, signed long int encoffset)
{
  signed long int offset;
  signed long int tmp;
  signed long int *objptr;
  signed long int *extrastr;
  switch(encoffset & (signed long int)0x7)
  {
    case (signed long int)0x0:
      break;
    case (signed long int)0x4:
    {
      offset = encoffset & (signed long int)~0x7;
      tmp = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + sizeof(signed long int) /*8ul*/  * (unsigned long int)2)));
      tmp = tmp - 1l;
      if(tmp >= 1l)
        *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + sizeof(signed long int) /*8ul*/  * (unsigned long int)2))) = tmp;

      else
      {
        objptr = (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + offset);
        extrastr = (signed long int *)((char *)objptr + (signed long int)(sizeof(signed long int) /*8ul*/  * (unsigned long int)5));
        tmp = *extrastr;
        wg_remove_from_strhash(db, encoffset);
        if(!(tmp == 0l))
          free_field_encoffset(db, tmp);

        *extrastr = (signed long int)0;
        wg_free_object(db, (void *)&((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->longstr_area_header, offset);
      }
      break;
    }
    case (signed long int)0x6:
    {
      wg_free_shortstr(db, encoffset & (signed long int)~0x7);
      break;
    }
    case (signed long int)0x2:
    {
      wg_free_doubleword(db, encoffset & (signed long int)~0x7);
      break;
    }
    case (signed long int)0x1:
    {
      wg_free_word(db, encoffset & (signed long int)~0x3);
      break;
    }
    case (signed long int)0x5:
      wg_free_word(db, encoffset & (signed long int)~0x3);
  }
  return (signed long int)0;
}

// free_lock
// file dblock.c line 1392
static void free_lock(void *db, signed long int node)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  struct anonymous_5 *tmp = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + node);
  tmp->next_cell = dbh->locks.freelist;
  dbh->locks.freelist = node;
}

// free_resultset
// file dbquery.c line 1368
static void free_resultset(void *db, struct anonymous_17 *set)
{
  if(!(set->mpool == NULL))
    wg_free_mpool(db, set->mpool);

  free((void *)set);
}

// free_shared_memory
// file dbmem.c line 801
static signed int free_shared_memory(signed int key)
{
  signed int shmflg;
  signed int shmid;
  signed int tmp;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  shmflg = 0666;
  shmid=shmget((signed int)key, (unsigned long int)0, shmflg);
  if(!(shmid >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    switch(*return_value___errno_location_2)
    {
      case 13:
      {
        show_memory_error("linking to shared memory segment (for freeing): Access denied");
        break;
      }
      case 2:
      {
        show_memory_error("linking to shared memory segment (for freeing): Segment does not exist");
        break;
      }
      default:
        show_memory_error("linking to shared memory segment (for freeing) failed");
    }
    return -1;
  }

  tmp=shmctl(shmid, 0, (struct shmid_ds *)(void *)0);
  if(tmp == -1)
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    if(*return_value___errno_location_3 == 1)
    {
      show_memory_error("freeing shared memory segment: Permission denied");
      goto __CPROVER_DUMP_L8;
    }

    show_memory_error("freeing shared memory segment failed");

  __CPROVER_DUMP_L8:
    ;
    return -2;
  }

  return 0;
}

// futex_trywait
// file dblock.c line 1411
static signed int futex_trywait(volatile signed long int *addr1, signed int val1, struct timespec *timeout)
{
  signed long int return_value_syscall_2;
  return_value_syscall_2=syscall((signed long int)202, (void *)addr1, 0, val1, timeout);
  signed int *return_value___errno_location_1;
  if(return_value_syscall_2 == -1l)
  {
    return_value___errno_location_1=__errno_location();
    return *return_value___errno_location_1;
  }

  else
    return 0;
}

// futex_wake
// file dblock.c line 1420
static void futex_wake(volatile signed long int *addr1, signed int val1)
{
  syscall((signed long int)202, (void *)addr1, 1, val1);
}

// ginthash_newbucket
// file dbhash.c line 721
static struct anonymous_34 * ginthash_newbucket(void *db, struct anonymous_35 *tbl)
{
  struct anonymous_34 *bucket;
  void *return_value_wg_alloc_mpool_1;
  return_value_wg_alloc_mpool_1=wg_alloc_mpool(db, tbl->mpool, (signed int)sizeof(struct anonymous_34) /*144ul*/ );
  bucket = (struct anonymous_34 *)return_value_wg_alloc_mpool_1;
  if(!(bucket == ((struct anonymous_34 *)NULL)))
    bucket->fill = (signed long int)0;

  return bucket;
}

// ginthash_splitbucket
// file dbhash.c line 735
static struct anonymous_34 * ginthash_splitbucket(void *db, struct anonymous_35 *tbl, struct anonymous_34 *bucket)
{
  signed long int msbmask;
  signed long int lowbits;
  signed int i;
  struct anonymous_34 *newbucket;
  if(bucket->level == tbl->level)
  {
    signed long int return_value_grow_ginthash_1;
    return_value_grow_ginthash_1=grow_ginthash(db, (struct anonymous_35 *)tbl);
    if(!(return_value_grow_ginthash_1 == 0l))
      return (struct anonymous_34 *)(void *)0;

  }

  signed long int tmp_post_2 = bucket->level;
  bucket->level = bucket->level + 1l;
  msbmask = (signed long int)(1 << tmp_post_2);
  signed long int return_value_rehash_gint_3;
  return_value_rehash_gint_3=rehash_gint(bucket->key[(signed long int)0]);
  lowbits = return_value_rehash_gint_3 & msbmask - (signed long int)1;
  newbucket=ginthash_newbucket(db, tbl);
  if(newbucket == ((struct anonymous_34 *)NULL))
    return (struct anonymous_34 *)(void *)0;

  else
  {
    newbucket->level = bucket->level;
    i = (signed int)(bucket->fill - (signed long int)1);
    for( ; i >= 0; i = i - 1)
    {
      signed long int k_i = bucket->key[(signed long int)i];
      signed long int return_value_rehash_gint_5;
      return_value_rehash_gint_5=rehash_gint(k_i);
      if(!((return_value_rehash_gint_5 & msbmask) == 0l))
      {
        signed long int return_value_remove_from_bucket_4;
        return_value_remove_from_bucket_4=remove_from_bucket(bucket, i);
        add_to_bucket(newbucket, k_i, return_value_remove_from_bucket_4);
      }

    }
    if(bucket->level == tbl->level)
      tbl->directory[msbmask | lowbits] = newbucket;

    else
    {
      unsigned long int msbbuckets = (unsigned long int)(1 << tbl->level - bucket->level);
      unsigned long int j = (unsigned long int)0;
      for( ; !(j >= msbbuckets); j = j + 1ul)
      {
        unsigned long int k = j << bucket->level | (unsigned long int)msbmask | (unsigned long int)lowbits;
        if(!(tbl->directory[(signed long int)k] == bucket))
          return (struct anonymous_34 *)(void *)0;

        tbl->directory[(signed long int)k] = newbucket;
      }
    }
    return newbucket;
  }
}

// grow_ginthash
// file dbhash.c line 685
static signed long int grow_ginthash(void *db, struct anonymous_35 *tbl)
{
  void *tmp;
  signed long int newlevel = tbl->level + (signed long int)1;
  signed long int return_value_show_ginthash_error_1;
  if(newlevel >= 23l)
  {
    return_value_show_ginthash_error_1=show_ginthash_error(db, "Maximum level exceeded.");
    return return_value_show_ginthash_error_1;
  }

  else
  {
    tmp=realloc((void *)tbl->directory, (unsigned long int)(1 << newlevel) * sizeof(struct anonymous_34 *) /*8ul*/ );
    if(!(tmp == NULL))
    {
      tbl->directory = (struct anonymous_34 **)tmp;
      if(!(tbl->level == 0l))
      {
        unsigned long int i;
        unsigned long int dirsize = (unsigned long int)(1 << tbl->level);
        i = (unsigned long int)0;
        for( ; !(i >= dirsize); i = i + 1ul)
          tbl->directory[(signed long int)(dirsize + i)] = tbl->directory[(signed long int)i];
      }

      else
      {
        tmp=wg_create_mpool(db, (signed int)((unsigned long int)2 * sizeof(struct anonymous_34) /*144ul*/ ));
        if(!(tmp == NULL))
        {
          tbl->mpool = tmp;
          memset((void *)tbl->directory, 0, (unsigned long int)2 * sizeof(struct anonymous_34 *) /*8ul*/ );
        }

        else
        {
          signed long int return_value_show_ginthash_error_2;
          return_value_show_ginthash_error_2=show_ginthash_error(db, "Failed to allocate bucket pool.");
          return return_value_show_ginthash_error_2;
        }
      }
    }

    else
    {
      signed long int return_value_show_ginthash_error_3;
      return_value_show_ginthash_error_3=show_ginthash_error(db, "Failed to reallocate directory.");
      return return_value_show_ginthash_error_3;
    }
    tbl->level = newlevel;
    return (signed long int)0;
  }
}

// hash_add_row
// file dbindex.c line 1473
static signed long int hash_add_row(void *db, signed long int index_id, void *rec)
{
  struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + index_id);
  signed long int i;
  signed long int values[10l];
  i = (signed long int)0;
  for( ; !(i >= hdr->fields); i = i + 1l)
    values[i]=wg_get_field(db, rec, hdr->rec_field_index[i]);
  signed long int return_value_hash_recurse_1;
  return_value_hash_recurse_1=hash_recurse(db, hdr, (char *)(void *)0, (signed long int)0, values, hdr->fields, rec, (signed long int)1, (signed long int)(hdr->type == (signed long int)61));
  return return_value_hash_recurse_1;
}

// hash_bytes
// file dbhash.c line 389
static unsigned long int hash_bytes(void *db, char *data, signed long int length, signed long int hashsz)
{
  char *endp;
  unsigned long int hash = (unsigned long int)0;
  if(!(data == ((char *)NULL)))
  {
    endp = data + length;
    for( ; !(data >= endp); data = data + 1l)
      hash = ((unsigned long int)*data + (hash << 6) + (hash << 16)) - hash;
  }

  return hash % (unsigned long int)hashsz;
}

// hash_extend_prefix
// file dbindex.c line 1565
static signed long int hash_extend_prefix(void *db, struct anonymous_21 *hdr, char *prefix, signed long int prefixlen, signed long int nextval, signed long int *values, signed long int count, void *rec, signed long int op, signed long int expand)
{
  char *fldbytes;
  char *newprefix;
  signed long int newlen;
  signed long int fldlen;
  signed long int retv;
  fldlen=wg_decode_for_hashing(db, nextval, &fldbytes);
  if(!(fldlen >= 1l))
  {
    show_index_error(db, "Failed to decode a field value for hash");
    return (signed long int)-1;
  }

  else
  {
    if(!(prefix == ((char *)NULL)) && !(prefixlen == 0l))
      newlen = prefixlen + fldlen + (signed long int)1;

    else
      newlen = fldlen;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)newlen);
    newprefix = (char *)return_value_malloc_1;
    if(newprefix == ((char *)NULL))
    {
      free((void *)fldbytes);
      show_index_error(db, "Failed to allocate memory");
      return (signed long int)-1;
    }

    else
    {
      if(!(prefix == ((char *)NULL)))
      {
        memcpy((void *)newprefix, (const void *)prefix, (unsigned long int)prefixlen);
        newprefix[prefixlen] = (char)0;
      }

      memcpy((void *)(newprefix + (newlen - fldlen)), (const void *)fldbytes, (unsigned long int)fldlen);
      retv=hash_recurse(db, hdr, newprefix, newlen, values, count, rec, op, expand);
      free((void *)fldbytes);
      free((void *)newprefix);
      return retv;
    }
  }
}

// hash_recurse
// file dbindex.c line 1514
static signed long int hash_recurse(void *db, struct anonymous_21 *hdr, char *prefix, signed long int prefixlen, signed long int *values, signed long int count, void *rec, signed long int op, signed long int expand)
{
  if(!(count == 0l))
  {
    signed long int nextvalue = values[(signed long int)0];
    if(!(expand == 0l))
    {
      signed long int return_value_wg_get_encoded_type_2;
      return_value_wg_get_encoded_type_2=wg_get_encoded_type(db, nextvalue);
      if(return_value_wg_get_encoded_type_2 == 2l)
      {
        void *valrec;
        valrec=wg_decode_record(db, nextvalue);
        if(!((64l & ((signed long int *)valrec)[1l]) == 0l))
        {
          signed long int i;
          signed long int reclen;
          signed long int retv = (signed long int)0;
          reclen=wg_get_record_len(db, valrec);
          i = (signed long int)0;
          for( ; !(i >= reclen); i = i + 1l)
          {
            signed long int return_value_wg_get_field_1;
            return_value_wg_get_field_1=wg_get_field(db, valrec, i);
            retv=hash_extend_prefix(db, hdr, prefix, prefixlen, return_value_wg_get_field_1, &values[(signed long int)1], count - (signed long int)1, rec, op, expand);
            if(!(retv == 0l))
              break;

          }
          return retv;
        }

      }

    }

    signed long int return_value_hash_extend_prefix_3;
    return_value_hash_extend_prefix_3=hash_extend_prefix(db, hdr, prefix, prefixlen, nextvalue, &values[(signed long int)1], count - (signed long int)1, rec, op, expand);
    return return_value_hash_extend_prefix_3;
  }

  else
    if(op == 1l)
    {
      signed long int return_value_wg_idxhash_store_4;
      return_value_wg_idxhash_store_4=wg_idxhash_store(db, &hdr->ctl.h.hasharea, prefix, prefixlen, (signed long int)((char *)rec - (char *)((struct anonymous_6 *)db)->db));
      return return_value_wg_idxhash_store_4;
    }

    else
      if(op == 2l)
      {
        signed long int return_value_wg_idxhash_remove_5;
        return_value_wg_idxhash_remove_5=wg_idxhash_remove(db, &hdr->ctl.h.hasharea, prefix, prefixlen, (signed long int)((char *)rec - (char *)((struct anonymous_6 *)db)->db));
        return return_value_wg_idxhash_remove_5;
      }

      else
      {
        signed long int return_value_wg_idxhash_find_6;
        return_value_wg_idxhash_find_6=wg_idxhash_find(db, &hdr->ctl.h.hasharea, prefix, prefixlen);
        return return_value_wg_idxhash_find_6;
      }
  return (signed long int)0;
}

// hash_remove_row
// file dbindex.c line 1490
static signed long int hash_remove_row(void *db, signed long int index_id, void *rec)
{
  struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + index_id);
  signed long int i;
  signed long int values[10l];
  i = (signed long int)0;
  for( ; !(i >= hdr->fields); i = i + 1l)
    values[i]=wg_get_field(db, rec, hdr->rec_field_index[i]);
  signed long int return_value_hash_recurse_1;
  return_value_hash_recurse_1=hash_recurse(db, hdr, (char *)(void *)0, (signed long int)0, values, hdr->fields, rec, (signed long int)2, (signed long int)(hdr->type == (signed long int)61));
  return return_value_hash_recurse_1;
}

// hexToDigit
// file yajl_all.c line 400
static void hexToDigit(unsigned int *val, const unsigned char *hex)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= 4u); i = i + 1u)
  {
    unsigned char c = hex[(signed long int)i];
    if((signed int)c >= 65)
      c = (unsigned char)(((signed int)c & ~0x20) - 7);

    c = c - (unsigned char)48;
    /* assertion !(c & 0xF0) */
    assert(!(((signed int)c & 0xF0) != 0));
    *val = *val << 4 | (unsigned int)c;
  }
}

// init_area_buckets
// file dballoc.c line 608
static signed long int init_area_buckets(void *db, void *area_header)
{
  struct _db_area_header *areah;
  signed long int *freebuckets;
  signed long int i;
  areah = (struct _db_area_header *)area_header;
  freebuckets = areah->freebuckets;
  i = (signed long int)0;
  for( ; !(i >= 290l); i = i + 1l)
    freebuckets[i] = (signed long int)0;
  return (signed long int)0;
}

// init_db_index_area_header
// file dballoc.c line 386
static signed long int init_db_index_area_header(void *db)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  dbh->index_control_area_header.number_of_indexes = (signed long int)0;
  memset((void *)dbh->index_control_area_header.index_table, 0, (unsigned long int)(127 + 1) * sizeof(signed long int) /*8ul*/ );
  dbh->index_control_area_header.index_list = (signed long int)0;
  dbh->index_control_area_header.index_template_list = (signed long int)0;
  memset((void *)dbh->index_control_area_header.index_template_table, 0, (unsigned long int)(127 + 1) * sizeof(signed long int) /*8ul*/ );
  return (signed long int)0;
}

// init_db_recptr_bitmap
// file dballoc.c line 456
static signed long int init_db_recptr_bitmap(void *db)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  dbh->recptr_bitmap.offset = (signed long int)0;
  dbh->recptr_bitmap.size = (signed long int)0;
  return (signed long int)0;
}

// init_db_subarea
// file dballoc.c line 269
static signed long int init_db_subarea(void *db, void *area_header, signed long int index, signed long int size)
{
  struct _db_area_header *areah;
  signed long int segmentchunk;
  signed long int i;
  signed long int asize;
  if(!(size >= 8192l))
    return (signed long int)-1;

  else
  {
    segmentchunk=alloc_db_segmentchunk(db, size);
    if(segmentchunk == 0l)
      return (signed long int)-2;

    else
    {
      areah = (struct _db_area_header *)area_header;
      areah->subarea_array[index].size = size;
      areah->subarea_array[index].offset = segmentchunk;
      i = (signed long int)8 - segmentchunk % (signed long int)8;
      if(i == 8l)
        i = (signed long int)0;

      areah->subarea_array[index].alignedoffset = segmentchunk + i;
      asize = size - i;
      i = asize - asize % ((signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/ );
      areah->subarea_array[index].alignedsize = i;
      areah->last_subarea_index = index;
      areah->freelist = (signed long int)0;
      return (signed long int)0;
    }
  }
}

// init_dbhandle
// file dbmem.c line 433
static void * init_dbhandle(void)
{
  void *dbhandle;
  dbhandle=malloc(sizeof(struct anonymous_6) /*16ul*/ );
  if(dbhandle == NULL)
  {
    show_memory_error("Failed to allocate the db handle");
    return (void *)0;
  }

  else
    memset(dbhandle, 0, sizeof(struct anonymous_6) /*16ul*/ );
  return dbhandle;
}

// init_extdb
// file dballoc.c line 369
static signed long int init_extdb(void *db)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed int i;
  dbh->extdbs.count = (signed long int)0;
  i = 0;
  for( ; !(i >= 20); i = i + 1)
  {
    dbh->extdbs.offset[(signed long int)i] = (signed long int)0;
    dbh->extdbs.size[(signed long int)i] = (signed long int)0;
  }
  return (signed long int)0;
}

// init_hash_subarea
// file dballoc.c line 430
static signed long int init_hash_subarea(void *db, struct _db_hash_area_header *areah, signed long int arraylength)
{
  signed long int segmentchunk;
  signed long int i;
  signed long int asize;
  signed long int j;
  asize = (signed long int)((unsigned long int)(arraylength + (signed long int)1) * sizeof(signed long int) /*8ul*/  + (unsigned long int)(2 * 8));
  segmentchunk=alloc_db_segmentchunk(db, asize);
  if(segmentchunk == 0l)
    return (signed long int)-2;

  else
  {
    areah->offset = segmentchunk;
    areah->size = asize;
    areah->arraylength = arraylength;
    i = (signed long int)8 - segmentchunk % (signed long int)8;
    if(i == 8l)
      i = (signed long int)0;

    areah->arraystart = segmentchunk + i;
    i = areah->arraystart;
    j = (signed long int)0;
    for( ; !(j >= arraylength); j = j + 1l)
      *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)i + (unsigned long int)j * sizeof(signed long int) /*8ul*/ ))) = (signed long int)0;
    return (signed long int)0;
  }
}

// init_logging
// file dballoc.c line 403
static signed long int init_logging(void *db)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  dbh->logging.active = (signed long int)0;
  dbh->logging.dirty = (signed long int)0;
  dbh->logging.serial = (signed long int)1;
  return (signed long int)0;
}

// init_strhash_area
// file dballoc.c line 415
static signed long int init_strhash_area(void *db, struct _db_hash_area_header *areah)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int arraylength;
  arraylength = (signed long int)((unsigned long int)(signed long int)((double)(dbh->size + (signed long int)1) * ((double)2 / 100.0)) / sizeof(signed long int) /*8ul*/ );
  signed long int return_value_init_hash_subarea_1;
  return_value_init_hash_subarea_1=init_hash_subarea(db, areah, arraylength);
  return return_value_init_hash_subarea_1;
}

// init_subarea_freespace
// file dballoc.c line 632
static signed long int init_subarea_freespace(void *db, void *area_header, signed long int arrayindex)
{
  struct _db_area_header *areah;
  signed long int *freebuckets;
  signed long int size;
  signed long int offset;
  signed long int dv;
  signed long int dvindex;
  signed long int dvsize;
  signed long int freelist;
  signed long int endmarkobj;
  signed long int freeoffset;
  signed long int freesize;
  areah = (struct _db_area_header *)area_header;
  freebuckets = areah->freebuckets;
  size = areah->subarea_array[arrayindex].alignedsize;
  offset = areah->subarea_array[arrayindex].alignedoffset;
  if(arrayindex >= 1l)
  {
    dv = freebuckets[(signed long int)(256 + 32)];
    dvsize = freebuckets[(signed long int)(256 + 32 + 1)];
    if(dvsize >= (signed long int)(sizeof(signed long int) * 4) /*32l*/  && !(dv == 0l))
    {
      *((signed long int *)((char *)((struct anonymous_6 *)db)->db + dv)) = dvsize & (signed long int)~3 | (signed long int)1;
      *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)(dv + dvsize) - sizeof(signed long int) /*8ul*/ ))) = dvsize & (signed long int)~3 | (signed long int)1;
      dvindex=wg_freebuckets_index(db, dvsize);
      freelist = freebuckets[dvindex];
      if(!(freelist == 0l))
        *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)freelist + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = dv;

      *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)dv + sizeof(signed long int) /*8ul*/ ))) = freelist;
      *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)dv + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)((char *)&freebuckets[dvindex] - (char *)((struct anonymous_6 *)db)->db);
      freebuckets[dvindex] = dv;
    }

  }

  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + offset)) = (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/  | (signed long int)3;
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + sizeof(signed long int) /*8ul*/ ))) = (signed long int)0;
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)0;
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)(offset + (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/ ) - sizeof(signed long int) /*8ul*/ ))) = (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/ ;
  endmarkobj = (offset + size) - (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/ ;
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + endmarkobj)) = (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/  | (signed long int)3;
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)endmarkobj + sizeof(signed long int) /*8ul*/ ))) = (signed long int)0;
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)endmarkobj + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)0;
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)(endmarkobj + (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/ ) - sizeof(signed long int) /*8ul*/ ))) = (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/ ;
  freeoffset = offset + (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/ ;
  freesize = size - (signed long int)2 * (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/ ;
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + freeoffset)) = freesize | (signed long int)3;
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)freeoffset + sizeof(signed long int) /*8ul*/ ))) = (signed long int)1;
  freebuckets[(signed long int)(256 + 32)] = freeoffset;
  freebuckets[(signed long int)(256 + 32 + 1)] = freesize;
  return (signed long int)0;
}

// init_syn_vars
// file dballoc.c line 338
static signed long int init_syn_vars(void *db)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int i;
  i=alloc_db_segmentchunk(db, (signed long int)(128 * (64 + 2)));
  if(i == 0l)
    return (signed long int)-1;

  else
  {
    i = (i + (signed long int)128) - (signed long int)1 & (signed long int)-128;
    dbh->locks.queue_lock = i;
    dbh->locks.storage = i + (signed long int)128;
    dbh->locks.max_nodes = (signed long int)64;
    dbh->locks.freelist = dbh->locks.storage;
    signed long int return_value_wg_init_locks_1;
    return_value_wg_init_locks_1=wg_init_locks(db);
    return return_value_wg_init_locks_1;
  }
}

// insert_into_list
// file dbindex.c line 1718
static signed long int insert_into_list(void *db, signed long int *head, signed long int value)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int old = *head;
  *head=wg_alloc_fixlen_object(db, (void *)&dbh->listcell_area_header);
  if(!(*head == 0l))
  {
    struct anonymous_20 *listelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *head);
    listelem->car = value;
    listelem->cdr = old;
  }

  return *head;
}

// internal_build_query
// file dbquery.c line 668
static struct anonymous_15 * internal_build_query(void *db, void *matchrec, signed long int reclen, struct anonymous_12 *arglist, signed long int argc, signed long int flags, unsigned long int rowlimit)
{
  struct anonymous_15 *query;
  struct anonymous_12 *full_arglist;
  signed long int fargc = (signed long int)0;
  signed long int col;
  signed long int index_id = (signed long int)-1;
  signed int i;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_6;
  signed long int tmp_if_expr_5;
  signed long int return_value_wg_compare_4;
  _Bool tmp_if_expr_9;
  signed long int tmp_if_expr_8;
  signed long int return_value_wg_compare_7;
  _Bool tmp_if_expr_12;
  signed long int tmp_if_expr_11;
  signed long int return_value_wg_compare_10;
  _Bool tmp_if_expr_15;
  signed long int tmp_if_expr_14;
  signed long int return_value_wg_compare_13;
  _Bool tmp_if_expr_18;
  signed long int tmp_if_expr_17;
  signed long int return_value_wg_compare_16;
  _Bool tmp_if_expr_21;
  signed long int tmp_if_expr_20;
  signed long int return_value_wg_compare_19;
  signed long int tmp_if_expr_23;
  signed long int return_value_wg_compare_22;
  signed int tmp_post_26;
  signed int tmp_post_28;
  if(!tmp_if_expr_1)
  {
    fprintf(stderr, "Invalid database pointer in wg_make_query.\n");
    return (struct anonymous_15 *)(void *)0;
  }

  else
  {
    signed long int return_value_prepare_params_2;
    return_value_prepare_params_2=prepare_params(db, matchrec, reclen, arglist, argc, &full_arglist, &fargc);
    if(!(return_value_prepare_params_2 == 0l))
      return (struct anonymous_15 *)(void *)0;

    else
    {
      void *return_value_malloc_3;
      return_value_malloc_3=malloc(sizeof(struct anonymous_15) /*112ul*/ );
      query = (struct anonymous_15 *)return_value_malloc_3;
      if(query == ((struct anonymous_15 *)NULL))
      {
        show_query_error(db, "Failed to allocate memory");
        if(!(full_arglist == ((struct anonymous_12 *)NULL)))
          free((void *)full_arglist);

        return (struct anonymous_15 *)(void *)0;
      }

      else
      {
        if(!(fargc == 0l))
          col=most_restricting_column(db, full_arglist, fargc, &index_id);

        else
        {
          index_id = (signed long int)-1;
          full_arglist = (struct anonymous_12 *)(void *)0;
        }
        if(index_id >= 1l)
        {
          signed int start_inclusive = 0;
          signed int end_inclusive = 0;
          signed long int start_bound = (signed long int)0xff;
          signed long int end_bound = (signed long int)0xff;
          query->qtype = (signed long int)0x01;
          query->column = col;
          query->curr_offset = (signed long int)0;
          query->curr_slot = (signed long int)-1;
          query->end_offset = (signed long int)0;
          query->end_slot = (signed long int)-1;
          query->direction = (signed long int)1;
          i = 0;
          for( ; !((signed long int)i >= fargc); i = i + 1)
            if((full_arglist + (signed long int)i)->column == col)
              switch((full_arglist + (signed long int)i)->cond)
              {
                case (signed long int)0x0001:
                {
                  if(start_bound == 255l)
                    tmp_if_expr_6 = (_Bool)1;

                  else
                  {
                    if(start_bound == (full_arglist + (signed long int)i)->value)
                      tmp_if_expr_5 = (signed long int)0;

                    else
                    {
                      return_value_wg_compare_4=wg_compare(db, start_bound, (full_arglist + (signed long int)i)->value, 7);
                      tmp_if_expr_5 = return_value_wg_compare_4;
                    }
                    tmp_if_expr_6 = tmp_if_expr_5 == (signed long int)-1 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_6)
                  {
                    start_bound = (full_arglist + (signed long int)i)->value;
                    start_inclusive = 1;
                  }

                  if(end_bound == 255l)
                    tmp_if_expr_9 = (_Bool)1;

                  else
                  {
                    if(end_bound == (full_arglist + (signed long int)i)->value)
                      tmp_if_expr_8 = (signed long int)0;

                    else
                    {
                      return_value_wg_compare_7=wg_compare(db, end_bound, (full_arglist + (signed long int)i)->value, 7);
                      tmp_if_expr_8 = return_value_wg_compare_7;
                    }
                    tmp_if_expr_9 = tmp_if_expr_8 == (signed long int)1 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_9)
                  {
                    end_bound = (full_arglist + (signed long int)i)->value;
                    end_inclusive = 1;
                  }

                  break;
                }
                case (signed long int)0x0004:
                {
                  if(end_bound == 255l)
                    tmp_if_expr_12 = (_Bool)1;

                  else
                  {
                    if(end_bound == (full_arglist + (signed long int)i)->value)
                      tmp_if_expr_11 = (signed long int)0;

                    else
                    {
                      return_value_wg_compare_10=wg_compare(db, end_bound, (full_arglist + (signed long int)i)->value, 7);
                      tmp_if_expr_11 = return_value_wg_compare_10;
                    }
                    tmp_if_expr_12 = tmp_if_expr_11 != (signed long int)-1 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_12)
                  {
                    end_bound = (full_arglist + (signed long int)i)->value;
                    end_inclusive = 0;
                  }

                  break;
                }
                case (signed long int)0x0008:
                {
                  if(start_bound == 255l)
                    tmp_if_expr_15 = (_Bool)1;

                  else
                  {
                    if(start_bound == (full_arglist + (signed long int)i)->value)
                      tmp_if_expr_14 = (signed long int)0;

                    else
                    {
                      return_value_wg_compare_13=wg_compare(db, start_bound, (full_arglist + (signed long int)i)->value, 7);
                      tmp_if_expr_14 = return_value_wg_compare_13;
                    }
                    tmp_if_expr_15 = tmp_if_expr_14 != (signed long int)1 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_15)
                  {
                    start_bound = (full_arglist + (signed long int)i)->value;
                    start_inclusive = 0;
                  }

                  break;
                }
                case (signed long int)0x0010:
                {
                  if(end_bound == 255l)
                    tmp_if_expr_18 = (_Bool)1;

                  else
                  {
                    if(end_bound == (full_arglist + (signed long int)i)->value)
                      tmp_if_expr_17 = (signed long int)0;

                    else
                    {
                      return_value_wg_compare_16=wg_compare(db, end_bound, (full_arglist + (signed long int)i)->value, 7);
                      tmp_if_expr_17 = return_value_wg_compare_16;
                    }
                    tmp_if_expr_18 = tmp_if_expr_17 == (signed long int)1 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_18)
                  {
                    end_bound = (full_arglist + (signed long int)i)->value;
                    end_inclusive = 1;
                  }

                  break;
                }
                case (signed long int)0x0020:
                {
                  if(start_bound == 255l)
                    tmp_if_expr_21 = (_Bool)1;

                  else
                  {
                    if(start_bound == (full_arglist + (signed long int)i)->value)
                      tmp_if_expr_20 = (signed long int)0;

                    else
                    {
                      return_value_wg_compare_19=wg_compare(db, start_bound, (full_arglist + (signed long int)i)->value, 7);
                      tmp_if_expr_20 = return_value_wg_compare_19;
                    }
                    tmp_if_expr_21 = tmp_if_expr_20 == (signed long int)-1 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_21)
                  {
                    start_bound = (full_arglist + (signed long int)i)->value;
                    start_inclusive = 1;
                  }

                  break;
                }
                case (signed long int)0x0002:
                {
                  query->column = (signed long int)-1;
                  break;
                }
                default:
                  show_query_error(db, "Invalid condition (ignoring)");
              }

          if(!(end_bound == 255l) && !(start_bound == 255l))
          {
            if(start_bound == end_bound)
              tmp_if_expr_23 = (signed long int)0;

            else
            {
              return_value_wg_compare_22=wg_compare(db, start_bound, end_bound, 7);
              tmp_if_expr_23 = return_value_wg_compare_22;
            }
            if(tmp_if_expr_23 == 1l)
            {
              query->argc = (signed long int)0;
              query->arglist = (struct anonymous_12 *)(void *)0;
              free((void *)full_arglist);
              return query;
            }

          }

          signed long int return_value_find_ttree_bounds_24;
          return_value_find_ttree_bounds_24=find_ttree_bounds(db, index_id, col, start_bound, end_bound, (signed long int)start_inclusive, (signed long int)end_inclusive, &query->curr_offset, &query->curr_slot, &query->end_offset, &query->end_slot);
          if(!(return_value_find_ttree_bounds_24 == 0l))
          {
            free((void *)query);
            free((void *)full_arglist);
            return (struct anonymous_15 *)(void *)0;
          }

        }

        else
        {
          void *internal_build_query__1__7__rec;
          query->qtype = (signed long int)0x04;
          query->column = (signed long int)-1;
          internal_build_query__1__7__rec=wg_get_first_record(db);
          if(!(internal_build_query__1__7__rec == NULL))
            query->curr_record = (signed long int)((char *)internal_build_query__1__7__rec - (char *)((struct anonymous_6 *)db)->db);

          else
            query->curr_record = (signed long int)0;
        }
        if(query->column == -1l)
        {
          query->arglist = full_arglist;
          query->argc = fargc;
        }

        else
        {
          signed int cnt = 0;
          i = 0;
          for( ; !((signed long int)i >= fargc); i = i + 1)
            if(!((full_arglist + (signed long int)i)->column == query->column))
              cnt = cnt + 1;

          if(!(cnt == 0))
          {
            signed int j;
            void *return_value_malloc_25;
            return_value_malloc_25=malloc((unsigned long int)cnt * sizeof(struct anonymous_12) /*24ul*/ );
            query->arglist = (struct anonymous_12 *)return_value_malloc_25;
            if(query->arglist == ((struct anonymous_12 *)NULL))
            {
              show_query_error(db, "Failed to allocate memory");
              free((void *)query);
              free((void *)full_arglist);
              return (struct anonymous_15 *)(void *)0;
            }

            i = 0;
            j = 0;
            for( ; !((signed long int)i >= fargc); i = i + 1)
              if(!((full_arglist + (signed long int)i)->column == query->column))
              {
                (query->arglist + (signed long int)j)->column = (full_arglist + (signed long int)i)->column;
                (query->arglist + (signed long int)j)->cond = (full_arglist + (signed long int)i)->cond;
                tmp_post_26 = j;
                j = j + 1;
                (query->arglist + (signed long int)tmp_post_26)->value = (full_arglist + (signed long int)i)->value;
              }

          }

          else
            query->arglist = (struct anonymous_12 *)(void *)0;
          query->argc = (signed long int)cnt;
          free((void *)full_arglist);
        }
        if(!((4096l & flags) == 0l))
        {
          struct __query_result_page **prevnext;
          struct __query_result_page *currpage;
          void *rec;
          query->curr_page = (void *)0;
          query->curr_pidx = (signed long int)0;
          query->res_count = (unsigned long int)0;
          query->mpool=wg_create_mpool(db, (signed int)sizeof(struct __query_result_page) /*512ul*/ );
          if(query->mpool == NULL)
          {
            show_query_error(db, "Failed to allocate result memory pool");
            wg_free_query(db, query);
            return (struct anonymous_15 *)(void *)0;
          }

          i = 63;
          prevnext = (struct __query_result_page **)&query->curr_page;
          do
          {
            rec=wg_fetch(db, query);
            if(rec == NULL)
              break;

            if(i >= 63)
            {
              void *return_value_wg_alloc_mpool_27;
              return_value_wg_alloc_mpool_27=wg_alloc_mpool(db, query->mpool, (signed int)sizeof(struct __query_result_page) /*512ul*/ );
              currpage = (struct __query_result_page *)return_value_wg_alloc_mpool_27;
              if(currpage == ((struct __query_result_page *)NULL))
              {
                show_query_error(db, "Failed to allocate a resultset row");
                wg_free_query(db, query);
                return (struct anonymous_15 *)(void *)0;
              }

              memset((void *)currpage->rows, 0, sizeof(signed long int) /*8ul*/  * (unsigned long int)63);
              *prevnext = currpage;
              prevnext = &currpage->next;
              currpage->next = (struct __query_result_page *)(void *)0;
              i = 0;
            }

            tmp_post_28 = i;
            i = i + 1;
            currpage->rows[(signed long int)tmp_post_28] = (signed long int)((char *)rec - (char *)((struct anonymous_6 *)db)->db);
            query->res_count = query->res_count + 1ul;
            if(!(rowlimit == 0ul))
            {
              if(query->res_count >= rowlimit)
                break;

            }

          }
          while((_Bool)1);
          query->qtype = (signed long int)0x80;
        }

        return query;
      }
    }
  }
}

// intersect_resultset
// file dbquery.c line 1449
static struct anonymous_17 * intersect_resultset(void *db, struct anonymous_17 *seta, struct anonymous_17 *setb)
{
  struct anonymous_17 *intersection;
  signed int strategy = 1;
  intersection=create_resultset(db);
  if(intersection == ((struct anonymous_17 *)NULL))
    return (struct anonymous_17 *)(void *)0;

  else
  {
    if(!(seta->res_count * setb->res_count >= 200l))
      strategy = 0;

    if(strategy == 1)
    {
      void *hasht = (void *)0;
      signed long int offset;
      if(!(setb->res_count >= seta->res_count))
      {
        struct anonymous_17 *tmp = seta;
        seta = setb;
        setb = tmp;
      }

      hasht=wg_dhash_init(db, (unsigned long int)seta->res_count);
      if(hasht == NULL)
      {
        free_resultset(db, intersection);
        return (struct anonymous_17 *)(void *)0;
      }

      rewind_resultset(db, seta);
      do
      {
        offset=fetch_resultset(db, seta);
        if(offset == 0l)
          break;

        signed long int return_value_wg_dhash_addkey_1;
        return_value_wg_dhash_addkey_1=wg_dhash_addkey(db, hasht, offset);
        if(!(return_value_wg_dhash_addkey_1 == 0l))
        {
          free_resultset(db, intersection);
          wg_dhash_free(db, hasht);
          return (struct anonymous_17 *)(void *)0;
        }

      }
      while((_Bool)1);
      rewind_resultset(db, setb);
      do
      {
        offset=fetch_resultset(db, setb);
        if(offset == 0l)
          break;

        signed long int return_value_wg_dhash_haskey_2;
        return_value_wg_dhash_haskey_2=wg_dhash_haskey(db, hasht, offset);
        if(!(return_value_wg_dhash_haskey_2 == 0l))
        {
          signed long int err;
          err=append_resultset(db, intersection, offset);
          if(!(err == 0l))
          {
            free_resultset(db, intersection);
            wg_dhash_free(db, hasht);
            return (struct anonymous_17 *)(void *)0;
          }

        }

      }
      while((_Bool)1);
      wg_dhash_free(db, hasht);
    }

    else
    {
      signed long int offseta;
      rewind_resultset(db, seta);
      do
      {
        offseta=fetch_resultset(db, seta);
        if(offseta == 0l)
          break;

        signed long int offsetb;
        rewind_resultset(db, setb);
        do
        {
          offsetb=fetch_resultset(db, setb);
          if(offsetb == 0l)
            break;

          if(offseta == offsetb)
          {
            signed long int intersect_resultset__1__4__1__1__1__err;
            intersect_resultset__1__4__1__1__1__err=append_resultset(db, intersection, offseta);
            if(!(intersect_resultset__1__4__1__1__1__err == 0l))
            {
              free_resultset(db, intersection);
              return (struct anonymous_17 *)(void *)0;
            }

            break;
          }

        }
        while((_Bool)1);
      }
      while((_Bool)1);
    }
    return intersection;
  }
}

// isleap
// file dbdata.c line 2890
static signed int isleap(unsigned int yr)
{
  return (signed int)(yr % (unsigned int)400 == (unsigned int)0 || yr % (unsigned int)4 == (unsigned int)0 && yr % (unsigned int)100 != (unsigned int)0);
}

// link_shared_memory
// file dbmem.c line 665
static void * link_shared_memory(signed int key, signed int *errcode)
{
  void *shm;
  signed int shmid;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  *errcode = 0;
  shmid=shmget((signed int)key, (unsigned long int)0, 0);
  if(!(shmid >= 0))
    return (void *)0;

  else
  {
    shm=shmat(shmid, (void *)0, 0);
    if((char *)shm == (char *)-1)
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *errcode = *return_value___errno_location_2;
      if(*errcode == 13)
      {
        show_memory_error("cannot attach to shared memory (No permission)");
        return (void *)0;
      }

      else
      {
        show_memory_error("attaching shared memory segment failed");
        return (void *)0;
      }
    }

    return (void *)shm;
  }
}

// lock_queue
// file dblock.c line 926
static void lock_queue(void *db)
{
  signed int i;
  struct timespec ts;
  volatile signed long int *gl = (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + ((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->locks.queue_lock);
  signed long int return_value_wg_compare_and_swap_1;
  return_value_wg_compare_and_swap_1=wg_compare_and_swap(gl, (signed long int)0, (signed long int)1);
  signed long int return_value_wg_compare_and_swap_2;
  if(return_value_wg_compare_and_swap_1 == 0l)
  {
    ts.tv_sec = (signed long int)0;
    ts.tv_nsec = (signed long int)500000;
    do
    {
      i = 0;
      for( ; !(i >= 500); i = i + 1)
      {
        asm("pause;\n");
        if(*gl == 0l)
        {
          return_value_wg_compare_and_swap_2=wg_compare_and_swap(gl, (signed long int)0, (signed long int)1);
          if(!(return_value_wg_compare_and_swap_2 == 0l))
            goto __CPROVER_DUMP_L6;

        }

      }
      nanosleep(&ts, (struct timespec *)(void *)0);
      ts.tv_nsec = ts.tv_nsec + (signed long int)500000;
    }
    while((_Bool)1);
  }


__CPROVER_DUMP_L6:
  ;
}

// main
// file stresstest.c line 120
signed int main(signed int argc, char **argv)
{
  char *shmname = (char *)(void *)0;
  void *shmptr;
  signed int rcnt = -1;
  signed int wcnt = -1;
  struct timeval tv;
  unsigned long long int start_ms;
  unsigned long long int end_ms;
  if(argc == 4)
  {
    shmname = argv[(signed long int)1];
    signed long int return_value_atol_1;
    return_value_atol_1=atol(argv[(signed long int)2]);
    rcnt = (signed int)return_value_atol_1;
    signed long int return_value_atol_2;
    return_value_atol_2=atol(argv[(signed long int)3]);
    wcnt = (signed int)return_value_atol_2;
  }

  if(!(rcnt >= 0) || !(wcnt >= 0))
  {
    fprintf(stderr, "usage: %s <shmname> <readers> <writers>\n", argv[(signed long int)0]);
    exit(1);
  }

  shmptr=wg_attach_database(shmname, (signed long int)10000000);
  if(shmptr == NULL)
    exit(2);

  signed int return_value_prepare_data_3;
  return_value_prepare_data_3=prepare_data(shmptr);
  if(!(return_value_prepare_data_3 == 0))
  {
    wg_delete_database(shmname);
    exit(3);
  }

  gettimeofday(&tv, (struct timezone *)(void *)0);
  start_ms = (unsigned long long int)(tv.tv_sec * (signed long int)1000 + tv.tv_usec / (signed long int)1000);
  run_workers(shmptr, rcnt, wcnt);
  gettimeofday(&tv, (struct timezone *)(void *)0);
  end_ms = (unsigned long long int)(tv.tv_sec * (signed long int)1000 + tv.tv_usec / (signed long int)1000);
  check_data(shmptr, wcnt);
  fprintf(stdout, "elapsed: %d ms\n", (signed int)(end_ms - start_ms));
  wg_delete_database(shmname);
  exit(0);
}

// make_subarea_freelist
// file dballoc.c line 569
static signed long int make_subarea_freelist(void *db, void *area_header, signed long int arrayindex)
{
  struct _db_area_header *areah;
  signed long int objlength;
  signed long int max;
  signed long int size;
  signed long int offset;
  signed long int i;
  areah = (struct _db_area_header *)area_header;
  objlength = areah->objlength;
  size = areah->subarea_array[arrayindex].alignedsize;
  offset = areah->subarea_array[arrayindex].alignedoffset;
  max = (offset + size) - (signed long int)2 * objlength;
  i = offset;
  for( ; max >= i; i = i + objlength)
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + i)) = i + objlength;
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + i)) = (signed long int)0;
  areah->freelist = offset;
  return (signed long int)0;
}

// memory_stats
// file dbmem.c line 583
static signed int memory_stats(void *db, struct shmid_ds *buf)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  if(!(dbh->key == 0l))
  {
    signed int shmid;
    shmid=shmget((signed int)dbh->key, (unsigned long int)0, 0);
    if(!(shmid >= 0))
    {
      show_memory_error("memory_stats(): failed to get shmid");
      return -2;
    }

    else
    {
      signed int err;
      memset((void *)buf, 0, sizeof(struct shmid_ds) /*112ul*/ );
      err=shmctl(shmid, 2, buf);
      if(!(err == 0))
      {
        show_memory_error("memory_stats(): failed to stat shared memory");
        return -2;
      }

      return 0;
    }
  }

  return -1;
}

// months_to_days
// file dbdata.c line 2894
static unsigned int months_to_days(unsigned int month)
{
  return (month * (unsigned int)3057 - (unsigned int)3007) / (unsigned int)100;
}

// most_restricting_column
// file dbquery.c line 137
static signed long int most_restricting_column(void *db, struct anonymous_12 *arglist, signed long int argc, signed long int *index_id)
{
  /* most_restricting_column::1::tag-column_score */
struct column_score
{
  // column
  signed long int column;
  // score
  signed int score;
  // index_id
  signed int index_id;
};

/* */
  ;
  struct column_score *sc;
  signed int i;
  signed int j;
  signed int mrc_score = -1;
  signed long int mrc = (signed long int)-1;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)argc * sizeof(struct column_score) /*16ul*/ );
  sc = (struct column_score *)return_value_malloc_1;
  _Bool tmp_if_expr_4;
  signed long int tmp_if_expr_3;
  signed long int return_value_wg_compare_2;
  if(sc == ((struct column_score *)NULL))
  {
    show_query_error(db, "Failed to allocate memory");
    return (signed long int)-1;
  }

  else
  {
    i = 0;
    while(!((signed long int)i >= argc))
    {
      (sc + (signed long int)i)->column = (signed long int)-1;
      (sc + (signed long int)i)->score = 0;
      (sc + (signed long int)i)->index_id = 0;
      j = 0;
      for( ; !((signed long int)j >= argc); j = j + 1)
      {
        if((sc + (signed long int)j)->column == -1l)
        {
          (sc + (signed long int)j)->column = (arglist + (signed long int)i)->column;
          break;
        }

        if((sc + (signed long int)j)->column == (arglist + (signed long int)i)->column)
          break;

      }
      switch((arglist + (signed long int)i)->cond)
      {
        case (signed long int)0x0001:
        {
          (sc + (signed long int)j)->score = (sc + (signed long int)j)->score + 5;
          if((arglist + (signed long int)i)->value == 0l)
            (sc + (signed long int)j)->score = (sc + (signed long int)j)->score + -1;

          goto __CPROVER_DUMP_L9;
        }
        case (signed long int)0x0004:

        case (signed long int)0x0008:

        case (signed long int)0x0010:

        case (signed long int)0x0020:
          (sc + (signed long int)j)->score = (sc + (signed long int)j)->score + 2;
        default:
        {

        __CPROVER_DUMP_L9:
          ;
          i = i + 1;
        }
      }
    }
    i = 0;
    for( ; !((signed long int)i >= argc); i = i + 1)
    {
      if((sc + (signed long int)i)->column == -1l)
        break;

      if(!((sc + (signed long int)i)->column >= 128l))
      {
        signed long int *ilist = &dbh->index_control_area_header.index_table[(sc + (signed long int)i)->column];
        while(!(*ilist == 0l))
        {
          struct anonymous_20 *ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
          if(!(ilistelem->car == 0l))
          {
            struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + ilistelem->car);
            if(hdr->type == 50l)
            {
              if(!(hdr->template_offset == 0l))
              {
                struct anonymous_22 *tmpl = (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + hdr->template_offset);
                void *matchrec = (void *)((char *)((struct anonymous_6 *)db)->db + tmpl->offset_matchrec);
                signed long int reclen;
                reclen=wg_get_record_len(db, matchrec);
                j = 0;
                for( ; !((signed long int)j >= reclen); j = j + 1)
                {
                  signed long int enc;
                  enc=wg_get_field(db, matchrec, (signed long int)j);
                  signed long int return_value_wg_get_encoded_type_5;
                  return_value_wg_get_encoded_type_5=wg_get_encoded_type(db, enc);
                  if(!(return_value_wg_get_encoded_type_5 == 14l))
                  {
                    signed int match = 0;
                    signed int k = 0;
                    for( ; !((signed long int)k >= argc); k = k + 1)
                      if((arglist + (signed long int)k)->column == (signed long int)j)
                      {
                        if((arglist + (signed long int)k)->cond == 1l)
                        {
                          if(enc == (arglist + (signed long int)k)->value)
                            tmp_if_expr_3 = (signed long int)0;

                          else
                          {
                            return_value_wg_compare_2=wg_compare(db, enc, (arglist + (signed long int)k)->value, 7);
                            tmp_if_expr_3 = return_value_wg_compare_2;
                          }
                          tmp_if_expr_4 = tmp_if_expr_3 == (signed long int)0 ? (_Bool)1 : (_Bool)0;
                        }

                        else
                          tmp_if_expr_4 = (_Bool)0;
                        if(tmp_if_expr_4)
                          match = 1;

                        else
                          goto nextindex;
                      }

                    if(!(match == 0))
                    {
                      (sc + (signed long int)i)->score = (sc + (signed long int)i)->score + 5;
                      if(enc == 0l)
                        (sc + (signed long int)i)->score = (sc + (signed long int)i)->score + -1;

                    }

                    else
                      goto nextindex;
                  }

                }
              }

              (sc + (signed long int)i)->index_id = (signed int)ilistelem->car;
              break;
            }

          }


        nextindex:
          ;
          ilist = &ilistelem->cdr;
        }
      }

      if((sc + (signed long int)i)->index_id == 0)
        (sc + (signed long int)i)->score = 0;

      if(!(mrc_score >= (sc + (signed long int)i)->score))
      {
        mrc_score = (sc + (signed long int)i)->score;
        mrc = (sc + (signed long int)i)->column;
        *index_id = (signed long int)(sc + (signed long int)i)->index_id;
      }

    }
    free((void *)sc);
    return mrc;
  }
}

// normalize_perms
// file dbmem.c line 177
static signed int normalize_perms(signed int mode)
{
  mode = mode & 0666;
  mode = mode | 0600;
  if(!((0060 & mode) == 0060))
    mode = mode & 0606;

  if(!((0006 & mode) == 0006))
    mode = mode & 0660;

  return mode;
}

// object_begin_cb
// file dbjson.c line 619
static signed int object_begin_cb(void *cb_ctx)
{
  struct anonymous_0 *ctx = (struct anonymous_0 *)cb_ctx;
  signed int return_value_push_1;
  return_value_push_1=push(ctx, (enum anonymous_2)OBJECT);
  if(return_value_push_1 == 0)
    return 0;

  else
    return 1;
}

// object_end_cb
// file dbjson.c line 630
static signed int object_end_cb(void *cb_ctx)
{
  struct anonymous_0 *ctx = (struct anonymous_0 *)cb_ctx;
  signed int return_value_pop_1;
  return_value_pop_1=pop(ctx);
  if(return_value_pop_1 == 0)
    return 0;

  else
    return 1;
}

// object_key_cb
// file dbjson.c line 671
static signed int object_key_cb(void *cb_ctx, const unsigned char *strval, unsigned long int strl)
{
  signed int res = 1;
  struct anonymous_0 *ctx = (struct anonymous_0 *)cb_ctx;
  char *buf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(strl + (unsigned long int)1);
  buf = (char *)return_value_malloc_1;
  if(buf == ((char *)NULL))
    return 0;

  else
  {
    strncpy(buf, (char *)strval, strl);
    buf[(signed long int)strl] = (char)0;
    signed int return_value_add_key_2;
    return_value_add_key_2=add_key(ctx, buf);
    if(return_value_add_key_2 == 0)
      res = 0;

    free((void *)buf);
    return res;
  }
}

// parse_input_type
// file dbutil.c line 568
static signed long int parse_input_type(void *db, char *buf, signed long int *intdata, double *doubledata, signed long int *datetime)
{
  signed long int type = (signed long int)0;
  char c = buf[(signed long int)0];
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_15;
  signed int return_value_wg_strp_iso_date_14;
  _Bool tmp_if_expr_13;
  signed int return_value_wg_strp_iso_time_12;
  _Bool tmp_if_expr_1;
  char *tmp_post_2;
  char *tmp_post_3;
  _Bool tmp_if_expr_7;
  signed int *return_value___errno_location_6;
  _Bool tmp_if_expr_11;
  signed int *return_value___errno_location_10;
  if((signed int)c == 0)
    type = (signed long int)1;

  else
  {
    if((signed int)c >= 48 && !((signed int)c >= 58))
      tmp_if_expr_18 = (_Bool)1;

    else
    {
      if((signed int)c == 45)
        tmp_if_expr_16 = (signed int)buf[(signed long int)1] >= 48 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_16 = (_Bool)0;
      if(tmp_if_expr_16)
        tmp_if_expr_17 = (signed int)buf[(signed long int)1] <= 57 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_17 = (_Bool)0;
      tmp_if_expr_18 = tmp_if_expr_17 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_18)
    {
      if(!((signed int)c == 45))
      {
        return_value_wg_strp_iso_date_14=wg_strp_iso_date(db, buf);
        *datetime = (signed long int)return_value_wg_strp_iso_date_14;
        tmp_if_expr_15 = *datetime >= (signed long int)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_15 = (_Bool)0;
      if(tmp_if_expr_15)
        type = (signed long int)11;

      else
      {
        if(!((signed int)c == 45))
        {
          return_value_wg_strp_iso_time_12=wg_strp_iso_time(db, buf);
          *datetime = (signed long int)return_value_wg_strp_iso_time_12;
          tmp_if_expr_13 = *datetime >= (signed long int)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_13 = (_Bool)0;
        if(tmp_if_expr_13)
          type = (signed long int)12;

        else
        {
          char numbuf[80l];
          char *ptr = buf;
          char *wptr = numbuf;
          char *decptr = (char *)(void *)0;
          signed int decsep = 0;
          while(!(*ptr == 0))
          {
            if((signed int)*ptr == 46)
            {
              decsep = decsep + 1;
              decptr = wptr;
            }

            else
            {
              if(!((signed int)*ptr >= 48))
                tmp_if_expr_1 = (_Bool)1;

              else
                tmp_if_expr_1 = (signed int)*ptr > 57 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_1)
              {
                if(!(ptr == buf))
                {
                  decsep = 2;
                  break;
                }

              }

            }
            tmp_post_2 = wptr;
            wptr = wptr + 1l;
            tmp_post_3 = ptr;
            ptr = ptr + 1l;
            *tmp_post_2 = *tmp_post_3;
            if((signed int)(wptr - numbuf) >= 79)
              break;

          }
          *wptr = (char)0;
          if(decsep == 1)
          {
            char tmp = *decptr;
            *decptr = (char)46;
            *doubledata=strtod(numbuf, (char ** restrict )(void *)0);
            signed int *return_value___errno_location_5;
            return_value___errno_location_5=__errno_location();
            if(!(*return_value___errno_location_5 == 34))
            {
              return_value___errno_location_6=__errno_location();
              tmp_if_expr_7 = *return_value___errno_location_6 != 22 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_7 = (_Bool)0;
            if(tmp_if_expr_7)
              type = (signed long int)4;

            else
            {
              signed int *return_value___errno_location_4;
              return_value___errno_location_4=__errno_location();
              *return_value___errno_location_4 = 0;
            }
            *decptr = tmp;
          }

          else
            if(decsep == 0)
            {
              *intdata=strtol(numbuf, (char ** restrict )(void *)0, 10);
              signed int *return_value___errno_location_9;
              return_value___errno_location_9=__errno_location();
              if(!(*return_value___errno_location_9 == 34))
              {
                return_value___errno_location_10=__errno_location();
                tmp_if_expr_11 = *return_value___errno_location_10 != 22 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_11 = (_Bool)0;
              if(tmp_if_expr_11)
                type = (signed long int)3;

              else
              {
                signed int *return_value___errno_location_8;
                return_value___errno_location_8=__errno_location();
                *return_value___errno_location_8 = 0;
              }
            }

        }
      }
    }

  }
  if(type == 0l)
    type = (signed long int)5;

  return type;
}

// pop
// file dbjson.c line 462
static signed int pop(struct anonymous_0 *ctx)
{
  struct anonymous_1 *e;
  void *rec;
  signed int ret;
  signed int istoplevel;
  signed int tmp_post_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  signed int tmp_post_4;
  if(!(ctx->stack_ptr >= 0))
    return 0;

  else
  {
    tmp_post_1 = ctx->stack_ptr;
    ctx->stack_ptr = ctx->stack_ptr - 1;
    e = &ctx->stack[(signed long int)tmp_post_1];
    if(!(ctx->stack_ptr >= 0))
      istoplevel = 1;

    else
      istoplevel = 0;
    if((signed int)e->type == ARRAY)
    {
      if(!(istoplevel == 0))
        tmp_if_expr_2 = ctx->isdocument != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      rec=wg_create_array(ctx->db, (signed long int)e->size, (signed long int)tmp_if_expr_2, (signed long int)ctx->isparam);
    }

    else
    {
      if(!(istoplevel == 0))
        tmp_if_expr_3 = ctx->isdocument != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      rec=wg_create_object(ctx->db, (signed long int)e->size, (signed long int)tmp_if_expr_3, (signed long int)ctx->isparam);
    }
    if(!(rec == NULL))
    {
      struct __stack_entry_elem *curr = e->head;
      signed int i = 0;
      ret = 1;
      while(!(curr == ((struct __stack_entry_elem *)NULL)))
      {
        tmp_post_4 = i;
        i = i + 1;
        signed long int return_value_wg_set_field_5;
        return_value_wg_set_field_5=wg_set_field(ctx->db, rec, (signed long int)tmp_post_4, curr->enc);
        if(!(return_value_wg_set_field_5 == 0l))
        {
          ret = 0;
          break;
        }

        curr = curr->next;
      }
      if(!(istoplevel == 0))
        *ctx->document = rec;

    }

    else
      ret = 0;
    while(!(e->head == ((struct __stack_entry_elem *)NULL)))
    {
      struct __stack_entry_elem *tmp = e->head;
      e->head = e->head->next;
      free((void *)tmp);
    }
    e->tail = (struct __stack_entry_elem *)(void *)0;
    e->size = 0;
    if(istoplevel == 0 && !(rec == NULL) && !(ret == 0))
    {
      signed long int enc;
      enc=wg_encode_record(ctx->db, rec);
      ret=add_literal(ctx, enc);
    }

    return ret;
  }
}

// prepare_data
// file stresstest.c line 178
signed int prepare_data(void *db)
{
  signed int i = 0;
  for( ; !(i >= 100000); i = i + 1)
  {
    signed int j;
    void *rec;
    rec=wg_create_record(db, (signed long int)5);
    if(rec == NULL)
    {
      fprintf(stderr, "Failed to create data record #%d: skipping tests.\n", i);
      return -1;
    }

    j = 0;
    for( ; !(j >= 5); j = j + 1)
    {
      signed long int return_value_wg_set_int_field_1;
      return_value_wg_set_int_field_1=wg_set_int_field(db, rec, (signed long int)j, (signed long int)0);
      if(!(return_value_wg_set_int_field_1 == 0l))
      {
        fprintf(stderr, "Failed to create data record #%d: skipping tests.\n", i);
        return -1;
      }

    }
  }
  return 0;
}

// prepare_json_arglist
// file dbquery.c line 1755
static signed long int prepare_json_arglist(void *db, struct anonymous_18 *arglist, struct anonymous_18 **sorted_arglist, signed long int argc, signed long int *index_id, signed long int *vindex_id, signed long int *kindex_id)
{
  signed long int icols[2l];
  signed long int need_ttree = (signed long int)0;
  struct anonymous_18 *tmp = (struct anonymous_18 *)(void *)0;
  icols[(signed long int)0] = (signed long int)(0 + 1);
  icols[(signed long int)1] = (signed long int)(0 + 2);
  *index_id=wg_multi_column_to_index_id(db, icols, (signed long int)2, (signed long int)61, (signed long int *)(void *)0, (signed long int)0);
  *kindex_id = (signed long int)-1;
  *vindex_id = *kindex_id;
  signed long int tmp_post_3;
  signed long int tmp_post_5;
  if(argc >= 2l)
  {
    signed long int i;
    signed long int j;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_18) /*16ul*/  * (unsigned long int)argc);
    tmp = (struct anonymous_18 *)return_value_malloc_1;
    if(tmp == ((struct anonymous_18 *)NULL))
    {
      signed long int return_value_show_query_error_2;
      return_value_show_query_error_2=show_query_error(db, "Failed to prepare query arguments");
      return return_value_show_query_error_2;
    }

    i = (signed long int)0;
    j = (signed long int)0;
    for( ; !(i >= argc); i = i + 1l)
    {
      signed long int return_value_wg_get_encoded_type_4;
      return_value_wg_get_encoded_type_4=wg_get_encoded_type(db, (arglist + i)->value);
      if(!(return_value_wg_get_encoded_type_4 == 2l))
      {
        (tmp + j)->key = (arglist + i)->key;
        tmp_post_3 = j;
        j = j + 1l;
        (tmp + tmp_post_3)->value = (arglist + i)->value;
      }

    }
    if(!(j >= i))
      need_ttree = (signed long int)1;

    i = (signed long int)0;
    for( ; !(i >= argc); i = i + 1l)
    {
      signed long int return_value_wg_get_encoded_type_6;
      return_value_wg_get_encoded_type_6=wg_get_encoded_type(db, (arglist + i)->value);
      if(return_value_wg_get_encoded_type_6 == 2l)
      {
        (tmp + j)->key = (arglist + i)->key;
        tmp_post_5 = j;
        j = j + 1l;
        (tmp + tmp_post_5)->value = (arglist + i)->value;
      }

    }
  }

  else
  {
    signed long int return_value_wg_get_encoded_type_7;
    return_value_wg_get_encoded_type_7=wg_get_encoded_type(db, (arglist + (signed long int)0)->value);
    if(return_value_wg_get_encoded_type_7 == 2l)
      need_ttree = (signed long int)1;

  }
  if(*index_id == -1l || !(need_ttree == 0l))
  {
    *vindex_id=wg_multi_column_to_index_id(db, &icols[(signed long int)1], (signed long int)1, (signed long int)51, (signed long int *)(void *)0, (signed long int)0);
    if(*vindex_id == -1l)
      *kindex_id=wg_multi_column_to_index_id(db, &icols[(signed long int)0], (signed long int)1, (signed long int)50, (signed long int *)(void *)0, (signed long int)0);

  }

  *sorted_arglist = tmp;
  return (signed long int)0;
}

// prepare_params
// file dbquery.c line 350
static signed long int prepare_params(void *db, void *matchrec, signed long int reclen, struct anonymous_12 *arglist, signed long int argc, struct anonymous_12 **farglist, signed long int *fargc)
{
  signed int i;
  signed int tmp_post_4;
  if(!(matchrec == NULL))
  {
    if(reclen == 0l)
    {
      reclen=wg_get_record_len(db, matchrec);
      signed long int *return_value_wg_get_record_dataarray_1;
      return_value_wg_get_record_dataarray_1=wg_get_record_dataarray(db, matchrec);
      matchrec = (void *)return_value_wg_get_record_dataarray_1;
    }

    if(!(reclen == 0l))
      goto __CPROVER_DUMP_L2;

    show_query_error(db, "Zero-length match record argument");
    return (signed long int)-1;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    if(argc == 0l && !(arglist == ((struct anonymous_12 *)NULL)))
    {
      show_query_error(db, "Zero-length argument list");
      return (signed long int)-1;
    }

    else
      if(arglist == ((struct anonymous_12 *)NULL) && !(argc == 0l))
      {
        show_query_error(db, "Invalid argument list (NULL)");
        return (signed long int)-1;
      }

      else
      {
        *fargc = argc;
        if(!(matchrec == NULL))
        {
          i = 0;
          for( ; !((signed long int)i >= reclen); i = i + 1)
          {
            signed long int return_value_wg_get_encoded_type_2;
            return_value_wg_get_encoded_type_2=wg_get_encoded_type(db, ((signed long int *)matchrec)[(signed long int)i]);
            if(!(return_value_wg_get_encoded_type_2 == 14l))
              *fargc = *fargc + 1l;

          }
        }

        if(!(*fargc == 0l))
        {
          struct anonymous_12 *tmp = (struct anonymous_12 *)(void *)0;
          void *return_value_malloc_3;
          return_value_malloc_3=malloc((unsigned long int)*fargc * sizeof(struct anonymous_12) /*24ul*/ );
          tmp = (struct anonymous_12 *)return_value_malloc_3;
          if(tmp == ((struct anonymous_12 *)NULL))
          {
            show_query_error(db, "Failed to allocate memory");
            return (signed long int)-2;
          }

          i = 0;
          for( ; !((signed long int)i >= argc); i = i + 1)
          {
            (tmp + (signed long int)i)->column = (arglist + (signed long int)i)->column;
            (tmp + (signed long int)i)->cond = (arglist + (signed long int)i)->cond;
            (tmp + (signed long int)i)->value = (arglist + (signed long int)i)->value;
          }
          if(!(matchrec == NULL))
          {
            signed int j;
            i = 0;
            j = (signed int)argc;
            for( ; !((signed long int)i >= reclen); i = i + 1)
            {
              signed long int return_value_wg_get_encoded_type_5;
              return_value_wg_get_encoded_type_5=wg_get_encoded_type(db, ((signed long int *)matchrec)[(signed long int)i]);
              if(!(return_value_wg_get_encoded_type_5 == 14l))
              {
                (tmp + (signed long int)j)->column = (signed long int)i;
                (tmp + (signed long int)j)->cond = (signed long int)0x0001;
                tmp_post_4 = j;
                j = j + 1;
                (tmp + (signed long int)tmp_post_4)->value = ((signed long int *)matchrec)[(signed long int)i];
              }

            }
          }

          *farglist = tmp;
        }

        else
          *farglist = (struct anonymous_12 *)(void *)0;
        return (signed long int)0;
      }
  }
}

// pretty_print_json
// file dbjson.c line 756
static signed int pretty_print_json(void *db, struct yajl_gen_t **g, void *rec)
{
  if(!((32l & ((signed long int *)rec)[1l]) == 0l))
  {
    signed long int i;
    signed long int reclen;
    enum anonymous_33 return_value_yajl_gen_map_open_2;
    return_value_yajl_gen_map_open_2=yajl_gen_map_open(*g);
    if(!((signed int)return_value_yajl_gen_map_open_2 == yajl_gen_status_ok))
    {
      signed long int return_value_show_json_error_1;
      return_value_show_json_error_1=show_json_error(db, "Formatter failure");
      return (signed int)return_value_show_json_error_1;
    }

    reclen=wg_get_record_len(db, rec);
    i = (signed long int)0;
    for( ; !(i >= reclen); i = i + 1l)
    {
      signed long int enc;
      enc=wg_get_field(db, rec, i);
      signed long int return_value_wg_get_encoded_type_4;
      return_value_wg_get_encoded_type_4=wg_get_encoded_type(db, enc);
      if(!(return_value_wg_get_encoded_type_4 == 2l))
      {
        signed long int return_value_show_json_error_3;
        return_value_show_json_error_3=show_json_error(db, "Object had an element of invalid type");
        return (signed int)return_value_show_json_error_3;
      }

      void *return_value_wg_decode_record_5;
      return_value_wg_decode_record_5=wg_decode_record(db, enc);
      signed int return_value_pretty_print_json_6;
      return_value_pretty_print_json_6=pretty_print_json(db, g, return_value_wg_decode_record_5);
      if(!(return_value_pretty_print_json_6 == 0))
        return -1;

    }
    enum anonymous_33 return_value_yajl_gen_map_close_8;
    return_value_yajl_gen_map_close_8=yajl_gen_map_close(*g);
    if(!((signed int)return_value_yajl_gen_map_close_8 == yajl_gen_status_ok))
    {
      signed long int return_value_show_json_error_7;
      return_value_show_json_error_7=show_json_error(db, "Formatter failure");
      return (signed int)return_value_show_json_error_7;
    }

  }

  else
    if(!((64l & ((signed long int *)rec)[1l]) == 0l))
    {
      signed long int pretty_print_json__1__2__i;
      signed long int pretty_print_json__1__2__reclen;
      enum anonymous_33 return_value_yajl_gen_array_open_10;
      return_value_yajl_gen_array_open_10=yajl_gen_array_open(*g);
      if(!((signed int)return_value_yajl_gen_array_open_10 == yajl_gen_status_ok))
      {
        signed long int return_value_show_json_error_9;
        return_value_show_json_error_9=show_json_error(db, "Formatter failure");
        return (signed int)return_value_show_json_error_9;
      }

      pretty_print_json__1__2__reclen=wg_get_record_len(db, rec);
      pretty_print_json__1__2__i = (signed long int)0;
      for( ; !(pretty_print_json__1__2__i >= pretty_print_json__1__2__reclen); pretty_print_json__1__2__i = pretty_print_json__1__2__i + 1l)
      {
        signed long int pretty_print_json__1__2__2__1__enc;
        pretty_print_json__1__2__2__1__enc=wg_get_field(db, rec, pretty_print_json__1__2__i);
        signed int return_value_pretty_print_jsonval_11;
        return_value_pretty_print_jsonval_11=pretty_print_jsonval(db, g, pretty_print_json__1__2__2__1__enc);
        if(!(return_value_pretty_print_jsonval_11 == 0))
          return -1;

      }
      enum anonymous_33 return_value_yajl_gen_array_close_13;
      return_value_yajl_gen_array_close_13=yajl_gen_array_close(*g);
      if(!((signed int)return_value_yajl_gen_array_close_13 == yajl_gen_status_ok))
      {
        signed long int return_value_show_json_error_12;
        return_value_show_json_error_12=show_json_error(db, "Formatter failure");
        return (signed int)return_value_show_json_error_12;
      }

    }

    else
    {
      signed long int key;
      signed long int value;
      key=wg_get_field(db, rec, (signed long int)(0 + 1));
      value=wg_get_field(db, rec, (signed long int)(0 + 2));
      signed long int return_value_wg_get_encoded_type_18;
      return_value_wg_get_encoded_type_18=wg_get_encoded_type(db, key);
      if(!(return_value_wg_get_encoded_type_18 == 5l))
      {
        signed long int return_value_show_json_error_14;
        return_value_show_json_error_14=show_json_error(db, "Key is of invalid type");
        return (signed int)return_value_show_json_error_14;
      }

      else
      {
        signed int len;
        signed long int return_value_wg_decode_str_len_15;
        return_value_wg_decode_str_len_15=wg_decode_str_len(db, key);
        len = (signed int)return_value_wg_decode_str_len_15;
        char *buf;
        buf=wg_decode_str(db, key);
        if(!(buf == ((char *)NULL)))
        {
          enum anonymous_33 return_value_yajl_gen_string_17;
          return_value_yajl_gen_string_17=yajl_gen_string(*g, (unsigned char *)buf, (unsigned long int)len);
          if(!((signed int)return_value_yajl_gen_string_17 == yajl_gen_status_ok))
          {
            signed long int return_value_show_json_error_16;
            return_value_show_json_error_16=show_json_error(db, "Formatter failure");
            return (signed int)return_value_show_json_error_16;
          }

        }

      }
      signed int return_value_pretty_print_jsonval_19;
      return_value_pretty_print_jsonval_19=pretty_print_jsonval(db, g, value);
      if(!(return_value_pretty_print_jsonval_19 == 0))
        return -1;

    }
  return 0;
}

// pretty_print_jsonval
// file dbjson.c line 830
static signed int pretty_print_jsonval(void *db, struct yajl_gen_t **g, signed long int enc)
{
  signed long int type;
  type=wg_get_encoded_type(db, enc);
  if(type == 2l)
  {
    void *return_value_wg_decode_record_1;
    return_value_wg_decode_record_1=wg_decode_record(db, enc);
    signed int return_value_pretty_print_json_2;
    return_value_pretty_print_json_2=pretty_print_json(db, g, return_value_wg_decode_record_1);
    if(!(return_value_pretty_print_json_2 == 0))
      return -1;

  }

  else
    if(type == 5l)
    {
      signed int len;
      signed long int return_value_wg_decode_str_len_3;
      return_value_wg_decode_str_len_3=wg_decode_str_len(db, enc);
      len = (signed int)return_value_wg_decode_str_len_3;
      char *buf;
      buf=wg_decode_str(db, enc);
      if(!(buf == ((char *)NULL)))
      {
        enum anonymous_33 return_value_yajl_gen_string_5;
        return_value_yajl_gen_string_5=yajl_gen_string(*g, (unsigned char *)buf, (unsigned long int)len);
        if(!((signed int)return_value_yajl_gen_string_5 == yajl_gen_status_ok))
        {
          signed long int return_value_show_json_error_4;
          return_value_show_json_error_4=show_json_error(db, "Formatter failure");
          return (signed int)return_value_show_json_error_4;
        }

      }

    }

    else
    {
      unsigned long int pretty_print_jsonval__1__3__len;
      char pretty_print_jsonval__1__3__buf[80l];
      wg_snprint_value(db, enc, pretty_print_jsonval__1__3__buf, 79);
      pretty_print_jsonval__1__3__len=strlen(pretty_print_jsonval__1__3__buf);
      if(type == 3l || type == 4l || type == 10l)
      {
        enum anonymous_33 return_value_yajl_gen_number_7;
        return_value_yajl_gen_number_7=yajl_gen_number(*g, pretty_print_jsonval__1__3__buf, pretty_print_jsonval__1__3__len);
        if(!((signed int)return_value_yajl_gen_number_7 == yajl_gen_status_ok))
        {
          signed long int return_value_show_json_error_6;
          return_value_show_json_error_6=show_json_error(db, "Formatter failure");
          return (signed int)return_value_show_json_error_6;
        }

      }

      else
      {
        enum anonymous_33 return_value_yajl_gen_string_9;
        return_value_yajl_gen_string_9=yajl_gen_string(*g, (unsigned char *)pretty_print_jsonval__1__3__buf, pretty_print_jsonval__1__3__len);
        if(!((signed int)return_value_yajl_gen_string_9 == yajl_gen_status_ok))
        {
          signed long int return_value_show_json_error_8;
          return_value_show_json_error_8=show_json_error(db, "Formatter failure");
          return (signed int)return_value_show_json_error_8;
        }

      }
    }
  return 0;
}

// print_cb
// file dbjson.c line 718
static void print_cb(void *cb_ctx, const char *str, unsigned long int len)
{
  struct _IO_FILE *f = (struct _IO_FILE *)cb_ctx;
  fwrite((const void *)str, len, (unsigned long int)1, f);
}

// push
// file dbjson.c line 444
static signed int push(struct anonymous_0 *ctx, enum anonymous_2 type)
{
  struct anonymous_1 *e;
  ctx->stack_ptr = ctx->stack_ptr + 1;
  if(ctx->stack_ptr >= 7)
    return 0;

  else
  {
    e = &ctx->stack[(signed long int)ctx->stack_ptr];
    e->size = 0;
    e->type = type;
    e->head = (struct __stack_entry_elem *)(void *)0;
    e->tail = (struct __stack_entry_elem *)(void *)0;
    return 1;
  }
}

// reader_thread
// file stresstest.c line 474
void * reader_thread(void *threadarg)
{
  void *db;
  signed int threadid;
  signed int i;
  signed int j;
  void *rec = (void *)0;
  db = ((struct anonymous_9 *)threadarg)->db;
  threadid = ((struct anonymous_9 *)threadarg)->threadid;
  fprintf(stdout, "Reader thread %d started.\n", threadid);
  pthread_mutex_lock(&twait_mutex);
  twait_cnt = twait_cnt + 1;
  pthread_cond_wait(&twait_cv, &twait_mutex);
  pthread_mutex_unlock(&twait_mutex);
  i = 0;
  for( ; !(i >= 100000); i = i + 1)
  {
    signed long int reclen;
    signed long int lock_id;
    lock_id=wg_start_read(db);
    if(lock_id == 0l)
    {
      fprintf(stderr, "Reader thread %d: wg_start_read failed.\n", threadid);
      goto reader_done;
    }

    if(!(i == 0))
      rec=wg_get_next_record(db, rec);

    else
      rec=wg_get_first_record(db);
    if(rec == NULL)
    {
      fprintf(stderr, "Reader thread %d: wg_get_next_record failed.\n", threadid);
      wg_end_read(db, lock_id);
      goto reader_done;
    }

    reclen=wg_get_record_len(db, rec);
    if(!(reclen >= 0l))
    {
      fprintf(stderr, "Reader thread %d: invalid record length.\n", threadid);
      wg_end_read(db, lock_id);
      goto reader_done;
    }

    j = 0;
    for( ; !((signed long int)j >= reclen); j = j + 1)
    {
      wg_get_field(db, rec, (signed long int)j);
      wg_get_field_type(db, rec, (signed long int)j);
    }
    signed long int return_value_wg_end_read_1;
    return_value_wg_end_read_1=wg_end_read(db, lock_id);
    if(return_value_wg_end_read_1 == 0l)
    {
      fprintf(stderr, "Reader thread %d: wg_end_read failed.\n", threadid);
      goto reader_done;
    }

  }
  fprintf(stdout, "Reader thread %d ended.\n", threadid);

reader_done:
  ;
  pthread_exit((void *)0);
}

// rehash_gint
// file dbhash.c line 671
static signed long int rehash_gint(signed long int val)
{
  signed int i;
  unsigned long int hash = (unsigned long int)14695981039346656037ULL;
  i = 0;
  for( ; !((unsigned long int)i >= sizeof(signed long int) /*8ul*/ ); i = i + 1)
  {
    hash = hash ^ (unsigned long int)((unsigned char *)&val)[(signed long int)i];
    hash = hash * (unsigned long int)1099511628211ULL;
  }
  return (signed long int)hash;
}

// remove_backlink_index_entries
// file dbdata.c line 471
static signed long int remove_backlink_index_entries(void *db, signed long int *record, signed long int value, signed long int depth)
{
  signed long int col;
  signed long int length;
  signed long int err = (signed long int)0;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  if((1l & record[1l]) == 0l)
  {
    length = ((*record & (signed long int)~3) >> (sizeof(signed long int) /*8ul*/  == (unsigned long int)4 ? 2 : 3)) - (signed long int)3;
    if(length >= 128l)
      length = (signed long int)(127 + 1);

    col = (signed long int)0;
    for( ; !(col >= length); col = col + 1l)
      if(record[3l + col] == value)
      {
        if(!(dbh->index_control_area_header.index_table[col] == 0l))
        {
          signed long int return_value_wg_index_del_field_1;
          return_value_wg_index_del_field_1=wg_index_del_field(db, (void *)record, col);
          if(!(return_value_wg_index_del_field_1 >= -1l))
            return (signed long int)-1;

        }

      }

  }

  if(depth >= 1l)
  {
    signed long int backlink_list = record[(signed long int)2];
    if(!(backlink_list == 0l))
    {
      struct anonymous_20 *next = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + backlink_list);
      do
      {
        signed long int return_value_wg_encode_record_2;
        return_value_wg_encode_record_2=wg_encode_record(db, (void *)record);
        err=remove_backlink_index_entries(db, (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + next->car), return_value_wg_encode_record_2, depth - (signed long int)1);
        if(!(err == 0l))
          return err;

        if(next->cdr == 0l)
          break;

        next = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + next->cdr);
      }
      while((_Bool)1);
    }

  }

  return (signed long int)0;
}

// remove_from_bucket
// file dbhash.c line 820
static signed long int remove_from_bucket(struct anonymous_34 *bucket, signed int idx)
{
  signed int i;
  signed long int val = bucket->value[(signed long int)idx];
  i = idx;
  for( ; !(i >= 7); i = i + 1)
  {
    bucket->key[(signed long int)i] = bucket->key[(signed long int)(i + 1)];
    bucket->value[(signed long int)i] = bucket->value[(signed long int)(i + 1)];
  }
  bucket->fill = bucket->fill - 1l;
  return val;
}

// remove_index_template
// file dbindex.c line 1924
static signed long int remove_index_template(void *db, signed long int template_offset)
{
  signed long int *ilist;
  void *rec;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  struct anonymous_22 *tmpl = (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + template_offset);
  rec = (void *)((char *)((struct anonymous_6 *)db)->db + tmpl->offset_matchrec);
  wg_delete_record(db, rec);
  ilist = &dbh->index_control_area_header.index_template_list;
  while(!(*ilist == 0l))
  {
    struct anonymous_20 *ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
    if(ilistelem->car == template_offset)
    {
      delete_from_list(db, ilist);
      break;
    }

    ilist = &ilistelem->cdr;
  }
  wg_free_fixlen_object(db, &dbh->indextmpl_area_header, template_offset);
  return (signed long int)0;
}

// restore_backlink_index_entries
// file dbdata.c line 529
static signed long int restore_backlink_index_entries(void *db, signed long int *record, signed long int value, signed long int depth)
{
  signed long int col;
  signed long int length;
  signed long int err = (signed long int)0;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  if((1l & record[1l]) == 0l)
  {
    length = ((*record & (signed long int)~3) >> (sizeof(signed long int) /*8ul*/  == (unsigned long int)4 ? 2 : 3)) - (signed long int)3;
    if(length >= 128l)
      length = (signed long int)(127 + 1);

    col = (signed long int)0;
    for( ; !(col >= length); col = col + 1l)
      if(record[3l + col] == value)
      {
        if(!(dbh->index_control_area_header.index_table[col] == 0l))
        {
          signed long int return_value_wg_index_add_field_1;
          return_value_wg_index_add_field_1=wg_index_add_field(db, (void *)record, col);
          if(!(return_value_wg_index_add_field_1 >= -1l))
            return (signed long int)-1;

        }

      }

  }

  if(depth >= 1l)
  {
    signed long int backlink_list = record[(signed long int)2];
    if(!(backlink_list == 0l))
    {
      struct anonymous_20 *next = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + backlink_list);
      do
      {
        signed long int return_value_wg_encode_record_2;
        return_value_wg_encode_record_2=wg_encode_record(db, (void *)record);
        err=restore_backlink_index_entries(db, (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + next->car), return_value_wg_encode_record_2, depth - (signed long int)1);
        if(!(err == 0l))
          return err;

        if(next->cdr == 0l)
          break;

        next = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + next->cdr);
      }
      while((_Bool)1);
    }

  }

  return (signed long int)0;
}

// rewind_resultset
// file dbquery.c line 1378
static void rewind_resultset(void *db, struct anonymous_17 *set)
{
  set->rcursor.page = set->first_page;
  set->rcursor.pidx = (signed long int)0;
}

// run_json_parser
// file dbjson.c line 385
static signed long int run_json_parser(void *db, char *buf, struct anonymous *cb, signed int isparam, signed int isdocument, void **document)
{
  signed int count = 0;
  signed int result = 0;
  struct yajl_handle_t *hand = (struct yajl_handle_t *)(void *)0;
  char *iptr = buf;
  struct anonymous_0 ctx;
  ctx.state = 0;
  ctx.stack_ptr = -1;
  ctx.db = db;
  ctx.isparam = isparam;
  ctx.isdocument = isdocument;
  ctx.document = document;
  hand=yajl_alloc(cb, (struct anonymous_3 *)(void *)0, (void *)&ctx);
  yajl_config(hand, (enum anonymous_4)yajl_allow_comments, 1);
  unsigned long int return_value_strnlen_1;
  do
  {
    return_value_strnlen_1=strnlen(iptr, (unsigned long int)16384);
    count = (signed int)return_value_strnlen_1;
    if(!(count >= 1))
      break;

    enum anonymous_27 return_value_yajl_parse_2;
    return_value_yajl_parse_2=yajl_parse(hand, (unsigned char *)iptr, (unsigned long int)count);
    if(!((signed int)return_value_yajl_parse_2 == yajl_status_ok))
    {
      show_json_error(db, "JSON parsing failed");
      result = -2;
      goto done;
    }

    iptr = iptr + (signed long int)count;
  }
  while((_Bool)1);
  enum anonymous_27 return_value_yajl_complete_parse_3;
  return_value_yajl_complete_parse_3=yajl_complete_parse(hand);
  if(!((signed int)return_value_yajl_complete_parse_3 == yajl_status_ok))
  {
    show_json_error(db, "JSON parsing failed");
    result = -2;
  }


done:
  ;
  if(!(hand == ((struct yajl_handle_t *)NULL)))
    yajl_free(hand);

  return (signed long int)result;
}

// run_workers
// file stresstest.c line 222
void run_workers(void *db, signed int rcnt, signed int wcnt)
{
  struct anonymous_9 *pt_table;
  signed int i;
  signed int tcnt;
  signed int err;
  void *status;
  union pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, 0);
  pthread_mutex_init(&twait_mutex, (const union anonymous_11 *)(void *)0);
  pthread_cond_init(&twait_cv, (const union anonymous_11 *)(void *)0);
  tcnt = rcnt + wcnt;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)tcnt * sizeof(struct anonymous_9) /*24ul*/ );
  pt_table = (struct anonymous_9 *)return_value_malloc_1;
  if(pt_table == ((struct anonymous_9 *)NULL))
    fprintf(stderr, "Failed to allocate thread table: skipping tests.\n");

  else
  {
    twait_cnt = 0;
    i = 0;
    for( ; !(i >= tcnt); i = i + 1)
    {
      (pt_table + (signed long int)i)->db = db;
      (pt_table + (signed long int)i)->threadid = i;
      if(!(i >= wcnt))
        err=pthread_create(&(pt_table + (signed long int)i)->pth, &attr, writer_thread, (void *)&pt_table[(signed long int)i]);

      else
        err=pthread_create(&(pt_table + (signed long int)i)->pth, &attr, reader_thread, (void *)&pt_table[(signed long int)i]);
      if(!(err == 0))
      {
        fprintf(stderr, "Error code from pthread_create: %d.\n", err);
        goto workers_done;
      }

    }
    do
    {
      pthread_mutex_lock(&twait_mutex);
      if(twait_cnt >= tcnt)
        break;

      pthread_mutex_unlock(&twait_mutex);
    }
    while((_Bool)1);
    pthread_cond_broadcast(&twait_cv);
    pthread_mutex_unlock(&twait_mutex);
    i = 0;
    for( ; !(i >= tcnt); i = i + 1)
    {
      err=pthread_join((pt_table + (signed long int)i)->pth, &status);
      if(!(err == 0))
      {
        fprintf(stderr, "Error code from pthread_join: %d.\n", err);
        break;
      }

    }

  workers_done:
    ;
    pthread_attr_destroy(&attr);
    pthread_mutex_destroy(&twait_mutex);
    pthread_cond_destroy(&twait_cv);
    free((void *)pt_table);
  }
}

// scalar_to_ymd
// file dbdata.c line 2912
static void scalar_to_ymd(signed long int scalar, unsigned int *yr, unsigned int *mo, unsigned int *day)
{
  unsigned int n = (unsigned int)((scalar * 400L) / 146097L);
  signed long int return_value_years_to_days_1;
  do
  {
    return_value_years_to_days_1=years_to_days(n);
    if(return_value_years_to_days_1 >= scalar)
      break;

    n = n + 1u;
  }
  while((_Bool)1);
  *yr = n;
  signed long int return_value_years_to_days_2;
  return_value_years_to_days_2=years_to_days(n - (unsigned int)1);
  n = (unsigned int)(scalar - return_value_years_to_days_2);
  if(n >= 60u)
  {
    n = n + (unsigned int)2;
    signed int return_value_isleap_3;
    return_value_isleap_3=isleap(*yr);
    if(!(return_value_isleap_3 == 0))
      n = n - (unsigned int)(n > (unsigned int)62 ? 1 : 2);

  }

  *mo = (n * (unsigned int)100 + (unsigned int)3007) / (unsigned int)3057;
  unsigned int return_value_months_to_days_4;
  return_value_months_to_days_4=months_to_days(*mo);
  *day = n - return_value_months_to_days_4;
}

// show_consistency_error_nr
// file dbhash.c line 965
static signed long int show_consistency_error_nr(void *db, char *errmsg, signed long int nr)
{
  fprintf(stderr, "wg consistency error: %s %d\n", errmsg, (signed int)nr);
  return (signed long int)-1;
}

// show_data_error
// file dbdata.c line 3165
static signed long int show_data_error(void *db, char *errmsg)
{
  fprintf(stderr, "wg data handling error: %s\n", errmsg);
  return (signed long int)-1;
}

// show_data_error_double
// file dbdata.c line 3183
static signed long int show_data_error_double(void *db, char *errmsg, double nr)
{
  fprintf(stderr, "wg data handling error: %s %f\n", errmsg, nr);
  return (signed long int)-1;
}

// show_data_error_nr
// file dbdata.c line 3174
static signed long int show_data_error_nr(void *db, char *errmsg, signed long int nr)
{
  fprintf(stderr, "wg data handling error: %s %d\n", errmsg, (signed int)nr);
  return (signed long int)-1;
}

// show_data_error_str
// file dbdata.c line 3192
static signed long int show_data_error_str(void *db, char *errmsg, char *str)
{
  fprintf(stderr, "wg data handling error: %s %s\n", errmsg, str);
  return (signed long int)-1;
}

// show_dballoc_error
// file dballoc.c line 1427
static signed long int show_dballoc_error(void *db, char *errmsg)
{
  fprintf(stderr, "db memory allocation error: %s\n", errmsg);
  return (signed long int)-1;
}

// show_dballoc_error_nr
// file dballoc.c line 1441
static signed long int show_dballoc_error_nr(void *db, char *errmsg, signed long int nr)
{
  fprintf(stderr, "db memory allocation error: %s %d\n", errmsg, (signed int)nr);
  return (signed long int)-1;
}

// show_dump_error
// file dbdump.c line 360
static signed long int show_dump_error(void *db, char *errmsg)
{
  fprintf(stderr, "wg dump error: %s.\n", errmsg);
  return (signed long int)-1;
}

// show_dump_error_str
// file dbdump.c line 369
static signed long int show_dump_error_str(void *db, char *errmsg, char *str)
{
  fprintf(stderr, "wg dump error: %s: %s.\n", errmsg, str);
  return (signed long int)-1;
}

// show_ginthash_error
// file dbhash.c line 999
static signed long int show_ginthash_error(void *db, char *errmsg)
{
  fprintf(stderr, "wg gint hash error: %s\n", errmsg);
  return (signed long int)-1;
}

// show_hash_error
// file dbhash.c line 991
static signed long int show_hash_error(void *db, char *errmsg)
{
  fprintf(stderr, "wg hash error: %s\n", errmsg);
  return (signed long int)-1;
}

// show_index_error
// file dbindex.c line 2992
static signed long int show_index_error(void *db, char *errmsg)
{
  fprintf(stderr, "index error: %s\n", errmsg);
  return (signed long int)-1;
}

// show_index_error_nr
// file dbindex.c line 3006
static signed long int show_index_error_nr(void *db, char *errmsg, signed long int nr)
{
  fprintf(stderr, "index error: %s %d\n", errmsg, (signed int)nr);
  return (signed long int)-1;
}

// show_io_error
// file dbutil.c line 1269
static signed long int show_io_error(void *db, char *errmsg)
{
  fprintf(stderr, "I/O error: %s.\n", errmsg);
  return (signed long int)-1;
}

// show_io_error_str
// file dbutil.c line 1277
static signed long int show_io_error_str(void *db, char *errmsg, char *str)
{
  fprintf(stderr, "I/O error: %s: %s.\n", errmsg, str);
  return (signed long int)-1;
}

// show_json_error
// file dbjson.c line 869
static signed long int show_json_error(void *db, char *errmsg)
{
  fprintf(stderr, "wg json I/O error: %s.\n", errmsg);
  return (signed long int)-1;
}

// show_json_error_byte
// file dbjson.c line 885
static signed long int show_json_error_byte(void *db, char *errmsg, signed int byte)
{
  fprintf(stderr, "wg json I/O error: %s (byte=%d)\n", errmsg, byte);
  return (signed long int)-1;
}

// show_json_error_fn
// file dbjson.c line 877
static signed long int show_json_error_fn(void *db, char *errmsg, char *filename)
{
  fprintf(stderr, "wg json I/O error: %s (file=`%s`)\n", errmsg, filename);
  return (signed long int)-1;
}

// show_lock_error
// file dblock.c line 1431
static signed long int show_lock_error(void *db, char *errmsg)
{
  fprintf(stderr, "wg locking error: %s.\n", errmsg);
  return (signed long int)-1;
}

// show_log_error
// file dblog.c line 1179
static signed long int show_log_error(void *db, char *errmsg)
{
  fprintf(stderr, "wg log error: %s.\n", errmsg);
  return (signed long int)-1;
}

// show_memory_error
// file dbmem.c line 873
static signed long int show_memory_error(char *errmsg)
{
  fprintf(stderr, "wg memory error: %s.\n", errmsg);
  return (signed long int)-1;
}

// show_mpool_error
// file dbmpool.c line 490
static signed int show_mpool_error(void *db, char *errmsg)
{
  fprintf(stderr, "db memory pool allocation error: %s\n", errmsg);
  return -1;
}

// show_mpool_error_nr
// file dbmpool.c line 504
static signed int show_mpool_error_nr(void *db, char *errmsg, signed int nr)
{
  fprintf(stderr, "db memory pool allocation error: %s %d\n", errmsg, nr);
  return -1;
}

// show_query_error
// file dbquery.c line 2279
static signed long int show_query_error(void *db, char *errmsg)
{
  fprintf(stderr, "query error: %s\n", errmsg);
  return (signed long int)-1;
}

// show_schema_error
// file dbschema.c line 259
static signed long int show_schema_error(void *db, char *errmsg)
{
  fprintf(stderr, "wg schema error: %s.\n", errmsg);
  return (signed long int)-1;
}

// snprint_record
// file dbutil.c line 166
static void snprint_record(void *db, signed long int *rec, char *buf, signed int buflen)
{
  char *strbuf;
  char *tmp_post_1;
  char *tmp_post_4;
  char *tmp_post_5;
  if(rec == ((signed long int *)NULL))
    snprintf(buf, (unsigned long int)buflen, "<null rec pointer>\n");

  else
    if(buflen >= 2)
    {
      tmp_post_1 = buf;
      buf = buf + 1l;
      *tmp_post_1 = (char)91;
      buflen = buflen - 1;
      void *return_value_malloc_2;
      return_value_malloc_2=malloc((unsigned long int)buflen);
      strbuf = (char *)return_value_malloc_2;
      if(!(strbuf == ((char *)NULL)))
      {
        signed int i;
        signed int strbuflen;
        signed long int enc;
        signed long int len;
        len=wg_get_record_len(db, (void *)rec);
        i = 0;
        for( ; !((signed long int)i >= len); i = i + 1)
        {
          enc=wg_get_field(db, (void *)rec, (signed long int)i);
          wg_snprint_value(db, enc, strbuf, buflen);
          unsigned long int return_value_strlen_3;
          return_value_strlen_3=strlen(strbuf);
          strbuflen = (signed int)return_value_strlen_3;
          if(!(buflen >= 2 + strbuflen))
            break;

          if(!(i == 0))
          {
            tmp_post_4 = buf;
            buf = buf + 1l;
            *tmp_post_4 = (char)44;
            buflen = buflen - 1;
          }

          strncpy(buf, strbuf, (unsigned long int)buflen);
          buflen = buflen - strbuflen;
          buf = buf + (signed long int)strbuflen;
          if(!(buflen >= 2))
            break;

        }
        free((void *)strbuf);
      }

      if(buflen >= 2)
      {
        tmp_post_5 = buf;
        buf = buf + 1l;
        *tmp_post_5 = (char)93;
      }

      *buf = (char)0;
    }

}

// snprint_value_csv
// file dbutil.c line 342
static void snprint_value_csv(void *db, signed long int enc, char *buf, signed int buflen)
{
  signed int intdata;
  signed int ilen;
  double doubledata;
  char strbuf[80l];
  char *ibuf;
  buflen = buflen - 1;
  signed long int return_value_wg_get_encoded_type_1;
  return_value_wg_get_encoded_type_1=wg_get_encoded_type(db, enc);
  void *return_value_wg_decode_record_2;
  signed long int return_value_wg_decode_int_3;
  char *return_value_wg_decode_str_4;
  char *return_value_wg_decode_xmlliteral_5;
  signed long int return_value_wg_decode_uri_len_6;
  signed long int return_value_wg_decode_uri_prefix_len_7;
  void *return_value_malloc_8;
  char *return_value_wg_decode_uri_prefix_9;
  char *return_value_wg_decode_uri_10;
  char return_value_wg_decode_char_11;
  switch(return_value_wg_get_encoded_type_1)
  {
    case (signed long int)1:
    {
      buf[(signed long int)0] = (char)0;
      break;
    }
    case (signed long int)2:
    {
      return_value_wg_decode_record_2=wg_decode_record(db, enc);
      intdata = (signed int)(signed long int)((char *)return_value_wg_decode_record_2 - (char *)((struct anonymous_6 *)db)->db);
      snprintf(buf, (unsigned long int)buflen, "\"<record offset %d>\"", intdata);
      break;
    }
    case (signed long int)3:
    {
      return_value_wg_decode_int_3=wg_decode_int(db, enc);
      intdata = (signed int)return_value_wg_decode_int_3;
      snprintf(buf, (unsigned long int)buflen, "%d", intdata);
      break;
    }
    case (signed long int)4:
    {
      doubledata=wg_decode_double(db, enc);
      snprintf(buf, (unsigned long int)buflen, "%f", doubledata);
      break;
    }
    case (signed long int)10:
    {
      doubledata=wg_decode_fixpoint(db, enc);
      snprintf(buf, (unsigned long int)buflen, "%f", doubledata);
      break;
    }
    case (signed long int)5:
    {
      return_value_wg_decode_str_4=wg_decode_str(db, enc);
      csv_escaped_str(db, return_value_wg_decode_str_4, buf, buflen);
      break;
    }
    case (signed long int)6:
    {
      return_value_wg_decode_xmlliteral_5=wg_decode_xmlliteral(db, enc);
      csv_escaped_str(db, return_value_wg_decode_xmlliteral_5, buf, buflen);
      break;
    }
    case (signed long int)7:
    {
      return_value_wg_decode_uri_len_6=wg_decode_uri_len(db, enc);
      ilen = (signed int)return_value_wg_decode_uri_len_6;
      return_value_wg_decode_uri_prefix_len_7=wg_decode_uri_prefix_len(db, enc);
      ilen = ilen + (signed int)return_value_wg_decode_uri_prefix_len_7;
      return_value_malloc_8=malloc((unsigned long int)(ilen + 1));
      ibuf = (char *)return_value_malloc_8;
      if(ibuf == ((char *)NULL))
      {
        show_io_error(db, "Failed to allocate memory");
        goto __CPROVER_DUMP_L15;
      }

      return_value_wg_decode_uri_prefix_9=wg_decode_uri_prefix(db, enc);
      return_value_wg_decode_uri_10=wg_decode_uri(db, enc);
      snprintf(ibuf, (unsigned long int)(ilen + 1), "%s%s", return_value_wg_decode_uri_prefix_9, return_value_wg_decode_uri_10);
      csv_escaped_str(db, ibuf, buf, buflen);
      free((void *)ibuf);
      break;
    }
    case (signed long int)9:
    {
      return_value_wg_decode_char_11=wg_decode_char(db, enc);
      intdata = (signed int)return_value_wg_decode_char_11;
      snprintf(buf, (unsigned long int)buflen, "%c", (char)intdata);
      break;
    }
    case (signed long int)11:
    {
      intdata=wg_decode_date(db, enc);
      wg_strf_iso_datetime(db, intdata, 0, strbuf);
      strbuf[(signed long int)10] = (char)0;
      snprintf(buf, (unsigned long int)buflen, "%s", (const void *)strbuf);
      break;
    }
    case (signed long int)12:
    {
      intdata=wg_decode_time(db, enc);
      wg_strf_iso_datetime(db, 1, intdata, strbuf);
      snprintf(buf, (unsigned long int)buflen, "%s", strbuf + (signed long int)11);
      break;
    }
    default:
      snprintf(buf, (unsigned long int)buflen, "\"<unsupported type>\"");
  }

__CPROVER_DUMP_L15:
  ;
}

// sort_columns
// file dbindex.c line 2001
static signed long int sort_columns(signed long int *sorted_cols, signed long int *columns, signed long int col_count)
{
  signed long int i = (signed long int)0;
  signed long int prev = (signed long int)-1;
  signed long int tmp_post_1;
  while(!(i >= col_count))
  {
    signed long int lowest = (signed long int)(127 + 1);
    signed long int j = (signed long int)0;
    for( ; !(j >= col_count); j = j + 1l)
      if(!(columns[j] >= lowest))
      {
        if(!(prev >= columns[j]))
          lowest = columns[j];

      }

    if(lowest == 128l)
      break;

    tmp_post_1 = i;
    i = i + 1l;
    sorted_cols[tmp_post_1] = lowest;
    prev = lowest;
  }
  return i;
}

// split_free
// file dballoc.c line 1057
static signed long int split_free(void *db, void *area_header, signed long int nr, signed long int *freebuckets, signed long int i)
{
  signed long int object;
  signed long int oldsize;
  signed long int oldnextptr;
  signed long int splitsize;
  signed long int splitobject;
  signed long int splitindex;
  signed long int freelist;
  signed long int dv;
  signed long int dvsize;
  signed long int dvindex;
  object = freebuckets[i];
  oldsize = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + object));
  if(!((3l & oldsize) == 1l))
    return (signed long int)-1;

  else
  {
    oldsize = oldsize & (signed long int)~3;
    oldnextptr = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)object + sizeof(signed long int) /*8ul*/ )));
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + object)) = nr & (signed long int)~3;
    freebuckets[i] = oldnextptr;
    splitsize = oldsize - nr;
    splitobject = object + nr;
    dvsize = freebuckets[(signed long int)(256 + 32 + 1)];
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + splitobject)) = splitsize & (signed long int)~3 | (signed long int)1;
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)(splitobject + splitsize) - sizeof(signed long int) /*8ul*/ ))) = splitsize & (signed long int)~3 | (signed long int)1;
    splitindex=wg_freebuckets_index(db, splitsize);
    if(!(splitindex >= 0l))
      return splitindex;

    freelist = freebuckets[splitindex];
    if(!(freelist == 0l))
      *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)freelist + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = splitobject;

    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)splitobject + sizeof(signed long int) /*8ul*/ ))) = freelist;
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)splitobject + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)((char *)&freebuckets[splitindex] - (char *)((struct anonymous_6 *)db)->db);
    freebuckets[splitindex] = splitobject;
    return (signed long int)0;
  }
}

// ttree_add_row
// file dbindex.c line 427
static signed long int ttree_add_row(void *db, signed long int index_id, void *rec)
{
  signed long int rootoffset;
  signed long int column;
  signed long int newvalue;
  signed long int boundtype;
  signed long int bnodeoffset;
  signed long int newoffset;
  struct wg_tnode *node;
  struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + index_id);
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  rootoffset = hdr->ctl.t.offset_root_node;
  signed long int tmp_if_expr_4;
  signed long int return_value_wg_get_field_2;
  signed long int return_value_wg_compare_3;
  signed long int tmp_if_expr_8;
  signed long int return_value_wg_get_field_6;
  signed long int return_value_wg_compare_7;
  if(rootoffset == 0l)
  {
    fprintf(stderr, "index at offset %d does not exist\n", (signed int)index_id);
    return (signed long int)-1;
  }

  else
  {
    column = hdr->rec_field_index[(signed long int)0];
    newvalue=wg_get_field(db, rec, column);
    bnodeoffset=wg_search_ttree_rightmost(db, rootoffset, newvalue, &boundtype, (struct wg_tnode *)(void *)0);
    node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + bnodeoffset);
    newoffset = (signed long int)0;
    if(boundtype == 0l)
    {
      if(!((signed int)node->number_of_elements >= 8))
      {
        signed int i;
        signed int j;
        signed long int cr;
        i = 0;
        for( ; !(i >= (signed int)node->number_of_elements); i = i + 1)
        {
          signed long int return_value_wg_get_field_1;
          return_value_wg_get_field_1=wg_get_field(db, (void *)((char *)((struct anonymous_6 *)db)->db + node->array_of_values[(signed long int)i]), column);
          if(return_value_wg_get_field_1 == newvalue)
            tmp_if_expr_4 = (signed long int)0;

          else
          {
            return_value_wg_get_field_2=wg_get_field(db, (void *)((char *)((struct anonymous_6 *)db)->db + node->array_of_values[(signed long int)i]), column);
            return_value_wg_compare_3=wg_compare(db, return_value_wg_get_field_2, newvalue, 7);
            tmp_if_expr_4 = return_value_wg_compare_3;
          }
          cr = tmp_if_expr_4;
          if(!(cr == -1l))
          {
            j = (signed int)node->number_of_elements;
            for( ; !(i >= j); j = j - 1)
              node->array_of_values[(signed long int)j] = node->array_of_values[(signed long int)(j - 1)];
            break;
          }

        }
        node->array_of_values[(signed long int)i] = (signed long int)((char *)rec - (char *)((struct anonymous_6 *)db)->db);
        node->number_of_elements = node->number_of_elements + 1;
        if(i == 0)
          node->current_min = newvalue;

      }

      else
      {
        signed int ttree_add_row__1__2__2__i;
        signed int ttree_add_row__1__2__2__j;
        signed long int ttree_add_row__1__2__2__cr;
        signed long int minvalue;
        signed long int minvaluerowoffset;
        minvalue = node->current_min;
        minvaluerowoffset = node->array_of_values[(signed long int)0];
        ttree_add_row__1__2__2__i = 8 - 1;
        for( ; ttree_add_row__1__2__2__i >= 1; ttree_add_row__1__2__2__i = ttree_add_row__1__2__2__i - 1)
        {
          signed long int return_value_wg_get_field_5;
          return_value_wg_get_field_5=wg_get_field(db, (void *)((char *)((struct anonymous_6 *)db)->db + node->array_of_values[(signed long int)ttree_add_row__1__2__2__i]), column);
          if(return_value_wg_get_field_5 == newvalue)
            tmp_if_expr_8 = (signed long int)0;

          else
          {
            return_value_wg_get_field_6=wg_get_field(db, (void *)((char *)((struct anonymous_6 *)db)->db + node->array_of_values[(signed long int)ttree_add_row__1__2__2__i]), column);
            return_value_wg_compare_7=wg_compare(db, return_value_wg_get_field_6, newvalue, 7);
            tmp_if_expr_8 = return_value_wg_compare_7;
          }
          ttree_add_row__1__2__2__cr = tmp_if_expr_8;
          if(!(ttree_add_row__1__2__2__cr == 1l))
          {
            ttree_add_row__1__2__2__j = 0;
            for( ; !(ttree_add_row__1__2__2__j >= ttree_add_row__1__2__2__i); ttree_add_row__1__2__2__j = ttree_add_row__1__2__2__j + 1)
              node->array_of_values[(signed long int)ttree_add_row__1__2__2__j] = node->array_of_values[(signed long int)(ttree_add_row__1__2__2__j + 1)];
            break;
          }

        }
        node->array_of_values[(signed long int)ttree_add_row__1__2__2__i] = (signed long int)((char *)rec - (char *)((struct anonymous_6 *)db)->db);
        if(ttree_add_row__1__2__2__i == 0)
          node->current_min = newvalue;

        else
        {
          node->current_min=wg_get_field(db, (void *)((char *)((struct anonymous_6 *)db)->db + node->array_of_values[(signed long int)0]), column);
          if(ttree_add_row__1__2__2__i == 8)
            node->current_max = newvalue;

        }
        if(!(node->left_child_offset == 0l))
        {
          signed long int greatestlb = node->pred_offset;
          node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + greatestlb);
        }

        if(!((signed int)node->number_of_elements >= 8))
        {
          node->array_of_values[(signed long int)node->number_of_elements] = minvaluerowoffset;
          node->number_of_elements = node->number_of_elements + 1;
          node->current_max = minvalue;
        }

        else
        {
          struct wg_tnode *leaf;
          signed long int newnode;
          newnode=wg_alloc_fixlen_object(db, (void *)&dbh->tnode_area_header);
          if(newnode == 0l)
            return (signed long int)-1;

          leaf = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + newnode);
          leaf->parent_offset = (signed long int)((char *)node - (char *)((struct anonymous_6 *)db)->db);
          leaf->left_subtree_height = (unsigned char)0;
          leaf->right_subtree_height = (unsigned char)0;
          leaf->current_max = minvalue;
          leaf->current_min = minvalue;
          leaf->number_of_elements = (signed short int)1;
          leaf->left_child_offset = (signed long int)0;
          leaf->right_child_offset = (signed long int)0;
          leaf->array_of_values[(signed long int)0] = minvaluerowoffset;
          if(bnodeoffset == (char *)node - (char *)((struct anonymous_6 *)db)->db)
          {
            node->left_child_offset = newnode;
            leaf->succ_offset = (signed long int)((char *)node - (char *)((struct anonymous_6 *)db)->db);
            leaf->pred_offset = node->pred_offset;
            if(!(node->pred_offset == 0l))
            {
              struct wg_tnode *pred = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + node->pred_offset);
              pred->succ_offset = newnode;
            }

            else
              hdr->ctl.t.offset_min_node = newnode;
            node->pred_offset = newnode;
          }

          else
          {
            struct wg_tnode *succ;
            node->right_child_offset = newnode;
            leaf->succ_offset = node->succ_offset;
            leaf->pred_offset = (signed long int)((char *)node - (char *)((struct anonymous_6 *)db)->db);
            if(node->succ_offset == 0l)
            {
              show_index_error(db, "GLB with no successor, panic");
              return (signed long int)-1;
            }

            else
            {
              succ = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + leaf->succ_offset);
              succ->pred_offset = newnode;
            }
            node->succ_offset = newnode;
          }
          newoffset = newnode;
        }
      }
    }

    else
      if(!((signed int)node->number_of_elements >= 8))
      {
        signed int ttree_add_row__1__3__1__i;
        if(boundtype == 1l)
        {
          ttree_add_row__1__3__1__i = (signed int)node->number_of_elements;
          for( ; ttree_add_row__1__3__1__i >= 1; ttree_add_row__1__3__1__i = ttree_add_row__1__3__1__i - 1)
            node->array_of_values[(signed long int)ttree_add_row__1__3__1__i] = node->array_of_values[(signed long int)(ttree_add_row__1__3__1__i - 1)];
          node->array_of_values[(signed long int)0] = (signed long int)((char *)rec - (char *)((struct anonymous_6 *)db)->db);
          node->current_min = newvalue;
        }

        else
        {
          node->array_of_values[(signed long int)node->number_of_elements] = (signed long int)((char *)rec - (char *)((struct anonymous_6 *)db)->db);
          node->current_max = newvalue;
        }
        node->number_of_elements = node->number_of_elements + 1;
        if((signed int)node->number_of_elements == 1)
        {
          node->current_max = newvalue;
          node->current_min = newvalue;
        }

      }

      else
      {
        struct wg_tnode *ttree_add_row__1__3__2__leaf;
        signed long int ttree_add_row__1__3__2__newnode;
        ttree_add_row__1__3__2__newnode=wg_alloc_fixlen_object(db, (void *)&dbh->tnode_area_header);
        if(ttree_add_row__1__3__2__newnode == 0l)
          return (signed long int)-1;

        ttree_add_row__1__3__2__leaf = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + ttree_add_row__1__3__2__newnode);
        ttree_add_row__1__3__2__leaf->parent_offset = (signed long int)((char *)node - (char *)((struct anonymous_6 *)db)->db);
        ttree_add_row__1__3__2__leaf->left_subtree_height = (unsigned char)0;
        ttree_add_row__1__3__2__leaf->right_subtree_height = (unsigned char)0;
        ttree_add_row__1__3__2__leaf->current_max = newvalue;
        ttree_add_row__1__3__2__leaf->current_min = newvalue;
        ttree_add_row__1__3__2__leaf->number_of_elements = (signed short int)1;
        ttree_add_row__1__3__2__leaf->left_child_offset = (signed long int)0;
        ttree_add_row__1__3__2__leaf->right_child_offset = (signed long int)0;
        ttree_add_row__1__3__2__leaf->array_of_values[(signed long int)0] = (signed long int)((char *)rec - (char *)((struct anonymous_6 *)db)->db);
        newoffset = ttree_add_row__1__3__2__newnode;
        if(boundtype == 1l)
        {
          node->left_child_offset = ttree_add_row__1__3__2__newnode;
          ttree_add_row__1__3__2__leaf->succ_offset = (signed long int)((char *)node - (char *)((struct anonymous_6 *)db)->db);
          ttree_add_row__1__3__2__leaf->pred_offset = node->pred_offset;
          if(!(node->pred_offset == 0l))
          {
            struct wg_tnode *ttree_add_row__1__3__2__1__1__pred = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + node->pred_offset);
            ttree_add_row__1__3__2__1__1__pred->succ_offset = ttree_add_row__1__3__2__newnode;
          }

          else
            hdr->ctl.t.offset_min_node = ttree_add_row__1__3__2__newnode;
          node->pred_offset = ttree_add_row__1__3__2__newnode;
        }

        else
          if(boundtype == 2l)
          {
            node->right_child_offset = ttree_add_row__1__3__2__newnode;
            ttree_add_row__1__3__2__leaf->succ_offset = node->succ_offset;
            ttree_add_row__1__3__2__leaf->pred_offset = (signed long int)((char *)node - (char *)((struct anonymous_6 *)db)->db);
            if(!(node->succ_offset == 0l))
            {
              struct wg_tnode *ttree_add_row__1__3__2__2__1__succ = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + node->succ_offset);
              ttree_add_row__1__3__2__2__1__succ->pred_offset = ttree_add_row__1__3__2__newnode;
            }

            else
              hdr->ctl.t.offset_max_node = ttree_add_row__1__3__2__newnode;
            node->succ_offset = ttree_add_row__1__3__2__newnode;
          }

      }
    if(!(newoffset == 0l))
    {
      struct wg_tnode *child = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + newoffset);
      struct wg_tnode *parent;
      signed int left = 0;
      while(!(child->parent_offset == 0l))
      {
        signed int balance;
        parent = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + child->parent_offset);
        if(parent->left_child_offset == (char *)child - (char *)((struct anonymous_6 *)db)->db)
          left = 1;

        else
          left = 0;
        if(!(left == 0))
          parent->left_subtree_height = parent->left_subtree_height + 1;

        else
          parent->right_subtree_height = parent->right_subtree_height + 1;
        balance = (signed int)parent->left_subtree_height - (signed int)parent->right_subtree_height;
        if(balance == 0)
          break;

        if(balance >= 2 || !(balance >= -1))
        {
          signed int overw;
          overw=db_which_branch_causes_overweight(db, parent);
          db_rotate_ttree(db, index_id, parent, overw);
          break;
        }

        else
          child = parent;
      }
    }

    return (signed long int)0;
  }
}

// ttree_remove_row
// file dbindex.c line 762
static signed long int ttree_remove_row(void *db, signed long int index_id, void *rec)
{
  signed int ttree_remove_row__1__i;
  signed int found;
  signed long int key;
  signed long int rootoffset;
  signed long int column;
  signed long int boundtype;
  signed long int bnodeoffset;
  signed long int rowoffset;
  struct wg_tnode *node;
  struct wg_tnode *parent;
  struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + index_id);
  rootoffset = hdr->ctl.t.offset_root_node;
  signed long int tmp_if_expr_2;
  signed long int return_value_wg_compare_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_4;
  signed int tmp_if_expr_8;
  if(rootoffset == 0l)
  {
    fprintf(stderr, "index at offset %d does not exist\n", (signed int)index_id);
    return (signed long int)-1;
  }

  else
  {
    column = hdr->rec_field_index[(signed long int)0];
    key=wg_get_field(db, rec, column);
    rowoffset = (signed long int)((char *)rec - (char *)((struct anonymous_6 *)db)->db);
    bnodeoffset=wg_search_ttree_leftmost(db, rootoffset, key, &boundtype, (struct wg_tnode *)(void *)0);
    node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + bnodeoffset);
    if(!(boundtype == 0l))
      return (signed long int)-2;

    else
    {
      found = -1;
      do
      {
        ttree_remove_row__1__i = 0;
        for( ; !(ttree_remove_row__1__i >= (signed int)node->number_of_elements); ttree_remove_row__1__i = ttree_remove_row__1__i + 1)
          if(node->array_of_values[(signed long int)ttree_remove_row__1__i] == rowoffset)
          {
            found = ttree_remove_row__1__i;
            goto found_row;
          }

        bnodeoffset = node->succ_offset;
        if(bnodeoffset == 0l)
          break;

        node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + bnodeoffset);
        if(node->current_min == key)
          tmp_if_expr_2 = (signed long int)0;

        else
        {
          return_value_wg_compare_1=wg_compare(db, node->current_min, key, 7);
          tmp_if_expr_2 = return_value_wg_compare_1;
        }
        if(tmp_if_expr_2 == 1l)
          break;

      }
      while((_Bool)1);

    found_row:
      ;
      if(found == -1)
        return (signed long int)-3;

      else
      {
        node->number_of_elements = node->number_of_elements - 1;
        if(!(found >= (signed int)node->number_of_elements))
        {
          ttree_remove_row__1__i = found;
          for( ; !(ttree_remove_row__1__i >= (signed int)node->number_of_elements); ttree_remove_row__1__i = ttree_remove_row__1__i + 1)
            node->array_of_values[(signed long int)ttree_remove_row__1__i] = node->array_of_values[(signed long int)(ttree_remove_row__1__i + 1)];
        }

        if(found == (signed int)node->number_of_elements)
          tmp_if_expr_3 = (signed int)node->number_of_elements != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
          node->current_max=wg_get_field(db, (void *)((char *)((struct anonymous_6 *)db)->db + node->array_of_values[(signed long int)((signed int)node->number_of_elements - 1)]), column);

        else
          if(found == 0)
          {
            if(!((signed int)node->number_of_elements == 0))
              node->current_min=wg_get_field(db, (void *)((char *)((struct anonymous_6 *)db)->db + node->array_of_values[(signed long int)0]), column);

          }

        if(!((signed int)node->number_of_elements >= 5))
        {
          if(!(node->left_child_offset == 0l))
          {
            if(!(node->right_child_offset == 0l))
            {
              signed long int greatestlb = node->pred_offset;
              struct wg_tnode *glbnode = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + greatestlb);
              ttree_remove_row__1__i = (signed int)node->number_of_elements;
              for( ; ttree_remove_row__1__i >= 1; ttree_remove_row__1__i = ttree_remove_row__1__i - 1)
                node->array_of_values[(signed long int)ttree_remove_row__1__i] = node->array_of_values[(signed long int)(ttree_remove_row__1__i - 1)];
              node->array_of_values[(signed long int)0] = glbnode->array_of_values[(signed long int)((signed int)glbnode->number_of_elements - 1)];
              node->number_of_elements = node->number_of_elements + 1;
              node->current_min = glbnode->current_max;
              if((signed int)node->number_of_elements == 1)
                node->current_max = glbnode->current_max;

              glbnode->number_of_elements = glbnode->number_of_elements - 1;
              if(!((signed int)glbnode->number_of_elements == 0))
                glbnode->current_max=wg_get_field(db, (void *)((char *)((struct anonymous_6 *)db)->db + glbnode->array_of_values[(signed long int)((signed int)glbnode->number_of_elements - 1)]), column);

              node = glbnode;
            }

          }

        }

        parent = (struct wg_tnode *)(void *)0;
        if(node->left_child_offset == 0l)
        {
          if(node->right_child_offset == 0l)
          {
            if((signed int)node->number_of_elements == 0)
            {
              if(!(node->parent_offset == 0l))
              {
                parent = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + node->parent_offset);
                if(parent->left_child_offset == (char *)node - (char *)((struct anonymous_6 *)db)->db)
                {
                  parent->left_child_offset = (signed long int)0;
                  parent->left_subtree_height = (unsigned char)0;
                }

                else
                {
                  parent->right_child_offset = (signed long int)0;
                  parent->right_subtree_height = (unsigned char)0;
                }
              }

              if(!(node->succ_offset == 0l))
              {
                struct wg_tnode *succ = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + node->succ_offset);
                succ->pred_offset = node->pred_offset;
              }

              else
                hdr->ctl.t.offset_max_node = node->pred_offset;
              if(!(node->pred_offset == 0l))
              {
                struct wg_tnode *pred = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + node->pred_offset);
                pred->succ_offset = node->succ_offset;
              }

              else
                hdr->ctl.t.offset_min_node = node->succ_offset;
              if(!(node == (struct wg_tnode *)((char *)((struct anonymous_6 *)db)->db + hdr->ctl.t.offset_root_node)))
                wg_free_tnode(db, (signed long int)((char *)node - (char *)((struct anonymous_6 *)db)->db));

              else
              {
                node->current_max = (signed long int)0xff;
                node->current_min = (signed long int)0xff;
                hdr->ctl.t.offset_max_node = hdr->ctl.t.offset_root_node;
                hdr->ctl.t.offset_min_node = hdr->ctl.t.offset_root_node;
              }
            }

          }

        }

        if(node->left_child_offset == 0l)
          tmp_if_expr_5 = node->right_child_offset != (signed long int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        if(tmp_if_expr_5)
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          if(!(node->left_child_offset == 0l))
            tmp_if_expr_6 = node->right_child_offset == (signed long int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_6 = (_Bool)0;
          tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
        {
          signed int elements = (signed int)node->number_of_elements;
          signed int left;
          struct wg_tnode *child;
          if(!(node->left_child_offset == 0l))
          {
            child = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + node->left_child_offset);
            left = 1;
          }

          else
          {
            child = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + node->right_child_offset);
            left = 0;
          }
          elements = elements + (signed int)child->number_of_elements;
          if((signed int)child->left_subtree_height == 0)
            tmp_if_expr_4 = (signed int)child->right_subtree_height == 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(!tmp_if_expr_4)
          {
            show_index_error(db, "index tree is not balanced, deleting algorithm doesn't work");
            return (signed long int)-4;
          }

          if(!(elements >= 9))
          {
            signed int i = (signed int)node->number_of_elements;
            signed int j;
            node->number_of_elements = (signed short int)elements;
            if(!(left == 0))
            {
              j = i - 1;
              for( ; j >= 0; j = j - 1)
                node->array_of_values[(signed long int)(j + (signed int)child->number_of_elements)] = node->array_of_values[(signed long int)j];
              j = 0;
              for( ; !(j >= (signed int)child->number_of_elements); j = j + 1)
                node->array_of_values[(signed long int)j] = child->array_of_values[(signed long int)j];
              node->left_subtree_height = (unsigned char)0;
              node->left_child_offset = (signed long int)0;
              node->current_min = child->current_min;
              if(i == 0)
                node->current_max = child->current_max;

            }

            else
            {
              j = 0;
              for( ; !(j >= (signed int)child->number_of_elements); j = j + 1)
                node->array_of_values[(signed long int)(i + j)] = child->array_of_values[(signed long int)j];
              node->right_subtree_height = (unsigned char)0;
              node->right_child_offset = (signed long int)0;
              node->current_max = child->current_max;
              if(i == 0)
                node->current_min = child->current_min;

            }
            if(!(child->succ_offset == 0l))
            {
              struct wg_tnode *ttree_remove_row__1__8__4__3__succ = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + child->succ_offset);
              ttree_remove_row__1__8__4__3__succ->pred_offset = child->pred_offset;
            }

            else
              hdr->ctl.t.offset_max_node = child->pred_offset;
            if(!(child->pred_offset == 0l))
            {
              struct wg_tnode *ttree_remove_row__1__8__4__5__pred = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + child->pred_offset);
              ttree_remove_row__1__8__4__5__pred->succ_offset = child->succ_offset;
            }

            else
              hdr->ctl.t.offset_min_node = child->succ_offset;
            wg_free_tnode(db, (signed long int)((char *)child - (char *)((struct anonymous_6 *)db)->db));
            if(!(node->parent_offset == 0l))
            {
              parent = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + node->parent_offset);
              if(parent->left_child_offset == (char *)node - (char *)((struct anonymous_6 *)db)->db)
                parent->left_subtree_height = (unsigned char)1;

              else
                parent->right_subtree_height = (unsigned char)1;
            }

          }

        }

        if(!(parent == ((struct wg_tnode *)NULL)))
        {
          signed int balance;
          signed int height;
          do
          {
            balance = (signed int)parent->left_subtree_height - (signed int)parent->right_subtree_height;
            if(balance >= 2 || !(balance >= -1))
            {
              signed int overw;
              overw=db_which_branch_causes_overweight(db, parent);
              db_rotate_ttree(db, index_id, parent, overw);
            }

            else
              if(!(parent->parent_offset == 0l))
              {
                struct wg_tnode *gp;
                if(!((signed int)parent->right_subtree_height >= (signed int)parent->left_subtree_height))
                  tmp_if_expr_8 = (signed int)parent->left_subtree_height;

                else
                  tmp_if_expr_8 = (signed int)parent->right_subtree_height;
                height = tmp_if_expr_8;
                gp = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + parent->parent_offset);
                if(gp->left_child_offset == (char *)parent - (char *)((struct anonymous_6 *)db)->db)
                  gp->left_subtree_height = (unsigned char)(1 + height);

                else
                  gp->right_subtree_height = (unsigned char)(1 + height);
              }

            if(parent->parent_offset == 0l)
              break;

            parent = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + parent->parent_offset);
          }
          while((_Bool)1);
        }

        return (signed long int)0;
      }
    }
  }
}

// unique_resultset
// file dbquery.c line 1528
static struct anonymous_17 * unique_resultset(void *db, struct anonymous_17 *set)
{
  signed long int offset;
  struct anonymous_17 *unique;
  signed int strategy = 1;
  unique=create_resultset(db);
  if(unique == ((struct anonymous_17 *)NULL))
    return (struct anonymous_17 *)(void *)0;

  else
  {
    if(!(set->res_count >= 20l))
      strategy = 0;

    rewind_resultset(db, set);
    if(strategy == 1)
    {
      void *hasht = (void *)0;
      hasht=wg_dhash_init(db, (unsigned long int)set->res_count);
      if(hasht == NULL)
      {
        free_resultset(db, unique);
        return (struct anonymous_17 *)(void *)0;
      }

      do
      {
        offset=fetch_resultset(db, set);
        if(offset == 0l)
          break;

        signed long int return_value_wg_dhash_haskey_1;
        return_value_wg_dhash_haskey_1=wg_dhash_haskey(db, hasht, offset);
        if(return_value_wg_dhash_haskey_1 == 0l)
        {
          signed long int unique_resultset__1__3__2__1__err;
          unique_resultset__1__3__2__1__err=append_resultset(db, unique, offset);
          if(unique_resultset__1__3__2__1__err == 0l)
            unique_resultset__1__3__2__1__err=wg_dhash_addkey(db, hasht, offset);

          if(!(unique_resultset__1__3__2__1__err == 0l))
          {
            free_resultset(db, unique);
            wg_dhash_free(db, hasht);
            return (struct anonymous_17 *)(void *)0;
          }

        }

      }
      while((_Bool)1);
      wg_dhash_free(db, hasht);
    }

    else
      do
      {
        offset=fetch_resultset(db, set);
        if(offset == 0l)
          break;

        signed long int offsetu;
        signed long int found = (signed long int)0;
        rewind_resultset(db, unique);
        do
        {
          offsetu=fetch_resultset(db, unique);
          if(offsetu == 0l)
            break;

          if(offset == offsetu)
          {
            found = (signed long int)1;
            break;
          }

        }
        while((_Bool)1);
        if(found == 0l)
        {
          signed long int err;
          err=append_resultset(db, unique, offset);
          if(!(err == 0l))
          {
            free_resultset(db, unique);
            return (struct anonymous_17 *)(void *)0;
          }

        }

      }
      while((_Bool)1);
    return unique;
  }
}

// unlock_queue
// file dblock.c line 970
static void unlock_queue(void *db)
{
  volatile signed long int *gl = (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + ((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->locks.queue_lock);
  *gl = (volatile signed long int)0;
}

// update_crc32
// file crc1.h line 83
static signed int update_crc32(char *buf, signed long int n, signed int crc)
{
  signed long int i;
  crc = crc ^ (signed int)0xffffffff;
  i = (signed long int)0;
  for( ; !(i >= n); i = i + 1l)
    crc = crc_table[(signed long int)(0xff & ((signed int)buf[i] ^ crc))] ^ crc >> 8;
  crc = crc ^ (signed int)0xffffffff;
  return crc;
}

// wg_add_int_atomic_field
// file dbdata.c line 1099
signed long int wg_add_int_atomic_field(void *db, void *record, signed long int fieldnr, signed int data)
{
  signed long int *fieldadr;
  signed long int old;
  signed long int nxt;
  signed long int r;
  signed int i;
  signed int sum;
  struct timespec ts;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
  {
    show_data_error_str(db, "wrong database pointer given to ", "wg_add_int_atomic_field");
    return (signed long int)-1;
  }

  else
  {
    if(!(fieldnr >= 0l))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (*((signed long int *)record) & (signed long int)~3) >> (sizeof(signed long int) /*8ul*/  == (unsigned long int)4 ? 2 : 3) <= fieldnr + (signed long int)3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      show_data_error_str(db, "wrong field number given to ", "wg_add_int_atomic_field");
      return (signed long int)-2;
    }

    else
    {
      fieldadr = (signed long int *)record + (signed long int)3 + fieldnr;
      i = 0;
      do
      {
        old = *fieldadr;
        if(!((7l & old) == 3l))
          return (signed long int)-11;

        signed long int return_value_wg_decode_int_3;
        return_value_wg_decode_int_3=wg_decode_int(db, (signed long int)old);
        sum = (signed int)(return_value_wg_decode_int_3 + (signed long int)data);
        if(!((sum << 3) >> 3 == sum))
          return (signed long int)-16;

        nxt = (signed long int)(sum << 3 | 0x3);
        r=wg_update_atomic_field(db, record, fieldnr, nxt, old);
        if(r == 0l)
          return (signed long int)0;

        if(!(r == -15l))
          return r;

        if(i >= 1001)
          return (signed long int)-17;

        if(i % 10 == 0)
        {
          ts.tv_sec = (signed long int)0;
          ts.tv_nsec = (signed long int)(100 + i);
          nanosleep(&ts, (struct timespec *)(void *)0);
        }

        i = i + 1;
      }
      while((_Bool)1);
      return (signed long int)-17;
    }
  }
}

// wg_alloc_fixlen_object
// file dballoc.c line 719
signed long int wg_alloc_fixlen_object(void *db, void *area_header)
{
  struct _db_area_header *areah;
  signed long int freelist;
  areah = (struct _db_area_header *)area_header;
  freelist = areah->freelist;
  if(freelist == 0l)
  {
    signed long int return_value_extend_fixedlen_area_1;
    return_value_extend_fixedlen_area_1=extend_fixedlen_area(db, (void *)areah);
    if(return_value_extend_fixedlen_area_1 == 0l)
    {
      show_dballoc_error_nr(db, "cannot extend fixed length object area for size ", areah->objlength);
      return (signed long int)0;
    }

    freelist = areah->freelist;
    if(freelist == 0l)
    {
      show_dballoc_error_nr(db, "no free fixed length objects available for size ", areah->objlength);
      return (signed long int)0;
    }

    else
    {
      areah->freelist = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + freelist));
      return freelist;
    }
  }

  else
  {
    areah->freelist = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + freelist));
    return freelist;
  }
}

// wg_alloc_gints
// file dballoc.c line 867
signed long int wg_alloc_gints(void *db, void *area_header, signed long int nr)
{
  signed long int wantedbytes;
  signed long int usedbytes;
  signed long int *freebuckets;
  signed long int res;
  signed long int nextobject;
  signed long int nextel;
  signed long int i;
  signed long int j;
  signed long int tmp;
  signed long int size;
  struct _db_area_header *areah = (struct _db_area_header *)area_header;
  wantedbytes = (signed long int)((unsigned long int)nr * sizeof(signed long int) /*8ul*/ );
  if(!(wantedbytes >= 0l))
    return (signed long int)0;

  else
  {
    if(!(wantedbytes >= 33l))
      usedbytes = (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/ ;

    else
      if(!(wantedbytes % 8l == 0l))
        usedbytes = wantedbytes + (signed long int)4;

      else
        usedbytes = wantedbytes;
    freebuckets = areah->freebuckets;
    if(!(usedbytes >= 256l))
    {
      if(freebuckets[usedbytes] == 0l)
        goto __CPROVER_DUMP_L7;

      res = freebuckets[usedbytes];
      nextel = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)res + sizeof(signed long int) /*8ul*/ )));
      freebuckets[usedbytes] = nextel;
      if(!(nextel == 0l))
        *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)nextel + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)((char *)&freebuckets[usedbytes] - (char *)((struct anonymous_6 *)db)->db);

      *((signed long int *)((char *)((struct anonymous_6 *)db)->db + res)) = wantedbytes & (signed long int)~3;
      nextobject = res + usedbytes;
      tmp = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + nextobject));
      if((1l & tmp) == 0l)
        *((signed long int *)((char *)((struct anonymous_6 *)db)->db + nextobject)) = tmp & (signed long int)~3;

      return res;
    }

    else
    {

    __CPROVER_DUMP_L7:
      ;
      j = (signed long int)0;
      i = usedbytes + (signed long int)1;
      for( ; !(i >= 256l) && !(j >= 3l); j = j + 1l)
      {
        if(!(freebuckets[i] == 0l))
        {
          if((-4l & *((signed long int *)((char *)((struct anonymous_6 *)db)->db + freebuckets[i]))) >= (signed long int)(sizeof(signed long int) * 4) /*32l*/  + usedbytes)
          {
            res = freebuckets[i];
            tmp=split_free(db, (void *)areah, usedbytes, freebuckets, i);
            if(!(tmp >= 0l))
              return (signed long int)0;

            *((signed long int *)((char *)((struct anonymous_6 *)db)->db + res)) = wantedbytes & (signed long int)~3;
            return res;
          }

        }

        i = i + 1l;
      }
      size = freebuckets[(signed long int)(256 + 32 + 1)];
      if(size >= usedbytes)
      {
        if(freebuckets[288l] == 0l)
          goto __CPROVER_DUMP_L13;

        res = freebuckets[(signed long int)(256 + 32)];
        if(usedbytes == size)
        {
          freebuckets[(signed long int)(256 + 32)] = (signed long int)0;
          freebuckets[(signed long int)(256 + 32 + 1)] = (signed long int)0;
          *((signed long int *)((char *)((struct anonymous_6 *)db)->db + res)) = wantedbytes & (signed long int)~3;
          return res;
        }

        if(!(size >= (signed long int)(sizeof(signed long int) * 4) /*32l*/  + usedbytes))
          goto __CPROVER_DUMP_L13;

        *((signed long int *)((char *)((struct anonymous_6 *)db)->db + res + usedbytes)) = size - usedbytes | (signed long int)3;
        *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)(res + usedbytes) + sizeof(signed long int) /*8ul*/ ))) = (signed long int)1;
        freebuckets[(signed long int)(256 + 32)] = res + usedbytes;
        freebuckets[(signed long int)(256 + 32 + 1)] = size - usedbytes;
        *((signed long int *)((char *)((struct anonymous_6 *)db)->db + res)) = wantedbytes & (signed long int)~3;
        return res;
      }

      else
      {

      __CPROVER_DUMP_L13:
        ;
        i = usedbytes + (signed long int)1;
        for( ; !(i >= 256l); i = i + 1l)
          if(!(freebuckets[i] == 0l))
          {
            if((-4l & *((signed long int *)((char *)((struct anonymous_6 *)db)->db + freebuckets[i]))) >= (signed long int)(sizeof(signed long int) * 4) /*32l*/  + usedbytes)
            {
              res = freebuckets[i];
              tmp=split_free(db, (void *)areah, usedbytes, freebuckets, i);
              if(!(tmp >= 0l))
                return (signed long int)0;

              *((signed long int *)((char *)((struct anonymous_6 *)db)->db + res)) = wantedbytes & (signed long int)~3;
              return res;
            }

          }

        i=wg_freebuckets_index(db, usedbytes);
        for( ; !(i >= 288l); i = i + 1l)
          if(!(freebuckets[i] == 0l))
          {
            size = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + freebuckets[i])) & (signed long int)~3;
            if(size == usedbytes)
            {
              res = freebuckets[i];
              nextel = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)res + sizeof(signed long int) /*8ul*/ )));
              freebuckets[i] = nextel;
              if(!(nextel == 0l))
                *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)nextel + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)((char *)&freebuckets[i] - (char *)((struct anonymous_6 *)db)->db);

              *((signed long int *)((char *)((struct anonymous_6 *)db)->db + res)) = wantedbytes & (signed long int)~3;
              return res;
            }

            else
              if(size >= (signed long int)(sizeof(signed long int) * 4) /*32l*/  + usedbytes)
              {
                res = freebuckets[i];
                tmp=split_free(db, (void *)areah, usedbytes, freebuckets, i);
                if(!(tmp >= 0l))
                  return (signed long int)0;

                *((signed long int *)((char *)((struct anonymous_6 *)db)->db + res)) = wantedbytes & (signed long int)~3;
                return res;
              }

          }

        tmp=extend_varlen_area(db, (void *)areah, usedbytes);
        if(tmp == 0l)
        {
          show_dballoc_error(db, " cannot initialize new varlen subarea");
          return (signed long int)0;
        }

        else
        {
          tmp=wg_alloc_gints(db, (void *)areah, nr);
          return tmp;
        }
      }
    }
  }
}

// wg_alloc_mpool
// file dbmpool.h line 46
void * wg_alloc_mpool(void *db, void *mpool, signed int bytes)
{
  void *curptr;
  void *nextptr;
  struct anonymous_8 *mpoolh;
  void *curend;
  signed int tmp;
  signed int i;
  if(!(bytes >= 1))
  {
    show_mpool_error_nr(db, " trying to allocate too little from mpool: ", bytes);
    return (void *)0;
  }

  else
    if(mpool == NULL)
    {
      show_mpool_error(db, " mpool passed to wg_alloc_mpool is NULL ");
      return (void *)0;
    }

    else
    {
      mpoolh = (struct anonymous_8 *)mpool;
      nextptr = (void *)((char *)mpoolh->freeptr + (signed long int)bytes);
      curend = mpoolh->subarea_table[(signed long int)mpoolh->cur_subarea].area_end;
      if(!(curend >= nextptr))
      {
        tmp=extend_mpool(db, mpool, bytes);
        if(!(tmp == 0))
        {
          show_mpool_error_nr(db, " cannot extend mpool size by: ", bytes);
          return (void *)0;
        }

        nextptr = (void *)((char *)mpoolh->freeptr + (signed long int)bytes);
      }

      curptr = mpoolh->freeptr;
      i = (signed int)((unsigned long int)nextptr % (unsigned long int)4);
      if(!(i == 0))
        nextptr = (void *)((char *)nextptr + (signed long int)(4 - i));

      mpoolh->freeptr = nextptr;
      return curptr;
    }
}

// wg_atomstr1
// file dbmpool.c line 380
char * wg_atomstr1(void *db, void *ptr)
{
  if(ptr == NULL)
    return (char *)(void *)0;

  else
    if(((char *)ptr)[1l] == 0)
      return (char *)(void *)0;

    else
      return (char *)ptr + (signed long int)1;
}

// wg_atomstr2
// file dbmpool.c line 386
char * wg_atomstr2(void *db, void *ptr)
{
  if(ptr == NULL)
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen((char *)ptr);
    ptr = (void *)((char *)ptr + (signed long int)return_value_strlen_1 + (signed long int)1);
    if(((char *)ptr)[1l] == 0)
      return (char *)(void *)0;

    else
      return (char *)ptr;
  }
}

// wg_atomtype
// file dbmpool.c line 374
signed int wg_atomtype(void *db, void *ptr)
{
  if(ptr == NULL)
    return 0;

  else
    return (signed int)(signed long int)*((char *)ptr);
}

// wg_attach_database
// file ../Db/dbmem.h line 52
void * wg_attach_database(char *dbasename, signed long int size)
{
  void *shm;
  shm=wg_attach_memsegment(dbasename, size, size, 1, 0, 0);
  if(!(shm == NULL))
  {
    if(!(((struct anonymous_6 *)shm)->db == ((struct _db_memsegment_header *)NULL)))
    {
      signed int err;
      err=wg_check_header_compat((struct _db_memsegment_header *)((struct anonymous_6 *)shm)->db);
      if(!(err == 0))
      {
        if(!(err >= -1))
        {
          show_memory_error("Existing segment header is incompatible");
          wg_print_code_version();
          wg_print_header_version((struct _db_memsegment_header *)((struct anonymous_6 *)shm)->db, 1);
        }

        return (void *)0;
      }

    }

  }

  return shm;
}

// wg_attach_database_mode
// file dbmem.c line 155
void * wg_attach_database_mode(char *dbasename, signed long int size, signed int mode)
{
  void *shm;
  shm=wg_attach_memsegment(dbasename, size, size, 1, 0, mode);
  if(!(shm == NULL))
  {
    if(!(((struct anonymous_6 *)shm)->db == ((struct _db_memsegment_header *)NULL)))
    {
      signed int err;
      err=wg_check_header_compat((struct _db_memsegment_header *)((struct anonymous_6 *)shm)->db);
      if(!(err == 0))
      {
        if(!(err >= -1))
        {
          show_memory_error("Existing segment header is incompatible");
          wg_print_code_version();
          wg_print_header_version((struct _db_memsegment_header *)((struct anonymous_6 *)shm)->db, 1);
        }

        return (void *)0;
      }

    }

  }

  return shm;
}

// wg_attach_existing_database
// file dbmem.c line 132
void * wg_attach_existing_database(char *dbasename)
{
  void *shm;
  shm=wg_attach_memsegment(dbasename, (signed long int)0, (signed long int)0, 0, 0, 0);
  if(!(shm == NULL))
  {
    if(!(((struct anonymous_6 *)shm)->db == ((struct _db_memsegment_header *)NULL)))
    {
      signed int err;
      err=wg_check_header_compat((struct _db_memsegment_header *)((struct anonymous_6 *)shm)->db);
      if(!(err == 0))
      {
        if(!(err >= -1))
        {
          show_memory_error("Existing segment header is incompatible");
          wg_print_code_version();
          wg_print_header_version((struct _db_memsegment_header *)((struct anonymous_6 *)shm)->db, 1);
        }

        return (void *)0;
      }

    }

  }

  return shm;
}

// wg_attach_local_database
// file dbmem.c line 376
void * wg_attach_local_database(signed long int size)
{
  void *shm;
  void *dbhandle;
  dbhandle=init_dbhandle();
  if(dbhandle == NULL)
    return (void *)0;

  else
  {
    if(!(size >= 1l))
      size = (signed long int)10000000;

    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)size);
    shm = (void *)return_value_malloc_1;
    if(shm == NULL)
    {
      show_memory_error("malloc failed");
      return (void *)0;
    }

    else
    {
      ((struct anonymous_6 *)dbhandle)->db = (struct _db_memsegment_header *)shm;
      signed long int return_value_wg_init_db_memsegment_2;
      return_value_wg_init_db_memsegment_2=wg_init_db_memsegment(dbhandle, (signed long int)0, size);
      if(!(return_value_wg_init_db_memsegment_2 == 0l))
      {
        show_memory_error("Database initialization failed");
        free(shm);
        free_dbhandle(dbhandle);
        return (void *)0;
      }

    }
    return dbhandle;
  }
}

// wg_attach_logged_database
// file dbmem.c line 143
void * wg_attach_logged_database(char *dbasename, signed long int size)
{
  void *shm;
  shm=wg_attach_memsegment(dbasename, size, size, 1, 1, 0);
  if(!(shm == NULL))
  {
    if(!(((struct anonymous_6 *)shm)->db == ((struct _db_memsegment_header *)NULL)))
    {
      signed int err;
      err=wg_check_header_compat((struct _db_memsegment_header *)((struct anonymous_6 *)shm)->db);
      if(!(err == 0))
      {
        if(!(err >= -1))
        {
          show_memory_error("Existing segment header is incompatible");
          wg_print_code_version();
          wg_print_header_version((struct _db_memsegment_header *)((struct anonymous_6 *)shm)->db, 1);
        }

        return (void *)0;
      }

    }

  }

  return shm;
}

// wg_attach_logged_database_mode
// file dbmem.c line 167
void * wg_attach_logged_database_mode(char *dbasename, signed long int size, signed int mode)
{
  void *shm;
  shm=wg_attach_memsegment(dbasename, size, size, 1, 1, mode);
  if(!(shm == NULL))
  {
    if(!(((struct anonymous_6 *)shm)->db == ((struct _db_memsegment_header *)NULL)))
    {
      signed int err;
      err=wg_check_header_compat((struct _db_memsegment_header *)((struct anonymous_6 *)shm)->db);
      if(!(err == 0))
      {
        if(!(err >= -1))
        {
          show_memory_error("Existing segment header is incompatible");
          wg_print_code_version();
          wg_print_header_version((struct _db_memsegment_header *)((struct anonymous_6 *)shm)->db, 1);
        }

        return (void *)0;
      }

    }

  }

  return shm;
}

// wg_attach_memsegment
// file dbmem.c line 196
void * wg_attach_memsegment(char *dbasename, signed long int minsize, signed long int size, signed int create, signed int logging, signed int mode)
{
  void *dbhandle;
  void *shm;
  signed int err;
  signed int key = 0;
  dbhandle=init_dbhandle();
  signed long int return_value_strtol_1;
  _Bool tmp_if_expr_2;
  if(dbhandle == NULL)
    return (void *)0;

  else
  {
    if(!(dbasename == ((char *)NULL)))
    {
      return_value_strtol_1=strtol(dbasename, (char ** restrict )(void *)0, 10);
      key = (signed int)return_value_strtol_1;
    }

    if(key == 0x7fffffff || key == -2147483648 || !(key >= 1))
      key = 1000;

    if(!(minsize >= 0l))
      minsize = (signed long int)0;

    if(!(size >= minsize))
      size = minsize;

    shm=link_shared_memory(key, &err);
    if(!(shm == NULL))
    {
      if(!(shm == NULL))
        tmp_if_expr_2 = *((signed int *)shm) == 1232319011 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
      {
        show_memory_error("Existing segment header is invalid");
        free_dbhandle(dbhandle);
        return (void *)0;
      }

      if(!(minsize == 0l))
      {
        if(!(((struct _db_memsegment_header *)shm)->size >= minsize))
        {
          show_memory_error("Existing segment is too small");
          free_dbhandle(dbhandle);
          return (void *)0;
        }

      }

      ((struct anonymous_6 *)dbhandle)->db = (struct _db_memsegment_header *)shm;
    }

    else
      if(err == 13 || create == 0)
      {
        free_dbhandle(dbhandle);
        return (void *)0;
      }

      else
      {
        if(size == 0l)
          size = (signed long int)10000000;

        mode=normalize_perms(mode);
        shm=create_shared_memory(key, size, mode);
        if(shm == NULL && !(minsize == 0l) && !(minsize >= size))
        {
          size = minsize;
          shm=create_shared_memory(key, size, mode);
        }

        if(shm == NULL)
        {
          show_memory_error("create_shared_memory failed");
          free_dbhandle(dbhandle);
          return (void *)0;
        }

        else
        {
          ((struct anonymous_6 *)dbhandle)->db = (struct _db_memsegment_header *)shm;
          signed long int return_value_wg_init_db_memsegment_3;
          return_value_wg_init_db_memsegment_3=wg_init_db_memsegment(dbhandle, (signed long int)key, size);
          err = (signed int)return_value_wg_init_db_memsegment_3;
          if(!(err == 0))
          {
            show_memory_error("Database initialization failed");
            free_shared_memory(key);
            free_dbhandle(dbhandle);
            return (void *)0;
          }

        }
      }
    return dbhandle;
  }
}

// wg_check_dump
// file dbdump.c line 199
signed long int wg_check_dump(void *db, char *fileName, signed long int *minsize, signed long int *maxsize)
{
  char *buf;
  struct _IO_FILE *f;
  signed long int len;
  signed long int filesize;
  signed int crc;
  signed int dump_crc;
  signed long int err = (signed long int)-1;
  f=fopen(fileName, "rb");
  unsigned long int return_value_fread_2;
  signed int return_value_wg_check_header_compat_3;
  unsigned long int return_value_fread_4;
  if(f == ((struct _IO_FILE *)NULL))
  {
    show_dump_error(db, "Error opening file");
    return (signed long int)-1;
  }

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)8192);
    buf = (char *)return_value_malloc_1;
    if(buf == ((char *)NULL))
      show_dump_error(db, "malloc error in wg_import_dump");

    else
    {
      return_value_fread_2=fread((void *)buf, (unsigned long int)8192, (unsigned long int)1, f);
      if(!(return_value_fread_2 == 1ul))
        show_dump_error(db, "Error reading dump header");

      else
      {
        return_value_wg_check_header_compat_3=wg_check_header_compat((struct _db_memsegment_header *)buf);
        if(!(return_value_wg_check_header_compat_3 == 0))
        {
          show_dump_error_str(db, "Incompatible dump file", fileName);
          wg_print_code_version();
          wg_print_header_version((struct _db_memsegment_header *)buf, 1);
          err = (signed long int)-2;
        }

        else
        {
          *minsize = ((struct _db_memsegment_header *)buf)->free;
          *maxsize = ((struct _db_memsegment_header *)buf)->size;
          dump_crc = ((struct _db_memsegment_header *)buf)->checksum;
          ((struct _db_memsegment_header *)buf)->checksum = 0;
          len = (signed long int)8192;
          filesize = (signed long int)0;
          crc = 0;
          do
          {
            filesize = filesize + len;
            crc=update_crc32(buf, len, crc);
            return_value_fread_4=fread((void *)buf, (unsigned long int)1, (unsigned long int)8192, f);
            len = (signed long int)return_value_fread_4;
          }
          while(len >= 1l);
          if(!(filesize == *minsize))
          {
            show_dump_error_str(db, "File size incorrect", fileName);
            err = (signed long int)-3;
          }

          else
            if(!(crc == dump_crc))
            {
              show_dump_error_str(db, "File CRC32 incorrect", fileName);
              err = (signed long int)-3;
            }

            else
              err = (signed long int)0;
        }
      }

    abort2:
      ;
      free((void *)buf);
    }

  abort1:
    ;
    fclose(f);
    return err;
  }
}

// wg_check_header_compat
// file dbmem.h line 62
signed int wg_check_header_compat(struct _db_memsegment_header *dbh)
{
  _Bool tmp_if_expr_4;
  if(!(dbh == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_4 = *((signed int *)dbh) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if(!tmp_if_expr_4)
  {
    signed int magic = 1232319011;
    char *magic_bytes = (char *)&magic;
    char *header_bytes = (char *)dbh;
    if(*magic_bytes == header_bytes[3l])
      tmp_if_expr_1 = magic_bytes[(signed long int)1] == header_bytes[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = magic_bytes[(signed long int)2] == header_bytes[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = magic_bytes[(signed long int)3] == header_bytes[(signed long int)0] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      return -2;

    else
      return -1;
  }

  if(!(dbh->version == 198400))
    return -3;

  else
    if(!(dbh->features == 47))
      return -4;

    else
      return 0;
}

// wg_check_json
// file dbjson.c line 278
signed long int wg_check_json(void *db, char *buf)
{
  signed int count = 0;
  signed int result = 0;
  signed int depth = -1;
  char *iptr = buf;
  struct yajl_handle_t *hand = (struct yajl_handle_t *)(void *)0;
  signed long int return_value_show_json_error_1;
  unsigned long int return_value_strnlen_2;
  if(buf == ((char *)NULL))
  {
    return_value_show_json_error_1=show_json_error(db, "Invalid input buffer");
    return return_value_show_json_error_1;
  }

  else
  {
    hand=yajl_alloc(&validate_cb, (struct anonymous_3 *)(void *)0, (void *)&depth);
    yajl_config(hand, (enum anonymous_4)yajl_allow_comments, 1);
    do
    {
      return_value_strnlen_2=strnlen(iptr, (unsigned long int)16384);
      count = (signed int)return_value_strnlen_2;
      if(!(count >= 1))
        break;

      enum anonymous_27 return_value_yajl_parse_3;
      return_value_yajl_parse_3=yajl_parse(hand, (unsigned char *)iptr, (unsigned long int)count);
      if(!((signed int)return_value_yajl_parse_3 == yajl_status_ok))
      {
        show_json_error(db, "JSON parsing failed");
        result = -1;
        goto done;
      }

      iptr = iptr + (signed long int)count;
    }
    while((_Bool)1);
    enum anonymous_27 return_value_yajl_complete_parse_4;
    return_value_yajl_complete_parse_4=yajl_complete_parse(hand);
    if(!((signed int)return_value_yajl_complete_parse_4 == yajl_status_ok))
    {
      show_json_error(db, "JSON parsing failed");
      result = -1;
    }

    else
      if(depth == -1)
      {
        show_json_error(db, "Top-level array or object is required in JSON");
        result = -1;
      }


  done:
    ;
    if(!(hand == ((struct yajl_handle_t *)NULL)))
      yajl_free(hand);

    return (signed long int)result;
  }
}

// wg_cleanup_handle_logdata
// file dblog.c line 722
void wg_cleanup_handle_logdata(void *db)
{
  ;
}

// wg_column_to_index_id
// file dbindex.c line 2377
signed long int wg_column_to_index_id(void *db, signed long int column, signed long int type, signed long int *matchrec, signed long int reclen)
{
  signed long int return_value_wg_multi_column_to_index_id_1;
  return_value_wg_multi_column_to_index_id_1=wg_multi_column_to_index_id(db, &column, (signed long int)1, type, matchrec, reclen);
  return return_value_wg_multi_column_to_index_id_1;
}

// wg_compare
// file dbcompare.c line 52
signed long int wg_compare(void *db, signed long int a, signed long int b, signed int depth)
{
  signed long int typea;
  typea=wg_get_encoded_type(db, a);
  signed long int typeb;
  typeb=wg_get_encoded_type(db, b);
  if(typeb == typea)
  {
    if(typea >= 10l)
    {
      if(typea >= 11l)
      {
        signed long int deca;
        signed long int wg_compare__1__1__1__1__decb;
        if(typea == 11l)
        {
          signed int return_value_wg_decode_date_1;
          return_value_wg_decode_date_1=wg_decode_date(db, a);
          deca = (signed long int)return_value_wg_decode_date_1;
          signed int return_value_wg_decode_date_2;
          return_value_wg_decode_date_2=wg_decode_date(db, b);
          wg_compare__1__1__1__1__decb = (signed long int)return_value_wg_decode_date_2;
        }

        else
          if(typea == 12l)
          {
            signed int return_value_wg_decode_time_3;
            return_value_wg_decode_time_3=wg_decode_time(db, a);
            deca = (signed long int)return_value_wg_decode_time_3;
            signed int return_value_wg_decode_time_4;
            return_value_wg_decode_time_4=wg_decode_time(db, b);
            wg_compare__1__1__1__1__decb = (signed long int)return_value_wg_decode_time_4;
          }

          else
            if(typea == 14l)
            {
              deca=wg_decode_var(db, a);
              wg_compare__1__1__1__1__decb=wg_decode_var(db, b);
            }

            else
              return (signed long int)(a > b ? 1 : -1);
        return (signed long int)(deca > wg_compare__1__1__1__1__decb ? 1 : -1);
      }

      else
      {
        double wg_compare__1__1__1__2__deca;
        double wg_compare__1__1__1__2__decb;
        wg_compare__1__1__1__2__deca=wg_decode_fixpoint(db, a);
        wg_compare__1__1__1__2__decb=wg_decode_fixpoint(db, b);
        return (signed long int)(wg_compare__1__1__1__2__deca > wg_compare__1__1__1__2__decb ? 1 : -1);
      }
    }

    else
      if(!(typea >= 5l))
      {
        if(typea == 2l)
        {
          void *wg_compare__1__1__2__1__deca;
          void *decb;
          wg_compare__1__1__2__1__deca=wg_decode_record(db, a);
          decb=wg_decode_record(db, b);
          if(depth == 0)
            return (signed long int)((signed long int)wg_compare__1__1__2__1__deca > (signed long int)decb ? 1 : -1);

          else
          {
            signed int i;
            signed int lena;
            signed long int return_value_wg_get_record_len_5;
            return_value_wg_get_record_len_5=wg_get_record_len(db, wg_compare__1__1__2__1__deca);
            lena = (signed int)return_value_wg_get_record_len_5;
            signed int lenb;
            signed long int return_value_wg_get_record_len_6;
            return_value_wg_get_record_len_6=wg_get_record_len(db, decb);
            lenb = (signed int)return_value_wg_get_record_len_6;
            if(!(lena == lenb))
              return (signed long int)(lena > lenb ? 1 : -1);

            i = 0;
            for( ; !(i >= lena); i = i + 1)
            {
              signed long int elema;
              elema=wg_get_field(db, wg_compare__1__1__2__1__deca, (signed long int)i);
              signed long int elemb;
              elemb=wg_get_field(db, decb, (signed long int)i);
              if(!(elema == elemb))
              {
                signed long int cr;
                cr=wg_compare(db, elema, elemb, depth - 1);
                if(!(cr == 0l))
                  return cr;

              }

            }
            return (signed long int)0;
          }
        }

        else
          if(typea == 3l)
          {
            signed long int wg_compare__1__1__2__2__deca;
            signed long int wg_compare__1__1__2__2__decb;
            wg_compare__1__1__2__2__deca=wg_decode_int(db, a);
            wg_compare__1__1__2__2__decb=wg_decode_int(db, b);
            if(wg_compare__1__1__2__2__deca == wg_compare__1__1__2__2__decb)
              return (signed long int)0;

            return (signed long int)(wg_compare__1__1__2__2__deca > wg_compare__1__1__2__2__decb ? 1 : -1);
          }

          else
          {
            double wg_compare__1__1__2__3__deca;
            double wg_compare__1__1__2__3__decb;
            wg_compare__1__1__2__3__deca=wg_decode_double(db, a);
            wg_compare__1__1__2__3__decb=wg_decode_double(db, b);
            if(IEEE_FLOAT_EQUAL(wg_compare__1__1__2__3__deca, wg_compare__1__1__2__3__decb))
              return (signed long int)0;

            return (signed long int)(wg_compare__1__1__2__3__deca > wg_compare__1__1__2__3__decb ? 1 : -1);
          }
      }

      else
      {
        char *wg_compare__1__1__3__deca;
        char *wg_compare__1__1__3__decb;
        char *exa = (char *)(void *)0;
        char *exb = (char *)(void *)0;
        char buf[4l];
        signed long int res;
        if(typea == 5l)
        {
          wg_compare__1__1__3__deca=wg_decode_str(db, a);
          wg_compare__1__1__3__decb=wg_decode_str(db, b);
        }

        else
          if(typea == 7l)
          {
            exa=wg_decode_uri_prefix(db, a);
            exb=wg_decode_uri_prefix(db, b);
            wg_compare__1__1__3__deca=wg_decode_uri(db, a);
            wg_compare__1__1__3__decb=wg_decode_uri(db, b);
          }

          else
            if(typea == 6l)
            {
              exa=wg_decode_xmlliteral_xsdtype(db, a);
              exb=wg_decode_xmlliteral_xsdtype(db, b);
              wg_compare__1__1__3__deca=wg_decode_xmlliteral(db, a);
              wg_compare__1__1__3__decb=wg_decode_xmlliteral(db, b);
            }

            else
              if(typea == 9l)
              {
                buf[(signed long int)0]=wg_decode_char(db, a);
                buf[(signed long int)1] = (char)0;
                buf[(signed long int)2]=wg_decode_char(db, b);
                buf[(signed long int)3] = (char)0;
                wg_compare__1__1__3__deca = buf;
                wg_compare__1__1__3__decb = &buf[(signed long int)2];
              }

              else
              {
                wg_compare__1__1__3__deca=wg_decode_blob(db, a);
                wg_compare__1__1__3__decb=wg_decode_blob(db, b);
              }
        if(!(exa == ((char *)NULL)) || !(exb == ((char *)NULL)))
        {
          if(exb == ((char *)NULL))
          {
            if(!(*exa == 0))
              return (signed long int)1;

          }

          else
            if(exa == ((char *)NULL))
            {
              if(!(*exb == 0))
                return (signed long int)-1;

            }

            else
            {
              signed int return_value_strcmp_7;
              return_value_strcmp_7=strcmp(exa, exb);
              res = (signed long int)return_value_strcmp_7;
              if(res >= 1l)
                return (signed long int)1;

              else
                if(!(res >= 0l))
                  return (signed long int)-1;

            }
        }

        if(typea == 8l)
        {
          signed int wg_compare__1__1__3__7__lena;
          signed long int return_value_wg_decode_blob_len_8;
          return_value_wg_decode_blob_len_8=wg_decode_blob_len(db, a);
          wg_compare__1__1__3__7__lena = (signed int)return_value_wg_decode_blob_len_8;
          signed int wg_compare__1__1__3__7__lenb;
          signed long int return_value_wg_decode_blob_len_9;
          return_value_wg_decode_blob_len_9=wg_decode_blob_len(db, b);
          wg_compare__1__1__3__7__lenb = (signed int)return_value_wg_decode_blob_len_9;
          signed int return_value_memcmp_10;
          return_value_memcmp_10=memcmp((const void *)wg_compare__1__1__3__deca, (const void *)wg_compare__1__1__3__decb, (unsigned long int)(wg_compare__1__1__3__7__lena < wg_compare__1__1__3__7__lenb ? wg_compare__1__1__3__7__lena : wg_compare__1__1__3__7__lenb));
          res = (signed long int)return_value_memcmp_10;
          if(res == 0l)
            res = (signed long int)(wg_compare__1__1__3__7__lena - wg_compare__1__1__3__7__lenb);

        }

        else
        {
          signed int return_value_strcmp_11;
          return_value_strcmp_11=strcmp(wg_compare__1__1__3__deca, wg_compare__1__1__3__decb);
          res = (signed long int)return_value_strcmp_11;
        }
        if(res >= 1l)
          return (signed long int)1;

        else
          if(!(res >= 0l))
            return (signed long int)-1;

          else
            return (signed long int)0;
      }
  }

  else
    return (signed long int)(typea > typeb ? 1 : -1);
}

// wg_compare_and_swap
// file dblock.h line 80
signed long int wg_compare_and_swap(volatile signed long int *ptr, signed long int oldv, signed long int newv)
{
  _Bool return_value___sync_bool_compare_and_swap_1;
  __CPROVER_atomic_begin();
  return_value___sync_bool_compare_and_swap_1 = *ptr == oldv;
  *ptr = *ptr == oldv ? newv : *ptr;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  return (signed long int)return_value___sync_bool_compare_and_swap_1;
}

// wg_create_array
// file dbschema.h line 46
void * wg_create_array(void *db, signed long int size, signed long int isdocument, signed long int isparam)
{
  void *rec;
  rec=wg_create_raw_record(db, size);
  signed long int *metap;
  signed long int meta;
  if(!(rec == NULL))
  {
    metap = (signed long int *)rec + (signed long int)1;
    meta = *metap;
    meta = meta | (signed long int)0x40;
    if(!(isdocument == 0l))
      meta = meta | (signed long int)0x10;

    if(!(isparam == 0l))
      meta = meta | (signed long int)(0x1 | 0x2);

    *metap = meta;
    if(isparam == 0l)
    {
      signed long int return_value_wg_index_add_rec_1;
      return_value_wg_index_add_rec_1=wg_index_add_rec(db, rec);
      if(!(return_value_wg_index_add_rec_1 >= -1l))
        return (void *)0;

    }

  }

  return rec;
}

// wg_create_hash
// file dballoc.c line 1388
signed long int wg_create_hash(void *db, struct _db_hash_area_header *areah, signed long int size)
{
  if(!(size >= 1l))
    size = (signed long int)10000;

  signed long int return_value_init_hash_subarea_2;
  return_value_init_hash_subarea_2=init_hash_subarea(db, areah, size);
  if(!(return_value_init_hash_subarea_2 == 0l))
  {
    signed long int return_value_show_dballoc_error_1;
    return_value_show_dballoc_error_1=show_dballoc_error(db, " cannot create strhash array area");
    return return_value_show_dballoc_error_1;
  }

  return (signed long int)0;
}

// wg_create_index
// file dbindex.c line 2024
signed long int wg_create_index(void *db, signed long int column, signed long int type, signed long int *matchrec, signed long int reclen)
{
  signed long int return_value_wg_create_multi_index_1;
  return_value_wg_create_multi_index_1=wg_create_multi_index(db, &column, (signed long int)1, type, matchrec, reclen);
  return return_value_wg_create_multi_index_1;
}

// wg_create_mpool
// file dbmpool.h line 45
void * wg_create_mpool(void *db, signed int origbytes)
{
  signed int bytes;
  void *mpool;
  struct anonymous_8 *mpoolh;
  signed int puresize;
  void *nextptr;
  signed int i;
  if(!(origbytes >= 4))
    bytes = (signed int)(sizeof(struct anonymous_8) /*2416ul*/  + (unsigned long int)1024 + (unsigned long int)4);

  else
    bytes = (signed int)(sizeof(struct anonymous_8) /*2416ul*/  + (unsigned long int)origbytes + (unsigned long int)4);
  puresize = (signed int)((unsigned long int)bytes - sizeof(struct anonymous_8) /*2416ul*/ );
  mpool=malloc((unsigned long int)bytes);
  if(mpool == NULL)
  {
    show_mpool_error_nr(db, " cannot create an mpool with size: ", origbytes);
    return (void *)0;
  }

  else
  {
    mpoolh = (struct anonymous_8 *)mpool;
    nextptr = (void *)((char *)mpool + (signed long int)sizeof(struct anonymous_8) /*2416ul*/ );
    i = (signed int)((unsigned long int)nextptr % (unsigned long int)4);
    if(!(i == 0))
      nextptr = (void *)((char *)nextptr + (signed long int)(4 - i));

    mpoolh->freeptr = nextptr;
    mpoolh->cur_subarea = 0;
    mpoolh->subarea_table[(signed long int)0].size = puresize;
    mpoolh->subarea_table[(signed long int)0].area_start = mpool;
    mpoolh->subarea_table[(signed long int)0].area_end = (void *)((char *)mpool + (signed long int)bytes);
    return mpool;
  }
}

// wg_create_multi_index
// file dbindex.c line 2047
signed long int wg_create_multi_index(void *db, signed long int *columns, signed long int col_count, signed long int type, signed long int *matchrec, signed long int reclen)
{
  signed long int index_id;
  signed long int template_offset = (signed long int)0;
  signed long int wg_create_multi_index__1__i;
  struct anonymous_21 *hdr;
  struct anonymous_22 *tmpl = (struct anonymous_22 *)(void *)0;
  signed long int fixed_columns = (signed long int)0;
  signed long int *ilist[10l];
  signed long int sorted_cols[10l];
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  signed long int return_value_wg_get_encoded_type_3;
  signed long int return_value_create_hash_index_5;
  if(!tmp_if_expr_1)
  {
    show_index_error(db, "Invalid database pointer in wg_create_multi_index");
    return (signed long int)-1;
  }

  else
    if(columns == ((signed long int *)NULL))
    {
      show_index_error(db, "columns list is a NULL pointer");
      return (signed long int)-1;
    }

    else
    {
      if(!(col_count >= 1l))
      {
        show_index_error(db, "need at least one indexed column");
        return (signed long int)-1;
      }

      else
        if(col_count >= 11l)
        {
          show_index_error_nr(db, "Max allowed indexed fields", (signed long int)10);
          return (signed long int)-1;
        }

        else
          if(col_count >= 2l && (type == 50l || type == 51l))
          {
            show_index_error(db, "Cannot create a T-tree index on multiple columns");
            return (signed long int)-1;
          }

      signed long int return_value_sort_columns_2;
      return_value_sort_columns_2=sort_columns(sorted_cols, columns, col_count);
      if(!(return_value_sort_columns_2 >= col_count))
      {
        show_index_error(db, "Duplicate columns not allowed");
        return (signed long int)-1;
      }

      else
      {
        wg_create_multi_index__1__i = (signed long int)0;
        for( ; !(wg_create_multi_index__1__i >= col_count); wg_create_multi_index__1__i = wg_create_multi_index__1__i + 1l)
          if(sorted_cols[wg_create_multi_index__1__i] >= 128l)
          {
            show_index_error_nr(db, "Max allowed column number", (signed long int)127);
            return (signed long int)-1;
          }

        if(!(matchrec == ((signed long int *)NULL)))
        {
          if(reclen == 0l)
          {
            show_index_error(db, "Zero-length match record not allowed");
            return (signed long int)-1;
          }

          if(reclen >= 129l)
          {
            show_index_error_nr(db, "Match record too long, max", (signed long int)(127 + 1));
            return (signed long int)-1;
          }

          wg_create_multi_index__1__i = (signed long int)0;
          for( ; !(wg_create_multi_index__1__i >= col_count); wg_create_multi_index__1__i = wg_create_multi_index__1__i + 1l)
            if(!(sorted_cols[wg_create_multi_index__1__i] >= reclen))
            {
              return_value_wg_get_encoded_type_3=wg_get_encoded_type(db, matchrec[sorted_cols[wg_create_multi_index__1__i]]);
              if(!(return_value_wg_get_encoded_type_3 == 14l))
              {
                show_index_error(db, "Indexed column not allowed in template");
                return (signed long int)-1;
              }

            }

          template_offset=add_index_template(db, matchrec, reclen);
          if(template_offset == 0l)
          {
            show_index_error(db, "Error adding index template");
            return (signed long int)-1;
          }

          tmpl = (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + template_offset);
          fixed_columns = tmpl->fixed_columns;
        }

        wg_create_multi_index__1__i = (signed long int)0;
        for( ; !(wg_create_multi_index__1__i >= col_count); wg_create_multi_index__1__i = wg_create_multi_index__1__i + 1l)
        {
          signed long int column = sorted_cols[wg_create_multi_index__1__i];
          ilist[wg_create_multi_index__1__i] = &dbh->index_control_area_header.index_table[column];
          while(!(*ilist[wg_create_multi_index__1__i] == 0l))
          {
            struct anonymous_20 *ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist[wg_create_multi_index__1__i]);
            if(ilistelem->car == 0l)
            {
              show_index_error(db, "Invalid header in index list");
              return (signed long int)-1;
            }

            hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + ilistelem->car);
            if(wg_create_multi_index__1__i == 0l)
            {
              if(hdr->type == type)
              {
                if(template_offset == hdr->template_offset)
                {
                  if(hdr->fields == col_count)
                  {
                    signed long int j;
                    signed long int match = (signed long int)1;
                    j = (signed long int)0;
                    for( ; !(j >= col_count); j = j + 1l)
                      if(!(hdr->rec_field_index[j] == sorted_cols[j]))
                      {
                        match = (signed long int)0;
                        break;
                      }

                    if(!(match == 0l))
                    {
                      show_index_error(db, "Identical index already exists on the column");
                      return (signed long int)-1;
                    }

                  }

                }

              }

            }

            if(!(hdr->template_offset == 0l))
            {
              struct anonymous_22 *t = (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + hdr->template_offset);
              if(!(t->fixed_columns >= fixed_columns))
                break;

            }

            else
              if(!(fixed_columns == 0l))
                break;

            ilist[wg_create_multi_index__1__i] = &ilistelem->cdr;
          }
        }
        index_id=wg_alloc_fixlen_object(db, (void *)&dbh->indexhdr_area_header);
        wg_create_multi_index__1__i = (signed long int)0;
        for( ; !(wg_create_multi_index__1__i >= col_count); wg_create_multi_index__1__i = wg_create_multi_index__1__i + 1l)
        {
          signed long int return_value_insert_into_list_4;
          return_value_insert_into_list_4=insert_into_list(db, ilist[wg_create_multi_index__1__i], index_id);
          if(return_value_insert_into_list_4 == 0l)
          {
            if(!(wg_create_multi_index__1__i == 0l))
              return (signed long int)-1;

            else
              return (signed long int)-1;
          }

        }
        hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + index_id);
        hdr->type = type;
        hdr->fields = col_count;
        wg_create_multi_index__1__i = (signed long int)0;
        for( ; !(wg_create_multi_index__1__i >= col_count); wg_create_multi_index__1__i = wg_create_multi_index__1__i + 1l)
          hdr->rec_field_index[wg_create_multi_index__1__i] = sorted_cols[wg_create_multi_index__1__i];
        hdr->template_offset = template_offset;
        switch(hdr->type)
        {
          case (signed long int)50:
          {
            create_ttree_index(db, index_id);
            break;
          }
          case (signed long int)60:

          case (signed long int)61:
          {
            return_value_create_hash_index_5=create_hash_index(db, index_id);
            if(!(return_value_create_hash_index_5 == 0l))
              return (signed long int)-1;

            break;
          }
          case (signed long int)51:

          default:
          {
            show_index_error(db, "Invalid index type");
            return (signed long int)-1;
          }
        }
        signed long int return_value_insert_into_list_6;
        return_value_insert_into_list_6=insert_into_list(db, &dbh->index_control_area_header.index_list, index_id);
        if(return_value_insert_into_list_6 == 0l)
          return (signed long int)-1;

        else
        {
          if(!(hdr->template_offset == 0l))
          {
            signed int i = 0;
            for( ; !((signed long int)i >= reclen); i = i + 1)
            {
              signed long int return_value_wg_get_encoded_type_8;
              return_value_wg_get_encoded_type_8=wg_get_encoded_type(db, matchrec[(signed long int)i]);
              if(!(return_value_wg_get_encoded_type_8 == 14l))
              {
                signed long int return_value_insert_into_list_7;
                return_value_insert_into_list_7=insert_into_list(db, &dbh->index_control_area_header.index_template_table[(signed long int)i], index_id);
                if(return_value_insert_into_list_7 == 0l)
                  return (signed long int)0;

              }

            }
          }

          dbh->index_control_area_header.number_of_indexes = dbh->index_control_area_header.number_of_indexes + 1l;
          if(!(tmpl == ((struct anonymous_22 *)NULL)))
            tmpl->refcount = tmpl->refcount + 1l;

          return (signed long int)0;
        }
      }
    }
}

// wg_create_object
// file dbschema.h line 47
void * wg_create_object(void *db, signed long int size, signed long int isdocument, signed long int isparam)
{
  void *rec;
  rec=wg_create_raw_record(db, size);
  signed long int *metap;
  signed long int meta;
  if(!(rec == NULL))
  {
    metap = (signed long int *)rec + (signed long int)1;
    meta = *metap;
    meta = meta | (signed long int)0x20;
    if(!(isdocument == 0l))
      meta = meta | (signed long int)0x10;

    if(!(isparam == 0l))
      meta = meta | (signed long int)(0x1 | 0x2);

    *metap = meta;
    if(isparam == 0l)
    {
      signed long int return_value_wg_index_add_rec_1;
      return_value_wg_index_add_rec_1=wg_index_add_rec(db, rec);
      if(!(return_value_wg_index_add_rec_1 >= -1l))
        return (void *)0;

    }

  }

  return rec;
}

// wg_create_raw_record
// file dbdata.c line 140
void * wg_create_raw_record(void *db, signed long int length)
{
  signed long int offset;
  signed long int i;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error_nr(db, "wrong database pointer given to wg_create_record with length ", length);
    return NULL;
  }

  else
    if(!(length >= 0l))
    {
      show_data_error_nr(db, "invalid record length:", length);
      return NULL;
    }

    else
    {
      offset=wg_alloc_gints(db, (void *)&((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->datarec_area_header, length + (signed long int)3);
      if(offset == 0l)
      {
        show_data_error_nr(db, "cannot create a record of size ", length);
        return NULL;
      }

      else
      {
        *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + (unsigned long int)1 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)0;
        *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)0;
        i = (signed long int)3;
        for( ; !(i >= 3l + length); i = i + 1l)
          *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)offset + (unsigned long int)i * sizeof(signed long int) /*8ul*/ ))) = (signed long int)0;
        return (void *)((char *)((struct anonymous_6 *)db)->db + offset);
      }
    }
}

// wg_create_record
// file ../Db/dbdata.h line 88
void * wg_create_record(void *db, signed long int length)
{
  void *rec;
  rec=wg_create_raw_record(db, length);
  if(!(rec == NULL))
  {
    signed long int return_value_wg_index_add_rec_1;
    return_value_wg_index_add_rec_1=wg_index_add_rec(db, rec);
    if(!(return_value_wg_index_add_rec_1 >= -1l))
      return (void *)0;

  }

  return rec;
}

// wg_create_triple
// file dbschema.h line 43
void * wg_create_triple(void *db, signed long int subj, signed long int prop, signed long int ob, signed long int isparam)
{
  void *rec;
  rec=wg_create_raw_record(db, (signed long int)3);
  signed long int *meta;
  signed long int return_value_wg_index_add_rec_1;
  if(!(rec == NULL))
  {
    meta = (signed long int *)rec + (signed long int)1;
    if(!(isparam == 0l))
      *meta = *meta | (signed long int)(0x1 | 0x2);

    else
    {
      return_value_wg_index_add_rec_1=wg_index_add_rec(db, rec);
      if(!(return_value_wg_index_add_rec_1 >= -1l))
        return (void *)0;

    }
    signed long int return_value_wg_set_field_2;
    return_value_wg_set_field_2=wg_set_field(db, rec, (signed long int)0, subj);
    if(!(return_value_wg_set_field_2 == 0l))
      return (void *)0;

    signed long int return_value_wg_set_field_3;
    return_value_wg_set_field_3=wg_set_field(db, rec, (signed long int)(0 + 1), prop);
    if(!(return_value_wg_set_field_3 == 0l))
      return (void *)0;

    signed long int return_value_wg_set_field_4;
    return_value_wg_set_field_4=wg_set_field(db, rec, (signed long int)(0 + 2), ob);
    if(!(return_value_wg_set_field_4 == 0l))
      return (void *)0;

  }

  return rec;
}

// wg_current_localdate
// file dbdata.c line 1714
signed int wg_current_localdate(void *db)
{
  signed long int esecs;
  signed int res;
  struct tm ctime;
  esecs=time((signed long int *)(void *)0);
  localtime_r(&esecs, &ctime);
  signed long int return_value_ymd_to_scalar_1;
  return_value_ymd_to_scalar_1=ymd_to_scalar((unsigned int)(ctime.tm_year + 1900), (unsigned int)(ctime.tm_mon + 1), (unsigned int)ctime.tm_mday);
  res = (signed int)return_value_ymd_to_scalar_1;
  return res;
}

// wg_current_localtime
// file dbdata.c line 1742
signed int wg_current_localtime(void *db)
{
  struct timeb tstruct;
  signed long int esecs;
  signed int secs;
  signed int milli;
  struct tm ctime;
  ftime(&tstruct);
  esecs = tstruct.time;
  milli = (signed int)tstruct.millitm;
  localtime_r(&esecs, &ctime);
  secs = ctime.tm_hour * 60 * 60 + ctime.tm_min * 60 + ctime.tm_sec;
  return secs * 100 + milli / 10;
}

// wg_current_utcdate
// file dbdata.c line 1706
signed int wg_current_utcdate(void *db)
{
  signed long int ts;
  signed int epochadd = 719163;
  ts=time((signed long int *)(void *)0);
  return (signed int)(ts / (signed long int)(24 * 60 * 60)) + epochadd;
}

// wg_current_utctime
// file dbdata.c line 1726
signed int wg_current_utctime(void *db)
{
  struct timeb tstruct;
  signed int esecs;
  signed int days;
  signed int secs;
  signed int milli;
  signed int secsday = 24 * 60 * 60;
  ftime(&tstruct);
  esecs = (signed int)tstruct.time;
  milli = (signed int)tstruct.millitm;
  days = esecs / secsday;
  secs = esecs - days * secsday;
  return secs * 100 + milli / 10;
}

// wg_database_freesize
// file dballoc.c line 1404
signed long int wg_database_freesize(void *db)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int freesize = dbh->size - dbh->free;
  return freesize < (signed long int)8192 ? (signed long int)0 : freesize;
}

// wg_database_size
// file dballoc.c line 1413
signed long int wg_database_size(void *db)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  return dbh->size;
}

// wg_date_to_ymd
// file dbdata.c line 1815
void wg_date_to_ymd(void *db, signed int date, signed int *yr, signed int *mo, signed int *day)
{
  unsigned int y;
  unsigned int m;
  unsigned int d;
  scalar_to_ymd((signed long int)date, &y, &m, &d);
  *yr = (signed int)y;
  *mo = (signed int)m;
  *day = (signed int)d;
}

// wg_decode_anonconst
// file dbdata.c line 2410
char * wg_decode_anonconst(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_anonconst");
    return (char *)(void *)0;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_anonconst is 0, not an encoded anonconst");
      return (char *)(void *)0;
    }

    else
    {
      char *return_value_wg_decode_unistr_2;
      return_value_wg_decode_unistr_2=wg_decode_unistr(db, data, (signed long int)7);
      return return_value_wg_decode_unistr_2;
    }
}

// wg_decode_blob
// file dbdata.h line 231
char * wg_decode_blob(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_blob");
    return (char *)(void *)0;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_blob is 0, not an encoded string");
      return (char *)(void *)0;
    }

    else
    {
      char *return_value_wg_decode_unistr_2;
      return_value_wg_decode_unistr_2=wg_decode_unistr(db, data, (signed long int)8);
      return return_value_wg_decode_unistr_2;
    }
}

// wg_decode_blob_copy
// file dbdata.c line 2313
signed long int wg_decode_blob_copy(void *db, signed long int data, char *strbuf, signed long int buflen)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_blob_copy");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_blob_copy is 0, not an encoded string");
      return (signed long int)-1;
    }

    else
      if(strbuf == ((char *)NULL))
      {
        show_data_error(db, "buffer given to wg_decode_blob_copy is 0, not a valid buffer pointer");
        return (signed long int)-1;
      }

      else
        if(!(buflen >= 1l))
        {
          show_data_error(db, "buffer len given to wg_decode_blob_copy is 0 or less");
          return (signed long int)-1;
        }

        else
        {
          signed long int return_value_wg_decode_unistr_copy_2;
          return_value_wg_decode_unistr_copy_2=wg_decode_unistr_copy(db, data, strbuf, buflen, (signed long int)8);
          return return_value_wg_decode_unistr_copy_2;
        }
}

// wg_decode_blob_len
// file dbdata.h line 234
signed long int wg_decode_blob_len(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_blob_len");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_blob_len is 0, not an encoded string");
      return (signed long int)-1;
    }

    else
    {
      signed long int return_value_wg_decode_unistr_len_2;
      return_value_wg_decode_unistr_len_2=wg_decode_unistr_len(db, data, (signed long int)8);
      return return_value_wg_decode_unistr_len_2 + (signed long int)1;
    }
}

// wg_decode_blob_type
// file dbdata.c line 2336
char * wg_decode_blob_type(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_blob_type");
    return (char *)(void *)0;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_blob_type is 0, not an encoded blob");
      return (char *)(void *)0;
    }

    else
    {
      char *return_value_wg_decode_unistr_lang_2;
      return_value_wg_decode_unistr_lang_2=wg_decode_unistr_lang(db, data, (signed long int)8);
      return return_value_wg_decode_unistr_lang_2;
    }
}

// wg_decode_blob_type_copy
// file dbdata.c line 2367
signed long int wg_decode_blob_type_copy(void *db, signed long int data, char *langbuf, signed long int buflen)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_blob_type_copy");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_blob_type_copy is 0, not an encoded string");
      return (signed long int)-1;
    }

    else
      if(langbuf == ((char *)NULL))
      {
        show_data_error(db, "buffer given to wg_decode_blob_type_copy is 0, not a valid buffer pointer");
        return (signed long int)-1;
      }

      else
        if(!(buflen >= 1l))
        {
          show_data_error(db, "buffer len given to wg_decode_blob_type_copy is 0 or less");
          return (signed long int)-1;
        }

        else
        {
          signed long int return_value_wg_decode_unistr_lang_copy_2;
          return_value_wg_decode_unistr_lang_copy_2=wg_decode_unistr_lang_copy(db, data, langbuf, buflen, (signed long int)8);
          return return_value_wg_decode_unistr_lang_copy_2;
        }
}

// wg_decode_blob_type_len
// file dbdata.c line 2351
signed long int wg_decode_blob_type_len(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_blob_type_len");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_blob_type_len is 0, not an encoded string");
      return (signed long int)-1;
    }

    else
    {
      signed long int return_value_wg_decode_unistr_lang_len_2;
      return_value_wg_decode_unistr_lang_len_2=wg_decode_unistr_lang_len(db, data, (signed long int)8);
      return return_value_wg_decode_unistr_lang_len_2;
    }
}

// wg_decode_char
// file dbdata.h line 144
char wg_decode_char(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_char");
    return (char)0;
  }

  else
    return (char)(data >> 8);
}

// wg_decode_date
// file dbdata.h line 160
signed int wg_decode_date(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_date");
    return 0;
  }

  else
    if((255l & data) == 47l)
      return (signed int)(data >> 8);

    else
    {
      show_data_error_nr(db, "data given to wg_decode_date is not an encoded date: ", data);
      return 0;
    }
}

// wg_decode_double
// file dbdata.h line 150
double wg_decode_double(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_double");
    return (double)0;
  }

  else
    if((7l & data) == 2l)
      return *((double *)(void *)((char *)((struct anonymous_6 *)db)->db + (data & (signed long int)~0x7)));

    else
    {
      show_data_error_nr(db, "data given to wg_decode_double is not an encoded double: ", data);
      return (double)0;
    }
}

// wg_decode_fixpoint
// file dbdata.h line 155
double wg_decode_fixpoint(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_double");
    return (double)0;
  }

  else
    if((255l & data) == 15l)
      return (double)((double)(data >> 8) / (double)10000.0);

    else
    {
      show_data_error_nr(db, "data given to wg_decode_fixpoint is not an encoded fixpoint: ", data);
      return (double)0;
    }
}

// wg_decode_for_hashing
// file dbhash.c line 292
signed long int wg_decode_for_hashing(void *db, signed long int enc, char **decbytes)
{
  signed long int len;
  signed long int type;
  signed long int ptrdata;
  signed int intdata;
  double doubledata;
  char *bytedata;
  char *exdata;
  char *buf = (char *)(void *)0;
  char *outbuf;
  type=wg_get_encoded_type(db, enc);
  signed long int return_value_wg_decode_int_1;
  char return_value_wg_decode_char_4;
  signed long int return_value_wg_decode_var_5;
  switch(type)
  {
    case (signed long int)1:
    {
      len = (signed long int)sizeof(signed long int) /*8ul*/ ;
      ptrdata = (signed long int)0;
      bytedata = (char *)&ptrdata;
      break;
    }
    case (signed long int)2:
    {
      len = (signed long int)sizeof(signed long int) /*8ul*/ ;
      ptrdata = enc;
      bytedata = (char *)&ptrdata;
      break;
    }
    case (signed long int)3:
    {
      len = (signed long int)sizeof(signed int) /*4ul*/ ;
      return_value_wg_decode_int_1=wg_decode_int(db, enc);
      intdata = (signed int)return_value_wg_decode_int_1;
      bytedata = (char *)&intdata;
      break;
    }
    case (signed long int)4:
    {
      len = (signed long int)sizeof(double) /*8ul*/ ;
      doubledata=wg_decode_double(db, enc);
      bytedata = (char *)&doubledata;
      break;
    }
    case (signed long int)10:
    {
      len = (signed long int)sizeof(double) /*8ul*/ ;
      doubledata=wg_decode_fixpoint(db, enc);
      bytedata = (char *)&doubledata;
      break;
    }
    case (signed long int)5:
    {
      len=wg_decode_str_len(db, enc);
      bytedata=wg_decode_str(db, enc);
      break;
    }
    case (signed long int)7:
    {
      len=wg_decode_uri_len(db, enc);
      bytedata=wg_decode_uri(db, enc);
      exdata=wg_decode_uri_prefix(db, enc);
      if(!(exdata == ((char *)NULL)))
      {
        signed long int xl;
        xl=wg_decode_xmlliteral_xsdtype_len(db, enc);
        void *return_value_malloc_2;
        return_value_malloc_2=malloc((unsigned long int)(xl + len + (signed long int)1));
        buf = (char *)return_value_malloc_2;
        if(buf == ((char *)NULL))
          return (signed long int)0;

        memcpy((void *)buf, (const void *)exdata, (unsigned long int)xl);
        buf[xl] = (char)0;
        memcpy((void *)(buf + xl + (signed long int)1), (const void *)bytedata, (unsigned long int)len);
        bytedata = buf;
        len = len + xl + (signed long int)1;
      }

      break;
    }
    case (signed long int)6:
    {
      len=wg_decode_xmlliteral_len(db, enc);
      bytedata=wg_decode_xmlliteral(db, enc);
      exdata=wg_decode_xmlliteral_xsdtype(db, enc);
      if(!(exdata == ((char *)NULL)))
      {
        signed long int wg_decode_for_hashing__1__1__2__xl;
        wg_decode_for_hashing__1__1__2__xl=wg_decode_xmlliteral_xsdtype_len(db, enc);
        void *return_value_malloc_3;
        return_value_malloc_3=malloc((unsigned long int)(wg_decode_for_hashing__1__1__2__xl + len + (signed long int)1));
        buf = (char *)return_value_malloc_3;
        if(buf == ((char *)NULL))
          return (signed long int)0;

        memcpy((void *)buf, (const void *)exdata, (unsigned long int)wg_decode_for_hashing__1__1__2__xl);
        buf[wg_decode_for_hashing__1__1__2__xl] = (char)0;
        memcpy((void *)(buf + wg_decode_for_hashing__1__1__2__xl + (signed long int)1), (const void *)bytedata, (unsigned long int)len);
        bytedata = buf;
        len = len + wg_decode_for_hashing__1__1__2__xl + (signed long int)1;
      }

      break;
    }
    case (signed long int)9:
    {
      len = (signed long int)sizeof(signed int) /*4ul*/ ;
      return_value_wg_decode_char_4=wg_decode_char(db, enc);
      intdata = (signed int)return_value_wg_decode_char_4;
      bytedata = (char *)&intdata;
      break;
    }
    case (signed long int)11:
    {
      len = (signed long int)sizeof(signed int) /*4ul*/ ;
      intdata=wg_decode_date(db, enc);
      bytedata = (char *)&intdata;
      break;
    }
    case (signed long int)12:
    {
      len = (signed long int)sizeof(signed int) /*4ul*/ ;
      intdata=wg_decode_time(db, enc);
      bytedata = (char *)&intdata;
      break;
    }
    case (signed long int)14:
    {
      len = (signed long int)sizeof(signed int) /*4ul*/ ;
      return_value_wg_decode_var_5=wg_decode_var(db, enc);
      intdata = (signed int)return_value_wg_decode_var_5;
      bytedata = (char *)&intdata;
      break;
    }
    case (signed long int)13:

    default:
      return (signed long int)0;
  }
  void *return_value_malloc_6;
  return_value_malloc_6=malloc((unsigned long int)(len + (signed long int)1));
  outbuf = (char *)return_value_malloc_6;
  signed long int tmp_post_7;
  if(!(outbuf == ((char *)NULL)))
  {
    outbuf[(signed long int)0] = (char)type;
    tmp_post_7 = len;
    len = len + 1l;
    memcpy((void *)(outbuf + (signed long int)1), (const void *)bytedata, (unsigned long int)tmp_post_7);
    *decbytes = outbuf;
  }

  else
    len = (signed long int)0;
  if(!(buf == ((char *)NULL)))
    free((void *)buf);

  return len;
}

// wg_decode_int
// file ../Db/dbdata.h line 139
signed long int wg_decode_int(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_int");
    return (signed long int)0;
  }

  else
    if((7l & data) == 3l)
      return data >> 3;

    else
      if((3l & data) == 1l)
        return *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (data & (signed long int)~0x3)));

      else
      {
        show_data_error_nr(db, "data given to wg_decode_int is not an encoded int: ", data);
        return (signed long int)0;
      }
}

// wg_decode_null
// file dbdata.c line 1443
char * wg_decode_null(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_null");
    return (char *)(void *)0;
  }

  else
    if(!(data == 0l))
    {
      show_data_error(db, "data given to wg_decode_null is not an encoded NULL");
      return (char *)(void *)0;
    }

    else
      return (char *)(void *)0;
}

// wg_decode_record
// file dbdata.h line 182
void * wg_decode_record(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_encode_char");
    return NULL;
  }

  else
    return (void *)((char *)((struct anonymous_6 *)db)->db + data);
}

// wg_decode_str
// file dbdata.h line 189
char * wg_decode_str(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_str");
    return (char *)(void *)0;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_str is 0, not an encoded string");
      return (char *)(void *)0;
    }

    else
    {
      char *return_value_wg_decode_unistr_2;
      return_value_wg_decode_unistr_2=wg_decode_unistr(db, data, (signed long int)5);
      return return_value_wg_decode_unistr_2;
    }
}

// wg_decode_str_copy
// file dbdata.c line 1929
signed long int wg_decode_str_copy(void *db, signed long int data, char *strbuf, signed long int buflen)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_str_copy");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_str_copy is 0, not an encoded string");
      return (signed long int)-1;
    }

    else
      if(strbuf == ((char *)NULL))
      {
        show_data_error(db, "buffer given to wg_decode_str_copy is 0, not a valid buffer pointer");
        return (signed long int)-1;
      }

      else
        if(!(buflen >= 1l))
        {
          show_data_error(db, "buffer len given to wg_decode_str_copy is 0 or less");
          return (signed long int)-1;
        }

        else
        {
          signed long int return_value_wg_decode_unistr_copy_2;
          return_value_wg_decode_unistr_copy_2=wg_decode_unistr_copy(db, data, strbuf, buflen, (signed long int)5);
          return return_value_wg_decode_unistr_copy_2;
        }
}

// wg_decode_str_lang
// file dbdata.c line 1952
char * wg_decode_str_lang(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_str");
    return (char *)(void *)0;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_str_lang is 0, not an encoded string");
      return (char *)(void *)0;
    }

    else
    {
      char *return_value_wg_decode_unistr_lang_2;
      return_value_wg_decode_unistr_lang_2=wg_decode_unistr_lang(db, data, (signed long int)5);
      return return_value_wg_decode_unistr_lang_2;
    }
}

// wg_decode_str_lang_copy
// file dbdata.c line 1983
signed long int wg_decode_str_lang_copy(void *db, signed long int data, char *langbuf, signed long int buflen)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_str_lang_copy");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_str_lang_copy is 0, not an encoded string");
      return (signed long int)-1;
    }

    else
      if(langbuf == ((char *)NULL))
      {
        show_data_error(db, "buffer given to wg_decode_str_lang_copy is 0, not a valid buffer pointer");
        return (signed long int)-1;
      }

      else
        if(!(buflen >= 1l))
        {
          show_data_error(db, "buffer len given to wg_decode_str_lang_copy is 0 or less");
          return (signed long int)-1;
        }

        else
        {
          signed long int return_value_wg_decode_unistr_lang_copy_2;
          return_value_wg_decode_unistr_lang_copy_2=wg_decode_unistr_lang_copy(db, data, langbuf, buflen, (signed long int)5);
          return return_value_wg_decode_unistr_lang_copy_2;
        }
}

// wg_decode_str_lang_len
// file dbdata.c line 1967
signed long int wg_decode_str_lang_len(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_str_lang_len");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_str_lang_len is 0, not an encoded string");
      return (signed long int)-1;
    }

    else
    {
      signed long int return_value_wg_decode_unistr_lang_len_2;
      return_value_wg_decode_unistr_lang_len_2=wg_decode_unistr_lang_len(db, data, (signed long int)5);
      return return_value_wg_decode_unistr_lang_len_2;
    }
}

// wg_decode_str_len
// file dbdata.c line 1913
signed long int wg_decode_str_len(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_str_len");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_str_len is 0, not an encoded string");
      return (signed long int)-1;
    }

    else
    {
      signed long int return_value_wg_decode_unistr_len_2;
      return_value_wg_decode_unistr_len_2=wg_decode_unistr_len(db, data, (signed long int)5);
      return return_value_wg_decode_unistr_len_2;
    }
}

// wg_decode_time
// file dbdata.h line 163
signed int wg_decode_time(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_time");
    return 0;
  }

  else
    if((255l & data) == 63l)
      return (signed int)((unsigned int)data >> 8);

    else
    {
      show_data_error_nr(db, "data given to wg_decode_time is not an encoded time: ", data);
      return 0;
    }
}

// wg_decode_unistr
// file dbdata.c line 2670
char * wg_decode_unistr(void *db, signed long int data, signed long int type)
{
  signed long int *objptr;
  char *dataptr;
  if((7l & data) == 6l)
  {
    dataptr = (char *)(void *)((char *)((struct anonymous_6 *)db)->db + (data & (signed long int)~0x7));
    return dataptr;
  }

  else
    if((7l & data) == 4l)
    {
      objptr = (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + (data & (signed long int)~0x7));
      dataptr = (char *)objptr + (signed long int)((unsigned long int)6 * sizeof(signed long int) /*8ul*/ );
      return dataptr;
    }

    else
    {
      show_data_error(db, "data given to wg_decode_unistr is not an encoded string");
      return (char *)(void *)0;
    }
}

// wg_decode_unistr_copy
// file dbdata.c line 2770
signed long int wg_decode_unistr_copy(void *db, signed long int data, char *strbuf, signed long int buflen, signed long int type)
{
  signed long int i;
  signed long int *objptr;
  char *dataptr;
  signed long int objsize;
  signed long int strsize;
  _Bool tmp_if_expr_1;
  signed long int tmp_if_expr_3;
  signed long int tmp_if_expr_2;
  if((7l & data) == 6l && type == 5l)
  {
    dataptr = (char *)(void *)((char *)((struct anonymous_6 *)db)->db + (data & (signed long int)~0x7));
    i = (signed long int)1;
    do
    {
      if(!(i >= 32l))
        tmp_if_expr_1 = (signed int)*dataptr != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      if(i >= buflen)
      {
        show_data_error_nr(db, "insufficient buffer length given to wg_decode_unistr_copy:", buflen);
        return (signed long int)-1;
      }

      *strbuf = *dataptr;
      i = i + 1l;
      dataptr = dataptr + 1l;
      strbuf = strbuf + 1l;
    }
    while((_Bool)1);
    *strbuf = (char)0;
    return i - (signed long int)1;
  }

  else
    if((7l & data) == 4l)
    {
      objptr = (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + (data & (signed long int)~0x7));
      if(!((-4l & *objptr) >= 33l))
        tmp_if_expr_3 = (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/ ;

      else
      {
        if(!((-4l & *objptr) % 8l == 0l))
          tmp_if_expr_2 = (*objptr & (signed long int)~3) + (signed long int)4;

        else
          tmp_if_expr_2 = *objptr & (signed long int)~3;
        tmp_if_expr_3 = tmp_if_expr_2;
      }
      objsize = tmp_if_expr_3;
      dataptr = (char *)objptr + (signed long int)((unsigned long int)6 * sizeof(signed long int) /*8ul*/ );
      strsize = objsize - ((objptr[(signed long int)1] & (signed long int)0xFF00) >> 8);
      if(!(buflen >= strsize))
      {
        show_data_error_nr(db, "insufficient buffer length given to wg_decode_unistr_copy:", buflen);
        return (signed long int)-1;
      }

      memcpy((void *)strbuf, (const void *)dataptr, (unsigned long int)strsize);
      if(type == 8l)
        return strsize;

      return strsize - (signed long int)1;
    }

    else
    {
      show_data_error(db, "data given to wg_decode_unistr_copy is not an encoded string");
      return (signed long int)-1;
    }
}

// wg_decode_unistr_lang
// file dbdata.c line 2697
char * wg_decode_unistr_lang(void *db, signed long int data, signed long int type)
{
  signed long int *objptr;
  signed long int *fldptr;
  signed long int fldval;
  char *res;
  if((7l & data) == 6l && type == 5l)
    return (char *)(void *)0;

  else
    if((7l & data) == 4l)
    {
      objptr = (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + (data & (signed long int)~0x7));
      fldptr = (signed long int *)objptr + (signed long int)5;
      fldval = *fldptr;
      if(fldval == 0l)
        return (char *)(void *)0;

      res=wg_decode_unistr(db, fldval, type);
      return res;
    }

    else
    {
      show_data_error(db, "data given to wg_decode_unistr_lang is not an encoded string");
      return (char *)(void *)0;
    }
}

// wg_decode_unistr_lang_copy
// file dbdata.c line 2860
signed long int wg_decode_unistr_lang_copy(void *db, signed long int data, char *strbuf, signed long int buflen, signed long int type)
{
  char *langptr;
  signed long int len;
  langptr=wg_decode_unistr_lang(db, data, type);
  if(langptr == ((char *)NULL))
  {
    *strbuf = (char)0;
    return (signed long int)0;
  }

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(langptr);
    len = (signed long int)return_value_strlen_1;
    if(len >= buflen)
    {
      show_data_error_nr(db, "insufficient buffer length given to wg_decode_unistr_lang_copy:", buflen);
      return (signed long int)-1;
    }

    else
    {
      memcpy((void *)strbuf, (const void *)langptr, (unsigned long int)(len + (signed long int)1));
      return len;
    }
  }
}

// wg_decode_unistr_lang_len
// file dbdata.c line 2839
signed long int wg_decode_unistr_lang_len(void *db, signed long int data, signed long int type)
{
  char *langptr;
  signed long int len;
  langptr=wg_decode_unistr_lang(db, data, type);
  if(langptr == ((char *)NULL))
    return (signed long int)0;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(langptr);
    len = (signed long int)return_value_strlen_1;
    return len;
  }
}

// wg_decode_unistr_len
// file dbdata.c line 2729
signed long int wg_decode_unistr_len(void *db, signed long int data, signed long int type)
{
  char *dataptr;
  signed long int *objptr;
  signed long int objsize;
  signed long int strsize;
  if((7l & data) == 6l)
  {
    dataptr = (char *)(void *)((char *)((struct anonymous_6 *)db)->db + (data & (signed long int)~0x7));
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(dataptr);
    strsize = (signed long int)return_value_strlen_1;
    return strsize;
  }

  signed long int tmp_if_expr_3;
  signed long int tmp_if_expr_2;
  if((7l & data) == 4l)
  {
    objptr = (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + (data & (signed long int)~0x7));
    if(!((-4l & *objptr) >= 33l))
      tmp_if_expr_3 = (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/ ;

    else
    {
      if(!((-4l & *objptr) % 8l == 0l))
        tmp_if_expr_2 = (*objptr & (signed long int)~3) + (signed long int)4;

      else
        tmp_if_expr_2 = *objptr & (signed long int)~3;
      tmp_if_expr_3 = tmp_if_expr_2;
    }
    objsize = tmp_if_expr_3;
    dataptr = (char *)objptr + (signed long int)((unsigned long int)6 * sizeof(signed long int) /*8ul*/ );
    strsize = objsize - ((objptr[(signed long int)1] & (signed long int)0xFF00) >> 8);
    return strsize - (signed long int)1;
  }

  else
  {
    show_data_error(db, "data given to wg_decode_unistr_len is not an encoded string");
    return (signed long int)0;
  }
}

// wg_decode_uri
// file dbdata.h line 216
char * wg_decode_uri(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_uri");
    return (char *)(void *)0;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_uri is 0, not an encoded string");
      return (char *)(void *)0;
    }

    else
    {
      char *return_value_wg_decode_unistr_2;
      return_value_wg_decode_unistr_2=wg_decode_unistr(db, data, (signed long int)7);
      return return_value_wg_decode_unistr_2;
    }
}

// wg_decode_uri_copy
// file dbdata.c line 2187
signed long int wg_decode_uri_copy(void *db, signed long int data, char *strbuf, signed long int buflen)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_uri_copy");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_uri_copy is 0, not an encoded string");
      return (signed long int)-1;
    }

    else
      if(strbuf == ((char *)NULL))
      {
        show_data_error(db, "buffer given to wg_decode_uri_copy is 0, not a valid buffer pointer");
        return (signed long int)-1;
      }

      else
        if(!(buflen >= 1l))
        {
          show_data_error(db, "buffer len given to wg_decode_uri_copy is 0 or less");
          return (signed long int)-1;
        }

        else
        {
          signed long int return_value_wg_decode_unistr_copy_2;
          return_value_wg_decode_unistr_copy_2=wg_decode_unistr_copy(db, data, strbuf, buflen, (signed long int)7);
          return return_value_wg_decode_unistr_copy_2;
        }
}

// wg_decode_uri_len
// file dbdata.c line 2171
signed long int wg_decode_uri_len(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_uri_len");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_uri_len is 0, not an encoded string");
      return (signed long int)-1;
    }

    else
    {
      signed long int return_value_wg_decode_unistr_len_2;
      return_value_wg_decode_unistr_len_2=wg_decode_unistr_len(db, data, (signed long int)7);
      return return_value_wg_decode_unistr_len_2;
    }
}

// wg_decode_uri_prefix
// file dbdata.h line 217
char * wg_decode_uri_prefix(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_uri_prefix");
    return (char *)(void *)0;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_uri_prefix is 0, not an encoded uri");
      return (char *)(void *)0;
    }

    else
    {
      char *return_value_wg_decode_unistr_lang_2;
      return_value_wg_decode_unistr_lang_2=wg_decode_unistr_lang(db, data, (signed long int)7);
      return return_value_wg_decode_unistr_lang_2;
    }
}

// wg_decode_uri_prefix_copy
// file dbdata.c line 2241
signed long int wg_decode_uri_prefix_copy(void *db, signed long int data, char *langbuf, signed long int buflen)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_uri_prefix_copy");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_uri_prefix_copy is 0, not an encoded string");
      return (signed long int)-1;
    }

    else
      if(langbuf == ((char *)NULL))
      {
        show_data_error(db, "buffer given to wg_decode_uri_prefix_copy is 0, not a valid buffer pointer");
        return (signed long int)-1;
      }

      else
        if(!(buflen >= 1l))
        {
          show_data_error(db, "buffer len given to wg_decode_uri_prefix_copy is 0 or less");
          return (signed long int)-1;
        }

        else
        {
          signed long int return_value_wg_decode_unistr_lang_copy_2;
          return_value_wg_decode_unistr_lang_copy_2=wg_decode_unistr_lang_copy(db, data, langbuf, buflen, (signed long int)7);
          return return_value_wg_decode_unistr_lang_copy_2;
        }
}

// wg_decode_uri_prefix_len
// file dbdata.c line 2225
signed long int wg_decode_uri_prefix_len(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_uri_prefix_len");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_uri_prefix_len is 0, not an encoded string");
      return (signed long int)-1;
    }

    else
    {
      signed long int return_value_wg_decode_unistr_lang_len_2;
      return_value_wg_decode_unistr_lang_len_2=wg_decode_unistr_lang_len(db, data, (signed long int)7);
      return return_value_wg_decode_unistr_lang_len_2;
    }
}

// wg_decode_var
// file dbdata.h line 247
signed long int wg_decode_var(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_var");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_var is 0, not an encoded var");
      return (signed long int)-1;
    }

    else
      return data >> 4;
}

// wg_decode_xmlliteral
// file dbdata.h line 202
char * wg_decode_xmlliteral(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_xmlliteral");
    return (char *)(void *)0;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_xmlliteral is 0, not an encoded xmlliteral");
      return (char *)(void *)0;
    }

    else
    {
      char *return_value_wg_decode_unistr_2;
      return_value_wg_decode_unistr_2=wg_decode_unistr(db, data, (signed long int)6);
      return return_value_wg_decode_unistr_2;
    }
}

// wg_decode_xmlliteral_copy
// file dbdata.c line 2060
signed long int wg_decode_xmlliteral_copy(void *db, signed long int data, char *strbuf, signed long int buflen)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_xmlliteral_copy");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_xmlliteral_copy is 0, not an encoded xmlliteral");
      return (signed long int)-1;
    }

    else
      if(strbuf == ((char *)NULL))
      {
        show_data_error(db, "buffer given to wg_decode_xmlliteral_copy is 0, not a valid buffer pointer");
        return (signed long int)-1;
      }

      else
        if(!(buflen >= 1l))
        {
          show_data_error(db, "buffer len given to wg_decode_xmlliteral_copy is 0 or less");
          return (signed long int)-1;
        }

        else
        {
          signed long int return_value_wg_decode_unistr_copy_2;
          return_value_wg_decode_unistr_copy_2=wg_decode_unistr_copy(db, data, strbuf, buflen, (signed long int)6);
          return return_value_wg_decode_unistr_copy_2;
        }
}

// wg_decode_xmlliteral_len
// file dbdata.c line 2044
signed long int wg_decode_xmlliteral_len(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_xmlliteral_len");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_xmlliteral_len is 0, not an encoded xmlliteral");
      return (signed long int)-1;
    }

    else
    {
      signed long int return_value_wg_decode_unistr_len_2;
      return_value_wg_decode_unistr_len_2=wg_decode_unistr_len(db, data, (signed long int)6);
      return return_value_wg_decode_unistr_len_2;
    }
}

// wg_decode_xmlliteral_xsdtype
// file dbdata.h line 203
char * wg_decode_xmlliteral_xsdtype(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_xmlliteral");
    return (char *)(void *)0;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_xmlliteral_xsdtype is 0, not an encoded xmlliteral");
      return (char *)(void *)0;
    }

    else
    {
      char *return_value_wg_decode_unistr_lang_2;
      return_value_wg_decode_unistr_lang_2=wg_decode_unistr_lang(db, data, (signed long int)6);
      return return_value_wg_decode_unistr_lang_2;
    }
}

// wg_decode_xmlliteral_xsdtype_copy
// file dbdata.c line 2114
signed long int wg_decode_xmlliteral_xsdtype_copy(void *db, signed long int data, char *langbuf, signed long int buflen)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_xmlliteral_xsdtype_copy");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_xmlliteral_xsdtype_copy is 0, not an encoded xmlliteral");
      return (signed long int)-1;
    }

    else
      if(langbuf == ((char *)NULL))
      {
        show_data_error(db, "buffer given to wg_decode_xmlliteral_xsdtype_copy is 0, not a valid buffer pointer");
        return (signed long int)-1;
      }

      else
        if(!(buflen >= 1l))
        {
          show_data_error(db, "buffer len given to wg_decode_xmlliteral_xsdtype_copy is 0 or less");
          return (signed long int)-1;
        }

        else
        {
          signed long int return_value_wg_decode_unistr_lang_copy_2;
          return_value_wg_decode_unistr_lang_copy_2=wg_decode_unistr_lang_copy(db, data, langbuf, buflen, (signed long int)6);
          return return_value_wg_decode_unistr_lang_copy_2;
        }
}

// wg_decode_xmlliteral_xsdtype_len
// file dbdata.c line 2098
signed long int wg_decode_xmlliteral_xsdtype_len(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_decode_xmlliteral_xsdtype_len");
    return (signed long int)-1;
  }

  else
    if(data == 0l)
    {
      show_data_error(db, "data given to wg_decode_xmlliteral_lang_xsdtype is 0, not an encoded xmlliteral");
      return (signed long int)-1;
    }

    else
    {
      signed long int return_value_wg_decode_unistr_lang_len_2;
      return_value_wg_decode_unistr_lang_len_2=wg_decode_unistr_lang_len(db, data, (signed long int)6);
      return return_value_wg_decode_unistr_lang_len_2;
    }
}

// wg_delete_database
// file ../Db/dbmem.h line 61
signed int wg_delete_database(char *dbasename)
{
  signed int key = 0;
  signed long int return_value_strtol_1;
  if(!(dbasename == ((char *)NULL)))
  {
    return_value_strtol_1=strtol(dbasename, (char ** restrict )(void *)0, 10);
    key = (signed int)return_value_strtol_1;
  }

  if(key == 0x7fffffff || key == -2147483648 || !(key >= 1))
    key = 1000;

  signed int return_value_free_shared_memory_2;
  return_value_free_shared_memory_2=free_shared_memory(key);
  return return_value_free_shared_memory_2;
}

// wg_delete_document
// file dbschema.c line 216
signed long int wg_delete_document(void *db, void *document)
{
  if((16l & ((signed long int *)document)[1l]) == 0l)
  {
    signed long int return_value_show_schema_error_1;
    return_value_show_schema_error_1=show_schema_error(db, "wg_delete_document: not a document");
    return return_value_show_schema_error_1;
  }

  signed long int return_value_delete_record_recursive_2;
  return_value_delete_record_recursive_2=delete_record_recursive(db, document, 7);
  return return_value_delete_record_recursive_2;
}

// wg_delete_local_database
// file dbmem.c line 417
void wg_delete_local_database(void *dbase)
{
  if(!(dbase == NULL))
  {
    void *localmem = (void *)((struct anonymous_6 *)dbase)->db;
    if(!(localmem == NULL))
      free(localmem);

    free_dbhandle(dbase);
  }

}

// wg_delete_record
// file dbdata.c line 203
signed long int wg_delete_record(void *db, void *rec)
{
  signed long int offset;
  signed long int *dptr;
  signed long int *dendptr;
  signed long int data;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_delete_record");
    return (signed long int)-2;
  }

  else
    if(!(((signed long int *)rec)[2l] == 0l))
      return (signed long int)-1;

    else
    {
      if((1l & ((signed long int *)rec)[1l]) == 0l)
      {
        signed long int return_value_wg_index_del_rec_2;
        return_value_wg_index_del_rec_2=wg_index_del_rec(db, rec);
        if(!(return_value_wg_index_del_rec_2 >= -1l))
          return (signed long int)-3;

      }

      offset = (signed long int)((char *)rec - (char *)((struct anonymous_6 *)db)->db);
      dendptr = (signed long int *)((char *)rec + (*((signed long int *)rec) & (signed long int)~3));
      dptr = (signed long int *)rec + (signed long int)3;
      for( ; !(dptr >= dendptr); dptr = dptr + 1l)
      {
        data = *dptr;
        signed long int return_value_wg_get_encoded_type_4;
        return_value_wg_get_encoded_type_4=wg_get_encoded_type(db, data);
        if(return_value_wg_get_encoded_type_4 == 2l)
        {
          signed long int *child;
          void *return_value_wg_decode_record_3;
          return_value_wg_decode_record_3=wg_decode_record(db, data);
          child = (signed long int *)return_value_wg_decode_record_3;
          signed long int *next_offset = child + (signed long int)2;
          struct anonymous_20 *old = (struct anonymous_20 *)(void *)0;
          for( ; !(*next_offset == 0l); next_offset = &old->cdr)
          {
            old = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *next_offset);
            if(old->car == offset)
            {
              signed long int old_offset = *next_offset;
              *next_offset = old->cdr;
              wg_free_listcell(db, old_offset);
              goto recdel_backlink_removed;
            }

          }
          show_data_error(db, "Corrupt backlink chain");
          return (signed long int)-3;
        }


      recdel_backlink_removed:
        ;
        if(!((3l & data) == 3l) && !(data == 0l))
          free_field_encoffset(db, data);

      }
      wg_free_object(db, (void *)&((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->datarec_area_header, offset);
      return (signed long int)0;
    }
}

// wg_detach_database
// file dbmem.c line 344
signed int wg_detach_database(void *dbase)
{
  signed int err;
  err=detach_shared_memory((void *)((struct anonymous_6 *)dbase)->db);
  if(err == 0)
    free_dbhandle(dbase);

  return err;
}

// wg_dhash_addkey
// file dbhash.c line 932
signed long int wg_dhash_addkey(void *db, void *tbl, signed long int key)
{
  signed long int *b;
  b=dhash_lookup((struct anonymous_36 *)tbl, key);
  if(*b == 0l)
    *b = key;

  else
    if(!(*b == key))
      return (signed long int)-1;

  return (signed long int)0;
}

// wg_dhash_free
// file dbhash.c line 919
void wg_dhash_free(void *db, void *tbl)
{
  if(!(tbl == NULL))
  {
    if(!(((struct anonymous_36 *)tbl)->keys == ((signed long int *)NULL)))
      free((void *)((struct anonymous_36 *)tbl)->keys);

    free(tbl);
  }

}

// wg_dhash_haskey
// file dbhash.c line 947
signed long int wg_dhash_haskey(void *db, void *tbl, signed long int key)
{
  signed long int *b;
  b=dhash_lookup((struct anonymous_36 *)tbl, key);
  return (signed long int)(*b == key);
}

// wg_dhash_init
// file dbhash.c line 903
void * wg_dhash_init(void *db, unsigned long int entries)
{
  struct anonymous_36 *tbl;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_36) /*16ul*/ );
  tbl = (struct anonymous_36 *)return_value_malloc_1;
  _Bool tmp_if_expr_3;
  if(!(tbl == ((struct anonymous_36 *)NULL)))
  {
    tbl->dhash_size=dhash_size(entries);
    void *return_value_calloc_2;
    return_value_calloc_2=calloc(tbl->dhash_size, sizeof(signed long int) /*8ul*/ );
    tbl->keys = (signed long int *)return_value_calloc_2;
    if(tbl->keys == ((signed long int *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = !(tbl->dhash_size != 0ul) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      free((void *)tbl);
      tbl = (struct anonymous_36 *)(void *)0;
    }

  }

  return (void *)tbl;
}

// wg_drop_index
// file dbindex.c line 2273
signed long int wg_drop_index(void *db, signed long int index_id)
{
  signed int i;
  struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)0;
  signed long int *ilist;
  struct anonymous_20 *ilistelem;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  ilist = &dbh->index_control_area_header.index_list;
  for( ; !(*ilist == 0l); ilist = &ilistelem->cdr)
  {
    ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
    if(ilistelem->car == index_id)
    {
      hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + index_id);
      delete_from_list(db, ilist);
      break;
    }

  }
  signed long int return_value_drop_ttree_index_3;
  signed long int return_value_drop_hash_index_4;
  if(hdr == ((struct anonymous_21 *)NULL))
  {
    show_index_error_nr(db, "Invalid index for delete", index_id);
    return (signed long int)-1;
  }

  else
  {
    i = 0;
    for( ; !((signed long int)i >= hdr->fields); i = i + 1)
    {
      signed int column = (signed int)hdr->rec_field_index[(signed long int)i];
      ilist = &dbh->index_control_area_header.index_table[(signed long int)column];
      for( ; !(*ilist == 0l); ilist = &ilistelem->cdr)
      {
        ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
        if(ilistelem->car == index_id)
        {
          delete_from_list(db, ilist);
          break;
        }

      }
    }
    if(!(hdr->template_offset == 0l))
    {
      struct anonymous_22 *wg_drop_index__1__4__tmpl = (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + hdr->template_offset);
      void *matchrec = (void *)((char *)((struct anonymous_6 *)db)->db + wg_drop_index__1__4__tmpl->offset_matchrec);
      signed long int reclen;
      reclen=wg_get_record_len(db, matchrec);
      i = 0;
      for( ; !((signed long int)i >= reclen); i = i + 1)
      {
        signed long int return_value_wg_get_field_1;
        return_value_wg_get_field_1=wg_get_field(db, matchrec, (signed long int)i);
        signed long int return_value_wg_get_encoded_type_2;
        return_value_wg_get_encoded_type_2=wg_get_encoded_type(db, return_value_wg_get_field_1);
        if(!(return_value_wg_get_encoded_type_2 == 14l))
        {
          ilist = &dbh->index_control_area_header.index_template_table[(signed long int)i];
          for( ; !(*ilist == 0l); ilist = &ilistelem->cdr)
          {
            ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
            if(ilistelem->car == index_id)
            {
              delete_from_list(db, ilist);
              break;
            }

          }
        }

      }
    }

    switch(hdr->type)
    {
      case (signed long int)50:

      case (signed long int)51:
      {
        return_value_drop_ttree_index_3=drop_ttree_index(db, index_id);
        if(!(return_value_drop_ttree_index_3 == 0l))
          return (signed long int)-1;

        break;
      }
      case (signed long int)60:

      case (signed long int)61:
      {
        return_value_drop_hash_index_4=drop_hash_index(db, index_id);
        if(!(return_value_drop_hash_index_4 == 0l))
          return (signed long int)-1;

        break;
      }
      default:
      {
        show_index_error(db, "Invalid index type");
        return (signed long int)-1;
      }
    }
    if(!(hdr->template_offset == 0l))
    {
      struct anonymous_22 *tmpl = (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + hdr->template_offset);
      tmpl->refcount = tmpl->refcount - 1l;
      if(tmpl->refcount == 0l)
        remove_index_template(db, hdr->template_offset);

    }

    wg_free_fixlen_object(db, &dbh->indexhdr_area_header, index_id);
    dbh->index_control_area_header.number_of_indexes = dbh->index_control_area_header.number_of_indexes - 1l;
    return (signed long int)0;
  }
}

// wg_dump
// file dbdump.c line 76
signed long int wg_dump(void *db, char *fileName)
{
  signed long int return_value_wg_dump_internal_1;
  return_value_wg_dump_internal_1=wg_dump_internal(db, fileName, 1);
  return return_value_wg_dump_internal_1;
}

// wg_dump_internal
// file dbdump.c line 84
signed long int wg_dump_internal(void *db, char *fileName, signed int locking)
{
  struct _IO_FILE *f;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int dbsize = dbh->free;
  signed long int err = (signed long int)-1;
  signed long int lock_id = (signed long int)0;
  signed int crc;
  if(!(dbh->extdbs.count == 0l))
    show_dump_error(db, "Database contains external references");

  f=fopen(fileName, "wb");
  if(f == ((struct _IO_FILE *)NULL))
  {
    show_dump_error(db, "Error opening file");
    return (signed long int)-1;
  }

  else
    if(!(locking == 0))
    {
      lock_id=db_tfqueue_rlock(db, (signed long int)2000);
      if(!(lock_id == 0l))
        goto __CPROVER_DUMP_L3;

      show_dump_error(db, "Failed to lock the database for dump");
      return (signed long int)-1;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      crc=update_crc32((char *)((struct anonymous_6 *)db)->db, dbsize, 0x0);
      unsigned long int return_value_fwrite_2;
      return_value_fwrite_2=fwrite((void *)((struct anonymous_6 *)db)->db, (unsigned long int)dbsize, (unsigned long int)1, f);
      if(return_value_fwrite_2 == 1ul)
      {
        fseek(f, (signed long int)((char *)&dbh->checksum - (char *)((struct anonymous_6 *)db)->db), 0);
        unsigned long int return_value_fwrite_1;
        return_value_fwrite_1=fwrite((const void *)&crc, sizeof(signed int) /*4ul*/ , (unsigned long int)1, f);
        if(return_value_fwrite_1 == 1ul)
          err = (signed long int)0;

      }

      if(!(err == 0l))
        show_dump_error(db, "Error writing file");

      if(!(locking == 0))
      {
        signed long int return_value_db_tfqueue_rulock_3;
        return_value_db_tfqueue_rulock_3=db_tfqueue_rulock(db, lock_id);
        if(return_value_db_tfqueue_rulock_3 == 0l)
        {
          show_dump_error(db, "Failed to unlock the database");
          err = (signed long int)-2;
        }

      }

      fflush(f);
      fclose(f);
      return err;
    }
}

// wg_encode_anonconst
// file dbdata.c line 2393
signed long int wg_encode_anonconst(void *db, char *str)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_encode_anonconst");
    return (signed long int)0xff;
  }

  else
    if(str == ((char *)NULL))
    {
      show_data_error(db, "NULL string ptr given to wg_encode_anonconst");
      return (signed long int)0xff;
    }

    else
    {
      signed long int return_value_wg_encode_unistr_2;
      return_value_wg_encode_unistr_2=wg_encode_unistr(db, str, (char *)(void *)0, (signed long int)7);
      return return_value_wg_encode_unistr_2;
    }
}

// wg_encode_blob
// file dbdata.c line 2267
signed long int wg_encode_blob(void *db, char *str, char *type, signed long int len)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_encode_blob");
    return (signed long int)0xff;
  }

  else
    if(str == ((char *)NULL))
    {
      show_data_error(db, "NULL string ptr given to wg_encode_blob");
      return (signed long int)0xff;
    }

    else
    {
      signed long int return_value_wg_encode_uniblob_2;
      return_value_wg_encode_uniblob_2=wg_encode_uniblob(db, str, type, (signed long int)8, len);
      return return_value_wg_encode_uniblob_2;
    }
}

// wg_encode_char
// file dbdata.c line 1513
signed long int wg_encode_char(void *db, char data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_encode_char");
    return (signed long int)0xff;
  }

  else
    return (signed long int)((signed long int)data << 8 | (signed long int)0x1f);
}

// wg_encode_date
// file dbdata.c line 1634
signed long int wg_encode_date(void *db, signed int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_encode_date");
    return (signed long int)0xff;
  }

  else
    if(!(data >= 255) || data >= 8323201)
    {
      show_data_error(db, "argument given to wg_encode_date too big or too small");
      return (signed long int)0xff;
    }

    else
      return (signed long int)(data << 8 | 0x2f);
}

// wg_encode_double
// file dbdata.c line 1543
signed long int wg_encode_double(void *db, double data)
{
  signed long int offset;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_encode_double");
    return (signed long int)0xff;
  }

  else
  {
    offset=wg_alloc_fixlen_object(db, (void *)&((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->doubleword_area_header);
    if(offset == 0l)
    {
      show_data_error_double(db, "cannot store a double in wg_set_double_field: ", data);
      return (signed long int)0xff;
    }

    *((double *)(void *)((char *)((struct anonymous_6 *)db)->db + offset)) = data;
    return offset | (signed long int)0x2;
  }
}

// wg_encode_external_data
// file dbdata.c line 2954
signed long int wg_encode_external_data(void *db, void *extdb, signed long int encoded)
{
  show_data_error(db, "child databases support is not enabled.");
  return (signed long int)0xff;
}

// wg_encode_fixpoint
// file dbdata.c line 1597
signed long int wg_encode_fixpoint(void *db, double data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_encode_fixpoint");
    return (signed long int)0xff;
  }

  else
    if(!(data <= 800.000000) || !(data >= -800.000000))
    {
      show_data_error(db, "argument given to wg_encode_fixpoint too big or too small");
      return (signed long int)0xff;
    }

    else
    {
      double return_value_round_2;
      return_value_round_2=round(data * (double)10000.0);
      return (signed long int)((signed int)return_value_round_2 << 8 | 0xf);
    }
}

// wg_encode_int
// file dbdata.c line 1457
signed long int wg_encode_int(void *db, signed long int data)
{
  signed long int offset;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_encode_int");
    return (signed long int)0xff;
  }

  else
    if((data << 3) >> 3 == data)
      return data << 3 | (signed long int)0x3;

    else
    {
      offset=wg_alloc_fixlen_object(db, (void *)&((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->word_area_header);
      if(offset == 0l)
      {
        show_data_error_nr(db, "cannot store an integer in wg_set_int_field: ", data);
        return (signed long int)0xff;
      }

      *((signed long int *)((char *)((struct anonymous_6 *)db)->db + offset)) = data;
      return offset | (signed long int)0x1;
    }
}

// wg_encode_null
// file dbdata.c line 1421
signed long int wg_encode_null(void *db, char *data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_encode_null");
    return (signed long int)0xff;
  }

  else
    if(!(data == ((char *)NULL)))
    {
      show_data_error(db, "data given to wg_encode_null is not NULL");
      return (signed long int)0xff;
    }

    else
      return (signed long int)0;
}

// wg_encode_query_param_char
// file dbquery.c line 1130
signed long int wg_encode_query_param_char(void *db, char data)
{
  signed long int return_value_wg_encode_char_1;
  return_value_wg_encode_char_1=wg_encode_char(db, data);
  return return_value_wg_encode_char_1;
}

// wg_encode_query_param_date
// file dbquery.c line 1138
signed long int wg_encode_query_param_date(void *db, signed int data)
{
  signed long int return_value_wg_encode_date_1;
  return_value_wg_encode_date_1=wg_encode_date(db, data);
  return return_value_wg_encode_date_1;
}

// wg_encode_query_param_double
// file dbquery.c line 1171
signed long int wg_encode_query_param_double(void *db, double data)
{
  void *dptr;
  dptr=malloc((unsigned long int)2 * sizeof(signed long int) /*8ul*/ );
  if(dptr == NULL)
  {
    show_query_error(db, "Failed to encode query parameter");
    return (signed long int)0xff;
  }

  else
  {
    *((double *)dptr) = data;
    return (signed long int)((char *)dptr - (char *)((struct anonymous_6 *)db)->db) | (signed long int)0x2;
  }
}

// wg_encode_query_param_fixpoint
// file dbquery.c line 1134
signed long int wg_encode_query_param_fixpoint(void *db, double data)
{
  signed long int return_value_wg_encode_fixpoint_1;
  return_value_wg_encode_fixpoint_1=wg_encode_fixpoint(db, data);
  return return_value_wg_encode_fixpoint_1;
}

// wg_encode_query_param_int
// file dbquery.c line 1155
signed long int wg_encode_query_param_int(void *db, signed long int data)
{
  void *dptr;
  if((data << 3) >> 3 == data)
    return data << 3 | (signed long int)0x3;

  else
  {
    dptr=malloc(sizeof(signed long int) /*8ul*/ );
    if(dptr == NULL)
    {
      show_query_error(db, "Failed to encode query parameter");
      return (signed long int)0xff;
    }

    *((signed long int *)dptr) = data;
    return (signed long int)((char *)dptr - (char *)((struct anonymous_6 *)db)->db) | (signed long int)0x1;
  }
}

// wg_encode_query_param_null
// file dbquery.c line 1122
signed long int wg_encode_query_param_null(void *db, char *data)
{
  signed long int return_value_wg_encode_null_1;
  return_value_wg_encode_null_1=wg_encode_null(db, data);
  return return_value_wg_encode_null_1;
}

// wg_encode_query_param_record
// file dbquery.c line 1126
signed long int wg_encode_query_param_record(void *db, void *data)
{
  signed long int return_value_wg_encode_record_1;
  return_value_wg_encode_record_1=wg_encode_record(db, data);
  return return_value_wg_encode_record_1;
}

// wg_encode_query_param_str
// file dbquery.c line 1183
signed long int wg_encode_query_param_str(void *db, char *data, char *lang)
{
  if(!(data == ((char *)NULL)))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(data);
    signed long int return_value_encode_query_param_unistr_2;
    return_value_encode_query_param_unistr_2=encode_query_param_unistr(db, data, (signed long int)5, lang, (signed int)return_value_strlen_1);
    return return_value_encode_query_param_unistr_2;
  }

  else
  {
    show_query_error(db, "NULL pointer given as parameter");
    return (signed long int)0xff;
  }
}

// wg_encode_query_param_time
// file dbquery.c line 1142
signed long int wg_encode_query_param_time(void *db, signed int data)
{
  signed long int return_value_wg_encode_time_1;
  return_value_wg_encode_time_1=wg_encode_time(db, data);
  return return_value_wg_encode_time_1;
}

// wg_encode_query_param_uri
// file dbquery.c line 1202
signed long int wg_encode_query_param_uri(void *db, char *data, char *prefix)
{
  if(!(data == ((char *)NULL)))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(data);
    signed long int return_value_encode_query_param_unistr_2;
    return_value_encode_query_param_unistr_2=encode_query_param_unistr(db, data, (signed long int)7, prefix, (signed int)return_value_strlen_1);
    return return_value_encode_query_param_unistr_2;
  }

  else
  {
    show_query_error(db, "NULL pointer given as parameter");
    return (signed long int)0xff;
  }
}

// wg_encode_query_param_var
// file dbquery.c line 1146
signed long int wg_encode_query_param_var(void *db, signed long int data)
{
  signed long int return_value_wg_encode_var_1;
  return_value_wg_encode_var_1=wg_encode_var(db, data);
  return return_value_wg_encode_var_1;
}

// wg_encode_query_param_xmlliteral
// file dbquery.c line 1192
signed long int wg_encode_query_param_xmlliteral(void *db, char *data, char *xsdtype)
{
  if(!(data == ((char *)NULL)))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(data);
    signed long int return_value_encode_query_param_unistr_2;
    return_value_encode_query_param_unistr_2=encode_query_param_unistr(db, data, (signed long int)6, xsdtype, (signed int)return_value_strlen_1);
    return return_value_encode_query_param_unistr_2;
  }

  else
  {
    show_query_error(db, "NULL pointer given as parameter");
    return (signed long int)0xff;
  }
}

// wg_encode_record
// file dbdata.c line 1840
signed long int wg_encode_record(void *db, void *data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_encode_char");
    return (signed long int)0xff;
  }

  else
    return (signed long int)((char *)data - (char *)((struct anonymous_6 *)db)->db);
}

// wg_encode_str
// file dbdata.c line 1882
signed long int wg_encode_str(void *db, char *str, char *lang)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_encode_str");
    return (signed long int)0xff;
  }

  else
    if(str == ((char *)NULL))
    {
      show_data_error(db, "NULL string ptr given to wg_encode_str");
      return (signed long int)0xff;
    }

    else
    {
      signed long int return_value_wg_encode_unistr_2;
      return_value_wg_encode_unistr_2=wg_encode_unistr(db, str, lang, (signed long int)5);
      return return_value_wg_encode_unistr_2;
    }
}

// wg_encode_time
// file dbdata.c line 1670
signed long int wg_encode_time(void *db, signed int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_encode_time");
    return (signed long int)0xff;
  }

  else
    if(!(data >= 0) || data >= 8640001)
    {
      show_data_error(db, "argument given to wg_encode_time too big or too small");
      return (signed long int)0xff;
    }

    else
      return (signed long int)(data << 8 | 0x3f);
}

// wg_encode_uniblob
// file dbdata.c line 2564
signed long int wg_encode_uniblob(void *db, char *str, char *lang, signed long int type, signed long int len)
{
  signed long int offset;
  offset=find_create_longstr(db, str, lang, type, len);
  if(offset == 0l)
  {
    show_data_error_nr(db, "cannot create a blob of size ", len);
    return (signed long int)0xff;
  }

  return offset | (signed long int)0x4;
}

// wg_encode_unistr
// file dbdata.c line 2476
signed long int wg_encode_unistr(void *db, char *str, char *lang, signed long int type)
{
  signed long int offset;
  signed long int len;
  char *dptr;
  char *sptr;
  char *dendptr;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  len = (signed long int)return_value_strlen_1;
  if(lang == ((char *)NULL) && type == 5l && !(len >= 32l))
  {
    offset=wg_alloc_fixlen_object(db, (void *)&((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->shortstr_area_header);
    if(offset == 0l)
    {
      show_data_error_str(db, "cannot store a string in wg_encode_unistr", str);
      return (signed long int)0xff;
    }

    dptr = (char *)(void *)((char *)((struct anonymous_6 *)db)->db + offset);
    dendptr = dptr + (signed long int)32;
    sptr = str;
    do
    {
      *dptr = *sptr;
      if((signed int)*dptr == 0)
        break;

      sptr = sptr + 1l;
      dptr = dptr + 1l;
    }
    while((_Bool)1);
    dptr = dptr + 1l;
    for( ; !(dptr >= dendptr); dptr = dptr + 1l)
      *dptr = (char)0;
    return offset | (signed long int)0x6;
  }

  else
  {
    offset=find_create_longstr(db, str, lang, type, len + (signed long int)1);
    if(offset == 0l)
    {
      show_data_error_nr(db, "cannot create a string of size ", len);
      return (signed long int)0xff;
    }

    return offset | (signed long int)0x4;
  }
}

// wg_encode_uri
// file dbdata.c line 2140
signed long int wg_encode_uri(void *db, char *str, char *prefix)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_encode_uri");
    return (signed long int)0xff;
  }

  else
    if(str == ((char *)NULL))
    {
      show_data_error(db, "NULL string ptr given to wg_encode_uri");
      return (signed long int)0xff;
    }

    else
    {
      signed long int return_value_wg_encode_unistr_2;
      return_value_wg_encode_unistr_2=wg_encode_unistr(db, str, prefix, (signed long int)7);
      return return_value_wg_encode_unistr_2;
    }
}

// wg_encode_var
// file dbdata.c line 2429
signed long int wg_encode_var(void *db, signed long int varnr)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_encode_var");
    return (signed long int)0xff;
  }

  else
    if(!((varnr << 4) >> 4 == varnr))
    {
      show_data_error(db, "int given to wg_encode_var too big/small");
      return (signed long int)0xff;
    }

    else
      return varnr << 4 | (signed long int)0x7;
}

// wg_encode_xmlliteral
// file dbdata.c line 2009
signed long int wg_encode_xmlliteral(void *db, char *str, char *xsdtype)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_encode_xmlliteral");
    return (signed long int)0xff;
  }

  else
    if(str == ((char *)NULL))
    {
      show_data_error(db, "NULL string ptr given to wg_encode_xmlliteral");
      return (signed long int)0xff;
    }

    else
      if(xsdtype == ((char *)NULL))
      {
        show_data_error(db, "NULL xsdtype ptr given to wg_encode_xmlliteral");
        return (signed long int)0xff;
      }

      else
      {
        signed long int return_value_wg_encode_unistr_2;
        return_value_wg_encode_unistr_2=wg_encode_unistr(db, str, xsdtype, (signed long int)6);
        return return_value_wg_encode_unistr_2;
      }
}

// wg_end_read
// file ../Db/dblock.h line 76
signed long int wg_end_read(void *db, signed long int lock)
{
  signed long int return_value_db_tfqueue_rulock_1;
  return_value_db_tfqueue_rulock_1=db_tfqueue_rulock(db, lock);
  return return_value_db_tfqueue_rulock_1;
}

// wg_end_write
// file ../Db/dblock.h line 74
signed long int wg_end_write(void *db, signed long int lock)
{
  signed long int return_value_db_tfqueue_wulock_1;
  return_value_db_tfqueue_wulock_1=db_tfqueue_wulock(db, lock);
  return return_value_db_tfqueue_wulock_1;
}

// wg_export_db_csv
// file dbutil.c line 673
void wg_export_db_csv(void *db, char *filename)
{
  void *rec;
  struct _IO_FILE *f;
  f=fopen(filename, "w");
  if(f == ((struct _IO_FILE *)NULL))
    show_io_error_str(db, "failed to open file", filename);

  else
  {
    rec=wg_get_first_record(db);
    while(!(rec == NULL))
    {
      wg_fprint_record_csv(db, (signed long int *)rec, f);
      fprintf(f, "\n");
      rec=wg_get_next_record(db, rec);
    }
    fclose(f);
  }
}

// wg_fetch
// file dbquery.c line 976
void * wg_fetch(void *db, struct anonymous_15 *query)
{
  void *rec;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_3;
  signed long int return_value_check_arglist_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_6;
  signed long int return_value_check_arglist_5;
  signed long int tmp_post_7;
  if(!tmp_if_expr_1)
  {
    fprintf(stderr, "Invalid database pointer in wg_fetch.\n");
    return (void *)0;
  }

  else
    if(query == ((struct anonymous_15 *)NULL))
    {
      show_query_error(db, "Invalid query object");
      return (void *)0;
    }

    else
    {
      if(query->qtype == 4l)
        do
        {
          void *next;
          if(query->curr_record == 0l)
            return (void *)0;

          rec = (void *)((char *)((struct anonymous_6 *)db)->db + query->curr_record);
          next=wg_get_next_record(db, rec);
          if(!(next == NULL))
            query->curr_record = (signed long int)((char *)next - (char *)((struct anonymous_6 *)db)->db);

          else
            query->curr_record = (signed long int)0;
          if(query->arglist == ((struct anonymous_12 *)NULL))
            tmp_if_expr_3 = (_Bool)1;

          else
          {
            return_value_check_arglist_2=check_arglist(db, rec, query->arglist, query->argc);
            tmp_if_expr_3 = return_value_check_arglist_2 != 0l ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_3)
            return rec;

        }
        while((_Bool)1);

      else
        if(query->qtype == 1l)
        {
          struct wg_tnode *node;
          while((_Bool)1)
          {
            if(query->curr_offset == 0l)
              return (void *)0;

            node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + query->curr_offset);
            rec = (void *)((char *)((struct anonymous_6 *)db)->db + node->array_of_values[query->curr_slot]);
            if(query->curr_offset == query->end_offset)
              tmp_if_expr_4 = query->curr_slot == query->end_slot ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_4 = (_Bool)0;
            if(tmp_if_expr_4)
              query->curr_offset = (signed long int)0;

            else
            {
              query->curr_slot = query->curr_slot + query->direction;
              if(!(query->curr_slot >= 0l))
              {
                if(query->end_offset == query->curr_offset)
                {
                  show_query_error(db, "Warning: end slot mismatch, possible bug");
                  query->curr_offset = (signed long int)0;
                }

                else
                {
                  query->curr_offset = node->pred_offset;
                  if(!(query->curr_offset == 0l))
                  {
                    node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + query->curr_offset);
                    query->curr_slot = (signed long int)((signed int)node->number_of_elements - 1);
                  }

                }
              }

              else
                if(query->curr_slot >= (signed long int)node->number_of_elements)
                {
                  if(query->end_offset == query->curr_offset)
                  {
                    show_query_error(db, "Warning: end slot mismatch, possible bug");
                    query->curr_offset = (signed long int)0;
                  }

                  else
                  {
                    query->curr_offset = node->succ_offset;
                    query->curr_slot = (signed long int)0;
                  }
                }

            }
            if(query->arglist == ((struct anonymous_12 *)NULL))
              tmp_if_expr_6 = (_Bool)1;

            else
            {
              return_value_check_arglist_5=check_arglist(db, rec, query->arglist, query->argc);
              tmp_if_expr_6 = return_value_check_arglist_5 != 0l ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_6)
              return rec;

          }
        }

      if(query->qtype == 128l)
      {
        if(!(query->curr_page == NULL))
        {
          struct __query_result_page *currpage = (struct __query_result_page *)query->curr_page;
          signed long int offset;
          tmp_post_7 = query->curr_pidx;
          query->curr_pidx = query->curr_pidx + 1l;
          offset = currpage->rows[tmp_post_7];
          if(offset == 0l)
          {
            query->curr_page = (void *)0;
            return (void *)0;
          }

          else
            if(query->curr_pidx >= 63l)
            {
              query->curr_page = (void *)currpage->next;
              query->curr_pidx = (signed long int)0;
            }

          return (void *)((char *)((struct anonymous_6 *)db)->db + offset);
        }

        else
          return (void *)0;
      }

      else
      {
        show_query_error(db, "Unsupported query type");
        return (void *)0;
      }
    }
}

// wg_find_document
// file dbschema.h line 48
void * wg_find_document(void *db, void *rec)
{
  void *return_value_find_document_recursive_1;
  return_value_find_document_recursive_1=find_document_recursive(db, (signed long int *)rec, 7 - 1);
  return return_value_find_document_recursive_1;
}

// wg_find_record
// file dbquery.c line 2035
void * wg_find_record(void *db, signed long int fieldnr, signed long int cond, signed long int data, void *lastrecord)
{
  signed long int index_id = (signed long int)-1;
  if(!(cond == 2l))
    index_id=wg_multi_column_to_index_id(db, &fieldnr, (signed long int)1, (signed long int)50, (signed long int *)(void *)0, (signed long int)0);

  if(index_id >= 1l)
  {
    signed int start_inclusive = 1;
    signed int end_inclusive = 1;
    signed long int start_bound = (signed long int)0xff;
    signed long int end_bound = (signed long int)0xff;
    signed long int curr_offset = (signed long int)0;
    signed long int curr_slot = (signed long int)-1;
    signed long int end_offset = (signed long int)0;
    signed long int end_slot = (signed long int)-1;
    void *prev = (void *)0;
    switch(cond)
    {
      case (signed long int)0x0001:
      {
        end_bound = data;
        start_bound = end_bound;
        break;
      }
      case (signed long int)0x0004:
      {
        end_bound = data;
        end_inclusive = 0;
        break;
      }
      case (signed long int)0x0008:
      {
        start_bound = data;
        start_inclusive = 0;
        break;
      }
      case (signed long int)0x0010:
      {
        end_bound = data;
        break;
      }
      case (signed long int)0x0020:
      {
        start_bound = data;
        break;
      }
      default:
      {
        show_query_error(db, "Invalid condition (ignoring)");
        return (void *)0;
      }
    }
    signed long int return_value_find_ttree_bounds_1;
    return_value_find_ttree_bounds_1=find_ttree_bounds(db, index_id, fieldnr, start_bound, end_bound, (signed long int)start_inclusive, (signed long int)end_inclusive, &curr_offset, &curr_slot, &end_offset, &end_slot);
    if(!(return_value_find_ttree_bounds_1 == 0l))
      return (void *)0;

    while(!(curr_offset == 0l))
    {
      struct wg_tnode *node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + curr_offset);
      void *wg_find_record__1__2__3__rec = (void *)((char *)((struct anonymous_6 *)db)->db + node->array_of_values[curr_slot]);
      if(prev == lastrecord)
        return wg_find_record__1__2__3__rec;

      prev = wg_find_record__1__2__3__rec;
      if(curr_offset == end_offset && curr_slot == end_slot)
        break;

      else
      {
        curr_slot = curr_slot + (signed long int)1;
        if(curr_slot >= (signed long int)node->number_of_elements)
        {
          if(end_offset == curr_offset)
          {
            show_query_error(db, "Warning: end slot mismatch, possible bug");
            break;
          }

          else
          {
            curr_offset = node->succ_offset;
            curr_slot = (signed long int)0;
          }
        }

      }
    }
  }

  else
  {
    struct anonymous_12 arg;
    void *rec;
    if(!(lastrecord == NULL))
      rec=wg_get_next_record(db, lastrecord);

    else
      rec=wg_get_first_record(db);
    arg.column = fieldnr;
    arg.cond = cond;
    arg.value = data;
    while(!(rec == NULL))
    {
      signed long int return_value_check_arglist_2;
      return_value_check_arglist_2=check_arglist(db, rec, &arg, (signed long int)1);
      if(!(return_value_check_arglist_2 == 0l))
        return rec;

      rec=wg_get_next_record(db, rec);
    }
  }
  return (void *)0;
}

// wg_find_record_char
// file dbquery.c line 2169
void * wg_find_record_char(void *db, signed long int fieldnr, signed long int cond, char data, void *lastrecord)
{
  signed long int enc;
  enc=wg_encode_query_param_char(db, data);
  void *rec;
  rec=wg_find_record(db, fieldnr, cond, enc, lastrecord);
  return rec;
}

// wg_find_record_date
// file dbquery.c line 2189
void * wg_find_record_date(void *db, signed long int fieldnr, signed long int cond, signed int data, void *lastrecord)
{
  signed long int enc;
  enc=wg_encode_query_param_date(db, data);
  void *rec;
  rec=wg_find_record(db, fieldnr, cond, enc, lastrecord);
  return rec;
}

// wg_find_record_double
// file dbquery.c line 2230
void * wg_find_record_double(void *db, signed long int fieldnr, signed long int cond, double data, void *lastrecord)
{
  signed long int enc;
  enc=wg_encode_query_param_double(db, data);
  void *rec;
  rec=wg_find_record(db, fieldnr, cond, enc, lastrecord);
  wg_free_query_param(db, enc);
  return rec;
}

// wg_find_record_fixpoint
// file dbquery.c line 2179
void * wg_find_record_fixpoint(void *db, signed long int fieldnr, signed long int cond, double data, void *lastrecord)
{
  signed long int enc;
  enc=wg_encode_query_param_fixpoint(db, data);
  void *rec;
  rec=wg_find_record(db, fieldnr, cond, enc, lastrecord);
  return rec;
}

// wg_find_record_int
// file dbquery.c line 2219
void * wg_find_record_int(void *db, signed long int fieldnr, signed long int cond, signed int data, void *lastrecord)
{
  signed long int enc;
  enc=wg_encode_query_param_int(db, (signed long int)data);
  void *rec;
  rec=wg_find_record(db, fieldnr, cond, enc, lastrecord);
  wg_free_query_param(db, enc);
  return rec;
}

// wg_find_record_null
// file dbquery.c line 2149
void * wg_find_record_null(void *db, signed long int fieldnr, signed long int cond, char *data, void *lastrecord)
{
  signed long int enc;
  enc=wg_encode_query_param_null(db, data);
  void *rec;
  rec=wg_find_record(db, fieldnr, cond, enc, lastrecord);
  return rec;
}

// wg_find_record_record
// file dbquery.c line 2159
void * wg_find_record_record(void *db, signed long int fieldnr, signed long int cond, void *data, void *lastrecord)
{
  signed long int enc;
  enc=wg_encode_query_param_record(db, data);
  void *rec;
  rec=wg_find_record(db, fieldnr, cond, enc, lastrecord);
  return rec;
}

// wg_find_record_str
// file dbquery.c line 2241
void * wg_find_record_str(void *db, signed long int fieldnr, signed long int cond, char *data, void *lastrecord)
{
  signed long int enc;
  enc=wg_encode_query_param_str(db, data, (char *)(void *)0);
  void *rec;
  rec=wg_find_record(db, fieldnr, cond, enc, lastrecord);
  wg_free_query_param(db, enc);
  return rec;
}

// wg_find_record_time
// file dbquery.c line 2199
void * wg_find_record_time(void *db, signed long int fieldnr, signed long int cond, signed int data, void *lastrecord)
{
  signed long int enc;
  enc=wg_encode_query_param_time(db, data);
  void *rec;
  rec=wg_find_record(db, fieldnr, cond, enc, lastrecord);
  return rec;
}

// wg_find_record_uri
// file dbquery.c line 2263
void * wg_find_record_uri(void *db, signed long int fieldnr, signed long int cond, char *data, char *prefix, void *lastrecord)
{
  signed long int enc;
  enc=wg_encode_query_param_uri(db, data, prefix);
  void *rec;
  rec=wg_find_record(db, fieldnr, cond, enc, lastrecord);
  wg_free_query_param(db, enc);
  return rec;
}

// wg_find_record_var
// file dbquery.c line 2209
void * wg_find_record_var(void *db, signed long int fieldnr, signed long int cond, signed long int data, void *lastrecord)
{
  signed long int enc;
  enc=wg_encode_query_param_var(db, data);
  void *rec;
  rec=wg_find_record(db, fieldnr, cond, enc, lastrecord);
  return rec;
}

// wg_find_record_xmlliteral
// file dbquery.c line 2252
void * wg_find_record_xmlliteral(void *db, signed long int fieldnr, signed long int cond, char *data, char *xsdtype, void *lastrecord)
{
  signed long int enc;
  enc=wg_encode_query_param_xmlliteral(db, data, xsdtype);
  void *rec;
  rec=wg_find_record(db, fieldnr, cond, enc, lastrecord);
  wg_free_query_param(db, enc);
  return rec;
}

// wg_find_strhash_bucket
// file dbhash.h line 51
signed long int wg_find_strhash_bucket(void *db, char *data, char *extrastr, signed long int type, signed long int size, signed long int hashchain)
{
  for( ; !(hashchain == 0l); hashchain = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)(hashchain & (signed long int)~0x7) + (unsigned long int)4 * sizeof(signed long int) /*8ul*/ ))))
  {
    signed int return_value_wg_right_strhash_bucket_1;
    return_value_wg_right_strhash_bucket_1=wg_right_strhash_bucket(db, hashchain, data, extrastr, type, size);
    if(!(return_value_wg_right_strhash_bucket_1 == 0))
      return hashchain;

  }
  return (signed long int)0;
}

// wg_first
// file dbmpool.c line 318
void * wg_first(void *db, void *ptr)
{
  return (void *)*((signed long int *)ptr);
}

// wg_fprint_record_csv
// file dbutil.c line 641
void wg_fprint_record_csv(void *db, signed long int *rec, struct _IO_FILE *f)
{
  signed long int len;
  signed long int enc;
  signed int i;
  char *strbuf;
  if(rec == ((signed long int *)NULL))
    show_io_error(db, "null record pointer");

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)4096);
    strbuf = (char *)return_value_malloc_1;
    if(strbuf == ((char *)NULL))
      show_io_error(db, "Failed to allocate memory");

    else
    {
      len=wg_get_record_len(db, (void *)rec);
      i = 0;
      for( ; !((signed long int)i >= len); i = i + 1)
      {
        if(!(i == 0))
          fprintf(f, "%c", 44);

        enc=wg_get_field(db, (void *)rec, (signed long int)i);
        snprint_value_csv(db, enc, strbuf, 4096 - 1);
        fprintf(f, "%s", strbuf);
      }
      free((void *)strbuf);
    }
  }
}

// wg_free_doubleword
// file dballoc.c line 830
void wg_free_doubleword(void *db, signed long int offset)
{
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + offset)) = ((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->doubleword_area_header.freelist;
  ((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->doubleword_area_header.freelist = offset;
}

// wg_free_encoded
// file dbdata.c line 1178
signed long int wg_free_encoded(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_free_encoded");
    return (signed long int)0;
  }

  else
  {
    if(!((3l & data) == 3l) && !(data == 0l))
    {
      signed long int *strptr;
      if((7l & data) == 4l)
      {
        strptr = (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + (data & (signed long int)~0x7));
        strptr[(signed long int)2] = strptr[(signed long int)2] + 1l;
      }

      signed long int return_value_free_field_encoffset_2;
      return_value_free_field_encoffset_2=free_field_encoffset(db, data);
      return return_value_free_field_encoffset_2;
    }

    return (signed long int)0;
  }
}

// wg_free_fixlen_object
// file dballoc.c line 852
void wg_free_fixlen_object(void *db, struct _db_area_header *hdr, signed long int offset)
{
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + offset)) = hdr->freelist;
  hdr->freelist = offset;
}

// wg_free_listcell
// file dballoc.c line 794
void wg_free_listcell(void *db, signed long int offset)
{
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + offset)) = ((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->listcell_area_header.freelist;
  ((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->listcell_area_header.freelist = offset;
}

// wg_free_mpool
// file dbmpool.h line 48
void wg_free_mpool(void *db, void *mpool)
{
  signed int i;
  struct anonymous_8 *mpoolh = (struct anonymous_8 *)mpool;
  i = mpoolh->cur_subarea;
  for( ; i >= 1; i = i - 1)
    free(mpoolh->subarea_table[(signed long int)i].area_start);
  free(mpool);
}

// wg_free_object
// file dballoc.c line 1158
signed long int wg_free_object(void *db, void *area_header, signed long int object)
{
  signed long int size;
  signed long int i;
  signed long int *freebuckets;
  signed long int objecthead;
  signed long int prevobject;
  signed long int prevobjectsize;
  signed long int prevobjecthead;
  signed long int previndex;
  signed long int nextobject;
  signed long int nextobjecthead;
  signed long int nextindex;
  signed long int freelist;
  signed long int prevnextptr;
  signed long int prevprevptr;
  signed long int nextnextptr;
  signed long int nextprevptr;
  signed long int bucketfreelist;
  struct _db_area_header *areah;
  signed long int dv;
  signed long int dvsize;
  signed long int tmp;
  areah = (struct _db_area_header *)area_header;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
  {
    show_dballoc_error(db, "wg_free_object first arg is not a db address");
    return (signed long int)-1;
  }

  else
  {
    objecthead = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + object));
    if((3l & objecthead) == 1l)
    {
      show_dballoc_error(db, "wg_free_object second arg is already a free object");
      return (signed long int)-2;
    }

    else
    {
      size = (objecthead & (signed long int)~3) <= (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/  ? (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/  : ((objecthead & (signed long int)~3) % (signed long int)8 != 0l ? (objecthead & (signed long int)~3) + (signed long int)4 : objecthead & (signed long int)~3);
      if(!(size >= (signed long int)(sizeof(signed long int) * 4) /*32l*/ ))
      {
        show_dballoc_error(db, "wg_free_object second arg has a too small size");
        return (signed long int)-3;
      }

      else
      {
        freebuckets = areah->freebuckets;
        if((3l & objecthead) == 2l)
        {
          prevobjectsize = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)object - sizeof(signed long int) /*8ul*/ ))) & (signed long int)~3;
          prevobject = object - prevobjectsize;
          prevobjecthead = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + prevobject));
          if((signed long int)((-4l & prevobject) == 0l) == prevobjectsize || !((3l & prevobjecthead) == 1l))
          {
            show_dballoc_error(db, "wg_free_object notices corruption: previous object is not ok free object");
            return (signed long int)-4;
          }

          prevnextptr = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)prevobject + sizeof(signed long int) /*8ul*/ )));
          prevprevptr = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)prevobject + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ )));
          previndex=wg_freebuckets_index(db, prevobjectsize);
          freelist = freebuckets[previndex];
          if(freelist == prevobject)
          {
            freebuckets[previndex] = prevnextptr;
            if(!(prevnextptr == 0l))
              *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)prevnextptr + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = prevprevptr;

          }

          else
          {
            *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)prevprevptr + sizeof(signed long int) /*8ul*/ ))) = prevnextptr;
            if(!(prevnextptr == 0l))
              *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)prevnextptr + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = prevprevptr;

          }
          object = prevobject;
          size = size + prevobjectsize;
        }

        else
          if(freebuckets[288l] + freebuckets[289l] == object)
          {
            object = freebuckets[(signed long int)(256 + 32)];
            size = size + freebuckets[(signed long int)(256 + 32 + 1)];
            freebuckets[(signed long int)(256 + 32 + 1)] = size;
            *((signed long int *)((char *)((struct anonymous_6 *)db)->db + object)) = size | (signed long int)3;
            *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)object + sizeof(signed long int) /*8ul*/ ))) = (signed long int)1;
            return (signed long int)0;
          }

        nextobject = object + size;
        nextobjecthead = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + nextobject));
        if((3l & nextobjecthead) == 1l)
        {
          size = size + (nextobjecthead & (signed long int)~3);
          nextnextptr = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)nextobject + sizeof(signed long int) /*8ul*/ )));
          nextprevptr = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)nextobject + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ )));
          nextindex=wg_freebuckets_index(db, nextobjecthead & (signed long int)~3);
          freelist = freebuckets[nextindex];
          if(freelist == nextobject)
          {
            freebuckets[nextindex] = nextnextptr;
            if(!(nextnextptr == 0l))
              *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)nextnextptr + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = nextprevptr;

          }

          else
          {
            *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)nextprevptr + sizeof(signed long int) /*8ul*/ ))) = nextnextptr;
            if(!(nextnextptr == 0l))
              *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)nextnextptr + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = nextprevptr;

          }
        }

        else
        {
          if((3l & nextobjecthead) == 3l)
            tmp_if_expr_2 = nextobject == freebuckets[(signed long int)(256 + 32)] ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_2 = (_Bool)0;
          if(tmp_if_expr_2)
          {
            size = size + freebuckets[(signed long int)(256 + 32 + 1)];
            freebuckets[(signed long int)(256 + 32)] = object;
            freebuckets[(signed long int)(256 + 32 + 1)] = size;
            *((signed long int *)((char *)((struct anonymous_6 *)db)->db + object)) = size | (signed long int)3;
            *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)object + sizeof(signed long int) /*8ul*/ ))) = (signed long int)1;
            return (signed long int)0;
          }

          else
            if((1l & nextobjecthead) == 0l)
              *((signed long int *)((char *)((struct anonymous_6 *)db)->db + nextobject)) = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + nextobject)) & (signed long int)~3 | (signed long int)2;

        }
        if(!(freebuckets[289l] >= size))
        {
          dv = freebuckets[(signed long int)(256 + 32)];
          dvsize = freebuckets[(signed long int)(256 + 32 + 1)];
          freebuckets[(signed long int)(256 + 32)] = object;
          freebuckets[(signed long int)(256 + 32 + 1)] = size;
          *((signed long int *)((char *)((struct anonymous_6 *)db)->db + object)) = size | (signed long int)3;
          *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)object + sizeof(signed long int) /*8ul*/ ))) = (signed long int)1;
          nextobject = object + size;
          tmp = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + nextobject));
          if((1l & tmp) == 0l)
            *((signed long int *)((char *)((struct anonymous_6 *)db)->db + nextobject)) = tmp & (signed long int)~3;

          if(dv == 0l)
            return (signed long int)0;

          nextobject = dv + dvsize;
          tmp = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + nextobject));
          if((1l & tmp) == 0l)
            *((signed long int *)((char *)((struct anonymous_6 *)db)->db + nextobject)) = tmp & (signed long int)~3 | (signed long int)2;

          object = dv;
          size = dvsize;
        }

        i=wg_freebuckets_index(db, size);
        bucketfreelist = freebuckets[i];
        if(!(bucketfreelist == 0l))
          *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)bucketfreelist + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = object;

        *((signed long int *)((char *)((struct anonymous_6 *)db)->db + object)) = size & (signed long int)~3 | (signed long int)1;
        *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)(object + size) - sizeof(signed long int) /*8ul*/ ))) = size & (signed long int)~3 | (signed long int)1;
        *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)object + sizeof(signed long int) /*8ul*/ ))) = bucketfreelist;
        *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)object + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)((char *)&freebuckets[i] - (char *)((struct anonymous_6 *)db)->db);
        freebuckets[i] = object;
        return (signed long int)0;
      }
    }
  }
}

// wg_free_query
// file dbquery.c line 1108
void wg_free_query(void *db, struct anonymous_15 *query)
{
  if(!(query->arglist == ((struct anonymous_12 *)NULL)))
    free((void *)query->arglist);

  if(query->qtype == 128l)
  {
    if(!(query->mpool == NULL))
      wg_free_mpool(db, query->mpool);

  }

  free((void *)query);
}

// wg_free_query_param
// file dbquery.c line 1294
signed long int wg_free_query_param(void *db, signed long int data)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_query_error(db, "wrong database pointer given to wg_free_query_param");
    return (signed long int)0;
  }

  else
  {
    if(!((3l & data) == 3l) && !(data == 0l))
    {
      signed long int offset;
      switch(data & (signed long int)0x7)
      {
        case (signed long int)0x0:
          break;
        case (signed long int)0x6:
        {
          offset = data & (signed long int)~0x7;
          free((void *)((char *)((struct anonymous_6 *)db)->db + offset));
          break;
        }
        case (signed long int)0x4:
        {
          offset = data & (signed long int)~0x7;
          free((void *)((char *)((struct anonymous_6 *)db)->db + offset));
          break;
        }
        case (signed long int)0x2:
        {
          offset = data & (signed long int)~0x7;
          free((void *)((char *)((struct anonymous_6 *)db)->db + offset));
          break;
        }
        case (signed long int)0x1:

        case (signed long int)0x5:
        {
          offset = data & (signed long int)~0x3;
          free((void *)((char *)((struct anonymous_6 *)db)->db + offset));
          break;
        }
        default:
          show_query_error(db, "Bad encoded value given to wg_free_query_param");
      }
    }

    return (signed long int)0;
  }
}

// wg_free_shortstr
// file dballoc.c line 806
void wg_free_shortstr(void *db, signed long int offset)
{
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + offset)) = ((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->shortstr_area_header.freelist;
  ((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->shortstr_area_header.freelist = offset;
}

// wg_free_tnode
// file dballoc.c line 841
void wg_free_tnode(void *db, signed long int offset)
{
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + offset)) = ((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->tnode_area_header.freelist;
  ((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->tnode_area_header.freelist = offset;
}

// wg_free_word
// file dballoc.c line 817
void wg_free_word(void *db, signed long int offset)
{
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + offset)) = ((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->word_area_header.freelist;
  ((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->word_area_header.freelist = offset;
}

// wg_freebuckets_index
// file dballoc.c line 1138
signed long int wg_freebuckets_index(void *db, signed long int size)
{
  signed long int i;
  signed long int cursize;
  if(!(size >= 256l))
    return size;

  else
  {
    cursize = (signed long int)(256 * 2);
    i = (signed long int)0;
    for( ; !(i >= 32l); i = i + 1l)
    {
      if(!(size >= cursize))
        return (signed long int)256 + i;

      cursize = cursize * (signed long int)2;
    }
    return (signed long int)-1;
  }
}

// wg_get_all_indexes
// file dbindex.c line 2577
void * wg_get_all_indexes(void *db, signed long int *count)
{
  signed int column;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int *ilist;
  signed long int *res;
  *count = (signed long int)0;
  signed long int tmp_post_2;
  if(dbh->index_control_area_header.number_of_indexes == 0l)
    return (void *)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)dbh->index_control_area_header.number_of_indexes * sizeof(signed long int) /*8ul*/ );
    res = (signed long int *)return_value_malloc_1;
    if(res == ((signed long int *)NULL))
    {
      show_index_error(db, "Memory allocation failed");
      return (void *)0;
    }

    else
    {
      column = 0;
      for( ; !(column >= 128); column = column + 1)
      {
        ilist = &dbh->index_control_area_header.index_table[(signed long int)column];
        while(!(*ilist == 0l))
        {
          struct anonymous_20 *ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
          if(!(ilistelem->car == 0l))
          {
            tmp_post_2 = *count;
            *count = *count + 1l;
            res[tmp_post_2] = ilistelem->car;
          }

          ilist = &ilistelem->cdr;
        }
      }
      if(!(*count == dbh->index_control_area_header.number_of_indexes))
      {
        show_index_error(db, "Index control area is corrupted");
        free((void *)res);
        return (void *)0;
      }

      else
        return (void *)res;
    }
  }
}

// wg_get_encoded_type
// file dbdata.h line 124
signed long int wg_get_encoded_type(void *db, signed long int data)
{
  signed long int fieldoffset;
  signed long int tmp;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_get_encoded_type");
    return (signed long int)0;
  }

  else
    if(data == 0l)
      return (signed long int)1;

    else
      if((3l & data) == 3l)
      {
        if((15l & data) == 7l)
          return (signed long int)14;

        if((7l & data) == 3l)
          return (signed long int)3;

        switch(data & (signed long int)0xff)
        {
          case (signed long int)0x1f:
            return (signed long int)9;
          case (signed long int)0xf:
            return (signed long int)10;
          case (signed long int)0x2f:
            return (signed long int)11;
          case (signed long int)0x3f:
            return (signed long int)12;
          case (signed long int)0x4f:
            return (signed long int)5;
          case (signed long int)0x7:
            return (signed long int)14;
          case (signed long int)0x5f:
            return (signed long int)13;
          default:
            return (signed long int)-1;
        }
      }

      else
      {
        switch(data & (signed long int)0x7)
        {
          case (signed long int)0x0:
            return (signed long int)2;
          case (signed long int)0x4:
          {
            fieldoffset = (signed long int)((unsigned long int)(data & (signed long int)~0x7) + (unsigned long int)1 * sizeof(signed long int) /*8ul*/ );
            tmp = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + fieldoffset));
            return tmp & (signed long int)0xFF;
          }
          case (signed long int)0x6:
            return (signed long int)5;
          case (signed long int)0x2:
            return (signed long int)4;
          case (signed long int)0x1:
            return (signed long int)3;
          case (signed long int)0x5:
            return (signed long int)3;
          default:
            return (signed long int)-1;
        }
        return (signed long int)0;
      }
}

// wg_get_field
// file ../Db/dbdata.h line 118
signed long int wg_get_field(void *db, void *record, signed long int fieldnr)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
  {
    show_data_error_nr(db, "wrong database pointer given to wg_get_field", fieldnr);
    return (signed long int)0xff;
  }

  else
  {
    if(!(fieldnr >= 0l))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (*((signed long int *)record) & (signed long int)~3) >> (sizeof(signed long int) /*8ul*/  == (unsigned long int)4 ? 2 : 3) <= fieldnr + (signed long int)3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      show_data_error_nr(db, "wrong field number given to wg_get_field", fieldnr);
      return (signed long int)0xff;
    }

    else
      return ((signed long int *)record + (signed long int)3)[fieldnr];
  }
}

// wg_get_field_type
// file ../Db/dbdata.h line 119
signed long int wg_get_field_type(void *db, void *record, signed long int fieldnr)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
  {
    show_data_error_nr(db, "wrong database pointer given to wg_get_field_type", fieldnr);
    return (signed long int)0;
  }

  else
  {
    if(!(fieldnr >= 0l))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (*((signed long int *)record) & (signed long int)~3) >> (sizeof(signed long int) /*8ul*/  == (unsigned long int)4 ? 2 : 3) <= fieldnr + (signed long int)3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      show_data_error_nr(db, "wrong field number given to wg_get_field_type", fieldnr);
      return (signed long int)0;
    }

    else
    {
      signed long int return_value_wg_get_encoded_type_3;
      return_value_wg_get_encoded_type_3=wg_get_encoded_type(db, ((signed long int *)record + (signed long int)3)[fieldnr]);
      return return_value_wg_get_encoded_type_3;
    }
  }
}

// wg_get_first_parent
// file dbdata.c line 414
void * wg_get_first_parent(void *db, void *record)
{
  signed long int backlink_list;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "invalid database pointer given to wg_get_first_parent");
    return (void *)0;
  }

  else
  {
    backlink_list = ((signed long int *)record)[(signed long int)2];
    if(!(backlink_list == 0l))
    {
      struct anonymous_20 *cell = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + backlink_list);
      return (void *)((char *)((struct anonymous_6 *)db)->db + cell->car);
    }

    return (void *)0;
  }
}

// wg_get_first_raw_record
// file dbdata.c line 314
void * wg_get_first_raw_record(void *db)
{
  struct _db_subarea_header *arrayadr;
  signed long int firstoffset;
  void *res;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_get_first_record");
    return (void *)0;
  }

  else
  {
    arrayadr = &((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->datarec_area_header.subarea_array[(signed long int)0];
    firstoffset = (arrayadr + (signed long int)0)->alignedoffset;
    res=wg_get_next_raw_record(db, (void *)((char *)((struct anonymous_6 *)db)->db + firstoffset));
    return res;
  }
}

// wg_get_first_record
// file ../Db/dbdata.h line 92
void * wg_get_first_record(void *db)
{
  void *res;
  res=wg_get_first_raw_record(db);
  void *return_value_wg_get_next_record_1;
  if(!(res == NULL))
  {
    if((1l & ((signed long int *)res)[1l]) == 0l)
      goto __CPROVER_DUMP_L1;

    return_value_wg_get_next_record_1=wg_get_next_record(db, res);
    return return_value_wg_get_next_record_1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return res;
  }
}

// wg_get_index_template
// file dbindex.c line 2524
void * wg_get_index_template(void *db, signed long int index_id, signed long int *reclen)
{
  struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)0;
  signed long int *ilist;
  struct anonymous_20 *ilistelem;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  struct anonymous_22 *tmpl = (struct anonymous_22 *)(void *)0;
  void *matchrec;
  ilist = &dbh->index_control_area_header.index_list;
  for( ; !(*ilist == 0l); ilist = &ilistelem->cdr)
  {
    ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
    if(ilistelem->car == index_id)
    {
      hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + index_id);
      break;
    }

  }
  if(hdr == ((struct anonymous_21 *)NULL))
  {
    show_index_error_nr(db, "Invalid index_id", index_id);
    return (void *)0;
  }

  else
    if(hdr->template_offset == 0l)
      return (void *)0;

    else
    {
      tmpl = (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + hdr->template_offset);
      if(tmpl->offset_matchrec == 0l)
      {
        show_index_error(db, "Invalid match record template");
        return (void *)0;
      }

      else
      {
        matchrec = (void *)((char *)((struct anonymous_6 *)db)->db + tmpl->offset_matchrec);
        *reclen=wg_get_record_len(db, matchrec);
        signed long int *return_value_wg_get_record_dataarray_1;
        return_value_wg_get_record_dataarray_1=wg_get_record_dataarray(db, matchrec);
        return (void *)return_value_wg_get_record_dataarray_1;
      }
    }
}

// wg_get_index_type
// file dbindex.c line 2490
signed long int wg_get_index_type(void *db, signed long int index_id)
{
  struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)0;
  signed long int *ilist;
  struct anonymous_20 *ilistelem;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  ilist = &dbh->index_control_area_header.index_list;
  for( ; !(*ilist == 0l); ilist = &ilistelem->cdr)
  {
    ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
    if(ilistelem->car == index_id)
    {
      hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + index_id);
      break;
    }

  }
  if(hdr == ((struct anonymous_21 *)NULL))
  {
    show_index_error_nr(db, "Invalid index_id", index_id);
    return (signed long int)-1;
  }

  else
    return hdr->type;
}

// wg_get_next_parent
// file dbdata.c line 435
void * wg_get_next_parent(void *db, void *record, void *parent)
{
  signed long int backlink_list;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "invalid database pointer given to wg_get_next_parent");
    return (void *)0;
  }

  else
  {
    backlink_list = ((signed long int *)record)[(signed long int)2];
    if(!(backlink_list == 0l))
    {
      struct anonymous_20 *next = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + backlink_list);
      while(!(next->cdr == 0l))
      {
        void *pp = (void *)((char *)((struct anonymous_6 *)db)->db + next->car);
        next = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + next->cdr);
        if(pp == parent)
        {
          if(!(next->car == 0l))
            return (void *)((char *)((struct anonymous_6 *)db)->db + next->car);

        }

      }
    }

    return (void *)0;
  }
}

// wg_get_next_raw_record
// file dbdata.c line 335
void * wg_get_next_raw_record(void *db, void *record)
{
  signed long int curoffset;
  signed long int head;
  struct _db_subarea_header *arrayadr;
  signed long int last_subarea_index;
  signed long int i;
  signed long int found;
  signed long int subareastart;
  signed long int subareaend;
  signed long int freemarker;
  curoffset = (signed long int)((char *)record - (char *)((struct anonymous_6 *)db)->db);
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_get_first_record");
    return (void *)0;
  }

  else
  {
    head = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + curoffset));
    if((3l & head) == 1l)
    {
      show_data_error(db, "wrong record pointer (free) given to wg_get_next_record");
      return (void *)0;
    }

    else
    {
      freemarker = (signed long int)0;
      head = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + curoffset));
      while((_Bool)1)
      {
        curoffset = curoffset + (freemarker != 0l ? head & (signed long int)~3 : ((head & (signed long int)~3) <= (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/  ? (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/  : ((head & (signed long int)~3) % (signed long int)8 != 0l ? (head & (signed long int)~3) + (signed long int)4 : head & (signed long int)~3)));
        head = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + curoffset));
        if((1l & head) == 0l)
          return (void *)((char *)((struct anonymous_6 *)db)->db + curoffset);

        if((3l & head) == 1l)
          freemarker = (signed long int)1;

        else
        {
          freemarker = (signed long int)0;
          if(*((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)sizeof(signed long int) /*8l*/  + (signed long int)(unsigned long int)curoffset)) == 1l)
            continue;

          else
          {
            arrayadr = &((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->datarec_area_header.subarea_array[(signed long int)0];
            last_subarea_index = ((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->datarec_area_header.last_subarea_index;
            found = (signed long int)0;
            i = (signed long int)0;
            for( ; last_subarea_index >= i && !(i >= 64l); i = i + 1l)
            {
              subareastart = (arrayadr + i)->alignedoffset;
              subareaend = (arrayadr + i)->offset + (arrayadr + i)->size;
              if(curoffset >= subareastart && !(curoffset >= subareaend))
              {
                found = (signed long int)1;
                break;
              }

            }
            if(found == 0l)
            {
              show_data_error(db, "wrong record pointer (out of area) given to wg_get_next_record");
              return (void *)0;
            }

            i = i + 1l;
            if(i >= 64l || !(last_subarea_index >= i))
              return (void *)0;

            curoffset = (arrayadr + i)->alignedoffset;
            head = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + curoffset));
          }
        }
      }
    }
  }
}

// wg_get_next_record
// file ../Db/dbdata.h line 93
void * wg_get_next_record(void *db, void *record)
{
  void *res = record;
  _Bool tmp_if_expr_1;
  do
  {
    res=wg_get_next_raw_record(db, res);
    if(!(res == NULL))
      tmp_if_expr_1 = (((signed long int *)res)[(signed long int)1] & (signed long int)0x1) != 0l ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
  }
  while(tmp_if_expr_1);
  return res;
}

// wg_get_rec_owner
// file dbdata.c line 3068
void * wg_get_rec_owner(void *db, void *rec)
{
  signed int i;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  if(!((signed long int)(unsigned long int)((struct anonymous_6 *)db)->db >= (signed long int)rec))
  {
    void *wg_get_rec_owner__1__1__eodb = (void *)((char *)((struct anonymous_6 *)db)->db + dbh->size);
    if(!((signed long int)rec >= (signed long int)wg_get_rec_owner__1__1__eodb))
      return (void *)((struct anonymous_6 *)db)->db;

  }

  i = 0;
  for( ; !((signed long int)i >= dbh->extdbs.count); i = i + 1)
  {
    void *base = (void *)((char *)((struct anonymous_6 *)db)->db + dbh->extdbs.offset[(signed long int)i]);
    void *eodb = (void *)((char *)base + dbh->extdbs.size[(signed long int)i]);
    if(!((signed long int)base >= (signed long int)rec) && !((signed long int)rec >= (signed long int)eodb))
      return base;

  }
  show_data_error(db, "invalid pointer in wg_get_rec_base_offset");
  return (void *)0;
}

// wg_get_record_dataarray
// file dbdata.c line 590
signed long int * wg_get_record_dataarray(void *db, void *record)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_get_record_dataarray");
    return (signed long int *)(void *)0;
  }

  else
    return (signed long int *)record + (signed long int)3;
}

// wg_get_record_len
// file ../Db/dbdata.h line 103
signed long int wg_get_record_len(void *db, void *record)
{
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    show_data_error(db, "wrong database pointer given to wg_get_record_len");
    return (signed long int)-1;
  }

  else
    return (signed long int)((*((signed long int *)record) & (signed long int)~3) >> (sizeof(signed long int) /*8ul*/  == (unsigned long int)4 ? 2 : 3)) - (signed long int)3;
}

// wg_get_type_name
// file dbdata.c line 1400
char * wg_get_type_name(void *db, signed long int type)
{
  switch(type)
  {
    case (signed long int)1:
      return "null";
    case (signed long int)2:
      return "record";
    case (signed long int)3:
      return "int";
    case (signed long int)4:
      return "double";
    case (signed long int)5:
      return "string";
    case (signed long int)6:
      return "xmlliteral";
    case (signed long int)7:
      return "uri";
    case (signed long int)8:
      return "blob";
    case (signed long int)9:
      return "char";
    case (signed long int)10:
      return "fixpoint";
    case (signed long int)11:
      return "date";
    case (signed long int)12:
      return "time";
    case (signed long int)13:
      return "anonconstant";
    case (signed long int)14:
      return "var";
    default:
      return "unknown";
  }
}

// wg_ginthash_addkey
// file dbhash.c line 600
signed long int wg_ginthash_addkey(void *db, void *tbl, signed long int key, signed long int val)
{
  unsigned long int dirsize = (unsigned long int)(1 << ((struct anonymous_35 *)tbl)->level);
  unsigned long int hash;
  signed long int return_value_rehash_gint_1;
  return_value_rehash_gint_1=rehash_gint(key);
  hash = (unsigned long int)return_value_rehash_gint_1 & dirsize - (unsigned long int)1;
  struct anonymous_34 *bucket = ((struct anonymous_35 *)tbl)->directory[(signed long int)hash];
  if(bucket == ((struct anonymous_34 *)NULL))
  {
    bucket=ginthash_newbucket(db, (struct anonymous_35 *)tbl);
    if(bucket == ((struct anonymous_34 *)NULL))
      return (signed long int)-1;

    bucket->level = ((struct anonymous_35 *)tbl)->level;
    add_to_bucket(bucket, key, val);
    ((struct anonymous_35 *)tbl)->directory[(signed long int)hash] = bucket;
  }

  else
  {
    add_to_bucket(bucket, key, val);
    while(bucket->fill >= 8l)
    {
      struct anonymous_34 *newb;
      newb=ginthash_splitbucket(db, (struct anonymous_35 *)tbl, bucket);
      if(newb == ((struct anonymous_34 *)NULL))
        return (signed long int)-1;

      if(newb->fill >= 8l)
        bucket = newb;

    }
  }
  return (signed long int)0;
}

// wg_ginthash_free
// file dbhash.c line 655
void wg_ginthash_free(void *db, void *tbl)
{
  if(!(tbl == NULL))
  {
    if(!(((struct anonymous_35 *)tbl)->directory == ((struct anonymous_34 **)NULL)))
      free((void *)((struct anonymous_35 *)tbl)->directory);

    if(!(((struct anonymous_35 *)tbl)->mpool == NULL))
      wg_free_mpool(db, ((struct anonymous_35 *)tbl)->mpool);

    free(tbl);
  }

}

// wg_ginthash_getkey
// file dbhash.c line 636
signed long int wg_ginthash_getkey(void *db, void *tbl, signed long int key, signed long int *val)
{
  unsigned long int dirsize = (unsigned long int)(1 << ((struct anonymous_35 *)tbl)->level);
  unsigned long int hash;
  signed long int return_value_rehash_gint_1;
  return_value_rehash_gint_1=rehash_gint(key);
  hash = (unsigned long int)return_value_rehash_gint_1 & dirsize - (unsigned long int)1;
  struct anonymous_34 *bucket = ((struct anonymous_35 *)tbl)->directory[(signed long int)hash];
  if(!(bucket == ((struct anonymous_34 *)NULL)))
  {
    signed int i = 0;
    for( ; !((signed long int)i >= bucket->fill); i = i + 1)
      if(bucket->key[(signed long int)i] == key)
      {
        *val = bucket->value[(signed long int)i];
        return (signed long int)0;
      }

  }

  return (signed long int)-1;
}

// wg_ginthash_init
// file dbhash.c line 580
void * wg_ginthash_init(void *db)
{
  struct anonymous_35 *tbl;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_35) /*24ul*/ );
  tbl = (struct anonymous_35 *)return_value_malloc_1;
  if(tbl == ((struct anonymous_35 *)NULL))
  {
    show_ginthash_error(db, "Failed to allocate table.");
    return (void *)0;
  }

  else
  {
    memset((void *)tbl, 0, sizeof(struct anonymous_35) /*24ul*/ );
    signed long int return_value_grow_ginthash_2;
    return_value_grow_ginthash_2=grow_ginthash(db, tbl);
    if(!(return_value_grow_ginthash_2 == 0l))
    {
      free((void *)tbl);
      return (void *)0;
    }

    else
      return (void *)tbl;
  }
}

// wg_hash_typedstr
// file dbhash.h line 50
signed int wg_hash_typedstr(void *db, char *data, char *extrastr, signed long int type, signed long int length)
{
  char *endp;
  unsigned long int hash = (unsigned long int)0;
  signed int c;
  if(!(data == ((char *)NULL)))
  {
    endp = data + length;
    for( ; !(data >= endp); data = data + 1l)
    {
      c = (signed int)*data;
      hash = ((unsigned long int)c + (hash << 6) + (hash << 16)) - hash;
    }
  }

  char *tmp_post_1;
  if(!(extrastr == ((char *)NULL)))
    do
    {
      tmp_post_1 = extrastr;
      extrastr = extrastr + 1l;
      c = (signed int)*tmp_post_1;
      if(c == 0)
        break;

      hash = ((unsigned long int)c + (hash << 6) + (hash << 16)) - hash;
    }
    while((_Bool)1);

  return (signed int)(hash % (unsigned long int)((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->strhash_area_header.arraylength);
}

// wg_hms_to_time
// file dbdata.c line 1808
signed int wg_hms_to_time(void *db, signed int hr, signed int min, signed int sec, signed int prt)
{
  if(hr >= 25 || min >= 61 || prt >= 100 || sec >= 61 || !(hr >= 0) || !(min >= 0) || !(prt >= 0) || !(sec >= 0))
    return -1;

  else
    return hr * 60 * 60 * 100 + min * 60 * 100 + sec * 100 + prt;
}

// wg_idxhash_find
// file dbhash.c line 548
signed long int wg_idxhash_find(void *db, struct _db_hash_area_header *ha, char *data, signed long int length)
{
  unsigned long int hash;
  signed long int head_offset;
  signed long int bucket;
  hash=hash_bytes(db, data, length, ha->arraylength);
  head_offset = (signed long int)((unsigned long int)ha->arraystart + sizeof(signed long int) /*8ul*/  * hash);
  bucket=find_idxhash_bucket(db, data, length, &head_offset);
  if(bucket == 0l)
    return (signed long int)0;

  else
    return *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)bucket + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ )));
}

// wg_idxhash_remove
// file dbhash.c line 501
signed long int wg_idxhash_remove(void *db, struct _db_hash_area_header *ha, char *data, signed long int length, signed long int offset)
{
  unsigned long int hash;
  signed long int bucket_offset;
  signed long int bucket;
  signed long int *next_offset;
  signed long int *reclist_offset;
  hash=hash_bytes(db, data, length, ha->arraylength);
  bucket_offset = (signed long int)((unsigned long int)ha->arraystart + sizeof(signed long int) /*8ul*/  * hash);
  bucket=find_idxhash_bucket(db, data, length, &bucket_offset);
  if(bucket == 0l)
  {
    signed long int return_value_show_hash_error_1;
    return_value_show_hash_error_1=show_hash_error(db, "wg_idxhash_remove: Hash value not found.");
    return return_value_show_hash_error_1;
  }

  reclist_offset = (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)bucket + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ));
  next_offset = reclist_offset;
  while(!(*next_offset == 0l))
  {
    struct anonymous_20 *rec_cell = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *next_offset);
    if(rec_cell->car == offset)
    {
      signed long int rec_offset = *next_offset;
      *next_offset = rec_cell->cdr;
      wg_free_listcell(db, rec_offset);
      goto is_bucket_empty;
    }

    next_offset = &rec_cell->cdr;
  }
  signed long int return_value_show_hash_error_2;
  return_value_show_hash_error_2=show_hash_error(db, "wg_idxhash_remove: Offset not found");
  return return_value_show_hash_error_2;

is_bucket_empty:
  ;
  if(*reclist_offset == 0l)
  {
    signed long int nextchain = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)bucket + (unsigned long int)3 * sizeof(signed long int) /*8ul*/ )));
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + bucket_offset)) = nextchain;
    wg_free_object(db, (void *)&((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->indexhash_area_header, bucket);
  }

  return (signed long int)0;
}

// wg_idxhash_store
// file dbhash.c line 433
signed long int wg_idxhash_store(void *db, struct _db_hash_area_header *ha, char *data, signed long int length, signed long int offset)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  unsigned long int hash;
  signed long int head_offset;
  signed long int head;
  signed long int bucket;
  signed long int rec_head;
  signed long int rec_offset;
  struct anonymous_20 *rec_cell;
  hash=hash_bytes(db, data, length, ha->arraylength);
  head_offset = (signed long int)((unsigned long int)ha->arraystart + sizeof(signed long int) /*8ul*/  * hash);
  head = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + head_offset));
  bucket=find_idxhash_bucket(db, data, length, &head_offset);
  if(bucket == 0l)
  {
    unsigned long int i;
    signed long int lengints;
    signed long int lenrest;
    char *dptr;
    lengints = (signed long int)((unsigned long int)length / sizeof(signed long int) /*8ul*/ );
    lenrest = (signed long int)((unsigned long int)length % sizeof(signed long int) /*8ul*/ );
    if(!(lenrest == 0l))
      lengints = lengints + 1l;

    bucket=wg_alloc_gints(db, (void *)&dbh->indexhash_area_header, lengints + (signed long int)4);
    if(bucket == 0l)
      return (signed long int)-1;

    dptr = (char *)(void *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)bucket + (unsigned long int)4 * sizeof(signed long int) /*8ul*/ ));
    memcpy((void *)dptr, (const void *)data, (unsigned long int)length);
    i = (unsigned long int)0;
    for( ; !(lenrest == 0l) && !(i >= sizeof(signed long int) /*8ul*/  + -((unsigned long int)lenrest)); i = i + 1ul)
      (dptr + length)[(signed long int)i] = (char)0;
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)bucket + (unsigned long int)1 * sizeof(signed long int) /*8ul*/ ))) = length;
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)bucket + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = (signed long int)0;
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)ha->arraystart + sizeof(signed long int) /*8ul*/  * hash))) = bucket;
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)bucket + (unsigned long int)3 * sizeof(signed long int) /*8ul*/ ))) = head;
  }

  rec_head = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)bucket + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ )));
  rec_offset=wg_alloc_fixlen_object(db, (void *)&dbh->listcell_area_header);
  rec_cell = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + rec_offset);
  rec_cell->car = offset;
  rec_cell->cdr = rec_head;
  *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)bucket + (unsigned long int)2 * sizeof(signed long int) /*8ul*/ ))) = rec_offset;
  return (signed long int)0;
}

// wg_import_db_csv
// file dbutil.c line 901
signed long int wg_import_db_csv(void *db, char *filename)
{
  struct _IO_FILE *f;
  signed long int err = (signed long int)0;
  f=fopen(filename, "r");
  if(f == ((struct _IO_FILE *)NULL))
  {
    show_io_error_str(db, "failed to open file", filename);
    return (signed long int)-1;
  }

  else
  {
    err=fread_csv(db, f);
    fclose(f);
    return err;
  }
}

// wg_import_dump
// file dbdump.c line 278
signed long int wg_import_dump(void *db, char *fileName)
{
  struct _db_memsegment_header *dumph;
  struct _IO_FILE *f;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int dbsize = (signed long int)-1;
  signed long int newsize;
  signed long int err = (signed long int)-1;
  f=fopen(fileName, "rb");
  unsigned long int return_value_fread_2;
  if(f == ((struct _IO_FILE *)NULL))
  {
    show_dump_error(db, "Error opening file");
    return (signed long int)-1;
  }

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct _db_memsegment_header) /*46568ul*/ );
    dumph = (struct _db_memsegment_header *)return_value_malloc_1;
    if(dumph == ((struct _db_memsegment_header *)NULL))
      show_dump_error(db, "malloc error in wg_import_dump");

    else
    {
      return_value_fread_2=fread((void *)dumph, sizeof(struct _db_memsegment_header) /*46568ul*/ , (unsigned long int)1, f);
      if(!(return_value_fread_2 == 1ul))
        show_dump_error(db, "Error reading dump header");

      else
      {
        dbsize = dumph->free;
        if(!(dumph->extdbs.count == 0l))
        {
          show_dump_error(db, "Dump contains external references");
          goto abort;
        }

      }
    }
    if(!(dumph == ((struct _db_memsegment_header *)NULL)))
      free((void *)dumph);

    if(!(dbh->size >= dbsize))
      show_dump_error(db, "Data does not fit in shared memory area");

    else
      if(dbsize >= 1l)
      {
        newsize = dbh->size;
        fseek(f, (signed long int)0, 0);
        unsigned long int return_value_fread_3;
        return_value_fread_3=fread((void *)((struct anonymous_6 *)db)->db, (unsigned long int)dbsize, (unsigned long int)1, f);
        if(!(return_value_fread_3 == 1ul))
        {
          show_dump_error(db, "Error reading dump file");
          err = (signed long int)-2;
        }

        else
        {
          err = (signed long int)0;
          dbh->size = newsize;
          dbh->checksum = 0;
        }
      }


  abort:
    ;
    fclose(f);
    if(!(err == 0l))
      return err;

    else
    {
      signed long int return_value_wg_init_locks_4;
      return_value_wg_init_locks_4=wg_init_locks(db);
      return return_value_wg_init_locks_4;
    }
  }
}

// wg_index_add_field
// file dbindex.h line 145
signed long int wg_index_add_field(void *db, void *rec, signed long int column)
{
  signed long int *ilist;
  struct anonymous_20 *ilistelem;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int reclen;
  reclen=wg_get_record_len(db, rec);
  signed long int tmp_if_expr_6;
  signed long int return_value_wg_match_template_5;
  signed long int return_value_ttree_add_row_1;
  signed long int return_value_hash_add_row_3;
  signed long int tmp_if_expr_12;
  signed long int return_value_wg_match_template_11;
  signed long int return_value_ttree_add_row_7;
  signed long int return_value_hash_add_row_9;
  if(column >= 128l || column >= reclen)
    return (signed long int)-1;

  else
    if(!((1l & ((signed long int *)rec)[1l]) == 0l))
      return (signed long int)-1;

    else
    {
      ilist = &dbh->index_control_area_header.index_table[column];
      for( ; !(*ilist == 0l); ilist = &ilistelem->cdr)
      {
        ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
        if(!(ilistelem->car == 0l))
        {
          struct anonymous_21 *wg_index_add_field__1__1__1__hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + ilistelem->car);
          if(!(wg_index_add_field__1__1__1__hdr->rec_field_index[wg_index_add_field__1__1__1__hdr->fields + -1l] >= reclen))
          {
            if(!(wg_index_add_field__1__1__1__hdr->template_offset == 0l))
            {
              return_value_wg_match_template_5=wg_match_template(db, (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + wg_index_add_field__1__1__1__hdr->template_offset), rec);
              tmp_if_expr_6 = return_value_wg_match_template_5;
            }

            else
              tmp_if_expr_6 = (signed long int)1;
            if(!(tmp_if_expr_6 == 0l))
              switch(wg_index_add_field__1__1__1__hdr->type)
              {
                case (signed long int)50:
                {
                  return_value_ttree_add_row_1=ttree_add_row(db, ilistelem->car, rec);
                  if(!(return_value_ttree_add_row_1 == 0l))
                    return (signed long int)-2;

                  break;
                }
                case (signed long int)51:
                {
                  if(((signed long int *)rec)[1l] == 0l)
                  {
                    signed long int return_value_ttree_add_row_2;
                    return_value_ttree_add_row_2=ttree_add_row(db, ilistelem->car, rec);
                    if(!(return_value_ttree_add_row_2 == 0l))
                      return (signed long int)-2;

                  }

                  break;
                }
                case (signed long int)60:
                {
                  return_value_hash_add_row_3=hash_add_row(db, ilistelem->car, rec);
                  if(!(return_value_hash_add_row_3 == 0l))
                    return (signed long int)-2;

                  break;
                }
                case (signed long int)61:
                {
                  if(((signed long int *)rec)[1l] == 0l)
                  {
                    signed long int return_value_hash_add_row_4;
                    return_value_hash_add_row_4=hash_add_row(db, ilistelem->car, rec);
                    if(!(return_value_hash_add_row_4 == 0l))
                      return (signed long int)-2;

                  }

                  break;
                }
                default:
                  show_index_error(db, "unknown index type, ignoring");
              }

          }

        }

      }
      ilist = &dbh->index_control_area_header.index_template_table[column];
      for( ; !(*ilist == 0l); ilist = &ilistelem->cdr)
      {
        ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
        if(!(ilistelem->car == 0l))
        {
          struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + ilistelem->car);
          if(!(hdr->rec_field_index[hdr->fields + -1l] >= reclen))
          {
            if(!(hdr->template_offset == 0l))
            {
              return_value_wg_match_template_11=wg_match_template(db, (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + hdr->template_offset), rec);
              tmp_if_expr_12 = return_value_wg_match_template_11;
            }

            else
              tmp_if_expr_12 = (signed long int)1;
            if(!(tmp_if_expr_12 == 0l))
              switch(hdr->type)
              {
                case (signed long int)50:
                {
                  return_value_ttree_add_row_7=ttree_add_row(db, ilistelem->car, rec);
                  if(!(return_value_ttree_add_row_7 == 0l))
                    return (signed long int)-2;

                  break;
                }
                case (signed long int)51:
                {
                  if(((signed long int *)rec)[1l] == 0l)
                  {
                    signed long int return_value_ttree_add_row_8;
                    return_value_ttree_add_row_8=ttree_add_row(db, ilistelem->car, rec);
                    if(!(return_value_ttree_add_row_8 == 0l))
                      return (signed long int)-2;

                  }

                  break;
                }
                case (signed long int)60:
                {
                  return_value_hash_add_row_9=hash_add_row(db, ilistelem->car, rec);
                  if(!(return_value_hash_add_row_9 == 0l))
                    return (signed long int)-2;

                  break;
                }
                case (signed long int)61:
                {
                  if(((signed long int *)rec)[1l] == 0l)
                  {
                    signed long int return_value_hash_add_row_10;
                    return_value_hash_add_row_10=hash_add_row(db, ilistelem->car, rec);
                    if(!(return_value_hash_add_row_10 == 0l))
                      return (signed long int)-2;

                  }

                  break;
                }
                default:
                  show_index_error(db, "unknown index type, ignoring");
              }

          }

        }

      }
      return (signed long int)0;
    }
}

// wg_index_add_rec
// file dbindex.h line 146
signed long int wg_index_add_rec(void *db, void *rec)
{
  signed long int i;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int reclen;
  reclen=wg_get_record_len(db, rec);
  signed long int tmp_if_expr_6;
  signed long int return_value_wg_match_template_5;
  signed long int return_value_ttree_add_row_1;
  signed long int return_value_hash_add_row_3;
  signed long int tmp_if_expr_10;
  signed long int return_value_wg_get_field_8;
  signed long int return_value_wg_compare_9;
  signed long int return_value_ttree_add_row_12;
  signed long int return_value_hash_add_row_14;
  if(!((1l & ((signed long int *)rec)[1l]) == 0l))
    return (signed long int)-1;

  else
  {
    if(reclen >= 128l)
      reclen = (signed long int)(127 + 1);

    i = (signed long int)0;
    for( ; !(i >= reclen); i = i + 1l)
    {
      signed long int *ilist;
      struct anonymous_20 *ilistelem;
      ilist = &dbh->index_control_area_header.index_table[i];
      for( ; !(*ilist == 0l); ilist = &ilistelem->cdr)
      {
        ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
        if(!(ilistelem->car == 0l))
        {
          struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + ilistelem->car);
          if(hdr->rec_field_index[hdr->fields + -1l] == i)
          {
            if(!(hdr->template_offset == 0l))
            {
              return_value_wg_match_template_5=wg_match_template(db, (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + hdr->template_offset), rec);
              tmp_if_expr_6 = return_value_wg_match_template_5;
            }

            else
              tmp_if_expr_6 = (signed long int)1;
            if(!(tmp_if_expr_6 == 0l))
              switch(hdr->type)
              {
                case (signed long int)50:
                {
                  return_value_ttree_add_row_1=ttree_add_row(db, ilistelem->car, rec);
                  if(!(return_value_ttree_add_row_1 == 0l))
                    return (signed long int)-2;

                  break;
                }
                case (signed long int)51:
                {
                  if(((signed long int *)rec)[1l] == 0l)
                  {
                    signed long int return_value_ttree_add_row_2;
                    return_value_ttree_add_row_2=ttree_add_row(db, ilistelem->car, rec);
                    if(!(return_value_ttree_add_row_2 == 0l))
                      return (signed long int)-2;

                  }

                  break;
                }
                case (signed long int)60:
                {
                  return_value_hash_add_row_3=hash_add_row(db, ilistelem->car, rec);
                  if(!(return_value_hash_add_row_3 == 0l))
                    return (signed long int)-2;

                  break;
                }
                case (signed long int)61:
                {
                  if(((signed long int *)rec)[1l] == 0l)
                  {
                    signed long int return_value_hash_add_row_4;
                    return_value_hash_add_row_4=hash_add_row(db, ilistelem->car, rec);
                    if(!(return_value_hash_add_row_4 == 0l))
                      return (signed long int)-2;

                  }

                  break;
                }
                default:
                  show_index_error(db, "unknown index type, ignoring");
              }

          }

        }

      }
      ilist = &dbh->index_control_area_header.index_template_table[i];
      for( ; !(*ilist == 0l); ilist = &ilistelem->cdr)
      {
        ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
        if(!(ilistelem->car == 0l))
        {
          struct anonymous_21 *wg_index_add_rec__1__1__1__2__1__hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + ilistelem->car);
          struct anonymous_22 *tmpl = (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + wg_index_add_rec__1__1__1__2__1__hdr->template_offset);
          void *matchrec;
          signed long int mreclen;
          signed int j;
          signed int firstmatch = -1;
          matchrec = (void *)((char *)((struct anonymous_6 *)db)->db + tmpl->offset_matchrec);
          mreclen=wg_get_record_len(db, matchrec);
          if(reclen >= mreclen)
          {
            j = 0;
            for( ; !((signed long int)j >= mreclen); j = j + 1)
            {
              signed long int enc;
              enc=wg_get_field(db, matchrec, (signed long int)j);
              signed long int return_value_wg_get_encoded_type_11;
              return_value_wg_get_encoded_type_11=wg_get_encoded_type(db, enc);
              if(!(return_value_wg_get_encoded_type_11 == 14l))
              {
                signed long int return_value_wg_get_field_7;
                return_value_wg_get_field_7=wg_get_field(db, rec, (signed long int)j);
                if(enc == return_value_wg_get_field_7)
                  tmp_if_expr_10 = (signed long int)0;

                else
                {
                  return_value_wg_get_field_8=wg_get_field(db, rec, (signed long int)j);
                  return_value_wg_compare_9=wg_compare(db, enc, return_value_wg_get_field_8, 7);
                  tmp_if_expr_10 = return_value_wg_compare_9;
                }
                if(!(tmp_if_expr_10 == 0l))
                  goto nexttmpl1;

                if(!(firstmatch >= 0))
                  firstmatch = j;

              }

            }
            if((signed long int)firstmatch == i)
            {
              if(!(wg_index_add_rec__1__1__1__2__1__hdr->rec_field_index[wg_index_add_rec__1__1__1__2__1__hdr->fields + -1l] >= reclen))
                switch(wg_index_add_rec__1__1__1__2__1__hdr->type)
                {
                  case (signed long int)50:
                  {
                    return_value_ttree_add_row_12=ttree_add_row(db, ilistelem->car, rec);
                    if(!(return_value_ttree_add_row_12 == 0l))
                      return (signed long int)-2;

                    break;
                  }
                  case (signed long int)51:
                  {
                    if(((signed long int *)rec)[1l] == 0l)
                    {
                      signed long int return_value_ttree_add_row_13;
                      return_value_ttree_add_row_13=ttree_add_row(db, ilistelem->car, rec);
                      if(!(return_value_ttree_add_row_13 == 0l))
                        return (signed long int)-2;

                    }

                    break;
                  }
                  case (signed long int)60:
                  {
                    return_value_hash_add_row_14=hash_add_row(db, ilistelem->car, rec);
                    if(!(return_value_hash_add_row_14 == 0l))
                      return (signed long int)-2;

                    break;
                  }
                  case (signed long int)61:
                  {
                    if(((signed long int *)rec)[1l] == 0l)
                    {
                      signed long int return_value_hash_add_row_15;
                      return_value_hash_add_row_15=hash_add_row(db, ilistelem->car, rec);
                      if(!(return_value_hash_add_row_15 == 0l))
                        return (signed long int)-2;

                    }

                    break;
                  }
                  default:
                    show_index_error(db, "unknown index type, ignoring");
                }

            }

          }

        }


      nexttmpl1:
        ;
      }
    }
    return (signed long int)0;
  }
}

// wg_index_del_field
// file dbindex.h line 147
signed long int wg_index_del_field(void *db, void *rec, signed long int column)
{
  signed long int *ilist;
  struct anonymous_20 *ilistelem;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int reclen;
  reclen=wg_get_record_len(db, rec);
  signed long int tmp_if_expr_6;
  signed long int return_value_wg_match_template_5;
  signed long int return_value_ttree_remove_row_1;
  signed long int return_value_hash_remove_row_3;
  signed long int tmp_if_expr_12;
  signed long int return_value_wg_match_template_11;
  signed long int return_value_ttree_remove_row_7;
  signed long int return_value_hash_remove_row_9;
  if(column >= 128l || column >= reclen)
    return (signed long int)-1;

  else
    if(!((1l & ((signed long int *)rec)[1l]) == 0l))
      return (signed long int)-1;

    else
    {
      ilist = &dbh->index_control_area_header.index_table[column];
      for( ; !(*ilist == 0l); ilist = &ilistelem->cdr)
      {
        ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
        if(!(ilistelem->car == 0l))
        {
          struct anonymous_21 *wg_index_del_field__1__1__1__hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + ilistelem->car);
          if(!(wg_index_del_field__1__1__1__hdr->rec_field_index[wg_index_del_field__1__1__1__hdr->fields + -1l] >= reclen))
          {
            if(!(wg_index_del_field__1__1__1__hdr->template_offset == 0l))
            {
              return_value_wg_match_template_5=wg_match_template(db, (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + wg_index_del_field__1__1__1__hdr->template_offset), rec);
              tmp_if_expr_6 = return_value_wg_match_template_5;
            }

            else
              tmp_if_expr_6 = (signed long int)1;
            if(!(tmp_if_expr_6 == 0l))
              switch(wg_index_del_field__1__1__1__hdr->type)
              {
                case (signed long int)50:
                {
                  return_value_ttree_remove_row_1=ttree_remove_row(db, ilistelem->car, rec);
                  if(!(return_value_ttree_remove_row_1 >= -2l))
                    return (signed long int)-2;

                  break;
                }
                case (signed long int)51:
                {
                  if(((signed long int *)rec)[1l] == 0l)
                  {
                    signed long int return_value_ttree_remove_row_2;
                    return_value_ttree_remove_row_2=ttree_remove_row(db, ilistelem->car, rec);
                    if(!(return_value_ttree_remove_row_2 >= -2l))
                      return (signed long int)-2;

                  }

                  break;
                }
                case (signed long int)60:
                {
                  return_value_hash_remove_row_3=hash_remove_row(db, ilistelem->car, rec);
                  if(!(return_value_hash_remove_row_3 >= -2l))
                    return (signed long int)-2;

                  break;
                }
                case (signed long int)61:
                {
                  if(((signed long int *)rec)[1l] == 0l)
                  {
                    signed long int return_value_hash_remove_row_4;
                    return_value_hash_remove_row_4=hash_remove_row(db, ilistelem->car, rec);
                    if(!(return_value_hash_remove_row_4 >= -2l))
                      return (signed long int)-2;

                  }

                  break;
                }
                default:
                  show_index_error(db, "unknown index type, ignoring");
              }

          }

        }

      }
      ilist = &dbh->index_control_area_header.index_template_table[column];
      for( ; !(*ilist == 0l); ilist = &ilistelem->cdr)
      {
        ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
        if(!(ilistelem->car == 0l))
        {
          struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + ilistelem->car);
          if(!(hdr->rec_field_index[hdr->fields + -1l] >= reclen))
          {
            if(!(hdr->template_offset == 0l))
            {
              return_value_wg_match_template_11=wg_match_template(db, (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + hdr->template_offset), rec);
              tmp_if_expr_12 = return_value_wg_match_template_11;
            }

            else
              tmp_if_expr_12 = (signed long int)1;
            if(!(tmp_if_expr_12 == 0l))
              switch(hdr->type)
              {
                case (signed long int)50:
                {
                  return_value_ttree_remove_row_7=ttree_remove_row(db, ilistelem->car, rec);
                  if(!(return_value_ttree_remove_row_7 >= -2l))
                    return (signed long int)-2;

                  break;
                }
                case (signed long int)51:
                {
                  if(((signed long int *)rec)[1l] == 0l)
                  {
                    signed long int return_value_ttree_remove_row_8;
                    return_value_ttree_remove_row_8=ttree_remove_row(db, ilistelem->car, rec);
                    if(!(return_value_ttree_remove_row_8 >= -2l))
                      return (signed long int)-2;

                  }

                  break;
                }
                case (signed long int)60:
                {
                  return_value_hash_remove_row_9=hash_remove_row(db, ilistelem->car, rec);
                  if(!(return_value_hash_remove_row_9 >= -2l))
                    return (signed long int)-2;

                  break;
                }
                case (signed long int)61:
                {
                  if(((signed long int *)rec)[1l] == 0l)
                  {
                    signed long int return_value_hash_remove_row_10;
                    return_value_hash_remove_row_10=hash_remove_row(db, ilistelem->car, rec);
                    if(!(return_value_hash_remove_row_10 >= -2l))
                      return (signed long int)-2;

                  }

                  break;
                }
                default:
                  show_index_error(db, "unknown index type, ignoring");
              }

          }

        }

      }
      return (signed long int)0;
    }
}

// wg_index_del_rec
// file dbindex.h line 148
signed long int wg_index_del_rec(void *db, void *rec)
{
  signed long int i;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int reclen;
  reclen=wg_get_record_len(db, rec);
  signed long int tmp_if_expr_6;
  signed long int return_value_wg_match_template_5;
  signed long int return_value_ttree_remove_row_1;
  signed long int return_value_hash_remove_row_3;
  signed long int tmp_if_expr_10;
  signed long int return_value_wg_get_field_8;
  signed long int return_value_wg_compare_9;
  signed long int return_value_ttree_remove_row_12;
  signed long int return_value_hash_remove_row_14;
  if(!((1l & ((signed long int *)rec)[1l]) == 0l))
    return (signed long int)-1;

  else
  {
    if(reclen >= 128l)
      reclen = (signed long int)(127 + 1);

    i = (signed long int)0;
    for( ; !(i >= reclen); i = i + 1l)
    {
      signed long int *ilist;
      struct anonymous_20 *ilistelem;
      ilist = &dbh->index_control_area_header.index_table[i];
      for( ; !(*ilist == 0l); ilist = &ilistelem->cdr)
      {
        ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
        if(!(ilistelem->car == 0l))
        {
          struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + ilistelem->car);
          if(hdr->rec_field_index[hdr->fields + -1l] == i)
          {
            if(!(hdr->template_offset == 0l))
            {
              return_value_wg_match_template_5=wg_match_template(db, (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + hdr->template_offset), rec);
              tmp_if_expr_6 = return_value_wg_match_template_5;
            }

            else
              tmp_if_expr_6 = (signed long int)1;
            if(!(tmp_if_expr_6 == 0l))
              switch(hdr->type)
              {
                case (signed long int)50:
                {
                  return_value_ttree_remove_row_1=ttree_remove_row(db, ilistelem->car, rec);
                  if(!(return_value_ttree_remove_row_1 >= -2l))
                    return (signed long int)-2;

                  break;
                }
                case (signed long int)51:
                {
                  if(((signed long int *)rec)[1l] == 0l)
                  {
                    signed long int return_value_ttree_remove_row_2;
                    return_value_ttree_remove_row_2=ttree_remove_row(db, ilistelem->car, rec);
                    if(!(return_value_ttree_remove_row_2 >= -2l))
                      return (signed long int)-2;

                  }

                  break;
                }
                case (signed long int)60:
                {
                  return_value_hash_remove_row_3=hash_remove_row(db, ilistelem->car, rec);
                  if(!(return_value_hash_remove_row_3 >= -2l))
                    return (signed long int)-2;

                  break;
                }
                case (signed long int)61:
                {
                  if(((signed long int *)rec)[1l] == 0l)
                  {
                    signed long int return_value_hash_remove_row_4;
                    return_value_hash_remove_row_4=hash_remove_row(db, ilistelem->car, rec);
                    if(!(return_value_hash_remove_row_4 >= -2l))
                      return (signed long int)-2;

                  }

                  break;
                }
                default:
                  show_index_error(db, "unknown index type, ignoring");
              }

          }

        }

      }
      ilist = &dbh->index_control_area_header.index_template_table[i];
      for( ; !(*ilist == 0l); ilist = &ilistelem->cdr)
      {
        ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
        if(!(ilistelem->car == 0l))
        {
          struct anonymous_21 *wg_index_del_rec__1__1__1__2__1__hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + ilistelem->car);
          struct anonymous_22 *tmpl = (struct anonymous_22 *)(void *)((char *)((struct anonymous_6 *)db)->db + wg_index_del_rec__1__1__1__2__1__hdr->template_offset);
          void *matchrec;
          signed long int mreclen;
          signed int j;
          signed int firstmatch = -1;
          matchrec = (void *)((char *)((struct anonymous_6 *)db)->db + tmpl->offset_matchrec);
          mreclen=wg_get_record_len(db, matchrec);
          if(reclen >= mreclen)
          {
            j = 0;
            for( ; !((signed long int)j >= mreclen); j = j + 1)
            {
              signed long int enc;
              enc=wg_get_field(db, matchrec, (signed long int)j);
              signed long int return_value_wg_get_encoded_type_11;
              return_value_wg_get_encoded_type_11=wg_get_encoded_type(db, enc);
              if(!(return_value_wg_get_encoded_type_11 == 14l))
              {
                signed long int return_value_wg_get_field_7;
                return_value_wg_get_field_7=wg_get_field(db, rec, (signed long int)j);
                if(enc == return_value_wg_get_field_7)
                  tmp_if_expr_10 = (signed long int)0;

                else
                {
                  return_value_wg_get_field_8=wg_get_field(db, rec, (signed long int)j);
                  return_value_wg_compare_9=wg_compare(db, enc, return_value_wg_get_field_8, 7);
                  tmp_if_expr_10 = return_value_wg_compare_9;
                }
                if(!(tmp_if_expr_10 == 0l))
                  goto nexttmpl2;

                if(!(firstmatch >= 0))
                  firstmatch = j;

              }

            }
            if((signed long int)firstmatch == i)
            {
              if(!(wg_index_del_rec__1__1__1__2__1__hdr->rec_field_index[wg_index_del_rec__1__1__1__2__1__hdr->fields + -1l] >= reclen))
                switch(wg_index_del_rec__1__1__1__2__1__hdr->type)
                {
                  case (signed long int)50:
                  {
                    return_value_ttree_remove_row_12=ttree_remove_row(db, ilistelem->car, rec);
                    if(!(return_value_ttree_remove_row_12 >= -2l))
                      return (signed long int)-2;

                    break;
                  }
                  case (signed long int)51:
                  {
                    if(((signed long int *)rec)[1l] == 0l)
                    {
                      signed long int return_value_ttree_remove_row_13;
                      return_value_ttree_remove_row_13=ttree_remove_row(db, ilistelem->car, rec);
                      if(!(return_value_ttree_remove_row_13 >= -2l))
                        return (signed long int)-2;

                    }

                    break;
                  }
                  case (signed long int)60:
                  {
                    return_value_hash_remove_row_14=hash_remove_row(db, ilistelem->car, rec);
                    if(!(return_value_hash_remove_row_14 >= -2l))
                      return (signed long int)-2;

                    break;
                  }
                  case (signed long int)61:
                  {
                    if(((signed long int *)rec)[1l] == 0l)
                    {
                      signed long int return_value_hash_remove_row_15;
                      return_value_hash_remove_row_15=hash_remove_row(db, ilistelem->car, rec);
                      if(!(return_value_hash_remove_row_15 >= -2l))
                        return (signed long int)-2;

                    }

                    break;
                  }
                  default:
                    show_index_error(db, "unknown index type, ignoring");
                }

            }

          }

        }


      nexttmpl2:
        ;
      }
    }
    return (signed long int)0;
  }
}

// wg_init_db_memsegment
// file dballoc.c line 99
signed long int wg_init_db_memsegment(void *db, signed long int key, signed long int size)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int tmp;
  signed long int wg_init_db_memsegment__1__free;
  signed long int i;
  dbh->mark = (signed int)1916950123;
  dbh->version = (signed int)(3 << 16 | 7 << 8 | 0);
  dbh->features = (signed int)(0x1 | 0x2 | 0x4 | 0x8 | 0x0 | 0x20);
  dbh->checksum = 0;
  dbh->size = size;
  dbh->initialadr = (signed long int)dbh;
  dbh->key = key;
  if(!((signed long int)dbh % 8l == 0l))
    show_dballoc_error((void *)dbh, "db base pointer has bad alignment (ignoring)");

  wg_init_db_memsegment__1__free = (signed long int)sizeof(struct _db_memsegment_header) /*46568ul*/ ;
  i = (signed long int)8 - wg_init_db_memsegment__1__free % (signed long int)8;
  if(i == 8l)
    i = (signed long int)0;

  dbh->free = wg_init_db_memsegment__1__free + i;
  tmp=init_db_subarea(db, (void *)&dbh->datarec_area_header, (signed long int)0, (signed long int)8192);
  if(!(tmp == 0l))
  {
    show_dballoc_error(db, " cannot create datarec area");
    return (signed long int)-1;
  }

  else
  {
    dbh->datarec_area_header.fixedlength = (signed long int)0;
    tmp=init_area_buckets(db, (void *)&dbh->datarec_area_header);
    if(!(tmp == 0l))
    {
      show_dballoc_error(db, " cannot initialize datarec area buckets");
      return (signed long int)-1;
    }

    else
    {
      tmp=init_subarea_freespace(db, (void *)&dbh->datarec_area_header, (signed long int)0);
      if(!(tmp == 0l))
      {
        show_dballoc_error(db, " cannot initialize datarec subarea 0");
        return (signed long int)-1;
      }

      else
      {
        tmp=init_db_subarea(db, (void *)&dbh->longstr_area_header, (signed long int)0, (signed long int)8192);
        if(!(tmp == 0l))
        {
          show_dballoc_error(db, " cannot create longstr area");
          return (signed long int)-1;
        }

        else
        {
          dbh->longstr_area_header.fixedlength = (signed long int)0;
          tmp=init_area_buckets(db, (void *)&dbh->longstr_area_header);
          if(!(tmp == 0l))
          {
            show_dballoc_error(db, " cannot initialize longstr area buckets");
            return (signed long int)-1;
          }

          else
          {
            tmp=init_subarea_freespace(db, (void *)&dbh->longstr_area_header, (signed long int)0);
            if(!(tmp == 0l))
            {
              show_dballoc_error(db, " cannot initialize longstr subarea 0");
              return (signed long int)-1;
            }

            else
            {
              tmp=init_db_subarea(db, (void *)&dbh->listcell_area_header, (signed long int)0, (signed long int)8192);
              if(!(tmp == 0l))
              {
                show_dballoc_error(db, " cannot create listcell area");
                return (signed long int)-1;
              }

              else
              {
                dbh->listcell_area_header.fixedlength = (signed long int)1;
                dbh->listcell_area_header.objlength = (signed long int)sizeof(struct anonymous_20) /*16ul*/ ;
                tmp=make_subarea_freelist(db, (void *)&dbh->listcell_area_header, (signed long int)0);
                if(!(tmp == 0l))
                {
                  show_dballoc_error(db, " cannot initialize listcell area");
                  return (signed long int)-1;
                }

                else
                {
                  tmp=init_db_subarea(db, (void *)&dbh->shortstr_area_header, (signed long int)0, (signed long int)8192);
                  if(!(tmp == 0l))
                  {
                    show_dballoc_error(db, " cannot create short string area");
                    return (signed long int)-1;
                  }

                  else
                  {
                    dbh->shortstr_area_header.fixedlength = (signed long int)1;
                    dbh->shortstr_area_header.objlength = (signed long int)32;
                    tmp=make_subarea_freelist(db, (void *)&dbh->shortstr_area_header, (signed long int)0);
                    if(!(tmp == 0l))
                    {
                      show_dballoc_error(db, " cannot initialize shortstr area");
                      return (signed long int)-1;
                    }

                    else
                    {
                      tmp=init_db_subarea(db, (void *)&dbh->word_area_header, (signed long int)0, (signed long int)8192);
                      if(!(tmp == 0l))
                      {
                        show_dballoc_error(db, " cannot create word area");
                        return (signed long int)-1;
                      }

                      else
                      {
                        dbh->word_area_header.fixedlength = (signed long int)1;
                        dbh->word_area_header.objlength = (signed long int)sizeof(signed long int) /*8ul*/ ;
                        tmp=make_subarea_freelist(db, (void *)&dbh->word_area_header, (signed long int)0);
                        if(!(tmp == 0l))
                        {
                          show_dballoc_error(db, " cannot initialize word area");
                          return (signed long int)-1;
                        }

                        else
                        {
                          tmp=init_db_subarea(db, (void *)&dbh->doubleword_area_header, (signed long int)0, (signed long int)8192);
                          if(!(tmp == 0l))
                          {
                            show_dballoc_error(db, " cannot create doubleword area");
                            return (signed long int)-1;
                          }

                          else
                          {
                            dbh->doubleword_area_header.fixedlength = (signed long int)1;
                            dbh->doubleword_area_header.objlength = (signed long int)((unsigned long int)2 * sizeof(signed long int) /*8ul*/ );
                            tmp=make_subarea_freelist(db, (void *)&dbh->doubleword_area_header, (signed long int)0);
                            if(!(tmp == 0l))
                            {
                              show_dballoc_error(db, " cannot initialize doubleword area");
                              return (signed long int)-1;
                            }

                            else
                            {
                              tmp=init_db_subarea(db, (void *)&dbh->tnode_area_header, (signed long int)0, (signed long int)8192);
                              if(!(tmp == 0l))
                              {
                                show_dballoc_error(db, " cannot create tnode area");
                                return (signed long int)-1;
                              }

                              else
                              {
                                dbh->tnode_area_header.fixedlength = (signed long int)1;
                                dbh->tnode_area_header.objlength = (signed long int)sizeof(struct wg_tnode) /*128ul*/ ;
                                tmp=make_subarea_freelist(db, (void *)&dbh->tnode_area_header, (signed long int)0);
                                if(!(tmp == 0l))
                                {
                                  show_dballoc_error(db, " cannot initialize tnode area");
                                  return (signed long int)-1;
                                }

                                else
                                {
                                  tmp=init_db_subarea(db, (void *)&dbh->indexhdr_area_header, (signed long int)0, (signed long int)8192);
                                  if(!(tmp == 0l))
                                  {
                                    show_dballoc_error(db, " cannot create index header area");
                                    return (signed long int)-1;
                                  }

                                  else
                                  {
                                    dbh->indexhdr_area_header.fixedlength = (signed long int)1;
                                    dbh->indexhdr_area_header.objlength = (signed long int)sizeof(struct anonymous_21) /*144ul*/ ;
                                    tmp=make_subarea_freelist(db, (void *)&dbh->indexhdr_area_header, (signed long int)0);
                                    if(!(tmp == 0l))
                                    {
                                      show_dballoc_error(db, " cannot initialize index header area");
                                      return (signed long int)-1;
                                    }

                                    else
                                    {
                                      tmp=init_db_subarea(db, (void *)&dbh->indextmpl_area_header, (signed long int)0, (signed long int)8192);
                                      if(!(tmp == 0l))
                                      {
                                        show_dballoc_error(db, " cannot create index header area");
                                        return (signed long int)-1;
                                      }

                                      else
                                      {
                                        dbh->indextmpl_area_header.fixedlength = (signed long int)1;
                                        dbh->indextmpl_area_header.objlength = (signed long int)sizeof(struct anonymous_22) /*24ul*/ ;
                                        tmp=make_subarea_freelist(db, (void *)&dbh->indextmpl_area_header, (signed long int)0);
                                        if(!(tmp == 0l))
                                        {
                                          show_dballoc_error(db, " cannot initialize index header area");
                                          return (signed long int)-1;
                                        }

                                        else
                                        {
                                          tmp=init_db_subarea(db, (void *)&dbh->indexhash_area_header, (signed long int)0, (signed long int)8192);
                                          if(!(tmp == 0l))
                                          {
                                            show_dballoc_error(db, " cannot create indexhash area");
                                            return (signed long int)-1;
                                          }

                                          else
                                          {
                                            dbh->indexhash_area_header.fixedlength = (signed long int)0;
                                            tmp=init_area_buckets(db, (void *)&dbh->indexhash_area_header);
                                            if(!(tmp == 0l))
                                            {
                                              show_dballoc_error(db, " cannot initialize indexhash area buckets");
                                              return (signed long int)-1;
                                            }

                                            else
                                            {
                                              tmp=init_subarea_freespace(db, (void *)&dbh->indexhash_area_header, (signed long int)0);
                                              if(!(tmp == 0l))
                                              {
                                                show_dballoc_error(db, " cannot initialize indexhash subarea 0");
                                                return (signed long int)-1;
                                              }

                                              else
                                              {
                                                tmp=init_strhash_area(db, &dbh->strhash_area_header);
                                                if(!(tmp == 0l))
                                                {
                                                  show_dballoc_error(db, " cannot create strhash array area");
                                                  return (signed long int)-1;
                                                }

                                                else
                                                {
                                                  tmp=init_syn_vars(db);
                                                  if(!(tmp == 0l))
                                                  {
                                                    show_dballoc_error(db, " cannot initialize synchronization area");
                                                    return (signed long int)-1;
                                                  }

                                                  else
                                                  {
                                                    tmp=init_extdb(db);
                                                    if(!(tmp == 0l))
                                                    {
                                                      show_dballoc_error(db, " cannot initialize external db register");
                                                      return (signed long int)-1;
                                                    }

                                                    else
                                                    {
                                                      tmp=init_db_index_area_header(db);
                                                      if(!(tmp == 0l))
                                                      {
                                                        show_dballoc_error(db, " cannot initialize index header area");
                                                        return (signed long int)-1;
                                                      }

                                                      else
                                                      {
                                                        tmp=init_db_recptr_bitmap(db);
                                                        if(!(tmp == 0l))
                                                        {
                                                          show_dballoc_error(db, " cannot initialize record pointer bitmap");
                                                          return (signed long int)-1;
                                                        }

                                                        else
                                                        {
                                                          tmp=init_logging(db);
                                                          dbh->mark = (signed int)1232319011;
                                                          return (signed long int)0;
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// wg_init_handle_logdata
// file dblog.c line 705
signed long int wg_init_handle_logdata(void *db)
{
  return (signed long int)0;
}

// wg_init_locks
// file dblock.h line 81
signed long int wg_init_locks(void *db)
{
  signed long int i;
  signed long int chunk_wall;
  struct anonymous_5 *tmp = (struct anonymous_5 *)(void *)0;
  struct _db_memsegment_header *dbh;
  _Bool tmp_if_expr_2;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_2 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_1;
  if(!tmp_if_expr_2)
  {
    if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
      tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1916950123 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      goto __CPROVER_DUMP_L5;

    show_lock_error(db, "Invalid database pointer in wg_init_locks");
    return (signed long int)-1;
  }

  else
  {

  __CPROVER_DUMP_L5:
    ;
    dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
    chunk_wall = dbh->locks.storage + dbh->locks.max_nodes * (signed long int)128;
    i = dbh->locks.storage;
    for( ; !(i >= chunk_wall); tmp->next_cell = i)
    {
      tmp = (struct anonymous_5 *)(void *)((char *)((struct anonymous_6 *)db)->db + i);
      i = i + (signed long int)128;
    }
    tmp->next_cell = (signed long int)0;
    dbh->locks.freelist = dbh->locks.storage;
    dbh->locks.tail = (signed long int)0;
    *((signed long int *)((char *)((struct anonymous_6 *)db)->db + dbh->locks.queue_lock)) = (signed long int)0;
    return (signed long int)0;
  }
}

// wg_isatom
// file dbmpool.c line 336
signed int wg_isatom(void *db, void *ptr)
{
  return (signed int)(ptr != (void *)0 && ((signed long int)ptr & (signed long int)1) == (signed long int)1);
}

// wg_ispair
// file dbmpool.c line 301
signed int wg_ispair(void *db, void *ptr)
{
  return (signed int)(ptr != (void *)0 && ((signed long int)ptr & (signed long int)1) == (signed long int)0);
}

// wg_journal_filename
// file dblog.c line 687
void wg_journal_filename(void *db, char *buf, unsigned long int buflen)
{
  buf[(signed long int)0] = (char)0;
}

// wg_listtreecount
// file dbmpool.c line 326
signed int wg_listtreecount(void *db, void *ptr)
{
  signed int return_value_wg_ispair_5;
  return_value_wg_ispair_5=wg_ispair(db, ptr);
  void *return_value_wg_first_1;
  signed int return_value_wg_listtreecount_2;
  void *return_value_wg_rest_3;
  signed int return_value_wg_listtreecount_4;
  if(!(return_value_wg_ispair_5 == 0))
  {
    return_value_wg_first_1=wg_first(db, ptr);
    return_value_wg_listtreecount_2=wg_listtreecount(db, return_value_wg_first_1);
    return_value_wg_rest_3=wg_rest(db, ptr);
    return_value_wg_listtreecount_4=wg_listtreecount(db, return_value_wg_rest_3);
    return return_value_wg_listtreecount_2 + return_value_wg_listtreecount_4;
  }

  else
    return 1;
}

// wg_log_create_record
// file dblog.c line 1012
signed long int wg_log_create_record(void *db, signed long int length)
{
  signed long int return_value_show_log_error_1;
  return_value_show_log_error_1=show_log_error(db, "Logging is disabled");
  return return_value_show_log_error_1;
}

// wg_log_delete_record
// file dblog.c line 1028
signed long int wg_log_delete_record(void *db, signed long int enc)
{
  signed long int return_value_show_log_error_1;
  return_value_show_log_error_1=show_log_error(db, "Logging is disabled");
  return return_value_show_log_error_1;
}

// wg_log_encode
// file dblog.c line 1062
signed long int wg_log_encode(void *db, signed long int type, void *data, signed long int length, void *extdata, signed long int extlength)
{
  signed long int return_value_show_log_error_1;
  return_value_show_log_error_1=show_log_error(db, "Logging is disabled");
  return return_value_show_log_error_1;
}

// wg_log_encval
// file dblog.c line 1046
signed long int wg_log_encval(void *db, signed long int enc)
{
  signed long int return_value_show_log_error_1;
  return_value_show_log_error_1=show_log_error(db, "Logging is disabled");
  return return_value_show_log_error_1;
}

// wg_log_set_field
// file dblog.c line 1143
signed long int wg_log_set_field(void *db, void *rec, signed long int col, signed long int data)
{
  signed long int return_value_show_log_error_1;
  return_value_show_log_error_1=show_log_error(db, "Logging is disabled");
  return return_value_show_log_error_1;
}

// wg_log_set_meta
// file dblog.c line 1162
signed long int wg_log_set_meta(void *db, void *rec, signed long int meta)
{
  signed long int return_value_show_log_error_1;
  return_value_show_log_error_1=show_log_error(db, "Logging is disabled");
  return return_value_show_log_error_1;
}

// wg_log_umask
// file dblog.c line 748
signed int wg_log_umask(void *db, signed int cmask)
{
  signed int prev = 0;
  return prev;
}

// wg_make_json_query
// file dbquery.c line 1830
struct anonymous_15 * wg_make_json_query(void *db, struct anonymous_18 *arglist, signed long int argc)
{
  struct anonymous_15 *query = (struct anonymous_15 *)(void *)0;
  struct anonymous_17 *curr_res = (struct anonymous_17 *)(void *)0;
  struct anonymous_18 *sorted_arglist = (struct anonymous_18 *)(void *)0;
  signed long int index_id = (signed long int)-1;
  signed long int vindex_id = (signed long int)-1;
  signed long int kindex_id = (signed long int)-1;
  signed long int i;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_7;
  signed long int return_value_wg_get_encoded_type_6;
  if(arglist == ((struct anonymous_18 *)NULL) || !(argc >= 1l))
  {
    show_query_error(db, "Not enough parameters");
    return (struct anonymous_15 *)(void *)0;
  }

  else
  {
    if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
      tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
    {
      fprintf(stderr, "Invalid database pointer in wg_make_json_query.\n");
      return (struct anonymous_15 *)(void *)0;
    }

    else
    {
      prepare_json_arglist(db, arglist, &sorted_arglist, argc, &index_id, &vindex_id, &kindex_id);
      if(!(sorted_arglist == ((struct anonymous_18 *)NULL)))
        arglist = sorted_arglist;

      i = (signed long int)0;
      for( ; !(i >= argc); i = i + 1l)
      {
        struct anonymous_17 *next_set;
        struct anonymous_17 *tmp_set;
        next_set=create_resultset(db);
        if(next_set == ((struct anonymous_17 *)NULL))
        {
          if(!(curr_res == ((struct anonymous_17 *)NULL)))
            free_resultset(db, curr_res);

          return (struct anonymous_15 *)(void *)0;
        }

        if(index_id >= 1l)
        {
          return_value_wg_get_encoded_type_6=wg_get_encoded_type(db, (arglist + i)->value);
          tmp_if_expr_7 = return_value_wg_get_encoded_type_6 != (signed long int)2 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_7 = (_Bool)0;
        if(tmp_if_expr_7)
        {
          signed long int values[2l];
          signed long int reclist_offset;
          values[(signed long int)0] = (arglist + i)->key;
          values[(signed long int)1] = (arglist + i)->value;
          reclist_offset=wg_search_hash(db, index_id, values, (signed long int)2);
          if(reclist_offset >= 1l)
          {
            signed long int *nextoffset = &reclist_offset;
            while(!(*nextoffset == 0l))
            {
              struct anonymous_20 *rec_cell = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *nextoffset);
              signed long int wg_make_json_query__1__3__1__2__1__1__rc = (signed long int)-1;
              void *doc;
              doc=wg_find_document(db, (void *)((char *)((struct anonymous_6 *)db)->db + rec_cell->car));
              if(!(doc == NULL))
              {
                signed long int return_value_append_resultset_2;
                return_value_append_resultset_2=append_resultset(db, next_set, (signed long int)((char *)doc - (char *)((struct anonymous_6 *)db)->db));
                if(return_value_append_resultset_2 == 0l)
                  wg_make_json_query__1__3__1__2__1__1__rc = (signed long int)1;

                else
                  wg_make_json_query__1__3__1__2__1__1__rc = (signed long int)-1;
              }

              else
                wg_make_json_query__1__3__1__2__1__1__rc=show_query_error(db, "Failed to retrieve the document");
              if(!(wg_make_json_query__1__3__1__2__1__1__rc >= 0l))
              {
                free_resultset(db, next_set);
                if(!(curr_res == ((struct anonymous_17 *)NULL)))
                  free_resultset(db, curr_res);

                if(!(sorted_arglist == ((struct anonymous_18 *)NULL)))
                  free((void *)sorted_arglist);

                return (struct anonymous_15 *)(void *)0;
              }

              nextoffset = &rec_cell->cdr;
            }
          }

        }

        else
          if(kindex_id >= 1l)
          {
            signed long int curr_offset = (signed long int)0;
            signed long int curr_slot = (signed long int)-1;
            signed long int end_offset = (signed long int)0;
            signed long int end_slot = (signed long int)-1;
            signed long int return_value_find_ttree_bounds_3;
            return_value_find_ttree_bounds_3=find_ttree_bounds(db, kindex_id, (signed long int)(0 + 1), (arglist + i)->key, (arglist + i)->key, (signed long int)1, (signed long int)1, &curr_offset, &curr_slot, &end_offset, &end_slot);
            if(!(return_value_find_ttree_bounds_3 == 0l))
              curr_offset = (signed long int)0;

            while(!(curr_offset == 0l))
            {
              signed long int wg_make_json_query__1__3__1__3__2__rc;
              struct wg_tnode *node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + curr_offset);
              void *wg_make_json_query__1__3__1__3__2__rec = (void *)((char *)((struct anonymous_6 *)db)->db + node->array_of_values[curr_slot]);
              wg_make_json_query__1__3__1__3__2__rc=check_and_merge_by_key(db, wg_make_json_query__1__3__1__3__2__rec, &arglist[i], next_set);
              if(!(wg_make_json_query__1__3__1__3__2__rc >= 0l))
              {
                free_resultset(db, next_set);
                if(!(curr_res == ((struct anonymous_17 *)NULL)))
                  free_resultset(db, curr_res);

                if(!(sorted_arglist == ((struct anonymous_18 *)NULL)))
                  free((void *)sorted_arglist);

                return (struct anonymous_15 *)(void *)0;
              }

              if(curr_offset == end_offset && curr_slot == end_slot)
                break;

              else
              {
                curr_slot = curr_slot + (signed long int)1;
                if(curr_slot >= (signed long int)node->number_of_elements)
                {
                  if(end_offset == curr_offset)
                  {
                    show_query_error(db, "Warning: end slot mismatch, possible bug");
                    break;
                  }

                  else
                  {
                    curr_offset = node->succ_offset;
                    curr_slot = (signed long int)0;
                  }
                }

              }
            }
          }

          else
            if(!(curr_res == ((struct anonymous_17 *)NULL)))
            {
              signed long int offset;
              rewind_resultset(db, curr_res);
              do
              {
                offset=fetch_resultset(db, curr_res);
                if(offset == 0l)
                  break;

                signed long int *rec = (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + offset);
                signed long int rc;
                rc=check_and_merge_recursively(db, (void *)rec, &arglist[i], next_set, 7);
                if(!(rc >= 0l))
                {
                  free_resultset(db, next_set);
                  if(!(curr_res == ((struct anonymous_17 *)NULL)))
                    free_resultset(db, curr_res);

                  if(!(sorted_arglist == ((struct anonymous_18 *)NULL)))
                    free((void *)sorted_arglist);

                  return (struct anonymous_15 *)(void *)0;
                }

              }
              while((_Bool)1);
              free_resultset(db, curr_res);
              curr_res = (struct anonymous_17 *)(void *)0;
            }

            else
            {
              signed long int *wg_make_json_query__1__3__1__5__rec;
              void *return_value_wg_get_first_record_4;
              return_value_wg_get_first_record_4=wg_get_first_record(db);
              wg_make_json_query__1__3__1__5__rec = (signed long int *)return_value_wg_get_first_record_4;
              while(!(wg_make_json_query__1__3__1__5__rec == ((signed long int *)NULL)))
              {
                signed long int wg_make_json_query__1__3__1__5__1__rc;
                wg_make_json_query__1__3__1__5__1__rc=check_and_merge_by_kv(db, (void *)wg_make_json_query__1__3__1__5__rec, &arglist[i], next_set);
                if(!(wg_make_json_query__1__3__1__5__1__rc >= 0l))
                {
                  free_resultset(db, next_set);
                  if(!(curr_res == ((struct anonymous_17 *)NULL)))
                    free_resultset(db, curr_res);

                  if(!(sorted_arglist == ((struct anonymous_18 *)NULL)))
                    free((void *)sorted_arglist);

                  return (struct anonymous_15 *)(void *)0;
                }

                void *return_value_wg_get_next_record_5;
                return_value_wg_get_next_record_5=wg_get_next_record(db, (void *)wg_make_json_query__1__3__1__5__rec);
                wg_make_json_query__1__3__1__5__rec = (signed long int *)return_value_wg_get_next_record_5;
              }
            }
        tmp_set=unique_resultset(db, next_set);
        free_resultset(db, next_set);
        if(tmp_set == ((struct anonymous_17 *)NULL))
        {
          if(!(curr_res == ((struct anonymous_17 *)NULL)))
            free_resultset(db, curr_res);

          if(!(sorted_arglist == ((struct anonymous_18 *)NULL)))
            free((void *)sorted_arglist);

          return (struct anonymous_15 *)(void *)0;
        }

        else
          next_set = tmp_set;
        if(!(curr_res == ((struct anonymous_17 *)NULL)))
        {
          tmp_set=intersect_resultset(db, curr_res, next_set);
          free_resultset(db, curr_res);
          free_resultset(db, next_set);
          if(tmp_set == ((struct anonymous_17 *)NULL))
          {
            if(!(sorted_arglist == ((struct anonymous_18 *)NULL)))
              free((void *)sorted_arglist);

            return (struct anonymous_15 *)(void *)0;
          }

          else
            curr_res = tmp_set;
        }

        else
          curr_res = next_set;
      }
      if(!(sorted_arglist == ((struct anonymous_18 *)NULL)))
        free((void *)sorted_arglist);

      void *return_value_malloc_8;
      return_value_malloc_8=malloc(sizeof(struct anonymous_15) /*112ul*/ );
      query = (struct anonymous_15 *)return_value_malloc_8;
      if(query == ((struct anonymous_15 *)NULL))
      {
        free_resultset(db, curr_res);
        show_query_error(db, "Failed to allocate memory");
        return (struct anonymous_15 *)(void *)0;
      }

      else
      {
        query->qtype = (signed long int)0x80;
        query->arglist = (struct anonymous_12 *)(void *)0;
        query->argc = (signed long int)0;
        query->column = (signed long int)-1;
        query->curr_page = (void *)curr_res->first_page;
        query->curr_pidx = (signed long int)0;
        query->res_count = (unsigned long int)curr_res->res_count;
        query->mpool = curr_res->mpool;
        free((void *)curr_res);
        return query;
      }
    }
  }
}

// wg_make_query
// file dbquery.c line 953
struct anonymous_15 * wg_make_query(void *db, void *matchrec, signed long int reclen, struct anonymous_12 *arglist, signed long int argc)
{
  struct anonymous_15 *return_value_internal_build_query_1;
  return_value_internal_build_query_1=internal_build_query(db, matchrec, reclen, arglist, argc, (signed long int)0x1000, (unsigned long int)0);
  return return_value_internal_build_query_1;
}

// wg_make_query_rc
// file dbquery.c line 965
struct anonymous_15 * wg_make_query_rc(void *db, void *matchrec, signed long int reclen, struct anonymous_12 *arglist, signed long int argc, unsigned long int rowlimit)
{
  struct anonymous_15 *return_value_internal_build_query_1;
  return_value_internal_build_query_1=internal_build_query(db, matchrec, reclen, arglist, argc, (signed long int)0x1000, rowlimit);
  return return_value_internal_build_query_1;
}

// wg_match_template
// file dbindex.c line 1958
signed long int wg_match_template(void *db, struct anonymous_22 *tmpl, void *rec)
{
  void *matchrec;
  signed long int reclen;
  signed long int mreclen;
  signed int i;
  signed long int tmp_if_expr_4;
  signed long int return_value_wg_get_field_2;
  signed long int return_value_wg_compare_3;
  if(tmpl->offset_matchrec == 0l)
  {
    show_index_error(db, "Invalid match record template");
    return (signed long int)0;
  }

  else
  {
    matchrec = (void *)((char *)((struct anonymous_6 *)db)->db + tmpl->offset_matchrec);
    mreclen=wg_get_record_len(db, matchrec);
    reclen=wg_get_record_len(db, rec);
    if(!(reclen >= mreclen))
      return (signed long int)0;

    else
      if(!(mreclen >= reclen))
        reclen = mreclen;

    i = 0;
    for( ; !((signed long int)i >= reclen); i = i + 1)
    {
      signed long int enc;
      enc=wg_get_field(db, matchrec, (signed long int)i);
      signed long int return_value_wg_get_encoded_type_5;
      return_value_wg_get_encoded_type_5=wg_get_encoded_type(db, enc);
      if(!(return_value_wg_get_encoded_type_5 == 14l))
      {
        signed long int return_value_wg_get_field_1;
        return_value_wg_get_field_1=wg_get_field(db, rec, (signed long int)i);
        if(enc == return_value_wg_get_field_1)
          tmp_if_expr_4 = (signed long int)0;

        else
        {
          return_value_wg_get_field_2=wg_get_field(db, rec, (signed long int)i);
          return_value_wg_compare_3=wg_compare(db, enc, return_value_wg_get_field_2, 7);
          tmp_if_expr_4 = return_value_wg_compare_3;
        }
        if(!(tmp_if_expr_4 == 0l))
          return (signed long int)0;

      }

    }
    return (signed long int)1;
  }
}

// wg_memgroup
// file dbmem.c line 646
signed int wg_memgroup(void *db)
{
  signed int gid;
  unsigned int return_value_getgid_1;
  return_value_getgid_1=getgid();
  gid = (signed int)return_value_getgid_1;
  struct shmid_ds buf;
  signed int err;
  err=memory_stats(db, &buf);
  if(err == 0)
    gid = (signed int)buf.shm_perm.gid;

  else
    if(!(err >= -1))
      return -1;

  return gid;
}

// wg_memmode
// file dbmem.c line 610
signed int wg_memmode(void *db)
{
  signed int mode = 0600;
  struct shmid_ds buf;
  signed int err;
  err=memory_stats(db, &buf);
  if(err == 0)
    mode = (signed int)buf.shm_perm.mode;

  else
    if(!(err >= -1))
      return -1;

  return mode;
}

// wg_memowner
// file dbmem.c line 627
signed int wg_memowner(void *db)
{
  signed int uid;
  unsigned int return_value_getuid_1;
  return_value_getuid_1=getuid();
  uid = (signed int)return_value_getuid_1;
  struct shmid_ds buf;
  signed int err;
  err=memory_stats(db, &buf);
  if(err == 0)
    uid = (signed int)buf.shm_perm.uid;

  else
    if(!(err >= -1))
      return -1;

  return uid;
}

// wg_mkatom
// file dbmpool.c line 341
void * wg_mkatom(void *db, void *mpool, signed int type, char *str1, char *str2)
{
  char *ptr;
  char *curptr;
  signed int size = 2;
  unsigned long int return_value_strlen_1;
  if(!(str1 == ((char *)NULL)))
  {
    return_value_strlen_1=strlen(str1);
    size = (signed int)((unsigned long int)size + return_value_strlen_1);
  }

  size = size + 1;
  unsigned long int return_value_strlen_2;
  if(!(str2 == ((char *)NULL)))
  {
    return_value_strlen_2=strlen(str2);
    size = (signed int)((unsigned long int)size + return_value_strlen_2);
  }

  size = size + 1;
  void *return_value_wg_alloc_mpool_3;
  return_value_wg_alloc_mpool_3=wg_alloc_mpool(db, mpool, size);
  ptr = (char *)return_value_wg_alloc_mpool_3;
  char *tmp_post_4;
  char *tmp_post_5;
  char *tmp_post_6;
  char *tmp_post_7;
  if(ptr == ((char *)NULL))
  {
    show_mpool_error(db, "cannot create an atom in mpool");
    return (void *)0;
  }

  else
  {
    ptr = ptr + 1l;
    curptr = ptr;
    *curptr = (char)type;
    curptr = curptr + 1l;
    if(!(str1 == ((char *)NULL)))
      do
      {
        tmp_post_4 = curptr;
        curptr = curptr + 1l;
        tmp_post_5 = str1;
        str1 = str1 + 1l;
        *tmp_post_4 = *tmp_post_5;
        if(*tmp_post_4 == 0)
          break;

      }
      while((_Bool)1);

    else
    {
      *curptr = (char)0;
      curptr = curptr + 1l;
    }
    if(!(str2 == ((char *)NULL)))
      do
      {
        tmp_post_6 = curptr;
        curptr = curptr + 1l;
        tmp_post_7 = str2;
        str2 = str2 + 1l;
        *tmp_post_6 = *tmp_post_7;
        if(*tmp_post_6 == 0)
          break;

      }
      while((_Bool)1);

    else
    {
      *curptr = (char)0;
      curptr = curptr + 1l;
    }
    return (void *)ptr;
  }
}

// wg_mkpair
// file dbmpool.c line 305
void * wg_mkpair(void *db, void *mpool, void *x, void *y)
{
  void *ptr;
  ptr=wg_alloc_mpool(db, mpool, (signed int)(sizeof(signed long int) /*8ul*/  * (unsigned long int)2));
  if(ptr == NULL)
  {
    show_mpool_error(db, "cannot create a pair in mpool");
    return (void *)0;
  }

  else
  {
    *((signed long int *)ptr) = (signed long int)x;
    ((signed long int *)ptr)[(signed long int)1] = (signed long int)y;
    return ptr;
  }
}

// wg_mpool_print
// file dbmpool.c line 396
void wg_mpool_print(void *db, void *ptr)
{
  wg_mpool_print_aux(db, ptr, 0, 1);
}

// wg_mpool_print_aux
// file dbmpool.c line 400
static void wg_mpool_print_aux(void *db, void *ptr, signed int depth, signed int pflag)
{
  signed int type;
  char *p;
  signed int count;
  signed int ppflag = 0;
  signed int i;
  void *curptr;
  signed int return_value_wg_isatom_16;
  _Bool tmp_if_expr_3;
  char *return_value_strchr_2;
  _Bool tmp_if_expr_5;
  char *return_value_strchr_4;
  _Bool tmp_if_expr_8;
  char *return_value_strchr_7;
  _Bool tmp_if_expr_10;
  char *return_value_strchr_9;
  signed int return_value_wg_listtreecount_11;
  _Bool tmp_if_expr_13;
  signed int return_value_wg_isatom_12;
  if(ptr == NULL)
    printf("()");

  else
  {
    return_value_wg_isatom_16=wg_isatom(db, ptr);
    if(!(return_value_wg_isatom_16 == 0))
    {
      type=wg_atomtype(db, ptr);
      switch(type)
      {
        case 0:
        {
          printf("_:");
          break;
        }
        case 1:
        {
          printf("n:");
          break;
        }
        case 2:
        {
          printf("r:");
          break;
        }
        case 3:
        {
          printf("i:");
          break;
        }
        case 4:
        {
          printf("d:");
          break;
        }
        case 5:
        {
          printf("s:");
          break;
        }
        case 6:
        {
          printf("x:");
          break;
        }
        case 7:
        {
          printf("u:");
          break;
        }
        case 8:
        {
          printf("b:");
          break;
        }
        case 9:
        {
          printf("c:");
          break;
        }
        case 10:
        {
          printf("f:");
          break;
        }
        case 11:
        {
          printf("date:");
          break;
        }
        case 12:
        {
          printf("time:");
          break;
        }
        case 13:
        {
          printf("a:");
          break;
        }
        case 14:
        {
          printf("?:");
          break;
        }
        default:
          printf("!:");
      }
      p=wg_atomstr1(db, ptr);
      if(!(p == ((char *)NULL)))
      {
        char *return_value_strchr_1;
        return_value_strchr_1=strchr(p, 32);
        if(!(return_value_strchr_1 == ((char *)NULL)))
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value_strchr_2=strchr(p, 10);
          tmp_if_expr_3 = return_value_strchr_2 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          return_value_strchr_4=strchr(p, 9);
          tmp_if_expr_5 = return_value_strchr_4 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
          printf("\"%s\"", p);

        else
          printf("%s", p);
      }

      else
        printf("\"\"");
      p=wg_atomstr2(db, ptr);
      if(!(p == ((char *)NULL)))
      {
        char *return_value_strchr_6;
        return_value_strchr_6=strchr(p, 32);
        if(!(return_value_strchr_6 == ((char *)NULL)))
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_strchr_7=strchr(p, 10);
          tmp_if_expr_8 = return_value_strchr_7 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
          tmp_if_expr_10 = (_Bool)1;

        else
        {
          return_value_strchr_9=strchr(p, 9);
          tmp_if_expr_10 = return_value_strchr_9 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_10)
          printf("^^\"%s\"", p);

        else
          printf("^^%s", p);
      }

    }

    else
    {
      if(!(pflag == 0))
      {
        return_value_wg_listtreecount_11=wg_listtreecount(db, ptr);
        if(return_value_wg_listtreecount_11 >= 11)
          ppflag = 1;

      }

      printf("(");
      curptr = ptr;
      count = 0;
      do
      {
        if(!(curptr == NULL))
        {
          return_value_wg_isatom_12=wg_isatom(db, curptr);
          tmp_if_expr_13 = !(return_value_wg_isatom_12 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_13 = (_Bool)0;
        if(!tmp_if_expr_13)
          break;

        if(count >= 1)
        {
          if(!(ppflag == 0))
          {
            printf("\n");
            i = 0;
            for( ; !(i >= depth); i = i + 1)
              printf(" ");
          }

          printf(" ");
        }

        void *return_value_wg_first_14;
        return_value_wg_first_14=wg_first(db, curptr);
        wg_mpool_print_aux(db, return_value_wg_first_14, depth + 1, 0);
        curptr=wg_rest(db, curptr);
        count = count + 1;
      }
      while((_Bool)1);
      signed int return_value_wg_isatom_15;
      return_value_wg_isatom_15=wg_isatom(db, curptr);
      if(!(return_value_wg_isatom_15 == 0))
      {
        printf(" . ");
        wg_mpool_print_aux(db, curptr, depth + 1, ppflag);
      }

      printf(")");
      if(!(ppflag == 0))
        printf("\n");

    }
  }
}

// wg_multi_column_to_index_id
// file dbindex.c line 2396
signed long int wg_multi_column_to_index_id(void *db, signed long int *columns, signed long int col_count, signed long int type, signed long int *matchrec, signed long int reclen)
{
  signed int i;
  signed long int template_offset = (signed long int)0;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int *ilist;
  struct anonymous_20 *ilistelem;
  signed long int sorted_cols[10l];
  _Bool tmp_if_expr_2;
  if(!(matchrec == ((signed long int *)NULL)))
  {
    if(reclen == 0l)
    {
      show_index_error(db, "Zero-length match record not allowed");
      return (signed long int)-1;
    }

    if(reclen >= 129l)
    {
      show_index_error_nr(db, "Match record too long, max", (signed long int)(127 + 1));
      return (signed long int)-1;
    }

    template_offset=find_index_template(db, matchrec, reclen);
    if(!(template_offset == 0l))
      goto __CPROVER_DUMP_L3;

    return (signed long int)-1;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    if(!(col_count >= 1l))
    {
      show_index_error(db, "need at least one indexed column");
      return (signed long int)-1;
    }

    else
      if(col_count >= 11l)
      {
        show_index_error_nr(db, "Max allowed indexed fields", (signed long int)10);
        return (signed long int)-1;
      }

    if(col_count >= 2l)
    {
      signed long int return_value_sort_columns_1;
      return_value_sort_columns_1=sort_columns(sorted_cols, columns, col_count);
      if(!(return_value_sort_columns_1 >= col_count))
      {
        show_index_error(db, "Duplicate columns not allowed");
        return (signed long int)-1;
      }

    }

    else
      sorted_cols[(signed long int)0] = columns[(signed long int)0];
    i = 0;
    for( ; !((signed long int)i >= col_count); i = i + 1)
      if(sorted_cols[(signed long int)i] >= 128l)
      {
        show_index_error_nr(db, "Max allowed column number", (signed long int)127);
        return (signed long int)-1;
      }

    ilist = &dbh->index_control_area_header.index_table[sorted_cols[(signed long int)0]];
    for( ; !(*ilist == 0l); ilist = &ilistelem->cdr)
    {
      ilistelem = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *ilist);
      if(!(ilistelem->car == 0l))
      {
        struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + ilistelem->car);
        if(type == 0l)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = type == hdr->type ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
        {
          if(hdr->template_offset == template_offset)
          {
            if(hdr->fields == col_count)
            {
              i = 0;
              for( ; !((signed long int)i >= col_count); i = i + 1)
                if(!(hdr->rec_field_index[(signed long int)i] == sorted_cols[(signed long int)i]))
                  goto nextindex;

              return ilistelem->car;
            }

          }

        }

      }


    nextindex:
      ;
    }
    return (signed long int)-1;
  }
}

// wg_parse_and_encode
// file dbutil.c line 469
signed long int wg_parse_and_encode(void *db, char *buf)
{
  signed long int intdata = (signed long int)0;
  double doubledata = (double)0;
  signed long int encoded = (signed long int)0xff;
  signed long int res = (signed long int)0;
  signed long int return_value_parse_input_type_1;
  return_value_parse_input_type_1=parse_input_type(db, buf, &intdata, &doubledata, &res);
  switch(return_value_parse_input_type_1)
  {
    case (signed long int)1:
    {
      encoded = (signed long int)0;
      break;
    }
    case (signed long int)3:
    {
      encoded=wg_encode_int(db, intdata);
      break;
    }
    case (signed long int)4:
    {
      encoded=wg_encode_double(db, doubledata);
      break;
    }
    case (signed long int)5:
    {
      encoded=wg_encode_str(db, buf, (char *)(void *)0);
      break;
    }
    case (signed long int)11:
    {
      encoded=wg_encode_date(db, (signed int)res);
      break;
    }
    case (signed long int)12:
      encoded=wg_encode_time(db, (signed int)res);
  }
  return encoded;
}

// wg_parse_and_encode_param
// file dbutil.c line 507
signed long int wg_parse_and_encode_param(void *db, char *buf)
{
  signed long int intdata = (signed long int)0;
  double doubledata = (double)0;
  signed long int encoded = (signed long int)0xff;
  signed long int res = (signed long int)0;
  signed long int return_value_parse_input_type_1;
  return_value_parse_input_type_1=parse_input_type(db, buf, &intdata, &doubledata, &res);
  switch(return_value_parse_input_type_1)
  {
    case (signed long int)1:
    {
      encoded = (signed long int)0;
      break;
    }
    case (signed long int)3:
    {
      encoded=wg_encode_query_param_int(db, intdata);
      break;
    }
    case (signed long int)4:
    {
      encoded=wg_encode_query_param_double(db, doubledata);
      break;
    }
    case (signed long int)5:
    {
      encoded=wg_encode_query_param_str(db, buf, (char *)(void *)0);
      break;
    }
    case (signed long int)11:
    {
      encoded=wg_encode_query_param_date(db, (signed int)res);
      break;
    }
    case (signed long int)12:
      encoded=wg_encode_query_param_time(db, (signed int)res);
  }
  return encoded;
}

// wg_parse_json_document
// file dbjson.c line 327
signed long int wg_parse_json_document(void *db, char *buf, void **document)
{
  void *rec = (void *)0;
  signed long int retv;
  retv=run_json_parser(db, buf, &input_cb, 0, 1, &rec);
  if(!(document == ((void **)NULL)))
    *document = rec;

  return retv;
}

// wg_parse_json_file
// file dbjson.c line 181
signed long int wg_parse_json_file(void *db, char *filename)
{
  char *buf = (char *)(void *)0;
  struct _IO_FILE *f = (struct _IO_FILE *)(void *)0;
  signed int count = 0;
  signed int result = 0;
  signed int bufsize = 0;
  signed int depth = -1;
  struct yajl_handle_t *hand = (struct yajl_handle_t *)(void *)0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)16384);
  buf = (char *)return_value_malloc_1;
  if(buf == ((char *)NULL))
  {
    signed long int return_value_show_json_error_2;
    return_value_show_json_error_2=show_json_error(db, "Failed to allocate memory");
    return return_value_show_json_error_2;
  }

  bufsize = 16384;
  if(filename == ((char *)NULL))
  {
    printf("reading JSON from stdin, press CTRL-D when done\n");
    fflush(stdout);
    f = stdin;
  }

  else
  {
    f=fopen(filename, "r");
    if(f == ((struct _IO_FILE *)NULL))
    {
      show_json_error_fn(db, "Failed to open input", filename);
      result = -1;
      goto done;
    }

  }
  hand=yajl_alloc(&validate_cb, (struct anonymous_3 *)(void *)0, (void *)&depth);
  yajl_config(hand, (enum anonymous_4)yajl_allow_comments, 1);
  signed int return_value_feof_3;
  do
  {
    return_value_feof_3=feof(f);
    if(!(return_value_feof_3 == 0))
      break;

    signed int rd;
    unsigned long int return_value_fread_4;
    return_value_fread_4=fread((void *)&buf[(signed long int)count], (unsigned long int)1, (unsigned long int)16384, f);
    rd = (signed int)return_value_fread_4;
    if(rd == 0)
    {
      signed int return_value_feof_5;
      return_value_feof_5=feof(f);
      if(return_value_feof_5 == 0)
      {
        show_json_error_byte(db, "Read error", count);
        result = -1;
      }

      goto done;
    }

    enum anonymous_27 return_value_yajl_parse_6;
    return_value_yajl_parse_6=yajl_parse(hand, (unsigned char *)&buf[(signed long int)count], (unsigned long int)rd);
    if(!((signed int)return_value_yajl_parse_6 == yajl_status_ok))
    {
      unsigned char *errtxt;
      errtxt=yajl_get_error(hand, 1, (unsigned char *)&buf[(signed long int)count], (unsigned long int)rd);
      show_json_error(db, (char *)errtxt);
      yajl_free_error(hand, errtxt);
      result = -1;
      goto done;
    }

    count = count + rd;
    if(count >= bufsize)
    {
      void *tmp;
      tmp=realloc((void *)buf, (unsigned long int)(bufsize + 16384));
      if(tmp == NULL)
      {
        show_json_error(db, "Failed to allocate additional memory");
        result = -1;
        goto done;
      }

      buf = (char *)tmp;
      bufsize = bufsize + 16384;
    }

  }
  while((_Bool)1);
  enum anonymous_27 return_value_yajl_complete_parse_7;
  return_value_yajl_complete_parse_7=yajl_complete_parse(hand);
  signed long int return_value_wg_parse_json_document_8;
  if(!((signed int)return_value_yajl_complete_parse_7 == yajl_status_ok))
  {
    show_json_error(db, "Syntax error (JSON not properly terminated?)");
    result = -1;
  }

  else
    if(depth == -1)
    {
      show_json_error(db, "Top-level array or object is required in JSON");
      result = -1;
    }

    else
    {
      buf[(signed long int)count] = (char)0;
      return_value_wg_parse_json_document_8=wg_parse_json_document(db, buf, (void **)(void *)0);
      result = (signed int)return_value_wg_parse_json_document_8;
    }

done:
  ;
  if(!(buf == ((char *)NULL)))
    free((void *)buf);

  if(!(filename == ((char *)NULL)) && !(f == ((struct _IO_FILE *)NULL)))
    fclose(f);

  if(!(hand == ((struct yajl_handle_t *)NULL)))
    yajl_free(hand);

  return (signed long int)result;
}

// wg_parse_json_fragment
// file dbjson.c line 343
signed long int wg_parse_json_fragment(void *db, char *buf, void **document)
{
  void *rec = (void *)0;
  signed long int retv;
  retv=run_json_parser(db, buf, &input_cb, 0, 0, &rec);
  if(!(document == ((void **)NULL)))
    *document = rec;

  return retv;
}

// wg_parse_json_param
// file dbjson.c line 361
signed long int wg_parse_json_param(void *db, char *buf, void **document)
{
  if(document == ((void **)NULL))
  {
    signed long int return_value_show_json_error_1;
    return_value_show_json_error_1=show_json_error(db, "wg_parse_json_param: arg 3 cannot be NULL");
    return return_value_show_json_error_1;
  }

  signed long int return_value_run_json_parser_2;
  return_value_run_json_parser_2=run_json_parser(db, buf, &input_cb, 1, 1, document);
  return return_value_run_json_parser_2;
}

// wg_pretty_print_memsize
// file dbutil.c line 1254
void wg_pretty_print_memsize(signed long int memsz, char *buf, unsigned long int buflen)
{
  if(!(memsz >= 1000l))
    snprintf(buf, buflen - (unsigned long int)1, "%d bytes", (signed int)memsz);

  else
    if(!(memsz >= 1000000l))
      snprintf(buf, buflen - (unsigned long int)1, "%d kB", (signed int)(memsz / (signed long int)1000));

    else
      if(!(memsz >= 1000000000l))
        snprintf(buf, buflen - (unsigned long int)1, "%d MB", (signed int)(memsz / (signed long int)1000000));

      else
        snprintf(buf, buflen - (unsigned long int)1, "%d GB", (signed int)(memsz / (signed long int)1000000000));
  buf[(signed long int)(buflen - (unsigned long int)1)] = (char)0;
}

// wg_print_code_version
// file dbmem.h line 63
void wg_print_code_version(void)
{
  signed int i = 1;
  char *i_bytes = (char *)&i;
  printf("\nlibwgdb version: %d.%d.%d\n", 0, 7, 3);
  printf("byte order: %s endian\n", (signed int)i_bytes[(signed long int)0] == 1 ? "little" : "big");
  printf("compile-time features:\n  64-bit encoded data: %s\n  queued locks: %s\n  chained nodes in T-tree: %s\n  record backlinking: %s\n  child databases: %s\n  index templates: %s\n", ((0x1 | 0x2 | 0x4 | 0x8 | 0x0 | 0x20) & 0x1) != 0 ? "yes" : "no", ((0x1 | 0x2 | 0x4 | 0x8 | 0x0 | 0x20) & 0x2) != 0 ? "yes" : "no", ((0x1 | 0x2 | 0x4 | 0x8 | 0x0 | 0x20) & 0x4) != 0 ? "yes" : "no", ((0x1 | 0x2 | 0x4 | 0x8 | 0x0 | 0x20) & 0x8) != 0 ? "yes" : "no", ((0x1 | 0x2 | 0x4 | 0x8 | 0x0 | 0x20) & 0x10) != 0 ? "yes" : "no", ((0x1 | 0x2 | 0x4 | 0x8 | 0x0 | 0x20) & 0x20) != 0 ? "yes" : "no");
}

// wg_print_db
// file dbutil.c line 116
void wg_print_db(void *db)
{
  void *rec;
  rec=wg_get_first_record(db);
  while(!(rec == NULL))
  {
    wg_print_record(db, (signed long int *)rec);
    printf("\n");
    rec=wg_get_next_record(db, rec);
  }
}

// wg_print_header_version
// file dbmem.h line 64
void wg_print_header_version(struct _db_memsegment_header *dbh, signed int verbose)
{
  signed int version;
  signed int features;
  signed int magic = 1232319011;
  char *magic_bytes = (char *)&magic;
  char *header_bytes = (char *)dbh;
  char magic_lsb = (char)(1232319011 & 0xff);
  _Bool tmp_if_expr_1;
  if(*magic_bytes == header_bytes[3l])
    tmp_if_expr_1 = magic_bytes[(signed long int)1] == header_bytes[(signed long int)2] ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = magic_bytes[(signed long int)2] == header_bytes[(signed long int)1] ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = magic_bytes[(signed long int)3] == header_bytes[(signed long int)0] ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  if(tmp_if_expr_3)
  {
    char *f1 = (char *)&dbh->version;
    char *t1 = (char *)&version;
    char *f2 = (char *)&dbh->features;
    char *t2 = (char *)&features;
    signed int i = 0;
    for( ; !(i >= 4); i = i + 1)
    {
      t1[(signed long int)i] = f1[(signed long int)(3 - i)];
      t2[(signed long int)i] = f2[(signed long int)(3 - i)];
    }
  }

  else
  {
    version = dbh->version;
    features = dbh->features;
  }
  if(!(verbose == 0))
  {
    printf("\nheader version: %d.%d.%d\n", version & 0xff, version >> 8 & 0xff, version >> 16 & 0xff);
    printf("byte order: %s endian\n", header_bytes[(signed long int)0] == magic_lsb ? "little" : "big");
    printf("compile-time features:\n  64-bit encoded data: %s\n  queued locks: %s\n  chained nodes in T-tree: %s\n  record backlinking: %s\n  child databases: %s\n  index templates: %s\n", (features & 0x1) != 0 ? "yes" : "no", (features & 0x2) != 0 ? "yes" : "no", (features & 0x4) != 0 ? "yes" : "no", (features & 0x8) != 0 ? "yes" : "no", (features & 0x10) != 0 ? "yes" : "no", (features & 0x20) != 0 ? "yes" : "no");
  }

  else
    printf("%d.%d.%d%s\n", version & 0xff, version >> 8 & 0xff, version >> 16 & 0xff, (features & 0x1) != 0 ? " (64-bit)" : "");
}

// wg_print_json_document
// file dbjson.c line 730
void wg_print_json_document(void *db, void *cb, void *cb_ctx, void *document)
{
  struct yajl_gen_t *g;
  if((16l & ((signed long int *)document)[1l]) == 0l)
    show_json_error(db, "Given record is not a document");

  else
  {
    g=yajl_gen_alloc((const struct anonymous_3 *)(void *)0);
    yajl_gen_config(g, (enum anonymous_32)yajl_gen_beautify, 1);
    if(!(cb == NULL))
      yajl_gen_config(g, (enum anonymous_32)yajl_gen_print_callback, (void (**)(void *, const char *, unsigned long int))cb, cb_ctx);

    else
      yajl_gen_config(g, (enum anonymous_32)yajl_gen_print_callback, print_cb, (void *)stdout);
    pretty_print_json(db, &g, document);
    yajl_gen_free(g);
  }
}

// wg_print_record
// file dbutil.c line 130
void wg_print_record(void *db, signed long int *rec)
{
  signed long int len;
  signed long int enc;
  signed int i;
  char strbuf[256l];
  if(rec == ((signed long int *)NULL))
    printf("<null rec pointer>\n");

  else
  {
    len=wg_get_record_len(db, (void *)rec);
    printf("[");
    i = 0;
    for( ; !((signed long int)i >= len); i = i + 1)
    {
      if(!(i == 0))
        printf(",");

      enc=wg_get_field(db, (void *)rec, (signed long int)i);
      wg_snprint_value(db, enc, strbuf, 255);
      printf("%s", (const void *)strbuf);
    }
    printf("]");
  }
}

// wg_register_external_db
// file dballoc.c line 1353
signed long int wg_register_external_db(void *db, void *extdb)
{
  show_dballoc_error(db, "child database support is not enabled");
  return (signed long int)-1;
}

// wg_remove_from_strhash
// file dbhash.h line 54
signed long int wg_remove_from_strhash(void *db, signed long int longstr)
{
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int type;
  signed long int *extrastrptr;
  char *extrastr;
  char *data;
  signed long int length;
  signed long int hash;
  signed long int chainoffset;
  signed long int hashchain;
  signed long int nextchain;
  signed long int offset;
  signed long int *objptr;
  signed long int fldval;
  signed long int objsize;
  signed long int strsize;
  signed long int *typeptr;
  offset = longstr & (signed long int)~0x7;
  objptr = (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + offset);
  extrastrptr = (signed long int *)((char *)objptr + (signed long int)((unsigned long int)5 * sizeof(signed long int) /*8ul*/ ));
  fldval = *extrastrptr;
  if(fldval == 0l)
    extrastr = (char *)(void *)0;

  else
    extrastr=wg_decode_str(db, fldval);
  data = (char *)objptr + (signed long int)((unsigned long int)6 * sizeof(signed long int) /*8ul*/ );
  signed long int tmp_if_expr_2;
  signed long int tmp_if_expr_1;
  if(!((-4l & *objptr) >= 33l))
    tmp_if_expr_2 = (signed long int)4 * (signed long int)sizeof(signed long int) /*8ul*/ ;

  else
  {
    if(!((-4l & *objptr) % 8l == 0l))
      tmp_if_expr_1 = (*objptr & (signed long int)~3) + (signed long int)4;

    else
      tmp_if_expr_1 = *objptr & (signed long int)~3;
    tmp_if_expr_2 = tmp_if_expr_1;
  }
  objsize = tmp_if_expr_2;
  strsize = objsize - ((objptr[(signed long int)1] & (signed long int)0xFF00) >> 8);
  length = strsize;
  typeptr = (signed long int *)((char *)objptr + (signed long int)((unsigned long int)+1 * sizeof(signed long int) /*8ul*/ ));
  type = *typeptr & (signed long int)0xFF;
  signed int return_value_wg_hash_typedstr_3;
  return_value_wg_hash_typedstr_3=wg_hash_typedstr(db, data, extrastr, type, length);
  hash = (signed long int)return_value_wg_hash_typedstr_3;
  chainoffset = (signed long int)((unsigned long int)dbh->strhash_area_header.arraystart + sizeof(signed long int) /*8ul*/  * (unsigned long int)hash);
  hashchain = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + chainoffset));
  for( ; !(hashchain == 0l); hashchain = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + chainoffset)))
  {
    if(hashchain == longstr)
    {
      nextchain = *((signed long int *)((char *)((struct anonymous_6 *)db)->db + (signed long int)((unsigned long int)(hashchain & (signed long int)~0x7) + (unsigned long int)4 * sizeof(signed long int) /*8ul*/ )));
      *((signed long int *)((char *)((struct anonymous_6 *)db)->db + chainoffset)) = nextchain;
      return (signed long int)0;
    }

    chainoffset = (signed long int)((unsigned long int)(hashchain & (signed long int)~0x7) + (unsigned long int)4 * sizeof(signed long int) /*8ul*/ );
  }
  show_consistency_error_nr(db, "string not found in hash during deletion, offset", offset);
  return (signed long int)-1;
}

// wg_replay_log
// file dblog.c line 870
signed long int wg_replay_log(void *db, char *filename)
{
  signed long int return_value_show_log_error_1;
  return_value_show_log_error_1=show_log_error(db, "Logging is disabled");
  return return_value_show_log_error_1;
}

// wg_rest
// file dbmpool.c line 322
void * wg_rest(void *db, void *ptr)
{
  return (void *)((signed long int *)ptr)[(signed long int)1];
}

// wg_right_strhash_bucket
// file dbhash.c line 185
signed int wg_right_strhash_bucket(void *db, signed long int longstr, char *cstr, char *cextrastr, signed long int ctype, signed long int cstrsize)
{
  char *str;
  char *extrastr;
  signed int strsize;
  signed long int type;
  type=wg_get_encoded_type(db, longstr);
  signed int return_value_memcmp_2;
  signed int return_value_strcmp_3;
  if(!(type == ctype))
    return 0;

  else
  {
    signed long int return_value_wg_decode_str_len_1;
    return_value_wg_decode_str_len_1=wg_decode_str_len(db, longstr);
    strsize = (signed int)(return_value_wg_decode_str_len_1 + (signed long int)1);
    if(!((signed long int)strsize == cstrsize))
      return 0;

    else
    {
      str=wg_decode_str(db, longstr);
      if(str == ((char *)NULL) && !(cstr == ((char *)NULL)) || cstr == ((char *)NULL) && !(str == ((char *)NULL)))
        return 0;

      else
        if(!(cstr == ((char *)NULL)))
        {
          return_value_memcmp_2=memcmp((const void *)str, (const void *)cstr, (unsigned long int)cstrsize);
          if(return_value_memcmp_2 == 0)
            goto __CPROVER_DUMP_L4;

          return 0;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          extrastr=wg_decode_str_lang(db, longstr);
          if(extrastr == ((char *)NULL) && !(cextrastr == ((char *)NULL)) || cextrastr == ((char *)NULL) && !(extrastr == ((char *)NULL)))
            return 0;

          else
            if(!(cextrastr == ((char *)NULL)))
            {
              return_value_strcmp_3=strcmp(extrastr, cextrastr);
              if(return_value_strcmp_3 == 0)
                goto __CPROVER_DUMP_L6;

              return 0;
            }

            else
            {

            __CPROVER_DUMP_L6:
              ;
              return 1;
            }
        }
    }
  }
}

// wg_search_hash
// file dbindex.c line 1692
signed long int wg_search_hash(void *db, signed long int index_id, signed long int *values, signed long int count)
{
  struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + index_id);
  signed long int type;
  type=wg_get_index_type(db, index_id);
  signed long int return_value_show_index_error_1;
  if(!(type >= 0l))
    return type;

  else
    if(!(type == 60l) && !(type == 61l))
    {
      return_value_show_index_error_1=show_index_error(db, "wg_search_hash: Not a hash index");
      return return_value_show_index_error_1;
    }

    else
      if(!(hdr->fields == count))
      {
        show_index_error(db, "Number of indexed fields does not match");
        return (signed long int)-1;
      }

      else
      {
        signed long int return_value_hash_recurse_2;
        return_value_hash_recurse_2=hash_recurse(db, hdr, (char *)(void *)0, (signed long int)0, values, count, (void *)0, (signed long int)3, (signed long int)0);
        return return_value_hash_recurse_2;
      }
}

// wg_search_tnode_first
// file dbindex.c line 1325
signed long int wg_search_tnode_first(void *db, signed long int nodeoffset, signed long int key, signed long int column)
{
  signed long int i;
  signed long int encoded;
  struct wg_tnode *node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + nodeoffset);
  i = (signed long int)0;
  signed long int tmp_if_expr_2;
  signed long int return_value_wg_compare_1;
  for( ; !(i >= (signed long int)node->number_of_elements); i = i + 1l)
  {
    encoded=wg_get_field(db, (void *)((char *)((struct anonymous_6 *)db)->db + node->array_of_values[i]), column);
    if(encoded == key)
      tmp_if_expr_2 = (signed long int)0;

    else
    {
      return_value_wg_compare_1=wg_compare(db, encoded, key, 7);
      tmp_if_expr_2 = return_value_wg_compare_1;
    }
    if(!(tmp_if_expr_2 == -1l))
      return i;

  }
  return (signed long int)-1;
}

// wg_search_tnode_last
// file dbindex.c line 1348
signed long int wg_search_tnode_last(void *db, signed long int nodeoffset, signed long int key, signed long int column)
{
  signed long int i;
  signed long int encoded;
  struct wg_tnode *node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + nodeoffset);
  i = (signed long int)((signed int)node->number_of_elements - 1);
  signed long int tmp_if_expr_2;
  signed long int return_value_wg_compare_1;
  for( ; i >= 0l; i = i - 1l)
  {
    encoded=wg_get_field(db, (void *)((char *)((struct anonymous_6 *)db)->db + node->array_of_values[i]), column);
    if(encoded == key)
      tmp_if_expr_2 = (signed long int)0;

    else
    {
      return_value_wg_compare_1=wg_compare(db, encoded, key, 7);
      tmp_if_expr_2 = return_value_wg_compare_1;
    }
    if(!(tmp_if_expr_2 == 1l))
      return i;

  }
  return (signed long int)-1;
}

// wg_search_ttree_index
// file dbindex.c line 1042
signed long int wg_search_ttree_index(void *db, signed long int index_id, signed long int key)
{
  signed int i;
  signed long int rootoffset;
  signed long int bnodetype;
  signed long int bnodeoffset;
  signed long int rowoffset;
  signed long int column;
  struct wg_tnode *node;
  struct anonymous_21 *hdr = (struct anonymous_21 *)(void *)((char *)((struct anonymous_6 *)db)->db + index_id);
  rootoffset = hdr->ctl.t.offset_root_node;
  signed long int tmp_if_expr_4;
  signed long int return_value_wg_get_field_2;
  signed long int return_value_wg_compare_3;
  signed long int tmp_if_expr_6;
  signed long int return_value_wg_compare_5;
  if(rootoffset == 0l)
  {
    fprintf(stderr, "index at offset %d does not exist\n", (signed int)index_id);
    return (signed long int)-1;
  }

  else
  {
    bnodeoffset=wg_search_ttree_leftmost(db, rootoffset, key, &bnodetype, (struct wg_tnode *)(void *)0);
    node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + bnodeoffset);
    if(!(bnodetype == 0l))
      return (signed long int)0;

    else
    {
      column = hdr->rec_field_index[(signed long int)0];
      do
      {
        i = 0;
        for( ; !(i >= (signed int)node->number_of_elements); i = i + 1)
        {
          rowoffset = node->array_of_values[(signed long int)i];
          signed long int return_value_wg_get_field_1;
          return_value_wg_get_field_1=wg_get_field(db, (void *)((char *)((struct anonymous_6 *)db)->db + rowoffset), column);
          if(return_value_wg_get_field_1 == key)
            tmp_if_expr_4 = (signed long int)0;

          else
          {
            return_value_wg_get_field_2=wg_get_field(db, (void *)((char *)((struct anonymous_6 *)db)->db + rowoffset), column);
            return_value_wg_compare_3=wg_compare(db, return_value_wg_get_field_2, key, 7);
            tmp_if_expr_4 = return_value_wg_compare_3;
          }
          if(tmp_if_expr_4 == 0l)
            return rowoffset;

        }
        bnodeoffset = node->succ_offset;
        if(bnodeoffset == 0l)
          break;

        node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + bnodeoffset);
        if(node->current_min == key)
          tmp_if_expr_6 = (signed long int)0;

        else
        {
          return_value_wg_compare_5=wg_compare(db, node->current_min, key, 7);
          tmp_if_expr_6 = return_value_wg_compare_5;
        }
        if(tmp_if_expr_6 == 1l)
          break;

      }
      while((_Bool)1);
      return (signed long int)0;
    }
  }
}

// wg_search_ttree_leftmost
// file dbindex.c line 1257
signed long int wg_search_ttree_leftmost(void *db, signed long int rootoffset, signed long int key, signed long int *result, struct wg_tnode *lb_node)
{
  struct wg_tnode *node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + rootoffset);
  signed long int tmp_if_expr_8;
  signed long int return_value_wg_compare_7;
  if(key == node->current_max)
    tmp_if_expr_8 = (signed long int)0;

  else
  {
    return_value_wg_compare_7=wg_compare(db, key, node->current_max, 7);
    tmp_if_expr_8 = return_value_wg_compare_7;
  }
  signed long int tmp_if_expr_3;
  signed long int return_value_wg_compare_2;
  signed long int tmp_if_expr_6;
  signed long int return_value_wg_compare_5;
  if(tmp_if_expr_8 == 1l)
  {
    if(!(node->right_child_offset == 0l))
    {
      signed long int return_value_wg_search_ttree_leftmost_1;
      return_value_wg_search_ttree_leftmost_1=wg_search_ttree_leftmost(db, node->right_child_offset, key, result, lb_node);
      return return_value_wg_search_ttree_leftmost_1;
    }

    else
      if(!(lb_node == ((struct wg_tnode *)NULL)))
      {
        if(key == lb_node->current_min)
          tmp_if_expr_3 = (signed long int)0;

        else
        {
          return_value_wg_compare_2=wg_compare(db, key, lb_node->current_min, 7);
          tmp_if_expr_3 = return_value_wg_compare_2;
        }
        if(!(tmp_if_expr_3 == -1l))
        {
          *result = (signed long int)0;
          return (signed long int)((char *)lb_node - (char *)((struct anonymous_6 *)db)->db);
        }

      }

    *result = (signed long int)2;
    return rootoffset;
  }

  else
  {
    if(!(node->left_child_offset == 0l))
    {
      signed long int return_value_wg_search_ttree_leftmost_4;
      return_value_wg_search_ttree_leftmost_4=wg_search_ttree_leftmost(db, node->left_child_offset, key, result, node);
      return return_value_wg_search_ttree_leftmost_4;
    }

    else
    {
      if(key == node->current_min)
        tmp_if_expr_6 = (signed long int)0;

      else
      {
        return_value_wg_compare_5=wg_compare(db, key, node->current_min, 7);
        tmp_if_expr_6 = return_value_wg_compare_5;
      }
      if(!(tmp_if_expr_6 == -1l))
      {
        *result = (signed long int)0;
        return rootoffset;
      }

    }
    *result = (signed long int)1;
    return rootoffset;
  }
}

// wg_search_ttree_rightmost
// file dbindex.c line 1180
signed long int wg_search_ttree_rightmost(void *db, signed long int rootoffset, signed long int key, signed long int *result, struct wg_tnode *rb_node)
{
  struct wg_tnode *node = (struct wg_tnode *)(void *)((char *)((struct anonymous_6 *)db)->db + rootoffset);
  signed long int tmp_if_expr_8;
  signed long int return_value_wg_compare_7;
  if(key == node->current_min)
    tmp_if_expr_8 = (signed long int)0;

  else
  {
    return_value_wg_compare_7=wg_compare(db, key, node->current_min, 7);
    tmp_if_expr_8 = return_value_wg_compare_7;
  }
  signed long int tmp_if_expr_3;
  signed long int return_value_wg_compare_2;
  signed long int tmp_if_expr_6;
  signed long int return_value_wg_compare_5;
  if(tmp_if_expr_8 == -1l)
  {
    if(!(node->left_child_offset == 0l))
    {
      signed long int return_value_wg_search_ttree_rightmost_1;
      return_value_wg_search_ttree_rightmost_1=wg_search_ttree_rightmost(db, node->left_child_offset, key, result, rb_node);
      return return_value_wg_search_ttree_rightmost_1;
    }

    else
      if(!(rb_node == ((struct wg_tnode *)NULL)))
      {
        if(key == rb_node->current_max)
          tmp_if_expr_3 = (signed long int)0;

        else
        {
          return_value_wg_compare_2=wg_compare(db, key, rb_node->current_max, 7);
          tmp_if_expr_3 = return_value_wg_compare_2;
        }
        if(!(tmp_if_expr_3 == 1l))
        {
          *result = (signed long int)0;
          return (signed long int)((char *)rb_node - (char *)((struct anonymous_6 *)db)->db);
        }

      }

    *result = (signed long int)1;
    return rootoffset;
  }

  else
  {
    if(!(node->right_child_offset == 0l))
    {
      signed long int return_value_wg_search_ttree_rightmost_4;
      return_value_wg_search_ttree_rightmost_4=wg_search_ttree_rightmost(db, node->right_child_offset, key, result, node);
      return return_value_wg_search_ttree_rightmost_4;
    }

    else
    {
      if(key == node->current_max)
        tmp_if_expr_6 = (signed long int)0;

      else
      {
        return_value_wg_compare_5=wg_compare(db, key, node->current_max, 7);
        tmp_if_expr_6 = return_value_wg_compare_5;
      }
      if(!(tmp_if_expr_6 == 1l))
      {
        *result = (signed long int)0;
        return rootoffset;
      }

    }
    *result = (signed long int)2;
    return rootoffset;
  }
}

// wg_set_atomic_field
// file dbdata.c line 1047
signed long int wg_set_atomic_field(void *db, void *record, signed long int fieldnr, signed long int data)
{
  signed long int *fieldadr;
  signed long int old;
  signed long int r;
  signed int i;
  struct timespec ts;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
  {
    show_data_error_str(db, "wrong database pointer given to ", "wg_set_atomic_field");
    return (signed long int)-1;
  }

  else
  {
    if(!(fieldnr >= 0l))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (*((signed long int *)record) & (signed long int)~3) >> (sizeof(signed long int) /*8ul*/  == (unsigned long int)4 ? 2 : 3) <= fieldnr + (signed long int)3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      show_data_error_str(db, "wrong field number given to ", "wg_set_atomic_field");
      return (signed long int)-2;
    }

    else
    {
      fieldadr = (signed long int *)record + (signed long int)3 + fieldnr;
      i = 0;
      do
      {
        old = *fieldadr;
        r=wg_update_atomic_field(db, record, fieldnr, data, old);
        if(r == 0l)
          return (signed long int)0;

        if(!(r == -15l))
          return r;

        if(i >= 1001)
          return (signed long int)-17;

        if(i % 10 == 0)
        {
          ts.tv_sec = (signed long int)0;
          ts.tv_nsec = (signed long int)(100 + i);
          nanosleep(&ts, (struct timespec *)(void *)0);
        }

        i = i + 1;
      }
      while((_Bool)1);
      return (signed long int)-17;
    }
  }
}

// wg_set_double_field
// file dbdata.c line 938
signed long int wg_set_double_field(void *db, void *record, signed long int fieldnr, double data)
{
  signed long int fielddata;
  fielddata=wg_encode_double(db, data);
  if(fielddata == 255l)
    return (signed long int)-1;

  else
  {
    signed long int return_value_wg_set_field_1;
    return_value_wg_set_field_1=wg_set_field(db, record, fieldnr, fielddata);
    return return_value_wg_set_field_1;
  }
}

// wg_set_field
// file dbdata.c line 610
signed long int wg_set_field(void *db, void *record, signed long int fieldnr, signed long int data)
{
  signed long int *fieldadr;
  signed long int fielddata;
  signed long int *strptr;
  signed long int backlink_list;
  signed long int rec_enc = (signed long int)0xff;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_8;
  if(!tmp_if_expr_1)
  {
    show_data_error_str(db, "wrong database pointer given to ", "wg_set_field");
    return (signed long int)-1;
  }

  else
  {
    if(!(fieldnr >= 0l))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (*((signed long int *)record) & (signed long int)~3) >> (sizeof(signed long int) /*8ul*/  == (unsigned long int)4 ? 2 : 3) <= fieldnr + (signed long int)3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      show_data_error_str(db, "wrong field number given to ", "wg_set_field");
      return (signed long int)-2;
    }

    else
    {
      fieldadr = (signed long int *)record + (signed long int)3 + fieldnr;
      fielddata = *fieldadr;
      if((1l & ((signed long int *)record)[1l]) == 0l)
      {
        if(!(fieldnr >= 128l))
        {
          if(!(dbh->index_control_area_header.index_table[fieldnr] == 0l))
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = dbh->index_control_area_header.index_template_table[fieldnr] != 0l ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_4)
          {
            signed long int return_value_wg_index_del_field_3;
            return_value_wg_index_del_field_3=wg_index_del_field(db, record, fieldnr);
            if(!(return_value_wg_index_del_field_3 >= -1l))
              return (signed long int)-3;

          }

        }

      }

      backlink_list = ((signed long int *)record)[(signed long int)2];
      if(!(backlink_list == 0l))
      {
        signed long int err;
        struct anonymous_20 *next = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + backlink_list);
        rec_enc=wg_encode_record(db, record);
        do
        {
          err=remove_backlink_index_entries(db, (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + next->car), rec_enc, (signed long int)(7 - 1));
          if(!(err == 0l))
            return (signed long int)-4;

          if(next->cdr == 0l)
            break;

          next = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + next->cdr);
        }
        while((_Bool)1);
      }

      signed long int return_value_wg_get_encoded_type_6;
      return_value_wg_get_encoded_type_6=wg_get_encoded_type(db, fielddata);
      if(return_value_wg_get_encoded_type_6 == 2l)
      {
        signed long int *rec;
        void *return_value_wg_decode_record_5;
        return_value_wg_decode_record_5=wg_decode_record(db, fielddata);
        rec = (signed long int *)return_value_wg_decode_record_5;
        signed long int *next_offset = rec + (signed long int)2;
        signed long int parent_offset = (signed long int)((char *)record - (char *)((struct anonymous_6 *)db)->db);
        struct anonymous_20 *old = (struct anonymous_20 *)(void *)0;
        for( ; !(*next_offset == 0l); next_offset = &old->cdr)
        {
          old = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *next_offset);
          if(old->car == parent_offset)
          {
            signed long int old_offset = *next_offset;
            *next_offset = old->cdr;
            wg_free_listcell(db, old_offset);
            goto setfld_backlink_removed;
          }

        }
        show_data_error(db, "Corrupt backlink chain");
        return (signed long int)-4;
      }


    setfld_backlink_removed:
      ;
      if(!((3l & fielddata) == 3l) && !(fielddata == 0l))
        free_field_encoffset(db, fielddata);

      *fieldadr = data;
      if((7l & data) == 4l)
      {
        strptr = (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + (data & (signed long int)~0x7));
        strptr[(signed long int)2] = strptr[(signed long int)2] + 1l;
      }

      if((1l & ((signed long int *)record)[1l]) == 0l)
      {
        if(!(fieldnr >= 128l))
        {
          if(!(dbh->index_control_area_header.index_table[fieldnr] == 0l))
            tmp_if_expr_8 = (_Bool)1;

          else
            tmp_if_expr_8 = dbh->index_control_area_header.index_template_table[fieldnr] != 0l ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_8)
          {
            signed long int return_value_wg_index_add_field_7;
            return_value_wg_index_add_field_7=wg_index_add_field(db, record, fieldnr);
            if(!(return_value_wg_index_add_field_7 >= -1l))
              return (signed long int)-3;

          }

        }

      }

      signed long int return_value_wg_get_encoded_type_10;
      return_value_wg_get_encoded_type_10=wg_get_encoded_type(db, data);
      if(return_value_wg_get_encoded_type_10 == 2l)
      {
        signed long int *wg_set_field__1__8__rec;
        void *return_value_wg_decode_record_9;
        return_value_wg_decode_record_9=wg_decode_record(db, data);
        wg_set_field__1__8__rec = (signed long int *)return_value_wg_decode_record_9;
        signed long int *wg_set_field__1__8__next_offset = wg_set_field__1__8__rec + (signed long int)2;
        signed long int new_offset;
        new_offset=wg_alloc_fixlen_object(db, (void *)&((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->listcell_area_header);
        struct anonymous_20 *new_cell = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + new_offset);
        for( ; !(*wg_set_field__1__8__next_offset == 0l); wg_set_field__1__8__next_offset = &((struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *wg_set_field__1__8__next_offset))->cdr)
          ;
        new_cell->car = (signed long int)((char *)record - (char *)((struct anonymous_6 *)db)->db);
        new_cell->cdr = (signed long int)0;
        *wg_set_field__1__8__next_offset = new_offset;
      }

      if(!(backlink_list == 0l))
      {
        signed long int wg_set_field__1__9__err;
        struct anonymous_20 *wg_set_field__1__9__next = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + backlink_list);
        do
        {
          wg_set_field__1__9__err=restore_backlink_index_entries(db, (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + wg_set_field__1__9__next->car), rec_enc, (signed long int)(7 - 1));
          if(!(wg_set_field__1__9__err == 0l))
            return (signed long int)-4;

          if(wg_set_field__1__9__next->cdr == 0l)
            break;

          wg_set_field__1__9__next = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + wg_set_field__1__9__next->cdr);
        }
        while((_Bool)1);
      }

      return (signed long int)0;
    }
  }
}

// wg_set_int_field
// file ../Db/dbdata.h line 110
signed long int wg_set_int_field(void *db, void *record, signed long int fieldnr, signed long int data)
{
  signed long int fielddata;
  fielddata=wg_encode_int(db, data);
  if(fielddata == 255l)
    return (signed long int)-1;

  else
  {
    signed long int return_value_wg_set_field_1;
    return_value_wg_set_field_1=wg_set_field(db, record, fieldnr, fielddata);
    return return_value_wg_set_field_1;
  }
}

// wg_set_new_field
// file dbdata.c line 814
signed long int wg_set_new_field(void *db, void *record, signed long int fieldnr, signed long int data)
{
  signed long int *fieldadr;
  signed long int *strptr;
  signed long int backlink_list;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  if(!tmp_if_expr_1)
  {
    show_data_error_str(db, "wrong database pointer given to ", "wg_set_field");
    return (signed long int)-1;
  }

  else
  {
    if(!(fieldnr >= 0l))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (*((signed long int *)record) & (signed long int)~3) >> (sizeof(signed long int) /*8ul*/  == (unsigned long int)4 ? 2 : 3) <= fieldnr + (signed long int)3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      show_data_error_str(db, "wrong field number given to ", "wg_set_field");
      return (signed long int)-2;
    }

    else
    {
      fieldadr = (signed long int *)record + (signed long int)3 + fieldnr;
      if(!(*fieldadr == 0l))
      {
        show_data_error(db, "wg_set_new_field called on field that contains data");
        return (signed long int)-2;
      }

      else
      {
        *fieldadr = data;
        if((7l & data) == 4l)
        {
          strptr = (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + (data & (signed long int)~0x7));
          strptr[(signed long int)2] = strptr[(signed long int)2] + 1l;
        }

        if((1l & ((signed long int *)record)[1l]) == 0l)
        {
          if(!(fieldnr >= 128l))
          {
            if(!(dbh->index_control_area_header.index_table[fieldnr] == 0l))
              tmp_if_expr_4 = (_Bool)1;

            else
              tmp_if_expr_4 = dbh->index_control_area_header.index_template_table[fieldnr] != 0l ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_4)
            {
              signed long int return_value_wg_index_add_field_3;
              return_value_wg_index_add_field_3=wg_index_add_field(db, record, fieldnr);
              if(!(return_value_wg_index_add_field_3 >= -1l))
                return (signed long int)-3;

            }

          }

        }

        signed long int return_value_wg_get_encoded_type_6;
        return_value_wg_get_encoded_type_6=wg_get_encoded_type(db, data);
        if(return_value_wg_get_encoded_type_6 == 2l)
        {
          signed long int *rec;
          void *return_value_wg_decode_record_5;
          return_value_wg_decode_record_5=wg_decode_record(db, data);
          rec = (signed long int *)return_value_wg_decode_record_5;
          signed long int *next_offset = rec + (signed long int)2;
          signed long int new_offset;
          new_offset=wg_alloc_fixlen_object(db, (void *)&((struct _db_memsegment_header *)((struct anonymous_6 *)db)->db)->listcell_area_header);
          struct anonymous_20 *new_cell = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + new_offset);
          for( ; !(*next_offset == 0l); next_offset = &((struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + *next_offset))->cdr)
            ;
          new_cell->car = (signed long int)((char *)record - (char *)((struct anonymous_6 *)db)->db);
          new_cell->cdr = (signed long int)0;
          *next_offset = new_offset;
        }

        backlink_list = ((signed long int *)record)[(signed long int)2];
        if(!(backlink_list == 0l))
        {
          signed long int err;
          struct anonymous_20 *next = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + backlink_list);
          signed long int rec_enc;
          rec_enc=wg_encode_record(db, record);
          do
          {
            err=restore_backlink_index_entries(db, (signed long int *)(void *)((char *)((struct anonymous_6 *)db)->db + next->car), rec_enc, (signed long int)(7 - 1));
            if(!(err == 0l))
              return (signed long int)-4;

            if(next->cdr == 0l)
              break;

            next = (struct anonymous_20 *)(void *)((char *)((struct anonymous_6 *)db)->db + next->cdr);
          }
          while((_Bool)1);
        }

        return (signed long int)0;
      }
    }
  }
}

// wg_set_rec_field
// file dbdata.c line 954
signed long int wg_set_rec_field(void *db, void *record, signed long int fieldnr, void *data)
{
  signed long int fielddata;
  fielddata=wg_encode_record(db, data);
  if(fielddata == 255l)
    return (signed long int)-1;

  else
  {
    signed long int return_value_wg_set_field_1;
    return_value_wg_set_field_1=wg_set_field(db, record, fieldnr, fielddata);
    return return_value_wg_set_field_1;
  }
}

// wg_set_str_field
// file dbdata.c line 946
signed long int wg_set_str_field(void *db, void *record, signed long int fieldnr, char *data)
{
  signed long int fielddata;
  fielddata=wg_encode_str(db, data, (char *)(void *)0);
  if(fielddata == 255l)
    return (signed long int)-1;

  else
  {
    signed long int return_value_wg_set_field_1;
    return_value_wg_set_field_1=wg_set_field(db, record, fieldnr, fielddata);
    return return_value_wg_set_field_1;
  }
}

// wg_snprint_value
// file dbutil.h line 61
void wg_snprint_value(void *db, signed long int enc, char *buf, signed int buflen)
{
  signed long int ptrdata;
  signed int intdata;
  signed int len;
  char *strdata;
  char *exdata;
  double doubledata;
  char strbuf[80l];
  buflen = buflen - 1;
  signed long int return_value_wg_get_encoded_type_1;
  return_value_wg_get_encoded_type_1=wg_get_encoded_type(db, enc);
  void *return_value_wg_decode_record_2;
  unsigned long int return_value_strlen_3;
  signed long int return_value_wg_decode_int_4;
  char return_value_wg_decode_char_5;
  signed long int return_value_wg_decode_var_6;
  switch(return_value_wg_get_encoded_type_1)
  {
    case (signed long int)1:
    {
      snprintf(buf, (unsigned long int)buflen, "NULL");
      break;
    }
    case (signed long int)2:
    {
      return_value_wg_decode_record_2=wg_decode_record(db, enc);
      ptrdata = (signed long int)return_value_wg_decode_record_2;
      snprintf(buf, (unsigned long int)buflen, "<rec %x>", (signed int)ptrdata);
      return_value_strlen_3=strlen(buf);
      len = (signed int)return_value_strlen_3;
      if(buflen + -len >= 2)
        snprint_record(db, (signed long int *)ptrdata, buf + (signed long int)len, buflen - len);

      break;
    }
    case (signed long int)3:
    {
      return_value_wg_decode_int_4=wg_decode_int(db, enc);
      intdata = (signed int)return_value_wg_decode_int_4;
      snprintf(buf, (unsigned long int)buflen, "%d", intdata);
      break;
    }
    case (signed long int)4:
    {
      doubledata=wg_decode_double(db, enc);
      snprintf(buf, (unsigned long int)buflen, "%f", doubledata);
      break;
    }
    case (signed long int)10:
    {
      doubledata=wg_decode_fixpoint(db, enc);
      snprintf(buf, (unsigned long int)buflen, "%f", doubledata);
      break;
    }
    case (signed long int)5:
    {
      strdata=wg_decode_str(db, enc);
      snprintf(buf, (unsigned long int)buflen, "\"%s\"", strdata);
      break;
    }
    case (signed long int)7:
    {
      strdata=wg_decode_uri(db, enc);
      exdata=wg_decode_uri_prefix(db, enc);
      if(exdata == ((char *)NULL))
        snprintf(buf, (unsigned long int)buflen, "%s", strdata);

      else
        snprintf(buf, (unsigned long int)buflen, "%s:%s", exdata, strdata);
      break;
    }
    case (signed long int)6:
    {
      strdata=wg_decode_xmlliteral(db, enc);
      exdata=wg_decode_xmlliteral_xsdtype(db, enc);
      snprintf(buf, (unsigned long int)buflen, "\"<xsdtype %s>%s\"", exdata, strdata);
      break;
    }
    case (signed long int)9:
    {
      return_value_wg_decode_char_5=wg_decode_char(db, enc);
      intdata = (signed int)return_value_wg_decode_char_5;
      snprintf(buf, (unsigned long int)buflen, "%c", (char)intdata);
      break;
    }
    case (signed long int)11:
    {
      intdata=wg_decode_date(db, enc);
      wg_strf_iso_datetime(db, intdata, 0, strbuf);
      strbuf[(signed long int)10] = (char)0;
      snprintf(buf, (unsigned long int)buflen, "<raw date %d>%s", intdata, (const void *)strbuf);
      break;
    }
    case (signed long int)12:
    {
      intdata=wg_decode_time(db, enc);
      wg_strf_iso_datetime(db, 1, intdata, strbuf);
      snprintf(buf, (unsigned long int)buflen, "<raw time %d>%s", intdata, strbuf + (signed long int)11);
      break;
    }
    case (signed long int)14:
    {
      return_value_wg_decode_var_6=wg_decode_var(db, enc);
      intdata = (signed int)return_value_wg_decode_var_6;
      snprintf(buf, (unsigned long int)buflen, "?%d", intdata);
      break;
    }
    case (signed long int)13:
    {
      strdata=wg_decode_anonconst(db, enc);
      snprintf(buf, (unsigned long int)buflen, "!%s", strdata);
      break;
    }
    default:
      snprintf(buf, (unsigned long int)buflen, "<unsupported type>");
  }
}

// wg_start_logging
// file dblog.c line 780
signed long int wg_start_logging(void *db)
{
  signed long int return_value_show_log_error_1;
  return_value_show_log_error_1=show_log_error(db, "Logging is disabled");
  return return_value_show_log_error_1;
}

// wg_start_read
// file ../Db/dblock.h line 75
signed long int wg_start_read(void *db)
{
  signed long int return_value_db_tfqueue_rlock_1;
  return_value_db_tfqueue_rlock_1=db_tfqueue_rlock(db, (signed long int)2000);
  return return_value_db_tfqueue_rlock_1;
}

// wg_start_write
// file ../Db/dblock.h line 73
signed long int wg_start_write(void *db)
{
  signed long int return_value_db_tfqueue_wlock_1;
  return_value_db_tfqueue_wlock_1=db_tfqueue_wlock(db, (signed long int)2000);
  return return_value_db_tfqueue_wlock_1;
}

// wg_stop_logging
// file dblog.c line 843
signed long int wg_stop_logging(void *db)
{
  signed long int return_value_show_log_error_1;
  return_value_show_log_error_1=show_log_error(db, "Logging is disabled");
  return return_value_show_log_error_1;
}

// wg_strf_iso_datetime
// file dbdata.c line 1757
signed int wg_strf_iso_datetime(void *db, signed int date, signed int time, char *buf)
{
  unsigned int yr;
  unsigned int mo;
  unsigned int day;
  unsigned int hr;
  unsigned int min;
  unsigned int sec;
  unsigned int spart;
  signed int t = time;
  signed int c;
  hr = (unsigned int)(t / (60 * 60 * 100));
  t = (signed int)((unsigned int)t - hr * (unsigned int)(60 * 60 * 100));
  min = (unsigned int)(t / (60 * 100));
  t = (signed int)((unsigned int)t - min * (unsigned int)(60 * 100));
  sec = (unsigned int)(t / 100);
  t = (signed int)((unsigned int)t - sec * (unsigned int)100);
  spart = (unsigned int)t;
  scalar_to_ymd((signed long int)date, &yr, &mo, &day);
  c=snprintf(buf, (unsigned long int)24, "%04d-%02d-%02dT%02d:%02d:%02d.%02d", yr, mo, day, hr, min, sec, spart);
  return c;
}

// wg_strp_iso_date
// file dbdata.c line 1775
signed int wg_strp_iso_date(void *db, char *inbuf)
{
  signed int sres;
  signed int yr = 0;
  signed int mo = 0;
  signed int day = 0;
  signed int res;
  sres=sscanf(inbuf, "%4d-%2d-%2d", &yr, &mo, &day);
  if(day >= 32 || mo >= 13 || !(day >= 1) || !(mo >= 1) || !(sres >= 3) || !(yr >= 0))
    return -1;

  else
  {
    signed long int return_value_ymd_to_scalar_1;
    return_value_ymd_to_scalar_1=ymd_to_scalar((unsigned int)yr, (unsigned int)mo, (unsigned int)day);
    res = (signed int)return_value_ymd_to_scalar_1;
    return res;
  }
}

// wg_strp_iso_time
// file dbdata.c line 1789
signed int wg_strp_iso_time(void *db, char *inbuf)
{
  signed int sres;
  signed int hr = 0;
  signed int min = 0;
  signed int sec = 0;
  signed int prt = 0;
  sres=sscanf(inbuf, "%2d:%2d:%2d.%2d", &hr, &min, &sec, &prt);
  if(hr >= 25 || min >= 61 || prt >= 100 || sec >= 61 || !(hr >= 0) || !(min >= 0) || !(prt >= 0) || !(sec >= 0) || !(sres >= 3))
    return -1;

  else
    return hr * 60 * 60 * 100 + min * 60 * 100 + sec * 100 + prt;
}

// wg_time_to_hms
// file dbdata.c line 1825
void wg_time_to_hms(void *db, signed int time, signed int *hr, signed int *min, signed int *sec, signed int *prt)
{
  signed int t = time;
  *hr = t / (60 * 60 * 100);
  t = t - *hr * 60 * 60 * 100;
  *min = t / (60 * 100);
  t = t - *min * 60 * 100;
  *sec = t / 100;
  t = t - *sec * 100;
  *prt = t;
}

// wg_update_atomic_field
// file dbdata.c line 1000
signed long int wg_update_atomic_field(void *db, void *record, signed long int fieldnr, signed long int data, signed long int old_data)
{
  signed long int *fieldadr;
  struct _db_memsegment_header *dbh = (struct _db_memsegment_header *)((struct anonymous_6 *)db)->db;
  signed long int tmp;
  _Bool tmp_if_expr_1;
  if(!(((struct anonymous_6 *)db)->db == ((struct _db_memsegment_header *)NULL)))
    tmp_if_expr_1 = *((signed int *)(struct _db_memsegment_header *)((struct anonymous_6 *)db)->db) == 1232319011 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if(!tmp_if_expr_1)
  {
    show_data_error_str(db, "wrong database pointer given to ", "wg_update_atomic_field");
    return (signed long int)-1;
  }

  else
  {
    if(!(fieldnr >= 0l))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (*((signed long int *)record) & (signed long int)~3) >> (sizeof(signed long int) /*8ul*/  == (unsigned long int)4 ? 2 : 3) <= fieldnr + (signed long int)3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      show_data_error_str(db, "wrong field number given to ", "wg_update_atomic_field");
      return (signed long int)-2;
    }

    else
      if(!(data == 0l) && ((3l & data) == 1l || !((3l & data) == 3l) && !(data == 0l)))
        return (signed long int)-10;

      else
        if(!(old_data == 0l) && ((3l & old_data) == 1l || !((3l & old_data) == 3l) && !(old_data == 0l)))
          return (signed long int)-11;

        else
          if((1l & ((signed long int *)record)[1l]) == 0l)
          {
            if(fieldnr >= 128l)
              goto __CPROVER_DUMP_L11;

            if(!(dbh->index_control_area_header.index_table[fieldnr] == 0l))
              tmp_if_expr_3 = (_Bool)1;

            else
              tmp_if_expr_3 = dbh->index_control_area_header.index_template_table[fieldnr] != 0l ? (_Bool)1 : (_Bool)0;
            if(!tmp_if_expr_3)
              goto __CPROVER_DUMP_L11;

            return (signed long int)-13;
          }

          else
          {

          __CPROVER_DUMP_L11:
            ;
            fieldadr = (signed long int *)record + (signed long int)3 + fieldnr;
            tmp=wg_compare_and_swap(fieldadr, old_data, data);
            if(!(tmp == 0l))
              return (signed long int)0;

            else
              return (signed long int)-15;
          }
  }
}

// wg_ymd_to_date
// file dbdata.c line 1802
signed int wg_ymd_to_date(void *db, signed int yr, signed int mo, signed int day)
{
  if(day >= 32 || mo >= 13 || !(day >= 1) || !(mo >= 1) || !(yr >= 0))
    return -1;

  else
  {
    signed long int return_value_ymd_to_scalar_1;
    return_value_ymd_to_scalar_1=ymd_to_scalar((unsigned int)yr, (unsigned int)mo, (unsigned int)day);
    return (signed int)return_value_ymd_to_scalar_1;
  }
}

// writer_thread
// file stresstest.c line 371
void * writer_thread(void *threadarg)
{
  void *db;
  signed int threadid;
  signed int i;
  signed int j;
  signed int cksum;
  void *rec = (void *)0;
  void *frec = (void *)0;
  db = ((struct anonymous_9 *)threadarg)->db;
  threadid = ((struct anonymous_9 *)threadarg)->threadid;
  fprintf(stdout, "Writer thread %d started.\n", threadid);
  pthread_mutex_lock(&twait_mutex);
  twait_cnt = twait_cnt + 1;
  pthread_cond_wait(&twait_cv, &twait_mutex);
  pthread_mutex_unlock(&twait_mutex);
  frec=wg_get_first_record(db);
  i = 0;
  signed long int tmp_post_3;
  for( ; !(i >= 100000); i = i + 1)
  {
    signed long int c = (signed long int)-1;
    signed long int lock_id;
    lock_id=wg_start_write(db);
    if(lock_id == 0l)
    {
      fprintf(stderr, "Writer thread %d: wg_start_write failed.\n", threadid);
      goto writer_done;
    }

    signed long int return_value_wg_get_field_1;
    return_value_wg_get_field_1=wg_get_field(db, frec, (signed long int)0);
    signed long int return_value_wg_decode_int_2;
    return_value_wg_decode_int_2=wg_decode_int(db, return_value_wg_get_field_1);
    cksum = (signed int)return_value_wg_decode_int_2;
    if(!(i == 0))
      rec=wg_get_next_record(db, rec);

    else
      rec = frec;
    if(rec == NULL)
    {
      fprintf(stderr, "Writer thread %d: wg_get_next_record failed.\n", threadid);
      wg_end_write(db, lock_id);
      goto writer_done;
    }

    if(!(i == 0))
      j = 0;

    else
      j = 1;
    for( ; !(j >= 5); j = j + 1)
    {
      tmp_post_3 = c;
      c = c - 1l;
      signed long int return_value_wg_set_int_field_4;
      return_value_wg_set_int_field_4=wg_set_int_field(db, rec, (signed long int)j, tmp_post_3);
      if(!(return_value_wg_set_int_field_4 == 0l))
      {
        fprintf(stderr, "Writer thread %d: int storage error.\n", threadid);
        wg_end_write(db, lock_id);
        goto writer_done;
      }

    }
    cksum = cksum + 1;
    wg_set_int_field(db, frec, (signed long int)0, (signed long int)cksum);
    signed long int return_value_wg_end_write_5;
    return_value_wg_end_write_5=wg_end_write(db, lock_id);
    if(return_value_wg_end_write_5 == 0l)
    {
      fprintf(stderr, "Writer thread %d: wg_end_write failed.\n", threadid);
      goto writer_done;
    }

  }
  fprintf(stdout, "Writer thread %d ended.\n", threadid);

writer_done:
  ;
  pthread_exit((void *)0);
}

// yajl_alloc
// file ../json/yajl_api.h line 136
struct yajl_handle_t * yajl_alloc(const struct anonymous *callbacks, struct anonymous_3 *afs, void *ctx)
{
  struct yajl_handle_t *hand = (struct yajl_handle_t *)(void *)0;
  struct anonymous_3 afsBuffer;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(!(afs == ((struct anonymous_3 *)NULL)))
  {
    if(afs->malloc == ((void * (*)(void *, unsigned long int))NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = afs->realloc == (void * (*)(void *, void *, unsigned long int))(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = afs->free == (void (*)(void *, void *))(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return (struct yajl_handle_t *)(void *)0;

  }

  else
  {
    yajl_set_default_alloc_funcs(&afsBuffer);
    afs = &afsBuffer;
  }
  void *return_value;
  return_value=afs->malloc(afs->ctx, sizeof(struct yajl_handle_t) /*120ul*/ );
  hand = (struct yajl_handle_t *)return_value;
  memcpy((void *)&hand->alloc, (void *)afs, sizeof(struct anonymous_3) /*32ul*/ );
  hand->callbacks = callbacks;
  hand->ctx = ctx;
  hand->lexer = (struct yajl_lexer_t *)(void *)0;
  hand->bytesConsumed = (unsigned long int)0;
  hand->decodeBuf=yajl_buf_alloc(&hand->alloc);
  hand->flags = (unsigned int)0;
  hand->stateStack.stack = (unsigned char *)(void *)0;
  hand->stateStack.size = (unsigned long int)0;
  hand->stateStack.used = (unsigned long int)0;
  hand->stateStack.yaf = &hand->alloc;
  if(hand->stateStack.size == hand->stateStack.used)
  {
    hand->stateStack.size = hand->stateStack.size + (unsigned long int)128;
    void *return_value_1;
    return_value_1=hand->stateStack.yaf->realloc(hand->stateStack.yaf->ctx, (void *)hand->stateStack.stack, hand->stateStack.size);
    hand->stateStack.stack = (unsigned char *)return_value_1;
  }

  unsigned long int tmp_post_3 = hand->stateStack.used;
  hand->stateStack.used = hand->stateStack.used + 1ul;
  hand->stateStack.stack[(signed long int)tmp_post_3] = (unsigned char)yajl_state_start;
  return hand;
}

// yajl_buf_alloc
// file yajl_all.c line 155
static struct yajl_buf_t * yajl_buf_alloc(struct anonymous_3 *alloc)
{
  struct yajl_buf_t *b;
  void *return_value;
  return_value=alloc->malloc(alloc->ctx, sizeof(struct yajl_buf_t) /*32ul*/ );
  b = (struct yajl_buf_t *)return_value;
  memset((void *)b, 0, sizeof(struct yajl_buf_t) /*32ul*/ );
  b->alloc = alloc;
  return b;
}

// yajl_buf_append
// file yajl_all.c line 170
static void yajl_buf_append(struct yajl_buf_t *buf, const void *data, unsigned long int len)
{
  yajl_buf_ensure_available(buf, len);
  if(len >= 1ul)
  {
    /* assertion data != ((void *)0) */
    assert(data != (void *)0);
    memcpy((void *)(buf->data + (signed long int)buf->used), data, len);
    buf->used = buf->used + len;
    buf->data[(signed long int)buf->used] = (unsigned char)0;
  }

}

// yajl_buf_clear
// file yajl_all.c line 181
static void yajl_buf_clear(struct yajl_buf_t *buf)
{
  buf->used = (unsigned long int)0;
  if(!(buf->data == ((unsigned char *)NULL)))
    buf->data[(signed long int)buf->used] = (unsigned char)0;

}

// yajl_buf_data
// file yajl_all.c line 187
static const unsigned char * yajl_buf_data(struct yajl_buf_t *buf)
{
  return buf->data;
}

// yajl_buf_ensure_available
// file yajl_all.c line 132
static void yajl_buf_ensure_available(struct yajl_buf_t *buf, unsigned long int want)
{
  unsigned long int need;
  /* assertion buf != ((void *)0) */
  assert(buf != (struct yajl_buf_t *)(void *)0);
  if(buf->data == ((unsigned char *)NULL))
  {
    buf->len = (unsigned long int)2048;
    void *return_value;
    return_value=buf->alloc->malloc(buf->alloc->ctx, buf->len);
    buf->data = (unsigned char *)return_value;
    buf->data[(signed long int)0] = (unsigned char)0;
  }

  need = buf->len;
  for( ; want >= need + -buf->used; need = need << 1)
    ;
  if(!(need == buf->len))
  {
    void *return_value_1;
    return_value_1=buf->alloc->realloc(buf->alloc->ctx, (void *)buf->data, need);
    buf->data = (unsigned char *)return_value_1;
    buf->len = need;
  }

}

// yajl_buf_free
// file yajl_all.c line 163
static void yajl_buf_free(struct yajl_buf_t *buf)
{
  /* assertion buf != ((void *)0) */
  assert(buf != (struct yajl_buf_t *)(void *)0);
  if(!(buf->data == ((unsigned char *)NULL)))
    buf->alloc->free(buf->alloc->ctx, (void *)buf->data);

  buf->alloc->free(buf->alloc->ctx, (void *)buf);
}

// yajl_buf_len
// file yajl_all.c line 192
static unsigned long int yajl_buf_len(struct yajl_buf_t *buf)
{
  return buf->used;
}

// yajl_complete_parse
// file ../json/yajl_api.h line 218
enum anonymous_27 yajl_complete_parse(struct yajl_handle_t *hand)
{
  if(hand->lexer == ((struct yajl_lexer_t *)NULL))
    hand->lexer=yajl_lex_alloc(&hand->alloc, hand->flags & (unsigned int)yajl_allow_comments, (unsigned int)!((hand->flags & (unsigned int)yajl_dont_validate_strings) != 0u));

  enum anonymous_27 return_value_yajl_do_finish_1;
  return_value_yajl_do_finish_1=yajl_do_finish(hand);
  return return_value_yajl_do_finish_1;
}

// yajl_config
// file ../json/yajl_api.h line 195
signed int yajl_config(struct yajl_handle_t *h, enum anonymous_4 opt, ...)
{
  signed int rv = 1;
  __builtin_va_list ap;
  va_start(ap, opt);
  signed int return_value_gcc_builtin_va_arg_1;
  if((signed int)opt == yajl_allow_comments || (signed int)opt == yajl_dont_validate_strings || (signed int)opt == yajl_allow_trailing_garbage || (signed int)opt == yajl_allow_multiple_values || (signed int)opt == yajl_allow_partial_values)
  {
    return_value_gcc_builtin_va_arg_1=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_1));
    if(!(return_value_gcc_builtin_va_arg_1 == 0))
      h->flags = h->flags | (unsigned int)opt;

    else
      h->flags = h->flags & (unsigned int)~((signed int)opt);
    goto __CPROVER_DUMP_L5;
  }

  rv = 0;

__CPROVER_DUMP_L5:
  ;
  va_end(ap);
  return rv;
}

// yajl_do_finish
// file yajl_all.c line 1684
static enum anonymous_27 yajl_do_finish(struct yajl_handle_t *hand)
{
  enum anonymous_27 stat;
  stat=yajl_do_parse(hand, (const unsigned char *)" ", (unsigned long int)1);
  if(!((signed int)stat == yajl_status_ok))
    return stat;

  else
  {
    /* assertion (hand->stateStack).used > 0 */
    assert(hand->stateStack.used > (unsigned long int)0);
    switch((signed int)hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)])
    {
      case yajl_state_parse_error:

      case yajl_state_lexical_error:
        return (enum anonymous_27)yajl_status_error;
      case yajl_state_got_value:

      case yajl_state_parse_complete:
        return (enum anonymous_27)yajl_status_ok;
      default:
      {
        if((16u & hand->flags) == 0u)
        {
          hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
          hand->parseError = "premature EOF";
          return (enum anonymous_27)yajl_status_error;
        }

        return (enum anonymous_27)yajl_status_ok;
      }
    }
  }
}

// yajl_do_parse
// file yajl_all.c line 1711
static enum anonymous_27 yajl_do_parse(struct yajl_handle_t *hand, const unsigned char *jsonText, unsigned long int jsonTextLen)
{
  enum anonymous_29 tok;
  const unsigned char *buf;
  unsigned long int bufLen;
  unsigned long int *offset = &hand->bytesConsumed;
  *offset = (unsigned long int)0;
  signed int *return_value___errno_location_4;
  _Bool tmp_if_expr_9;
  double return_value___builtin_huge_val_8;
  signed int *return_value___errno_location_6;
  unsigned long int tmp_post_10;
  do
  {
  /* assertion (hand->stateStack).used > 0 */

  around_again:
    ;
    /* assertion (hand->stateStack).used > 0 */
    assert(hand->stateStack.used > (unsigned long int)0);
    if(!((signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_parse_complete))
    {
      if((signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_parse_error || (signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_lexical_error)
        goto __CPROVER_DUMP_L6;

      if((signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_start || (signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_map_need_val || (signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_array_start || (signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_array_need_val || (signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_got_value)
        goto __CPROVER_DUMP_L7;

      if((signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_map_start || (signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_map_need_key)
        goto __CPROVER_DUMP_L57;

      if((signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_map_sep)
        goto __CPROVER_DUMP_L68;

      if((signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_map_got_val)
        goto __CPROVER_DUMP_L73;

      if((signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_array_got_val)
        goto __CPROVER_DUMP_L83;

      break;
    }

    if(!((8u & hand->flags) == 0u))
    {
      hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_got_value;
      goto around_again;
    }

    if((4u & hand->flags) == 0u)
    {
      if(!(*offset == jsonTextLen))
      {
        tok=yajl_lex_lex(hand->lexer, jsonText, jsonTextLen, offset, &buf, &bufLen);
        if(!((signed int)tok == yajl_tok_eof))
        {
          hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
          hand->parseError = "trailing garbage";
        }

        goto around_again;
      }

    }

    return (enum anonymous_27)yajl_status_ok;

  __CPROVER_DUMP_L6:
    ;
    return (enum anonymous_27)yajl_status_error;

  __CPROVER_DUMP_L7:
    ;
    enum anonymous_30 stateToPush = (enum anonymous_30)yajl_state_start;
    tok=yajl_lex_lex(hand->lexer, jsonText, jsonTextLen, offset, &buf, &bufLen);
    switch((signed int)tok)
    {
      case yajl_tok_eof:
        return (enum anonymous_27)yajl_status_ok;
      case yajl_tok_error:
      {
        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_lexical_error;
        goto around_again;
      }
      case yajl_tok_string:
      {
        if(!(hand->callbacks == ((const struct anonymous *)NULL)))
        {
          if(!(hand->callbacks->yajl_string == ((signed int (*)(void *, const unsigned char *, unsigned long int))NULL)))
          {
            signed int return_value;
            return_value=hand->callbacks->yajl_string(hand->ctx, buf, bufLen);
            if(return_value == 0)
            {
              hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
              hand->parseError = "client cancelled parse via callback return value";
              return (enum anonymous_27)yajl_status_client_canceled;
            }

          }

        }

        break;
      }
      case yajl_tok_string_with_escapes:
      {
        if(!(hand->callbacks == ((const struct anonymous *)NULL)))
        {
          if(!(hand->callbacks->yajl_string == ((signed int (*)(void *, const unsigned char *, unsigned long int))NULL)))
          {
            yajl_buf_clear(hand->decodeBuf);
            yajl_string_decode(hand->decodeBuf, buf, bufLen);
            const unsigned char *return_value_yajl_buf_data_1;
            return_value_yajl_buf_data_1=yajl_buf_data(hand->decodeBuf);
            unsigned long int return_value_yajl_buf_len_2;
            return_value_yajl_buf_len_2=yajl_buf_len(hand->decodeBuf);
            signed int return_value_1;
            return_value_1=hand->callbacks->yajl_string(hand->ctx, return_value_yajl_buf_data_1, return_value_yajl_buf_len_2);
            if(return_value_1 == 0)
            {
              hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
              hand->parseError = "client cancelled parse via callback return value";
              return (enum anonymous_27)yajl_status_client_canceled;
            }

          }

        }

        break;
      }
      case yajl_tok_bool:
      {
        if(!(hand->callbacks == ((const struct anonymous *)NULL)))
        {
          if(!(hand->callbacks->yajl_boolean == ((signed int (*)(void *, signed int))NULL)))
          {
            signed int return_value_2;
            return_value_2=hand->callbacks->yajl_boolean(hand->ctx, (signed int)((signed int)*buf == 116));
            if(return_value_2 == 0)
            {
              hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
              hand->parseError = "client cancelled parse via callback return value";
              return (enum anonymous_27)yajl_status_client_canceled;
            }

          }

        }

        break;
      }
      case yajl_tok_null:
      {
        if(!(hand->callbacks == ((const struct anonymous *)NULL)))
        {
          if(!(hand->callbacks->yajl_null == ((signed int (*)(void *))NULL)))
          {
            signed int return_value_3;
            return_value_3=hand->callbacks->yajl_null(hand->ctx);
            if(return_value_3 == 0)
            {
              hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
              hand->parseError = "client cancelled parse via callback return value";
              return (enum anonymous_27)yajl_status_client_canceled;
            }

          }

        }

        break;
      }
      case yajl_tok_left_bracket:
      {
        if(!(hand->callbacks == ((const struct anonymous *)NULL)))
        {
          if(!(hand->callbacks->yajl_start_map == ((signed int (*)(void *))NULL)))
          {
            signed int return_value_4;
            return_value_4=hand->callbacks->yajl_start_map(hand->ctx);
            if(return_value_4 == 0)
            {
              hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
              hand->parseError = "client cancelled parse via callback return value";
              return (enum anonymous_27)yajl_status_client_canceled;
            }

          }

        }

        stateToPush = (enum anonymous_30)yajl_state_map_start;
        break;
      }
      case yajl_tok_left_brace:
      {
        if(!(hand->callbacks == ((const struct anonymous *)NULL)))
        {
          if(!(hand->callbacks->yajl_start_array == ((signed int (*)(void *))NULL)))
          {
            signed int return_value_5;
            return_value_5=hand->callbacks->yajl_start_array(hand->ctx);
            if(return_value_5 == 0)
            {
              hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
              hand->parseError = "client cancelled parse via callback return value";
              return (enum anonymous_27)yajl_status_client_canceled;
            }

          }

        }

        stateToPush = (enum anonymous_30)yajl_state_array_start;
        break;
      }
      case yajl_tok_integer:
      {
        if(!(hand->callbacks == ((const struct anonymous *)NULL)))
        {
          if(!(hand->callbacks->yajl_number == ((signed int (*)(void *, const char *, unsigned long int))NULL)))
          {
            signed int return_value_6;
            return_value_6=hand->callbacks->yajl_number(hand->ctx, (const char *)buf, bufLen);
            if(return_value_6 == 0)
            {
              hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
              hand->parseError = "client cancelled parse via callback return value";
              return (enum anonymous_27)yajl_status_client_canceled;
            }

          }

          else
            if(!(hand->callbacks->yajl_integer == ((signed int (*)(void *, signed long long int))NULL)))
            {
              signed long long int i = (signed long long int)0;
              signed int *return_value___errno_location_3;
              return_value___errno_location_3=__errno_location();
              *return_value___errno_location_3 = 0;
              i=yajl_parse_integer(buf, (unsigned int)bufLen);
              if(i == 0x7fffffffffffffffLL || i == -9223372036854775808ll)
              {
                return_value___errno_location_4=__errno_location();
                if(*return_value___errno_location_4 == 34)
                {
                  hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
                  hand->parseError = "integer overflow";
                  if(*offset >= bufLen)
                    *offset = *offset - bufLen;

                  else
                    *offset = (unsigned long int)0;
                  goto around_again;
                }

              }

              signed int return_value_7;
              return_value_7=hand->callbacks->yajl_integer(hand->ctx, i);
              if(return_value_7 == 0)
              {
                hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
                hand->parseError = "client cancelled parse via callback return value";
                return (enum anonymous_27)yajl_status_client_canceled;
              }

            }

        }

        break;
      }
      case yajl_tok_double:
      {
        if(!(hand->callbacks == ((const struct anonymous *)NULL)))
        {
          if(!(hand->callbacks->yajl_number == ((signed int (*)(void *, const char *, unsigned long int))NULL)))
          {
            signed int return_value_8;
            return_value_8=hand->callbacks->yajl_number(hand->ctx, (const char *)buf, bufLen);
            if(return_value_8 == 0)
            {
              hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
              hand->parseError = "client cancelled parse via callback return value";
              return (enum anonymous_27)yajl_status_client_canceled;
            }

          }

          else
            if(!(hand->callbacks->yajl_double == ((signed int (*)(void *, double))NULL)))
            {
              double d = 0.0;
              yajl_buf_clear(hand->decodeBuf);
              yajl_buf_append(hand->decodeBuf, (const void *)buf, bufLen);
              buf=yajl_buf_data(hand->decodeBuf);
              signed int *return_value___errno_location_5;
              return_value___errno_location_5=__errno_location();
              *return_value___errno_location_5 = 0;
              d=strtod((char *)buf, (char ** restrict )(void *)0);
              double return_value___builtin_huge_val_7;
              return_value___builtin_huge_val_7=__builtin_huge_val();
              if(IEEE_FLOAT_EQUAL(d, return_value___builtin_huge_val_7))
                tmp_if_expr_9 = (_Bool)1;

              else
              {
                return_value___builtin_huge_val_8=__builtin_huge_val();
                tmp_if_expr_9 = IEEE_FLOAT_EQUAL(d, -return_value___builtin_huge_val_8) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_9)
              {
                return_value___errno_location_6=__errno_location();
                if(*return_value___errno_location_6 == 34)
                {
                  hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
                  hand->parseError = "numeric (floating point) overflow";
                  if(*offset >= bufLen)
                    *offset = *offset - bufLen;

                  else
                    *offset = (unsigned long int)0;
                  goto around_again;
                }

              }

              signed int return_value_9;
              return_value_9=hand->callbacks->yajl_double(hand->ctx, d);
              if(return_value_9 == 0)
              {
                hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
                hand->parseError = "client cancelled parse via callback return value";
                return (enum anonymous_27)yajl_status_client_canceled;
              }

            }

        }

        break;
      }
      case yajl_tok_right_brace:
      {
        /* assertion (hand->stateStack).used > 0 */
        assert(hand->stateStack.used > (unsigned long int)0);
        if((signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_array_start)
        {
          if(!(hand->callbacks == ((const struct anonymous *)NULL)))
          {
            if(!(hand->callbacks->yajl_end_array == ((signed int (*)(void *))NULL)))
            {
              signed int return_value_10;
              return_value_10=hand->callbacks->yajl_end_array(hand->ctx);
              if(return_value_10 == 0)
              {
                hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
                hand->parseError = "client cancelled parse via callback return value";
                return (enum anonymous_27)yajl_status_client_canceled;
              }

            }

          }

          hand->stateStack.used = hand->stateStack.used - 1ul;
          goto around_again;
        }

      }
      case yajl_tok_colon:

      case yajl_tok_comma:

      case yajl_tok_right_bracket:
      {
        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
        hand->parseError = "unallowed token at this point in JSON text";
        goto around_again;
      }
      default:
      {
        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
        hand->parseError = "invalid token, internal error";
        goto around_again;
      }
    }
    enum anonymous_30 s;
    /* assertion (hand->stateStack).used > 0 */
    assert(hand->stateStack.used > (unsigned long int)0);
    s = (enum anonymous_30)hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)];
    if((signed int)s == yajl_state_start || (signed int)s == yajl_state_got_value)
      hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_complete;

    else
      if((signed int)s == yajl_state_map_need_val)
        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_map_got_val;

      else
        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_array_got_val;
    if(!((signed int)stateToPush == yajl_state_start))
    {
      if(hand->stateStack.size == hand->stateStack.used)
      {
        hand->stateStack.size = hand->stateStack.size + (unsigned long int)128;
        void *return_value_11;
        return_value_11=hand->stateStack.yaf->realloc(hand->stateStack.yaf->ctx, (void *)hand->stateStack.stack, hand->stateStack.size);
        hand->stateStack.stack = (unsigned char *)return_value_11;
      }

      tmp_post_10 = hand->stateStack.used;
      hand->stateStack.used = hand->stateStack.used + 1ul;
      hand->stateStack.stack[(signed long int)tmp_post_10] = (unsigned char)stateToPush;
    }

    goto around_again;

  __CPROVER_DUMP_L57:
    ;
    tok=yajl_lex_lex(hand->lexer, jsonText, jsonTextLen, offset, &buf, &bufLen);
    switch((signed int)tok)
    {
      case yajl_tok_eof:
        return (enum anonymous_27)yajl_status_ok;
      case yajl_tok_error:
      {
        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_lexical_error;
        goto around_again;
      }
      case yajl_tok_string_with_escapes:
        if(!(hand->callbacks == ((const struct anonymous *)NULL)))
        {
          if(!(hand->callbacks->yajl_map_key == ((signed int (*)(void *, const unsigned char *, unsigned long int))NULL)))
          {
            yajl_buf_clear(hand->decodeBuf);
            yajl_string_decode(hand->decodeBuf, buf, bufLen);
            buf=yajl_buf_data(hand->decodeBuf);
            bufLen=yajl_buf_len(hand->decodeBuf);
          }

        }

      case yajl_tok_string:
      {
        if(!(hand->callbacks == ((const struct anonymous *)NULL)))
        {
          if(!(hand->callbacks->yajl_map_key == ((signed int (*)(void *, const unsigned char *, unsigned long int))NULL)))
          {
            signed int return_value_12;
            return_value_12=hand->callbacks->yajl_map_key(hand->ctx, buf, bufLen);
            if(return_value_12 == 0)
            {
              hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
              hand->parseError = "client cancelled parse via callback return value";
              return (enum anonymous_27)yajl_status_client_canceled;
            }

          }

        }

        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_map_sep;
        goto around_again;
      }
      case yajl_tok_right_bracket:
      {
        /* assertion (hand->stateStack).used > 0 */
        assert(hand->stateStack.used > (unsigned long int)0);
        if((signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_map_start)
        {
          if(!(hand->callbacks == ((const struct anonymous *)NULL)))
          {
            if(!(hand->callbacks->yajl_end_map == ((signed int (*)(void *))NULL)))
            {
              signed int return_value_13;
              return_value_13=hand->callbacks->yajl_end_map(hand->ctx);
              if(return_value_13 == 0)
              {
                hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
                hand->parseError = "client cancelled parse via callback return value";
                return (enum anonymous_27)yajl_status_client_canceled;
              }

            }

          }

          hand->stateStack.used = hand->stateStack.used - 1ul;
          goto around_again;
        }

      }
      default:
      {
        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
        hand->parseError = "invalid object key (must be a string)";
        goto around_again;
      }
    }

  __CPROVER_DUMP_L68:
    ;
    tok=yajl_lex_lex(hand->lexer, jsonText, jsonTextLen, offset, &buf, &bufLen);
    switch((signed int)tok)
    {
      case yajl_tok_colon:
      {
        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_map_need_val;
        goto around_again;
      }
      case yajl_tok_eof:
        return (enum anonymous_27)yajl_status_ok;
      case yajl_tok_error:
      {
        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_lexical_error;
        goto around_again;
      }
      default:
      {
        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
        hand->parseError = "object key and value must be separated by a colon (':')";
        goto around_again;
      }
    }

  __CPROVER_DUMP_L73:
    ;
    tok=yajl_lex_lex(hand->lexer, jsonText, jsonTextLen, offset, &buf, &bufLen);
    switch((signed int)tok)
    {
      case yajl_tok_right_bracket:
      {
        if(!(hand->callbacks == ((const struct anonymous *)NULL)))
        {
          if(!(hand->callbacks->yajl_end_map == ((signed int (*)(void *))NULL)))
          {
            signed int return_value_14;
            return_value_14=hand->callbacks->yajl_end_map(hand->ctx);
            if(return_value_14 == 0)
            {
              hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
              hand->parseError = "client cancelled parse via callback return value";
              return (enum anonymous_27)yajl_status_client_canceled;
            }

          }

        }

        hand->stateStack.used = hand->stateStack.used - 1ul;
        goto around_again;
      }
      case yajl_tok_comma:
      {
        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_map_need_key;
        goto around_again;
      }
      case yajl_tok_eof:
        return (enum anonymous_27)yajl_status_ok;
      case yajl_tok_error:
      {
        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_lexical_error;
        goto around_again;
      }
      default:
      {
        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
        hand->parseError = "after key and value, inside map, I expect ',' or '}'";
        if(*offset >= bufLen)
          *offset = *offset - bufLen;

        else
          *offset = (unsigned long int)0;
        goto around_again;
      }
    }

  __CPROVER_DUMP_L83:
    ;
    tok=yajl_lex_lex(hand->lexer, jsonText, jsonTextLen, offset, &buf, &bufLen);
    switch((signed int)tok)
    {
      case yajl_tok_right_brace:
      {
        if(!(hand->callbacks == ((const struct anonymous *)NULL)))
        {
          if(!(hand->callbacks->yajl_end_array == ((signed int (*)(void *))NULL)))
          {
            signed int return_value_15;
            return_value_15=hand->callbacks->yajl_end_array(hand->ctx);
            if(return_value_15 == 0)
            {
              hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
              hand->parseError = "client cancelled parse via callback return value";
              return (enum anonymous_27)yajl_status_client_canceled;
            }

          }

        }

        hand->stateStack.used = hand->stateStack.used - 1ul;
        goto around_again;
      }
      case yajl_tok_comma:
      {
        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_array_need_val;
        goto around_again;
      }
      case yajl_tok_eof:
        return (enum anonymous_27)yajl_status_ok;
      case yajl_tok_error:
      {
        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_lexical_error;
        goto around_again;
      }
      default:
      {
        hand->stateStack.stack[(signed long int)(hand->stateStack.used - (unsigned long int)1)] = (unsigned char)yajl_state_parse_error;
        hand->parseError = "after array element, I expect ',' or ']'";
      }
    }
  }
  while((_Bool)1);
  abort();
  return (enum anonymous_27)yajl_status_error;
}

// yajl_free
// file ../json/yajl_api.h line 198
void yajl_free(struct yajl_handle_t *handle)
{
  if(!(handle->stateStack.stack == ((unsigned char *)NULL)))
    handle->stateStack.yaf->free(handle->stateStack.yaf->ctx, (void *)handle->stateStack.stack);

  yajl_buf_free(handle->decodeBuf);
  if(!(handle->lexer == ((struct yajl_lexer_t *)NULL)))
  {
    yajl_lex_free(handle->lexer);
    handle->lexer = (struct yajl_lexer_t *)(void *)0;
  }

  (&handle->alloc)->free((&handle->alloc)->ctx, (void *)handle);
}

// yajl_free_error
// file ../json/yajl_api.h line 249
void yajl_free_error(struct yajl_handle_t *hand, unsigned char *str)
{
  (&hand->alloc)->free((&hand->alloc)->ctx, (void *)str);
}

// yajl_gen_alloc
// file ../json/yajl_api.h line 342
struct yajl_gen_t * yajl_gen_alloc(const struct anonymous_3 *afs)
{
  struct yajl_gen_t *g = (struct yajl_gen_t *)(void *)0;
  struct anonymous_3 afsBuffer;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(!(afs == ((const struct anonymous_3 *)NULL)))
  {
    if(afs->malloc == ((void * (*)(void *, unsigned long int))NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = afs->realloc == (void * (*)(void *, void *, unsigned long int))(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = afs->free == (void (*)(void *, void *))(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return (struct yajl_gen_t *)(void *)0;

  }

  else
  {
    yajl_set_default_alloc_funcs(&afsBuffer);
    afs = &afsBuffer;
  }
  void *return_value;
  return_value=afs->malloc(afs->ctx, sizeof(struct yajl_gen_t) /*576ul*/ );
  g = (struct yajl_gen_t *)return_value;
  if(g == ((struct yajl_gen_t *)NULL))
    return (struct yajl_gen_t *)(void *)0;

  else
  {
    memset((void *)g, 0, sizeof(struct yajl_gen_t) /*576ul*/ );
    memcpy((void *)&g->alloc, (void *)afs, sizeof(struct anonymous_3) /*32ul*/ );
    g->print = (void (*)(void *, const char *, unsigned long int))yajl_buf_append;
    struct yajl_buf_t *return_value_yajl_buf_alloc_3;
    return_value_yajl_buf_alloc_3=yajl_buf_alloc(&g->alloc);
    g->ctx = (void *)return_value_yajl_buf_alloc_3;
    g->indentString = "    ";
    return g;
  }
}

// yajl_gen_array_close
// file ../json/yajl_api.h line 363
enum anonymous_33 yajl_gen_array_close(struct yajl_gen_t *g)
{
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_error)
    return (enum anonymous_33)yajl_gen_in_error_state;

  else
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
      return (enum anonymous_33)yajl_gen_generation_complete;

  g->depth = g->depth - 1u;
  unsigned long int return_value_strlen_1;
  if(g->depth >= 128u)
    return (enum anonymous_33)yajl_max_depth_exceeded;

  else
  {
    if(!((1u & g->flags) == 0u))
      g->print(g->ctx, "\n", (unsigned long int)1);

    switch((signed int)g->state[(signed long int)g->depth])
    {
      case yajl_gen_start:
      {
        g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_complete;
        break;
      }
      case yajl_gen_map_start:

      case yajl_gen_map_key:
      {
        g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_val;
        break;
      }
      case yajl_gen_array_start:
      {
        g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_in_array;
        break;
      }
      case yajl_gen_map_val:
        g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_key;
    }
    if(!((1u & g->flags) == 0u))
    {
      if(!((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val))
      {
        unsigned int _i = (unsigned int)0;
        if(!(_i >= g->depth))
        {
          return_value_strlen_1=strlen(g->indentString);
          g->print(g->ctx, g->indentString, (unsigned long int)(unsigned int)return_value_strlen_1);
          _i = _i + 1u;
        }

      }

    }

    g->print(g->ctx, "]", (unsigned long int)1);
    if(!((1u & g->flags) == 0u))
    {
      if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
        g->print(g->ctx, "\n", (unsigned long int)1);

    }

    return (enum anonymous_33)yajl_gen_status_ok;
  }
}

// yajl_gen_array_open
// file ../json/yajl_api.h line 362
enum anonymous_33 yajl_gen_array_open(struct yajl_gen_t *g)
{
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_error)
    return (enum anonymous_33)yajl_gen_in_error_state;

  else
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
      return (enum anonymous_33)yajl_gen_generation_complete;

  _Bool tmp_if_expr_1;
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_key)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)g->state[(signed long int)g->depth] == yajl_gen_map_start ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_3;
  if(tmp_if_expr_1)
    return (enum anonymous_33)yajl_gen_keys_must_be_strings;

  else
  {
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_key)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)g->state[(signed long int)g->depth] == yajl_gen_in_array ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      g->print(g->ctx, ",", (unsigned long int)1);
      if(!((1u & g->flags) == 0u))
        g->print(g->ctx, "\n", (unsigned long int)1);

    }

    else
      if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val)
      {
        g->print(g->ctx, ":", (unsigned long int)1);
        if(!((1u & g->flags) == 0u))
          g->print(g->ctx, " ", (unsigned long int)1);

      }

    if(!((1u & g->flags) == 0u))
    {
      if(!((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val))
      {
        unsigned int _i = (unsigned int)0;
        if(!(_i >= g->depth))
        {
          return_value_strlen_3=strlen(g->indentString);
          g->print(g->ctx, g->indentString, (unsigned long int)(unsigned int)return_value_strlen_3);
          _i = _i + 1u;
        }

      }

    }

    g->depth = g->depth + 1u;
    if(g->depth >= 128u)
      return (enum anonymous_33)yajl_max_depth_exceeded;

    else
    {
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_array_start;
      g->print(g->ctx, "[", (unsigned long int)1);
      if(!((1u & g->flags) == 0u))
        g->print(g->ctx, "\n", (unsigned long int)1);

      if(!((1u & g->flags) == 0u))
      {
        if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
          g->print(g->ctx, "\n", (unsigned long int)1);

      }

      return (enum anonymous_33)yajl_gen_status_ok;
    }
  }
}

// yajl_gen_bool
// file yajl_all.c line 776
enum anonymous_33 yajl_gen_bool(struct yajl_gen_t *g, signed int boolean)
{
  const char *val = boolean != 0 ? "true" : "false";
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_error)
    return (enum anonymous_33)yajl_gen_in_error_state;

  else
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
      return (enum anonymous_33)yajl_gen_generation_complete;

  _Bool tmp_if_expr_1;
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_key)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)g->state[(signed long int)g->depth] == yajl_gen_map_start ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_3;
  if(tmp_if_expr_1)
    return (enum anonymous_33)yajl_gen_keys_must_be_strings;

  else
  {
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_key)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)g->state[(signed long int)g->depth] == yajl_gen_in_array ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      g->print(g->ctx, ",", (unsigned long int)1);
      if(!((1u & g->flags) == 0u))
        g->print(g->ctx, "\n", (unsigned long int)1);

    }

    else
      if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val)
      {
        g->print(g->ctx, ":", (unsigned long int)1);
        if(!((1u & g->flags) == 0u))
          g->print(g->ctx, " ", (unsigned long int)1);

      }

    if(!((1u & g->flags) == 0u))
    {
      if(!((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val))
      {
        unsigned int _i = (unsigned int)0;
        if(!(_i >= g->depth))
        {
          return_value_strlen_3=strlen(g->indentString);
          g->print(g->ctx, g->indentString, (unsigned long int)(unsigned int)return_value_strlen_3);
          _i = _i + 1u;
        }

      }

    }

    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(val);
    g->print(g->ctx, val, (unsigned long int)(unsigned int)return_value_strlen_4);
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_start)
    {
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_complete;
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_val;
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_in_array;
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_key;
    }

    if(!((1u & g->flags) == 0u))
    {
      if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
        g->print(g->ctx, "\n", (unsigned long int)1);

    }

    return (enum anonymous_33)yajl_gen_status_ok;
  }
}

// yajl_gen_clear
// file yajl_all.c line 850
void yajl_gen_clear(struct yajl_gen_t *g)
{
  if(g->print == (void (*)(void *, const char *, unsigned long int))yajl_buf_append)
    yajl_buf_clear((struct yajl_buf_t *)g->ctx);

}

// yajl_gen_config
// file ../json/yajl_api.h line 332
signed int yajl_gen_config(struct yajl_gen_t *g, enum anonymous_32 opt, ...)
{
  signed int rv = 1;
  __builtin_va_list ap;
  va_start(ap, opt);
  signed int return_value_gcc_builtin_va_arg_1;
  const char *indent;
  switch((signed int)opt)
  {
    case yajl_gen_beautify:

    case yajl_gen_validate_utf8:

    case yajl_gen_escape_solidus:
    {
      return_value_gcc_builtin_va_arg_1=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_1));
      if(!(return_value_gcc_builtin_va_arg_1 == 0))
        g->flags = g->flags | (unsigned int)opt;

      else
        g->flags = g->flags & (unsigned int)~((signed int)opt);
      break;
    }
    case yajl_gen_indent_string:
    {
      indent=va_arg(ap, __typeof__(indent));
      g->indentString = indent;
      for( ; !(*indent == 0); indent = indent + 1l)
        if(!((signed int)*indent == 10))
        {
          if(!((signed int)*indent == 11))
          {
            if(!((signed int)*indent == 12))
            {
              if(!((signed int)*indent == 9))
              {
                if(!((signed int)*indent == 13))
                {
                  if(!((signed int)*indent == 32))
                  {
                    g->indentString = (const char *)(void *)0;
                    rv = 0;
                  }

                }

              }

            }

          }

        }

      break;
    }
    case yajl_gen_print_callback:
    {
      yajl_buf_free((struct yajl_buf_t *)g->ctx);
      g->print=va_arg(ap, __typeof__(g->print));
      g->ctx=va_arg(ap, __typeof__(g->ctx));
      break;
    }
    default:
      rv = 0;
  }
  va_end(ap);
  return rv;
}

// yajl_gen_double
// file yajl_all.c line 714
enum anonymous_33 yajl_gen_double(struct yajl_gen_t *g, double number)
{
  char i[32l];
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_error)
    return (enum anonymous_33)yajl_gen_in_error_state;

  else
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
      return (enum anonymous_33)yajl_gen_generation_complete;

  _Bool tmp_if_expr_1;
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_key)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)g->state[(signed long int)g->depth] == yajl_gen_map_start ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4;
  signed int return_value___isinf_3;
  _Bool tmp_if_expr_5;
  unsigned long int return_value_strlen_6;
  if(tmp_if_expr_1)
    return (enum anonymous_33)yajl_gen_keys_must_be_strings;

  else
  {
    signed int return_value___isnan_2;
    return_value___isnan_2=__isnan(number);
    if(!(return_value___isnan_2 == 0))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value___isinf_3=__isinf(number);
      tmp_if_expr_4 = return_value___isinf_3 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      return (enum anonymous_33)yajl_gen_invalid_number;

    else
    {
      if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_key)
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)g->state[(signed long int)g->depth] == yajl_gen_in_array ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
      {
        g->print(g->ctx, ",", (unsigned long int)1);
        if(!((1u & g->flags) == 0u))
          g->print(g->ctx, "\n", (unsigned long int)1);

      }

      else
        if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val)
        {
          g->print(g->ctx, ":", (unsigned long int)1);
          if(!((1u & g->flags) == 0u))
            g->print(g->ctx, " ", (unsigned long int)1);

        }

      if(!((1u & g->flags) == 0u))
      {
        if(!((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val))
        {
          unsigned int _i = (unsigned int)0;
          if(!(_i >= g->depth))
          {
            return_value_strlen_6=strlen(g->indentString);
            g->print(g->ctx, g->indentString, (unsigned long int)(unsigned int)return_value_strlen_6);
            _i = _i + 1u;
          }

        }

      }

      snprintf(i, (unsigned long int)31, "%.20g", number);
      unsigned long int return_value_strspn_7;
      return_value_strspn_7=strspn(i, "0123456789-");
      unsigned long int return_value_strlen_8;
      return_value_strlen_8=strlen(i);
      if(return_value_strspn_7 == return_value_strlen_8)
        strcat(i, ".0");

      unsigned long int return_value_strlen_9;
      return_value_strlen_9=strlen(i);
      g->print(g->ctx, i, (unsigned long int)(unsigned int)return_value_strlen_9);
      if((signed int)g->state[(signed long int)g->depth] == yajl_gen_start)
      {
        g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_complete;
        g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_val;
        g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_in_array;
        g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_key;
      }

      if(!((1u & g->flags) == 0u))
      {
        if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
          g->print(g->ctx, "\n", (unsigned long int)1);

      }

      return (enum anonymous_33)yajl_gen_status_ok;
    }
  }
}

// yajl_gen_free
// file ../json/yajl_api.h line 345
void yajl_gen_free(struct yajl_gen_t *g)
{
  if(g->print == (void (*)(void *, const char *, unsigned long int))yajl_buf_append)
    yajl_buf_free((struct yajl_buf_t *)g->ctx);

  (&g->alloc)->free((&g->alloc)->ctx, (void *)g);
}

// yajl_gen_get_buf
// file yajl_all.c line 840
enum anonymous_33 yajl_gen_get_buf(struct yajl_gen_t *g, const unsigned char **buf, unsigned long int *len)
{
  if(!(g->print == (void (*)(void *, const char *, unsigned long int))yajl_buf_append))
    return (enum anonymous_33)yajl_gen_no_buf;

  else
  {
    *buf=yajl_buf_data((struct yajl_buf_t *)g->ctx);
    *len=yajl_buf_len((struct yajl_buf_t *)g->ctx);
    return (enum anonymous_33)yajl_gen_status_ok;
  }
}

// yajl_gen_integer
// file yajl_all.c line 696
enum anonymous_33 yajl_gen_integer(struct yajl_gen_t *g, signed long long int number)
{
  char i[32l];
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_error)
    return (enum anonymous_33)yajl_gen_in_error_state;

  else
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
      return (enum anonymous_33)yajl_gen_generation_complete;

  _Bool tmp_if_expr_1;
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_key)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)g->state[(signed long int)g->depth] == yajl_gen_map_start ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_3;
  if(tmp_if_expr_1)
    return (enum anonymous_33)yajl_gen_keys_must_be_strings;

  else
  {
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_key)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)g->state[(signed long int)g->depth] == yajl_gen_in_array ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      g->print(g->ctx, ",", (unsigned long int)1);
      if(!((1u & g->flags) == 0u))
        g->print(g->ctx, "\n", (unsigned long int)1);

    }

    else
      if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val)
      {
        g->print(g->ctx, ":", (unsigned long int)1);
        if(!((1u & g->flags) == 0u))
          g->print(g->ctx, " ", (unsigned long int)1);

      }

    if(!((1u & g->flags) == 0u))
    {
      if(!((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val))
      {
        unsigned int _i = (unsigned int)0;
        if(!(_i >= g->depth))
        {
          return_value_strlen_3=strlen(g->indentString);
          g->print(g->ctx, g->indentString, (unsigned long int)(unsigned int)return_value_strlen_3);
          _i = _i + 1u;
        }

      }

    }

    snprintf(i, (unsigned long int)31, "%lld", number);
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(i);
    g->print(g->ctx, i, (unsigned long int)(unsigned int)return_value_strlen_4);
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_start)
    {
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_complete;
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_val;
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_in_array;
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_key;
    }

    if(!((1u & g->flags) == 0u))
    {
      if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
        g->print(g->ctx, "\n", (unsigned long int)1);

    }

    return (enum anonymous_33)yajl_gen_status_ok;
  }
}

// yajl_gen_map_close
// file ../json/yajl_api.h line 361
enum anonymous_33 yajl_gen_map_close(struct yajl_gen_t *g)
{
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_error)
    return (enum anonymous_33)yajl_gen_in_error_state;

  else
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
      return (enum anonymous_33)yajl_gen_generation_complete;

  g->depth = g->depth - 1u;
  unsigned long int return_value_strlen_1;
  if(g->depth >= 128u)
    return (enum anonymous_33)yajl_max_depth_exceeded;

  else
  {
    if(!((1u & g->flags) == 0u))
      g->print(g->ctx, "\n", (unsigned long int)1);

    switch((signed int)g->state[(signed long int)g->depth])
    {
      case yajl_gen_start:
      {
        g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_complete;
        break;
      }
      case yajl_gen_map_start:

      case yajl_gen_map_key:
      {
        g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_val;
        break;
      }
      case yajl_gen_array_start:
      {
        g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_in_array;
        break;
      }
      case yajl_gen_map_val:
        g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_key;
    }
    if(!((1u & g->flags) == 0u))
    {
      if(!((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val))
      {
        unsigned int _i = (unsigned int)0;
        if(!(_i >= g->depth))
        {
          return_value_strlen_1=strlen(g->indentString);
          g->print(g->ctx, g->indentString, (unsigned long int)(unsigned int)return_value_strlen_1);
          _i = _i + 1u;
        }

      }

    }

    g->print(g->ctx, "}", (unsigned long int)1);
    if(!((1u & g->flags) == 0u))
    {
      if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
        g->print(g->ctx, "\n", (unsigned long int)1);

    }

    return (enum anonymous_33)yajl_gen_status_ok;
  }
}

// yajl_gen_map_open
// file ../json/yajl_api.h line 360
enum anonymous_33 yajl_gen_map_open(struct yajl_gen_t *g)
{
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_error)
    return (enum anonymous_33)yajl_gen_in_error_state;

  else
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
      return (enum anonymous_33)yajl_gen_generation_complete;

  _Bool tmp_if_expr_1;
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_key)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)g->state[(signed long int)g->depth] == yajl_gen_map_start ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_3;
  if(tmp_if_expr_1)
    return (enum anonymous_33)yajl_gen_keys_must_be_strings;

  else
  {
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_key)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)g->state[(signed long int)g->depth] == yajl_gen_in_array ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      g->print(g->ctx, ",", (unsigned long int)1);
      if(!((1u & g->flags) == 0u))
        g->print(g->ctx, "\n", (unsigned long int)1);

    }

    else
      if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val)
      {
        g->print(g->ctx, ":", (unsigned long int)1);
        if(!((1u & g->flags) == 0u))
          g->print(g->ctx, " ", (unsigned long int)1);

      }

    if(!((1u & g->flags) == 0u))
    {
      if(!((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val))
      {
        unsigned int _i = (unsigned int)0;
        if(!(_i >= g->depth))
        {
          return_value_strlen_3=strlen(g->indentString);
          g->print(g->ctx, g->indentString, (unsigned long int)(unsigned int)return_value_strlen_3);
          _i = _i + 1u;
        }

      }

    }

    g->depth = g->depth + 1u;
    if(g->depth >= 128u)
      return (enum anonymous_33)yajl_max_depth_exceeded;

    else
    {
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_start;
      g->print(g->ctx, "{", (unsigned long int)1);
      if(!((1u & g->flags) == 0u))
        g->print(g->ctx, "\n", (unsigned long int)1);

      if(!((1u & g->flags) == 0u))
      {
        if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
          g->print(g->ctx, "\n", (unsigned long int)1);

      }

      return (enum anonymous_33)yajl_gen_status_ok;
    }
  }
}

// yajl_gen_null
// file yajl_all.c line 766
enum anonymous_33 yajl_gen_null(struct yajl_gen_t *g)
{
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_error)
    return (enum anonymous_33)yajl_gen_in_error_state;

  else
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
      return (enum anonymous_33)yajl_gen_generation_complete;

  _Bool tmp_if_expr_1;
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_key)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)g->state[(signed long int)g->depth] == yajl_gen_map_start ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_3;
  if(tmp_if_expr_1)
    return (enum anonymous_33)yajl_gen_keys_must_be_strings;

  else
  {
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_key)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)g->state[(signed long int)g->depth] == yajl_gen_in_array ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      g->print(g->ctx, ",", (unsigned long int)1);
      if(!((1u & g->flags) == 0u))
        g->print(g->ctx, "\n", (unsigned long int)1);

    }

    else
      if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val)
      {
        g->print(g->ctx, ":", (unsigned long int)1);
        if(!((1u & g->flags) == 0u))
          g->print(g->ctx, " ", (unsigned long int)1);

      }

    if(!((1u & g->flags) == 0u))
    {
      if(!((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val))
      {
        unsigned int _i = (unsigned int)0;
        if(!(_i >= g->depth))
        {
          return_value_strlen_3=strlen(g->indentString);
          g->print(g->ctx, g->indentString, (unsigned long int)(unsigned int)return_value_strlen_3);
          _i = _i + 1u;
        }

      }

    }

    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen("null");
    g->print(g->ctx, "null", return_value_strlen_4);
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_start)
    {
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_complete;
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_val;
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_in_array;
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_key;
    }

    if(!((1u & g->flags) == 0u))
    {
      if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
        g->print(g->ctx, "\n", (unsigned long int)1);

    }

    return (enum anonymous_33)yajl_gen_status_ok;
  }
}

// yajl_gen_number
// file ../json/yajl_api.h line 352
enum anonymous_33 yajl_gen_number(struct yajl_gen_t *g, const char *s, unsigned long int l)
{
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_error)
    return (enum anonymous_33)yajl_gen_in_error_state;

  else
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
      return (enum anonymous_33)yajl_gen_generation_complete;

  _Bool tmp_if_expr_1;
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_key)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)g->state[(signed long int)g->depth] == yajl_gen_map_start ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_3;
  if(tmp_if_expr_1)
    return (enum anonymous_33)yajl_gen_keys_must_be_strings;

  else
  {
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_key)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)g->state[(signed long int)g->depth] == yajl_gen_in_array ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      g->print(g->ctx, ",", (unsigned long int)1);
      if(!((1u & g->flags) == 0u))
        g->print(g->ctx, "\n", (unsigned long int)1);

    }

    else
      if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val)
      {
        g->print(g->ctx, ":", (unsigned long int)1);
        if(!((1u & g->flags) == 0u))
          g->print(g->ctx, " ", (unsigned long int)1);

      }

    if(!((1u & g->flags) == 0u))
    {
      if(!((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val))
      {
        unsigned int _i = (unsigned int)0;
        if(!(_i >= g->depth))
        {
          return_value_strlen_3=strlen(g->indentString);
          g->print(g->ctx, g->indentString, (unsigned long int)(unsigned int)return_value_strlen_3);
          _i = _i + 1u;
        }

      }

    }

    g->print(g->ctx, s, l);
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_start)
    {
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_complete;
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_val;
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_in_array;
      g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_key;
    }

    if(!((1u & g->flags) == 0u))
    {
      if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
        g->print(g->ctx, "\n", (unsigned long int)1);

    }

    return (enum anonymous_33)yajl_gen_status_ok;
  }
}

// yajl_gen_string
// file ../json/yajl_api.h line 355
enum anonymous_33 yajl_gen_string(struct yajl_gen_t *g, const unsigned char *str, unsigned long int len)
{
  if(!((8u & g->flags) == 0u))
  {
    signed int return_value_yajl_string_validate_utf8_1;
    return_value_yajl_string_validate_utf8_1=yajl_string_validate_utf8(str, len);
    if(return_value_yajl_string_validate_utf8_1 == 0)
      return (enum anonymous_33)yajl_gen_invalid_string;

  }

  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_error)
    return (enum anonymous_33)yajl_gen_in_error_state;

  else
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
      return (enum anonymous_33)yajl_gen_generation_complete;

  _Bool tmp_if_expr_2;
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_key)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)g->state[(signed long int)g->depth] == yajl_gen_in_array ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    g->print(g->ctx, ",", (unsigned long int)1);
    if(!((1u & g->flags) == 0u))
      g->print(g->ctx, "\n", (unsigned long int)1);

  }

  else
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val)
    {
      g->print(g->ctx, ":", (unsigned long int)1);
      if(!((1u & g->flags) == 0u))
        g->print(g->ctx, " ", (unsigned long int)1);

    }

  unsigned long int return_value_strlen_3;
  if(!((1u & g->flags) == 0u))
  {
    if(!((signed int)g->state[(signed long int)g->depth] == yajl_gen_map_val))
    {
      unsigned int _i = (unsigned int)0;
      if(!(_i >= g->depth))
      {
        return_value_strlen_3=strlen(g->indentString);
        g->print(g->ctx, g->indentString, (unsigned long int)(unsigned int)return_value_strlen_3);
        _i = _i + 1u;
      }

    }

  }

  g->print(g->ctx, "\"", (unsigned long int)1);
  yajl_string_encode(g->print, g->ctx, str, len, (signed int)(g->flags & (unsigned int)yajl_gen_escape_solidus));
  g->print(g->ctx, "\"", (unsigned long int)1);
  if((signed int)g->state[(signed long int)g->depth] == yajl_gen_start)
  {
    g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_complete;
    g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_val;
    g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_in_array;
    g->state[(signed long int)g->depth] = (enum anonymous_31)yajl_gen_map_key;
  }

  if(!((1u & g->flags) == 0u))
  {
    if((signed int)g->state[(signed long int)g->depth] == yajl_gen_complete)
      g->print(g->ctx, "\n", (unsigned long int)1);

  }

  return (enum anonymous_33)yajl_gen_status_ok;
}

// yajl_get_bytes_consumed
// file yajl_all.c line 331
unsigned long int yajl_get_bytes_consumed(struct yajl_handle_t *hand)
{
  if(hand == ((struct yajl_handle_t *)NULL))
    return (unsigned long int)0;

  else
    return hand->bytesConsumed;
}

// yajl_get_error
// file ../json/yajl_api.h line 230
unsigned char * yajl_get_error(struct yajl_handle_t *hand, signed int verbose, const unsigned char *jsonText, unsigned long int jsonTextLen)
{
  unsigned char *return_value_yajl_render_error_string_1;
  return_value_yajl_render_error_string_1=yajl_render_error_string(hand, jsonText, jsonTextLen, verbose);
  return return_value_yajl_render_error_string_1;
}

// yajl_internal_free
// file yajl_all.c line 117
static void yajl_internal_free(void *ctx, void *ptr)
{
  (void)ctx;
  free(ptr);
}

// yajl_internal_malloc
// file yajl_all.c line 104
static void * yajl_internal_malloc(void *ctx, unsigned long int sz)
{
  (void)ctx;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sz);
  return return_value_malloc_1;
}

// yajl_internal_realloc
// file yajl_all.c line 110
static void * yajl_internal_realloc(void *ctx, void *previous, unsigned long int sz)
{
  (void)ctx;
  void *return_value_realloc_1;
  return_value_realloc_1=realloc(previous, sz);
  return return_value_realloc_1;
}

// yajl_lex_alloc
// file yajl_all.c line 906
static struct yajl_lexer_t * yajl_lex_alloc(struct anonymous_3 *alloc, unsigned int allowComments, unsigned int validateUTF8)
{
  struct yajl_lexer_t *lxr;
  void *return_value;
  return_value=alloc->malloc(alloc->ctx, sizeof(struct yajl_lexer_t) /*64ul*/ );
  lxr = (struct yajl_lexer_t *)return_value;
  memset((void *)lxr, 0, sizeof(struct yajl_lexer_t) /*64ul*/ );
  lxr->buf=yajl_buf_alloc(alloc);
  lxr->allowComments = allowComments;
  lxr->validateUTF8 = validateUTF8;
  lxr->alloc = alloc;
  return lxr;
}

// yajl_lex_comment
// file yajl_all.c line 1260
static enum anonymous_29 yajl_lex_comment(struct yajl_lexer_t *lexer, const unsigned char *jsonText, unsigned long int jsonTextLen, unsigned long int *offset)
{
  unsigned char c;
  enum anonymous_29 tok = (enum anonymous_29)yajl_tok_comment;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_yajl_buf_len_1;
  _Bool tmp_if_expr_4;
  unsigned long int return_value_yajl_buf_len_3;
  signed int tmp_if_expr_8;
  const unsigned char *return_value_yajl_buf_data_5;
  unsigned long int tmp_post_6;
  unsigned long int tmp_post_7;
  _Bool tmp_if_expr_10;
  unsigned long int return_value_yajl_buf_len_9;
  _Bool tmp_if_expr_12;
  unsigned long int return_value_yajl_buf_len_11;
  signed int tmp_if_expr_16;
  const unsigned char *return_value_yajl_buf_data_13;
  unsigned long int tmp_post_14;
  unsigned long int tmp_post_15;
  _Bool tmp_if_expr_18;
  unsigned long int return_value_yajl_buf_len_17;
  _Bool tmp_if_expr_20;
  unsigned long int return_value_yajl_buf_len_19;
  signed int tmp_if_expr_24;
  const unsigned char *return_value_yajl_buf_data_21;
  unsigned long int tmp_post_22;
  unsigned long int tmp_post_23;
  _Bool tmp_if_expr_26;
  unsigned long int return_value_yajl_buf_len_25;
  _Bool tmp_if_expr_28;
  unsigned long int return_value_yajl_buf_len_27;
  signed int tmp_if_expr_32;
  const unsigned char *return_value_yajl_buf_data_29;
  unsigned long int tmp_post_30;
  unsigned long int tmp_post_31;
  if(*offset >= jsonTextLen)
    return (enum anonymous_29)yajl_tok_eof;

  else
  {
    if(!(lexer->bufInUse == 0u))
    {
      return_value_yajl_buf_len_1=yajl_buf_len(lexer->buf);
      tmp_if_expr_2 = return_value_yajl_buf_len_1 != 0ul ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
    {
      return_value_yajl_buf_len_3=yajl_buf_len(lexer->buf);
      tmp_if_expr_4 = lexer->bufOff < return_value_yajl_buf_len_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      return_value_yajl_buf_data_5=yajl_buf_data(lexer->buf);
      tmp_post_6 = lexer->bufOff;
      lexer->bufOff = lexer->bufOff + 1ul;
      tmp_if_expr_8 = (signed int)((const unsigned char *)return_value_yajl_buf_data_5)[(signed long int)tmp_post_6];
    }

    else
    {
      tmp_post_7 = *offset;
      *offset = *offset + 1ul;
      tmp_if_expr_8 = (signed int)jsonText[(signed long int)tmp_post_7];
    }
    c = (unsigned char)tmp_if_expr_8;
    if((signed int)c == 47)
      while((_Bool)1)
      {
        if(*offset >= jsonTextLen)
          return (enum anonymous_29)yajl_tok_eof;

        if(!(lexer->bufInUse == 0u))
        {
          return_value_yajl_buf_len_9=yajl_buf_len(lexer->buf);
          tmp_if_expr_10 = return_value_yajl_buf_len_9 != 0ul ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_10 = (_Bool)0;
        if(tmp_if_expr_10)
        {
          return_value_yajl_buf_len_11=yajl_buf_len(lexer->buf);
          tmp_if_expr_12 = lexer->bufOff < return_value_yajl_buf_len_11 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_12 = (_Bool)0;
        if(tmp_if_expr_12)
        {
          return_value_yajl_buf_data_13=yajl_buf_data(lexer->buf);
          tmp_post_14 = lexer->bufOff;
          lexer->bufOff = lexer->bufOff + 1ul;
          tmp_if_expr_16 = (signed int)((const unsigned char *)return_value_yajl_buf_data_13)[(signed long int)tmp_post_14];
        }

        else
        {
          tmp_post_15 = *offset;
          *offset = *offset + 1ul;
          tmp_if_expr_16 = (signed int)jsonText[(signed long int)tmp_post_15];
        }
        c = (unsigned char)tmp_if_expr_16;
        if((signed int)c == 10)
          break;

      }

    else
      if((signed int)c == 42)
        while((_Bool)1)
        {
          if(*offset >= jsonTextLen)
            return (enum anonymous_29)yajl_tok_eof;

          if(!(lexer->bufInUse == 0u))
          {
            return_value_yajl_buf_len_17=yajl_buf_len(lexer->buf);
            tmp_if_expr_18 = return_value_yajl_buf_len_17 != 0ul ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_18 = (_Bool)0;
          if(tmp_if_expr_18)
          {
            return_value_yajl_buf_len_19=yajl_buf_len(lexer->buf);
            tmp_if_expr_20 = lexer->bufOff < return_value_yajl_buf_len_19 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_20 = (_Bool)0;
          if(tmp_if_expr_20)
          {
            return_value_yajl_buf_data_21=yajl_buf_data(lexer->buf);
            tmp_post_22 = lexer->bufOff;
            lexer->bufOff = lexer->bufOff + 1ul;
            tmp_if_expr_24 = (signed int)((const unsigned char *)return_value_yajl_buf_data_21)[(signed long int)tmp_post_22];
          }

          else
          {
            tmp_post_23 = *offset;
            *offset = *offset + 1ul;
            tmp_if_expr_24 = (signed int)jsonText[(signed long int)tmp_post_23];
          }
          c = (unsigned char)tmp_if_expr_24;
          if((signed int)c == 42)
          {
            if(*offset >= jsonTextLen)
              return (enum anonymous_29)yajl_tok_eof;

            if(!(lexer->bufInUse == 0u))
            {
              return_value_yajl_buf_len_25=yajl_buf_len(lexer->buf);
              tmp_if_expr_26 = return_value_yajl_buf_len_25 != 0ul ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_26 = (_Bool)0;
            if(tmp_if_expr_26)
            {
              return_value_yajl_buf_len_27=yajl_buf_len(lexer->buf);
              tmp_if_expr_28 = lexer->bufOff < return_value_yajl_buf_len_27 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_28 = (_Bool)0;
            if(tmp_if_expr_28)
            {
              return_value_yajl_buf_data_29=yajl_buf_data(lexer->buf);
              tmp_post_30 = lexer->bufOff;
              lexer->bufOff = lexer->bufOff + 1ul;
              tmp_if_expr_32 = (signed int)((const unsigned char *)return_value_yajl_buf_data_29)[(signed long int)tmp_post_30];
            }

            else
            {
              tmp_post_31 = *offset;
              *offset = *offset + 1ul;
              tmp_if_expr_32 = (signed int)jsonText[(signed long int)tmp_post_31];
            }
            c = (unsigned char)tmp_if_expr_32;
            if((signed int)c == 47)
              break;

            else
              if(*offset >= 1ul)
                *offset = *offset - 1ul;

              else
                lexer->bufOff = lexer->bufOff - 1ul;
          }

        }

      else
      {
        lexer->error = (enum anonymous_28)yajl_lex_invalid_char;
        tok = (enum anonymous_29)yajl_tok_error;
      }
    return tok;
  }
}

// yajl_lex_error_to_string
// file yajl_all.c line 1493
static const char * yajl_lex_error_to_string(enum anonymous_28 error)
{
  switch((signed int)error)
  {
    case yajl_lex_e_ok:
      return "ok, no error";
    case yajl_lex_string_invalid_utf8:
      return "invalid bytes in UTF8 string.";
    case yajl_lex_string_invalid_escaped_char:
      return "inside a string, '\\' occurs before a character which it may not.";
    case yajl_lex_string_invalid_json_char:
      return "invalid character inside string.";
    case yajl_lex_string_invalid_hex_char:
      return "invalid (non-hex) character occurs after '\\u' inside string.";
    case yajl_lex_invalid_char:
      return "invalid char in json text.";
    case yajl_lex_invalid_string:
      return "invalid string in json text.";
    case yajl_lex_missing_integer_after_exponent:
      return "malformed number, a digit is required after the exponent.";
    case yajl_lex_missing_integer_after_decimal:
      return "malformed number, a digit is required after the decimal point.";
    case yajl_lex_missing_integer_after_minus:
      return "malformed number, a digit is required after the minus sign.";
    case yajl_lex_unallowed_comment:
      return "probable comment found in input text, comments are not enabled.";
    default:
      return "unknown error code";
  }
}

// yajl_lex_free
// file yajl_all.c line 919
static void yajl_lex_free(struct yajl_lexer_t *lxr)
{
  yajl_buf_free(lxr->buf);
  lxr->alloc->free(lxr->alloc->ctx, (void *)lxr);
}

// yajl_lex_get_error
// file yajl_all.c line 1531
static enum anonymous_28 yajl_lex_get_error(struct yajl_lexer_t *lexer)
{
  if(lexer == ((struct yajl_lexer_t *)NULL))
    return (enum anonymous_28)-1;

  else
    return lexer->error;
}

// yajl_lex_lex
// file yajl_all.c line 1301
static enum anonymous_29 yajl_lex_lex(struct yajl_lexer_t *lexer, const unsigned char *jsonText, unsigned long int jsonTextLen, unsigned long int *offset, const unsigned char **outBuf, unsigned long int *outLen)
{
  enum anonymous_29 tok = (enum anonymous_29)yajl_tok_error;
  unsigned char c;
  unsigned long int startOffset = *offset;
  *outBuf = (const unsigned char *)(void *)0;
  *outLen = (unsigned long int)0;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_yajl_buf_len_1;
  _Bool tmp_if_expr_4;
  unsigned long int return_value_yajl_buf_len_3;
  signed int tmp_if_expr_8;
  const unsigned char *return_value_yajl_buf_data_5;
  unsigned long int tmp_post_6;
  unsigned long int tmp_post_7;
  const char *want;
  _Bool tmp_if_expr_10;
  unsigned long int return_value_yajl_buf_len_9;
  _Bool tmp_if_expr_12;
  unsigned long int return_value_yajl_buf_len_11;
  signed int tmp_if_expr_16;
  const unsigned char *return_value_yajl_buf_data_13;
  unsigned long int tmp_post_14;
  unsigned long int tmp_post_15;
  const char *yajl_lex_lex__1__1__1__2__2__want;
  _Bool tmp_if_expr_18;
  unsigned long int return_value_yajl_buf_len_17;
  _Bool tmp_if_expr_20;
  unsigned long int return_value_yajl_buf_len_19;
  signed int tmp_if_expr_24;
  const unsigned char *return_value_yajl_buf_data_21;
  unsigned long int tmp_post_22;
  unsigned long int tmp_post_23;
  const char *yajl_lex_lex__1__1__1__2__3__want;
  _Bool tmp_if_expr_26;
  unsigned long int return_value_yajl_buf_len_25;
  _Bool tmp_if_expr_28;
  unsigned long int return_value_yajl_buf_len_27;
  signed int tmp_if_expr_32;
  const unsigned char *return_value_yajl_buf_data_29;
  unsigned long int tmp_post_30;
  unsigned long int tmp_post_31;
  do
  {
    /* assertion *offset <= jsonTextLen */
    assert(*offset <= jsonTextLen);
    if(*offset >= jsonTextLen)
    {
      tok = (enum anonymous_29)yajl_tok_eof;
      break;
    }

    if(!(lexer->bufInUse == 0u))
    {
      return_value_yajl_buf_len_1=yajl_buf_len(lexer->buf);
      tmp_if_expr_2 = return_value_yajl_buf_len_1 != 0ul ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
    {
      return_value_yajl_buf_len_3=yajl_buf_len(lexer->buf);
      tmp_if_expr_4 = lexer->bufOff < return_value_yajl_buf_len_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      return_value_yajl_buf_data_5=yajl_buf_data(lexer->buf);
      tmp_post_6 = lexer->bufOff;
      lexer->bufOff = lexer->bufOff + 1ul;
      tmp_if_expr_8 = (signed int)((const unsigned char *)return_value_yajl_buf_data_5)[(signed long int)tmp_post_6];
    }

    else
    {
      tmp_post_7 = *offset;
      *offset = *offset + 1ul;
      tmp_if_expr_8 = (signed int)jsonText[(signed long int)tmp_post_7];
    }
    c = (unsigned char)tmp_if_expr_8;
    switch((signed int)c)
    {
      case 123:
      {
        tok = (enum anonymous_29)yajl_tok_left_bracket;
        goto lexed;
      }
      case 125:
      {
        tok = (enum anonymous_29)yajl_tok_right_bracket;
        goto lexed;
      }
      case 91:
      {
        tok = (enum anonymous_29)yajl_tok_left_brace;
        goto lexed;
      }
      case 93:
      {
        tok = (enum anonymous_29)yajl_tok_right_brace;
        goto lexed;
      }
      case 44:
      {
        tok = (enum anonymous_29)yajl_tok_comma;
        goto lexed;
      }
      case 58:
      {
        tok = (enum anonymous_29)yajl_tok_colon;
        goto lexed;
      }
      case 9:

      case 10:

      case 11:

      case 12:

      case 13:

      case 32:
      {
        startOffset = startOffset + 1ul;
        break;
      }
      case 116:
      {
        want = "rue";
        while((_Bool)1)
        {
          if(*offset >= jsonTextLen)
          {
            tok = (enum anonymous_29)yajl_tok_eof;
            goto lexed;
          }

          if(!(lexer->bufInUse == 0u))
          {
            return_value_yajl_buf_len_9=yajl_buf_len(lexer->buf);
            tmp_if_expr_10 = return_value_yajl_buf_len_9 != 0ul ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_10 = (_Bool)0;
          if(tmp_if_expr_10)
          {
            return_value_yajl_buf_len_11=yajl_buf_len(lexer->buf);
            tmp_if_expr_12 = lexer->bufOff < return_value_yajl_buf_len_11 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_12 = (_Bool)0;
          if(tmp_if_expr_12)
          {
            return_value_yajl_buf_data_13=yajl_buf_data(lexer->buf);
            tmp_post_14 = lexer->bufOff;
            lexer->bufOff = lexer->bufOff + 1ul;
            tmp_if_expr_16 = (signed int)((const unsigned char *)return_value_yajl_buf_data_13)[(signed long int)tmp_post_14];
          }

          else
          {
            tmp_post_15 = *offset;
            *offset = *offset + 1ul;
            tmp_if_expr_16 = (signed int)jsonText[(signed long int)tmp_post_15];
          }
          c = (unsigned char)tmp_if_expr_16;
          if(!((signed int)c == (signed int)*want))
          {
            if(*offset >= 1ul)
              *offset = *offset - 1ul;

            else
              lexer->bufOff = lexer->bufOff - 1ul;
            lexer->error = (enum anonymous_28)yajl_lex_invalid_string;
            tok = (enum anonymous_29)yajl_tok_error;
            goto lexed;
          }

          want = want + 1l;
          if(*want == 0)
            break;

        }
        tok = (enum anonymous_29)yajl_tok_bool;
        goto lexed;
      }
      case 102:
      {
        yajl_lex_lex__1__1__1__2__2__want = "alse";
        while((_Bool)1)
        {
          if(*offset >= jsonTextLen)
          {
            tok = (enum anonymous_29)yajl_tok_eof;
            goto lexed;
          }

          if(!(lexer->bufInUse == 0u))
          {
            return_value_yajl_buf_len_17=yajl_buf_len(lexer->buf);
            tmp_if_expr_18 = return_value_yajl_buf_len_17 != 0ul ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_18 = (_Bool)0;
          if(tmp_if_expr_18)
          {
            return_value_yajl_buf_len_19=yajl_buf_len(lexer->buf);
            tmp_if_expr_20 = lexer->bufOff < return_value_yajl_buf_len_19 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_20 = (_Bool)0;
          if(tmp_if_expr_20)
          {
            return_value_yajl_buf_data_21=yajl_buf_data(lexer->buf);
            tmp_post_22 = lexer->bufOff;
            lexer->bufOff = lexer->bufOff + 1ul;
            tmp_if_expr_24 = (signed int)((const unsigned char *)return_value_yajl_buf_data_21)[(signed long int)tmp_post_22];
          }

          else
          {
            tmp_post_23 = *offset;
            *offset = *offset + 1ul;
            tmp_if_expr_24 = (signed int)jsonText[(signed long int)tmp_post_23];
          }
          c = (unsigned char)tmp_if_expr_24;
          if(!((signed int)c == (signed int)*yajl_lex_lex__1__1__1__2__2__want))
          {
            if(*offset >= 1ul)
              *offset = *offset - 1ul;

            else
              lexer->bufOff = lexer->bufOff - 1ul;
            lexer->error = (enum anonymous_28)yajl_lex_invalid_string;
            tok = (enum anonymous_29)yajl_tok_error;
            goto lexed;
          }

          yajl_lex_lex__1__1__1__2__2__want = yajl_lex_lex__1__1__1__2__2__want + 1l;
          if(*yajl_lex_lex__1__1__1__2__2__want == 0)
            break;

        }
        tok = (enum anonymous_29)yajl_tok_bool;
        goto lexed;
      }
      case 110:
      {
        yajl_lex_lex__1__1__1__2__3__want = "ull";
        while((_Bool)1)
        {
          if(*offset >= jsonTextLen)
          {
            tok = (enum anonymous_29)yajl_tok_eof;
            goto lexed;
          }

          if(!(lexer->bufInUse == 0u))
          {
            return_value_yajl_buf_len_25=yajl_buf_len(lexer->buf);
            tmp_if_expr_26 = return_value_yajl_buf_len_25 != 0ul ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_26 = (_Bool)0;
          if(tmp_if_expr_26)
          {
            return_value_yajl_buf_len_27=yajl_buf_len(lexer->buf);
            tmp_if_expr_28 = lexer->bufOff < return_value_yajl_buf_len_27 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_28 = (_Bool)0;
          if(tmp_if_expr_28)
          {
            return_value_yajl_buf_data_29=yajl_buf_data(lexer->buf);
            tmp_post_30 = lexer->bufOff;
            lexer->bufOff = lexer->bufOff + 1ul;
            tmp_if_expr_32 = (signed int)((const unsigned char *)return_value_yajl_buf_data_29)[(signed long int)tmp_post_30];
          }

          else
          {
            tmp_post_31 = *offset;
            *offset = *offset + 1ul;
            tmp_if_expr_32 = (signed int)jsonText[(signed long int)tmp_post_31];
          }
          c = (unsigned char)tmp_if_expr_32;
          if(!((signed int)c == (signed int)*yajl_lex_lex__1__1__1__2__3__want))
          {
            if(*offset >= 1ul)
              *offset = *offset - 1ul;

            else
              lexer->bufOff = lexer->bufOff - 1ul;
            lexer->error = (enum anonymous_28)yajl_lex_invalid_string;
            tok = (enum anonymous_29)yajl_tok_error;
            goto lexed;
          }

          yajl_lex_lex__1__1__1__2__3__want = yajl_lex_lex__1__1__1__2__3__want + 1l;
          if(*yajl_lex_lex__1__1__1__2__3__want == 0)
            break;

        }
        tok = (enum anonymous_29)yajl_tok_null;
        goto lexed;
      }
      case 34:
      {
        tok=yajl_lex_string(lexer, (const unsigned char *)jsonText, jsonTextLen, offset);
        goto lexed;
      }
      case 45:

      case 48:

      case 49:

      case 50:

      case 51:

      case 52:

      case 53:

      case 54:

      case 55:

      case 56:

      case 57:
      {
        if(*offset >= 1ul)
          *offset = *offset - 1ul;

        else
          lexer->bufOff = lexer->bufOff - 1ul;
        tok=yajl_lex_number(lexer, (const unsigned char *)jsonText, jsonTextLen, offset);
        goto lexed;
      }
      case 47:
      {
        if(lexer->allowComments == 0u)
        {
          if(*offset >= 1ul)
            *offset = *offset - 1ul;

          else
            lexer->bufOff = lexer->bufOff - 1ul;
          lexer->error = (enum anonymous_28)yajl_lex_unallowed_comment;
          tok = (enum anonymous_29)yajl_tok_error;
          goto lexed;
        }

        tok=yajl_lex_comment(lexer, (const unsigned char *)jsonText, jsonTextLen, offset);
        if((signed int)tok == yajl_tok_comment)
        {
          tok = (enum anonymous_29)yajl_tok_error;
          yajl_buf_clear(lexer->buf);
          lexer->bufInUse = (unsigned int)0;
          startOffset = *offset;
          break;
        }

        goto lexed;
      }
      default:
      {
        lexer->error = (enum anonymous_28)yajl_lex_invalid_char;
        tok = (enum anonymous_29)yajl_tok_error;
        goto lexed;
      }
    }
  }
  while((_Bool)1);

lexed:
  ;
  _Bool tmp_if_expr_33;
  if((signed int)tok == yajl_tok_eof)
    tmp_if_expr_33 = (_Bool)1;

  else
    tmp_if_expr_33 = lexer->bufInUse != 0u ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_33)
  {
    if(lexer->bufInUse == 0u)
      yajl_buf_clear(lexer->buf);

    lexer->bufInUse = (unsigned int)1;
    yajl_buf_append(lexer->buf, (const void *)(jsonText + (signed long int)startOffset), *offset - startOffset);
    lexer->bufOff = (unsigned long int)0;
    if(!((signed int)tok == yajl_tok_eof))
    {
      *outBuf=yajl_buf_data(lexer->buf);
      *outLen=yajl_buf_len(lexer->buf);
      lexer->bufInUse = (unsigned int)0;
    }

  }

  else
    if(!((signed int)tok == yajl_tok_error))
    {
      *outBuf = jsonText + (signed long int)startOffset;
      *outLen = *offset - startOffset;
    }

  if((signed int)tok == yajl_tok_string || (signed int)tok == yajl_tok_string_with_escapes)
  {
    /* assertion *outLen >= 2 */
    assert(*outLen >= (unsigned long int)2);
    *outBuf = *outBuf + 1l;
    *outLen = *outLen - (unsigned long int)2;
  }

  return tok;
}

// yajl_lex_number
// file yajl_all.c line 1173
static enum anonymous_29 yajl_lex_number(struct yajl_lexer_t *lexer, const unsigned char *jsonText, unsigned long int jsonTextLen, unsigned long int *offset)
{
  unsigned char c;
  enum anonymous_29 tok = (enum anonymous_29)yajl_tok_integer;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_yajl_buf_len_1;
  _Bool tmp_if_expr_4;
  unsigned long int return_value_yajl_buf_len_3;
  signed int tmp_if_expr_8;
  const unsigned char *return_value_yajl_buf_data_5;
  unsigned long int tmp_post_6;
  unsigned long int tmp_post_7;
  _Bool tmp_if_expr_10;
  unsigned long int return_value_yajl_buf_len_9;
  _Bool tmp_if_expr_12;
  unsigned long int return_value_yajl_buf_len_11;
  signed int tmp_if_expr_16;
  const unsigned char *return_value_yajl_buf_data_13;
  unsigned long int tmp_post_14;
  unsigned long int tmp_post_15;
  _Bool tmp_if_expr_18;
  unsigned long int return_value_yajl_buf_len_17;
  _Bool tmp_if_expr_20;
  unsigned long int return_value_yajl_buf_len_19;
  signed int tmp_if_expr_24;
  const unsigned char *return_value_yajl_buf_data_21;
  unsigned long int tmp_post_22;
  unsigned long int tmp_post_23;
  _Bool tmp_if_expr_26;
  unsigned long int return_value_yajl_buf_len_25;
  _Bool tmp_if_expr_28;
  unsigned long int return_value_yajl_buf_len_27;
  signed int tmp_if_expr_32;
  const unsigned char *return_value_yajl_buf_data_29;
  unsigned long int tmp_post_30;
  unsigned long int tmp_post_31;
  _Bool tmp_if_expr_34;
  unsigned long int return_value_yajl_buf_len_33;
  _Bool tmp_if_expr_36;
  unsigned long int return_value_yajl_buf_len_35;
  signed int tmp_if_expr_40;
  const unsigned char *return_value_yajl_buf_data_37;
  unsigned long int tmp_post_38;
  unsigned long int tmp_post_39;
  _Bool tmp_if_expr_42;
  unsigned long int return_value_yajl_buf_len_41;
  _Bool tmp_if_expr_44;
  unsigned long int return_value_yajl_buf_len_43;
  signed int tmp_if_expr_48;
  const unsigned char *return_value_yajl_buf_data_45;
  unsigned long int tmp_post_46;
  unsigned long int tmp_post_47;
  _Bool tmp_if_expr_50;
  unsigned long int return_value_yajl_buf_len_49;
  _Bool tmp_if_expr_52;
  unsigned long int return_value_yajl_buf_len_51;
  signed int tmp_if_expr_56;
  const unsigned char *return_value_yajl_buf_data_53;
  unsigned long int tmp_post_54;
  unsigned long int tmp_post_55;
  _Bool tmp_if_expr_58;
  unsigned long int return_value_yajl_buf_len_57;
  _Bool tmp_if_expr_60;
  unsigned long int return_value_yajl_buf_len_59;
  signed int tmp_if_expr_64;
  const unsigned char *return_value_yajl_buf_data_61;
  unsigned long int tmp_post_62;
  unsigned long int tmp_post_63;
  _Bool tmp_if_expr_66;
  unsigned long int return_value_yajl_buf_len_65;
  _Bool tmp_if_expr_68;
  unsigned long int return_value_yajl_buf_len_67;
  signed int tmp_if_expr_72;
  const unsigned char *return_value_yajl_buf_data_69;
  unsigned long int tmp_post_70;
  unsigned long int tmp_post_71;
  if(*offset >= jsonTextLen)
    return (enum anonymous_29)yajl_tok_eof;

  else
  {
    if(!(lexer->bufInUse == 0u))
    {
      return_value_yajl_buf_len_1=yajl_buf_len(lexer->buf);
      tmp_if_expr_2 = return_value_yajl_buf_len_1 != 0ul ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
    {
      return_value_yajl_buf_len_3=yajl_buf_len(lexer->buf);
      tmp_if_expr_4 = lexer->bufOff < return_value_yajl_buf_len_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      return_value_yajl_buf_data_5=yajl_buf_data(lexer->buf);
      tmp_post_6 = lexer->bufOff;
      lexer->bufOff = lexer->bufOff + 1ul;
      tmp_if_expr_8 = (signed int)((const unsigned char *)return_value_yajl_buf_data_5)[(signed long int)tmp_post_6];
    }

    else
    {
      tmp_post_7 = *offset;
      *offset = *offset + 1ul;
      tmp_if_expr_8 = (signed int)jsonText[(signed long int)tmp_post_7];
    }
    c = (unsigned char)tmp_if_expr_8;
    if((signed int)c == 45)
    {
      if(*offset >= jsonTextLen)
        return (enum anonymous_29)yajl_tok_eof;

      if(!(lexer->bufInUse == 0u))
      {
        return_value_yajl_buf_len_9=yajl_buf_len(lexer->buf);
        tmp_if_expr_10 = return_value_yajl_buf_len_9 != 0ul ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_10 = (_Bool)0;
      if(tmp_if_expr_10)
      {
        return_value_yajl_buf_len_11=yajl_buf_len(lexer->buf);
        tmp_if_expr_12 = lexer->bufOff < return_value_yajl_buf_len_11 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_12 = (_Bool)0;
      if(tmp_if_expr_12)
      {
        return_value_yajl_buf_data_13=yajl_buf_data(lexer->buf);
        tmp_post_14 = lexer->bufOff;
        lexer->bufOff = lexer->bufOff + 1ul;
        tmp_if_expr_16 = (signed int)((const unsigned char *)return_value_yajl_buf_data_13)[(signed long int)tmp_post_14];
      }

      else
      {
        tmp_post_15 = *offset;
        *offset = *offset + 1ul;
        tmp_if_expr_16 = (signed int)jsonText[(signed long int)tmp_post_15];
      }
      c = (unsigned char)tmp_if_expr_16;
    }

    if((signed int)c == 48)
    {
      if(*offset >= jsonTextLen)
        return (enum anonymous_29)yajl_tok_eof;

      if(!(lexer->bufInUse == 0u))
      {
        return_value_yajl_buf_len_17=yajl_buf_len(lexer->buf);
        tmp_if_expr_18 = return_value_yajl_buf_len_17 != 0ul ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_18 = (_Bool)0;
      if(tmp_if_expr_18)
      {
        return_value_yajl_buf_len_19=yajl_buf_len(lexer->buf);
        tmp_if_expr_20 = lexer->bufOff < return_value_yajl_buf_len_19 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_20 = (_Bool)0;
      if(tmp_if_expr_20)
      {
        return_value_yajl_buf_data_21=yajl_buf_data(lexer->buf);
        tmp_post_22 = lexer->bufOff;
        lexer->bufOff = lexer->bufOff + 1ul;
        tmp_if_expr_24 = (signed int)((const unsigned char *)return_value_yajl_buf_data_21)[(signed long int)tmp_post_22];
      }

      else
      {
        tmp_post_23 = *offset;
        *offset = *offset + 1ul;
        tmp_if_expr_24 = (signed int)jsonText[(signed long int)tmp_post_23];
      }
      c = (unsigned char)tmp_if_expr_24;
    }

    else
      if((signed int)c >= 49 && !((signed int)c >= 58))
        while((_Bool)1)
        {
          if(*offset >= jsonTextLen)
            return (enum anonymous_29)yajl_tok_eof;

          if(!(lexer->bufInUse == 0u))
          {
            return_value_yajl_buf_len_25=yajl_buf_len(lexer->buf);
            tmp_if_expr_26 = return_value_yajl_buf_len_25 != 0ul ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_26 = (_Bool)0;
          if(tmp_if_expr_26)
          {
            return_value_yajl_buf_len_27=yajl_buf_len(lexer->buf);
            tmp_if_expr_28 = lexer->bufOff < return_value_yajl_buf_len_27 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_28 = (_Bool)0;
          if(tmp_if_expr_28)
          {
            return_value_yajl_buf_data_29=yajl_buf_data(lexer->buf);
            tmp_post_30 = lexer->bufOff;
            lexer->bufOff = lexer->bufOff + 1ul;
            tmp_if_expr_32 = (signed int)((const unsigned char *)return_value_yajl_buf_data_29)[(signed long int)tmp_post_30];
          }

          else
          {
            tmp_post_31 = *offset;
            *offset = *offset + 1ul;
            tmp_if_expr_32 = (signed int)jsonText[(signed long int)tmp_post_31];
          }
          c = (unsigned char)tmp_if_expr_32;
          if(!((signed int)c >= 48) || (signed int)c >= 58)
            break;

        }

      else
      {
        if(*offset >= 1ul)
          *offset = *offset - 1ul;

        else
          lexer->bufOff = lexer->bufOff - 1ul;
        lexer->error = (enum anonymous_28)yajl_lex_missing_integer_after_minus;
        return (enum anonymous_29)yajl_tok_error;
      }
    if((signed int)c == 46)
    {
      signed int numRd = 0;
      if(*offset >= jsonTextLen)
        return (enum anonymous_29)yajl_tok_eof;

      if(!(lexer->bufInUse == 0u))
      {
        return_value_yajl_buf_len_33=yajl_buf_len(lexer->buf);
        tmp_if_expr_34 = return_value_yajl_buf_len_33 != 0ul ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_34 = (_Bool)0;
      if(tmp_if_expr_34)
      {
        return_value_yajl_buf_len_35=yajl_buf_len(lexer->buf);
        tmp_if_expr_36 = lexer->bufOff < return_value_yajl_buf_len_35 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_36 = (_Bool)0;
      if(tmp_if_expr_36)
      {
        return_value_yajl_buf_data_37=yajl_buf_data(lexer->buf);
        tmp_post_38 = lexer->bufOff;
        lexer->bufOff = lexer->bufOff + 1ul;
        tmp_if_expr_40 = (signed int)((const unsigned char *)return_value_yajl_buf_data_37)[(signed long int)tmp_post_38];
      }

      else
      {
        tmp_post_39 = *offset;
        *offset = *offset + 1ul;
        tmp_if_expr_40 = (signed int)jsonText[(signed long int)tmp_post_39];
      }
      c = (unsigned char)tmp_if_expr_40;
      while((signed int)c >= 48 && !((signed int)c >= 58))
      {
        numRd = numRd + 1;
        if(*offset >= jsonTextLen)
          return (enum anonymous_29)yajl_tok_eof;

        if(!(lexer->bufInUse == 0u))
        {
          return_value_yajl_buf_len_41=yajl_buf_len(lexer->buf);
          tmp_if_expr_42 = return_value_yajl_buf_len_41 != 0ul ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_42 = (_Bool)0;
        if(tmp_if_expr_42)
        {
          return_value_yajl_buf_len_43=yajl_buf_len(lexer->buf);
          tmp_if_expr_44 = lexer->bufOff < return_value_yajl_buf_len_43 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_44 = (_Bool)0;
        if(tmp_if_expr_44)
        {
          return_value_yajl_buf_data_45=yajl_buf_data(lexer->buf);
          tmp_post_46 = lexer->bufOff;
          lexer->bufOff = lexer->bufOff + 1ul;
          tmp_if_expr_48 = (signed int)((const unsigned char *)return_value_yajl_buf_data_45)[(signed long int)tmp_post_46];
        }

        else
        {
          tmp_post_47 = *offset;
          *offset = *offset + 1ul;
          tmp_if_expr_48 = (signed int)jsonText[(signed long int)tmp_post_47];
        }
        c = (unsigned char)tmp_if_expr_48;
      }
      if(numRd == 0)
      {
        if(*offset >= 1ul)
          *offset = *offset - 1ul;

        else
          lexer->bufOff = lexer->bufOff - 1ul;
        lexer->error = (enum anonymous_28)yajl_lex_missing_integer_after_decimal;
        return (enum anonymous_29)yajl_tok_error;
      }

      tok = (enum anonymous_29)yajl_tok_double;
    }

    if((signed int)c == 69 || (signed int)c == 101)
    {
      if(*offset >= jsonTextLen)
        return (enum anonymous_29)yajl_tok_eof;

      if(!(lexer->bufInUse == 0u))
      {
        return_value_yajl_buf_len_49=yajl_buf_len(lexer->buf);
        tmp_if_expr_50 = return_value_yajl_buf_len_49 != 0ul ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_50 = (_Bool)0;
      if(tmp_if_expr_50)
      {
        return_value_yajl_buf_len_51=yajl_buf_len(lexer->buf);
        tmp_if_expr_52 = lexer->bufOff < return_value_yajl_buf_len_51 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_52 = (_Bool)0;
      if(tmp_if_expr_52)
      {
        return_value_yajl_buf_data_53=yajl_buf_data(lexer->buf);
        tmp_post_54 = lexer->bufOff;
        lexer->bufOff = lexer->bufOff + 1ul;
        tmp_if_expr_56 = (signed int)((const unsigned char *)return_value_yajl_buf_data_53)[(signed long int)tmp_post_54];
      }

      else
      {
        tmp_post_55 = *offset;
        *offset = *offset + 1ul;
        tmp_if_expr_56 = (signed int)jsonText[(signed long int)tmp_post_55];
      }
      c = (unsigned char)tmp_if_expr_56;
      if((signed int)c == 43 || (signed int)c == 45)
      {
        if(*offset >= jsonTextLen)
          return (enum anonymous_29)yajl_tok_eof;

        if(!(lexer->bufInUse == 0u))
        {
          return_value_yajl_buf_len_57=yajl_buf_len(lexer->buf);
          tmp_if_expr_58 = return_value_yajl_buf_len_57 != 0ul ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_58 = (_Bool)0;
        if(tmp_if_expr_58)
        {
          return_value_yajl_buf_len_59=yajl_buf_len(lexer->buf);
          tmp_if_expr_60 = lexer->bufOff < return_value_yajl_buf_len_59 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_60 = (_Bool)0;
        if(tmp_if_expr_60)
        {
          return_value_yajl_buf_data_61=yajl_buf_data(lexer->buf);
          tmp_post_62 = lexer->bufOff;
          lexer->bufOff = lexer->bufOff + 1ul;
          tmp_if_expr_64 = (signed int)((const unsigned char *)return_value_yajl_buf_data_61)[(signed long int)tmp_post_62];
        }

        else
        {
          tmp_post_63 = *offset;
          *offset = *offset + 1ul;
          tmp_if_expr_64 = (signed int)jsonText[(signed long int)tmp_post_63];
        }
        c = (unsigned char)tmp_if_expr_64;
      }

      if((signed int)c >= 48 && !((signed int)c >= 58))
        while((_Bool)1)
        {
          if(*offset >= jsonTextLen)
            return (enum anonymous_29)yajl_tok_eof;

          if(!(lexer->bufInUse == 0u))
          {
            return_value_yajl_buf_len_65=yajl_buf_len(lexer->buf);
            tmp_if_expr_66 = return_value_yajl_buf_len_65 != 0ul ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_66 = (_Bool)0;
          if(tmp_if_expr_66)
          {
            return_value_yajl_buf_len_67=yajl_buf_len(lexer->buf);
            tmp_if_expr_68 = lexer->bufOff < return_value_yajl_buf_len_67 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_68 = (_Bool)0;
          if(tmp_if_expr_68)
          {
            return_value_yajl_buf_data_69=yajl_buf_data(lexer->buf);
            tmp_post_70 = lexer->bufOff;
            lexer->bufOff = lexer->bufOff + 1ul;
            tmp_if_expr_72 = (signed int)((const unsigned char *)return_value_yajl_buf_data_69)[(signed long int)tmp_post_70];
          }

          else
          {
            tmp_post_71 = *offset;
            *offset = *offset + 1ul;
            tmp_if_expr_72 = (signed int)jsonText[(signed long int)tmp_post_71];
          }
          c = (unsigned char)tmp_if_expr_72;
          if(!((signed int)c >= 48) || (signed int)c >= 58)
            break;

        }

      else
      {
        if(*offset >= 1ul)
          *offset = *offset - 1ul;

        else
          lexer->bufOff = lexer->bufOff - 1ul;
        lexer->error = (enum anonymous_28)yajl_lex_missing_integer_after_exponent;
        return (enum anonymous_29)yajl_tok_error;
      }
      tok = (enum anonymous_29)yajl_tok_double;
    }

    if(*offset >= 1ul)
      *offset = *offset - 1ul;

    else
      lexer->bufOff = lexer->bufOff - 1ul;
    return tok;
  }
}

// yajl_lex_string
// file yajl_all.c line 1070
static enum anonymous_29 yajl_lex_string(struct yajl_lexer_t *lexer, const unsigned char *jsonText, unsigned long int jsonTextLen, unsigned long int *offset)
{
  enum anonymous_29 tok = (enum anonymous_29)yajl_tok_error;
  signed int hasEscapes = 0;
  _Bool tmp_if_expr_6;
  unsigned long int return_value_yajl_buf_len_5;
  _Bool tmp_if_expr_8;
  unsigned long int return_value_yajl_buf_len_7;
  _Bool tmp_if_expr_10;
  unsigned long int return_value_yajl_buf_len_9;
  _Bool tmp_if_expr_12;
  unsigned long int return_value_yajl_buf_len_11;
  signed int tmp_if_expr_16;
  const unsigned char *return_value_yajl_buf_data_13;
  unsigned long int tmp_post_14;
  unsigned long int tmp_post_15;
  _Bool tmp_if_expr_18;
  unsigned long int return_value_yajl_buf_len_17;
  _Bool tmp_if_expr_20;
  unsigned long int return_value_yajl_buf_len_19;
  signed int tmp_if_expr_24;
  const unsigned char *return_value_yajl_buf_data_21;
  unsigned long int tmp_post_22;
  unsigned long int tmp_post_23;
  _Bool tmp_if_expr_26;
  unsigned long int return_value_yajl_buf_len_25;
  _Bool tmp_if_expr_28;
  unsigned long int return_value_yajl_buf_len_27;
  signed int tmp_if_expr_32;
  const unsigned char *return_value_yajl_buf_data_29;
  unsigned long int tmp_post_30;
  unsigned long int tmp_post_31;
  do
  {
    unsigned char curChar;
    const unsigned char *p;
    unsigned long int len;
    if(!(lexer->bufInUse == 0u))
    {
      return_value_yajl_buf_len_5=yajl_buf_len(lexer->buf);
      tmp_if_expr_6 = return_value_yajl_buf_len_5 != 0ul ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_6 = (_Bool)0;
    if(tmp_if_expr_6)
    {
      return_value_yajl_buf_len_7=yajl_buf_len(lexer->buf);
      tmp_if_expr_8 = lexer->bufOff < return_value_yajl_buf_len_7 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    if(tmp_if_expr_8)
    {
      const unsigned char *return_value_yajl_buf_data_1;
      return_value_yajl_buf_data_1=yajl_buf_data(lexer->buf);
      p = (const unsigned char *)return_value_yajl_buf_data_1 + (signed long int)lexer->bufOff;
      unsigned long int return_value_yajl_buf_len_2;
      return_value_yajl_buf_len_2=yajl_buf_len(lexer->buf);
      len = return_value_yajl_buf_len_2 - lexer->bufOff;
      unsigned long int return_value_yajl_string_scan_3;
      return_value_yajl_string_scan_3=yajl_string_scan(p, len, (signed int)lexer->validateUTF8);
      lexer->bufOff = lexer->bufOff + return_value_yajl_string_scan_3;
    }

    else
      if(!(*offset >= jsonTextLen))
      {
        p = jsonText + (signed long int)*offset;
        len = jsonTextLen - *offset;
        unsigned long int return_value_yajl_string_scan_4;
        return_value_yajl_string_scan_4=yajl_string_scan(p, len, (signed int)lexer->validateUTF8);
        *offset = *offset + return_value_yajl_string_scan_4;
      }

    if(*offset >= jsonTextLen)
    {
      tok = (enum anonymous_29)yajl_tok_eof;
      break;
    }

    if(!(lexer->bufInUse == 0u))
    {
      return_value_yajl_buf_len_9=yajl_buf_len(lexer->buf);
      tmp_if_expr_10 = return_value_yajl_buf_len_9 != 0ul ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_10 = (_Bool)0;
    if(tmp_if_expr_10)
    {
      return_value_yajl_buf_len_11=yajl_buf_len(lexer->buf);
      tmp_if_expr_12 = lexer->bufOff < return_value_yajl_buf_len_11 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_12 = (_Bool)0;
    if(tmp_if_expr_12)
    {
      return_value_yajl_buf_data_13=yajl_buf_data(lexer->buf);
      tmp_post_14 = lexer->bufOff;
      lexer->bufOff = lexer->bufOff + 1ul;
      tmp_if_expr_16 = (signed int)((const unsigned char *)return_value_yajl_buf_data_13)[(signed long int)tmp_post_14];
    }

    else
    {
      tmp_post_15 = *offset;
      *offset = *offset + 1ul;
      tmp_if_expr_16 = (signed int)jsonText[(signed long int)tmp_post_15];
    }
    curChar = (unsigned char)tmp_if_expr_16;
    if((signed int)curChar == 34)
    {
      tok = (enum anonymous_29)yajl_tok_string;
      break;
    }

    else
      if((signed int)curChar == 92)
      {
        hasEscapes = 1;
        if(*offset >= jsonTextLen)
        {
          tok = (enum anonymous_29)yajl_tok_eof;
          break;
        }

        if(!(lexer->bufInUse == 0u))
        {
          return_value_yajl_buf_len_17=yajl_buf_len(lexer->buf);
          tmp_if_expr_18 = return_value_yajl_buf_len_17 != 0ul ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_18 = (_Bool)0;
        if(tmp_if_expr_18)
        {
          return_value_yajl_buf_len_19=yajl_buf_len(lexer->buf);
          tmp_if_expr_20 = lexer->bufOff < return_value_yajl_buf_len_19 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_20 = (_Bool)0;
        if(tmp_if_expr_20)
        {
          return_value_yajl_buf_data_21=yajl_buf_data(lexer->buf);
          tmp_post_22 = lexer->bufOff;
          lexer->bufOff = lexer->bufOff + 1ul;
          tmp_if_expr_24 = (signed int)((const unsigned char *)return_value_yajl_buf_data_21)[(signed long int)tmp_post_22];
        }

        else
        {
          tmp_post_23 = *offset;
          *offset = *offset + 1ul;
          tmp_if_expr_24 = (signed int)jsonText[(signed long int)tmp_post_23];
        }
        curChar = (unsigned char)tmp_if_expr_24;
        if((signed int)curChar == 117)
        {
          unsigned int i = (unsigned int)0;
          i = (unsigned int)0;
          for( ; !(i >= 4u); i = i + 1u)
          {
            if(*offset >= jsonTextLen)
            {
              tok = (enum anonymous_29)yajl_tok_eof;
              goto finish_string_lex;
            }

            if(!(lexer->bufInUse == 0u))
            {
              return_value_yajl_buf_len_25=yajl_buf_len(lexer->buf);
              tmp_if_expr_26 = return_value_yajl_buf_len_25 != 0ul ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_26 = (_Bool)0;
            if(tmp_if_expr_26)
            {
              return_value_yajl_buf_len_27=yajl_buf_len(lexer->buf);
              tmp_if_expr_28 = lexer->bufOff < return_value_yajl_buf_len_27 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_28 = (_Bool)0;
            if(tmp_if_expr_28)
            {
              return_value_yajl_buf_data_29=yajl_buf_data(lexer->buf);
              tmp_post_30 = lexer->bufOff;
              lexer->bufOff = lexer->bufOff + 1ul;
              tmp_if_expr_32 = (signed int)((const unsigned char *)return_value_yajl_buf_data_29)[(signed long int)tmp_post_30];
            }

            else
            {
              tmp_post_31 = *offset;
              *offset = *offset + 1ul;
              tmp_if_expr_32 = (signed int)jsonText[(signed long int)tmp_post_31];
            }
            curChar = (unsigned char)tmp_if_expr_32;
            if((0x04 & (signed int)charLookupTable[(signed long int)curChar]) == 0)
            {
              if(*offset >= 1ul)
                *offset = *offset - 1ul;

              else
                lexer->bufOff = lexer->bufOff - 1ul;
              lexer->error = (enum anonymous_28)yajl_lex_string_invalid_hex_char;
              goto finish_string_lex;
            }

          }
        }

        else
          if((0x01 & (signed int)charLookupTable[(signed long int)curChar]) == 0)
          {
            if(*offset >= 1ul)
              *offset = *offset - 1ul;

            else
              lexer->bufOff = lexer->bufOff - 1ul;
            lexer->error = (enum anonymous_28)yajl_lex_string_invalid_escaped_char;
            break;
          }

      }

      else
        if(!((0x02 & (signed int)charLookupTable[(signed long int)curChar]) == 0))
        {
          if(*offset >= 1ul)
            *offset = *offset - 1ul;

          else
            lexer->bufOff = lexer->bufOff - 1ul;
          lexer->error = (enum anonymous_28)yajl_lex_string_invalid_json_char;
          break;
        }

        else
          if(!(lexer->validateUTF8 == 0u))
          {
            enum anonymous_29 t;
            t=yajl_lex_utf8_char(lexer, jsonText, jsonTextLen, offset, curChar);
            if((signed int)t == yajl_tok_eof)
            {
              tok = (enum anonymous_29)yajl_tok_eof;
              break;
            }

            else
              if((signed int)t == yajl_tok_error)
              {
                lexer->error = (enum anonymous_28)yajl_lex_string_invalid_utf8;
                break;
              }

          }

  }
  while((_Bool)1);

finish_string_lex:
  ;
  if((signed int)tok == yajl_tok_string && !(hasEscapes == 0))
    tok = (enum anonymous_29)yajl_tok_string_with_escapes;

  return tok;
}

// yajl_lex_utf8_char
// file yajl_all.c line 997
static enum anonymous_29 yajl_lex_utf8_char(struct yajl_lexer_t *lexer, const unsigned char *jsonText, unsigned long int jsonTextLen, unsigned long int *offset, unsigned char curChar)
{
  _Bool tmp_if_expr_2;
  unsigned long int return_value_yajl_buf_len_1;
  _Bool tmp_if_expr_4;
  unsigned long int return_value_yajl_buf_len_3;
  signed int tmp_if_expr_8;
  const unsigned char *return_value_yajl_buf_data_5;
  unsigned long int tmp_post_6;
  unsigned long int tmp_post_7;
  _Bool tmp_if_expr_10;
  unsigned long int return_value_yajl_buf_len_9;
  _Bool tmp_if_expr_12;
  unsigned long int return_value_yajl_buf_len_11;
  signed int tmp_if_expr_16;
  const unsigned char *return_value_yajl_buf_data_13;
  unsigned long int tmp_post_14;
  unsigned long int tmp_post_15;
  _Bool tmp_if_expr_18;
  unsigned long int return_value_yajl_buf_len_17;
  _Bool tmp_if_expr_20;
  unsigned long int return_value_yajl_buf_len_19;
  signed int tmp_if_expr_24;
  const unsigned char *return_value_yajl_buf_data_21;
  unsigned long int tmp_post_22;
  unsigned long int tmp_post_23;
  _Bool tmp_if_expr_26;
  unsigned long int return_value_yajl_buf_len_25;
  _Bool tmp_if_expr_28;
  unsigned long int return_value_yajl_buf_len_27;
  signed int tmp_if_expr_32;
  const unsigned char *return_value_yajl_buf_data_29;
  unsigned long int tmp_post_30;
  unsigned long int tmp_post_31;
  _Bool tmp_if_expr_34;
  unsigned long int return_value_yajl_buf_len_33;
  _Bool tmp_if_expr_36;
  unsigned long int return_value_yajl_buf_len_35;
  signed int tmp_if_expr_40;
  const unsigned char *return_value_yajl_buf_data_37;
  unsigned long int tmp_post_38;
  unsigned long int tmp_post_39;
  _Bool tmp_if_expr_42;
  unsigned long int return_value_yajl_buf_len_41;
  _Bool tmp_if_expr_44;
  unsigned long int return_value_yajl_buf_len_43;
  signed int tmp_if_expr_48;
  const unsigned char *return_value_yajl_buf_data_45;
  unsigned long int tmp_post_46;
  unsigned long int tmp_post_47;
  if(!((signed int)curChar >= 128))
    return (enum anonymous_29)yajl_tok_string;

  else
    if((signed int)curChar >> 5 == 0x6)
    {
      if(*offset >= jsonTextLen)
        return (enum anonymous_29)yajl_tok_eof;

      if(!(lexer->bufInUse == 0u))
      {
        return_value_yajl_buf_len_1=yajl_buf_len(lexer->buf);
        tmp_if_expr_2 = return_value_yajl_buf_len_1 != 0ul ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
      {
        return_value_yajl_buf_len_3=yajl_buf_len(lexer->buf);
        tmp_if_expr_4 = lexer->bufOff < return_value_yajl_buf_len_3 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
      {
        return_value_yajl_buf_data_5=yajl_buf_data(lexer->buf);
        tmp_post_6 = lexer->bufOff;
        lexer->bufOff = lexer->bufOff + 1ul;
        tmp_if_expr_8 = (signed int)((const unsigned char *)return_value_yajl_buf_data_5)[(signed long int)tmp_post_6];
      }

      else
      {
        tmp_post_7 = *offset;
        *offset = *offset + 1ul;
        tmp_if_expr_8 = (signed int)jsonText[(signed long int)tmp_post_7];
      }
      curChar = (unsigned char)tmp_if_expr_8;
      if((signed int)curChar >> 6 == 0x2)
        return (enum anonymous_29)yajl_tok_string;

    }

    else
      if((signed int)curChar >> 4 == 0x0e)
      {
        if(*offset >= jsonTextLen)
          return (enum anonymous_29)yajl_tok_eof;

        if(!(lexer->bufInUse == 0u))
        {
          return_value_yajl_buf_len_9=yajl_buf_len(lexer->buf);
          tmp_if_expr_10 = return_value_yajl_buf_len_9 != 0ul ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_10 = (_Bool)0;
        if(tmp_if_expr_10)
        {
          return_value_yajl_buf_len_11=yajl_buf_len(lexer->buf);
          tmp_if_expr_12 = lexer->bufOff < return_value_yajl_buf_len_11 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_12 = (_Bool)0;
        if(tmp_if_expr_12)
        {
          return_value_yajl_buf_data_13=yajl_buf_data(lexer->buf);
          tmp_post_14 = lexer->bufOff;
          lexer->bufOff = lexer->bufOff + 1ul;
          tmp_if_expr_16 = (signed int)((const unsigned char *)return_value_yajl_buf_data_13)[(signed long int)tmp_post_14];
        }

        else
        {
          tmp_post_15 = *offset;
          *offset = *offset + 1ul;
          tmp_if_expr_16 = (signed int)jsonText[(signed long int)tmp_post_15];
        }
        curChar = (unsigned char)tmp_if_expr_16;
        if((signed int)curChar >> 6 == 0x2)
        {
          if(*offset >= jsonTextLen)
            return (enum anonymous_29)yajl_tok_eof;

          if(!(lexer->bufInUse == 0u))
          {
            return_value_yajl_buf_len_17=yajl_buf_len(lexer->buf);
            tmp_if_expr_18 = return_value_yajl_buf_len_17 != 0ul ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_18 = (_Bool)0;
          if(tmp_if_expr_18)
          {
            return_value_yajl_buf_len_19=yajl_buf_len(lexer->buf);
            tmp_if_expr_20 = lexer->bufOff < return_value_yajl_buf_len_19 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_20 = (_Bool)0;
          if(tmp_if_expr_20)
          {
            return_value_yajl_buf_data_21=yajl_buf_data(lexer->buf);
            tmp_post_22 = lexer->bufOff;
            lexer->bufOff = lexer->bufOff + 1ul;
            tmp_if_expr_24 = (signed int)((const unsigned char *)return_value_yajl_buf_data_21)[(signed long int)tmp_post_22];
          }

          else
          {
            tmp_post_23 = *offset;
            *offset = *offset + 1ul;
            tmp_if_expr_24 = (signed int)jsonText[(signed long int)tmp_post_23];
          }
          curChar = (unsigned char)tmp_if_expr_24;
          if((signed int)curChar >> 6 == 0x2)
            return (enum anonymous_29)yajl_tok_string;

        }

      }

      else
        if((signed int)curChar >> 3 == 0x1e)
        {
          if(*offset >= jsonTextLen)
            return (enum anonymous_29)yajl_tok_eof;

          if(!(lexer->bufInUse == 0u))
          {
            return_value_yajl_buf_len_25=yajl_buf_len(lexer->buf);
            tmp_if_expr_26 = return_value_yajl_buf_len_25 != 0ul ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_26 = (_Bool)0;
          if(tmp_if_expr_26)
          {
            return_value_yajl_buf_len_27=yajl_buf_len(lexer->buf);
            tmp_if_expr_28 = lexer->bufOff < return_value_yajl_buf_len_27 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_28 = (_Bool)0;
          if(tmp_if_expr_28)
          {
            return_value_yajl_buf_data_29=yajl_buf_data(lexer->buf);
            tmp_post_30 = lexer->bufOff;
            lexer->bufOff = lexer->bufOff + 1ul;
            tmp_if_expr_32 = (signed int)((const unsigned char *)return_value_yajl_buf_data_29)[(signed long int)tmp_post_30];
          }

          else
          {
            tmp_post_31 = *offset;
            *offset = *offset + 1ul;
            tmp_if_expr_32 = (signed int)jsonText[(signed long int)tmp_post_31];
          }
          curChar = (unsigned char)tmp_if_expr_32;
          if((signed int)curChar >> 6 == 0x2)
          {
            if(*offset >= jsonTextLen)
              return (enum anonymous_29)yajl_tok_eof;

            if(!(lexer->bufInUse == 0u))
            {
              return_value_yajl_buf_len_33=yajl_buf_len(lexer->buf);
              tmp_if_expr_34 = return_value_yajl_buf_len_33 != 0ul ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_34 = (_Bool)0;
            if(tmp_if_expr_34)
            {
              return_value_yajl_buf_len_35=yajl_buf_len(lexer->buf);
              tmp_if_expr_36 = lexer->bufOff < return_value_yajl_buf_len_35 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_36 = (_Bool)0;
            if(tmp_if_expr_36)
            {
              return_value_yajl_buf_data_37=yajl_buf_data(lexer->buf);
              tmp_post_38 = lexer->bufOff;
              lexer->bufOff = lexer->bufOff + 1ul;
              tmp_if_expr_40 = (signed int)((const unsigned char *)return_value_yajl_buf_data_37)[(signed long int)tmp_post_38];
            }

            else
            {
              tmp_post_39 = *offset;
              *offset = *offset + 1ul;
              tmp_if_expr_40 = (signed int)jsonText[(signed long int)tmp_post_39];
            }
            curChar = (unsigned char)tmp_if_expr_40;
            if((signed int)curChar >> 6 == 0x2)
            {
              if(*offset >= jsonTextLen)
                return (enum anonymous_29)yajl_tok_eof;

              if(!(lexer->bufInUse == 0u))
              {
                return_value_yajl_buf_len_41=yajl_buf_len(lexer->buf);
                tmp_if_expr_42 = return_value_yajl_buf_len_41 != 0ul ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_42 = (_Bool)0;
              if(tmp_if_expr_42)
              {
                return_value_yajl_buf_len_43=yajl_buf_len(lexer->buf);
                tmp_if_expr_44 = lexer->bufOff < return_value_yajl_buf_len_43 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_44 = (_Bool)0;
              if(tmp_if_expr_44)
              {
                return_value_yajl_buf_data_45=yajl_buf_data(lexer->buf);
                tmp_post_46 = lexer->bufOff;
                lexer->bufOff = lexer->bufOff + 1ul;
                tmp_if_expr_48 = (signed int)((const unsigned char *)return_value_yajl_buf_data_45)[(signed long int)tmp_post_46];
              }

              else
              {
                tmp_post_47 = *offset;
                *offset = *offset + 1ul;
                tmp_if_expr_48 = (signed int)jsonText[(signed long int)tmp_post_47];
              }
              curChar = (unsigned char)tmp_if_expr_48;
              if((signed int)curChar >> 6 == 0x2)
                return (enum anonymous_29)yajl_tok_string;

            }

          }

        }

  return (enum anonymous_29)yajl_tok_error;
}

// yajl_parse
// file ../json/yajl_api.h line 205
enum anonymous_27 yajl_parse(struct yajl_handle_t *hand, const unsigned char *jsonText, unsigned long int jsonTextLen)
{
  enum anonymous_27 status;
  if(hand->lexer == ((struct yajl_lexer_t *)NULL))
    hand->lexer=yajl_lex_alloc(&hand->alloc, hand->flags & (unsigned int)yajl_allow_comments, (unsigned int)!((hand->flags & (unsigned int)yajl_dont_validate_strings) != 0u));

  status=yajl_do_parse(hand, jsonText, jsonTextLen);
  return status;
}

// yajl_parse_integer
// file yajl_all.c line 1541
static signed long long int yajl_parse_integer(const unsigned char *number, unsigned int length)
{
  signed long long int ret = (signed long long int)0;
  signed long int sign = (signed long int)1;
  const unsigned char *pos = number;
  if((signed int)*pos == 45)
  {
    pos = pos + 1l;
    sign = (signed long int)-1;
  }

  if((signed int)*pos == 43)
    pos = pos + 1l;

  _Bool tmp_if_expr_4;
  const unsigned char *tmp_post_5;
  for( ; !(pos >= number + (signed long int)length); ret = ret + (signed long long int)((signed int)*tmp_post_5 - 48))
  {
    if(ret >= 922337203685477588ll)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 34;
      return sign == (signed long int)1 ? 0x7fffffffffffffffLL : -0x7fffffffffffffffLL - 1LL;
    }

    ret = ret * (signed long long int)10;
    if(!(0x7fffffffffffffffLL + -ret >= (signed long int)((signed int)*pos + -48)))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 34;
      return sign == (signed long int)1 ? 0x7fffffffffffffffLL : -0x7fffffffffffffffLL - 1LL;
    }

    if(!((signed int)*pos >= 48))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)*pos > 57 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 34;
      return sign == (signed long int)1 ? 0x7fffffffffffffffLL : -0x7fffffffffffffffLL - 1LL;
    }

    tmp_post_5 = pos;
    pos = pos + 1l;
  }
  return sign * ret;
}

// yajl_render_error_string
// file yajl_all.c line 1570
static unsigned char * yajl_render_error_string(struct yajl_handle_t *hand, const unsigned char *jsonText, unsigned long int jsonTextLen, signed int verbose)
{
  unsigned long int offset = hand->bytesConsumed;
  unsigned char *str;
  const char *errorType = (const char *)(void *)0;
  const char *errorText = (const char *)(void *)0;
  char text[72l];
  const char *arrow = "                     (right here) ------^\n";
  /* assertion (hand->stateStack).used > 0 */
  assert(hand->stateStack.used > (unsigned long int)0);
  if((signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_parse_error)
  {
    errorType = "parse";
    errorText = hand->parseError;
  }

  else
  {
    /* assertion (hand->stateStack).used > 0 */
    assert(hand->stateStack.used > (unsigned long int)0);
    if((signed int)hand->stateStack.stack[-1l + (signed long int)hand->stateStack.used] == yajl_state_lexical_error)
    {
      errorType = "lexical";
      enum anonymous_28 return_value_yajl_lex_get_error_1;
      return_value_yajl_lex_get_error_1=yajl_lex_get_error(hand->lexer);
      errorText=yajl_lex_error_to_string(return_value_yajl_lex_get_error_1);
    }

    else
      errorType = "unknown";
  }
  unsigned long int yajl_render_error_string__1__4__memneeded = (unsigned long int)0;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(errorType);
  yajl_render_error_string__1__4__memneeded = yajl_render_error_string__1__4__memneeded + return_value_strlen_2;
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(" error");
  yajl_render_error_string__1__4__memneeded = yajl_render_error_string__1__4__memneeded + return_value_strlen_3;
  if(!(errorText == ((const char *)NULL)))
  {
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(": ");
    yajl_render_error_string__1__4__memneeded = yajl_render_error_string__1__4__memneeded + return_value_strlen_4;
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen(errorText);
    yajl_render_error_string__1__4__memneeded = yajl_render_error_string__1__4__memneeded + return_value_strlen_5;
  }

  void *return_value;
  return_value=(&hand->alloc)->malloc((&hand->alloc)->ctx, yajl_render_error_string__1__4__memneeded + (unsigned long int)2);
  str = (unsigned char *)return_value;
  _Bool tmp_if_expr_6;
  unsigned long int tmp_post_7;
  if(str == ((unsigned char *)NULL))
    return (unsigned char *)(void *)0;

  else
  {
    str[(signed long int)0] = (unsigned char)0;
    strcat((char *)str, errorType);
    strcat((char *)str, " error");
    if(!(errorText == ((const char *)NULL)))
    {
      strcat((char *)str, ": ");
      strcat((char *)str, errorText);
    }

    strcat((char *)str, "\n");
    if(!(verbose == 0))
    {
      unsigned long int start;
      unsigned long int end;
      unsigned long int i;
      unsigned long int spacesNeeded = offset < (unsigned long int)30 ? (unsigned long int)40 - offset : (unsigned long int)10;
      start = offset >= (unsigned long int)30 ? offset - (unsigned long int)30 : (unsigned long int)0;
      end = offset + (unsigned long int)30 > jsonTextLen ? jsonTextLen : offset + (unsigned long int)30;
      i = (unsigned long int)0;
      if(!(i >= spacesNeeded))
      {
        text[(signed long int)i] = (char)32;
        i = i + 1ul;
      }

      if(!(start >= end))
      {
        if(!((signed int)jsonText[(signed long int)start] == 10))
          tmp_if_expr_6 = (signed int)jsonText[(signed long int)start] != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_6 = (_Bool)0;
        if(tmp_if_expr_6)
          text[(signed long int)i] = (char)jsonText[(signed long int)start];

        else
          text[(signed long int)i] = (char)32;
        start = start + 1ul;
        i = i + 1ul;
      }

      /* assertion i <= 71 */
      assert(i <= (unsigned long int)71);
      tmp_post_7 = i;
      i = i + 1ul;
      text[(signed long int)tmp_post_7] = (char)10;
      text[(signed long int)i] = (char)0;
      unsigned long int memneeded;
      unsigned long int return_value_strlen_8;
      return_value_strlen_8=strlen((char *)str);
      unsigned long int return_value_strlen_9;
      return_value_strlen_9=strlen((char *)text);
      unsigned long int return_value_strlen_10;
      return_value_strlen_10=strlen(arrow);
      memneeded = (unsigned long int)(unsigned int)(return_value_strlen_8 + return_value_strlen_9 + return_value_strlen_10 + (unsigned long int)1);
      char *newStr;
      void *return_value_1;
      return_value_1=(&hand->alloc)->malloc((&hand->alloc)->ctx, memneeded);
      newStr = (char *)return_value_1;
      if(!(newStr == ((char *)NULL)))
      {
        newStr[(signed long int)0] = (char)0;
        strcat((char *)newStr, (char *)str);
        strcat((char *)newStr, text);
        strcat((char *)newStr, arrow);
      }

      (&hand->alloc)->free((&hand->alloc)->ctx, (void *)str);
      str = (unsigned char *)newStr;
    }

    return str;
  }
}

// yajl_set_default_alloc_funcs
// file yajl_all.c line 123
static void yajl_set_default_alloc_funcs(struct anonymous_3 *yaf)
{
  yaf->malloc = yajl_internal_malloc;
  yaf->free = yajl_internal_free;
  yaf->realloc = yajl_internal_realloc;
  yaf->ctx = (void *)0;
}

// yajl_status_to_string
// file yajl_all.c line 198
const char * yajl_status_to_string(enum anonymous_27 stat)
{
  const char *statStr = "unknown";
  switch((signed int)stat)
  {
    case yajl_status_ok:
    {
      statStr = "ok, no error";
      break;
    }
    case yajl_status_client_canceled:
    {
      statStr = "client canceled parse";
      break;
    }
    case yajl_status_error:
      statStr = "parse error";
  }
  return statStr;
}

// yajl_string_decode
// file yajl_all.c line 438
static void yajl_string_decode(struct yajl_buf_t *buf, const unsigned char *str, unsigned long int len)
{
  unsigned long int beg = (unsigned long int)0;
  unsigned long int end = (unsigned long int)0;
  unsigned int codepoint;
  _Bool tmp_if_expr_1;
  while(!(end >= len))
  {
    if((signed int)str[(signed long int)end] == 92)
    {
      char utf8Buf[5l];
      const char *unescaped = "?";
      yajl_buf_append(buf, (const void *)(str + (signed long int)beg), end - beg);
      end = end + 1ul;
      switch((signed int)str[(signed long int)end])
      {
        case 114:
        {
          unescaped = "\r";
          break;
        }
        case 110:
        {
          unescaped = "\n";
          break;
        }
        case 92:
        {
          unescaped = "\\";
          break;
        }
        case 47:
        {
          unescaped = "/";
          break;
        }
        case 34:
        {
          unescaped = "\"";
          break;
        }
        case 102:
        {
          unescaped = "\f";
          break;
        }
        case 98:
        {
          unescaped = "\b";
          break;
        }
        case 116:
        {
          unescaped = "\t";
          break;
        }
        case 117:
        {
          codepoint = (unsigned int)0;
          end = end + 1ul;
          hexToDigit(&codepoint, str + (signed long int)end);
          end = end + (unsigned long int)3;
          if((64512u & codepoint) == 55296u)
          {
            end = end + 1ul;
            if((signed int)str[(signed long int)end] == 92)
              tmp_if_expr_1 = (signed int)str[(signed long int)(end + (unsigned long int)1)] == 117 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_1 = (_Bool)0;
            if(tmp_if_expr_1)
            {
              unsigned int surrogate = (unsigned int)0;
              hexToDigit(&surrogate, str + (signed long int)end + (signed long int)2);
              codepoint = (codepoint & (unsigned int)0x3F) << 10 | (codepoint >> 6 & (unsigned int)0xF) + (unsigned int)1 << 16 | surrogate & (unsigned int)0x3FF;
              end = end + (unsigned long int)5;
            }

            else
            {
              unescaped = "?";
              break;
            }
          }

          Utf32toUtf8(codepoint, utf8Buf);
          unescaped = utf8Buf;
          if(codepoint == 0u)
          {
            yajl_buf_append(buf, (const void *)unescaped, (unsigned long int)1);
            end = end + 1ul;
            beg = end;
            goto __CPROVER_DUMP_L19;
          }

          break;
        }
        default:
          /* assertion "this should never happen" == ((void *)0) */
          assert("this should never happen" == (char *)(void *)0);
      }
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(unescaped);
      yajl_buf_append(buf, (const void *)unescaped, (unsigned long int)(unsigned int)return_value_strlen_2);
      end = end + 1ul;
      beg = end;
    }

    else
      end = end + 1ul;

  __CPROVER_DUMP_L19:
    ;
  }
  yajl_buf_append(buf, (const void *)(str + (signed long int)beg), end - beg);
}

// yajl_string_encode
// file yajl_all.c line 354
static void yajl_string_encode(void (* const print)(void *, const char *, unsigned long int), void *ctx, const unsigned char *str, unsigned long int len, signed int escape_solidus)
{
  unsigned long int beg = (unsigned long int)0;
  unsigned long int end = (unsigned long int)0;
  char hexBuf[7l];
  hexBuf[(signed long int)0] = (char)92;
  hexBuf[(signed long int)1] = (char)117;
  hexBuf[(signed long int)2] = (char)48;
  hexBuf[(signed long int)3] = (char)48;
  hexBuf[(signed long int)6] = (char)0;
  while(!(end >= len))
  {
    const char *escaped = (const char *)(void *)0;
    switch((signed int)str[(signed long int)end])
    {
      case 13:
      {
        escaped = "\\r";
        break;
      }
      case 10:
      {
        escaped = "\\n";
        break;
      }
      case 92:
      {
        escaped = "\\\\";
        break;
      }
      case 47:
      {
        if(!(escape_solidus == 0))
          escaped = "\\/";

        break;
      }
      case 34:
      {
        escaped = "\\\"";
        break;
      }
      case 12:
      {
        escaped = "\\f";
        break;
      }
      case 8:
      {
        escaped = "\\b";
        break;
      }
      case 9:
      {
        escaped = "\\t";
        break;
      }
      default:
        if(!((signed int)str[(signed long int)end] >= 32))
        {
          CharToHex(str[(signed long int)end], hexBuf + (signed long int)4);
          escaped = hexBuf;
        }

    }
    if(!(escaped == ((const char *)NULL)))
    {
      print(ctx, (const char *)(str + (signed long int)beg), end - beg);
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(escaped);
      print(ctx, escaped, (unsigned long int)(unsigned int)return_value_strlen_1);
      end = end + 1ul;
      beg = end;
    }

    else
      end = end + 1ul;
  }
  print(ctx, (const char *)(str + (signed long int)beg), end - beg);
}

// yajl_string_scan
// file yajl_all.c line 1057
static unsigned long int yajl_string_scan(const unsigned char *buf, unsigned long int len, signed int utf8check)
{
  unsigned char mask = (unsigned char)(0x02 | 0x08 | (utf8check != 0 ? 0x10 : 0));
  unsigned long int skip = (unsigned long int)0;
  for( ; !(skip >= len); buf = buf + 1l)
  {
    if(!(((signed int)charLookupTable[(signed long int)*buf] & (signed int)mask) == 0))
      break;

    skip = skip + 1ul;
  }
  return skip;
}

// yajl_string_validate_utf8
// file yajl_all.c line 504
static signed int yajl_string_validate_utf8(const unsigned char *s, unsigned long int len)
{
  unsigned long int tmp_post_1;
  unsigned long int tmp_post_2;
  unsigned long int tmp_post_3;
  unsigned long int tmp_post_4;
  unsigned long int tmp_post_5;
  unsigned long int tmp_post_6;
  unsigned long int tmp_post_7;
  if(len == 0ul)
    return 1;

  else
    if(s == ((const unsigned char *)NULL))
      return 0;

    else
    {
      do
      {
        tmp_post_1 = len;
        len = len - 1ul;
        if(tmp_post_1 == 0ul)
          break;

        if((signed int)*s >= 128)
        {
          if((signed int)*s >> 5 == 0x6)
          {
            s = s + 1l;
            tmp_post_2 = len;
            len = len - 1ul;
            if(tmp_post_2 == 0ul)
              return 0;

            if(!((signed int)*s >> 6 == 0x2))
              return 0;

          }

          else
            if((signed int)*s >> 4 == 0x0e)
            {
              s = s + 1l;
              tmp_post_3 = len;
              len = len - 1ul;
              if(tmp_post_3 == 0ul)
                return 0;

              if(!((signed int)*s >> 6 == 0x2))
                return 0;

              s = s + 1l;
              tmp_post_4 = len;
              len = len - 1ul;
              if(tmp_post_4 == 0ul)
                return 0;

              if(!((signed int)*s >> 6 == 0x2))
                return 0;

            }

            else
              if((signed int)*s >> 3 == 0x1e)
              {
                s = s + 1l;
                tmp_post_5 = len;
                len = len - 1ul;
                if(tmp_post_5 == 0ul)
                  return 0;

                if(!((signed int)*s >> 6 == 0x2))
                  return 0;

                s = s + 1l;
                tmp_post_6 = len;
                len = len - 1ul;
                if(tmp_post_6 == 0ul)
                  return 0;

                if(!((signed int)*s >> 6 == 0x2))
                  return 0;

                s = s + 1l;
                tmp_post_7 = len;
                len = len - 1ul;
                if(tmp_post_7 == 0ul)
                  return 0;

                if(!((signed int)*s >> 6 == 0x2))
                  return 0;

              }

              else
                return 0;
        }

        s = s + 1l;
      }
      while((_Bool)1);
      return 1;
    }
}

// years_to_days
// file dbdata.c line 2898
static signed long int years_to_days(unsigned int yr)
{
  return (((signed long int)yr * 365L + (signed long int)(yr / (unsigned int)4)) - (signed long int)(yr / (unsigned int)100)) + (signed long int)(yr / (unsigned int)400);
}

// ymd_to_scalar
// file dbdata.c line 2902
static signed long int ymd_to_scalar(unsigned int yr, unsigned int mo, unsigned int day)
{
  signed long int scalar;
  unsigned int return_value_months_to_days_1;
  return_value_months_to_days_1=months_to_days(mo);
  scalar = (signed long int)(day + return_value_months_to_days_1);
  signed int return_value_isleap_2;
  if(mo >= 3u)
  {
    return_value_isleap_2=isleap(yr);
    scalar = scalar - (signed long int)(return_value_isleap_2 != 0 ? 1 : 2);
  }

  yr = yr - 1u;
  signed long int return_value_years_to_days_3;
  return_value_years_to_days_3=years_to_days(yr);
  scalar = scalar + return_value_years_to_days_3;
  return scalar;
}

