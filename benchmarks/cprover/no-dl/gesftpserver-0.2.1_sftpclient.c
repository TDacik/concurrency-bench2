// tag-#anon#ST[S32'__count'||SYM#tag-#anon#UN[U32'__wch'||ARR4{S8}_S8_'__wchb'|]#'__value'|]
// file /usr/include/wchar.h line 82
struct anonymous_6;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_4;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_8;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_1;

// tag-#anon#UN[S32'fd'||*{SYM#tag-__dirstream#}_SYM#tag-__dirstream#_'dir'|]
// file handle.c line 39
union anonymous_9;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_2;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_0;

// tag-#anon#UN[U32'__wch'||ARR4{S8}_S8_'__wchb'|]
// file /usr/include/wchar.h line 85
union anonymous_5;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_3;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_7;

// tag-#anon#cST[S32'errno_value'||U32'status_value'|]
// file status.c line 110
struct anonymous_10;

// tag-#anon#cST[U32'bit'||U32'_pad0'||*{cS8}_cS8_'description'|]
// file stat.c line 114
struct anonymous;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-allocator
// file sftpcommon.h line 76
struct allocator;

// tag-block
// file alloc.c line 31
union block;

// tag-chunk
// file alloc.h line 26
struct chunk;

// tag-client_handle
// file sftpclient.c line 70
struct client_handle;

// tag-command
// file sftpclient.c line 62
struct command;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-group
// file /usr/include/grp.h line 42
struct group;

// tag-handle
// file handle.c line 36
struct handle;

// tag-handleid
// file sftpcommon.h line 77
struct handleid;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-option
// file ./getopt.h line 83
struct option;

// tag-outstanding_read
// file sftpclient.c line 1307
struct outstanding_read;

// tag-outstanding_write
// file sftpclient.c line 1670
struct outstanding_write;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-queue
// file sftpcommon.h line 75
struct queue;

// tag-queuedetails
// file queue.h line 29
struct queuedetails;

// tag-queuejob
// file queue.c line 34
struct queuejob;

// tag-reader_data
// file sftpclient.c line 1312
struct reader_data;

// tag-sftp_set_status_callbacks
// file stat.c line 272
struct sftp_set_status_callbacks;

// tag-sftpattr
// file sftpcommon.h line 79
struct sftpattr;

// tag-sftpcmd
// file types.h line 255
struct sftpcmd;

// tag-sftpextension
// file types.h line 264
struct sftpextension;

// tag-sftpjob
// file sftpcommon.h line 78
struct sftpjob;

// tag-sftpprotocol
// file globals.h line 30
struct sftpprotocol;

// tag-sftptime
// file types.h line 31
struct sftptime;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-space_available
// file sftpclient.c line 796
struct space_available;

// tag-sqnode
// file serialize.c line 64
struct sqnode;

// tag-stat
// file sftpcommon.h line 81
struct stat;

// tag-statvfs
// file /usr/include/x86_64-linux-gnu/bits/statvfs.h line 29
struct statvfs;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/wchar.h line 137
struct tm;

// tag-winsize
// file /usr/include/x86_64-linux-gnu/bits/ioctl-types.h line 27
struct winsize;

// tag-worker
// file sftpcommon.h line 80
struct worker;

// tag-writer_data
// file sftpclient.c line 1675
struct writer_data;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// _IO_getc
// file /usr/include/libio.h line 434
extern signed int _IO_getc(struct _IO_FILE *);
// _IO_putc
// file /usr/include/libio.h line 435
extern signed int _IO_putc(signed int, struct _IO_FILE *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __xpg_basename
// file /usr/include/libgen.h line 34
extern char * __xpg_basename(char *);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// add_history
// file /usr/include/readline/history.h line 84
extern void add_history(const char *);
// append
// file utils.c line 159
char * append(struct allocator *a, char *s, unsigned long int *ns, const char *t);
// appendn
// file utils.c line 136
char * appendn(struct allocator *a, char *s, unsigned long int *ns, const char *t, unsigned long int lt);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// blocks
// file alloc.c line 85
static inline unsigned long int blocks(unsigned long int nbytes);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// chmod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 283
extern signed int chmod(const char *, unsigned int);
// chown
// file /usr/include/unistd.h line 473
extern signed int chown(const char *, unsigned int, unsigned int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// cmd_bad_handle
// file sftpclient.c line 2201
static signed int cmd_bad_handle(signed int ac, char **av);
// cmd_bad_packet
// file sftpclient.c line 2221
static signed int cmd_bad_packet(signed int ac, char **av);
// cmd_bad_packet456
// file sftpclient.c line 2288
static signed int cmd_bad_packet456(signed int ac, char **av);
// cmd_bad_path
// file sftpclient.c line 2302
static signed int cmd_bad_path(signed int ac, char **av);
// cmd_binary
// file sftpclient.c line 2005
static signed int cmd_binary(signed int ac, char **av);
// cmd_cd
// file sftpclient.c line 888
static signed int cmd_cd(signed int ac, char **av);
// cmd_chgrp
// file sftpclient.c line 1229
static signed int cmd_chgrp(signed int ac, char **av);
// cmd_chmod
// file sftpclient.c line 1247
static signed int cmd_chmod(signed int ac, char **av);
// cmd_chown
// file sftpclient.c line 1211
static signed int cmd_chown(signed int ac, char **av);
// cmd_debug
// file sftpclient.c line 2044
static signed int cmd_debug(signed int ac, char **av);
// cmd_df
// file sftpclient.c line 2069
static signed int cmd_df(signed int ac, char **av);
// cmd_ext_unsupported
// file sftpclient.c line 2115
static signed int cmd_ext_unsupported(signed int ac, char **av);
// cmd_get
// file sftpclient.c line 1503
static signed int cmd_get(signed int ac, char **av);
// cmd_help
// file sftpclient.c line 2672
static signed int cmd_help(signed int ac, char **av);
// cmd_init
// file sftpclient.c line 2099
static signed int cmd_init(signed int ac, char **av);
// cmd_lcd
// file sftpclient.c line 936
static signed int cmd_lcd(signed int ac, char **av);
// cmd_link
// file sftpclient.c line 1301
static signed int cmd_link(signed int ac, char **av);
// cmd_lls
// file sftpclient.c line 1154
static signed int cmd_lls(signed int ac, char **av);
// cmd_lmkdir
// file sftpclient.c line 1202
static signed int cmd_lmkdir(signed int ac, char **av);
// cmd_lpwd
// file sftpclient.c line 924
static signed int cmd_lpwd(signed int ac, char **av);
// cmd_lrealpath
// file sftpclient.c line 2178
static signed int cmd_lrealpath(signed int ac, char **av);
// cmd_ls
// file sftpclient.c line 1000
static signed int cmd_ls(signed int ac, char **av);
// cmd_ls::1::4::sorter_object
//
signed int sorter_object(const void *, const void *);
// cmd_lstat
// file sftpclient.c line 2329
static signed int cmd_lstat(signed int ac, char **av);
// cmd_lumask
// file sftpclient.c line 1178
static signed int cmd_lumask(signed int ac, char **av);
// cmd_mkdir
// file sftpclient.c line 2084
static signed int cmd_mkdir(signed int ac, char **av);
// cmd_mv
// file sftpclient.c line 1269
static signed int cmd_mv(signed int ac, char **av);
// cmd_overlap
// file sftpclient.c line 2352
static signed int cmd_overlap(signed int ac, char **av);
// cmd_progress
// file sftpclient.c line 1983
static signed int cmd_progress(signed int ac, char **av);
// cmd_put
// file sftpclient.c line 1725
static signed int cmd_put(signed int ac, char **av);
// cmd_pwd
// file sftpclient.c line 882
static signed int cmd_pwd(signed int ac, char **av);
// cmd_quit
// file sftpclient.c line 916
static signed int cmd_quit(signed int ac, char **av);
// cmd_readlink
// file sftpclient.c line 2127
static signed int cmd_readlink(signed int ac, char **av);
// cmd_realpath
// file sftpclient.c line 2138
static signed int cmd_realpath(signed int ac, char **av);
// cmd_realpath6
// file sftpclient.c line 2149
static signed int cmd_realpath6(signed int ac, char **av);
// cmd_rm
// file sftpclient.c line 1259
static signed int cmd_rm(signed int ac, char **av);
// cmd_rmdir
// file sftpclient.c line 1264
static signed int cmd_rmdir(signed int ac, char **av);
// cmd_stat
// file sftpclient.c line 2316
static signed int cmd_stat(signed int ac, char **av);
// cmd_symlink
// file sftpclient.c line 1296
static signed int cmd_symlink(signed int ac, char **av);
// cmd_text
// file sftpclient.c line 1996
static signed int cmd_text(signed int ac, char **av);
// cmd_truncate
// file sftpclient.c line 2342
static signed int cmd_truncate(signed int ac, char **av);
// cmd_unsupported
// file sftpclient.c line 2104
static signed int cmd_unsupported(signed int ac, char **av);
// cmd_version
// file sftpclient.c line 2011
static signed int cmd_version(signed int ac, char **av);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous_7, unsigned int);
// do_read
// file utils.h line 35
signed int do_read(signed int fd, void *buffer, unsigned long int size);
// do_sftp_set_status
// file stat.c line 333
static unsigned int do_sftp_set_status(struct allocator *a, const void *what, struct sftpattr *attrsp, struct sftp_set_status_callbacks *cb, const char **whyp);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// error
// file sftpclient.c line 181
static signed int error(const char *fmt, ...);
// execvp
// file /usr/include/unistd.h line 578
extern signed int execvp(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exitfn_object
//
void exitfn_object(signed int);
// fatal
// file utils.h line 185
void fatal(const char *msg, ...);
// fchmod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 296
extern signed int fchmod(signed int, unsigned int);
// fchown
// file /usr/include/unistd.h line 478
extern signed int fchown(signed int, unsigned int, unsigned int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fd_chmod
// file stat.c line 517
static signed int fd_chmod(const void *what, unsigned int mode);
// fd_chown
// file stat.c line 508
static signed int fd_chown(const void *what, unsigned int uid, unsigned int gid);
// fd_stat
// file stat.c line 526
static signed int fd_stat(const void *what, struct stat *sb);
// fd_truncate
// file stat.c line 498
static signed int fd_truncate(const void *what, signed long int size);
// fd_utimes
// file stat.c line 535
static signed int fd_utimes(const void *what, struct timeval *tv);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// find_free_handle
// file handle.c line 63
static void find_free_handle(struct handleid *id, signed int type);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// forked
// file utils.c line 122
void forked(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// ftruncate
// file /usr/include/unistd.h line 1016
extern signed int ftruncate(signed int, signed long int);
// futimes
// file /usr/include/x86_64-linux-gnu/sys/time.h line 147
extern signed int futimes(signed int, struct timeval *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// get16
// file putword.h line 85
static inline unsigned short int get16(const void *where);
// get32
// file putword.h line 102
static inline unsigned int get32(const void *where);
// get64
// file putword.h line 119
static inline unsigned long int get64(const void *where);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getcwd
// file /usr/include/unistd.h line 511
extern char * getcwd(char *, unsigned long int);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getgrgid
// file /usr/include/grp.h line 104
extern struct group * getgrgid(unsigned int);
// getgrnam
// file /usr/include/grp.h line 110
extern struct group * getgrnam(const char *);
// getopt_long
// file ./getopt.h line 140
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getresponse
// file sftpclient.c line 211
static unsigned char getresponse(signed int expected, unsigned int expected_id, const char *what);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// gmtime_r
// file /usr/include/time.h line 249
extern struct tm * gmtime_r(const signed long int *, struct tm *);
// handles_equal
// file serialize.c line 101
static inline signed int handles_equal(struct handleid *h1, struct handleid *h2);
// help
// file sftpclient.c line 147
static void help(void);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// iconv
// file /usr/include/iconv.h line 42
extern unsigned long int iconv(void *, char ** restrict , unsigned long int *, char ** restrict , unsigned long int *);
// iconv_open
// file /usr/include/iconv.h line 37
extern void * iconv_open(const char *, const char *);
// input
// file sftpclient.c line 2700
static char * input(const char *prompt, struct _IO_FILE *fp);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// link
// file /usr/include/unistd.h line 790
extern signed int link(const char *, const char *);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// lseek
// file /usr/include/unistd.h line 334
extern signed long int lseek(signed int, signed long int, signed int);
// lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 262
extern signed int lstat(const char *, struct stat *);
// makeabspath
// file sftpclient.c line 300
static const char * makeabspath(const char *name);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mbsrtowcs
// file /usr/include/wchar.h line 408
extern unsigned long int mbsrtowcs(signed int *, const char ** restrict , unsigned long int, struct anonymous_6 *);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// name_chmod
// file stat.c line 455
static signed int name_chmod(const void *what, unsigned int mode);
// name_chown
// file stat.c line 446
static signed int name_chown(const void *what, unsigned int uid, unsigned int gid);
// name_lstat
// file stat.c line 464
static signed int name_lstat(const void *what, struct stat *sb);
// name_truncate
// file stat.c line 436
static signed int name_truncate(const void *what, signed long int size);
// name_utimes
// file stat.c line 473
static signed int name_utimes(const void *what, struct timeval *tv);
// newid
// file sftpclient.c line 281
static unsigned int newid(void);
// nl_langinfo
// file /usr/include/langinfo.h line 583
extern char * nl_langinfo(signed int);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// opendebug
// file debug.c line 42
static void opendebug(void);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// pread
// file /usr/include/unistd.h line 376
extern signed long int pread(signed int, void *, unsigned long int, signed long int);
// process
// file sftpclient.c line 2728
static void process(const char *prompt, struct _IO_FILE *fp);
// process_path
// file realpath.c line 75
static char * process_path(struct allocator *a, char *result, unsigned long int *nresultp, const char *path, unsigned int flags);
// progress
// file sftpclient.c line 311
static void progress(const char *path, unsigned long int sofar, unsigned long int total);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_2 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_2 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_2 *, const union anonymous_1 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_2 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_2 *, union anonymous_0 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_0 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_0 *, const union anonymous_1 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_0 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_0 *);
// put16
// file putword.h line 36
static inline void put16(void *where, unsigned short int u);
// put32
// file putword.h line 52
static inline void put32(void *where, unsigned int u);
// put64
// file putword.h line 70
static inline void put64(void *where, unsigned long int u);
// pwrite
// file /usr/include/unistd.h line 384
extern signed long int pwrite(signed int, const void *, unsigned long int, signed long int);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// queue_add
// file queue.c line 125
void queue_add(struct queue *q, void *job);
// queue_destroy
// file queue.c line 138
void queue_destroy(struct queue *q);
// queue_init
// file queue.c line 104
void queue_init(struct queue **qr, struct queuedetails *details, signed int nthreads);
// queue_serializable_job
// file serialize.c line 163
void queue_serializable_job(struct sftpjob *job);
// queue_thread
// file queue.c line 73
static void * queue_thread(void *vq);
// ranges_overlap
// file serialize.c line 111
static signed int ranges_overlap(struct sqnode *a, struct sqnode *b);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// reader_thread
// file sftpclient.c line 1329
static void * reader_thread(void *arg);
// readline
// file /usr/include/readline/readline.h line 288
extern char * readline(const char *);
// readlink
// file /usr/include/unistd.h line 809
extern signed long int readlink(const char *, char *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reap_write_response
// file sftpclient.c line 1442
static void reap_write_response(struct reader_data *r);
// remote_cwd
// file sftpclient.c line 291
static char * remote_cwd(void);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// reorderable
// file serialize.c line 134
static signed int reorderable(struct sqnode *q1, struct sqnode *q2, unsigned int flags);
// report_bytes
// file sftpclient.c line 2051
static void report_bytes(signed int width, const char *what, unsigned long int howmuch);
// reverse
// file sftpclient.c line 982
static void reverse(void *array, unsigned long int count, unsigned long int size);
// rmdir
// file /usr/include/unistd.h line 835
extern signed int rmdir(const char *);
// serialize
// file serialize.c line 203
void serialize(struct sftpjob *job);
// serialize_remove_job
// file serialize.c line 228
void serialize_remove_job(struct sftpjob *job);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// sftp__xmalloc
// file utils.h line 50
void * sftp__xmalloc(unsigned long int n);
// sftp__xrealloc
// file utils.h line 70
void * sftp__xrealloc(void *ptr, unsigned long int n);
// sftp_alloc
// file alloc.h line 58
void * sftp_alloc(struct allocator *a, unsigned long int n);
// sftp_alloc_destroy
// file alloc.h line 79
void sftp_alloc_destroy(struct allocator *a);
// sftp_alloc_init
// file alloc.h line 46
struct allocator * sftp_alloc_init(struct allocator *a);
// sftp_alloc_more
// file alloc.c line 121
void * sftp_alloc_more(struct allocator *a, void *ptr, unsigned long int oldn, unsigned long int newn);
// sftp_close
// file sftpclient.c line 593
static signed int sftp_close(struct client_handle *hp);
// sftp_debug_hexdump
// file debug.h line 40
void sftp_debug_hexdump(const void *ptr, unsigned long int n);
// sftp_debug_printf
// file debug.h line 48
void sftp_debug_printf(const char *fmt, ...);
// sftp_dirname
// file utils.h line 174
const char * sftp_dirname(struct allocator *a, const char *path);
// sftp_do_readlink
// file utils.h line 120
char * sftp_do_readlink(struct allocator *a, const char *path);
// sftp_find_realpath
// file utils.h line 148
char * sftp_find_realpath(struct allocator *a, const char *path, unsigned int flags);
// sftp_format_attr
// file stat.h line 38
const char * sftp_format_attr(struct allocator *a, struct sftpattr *attrs, signed int thisyear, unsigned long int flags);
// sftp_fsetstat
// file sftpclient.c line 620
static signed int sftp_fsetstat(struct client_handle *hp, struct sftpattr *attrs);
// sftp_fstat
// file sftpclient.c line 512
static signed int sftp_fstat(struct client_handle *hp, struct sftpattr *attrs);
// sftp_generic_open
// file sftpserver.h line 303
unsigned int sftp_generic_open(struct sftpjob *job, const char *path, unsigned int desired_access, unsigned int flags, struct sftpattr *attrs);
// sftp_getcwd
// file utils.h line 167
char * sftp_getcwd(struct allocator *a);
// sftp_gid2name
// file users.c line 48
char * sftp_gid2name(struct allocator *a, unsigned int gid);
// sftp_handle_close
// file handle.c line 137
unsigned int sftp_handle_close(struct handleid *id);
// sftp_handle_flags
// file handle.c line 168
unsigned int sftp_handle_flags(struct handleid *id);
// sftp_handle_get_dir
// file handle.c line 119
unsigned int sftp_handle_get_dir(struct handleid *id, struct __dirstream **dp, const char **pathp);
// sftp_handle_get_fd
// file handle.c line 101
unsigned int sftp_handle_get_fd(struct handleid *id, signed int *fd, unsigned int *flagsp);
// sftp_handle_new_dir
// file handle.c line 93
void sftp_handle_new_dir(struct handleid *id, struct __dirstream *dp, const char *path);
// sftp_handle_new_file
// file handle.c line 83
void sftp_handle_new_file(struct handleid *id, signed int fd, const char *path, unsigned int flags);
// sftp_iconv
// file charset.c line 46
signed int sftp_iconv(struct allocator *a, void *cd, char **sp);
// sftp_init
// file sftpclient.c line 327
static signed int sftp_init(void);
// sftp_link
// file sftpclient.c line 696
static signed int sftp_link(const char *targetpath, const char *linkpath, signed int sftp_send_symlink);
// sftp_mbs2wcs
// file charset.h line 33
signed int * sftp_mbs2wcs(const char *s);
// sftp_mkdir
// file sftpclient.c line 826
static signed int sftp_mkdir(const char *path, unsigned int mode);
// sftp_name2gid
// file users.c line 74
unsigned int sftp_name2gid(const char *name);
// sftp_name2uid
// file users.c line 61
unsigned int sftp_name2uid(const char *name);
// sftp_normalize_ownergroup
// file stat.h line 67
unsigned int sftp_normalize_ownergroup(struct allocator *a, struct sftpattr *attrs);
// sftp_open
// file sftpclient.c line 726
static signed int sftp_open(const char *path, unsigned int desired_access, unsigned int flags, struct sftpattr *attrs, struct client_handle *hp);
// sftp_opendir
// file sftpclient.c line 528
static signed int sftp_opendir(const char *path, struct client_handle *hp);
// sftp_parse_handle
// file parse.c line 97
unsigned int sftp_parse_handle(struct sftpjob *job, struct handleid *id);
// sftp_parse_path
// file parse.h line 76
unsigned int sftp_parse_path(struct sftpjob *job, char **strp);
// sftp_parse_string
// file parse.h line 65
unsigned int sftp_parse_string(struct sftpjob *job, char **strp, unsigned long int *lenp);
// sftp_parse_uint16
// file parse.h line 38
unsigned int sftp_parse_uint16(struct sftpjob *job, unsigned short int *ur);
// sftp_parse_uint32
// file parse.h line 45
unsigned int sftp_parse_uint32(struct sftpjob *job, unsigned int *ur);
// sftp_parse_uint64
// file parse.h line 52
unsigned int sftp_parse_uint64(struct sftpjob *job, unsigned long int *ur);
// sftp_parse_uint8
// file parse.h line 31
unsigned int sftp_parse_uint8(struct sftpjob *job, unsigned char *ur);
// sftp_prename
// file sftpclient.c line 681
static signed int sftp_prename(const char *oldpath, const char *newpath);
// sftp_readdir
// file sftpclient.c line 543
static signed int sftp_readdir(struct client_handle *hp, struct sftpattr **attrsp, unsigned long int *nattrsp);
// sftp_readlink
// file sftpclient.c line 847
static char * sftp_readlink(const char *path);
// sftp_realpath
// file sftpclient.c line 446
static char * sftp_realpath(const char *path);
// sftp_realpath_v6
// file sftpclient.c line 464
static char * sftp_realpath_v6(const char *path, signed int control_byte, char **compose, struct sftpattr *attrs);
// sftp_remove
// file sftpclient.c line 647
static signed int sftp_remove(const char *path);
// sftp_rename
// file sftpclient.c line 660
static signed int sftp_rename(const char *oldpath, const char *newpath, unsigned int flags);
// sftp_rmdir
// file sftpclient.c line 634
static signed int sftp_rmdir(const char *path);
// sftp_send_begin
// file send.h line 39
void sftp_send_begin(struct worker *w);
// sftp_send_bytes
// file send.h line 81
void sftp_send_bytes(struct worker *w, const void *bytes, unsigned long int n);
// sftp_send_end
// file send.h line 50
void sftp_send_end(struct worker *w);
// sftp_send_errno_status
// file status.c line 131
void sftp_send_errno_status(struct sftpjob *job);
// sftp_send_handle
// file send.c line 141
void sftp_send_handle(struct worker *w, struct handleid *id);
// sftp_send_need
// file send.h line 32
void sftp_send_need(struct worker *w, unsigned long int n);
// sftp_send_path
// file send.h line 100
void sftp_send_path(struct sftpjob *job, struct worker *w, const char *path);
// sftp_send_status
// file status.c line 70
void sftp_send_status(struct sftpjob *job, unsigned int status, const char *msg);
// sftp_send_string
// file send.h line 93
void sftp_send_string(struct worker *w, const char *s);
// sftp_send_sub_begin
// file send.c line 148
unsigned long int sftp_send_sub_begin(struct worker *w);
// sftp_send_sub_end
// file send.c line 154
void sftp_send_sub_end(struct worker *w, unsigned long int offset);
// sftp_send_uint16
// file send.c line 109
void sftp_send_uint16(struct worker *w, unsigned short int u);
// sftp_send_uint32
// file send.h line 68
void sftp_send_uint32(struct worker *w, unsigned int u);
// sftp_send_uint64
// file send.h line 74
void sftp_send_uint64(struct worker *w, unsigned long int u);
// sftp_send_uint8
// file send.h line 56
void sftp_send_uint8(struct worker *w, signed int n);
// sftp_set_fstatus
// file stat.h line 89
unsigned int sftp_set_fstatus(struct allocator *a, signed int fd, struct sftpattr *attrsp, const char **whyp);
// sftp_set_status
// file stat.h line 77
unsigned int sftp_set_status(struct allocator *a, const char *path, struct sftpattr *attrsp, const char **whyp);
// sftp_setstat
// file sftpclient.c line 605
static signed int sftp_setstat(const char *path, struct sftpattr *attrs);
// sftp_space_available
// file sftpclient.c line 804
static signed int sftp_space_available(const char *path, struct space_available *as);
// sftp_stat
// file sftpclient.c line 492
static signed int sftp_stat(const char *path, struct sftpattr *attrs, unsigned char type);
// sftp_stat_to_attrs
// file stat.h line 109
void sftp_stat_to_attrs(struct allocator *a, struct stat *sb, struct sftpattr *attrs, unsigned int flags, const char *path);
// sftp_text_seek
// file sftpclient.c line 866
static signed int sftp_text_seek(struct client_handle *hp, unsigned long int line);
// sftp_uid2name
// file users.c line 35
char * sftp_uid2name(struct allocator *a, unsigned int uid);
// sftp_v345_realpath
// file v3.c line 448
unsigned int sftp_v345_realpath(struct sftpjob *job);
// sftp_v345_symlink
// file v3.c line 283
unsigned int sftp_v345_symlink(struct sftpjob *job);
// sftp_v34_open
// file v3.c line 591
unsigned int sftp_v34_open(struct sftpjob *job);
// sftp_v34_rename
// file v3.c line 228
unsigned int sftp_v34_rename(struct sftpjob *job);
// sftp_v3_encode
// file v3.c line 53
signed int sftp_v3_encode(struct sftpjob *job, char **path);
// sftp_v3_fstat
// file v3.c line 507
static unsigned int sftp_v3_fstat(struct sftpjob *job);
// sftp_v3_lstat
// file v3.c line 489
static unsigned int sftp_v3_lstat(struct sftpjob *job);
// sftp_v3_stat
// file v3.c line 498
static unsigned int sftp_v3_stat(struct sftpjob *job);
// sftp_v3_stat_core
// file v3.c line 470
static unsigned int sftp_v3_stat_core(struct sftpjob *job, signed int rc, struct stat *sb);
// sftp_v456_decode
// file v4.c line 40
unsigned int sftp_v456_decode(struct sftpjob *job, char **path);
// sftp_v456_encode
// file v4.c line 34
signed int sftp_v456_encode(struct sftpjob *job, char **path);
// sftp_v456_fstat
// file v4.c line 250
unsigned int sftp_v456_fstat(struct sftpjob *job);
// sftp_v456_lstat
// file v4.c line 232
unsigned int sftp_v456_lstat(struct sftpjob *job);
// sftp_v456_parseattrs
// file v4.c line 107
unsigned int sftp_v456_parseattrs(struct sftpjob *job, struct sftpattr *attrs);
// sftp_v456_sendattrs
// file v4.c line 49
void sftp_v456_sendattrs(struct sftpjob *job, struct sftpattr *attrs);
// sftp_v456_sendnames
// file v4.c line 200
void sftp_v456_sendnames(struct sftpjob *job, signed int nnames, struct sftpattr *names);
// sftp_v456_stat
// file v4.c line 241
unsigned int sftp_v456_stat(struct sftpjob *job);
// sftp_v456_stat_core
// file v4.c line 214
static unsigned int sftp_v456_stat_core(struct sftpjob *job, signed int rc, struct stat *sb, const char *path);
// sftp_v56_open
// file v5.c line 39
unsigned int sftp_v56_open(struct sftpjob *job);
// sftp_v56_rename
// file v5.c line 316
unsigned int sftp_v56_rename(struct sftpjob *job);
// sftp_v6_link
// file v6.c line 112
unsigned int sftp_v6_link(struct sftpjob *job);
// sftp_v6_realpath
// file v6.c line 36
unsigned int sftp_v6_realpath(struct sftpjob *job);
// sftp_v6_version_select
// file v6.c line 142
unsigned int sftp_v6_version_select(struct sftpjob *job);
// sftp_vany_already_init
// file v3.c line 188
unsigned int sftp_vany_already_init(struct sftpjob *job);
// sftp_vany_close
// file v3.c line 440
unsigned int sftp_vany_close(struct sftpjob *job);
// sftp_vany_extended
// file sftpserver.h line 148
unsigned int sftp_vany_extended(struct sftpjob *job);
// sftp_vany_fsetstat
// file v3.c line 536
unsigned int sftp_vany_fsetstat(struct sftpjob *job);
// sftp_vany_mkdir
// file v3.c line 555
unsigned int sftp_vany_mkdir(struct sftpjob *job);
// sftp_vany_opendir
// file v3.c line 366
unsigned int sftp_vany_opendir(struct sftpjob *job);
// sftp_vany_posix_rename
// file v3.c line 716
unsigned int sftp_vany_posix_rename(struct sftpjob *job);
// sftp_vany_read
// file v3.c line 639
unsigned int sftp_vany_read(struct sftpjob *job);
// sftp_vany_readdir
// file v3.c line 385
unsigned int sftp_vany_readdir(struct sftpjob *job);
// sftp_vany_readlink
// file v3.c line 343
unsigned int sftp_vany_readlink(struct sftpjob *job);
// sftp_vany_remove
// file v3.c line 193
unsigned int sftp_vany_remove(struct sftpjob *job);
// sftp_vany_rmdir
// file v3.c line 212
unsigned int sftp_vany_rmdir(struct sftpjob *job);
// sftp_vany_setstat
// file v3.c line 520
unsigned int sftp_vany_setstat(struct sftpjob *job);
// sftp_vany_space_available
// file sftpserver.h line 311
unsigned int sftp_vany_space_available(struct sftpjob *job);
// sftp_vany_statfs
// file v3.c line 730
unsigned int sftp_vany_statfs(struct sftpjob *job);
// sftp_vany_text_seek
// file sftpserver.h line 293
unsigned int sftp_vany_text_seek(struct sftpjob *job);
// sftp_vany_write
// file v3.c line 681
unsigned int sftp_vany_write(struct sftpjob *job);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sort_by_mtime
// file sftpclient.c line 963
static signed int sort_by_mtime(const void *av, const void *bv);
// sort_by_name
// file sftpclient.c line 945
static signed int sort_by_name(const void *av, const void *bv);
// sort_by_size
// file sftpclient.c line 951
static signed int sort_by_size(const void *av, const void *bv);
// split
// file sftpclient.c line 247
static signed int split(char *line, char **av);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// status
// file sftpclient.c line 194
static signed int status(void);
// status_to_string
// file sftpcommon.h line 87
const char * status_to_string(unsigned int status);
// statvfs
// file /usr/include/x86_64-linux-gnu/sys/statvfs.h line 51
extern signed int statvfs(const char *, struct statvfs *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// strtoull
// file /usr/include/stdlib.h line 214
extern unsigned long long int strtoull(const char *, char ** restrict , signed int);
// symlink
// file /usr/include/unistd.h line 803
extern signed int symlink(const char *, const char *);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// truncate
// file /usr/include/unistd.h line 993
extern signed int truncate(const char *, signed long int);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// ungetc
// file /usr/include/stdio.h line 702
extern signed int ungetc(signed int, struct _IO_FILE *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// utimes
// file /usr/include/x86_64-linux-gnu/sys/time.h line 138
extern signed int utimes(const char *, struct timeval *);
// v3_decode
// file v3.c line 58
static unsigned int v3_decode(struct sftpjob *job, char **path);
// v3_parseattrs
// file v3.c line 128
static unsigned int v3_parseattrs(struct sftpjob *job, struct sftpattr *attrs);
// v3_sendattrs
// file v3.c line 83
static void v3_sendattrs(struct sftpjob *job, struct sftpattr *attrs);
// v3_sendnames
// file v3.c line 65
static void v3_sendnames(struct sftpjob *job, signed int nnames, struct sftpattr *names);
// version
// file sftpclient.c line 174
static void version(void);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsyslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 200
extern void vsyslog(signed int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// wcswidth
// file /usr/include/wchar.h line 443
extern signed int wcswidth(const signed int *, unsigned long int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_translated
// file sftpclient.c line 1384
static signed int write_translated(struct reader_data *r, const void *vptr, unsigned long int bytes);
// write_translated_done
// file sftpclient.c line 1424
static signed int write_translated_done(struct reader_data *r);
// write_translated_init
// file sftpclient.c line 1377
static signed int write_translated_init(struct reader_data *r);
// writer_thread
// file sftpclient.c line 1687
static void * writer_thread(void *arg);
// xcalloc
// file utils.h line 59
void * xcalloc(unsigned long int n, unsigned long int size);
// xclose
// file xfns.h line 31
void xclose(signed int fd);
// xdup2
// file xfns.h line 39
void xdup2(signed int fd, signed int newfd);
// xfork
// file utils.h line 194
signed int xfork(void);
// xpipe
// file xfns.h line 46
void xpipe(signed int *pfd);
// xprintf
// file xfns.h line 55
signed int xprintf(const char *fmt, ...);
// xrecalloc
// file utils.h line 82
void * xrecalloc(void *ptr, unsigned long int n, unsigned long int size);
// xstrdup
// file utils.h line 90
char * xstrdup(const char *s);

union anonymous_5
{
  // __wch
  unsigned int __wch;
  // __wchb
  char __wchb[4l];
};

struct anonymous_6
{
  // __count
  signed int __count;
  // __value
  union anonymous_5 __value;
};

struct anonymous_4
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union anonymous_8
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_1
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_9
{
  // fd
  signed int fd;
  // dir
  struct __dirstream *dir;
};

union anonymous_2
{
  // __data
  struct anonymous_4 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_0
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous_3
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_7
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct anonymous_10
{
  // errno_value
  signed int errno_value;
  // status_value
  unsigned int status_value;
};

struct anonymous
{
  // bit
  unsigned int bit;
  // description
  const char *description;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct allocator
{
  // chunks
  struct chunk *chunks;
};

struct chunk
{
  // next
  struct chunk *next;
  // ptr
  union block *ptr;
  // left
  unsigned long int left;
  // spare
  unsigned long int spare;
};

union block
{
  // i
  signed int i;
  // l
  signed long int l;
  // f
  float f;
  // d
  double d;
  // vp
  void *vp;
  // ip
  double *ip;
  // fnp
  signed int (*fnp)(void);
  // c
  struct chunk c;
};

struct client_handle
{
  // len
  unsigned long int len;
  // data
  char *data;
};

struct command
{
  // name
  const char *name;
  // minargs
  signed int minargs;
  // maxargs
  signed int maxargs;
  // handler
  signed int (*handler)(signed int, char **);
  // args
  const char *args;
  // help
  const char *help;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct group
{
  // gr_name
  char *gr_name;
  // gr_passwd
  char *gr_passwd;
  // gr_gid
  unsigned int gr_gid;
  // gr_mem
  char **gr_mem;
};

struct handle
{
  // type
  signed int type;
  // tag
  unsigned int tag;
  // u
  union anonymous_9 u;
  // path
  char *path;
  // flags
  unsigned int flags;
};

struct handleid
{
  // id
  unsigned int id;
  // tag
  unsigned int tag;
};

struct in6_addr
{
  // __in6_u
  union anonymous_8 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct outstanding_read
{
  // id
  unsigned int id;
  // offset
  signed long int offset;
};

struct outstanding_write
{
  // id
  unsigned int id;
  // n
  signed long int n;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct queue
{
  // jobs
  struct queuejob *jobs;
  // jobstail
  struct queuejob **jobstail;
  // m
  union anonymous_0 m;
  // c
  union anonymous_2 c;
  // details
  struct queuedetails *details;
  // nthreads
  signed int nthreads;
  // threads
  unsigned long int *threads;
  // join
  signed int join;
};

struct queuedetails
{
  // init
  void * (*init)();
  // worker
  void (*worker)(void *, void *, struct allocator *);
  // cleanup
  void (*cleanup)(void *);
};

struct queuejob
{
  // next
  struct queuejob *next;
  // job
  void *job;
};

struct reader_data
{
  // m
  union anonymous_0 m;
  // c1
  union anonymous_2 c1;
  // c2
  union anonymous_2 c2;
  // h
  struct client_handle h;
  // reqs
  struct outstanding_read *reqs;
  // next_offset
  unsigned long int next_offset;
  // outstanding
  signed int outstanding;
  // eof
  signed int eof;
  // failed
  signed int failed;
  // size
  unsigned long int size;
  // written
  unsigned long int written;
  // fd
  signed int fd;
  // local
  char *local;
  // tmp
  char *tmp;
  // translated_fp
  struct _IO_FILE *translated_fp;
  // translated_state
  unsigned long int translated_state;
};

struct sftp_set_status_callbacks
{
  // do_truncate
  signed int (*do_truncate)(const void *, signed long int);
  // do_chown
  signed int (*do_chown)(const void *, unsigned int, unsigned int);
  // do_chmod
  signed int (*do_chmod)(const void *, unsigned int);
  // do_stat
  signed int (*do_stat)(const void *, struct stat *);
  // do_utimes
  signed int (*do_utimes)(const void *, struct timeval *);
};

struct sftptime
{
  // seconds
  signed long int seconds;
  // nanoseconds
  unsigned int nanoseconds;
};

struct sftpattr
{
  // valid
  unsigned int valid;
  // type
  unsigned char type;
  // size
  unsigned long int size;
  // allocation_size
  unsigned long int allocation_size;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // owner
  char *owner;
  // group
  char *group;
  // permissions
  unsigned int permissions;
  // atime
  struct sftptime atime;
  // createtime
  struct sftptime createtime;
  // mtime
  struct sftptime mtime;
  // ctime
  struct sftptime ctime;
  // acl
  char *acl;
  // attrib_bits
  unsigned int attrib_bits;
  // attrib_bits_valid
  unsigned int attrib_bits_valid;
  // text_hint
  unsigned char text_hint;
  // mime_type
  char *mime_type;
  // link_count
  unsigned int link_count;
  // untranslated_name
  char *untranslated_name;
  // name
  const char *name;
  // longname
  const char *longname;
  // wname
  const signed int *wname;
  // target
  const char *target;
};

struct sftpcmd
{
  // type
  unsigned char type;
  // handler
  unsigned int (*handler)(struct sftpjob *);
};

struct sftpextension
{
  // name
  const char *name;
  // handler
  unsigned int (*handler)(struct sftpjob *);
};

struct sftpjob
{
  // len
  unsigned long int len;
  // data
  unsigned char *data;
  // left
  unsigned long int left;
  // ptr
  const unsigned char *ptr;
  // a
  struct allocator *a;
  // id
  unsigned int id;
  // worker
  struct worker *worker;
};

struct sftpprotocol
{
  // ncommands
  signed int ncommands;
  // commands
  struct sftpcmd *commands;
  // version
  signed int version;
  // attrmask
  unsigned int attrmask;
  // maxstatus
  unsigned int maxstatus;
  // sendnames
  void (*sendnames)(struct sftpjob *, signed int, struct sftpattr *);
  // sendattrs
  void (*sendattrs)(struct sftpjob *, struct sftpattr *);
  // parseattrs
  unsigned int (*parseattrs)(struct sftpjob *, struct sftpattr *);
  // encode
  signed int (*encode)(struct sftpjob *, char **);
  // decode
  unsigned int (*decode)(struct sftpjob *, char **);
  // nextensions
  signed int nextensions;
  // extensions
  struct sftpextension *extensions;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct space_available
{
  // bytes_on_device
  unsigned long int bytes_on_device;
  // unused_bytes_on_device
  unsigned long int unused_bytes_on_device;
  // bytes_available_to_user
  unsigned long int bytes_available_to_user;
  // unused_bytes_available_to_user
  unsigned long int unused_bytes_available_to_user;
  // bytes_per_allocation_unit
  unsigned int bytes_per_allocation_unit;
};

struct sqnode
{
  // older
  struct sqnode *older;
  // job
  struct sftpjob *job;
  // hid
  struct handleid hid;
  // handleflags
  unsigned int handleflags;
  // offset
  unsigned long int offset;
  // len
  unsigned long int len;
  // type
  unsigned char type;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct statvfs
{
  // f_bsize
  unsigned long int f_bsize;
  // f_frsize
  unsigned long int f_frsize;
  // f_blocks
  unsigned long int f_blocks;
  // f_bfree
  unsigned long int f_bfree;
  // f_bavail
  unsigned long int f_bavail;
  // f_files
  unsigned long int f_files;
  // f_ffree
  unsigned long int f_ffree;
  // f_favail
  unsigned long int f_favail;
  // f_fsid
  unsigned long int f_fsid;
  // f_flag
  unsigned long int f_flag;
  // f_namemax
  unsigned long int f_namemax;
  // __f_spare
  signed int __f_spare[6l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct winsize
{
  // ws_row
  unsigned short int ws_row;
  // ws_col
  unsigned short int ws_col;
  // ws_xpixel
  unsigned short int ws_xpixel;
  // ws_ypixel
  unsigned short int ws_ypixel;
};

struct worker
{
  // bufsize
  unsigned long int bufsize;
  // bufused
  unsigned long int bufused;
  // buffer
  unsigned char *buffer;
  // local_to_utf8
  void *local_to_utf8;
  // utf8_to_local
  void *utf8_to_local;
};

struct writer_data
{
  // m
  union anonymous_0 m;
  // c1
  union anonymous_2 c1;
  // c2
  union anonymous_2 c2;
  // failed
  signed int failed;
  // outstanding
  signed int outstanding;
  // finished
  signed int finished;
  // reqs
  struct outstanding_write *reqs;
  // remote
  const char *remote;
  // written
  unsigned long int written;
  // total
  unsigned long int total;
};


// allocator
// file sftpclient.c line 76
static struct allocator allocator;
// attr_bits
// file stat.c line 117
static struct anonymous attr_bits[12l] = { { .bit=(unsigned int)0x00000001, .description="ro" },
    { .bit=(unsigned int)0x00000002, .description="sys" },
    { .bit=(unsigned int)0x00000004, .description="hide" },
    { .bit=(unsigned int)0x00000008, .description="ci" },
    { .bit=(unsigned int)0x00000010, .description="arc" },
    { .bit=(unsigned int)0x00000020, .description="enc" },
    { .bit=(unsigned int)0x00000040, .description="comp" },
    { .bit=(unsigned int)0x00000080, .description="sp" },
    { .bit=(unsigned int)0x00000100, .description="app" },
    { .bit=(unsigned int)0x00000200, .description="imm" },
    { .bit=(unsigned int)0x00000400, .description="sync" },
    { .bit=(unsigned int)0x00000800, .description="trans" } };
// attrmask
// file sftpclient.c line 90
static unsigned int attrmask;
// batchfile
// file sftpclient.c line 100
static const char *batchfile;
// buffersize
// file sftpclient.c line 96
static unsigned long int buffersize = (unsigned long int)32768;
// commands
// file sftpclient.c line 2444
static struct command commands[46l];
// commands
// file sftpclient.c line 2444
static struct command commands[46l] = { { .name="_bad_handle", .minargs=0, .maxargs=0, .handler=cmd_bad_handle,
    .args=((const char *)NULL), .help="operate on a bogus handle" },
    { .name="_bad_packet", .minargs=0, .maxargs=0, .handler=cmd_bad_packet,
    .args=((const char *)NULL), .help="send bad packets" },
    { .name="_bad_packet456", .minargs=0, .maxargs=0, .handler=cmd_bad_packet456,
    .args=((const char *)NULL), .help="send bad packets (protos >= 4 only)" },
    { .name="_bad_path", .minargs=0, .maxargs=0, .handler=cmd_bad_path,
    .args=((const char *)NULL), .help="send bad paths" },
    { .name="_ext_unsupported", .minargs=0, .maxargs=0, .handler=cmd_ext_unsupported,
    .args=((const char *)NULL), .help="send an unsupported extension" },
    { .name="_init", .minargs=0, .maxargs=0, .handler=cmd_init,
    .args=((const char *)NULL), .help="resend SSH_FXP_INIT" },
    { .name="_lrealpath", .minargs=2, .maxargs=2, .handler=cmd_lrealpath,
    .args="CONTROL PATH", .help="expand a local path name" },
    { .name="_overlap", .minargs=0, .maxargs=0, .handler=cmd_overlap,
    .args="", .help="test overlapping writes" },
    { .name="_unsupported", .minargs=0, .maxargs=0, .handler=cmd_unsupported,
    .args=((const char *)NULL), .help="send an unsupported command" },
    { .name="binary", .minargs=0, .maxargs=0, .handler=cmd_binary,
    .args=((const char *)NULL), .help="binary mode" },
    { .name="bye", .minargs=0, .maxargs=0, .handler=cmd_quit, .args=((const char *)NULL),
    .help="quit" },
    { .name="cd", .minargs=1, .maxargs=1, .handler=cmd_cd, .args="DIR",
    .help="change remote directory" },
    { .name="chgrp", .minargs=2, .maxargs=2, .handler=cmd_chgrp,
    .args="GID PATH", .help="change remote file group" },
    { .name="chmod", .minargs=2, .maxargs=2, .handler=cmd_chmod,
    .args="OCTAL PATH", .help="change remote file permissions" },
    { .name="chown", .minargs=2, .maxargs=2, .handler=cmd_chown,
    .args="UID PATH", .help="change remote file ownership" },
    { .name="debug", .minargs=0, .maxargs=0, .handler=cmd_debug,
    .args=((const char *)NULL), .help="toggle sftp_debugging" },
    { .name="df", .minargs=0, .maxargs=1, .handler=cmd_df, .args="[PATH]",
    .help="query available space" },
    { .name="exit", .minargs=0, .maxargs=0, .handler=cmd_quit, .args=((const char *)NULL),
    .help="quit" },
    { .name="get", .minargs=1, .maxargs=3, .handler=cmd_get, .args="[-PfL<line>] REMOTE-PATH [LOCAL-PATH]",
    .help="retrieve a remote file" },
    { .name="help", .minargs=0, .maxargs=0, .handler=cmd_help, .args=((const char *)NULL),
    .help="display help" },
    { .name="lcd", .minargs=1, .maxargs=1, .handler=cmd_lcd, .args="DIR",
    .help="change local directory" },
    { .name="link", .minargs=2, .maxargs=2, .handler=cmd_link, .args="OLDPATH NEWPATH",
    .help="create a remote hard link" },
    { .name="lpwd", .minargs=0, .maxargs=0, .handler=cmd_lpwd, .args="DIR",
    .help="display current local directory" },
    { .name="lls", .minargs=0, .maxargs=0x7fffffff, .handler=cmd_lls,
    .args="[OPTIONS] [LOCAL-PATH]", .help="list local directory" },
    { .name="lmkdir", .minargs=1, .maxargs=1, .handler=cmd_lmkdir,
    .args="LOCAL-PATH", .help="create local directory" },
    { .name="ls", .minargs=0, .maxargs=2, .handler=cmd_ls, .args="[OPTIONS] [PATH]",
    .help="list remote directory" },
    { .name="lstat", .minargs=1, .maxargs=1, .handler=cmd_lstat,
    .args="PATH", .help="lstat a file" },
    { .name="lumask", .minargs=0, .maxargs=1, .handler=cmd_lumask,
    .args="OCTAL", .help="get or set local umask" },
    { .name="mkdir", .minargs=1, .maxargs=2, .handler=cmd_mkdir,
    .args="[MODE] DIRECTORY", .help="create a remote directory" },
    { .name="mv", .minargs=2, .maxargs=3, .handler=cmd_mv, .args="[-naop] OLDPATH NEWPATH",
    .help="rename a remote file" },
    { .name="progress", .minargs=0, .maxargs=1, .handler=cmd_progress,
    .args="[on|off]", .help="set or toggle progress indicators" },
    { .name="put", .minargs=1, .maxargs=3, .handler=cmd_put, .args="[-PaftemMODE] LOCAL-PATH [REMOTE-PATH]",
    .help="upload a file" },
    { .name="pwd", .minargs=0, .maxargs=0, .handler=cmd_pwd, .args=((const char *)NULL),
    .help="display current remote directory" },
    { .name="quit", .minargs=0, .maxargs=0, .handler=cmd_quit, .args=((const char *)NULL),
    .help="quit" },
    { .name="readlink", .minargs=1, .maxargs=1, .handler=cmd_readlink,
    .args="PATH", .help="inspect a symlink" },
    { .name="realpath", .minargs=1, .maxargs=1, .handler=cmd_realpath,
    .args="PATH", .help="expand a path name" },
    { .name="realpath6", .minargs=2, .maxargs=0x7fffffff, .handler=cmd_realpath6,
    .args="CONTROL PATH [COMPOSE...]", .help="expand a path name" },
    { .name="rename", .minargs=2, .maxargs=2, .handler=cmd_mv,
    .args="OLDPATH NEWPATH", .help="rename a remote file" },
    { .name="rm", .minargs=1, .maxargs=1, .handler=cmd_rm, .args="PATH",
    .help="remove remote file" },
    { .name="rmdir", .minargs=1, .maxargs=1, .handler=cmd_rmdir,
    .args="PATH", .help="remove remote directory" },
    { .name="symlink", .minargs=2, .maxargs=2, .handler=cmd_symlink,
    .args="TARGET NEWPATH", .help="create a remote symlink" },
    { .name="stat", .minargs=1, .maxargs=1, .handler=cmd_stat, .args="PATH",
    .help="stat a file" },
    { .name="text", .minargs=0, .maxargs=0, .handler=cmd_text, .args=((const char *)NULL),
    .help="text mode" },
    { .name="truncate", .minargs=2, .maxargs=2, .handler=cmd_truncate,
    .args="LENGTH FILE", .help="truncate a file" },
    { .name="version", .minargs=0, .maxargs=1, .handler=cmd_version,
    .args=((const char *)NULL), .help="set or display protocol version" },
    { .name=((const char *)NULL), .minargs=0, .maxargs=0,
    .handler=((signed int (*)(signed int, char **))NULL), .args=((const char *)NULL),
    .help=((const char *)NULL) } };
// compress
// file sftpclient.c line 102
static signed int compress;
// cwd
// file sftpclient.c line 79
static char *cwd;
// debugfp
// file debug.c line 35
static struct _IO_FILE *debugfp;
// echo
// file sftpclient.c line 89
static signed int echo;
// errnotab
// file status.c line 113
static struct anonymous_10 errnotab[15l] = { { .errno_value=0, .status_value=(unsigned int)0 },
    { .errno_value=1, .status_value=(unsigned int)3 },
    { .errno_value=13, .status_value=(unsigned int)3 },
    { .errno_value=2, .status_value=(unsigned int)2 },
    { .errno_value=5, .status_value=(unsigned int)28 },
    { .errno_value=28, .status_value=(unsigned int)14 },
    { .errno_value=20, .status_value=(unsigned int)19 },
    { .errno_value=21, .status_value=(unsigned int)24 },
    { .errno_value=17, .status_value=(unsigned int)11 },
    { .errno_value=30, .status_value=(unsigned int)12 },
    { .errno_value=40, .status_value=(unsigned int)21 },
    { .errno_value=36, .status_value=(unsigned int)20 },
    { .errno_value=39, .status_value=(unsigned int)18 },
    { .errno_value=122, .status_value=(unsigned int)15 },
    { .errno_value=-1, .status_value=(unsigned int)4 } };
// exitfn
// file utils.c line 105
static void (*exitfn)(signed int);
// exitfn
// file utils.c line 105
static void (*exitfn)(signed int) = exit;
// fakejob
// file sftpclient.c line 77
static struct sftpjob fakejob;
// fakeworker
// file sftpclient.c line 78
static struct worker fakeworker;
// fd_callbacks
// file stat.c line 540
static struct sftp_set_status_callbacks fd_callbacks;
// fd_callbacks
// file stat.c line 540
static struct sftp_set_status_callbacks fd_callbacks = { .do_truncate=fd_truncate, .do_chown=fd_chown, .do_chmod=fd_chmod,
    .do_stat=fd_stat, .do_utimes=fd_utimes };
// forceversion
// file sftpclient.c line 109
static signed int forceversion;
// handles
// file handle.c line 48
static struct handle *handles;
// inputline
// file sftpclient.c line 81
static signed int inputline;
// inputpath
// file sftpclient.c line 80
static const char *inputpath;
// log_syslog
// file utils.c line 35
signed int log_syslog;
// name_callbacks
// file stat.c line 478
static struct sftp_set_status_callbacks name_callbacks;
// name_callbacks
// file stat.c line 478
static struct sftp_set_status_callbacks name_callbacks = { .do_truncate=name_truncate, .do_chown=name_chown, .do_chmod=name_chmod,
    .do_stat=name_lstat, .do_utimes=name_utimes };
// newest
// file serialize.c line 88
static struct sqnode *newest;
// newline
// file sftpclient.c line 85
static char *newline;
// nhandles
// file handle.c line 51
static unsigned long int nhandles;
// nrequests
// file sftpclient.c line 97
static signed int nrequests = 16;
// nsshoptions
// file sftpclient.c line 105
static signed int nsshoptions;
// optarg
// file ./getopt.h line 36
extern char *optarg;
// optind
// file ./getopt.h line 50
extern signed int optind;
// options
// file sftpclient.c line 113
static struct option options[30l] = { { .name="help", .has_arg=0, .flag=((signed int *)NULL), .val=104 },
    { .name="version", .has_arg=0, .flag=((signed int *)NULL), .val=86 },
    { .name="dropbear", .has_arg=0, .flag=((signed int *)NULL), .val=114 },
    { .name="buffer", .has_arg=1, .flag=((signed int *)NULL), .val=66 },
    { .name="batch", .has_arg=1, .flag=((signed int *)NULL), .val=98 },
    { .name="program", .has_arg=1, .flag=((signed int *)NULL), .val=80 },
    { .name="requests", .has_arg=1, .flag=((signed int *)NULL), .val=82 },
    { .name="subsystem", .has_arg=1, .flag=((signed int *)NULL), .val=115 },
    { .name="sftp-version", .has_arg=1, .flag=((signed int *)NULL), .val=83 },
    { .name="quirk-reverse-symlink", .has_arg=0, .flag=((signed int *)NULL),
    .val=256 },
    { .name="stop-on-error", .has_arg=0, .flag=((signed int *)NULL), .val=257 },
    { .name="no-stop-on-error", .has_arg=0, .flag=((signed int *)NULL), .val=258 },
    { .name="progress", .has_arg=0, .flag=((signed int *)NULL), .val=259 },
    { .name="no-progress", .has_arg=0, .flag=((signed int *)NULL), .val=260 },
    { .name="echo", .has_arg=0, .flag=((signed int *)NULL), .val=261 },
    { .name="fix-sigpipe", .has_arg=0, .flag=((signed int *)NULL), .val=262 },
    { .name="force-version", .has_arg=1, .flag=((signed int *)NULL), .val=263 },
    { .name="debug", .has_arg=0, .flag=((signed int *)NULL), .val=100 },
    { .name="debug-path", .has_arg=1, .flag=((signed int *)NULL), .val=68 },
    { .name="host", .has_arg=1, .flag=((signed int *)NULL), .val=72 },
    { .name="port", .has_arg=1, .flag=((signed int *)NULL), .val=112 },
    { .name="ipv4", .has_arg=0, .flag=((signed int *)NULL), .val=52 },
    { .name="ipv6", .has_arg=0, .flag=((signed int *)NULL), .val=54 },
    { .name="1", .has_arg=0, .flag=((signed int *)NULL), .val=49 },
    { .name="2", .has_arg=0, .flag=((signed int *)NULL), .val=50 },
    { .name="C", .has_arg=0, .flag=((signed int *)NULL), .val=67 },
    { .name="F", .has_arg=1, .flag=((signed int *)NULL), .val=70 },
    { .name="o", .has_arg=1, .flag=((signed int *)NULL), .val=111 },
    { .name="v", .has_arg=0, .flag=((signed int *)NULL), .val=118 },
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
// output_lock
// file send.c line 40
static union anonymous_0 output_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// program
// file sftpclient.c line 99
static const char *program;
// progress_indicators
// file sftpclient.c line 82
static signed int progress_indicators = 1;
// protocol
// file sftpclient.c line 92
struct sftpprotocol *protocol;
// sftp_v3
// file v3.c line 783
struct sftpprotocol sftp_v3;
// sftpv3tab
// file v3.c line 754
static struct sftpcmd sftpv3tab[20l];
// sftpv3tab
// file v3.c line 754
static struct sftpcmd sftpv3tab[20l] = { { .type=(unsigned char)1, .handler=sftp_vany_already_init },
    { .type=(unsigned char)3, .handler=sftp_v34_open },
    { .type=(unsigned char)4, .handler=sftp_vany_close },
    { .type=(unsigned char)5, .handler=sftp_vany_read },
    { .type=(unsigned char)6, .handler=sftp_vany_write },
    { .type=(unsigned char)7, .handler=sftp_v3_lstat },
    { .type=(unsigned char)8, .handler=sftp_v3_fstat },
    { .type=(unsigned char)9, .handler=sftp_vany_setstat },
    { .type=(unsigned char)10, .handler=sftp_vany_fsetstat },
    { .type=(unsigned char)11, .handler=sftp_vany_opendir },
    { .type=(unsigned char)12, .handler=sftp_vany_readdir },
    { .type=(unsigned char)13, .handler=sftp_vany_remove },
    { .type=(unsigned char)14, .handler=sftp_vany_mkdir },
    { .type=(unsigned char)15, .handler=sftp_vany_rmdir },
    { .type=(unsigned char)16, .handler=sftp_v345_realpath },
    { .type=(unsigned char)17, .handler=sftp_v3_stat },
    { .type=(unsigned char)18, .handler=sftp_v34_rename },
    { .type=(unsigned char)19, .handler=sftp_vany_readlink },
    { .type=(unsigned char)20, .handler=sftp_v345_symlink },
    { .type=(unsigned char)200, .handler=sftp_vany_extended } };
// v3_extensions
// file v3.c line 777
static struct sftpextension v3_extensions[3l];
// v3_extensions
// file v3.c line 777
static struct sftpextension v3_extensions[3l] = { { .name="posix-rename@openssh.org", .handler=sftp_vany_posix_rename },
    { .name="space-available", .handler=sftp_vany_space_available },
    { .name="statfs@openssh.org", .handler=sftp_vany_statfs } };
// sftp_v3
// file v3.c line 783
struct sftpprotocol sftp_v3 = { .ncommands=(signed int)(sizeof(struct sftpcmd [20l]) /*320ul*/  / sizeof(struct sftpcmd) /*16ul*/ ), .commands=sftpv3tab,
    .version=3, .attrmask=(unsigned int)(0x00000001 | 0x00000004 | 0x00000008 | 0x00000020 | 0x00000002), .maxstatus=(unsigned int)8,
    .sendnames=v3_sendnames, .sendattrs=v3_sendattrs,
    .parseattrs=v3_parseattrs, .encode=sftp_v3_encode,
    .decode=v3_decode, .nextensions=(signed int)(sizeof(struct sftpextension [3l]) /*48ul*/  / sizeof(struct sftpextension) /*16ul*/ ),
    .extensions=v3_extensions };
// protocol
// file sftpclient.c line 92
struct sftpprotocol *protocol = &sftp_v3;
// quirk_reverse_symlink
// file sftpclient.c line 108
static signed int quirk_reverse_symlink;
// readonly
// file readwrite.c line 21
signed int readonly;
// reverse_symlink
// file v3.c line 46
signed int reverse_symlink;
// sendtype
// file sftpclient.c line 93
const char sendtype[8l] = { 'r', 'e', 'q', 'u', 'e', 's', 't', 0 };
// sequence
// file handle.c line 54
static unsigned int sequence;
// serverbuild
// file sftpclient.c line 87
static unsigned long int serverbuild;
// servername
// file sftpclient.c line 86
static char *servername;
// serverversion
// file sftpclient.c line 86
static char *serverversion;
// serverversions
// file sftpclient.c line 86
static char *serverversions;
// sftp_debugging
// file debug.c line 39
signed int sftp_debugging;
// sftp_debugpath
// file debug.c line 37
const char *sftp_debugpath;
// sftp_handle_lock
// file handle.c line 57
static union anonymous_0 sftp_handle_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// sftp_v4
// file v4.c line 293
struct sftpprotocol sftp_v4;
// sftpv4tab
// file v4.c line 263
static struct sftpcmd sftpv4tab[20l];
// sftpv4tab
// file v4.c line 263
static struct sftpcmd sftpv4tab[20l] = { { .type=(unsigned char)1, .handler=sftp_vany_already_init },
    { .type=(unsigned char)3, .handler=sftp_v34_open },
    { .type=(unsigned char)4, .handler=sftp_vany_close },
    { .type=(unsigned char)5, .handler=sftp_vany_read },
    { .type=(unsigned char)6, .handler=sftp_vany_write },
    { .type=(unsigned char)7, .handler=sftp_v456_lstat },
    { .type=(unsigned char)8, .handler=sftp_v456_fstat },
    { .type=(unsigned char)9, .handler=sftp_vany_setstat },
    { .type=(unsigned char)10, .handler=sftp_vany_fsetstat },
    { .type=(unsigned char)11, .handler=sftp_vany_opendir },
    { .type=(unsigned char)12, .handler=sftp_vany_readdir },
    { .type=(unsigned char)13, .handler=sftp_vany_remove },
    { .type=(unsigned char)14, .handler=sftp_vany_mkdir },
    { .type=(unsigned char)15, .handler=sftp_vany_rmdir },
    { .type=(unsigned char)16, .handler=sftp_v345_realpath },
    { .type=(unsigned char)17, .handler=sftp_v456_stat },
    { .type=(unsigned char)18, .handler=sftp_v34_rename },
    { .type=(unsigned char)19, .handler=sftp_vany_readlink },
    { .type=(unsigned char)20, .handler=sftp_v345_symlink },
    { .type=(unsigned char)200, .handler=sftp_vany_extended } };
// v4_extensions
// file v4.c line 286
static struct sftpextension v4_extensions[4l];
// v4_extensions
// file v4.c line 286
static struct sftpextension v4_extensions[4l] = { { .name="posix-rename@openssh.org", .handler=sftp_vany_posix_rename },
    { .name="space-available", .handler=sftp_vany_space_available },
    { .name="statfs@openssh.org", .handler=sftp_vany_statfs },
    { .name="text-seek", .handler=sftp_vany_text_seek } };
// sftp_v4
// file v4.c line 293
struct sftpprotocol sftp_v4 = { .ncommands=(signed int)(sizeof(struct sftpcmd [20l]) /*320ul*/  / sizeof(struct sftpcmd) /*16ul*/ ), .commands=sftpv4tab,
    .version=4, .attrmask=(unsigned int)(0x00000001 | 0x00000004 | 0x00000008 | 0x00000020 | 0x00000080 | 0x00000100), .maxstatus=(unsigned int)13,
    .sendnames=sftp_v456_sendnames, .sendattrs=sftp_v456_sendattrs,
    .parseattrs=sftp_v456_parseattrs, .encode=sftp_v456_encode,
    .decode=sftp_v456_decode, .nextensions=(signed int)(sizeof(struct sftpextension [4l]) /*64ul*/  / sizeof(struct sftpextension) /*16ul*/ ),
    .extensions=v4_extensions };
// sftp_v5
// file v5.c line 486
struct sftpprotocol sftp_v5;
// sftp_v5_extensions
// file v5.c line 479
static struct sftpextension sftp_v5_extensions[4l];
// sftp_v5_extensions
// file v5.c line 479
static struct sftpextension sftp_v5_extensions[4l] = { { .name="posix-rename@openssh.org", .handler=sftp_vany_posix_rename },
    { .name="space-available", .handler=sftp_vany_space_available },
    { .name="statfs@openssh.org", .handler=sftp_vany_statfs },
    { .name="text-seek", .handler=sftp_vany_text_seek } };
// sftpv5tab
// file v5.c line 456
static struct sftpcmd sftpv5tab[20l];
// sftpv5tab
// file v5.c line 456
static struct sftpcmd sftpv5tab[20l] = { { .type=(unsigned char)1, .handler=sftp_vany_already_init },
    { .type=(unsigned char)3, .handler=sftp_v56_open },
    { .type=(unsigned char)4, .handler=sftp_vany_close },
    { .type=(unsigned char)5, .handler=sftp_vany_read },
    { .type=(unsigned char)6, .handler=sftp_vany_write },
    { .type=(unsigned char)7, .handler=sftp_v456_lstat },
    { .type=(unsigned char)8, .handler=sftp_v456_fstat },
    { .type=(unsigned char)9, .handler=sftp_vany_setstat },
    { .type=(unsigned char)10, .handler=sftp_vany_fsetstat },
    { .type=(unsigned char)11, .handler=sftp_vany_opendir },
    { .type=(unsigned char)12, .handler=sftp_vany_readdir },
    { .type=(unsigned char)13, .handler=sftp_vany_remove },
    { .type=(unsigned char)14, .handler=sftp_vany_mkdir },
    { .type=(unsigned char)15, .handler=sftp_vany_rmdir },
    { .type=(unsigned char)16, .handler=sftp_v345_realpath },
    { .type=(unsigned char)17, .handler=sftp_v456_stat },
    { .type=(unsigned char)18, .handler=sftp_v56_rename },
    { .type=(unsigned char)19, .handler=sftp_vany_readlink },
    { .type=(unsigned char)20, .handler=sftp_v345_symlink },
    { .type=(unsigned char)200, .handler=sftp_vany_extended } };
// sftp_v5
// file v5.c line 486
struct sftpprotocol sftp_v5 = { .ncommands=(signed int)(sizeof(struct sftpcmd [20l]) /*320ul*/  / sizeof(struct sftpcmd) /*16ul*/ ), .commands=sftpv5tab,
    .version=5, .attrmask=(unsigned int)(0x00000001 | 0x00000004 | 0x00000008 | 0x00000020 | 0x00000080 | 0x00000100 | 0x00000200), .maxstatus=(unsigned int)17,
    .sendnames=sftp_v456_sendnames, .sendattrs=sftp_v456_sendattrs,
    .parseattrs=sftp_v456_parseattrs, .encode=sftp_v456_encode,
    .decode=sftp_v456_decode, .nextensions=(signed int)(sizeof(struct sftpextension [4l]) /*64ul*/  / sizeof(struct sftpextension) /*16ul*/ ),
    .extensions=sftp_v5_extensions };
// sftp_v6
// file v6.c line 194
struct sftpprotocol sftp_v6;
// sftp_v6_extensions
// file v6.c line 186
static struct sftpextension sftp_v6_extensions[5l];
// sftp_v6_extensions
// file v6.c line 186
static struct sftpextension sftp_v6_extensions[5l] = { { .name="posix-rename@openssh.org", .handler=sftp_vany_posix_rename },
    { .name="space-available", .handler=sftp_vany_space_available },
    { .name="statfs@openssh.org", .handler=sftp_vany_statfs },
    { .name="text-seek", .handler=sftp_vany_text_seek },
    { .name="version-select", .handler=sftp_v6_version_select } };
// sftpv6tab
// file v6.c line 161
static struct sftpcmd sftpv6tab[20l];
// sftpv6tab
// file v6.c line 161
static struct sftpcmd sftpv6tab[20l] = { { .type=(unsigned char)1, .handler=sftp_vany_already_init },
    { .type=(unsigned char)3, .handler=sftp_v56_open },
    { .type=(unsigned char)4, .handler=sftp_vany_close },
    { .type=(unsigned char)5, .handler=sftp_vany_read },
    { .type=(unsigned char)6, .handler=sftp_vany_write },
    { .type=(unsigned char)7, .handler=sftp_v456_lstat },
    { .type=(unsigned char)8, .handler=sftp_v456_fstat },
    { .type=(unsigned char)9, .handler=sftp_vany_setstat },
    { .type=(unsigned char)10, .handler=sftp_vany_fsetstat },
    { .type=(unsigned char)11, .handler=sftp_vany_opendir },
    { .type=(unsigned char)12, .handler=sftp_vany_readdir },
    { .type=(unsigned char)13, .handler=sftp_vany_remove },
    { .type=(unsigned char)14, .handler=sftp_vany_mkdir },
    { .type=(unsigned char)15, .handler=sftp_vany_rmdir },
    { .type=(unsigned char)16, .handler=sftp_v6_realpath },
    { .type=(unsigned char)17, .handler=sftp_v456_stat },
    { .type=(unsigned char)18, .handler=sftp_v56_rename },
    { .type=(unsigned char)19, .handler=sftp_vany_readlink },
    { .type=(unsigned char)21, .handler=sftp_v6_link },
    { .type=(unsigned char)200, .handler=sftp_vany_extended } };
// sftp_v6
// file v6.c line 194
struct sftpprotocol sftp_v6 = { .ncommands=(signed int)(sizeof(struct sftpcmd [20l]) /*320ul*/  / sizeof(struct sftpcmd) /*16ul*/ ), .commands=sftpv6tab,
    .version=6, .attrmask=(unsigned int)(0x00000001 | 0x00000004 | 0x00000008 | 0x00008000 | 0x00000020 | 0x00000080 | 0x00000100 | 0x00000200 | 0x00002000), .maxstatus=(unsigned int)31,
    .sendnames=sftp_v456_sendnames, .sendattrs=sftp_v456_sendattrs,
    .parseattrs=sftp_v456_parseattrs, .encode=sftp_v456_encode,
    .decode=sftp_v456_decode, .nextensions=(signed int)(sizeof(struct sftpextension [5l]) /*80ul*/  / sizeof(struct sftpextension) /*16ul*/ ),
    .extensions=sftp_v6_extensions };
// sftpin
// file sftpclient.c line 75
static signed int sftpin;
// sftpout
// file send.c line 42
signed int sftpout = 1;
// sftpversion
// file sftpclient.c line 107
static signed int sftpversion = 6;
// sq_cond
// file serialize.c line 94
static union anonymous_2 sq_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// sq_mutex
// file serialize.c line 91
static union anonymous_0 sq_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// sshconf
// file sftpclient.c line 103
static const char *sshconf;
// sshoptions
// file sftpclient.c line 104
static const char *sshoptions[1024l];
// sshverbose
// file sftpclient.c line 106
static signed int sshverbose;
// sshversion
// file sftpclient.c line 101
static signed int sshversion;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// stoponerror
// file sftpclient.c line 88
static signed int stoponerror;
// subsystem
// file sftpclient.c line 98
static const char *subsystem;
// terminal_width
// file sftpclient.c line 83
static signed int terminal_width;
// textmode
// file sftpclient.c line 84
static signed int textmode;
// user_lock
// file users.c line 33
static union anonymous_0 user_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// vendorname
// file sftpclient.c line 86
static char *vendorname;
// workqueue
// file globals.c line 25
struct queue *workqueue = ((struct queue *)NULL);

// append
// file utils.c line 159
char * append(struct allocator *a, char *s, unsigned long int *ns, const char *t)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(t);
  char *return_value_appendn_2;
  return_value_appendn_2=appendn(a, s, ns, t, return_value_strlen_1);
  return return_value_appendn_2;
}

// appendn
// file utils.c line 136
char * appendn(struct allocator *a, char *s, unsigned long int *ns, const char *t, unsigned long int lt)
{
  unsigned long int ls;
  unsigned long int tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(!(s == ((char *)NULL)))
  {
    return_value_strlen_1=strlen(s);
    tmp_if_expr_2 = return_value_strlen_1;
  }

  else
    tmp_if_expr_2 = (unsigned long int)0;
  ls = tmp_if_expr_2;
  const unsigned long int need = lt + ls + (unsigned long int)1;
  unsigned long int tmp_if_expr_3;
  if(!(*ns >= need))
  {
    unsigned long int newsize;
    if(!(*ns == 0ul))
      tmp_if_expr_3 = *ns;

    else
      tmp_if_expr_3 = (unsigned long int)16;
    newsize = tmp_if_expr_3;
    for( ; !(newsize == 0ul) && !(newsize >= need); newsize = newsize * (unsigned long int)2)
      ;
    if(newsize == 0ul)
      fatal("appendn: out of memory (%zu, %zu)", ls, need);

    void *return_value_sftp_alloc_more_4;
    return_value_sftp_alloc_more_4=sftp_alloc_more(a, (void *)s, *ns, newsize);
    s = (char *)return_value_sftp_alloc_more_4;
    *ns = newsize;
  }

  else
    /* assertion s */
    assert(s != ((char *)NULL));
  memcpy((void *)(s + (signed long int)ls), (const void *)t, lt);
  s[(signed long int)(ls + lt)] = (char)0;
  return s;
}

// blocks
// file alloc.c line 85
static inline unsigned long int blocks(unsigned long int nbytes)
{
  return nbytes / sizeof(union block) /*32ul*/  + (unsigned long int)!(!(nbytes % sizeof(union block) /*32ul*/  != 0ul));
}

// cmd_bad_handle
// file sftpclient.c line 2201
static signed int cmd_bad_handle(signed int ac, char **av)
{
  struct client_handle h;
  h.len = (unsigned long int)8;
  h.data = (char *)(void *)"\0\0\0\0\0\0\0\0";
  sftp_readdir(&h, ((struct sftpattr **)NULL), ((unsigned long int *)NULL));
  sftp_close(&h);
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 5);
  sftp_send_uint32(&fakeworker, (unsigned int)0);
  sftp_send_bytes(&fakeworker, (const void *)h.data, h.len);
  sftp_send_uint64(&fakeworker, (unsigned long int)0);
  sftp_send_uint32(&fakeworker, (unsigned int)64);
  sftp_send_end(&fakeworker);
  getresponse(101, (unsigned int)0, "_bad_handle");
  status();
  return 0;
}

// cmd_bad_packet
// file sftpclient.c line 2221
static signed int cmd_bad_packet(signed int ac, char **av)
{
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 5);
  sftp_send_end(&fakeworker);
  getresponse(101, (unsigned int)0, "_bad_packet");
  status();
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 5);
  sftp_send_uint8(&fakeworker, 0);
  sftp_send_end(&fakeworker);
  getresponse(101, (unsigned int)0, "_bad_packet");
  status();
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 5);
  sftp_send_uint32(&fakeworker, (unsigned int)0);
  sftp_send_uint8(&fakeworker, 0);
  sftp_send_end(&fakeworker);
  getresponse(101, (unsigned int)0, "_bad_packet");
  status();
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 5);
  sftp_send_uint32(&fakeworker, (unsigned int)0);
  sftp_send_uint32(&fakeworker, (unsigned int)64);
  sftp_send_end(&fakeworker);
  getresponse(101, (unsigned int)0, "_bad_packet");
  status();
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 5);
  sftp_send_uint32(&fakeworker, (unsigned int)0);
  sftp_send_uint32(&fakeworker, 0xFFFFFFFF);
  sftp_send_end(&fakeworker);
  getresponse(101, (unsigned int)0, "_bad_packet");
  status();
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 5);
  sftp_send_uint32(&fakeworker, (unsigned int)0);
  sftp_send_string(&fakeworker, "12345678");
  sftp_send_uint32(&fakeworker, (unsigned int)0);
  sftp_send_end(&fakeworker);
  getresponse(101, (unsigned int)0, "_bad_packet");
  status();
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 19);
  sftp_send_uint32(&fakeworker, (unsigned int)0);
  sftp_send_uint32(&fakeworker, 0xFFFFFFFF);
  sftp_send_end(&fakeworker);
  getresponse(101, (unsigned int)0, "_bad_packet");
  status();
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 19);
  sftp_send_uint32(&fakeworker, (unsigned int)0);
  sftp_send_uint32(&fakeworker, (unsigned int)32);
  sftp_send_end(&fakeworker);
  getresponse(101, (unsigned int)0, "_bad_packet");
  status();
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 19);
  sftp_send_uint32(&fakeworker, (unsigned int)0);
  sftp_send_uint8(&fakeworker, 0);
  sftp_send_end(&fakeworker);
  getresponse(101, (unsigned int)0, "_bad_packet");
  status();
  return 0;
}

// cmd_bad_packet456
// file sftpclient.c line 2288
static signed int cmd_bad_packet456(signed int ac, char **av)
{
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 9);
  sftp_send_uint32(&fakeworker, (unsigned int)0);
  sftp_send_string(&fakeworker, "path");
  sftp_send_uint32(&fakeworker, (unsigned int)0);
  sftp_send_end(&fakeworker);
  getresponse(101, (unsigned int)0, "_bad_packet");
  status();
  return 0;
}

// cmd_bad_path
// file sftpclient.c line 2302
static signed int cmd_bad_path(signed int ac, char **av)
{
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 11);
  sftp_send_uint32(&fakeworker, (unsigned int)0);
  sftp_send_string(&fakeworker, "");
  sftp_send_end(&fakeworker);
  getresponse(101, (unsigned int)0, "_bad_path");
  status();
  return 0;
}

// cmd_binary
// file sftpclient.c line 2005
static signed int cmd_binary(signed int ac, char **av)
{
  textmode = 0;
  return 0;
}

// cmd_cd
// file sftpclient.c line 888
static signed int cmd_cd(signed int ac, char **av)
{
  const char *newcwd;
  struct sftpattr attrs;
  remote_cwd();
  if(protocol->version >= 6)
  {
    newcwd=sftp_realpath_v6(cwd, 0x00000003, av, &attrs);
    if(newcwd == ((const char *)NULL))
      return -1;

  }

  else
  {
    const char *return_value_makeabspath_1;
    return_value_makeabspath_1=makeabspath(av[(signed long int)0]);
    newcwd=sftp_realpath(return_value_makeabspath_1);
    if(newcwd == ((const char *)NULL))
      return -1;

    signed int return_value_sftp_stat_2;
    return_value_sftp_stat_2=sftp_stat(newcwd, &attrs, (unsigned char)7);
    if(!(return_value_sftp_stat_2 == 0))
      return -1;

  }
  if(!((signed int)attrs.type == 2))
  {
    error("%s is not a directory (type %d)", av[(signed long int)0], attrs.type);
    return -1;
  }

  else
  {
    free((void *)cwd);
    cwd=xstrdup(newcwd);
    return 0;
  }
}

// cmd_chgrp
// file sftpclient.c line 1229
static signed int cmd_chgrp(signed int ac, char **av)
{
  struct sftpattr attrs;
  signed int return_value_sftp_stat_1;
  return_value_sftp_stat_1=sftp_stat(av[(signed long int)1], &attrs, (unsigned char)17);
  signed int return_value_error_2;
  signed int return_value_error_3;
  if(!(return_value_sftp_stat_1 == 0))
    return -1;

  else
  {
    if(protocol->version >= 4)
    {
      if((128u & attrs.valid) == 0u)
      {
        return_value_error_2=error("cannot determine former owner/group");
        return return_value_error_2;
      }

      attrs.group = av[(signed long int)0];
    }

    else
    {
      if((2u & attrs.valid) == 0u)
      {
        return_value_error_3=error("cannot determine former UID/GID");
        return return_value_error_3;
      }

      signed int return_value_atoi_4;
      return_value_atoi_4=atoi(av[(signed long int)0]);
      attrs.gid = (unsigned int)return_value_atoi_4;
    }
    signed int return_value_sftp_setstat_5;
    return_value_sftp_setstat_5=sftp_setstat(av[(signed long int)1], &attrs);
    return return_value_sftp_setstat_5;
  }
}

// cmd_chmod
// file sftpclient.c line 1247
static signed int cmd_chmod(signed int ac, char **av)
{
  struct sftpattr attrs;
  attrs.valid = (unsigned int)0x00000004;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  signed long int return_value_strtol_2;
  return_value_strtol_2=strtol(av[(signed long int)0], ((char ** restrict )NULL), 8);
  attrs.permissions = (unsigned int)return_value_strtol_2;
  signed int *return_value___errno_location_5;
  return_value___errno_location_5=__errno_location();
  signed int *return_value___errno_location_3;
  char *return_value_strerror_4;
  if(!(*return_value___errno_location_5 == 0) || !(attrs.permissions == (4095u & attrs.permissions)))
  {
    return_value___errno_location_3=__errno_location();
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    error("invalid permissions: %s", return_value_strerror_4);
  }

  signed int return_value_sftp_setstat_6;
  return_value_sftp_setstat_6=sftp_setstat(av[(signed long int)1], &attrs);
  return return_value_sftp_setstat_6;
}

// cmd_chown
// file sftpclient.c line 1211
static signed int cmd_chown(signed int ac, char **av)
{
  struct sftpattr attrs;
  signed int return_value_sftp_stat_1;
  return_value_sftp_stat_1=sftp_stat(av[(signed long int)1], &attrs, (unsigned char)17);
  signed int return_value_error_2;
  signed int return_value_error_3;
  if(!(return_value_sftp_stat_1 == 0))
    return -1;

  else
  {
    if(protocol->version >= 4)
    {
      if((128u & attrs.valid) == 0u)
      {
        return_value_error_2=error("cannot determine former owner/group");
        return return_value_error_2;
      }

      attrs.owner = av[(signed long int)0];
    }

    else
    {
      if((2u & attrs.valid) == 0u)
      {
        return_value_error_3=error("cannot determine former UID/GID");
        return return_value_error_3;
      }

      signed int return_value_atoi_4;
      return_value_atoi_4=atoi(av[(signed long int)0]);
      attrs.uid = (unsigned int)return_value_atoi_4;
    }
    signed int return_value_sftp_setstat_5;
    return_value_sftp_setstat_5=sftp_setstat(av[(signed long int)1], &attrs);
    return return_value_sftp_setstat_5;
  }
}

// cmd_debug
// file sftpclient.c line 2044
static signed int cmd_debug(signed int ac, char **av)
{
  sftp_debugging = (signed int)!(sftp_debugging != 0);
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_debugging enabled");

  while((_Bool)0);
  return 0;
}

// cmd_df
// file sftpclient.c line 2069
static signed int cmd_df(signed int ac, char **av)
{
  struct space_available as;
  char *tmp_if_expr_2;
  char *return_value_remote_cwd_1;
  if(!(ac == 0))
    tmp_if_expr_2 = av[(signed long int)0];

  else
  {
    return_value_remote_cwd_1=remote_cwd();
    tmp_if_expr_2 = return_value_remote_cwd_1;
  }
  signed int return_value_sftp_space_available_3;
  return_value_sftp_space_available_3=sftp_space_available(tmp_if_expr_2, &as);
  if(!(return_value_sftp_space_available_3 == 0))
    return -1;

  else
  {
    report_bytes(32, "Bytes on device", as.bytes_on_device);
    report_bytes(32, "Unused bytes on device", as.unused_bytes_on_device);
    report_bytes(32, "Available bytes on device", as.bytes_available_to_user);
    report_bytes(32, "Unused available bytes on device", as.unused_bytes_available_to_user);
    report_bytes(32, "Bytes per allocation unit", (unsigned long int)as.bytes_per_allocation_unit);
    return 0;
  }
}

// cmd_ext_unsupported
// file sftpclient.c line 2115
static signed int cmd_ext_unsupported(signed int ac, char **av)
{
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 200);
  sftp_send_uint32(&fakeworker, (unsigned int)0);
  sftp_send_string(&fakeworker, "no-such-sftp-extension@rjk.greenend.org.uk");
  sftp_send_end(&fakeworker);
  getresponse(101, (unsigned int)0, "_unsupported");
  status();
  return 0;
}

// cmd_get
// file sftpclient.c line 1503
static signed int cmd_get(signed int ac, char **av)
{
  signed int preserve = 0;
  const char *e;
  char *remote;
  struct reader_data r;
  struct sftpattr attrs;
  unsigned long int tid;
  struct timeval started;
  struct timeval finished;
  double elapsed;
  unsigned int flags = (unsigned int)0;
  signed int seek = 0;
  unsigned long int line = (unsigned long int)0;
  memset((void *)&attrs, 0, sizeof(struct sftpattr) /*200ul*/ );
  memset((void *)&r, 0, sizeof(struct reader_data) /*240ul*/ );
  r.fd = -1;
  char **tmp_post_1;
  const char *tmp_post_2;
  unsigned long long int return_value_strtoull_3;
  signed int return_value_error_4;
  if((signed int)*(*av) == 45)
  {
    const char *s;
    tmp_post_1 = av;
    av = av + 1l;
    s = *tmp_post_1;
    s = s + 1l;
    while(!(*s == 0))
    {
      tmp_post_2 = s;
      s = s + 1l;
      switch((signed int)*tmp_post_2)
      {
        case 80:
        {
          preserve = 1;
          break;
        }
        case 102:
        {
          flags = flags | (unsigned int)0x00000400;
          break;
        }
        case 76:
        {
          seek = 1;
          return_value_strtoull_3=strtoull(s, ((char ** restrict )NULL), 10);
          line = (unsigned long int)return_value_strtoull_3;
          s = "";
          break;
        }
        default:
        {
          return_value_error_4=error("unknown get option -%c'", s[(signed long int)-1]);
          return return_value_error_4;
        }
      }
    }
    ac = ac - 1;
  }

  char **tmp_post_5 = av;
  av = av + 1l;
  remote = *tmp_post_5;
  ac = ac - 1;
  char **tmp_post_6;
  if(!(ac == 0))
  {
    tmp_post_6 = av;
    av = av + 1l;
    r.local = *tmp_post_6;
    ac = ac - 1;
  }

  else
    r.local=__xpg_basename(remote);
  unsigned long int return_value_strlen_7;
  return_value_strlen_7=strlen(r.local);
  void *return_value_sftp_alloc_8;
  return_value_sftp_alloc_8=sftp_alloc(fakejob.a, return_value_strlen_7 + (unsigned long int)5);
  r.tmp = (char *)return_value_sftp_alloc_8;
  sprintf(r.tmp, "%s.new", r.local);
  r.fd=open(r.tmp, 01 | 01000 | 0100, 0666);
  if(!(r.fd >= 0))
  {
    signed int *return_value___errno_location_9;
    return_value___errno_location_9=__errno_location();
    char *return_value_strerror_10;
    return_value_strerror_10=strerror(*return_value___errno_location_9);
    error("error opening %s: %s", r.tmp, return_value_strerror_10);
    goto error;
  }

  if(!(textmode == 0))
  {
    flags = flags | (unsigned int)0x00000020;
    signed int return_value_write_translated_init_11;
    return_value_write_translated_init_11=write_translated_init(&r);
    if(!(return_value_write_translated_init_11 == 0))
      goto error;

    r.fd = -1;
  }

  signed int return_value_sftp_open_12;
  return_value_sftp_open_12=sftp_open(remote, (unsigned int)(0x00000001 | 0x00000080), (unsigned int)0x00000002 | flags, &attrs, &r.h);
  signed int return_value_sftp_fstat_13;
  void *return_value_sftp_alloc_18;
  signed int return_value_close_38;
  signed int return_value_rename_41;
  if(return_value_sftp_open_12 == 0)
  {
    return_value_sftp_fstat_13=sftp_fstat(&r.h, &attrs);
    if(!(return_value_sftp_fstat_13 == 0))
      goto error;

    if(textmode == 0 && !((1u & attrs.valid) == 0u))
    {
      if(!((unsigned long int)(signed long int)attrs.size == attrs.size))
      {
        error("remote file %s is too large (%lu bytes)", remote, attrs.size);
        goto error;
      }

      r.size = attrs.size;
    }

    else
      r.size = (unsigned long int)-1;
    if(!(seek == 0) && !(textmode == 0))
    {
      signed int return_value_sftp_text_seek_14;
      return_value_sftp_text_seek_14=sftp_text_seek(&r.h, line);
      if(!(return_value_sftp_text_seek_14 == 0))
        goto error;

    }

    gettimeofday(&started, ((struct timezone *)NULL));
    do
    {
      signed int frc;
      frc=pthread_mutex_init(&r.m, ((const union anonymous_1 *)NULL));
      if(!(frc == 0))
      {
        char *return_value_strerror_15;
        return_value_strerror_15=strerror(frc);
        fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1588, (const void *)"pthread_mutex_init(&r.m, 0)", return_value_strerror_15);
        exit(1);
      }

    }
    while((_Bool)0);
    do
    {
      signed int cmd_get__1__8__frc;
      cmd_get__1__8__frc=pthread_cond_init(&r.c1, ((const union anonymous_1 *)NULL));
      if(!(cmd_get__1__8__frc == 0))
      {
        char *return_value_strerror_16;
        return_value_strerror_16=strerror(cmd_get__1__8__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1589, (const void *)"pthread_cond_init(&r.c1, 0)", return_value_strerror_16);
        exit(1);
      }

    }
    while((_Bool)0);
    do
    {
      signed int cmd_get__1__9__frc;
      cmd_get__1__9__frc=pthread_cond_init(&r.c2, ((const union anonymous_1 *)NULL));
      if(!(cmd_get__1__9__frc == 0))
      {
        char *return_value_strerror_17;
        return_value_strerror_17=strerror(cmd_get__1__9__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1590, (const void *)"pthread_cond_init(&r.c2, 0)", return_value_strerror_17);
        exit(1);
      }

    }
    while((_Bool)0);
    return_value_sftp_alloc_18=sftp_alloc(fakejob.a, (unsigned long int)nrequests * sizeof(struct outstanding_read) /*16ul*/ );
    r.reqs = (struct outstanding_read *)return_value_sftp_alloc_18;
    do
    {
      signed int cmd_get__1__10__frc;
      cmd_get__1__10__frc=pthread_create(&tid, ((const union pthread_attr_t *)NULL), reader_thread, (void *)&r);
      if(!(cmd_get__1__10__frc == 0))
      {
        char *return_value_strerror_19;
        return_value_strerror_19=strerror(cmd_get__1__10__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1592, (const void *)"pthread_create(&tid, 0, reader_thread, &r)", return_value_strerror_19);
        exit(1);
      }

    }
    while((_Bool)0);
    do
    {
      signed int cmd_get__1__11__frc;
      cmd_get__1__11__frc=pthread_mutex_lock(&r.m);
      if(!(cmd_get__1__11__frc == 0))
      {
        char *return_value_strerror_20;
        return_value_strerror_20=strerror(cmd_get__1__11__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1593, (const void *)"pthread_mutex_lock(&r.m)", return_value_strerror_20);
        exit(1);
      }

    }
    while((_Bool)0);
    while(r.eof == 0 && r.failed == 0)
    {
      while(r.outstanding == 0)
        do
        {
          signed int cmd_get__1__12__1__frc;
          cmd_get__1__12__1__frc=pthread_cond_wait(&r.c2, &r.m);
          if(!(cmd_get__1__12__1__frc == 0))
          {
            char *return_value_strerror_21;
            return_value_strerror_21=strerror(cmd_get__1__12__1__frc);
            fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1602, (const void *)"pthread_cond_wait(&r.c2, &r.m)", return_value_strerror_21);
            exit(1);
          }

        }
        while((_Bool)0);
      reap_write_response(&r);
      do
      {
        signed int cmd_get__1__12__2__frc;
        cmd_get__1__12__2__frc=pthread_cond_signal(&r.c1);
        if(!(cmd_get__1__12__2__frc == 0))
        {
          char *return_value_strerror_22;
          return_value_strerror_22=strerror(cmd_get__1__12__2__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1605, (const void *)"pthread_cond_signal(&r.c1)", return_value_strerror_22);
          exit(1);
        }

      }
      while((_Bool)0);
    }
    do
    {
      signed int cmd_get__1__13__frc;
      cmd_get__1__13__frc=pthread_mutex_unlock(&r.m);
      if(!(cmd_get__1__13__frc == 0))
      {
        char *return_value_strerror_23;
        return_value_strerror_23=strerror(cmd_get__1__13__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1607, (const void *)"pthread_mutex_unlock(&r.m)", return_value_strerror_23);
        exit(1);
      }

    }
    while((_Bool)0);
    do
    {
      signed int cmd_get__1__14__frc;
      cmd_get__1__14__frc=pthread_join(tid, ((void **)NULL));
      if(!(cmd_get__1__14__frc == 0))
      {
        char *return_value_strerror_24;
        return_value_strerror_24=strerror(cmd_get__1__14__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1609, (const void *)"pthread_join(tid, 0)", return_value_strerror_24);
        exit(1);
      }

    }
    while((_Bool)0);
    do
    {
      signed int cmd_get__1__15__frc;
      cmd_get__1__15__frc=pthread_mutex_lock(&r.m);
      if(!(cmd_get__1__15__frc == 0))
      {
        char *return_value_strerror_25;
        return_value_strerror_25=strerror(cmd_get__1__15__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1611, (const void *)"pthread_mutex_lock(&r.m)", return_value_strerror_25);
        exit(1);
      }

    }
    while((_Bool)0);
    while(!(r.outstanding == 0))
      reap_write_response(&r);
    do
    {
      signed int cmd_get__1__16__frc;
      cmd_get__1__16__frc=pthread_mutex_unlock(&r.m);
      if(!(cmd_get__1__16__frc == 0))
      {
        char *return_value_strerror_26;
        return_value_strerror_26=strerror(cmd_get__1__16__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1614, (const void *)"pthread_mutex_unlock(&r.m)", return_value_strerror_26);
        exit(1);
      }

    }
    while((_Bool)0);
    do
    {
      signed int cmd_get__1__17__frc;
      cmd_get__1__17__frc=pthread_mutex_destroy(&r.m);
      if(!(cmd_get__1__17__frc == 0))
      {
        char *return_value_strerror_27;
        return_value_strerror_27=strerror(cmd_get__1__17__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1616, (const void *)"pthread_mutex_destroy(&r.m)", return_value_strerror_27);
        exit(1);
      }

    }
    while((_Bool)0);
    do
    {
      signed int cmd_get__1__18__frc;
      cmd_get__1__18__frc=pthread_cond_destroy(&r.c1);
      if(!(cmd_get__1__18__frc == 0))
      {
        char *return_value_strerror_28;
        return_value_strerror_28=strerror(cmd_get__1__18__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1617, (const void *)"pthread_cond_destroy(&r.c1)", return_value_strerror_28);
        exit(1);
      }

    }
    while((_Bool)0);
    do
    {
      signed int cmd_get__1__19__frc;
      cmd_get__1__19__frc=pthread_cond_destroy(&r.c2);
      if(!(cmd_get__1__19__frc == 0))
      {
        char *return_value_strerror_29;
        return_value_strerror_29=strerror(cmd_get__1__19__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1618, (const void *)"pthread_cond_destroy(&r.c2)", return_value_strerror_29);
        exit(1);
      }

    }
    while((_Bool)0);
    progress(((const char *)NULL), (unsigned long int)0, (unsigned long int)0);
    if(!(r.failed == 0))
      goto error;

    gettimeofday(&finished, ((struct timezone *)NULL));
    if(!(progress_indicators == 0))
    {
      elapsed = (double)(finished.tv_sec - started.tv_sec) + (double)(finished.tv_usec - started.tv_usec) / 1000000.0;
      xprintf("%lu bytes in %.1f seconds", r.written, elapsed);
      if(elapsed > 0.1)
        xprintf(" %.0f bytes/sec", (double)r.written / elapsed);

      xprintf("\n");
    }

    sftp_close(&r.h);
    r.h.len = (unsigned long int)0;
    if(!(preserve == 0))
    {
      attrs.valid = attrs.valid & (unsigned int)~0x00000001;
      attrs.valid = attrs.valid & (unsigned int)~0x00000002;
      unsigned int return_value_sftp_set_fstatus_32;
      return_value_sftp_set_fstatus_32=sftp_set_fstatus(fakejob.a, r.fd, &attrs, &e);
      if(!(return_value_sftp_set_fstatus_32 == 0u))
      {
        signed int *return_value___errno_location_30;
        return_value___errno_location_30=__errno_location();
        char *return_value_strerror_31;
        return_value_strerror_31=strerror(*return_value___errno_location_30);
        error("cannot %s %s: %s", e, r.tmp, return_value_strerror_31);
        goto error;
      }

    }

    if(!(textmode == 0))
    {
      signed int return_value_write_translated_done_35;
      return_value_write_translated_done_35=write_translated_done(&r);
      if(!(return_value_write_translated_done_35 == 0))
      {
        signed int *return_value___errno_location_33;
        return_value___errno_location_33=__errno_location();
        char *return_value_strerror_34;
        return_value_strerror_34=strerror(*return_value___errno_location_33);
        error("error writing to %s: %s", r.tmp, return_value_strerror_34);
        goto error;
      }

    }

    else
    {
      return_value_close_38=close(r.fd);
      if(!(return_value_close_38 >= 0))
      {
        signed int *return_value___errno_location_36;
        return_value___errno_location_36=__errno_location();
        char *return_value_strerror_37;
        return_value_strerror_37=strerror(*return_value___errno_location_36);
        error("error closing %s: %s", r.tmp, return_value_strerror_37);
        r.fd = -1;
        goto error;
      }

    }
    return_value_rename_41=rename(r.tmp, r.local);
    if(!(return_value_rename_41 >= 0))
    {
      signed int *return_value___errno_location_39;
      return_value___errno_location_39=__errno_location();
      char *return_value_strerror_40;
      return_value_strerror_40=strerror(*return_value___errno_location_39);
      error("error renaming %s: %s", r.tmp, return_value_strerror_40);
      goto error;
    }

    return 0;
  }

  else
  {

  error:
    ;
    write_translated_done(&r);
    if(r.fd >= 0)
      close(r.fd);

    if(!(r.tmp == ((char *)NULL)))
      unlink(r.tmp);

    if(!(r.h.len == 0ul))
      sftp_close(&r.h);

    return -1;
  }
}

// cmd_help
// file sftpclient.c line 2672
static signed int cmd_help(signed int ac, char **av)
{
  signed int n;
  unsigned long int max = (unsigned long int)0;
  unsigned long int len = (unsigned long int)0;
  n = 0;
  unsigned long int return_value_strlen_1;
  for( ; !(commands[(signed long int)n].name == ((const char *)NULL)); n = n + 1)
    if(!((signed int)*commands[(signed long int)n].name == 95))
    {
      len=strlen(commands[(signed long int)n].name);
      if(!(commands[(signed long int)n].args == ((const char *)NULL)))
      {
        return_value_strlen_1=strlen(commands[(signed long int)n].args);
        len = len + return_value_strlen_1 + (unsigned long int)1;
      }

      if(!(max >= len))
        max = len;

    }

  n = 0;
  for( ; !(commands[(signed long int)n].name == ((const char *)NULL)); n = n + 1)
    if(!((signed int)*commands[(signed long int)n].name == 95))
    {
      len=strlen(commands[(signed long int)n].name);
      xprintf("%s", commands[(signed long int)n].name);
      if(!(commands[(signed long int)n].args == ((const char *)NULL)))
      {
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(commands[(signed long int)n].args);
        len = len + return_value_strlen_2 + (unsigned long int)1;
        xprintf(" %s", commands[(signed long int)n].args);
      }

      xprintf("%*s  %s\n", (signed int)(max - len), (const void *)"", commands[(signed long int)n].help);
    }

  return 0;
}

// cmd_init
// file sftpclient.c line 2099
static signed int cmd_init(signed int ac, char **av)
{
  signed int return_value_sftp_init_1;
  return_value_sftp_init_1=sftp_init();
  return return_value_sftp_init_1;
}

// cmd_lcd
// file sftpclient.c line 936
static signed int cmd_lcd(signed int ac, char **av)
{
  signed int return_value_chdir_3;
  return_value_chdir_3=chdir(av[(signed long int)0]);
  if(!(return_value_chdir_3 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    error("error calling chdir: %s", return_value_strerror_2);
    return -1;
  }

  return 0;
}

// cmd_link
// file sftpclient.c line 1301
static signed int cmd_link(signed int ac, char **av)
{
  signed int return_value_sftp_link_1;
  return_value_sftp_link_1=sftp_link(av[(signed long int)0], av[(signed long int)1], 0);
  return return_value_sftp_link_1;
}

// cmd_lls
// file sftpclient.c line 1154
static signed int cmd_lls(signed int ac, char **av)
{
  const char **args;
  void *return_value_sftp_alloc_1;
  return_value_sftp_alloc_1=sftp_alloc(fakejob.a, (unsigned long int)(ac + 2) * sizeof(char *) /*8ul*/ );
  args = (const char **)return_value_sftp_alloc_1;
  signed int n = 0;
  signed int pid;
  signed int tmp_post_2 = n;
  n = n + 1;
  args[(signed long int)tmp_post_2] = "ls";
  signed int tmp_post_3;
  signed int tmp_post_4;
  char **tmp_post_5;
  do
  {
    tmp_post_3 = ac;
    ac = ac - 1;
    if(tmp_post_3 == 0)
      break;

    tmp_post_4 = n;
    n = n + 1;
    tmp_post_5 = av;
    av = av + 1l;
    args[(signed long int)tmp_post_4] = *tmp_post_5;
  }
  while((_Bool)1);
  args[(signed long int)n] = ((const char *)NULL);
  pid=xfork();
  if(pid == 0)
  {
    execvp(args[(signed long int)0], (char * const *)(void *)args);
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    char *return_value_strerror_7;
    return_value_strerror_7=strerror(*return_value___errno_location_6);
    fatal("executing ls: %s", return_value_strerror_7);
  }

  signed int return_value_waitpid_10;
  return_value_waitpid_10=waitpid(pid, &n, 0);
  if(!(return_value_waitpid_10 >= 0))
  {
    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    char *return_value_strerror_9;
    return_value_strerror_9=strerror(*return_value___errno_location_8);
    fatal("error calling waitpid: %s", return_value_strerror_9);
    if(!(n == 0))
    {
      error("ls returned status %#x", n);
      return -1;
    }

  }

  return 0;
}

// cmd_lmkdir
// file sftpclient.c line 1202
static signed int cmd_lmkdir(signed int ac, char **av)
{
  signed int return_value_mkdir_3;
  return_value_mkdir_3=mkdir(av[(signed long int)0], (unsigned int)0777);
  if(!(return_value_mkdir_3 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    error("creating directory %s: %s", av[(signed long int)0], return_value_strerror_2);
    return -1;
  }

  return 0;
}

// cmd_lpwd
// file sftpclient.c line 924
static signed int cmd_lpwd(signed int ac, char **av)
{
  char *lpwd;
  lpwd=sftp_getcwd(fakejob.a);
  if(lpwd == ((char *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    error("error calling getcwd: %s", return_value_strerror_2);
    return -1;
  }

  xprintf("%s\n", lpwd);
  return 0;
}

// cmd_lrealpath
// file sftpclient.c line 2178
static signed int cmd_lrealpath(signed int ac, char **av)
{
  char *r;
  unsigned int flags;
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(av[(signed long int)0], "no-check");
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  signed int return_value_error_1;
  if(return_value_strcmp_4 == 0)
    flags = (unsigned int)0;

  else
  {
    return_value_strcmp_3=strcmp(av[(signed long int)0], "stat-if");
    if(return_value_strcmp_3 == 0)
      flags = (unsigned int)0x0001;

    else
    {
      return_value_strcmp_2=strcmp(av[(signed long int)0], "stat-always");
      if(return_value_strcmp_2 == 0)
        flags = (unsigned int)(0x0001 | 0x0002);

      else
      {
        return_value_error_1=error("unknown control string '%s'", av[(signed long int)0]);
        return return_value_error_1;
      }
    }
  }
  r=sftp_find_realpath(fakejob.a, av[(signed long int)1], flags);
  if(!(r == ((char *)NULL)))
  {
    xprintf("%s\n", r);
    return 0;
  }

  else
  {
    perror(((const char *)NULL));
    return -1;
  }
}

// cmd_ls
// file sftpclient.c line 1000
static signed int cmd_ls(signed int ac, char **av)
{
  const char *cmd_ls__1__options;
  const char *path;
  struct sftpattr *attrs;
  struct sftpattr *allattrs = ((struct sftpattr *)NULL);
  struct sftpattr fileattrs;
  unsigned long int nattrs;
  unsigned long int nallattrs = (unsigned long int)0;
  unsigned long int n;
  unsigned long int m;
  unsigned long int i;
  unsigned long int maxnamewidth = (unsigned long int)0;
  struct client_handle h;
  unsigned long int cols;
  unsigned long int rows;
  signed int singlefile;
  remote_cwd();
  _Bool tmp_if_expr_2;
  if(ac >= 1)
    tmp_if_expr_2 = (signed int)av[(signed long int)0][(signed long int)0] == 45 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  char **tmp_post_1;
  if(tmp_if_expr_2)
  {
    tmp_post_1 = av;
    av = av + 1l;
    cmd_ls__1__options = *tmp_post_1;
    ac = ac - 1;
  }

  else
    cmd_ls__1__options = "";
  char *tmp_if_expr_4;
  char *return_value_remote_cwd_3;
  if(ac >= 1)
    tmp_if_expr_4 = av[(signed long int)0];

  else
  {
    return_value_remote_cwd_3=remote_cwd();
    tmp_if_expr_4 = return_value_remote_cwd_3;
  }
  path = tmp_if_expr_4;
  signed int return_value_sftp_stat_5;
  return_value_sftp_stat_5=sftp_stat(path, &fileattrs, (unsigned char)7);
  _Bool tmp_if_expr_14;
  char *return_value_strchr_13;
  _Bool tmp_if_expr_12;
  unsigned long int tmp_post_11;
  char *return_value_strchr_15;
  _Bool tmp_if_expr_29;
  char *return_value_strchr_28;
  char *return_value_strchr_26;
  _Bool tmp_if_expr_24;
  if(!(return_value_sftp_stat_5 == 0))
    return -1;

  else
  {
    if(!((signed int)fileattrs.type == 2))
      tmp_if_expr_14 = (_Bool)1;

    else
    {
      return_value_strchr_13=strchr(cmd_ls__1__options, 100);
      tmp_if_expr_14 = return_value_strchr_13 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_14)
    {
      allattrs = &fileattrs;
      nallattrs = (unsigned long int)1;
      singlefile = 1;
    }

    else
    {
      signed int include_dotfiles;
      char *return_value_strchr_6;
      return_value_strchr_6=strchr(cmd_ls__1__options, 97);
      include_dotfiles = (const signed int)!(!(return_value_strchr_6 != ((char *)NULL)));
      singlefile = 0;
      signed int return_value_sftp_opendir_7;
      return_value_sftp_opendir_7=sftp_opendir(path, &h);
      if(!(return_value_sftp_opendir_7 == 0))
        return -1;

      do
      {
        signed int return_value_sftp_readdir_8;
        return_value_sftp_readdir_8=sftp_readdir(&h, &attrs, &nattrs);
        if(!(return_value_sftp_readdir_8 == 0))
        {
          sftp_close(&h);
          free((void *)allattrs);
          return -1;
        }

        if(nattrs == 0ul)
          break;

        void *return_value_xrecalloc_9;
        return_value_xrecalloc_9=xrecalloc((void *)allattrs, nattrs + nallattrs, sizeof(struct sftpattr) /*200ul*/ );
        allattrs = (struct sftpattr *)return_value_xrecalloc_9;
        n = (unsigned long int)0;
        for( ; !(n >= nattrs); n = n + 1ul)
        {
          unsigned long int w;
          signed int return_value_wcswidth_10;
          return_value_wcswidth_10=wcswidth((attrs + (signed long int)n)->wname, 18446744073709551615UL);
          w = (const unsigned long int)return_value_wcswidth_10;
          if(!(include_dotfiles == 0))
            tmp_if_expr_12 = (_Bool)1;

          else
            tmp_if_expr_12 = (signed int)(attrs + (signed long int)n)->name[(signed long int)0] != 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_12)
          {
            if(!(maxnamewidth >= w))
              maxnamewidth = w;

            tmp_post_11 = nallattrs;
            nallattrs = nallattrs + 1ul;
            allattrs[(signed long int)tmp_post_11] = attrs[(signed long int)n];
          }

        }
      }
      while((_Bool)1);
      sftp_close(&h);
    }
    char *return_value_strchr_18;
    return_value_strchr_18=strchr(cmd_ls__1__options, 102);
    if(return_value_strchr_18 == ((char *)NULL))
    {
      signed int (*sorter)(const void *, const void *);
      char *return_value_strchr_16;
      return_value_strchr_16=strchr(cmd_ls__1__options, 83);
      if(!(return_value_strchr_16 == ((char *)NULL)))
        sorter = sort_by_size;

      else
      {
        return_value_strchr_15=strchr(cmd_ls__1__options, 116);
        if(!(return_value_strchr_15 == ((char *)NULL)))
          sorter = sort_by_mtime;

        else
          sorter = sort_by_name;
      }
      if(!(nallattrs == 0ul))
        qsort((void *)allattrs, nallattrs, sizeof(struct sftpattr) /*200ul*/ , sorter);

      char *return_value_strchr_17;
      return_value_strchr_17=strchr(cmd_ls__1__options, 114);
      if(!(return_value_strchr_17 == ((char *)NULL)))
        reverse((void *)allattrs, nallattrs, sizeof(struct sftpattr) /*200ul*/ );

    }

    char *return_value_strchr_27;
    return_value_strchr_27=strchr(cmd_ls__1__options, 108);
    if(!(return_value_strchr_27 == ((char *)NULL)))
      tmp_if_expr_29 = (_Bool)1;

    else
    {
      return_value_strchr_28=strchr(cmd_ls__1__options, 110);
      tmp_if_expr_29 = return_value_strchr_28 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_29)
    {
      signed long int now;
      struct tm nowtime;
      unsigned long int flags;
      char *return_value_strchr_19;
      return_value_strchr_19=strchr(cmd_ls__1__options, 110);
      flags = (const unsigned long int)((return_value_strchr_19 != ((char *)NULL) ? 0x00000001 : 0) | 0x00000002 | 0x00000004);
      time(&now);
      gmtime_r(&now, &nowtime);
      n = (unsigned long int)0;
      for( ; !(n >= nallattrs); n = n + 1ul)
      {
        struct sftpattr * const cmd_ls__1__5__1__1__attrs = &allattrs[(signed long int)n];
        if((signed int)cmd_ls__1__5__1__1__attrs->type == 3)
        {
          if(cmd_ls__1__5__1__1__attrs->target == ((const char *)NULL))
          {
            if(!(singlefile == 0))
              cmd_ls__1__5__1__1__attrs->target=sftp_readlink(cmd_ls__1__5__1__1__attrs->name);

            else
            {
              char *fullname;
              unsigned long int return_value_strlen_20;
              return_value_strlen_20=strlen(path);
              unsigned long int return_value_strlen_21;
              return_value_strlen_21=strlen(cmd_ls__1__5__1__1__attrs->name);
              void *return_value_sftp_alloc_22;
              return_value_sftp_alloc_22=sftp_alloc(fakejob.a, return_value_strlen_20 + return_value_strlen_21 + (unsigned long int)2);
              fullname = (char *)return_value_sftp_alloc_22;
              strcpy(fullname, path);
              strcat(fullname, "/");
              strcat(fullname, cmd_ls__1__5__1__1__attrs->name);
              do
                if(!(sftp_debugging == 0))
                  sftp_debug_printf("%s -> %s", cmd_ls__1__5__1__1__attrs->name, fullname);

              while((_Bool)0);
              cmd_ls__1__5__1__1__attrs->target=sftp_readlink(fullname);
            }
          }

        }

        const char *return_value_sftp_format_attr_23;
        return_value_sftp_format_attr_23=sftp_format_attr(fakejob.a, cmd_ls__1__5__1__1__attrs, nowtime.tm_year, flags);
        xprintf("%s\n", return_value_sftp_format_attr_23);
      }
    }

    else
    {
      return_value_strchr_26=strchr(cmd_ls__1__options, 49);
      if(!(return_value_strchr_26 == ((char *)NULL)))
      {
        n = (unsigned long int)0;
        for( ; !(n >= nallattrs); n = n + 1ul)
          xprintf("%s\n", (allattrs + (signed long int)n)->name);
      }

      else
      {
        cols = (unsigned long int)(terminal_width + 1) / (maxnamewidth + (unsigned long int)1);
        if(cols == 0ul)
          cols = (unsigned long int)1;

        rows = ((nallattrs + cols) - (unsigned long int)1) / cols;
        n = (unsigned long int)0;
        for( ; !(n >= rows); n = n + 1ul)
        {
          m = (unsigned long int)0;
          do
          {
            if(!(m >= cols))
            {
              i = n + m * rows;
              tmp_if_expr_24 = i < nallattrs ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_24 = (_Bool)0;
            if(!tmp_if_expr_24)
              break;

            unsigned long int cmd_ls__1__7__1__1__1__1__w;
            signed int return_value_wcswidth_25;
            return_value_wcswidth_25=wcswidth((allattrs + (signed long int)i)->wname, 18446744073709551615UL);
            cmd_ls__1__7__1__1__1__1__w = (const unsigned long int)return_value_wcswidth_25;
            xprintf("%s%*s", (allattrs + (signed long int)i)->name, m + (unsigned long int)1 < cols && i + rows < nallattrs ? (signed int)((maxnamewidth - cmd_ls__1__7__1__1__1__1__w) + (unsigned long int)1) : 0, (const void *)"");
            m = m + 1ul;
          }
          while((_Bool)1);
          xprintf("\n");
        }
      }
    }
    if(!(allattrs == &fileattrs))
      free((void *)allattrs);

    return 0;
  }
}

// cmd_lstat
// file sftpclient.c line 2329
static signed int cmd_lstat(signed int ac, char **av)
{
  struct sftpattr attrs;
  signed long int now;
  struct tm nowtime;
  signed int return_value_sftp_stat_1;
  return_value_sftp_stat_1=sftp_stat(av[(signed long int)0], &attrs, (unsigned char)7);
  if(!(return_value_sftp_stat_1 == 0))
    return -1;

  else
  {
    time(&now);
    gmtime_r(&now, &nowtime);
    const char *return_value_sftp_format_attr_2;
    return_value_sftp_format_attr_2=sftp_format_attr(fakejob.a, &attrs, nowtime.tm_year, (unsigned long int)0);
    xprintf("%s\n", return_value_sftp_format_attr_2);
    return 0;
  }
}

// cmd_lumask
// file sftpclient.c line 1178
static signed int cmd_lumask(signed int ac, char **av)
{
  unsigned int n;
  if(!(ac == 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 0;
    signed long int return_value_strtol_2;
    return_value_strtol_2=strtol(av[(signed long int)0], ((char ** restrict )NULL), 8);
    n = (unsigned int)return_value_strtol_2;
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    if(!(*return_value___errno_location_5 == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      error("invalid umask: %s", return_value_strerror_4);
      return -1;
    }

    if(!(n == (511u & n)))
    {
      error("umask out of range");
      return -1;
    }

    umask(n);
  }

  else
  {
    n=umask((unsigned int)0);
    umask(n);
    xprintf("%03o\n", (unsigned int)n);
  }
  return 0;
}

// cmd_mkdir
// file sftpclient.c line 2084
static signed int cmd_mkdir(signed int ac, char **av)
{
  const char *path;
  unsigned int mode;
  if(ac == 2)
  {
    unsigned long int return_value_strtoul_1;
    return_value_strtoul_1=strtoul(av[(signed long int)0], ((char ** restrict )NULL), 8);
    mode = (unsigned int)return_value_strtoul_1;
    path = av[(signed long int)1];
  }

  else
  {
    mode = (unsigned int)-1;
    path = av[(signed long int)0];
  }
  signed int return_value_sftp_mkdir_2;
  return_value_sftp_mkdir_2=sftp_mkdir(path, mode);
  return return_value_sftp_mkdir_2;
}

// cmd_mv
// file sftpclient.c line 1269
static signed int cmd_mv(signed int ac, char **av)
{
  const char *tmp_post_2;
  signed int return_value_error_1;
  const char *tmp_post_3;
  signed int return_value_error_4;
  signed int return_value_sftp_prename_5;
  signed int return_value_sftp_rename_6;
  signed int return_value_sftp_rename_7;
  if(ac == 3)
  {
    const char *ptr = av[(signed long int)0];
    signed int c;
    unsigned int flags = (unsigned int)0;
    signed int posixrename = 0;
    tmp_post_2 = ptr;
    ptr = ptr + 1l;
    if(!((signed int)*tmp_post_2 == 45))
    {
      return_value_error_1=error("invalid options '%s'", av[(signed long int)0]);
      return return_value_error_1;
    }

    do
    {
      tmp_post_3 = ptr;
      ptr = ptr + 1l;
      c = (signed int)*tmp_post_3;
      if(c == 0)
        break;

      switch(c)
      {
        case 110:
        {
          flags = flags | (unsigned int)0x00000004;
          break;
        }
        case 97:
        {
          flags = flags | (unsigned int)0x00000002;
          break;
        }
        case 111:
        {
          flags = flags | (unsigned int)0x00000001;
          break;
        }
        case 112:
        {
          posixrename = 1;
          break;
        }
        default:
        {
          return_value_error_4=error("invalid options '%s'", av[(signed long int)0]);
          return return_value_error_4;
        }
      }
    }
    while((_Bool)1);
    if(!(posixrename == 0))
    {
      return_value_sftp_prename_5=sftp_prename(av[(signed long int)1], av[(signed long int)2]);
      return return_value_sftp_prename_5;
    }

    else
    {
      return_value_sftp_rename_6=sftp_rename(av[(signed long int)1], av[(signed long int)2], flags);
      return return_value_sftp_rename_6;
    }
  }

  else
  {
    return_value_sftp_rename_7=sftp_rename(av[(signed long int)0], av[(signed long int)1], (unsigned int)0);
    return return_value_sftp_rename_7;
  }
}

// cmd_overlap
// file sftpclient.c line 2352
static signed int cmd_overlap(signed int ac, char **av)
{
  struct sftpattr attrs;
  char buffer[128l];
  signed int n;
  signed int r;
  signed int rc = -1;
  unsigned int ida;
  unsigned int idb;
  unsigned int idc;
  unsigned int idd;
  signed int fd = -1;
  struct client_handle h;
  memset((void *)&attrs, 0, sizeof(struct sftpattr) /*200ul*/ );
  signed int return_value_sftp_open_1;
  return_value_sftp_open_1=sftp_open("dest", (unsigned int)0x00000002, (unsigned int)0x00000001, &attrs, &h);
  if(return_value_sftp_open_1 == 0)
  {
    fd=open("dest", 02);
    if(!(fd >= 0))
      perror("open dest");

    else
    {
      n = 0;
      for( ; !(n >= 1024); n = n + 1)
      {
        sftp_send_begin(&fakeworker);
        sftp_send_uint8(&fakeworker, 6);
        ida=newid();
        sftp_send_uint32(&fakeworker, ida);
        sftp_send_bytes(&fakeworker, (const void *)h.data, h.len);
        sftp_send_uint64(&fakeworker, (unsigned long int)0);
        static const char a[65l] = { 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 0 };
        sftp_send_bytes(&fakeworker, (const void *)a, (unsigned long int)64);
        sftp_send_end(&fakeworker);
        sftp_send_begin(&fakeworker);
        sftp_send_uint8(&fakeworker, 6);
        idb=newid();
        sftp_send_uint32(&fakeworker, idb);
        sftp_send_bytes(&fakeworker, (const void *)h.data, h.len);
        sftp_send_uint64(&fakeworker, (unsigned long int)16);
        static const char b[65l] = { 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 0 };
        sftp_send_bytes(&fakeworker, (const void *)b, (unsigned long int)64);
        sftp_send_end(&fakeworker);
        sftp_send_begin(&fakeworker);
        sftp_send_uint8(&fakeworker, 6);
        idc=newid();
        sftp_send_uint32(&fakeworker, idc);
        sftp_send_bytes(&fakeworker, (const void *)h.data, h.len);
        sftp_send_uint64(&fakeworker, (unsigned long int)32);
        static const char c[65l] = { 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 0 };
        sftp_send_bytes(&fakeworker, (const void *)c, (unsigned long int)64);
        sftp_send_end(&fakeworker);
        sftp_send_begin(&fakeworker);
        sftp_send_uint8(&fakeworker, 6);
        idd=newid();
        sftp_send_uint32(&fakeworker, idd);
        sftp_send_bytes(&fakeworker, (const void *)h.data, h.len);
        sftp_send_uint64(&fakeworker, (unsigned long int)48);
        static const char d[65l] = { 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 0 };
        sftp_send_bytes(&fakeworker, (const void *)d, (unsigned long int)64);
        sftp_send_end(&fakeworker);
        getresponse(101, (unsigned int)0, "SSH_FXP_WRITE");
        getresponse(101, (unsigned int)0, "SSH_FXP_WRITE");
        getresponse(101, (unsigned int)0, "SSH_FXP_WRITE");
        getresponse(101, (unsigned int)0, "SSH_FXP_WRITE");
        signed long int return_value_lseek_2;
        return_value_lseek_2=lseek(fd, (signed long int)0, 0);
        if(!(return_value_lseek_2 >= 0l))
        {
          perror("lseek");
          goto error;
        }

        signed long int return_value_read_3;
        return_value_read_3=read(fd, (void *)buffer, sizeof(char [128l]) /*128ul*/ );
        r = (signed int)return_value_read_3;
        if(!(r == 48))
        {
          fprintf(stderr, "expected %d bytes got %d\n", 48 + 64, r);
          goto error;
        }

        buffer[(signed long int)r] = (char)0;
        signed int return_value_memcmp_4;
        static const char expect[113l] = { 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 0 };
        return_value_memcmp_4=memcmp((const void *)buffer, (const void *)expect, (unsigned long int)(48 + 64));
        if(!(return_value_memcmp_4 == 0))
        {
          fprintf(stderr, "buffer contents mismatch\nexpect: %s\n   got: %s\n", (const void *)expect, (const void *)buffer);
          goto error;
        }

        signed int return_value_ftruncate_5;
        return_value_ftruncate_5=ftruncate(fd, (signed long int)0);
        if(!(return_value_ftruncate_5 >= 0))
        {
          perror("ftruncate");
          goto error;
        }

      }
      rc = 0;
    }
  }


error:
  ;
  if(fd >= 0)
    close(fd);

  return rc;
}

// cmd_progress
// file sftpclient.c line 1983
static signed int cmd_progress(signed int ac, char **av)
{
  signed int return_value_strcmp_2;
  signed int return_value_error_1;
  if(!(ac == 0))
  {
    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(av[(signed long int)0], "on");
    if(return_value_strcmp_3 == 0)
      progress_indicators = 1;

    else
    {
      return_value_strcmp_2=strcmp(av[(signed long int)0], "off");
      if(return_value_strcmp_2 == 0)
        progress_indicators = 0;

      else
      {
        return_value_error_1=error("invalid progress option '%s'", av[(signed long int)0]);
        return return_value_error_1;
      }
    }
  }

  else
    progress_indicators = progress_indicators ^ 1;
  return 0;
}

// cmd_put
// file sftpclient.c line 1725
static signed int cmd_put(signed int ac, char **av)
{
  char *local;
  const char *remote;
  struct sftpattr attrs;
  struct stat sb;
  signed int fd = -1;
  signed int i;
  signed int preserve = 0;
  signed int failed = 0;
  signed int eof = 0;
  struct client_handle h;
  signed long int offset;
  signed long int n;
  struct writer_data w;
  unsigned long int tid;
  struct timeval started;
  struct timeval finished;
  double elapsed;
  unsigned int id;
  struct _IO_FILE *fp = ((struct _IO_FILE *)NULL);
  unsigned int disp = (unsigned int)0x00000001;
  unsigned int flags = (unsigned int)0;
  signed int setmode = 0;
  unsigned int mode = (unsigned int)0;
  memset((void *)&h, 0, sizeof(struct client_handle) /*16ul*/ );
  memset((void *)&attrs, 0, sizeof(struct sftpattr) /*200ul*/ );
  memset((void *)&w, 0, sizeof(struct writer_data) /*184ul*/ );
  char **tmp_post_1;
  const char *tmp_post_2;
  unsigned long int return_value_strtoul_3;
  signed int return_value_error_4;
  if((signed int)*(*av) == 45)
  {
    const char *s;
    tmp_post_1 = av;
    av = av + 1l;
    s = *tmp_post_1;
    s = s + 1l;
    while(!(*s == 0))
    {
      tmp_post_2 = s;
      s = s + 1l;
      switch((signed int)*tmp_post_2)
      {
        case 80:
        {
          preserve = 1;
          break;
        }
        case 97:
        {
          disp = (unsigned int)0x00000003;
          flags = flags | (unsigned int)0x00000008;
          break;
        }
        case 65:
        {
          disp = (unsigned int)0x00000002;
          flags = flags | (unsigned int)0x00000008;
          break;
        }
        case 102:
        {
          flags = flags | (unsigned int)0x00000400;
          break;
        }
        case 116:
        {
          disp = (unsigned int)0x00000000;
          break;
        }
        case 101:
        {
          disp = (unsigned int)0x00000004;
          break;
        }
        case 100:
        {
          flags = flags | (unsigned int)0x00000800;
          break;
        }
        case 109:
        {
          setmode = 1;
          return_value_strtoul_3=strtoul(s, ((char ** restrict )NULL), 8);
          mode = (unsigned int)return_value_strtoul_3;
          s = "";
          break;
        }
        default:
        {
          return_value_error_4=error("unknown put option -%c'", s[(signed long int)-1]);
          return return_value_error_4;
        }
      }
    }
    ac = ac - 1;
  }

  char **tmp_post_5 = av;
  av = av + 1l;
  local = *tmp_post_5;
  ac = ac - 1;
  char **tmp_post_6;
  if(!(ac == 0))
  {
    tmp_post_6 = av;
    av = av + 1l;
    remote = *tmp_post_6;
    ac = ac - 1;
  }

  else
    remote=__xpg_basename(local);
  fd=open(local, 00);
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    char *return_value_strerror_8;
    return_value_strerror_8=strerror(*return_value___errno_location_7);
    error("cannot open %s: %s", local, return_value_strerror_8);
    goto error;
  }

  signed int return_value_fstat_11;
  return_value_fstat_11=fstat(fd, &sb);
  if(!(return_value_fstat_11 >= 0))
  {
    signed int *return_value___errno_location_9;
    return_value___errno_location_9=__errno_location();
    char *return_value_strerror_10;
    return_value_strerror_10=strerror(*return_value___errno_location_9);
    error("cannot stat %s: %s", local, return_value_strerror_10);
    goto error;
  }

  signed int return_value_sftp_open_12;
  void *return_value_sftp_alloc_15;
  signed int *return_value___errno_location_23;
  char *return_value_strerror_24;
  char *tmp_post_26;
  _Bool tmp_if_expr_29;
  if((61440u & sb.st_mode) == 16384u)
    error("%s is a directory", local);

  else
  {
    if((61440u & sb.st_mode) == 32768u)
    {
      w.total = (unsigned long int)sb.st_size;
      if(!((signed long int)w.total == sb.st_size))
      {
        error("%s is too large to upload via SFTP", local);
        goto error;
      }

    }

    else
      w.total = (unsigned long int)-1;
    if(!(preserve == 0))
    {
      sftp_stat_to_attrs(fakejob.a, &sb, &attrs, 0xFFFFFFFF, local);
      attrs.valid = attrs.valid & (unsigned int)~(0x00000001 | 0x00002000 | 0x00000002);
      attrs.valid = attrs.valid & attrmask;
      /* assertion !(attrs.valid & 0x00008000) */
      assert(!((attrs.valid & (unsigned int)0x00008000) != 0u));
      attrs.attrib_bits = attrs.attrib_bits & (unsigned int)~0x00000004;
    }

    if(!(setmode == 0))
    {
      attrs.valid = attrs.valid | (unsigned int)0x00000004;
      attrs.permissions = mode;
    }

    if(!(textmode == 0))
      flags = flags | (unsigned int)0x00000020;

    return_value_sftp_open_12=sftp_open(remote, (unsigned int)(0x00000002 | 0x00000100), disp | flags, &attrs, &h);
    if(return_value_sftp_open_12 == 0)
    {
      if(!(textmode == 0))
      {
        fp=fdopen(fd, "r");
        if(fp == ((struct _IO_FILE *)NULL))
        {
          signed int *return_value___errno_location_13;
          return_value___errno_location_13=__errno_location();
          char *return_value_strerror_14;
          return_value_strerror_14=strerror(*return_value___errno_location_13);
          error("error calling fdopen: %s", return_value_strerror_14);
          goto error;
        }

        fd = -1;
      }

      return_value_sftp_alloc_15=sftp_alloc(fakejob.a, (unsigned long int)nrequests * sizeof(struct outstanding_write) /*16ul*/ );
      w.reqs = (struct outstanding_write *)return_value_sftp_alloc_15;
      w.remote = remote;
      gettimeofday(&started, ((struct timezone *)NULL));
      do
      {
        signed int cmd_put__1__10__frc;
        cmd_put__1__10__frc=pthread_mutex_init(&w.m, ((const union anonymous_1 *)NULL));
        if(!(cmd_put__1__10__frc == 0))
        {
          char *return_value_strerror_16;
          return_value_strerror_16=strerror(cmd_put__1__10__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1847, (const void *)"pthread_mutex_init(&w.m, 0)", return_value_strerror_16);
          exit(1);
        }

      }
      while((_Bool)0);
      do
      {
        signed int cmd_put__1__11__frc;
        cmd_put__1__11__frc=pthread_cond_init(&w.c1, ((const union anonymous_1 *)NULL));
        if(!(cmd_put__1__11__frc == 0))
        {
          char *return_value_strerror_17;
          return_value_strerror_17=strerror(cmd_put__1__11__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1848, (const void *)"pthread_cond_init(&w.c1, 0)", return_value_strerror_17);
          exit(1);
        }

      }
      while((_Bool)0);
      do
      {
        signed int frc;
        frc=pthread_cond_init(&w.c2, ((const union anonymous_1 *)NULL));
        if(!(frc == 0))
        {
          char *return_value_strerror_18;
          return_value_strerror_18=strerror(frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1849, (const void *)"pthread_cond_init(&w.c2, 0)", return_value_strerror_18);
          exit(1);
        }

      }
      while((_Bool)0);
      do
      {
        signed int cmd_put__1__13__frc;
        cmd_put__1__13__frc=pthread_create(&tid, ((const union pthread_attr_t *)NULL), writer_thread, (void *)&w);
        if(!(cmd_put__1__13__frc == 0))
        {
          char *return_value_strerror_19;
          return_value_strerror_19=strerror(cmd_put__1__13__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1850, (const void *)"pthread_create(&tid, 0, writer_thread, &w)", return_value_strerror_19);
          exit(1);
        }

      }
      while((_Bool)0);
      do
      {
        signed int cmd_put__1__14__frc;
        cmd_put__1__14__frc=pthread_mutex_lock(&w.m);
        if(!(cmd_put__1__14__frc == 0))
        {
          char *return_value_strerror_20;
          return_value_strerror_20=strerror(cmd_put__1__14__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1851, (const void *)"pthread_mutex_lock(&w.m)", return_value_strerror_20);
          exit(1);
        }

      }
      while((_Bool)0);
      offset = (signed long int)0;
      while(w.failed == 0 && eof == 0 && failed == 0)
        if(w.outstanding >= nrequests)
          do
          {
            signed int cmd_put__1__15__1__1__frc;
            cmd_put__1__15__1__1__frc=pthread_cond_wait(&w.c2, &w.m);
            if(!(cmd_put__1__15__1__1__frc == 0))
            {
              char *return_value_strerror_21;
              return_value_strerror_21=strerror(cmd_put__1__15__1__1__frc);
              fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1856, (const void *)"pthread_cond_wait(&w.c2, &w.m)", return_value_strerror_21);
              exit(1);
            }

          }
          while((_Bool)0);

        else
        {
          do
          {
            signed int cmd_put__1__15__2__frc;
            cmd_put__1__15__2__frc=pthread_mutex_unlock(&w.m);
            if(!(cmd_put__1__15__2__frc == 0))
            {
              char *return_value_strerror_22;
              return_value_strerror_22=strerror(cmd_put__1__15__2__frc);
              fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1860, (const void *)"pthread_mutex_unlock(&w.m)", return_value_strerror_22);
              exit(1);
            }

          }
          while((_Bool)0);
          sftp_send_begin(&fakeworker);
          sftp_send_uint8(&fakeworker, 6);
          id=newid();
          sftp_send_uint32(&fakeworker, id);
          sftp_send_bytes(&fakeworker, (const void *)h.data, h.len);
          sftp_send_uint64(&fakeworker, (unsigned long int)offset);
          sftp_send_need(fakejob.worker, buffersize + (unsigned long int)4);
          if(!(textmode == 0))
          {
            char * const start = (char *)fakejob.worker->buffer + (signed long int)fakejob.worker->bufused + (signed long int)4;
            char *ptr = start;
            unsigned long int left = buffersize;
            unsigned long int newline_len;
            newline_len=strlen(newline);
            signed int c;
            while(left >= 1ul)
            {
              c=_IO_getc(fp);
              if(c == -1)
                break;

              if(c == 10)
              {
                if(left >= newline_len)
                {
                  strcpy(ptr, newline);
                  ptr = ptr + (signed long int)newline_len;
                  left = left - newline_len;
                }

                else
                {
                  signed int return_value_ungetc_25;
                  return_value_ungetc_25=ungetc(c, fp);
                  if(!(return_value_ungetc_25 >= 0))
                  {
                    return_value___errno_location_23=__errno_location();
                    return_value_strerror_24=strerror(*return_value___errno_location_23);
                    fatal("ungetc: %s", return_value_strerror_24);
                  }

                }
              }

              else
              {
                tmp_post_26 = ptr;
                ptr = ptr + 1l;
                *tmp_post_26 = (char)c;
                left = left - 1ul;
              }
            }
            signed int return_value_ferror_27;
            return_value_ferror_27=ferror(fp);
            if(!(return_value_ferror_27 == 0))
              n = (signed long int)-1;

            else
              n = ptr - start;
          }

          else
            n=read(fd, (void *)(fakejob.worker->buffer + (signed long int)fakejob.worker->bufused + (signed long int)4), buffersize);
          if(n >= 1l)
          {
            do
            {
              signed int cmd_put__1__15__5__1__frc;
              cmd_put__1__15__5__1__frc=pthread_mutex_lock(&w.m);
              if(!(cmd_put__1__15__5__1__frc == 0))
              {
                char *return_value_strerror_28;
                return_value_strerror_28=strerror(cmd_put__1__15__5__1__frc);
                fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1913, (const void *)"pthread_mutex_lock(&w.m)", return_value_strerror_28);
                exit(1);
              }

            }
            while((_Bool)0);
            i = 0;
            do
            {
              if(!(i >= nrequests))
                tmp_if_expr_29 = (w.reqs + (signed long int)i)->id != 0u ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_29 = (_Bool)0;
              if(!tmp_if_expr_29)
                break;

              i = i + 1;
            }
            while((_Bool)1);
            /* assertion i < nrequests */
            assert(i < nrequests);
            (w.reqs + (signed long int)i)->id = id;
            (w.reqs + (signed long int)i)->n = n;
            w.outstanding = w.outstanding + 1;
            do
            {
              signed int cmd_put__1__15__5__3__frc;
              cmd_put__1__15__5__3__frc=pthread_mutex_unlock(&w.m);
              if(!(cmd_put__1__15__5__3__frc == 0))
              {
                char *return_value_strerror_30;
                return_value_strerror_30=strerror(cmd_put__1__15__5__3__frc);
                fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1920, (const void *)"pthread_mutex_unlock(&w.m)", return_value_strerror_30);
                exit(1);
              }

            }
            while((_Bool)0);
            sftp_send_uint32(&fakeworker, (unsigned int)n);
            fakejob.worker->bufused = fakejob.worker->bufused + (unsigned long int)n;
            sftp_send_end(&fakeworker);
            offset = offset + n;
          }

          else
            if(n == 0l)
              eof = 1;

            else
            {
              signed int *return_value___errno_location_31;
              return_value___errno_location_31=__errno_location();
              char *return_value_strerror_32;
              return_value_strerror_32=strerror(*return_value___errno_location_31);
              error("error reading %s: %s", local, return_value_strerror_32);
              failed = 1;
            }
          do
          {
            signed int cmd_put__1__15__8__frc;
            cmd_put__1__15__8__frc=pthread_mutex_lock(&w.m);
            if(!(cmd_put__1__15__8__frc == 0))
            {
              char *return_value_strerror_33;
              return_value_strerror_33=strerror(cmd_put__1__15__8__frc);
              fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1934, (const void *)"pthread_mutex_lock(&w.m)", return_value_strerror_33);
              exit(1);
            }

          }
          while((_Bool)0);
          do
          {
            signed int cmd_put__1__15__9__frc;
            cmd_put__1__15__9__frc=pthread_cond_signal(&w.c1);
            if(!(cmd_put__1__15__9__frc == 0))
            {
              char *return_value_strerror_34;
              return_value_strerror_34=strerror(cmd_put__1__15__9__frc);
              fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1935, (const void *)"pthread_cond_signal(&w.c1)", return_value_strerror_34);
              exit(1);
            }

          }
          while((_Bool)0);
        }
      w.finished = 1;
      do
      {
        signed int cmd_put__1__16__frc;
        cmd_put__1__16__frc=pthread_cond_signal(&w.c1);
        if(!(cmd_put__1__16__frc == 0))
        {
          char *return_value_strerror_35;
          return_value_strerror_35=strerror(cmd_put__1__16__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1938, (const void *)"pthread_cond_signal(&w.c1)", return_value_strerror_35);
          exit(1);
        }

      }
      while((_Bool)0);
      do
      {
        signed int cmd_put__1__17__frc;
        cmd_put__1__17__frc=pthread_mutex_unlock(&w.m);
        if(!(cmd_put__1__17__frc == 0))
        {
          char *return_value_strerror_36;
          return_value_strerror_36=strerror(cmd_put__1__17__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1939, (const void *)"pthread_mutex_unlock(&w.m)", return_value_strerror_36);
          exit(1);
        }

      }
      while((_Bool)0);
      do
      {
        signed int cmd_put__1__18__frc;
        cmd_put__1__18__frc=pthread_join(tid, ((void **)NULL));
        if(!(cmd_put__1__18__frc == 0))
        {
          char *return_value_strerror_37;
          return_value_strerror_37=strerror(cmd_put__1__18__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1940, (const void *)"pthread_join(tid, 0)", return_value_strerror_37);
          exit(1);
        }

      }
      while((_Bool)0);
      /* assertion w.outstanding == 0 */
      assert(w.outstanding == 0);
      do
      {
        signed int cmd_put__1__19__frc;
        cmd_put__1__19__frc=pthread_mutex_destroy(&w.m);
        if(!(cmd_put__1__19__frc == 0))
        {
          char *return_value_strerror_38;
          return_value_strerror_38=strerror(cmd_put__1__19__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1942, (const void *)"pthread_mutex_destroy(&w.m)", return_value_strerror_38);
          exit(1);
        }

      }
      while((_Bool)0);
      do
      {
        signed int cmd_put__1__20__frc;
        cmd_put__1__20__frc=pthread_cond_destroy(&w.c1);
        if(!(cmd_put__1__20__frc == 0))
        {
          char *return_value_strerror_39;
          return_value_strerror_39=strerror(cmd_put__1__20__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1943, (const void *)"pthread_cond_destroy(&w.c1)", return_value_strerror_39);
          exit(1);
        }

      }
      while((_Bool)0);
      do
      {
        signed int cmd_put__1__21__frc;
        cmd_put__1__21__frc=pthread_cond_destroy(&w.c2);
        if(!(cmd_put__1__21__frc == 0))
        {
          char *return_value_strerror_40;
          return_value_strerror_40=strerror(cmd_put__1__21__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1944, (const void *)"pthread_cond_destroy(&w.c2)", return_value_strerror_40);
          exit(1);
        }

      }
      while((_Bool)0);
      if(w.failed == 0 && failed == 0)
      {
        gettimeofday(&finished, ((struct timezone *)NULL));
        if(!(progress_indicators == 0))
        {
          elapsed = (double)(finished.tv_sec - started.tv_sec) + (double)(finished.tv_usec - started.tv_usec) / 1000000.0;
          xprintf("%lu bytes in %.1f seconds", w.written, elapsed);
          if(elapsed > 0.1)
            xprintf(" %.0f bytes/sec", (double)w.written / elapsed);

          xprintf("\n");
        }

        if(fd >= 0)
        {
          close(fd);
          fd = -1;
        }

        if(!(fp == ((struct _IO_FILE *)NULL)))
        {
          fclose(fp);
          fp = ((struct _IO_FILE *)NULL);
        }

        if(!(preserve == 0))
        {
          signed int return_value_sftp_fsetstat_41;
          return_value_sftp_fsetstat_41=sftp_fsetstat(&h, &attrs);
          if(!(return_value_sftp_fsetstat_41 == 0))
            goto error;

        }

        sftp_close(&h);
        return 0;
      }

    }

  }

error:
  ;
  if(!(fp == ((struct _IO_FILE *)NULL)))
    fclose(fp);

  if(fd >= 0)
    close(fd);

  if(!(h.len == 0ul))
  {
    sftp_close(&h);
    sftp_remove(remote);
  }

  return -1;
}

// cmd_pwd
// file sftpclient.c line 882
static signed int cmd_pwd(signed int ac, char **av)
{
  char *return_value_remote_cwd_1;
  return_value_remote_cwd_1=remote_cwd();
  xprintf("%s\n", return_value_remote_cwd_1);
  return 0;
}

// cmd_quit
// file sftpclient.c line 916
static signed int cmd_quit(signed int ac, char **av)
{
  exit(0);
}

// cmd_readlink
// file sftpclient.c line 2127
static signed int cmd_readlink(signed int ac, char **av)
{
  char *r;
  r=sftp_readlink(av[(signed long int)0]);
  if(!(r == ((char *)NULL)))
  {
    xprintf("%s\n", r);
    return 0;
  }

  else
    return -1;
}

// cmd_realpath
// file sftpclient.c line 2138
static signed int cmd_realpath(signed int ac, char **av)
{
  char *r;
  r=sftp_realpath(av[(signed long int)0]);
  if(!(r == ((char *)NULL)))
  {
    xprintf("%s\n", r);
    return 0;
  }

  else
    return -1;
}

// cmd_realpath6
// file sftpclient.c line 2149
static signed int cmd_realpath6(signed int ac, char **av)
{
  signed int control_byte;
  char *resolved;
  struct sftpattr attrs;
  signed long int now;
  struct tm nowtime;
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(av[(signed long int)0], "no-check");
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  signed int return_value_error_1;
  if(return_value_strcmp_4 == 0)
    control_byte = 0x00000001;

  else
  {
    return_value_strcmp_3=strcmp(av[(signed long int)0], "stat-if");
    if(return_value_strcmp_3 == 0)
      control_byte = 0x00000002;

    else
    {
      return_value_strcmp_2=strcmp(av[(signed long int)0], "stat-always");
      if(return_value_strcmp_2 == 0)
        control_byte = 0x00000003;

      else
      {
        return_value_error_1=error("unknown control string '%s'", av[(signed long int)0]);
        return return_value_error_1;
      }
    }
  }
  resolved=sftp_realpath_v6(av[(signed long int)1], control_byte, av + (signed long int)2, &attrs);
  if(resolved == ((char *)NULL))
    return -1;

  else
  {
    if(!(attrs.valid == 0u))
    {
      attrs.name = resolved;
      time(&now);
      gmtime_r(&now, &nowtime);
      const char *return_value_sftp_format_attr_5;
      return_value_sftp_format_attr_5=sftp_format_attr(fakejob.a, &attrs, nowtime.tm_year, (unsigned long int)0);
      xprintf("%s\n", return_value_sftp_format_attr_5);
    }

    else
      xprintf("%s\n", resolved);
    return 0;
  }
}

// cmd_rm
// file sftpclient.c line 1259
static signed int cmd_rm(signed int ac, char **av)
{
  signed int return_value_sftp_remove_1;
  return_value_sftp_remove_1=sftp_remove(av[(signed long int)0]);
  return return_value_sftp_remove_1;
}

// cmd_rmdir
// file sftpclient.c line 1264
static signed int cmd_rmdir(signed int ac, char **av)
{
  signed int return_value_sftp_rmdir_1;
  return_value_sftp_rmdir_1=sftp_rmdir(av[(signed long int)0]);
  return return_value_sftp_rmdir_1;
}

// cmd_stat
// file sftpclient.c line 2316
static signed int cmd_stat(signed int ac, char **av)
{
  struct sftpattr attrs;
  signed long int now;
  struct tm nowtime;
  signed int return_value_sftp_stat_1;
  return_value_sftp_stat_1=sftp_stat(av[(signed long int)0], &attrs, (unsigned char)17);
  if(!(return_value_sftp_stat_1 == 0))
    return -1;

  else
  {
    time(&now);
    gmtime_r(&now, &nowtime);
    const char *return_value_sftp_format_attr_2;
    return_value_sftp_format_attr_2=sftp_format_attr(fakejob.a, &attrs, nowtime.tm_year, (unsigned long int)0);
    xprintf("%s\n", return_value_sftp_format_attr_2);
    return 0;
  }
}

// cmd_symlink
// file sftpclient.c line 1296
static signed int cmd_symlink(signed int ac, char **av)
{
  signed int return_value_sftp_link_1;
  return_value_sftp_link_1=sftp_link(av[(signed long int)0], av[(signed long int)1], 1);
  return return_value_sftp_link_1;
}

// cmd_text
// file sftpclient.c line 1996
static signed int cmd_text(signed int ac, char **av)
{
  signed int return_value_error_1;
  if(!(protocol->version >= 4))
  {
    return_value_error_1=error("text mode not supported in protocol version %d", protocol->version);
    return return_value_error_1;
  }

  else
  {
    textmode = 1;
    return 0;
  }
}

// cmd_truncate
// file sftpclient.c line 2342
static signed int cmd_truncate(signed int ac, char **av)
{
  struct sftpattr attrs;
  memset((void *)&attrs, 0, sizeof(struct sftpattr) /*200ul*/ );
  attrs.valid = (unsigned int)0x00000001;
  attrs.size=strtoull(av[(signed long int)0], ((char ** restrict )NULL), 0);
  signed int return_value_sftp_setstat_1;
  return_value_sftp_setstat_1=sftp_setstat(av[(signed long int)1], &attrs);
  return return_value_sftp_setstat_1;
}

// cmd_unsupported
// file sftpclient.c line 2104
static signed int cmd_unsupported(signed int ac, char **av)
{
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, (signed int)0xFFFFFFFF);
  sftp_send_uint32(&fakeworker, (unsigned int)0);
  sftp_send_end(&fakeworker);
  getresponse(101, (unsigned int)0, "_unsupported");
  status();
  return 0;
}

// cmd_version
// file sftpclient.c line 2011
static signed int cmd_version(signed int ac, char **av)
{
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  if(ac == 1)
  {
    unsigned int id;
    id=newid();
    sftp_send_begin(&fakeworker);
    sftp_send_uint8(&fakeworker, 200);
    sftp_send_uint32(&fakeworker, id);
    sftp_send_string(&fakeworker, "version-select");
    sftp_send_path(&fakejob, &fakeworker, av[(signed long int)0]);
    sftp_send_end(&fakeworker);
    getresponse(101, id, "version-select");
    signed int return_value_status_1;
    return_value_status_1=status();
    if(!(return_value_status_1 == 0))
      return -1;

    signed int return_value_strcmp_5;
    return_value_strcmp_5=strcmp(av[(signed long int)0], "3");
    if(return_value_strcmp_5 == 0)
      protocol = &sftp_v3;

    else
    {
      return_value_strcmp_4=strcmp(av[(signed long int)0], "4");
      if(return_value_strcmp_4 == 0)
        protocol = &sftp_v4;

      else
      {
        return_value_strcmp_3=strcmp(av[(signed long int)0], "5");
        if(return_value_strcmp_3 == 0)
          protocol = &sftp_v5;

        else
        {
          return_value_strcmp_2=strcmp(av[(signed long int)0], "6");
          if(return_value_strcmp_2 == 0)
            protocol = &sftp_v6;

          else
            fatal("unknown protocol %s", av[(signed long int)0]);
        }
      }
    }
    return 0;
  }

  else
  {
    xprintf("Protocol version: %d\n", protocol->version);
    if(!(servername == ((char *)NULL)))
      xprintf("Server vendor:    %s\nServer name:      %s\nServer version:   %s\nServer build:     %lu\n", vendorname, servername, serverversion, serverbuild);

    if(!(serverversions == ((char *)NULL)))
      xprintf("Server supports:  %s\n", serverversions);

    return 0;
  }
}

// do_read
// file utils.h line 35
signed int do_read(signed int fd, void *buffer, unsigned long int size)
{
  unsigned long int sofar = (unsigned long int)0;
  signed long int n;
  char *ptr = (char *)buffer;
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  while(!(sofar >= size))
  {
    n=read(fd, (void *)(ptr + (signed long int)sofar), size - sofar);
    if(n >= 1l)
      sofar = sofar + (unsigned long int)n;

    else
      if(n == 0l)
        return -1;

      else
      {
        return_value___errno_location_1=__errno_location();
        return_value_strerror_2=strerror(*return_value___errno_location_1);
        fatal("read error: %s", return_value_strerror_2);
      }
  }
  return 0;
}

// do_sftp_set_status
// file stat.c line 333
static unsigned int do_sftp_set_status(struct allocator *a, const void *what, struct sftpattr *attrsp, struct sftp_set_status_callbacks *cb, const char **whyp)
{
  struct timeval times[2l];
  struct stat current;
  struct sftpattr attrs = *attrsp;
  const char *why;
  if(whyp == ((const char **)NULL))
    whyp = &why;

  *whyp = ((const char *)NULL);
  if((1025u & attrs.valid) == 1025u && !(attrs.allocation_size >= attrs.size))
  {
    *whyp = "size exceeds allocation-size";
    return (unsigned int)23;
  }

  else
    if(!((10240u & attrs.valid) == 0u))
      return (unsigned int)23;

    else
      if(!((1455u & attrs.valid) == attrs.valid))
      {
        *whyp = "unsupported flags";
        return (unsigned int)8;
      }

      else
      {
        if(!((1u & attrs.valid) == 0u))
        {
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("...truncate to %lu", attrs.size);

          while((_Bool)0);
          signed int return_value;
          return_value=cb->do_truncate(what, (signed long int)attrs.size);
          if(!(return_value >= 0))
          {
            *whyp = "truncate";
            return (unsigned int)-2;
          }

        }

        sftp_normalize_ownergroup(a, &attrs);
        if(!((2u & attrs.valid) == 0u))
        {
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("...chown to %d/%d", attrs.uid, attrs.gid);

          while((_Bool)0);
          signed int return_value_1;
          return_value_1=cb->do_chown(what, attrs.uid, attrs.gid);
          if(!(return_value_1 >= 0))
          {
            *whyp = "chown";
            return (unsigned int)-2;
          }

        }

        if(!((4u & attrs.valid) == 0u))
        {
          const unsigned int mode = attrs.permissions & (unsigned int)07777;
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("...chmod to %#o", (unsigned int)mode);

          while((_Bool)0);
          signed int return_value_2;
          return_value_2=cb->do_chmod(what, mode);
          if(!(return_value_2 >= 0))
          {
            *whyp = "chmod";
            return (unsigned int)-2;
          }

        }

        if(!((40u & attrs.valid) == 0u))
        {
          signed int return_value_3;
          return_value_3=cb->do_stat(what, &current);
          if(!(return_value_3 >= 0))
          {
            if(!(sftp_debugging == 0))
              sftp_debug_printf("cannot stat");

            *whyp = "stat";
            return (unsigned int)-2;
          }

          memset((void *)times, 0, sizeof(struct timeval [2l]) /*32ul*/ );
          times[(signed long int)0].tv_sec = (attrs.valid & (unsigned int)0x00000008) != 0u ? (signed long int)attrs.atime.seconds : current.st_atim.tv_sec;
          times[(signed long int)1].tv_sec = (attrs.valid & (unsigned int)0x00000020) != 0u ? (signed long int)attrs.mtime.seconds : current.st_mtim.tv_sec;
          if(!(sftp_debugging == 0))
            sftp_debug_printf("...utimes to atime %lu.%06lu mtime %lu.%06lu", (unsigned long int)times[(signed long int)0].tv_sec, (unsigned long int)times[(signed long int)0].tv_usec, (unsigned long int)times[(signed long int)1].tv_sec, (unsigned long int)times[(signed long int)1].tv_usec);

          signed int return_value_4;
          return_value_4=cb->do_utimes(what, times);
          if(!(return_value_4 >= 0))
          {
            *whyp = "utimes";
            return (unsigned int)-2;
          }

        }

        return (unsigned int)0;
      }
}

// error
// file sftpclient.c line 181
static signed int error(const char *fmt, ...)
{
  void **ap;
  if(!(inputpath == ((const char *)NULL)))
    fprintf(stderr, "%s:%d ", inputpath, inputline);

  ap = (void **)&fmt;
  vfprintf(stderr, fmt, ap);
  ap = ((void **)NULL);
  fputc(10, stderr);
  fflush(stderr);
  return -1;
}

// fatal
// file utils.h line 185
void fatal(const char *msg, ...)
{
  void **ap = (void **)&msg;
  if(!(log_syslog == 0))
    vsyslog(3, msg, ap);

  else
  {
    fprintf(stderr, "FATAL: ");
    vfprintf(stderr, msg, ap);
    fputc(10, stderr);
  }
  ap = ((void **)NULL);
  exitfn(-1);
}

// fd_chmod
// file stat.c line 517
static signed int fd_chmod(const void *what, unsigned int mode)
{
  signed int return_value_fchmod_1;
  return_value_fchmod_1=fchmod(*((const signed int *)what), mode);
  return return_value_fchmod_1;
}

// fd_chown
// file stat.c line 508
static signed int fd_chown(const void *what, unsigned int uid, unsigned int gid)
{
  signed int return_value_fchown_1;
  return_value_fchown_1=fchown(*((const signed int *)what), uid, gid);
  return return_value_fchown_1;
}

// fd_stat
// file stat.c line 526
static signed int fd_stat(const void *what, struct stat *sb)
{
  signed int return_value_fstat_1;
  return_value_fstat_1=fstat(*((const signed int *)what), sb);
  return return_value_fstat_1;
}

// fd_truncate
// file stat.c line 498
static signed int fd_truncate(const void *what, signed long int size)
{
  signed int return_value_ftruncate_1;
  return_value_ftruncate_1=ftruncate(*((const signed int *)what), size);
  return return_value_ftruncate_1;
}

// fd_utimes
// file stat.c line 535
static signed int fd_utimes(const void *what, struct timeval *tv)
{
  signed int return_value_futimes_1;
  return_value_futimes_1=futimes(*((const signed int *)what), tv);
  return return_value_futimes_1;
}

// find_free_handle
// file handle.c line 63
static void find_free_handle(struct handleid *id, signed int type)
{
  unsigned long int n = (unsigned long int)0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(n >= nhandles))
      tmp_if_expr_1 = (handles + (signed long int)n)->tag != 0u ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    n = n + 1ul;
  }
  while((_Bool)1);
  if(n == nhandles && !(nhandles >= 128ul))
  {
    nhandles = nhandles != 0ul ? (unsigned long int)2 * nhandles : (unsigned long int)16;
    /* assertion nhandles != 0 */
    assert(nhandles != (unsigned long int)0);
    void *return_value_xrecalloc_2;
    return_value_xrecalloc_2=xrecalloc((void *)handles, nhandles, sizeof(struct handle) /*32ul*/ );
    handles = (struct handle *)return_value_xrecalloc_2;
    memset((void *)(handles + (signed long int)n), 0, (nhandles - n) * sizeof(struct handle) /*32ul*/ );
  }

  for( ; sequence == 0u; sequence = sequence + 1u)
    ;
  unsigned int tmp_post_3 = sequence;
  sequence = sequence + 1u;
  (handles + (signed long int)n)->tag = tmp_post_3;
  (handles + (signed long int)n)->type = type;
  id->id = (unsigned int)n;
  id->tag = (handles + (signed long int)n)->tag;
}

// forked
// file utils.c line 122
void forked(void)
{
  exitfn = _exit;
}

// get16
// file putword.h line 85
static inline unsigned short int get16(const void *where)
{
  unsigned short int r;
  asm("movw %[WHERE],%[R]\t\nxchg %h[R],%b[R]" : "=Q"(r) : "m"(*((const unsigned short int *)where)) : );
  return r;
}

// get32
// file putword.h line 102
static inline unsigned int get32(const void *where)
{
  unsigned int r;
  asm("movl %[WHERE],%[R]\n\tbswapl %[R]" : "=r"(r) : "m"(*((const unsigned int *)where)) : );
  return r;
}

// get64
// file putword.h line 119
static inline unsigned long int get64(const void *where)
{
  unsigned long int r;
  asm("movq %[WHERE],%[R]\n\tbswapq %[R]" : "=r"(r) : "m"(*((const unsigned long int *)where)) : );
  return r;
}

// getresponse
// file sftpclient.c line 211
static unsigned char getresponse(signed int expected, unsigned int expected_id, const char *what)
{
  unsigned int len;
  unsigned char type;
  signed int return_value_do_read_1;
  return_value_do_read_1=do_read(sftpin, (void *)&len, sizeof(unsigned int) /*4ul*/ );
  if(!(return_value_do_read_1 == 0))
    fatal("unexpected EOF from server while reading %s response length", what);

  free((void *)fakejob.data);
  unsigned int return_value_ntohl_2;
  return_value_ntohl_2=ntohl(len);
  fakejob.len = (unsigned long int)return_value_ntohl_2;
  void *return_value_sftp__xmalloc_3;
  return_value_sftp__xmalloc_3=sftp__xmalloc(fakejob.len);
  fakejob.data = (unsigned char *)return_value_sftp__xmalloc_3;
  signed int return_value_do_read_4;
  return_value_do_read_4=do_read(sftpin, (void *)fakejob.data, fakejob.len);
  if(!(return_value_do_read_4 == 0))
    fatal("unexpected EOF from server while reading %s response data", what);

  if(!(sftp_debugging == 0))
  {
    do
      if(!(sftp_debugging == 0))
        sftp_debug_printf("%s response:", what);

    while((_Bool)0);
    sftp_debug_hexdump((const void *)fakejob.data, fakejob.len);
  }

  fakejob.left = fakejob.len;
  fakejob.ptr = fakejob.data;
  do
  {
    unsigned int getresponse__1__2__rc;
    getresponse__1__2__rc=sftp_parse_uint8(&fakejob, &type);
    if(!(getresponse__1__2__rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 229, (const void *)"sftp_parse_uint8(&fakejob, &type)", getresponse__1__2__rc);

      while((_Bool)0);
      fatal("error parsing response from server");
    }

  }
  while((_Bool)0);
  if(!((signed int)type == 2))
  {
    do
    {
      unsigned int rc;
      rc=sftp_parse_uint32(&fakejob, &fakejob.id);
      if(!(rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 231, (const void *)"sftp_parse_uint32(&fakejob, &fakejob.id)", rc);

        while((_Bool)0);
        fatal("error parsing response from server");
      }

    }
    while((_Bool)0);
    if(!(fakejob.id == expected_id) && !(expected_id == 0u))
      fatal("wrong ID in response to %s (want %u got %u type was %d)", what, expected_id, fakejob.id, type);

  }

  if(expected >= 1 && !((signed int)type == expected))
  {
    if((signed int)type == 101)
      status();

    else
      fatal("expected %s response %d got %d", what, expected, type);
  }

  return type;
}

// handles_equal
// file serialize.c line 101
static inline signed int handles_equal(struct handleid *h1, struct handleid *h2)
{
  _Bool tmp_if_expr_1;
  if(h1->id == h2->id)
    tmp_if_expr_1 = h1->tag == h2->tag ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  return (signed int)tmp_if_expr_1;
}

// help
// file sftpclient.c line 147
static void help(void)
{
  xprintf("Usage:\n  sftpclient [OPTIONS] [USER@]HOST\n\nQuick and dirty SFTP client\n\n");
  xprintf("Options:\n  --help, -h               Display usage message\n  --version, -V            Display version number\n  -r, --dropbear           Use dbclient instead of ssh\n  -B, --buffer BYTES       Select buffer size (default 8192)\n  -b, --batch PATH         Read batch file\n  -P, --program PATH       Execute program as SFTP server\n");
  xprintf("  -R, --requests COUNT     Maximum outstanding requests (default 8)\n  -s, --subsystem NAME     Remote subsystem name\n  -S, --sftp-version VER   Protocol version to request (default 3)\n  --quirk-openssh          Server gets SSH_FXP_SYMLINK backwards\n");
  xprintf("Options passed to SSH:\n  -1, -2                   Select protocol version\n  -C                       Enable compression\n  -F PATH                  Use alternative  config file\n  -o OPTION                Pass option to client\n  -v                       Raise logging level\n");
  exit(0);
}

// input
// file sftpclient.c line 2700
static char * input(const char *prompt, struct _IO_FILE *fp)
{
  char buffer[4096l];
  const unsigned short int **return_value___ctype_b_loc_1;
  if(!(prompt == ((const char *)NULL)))
  {
    char *s;
    s=readline(prompt);
    if(!(s == ((char *)NULL)))
    {
      const char *t = s;
      do
      {
        return_value___ctype_b_loc_1=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)*t]) == 0)
          break;

        t = t + 1l;
      }
      while((_Bool)1);
      if(!(*t == 0))
        add_history(s);

    }

    return s;
  }

  char *return_value_fgets_2;
  return_value_fgets_2=fgets(buffer, (signed int)sizeof(char [4096l]) /*4096ul*/ , fp);
  if(return_value_fgets_2 == ((char *)NULL))
    return ((char *)NULL);

  else
  {
    char *return_value_xstrdup_3;
    return_value_xstrdup_3=xstrdup(buffer);
    return return_value_xstrdup_3;
  }
}

// main
// file sftpclient.c line 2787
signed int main(signed int argc, char **argv)
{
  signed int n;
  struct addrinfo hints;
  const char *host = ((const char *)NULL);
  const char *port = ((const char *)NULL);
  signed int dropbear = 0;
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_flags = 0;
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  setlocale(6, "");
  newline=xstrdup("\r\n");
  struct winsize ws;
  const char *e;
  e=getenv("COLUMNS");
  unsigned long int return_value_strtoul_1;
  signed int return_value_ioctl_2;
  if(!(e == ((const char *)NULL)))
  {
    return_value_strtoul_1=strtoul(e, ((char ** restrict )NULL), 10);
    terminal_width = (signed int)(unsigned long int)return_value_strtoul_1;
  }

  else
  {
    return_value_ioctl_2=ioctl(1, (unsigned long int)0x5413, &ws);
    if(return_value_ioctl_2 >= 0)
      terminal_width = (signed int)ws.ws_col;

    else
      terminal_width = 80;
  }
  signed int return_value_atoi_3;
  signed int tmp_post_4;
  do
  {
    n=getopt_long(argc, argv, "hVrB:b:P:R:s:S:12CF:o:vdH:p:46D:", options, ((signed int *)NULL));
    if(!(n >= 0))
      break;

    switch(n)
    {
      case 104:
        help();
      case 86:
        version();
      case 114:
      {
        dropbear = dropbear + 1;
        break;
      }
      case 66:
      {
        return_value_atoi_3=atoi(optarg);
        buffersize = (unsigned long int)return_value_atoi_3;
        break;
      }
      case 98:
      {
        batchfile = optarg;
        stoponerror = 1;
        progress_indicators = 0;
        break;
      }
      case 80:
      {
        program = optarg;
        break;
      }
      case 82:
      {
        nrequests=atoi(optarg);
        break;
      }
      case 115:
      {
        subsystem = optarg;
        break;
      }
      case 83:
      {
        sftpversion=atoi(optarg);
        break;
      }
      case 49:
      {
        sshversion = 1;
        break;
      }
      case 50:
      {
        sshversion = 2;
        break;
      }
      case 67:
      {
        compress = 1;
        break;
      }
      case 70:
      {
        sshconf = optarg;
        break;
      }
      case 111:
      {
        tmp_post_4 = nsshoptions;
        nsshoptions = nsshoptions + 1;
        sshoptions[(signed long int)tmp_post_4] = optarg;
        break;
      }
      case 118:
      {
        sshverbose = sshverbose + 1;
        break;
      }
      case 100:
      {
        sftp_debugging = 1;
        break;
      }
      case 68:
      {
        sftp_debugging = 1;
        sftp_debugpath = optarg;
        break;
      }
      case 256:
      {
        quirk_reverse_symlink = 1;
        break;
      }
      case 257:
      {
        stoponerror = 1;
        break;
      }
      case 258:
      {
        stoponerror = 0;
        break;
      }
      case 259:
      {
        progress_indicators = 1;
        break;
      }
      case 260:
      {
        progress_indicators = 0;
        break;
      }
      case 261:
      {
        echo = 1;
        break;
      }
      case 262:
      {
        signal(13, (void (*)(signed int))0);
        break;
      }
      case 263:
      {
        sftpversion=atoi(optarg);
        forceversion = 1;
        break;
      }
      case 72:
      {
        host = optarg;
        break;
      }
      case 112:
      {
        port = optarg;
        break;
      }
      case 52:
      {
        hints.ai_family = 2;
        break;
      }
      case 54:
      {
        hints.ai_family = 10;
        break;
      }
      default:
        exit(1);
    }
  }
  while((_Bool)1);
  if(!(nrequests >= 1))
    nrequests = 1;

  if(nrequests >= 129)
    nrequests = 128;

  if(!(buffersize >= 64ul))
    buffersize = (unsigned long int)64;

  if(buffersize >= 1048577ul)
    buffersize = (unsigned long int)1048576;

  if(forceversion == 0 && (sftpversion >= 7 || !(sftpversion >= 3)))
    fatal("unknown SFTP version %d", sftpversion);

  const char *return_value_gai_strerror_5;
  signed int *return_value___errno_location_6;
  char *return_value_strerror_7;
  signed int *return_value___errno_location_8;
  char *return_value_strerror_9;
  signed int tmp_post_11;
  signed int tmp_post_12;
  signed int tmp_post_13;
  signed int tmp_post_14;
  signed int tmp_post_15;
  signed int tmp_post_16;
  signed int tmp_post_17;
  signed int tmp_post_18;
  signed int tmp_post_19;
  signed int tmp_post_20;
  signed int tmp_post_21;
  signed int tmp_post_22;
  signed int tmp_post_23;
  signed int tmp_post_24;
  signed int tmp_post_25;
  signed int tmp_post_26;
  signed int tmp_post_27;
  if(!(host == ((const char *)NULL)) || !(port == ((const char *)NULL)))
  {
    struct addrinfo *res;
    signed int rc;
    signed int fd;
    if(host == ((const char *)NULL) || port == ((const char *)NULL) || !(program == ((const char *)NULL)) || !(subsystem == ((const char *)NULL)))
      fatal("inconsistent options");

    rc=getaddrinfo(host, port, &hints, &res);
    if(!(rc == 0))
    {
      return_value_gai_strerror_5=gai_strerror(rc);
      fatal("error resolving host %s port %s: %s", host, port, return_value_gai_strerror_5);
    }

    fd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if(!(fd >= 0))
    {
      return_value___errno_location_6=__errno_location();
      return_value_strerror_7=strerror(*return_value___errno_location_6);
      fatal("error calling socket: %s", return_value_strerror_7);
    }

    signed int return_value_connect_10;
    return_value_connect_10=connect(fd, res->ai_addr, res->ai_addrlen);
    if(!(return_value_connect_10 >= 0))
    {
      return_value___errno_location_8=__errno_location();
      return_value_strerror_9=strerror(*return_value___errno_location_8);
      fatal("error connecting to host %s port %s: %s", host, port, return_value_strerror_9);
    }

    sftpout = fd;
    sftpin = sftpout;
  }

  else
  {
    const char *cmdline[2048l];
    signed int ncmdline = 0;
    signed int ip[2l];
    signed int op[2l];
    signed int pid;
    if(!(program == ((const char *)NULL)))
    {
      tmp_post_11 = ncmdline;
      ncmdline = ncmdline + 1;
      cmdline[(signed long int)tmp_post_11] = program;
    }

    else
    {
      if(optind >= argc)
        fatal("missing USER@HOST argument");

      if(!(dropbear == 0))
      {
        tmp_post_12 = ncmdline;
        ncmdline = ncmdline + 1;
        cmdline[(signed long int)tmp_post_12] = "dbclient";
      }

      else
      {
        tmp_post_13 = ncmdline;
        ncmdline = ncmdline + 1;
        cmdline[(signed long int)tmp_post_13] = "ssh";
        if(sshversion == 1)
        {
          tmp_post_14 = ncmdline;
          ncmdline = ncmdline + 1;
          cmdline[(signed long int)tmp_post_14] = "-1";
        }

        if(sshversion == 2)
        {
          tmp_post_15 = ncmdline;
          ncmdline = ncmdline + 1;
          cmdline[(signed long int)tmp_post_15] = "-2";
        }

        if(!(compress == 0))
        {
          tmp_post_16 = ncmdline;
          ncmdline = ncmdline + 1;
          cmdline[(signed long int)tmp_post_16] = "-C";
        }

        if(!(sshconf == ((const char *)NULL)))
        {
          tmp_post_17 = ncmdline;
          ncmdline = ncmdline + 1;
          cmdline[(signed long int)tmp_post_17] = "-F";
          tmp_post_18 = ncmdline;
          ncmdline = ncmdline + 1;
          cmdline[(signed long int)tmp_post_18] = sshconf;
        }

        n = 0;
        for( ; !(n >= nsshoptions); n = n + 1)
        {
          tmp_post_19 = ncmdline;
          ncmdline = ncmdline + 1;
          cmdline[(signed long int)tmp_post_19] = "-o";
          tmp_post_20 = ncmdline;
          ncmdline = ncmdline + 1;
          tmp_post_21 = n;
          n = n + 1;
          cmdline[(signed long int)tmp_post_20] = sshoptions[(signed long int)tmp_post_21];
        }
        do
        {
          tmp_post_22 = sshverbose;
          sshverbose = sshverbose - 1;
          if(!(tmp_post_22 >= 1))
            break;

          tmp_post_23 = ncmdline;
          ncmdline = ncmdline + 1;
          cmdline[(signed long int)tmp_post_23] = "-v";
        }
        while((_Bool)1);
      }
      tmp_post_24 = ncmdline;
      ncmdline = ncmdline + 1;
      cmdline[(signed long int)tmp_post_24] = "-s";
      tmp_post_25 = ncmdline;
      ncmdline = ncmdline + 1;
      tmp_post_26 = optind;
      optind = optind + 1;
      cmdline[(signed long int)tmp_post_25] = argv[(signed long int)tmp_post_26];
      tmp_post_27 = ncmdline;
      ncmdline = ncmdline + 1;
      cmdline[(signed long int)tmp_post_27] = subsystem != ((const char *)NULL) ? subsystem : "sftp";
    }
    cmdline[(signed long int)ncmdline] = ((const char *)NULL);
    xpipe(ip);
    xpipe(op);
    pid=xfork();
    if(pid == 0)
    {
      xclose(ip[(signed long int)0]);
      xclose(op[(signed long int)1]);
      xdup2(ip[(signed long int)1], 1);
      xdup2(op[(signed long int)0], 0);
      execvp(cmdline[(signed long int)0], (char * const *)(void *)cmdline);
      signed int *return_value___errno_location_28;
      return_value___errno_location_28=__errno_location();
      char *return_value_strerror_29;
      return_value_strerror_29=strerror(*return_value___errno_location_28);
      fatal("executing %s: %s", cmdline[(signed long int)0], return_value_strerror_29);
    }

    xclose(ip[(signed long int)1]);
    xclose(op[(signed long int)0]);
    sftpin = ip[(signed long int)0];
    sftpout = op[(signed long int)1];
  }
  fakejob.a=sftp_alloc_init(&allocator);
  fakejob.worker = &fakeworker;
  char *return_value_nl_langinfo_32;
  return_value_nl_langinfo_32=nl_langinfo(14);
  fakeworker.utf8_to_local=iconv_open(return_value_nl_langinfo_32, "UTF-8");
  signed int *return_value___errno_location_30;
  char *return_value_strerror_31;
  if(fakeworker.utf8_to_local == (void *)-1)
  {
    return_value___errno_location_30=__errno_location();
    return_value_strerror_31=strerror(*return_value___errno_location_30);
    fatal("error calling iconv_open: %s", return_value_strerror_31);
  }

  char *return_value_nl_langinfo_35;
  return_value_nl_langinfo_35=nl_langinfo(14);
  fakeworker.local_to_utf8=iconv_open("UTF-8", return_value_nl_langinfo_35);
  signed int *return_value___errno_location_33;
  char *return_value_strerror_34;
  if(fakeworker.local_to_utf8 == (void *)-1)
  {
    return_value___errno_location_33=__errno_location();
    return_value_strerror_34=strerror(*return_value___errno_location_33);
    fatal("error calling iconv_open: %s", return_value_strerror_34);
  }

  signed int return_value_sftp_init_36;
  return_value_sftp_init_36=sftp_init();
  signed int *return_value___errno_location_37;
  char *return_value_strerror_38;
  if(!(return_value_sftp_init_36 == 0))
    return 1;

  else
  {
    if(!(batchfile == ((const char *)NULL)))
    {
      struct _IO_FILE *fp;
      inputpath = batchfile;
      fp=fopen(batchfile, "r");
      if(fp == ((struct _IO_FILE *)NULL))
      {
        return_value___errno_location_37=__errno_location();
        return_value_strerror_38=strerror(*return_value___errno_location_37);
        fatal("error opening %s: %s", batchfile, return_value_strerror_38);
      }

      process(((const char *)NULL), fp);
    }

    else
    {
      inputpath = "stdin";
      process("sftp> ", stdin);
    }
    return 0;
  }
}

// makeabspath
// file sftpclient.c line 300
static const char * makeabspath(const char *name)
{
  char *resolved;
  /* assertion cwd != 0 */
  assert(cwd != ((char *)NULL));
  if((signed int)*name == 47)
    return name;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(cwd);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(name);
    void *return_value_sftp_alloc_3;
    return_value_sftp_alloc_3=sftp_alloc(fakejob.a, return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)2);
    resolved = (char *)return_value_sftp_alloc_3;
    sprintf(resolved, "%s/%s", cwd, name);
    return resolved;
  }
}

// name_chmod
// file stat.c line 455
static signed int name_chmod(const void *what, unsigned int mode)
{
  signed int return_value_chmod_1;
  return_value_chmod_1=chmod((const char *)what, mode);
  return return_value_chmod_1;
}

// name_chown
// file stat.c line 446
static signed int name_chown(const void *what, unsigned int uid, unsigned int gid)
{
  signed int return_value_chown_1;
  return_value_chown_1=chown((const char *)what, uid, gid);
  return return_value_chown_1;
}

// name_lstat
// file stat.c line 464
static signed int name_lstat(const void *what, struct stat *sb)
{
  signed int return_value_lstat_1;
  return_value_lstat_1=lstat((const char *)what, sb);
  return return_value_lstat_1;
}

// name_truncate
// file stat.c line 436
static signed int name_truncate(const void *what, signed long int size)
{
  signed int return_value_truncate_1;
  return_value_truncate_1=truncate((const char *)what, size);
  return return_value_truncate_1;
}

// name_utimes
// file stat.c line 473
static signed int name_utimes(const void *what, struct timeval *tv)
{
  signed int return_value_utimes_1;
  return_value_utimes_1=utimes((const char *)what, tv);
  return return_value_utimes_1;
}

// newid
// file sftpclient.c line 281
static unsigned int newid(void)
{
  static unsigned int latestid;
  do
    latestid = latestid + 1u;
  while(latestid == 0u);
  return latestid;
}

// opendebug
// file debug.c line 42
static void opendebug(void)
{
  /* assertion sftp_debugging */
  assert(sftp_debugging != 0);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(debugfp == ((struct _IO_FILE *)NULL))
  {
    if(!(sftp_debugpath == ((const char *)NULL)))
    {
      signed int fd;
      fd=open(sftp_debugpath, 01 | 0100 | 01000, 0600);
      if(fd >= 0)
        debugfp=fdopen(fd, "w");

      else
      {
        return_value___errno_location_1=__errno_location();
        return_value_strerror_2=strerror(*return_value___errno_location_1);
        fprintf(stderr, "%s: %s\n", sftp_debugpath, return_value_strerror_2);
      }
    }

    if(debugfp == ((struct _IO_FILE *)NULL))
      debugfp = stderr;

  }

}

// process
// file sftpclient.c line 2728
static void process(const char *prompt, struct _IO_FILE *fp)
{
  char *line;
  signed int ac;
  signed int n;
  char *avbuf[256l];
  char **av;
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  char *return_value_getenv_4;
  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_5;
  _Bool tmp_if_expr_7;
  signed int return_value;
  signed int *return_value___errno_location_8;
  char *return_value_strerror_9;
  do
  {
    line=input(prompt, fp);
    if(line == ((char *)NULL))
      break;

    inputline = inputline + 1;
    if(!((signed int)*line == 35))
    {
      if(!(echo == 0))
      {
        xprintf("%s", line);
        signed int return_value_fflush_3;
        return_value_fflush_3=fflush(stdout);
        if(!(return_value_fflush_3 >= 0))
        {
          return_value___errno_location_1=__errno_location();
          return_value_strerror_2=strerror(*return_value___errno_location_1);
          fatal("error calling fflush: %s", return_value_strerror_2);
        }

      }

      if((signed int)*line == 33)
      {
        if(!((signed int)line[1l] == 10))
          system(line + (signed long int)1);

        else
        {
          return_value_getenv_4=getenv("SHELL");
          system(return_value_getenv_4);
        }
        goto next;
      }

      av = avbuf;
      ac=split(line, av);
      if(!(ac >= 0))
      {
        if(!(stoponerror == 0))
          fatal("stopping on error");

      }

      else
        if(!(ac == 0))
        {
          n = 0;
          do
          {
            if(!(commands[(signed long int)n].name == ((const char *)NULL)))
            {
              return_value_strcmp_5=strcmp(av[(signed long int)0], commands[(signed long int)n].name);
              tmp_if_expr_6 = return_value_strcmp_5 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_6 = (_Bool)0;
            if(!tmp_if_expr_6)
              break;

            n = n + 1;
          }
          while((_Bool)1);
          if(commands[(signed long int)n].name == ((const char *)NULL))
          {
            error("unknown command: '%s'", av[(signed long int)0]);
            if(!(stoponerror == 0))
              fatal("stopping on error");

          }

          else
          {
            av = av + 1l;
            ac = ac - 1;
            if(!(ac >= commands[(signed long int)n].minargs))
              tmp_if_expr_7 = (_Bool)1;

            else
              tmp_if_expr_7 = ac > commands[(signed long int)n].maxargs ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_7)
            {
              error("wrong number of arguments (got %d, want %d-%d)", ac, commands[(signed long int)n].minargs, commands[(signed long int)n].maxargs);
              if(!(stoponerror == 0))
                fatal("stopping on error");

            }

            else
            {
              return_value=commands[(signed long int)n].handler(ac, av);
              if(!(return_value == 0))
              {
                if(!(stoponerror == 0))
                  fatal("stopping on error");

              }

            }
          }
        }

    }


  next:
    ;
    signed int return_value_fflush_10;
    return_value_fflush_10=fflush(stdout);
    if(!(return_value_fflush_10 >= 0))
    {
      return_value___errno_location_8=__errno_location();
      return_value_strerror_9=strerror(*return_value___errno_location_8);
      fatal("error calling fflush: %s", return_value_strerror_9);
    }

    sftp_alloc_destroy(fakejob.a);
    free((void *)line);
  }
  while((_Bool)1);
  signed int return_value_ferror_13;
  return_value_ferror_13=ferror(fp);
  signed int *return_value___errno_location_11;
  char *return_value_strerror_12;
  if(!(return_value_ferror_13 == 0))
  {
    return_value___errno_location_11=__errno_location();
    return_value_strerror_12=strerror(*return_value___errno_location_11);
    fatal("error reading %s: %s", inputpath, return_value_strerror_12);
  }

  if(!(prompt == ((const char *)NULL)))
    xprintf("\n");

}

// process_path
// file realpath.c line 75
static char * process_path(struct allocator *a, char *result, unsigned long int *nresultp, const char *path, unsigned int flags)
{
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("process_path path='%s' result='%s'", path, result);

  while((_Bool)0);
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  while(!(*path == 0))
    if((signed int)*path == 47)
      path = path + 1l;

    else
    {
      unsigned long int elementlen;
      elementlen=strcspn(path, "/");
      if(elementlen == 1ul)
        tmp_if_expr_6 = (signed int)path[(signed long int)0] == 46 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      if(!tmp_if_expr_6)
      {
        if(elementlen == 2ul)
          tmp_if_expr_4 = (signed int)path[(signed long int)0] == 46 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
          tmp_if_expr_5 = (signed int)path[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        if(tmp_if_expr_5)
        {
          char *ls;
          ls=strrchr(result, 47);
          /* assertion ls != 0 */
          assert(ls != ((char *)NULL));
          if(!(ls == result))
            *ls = (char)0;

          else
            strcpy(result, "/");
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("result[0] -> '%s'", result);

          while((_Bool)0);
        }

        else
        {
          unsigned long int oldresultlen;
          oldresultlen=strlen(result);
          if(!(result[1l] == 0))
            result=append(a, result, nresultp, "/");

          result=appendn(a, result, nresultp, path, elementlen);
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("result[1] -> '%s'", result);

          while((_Bool)0);
          if(!((1u & flags) == 0u))
          {
            const char *target;
            target=sftp_do_readlink(a, result);
            if(!(target == ((const char *)NULL)))
            {
              if((signed int)*target == 47)
                strcpy(result, "/");

              else
                result[(signed long int)oldresultlen] = (char)0;
              result=process_path(a, result, nresultp, target, flags);
              if(result == ((char *)NULL))
                return result;

            }

            else
            {
              signed int *return_value___errno_location_1;
              return_value___errno_location_1=__errno_location();
              if(*return_value___errno_location_1 == 22)
                goto __CPROVER_DUMP_L27;

              if(!((2u & flags) == 0u))
              {
                do
                  if(!(sftp_debugging == 0))
                  {
                    return_value___errno_location_2=__errno_location();
                    return_value_strerror_3=strerror(*return_value___errno_location_2);
                    sftp_debug_printf("error reading link: %s", return_value_strerror_3);
                  }

                while((_Bool)0);
                return ((char *)NULL);
              }

            }
          }


        __CPROVER_DUMP_L27:
          ;
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("result[2] -> '%s'", result);

          while((_Bool)0);
        }
      }

      path = path + (signed long int)elementlen;
    }
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("returning '%s'", result);

  while((_Bool)0);
  return result;
}

// progress
// file sftpclient.c line 311
static void progress(const char *path, unsigned long int sofar, unsigned long int total)
{
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(!(progress_indicators == 0))
  {
    if(total == 0ul)
      xprintf("\r%*s\r", terminal_width, (const void *)"");

    else
      if(total == 18446744073709551615ul)
        xprintf("\r%.60s: %12lub", path, sofar);

      else
        xprintf("\r%.60s: %12lub %3d%%", path, sofar, (signed int)(((unsigned long int)100 * sofar) / total));
    signed int return_value_fflush_3;
    return_value_fflush_3=fflush(stdout);
    if(!(return_value_fflush_3 >= 0))
    {
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      fatal("error writing to stdout: %s", return_value_strerror_2);
    }

  }

}

// put16
// file putword.h line 36
static inline void put16(void *where, unsigned short int u)
{
  asm("xchg %h[U],%b[U]\n\tmovw %[U],%[WHERE]" : "+Q"(u) : "m"(*((unsigned short int *)where)) : );
}

// put32
// file putword.h line 52
static inline void put32(void *where, unsigned int u)
{
  asm("bswapl %[U]\n\tmovl %[U],%[WHERE]" : "+r"(u) : "m"(*((unsigned int *)where)) : );
}

// put64
// file putword.h line 70
static inline void put64(void *where, unsigned long int u)
{
  asm("bswapq %[U]\n\tmovq %[U],%[WHERE]" : "+r"(u) : "m"(*((unsigned long int *)where)) : );
}

// queue_add
// file queue.c line 125
void queue_add(struct queue *q, void *job)
{
  struct queuejob *qj;
  void *return_value_sftp__xmalloc_1;
  return_value_sftp__xmalloc_1=sftp__xmalloc(sizeof(struct queuejob) /*16ul*/ );
  qj = (struct queuejob *)return_value_sftp__xmalloc_1;
  qj->next = ((struct queuejob *)NULL);
  qj->job = job;
  do
  {
    signed int queue_add__1__1__frc;
    queue_add__1__1__frc=pthread_mutex_lock(&q->m);
    if(!(queue_add__1__1__frc == 0))
    {
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(queue_add__1__1__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"queue.c", 131, (const void *)"pthread_mutex_lock(&q->m)", return_value_strerror_2);
      exit(1);
    }

  }
  while((_Bool)0);
  *q->jobstail = qj;
  q->jobstail = &qj->next;
  do
  {
    signed int queue_add__1__2__frc;
    queue_add__1__2__frc=pthread_cond_signal(&q->c);
    if(!(queue_add__1__2__frc == 0))
    {
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(queue_add__1__2__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"queue.c", 134, (const void *)"pthread_cond_signal(&q->c)", return_value_strerror_3);
      exit(1);
    }

  }
  while((_Bool)0);
  do
  {
    signed int frc;
    frc=pthread_mutex_unlock(&q->m);
    if(!(frc == 0))
    {
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"queue.c", 135, (const void *)"pthread_mutex_unlock(&q->m)", return_value_strerror_4);
      exit(1);
    }

  }
  while((_Bool)0);
}

// queue_destroy
// file queue.c line 138
void queue_destroy(struct queue *q)
{
  signed int n;
  if(!(q == ((struct queue *)NULL)))
  {
    do
    {
      signed int queue_destroy__1__1__1__frc;
      queue_destroy__1__1__1__frc=pthread_mutex_lock(&q->m);
      if(!(queue_destroy__1__1__1__frc == 0))
      {
        char *return_value_strerror_1;
        return_value_strerror_1=strerror(queue_destroy__1__1__1__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"queue.c", 142, (const void *)"pthread_mutex_lock(&q->m)", return_value_strerror_1);
        exit(1);
      }

    }
    while((_Bool)0);
    q->join = 1;
    do
    {
      signed int frc;
      frc=pthread_cond_broadcast(&q->c);
      if(!(frc == 0))
      {
        char *return_value_strerror_2;
        return_value_strerror_2=strerror(frc);
        fatal("%s:%d: %s: %s\n", (const void *)"queue.c", 144, (const void *)"pthread_cond_broadcast(&q->c)", return_value_strerror_2);
        exit(1);
      }

    }
    while((_Bool)0);
    do
    {
      signed int queue_destroy__1__1__3__frc;
      queue_destroy__1__1__3__frc=pthread_mutex_unlock(&q->m);
      if(!(queue_destroy__1__1__3__frc == 0))
      {
        char *return_value_strerror_3;
        return_value_strerror_3=strerror(queue_destroy__1__1__3__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"queue.c", 145, (const void *)"pthread_mutex_unlock(&q->m)", return_value_strerror_3);
        exit(1);
      }

    }
    while((_Bool)0);
    n = 0;
    for( ; !(n >= q->nthreads); n = n + 1)
      do
      {
        signed int queue_destroy__1__1__4__1__frc;
        queue_destroy__1__1__4__1__frc=pthread_join(q->threads[(signed long int)n], ((void **)NULL));
        if(!(queue_destroy__1__1__4__1__frc == 0))
        {
          char *return_value_strerror_4;
          return_value_strerror_4=strerror(queue_destroy__1__1__4__1__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"queue.c", 147, (const void *)"pthread_join(q->threads[n], 0)", return_value_strerror_4);
          exit(1);
        }

      }
      while((_Bool)0);
    free((void *)q->threads);
    free((void *)q);
  }

}

// queue_init
// file queue.c line 104
void queue_init(struct queue **qr, struct queuedetails *details, signed int nthreads)
{
  signed int n;
  struct queue *q;
  void *return_value_sftp__xmalloc_1;
  return_value_sftp__xmalloc_1=sftp__xmalloc(sizeof(struct queue) /*136ul*/ );
  q = (struct queue *)return_value_sftp__xmalloc_1;
  memset((void *)q, 0, sizeof(struct queue) /*136ul*/ );
  q->jobs = ((struct queuejob *)NULL);
  q->jobstail = &q->jobs;
  do
  {
    signed int queue_init__1__1__frc;
    queue_init__1__1__frc=pthread_mutex_init(&q->m, ((const union anonymous_1 *)NULL));
    if(!(queue_init__1__1__frc == 0))
    {
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(queue_init__1__1__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"queue.c", 114, (const void *)"pthread_mutex_init(&q->m, 0)", return_value_strerror_2);
      exit(1);
    }

  }
  while((_Bool)0);
  do
  {
    signed int queue_init__1__2__frc;
    queue_init__1__2__frc=pthread_cond_init(&q->c, ((const union anonymous_1 *)NULL));
    if(!(queue_init__1__2__frc == 0))
    {
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(queue_init__1__2__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"queue.c", 115, (const void *)"pthread_cond_init(&q->c, 0)", return_value_strerror_3);
      exit(1);
    }

  }
  while((_Bool)0);
  q->details = details;
  q->nthreads = nthreads;
  void *return_value_xcalloc_4;
  return_value_xcalloc_4=xcalloc((unsigned long int)nthreads, sizeof(unsigned long int) /*8ul*/ );
  q->threads = (unsigned long int *)return_value_xcalloc_4;
  q->join = 0;
  n = 0;
  for( ; !(n >= q->nthreads); n = n + 1)
    do
    {
      signed int frc;
      frc=pthread_create(&q->threads[(signed long int)n], ((const union pthread_attr_t *)NULL), queue_thread, (void *)q);
      if(!(frc == 0))
      {
        char *return_value_strerror_5;
        return_value_strerror_5=strerror(frc);
        fatal("%s:%d: %s: %s\n", (const void *)"queue.c", 121, (const void *)"pthread_create(&q->threads[n], 0, queue_thread, q)", return_value_strerror_5);
        exit(1);
      }

    }
    while((_Bool)0);
  *qr = q;
}

// queue_serializable_job
// file serialize.c line 163
void queue_serializable_job(struct sftpjob *job)
{
  unsigned char type;
  unsigned int id;
  unsigned long int offset;
  unsigned long int len64;
  unsigned int len;
  struct handleid hid;
  unsigned int handleflags;
  struct sqnode *q;
  job->ptr = job->data;
  job->left = job->len;
  unsigned int return_value_sftp_parse_uint8_1;
  return_value_sftp_parse_uint8_1=sftp_parse_uint8(job, &type);
  _Bool tmp_if_expr_3;
  unsigned int return_value_sftp_parse_uint32_2;
  if(return_value_sftp_parse_uint8_1 == 0u && ((signed int)type == 5 || (signed int)type == 6))
  {
    return_value_sftp_parse_uint32_2=sftp_parse_uint32(job, &id);
    tmp_if_expr_3 = return_value_sftp_parse_uint32_2 == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  _Bool tmp_if_expr_5;
  unsigned int return_value_sftp_parse_handle_4;
  if(tmp_if_expr_3)
  {
    return_value_sftp_parse_handle_4=sftp_parse_handle(job, &hid);
    tmp_if_expr_5 = return_value_sftp_parse_handle_4 == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_5 = (_Bool)0;
  _Bool tmp_if_expr_7;
  unsigned int return_value_sftp_parse_uint64_6;
  if(tmp_if_expr_5)
  {
    return_value_sftp_parse_uint64_6=sftp_parse_uint64(job, &offset);
    tmp_if_expr_7 = return_value_sftp_parse_uint64_6 == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_7 = (_Bool)0;
  _Bool tmp_if_expr_9;
  unsigned int return_value_sftp_parse_uint32_8;
  if(tmp_if_expr_7)
  {
    return_value_sftp_parse_uint32_8=sftp_parse_uint32(job, &len);
    tmp_if_expr_9 = return_value_sftp_parse_uint32_8 == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_9 = (_Bool)0;
  if(tmp_if_expr_9)
  {
    len64 = (unsigned long int)len;
    handleflags=sftp_handle_flags(&hid);
  }

  else
  {
    memset((void *)&hid, 0, sizeof(struct handleid) /*8ul*/ );
    offset = (unsigned long int)0;
    len64 = ~((unsigned long int)0);
    handleflags = (unsigned int)0;
  }
  do
  {
    signed int frc;
    frc=pthread_mutex_lock(&sq_mutex);
    if(!(frc == 0))
    {
      char *return_value_strerror_10;
      return_value_strerror_10=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"serialize.c", 190, (const void *)"pthread_mutex_lock(&sq_mutex)", return_value_strerror_10);
      exit(1);
    }

  }
  while((_Bool)0);
  void *return_value_sftp__xmalloc_11;
  return_value_sftp__xmalloc_11=sftp__xmalloc(sizeof(struct sqnode) /*56ul*/ );
  q = (struct sqnode *)return_value_sftp__xmalloc_11;
  q->older = newest;
  q->job = job;
  q->type = type;
  q->hid = hid;
  q->handleflags = handleflags;
  q->offset = offset;
  q->len = len64;
  newest = q;
  do
  {
    signed int queue_serializable_job__1__4__frc;
    queue_serializable_job__1__4__frc=pthread_mutex_unlock(&sq_mutex);
    if(!(queue_serializable_job__1__4__frc == 0))
    {
      char *return_value_strerror_12;
      return_value_strerror_12=strerror(queue_serializable_job__1__4__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"serialize.c", 200, (const void *)"pthread_mutex_unlock(&sq_mutex)", return_value_strerror_12);
      exit(1);
    }

  }
  while((_Bool)0);
}

// queue_thread
// file queue.c line 73
static void * queue_thread(void *vq)
{
  struct queue * const q = (struct queue *)vq;
  struct queuejob *qj;
  struct allocator a;
  void *workerdata;
  workerdata=q->details->init();
  signed int frc;
  frc=pthread_mutex_lock(&q->m);
  if(!(frc == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(frc);
    fatal("%s:%d: %s: %s\n", (const void *)"queue.c", 80, (const void *)"pthread_mutex_lock(&q->m)", return_value_strerror_1);
    exit(1);
  }

  if(!(q->jobs == ((struct queuejob *)NULL)))
  {
    if(!(q->jobs == ((struct queuejob *)NULL)))
    {
      qj = q->jobs;
      q->jobs = qj->next;
      if(q->jobs == ((struct queuejob *)NULL))
        q->jobstail = &q->jobs;

      signed int queue_thread__1__2__1__1__frc;
      queue_thread__1__2__1__1__frc=pthread_mutex_unlock(&q->m);
      if(!(queue_thread__1__2__1__1__frc == 0))
      {
        char *return_value_strerror_2;
        return_value_strerror_2=strerror(queue_thread__1__2__1__1__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"queue.c", 88, (const void *)"pthread_mutex_unlock(&q->m)", return_value_strerror_2);
        exit(1);
      }

      sftp_alloc_init(&a);
      q->details->worker(qj->job, workerdata, &a);
      sftp_alloc_destroy(&a);
      free((void *)qj);
      signed int queue_thread__1__2__1__2__frc;
      queue_thread__1__2__1__2__frc=pthread_mutex_lock(&q->m);
      if(!(queue_thread__1__2__1__2__frc == 0))
      {
        char *return_value_strerror_3;
        return_value_strerror_3=strerror(queue_thread__1__2__1__2__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"queue.c", 93, (const void *)"pthread_mutex_lock(&q->m)", return_value_strerror_3);
        exit(1);
      }

    }

    else
    {
      signed int queue_thread__1__2__2__1__frc;
      queue_thread__1__2__2__1__frc=pthread_cond_wait(&q->c, &q->m);
      if(!(queue_thread__1__2__2__1__frc == 0))
      {
        char *return_value_strerror_4;
        return_value_strerror_4=strerror(queue_thread__1__2__2__1__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"queue.c", 96, (const void *)"pthread_cond_wait(&q->c, &q->m)", return_value_strerror_4);
        exit(1);
      }

    }
  }

  signed int queue_thread__1__3__frc;
  queue_thread__1__3__frc=pthread_mutex_unlock(&q->m);
  if(!(queue_thread__1__3__frc == 0))
  {
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(queue_thread__1__3__frc);
    fatal("%s:%d: %s: %s\n", (const void *)"queue.c", 99, (const void *)"pthread_mutex_unlock(&q->m)", return_value_strerror_5);
    exit(1);
  }

  q->details->cleanup(workerdata);
  return NULL;
}

// ranges_overlap
// file serialize.c line 111
static signed int ranges_overlap(struct sqnode *a, struct sqnode *b)
{
  if(!(a->len == 0ul))
  {
    if(!(b->len == 0ul))
    {
      const unsigned long int aend = (a->offset + a->len) - (unsigned long int)1;
      const unsigned long int bend = (b->offset + b->len) - (unsigned long int)1;
      if(aend >= b->offset)
      {
        if(bend >= aend)
          return 1;

      }

      if(bend >= a->offset)
      {
        if(aend >= bend)
          return 1;

      }

    }

  }

  return 0;
}

// reader_thread
// file sftpclient.c line 1329
static void * reader_thread(void *arg)
{
  struct reader_data * const r = (struct reader_data *)arg;
  signed int n;
  unsigned int id;
  unsigned int len;
  do
  {
    signed int frc;
    frc=pthread_mutex_lock(&r->m);
    if(!(frc == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1334, (const void *)"pthread_mutex_lock(&r->m)", return_value_strerror_1);
      exit(1);
    }

  }
  while((_Bool)0);
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  while(r->eof == 0)
  {
    if(!(r->failed == 0))
      break;

    while(r->outstanding == nrequests)
    {
      if(!(r->eof == 0))
        break;

      do
      {
        signed int reader_thread__1__2__1__frc;
        reader_thread__1__2__1__frc=pthread_cond_wait(&r->c1, &r->m);
        if(!(reader_thread__1__2__1__frc == 0))
        {
          char *return_value_strerror_2;
          return_value_strerror_2=strerror(reader_thread__1__2__1__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1338, (const void *)"pthread_cond_wait(&r->c1, &r->m)", return_value_strerror_2);
          exit(1);
        }

      }
      while((_Bool)0);
    }
    while(!(r->outstanding >= nrequests))
    {
      if(!(r->eof == 0))
        break;

      n = 0;
      do
      {
        if(!(n >= nrequests))
          tmp_if_expr_3 = (r->reqs + (signed long int)n)->id != 0u ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(!tmp_if_expr_3)
          break;

        n = n + 1;
      }
      while((_Bool)1);
      /* assertion n < nrequests */
      assert(n < nrequests);
      id=newid();
      sftp_send_begin(&fakeworker);
      sftp_send_uint8(&fakeworker, 5);
      sftp_send_uint32(&fakeworker, id);
      sftp_send_bytes(&fakeworker, (const void *)r->h.data, r->h.len);
      sftp_send_uint64(&fakeworker, r->next_offset);
      if(r->size == 18446744073709551615ul)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = r->size - r->next_offset > buffersize ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
        len = (unsigned int)buffersize;

      else
      {
        len = (unsigned int)(r->size - r->next_offset);
        r->eof = 1;
      }
      sftp_send_uint32(&fakeworker, len);
      (r->reqs + (signed long int)n)->id = id;
      (r->reqs + (signed long int)n)->offset = (signed long int)r->next_offset;
      r->outstanding = r->outstanding + 1;
      r->next_offset = r->next_offset + buffersize;
      do
      {
        signed int reader_thread__1__2__2__3__frc;
        reader_thread__1__2__2__3__frc=pthread_mutex_unlock(&r->m);
        if(!(reader_thread__1__2__2__3__frc == 0))
        {
          char *return_value_strerror_5;
          return_value_strerror_5=strerror(reader_thread__1__2__2__3__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1364, (const void *)"pthread_mutex_unlock(&r->m)", return_value_strerror_5);
          exit(1);
        }

      }
      while((_Bool)0);
      sftp_send_end(&fakeworker);
      do
      {
        signed int reader_thread__1__2__2__4__frc;
        reader_thread__1__2__2__4__frc=pthread_mutex_lock(&r->m);
        if(!(reader_thread__1__2__2__4__frc == 0))
        {
          char *return_value_strerror_6;
          return_value_strerror_6=strerror(reader_thread__1__2__2__4__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1366, (const void *)"pthread_mutex_lock(&r->m)", return_value_strerror_6);
          exit(1);
        }

      }
      while((_Bool)0);
      do
      {
        signed int reader_thread__1__2__2__5__frc;
        reader_thread__1__2__2__5__frc=pthread_cond_signal(&r->c2);
        if(!(reader_thread__1__2__2__5__frc == 0))
        {
          char *return_value_strerror_7;
          return_value_strerror_7=strerror(reader_thread__1__2__2__5__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1368, (const void *)"pthread_cond_signal(&r->c2)", return_value_strerror_7);
          exit(1);
        }

      }
      while((_Bool)0);
    }
  }
  do
  {
    signed int reader_thread__1__3__frc;
    reader_thread__1__3__frc=pthread_mutex_unlock(&r->m);
    if(!(reader_thread__1__3__frc == 0))
    {
      char *return_value_strerror_8;
      return_value_strerror_8=strerror(reader_thread__1__3__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1371, (const void *)"pthread_mutex_unlock(&r->m)", return_value_strerror_8);
      exit(1);
    }

  }
  while((_Bool)0);
  return NULL;
}

// reap_write_response
// file sftpclient.c line 1442
static void reap_write_response(struct reader_data *r)
{
  unsigned char rtype;
  unsigned int st;
  unsigned int len;
  signed int n;
  signed int reap_write_response__1__rc;
  do
  {
    signed int frc;
    frc=pthread_mutex_unlock(&r->m);
    if(!(frc == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1449, (const void *)"pthread_mutex_unlock(&r->m)", return_value_strerror_1);
      exit(1);
    }

  }
  while((_Bool)0);
  rtype=getresponse(-1, (unsigned int)0, "SSH_FXP_READ");
  do
  {
    signed int reap_write_response__1__2__frc;
    reap_write_response__1__2__frc=pthread_mutex_lock(&r->m);
    if(!(reap_write_response__1__2__frc == 0))
    {
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(reap_write_response__1__2__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1451, (const void *)"pthread_mutex_lock(&r->m)", return_value_strerror_2);
      exit(1);
    }

  }
  while((_Bool)0);
  r->outstanding = r->outstanding - 1;
  _Bool tmp_if_expr_3;
  signed long int return_value_pwrite_4;
  if(r->failed == 0)
    switch((signed int)rtype)
    {
      case 101:
      {
        do
        {
          unsigned int reap_write_response__1__3__1__rc;
          reap_write_response__1__3__1__rc=sftp_parse_uint32(&fakejob, &st);
          if(!(reap_write_response__1__3__1__rc == 0u))
          {
            do
              if(!(sftp_debugging == 0))
                sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 1458, (const void *)"sftp_parse_uint32(&fakejob, &st)", reap_write_response__1__3__1__rc);

            while((_Bool)0);
            fatal("error parsing response from server");
          }

        }
        while((_Bool)0);
        if(st == 1u)
          r->eof = 1;

        else
        {
          status();
          r->failed = 1;
        }
        break;
      }
      case 103:
      {
        n = 0;
        do
        {
          if(!(n >= nrequests))
            tmp_if_expr_3 = fakejob.id != (r->reqs + (signed long int)n)->id ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          if(!tmp_if_expr_3)
            break;

          n = n + 1;
        }
        while((_Bool)1);
        /* assertion n < nrequests */
        assert(n < nrequests);
        (r->reqs + (signed long int)n)->id = (unsigned int)0;
        do
        {
          unsigned int rc;
          rc=sftp_parse_uint32(&fakejob, &len);
          if(!(rc == 0u))
          {
            do
              if(!(sftp_debugging == 0))
                sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 1475, (const void *)"sftp_parse_uint32(&fakejob, &len)", rc);

            while((_Bool)0);
            fatal("error parsing response from server");
          }

        }
        while((_Bool)0);
        if(!(textmode == 0))
          reap_write_response__1__rc=write_translated(r, (const void *)fakejob.ptr, (unsigned long int)len);

        else
        {
          return_value_pwrite_4=pwrite(r->fd, (const void *)fakejob.ptr, (unsigned long int)len, (r->reqs + (signed long int)n)->offset);
          reap_write_response__1__rc = (signed int)return_value_pwrite_4;
        }
        if(!(reap_write_response__1__rc >= 0))
        {
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          char *return_value_strerror_6;
          return_value_strerror_6=strerror(*return_value___errno_location_5);
          error("error writing to %s: %s", r->tmp, return_value_strerror_6);
          r->failed = 1;
          goto __CPROVER_DUMP_L26;
        }

        r->written = r->written + (unsigned long int)len;
        progress(r->local, r->written, r->size);
        break;
      }
      default:
        fatal("unexpected response %d to SSH_FXP_READ", rtype);
    }


__CPROVER_DUMP_L26:
  ;
}

// remote_cwd
// file sftpclient.c line 291
static char * remote_cwd(void)
{
  if(cwd == ((char *)NULL))
  {
    cwd=sftp_realpath(".");
    if(cwd == ((char *)NULL))
      exit(1);

    cwd=xstrdup(cwd);
  }

  return cwd;
}

// reorderable
// file serialize.c line 134
static signed int reorderable(struct sqnode *q1, struct sqnode *q2, unsigned int flags)
{
  _Bool tmp_if_expr_4;
  if((signed int)q1->type == 5)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = (signed int)q1->type == 6 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_4)
  {
    if((signed int)q2->type == 5)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = (signed int)q2->type == 6 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_6 = (_Bool)0;
  _Bool tmp_if_expr_3;
  signed int return_value_ranges_overlap_2;
  if(tmp_if_expr_6)
  {
    signed int return_value_handles_equal_1;
    return_value_handles_equal_1=handles_equal(&q1->hid, &q2->hid);
    if(return_value_handles_equal_1 == 0)
      return 1;

    if((signed int)q1->type == 5)
    {
      if((signed int)q2->type == 5)
        return 0;

    }

    if(!((3u & flags) == 0u))
      return 0;

    if((signed int)q1->type == 6)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)q2->type == 6 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      return_value_ranges_overlap_2=ranges_overlap(q1, q2);
      if(!(return_value_ranges_overlap_2 == 0))
        return 0;

    }

    return 1;
  }

  else
    return 0;
}

// report_bytes
// file sftpclient.c line 2051
static void report_bytes(signed int width, const char *what, unsigned long int howmuch)
{
  if(!(howmuch == 0ul))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(what);
    xprintf("%s:%*s ", what, width - (signed int)return_value_strlen_1, (const void *)"");
    static const unsigned long int kbyte = (unsigned long int)1 << 10;
    static const unsigned long int mbyte = (unsigned long int)1 << 20;
    static const unsigned long int gbyte = (unsigned long int)1 << 30;
    if(howmuch >= 8ul * gbyte)
      xprintf("%lu Gbytes\n", howmuch / gbyte);

    else
      if(howmuch >= 8ul * mbyte)
        xprintf("%lu Mbytes\n", howmuch / mbyte);

      else
        if(howmuch >= 8ul * kbyte)
          xprintf("%lu Kbytes\n", howmuch / kbyte);

        else
          xprintf("%lu bytes\n", howmuch);
  }

}

// reverse
// file sftpclient.c line 982
static void reverse(void *array, unsigned long int count, unsigned long int size)
{
  if(!(array == NULL))
  {
    void *tmp;
    tmp=sftp__xmalloc(size);
    char * const base = (char *)array;
    unsigned long int n = (unsigned long int)0;
    for( ; !(n >= size / 2ul); n = n + 1ul)
    {
      memcpy(tmp, (const void *)(base + (signed long int)(n * size)), size);
      memcpy((void *)(base + (signed long int)(n * size)), (const void *)(base + (signed long int)(((count - n) - (unsigned long int)1) * size)), size);
      memcpy((void *)(base + (signed long int)(((count - n) - (unsigned long int)1) * size)), tmp, size);
    }
    free(tmp);
  }

}

// serialize
// file serialize.c line 203
void serialize(struct sftpjob *job)
{
  struct sqnode *q;
  struct sqnode *oq;
  do
  {
    signed int frc;
    frc=pthread_mutex_lock(&sq_mutex);
    if(!(frc == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"serialize.c", 206, (const void *)"pthread_mutex_lock(&sq_mutex)", return_value_strerror_1);
      exit(1);
    }

  }
  while((_Bool)0);
  _Bool tmp_if_expr_2;
  signed int return_value_reorderable_3;
  do
  {
    q = newest;
    do
    {
      if(!(q == ((struct sqnode *)NULL)))
        tmp_if_expr_2 = q->job != job ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        break;

      q = q->older;
    }
    while((_Bool)1);
    if(q == ((struct sqnode *)NULL))
      break;

    oq = q->older;
    for( ; !(oq == ((struct sqnode *)NULL)); oq = oq->older)
    {
      return_value_reorderable_3=reorderable(q, oq, q->handleflags);
      if(return_value_reorderable_3 == 0)
        break;

    }
    if(oq == ((struct sqnode *)NULL))
      break;

    do
    {
      signed int serialize__1__2__1__3__frc;
      serialize__1__2__1__3__frc=pthread_cond_wait(&sq_cond, &sq_mutex);
      if(!(serialize__1__2__1__3__frc == 0))
      {
        char *return_value_strerror_4;
        return_value_strerror_4=strerror(serialize__1__2__1__3__frc);
        fatal("%s:%d: %s: %s\n", (const void *)"serialize.c", 222, (const void *)"pthread_cond_wait(&sq_cond, &sq_mutex)", return_value_strerror_4);
        exit(1);
      }

    }
    while((_Bool)0);
  }
  while((_Bool)1);
  do
  {
    signed int serialize__1__3__frc;
    serialize__1__3__frc=pthread_mutex_unlock(&sq_mutex);
    if(!(serialize__1__3__frc == 0))
    {
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(serialize__1__3__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"serialize.c", 225, (const void *)"pthread_mutex_unlock(&sq_mutex)", return_value_strerror_5);
      exit(1);
    }

  }
  while((_Bool)0);
}

// serialize_remove_job
// file serialize.c line 228
void serialize_remove_job(struct sftpjob *job)
{
  struct sqnode *q;
  struct sqnode **qq;
  do
  {
    signed int serialize_remove_job__1__1__frc;
    serialize_remove_job__1__1__frc=pthread_mutex_lock(&sq_mutex);
    if(!(serialize_remove_job__1__1__frc == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(serialize_remove_job__1__1__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"serialize.c", 231, (const void *)"pthread_mutex_lock(&sq_mutex)", return_value_strerror_1);
      exit(1);
    }

  }
  while((_Bool)0);
  qq = &newest;
  _Bool tmp_if_expr_2;
  do
  {
    q = *qq;
    if(!(q == ((struct sqnode *)NULL)))
      tmp_if_expr_2 = q->job != job ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      break;

    qq = &q->older;
  }
  while((_Bool)1);
  if(!(q == ((struct sqnode *)NULL)))
  {
    *qq = q->older;
    free((void *)q);
    do
    {
      signed int frc;
      frc=pthread_cond_broadcast(&sq_cond);
      if(!(frc == 0))
      {
        char *return_value_strerror_3;
        return_value_strerror_3=strerror(frc);
        fatal("%s:%d: %s: %s\n", (const void *)"serialize.c", 238, (const void *)"pthread_cond_broadcast(&sq_cond)", return_value_strerror_3);
        exit(1);
      }

    }
    while((_Bool)0);
  }

  do
  {
    signed int serialize_remove_job__1__4__frc;
    serialize_remove_job__1__4__frc=pthread_mutex_unlock(&sq_mutex);
    if(!(serialize_remove_job__1__4__frc == 0))
    {
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(serialize_remove_job__1__4__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"serialize.c", 240, (const void *)"pthread_mutex_unlock(&sq_mutex)", return_value_strerror_4);
      exit(1);
    }

  }
  while((_Bool)0);
}

// sftp__xmalloc
// file utils.h line 50
void * sftp__xmalloc(unsigned long int n)
{
  void *ptr;
  if(!(n == 0ul))
  {
    ptr=malloc(n);
    if(ptr == NULL)
      fatal("xmalloc: out of memory (%zu)", n);

    return ptr;
  }

  else
    return NULL;
}

// sftp__xrealloc
// file utils.h line 70
void * sftp__xrealloc(void *ptr, unsigned long int n)
{
  if(!(n == 0ul))
  {
    ptr=realloc(ptr, n);
    if(ptr == NULL)
      fatal("xrealloc: out of memory (%zu)", n);

    return ptr;
  }

  else
  {
    free(ptr);
    return NULL;
  }
}

// sftp_alloc
// file alloc.h line 58
void * sftp_alloc(struct allocator *a, unsigned long int n)
{
  unsigned long int m;
  m=blocks(n);
  struct chunk *c;
  _Bool tmp_if_expr_2;
  if(m == 0ul)
    return NULL;

  else
  {
    /* assertion a != 0 */
    assert(a != ((struct allocator *)NULL));
    /* assertion m != (18446744073709551615UL) */
    assert(m != 18446744073709551615UL);
    c = a->chunks;
    if(c == ((struct chunk *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = c->left < m ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      const unsigned long int cs = m >= (unsigned long int)512 ? m + (unsigned long int)1 : (unsigned long int)512;
      union block *nb;
      void *return_value_xcalloc_1;
      return_value_xcalloc_1=xcalloc(cs, sizeof(union block) /*32ul*/ );
      nb = (union block *)return_value_xcalloc_1;
      c = &nb->c;
      c->next = a->chunks;
      c->ptr = nb + (signed long int)1;
      c->left = cs - (unsigned long int)1;
      a->chunks = c;
    }

    /* assertion m <= c->left */
    assert(m <= c->left);
    memset((void *)c->ptr, 0, m * sizeof(union block) /*32ul*/ );
    c->left = c->left - m;
    c->ptr = c->ptr + (signed long int)m;
    return (void *)(c->ptr - (signed long int)m);
  }
}

// sftp_alloc_destroy
// file alloc.h line 79
void sftp_alloc_destroy(struct allocator *a)
{
  struct chunk *c;
  struct chunk *d;
  c = a->chunks;
  do
  {
    d = c;
    if(d == ((struct chunk *)NULL))
      break;

    c = c->next;
    free((void *)d);
  }
  while((_Bool)1);
  a->chunks = ((struct chunk *)NULL);
}

// sftp_alloc_init
// file alloc.h line 46
struct allocator * sftp_alloc_init(struct allocator *a)
{
  a->chunks = ((struct chunk *)NULL);
  return a;
}

// sftp_alloc_more
// file alloc.c line 121
void * sftp_alloc_more(struct allocator *a, void *ptr, unsigned long int oldn, unsigned long int newn)
{
  unsigned long int oldm;
  oldm=blocks(oldn);
  unsigned long int newm;
  newm=blocks(newn);
  void *newptr;
  void *return_value_sftp_alloc_1;
  if(!(ptr == NULL))
  {
    /* assertion a->chunks != 0 */
    assert(a->chunks != ((struct chunk *)NULL));
    do
      if(!(sftp_debugging == 0))
        sftp_debug_printf("ptr=%p oldm=%zu a->chunks->ptr=%p blocksize=%zu", ptr, oldm, a->chunks->ptr, sizeof(union block) /*32ul*/ );

    while((_Bool)0);
    if((union block *)ptr + (signed long int)oldm == a->chunks->ptr)
    {
      if(oldm >= newm)
      {
        a->chunks->ptr = a->chunks->ptr - (signed long int)(oldm - newm);
        a->chunks->left = a->chunks->left + (oldm - newm);
        return ptr;
      }

      else
        if(a->chunks->left >= newm + -oldm)
        {
          a->chunks->ptr = a->chunks->ptr + (signed long int)(newm - oldm);
          a->chunks->left = a->chunks->left - (newm - oldm);
          memset((void *)((char *)ptr + (signed long int)oldn), 0, newn - oldn);
          return ptr;
        }

    }

    else
      if(newm == oldm)
        return ptr;

    newptr=sftp_alloc(a, newn);
    memcpy(newptr, ptr, oldn);
    return newptr;
  }

  else
  {
    return_value_sftp_alloc_1=sftp_alloc(a, newn);
    return return_value_sftp_alloc_1;
  }
}

// sftp_close
// file sftpclient.c line 593
static signed int sftp_close(struct client_handle *hp)
{
  unsigned int id;
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 4);
  id=newid();
  sftp_send_uint32(&fakeworker, id);
  sftp_send_bytes(&fakeworker, (const void *)hp->data, hp->len);
  sftp_send_end(&fakeworker);
  getresponse(101, id, "SSH_FXP_CLOSE");
  signed int return_value_status_1;
  return_value_status_1=status();
  return return_value_status_1;
}

// sftp_debug_hexdump
// file debug.h line 40
void sftp_debug_hexdump(const void *ptr, unsigned long int n)
{
  const unsigned char *p = (const unsigned char *)ptr;
  unsigned long int i;
  unsigned long int j;
  char buffer[80l];
  char *output;
  opendebug();
  i = (unsigned long int)0;
  signed int return_value_sprintf_2;
  char *tmp_post_3;
  const unsigned short int **return_value___ctype_b_loc_4;
  signed int tmp_if_expr_5;
  char *tmp_post_6;
  for( ; !(i >= n); i = i + (unsigned long int)16)
  {
    output = buffer;
    signed int return_value_sprintf_1;
    return_value_sprintf_1=sprintf(output, "%4lx ", (unsigned long int)i);
    output = output + (signed long int)return_value_sprintf_1;
    j = (unsigned long int)0;
    for( ; !(j >= 16ul); j = j + 1ul)
      if(!(i + j >= n))
      {
        return_value_sprintf_2=sprintf(output, " %02x", p[(signed long int)(i + j)]);
        output = output + (signed long int)return_value_sprintf_2;
      }

      else
      {
        strcpy(output, "   ");
        output = output + (signed long int)3;
      }
    strcpy(output, "  ");
    output = output + (signed long int)2;
    j = (unsigned long int)0;
    for( ; !(j >= 16ul); j = j + 1ul)
      if(!(i + j >= n))
      {
        tmp_post_3 = output;
        output = output + 1l;
        return_value___ctype_b_loc_4=__ctype_b_loc();
        if(!((16384 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)p[(signed long int)i + (signed long int)j]]) == 0))
          tmp_if_expr_5 = (signed int)p[(signed long int)(i + j)];

        else
          tmp_if_expr_5 = 46;
        *tmp_post_3 = (char)tmp_if_expr_5;
      }

    tmp_post_6 = output;
    output = output + 1l;
    *tmp_post_6 = (char)10;
    *output = (char)0;
    fputs(buffer, debugfp);
  }
  fflush(debugfp);
}

// sftp_debug_printf
// file debug.h line 48
void sftp_debug_printf(const char *fmt, ...)
{
  void **ap;
  signed int save_errno;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  save_errno = *return_value___errno_location_1;
  opendebug();
  ap = (void **)&fmt;
  vfprintf(debugfp, fmt, ap);
  ap = ((void **)NULL);
  fputc(10, debugfp);
  fflush(debugfp);
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  *return_value___errno_location_2 = save_errno;
}

// sftp_dirname
// file utils.h line 174
const char * sftp_dirname(struct allocator *a, const char *path)
{
  const char *ls;
  ls=strrchr(path, 47);
  if(!(ls == ((const char *)NULL)))
  {
    if(!(ls == path))
    {
      const unsigned long int len = (const unsigned long int)(ls - path);
      char *d;
      /* assertion len + 1 != 0 */
      assert(len + (unsigned long int)1 != (unsigned long int)0);
      void *return_value_sftp_alloc_1;
      return_value_sftp_alloc_1=sftp_alloc(a, len + (unsigned long int)1);
      d = (char *)return_value_sftp_alloc_1;
      memcpy((void *)d, (const void *)path, len);
      return d;
    }

    else
      return "/";
  }

  else
    return ".";
}

// sftp_do_readlink
// file utils.h line 120
char * sftp_do_readlink(struct allocator *a, const char *path)
{
  unsigned long int nresult = (unsigned long int)32;
  unsigned long int oldnresult = (unsigned long int)0;
  char *result = ((char *)NULL);
  signed int n;
  while(nresult >= 1ul && !(nresult >= 65537ul))
  {
    void *return_value_sftp_alloc_more_1;
    return_value_sftp_alloc_more_1=sftp_alloc_more(a, (void *)result, oldnresult, nresult);
    result = (char *)return_value_sftp_alloc_more_1;
    signed long int return_value_readlink_2;
    return_value_readlink_2=readlink(path, result, nresult);
    n = (signed int)return_value_readlink_2;
    if(!(n >= 0))
      return ((char *)NULL);

    if(!((unsigned long int)(unsigned int)n >= nresult))
    {
      result[(signed long int)n] = (char)0;
      return result;
    }

    oldnresult = nresult;
    nresult = nresult * (unsigned long int)2;
  }
  signed int *return_value___errno_location_3;
  return_value___errno_location_3=__errno_location();
  *return_value___errno_location_3 = 7;
  return ((char *)NULL);
}

// sftp_find_realpath
// file utils.h line 148
char * sftp_find_realpath(struct allocator *a, const char *path, unsigned int flags)
{
  char *sftp_find_realpath__1__cwd;
  char *abspath;
  char *result = ((char *)NULL);
  unsigned long int nresult = (unsigned long int)0;
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_find_realpath '%s' %#x", path, flags);

  while((_Bool)0);
  if((signed int)*path == 0)
    path = ".";

  if(!((signed int)*path == 47))
  {
    sftp_find_realpath__1__cwd=sftp_getcwd(a);
    if(sftp_find_realpath__1__cwd == ((char *)NULL))
      return ((char *)NULL);

    /* assertion cwd[0] == '/' */
    assert((signed int)sftp_find_realpath__1__cwd[(signed long int)0] == 47);
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(sftp_find_realpath__1__cwd);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(path);
    void *return_value_sftp_alloc_3;
    return_value_sftp_alloc_3=sftp_alloc(a, return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)2);
    abspath = (char *)return_value_sftp_alloc_3;
    strcpy(abspath, sftp_find_realpath__1__cwd);
    strcat(abspath, "/");
    strcat(abspath, path);
    path = abspath;
    do
      if(!(sftp_debugging == 0))
        sftp_debug_printf("convert relative path to '%s'", path);

    while((_Bool)0);
  }

  result=append(a, result, &nresult, "/");
  char *return_value_process_path_4;
  return_value_process_path_4=process_path(a, result, &nresult, path, flags);
  return return_value_process_path_4;
}

// sftp_format_attr
// file stat.h line 38
const char * sftp_format_attr(struct allocator *a, struct sftpattr *attrs, signed int thisyear, unsigned long int flags)
{
  char perms[64l];
  char linkcount[64l];
  char size[64l];
  char date[64l];
  char nowner[64l];
  char ngroup[64l];
  char *formatted;
  char *p;
  char *bits;
  unsigned long int nbits;
  const char *owner;
  const char *group;
  unsigned long int n;
  p = perms;
  char *tmp_post_1 = p;
  p = p + 1l;
  static const char typedetails[11l] = { '?', '-', 'd', 'l', '?', '?', 's', 'c', 'b', 'p', 0 };
  *tmp_post_1 = typedetails[(signed long int)attrs->type];
  char *tmp_post_2;
  char *tmp_post_3;
  char *tmp_post_4;
  char *tmp_post_5;
  char *tmp_post_6;
  char *tmp_post_7;
  char *tmp_post_8;
  char *tmp_post_9;
  char *tmp_post_10;
  char *tmp_post_11;
  char *tmp_post_12;
  char *tmp_post_13;
  char *tmp_post_14;
  char *tmp_post_15;
  char *tmp_post_16;
  char *tmp_post_17;
  char *tmp_post_18;
  char *tmp_post_19;
  if(!((4u & attrs->valid) == 0u))
  {
    tmp_post_2 = p;
    p = p + 1l;
    *tmp_post_2 = (char)((attrs->permissions & (unsigned int)00400) != 0u ? 114 : 45);
    tmp_post_3 = p;
    p = p + 1l;
    *tmp_post_3 = (char)((attrs->permissions & (unsigned int)00200) != 0u ? 119 : 45);
    switch(attrs->permissions & (unsigned int)04100)
    {
      case (unsigned int)00000:
      {
        tmp_post_4 = p;
        p = p + 1l;
        *tmp_post_4 = (char)45;
        break;
      }
      case (unsigned int)00100:
      {
        tmp_post_5 = p;
        p = p + 1l;
        *tmp_post_5 = (char)120;
        break;
      }
      case (unsigned int)04000:
      {
        tmp_post_6 = p;
        p = p + 1l;
        *tmp_post_6 = (char)83;
        break;
      }
      case (unsigned int)04100:
      {
        tmp_post_7 = p;
        p = p + 1l;
        *tmp_post_7 = (char)115;
      }
    }
    tmp_post_8 = p;
    p = p + 1l;
    *tmp_post_8 = (char)((attrs->permissions & (unsigned int)00040) != 0u ? 114 : 45);
    tmp_post_9 = p;
    p = p + 1l;
    *tmp_post_9 = (char)((attrs->permissions & (unsigned int)00020) != 0u ? 119 : 45);
    switch(attrs->permissions & (unsigned int)02010)
    {
      case (unsigned int)00000:
      {
        tmp_post_10 = p;
        p = p + 1l;
        *tmp_post_10 = (char)45;
        break;
      }
      case (unsigned int)00010:
      {
        tmp_post_11 = p;
        p = p + 1l;
        *tmp_post_11 = (char)120;
        break;
      }
      case (unsigned int)02000:
      {
        tmp_post_12 = p;
        p = p + 1l;
        *tmp_post_12 = (char)83;
        break;
      }
      case (unsigned int)02010:
      {
        tmp_post_13 = p;
        p = p + 1l;
        *tmp_post_13 = (char)115;
      }
    }
    tmp_post_14 = p;
    p = p + 1l;
    *tmp_post_14 = (char)((attrs->permissions & (unsigned int)00004) != 0u ? 114 : 45);
    tmp_post_15 = p;
    p = p + 1l;
    *tmp_post_15 = (char)((attrs->permissions & (unsigned int)00002) != 0u ? 119 : 45);
    switch(attrs->permissions & (unsigned int)01001)
    {
      case (unsigned int)00000:
      {
        tmp_post_16 = p;
        p = p + 1l;
        *tmp_post_16 = (char)45;
        break;
      }
      case (unsigned int)00001:
      {
        tmp_post_17 = p;
        p = p + 1l;
        *tmp_post_17 = (char)120;
        break;
      }
      case (unsigned int)01000:
      {
        tmp_post_18 = p;
        p = p + 1l;
        *tmp_post_18 = (char)84;
        break;
      }
      case (unsigned int)01001:
      {
        tmp_post_19 = p;
        p = p + 1l;
        *tmp_post_19 = (char)116;
      }
    }
    *p = (char)0;
  }

  else
    strcpy(p, "?????????");
  if(!((8192u & attrs->valid) == 0u))
    sprintf(linkcount, "%u", attrs->link_count);

  else
    strcpy(linkcount, "?");
  if(!((1u & attrs->valid) == 0u))
    sprintf(size, "%lu", attrs->size);

  else
    strcpy(size, "?");
  if(!((2u & attrs->valid) == 0u))
  {
    sprintf(nowner, "%u", attrs->uid);
    sprintf(ngroup, "%u", attrs->gid);
  }

  group = "?";
  owner = group;
  if(!((1ul & flags) == 0ul))
  {
    if(!((2u & attrs->valid) == 0u))
    {
      owner = nowner;
      group = ngroup;
    }

    else
      if(!((128u & attrs->valid) == 0u))
      {
        owner = attrs->owner;
        group = attrs->group;
      }

  }

  else
    if(!((128u & attrs->valid) == 0u))
    {
      owner = attrs->owner;
      group = attrs->group;
    }

    else
      if(!((2u & attrs->valid) == 0u))
      {
        owner = nowner;
        group = ngroup;
      }

  if(!((32u & attrs->valid) == 0u))
  {
    struct tm mtime;
    const signed long int m = attrs->mtime.seconds;
    ((flags & (unsigned long int)0x00000002) != 0ul ? localtime_r : gmtime_r)(&m, &mtime);
    if(mtime.tm_year == thisyear)
      strftime(date, sizeof(char [64l]) /*64ul*/ , "%b %d %H:%M", &mtime);

    else
      strftime(date, sizeof(char [64l]) /*64ul*/ , "%b %d  %Y", &mtime);
  }

  else
    strcpy(date, "?");
  bits = (char *)(void *)0;
  nbits = (unsigned long int)0;
  if(!((4ul & flags) == 0ul))
  {
    if(!((512u & attrs->valid) == 0u))
    {
      if(!(attrs->attrib_bits == 0u))
      {
        bits=append(a, bits, &nbits, "[");
        n = (unsigned long int)0;
        for( ; !(n >= 12ul); n = n + 1ul)
          if(!((attrs->attrib_bits & attr_bits[(signed long int)n].bit) == 0u))
          {
            if(!(bits[1l] == 0))
              bits=append(a, bits, &nbits, ",");

            bits=append(a, bits, &nbits, attr_bits[(signed long int)n].description);
          }

        bits=append(a, bits, &nbits, "]");
      }

    }

  }

  unsigned long int return_value_strlen_20;
  return_value_strlen_20=strlen(attrs->name);
  void *return_value_sftp_alloc_21;
  return_value_sftp_alloc_21=sftp_alloc(a, (unsigned long int)80 + return_value_strlen_20);
  formatted = (char *)return_value_sftp_alloc_21;
  const char *tmp_if_expr_22;
  if(!(attrs->target == ((const char *)NULL)))
    tmp_if_expr_22 = attrs->target;

  else
    tmp_if_expr_22 = "";
  sprintf(formatted, "%10.10s %3.3s %-8.8s %-8.8s %8.8s %12.12s %s%s%s%s%s", (const void *)perms, (const void *)linkcount, owner, group, (const void *)size, (const void *)date, attrs->name, attrs->target != ((const char *)NULL) ? " -> " : "", tmp_if_expr_22, (flags & (unsigned long int)0x00000004) != 0ul ? " " : "", (flags & (unsigned long int)0x00000004) != 0ul ? bits : "");
  return formatted;
}

// sftp_fsetstat
// file sftpclient.c line 620
static signed int sftp_fsetstat(struct client_handle *hp, struct sftpattr *attrs)
{
  unsigned int id;
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 10);
  id=newid();
  sftp_send_uint32(&fakeworker, id);
  sftp_send_bytes(&fakeworker, (const void *)hp->data, hp->len);
  protocol->sendattrs(&fakejob, attrs);
  sftp_send_end(&fakeworker);
  getresponse(101, id, "SSH_FXP_FSETSTAT");
  signed int return_value_status_1;
  return_value_status_1=status();
  return return_value_status_1;
}

// sftp_fstat
// file sftpclient.c line 512
static signed int sftp_fstat(struct client_handle *hp, struct sftpattr *attrs)
{
  unsigned int id;
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 8);
  id=newid();
  sftp_send_uint32(&fakeworker, id);
  sftp_send_bytes(&fakeworker, (const void *)hp->data, hp->len);
  if(protocol->version >= 4)
    sftp_send_uint32(&fakeworker, 0xFFFFFFFF);

  sftp_send_end(&fakeworker);
  unsigned char return_value_getresponse_1;
  return_value_getresponse_1=getresponse(105, id, "SSH_FXP_FSTAT");
  if(!((signed int)return_value_getresponse_1 == 105))
    return -1;

  else
  {
    unsigned int rc;
    rc=protocol->parseattrs(&fakejob, attrs);
    if(!(rc == 0u))
    {
      if(!(sftp_debugging == 0))
        sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 524, (const void *)"protocol->parseattrs(&fakejob, attrs)", rc);

      fatal("error parsing response from server");
    }

    return 0;
  }
}

// sftp_generic_open
// file sftpserver.h line 303
unsigned int sftp_generic_open(struct sftpjob *job, const char *path, unsigned int desired_access, unsigned int flags, struct sftpattr *attrs)
{
  unsigned int initial_permissions;
  signed int created;
  signed int open_flags;
  signed int fd;
  struct stat sb;
  struct handleid id;
  unsigned int sftp_generic_open__1__sftp_handle_flags = (unsigned int)0;
  unsigned int rc;
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_generic_open %s %#x %#x", path, desired_access, flags);

  while((_Bool)0);
  rc=sftp_normalize_ownergroup(job->a, attrs);
  unsigned int return_value_getuid_1;
  signed int *return_value___errno_location_4;
  signed int return_value_fstat_8;
  signed int *return_value___errno_location_12;
  signed int *return_value___errno_location_14;
  _Bool tmp_if_expr_16;
  signed int *return_value___errno_location_15;
  if(!(rc == 0u))
    return rc;

  else
  {
    attrs->valid = attrs->valid & ~((unsigned int)0x00000001);
    if(!((3u & desired_access) == 0u) && !((3u & desired_access) == 1u))
    {
      if((3u & desired_access) == 2u)
        goto __CPROVER_DUMP_L7;

      if((3u & desired_access) == 3u)
        goto __CPROVER_DUMP_L11;

    }

    else
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("O_RDONLY");

      while((_Bool)0);
      open_flags = 00;
      if(!((786704u & desired_access) == 0u))
        return (unsigned int)3;

      goto __CPROVER_DUMP_L15;

    __CPROVER_DUMP_L7:
      ;
      if(!(readonly == 0))
        return (unsigned int)3;

      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("O_WRONLY");

      while((_Bool)0);
      open_flags = 01;
      if(!((131208u & desired_access) == 0u))
        return (unsigned int)3;

      goto __CPROVER_DUMP_L15;

    __CPROVER_DUMP_L11:
      ;
      if(!(readonly == 0))
        return (unsigned int)3;

      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("O_RDWR");

      while((_Bool)0);
      open_flags = 02;
      goto __CPROVER_DUMP_L15;
    }
    fatal("bitwise operators have broken");

  __CPROVER_DUMP_L15:
    ;
    if(!((524288u & desired_access) == 0u))
    {
      return_value_getuid_1=getuid();
      if(return_value_getuid_1 == 0u)
        goto __CPROVER_DUMP_L16;

      return (unsigned int)3;
    }

    else
    {

    __CPROVER_DUMP_L16:
      ;
      open_flags = open_flags | 0400;
      if(!((24u & flags) == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("O_APPEND");

        while((_Bool)0);
        open_flags = open_flags | 02000;
        sftp_generic_open__1__sftp_handle_flags = sftp_generic_open__1__sftp_handle_flags | (unsigned int)0x0002;
      }

      if(!((32u & flags) == 0u))
        sftp_generic_open__1__sftp_handle_flags = sftp_generic_open__1__sftp_handle_flags | (unsigned int)0x0001;

      if(!((448u & flags) == 0u))
        return (unsigned int)8;

      else
      {
        if(!((1024u & flags) == 0u))
        {
          open_flags = open_flags | 0400000;
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("O_NOFOLLOW");

          while((_Bool)0);
        }

        if(!((4u & attrs->valid) == 0u))
        {
          initial_permissions = attrs->permissions & (unsigned int)07777;
          if(attrs->permissions == (511u & attrs->permissions))
            attrs->valid = attrs->valid ^ (unsigned int)0x00000004;

          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("using initial permission %#o", (unsigned int)initial_permissions);

          while((_Bool)0);
        }

        else
          initial_permissions = (unsigned int)(0755 & 0666);
        if(!(readonly == 0) && (!((7u & flags) == 2u) || !((2048u & flags) == 0u)))
          return (unsigned int)3;

        else
        {
          switch(flags & (unsigned int)0x00000007)
          {
            case (unsigned int)0x00000000:
            {
              if(!((1024u & flags) == 0u))
              {
                do
                  if(!(sftp_debugging == 0))
                    sftp_debug_printf("SSH_FXF_CREATE_NEW|SSH_FXF_NOFOLLOW -> O_CREAT|O_EXCL");

                while((_Bool)0);
                fd=open(path, open_flags | 0100 | 0200, initial_permissions);
                created = 1;
              }

              else
              {
                do
                  if(!(sftp_debugging == 0))
                    sftp_debug_printf("SSH_FXF_CREATE_NEW -> test for existence");

                while((_Bool)0);
                signed int return_value_stat_2;
                return_value_stat_2=stat(path, &sb);
                if(return_value_stat_2 == 0)
                  return (unsigned int)11;

                do
                  if(!(sftp_debugging == 0))
                    sftp_debug_printf("SSH_FXF_CREATE_NEW -> O_CREAT");

                while((_Bool)0);
                fd=open(path, open_flags | 0100, initial_permissions);
                created = 1;
              }
              break;
            }
            case (unsigned int)0x00000001:

            case (unsigned int)0x00000003:
            {
              if((7u & flags) == 1u)
              {
                do
                  if(!(sftp_debugging == 0))
                    sftp_debug_printf("SSH_FXF_CREATE_TRUNCATE -> O_TRUNC");

                while((_Bool)0);
                open_flags = open_flags | 01000;
              }

              else
                do
                  if(!(sftp_debugging == 0))
                    sftp_debug_printf("SSH_FXF_OPEN_OR_TRUNCATE -> not O_TRUNC");

                while((_Bool)0);
              if(!((1024u & flags) == 0u))
              {
                do
                  if(!(sftp_debugging == 0))
                    sftp_debug_printf("SSH_FXF_*|SSH_FXF_NOFOLLOW -> O_CREAT|O_EXCL");

                while((_Bool)0);
                fd=open(path, open_flags | 0100 | 0200, initial_permissions);
                if(fd >= 0)
                  created = 1;

                else
                {
                  return_value___errno_location_4=__errno_location();
                  if(*return_value___errno_location_4 == 17)
                  {
                    do
                      if(!(sftp_debugging == 0))
                        sftp_debug_printf("SSH_FXF_*|SSH_FXF_NOFOLLOW -> EEXIST");

                    while((_Bool)0);
                    signed int return_value_lstat_3;
                    return_value_lstat_3=lstat(path, &sb);
                    if(!(return_value_lstat_3 >= 0))
                      return (unsigned int)-2;

                    if((61440u & sb.st_mode) == 40960u)
                      return (unsigned int)21;

                    fd=open(path, open_flags, initial_permissions);
                    created = 0;
                  }

                  else
                    created = 0;
                }
              }

              else
              {
                do
                  if(!(sftp_debugging == 0))
                    sftp_debug_printf("SSH_FXF_* -> test for existence");

                while((_Bool)0);
                signed int return_value_stat_5;
                return_value_stat_5=stat(path, &sb);
                if(return_value_stat_5 == 0)
                {
                  do
                    if(!(sftp_debugging == 0))
                      sftp_debug_printf("SSH_FXF_* -> open");

                  while((_Bool)0);
                  fd=open(path, open_flags, initial_permissions);
                  created = 0;
                }

                else
                {
                  do
                    if(!(sftp_debugging == 0))
                      sftp_debug_printf("SSH_FXF_* -> O_CREAT");

                  while((_Bool)0);
                  fd=open(path, open_flags | 0100, initial_permissions);
                  created = 0;
                }
              }
              break;
            }
            case (unsigned int)0x00000002:
            {
              if(!((1024u & flags) == 0u))
              {
                do
                  if(!(sftp_debugging == 0))
                    sftp_debug_printf("emulating O_NOFOLLOW");

                while((_Bool)0);
                signed int return_value_lstat_6;
                return_value_lstat_6=lstat(path, &sb);
                if(return_value_lstat_6 == 0)
                {
                  if((61440u & sb.st_mode) == 40960u)
                    return (unsigned int)21;

                }

              }

              do
                if(!(sftp_debugging == 0))
                  sftp_debug_printf("SSH_FXF_OPEN_EXISTING -> open");

              while((_Bool)0);
              fd=open(path, open_flags, initial_permissions);
              created = 0;
              break;
            }
            case (unsigned int)0x00000004:
            {
              if(!((1024u & flags) == 0u))
              {
                do
                  if(!(sftp_debugging == 0))
                    sftp_debug_printf("emulating O_NOFOLLOW");

                while((_Bool)0);
                signed int return_value_lstat_7;
                return_value_lstat_7=lstat(path, &sb);
                if(return_value_lstat_7 == 0)
                {
                  if((61440u & sb.st_mode) == 40960u)
                    return (unsigned int)21;

                }

              }

              do
                if(!(sftp_debugging == 0))
                  sftp_debug_printf("SSH_FXF_TRUNCATE_EXISTING -> O_TRUNC");

              while((_Bool)0);
              fd=open(path, open_flags | 01000, initial_permissions);
              created = 0;
              break;
            }
            default:
              return (unsigned int)8;
          }
          if(fd >= 0)
          {
            return_value_fstat_8=fstat(fd, &sb);
            if(!(return_value_fstat_8 == 0))
              goto __CPROVER_DUMP_L75;

            if(!((61440u & sb.st_mode) == 16384u))
              goto __CPROVER_DUMP_L75;

            close(fd);
            return (unsigned int)24;
          }

          else
          {

          __CPROVER_DUMP_L75:
            ;
            if(!(fd >= 0))
            {
              if((7u & flags) == 2u || (7u & flags) == 4u)
              {
                return_value___errno_location_12=__errno_location();
                if(*return_value___errno_location_12 == 2)
                {
                  const char *return_value_sftp_dirname_9;
                  return_value_sftp_dirname_9=sftp_dirname(job->a, path);
                  signed int return_value_lstat_10;
                  return_value_lstat_10=lstat(return_value_sftp_dirname_9, &sb);
                  if(!(return_value_lstat_10 >= 0))
                    return (unsigned int)10;

                  signed int *return_value___errno_location_11;
                  return_value___errno_location_11=__errno_location();
                  *return_value___errno_location_11 = 2;
                }

              }

              if(!((1024u & flags) == 0u))
              {
                return_value___errno_location_14=__errno_location();
                if(*return_value___errno_location_14 == 2)
                  tmp_if_expr_16 = (_Bool)1;

                else
                {
                  return_value___errno_location_15=__errno_location();
                  tmp_if_expr_16 = *return_value___errno_location_15 == 17 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_16)
                {
                  signed int return_value_lstat_13;
                  return_value_lstat_13=lstat(path, &sb);
                  if(!(return_value_lstat_13 >= 0))
                    return (unsigned int)-2;

                  if((61440u & sb.st_mode) == 40960u)
                    return (unsigned int)21;

                }

              }

              return (unsigned int)-2;
            }

            if(!(created == 0))
            {
              if(!(attrs->valid == 0u))
              {
                rc=sftp_set_fstatus(job->a, fd, attrs, ((const char **)NULL));
                if(!(rc == 0u))
                {
                  signed int save_errno;
                  signed int *return_value___errno_location_17;
                  return_value___errno_location_17=__errno_location();
                  save_errno = *return_value___errno_location_17;
                  close(fd);
                  unlink(path);
                  signed int *return_value___errno_location_18;
                  return_value___errno_location_18=__errno_location();
                  *return_value___errno_location_18 = save_errno;
                  return rc;
                }

              }

            }

            if(!((2048u & flags) == 0u))
            {
              do
                if(!(sftp_debugging == 0))
                  sftp_debug_printf("SSH_FXF_DELETE_ON_CLOSE");

              while((_Bool)0);
              unlink(path);
            }

            sftp_handle_new_file(&id, fd, path, sftp_generic_open__1__sftp_handle_flags);
            do
              if(!(sftp_debugging == 0))
                sftp_debug_printf("...handle is %u %u", id.id, id.tag);

            while((_Bool)0);
            sftp_send_begin(job->worker);
            sftp_send_uint8(job->worker, 102);
            sftp_send_uint32(job->worker, job->id);
            sftp_send_handle(job->worker, &id);
            sftp_send_end(job->worker);
            return (unsigned int)-1;
          }
        }
      }
    }
  }
}

// sftp_getcwd
// file utils.h line 167
char * sftp_getcwd(struct allocator *a)
{
  char *buffer = ((char *)NULL);
  unsigned long int size = (unsigned long int)32;
  unsigned long int oldsize = (unsigned long int)0;
  signed int *return_value___errno_location_4;
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  do
  {
    void *return_value_sftp_alloc_more_1;
    return_value_sftp_alloc_more_1=sftp_alloc_more(a, (void *)buffer, oldsize, size);
    buffer = (char *)return_value_sftp_alloc_more_1;
    char *return_value_getcwd_5;
    return_value_getcwd_5=getcwd(buffer, size);
    if(!(return_value_getcwd_5 == ((char *)NULL)))
      return buffer;

    else
    {
      return_value___errno_location_4=__errno_location();
      if(!(*return_value___errno_location_4 == 34))
      {
        do
          if(!(sftp_debugging == 0))
          {
            return_value___errno_location_2=__errno_location();
            return_value_strerror_3=strerror(*return_value___errno_location_2);
            sftp_debug_printf("getcwd returned error %s", return_value_strerror_3);
          }

        while((_Bool)0);
        return ((char *)NULL);
      }

    }
    oldsize = size;
    size = size * (unsigned long int)2;
  }
  while(!(size == 0ul));
  return ((char *)NULL);
}

// sftp_gid2name
// file users.c line 48
char * sftp_gid2name(struct allocator *a, unsigned int gid)
{
  char *s;
  struct group *gr;
  do
  {
    signed int sftp_gid2name__1__1__frc;
    sftp_gid2name__1__1__frc=pthread_mutex_lock(&user_lock);
    if(!(sftp_gid2name__1__1__frc == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(sftp_gid2name__1__1__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"users.c", 52, (const void *)"pthread_mutex_lock(&user_lock)", return_value_strerror_1);
      exit(1);
    }

  }
  while((_Bool)0);
  gr=getgrgid(gid);
  unsigned long int return_value_strlen_2;
  void *return_value_sftp_alloc_3;
  if(!(gr == ((struct group *)NULL)))
  {
    return_value_strlen_2=strlen(gr->gr_name);
    return_value_sftp_alloc_3=sftp_alloc(a, return_value_strlen_2 + (unsigned long int)1);
    s=strcpy((char *)return_value_sftp_alloc_3, gr->gr_name);
  }

  else
    s = ((char *)NULL);
  do
  {
    signed int frc;
    frc=pthread_mutex_unlock(&user_lock);
    if(!(frc == 0))
    {
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"users.c", 57, (const void *)"pthread_mutex_unlock(&user_lock)", return_value_strerror_4);
      exit(1);
    }

  }
  while((_Bool)0);
  return s;
}

// sftp_handle_close
// file handle.c line 137
unsigned int sftp_handle_close(struct handleid *id)
{
  unsigned int rc;
  do
  {
    signed int frc;
    frc=pthread_mutex_lock(&sftp_handle_lock);
    if(!(frc == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"handle.c", 140, (const void *)"pthread_mutex_lock(&sftp_handle_lock)", return_value_strerror_1);
      exit(1);
    }

  }
  while((_Bool)0);
  _Bool tmp_if_expr_4;
  if(!((unsigned long int)id->id >= nhandles))
    tmp_if_expr_4 = id->tag == (handles + (signed long int)id->id)->tag ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  signed int return_value_close_2;
  signed int return_value_closedir_3;
  if(tmp_if_expr_4)
  {
    (handles + (signed long int)id->id)->tag = (unsigned int)0;
    switch((handles + (signed long int)id->id)->type)
    {
      case 3:
      {
        return_value_close_2=close((handles + (signed long int)id->id)->u.fd);
        if(!(return_value_close_2 >= 0))
          rc = (unsigned int)-2;

        else
          rc = (unsigned int)0;
        break;
      }
      case 11:
      {
        return_value_closedir_3=closedir((handles + (signed long int)id->id)->u.dir);
        if(!(return_value_closedir_3 >= 0))
          rc = (unsigned int)-2;

        else
          rc = (unsigned int)0;
        break;
      }
      default:
        rc = (unsigned int)9;
    }
    free((void *)(handles + (signed long int)id->id)->path);
  }

  else
    rc = (unsigned int)9;
  do
  {
    signed int sftp_handle_close__1__3__frc;
    sftp_handle_close__1__3__frc=pthread_mutex_unlock(&sftp_handle_lock);
    if(!(sftp_handle_close__1__3__frc == 0))
    {
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(sftp_handle_close__1__3__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"handle.c", 164, (const void *)"pthread_mutex_unlock(&sftp_handle_lock)", return_value_strerror_5);
      exit(1);
    }

  }
  while((_Bool)0);
  return rc;
}

// sftp_handle_flags
// file handle.c line 168
unsigned int sftp_handle_flags(struct handleid *id)
{
  unsigned int rc;
  do
  {
    signed int frc;
    frc=pthread_mutex_lock(&sftp_handle_lock);
    if(!(frc == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"handle.c", 171, (const void *)"pthread_mutex_lock(&sftp_handle_lock)", return_value_strerror_1);
      exit(1);
    }

  }
  while((_Bool)0);
  _Bool tmp_if_expr_2;
  if(!((unsigned long int)id->id >= nhandles))
    tmp_if_expr_2 = id->tag == (handles + (signed long int)id->id)->tag ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    rc = (handles + (signed long int)id->id)->flags;

  else
    rc = (unsigned int)0;
  do
  {
    signed int sftp_handle_flags__1__2__frc;
    sftp_handle_flags__1__2__frc=pthread_mutex_unlock(&sftp_handle_lock);
    if(!(sftp_handle_flags__1__2__frc == 0))
    {
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(sftp_handle_flags__1__2__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"handle.c", 177, (const void *)"pthread_mutex_unlock(&sftp_handle_lock)", return_value_strerror_3);
      exit(1);
    }

  }
  while((_Bool)0);
  return rc;
}

// sftp_handle_get_dir
// file handle.c line 119
unsigned int sftp_handle_get_dir(struct handleid *id, struct __dirstream **dp, const char **pathp)
{
  unsigned int rc;
  do
  {
    signed int frc;
    frc=pthread_mutex_lock(&sftp_handle_lock);
    if(!(frc == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"handle.c", 123, (const void *)"pthread_mutex_lock(&sftp_handle_lock)", return_value_strerror_1);
      exit(1);
    }

  }
  while((_Bool)0);
  _Bool tmp_if_expr_2;
  if(!((unsigned long int)id->id >= nhandles))
    tmp_if_expr_2 = id->tag == (handles + (signed long int)id->id)->tag ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (handles + (signed long int)id->id)->type == 11 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  if(tmp_if_expr_3)
  {
    *dp = (handles + (signed long int)id->id)->u.dir;
    if(!(pathp == ((const char **)NULL)))
      *pathp = (handles + (signed long int)id->id)->path;

    rc = (unsigned int)0;
  }

  else
    rc = (unsigned int)9;
  do
  {
    signed int sftp_handle_get_dir__1__3__frc;
    sftp_handle_get_dir__1__3__frc=pthread_mutex_unlock(&sftp_handle_lock);
    if(!(sftp_handle_get_dir__1__3__frc == 0))
    {
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(sftp_handle_get_dir__1__3__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"handle.c", 133, (const void *)"pthread_mutex_unlock(&sftp_handle_lock)", return_value_strerror_4);
      exit(1);
    }

  }
  while((_Bool)0);
  return rc;
}

// sftp_handle_get_fd
// file handle.c line 101
unsigned int sftp_handle_get_fd(struct handleid *id, signed int *fd, unsigned int *flagsp)
{
  unsigned int rc;
  do
  {
    signed int frc;
    frc=pthread_mutex_lock(&sftp_handle_lock);
    if(!(frc == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"handle.c", 105, (const void *)"pthread_mutex_lock(&sftp_handle_lock)", return_value_strerror_1);
      exit(1);
    }

  }
  while((_Bool)0);
  _Bool tmp_if_expr_2;
  if(!((unsigned long int)id->id >= nhandles))
    tmp_if_expr_2 = id->tag == (handles + (signed long int)id->id)->tag ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (handles + (signed long int)id->id)->type == 3 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  if(tmp_if_expr_3)
  {
    *fd = (handles + (signed long int)id->id)->u.fd;
    if(!(flagsp == ((unsigned int *)NULL)))
      *flagsp = (handles + (signed long int)id->id)->flags;

    rc = (unsigned int)0;
  }

  else
    rc = (unsigned int)9;
  do
  {
    signed int sftp_handle_get_fd__1__3__frc;
    sftp_handle_get_fd__1__3__frc=pthread_mutex_unlock(&sftp_handle_lock);
    if(!(sftp_handle_get_fd__1__3__frc == 0))
    {
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(sftp_handle_get_fd__1__3__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"handle.c", 115, (const void *)"pthread_mutex_unlock(&sftp_handle_lock)", return_value_strerror_4);
      exit(1);
    }

  }
  while((_Bool)0);
  return rc;
}

// sftp_handle_new_dir
// file handle.c line 93
void sftp_handle_new_dir(struct handleid *id, struct __dirstream *dp, const char *path)
{
  do
  {
    signed int frc;
    frc=pthread_mutex_lock(&sftp_handle_lock);
    if(!(frc == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"handle.c", 94, (const void *)"pthread_mutex_lock(&sftp_handle_lock)", return_value_strerror_1);
      exit(1);
    }

  }
  while((_Bool)0);
  find_free_handle(id, 11);
  (handles + (signed long int)id->id)->u.dir = dp;
  (handles + (signed long int)id->id)->path=xstrdup(path);
  do
  {
    signed int sftp_handle_new_dir__1__2__frc;
    sftp_handle_new_dir__1__2__frc=pthread_mutex_unlock(&sftp_handle_lock);
    if(!(sftp_handle_new_dir__1__2__frc == 0))
    {
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(sftp_handle_new_dir__1__2__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"handle.c", 98, (const void *)"pthread_mutex_unlock(&sftp_handle_lock)", return_value_strerror_2);
      exit(1);
    }

  }
  while((_Bool)0);
}

// sftp_handle_new_file
// file handle.c line 83
void sftp_handle_new_file(struct handleid *id, signed int fd, const char *path, unsigned int flags)
{
  do
  {
    signed int frc;
    frc=pthread_mutex_lock(&sftp_handle_lock);
    if(!(frc == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"handle.c", 85, (const void *)"pthread_mutex_lock(&sftp_handle_lock)", return_value_strerror_1);
      exit(1);
    }

  }
  while((_Bool)0);
  find_free_handle(id, 3);
  (handles + (signed long int)id->id)->u.fd = fd;
  (handles + (signed long int)id->id)->path=xstrdup(path);
  (handles + (signed long int)id->id)->flags = flags;
  do
  {
    signed int sftp_handle_new_file__1__2__frc;
    sftp_handle_new_file__1__2__frc=pthread_mutex_unlock(&sftp_handle_lock);
    if(!(sftp_handle_new_file__1__2__frc == 0))
    {
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(sftp_handle_new_file__1__2__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"handle.c", 90, (const void *)"pthread_mutex_unlock(&sftp_handle_lock)", return_value_strerror_2);
      exit(1);
    }

  }
  while((_Bool)0);
}

// sftp_iconv
// file charset.c line 46
signed int sftp_iconv(struct allocator *a, void *cd, char **sp)
{
  const char * const sftp_iconv__1__input = *sp;
  unsigned long int inputsize;
  inputsize=strlen(sftp_iconv__1__input);
  unsigned long int outputsize;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(sftp_iconv__1__input);
  outputsize = (unsigned long int)2 * return_value_strlen_1 + (unsigned long int)1;
  unsigned long int rc;
  const char *inbuf;
  char *outbuf;
  char *output;
  unsigned long int inbytesleft;
  unsigned long int outbytesleft;
  /* assertion cd != 0 */
  assert(cd != NULL);
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  do
  {
    void *return_value_sftp_alloc_4;
    return_value_sftp_alloc_4=sftp_alloc(a, outputsize);
    output = (char *)return_value_sftp_alloc_4;
    iconv(cd, ((char ** restrict )NULL), ((unsigned long int *)NULL), ((char ** restrict )NULL), ((unsigned long int *)NULL));
    inbuf = sftp_iconv__1__input;
    inbytesleft = inputsize;
    outbuf = output;
    outbytesleft = outputsize;
    rc=iconv(cd, (char ** restrict )(void *)&inbuf, &inbytesleft, &outbuf, &outbytesleft);
    outputsize = outputsize * (unsigned long int)2;
    if(rc == 18446744073709551615ul)
    {
      return_value___errno_location_2=__errno_location();
      tmp_if_expr_3 = *return_value___errno_location_2 == 7 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
  }
  while(tmp_if_expr_3);
  if(rc == 18446744073709551615ul)
    return -1;

  else
  {
    *sp = output;
    return 0;
  }
}

// sftp_init
// file sftpclient.c line 327
static signed int sftp_init(void)
{
  unsigned int sftp_init__1__version;
  unsigned int u32;
  unsigned short int u16;
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 1);
  sftp_send_uint32(&fakeworker, (unsigned int)sftpversion);
  sftp_send_end(&fakeworker);
  unsigned char return_value_getresponse_1;
  return_value_getresponse_1=getresponse(2, (unsigned int)0, "SSH_FXP_INIT");
  signed int return_value_error_2;
  signed int return_value_error_3;
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  if(!((signed int)return_value_getresponse_1 == 2))
    return -1;

  else
  {
    do
    {
      unsigned int sftp_init__1__1__rc;
      sftp_init__1__1__rc=sftp_parse_uint32(&fakejob, &sftp_init__1__version);
      if(!(sftp_init__1__1__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 340, (const void *)"sftp_parse_uint32(&fakejob, &version)", sftp_init__1__1__rc);

        while((_Bool)0);
        fatal("error parsing response from server");
      }

    }
    while((_Bool)0);
    switch(sftp_init__1__version)
    {
      case (unsigned int)3:
      {
        protocol = &sftp_v3;
        break;
      }
      case (unsigned int)4:
      {
        protocol = &sftp_v4;
        break;
      }
      case (unsigned int)5:
      {
        protocol = &sftp_v5;
        break;
      }
      case (unsigned int)6:
      {
        protocol = &sftp_v6;
        break;
      }
      default:
      {
        return_value_error_2=error("server wanted protocol version %u", sftp_init__1__version);
        return return_value_error_2;
      }
    }
    attrmask = protocol->attrmask;
    while(!(fakejob.left == 0ul))
    {
      char *xname;
      char *xdata;
      unsigned long int xdatalen;
      do
      {
        unsigned int sftp_init__1__3__1__rc;
        sftp_init__1__3__1__rc=sftp_parse_string(&fakejob, &xname, ((unsigned long int *)NULL));
        if(!(sftp_init__1__3__1__rc == 0u))
        {
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 363, (const void *)"sftp_parse_string(&fakejob, &xname, 0)", sftp_init__1__3__1__rc);

          while((_Bool)0);
          fatal("error parsing response from server");
        }

      }
      while((_Bool)0);
      do
      {
        unsigned int sftp_init__1__3__2__rc;
        sftp_init__1__3__2__rc=sftp_parse_string(&fakejob, &xdata, &xdatalen);
        if(!(sftp_init__1__3__2__rc == 0u))
        {
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 364, (const void *)"sftp_parse_string(&fakejob, &xdata, &xdatalen)", sftp_init__1__3__2__rc);

          while((_Bool)0);
          fatal("error parsing response from server");
        }

      }
      while((_Bool)0);
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("server sent extension '%s'", xname);

      while((_Bool)0);
      signed int return_value_strcmp_11;
      return_value_strcmp_11=strcmp(xname, "newline");
      if(return_value_strcmp_11 == 0)
      {
        free((void *)newline);
        newline=xstrdup(xdata);
        if(*newline == 0)
        {
          return_value_error_3=error("cannot cope with empty newline sequence");
          return return_value_error_3;
        }

      }

      else
      {
        return_value_strcmp_10=strcmp(xname, "vendor-id");
        if(return_value_strcmp_10 == 0)
        {
          struct sftpjob xjob;
          char *vn;
          char *sn;
          char *sv;
          xjob.a = &allocator;
          xjob.ptr = (const unsigned char *)(void *)xdata;
          xjob.left = xdatalen;
          do
          {
            unsigned int sftp_init__1__3__5__1__rc;
            sftp_init__1__3__5__1__rc=sftp_parse_string(&xjob, &vn, ((unsigned long int *)NULL));
            if(!(sftp_init__1__3__5__1__rc == 0u))
            {
              do
                if(!(sftp_debugging == 0))
                  sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 380, (const void *)"sftp_parse_string(&xjob, &vn, 0)", sftp_init__1__3__5__1__rc);

              while((_Bool)0);
              fatal("error parsing response from server");
            }

          }
          while((_Bool)0);
          do
          {
            unsigned int sftp_init__1__3__5__2__rc;
            sftp_init__1__3__5__2__rc=sftp_parse_string(&xjob, &sn, ((unsigned long int *)NULL));
            if(!(sftp_init__1__3__5__2__rc == 0u))
            {
              do
                if(!(sftp_debugging == 0))
                  sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 381, (const void *)"sftp_parse_string(&xjob, &sn, 0)", sftp_init__1__3__5__2__rc);

              while((_Bool)0);
              fatal("error parsing response from server");
            }

          }
          while((_Bool)0);
          do
          {
            unsigned int sftp_init__1__3__5__3__rc;
            sftp_init__1__3__5__3__rc=sftp_parse_string(&xjob, &sv, ((unsigned long int *)NULL));
            if(!(sftp_init__1__3__5__3__rc == 0u))
            {
              do
                if(!(sftp_debugging == 0))
                  sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 382, (const void *)"sftp_parse_string(&xjob, &sv, 0)", sftp_init__1__3__5__3__rc);

              while((_Bool)0);
              fatal("error parsing response from server");
            }

          }
          while((_Bool)0);
          do
          {
            unsigned int sftp_init__1__3__5__4__rc;
            sftp_init__1__3__5__4__rc=sftp_parse_uint64(&xjob, &serverbuild);
            if(!(sftp_init__1__3__5__4__rc == 0u))
            {
              do
                if(!(sftp_debugging == 0))
                  sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 383, (const void *)"sftp_parse_uint64(&xjob, &serverbuild)", sftp_init__1__3__5__4__rc);

              while((_Bool)0);
              fatal("error parsing response from server");
            }

          }
          while((_Bool)0);
          free((void *)vendorname);
          vendorname=xstrdup(vn);
          free((void *)servername);
          servername=xstrdup(sn);
          free((void *)serverversion);
          serverversion=xstrdup(sv);
        }

        else
        {
          return_value_strcmp_9=strcmp(xname, "versions");
          if(return_value_strcmp_9 == 0)
          {
            free((void *)serverversions);
            serverversions=xstrdup(xdata);
          }

          else
          {
            return_value_strcmp_8=strcmp(xname, "symlink-order@rjk.greenend.org.uk");
            if(return_value_strcmp_8 == 0)
            {
              signed int return_value_strcmp_5;
              return_value_strcmp_5=strcmp(xdata, "targetpath-linkpath");
              if(return_value_strcmp_5 == 0)
                quirk_reverse_symlink = 1;

              else
              {
                return_value_strcmp_4=strcmp(xdata, "linkpath-targetpath");
                if(return_value_strcmp_4 == 0)
                  quirk_reverse_symlink = 0;

                else
                  error("unknown %s value '%s'", xname, xdata);
              }
            }

            else
            {
              return_value_strcmp_7=strcmp(xname, "supported");
              if(return_value_strcmp_7 == 0)
              {
                struct sftpjob sftp_init__1__3__8__xjob;
                sftp_init__1__3__8__xjob.a = &allocator;
                sftp_init__1__3__8__xjob.ptr = (const unsigned char *)(void *)xdata;
                sftp_init__1__3__8__xjob.left = xdatalen;
                do
                {
                  unsigned int sftp_init__1__3__8__1__rc;
                  sftp_init__1__3__8__1__rc=sftp_parse_uint32(&sftp_init__1__3__8__xjob, &attrmask);
                  if(!(sftp_init__1__3__8__1__rc == 0u))
                  {
                    do
                      if(!(sftp_debugging == 0))
                        sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 407, (const void *)"sftp_parse_uint32(&xjob, &attrmask)", sftp_init__1__3__8__1__rc);

                    while((_Bool)0);
                    fatal("error parsing response from server");
                  }

                }
                while((_Bool)0);
                do
                {
                  unsigned int rc;
                  rc=sftp_parse_uint32(&sftp_init__1__3__8__xjob, &u32);
                  if(!(rc == 0u))
                  {
                    do
                      if(!(sftp_debugging == 0))
                        sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 408, (const void *)"sftp_parse_uint32(&xjob, &u32)", rc);

                    while((_Bool)0);
                    fatal("error parsing response from server");
                  }

                }
                while((_Bool)0);
                do
                {
                  unsigned int sftp_init__1__3__8__3__rc;
                  sftp_init__1__3__8__3__rc=sftp_parse_uint32(&sftp_init__1__3__8__xjob, &u32);
                  if(!(sftp_init__1__3__8__3__rc == 0u))
                  {
                    do
                      if(!(sftp_debugging == 0))
                        sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 409, (const void *)"sftp_parse_uint32(&xjob, &u32)", sftp_init__1__3__8__3__rc);

                    while((_Bool)0);
                    fatal("error parsing response from server");
                  }

                }
                while((_Bool)0);
                do
                {
                  unsigned int sftp_init__1__3__8__4__rc;
                  sftp_init__1__3__8__4__rc=sftp_parse_uint32(&sftp_init__1__3__8__xjob, &u32);
                  if(!(sftp_init__1__3__8__4__rc == 0u))
                  {
                    do
                      if(!(sftp_debugging == 0))
                        sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 410, (const void *)"sftp_parse_uint32(&xjob, &u32)", sftp_init__1__3__8__4__rc);

                    while((_Bool)0);
                    fatal("error parsing response from server");
                  }

                }
                while((_Bool)0);
                do
                {
                  unsigned int sftp_init__1__3__8__5__rc;
                  sftp_init__1__3__8__5__rc=sftp_parse_uint32(&sftp_init__1__3__8__xjob, &u32);
                  if(!(sftp_init__1__3__8__5__rc == 0u))
                  {
                    do
                      if(!(sftp_debugging == 0))
                        sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 411, (const void *)"sftp_parse_uint32(&xjob, &u32)", sftp_init__1__3__8__5__rc);

                    while((_Bool)0);
                    fatal("error parsing response from server");
                  }

                }
                while((_Bool)0);
                while(!(sftp_init__1__3__8__xjob.left == 0ul))
                  do
                  {
                    unsigned int sftp_init__1__3__8__6__rc;
                    sftp_init__1__3__8__6__rc=sftp_parse_string(&sftp_init__1__3__8__xjob, ((char **)NULL), ((unsigned long int *)NULL));
                    if(!(sftp_init__1__3__8__6__rc == 0u))
                    {
                      do
                        if(!(sftp_debugging == 0))
                          sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 413, (const void *)"sftp_parse_string(&xjob, 0, 0)", sftp_init__1__3__8__6__rc);

                      while((_Bool)0);
                      fatal("error parsing response from server");
                    }

                  }
                  while((_Bool)0);
              }

              else
              {
                return_value_strcmp_6=strcmp(xname, "supported2");
                if(return_value_strcmp_6 == 0)
                {
                  struct sftpjob sftp_init__1__3__9__xjob;
                  sftp_init__1__3__9__xjob.a = &allocator;
                  sftp_init__1__3__9__xjob.ptr = (const unsigned char *)(void *)xdata;
                  sftp_init__1__3__9__xjob.left = xdatalen;
                  do
                  {
                    unsigned int sftp_init__1__3__9__1__rc;
                    sftp_init__1__3__9__1__rc=sftp_parse_uint32(&sftp_init__1__3__9__xjob, &attrmask);
                    if(!(sftp_init__1__3__9__1__rc == 0u))
                    {
                      do
                        if(!(sftp_debugging == 0))
                          sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 420, (const void *)"sftp_parse_uint32(&xjob, &attrmask)", sftp_init__1__3__9__1__rc);

                      while((_Bool)0);
                      fatal("error parsing response from server");
                    }

                  }
                  while((_Bool)0);
                  /* assertion !(attrmask & 0x00008000) */
                  assert(!((attrmask & (unsigned int)0x00008000) != 0u));
                  do
                  {
                    unsigned int sftp_init__1__3__9__2__rc;
                    sftp_init__1__3__9__2__rc=sftp_parse_uint32(&sftp_init__1__3__9__xjob, &u32);
                    if(!(sftp_init__1__3__9__2__rc == 0u))
                    {
                      do
                        if(!(sftp_debugging == 0))
                          sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 422, (const void *)"sftp_parse_uint32(&xjob, &u32)", sftp_init__1__3__9__2__rc);

                      while((_Bool)0);
                      fatal("error parsing response from server");
                    }

                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned int sftp_init__1__3__9__3__rc;
                    sftp_init__1__3__9__3__rc=sftp_parse_uint32(&sftp_init__1__3__9__xjob, &u32);
                    if(!(sftp_init__1__3__9__3__rc == 0u))
                    {
                      do
                        if(!(sftp_debugging == 0))
                          sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 423, (const void *)"sftp_parse_uint32(&xjob, &u32)", sftp_init__1__3__9__3__rc);

                      while((_Bool)0);
                      fatal("error parsing response from server");
                    }

                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned int sftp_init__1__3__9__4__rc;
                    sftp_init__1__3__9__4__rc=sftp_parse_uint32(&sftp_init__1__3__9__xjob, &u32);
                    if(!(sftp_init__1__3__9__4__rc == 0u))
                    {
                      do
                        if(!(sftp_debugging == 0))
                          sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 424, (const void *)"sftp_parse_uint32(&xjob, &u32)", sftp_init__1__3__9__4__rc);

                      while((_Bool)0);
                      fatal("error parsing response from server");
                    }

                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned int sftp_init__1__3__9__5__rc;
                    sftp_init__1__3__9__5__rc=sftp_parse_uint32(&sftp_init__1__3__9__xjob, &u32);
                    if(!(sftp_init__1__3__9__5__rc == 0u))
                    {
                      do
                        if(!(sftp_debugging == 0))
                          sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 425, (const void *)"sftp_parse_uint32(&xjob, &u32)", sftp_init__1__3__9__5__rc);

                      while((_Bool)0);
                      fatal("error parsing response from server");
                    }

                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned int sftp_init__1__3__9__6__rc;
                    sftp_init__1__3__9__6__rc=sftp_parse_uint16(&sftp_init__1__3__9__xjob, &u16);
                    if(!(sftp_init__1__3__9__6__rc == 0u))
                    {
                      do
                        if(!(sftp_debugging == 0))
                          sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 426, (const void *)"sftp_parse_uint16(&xjob, &u16)", sftp_init__1__3__9__6__rc);

                      while((_Bool)0);
                      fatal("error parsing response from server");
                    }

                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned int sftp_init__1__3__9__7__rc;
                    sftp_init__1__3__9__7__rc=sftp_parse_uint16(&sftp_init__1__3__9__xjob, &u16);
                    if(!(sftp_init__1__3__9__7__rc == 0u))
                    {
                      do
                        if(!(sftp_debugging == 0))
                          sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 427, (const void *)"sftp_parse_uint16(&xjob, &u16)", sftp_init__1__3__9__7__rc);

                      while((_Bool)0);
                      fatal("error parsing response from server");
                    }

                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned int sftp_init__1__3__9__8__rc;
                    sftp_init__1__3__9__8__rc=sftp_parse_uint32(&sftp_init__1__3__9__xjob, &u32);
                    if(!(sftp_init__1__3__9__8__rc == 0u))
                    {
                      do
                        if(!(sftp_debugging == 0))
                          sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 428, (const void *)"sftp_parse_uint32(&xjob, &u32)", sftp_init__1__3__9__8__rc);

                      while((_Bool)0);
                      fatal("error parsing response from server");
                    }

                  }
                  while((_Bool)0);
                  for( ; u32 >= 1u; u32 = u32 - 1u)
                    do
                    {
                      unsigned int sftp_init__1__3__9__9__1__rc;
                      sftp_init__1__3__9__9__1__rc=sftp_parse_string(&sftp_init__1__3__9__xjob, ((char **)NULL), ((unsigned long int *)NULL));
                      if(!(sftp_init__1__3__9__9__1__rc == 0u))
                      {
                        do
                          if(!(sftp_debugging == 0))
                            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 430, (const void *)"sftp_parse_string(&xjob, 0, 0)", sftp_init__1__3__9__9__1__rc);

                        while((_Bool)0);
                        fatal("error parsing response from server");
                      }

                    }
                    while((_Bool)0);
                  do
                  {
                    unsigned int sftp_init__1__3__9__10__rc;
                    sftp_init__1__3__9__10__rc=sftp_parse_uint32(&sftp_init__1__3__9__xjob, &u32);
                    if(!(sftp_init__1__3__9__10__rc == 0u))
                    {
                      do
                        if(!(sftp_debugging == 0))
                          sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 433, (const void *)"sftp_parse_uint32(&xjob, &u32)", sftp_init__1__3__9__10__rc);

                      while((_Bool)0);
                      fatal("error parsing response from server");
                    }

                  }
                  while((_Bool)0);
                  for( ; u32 >= 1u; u32 = u32 - 1u)
                    do
                    {
                      unsigned int sftp_init__1__3__9__11__1__rc;
                      sftp_init__1__3__9__11__1__rc=sftp_parse_string(&sftp_init__1__3__9__xjob, ((char **)NULL), ((unsigned long int *)NULL));
                      if(!(sftp_init__1__3__9__11__1__rc == 0u))
                      {
                        do
                          if(!(sftp_debugging == 0))
                            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 435, (const void *)"sftp_parse_string(&xjob, 0, 0)", sftp_init__1__3__9__11__1__rc);

                        while((_Bool)0);
                        fatal("error parsing response from server");
                      }

                    }
                    while((_Bool)0);
                }

              }
            }
          }
        }
      }
    }
    unsigned long int return_value_strlen_12;
    return_value_strlen_12=strlen(newline);
    if(!(buffersize >= return_value_strlen_12))
      buffersize=strlen(newline);

    return 0;
  }
}

// sftp_link
// file sftpclient.c line 696
static signed int sftp_link(const char *targetpath, const char *linkpath, signed int sftp_send_symlink)
{
  unsigned int id;
  signed int return_value_error_1;
  const char *tmp_if_expr_5;
  const char *return_value_makeabspath_4;
  if(!(protocol->version >= 6))
  {
    if(!(sftp_send_symlink == 0))
      goto __CPROVER_DUMP_L1;

    return_value_error_1=error("hard links not supported in protocol %u", protocol->version);
    return return_value_error_1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    remote_cwd();
    sftp_send_begin(&fakeworker);
    sftp_send_uint8(&fakeworker, protocol->version >= 6 ? 21 : 20);
    id=newid();
    sftp_send_uint32(&fakeworker, id);
    if(!(quirk_reverse_symlink == 0))
    {
      sftp_send_path(&fakejob, &fakeworker, targetpath);
      const char *return_value_makeabspath_2;
      return_value_makeabspath_2=makeabspath(linkpath);
      sftp_send_path(&fakejob, &fakeworker, return_value_makeabspath_2);
    }

    else
    {
      const char *return_value_makeabspath_3;
      return_value_makeabspath_3=makeabspath(linkpath);
      sftp_send_path(&fakejob, &fakeworker, return_value_makeabspath_3);
      if(!(sftp_send_symlink == 0))
        tmp_if_expr_5 = targetpath;

      else
      {
        return_value_makeabspath_4=makeabspath(targetpath);
        tmp_if_expr_5 = return_value_makeabspath_4;
      }
      sftp_send_path(&fakejob, &fakeworker, tmp_if_expr_5);
    }
    if(protocol->version >= 6)
      sftp_send_uint8(&fakeworker, (signed int)!(!(sftp_send_symlink != 0)));

    sftp_send_end(&fakeworker);
    getresponse(101, id, "SSH_FXP_*LINK");
    signed int return_value_status_6;
    return_value_status_6=status();
    return return_value_status_6;
  }
}

// sftp_mbs2wcs
// file charset.h line 33
signed int * sftp_mbs2wcs(const char *s)
{
  signed int *ws;
  unsigned long int len;
  struct anonymous_6 ps;
  memset((void *)&ps, 0, sizeof(struct anonymous_6) /*8ul*/ );
  len=mbsrtowcs(((signed int *)NULL), &s, (unsigned long int)0, &ps);
  if(len == 18446744073709551615ul)
    return ((signed int *)NULL);

  else
  {
    void *return_value_xcalloc_1;
    return_value_xcalloc_1=xcalloc(len + (unsigned long int)1, sizeof(signed int) /*4ul*/ );
    ws = (signed int *)return_value_xcalloc_1;
    memset((void *)&ps, 0, sizeof(struct anonymous_6) /*8ul*/ );
    mbsrtowcs(ws, &s, len, &ps);
    return ws;
  }
}

// sftp_mkdir
// file sftpclient.c line 826
static signed int sftp_mkdir(const char *path, unsigned int mode)
{
  struct sftpattr attrs;
  unsigned int id;
  remote_cwd();
  if(mode == 4294967295u)
    attrs.valid = (unsigned int)0;

  else
  {
    attrs.valid = (unsigned int)0x00000004;
    attrs.permissions = mode;
  }
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 14);
  id=newid();
  sftp_send_uint32(&fakeworker, id);
  const char *return_value_makeabspath_1;
  return_value_makeabspath_1=makeabspath(path);
  sftp_send_path(&fakejob, &fakeworker, return_value_makeabspath_1);
  protocol->sendattrs(&fakejob, &attrs);
  sftp_send_end(&fakeworker);
  getresponse(101, id, "SSH_FXP_MKDIR");
  signed int return_value_status_2;
  return_value_status_2=status();
  return return_value_status_2;
}

// sftp_name2gid
// file users.c line 74
unsigned int sftp_name2gid(const char *name)
{
  struct group *gr;
  unsigned int gid;
  do
  {
    signed int sftp_name2gid__1__1__frc;
    sftp_name2gid__1__1__frc=pthread_mutex_lock(&user_lock);
    if(!(sftp_name2gid__1__1__frc == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(sftp_name2gid__1__1__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"users.c", 78, (const void *)"pthread_mutex_lock(&user_lock)", return_value_strerror_1);
      exit(1);
    }

  }
  while((_Bool)0);
  gr=getgrnam(name);
  if(!(gr == ((struct group *)NULL)))
    gid = gr->gr_gid;

  else
    gid = (unsigned int)-1;
  do
  {
    signed int frc;
    frc=pthread_mutex_unlock(&user_lock);
    if(!(frc == 0))
    {
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"users.c", 83, (const void *)"pthread_mutex_unlock(&user_lock)", return_value_strerror_2);
      exit(1);
    }

  }
  while((_Bool)0);
  return gid;
}

// sftp_name2uid
// file users.c line 61
unsigned int sftp_name2uid(const char *name)
{
  struct passwd *pw;
  unsigned int uid;
  do
  {
    signed int frc;
    frc=pthread_mutex_lock(&user_lock);
    if(!(frc == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"users.c", 65, (const void *)"pthread_mutex_lock(&user_lock)", return_value_strerror_1);
      exit(1);
    }

  }
  while((_Bool)0);
  pw=getpwnam(name);
  if(!(pw == ((struct passwd *)NULL)))
    uid = pw->pw_uid;

  else
    uid = (unsigned int)-1;
  do
  {
    signed int sftp_name2uid__1__2__frc;
    sftp_name2uid__1__2__frc=pthread_mutex_unlock(&user_lock);
    if(!(sftp_name2uid__1__2__frc == 0))
    {
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(sftp_name2uid__1__2__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"users.c", 70, (const void *)"pthread_mutex_unlock(&user_lock)", return_value_strerror_2);
      exit(1);
    }

  }
  while((_Bool)0);
  return uid;
}

// sftp_normalize_ownergroup
// file stat.h line 67
unsigned int sftp_normalize_ownergroup(struct allocator *a, struct sftpattr *attrs)
{
  unsigned int rc = (unsigned int)0;
  switch(attrs->valid & (unsigned int)(0x00000002 | 0x00000080))
  {
    case (unsigned int)0x00000002:
    {
      attrs->owner=sftp_uid2name(a, attrs->uid);
      if(!(attrs->owner == ((char *)NULL)))
      {
        attrs->group=sftp_gid2name(a, attrs->gid);
        if(!(attrs->group == ((char *)NULL)))
          attrs->valid = attrs->valid | (unsigned int)0x00000080;

      }

      break;
    }
    case (unsigned int)0x00000080:
    {
      attrs->uid=sftp_name2uid(attrs->owner);
      if(attrs->uid == 4294967295u)
        rc = (unsigned int)29;

      attrs->gid=sftp_name2gid(attrs->group);
      if(attrs->gid == 4294967295u)
        rc = (unsigned int)30;

      if(rc == 0u)
        attrs->valid = attrs->valid | (unsigned int)0x00000002;

    }
  }
  return rc;
}

// sftp_open
// file sftpclient.c line 726
static signed int sftp_open(const char *path, unsigned int desired_access, unsigned int flags, struct sftpattr *attrs, struct client_handle *hp)
{
  unsigned int id;
  unsigned int pflags = (unsigned int)0;
  remote_cwd();
  signed int return_value_error_1;
  signed int return_value_error_2;
  signed int return_value_error_3;
  if(!(protocol->version >= 5))
  {
    if(!((1u & desired_access) == 0u))
      pflags = pflags | (unsigned int)0x00000001;

    if(!((2u & desired_access) == 0u))
      pflags = pflags | (unsigned int)0x00000002;

    switch(flags & (unsigned int)0x00000007)
    {
      case (unsigned int)0x00000000:
      {
        pflags = pflags | (unsigned int)(0x00000008 | 0x00000020);
        break;
      }
      case (unsigned int)0x00000001:
      {
        pflags = pflags | (unsigned int)(0x00000008 | 0x00000010);
        break;
      }
      case (unsigned int)0x00000003:
      {
        pflags = pflags | (unsigned int)0x00000008;
        break;
      }
      case (unsigned int)0x00000002:
        break;
      case (unsigned int)0x00000004:
      {
        pflags = pflags | (unsigned int)0x00000010;
        break;
      }
      default:
      {
        return_value_error_1=error("unknown SSH_FXF_ACCESS_DISPOSITION %#x", flags);
        return return_value_error_1;
      }
    }
    if(!((24u & flags) == 0u))
      pflags = pflags | (unsigned int)0x00000004;

    if(!((32u & flags) == 0u))
    {
      if(!(protocol->version >= 4))
      {
        return_value_error_2=error("SSH_FXF_TEXT_MODE cannot be emulated in protocol %d", protocol->version);
        return return_value_error_2;
      }

      else
        pflags = pflags | (unsigned int)0x00000040;
    }

    if(!((4294967232u & flags) == 0u))
    {
      return_value_error_3=error("future SSH_FXP_OPEN flags (%#x) cannot be emulated in protocol %d", flags, protocol->version);
      return return_value_error_3;
    }

    sftp_send_begin(&fakeworker);
    sftp_send_uint8(&fakeworker, 3);
    id=newid();
    sftp_send_uint32(&fakeworker, id);
    const char *return_value_makeabspath_4;
    return_value_makeabspath_4=makeabspath(path);
    sftp_send_path(&fakejob, &fakeworker, return_value_makeabspath_4);
    sftp_send_uint32(&fakeworker, pflags);
    protocol->sendattrs(&fakejob, attrs);
    sftp_send_end(&fakeworker);
  }

  else
  {
    sftp_send_begin(&fakeworker);
    sftp_send_uint8(&fakeworker, 3);
    id=newid();
    sftp_send_uint32(&fakeworker, id);
    const char *return_value_makeabspath_5;
    return_value_makeabspath_5=makeabspath(path);
    sftp_send_path(&fakejob, &fakeworker, return_value_makeabspath_5);
    sftp_send_uint32(&fakeworker, desired_access);
    sftp_send_uint32(&fakeworker, flags);
    protocol->sendattrs(&fakejob, attrs);
    sftp_send_end(&fakeworker);
  }
  unsigned char return_value_getresponse_6;
  return_value_getresponse_6=getresponse(102, id, "SSH_FXP_OPEN");
  if(!((signed int)return_value_getresponse_6 == 102))
    return -1;

  else
  {
    unsigned int rc;
    rc=sftp_parse_string(&fakejob, &hp->data, &hp->len);
    if(!(rc == 0u))
    {
      if(!(sftp_debugging == 0))
        sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 792, (const void *)"sftp_parse_string(&fakejob, &hp->data, &hp->len)", rc);

      fatal("error parsing response from server");
    }

    return 0;
  }
}

// sftp_opendir
// file sftpclient.c line 528
static signed int sftp_opendir(const char *path, struct client_handle *hp)
{
  unsigned int id;
  remote_cwd();
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 11);
  id=newid();
  sftp_send_uint32(&fakeworker, id);
  const char *return_value_makeabspath_1;
  return_value_makeabspath_1=makeabspath(path);
  sftp_send_path(&fakejob, &fakeworker, return_value_makeabspath_1);
  sftp_send_end(&fakeworker);
  unsigned char return_value_getresponse_2;
  return_value_getresponse_2=getresponse(102, id, "SSH_FXP_OPENDIR");
  if(!((signed int)return_value_getresponse_2 == 102))
    return -1;

  else
  {
    do
    {
      unsigned int rc;
      rc=sftp_parse_string(&fakejob, &hp->data, &hp->len);
      if(!(rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 539, (const void *)"sftp_parse_string(&fakejob, &hp->data, &hp->len)", rc);

        while((_Bool)0);
        fatal("error parsing response from server");
      }

    }
    while((_Bool)0);
    return 0;
  }
}

// sftp_parse_handle
// file parse.c line 97
unsigned int sftp_parse_handle(struct sftpjob *job, struct handleid *id)
{
  unsigned int len;
  unsigned int rc;
  rc=sftp_parse_uint32(job, &len);
  _Bool tmp_if_expr_1;
  if(!(len == 8u) || !(rc == 0u))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    rc=sftp_parse_uint32(job, &id->id);
    tmp_if_expr_1 = rc != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_3;
  unsigned int return_value_sftp_parse_uint32_2;
  if(tmp_if_expr_1)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_sftp_parse_uint32_2=sftp_parse_uint32(job, &id->tag);
    rc = (unsigned int)(return_value_sftp_parse_uint32_2 != (unsigned int)0);
    tmp_if_expr_3 = rc != 0u ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
    return rc;

  else
    return (unsigned int)0;
}

// sftp_parse_path
// file parse.h line 76
unsigned int sftp_parse_path(struct sftpjob *job, char **strp)
{
  unsigned int rc;
  rc=sftp_parse_string(job, strp, ((unsigned long int *)NULL));
  if(!(rc == 0u))
    return rc;

  else
  {
    unsigned int return_value;
    return_value=protocol->decode(job, strp);
    return return_value;
  }
}

// sftp_parse_string
// file parse.h line 65
unsigned int sftp_parse_string(struct sftpjob *job, char **strp, unsigned long int *lenp)
{
  unsigned int len;
  unsigned int rc;
  char *str;
  rc=sftp_parse_uint32(job, &len);
  if(!(rc == 0u))
    return rc;

  else
    if(len == 0xFFFFFFFF)
      return (unsigned int)5;

    else
      if(!(job->left >= (unsigned long int)len))
        return (unsigned int)5;

      else
      {
        if(!(lenp == ((unsigned long int *)NULL)))
          *lenp = (unsigned long int)len;

        if(!(strp == ((char **)NULL)))
        {
          void *return_value_sftp_alloc_1;
          return_value_sftp_alloc_1=sftp_alloc(job->a, (unsigned long int)(len + (unsigned int)1));
          str = (char *)return_value_sftp_alloc_1;
          memcpy((void *)str, (const void *)job->ptr, (unsigned long int)len);
          *strp = str;
        }

        job->ptr = job->ptr + (signed long int)len;
        job->left = job->left - (unsigned long int)len;
        return (unsigned int)0;
      }
}

// sftp_parse_uint16
// file parse.h line 38
unsigned int sftp_parse_uint16(struct sftpjob *job, unsigned short int *ur)
{
  if(!(job->left >= 2ul))
    return (unsigned int)5;

  else
  {
    *ur=get16((const void *)job->ptr);
    job->ptr = job->ptr + (signed long int)2;
    job->left = job->left - (unsigned long int)2;
    return (unsigned int)0;
  }
}

// sftp_parse_uint32
// file parse.h line 45
unsigned int sftp_parse_uint32(struct sftpjob *job, unsigned int *ur)
{
  if(!(job->left >= 4ul))
    return (unsigned int)5;

  else
  {
    *ur=get32((const void *)job->ptr);
    job->ptr = job->ptr + (signed long int)4;
    job->left = job->left - (unsigned long int)4;
    return (unsigned int)0;
  }
}

// sftp_parse_uint64
// file parse.h line 52
unsigned int sftp_parse_uint64(struct sftpjob *job, unsigned long int *ur)
{
  if(!(job->left >= 8ul))
    return (unsigned int)5;

  else
  {
    *ur=get64((const void *)job->ptr);
    job->ptr = job->ptr + (signed long int)8;
    job->left = job->left - (unsigned long int)8;
    return (unsigned int)0;
  }
}

// sftp_parse_uint8
// file parse.h line 31
unsigned int sftp_parse_uint8(struct sftpjob *job, unsigned char *ur)
{
  const unsigned char *tmp_post_1;
  if(!(job->left >= 1ul))
    return (unsigned int)5;

  else
  {
    tmp_post_1 = job->ptr;
    job->ptr = job->ptr + 1l;
    *ur = *tmp_post_1;
    job->left = job->left - 1ul;
    return (unsigned int)0;
  }
}

// sftp_prename
// file sftpclient.c line 681
static signed int sftp_prename(const char *oldpath, const char *newpath)
{
  unsigned int id;
  remote_cwd();
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 200);
  id=newid();
  sftp_send_uint32(&fakeworker, id);
  sftp_send_string(&fakeworker, "posix-rename@openssh.org");
  const char *return_value_makeabspath_1;
  return_value_makeabspath_1=makeabspath(oldpath);
  sftp_send_path(&fakejob, &fakeworker, return_value_makeabspath_1);
  const char *return_value_makeabspath_2;
  return_value_makeabspath_2=makeabspath(newpath);
  sftp_send_path(&fakejob, &fakeworker, return_value_makeabspath_2);
  sftp_send_end(&fakeworker);
  getresponse(101, id, "posix-rename@openssh.org");
  signed int return_value_status_3;
  return_value_status_3=status();
  return return_value_status_3;
}

// sftp_readdir
// file sftpclient.c line 543
static signed int sftp_readdir(struct client_handle *hp, struct sftpattr **attrsp, unsigned long int *nattrsp)
{
  unsigned int id;
  unsigned int n;
  struct sftpattr *attrs;
  char *name;
  char *longname = ((char *)NULL);
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 12);
  id=newid();
  sftp_send_uint32(&fakeworker, id);
  sftp_send_bytes(&fakeworker, (const void *)hp->data, hp->len);
  sftp_send_end(&fakeworker);
  unsigned char return_value_getresponse_1;
  return_value_getresponse_1=getresponse(-1, id, "SSH_FXP_READDIR");
  void *return_value_sftp_alloc_2;
  switch((signed int)return_value_getresponse_1)
  {
    case 104:
    {
      do
      {
        unsigned int sftp_readdir__1__1__1__rc;
        sftp_readdir__1__1__1__rc=sftp_parse_uint32(&fakejob, &n);
        if(!(sftp_readdir__1__1__1__rc == 0u))
        {
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 557, (const void *)"sftp_parse_uint32(&fakejob, &n)", sftp_readdir__1__1__1__rc);

          while((_Bool)0);
          fatal("error parsing response from server");
        }

      }
      while((_Bool)0);
      if((unsigned long int)n >= 92233720368547759ul)
        fatal("too many attributes in SSH_FXP_READDIR response");

      return_value_sftp_alloc_2=sftp_alloc(fakejob.a, (unsigned long int)n * sizeof(struct sftpattr) /*200ul*/ );
      attrs = (struct sftpattr *)return_value_sftp_alloc_2;
      if(!(nattrsp == ((unsigned long int *)NULL)))
        *nattrsp = (unsigned long int)n;

      if(!(attrsp == ((struct sftpattr **)NULL)))
        *attrsp = attrs;

      if(n >= 1u)
      {
        do
        {
          unsigned int sftp_readdir__1__1__2__1__rc;
          sftp_readdir__1__1__2__1__rc=sftp_parse_path(&fakejob, &name);
          if(!(sftp_readdir__1__1__2__1__rc == 0u))
          {
            do
              if(!(sftp_debugging == 0))
                sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 566, (const void *)"sftp_parse_path(&fakejob, &name)", sftp_readdir__1__1__2__1__rc);

            while((_Bool)0);
            fatal("error parsing response from server");
          }

        }
        while((_Bool)0);
        if(!(protocol->version >= 4))
          do
          {
            unsigned int sftp_readdir__1__1__2__2__rc;
            sftp_readdir__1__1__2__2__rc=sftp_parse_path(&fakejob, &longname);
            if(!(sftp_readdir__1__1__2__2__rc == 0u))
            {
              do
                if(!(sftp_debugging == 0))
                  sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 568, (const void *)"sftp_parse_path(&fakejob, &longname)", sftp_readdir__1__1__2__2__rc);

              while((_Bool)0);
              fatal("error parsing response from server");
            }

          }
          while((_Bool)0);

        unsigned int sftp_readdir__1__1__2__3__rc;
        sftp_readdir__1__1__2__3__rc=protocol->parseattrs(&fakejob, attrs);
        if(!(sftp_readdir__1__1__2__3__rc == 0u))
        {
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 569, (const void *)"protocol->parseattrs(&fakejob, attrs)", sftp_readdir__1__1__2__3__rc);

          fatal("error parsing response from server");
        }

        attrs->name = name;
        attrs->longname = longname;
        attrs->wname=sftp_mbs2wcs(attrs->name);
        attrs = attrs + 1l;
        n = n - 1u;
      }

      return 0;
    }
    case 101:
    {
      do
      {
        unsigned int rc;
        rc=sftp_parse_uint32(&fakejob, &n);
        if(!(rc == 0u))
        {
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 578, (const void *)"sftp_parse_uint32(&fakejob, &n)", rc);

          while((_Bool)0);
          fatal("error parsing response from server");
        }

      }
      while((_Bool)0);
      if(n == 1u)
      {
        if(!(nattrsp == ((unsigned long int *)NULL)))
          *nattrsp = (unsigned long int)0;

        if(!(attrsp == ((struct sftpattr **)NULL)))
          *attrsp = ((struct sftpattr *)NULL);

        return 0;
      }

      status();
      return -1;
    }
    default:
      fatal("bogus response to SSH_FXP_READDIR");
  }
}

// sftp_readlink
// file sftpclient.c line 847
static char * sftp_readlink(const char *path)
{
  char *resolved;
  unsigned int u32;
  unsigned int id;
  remote_cwd();
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 19);
  id=newid();
  sftp_send_uint32(&fakeworker, id);
  const char *return_value_makeabspath_1;
  return_value_makeabspath_1=makeabspath(path);
  sftp_send_path(&fakejob, &fakeworker, return_value_makeabspath_1);
  sftp_send_end(&fakeworker);
  unsigned char return_value_getresponse_2;
  return_value_getresponse_2=getresponse(104, id, "SSH_FXP_READLINK");
  if(!((signed int)return_value_getresponse_2 == 104))
    return ((char *)NULL);

  else
  {
    do
    {
      unsigned int rc;
      rc=sftp_parse_uint32(&fakejob, &u32);
      if(!(rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 859, (const void *)"sftp_parse_uint32(&fakejob, &u32)", rc);

        while((_Bool)0);
        fatal("error parsing response from server");
      }

    }
    while((_Bool)0);
    if(!(u32 == 1u))
      fatal("wrong count in SSH_FXP_READLINK reply");

    do
    {
      unsigned int sftp_readlink__1__2__rc;
      sftp_readlink__1__2__rc=sftp_parse_path(&fakejob, &resolved);
      if(!(sftp_readlink__1__2__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 862, (const void *)"sftp_parse_path(&fakejob, &resolved)", sftp_readlink__1__2__rc);

        while((_Bool)0);
        fatal("error parsing response from server");
      }

    }
    while((_Bool)0);
    return resolved;
  }
}

// sftp_realpath
// file sftpclient.c line 446
static char * sftp_realpath(const char *path)
{
  char *resolved;
  unsigned int u32;
  unsigned int id;
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 16);
  id=newid();
  sftp_send_uint32(&fakeworker, id);
  sftp_send_path(&fakejob, &fakeworker, path);
  sftp_send_end(&fakeworker);
  unsigned char return_value_getresponse_1;
  return_value_getresponse_1=getresponse(104, id, "SSH_FXP_REALPATH");
  if(!((signed int)return_value_getresponse_1 == 104))
    return ((char *)NULL);

  else
  {
    do
    {
      unsigned int sftp_realpath__1__1__rc;
      sftp_realpath__1__1__rc=sftp_parse_uint32(&fakejob, &u32);
      if(!(sftp_realpath__1__1__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 457, (const void *)"sftp_parse_uint32(&fakejob, &u32)", sftp_realpath__1__1__rc);

        while((_Bool)0);
        fatal("error parsing response from server");
      }

    }
    while((_Bool)0);
    if(!(u32 == 1u))
      fatal("wrong count in SSH_FXP_REALPATH reply");

    do
    {
      unsigned int rc;
      rc=sftp_parse_path(&fakejob, &resolved);
      if(!(rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 460, (const void *)"sftp_parse_path(&fakejob, &resolved)", rc);

        while((_Bool)0);
        fatal("error parsing response from server");
      }

    }
    while((_Bool)0);
    return resolved;
  }
}

// sftp_realpath_v6
// file sftpclient.c line 464
static char * sftp_realpath_v6(const char *path, signed int control_byte, char **compose, struct sftpattr *attrs)
{
  char *resolved;
  unsigned int u32;
  unsigned int id;
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 16);
  id=newid();
  sftp_send_uint32(&fakeworker, id);
  sftp_send_path(&fakejob, &fakeworker, path);
  char **tmp_post_1;
  if(control_byte >= 0)
  {
    sftp_send_uint8(&fakeworker, control_byte);
    if(!(compose == ((char **)NULL)))
      while(!(*compose == ((char *)NULL)))
      {
        tmp_post_1 = compose;
        compose = compose + 1l;
        sftp_send_path(&fakejob, &fakeworker, *tmp_post_1);
      }

  }

  sftp_send_end(&fakeworker);
  unsigned char return_value_getresponse_2;
  return_value_getresponse_2=getresponse(104, id, "SSH_FXP_REALPATH");
  if(!((signed int)return_value_getresponse_2 == 104))
    return ((char *)NULL);

  else
  {
    do
    {
      unsigned int sftp_realpath_v6__1__2__rc;
      sftp_realpath_v6__1__2__rc=sftp_parse_uint32(&fakejob, &u32);
      if(!(sftp_realpath_v6__1__2__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 484, (const void *)"sftp_parse_uint32(&fakejob, &u32)", sftp_realpath_v6__1__2__rc);

        while((_Bool)0);
        fatal("error parsing response from server");
      }

    }
    while((_Bool)0);
    if(!(u32 == 1u))
      fatal("wrong count in SSH_FXP_REALPATH reply");

    do
    {
      unsigned int sftp_realpath_v6__1__3__rc;
      sftp_realpath_v6__1__3__rc=sftp_parse_path(&fakejob, &resolved);
      if(!(sftp_realpath_v6__1__3__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 487, (const void *)"sftp_parse_path(&fakejob, &resolved)", sftp_realpath_v6__1__3__rc);

        while((_Bool)0);
        fatal("error parsing response from server");
      }

    }
    while((_Bool)0);
    unsigned int rc;
    rc=protocol->parseattrs(&fakejob, attrs);
    if(!(rc == 0u))
    {
      if(!(sftp_debugging == 0))
        sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 488, (const void *)"protocol->parseattrs(&fakejob, attrs)", rc);

      fatal("error parsing response from server");
    }

    return resolved;
  }
}

// sftp_remove
// file sftpclient.c line 647
static signed int sftp_remove(const char *path)
{
  unsigned int id;
  remote_cwd();
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 13);
  id=newid();
  sftp_send_uint32(&fakeworker, id);
  const char *return_value_makeabspath_1;
  return_value_makeabspath_1=makeabspath(path);
  sftp_send_path(&fakejob, &fakeworker, return_value_makeabspath_1);
  sftp_send_end(&fakeworker);
  getresponse(101, id, "SSH_FXP_REMOVE");
  signed int return_value_status_2;
  return_value_status_2=status();
  return return_value_status_2;
}

// sftp_rename
// file sftpclient.c line 660
static signed int sftp_rename(const char *oldpath, const char *newpath, unsigned int flags)
{
  unsigned int id;
  remote_cwd();
  signed int return_value_error_1;
  if(!(protocol->version >= 5))
  {
    if((4294967293u & flags) == 0u)
      goto __CPROVER_DUMP_L1;

    return_value_error_1=error("cannot emulate rename flags %#x in protocol %d", flags, protocol->version);
    return return_value_error_1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    sftp_send_begin(&fakeworker);
    sftp_send_uint8(&fakeworker, 18);
    id=newid();
    sftp_send_uint32(&fakeworker, id);
    const char *return_value_makeabspath_2;
    return_value_makeabspath_2=makeabspath(oldpath);
    sftp_send_path(&fakejob, &fakeworker, return_value_makeabspath_2);
    const char *return_value_makeabspath_3;
    return_value_makeabspath_3=makeabspath(newpath);
    sftp_send_path(&fakejob, &fakeworker, return_value_makeabspath_3);
    if(protocol->version >= 5)
      sftp_send_uint32(&fakeworker, flags);

    sftp_send_end(&fakeworker);
    getresponse(101, id, "SSH_FXP_RENAME");
    signed int return_value_status_4;
    return_value_status_4=status();
    return return_value_status_4;
  }
}

// sftp_rmdir
// file sftpclient.c line 634
static signed int sftp_rmdir(const char *path)
{
  unsigned int id;
  remote_cwd();
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 15);
  id=newid();
  sftp_send_uint32(&fakeworker, id);
  const char *return_value_makeabspath_1;
  return_value_makeabspath_1=makeabspath(path);
  sftp_send_path(&fakejob, &fakeworker, return_value_makeabspath_1);
  sftp_send_end(&fakeworker);
  getresponse(101, id, "SSH_FXP_RMDIR");
  signed int return_value_status_2;
  return_value_status_2=status();
  return return_value_status_2;
}

// sftp_send_begin
// file send.h line 39
void sftp_send_begin(struct worker *w)
{
  w->bufused = (unsigned long int)0;
  sftp_send_uint32(w, (unsigned int)0);
}

// sftp_send_bytes
// file send.h line 81
void sftp_send_bytes(struct worker *w, const void *bytes, unsigned long int n)
{
  sftp_send_need(w, n + (unsigned long int)4);
  do
  {
    put32((void *)&w->buffer[(signed long int)w->bufused], (unsigned int)n);
    w->bufused = w->bufused + (unsigned long int)4;
  }
  while((_Bool)0);
  memcpy((void *)(w->buffer + (signed long int)w->bufused), bytes, n);
  w->bufused = w->bufused + n;
}

// sftp_send_end
// file send.h line 50
void sftp_send_end(struct worker *w)
{
  signed long int n;
  signed long int written;
  /* assertion w->bufused < 0x80000000 */
  assert(w->bufused < (unsigned long int)0x80000000);
  *((unsigned int *)w->buffer)=htonl((unsigned int)(w->bufused - (unsigned long int)4));
  do
  {
    signed int frc;
    frc=pthread_mutex_lock(&output_lock);
    if(!(frc == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"send.c", 88, (const void *)"pthread_mutex_lock(&output_lock)", return_value_strerror_1);
      exit(1);
    }

  }
  while((_Bool)0);
  if(!(sftp_debugging == 0))
  {
    do
      if(!(sftp_debugging == 0))
        sftp_debug_printf("%s:", (const void *)sendtype);

    while((_Bool)0);
    sftp_debug_hexdump((const void *)(w->buffer + (signed long int)4), w->bufused - (unsigned long int)4);
  }

  written = (signed long int)0;
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  while(!((unsigned long int)written >= w->bufused))
  {
    n=write(sftpout, (const void *)(w->buffer + written), w->bufused - (unsigned long int)written);
    if(n >= 1l)
      written = written + n;

    else
      if(!(n >= 0l))
      {
        return_value___errno_location_2=__errno_location();
        return_value_strerror_3=strerror(*return_value___errno_location_2);
        fatal("error sending response: %s", return_value_strerror_3);
      }

  }
  do
  {
    signed int sftp_send_end__1__3__frc;
    sftp_send_end__1__3__frc=pthread_mutex_unlock(&output_lock);
    if(!(sftp_send_end__1__3__frc == 0))
    {
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(sftp_send_end__1__3__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"send.c", 100, (const void *)"pthread_mutex_unlock(&output_lock)", return_value_strerror_4);
      exit(1);
    }

  }
  while((_Bool)0);
  w->bufused = (unsigned long int)0x80000000;
}

// sftp_send_errno_status
// file status.c line 131
void sftp_send_errno_status(struct sftpjob *job)
{
  signed int n;
  signed int errno_value;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  errno_value = *return_value___errno_location_1;
  n = 0;
  _Bool tmp_if_expr_2;
  do
  {
    if(!(errnotab[(signed long int)n].errno_value == errno_value))
      tmp_if_expr_2 = errnotab[(signed long int)n].errno_value != -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      break;

    n = n + 1;
  }
  while((_Bool)1);
  char *return_value_strerror_3;
  return_value_strerror_3=strerror(errno_value);
  sftp_send_status(job, errnotab[(signed long int)n].status_value, return_value_strerror_3);
}

// sftp_send_handle
// file send.c line 141
void sftp_send_handle(struct worker *w, struct handleid *id)
{
  sftp_send_need(w, (unsigned long int)12);
  do
  {
    put32((void *)&w->buffer[(signed long int)w->bufused], (unsigned int)8);
    w->bufused = w->bufused + (unsigned long int)4;
  }
  while((_Bool)0);
  do
  {
    put32((void *)&w->buffer[(signed long int)w->bufused], id->id);
    w->bufused = w->bufused + (unsigned long int)4;
  }
  while((_Bool)0);
  do
  {
    put32((void *)&w->buffer[(signed long int)w->bufused], id->tag);
    w->bufused = w->bufused + (unsigned long int)4;
  }
  while((_Bool)0);
}

// sftp_send_need
// file send.h line 32
void sftp_send_need(struct worker *w, unsigned long int n)
{
  /* assertion w->bufused < 0x80000000 */
  assert(w->bufused < (unsigned long int)0x80000000);
  unsigned long int tmp_if_expr_1;
  if(!(w->bufsize + -w->bufused >= n))
  {
    unsigned long int newsize;
    if(!(w->bufsize == 0ul))
      tmp_if_expr_1 = w->bufsize;

    else
      tmp_if_expr_1 = (unsigned long int)64;
    newsize = tmp_if_expr_1;
    for( ; !(newsize == 0ul); newsize = newsize << 1)
      if(newsize >= w->bufsize + n)
        break;

    if(newsize == 0ul)
      fatal("sftp_send_need: out of memory (%zu)", n);

    w->bufsize = newsize;
    void *return_value_sftp__xrealloc_2;
    return_value_sftp__xrealloc_2=sftp__xrealloc((void *)w->buffer, w->bufsize);
    w->buffer = (unsigned char *)return_value_sftp__xrealloc_2;
  }

}

// sftp_send_path
// file send.h line 100
void sftp_send_path(struct sftpjob *job, struct worker *w, const char *path)
{
  signed int return_value;
  return_value=protocol->encode(job, (char **)&path);
  if(!(return_value == 0))
    fatal("cannot encode local path name '%s'", path);

  sftp_send_string(w, path);
}

// sftp_send_status
// file status.c line 70
void sftp_send_status(struct sftpjob *job, unsigned int status, const char *msg)
{
  if(status == 4294967294u)
    sftp_send_errno_status(job);

  else
  {
    if(msg == ((const char *)NULL))
      msg=status_to_string(status);

    if(!(protocol->maxstatus >= status))
      switch(status)
      {
        case (unsigned int)20:
        {
          status = (unsigned int)5;
          break;
        }
        case (unsigned int)10:
        {
          status = (unsigned int)2;
          break;
        }
        default:
          status = (unsigned int)4;
      }

    sftp_send_begin(job->worker);
    sftp_send_uint8(job->worker, 101);
    sftp_send_uint32(job->worker, job->id);
    sftp_send_uint32(job->worker, status);
    sftp_send_path(job, job->worker, msg);
    sftp_send_string(job->worker, "en");
    sftp_send_end(job->worker);
  }
}

// sftp_send_string
// file send.h line 93
void sftp_send_string(struct worker *w, const char *s)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  sftp_send_bytes(w, (const void *)s, return_value_strlen_1);
}

// sftp_send_sub_begin
// file send.c line 148
unsigned long int sftp_send_sub_begin(struct worker *w)
{
  sftp_send_need(w, (unsigned long int)4);
  w->bufused = w->bufused + (unsigned long int)4;
  return w->bufused;
}

// sftp_send_sub_end
// file send.c line 154
void sftp_send_sub_end(struct worker *w, unsigned long int offset)
{
  const unsigned long int latest = w->bufused;
  w->bufused = offset - (unsigned long int)4;
  do
  {
    put32((void *)&w->buffer[(signed long int)w->bufused], (unsigned int)(latest - offset));
    w->bufused = w->bufused + (unsigned long int)4;
  }
  while((_Bool)0);
  w->bufused = latest;
}

// sftp_send_uint16
// file send.c line 109
void sftp_send_uint16(struct worker *w, unsigned short int u)
{
  sftp_send_need(w, (unsigned long int)2);
  do
  {
    put16((void *)&w->buffer[(signed long int)w->bufused], u);
    w->bufused = w->bufused + (unsigned long int)2;
  }
  while((_Bool)0);
}

// sftp_send_uint32
// file send.h line 68
void sftp_send_uint32(struct worker *w, unsigned int u)
{
  sftp_send_need(w, (unsigned long int)4);
  do
  {
    put32((void *)&w->buffer[(signed long int)w->bufused], u);
    w->bufused = w->bufused + (unsigned long int)4;
  }
  while((_Bool)0);
}

// sftp_send_uint64
// file send.h line 74
void sftp_send_uint64(struct worker *w, unsigned long int u)
{
  sftp_send_need(w, (unsigned long int)8);
  do
  {
    put64((void *)&w->buffer[(signed long int)w->bufused], u);
    w->bufused = w->bufused + (unsigned long int)8;
  }
  while((_Bool)0);
}

// sftp_send_uint8
// file send.h line 56
void sftp_send_uint8(struct worker *w, signed int n)
{
  sftp_send_need(w, (unsigned long int)1);
  unsigned long int tmp_post_1 = w->bufused;
  w->bufused = w->bufused + 1ul;
  w->buffer[(signed long int)tmp_post_1] = (unsigned char)n;
}

// sftp_set_fstatus
// file stat.h line 89
unsigned int sftp_set_fstatus(struct allocator *a, signed int fd, struct sftpattr *attrsp, const char **whyp)
{
  unsigned int return_value_do_sftp_set_status_1;
  return_value_do_sftp_set_status_1=do_sftp_set_status(a, (const void *)&fd, attrsp, &fd_callbacks, whyp);
  return return_value_do_sftp_set_status_1;
}

// sftp_set_status
// file stat.h line 77
unsigned int sftp_set_status(struct allocator *a, const char *path, struct sftpattr *attrsp, const char **whyp)
{
  unsigned int return_value_do_sftp_set_status_1;
  return_value_do_sftp_set_status_1=do_sftp_set_status(a, (const void *)path, attrsp, &name_callbacks, whyp);
  return return_value_do_sftp_set_status_1;
}

// sftp_setstat
// file sftpclient.c line 605
static signed int sftp_setstat(const char *path, struct sftpattr *attrs)
{
  unsigned int id;
  remote_cwd();
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 9);
  id=newid();
  sftp_send_uint32(&fakeworker, id);
  const char *return_value_makeabspath_1;
  return_value_makeabspath_1=makeabspath(path);
  sftp_send_path(&fakejob, &fakeworker, return_value_makeabspath_1);
  protocol->sendattrs(&fakejob, attrs);
  sftp_send_end(&fakeworker);
  getresponse(101, id, "SSH_FXP_SETSTAT");
  signed int return_value_status_2;
  return_value_status_2=status();
  return return_value_status_2;
}

// sftp_space_available
// file sftpclient.c line 804
static signed int sftp_space_available(const char *path, struct space_available *as)
{
  unsigned int id;
  remote_cwd();
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 200);
  id=newid();
  sftp_send_uint32(&fakeworker, id);
  sftp_send_string(&fakeworker, "space-available");
  const char *return_value_makeabspath_1;
  return_value_makeabspath_1=makeabspath(path);
  sftp_send_path(&fakejob, &fakeworker, return_value_makeabspath_1);
  sftp_send_end(&fakeworker);
  unsigned char return_value_getresponse_2;
  return_value_getresponse_2=getresponse(201, id, "space-available");
  if(!((signed int)return_value_getresponse_2 == 201))
    return -1;

  else
  {
    do
    {
      unsigned int sftp_space_available__1__1__rc;
      sftp_space_available__1__1__rc=sftp_parse_uint64(&fakejob, &as->bytes_on_device);
      if(!(sftp_space_available__1__1__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 818, (const void *)"sftp_parse_uint64(&fakejob, &as->bytes_on_device)", sftp_space_available__1__1__rc);

        while((_Bool)0);
        fatal("error parsing response from server");
      }

    }
    while((_Bool)0);
    do
    {
      unsigned int sftp_space_available__1__2__rc;
      sftp_space_available__1__2__rc=sftp_parse_uint64(&fakejob, &as->unused_bytes_on_device);
      if(!(sftp_space_available__1__2__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 819, (const void *)"sftp_parse_uint64(&fakejob, &as->unused_bytes_on_device)", sftp_space_available__1__2__rc);

        while((_Bool)0);
        fatal("error parsing response from server");
      }

    }
    while((_Bool)0);
    do
    {
      unsigned int sftp_space_available__1__3__rc;
      sftp_space_available__1__3__rc=sftp_parse_uint64(&fakejob, &as->bytes_available_to_user);
      if(!(sftp_space_available__1__3__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 820, (const void *)"sftp_parse_uint64(&fakejob, &as->bytes_available_to_user)", sftp_space_available__1__3__rc);

        while((_Bool)0);
        fatal("error parsing response from server");
      }

    }
    while((_Bool)0);
    do
    {
      unsigned int rc;
      rc=sftp_parse_uint64(&fakejob, &as->unused_bytes_available_to_user);
      if(!(rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 821, (const void *)"sftp_parse_uint64(&fakejob, &as->unused_bytes_available_to_user)", rc);

        while((_Bool)0);
        fatal("error parsing response from server");
      }

    }
    while((_Bool)0);
    do
    {
      unsigned int sftp_space_available__1__5__rc;
      sftp_space_available__1__5__rc=sftp_parse_uint32(&fakejob, &as->bytes_per_allocation_unit);
      if(!(sftp_space_available__1__5__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 822, (const void *)"sftp_parse_uint32(&fakejob, &as->bytes_per_allocation_unit)", sftp_space_available__1__5__rc);

        while((_Bool)0);
        fatal("error parsing response from server");
      }

    }
    while((_Bool)0);
    return 0;
  }
}

// sftp_stat
// file sftpclient.c line 492
static signed int sftp_stat(const char *path, struct sftpattr *attrs, unsigned char type)
{
  unsigned int id;
  remote_cwd();
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, (signed int)type);
  id=newid();
  sftp_send_uint32(&fakeworker, id);
  const char *return_value_makeabspath_1;
  return_value_makeabspath_1=makeabspath(path);
  sftp_send_path(&fakejob, &fakeworker, return_value_makeabspath_1);
  if(protocol->version >= 4)
    sftp_send_uint32(&fakeworker, 0xFFFFFFFF);

  sftp_send_end(&fakeworker);
  unsigned char return_value_getresponse_2;
  return_value_getresponse_2=getresponse(105, id, "SSH_FXP_*STAT");
  if(!((signed int)return_value_getresponse_2 == 105))
    return -1;

  else
  {
    unsigned int rc;
    rc=protocol->parseattrs(&fakejob, attrs);
    if(!(rc == 0u))
    {
      if(!(sftp_debugging == 0))
        sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 506, (const void *)"protocol->parseattrs(&fakejob, attrs)", rc);

      fatal("error parsing response from server");
    }

    attrs->name = path;
    attrs->wname=sftp_mbs2wcs(attrs->name);
    return 0;
  }
}

// sftp_stat_to_attrs
// file stat.h line 109
void sftp_stat_to_attrs(struct allocator *a, struct stat *sb, struct sftpattr *attrs, unsigned int flags, const char *path)
{
  memset((void *)attrs, 0, sizeof(struct sftpattr) /*200ul*/ );
  attrs->valid = (unsigned int)(0x00000001 | 0x00000004 | 0x00000008 | 0x00000020 | 0x00000002 | 0x00000400 | 0x00002000 | 0x00008000 | 0x00000200);
  switch(sb->st_mode & (unsigned int)0170000)
  {
    case (unsigned int)0010000:
    {
      attrs->type = (unsigned char)9;
      break;
    }
    case (unsigned int)0020000:
    {
      attrs->type = (unsigned char)7;
      break;
    }
    case (unsigned int)0040000:
    {
      attrs->type = (unsigned char)2;
      break;
    }
    case (unsigned int)0060000:
    {
      attrs->type = (unsigned char)8;
      break;
    }
    case (unsigned int)0100000:
    {
      attrs->type = (unsigned char)1;
      break;
    }
    case (unsigned int)0120000:
    {
      attrs->type = (unsigned char)3;
      break;
    }
    case (unsigned int)0140000:
    {
      attrs->type = (unsigned char)6;
      break;
    }
    default:
      attrs->type = (unsigned char)4;
  }
  attrs->size = (unsigned long int)sb->st_size;
  attrs->allocation_size = (unsigned long int)sb->st_blksize * (unsigned long int)sb->st_blocks;
  if(!((128u & flags) == 0u))
  {
    attrs->owner=sftp_uid2name(a, sb->st_uid);
    if(!(attrs->owner == ((char *)NULL)))
    {
      attrs->group=sftp_gid2name(a, sb->st_gid);
      if(!(attrs->group == ((char *)NULL)))
        attrs->valid = attrs->valid | (unsigned int)0x00000080;

    }

  }

  attrs->uid = sb->st_uid;
  attrs->gid = sb->st_gid;
  attrs->permissions = sb->st_mode;
  attrs->atime.seconds = sb->st_atim.tv_sec;
  attrs->mtime.seconds = sb->st_mtim.tv_sec;
  attrs->ctime.seconds = sb->st_ctim.tv_sec;
  attrs->link_count = (unsigned int)sb->st_nlink;
  if(!(path == ((const char *)NULL)))
  {
    const char *s;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(path);
    s = path + (signed long int)return_value_strlen_1;
    for( ; !(path >= s); s = s - 1l)
      if(!((signed int)s[-1l] == 47))
        break;

    for( ; !(path >= s); s = s - 1l)
      if((signed int)s[-1l] == 47)
        break;

    if((signed int)*s == 46)
      attrs->attrib_bits = attrs->attrib_bits | (unsigned int)0x00000004;

    attrs->attrib_bits_valid = attrs->attrib_bits_valid | (unsigned int)0x00000004;
  }

  attrs->name = path;
}

// sftp_text_seek
// file sftpclient.c line 866
static signed int sftp_text_seek(struct client_handle *hp, unsigned long int line)
{
  unsigned int id;
  sftp_send_begin(&fakeworker);
  sftp_send_uint8(&fakeworker, 200);
  id=newid();
  sftp_send_uint32(&fakeworker, id);
  sftp_send_string(&fakeworker, "text-seek");
  sftp_send_bytes(&fakeworker, (const void *)hp->data, hp->len);
  sftp_send_uint64(&fakeworker, line);
  sftp_send_end(&fakeworker);
  getresponse(101, id, "text-seek");
  signed int return_value_status_1;
  return_value_status_1=status();
  return return_value_status_1;
}

// sftp_uid2name
// file users.c line 35
char * sftp_uid2name(struct allocator *a, unsigned int uid)
{
  char *s;
  struct passwd *pw;
  do
  {
    signed int frc;
    frc=pthread_mutex_lock(&user_lock);
    if(!(frc == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"users.c", 39, (const void *)"pthread_mutex_lock(&user_lock)", return_value_strerror_1);
      exit(1);
    }

  }
  while((_Bool)0);
  pw=getpwuid(uid);
  unsigned long int return_value_strlen_2;
  void *return_value_sftp_alloc_3;
  if(!(pw == ((struct passwd *)NULL)))
  {
    return_value_strlen_2=strlen(pw->pw_name);
    return_value_sftp_alloc_3=sftp_alloc(a, return_value_strlen_2 + (unsigned long int)1);
    s=strcpy((char *)return_value_sftp_alloc_3, pw->pw_name);
  }

  else
    s = ((char *)NULL);
  do
  {
    signed int sftp_uid2name__1__2__frc;
    sftp_uid2name__1__2__frc=pthread_mutex_unlock(&user_lock);
    if(!(sftp_uid2name__1__2__frc == 0))
    {
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(sftp_uid2name__1__2__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"users.c", 44, (const void *)"pthread_mutex_unlock(&user_lock)", return_value_strerror_4);
      exit(1);
    }

  }
  while((_Bool)0);
  return s;
}

// sftp_v345_realpath
// file v3.c line 448
unsigned int sftp_v345_realpath(struct sftpjob *job)
{
  char *path;
  struct sftpattr attr;
  do
  {
    unsigned int rc;
    rc=sftp_parse_path(job, &path);
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 452, (const void *)"sftp_parse_path(job, &path)", rc);

      while((_Bool)0);
      return rc;
    }

  }
  while((_Bool)0);
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_v345_realpath %s", path);

  while((_Bool)0);
  memset((void *)&attr, 0, sizeof(struct sftpattr) /*200ul*/ );
  attr.name=sftp_find_realpath(job->a, path, (unsigned int)0x0001);
  if(!(attr.name == ((const char *)NULL)))
  {
    do
      if(!(sftp_debugging == 0))
        sftp_debug_printf("...real path is %s", attr.name);

    while((_Bool)0);
    sftp_send_begin(job->worker);
    sftp_send_uint8(job->worker, 104);
    sftp_send_uint32(job->worker, job->id);
    protocol->sendnames(job, 1, &attr);
    sftp_send_end(job->worker);
    return (unsigned int)-1;
  }

  else
    return (unsigned int)-2;
}

// sftp_v345_symlink
// file v3.c line 283
unsigned int sftp_v345_symlink(struct sftpjob *job)
{
  char *targetpath;
  char *linkpath;
  if(!(readonly == 0))
    return (unsigned int)3;

  else
  {
    if(!(reverse_symlink == 0))
    {
      do
      {
        unsigned int sftp_v345_symlink__1__1__1__rc;
        sftp_v345_symlink__1__1__1__rc=sftp_parse_path(job, &targetpath);
        if(!(sftp_v345_symlink__1__1__1__rc == 0u))
        {
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 330, (const void *)"sftp_parse_path(job, &targetpath)", sftp_v345_symlink__1__1__1__rc);

          while((_Bool)0);
          return sftp_v345_symlink__1__1__1__rc;
        }

      }
      while((_Bool)0);
      do
      {
        unsigned int rc;
        rc=sftp_parse_path(job, &linkpath);
        if(!(rc == 0u))
        {
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 331, (const void *)"sftp_parse_path(job, &linkpath)", rc);

          while((_Bool)0);
          return rc;
        }

      }
      while((_Bool)0);
    }

    else
    {
      do
      {
        unsigned int sftp_v345_symlink__1__2__1__rc;
        sftp_v345_symlink__1__2__1__rc=sftp_parse_path(job, &linkpath);
        if(!(sftp_v345_symlink__1__2__1__rc == 0u))
        {
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 333, (const void *)"sftp_parse_path(job, &linkpath)", sftp_v345_symlink__1__2__1__rc);

          while((_Bool)0);
          return sftp_v345_symlink__1__2__1__rc;
        }

      }
      while((_Bool)0);
      do
      {
        unsigned int sftp_v345_symlink__1__2__2__rc;
        sftp_v345_symlink__1__2__2__rc=sftp_parse_path(job, &targetpath);
        if(!(sftp_v345_symlink__1__2__2__rc == 0u))
        {
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 334, (const void *)"sftp_parse_path(job, &targetpath)", sftp_v345_symlink__1__2__2__rc);

          while((_Bool)0);
          return sftp_v345_symlink__1__2__2__rc;
        }

      }
      while((_Bool)0);
    }
    do
      if(!(sftp_debugging == 0))
        sftp_debug_printf("sftp_v345_symlink %s %s", targetpath, linkpath);

    while((_Bool)0);
    signed int return_value_symlink_1;
    return_value_symlink_1=symlink(targetpath, linkpath);
    if(!(return_value_symlink_1 >= 0))
      return (unsigned int)-2;

    else
      return (unsigned int)0;
  }
}

// sftp_v34_open
// file v3.c line 591
unsigned int sftp_v34_open(struct sftpjob *job)
{
  char *path;
  unsigned int pflags;
  struct sftpattr attrs;
  unsigned int desired_access = (unsigned int)0;
  unsigned int flags;
  do
  {
    unsigned int rc;
    rc=sftp_parse_path(job, &path);
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 598, (const void *)"sftp_parse_path(job, &path)", rc);

      while((_Bool)0);
      return rc;
    }

  }
  while((_Bool)0);
  do
  {
    unsigned int sftp_v34_open__1__2__rc;
    sftp_v34_open__1__2__rc=sftp_parse_uint32(job, &pflags);
    if(!(sftp_v34_open__1__2__rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 599, (const void *)"sftp_parse_uint32(job, &pflags)", sftp_v34_open__1__2__rc);

      while((_Bool)0);
      return sftp_v34_open__1__2__rc;
    }

  }
  while((_Bool)0);
  unsigned int sftp_v34_open__1__3__rc;
  sftp_v34_open__1__3__rc=protocol->parseattrs(job, &attrs);
  if(!(sftp_v34_open__1__3__rc == 0u))
  {
    if(!(sftp_debugging == 0))
      sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 600, (const void *)"protocol->parseattrs(job, &attrs)", sftp_v34_open__1__3__rc);

    return sftp_v34_open__1__3__rc;
  }

  else
  {
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_v34_open %s %#x", path, pflags);

    if((56u & pflags) == 0u)
    {
      flags = (unsigned int)0x00000002;
      flags = (unsigned int)0x00000004;
      flags = (unsigned int)0x00000003;
      flags = (unsigned int)0x00000001;
      flags = (unsigned int)0x00000000;
    }

    return (unsigned int)5;
    if(!((64u & pflags) == 0u))
      flags = flags | (unsigned int)0x00000020;

    if(!((1u & pflags) == 0u))
      desired_access = desired_access | (unsigned int)(0x00000001 | 0x00000080);

    if(!((2u & pflags) == 0u))
      desired_access = desired_access | (unsigned int)(0x00000002 | 0x00000100);

    if(!((4u & pflags) == 0u))
    {
      flags = flags | (unsigned int)0x00000008;
      desired_access = desired_access | (unsigned int)0x00000004;
    }

    unsigned int return_value_sftp_generic_open_1;
    return_value_sftp_generic_open_1=sftp_generic_open(job, path, desired_access, flags, &attrs);
    return return_value_sftp_generic_open_1;
  }
}

// sftp_v34_rename
// file v3.c line 228
unsigned int sftp_v34_rename(struct sftpjob *job)
{
  char *oldpath;
  char *newpath;
  signed int return_value_unlink_5;
  if(!(readonly == 0))
    return (unsigned int)3;

  else
  {
    do
    {
      unsigned int sftp_v34_rename__1__1__rc;
      sftp_v34_rename__1__1__rc=sftp_parse_path(job, &oldpath);
      if(!(sftp_v34_rename__1__1__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 233, (const void *)"sftp_parse_path(job, &oldpath)", sftp_v34_rename__1__1__rc);

        while((_Bool)0);
        return sftp_v34_rename__1__1__rc;
      }

    }
    while((_Bool)0);
    do
    {
      unsigned int rc;
      rc=sftp_parse_path(job, &newpath);
      if(!(rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 234, (const void *)"sftp_parse_path(job, &newpath)", rc);

        while((_Bool)0);
        return rc;
      }

    }
    while((_Bool)0);
    do
      if(!(sftp_debugging == 0))
        sftp_debug_printf("sftp_v34_rename %s %s", oldpath, newpath);

    while((_Bool)0);
    signed int return_value_link_6;
    return_value_link_6=link(oldpath, newpath);
    if(!(return_value_link_6 >= 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      if(!(*return_value___errno_location_2 == 17))
      {
        signed int return_value_rename_1;
        return_value_rename_1=rename(oldpath, newpath);
        if(!(return_value_rename_1 >= 0))
          return (unsigned int)-2;

        else
          return (unsigned int)0;
      }

      else
        return (unsigned int)-2;
    }

    else
    {
      return_value_unlink_5=unlink(oldpath);
      if(!(return_value_unlink_5 >= 0))
      {
        signed int save_errno;
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        save_errno = *return_value___errno_location_3;
        unlink(newpath);
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        *return_value___errno_location_4 = save_errno;
        return (unsigned int)-2;
      }

      else
        return (unsigned int)0;
    }
  }
}

// sftp_v3_encode
// file v3.c line 53
signed int sftp_v3_encode(struct sftpjob *job, char **path)
{
  return 0;
}

// sftp_v3_fstat
// file v3.c line 507
static unsigned int sftp_v3_fstat(struct sftpjob *job)
{
  signed int fd;
  struct handleid id;
  struct stat sb;
  unsigned int rc;
  do
  {
    unsigned int sftp_v3_fstat__1__1__rc;
    sftp_v3_fstat__1__1__rc=sftp_parse_handle(job, &id);
    if(!(sftp_v3_fstat__1__1__rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 513, (const void *)"sftp_parse_handle(job, &id)", sftp_v3_fstat__1__1__rc);

      while((_Bool)0);
      return sftp_v3_fstat__1__1__rc;
    }

  }
  while((_Bool)0);
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_v3_fstat %u %u", id.id, id.tag);

  while((_Bool)0);
  rc=sftp_handle_get_fd(&id, &fd, ((unsigned int *)NULL));
  if(!(rc == 0u))
    return rc;

  else
  {
    signed int return_value_fstat_1;
    return_value_fstat_1=fstat(fd, &sb);
    unsigned int return_value_sftp_v3_stat_core_2;
    return_value_sftp_v3_stat_core_2=sftp_v3_stat_core(job, return_value_fstat_1, &sb);
    return return_value_sftp_v3_stat_core_2;
  }
}

// sftp_v3_lstat
// file v3.c line 489
static unsigned int sftp_v3_lstat(struct sftpjob *job)
{
  char *path;
  struct stat sb;
  do
  {
    unsigned int rc;
    rc=sftp_parse_path(job, &path);
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 493, (const void *)"sftp_parse_path(job, &path)", rc);

      while((_Bool)0);
      return rc;
    }

  }
  while((_Bool)0);
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_v3_lstat %s", path);

  while((_Bool)0);
  signed int return_value_lstat_1;
  return_value_lstat_1=lstat(path, &sb);
  unsigned int return_value_sftp_v3_stat_core_2;
  return_value_sftp_v3_stat_core_2=sftp_v3_stat_core(job, return_value_lstat_1, &sb);
  return return_value_sftp_v3_stat_core_2;
}

// sftp_v3_stat
// file v3.c line 498
static unsigned int sftp_v3_stat(struct sftpjob *job)
{
  char *path;
  struct stat sb;
  do
  {
    unsigned int rc;
    rc=sftp_parse_path(job, &path);
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 502, (const void *)"sftp_parse_path(job, &path)", rc);

      while((_Bool)0);
      return rc;
    }

  }
  while((_Bool)0);
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_v3_stat %s", path);

  while((_Bool)0);
  signed int return_value_stat_1;
  return_value_stat_1=stat(path, &sb);
  unsigned int return_value_sftp_v3_stat_core_2;
  return_value_sftp_v3_stat_core_2=sftp_v3_stat_core(job, return_value_stat_1, &sb);
  return return_value_sftp_v3_stat_core_2;
}

// sftp_v3_stat_core
// file v3.c line 470
static unsigned int sftp_v3_stat_core(struct sftpjob *job, signed int rc, struct stat *sb)
{
  struct sftpattr attrs;
  if(rc == 0)
  {
    sftp_stat_to_attrs(job->a, sb, &attrs, ~((unsigned int)0x00000080), ((const char *)NULL));
    sftp_send_begin(job->worker);
    sftp_send_uint8(job->worker, 105);
    sftp_send_uint32(job->worker, job->id);
    protocol->sendattrs(job, &attrs);
    sftp_send_end(job->worker);
    return (unsigned int)-1;
  }

  else
    return (unsigned int)-2;
}

// sftp_v456_decode
// file v4.c line 40
unsigned int sftp_v456_decode(struct sftpjob *job, char **path)
{
  signed int return_value_sftp_iconv_1;
  return_value_sftp_iconv_1=sftp_iconv(job->a, job->worker->utf8_to_local, path);
  if(!(return_value_sftp_iconv_1 == 0))
    return (unsigned int)20;

  else
    return (unsigned int)0;
}

// sftp_v456_encode
// file v4.c line 34
signed int sftp_v456_encode(struct sftpjob *job, char **path)
{
  signed int return_value_sftp_iconv_1;
  return_value_sftp_iconv_1=sftp_iconv(job->a, job->worker->local_to_utf8, path);
  return return_value_sftp_iconv_1;
}

// sftp_v456_fstat
// file v4.c line 250
unsigned int sftp_v456_fstat(struct sftpjob *job)
{
  signed int fd;
  struct handleid id;
  struct stat sb;
  unsigned int rc;
  do
  {
    unsigned int sftp_v456_fstat__1__1__rc;
    sftp_v456_fstat__1__1__rc=sftp_parse_handle(job, &id);
    if(!(sftp_v456_fstat__1__1__rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v4.c", 256, (const void *)"sftp_parse_handle(job, &id)", sftp_v456_fstat__1__1__rc);

      while((_Bool)0);
      return sftp_v456_fstat__1__1__rc;
    }

  }
  while((_Bool)0);
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_fstat %u %u", id.id, id.tag);

  while((_Bool)0);
  rc=sftp_handle_get_fd(&id, &fd, ((unsigned int *)NULL));
  if(!(rc == 0u))
    return rc;

  else
  {
    signed int return_value_fstat_1;
    return_value_fstat_1=fstat(fd, &sb);
    unsigned int return_value_sftp_v456_stat_core_2;
    return_value_sftp_v456_stat_core_2=sftp_v456_stat_core(job, return_value_fstat_1, &sb, ((const char *)NULL));
    return return_value_sftp_v456_stat_core_2;
  }
}

// sftp_v456_lstat
// file v4.c line 232
unsigned int sftp_v456_lstat(struct sftpjob *job)
{
  char *path;
  struct stat sb;
  do
  {
    unsigned int rc;
    rc=sftp_parse_path(job, &path);
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v4.c", 236, (const void *)"sftp_parse_path(job, &path)", rc);

      while((_Bool)0);
      return rc;
    }

  }
  while((_Bool)0);
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_lstat %s", path);

  while((_Bool)0);
  signed int return_value_lstat_1;
  return_value_lstat_1=lstat(path, &sb);
  unsigned int return_value_sftp_v456_stat_core_2;
  return_value_sftp_v456_stat_core_2=sftp_v456_stat_core(job, return_value_lstat_1, &sb, path);
  return return_value_sftp_v456_stat_core_2;
}

// sftp_v456_parseattrs
// file v4.c line 107
unsigned int sftp_v456_parseattrs(struct sftpjob *job, struct sftpattr *attrs)
{
  unsigned int n;
  unsigned int rc;
  memset((void *)attrs, 0, sizeof(struct sftpattr) /*200ul*/ );
  rc=sftp_parse_uint32(job, &attrs->valid);
  unsigned int tmp_post_1;
  if(!(rc == 0u))
    return rc;

  else
  {
    rc=sftp_parse_uint8(job, &attrs->type);
    if(!(rc == 0u))
      return rc;

    else
      if(!((1u & attrs->valid) == 0u))
      {
        rc=sftp_parse_uint64(job, &attrs->size);
        if(rc == 0u)
          goto __CPROVER_DUMP_L3;

        return rc;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        if(!((128u & attrs->valid) == 0u))
        {
          rc=sftp_parse_path(job, &attrs->owner);
          if(!(rc == 0u))
            return rc;

          rc=sftp_parse_path(job, &attrs->group);
          if(rc == 0u)
            goto __CPROVER_DUMP_L5;

          return rc;
        }

        else
        {

        __CPROVER_DUMP_L5:
          ;
          if(!((4u & attrs->valid) == 0u))
          {
            rc=sftp_parse_uint32(job, &attrs->permissions);
            if(rc == 0u)
              goto __CPROVER_DUMP_L6;

            return rc;
          }

          else
          {

          __CPROVER_DUMP_L6:
            ;
            if(!((8u & attrs->valid) == 0u))
            {
              rc=sftp_parse_uint64(job, (unsigned long int *)&attrs->atime.seconds);
              if(!(rc == 0u))
                return rc;

              if((256u & attrs->valid) == 0u)
                goto __CPROVER_DUMP_L8;

              rc=sftp_parse_uint32(job, &attrs->atime.nanoseconds);
              if(rc == 0u)
                goto __CPROVER_DUMP_L8;

              return rc;
            }

            else
            {

            __CPROVER_DUMP_L8:
              ;
              if(!((16u & attrs->valid) == 0u))
              {
                rc=sftp_parse_uint64(job, (unsigned long int *)&attrs->createtime.seconds);
                if(!(rc == 0u))
                  return rc;

                if((256u & attrs->valid) == 0u)
                  goto __CPROVER_DUMP_L10;

                rc=sftp_parse_uint32(job, &attrs->createtime.nanoseconds);
                if(rc == 0u)
                  goto __CPROVER_DUMP_L10;

                return rc;
              }

              else
              {

              __CPROVER_DUMP_L10:
                ;
                if(!((32u & attrs->valid) == 0u))
                {
                  rc=sftp_parse_uint64(job, (unsigned long int *)&attrs->mtime.seconds);
                  if(!(rc == 0u))
                    return rc;

                  if((256u & attrs->valid) == 0u)
                    goto __CPROVER_DUMP_L12;

                  rc=sftp_parse_uint32(job, &attrs->mtime.nanoseconds);
                  if(rc == 0u)
                    goto __CPROVER_DUMP_L12;

                  return rc;
                }

                else
                {

                __CPROVER_DUMP_L12:
                  ;
                  if(!((32768u & attrs->valid) == 0u))
                  {
                    rc=sftp_parse_uint64(job, (unsigned long int *)&attrs->ctime.seconds);
                    if(!(rc == 0u))
                      return rc;

                    if((256u & attrs->valid) == 0u)
                      goto __CPROVER_DUMP_L14;

                    rc=sftp_parse_uint32(job, &attrs->ctime.nanoseconds);
                    if(rc == 0u)
                      goto __CPROVER_DUMP_L14;

                    return rc;
                  }

                  else
                  {

                  __CPROVER_DUMP_L14:
                    ;
                    if(!((64u & attrs->valid) == 0u))
                    {
                      rc=sftp_parse_string(job, &attrs->acl, ((unsigned long int *)NULL));
                      if(rc == 0u)
                        goto __CPROVER_DUMP_L15;

                      return rc;
                    }

                    else
                    {

                    __CPROVER_DUMP_L15:
                      ;
                      if(!((512u & attrs->valid) == 0u))
                      {
                        rc=sftp_parse_uint32(job, &attrs->attrib_bits);
                        if(!(rc == 0u))
                          return rc;

                        if(protocol->version >= 6)
                        {
                          rc=sftp_parse_uint32(job, &attrs->attrib_bits_valid);
                          if(!(rc == 0u))
                            return rc;

                        }

                        else
                          attrs->attrib_bits_valid = (unsigned int)0x7ff;
                      }

                      if(!((2048u & attrs->valid) == 0u))
                      {
                        rc=sftp_parse_uint8(job, &attrs->text_hint);
                        if(rc == 0u)
                          goto __CPROVER_DUMP_L20;

                        return rc;
                      }

                      else
                      {

                      __CPROVER_DUMP_L20:
                        ;
                        if(!((4096u & attrs->valid) == 0u))
                        {
                          rc=sftp_parse_string(job, &attrs->mime_type, ((unsigned long int *)NULL));
                          if(rc == 0u)
                            goto __CPROVER_DUMP_L21;

                          return rc;
                        }

                        else
                        {

                        __CPROVER_DUMP_L21:
                          ;
                          if(!((8192u & attrs->valid) == 0u))
                          {
                            rc=sftp_parse_uint32(job, &attrs->link_count);
                            if(rc == 0u)
                              goto __CPROVER_DUMP_L22;

                            return rc;
                          }

                          else
                          {

                          __CPROVER_DUMP_L22:
                            ;
                            if(!((16384u & attrs->valid) == 0u))
                            {
                              rc=sftp_parse_string(job, &attrs->mime_type, ((unsigned long int *)NULL));
                              if(rc == 0u)
                                goto __CPROVER_DUMP_L23;

                              return rc;
                            }

                            else
                            {

                            __CPROVER_DUMP_L23:
                              ;
                              if(!((0x80000000 & attrs->valid) == 0u))
                              {
                                rc=sftp_parse_uint32(job, &n);
                                if(!(rc == 0u))
                                  return rc;

                                do
                                {
                                  tmp_post_1 = n;
                                  n = n - 1u;
                                  if(!(tmp_post_1 >= 1u))
                                    break;

                                  rc=sftp_parse_string(job, ((char **)NULL), ((unsigned long int *)NULL));
                                  if(!(rc == 0u))
                                    return rc;

                                  rc=sftp_parse_string(job, ((char **)NULL), ((unsigned long int *)NULL));
                                  if(!(rc == 0u))
                                    return rc;

                                }
                                while((_Bool)1);
                              }

                              return (unsigned int)0;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
  }
}

// sftp_v456_sendattrs
// file v4.c line 49
void sftp_v456_sendattrs(struct sftpjob *job, struct sftpattr *attrs)
{
  const unsigned int valid = attrs->valid & protocol->attrmask;
  sftp_send_uint32(job->worker, valid);
  sftp_send_uint8(job->worker, (signed int)attrs->type);
  if(!((1u & valid) == 0u))
    sftp_send_uint64(job->worker, attrs->size);

  if(!((128u & valid) == 0u))
  {
    sftp_send_path(job, job->worker, attrs->owner);
    sftp_send_path(job, job->worker, attrs->group);
  }

  if(!((4u & valid) == 0u))
    sftp_send_uint32(job->worker, attrs->permissions);

  if(!((8u & valid) == 0u))
  {
    sftp_send_uint64(job->worker, (unsigned long int)attrs->atime.seconds);
    if(!((256u & valid) == 0u))
      sftp_send_uint32(job->worker, attrs->atime.nanoseconds);

  }

  if(!((16u & valid) == 0u))
  {
    sftp_send_uint64(job->worker, (unsigned long int)attrs->createtime.seconds);
    if(!((256u & valid) == 0u))
      sftp_send_uint32(job->worker, attrs->createtime.nanoseconds);

  }

  if(!((32u & valid) == 0u))
  {
    sftp_send_uint64(job->worker, (unsigned long int)attrs->mtime.seconds);
    if(!((256u & valid) == 0u))
      sftp_send_uint32(job->worker, attrs->mtime.nanoseconds);

  }

  if(!((32768u & valid) == 0u))
  {
    sftp_send_uint64(job->worker, (unsigned long int)attrs->ctime.seconds);
    if(!((256u & valid) == 0u))
      sftp_send_uint32(job->worker, attrs->ctime.nanoseconds);

  }

  if(!((64u & valid) == 0u))
    sftp_send_string(job->worker, attrs->acl);

  if(!((512u & valid) == 0u))
  {
    sftp_send_uint32(job->worker, attrs->attrib_bits);
    if(protocol->version >= 6)
      sftp_send_uint32(job->worker, attrs->attrib_bits_valid);

  }

  if(!((2048u & valid) == 0u))
    sftp_send_uint8(job->worker, (signed int)attrs->text_hint);

  if(!((4096u & valid) == 0u))
    sftp_send_string(job->worker, attrs->mime_type);

  if(!((8192u & valid) == 0u))
    sftp_send_uint32(job->worker, attrs->link_count);

}

// sftp_v456_sendnames
// file v4.c line 200
void sftp_v456_sendnames(struct sftpjob *job, signed int nnames, struct sftpattr *names)
{
  sftp_send_uint32(job->worker, (unsigned int)nnames);
  if(nnames >= 1)
  {
    sftp_send_path(job, job->worker, names->name);
    protocol->sendattrs(job, names);
    names = names + 1l;
    nnames = nnames - 1;
  }

}

// sftp_v456_stat
// file v4.c line 241
unsigned int sftp_v456_stat(struct sftpjob *job)
{
  char *path;
  struct stat sb;
  do
  {
    unsigned int rc;
    rc=sftp_parse_path(job, &path);
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v4.c", 245, (const void *)"sftp_parse_path(job, &path)", rc);

      while((_Bool)0);
      return rc;
    }

  }
  while((_Bool)0);
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_stat %s", path);

  while((_Bool)0);
  signed int return_value_stat_1;
  return_value_stat_1=stat(path, &sb);
  unsigned int return_value_sftp_v456_stat_core_2;
  return_value_sftp_v456_stat_core_2=sftp_v456_stat_core(job, return_value_stat_1, &sb, path);
  return return_value_sftp_v456_stat_core_2;
}

// sftp_v456_stat_core
// file v4.c line 214
static unsigned int sftp_v456_stat_core(struct sftpjob *job, signed int rc, struct stat *sb, const char *path)
{
  struct sftpattr attrs;
  unsigned int flags;
  if(rc == 0)
  {
    do
    {
      unsigned int sftp_v456_stat_core__1__1__1__rc;
      sftp_v456_stat_core__1__1__1__rc=sftp_parse_uint32(job, &flags);
      if(!(sftp_v456_stat_core__1__1__1__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v4.c", 220, (const void *)"sftp_parse_uint32(job, &flags)", sftp_v456_stat_core__1__1__1__rc);

        while((_Bool)0);
        return sftp_v456_stat_core__1__1__1__rc;
      }

    }
    while((_Bool)0);
    sftp_stat_to_attrs(job->a, sb, &attrs, flags, path);
    sftp_send_begin(job->worker);
    sftp_send_uint8(job->worker, 105);
    sftp_send_uint32(job->worker, job->id);
    protocol->sendattrs(job, &attrs);
    sftp_send_end(job->worker);
    return (unsigned int)-1;
  }

  else
    return (unsigned int)-2;
}

// sftp_v56_open
// file v5.c line 39
unsigned int sftp_v56_open(struct sftpjob *job)
{
  char *path;
  unsigned int desired_access;
  unsigned int flags;
  struct sftpattr attrs;
  do
  {
    unsigned int sftp_v56_open__1__1__rc;
    sftp_v56_open__1__1__rc=sftp_parse_path(job, &path);
    if(!(sftp_v56_open__1__1__rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v5.c", 44, (const void *)"sftp_parse_path(job, &path)", sftp_v56_open__1__1__rc);

      while((_Bool)0);
      return sftp_v56_open__1__1__rc;
    }

  }
  while((_Bool)0);
  do
  {
    unsigned int sftp_v56_open__1__2__rc;
    sftp_v56_open__1__2__rc=sftp_parse_uint32(job, &desired_access);
    if(!(sftp_v56_open__1__2__rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v5.c", 45, (const void *)"sftp_parse_uint32(job, &desired_access)", sftp_v56_open__1__2__rc);

      while((_Bool)0);
      return sftp_v56_open__1__2__rc;
    }

  }
  while((_Bool)0);
  do
  {
    unsigned int rc;
    rc=sftp_parse_uint32(job, &flags);
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v5.c", 46, (const void *)"sftp_parse_uint32(job, &flags)", rc);

      while((_Bool)0);
      return rc;
    }

  }
  while((_Bool)0);
  unsigned int sftp_v56_open__1__4__rc;
  sftp_v56_open__1__4__rc=protocol->parseattrs(job, &attrs);
  if(!(sftp_v56_open__1__4__rc == 0u))
  {
    if(!(sftp_debugging == 0))
      sftp_debug_printf("%s:%d: %s: %u", (const void *)"v5.c", 47, (const void *)"protocol->parseattrs(job, &attrs)", sftp_v56_open__1__4__rc);

    return sftp_v56_open__1__4__rc;
  }

  else
  {
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_v56_open %s %#x %#x", path, desired_access, flags);

    unsigned int return_value_sftp_generic_open_1;
    return_value_sftp_generic_open_1=sftp_generic_open(job, path, desired_access, flags, &attrs);
    return return_value_sftp_generic_open_1;
  }
}

// sftp_v56_rename
// file v5.c line 316
unsigned int sftp_v56_rename(struct sftpjob *job)
{
  char *oldpath;
  char *newpath;
  unsigned int flags;
  signed int return_value_unlink_6;
  if(!(readonly == 0))
    return (unsigned int)3;

  else
  {
    do
    {
      unsigned int rc;
      rc=sftp_parse_path(job, &oldpath);
      if(!(rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v5.c", 322, (const void *)"sftp_parse_path(job, &oldpath)", rc);

        while((_Bool)0);
        return rc;
      }

    }
    while((_Bool)0);
    do
    {
      unsigned int sftp_v56_rename__1__2__rc;
      sftp_v56_rename__1__2__rc=sftp_parse_path(job, &newpath);
      if(!(sftp_v56_rename__1__2__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v5.c", 323, (const void *)"sftp_parse_path(job, &newpath)", sftp_v56_rename__1__2__rc);

        while((_Bool)0);
        return sftp_v56_rename__1__2__rc;
      }

    }
    while((_Bool)0);
    do
    {
      unsigned int sftp_v56_rename__1__3__rc;
      sftp_v56_rename__1__3__rc=sftp_parse_uint32(job, &flags);
      if(!(sftp_v56_rename__1__3__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v5.c", 324, (const void *)"sftp_parse_uint32(job, &flags)", sftp_v56_rename__1__3__rc);

        while((_Bool)0);
        return sftp_v56_rename__1__3__rc;
      }

    }
    while((_Bool)0);
    do
      if(!(sftp_debugging == 0))
        sftp_debug_printf("sftp_v56_rename %s %s %#x", oldpath, newpath, flags);

    while((_Bool)0);
    if(!((5u & flags) == 0u))
    {
      signed int return_value_rename_1;
      return_value_rename_1=rename(oldpath, newpath);
      if(!(return_value_rename_1 >= 0))
        return (unsigned int)-2;

      else
        return (unsigned int)0;
    }

    else
    {
      signed int return_value_link_7;
      return_value_link_7=link(oldpath, newpath);
      if(!(return_value_link_7 >= 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        if(!(*return_value___errno_location_3 == 17))
        {
          signed int return_value_rename_2;
          return_value_rename_2=rename(oldpath, newpath);
          if(!(return_value_rename_2 >= 0))
            return (unsigned int)-2;

          else
            return (unsigned int)0;
        }

        else
          return (unsigned int)11;
      }

      else
      {
        return_value_unlink_6=unlink(oldpath);
        if(!(return_value_unlink_6 >= 0))
        {
          signed int save_errno;
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          save_errno = *return_value___errno_location_4;
          unlink(newpath);
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          *return_value___errno_location_5 = save_errno;
          return (unsigned int)-2;
        }

        else
          return (unsigned int)0;
      }
    }
  }
}

// sftp_v6_link
// file v6.c line 112
unsigned int sftp_v6_link(struct sftpjob *job)
{
  char *oldpath;
  char *newlinkpath;
  unsigned char symbolic;
  struct stat sb;
  _Bool tmp_if_expr_3;
  signed int return_value_stat_2;
  if(!(readonly == 0))
    return (unsigned int)3;

  else
  {
    do
    {
      unsigned int sftp_v6_link__1__1__rc;
      sftp_v6_link__1__1__rc=sftp_parse_path(job, &newlinkpath);
      if(!(sftp_v6_link__1__1__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v6.c", 120, (const void *)"sftp_parse_path(job, &newlinkpath)", sftp_v6_link__1__1__rc);

        while((_Bool)0);
        return sftp_v6_link__1__1__rc;
      }

    }
    while((_Bool)0);
    do
    {
      unsigned int sftp_v6_link__1__2__rc;
      sftp_v6_link__1__2__rc=sftp_parse_path(job, &oldpath);
      if(!(sftp_v6_link__1__2__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v6.c", 121, (const void *)"sftp_parse_path(job, &oldpath)", sftp_v6_link__1__2__rc);

        while((_Bool)0);
        return sftp_v6_link__1__2__rc;
      }

    }
    while((_Bool)0);
    do
    {
      unsigned int rc;
      rc=sftp_parse_uint8(job, &symbolic);
      if(!(rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v6.c", 122, (const void *)"sftp_parse_uint8(job, &symbolic)", rc);

        while((_Bool)0);
        return rc;
      }

    }
    while((_Bool)0);
    do
      if(!(sftp_debugging == 0))
        sftp_debug_printf("sftp_link %s %s [%s]", oldpath, newlinkpath, symbolic != 0 ? "symbolic" : "hard");

    while((_Bool)0);
    signed int return_value;
    return_value=(symbolic != 0 ? symlink : link)(oldpath, newlinkpath);
    if(!(return_value >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 1)
      {
        if(symbolic == 0)
        {
          return_value_stat_2=stat(oldpath, &sb);
          tmp_if_expr_3 = return_value_stat_2 >= 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_3 = (_Bool)0;
        if((61440u & sb.st_mode) == 16384u && tmp_if_expr_3)
          return (unsigned int)24;

        else
          return (unsigned int)8;
      }

      return (unsigned int)-2;
    }

    else
      return (unsigned int)0;
  }
}

// sftp_v6_realpath
// file v6.c line 36
unsigned int sftp_v6_realpath(struct sftpjob *job)
{
  char *path;
  char *compose;
  char *resolvedpath;
  unsigned char control_byte = (unsigned char)0x00000001;
  unsigned int rpflags = (unsigned int)0;
  struct stat sb;
  struct sftpattr attrs;
  do
  {
    unsigned int rc;
    rc=sftp_parse_path(job, &path);
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v6.c", 43, (const void *)"sftp_parse_path(job, &path)", rc);

      while((_Bool)0);
      return rc;
    }

  }
  while((_Bool)0);
  if(!(job->left == 0ul))
  {
    do
    {
      unsigned int sftp_v6_realpath__1__2__1__rc;
      sftp_v6_realpath__1__2__1__rc=sftp_parse_uint8(job, &control_byte);
      if(!(sftp_v6_realpath__1__2__1__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v6.c", 45, (const void *)"sftp_parse_uint8(job, &control_byte)", sftp_v6_realpath__1__2__1__rc);

        while((_Bool)0);
        return sftp_v6_realpath__1__2__1__rc;
      }

    }
    while((_Bool)0);
    while(!(job->left == 0ul))
    {
      do
      {
        unsigned int sftp_v6_realpath__1__2__2__1__rc;
        sftp_v6_realpath__1__2__2__1__rc=sftp_parse_path(job, &compose);
        if(!(sftp_v6_realpath__1__2__2__1__rc == 0u))
        {
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("%s:%d: %s: %u", (const void *)"v6.c", 47, (const void *)"sftp_parse_path(job, &compose)", sftp_v6_realpath__1__2__2__1__rc);

          while((_Bool)0);
          return sftp_v6_realpath__1__2__2__1__rc;
        }

      }
      while((_Bool)0);
      if((signed int)*compose == 47)
        path = compose;

      else
      {
        char *newpath;
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(path);
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(compose);
        void *return_value_sftp_alloc_3;
        return_value_sftp_alloc_3=sftp_alloc(job->a, return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)2);
        newpath = (char *)return_value_sftp_alloc_3;
        strcpy(newpath, path);
        strcat(newpath, "/");
        strcat(newpath, compose);
        path = newpath;
      }
    }
  }

  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_v6_realpath %s %#x", path, control_byte);

  while((_Bool)0);
  switch((signed int)control_byte)
  {
    case 0x00000001:
    {
      rpflags = (unsigned int)0;
      break;
    }
    case 0x00000002:
    {
      rpflags = (unsigned int)0x0001;
      break;
    }
    case 0x00000003:
    {
      rpflags = (unsigned int)(0x0001 | 0x0002);
      break;
    }
    default:
      return (unsigned int)5;
  }
  resolvedpath=sftp_find_realpath(job->a, path, rpflags);
  signed int return_value_stat_4;
  _Bool tmp_if_expr_6;
  signed int return_value_lstat_5;
  signed int return_value_stat_7;
  _Bool tmp_if_expr_9;
  signed int return_value_lstat_8;
  if(resolvedpath == ((char *)NULL))
    return (unsigned int)-2;

  else
  {
    do
      if(!(sftp_debugging == 0))
        sftp_debug_printf("...real path is %s", resolvedpath);

    while((_Bool)0);
    switch((signed int)control_byte)
    {
      case 0x00000001:
      {
        memset((void *)&attrs, 0, sizeof(struct sftpattr) /*200ul*/ );
        attrs.name = resolvedpath;
        break;
      }
      case 0x00000002:
      {
        return_value_stat_4=stat(resolvedpath, &sb);
        if(return_value_stat_4 >= 0)
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          return_value_lstat_5=lstat(resolvedpath, &sb);
          tmp_if_expr_6 = return_value_lstat_5 >= 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
          sftp_stat_to_attrs(job->a, &sb, &attrs, 0xFFFFFFFF, resolvedpath);

        else
        {
          memset((void *)&attrs, 0, sizeof(struct sftpattr) /*200ul*/ );
          attrs.name = resolvedpath;
        }
        break;
      }
      case 0x00000003:
      {
        return_value_stat_7=stat(resolvedpath, &sb);
        if(return_value_stat_7 >= 0)
          tmp_if_expr_9 = (_Bool)1;

        else
        {
          return_value_lstat_8=lstat(resolvedpath, &sb);
          tmp_if_expr_9 = return_value_lstat_8 >= 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_9)
          sftp_stat_to_attrs(job->a, &sb, &attrs, 0xFFFFFFFF, resolvedpath);

        else
          return (unsigned int)-2;
      }
    }
    sftp_send_begin(job->worker);
    sftp_send_uint8(job->worker, 104);
    sftp_send_uint32(job->worker, job->id);
    protocol->sendnames(job, 1, &attrs);
    sftp_send_end(job->worker);
    return (unsigned int)-1;
  }
}

// sftp_v6_version_select
// file v6.c line 142
unsigned int sftp_v6_version_select(struct sftpjob *job)
{
  char *newversion;
  if(workqueue == ((struct queue *)NULL))
  {
    do
    {
      unsigned int rc;
      rc=sftp_parse_path(job, &newversion);
      if(!(rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v6.c", 148, (const void *)"sftp_parse_path(job, &newversion)", rc);

        while((_Bool)0);
        return rc;
      }

    }
    while((_Bool)0);
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(newversion, "3");
    if(return_value_strcmp_1 == 0)
    {
      protocol = &sftp_v3;
      return (unsigned int)0;
    }

    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(newversion, "4");
    if(return_value_strcmp_2 == 0)
    {
      protocol = &sftp_v4;
      return (unsigned int)0;
    }

    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(newversion, "5");
    if(return_value_strcmp_3 == 0)
    {
      protocol = &sftp_v5;
      return (unsigned int)0;
    }

    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(newversion, "6");
    if(return_value_strcmp_4 == 0)
    {
      protocol = &sftp_v6;
      return (unsigned int)0;
    }

    sftp_send_status(job, (unsigned int)23, "unknown version");
  }

  else
    sftp_send_status(job, (unsigned int)23, "badly timed version-select");
  exit(-1);
}

// sftp_vany_already_init
// file v3.c line 188
unsigned int sftp_vany_already_init(struct sftpjob *job)
{
  return (unsigned int)4;
}

// sftp_vany_close
// file v3.c line 440
unsigned int sftp_vany_close(struct sftpjob *job)
{
  struct handleid id;
  do
  {
    unsigned int rc;
    rc=sftp_parse_handle(job, &id);
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 443, (const void *)"sftp_parse_handle(job, &id)", rc);

      while((_Bool)0);
      return rc;
    }

  }
  while((_Bool)0);
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_vany_close %u %u", id.id, id.tag);

  while((_Bool)0);
  unsigned int return_value_sftp_handle_close_1;
  return_value_sftp_handle_close_1=sftp_handle_close(&id);
  return return_value_sftp_handle_close_1;
}

// sftp_vany_extended
// file sftpserver.h line 148
unsigned int sftp_vany_extended(struct sftpjob *job)
{
  char *name;
  signed int n;
  do
  {
    unsigned int rc;
    rc=sftp_parse_string(job, &name, ((unsigned long int *)NULL));
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v5.c", 443, (const void *)"sftp_parse_string(job, &name, 0)", rc);

      while((_Bool)0);
      return rc;
    }

  }
  while((_Bool)0);
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("extension %s", name);

  while((_Bool)0);
  n = 0;
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  do
  {
    if(!(n >= protocol->nextensions))
    {
      return_value_strcmp_1=strcmp(name, (protocol->extensions + (signed long int)n)->name);
      tmp_if_expr_2 = return_value_strcmp_1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      break;

    n = n + 1;
  }
  while((_Bool)1);
  unsigned int return_value;
  if(n >= protocol->nextensions)
    return (unsigned int)8;

  else
  {
    return_value=(protocol->extensions + (signed long int)n)->handler(job);
    return return_value;
  }
}

// sftp_vany_fsetstat
// file v3.c line 536
unsigned int sftp_vany_fsetstat(struct sftpjob *job)
{
  struct handleid id;
  struct sftpattr attrs;
  signed int fd;
  unsigned int rc;
  if(!(readonly == 0))
    return (unsigned int)3;

  else
  {
    do
    {
      unsigned int sftp_vany_fsetstat__1__1__rc;
      sftp_vany_fsetstat__1__1__rc=sftp_parse_handle(job, &id);
      if(!(sftp_vany_fsetstat__1__1__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 544, (const void *)"sftp_parse_handle(job, &id)", sftp_vany_fsetstat__1__1__rc);

        while((_Bool)0);
        return sftp_vany_fsetstat__1__1__rc;
      }

    }
    while((_Bool)0);
    unsigned int sftp_vany_fsetstat__1__2__rc;
    sftp_vany_fsetstat__1__2__rc=protocol->parseattrs(job, &attrs);
    if(!(sftp_vany_fsetstat__1__2__rc == 0u))
    {
      if(!(sftp_debugging == 0))
        sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 545, (const void *)"protocol->parseattrs(job, &attrs)", sftp_vany_fsetstat__1__2__rc);

      return sftp_vany_fsetstat__1__2__rc;
    }

    else
    {
      if(!(sftp_debugging == 0))
        sftp_debug_printf("sftp_vany_fsetstat %u %u", id.id, id.tag);

      rc=sftp_normalize_ownergroup(job->a, &attrs);
      if(!(rc == 0u))
        return rc;

      else
      {
        rc=sftp_handle_get_fd(&id, &fd, ((unsigned int *)NULL));
        if(!(rc == 0u))
          return rc;

        else
        {
          unsigned int return_value_sftp_set_fstatus_1;
          return_value_sftp_set_fstatus_1=sftp_set_fstatus(job->a, fd, &attrs, ((const char **)NULL));
          return return_value_sftp_set_fstatus_1;
        }
      }
    }
  }
}

// sftp_vany_mkdir
// file v3.c line 555
unsigned int sftp_vany_mkdir(struct sftpjob *job)
{
  char *path;
  struct sftpattr attrs;
  unsigned int rc;
  if(!(readonly == 0))
    return (unsigned int)3;

  else
  {
    do
    {
      unsigned int sftp_vany_mkdir__1__1__rc;
      sftp_vany_mkdir__1__1__rc=sftp_parse_path(job, &path);
      if(!(sftp_vany_mkdir__1__1__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 562, (const void *)"sftp_parse_path(job, &path)", sftp_vany_mkdir__1__1__rc);

        while((_Bool)0);
        return sftp_vany_mkdir__1__1__rc;
      }

    }
    while((_Bool)0);
    unsigned int sftp_vany_mkdir__1__2__rc;
    sftp_vany_mkdir__1__2__rc=protocol->parseattrs(job, &attrs);
    if(!(sftp_vany_mkdir__1__2__rc == 0u))
    {
      if(!(sftp_debugging == 0))
        sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 563, (const void *)"protocol->parseattrs(job, &attrs)", sftp_vany_mkdir__1__2__rc);

      return sftp_vany_mkdir__1__2__rc;
    }

    else
    {
      if(!(sftp_debugging == 0))
        sftp_debug_printf("sftp_vany_mkdir %s", path);

      attrs.valid = attrs.valid & (unsigned int)~0x00000001;
      if(!((4u & attrs.valid) == 0u))
      {
        if(!(sftp_debugging == 0))
          sftp_debug_printf("initial permissions are %#o (%d decimal)", attrs.permissions, attrs.permissions);

        signed int return_value_mkdir_1;
        return_value_mkdir_1=mkdir(path, attrs.permissions & (unsigned int)07777);
        if(!(return_value_mkdir_1 >= 0))
          return (unsigned int)-2;

        if(attrs.permissions == (511u & attrs.permissions))
          attrs.valid = attrs.valid ^ (unsigned int)0x00000004;

      }

      else
      {
        signed int return_value_mkdir_2;
        return_value_mkdir_2=mkdir(path, (unsigned int)0755);
        if(!(return_value_mkdir_2 >= 0))
          return (unsigned int)-2;

      }
      rc=sftp_set_status(job->a, path, &attrs, ((const char **)NULL));
      if(!(rc == 0u))
      {
        signed int save_errno;
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        save_errno = *return_value___errno_location_3;
        rmdir(path);
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        *return_value___errno_location_4 = save_errno;
        return rc;
      }

      return (unsigned int)0;
    }
  }
}

// sftp_vany_opendir
// file v3.c line 366
unsigned int sftp_vany_opendir(struct sftpjob *job)
{
  char *path;
  struct __dirstream *dp;
  struct handleid id;
  do
  {
    unsigned int rc;
    rc=sftp_parse_path(job, &path);
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 371, (const void *)"sftp_parse_path(job, &path)", rc);

      while((_Bool)0);
      return rc;
    }

  }
  while((_Bool)0);
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_vany_opendir %s", path);

  while((_Bool)0);
  dp=opendir(path);
  if(dp == ((struct __dirstream *)NULL))
    return (unsigned int)-2;

  else
  {
    sftp_handle_new_dir(&id, dp, path);
    do
      if(!(sftp_debugging == 0))
        sftp_debug_printf("...handle is %u %u", id.id, id.tag);

    while((_Bool)0);
    sftp_send_begin(job->worker);
    sftp_send_uint8(job->worker, 102);
    sftp_send_uint32(job->worker, job->id);
    sftp_send_handle(job->worker, &id);
    sftp_send_end(job->worker);
    return (unsigned int)-1;
  }
}

// sftp_vany_posix_rename
// file v3.c line 716
unsigned int sftp_vany_posix_rename(struct sftpjob *job)
{
  char *oldpath;
  char *newpath;
  if(!(readonly == 0))
    return (unsigned int)3;

  else
  {
    do
    {
      unsigned int rc;
      rc=sftp_parse_path(job, &oldpath);
      if(!(rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 721, (const void *)"sftp_parse_path(job, &oldpath)", rc);

        while((_Bool)0);
        return rc;
      }

    }
    while((_Bool)0);
    do
    {
      unsigned int sftp_vany_posix_rename__1__2__rc;
      sftp_vany_posix_rename__1__2__rc=sftp_parse_path(job, &newpath);
      if(!(sftp_vany_posix_rename__1__2__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 722, (const void *)"sftp_parse_path(job, &newpath)", sftp_vany_posix_rename__1__2__rc);

        while((_Bool)0);
        return sftp_vany_posix_rename__1__2__rc;
      }

    }
    while((_Bool)0);
    do
      if(!(sftp_debugging == 0))
        sftp_debug_printf("sftp_vany_posix_rename %s %s", oldpath, newpath);

    while((_Bool)0);
    signed int return_value_rename_1;
    return_value_rename_1=rename(oldpath, newpath);
    if(!(return_value_rename_1 >= 0))
      return (unsigned int)-2;

    else
      return (unsigned int)0;
  }
}

// sftp_vany_read
// file v3.c line 639
unsigned int sftp_vany_read(struct sftpjob *job)
{
  struct handleid id;
  unsigned long int offset;
  unsigned int len;
  unsigned int rc;
  signed long int n;
  signed int fd;
  unsigned int flags;
  do
  {
    unsigned int sftp_vany_read__1__1__rc;
    sftp_vany_read__1__1__rc=sftp_parse_handle(job, &id);
    if(!(sftp_vany_read__1__1__rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 647, (const void *)"sftp_parse_handle(job, &id)", sftp_vany_read__1__1__rc);

      while((_Bool)0);
      return sftp_vany_read__1__1__rc;
    }

  }
  while((_Bool)0);
  do
  {
    unsigned int sftp_vany_read__1__2__rc;
    sftp_vany_read__1__2__rc=sftp_parse_uint64(job, &offset);
    if(!(sftp_vany_read__1__2__rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 648, (const void *)"sftp_parse_uint64(job, &offset)", sftp_vany_read__1__2__rc);

      while((_Bool)0);
      return sftp_vany_read__1__2__rc;
    }

  }
  while((_Bool)0);
  do
  {
    unsigned int sftp_vany_read__1__3__rc;
    sftp_vany_read__1__3__rc=sftp_parse_uint32(job, &len);
    if(!(sftp_vany_read__1__3__rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 649, (const void *)"sftp_parse_uint32(job, &len)", sftp_vany_read__1__3__rc);

      while((_Bool)0);
      return sftp_vany_read__1__3__rc;
    }

  }
  while((_Bool)0);
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_vany_read %x %u %u: %u bytes at %lu", job->id, id.id, id.tag, len, offset);

  while((_Bool)0);
  if(len >= 1048577u)
    len = (unsigned int)1048576;

  rc=sftp_handle_get_fd(&id, &fd, &flags);
  if(!(rc == 0u))
    return rc;

  else
  {
    sftp_send_begin(job->worker);
    sftp_send_uint8(job->worker, 103);
    sftp_send_uint32(job->worker, job->id);
    sftp_send_need(job->worker, (unsigned long int)(len + (unsigned int)4));
    if(!((3u & flags) == 0u))
      n=read(fd, (void *)(job->worker->buffer + (signed long int)job->worker->bufused + (signed long int)4), (unsigned long int)len);

    else
      n=pread(fd, (void *)(job->worker->buffer + (signed long int)job->worker->bufused + (signed long int)4), (unsigned long int)len, (signed long int)offset);
    if(n >= 1l)
    {
      sftp_send_uint32(job->worker, (unsigned int)n);
      job->worker->bufused = job->worker->bufused + (unsigned long int)n;
      sftp_send_end(job->worker);
      return (unsigned int)-1;
    }

    else
      if(n == 0l)
        return (unsigned int)1;

      else
        return (unsigned int)-2;
  }
}

// sftp_vany_readdir
// file v3.c line 385
unsigned int sftp_vany_readdir(struct sftpjob *job)
{
  struct handleid id;
  struct __dirstream *dp;
  unsigned int sftp_vany_readdir__1__rc;
  struct sftpattr d[32l];
  signed int n;
  struct dirent *de;
  const char *path;
  char *childpath;
  char *fullpath;
  struct stat sb;
  do
  {
    unsigned int rc;
    rc=sftp_parse_handle(job, &id);
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 396, (const void *)"sftp_parse_handle(job, &id)", rc);

      while((_Bool)0);
      return rc;
    }

  }
  while((_Bool)0);
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_vany_readdir %u %u", id.id, id.tag);

  while((_Bool)0);
  sftp_vany_readdir__1__rc=sftp_handle_get_dir(&id, &dp, &path);
  if(!(sftp_vany_readdir__1__rc == 0u))
  {
    sftp_send_status(job, sftp_vany_readdir__1__rc, "invalid directory handle");
    return (unsigned int)-1;
  }

  else
  {
    memset((void *)d, 0, sizeof(struct sftpattr [32l]) /*6400ul*/ );
    n = 0;
    while(!(n >= 32))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 0;
      de=readdir(dp);
      if(de == ((struct dirent *)NULL))
        break;

      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(de->d_name);
      void *return_value_sftp_alloc_3;
      return_value_sftp_alloc_3=sftp_alloc(job->a, return_value_strlen_2 + (unsigned long int)1);
      childpath=strcpy((char *)return_value_sftp_alloc_3, de->d_name);
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(path);
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(childpath);
      void *return_value_sftp_alloc_6;
      return_value_sftp_alloc_6=sftp_alloc(job->a, return_value_strlen_4 + return_value_strlen_5 + (unsigned long int)2);
      fullpath = (char *)return_value_sftp_alloc_6;
      strcpy(fullpath, path);
      strcat(fullpath, "/");
      strcat(fullpath, childpath);
      signed int return_value_lstat_7;
      return_value_lstat_7=lstat(fullpath, &sb);
      if(!(return_value_lstat_7 == 0))
        return (unsigned int)-2;

      sftp_stat_to_attrs(job->a, &sb, &d[(signed long int)n], 0xFFFFFFFF, childpath);
      d[(signed long int)n].name = childpath;
      n = n + 1;
      signed int *return_value___errno_location_8;
      return_value___errno_location_8=__errno_location();
      *return_value___errno_location_8 = 0;
    }
    signed int *return_value___errno_location_9;
    return_value___errno_location_9=__errno_location();
    if(!(*return_value___errno_location_9 == 0))
      return (unsigned int)-2;

    else
      if(!(n == 0))
      {
        sftp_send_begin(job->worker);
        sftp_send_uint8(job->worker, 104);
        sftp_send_uint32(job->worker, job->id);
        protocol->sendnames(job, n, d);
        sftp_send_end(job->worker);
        return (unsigned int)-1;
      }

      else
        return (unsigned int)1;
  }
}

// sftp_vany_readlink
// file v3.c line 343
unsigned int sftp_vany_readlink(struct sftpjob *job)
{
  char *path;
  char *result;
  struct sftpattr attr;
  do
  {
    unsigned int rc;
    rc=sftp_parse_path(job, &path);
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 347, (const void *)"sftp_parse_path(job, &path)", rc);

      while((_Bool)0);
      return rc;
    }

  }
  while((_Bool)0);
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_vany_readlink %s", path);

  while((_Bool)0);
  result=sftp_do_readlink(job->a, path);
  if(result == ((char *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 7)
    {
      sftp_send_status(job, (unsigned int)4, "link name is too long");
      return (unsigned int)-1;
    }

    return (unsigned int)-2;
  }

  memset((void *)&attr, 0, sizeof(struct sftpattr) /*200ul*/ );
  attr.name = result;
  sftp_send_begin(job->worker);
  sftp_send_uint8(job->worker, 104);
  sftp_send_uint32(job->worker, job->id);
  protocol->sendnames(job, 1, &attr);
  sftp_send_end(job->worker);
  return (unsigned int)-1;
}

// sftp_vany_remove
// file v3.c line 193
unsigned int sftp_vany_remove(struct sftpjob *job)
{
  char *path;
  struct stat sb;
  if(!(readonly == 0))
    return (unsigned int)3;

  else
  {
    do
    {
      unsigned int rc;
      rc=sftp_parse_path(job, &path);
      if(!(rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 199, (const void *)"sftp_parse_path(job, &path)", rc);

        while((_Bool)0);
        return rc;
      }

    }
    while((_Bool)0);
    do
      if(!(sftp_debugging == 0))
        sftp_debug_printf("sftp_vany_remove %s", path);

    while((_Bool)0);
    signed int return_value_unlink_4;
    return_value_unlink_4=unlink(path);
    if(!(return_value_unlink_4 >= 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      if(*return_value___errno_location_3 == 1)
      {
        signed int return_value_lstat_1;
        return_value_lstat_1=lstat(path, &sb);
        if(return_value_lstat_1 == 0)
        {
          if((61440u & sb.st_mode) == 16384u)
            return (unsigned int)24;

        }

        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = 1;
      }

      return (unsigned int)-2;
    }

    else
      return (unsigned int)0;
  }
}

// sftp_vany_rmdir
// file v3.c line 212
unsigned int sftp_vany_rmdir(struct sftpjob *job)
{
  char *path;
  signed int *return_value___errno_location_1;
  if(!(readonly == 0))
    return (unsigned int)3;

  else
  {
    do
    {
      unsigned int rc;
      rc=sftp_parse_path(job, &path);
      if(!(rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 217, (const void *)"sftp_parse_path(job, &path)", rc);

        while((_Bool)0);
        return rc;
      }

    }
    while((_Bool)0);
    do
      if(!(sftp_debugging == 0))
        sftp_debug_printf("sftp_vany_rmdir %s", path);

    while((_Bool)0);
    signed int return_value_rmdir_2;
    return_value_rmdir_2=rmdir(path);
    if(!(return_value_rmdir_2 >= 0))
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 17)
        return (unsigned int)18;

      else
        return (unsigned int)-2;
    }

    else
      return (unsigned int)0;
  }
}

// sftp_vany_setstat
// file v3.c line 520
unsigned int sftp_vany_setstat(struct sftpjob *job)
{
  char *path;
  struct sftpattr attrs;
  unsigned int sftp_vany_setstat__1__rc;
  if(!(readonly == 0))
    return (unsigned int)3;

  else
  {
    do
    {
      unsigned int rc;
      rc=sftp_parse_path(job, &path);
      if(!(rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 527, (const void *)"sftp_parse_path(job, &path)", rc);

        while((_Bool)0);
        return rc;
      }

    }
    while((_Bool)0);
    unsigned int sftp_vany_setstat__1__2__rc;
    sftp_vany_setstat__1__2__rc=protocol->parseattrs(job, &attrs);
    if(!(sftp_vany_setstat__1__2__rc == 0u))
    {
      if(!(sftp_debugging == 0))
        sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 528, (const void *)"protocol->parseattrs(job, &attrs)", sftp_vany_setstat__1__2__rc);

      return sftp_vany_setstat__1__2__rc;
    }

    else
    {
      if(!(sftp_debugging == 0))
        sftp_debug_printf("sftp_vany_setstat %s", path);

      sftp_vany_setstat__1__rc=sftp_normalize_ownergroup(job->a, &attrs);
      if(!(sftp_vany_setstat__1__rc == 0u))
        return sftp_vany_setstat__1__rc;

      else
      {
        unsigned int return_value_sftp_set_status_1;
        return_value_sftp_set_status_1=sftp_set_status(job->a, path, &attrs, ((const char **)NULL));
        return return_value_sftp_set_status_1;
      }
    }
  }
}

// sftp_vany_space_available
// file sftpserver.h line 311
unsigned int sftp_vany_space_available(struct sftpjob *job)
{
  char *path;
  struct statvfs fs;
  do
  {
    unsigned int rc;
    rc=sftp_parse_string(job, &path, ((unsigned long int *)NULL));
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v5.c", 418, (const void *)"sftp_parse_string(job, &path, 0)", rc);

      while((_Bool)0);
      return rc;
    }

  }
  while((_Bool)0);
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_space_available %s", path);

  while((_Bool)0);
  signed int return_value_statvfs_1;
  return_value_statvfs_1=statvfs(path, &fs);
  if(!(return_value_statvfs_1 >= 0))
    return (unsigned int)-2;

  else
  {
    sftp_send_begin(job->worker);
    sftp_send_uint8(job->worker, 201);
    sftp_send_uint32(job->worker, job->id);
    sftp_send_uint64(job->worker, (unsigned long int)fs.f_frsize * (unsigned long int)fs.f_blocks);
    sftp_send_uint64(job->worker, (unsigned long int)fs.f_frsize * (unsigned long int)fs.f_bfree);
    sftp_send_uint64(job->worker, (unsigned long int)0);
    sftp_send_uint64(job->worker, (unsigned long int)fs.f_frsize * (unsigned long int)fs.f_bavail);
    sftp_send_uint32(job->worker, (unsigned int)fs.f_frsize);
    sftp_send_end(job->worker);
    return (unsigned int)-1;
  }
}

// sftp_vany_statfs
// file v3.c line 730
unsigned int sftp_vany_statfs(struct sftpjob *job)
{
  char *path;
  struct statvfs fs;
  do
  {
    unsigned int rc;
    rc=sftp_parse_path(job, &path);
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 734, (const void *)"sftp_parse_path(job, &path)", rc);

      while((_Bool)0);
      return rc;
    }

  }
  while((_Bool)0);
  do
    if(!(sftp_debugging == 0))
      sftp_debug_printf("sftp_vany_statfs %s", path);

  while((_Bool)0);
  signed int return_value_statvfs_1;
  return_value_statvfs_1=statvfs(path, &fs);
  if(!(return_value_statvfs_1 >= 0))
    return (unsigned int)-2;

  else
  {
    sftp_send_begin(job->worker);
    sftp_send_uint8(job->worker, 201);
    sftp_send_uint32(job->worker, job->id);
    sftp_send_uint32(job->worker, (unsigned int)fs.f_frsize);
    sftp_send_uint64(job->worker, fs.f_blocks);
    sftp_send_uint64(job->worker, fs.f_bfree);
    sftp_send_uint64(job->worker, fs.f_bavail);
    sftp_send_uint64(job->worker, fs.f_files);
    sftp_send_uint64(job->worker, fs.f_ffree);
    sftp_send_end(job->worker);
    return (unsigned int)-1;
  }
}

// sftp_vany_text_seek
// file sftpserver.h line 293
unsigned int sftp_vany_text_seek(struct sftpjob *job)
{
  struct handleid id;
  unsigned long int line;
  signed int fd;
  char buffer[8192l];
  signed long int n;
  signed long int i;
  unsigned int sftp_vany_text_seek__1__rc;
  do
  {
    unsigned int sftp_vany_text_seek__1__1__rc;
    sftp_vany_text_seek__1__1__rc=sftp_parse_handle(job, &id);
    if(!(sftp_vany_text_seek__1__1__rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v5.c", 376, (const void *)"sftp_parse_handle(job, &id)", sftp_vany_text_seek__1__1__rc);

      while((_Bool)0);
      return sftp_vany_text_seek__1__1__rc;
    }

  }
  while((_Bool)0);
  do
  {
    unsigned int rc;
    rc=sftp_parse_uint64(job, &line);
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s: %u", (const void *)"v5.c", 377, (const void *)"sftp_parse_uint64(job, &line)", rc);

      while((_Bool)0);
      return rc;
    }

  }
  while((_Bool)0);
  sftp_vany_text_seek__1__rc=sftp_handle_get_fd(&id, &fd, ((unsigned int *)NULL));
  signed long int tmp_post_2;
  if(!(sftp_vany_text_seek__1__rc == 0u))
    return sftp_vany_text_seek__1__rc;

  else
  {
    signed long int return_value_lseek_1;
    return_value_lseek_1=lseek(fd, (signed long int)0, 0);
    if(!(return_value_lseek_1 >= 0l))
      return (unsigned int)-2;

    else
      if(line == 0ul)
        return (unsigned int)0;

      else
      {
        i = (signed long int)0;
        n = (signed long int)0;
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("on entry: line=%lu", line);

        while((_Bool)0);
        while(line >= 1ul)
        {
          n=read(fd, (void *)buffer, sizeof(char [8192l]) /*8192ul*/ );
          if(!(n >= 1l))
            break;

          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("outer: line=%lu n=%zd", line, n);

          while((_Bool)0);
          i = (signed long int)0;
          while(line >= 1ul && !(i >= n))
          {
            tmp_post_2 = i;
            i = i + 1l;
            if((signed int)buffer[tmp_post_2] == 10)
              line = line - 1ul;

          }
        }
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("exited:: line=%lu n=%zd i=%zd", line, n, i);

        while((_Bool)0);
        if(!(n >= 0l))
          return (unsigned int)-2;

        else
          if(n == 0l)
            return (unsigned int)1;

          else
          {
            signed long int return_value_lseek_3;
            return_value_lseek_3=lseek(fd, i - n, 1);
            if(!(return_value_lseek_3 >= 0l))
              return (unsigned int)-2;

            return (unsigned int)0;
          }
      }
  }
}

// sftp_vany_write
// file v3.c line 681
unsigned int sftp_vany_write(struct sftpjob *job)
{
  struct handleid id;
  unsigned long int offset;
  unsigned int len;
  unsigned int sftp_vany_write__1__rc;
  signed long int n;
  signed int fd;
  unsigned int flags;
  if(!(readonly == 0))
    return (unsigned int)3;

  else
  {
    do
    {
      unsigned int sftp_vany_write__1__1__rc;
      sftp_vany_write__1__1__rc=sftp_parse_handle(job, &id);
      if(!(sftp_vany_write__1__1__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 691, (const void *)"sftp_parse_handle(job, &id)", sftp_vany_write__1__1__rc);

        while((_Bool)0);
        return sftp_vany_write__1__1__rc;
      }

    }
    while((_Bool)0);
    do
    {
      unsigned int rc;
      rc=sftp_parse_uint64(job, &offset);
      if(!(rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 692, (const void *)"sftp_parse_uint64(job, &offset)", rc);

        while((_Bool)0);
        return rc;
      }

    }
    while((_Bool)0);
    do
    {
      unsigned int sftp_vany_write__1__3__rc;
      sftp_vany_write__1__3__rc=sftp_parse_uint32(job, &len);
      if(!(sftp_vany_write__1__3__rc == 0u))
      {
        do
          if(!(sftp_debugging == 0))
            sftp_debug_printf("%s:%d: %s: %u", (const void *)"v3.c", 693, (const void *)"sftp_parse_uint32(job, &len)", sftp_vany_write__1__3__rc);

        while((_Bool)0);
        return sftp_vany_write__1__3__rc;
      }

    }
    while((_Bool)0);
    if(!(job->left >= (unsigned long int)len))
      return (unsigned int)5;

    else
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("sftp_vany_write %u %u: %u bytes at %lu", id.id, id.tag, len, offset);

      while((_Bool)0);
      sftp_vany_write__1__rc=sftp_handle_get_fd(&id, &fd, &flags);
      if(!(sftp_vany_write__1__rc == 0u))
        return sftp_vany_write__1__rc;

      else
      {
        for( ; len >= 1u; offset = offset + (unsigned long int)n)
        {
          if(!((3u & flags) == 0u))
            n=write(fd, (const void *)job->ptr, (unsigned long int)len);

          else
            n=pwrite(fd, (const void *)job->ptr, (unsigned long int)len, (signed long int)offset);
          if(!(n >= 0l))
            return (unsigned int)-2;

          job->ptr = job->ptr + n;
          job->left = job->left + (unsigned long int)n;
          len = len - (unsigned int)n;
        }
        return (unsigned int)0;
      }
    }
  }
}

// sort_by_mtime
// file sftpclient.c line 963
static signed int sort_by_mtime(const void *av, const void *bv)
{
  struct sftpattr * const a = (struct sftpattr *)av;
  struct sftpattr * const b = (struct sftpattr *)bv;
  if(!((32u & a->valid & b->valid) == 0u))
  {
    if(!(a->mtime.seconds >= b->mtime.seconds))
      return -1;

    else
      if(!(b->mtime.seconds >= a->mtime.seconds))
        return 1;

    if((256u & a->valid & b->valid) == 0u)
      goto __CPROVER_DUMP_L4;

    if(!(a->mtime.nanoseconds >= b->mtime.nanoseconds))
      return -1;

    if(b->mtime.nanoseconds >= a->mtime.nanoseconds)
      goto __CPROVER_DUMP_L4;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    signed int return_value_sort_by_name_1;
    return_value_sort_by_name_1=sort_by_name(av, bv);
    return return_value_sort_by_name_1;
  }
}

// sort_by_name
// file sftpclient.c line 945
static signed int sort_by_name(const void *av, const void *bv)
{
  struct sftpattr * const a = (struct sftpattr *)av;
  struct sftpattr * const b = (struct sftpattr *)bv;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(a->name, b->name);
  return return_value_strcmp_1;
}

// sort_by_size
// file sftpclient.c line 951
static signed int sort_by_size(const void *av, const void *bv)
{
  struct sftpattr * const a = (struct sftpattr *)av;
  struct sftpattr * const b = (struct sftpattr *)bv;
  if(!((1u & a->valid & b->valid) == 0u))
  {
    if(!(a->size >= b->size))
      return -1;

    if(b->size >= a->size)
      goto __CPROVER_DUMP_L2;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    signed int return_value_sort_by_name_1;
    return_value_sort_by_name_1=sort_by_name(av, bv);
    return return_value_sort_by_name_1;
  }
}

// split
// file sftpclient.c line 247
static signed int split(char *line, char **av)
{
  char *arg;
  signed int ac = 0;
  signed int tmp_post_2;
  char *tmp_post_3;
  char *tmp_post_4;
  char *tmp_post_5;
  char *tmp_post_6;
  signed int tmp_post_7;
  const unsigned short int **return_value___ctype_b_loc_8;
  char *tmp_post_9;
  while(!(*line == 0))
  {
    const unsigned short int **return_value___ctype_b_loc_1;
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)*line]) == 0))
      line = line + 1l;

    else
      if((signed int)*line == 34)
      {
        tmp_post_2 = ac;
        ac = ac + 1;
        tmp_post_3 = line;
        line = line + 1l;
        av[(signed long int)tmp_post_2] = tmp_post_3;
        arg = av[(signed long int)tmp_post_2];
        for( ; !(*line == 0); *tmp_post_4 = *tmp_post_5)
        {
          if((signed int)*line == 34)
            break;

          if((signed int)*line == 92)
          {
            if(!(line[1l] == 0))
              line = line + 1l;

          }

          tmp_post_4 = arg;
          arg = arg + 1l;
          tmp_post_5 = line;
          line = line + 1l;
        }
        if(*line == 0)
        {
          error("unterminated string");
          return -1;
        }

        tmp_post_6 = arg;
        arg = arg + 1l;
        *tmp_post_6 = (char)0;
        line = line + 1l;
      }

      else
      {
        tmp_post_7 = ac;
        ac = ac + 1;
        av[(signed long int)tmp_post_7] = line;
        for( ; !(*line == 0); line = line + 1l)
        {
          return_value___ctype_b_loc_8=__ctype_b_loc();
          if(!((8192 & (signed int)(*return_value___ctype_b_loc_8)[(signed long int)(signed int)(unsigned char)*line]) == 0))
            break;

        }
        if(!(*line == 0))
        {
          tmp_post_9 = line;
          line = line + 1l;
          *tmp_post_9 = (char)0;
        }

      }
  }
  av[(signed long int)ac] = ((char *)NULL);
  return ac;
}

// status
// file sftpclient.c line 194
static signed int status(void)
{
  unsigned int status__1__status;
  char *msg;
  fakejob.ptr = fakejob.data + (signed long int)5;
  fakejob.left = fakejob.len - (unsigned long int)5;
  do
  {
    unsigned int rc;
    rc=sftp_parse_uint32(&fakejob, &status__1__status);
    if(!(rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 201, (const void *)"sftp_parse_uint32(&fakejob, &status)", rc);

      while((_Bool)0);
      fatal("error parsing response from server");
    }

  }
  while((_Bool)0);
  do
  {
    unsigned int status__1__2__rc;
    status__1__2__rc=sftp_parse_string(&fakejob, &msg, ((unsigned long int *)NULL));
    if(!(status__1__2__rc == 0u))
    {
      do
        if(!(sftp_debugging == 0))
          sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 202, (const void *)"sftp_parse_string(&fakejob, &msg, 0)", status__1__2__rc);

      while((_Bool)0);
      fatal("error parsing response from server");
    }

  }
  while((_Bool)0);
  if(!(status__1__status == 0u))
  {
    const char *return_value_status_to_string_1;
    return_value_status_to_string_1=status_to_string(status__1__status);
    error("%s (%s)", msg, return_value_status_to_string_1);
    return -1;
  }

  else
    return 0;
}

// status_to_string
// file sftpcommon.h line 87
const char * status_to_string(unsigned int status)
{
  switch(status)
  {
    case (unsigned int)0:
      return "OK";
    case (unsigned int)1:
      return "end of file";
    case (unsigned int)2:
      return "file does not exist";
    case (unsigned int)3:
      return "permission denied";
    case (unsigned int)4:
      return "operation failed";
    case (unsigned int)5:
      return "badly encoded SFTP packet";
    case (unsigned int)6:
      return "no connection";
    case (unsigned int)7:
      return "connection lost";
    case (unsigned int)8:
      return "operation not supported";
    case (unsigned int)9:
      return "invalid handle";
    case (unsigned int)10:
      return "path does not exist or is invalid";
    case (unsigned int)11:
      return "file already exists";
    case (unsigned int)12:
      return "file is on read-only medium";
    case (unsigned int)13:
      return "no medium in drive";
    case (unsigned int)14:
      return "no space on filesystem";
    case (unsigned int)15:
      return "quota exceeded";
    case (unsigned int)16:
      return "unknown principal";
    case (unsigned int)17:
      return "file is locked";
    case (unsigned int)18:
      return "directory is not empty";
    case (unsigned int)19:
      return "file is not a directory";
    case (unsigned int)20:
      return "invalid filename";
    case (unsigned int)21:
      return "too many symbolic links";
    case (unsigned int)22:
      return "file cannot be deleted";
    case (unsigned int)23:
      return "invalid parameter";
    case (unsigned int)24:
      return "file is a directory";
    case (unsigned int)25:
      return "byte range is locked";
    case (unsigned int)26:
      return "cannot lock byte range";
    case (unsigned int)27:
      return "file deletion pending";
    case (unsigned int)28:
      return "file is corrupt";
    case (unsigned int)29:
      return "invalid owner";
    case (unsigned int)30:
      return "invalid group";
    case (unsigned int)31:
      return "no such lock";
    default:
      return "unknown status";
  }
}

// v3_decode
// file v3.c line 58
static unsigned int v3_decode(struct sftpjob *job, char **path)
{
  return (unsigned int)0;
}

// v3_parseattrs
// file v3.c line 128
static unsigned int v3_parseattrs(struct sftpjob *job, struct sftpattr *attrs)
{
  unsigned int n;
  unsigned int rc;
  memset((void *)attrs, 0, sizeof(struct sftpattr) /*200ul*/ );
  rc=sftp_parse_uint32(job, &attrs->valid);
  unsigned int tmp_post_1;
  _Bool tmp_if_expr_2;
  if(!(rc == 0u))
    return rc;

  else
  {
    if(!((8u & attrs->valid) == 0u))
      attrs->valid = attrs->valid | (unsigned int)(0x00000008 | 0x00000020);

    if(!((1u & attrs->valid) == 0u))
    {
      rc=sftp_parse_uint64(job, &attrs->size);
      if(rc == 0u)
        goto __CPROVER_DUMP_L3;

      return rc;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      if(!((2u & attrs->valid) == 0u))
      {
        rc=sftp_parse_uint32(job, &attrs->uid);
        if(!(rc == 0u))
          return rc;

        rc=sftp_parse_uint32(job, &attrs->gid);
        if(rc == 0u)
          goto __CPROVER_DUMP_L5;

        return rc;
      }

      else
      {

      __CPROVER_DUMP_L5:
        ;
        if(!((4u & attrs->valid) == 0u))
        {
          rc=sftp_parse_uint32(job, &attrs->permissions);
          if(!(rc == 0u))
            return rc;

          switch(attrs->permissions & (unsigned int)0170000)
          {
            case (unsigned int)0010000:
            {
              attrs->type = (unsigned char)9;
              break;
            }
            case (unsigned int)0020000:
            {
              attrs->type = (unsigned char)7;
              break;
            }
            case (unsigned int)0040000:
            {
              attrs->type = (unsigned char)2;
              break;
            }
            case (unsigned int)0060000:
            {
              attrs->type = (unsigned char)8;
              break;
            }
            case (unsigned int)0100000:
            {
              attrs->type = (unsigned char)1;
              break;
            }
            case (unsigned int)0120000:
            {
              attrs->type = (unsigned char)3;
              break;
            }
            case (unsigned int)0140000:
            {
              attrs->type = (unsigned char)6;
              break;
            }
            default:
              attrs->type = (unsigned char)5;
          }
        }

        else
          attrs->type = (unsigned char)5;
        if(!((8u & attrs->valid) == 0u))
        {
          rc=sftp_parse_uint32(job, &n);
          if(!(rc == 0u))
            return rc;

          attrs->atime.seconds = (signed long int)n;
        }

        if(!((32u & attrs->valid) == 0u))
        {
          rc=sftp_parse_uint32(job, &n);
          if(!(rc == 0u))
            return rc;

          attrs->mtime.seconds = (signed long int)n;
        }

        if(!((0x80000000 & attrs->valid) == 0u))
        {
          rc=sftp_parse_uint32(job, &n);
          if(!(rc == 0u))
            return rc;

          do
          {
            tmp_post_1 = n;
            n = n - 1u;
            if(!(tmp_post_1 >= 1u))
              break;

            rc=sftp_parse_string(job, ((char **)NULL), ((unsigned long int *)NULL));
            if(!(rc == 0u))
              tmp_if_expr_2 = (_Bool)1;

            else
            {
              rc=sftp_parse_string(job, ((char **)NULL), ((unsigned long int *)NULL));
              tmp_if_expr_2 = rc != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_2)
              return rc;

          }
          while((_Bool)1);
        }

        return (unsigned int)0;
      }
    }
  }
}

// v3_sendattrs
// file v3.c line 83
static void v3_sendattrs(struct sftpjob *job, struct sftpattr *attrs)
{
  unsigned int v3bits;
  unsigned int m;
  unsigned int a;
  if((40u & attrs->valid) == 40u)
    v3bits = attrs->valid & (unsigned int)(0x00000001 | 0x00000002 | 0x00000004) | (unsigned int)0x00000008;

  else
    v3bits = attrs->valid & (unsigned int)(0x00000001 | 0x00000002 | 0x00000004);
  sftp_send_uint32(job->worker, v3bits);
  if(!((1u & v3bits) == 0u))
    sftp_send_uint64(job->worker, attrs->size);

  if(!((2u & v3bits) == 0u))
  {
    sftp_send_uint32(job->worker, attrs->uid);
    sftp_send_uint32(job->worker, attrs->gid);
  }

  if(!((4u & v3bits) == 0u))
    sftp_send_uint32(job->worker, attrs->permissions);

  if(!((8u & v3bits) == 0u))
  {
    m = (unsigned int)attrs->mtime.seconds;
    a = (unsigned int)attrs->atime.seconds;
    if(!((signed long int)m == attrs->mtime.seconds))
      fatal("sending out-of-range mtime");

    if(!((signed long int)a == attrs->atime.seconds))
      fatal("sending out-of-range mtime");

    sftp_send_uint32(job->worker, m);
    sftp_send_uint32(job->worker, a);
  }

}

// v3_sendnames
// file v3.c line 65
static void v3_sendnames(struct sftpjob *job, signed int nnames, struct sftpattr *names)
{
  signed long int now;
  struct tm nowtime;
  time(&now);
  gmtime_r(&now, &nowtime);
  sftp_send_uint32(job->worker, (unsigned int)nnames);
  if(nnames >= 1)
  {
    sftp_send_path(job, job->worker, names->name);
    const char *return_value_sftp_format_attr_1;
    return_value_sftp_format_attr_1=sftp_format_attr(job->a, names, nowtime.tm_year, (unsigned long int)0);
    sftp_send_string(job->worker, return_value_sftp_format_attr_1);
    protocol->sendattrs(job, names);
    names = names + 1l;
    nnames = nnames - 1;
  }

}

// version
// file sftpclient.c line 174
static void version(void)
{
  xprintf("sftp client version %s\n", (const void *)"0.2.1");
  exit(0);
}

// write_translated
// file sftpclient.c line 1384
static signed int write_translated(struct reader_data *r, const void *vptr, unsigned long int bytes)
{
  const char *ptr = (const char *)vptr;
  const char *tmp_post_1;
  while(bytes >= 1ul)
  {
    signed int c;
    tmp_post_1 = ptr;
    ptr = ptr + 1l;
    c = (const signed int)(unsigned char)*tmp_post_1;
    bytes = bytes - 1ul;
    if(c == (signed int)newline[(signed long int)r->translated_state])
    {
      r->translated_state = r->translated_state + 1ul;
      if(newline[(signed long int)r->translated_state] == 0)
      {
        signed int return_value__IO_putc_2;
        return_value__IO_putc_2=_IO_putc(10, r->translated_fp);
        if(!(return_value__IO_putc_2 >= 0))
          return -1;

        r->translated_state = (unsigned long int)0;
      }

    }

    else
      if(!(r->translated_state == 0ul))
      {
        unsigned long int return_value_fwrite_3;
        return_value_fwrite_3=fwrite((const void *)newline, (unsigned long int)1, r->translated_state, r->translated_fp);
        if(!(return_value_fwrite_3 == r->translated_state))
          return -1;

        r->translated_state = (unsigned long int)0;
        continue;
      }

      else
      {
        signed int return_value__IO_putc_4;
        return_value__IO_putc_4=_IO_putc(c, r->translated_fp);
        if(!(return_value__IO_putc_4 >= 0))
          return -1;

      }
  }
  return 0;
}

// write_translated_done
// file sftpclient.c line 1424
static signed int write_translated_done(struct reader_data *r)
{
  signed int rc = 0;
  if(!(r->translated_fp == ((struct _IO_FILE *)NULL)))
  {
    if(!(r->translated_state == 0ul))
    {
      unsigned long int return_value_fwrite_1;
      return_value_fwrite_1=fwrite((const void *)newline, (unsigned long int)1, r->translated_state, r->translated_fp);
      if(!(return_value_fwrite_1 == r->translated_state))
        rc = -1;

      r->translated_state = (unsigned long int)0;
    }

    signed int return_value_fclose_2;
    return_value_fclose_2=fclose(r->translated_fp);
    if(!(return_value_fclose_2 >= 0))
      rc = -1;

    r->translated_fp = ((struct _IO_FILE *)NULL);
  }

  return rc;
}

// write_translated_init
// file sftpclient.c line 1377
static signed int write_translated_init(struct reader_data *r)
{
  r->translated_fp=fdopen(r->fd, "w");
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  signed int return_value_error_3;
  if(r->translated_fp == ((struct _IO_FILE *)NULL))
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    return_value_error_3=error("error calling fdopen: %s", return_value_strerror_2);
    return return_value_error_3;
  }

  else
  {
    r->translated_state = (unsigned long int)0;
    return 0;
  }
}

// writer_thread
// file sftpclient.c line 1687
static void * writer_thread(void *arg)
{
  struct writer_data * const w = (struct writer_data *)arg;
  signed int i;
  unsigned int st;
  do
  {
    signed int frc;
    frc=pthread_mutex_lock(&w->m);
    if(!(frc == 0))
    {
      char *return_value_strerror_1;
      return_value_strerror_1=strerror(frc);
      fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1692, (const void *)"pthread_mutex_lock(&w->m)", return_value_strerror_1);
      exit(1);
    }

  }
  while((_Bool)0);
  _Bool tmp_if_expr_4;
  while((_Bool)1)
  {
    if(!(w->finished == 0))
    {
      if(w->outstanding == 0)
        goto __CPROVER_DUMP_L20;

    }

    if(w->outstanding == 0)
      do
      {
        signed int writer_thread__1__2__1__1__frc;
        writer_thread__1__2__1__1__frc=pthread_cond_wait(&w->c1, &w->m);
        if(!(writer_thread__1__2__1__1__frc == 0))
        {
          char *return_value_strerror_2;
          return_value_strerror_2=strerror(writer_thread__1__2__1__1__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1698, (const void *)"pthread_cond_wait(&w->c1, &w->m)", return_value_strerror_2);
          exit(1);
        }

      }
      while((_Bool)0);

    else
    {
      getresponse(101, (unsigned int)0, "SSH_FXP_WRITE");
      do
      {
        signed int writer_thread__1__2__2__frc;
        writer_thread__1__2__2__frc=pthread_cond_signal(&w->c2);
        if(!(writer_thread__1__2__2__frc == 0))
        {
          char *return_value_strerror_3;
          return_value_strerror_3=strerror(writer_thread__1__2__2__frc);
          fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1703, (const void *)"pthread_cond_signal(&w->c2)", return_value_strerror_3);
          exit(1);
        }

      }
      while((_Bool)0);
      i = 0;
      do
      {
        if(!(i >= nrequests))
          tmp_if_expr_4 = (w->reqs + (signed long int)i)->id != fakejob.id ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(!tmp_if_expr_4)
          break;

        i = i + 1;
      }
      while((_Bool)1);
      /* assertion i < nrequests */
      assert(i < nrequests);
      w->outstanding = w->outstanding - 1;
      do
      {
        unsigned int rc;
        rc=sftp_parse_uint32(&fakejob, &st);
        if(!(rc == 0u))
        {
          do
            if(!(sftp_debugging == 0))
              sftp_debug_printf("%s:%d: %s returned %u", (const void *)"sftpclient.c", 1709, (const void *)"sftp_parse_uint32(&fakejob, &st)", rc);

          while((_Bool)0);
          fatal("error parsing response from server");
        }

      }
      while((_Bool)0);
      if(st == 0u)
      {
        w->written = w->written + (unsigned long int)(w->reqs + (signed long int)i)->n;
        (w->reqs + (signed long int)i)->id = (unsigned int)0;
        progress(w->remote, w->written, w->total);
      }

      else
        if(w->failed == 0)
        {
          status();
          w->failed = 1;
        }

    }
  }

__CPROVER_DUMP_L20:
  ;
  progress(((const char *)NULL), (unsigned long int)0, (unsigned long int)0);
  do
  {
    signed int writer_thread__1__3__frc;
    writer_thread__1__3__frc=pthread_mutex_unlock(&w->m);
    if(!(writer_thread__1__3__frc == 0))
    {
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(writer_thread__1__3__frc);
      fatal("%s:%d: %s: %s\n", (const void *)"sftpclient.c", 1721, (const void *)"pthread_mutex_unlock(&w->m)", return_value_strerror_5);
      exit(1);
    }

  }
  while((_Bool)0);
  return NULL;
}

// xcalloc
// file utils.h line 59
void * xcalloc(unsigned long int n, unsigned long int size)
{
  void *ptr;
  if(!(n == 0ul) && !(size == 0ul))
  {
    ptr=calloc(n, size);
    if(ptr == NULL)
      fatal("xcalloc: out of memory (%zu, %zu)", n, size);

    return ptr;
  }

  else
    return NULL;
}

// xclose
// file xfns.h line 31
void xclose(signed int fd)
{
  signed int return_value_close_3;
  return_value_close_3=close(fd);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(!(return_value_close_3 >= 0))
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fatal("error calling close: %s", return_value_strerror_2);
  }

}

// xdup2
// file xfns.h line 39
void xdup2(signed int fd, signed int newfd)
{
  signed int return_value_dup2_3;
  return_value_dup2_3=dup2(fd, newfd);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(!(return_value_dup2_3 >= 0))
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fatal("error calling dup2: %s", return_value_strerror_2);
  }

}

// xfork
// file utils.h line 194
signed int xfork(void)
{
  signed int pid;
  pid=fork();
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(!(pid >= 0))
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fatal("fork: %s", return_value_strerror_2);
  }

  if(pid == 0)
    forked();

  return pid;
}

// xpipe
// file xfns.h line 46
void xpipe(signed int *pfd)
{
  signed int return_value_pipe_3;
  return_value_pipe_3=pipe(pfd);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(!(return_value_pipe_3 >= 0))
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fatal("error calling pipe: %s", return_value_strerror_2);
  }

}

// xprintf
// file xfns.h line 55
signed int xprintf(const char *fmt, ...)
{
  void **ap;
  signed int rc;
  ap = (void **)&fmt;
  rc=vfprintf(stdout, fmt, ap);
  ap = ((void **)NULL);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(!(rc >= 0))
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fatal("error writing to stdout: %s", return_value_strerror_2);
  }

  return rc;
}

// xrecalloc
// file utils.h line 82
void * xrecalloc(void *ptr, unsigned long int n, unsigned long int size)
{
  if(!(18446744073709551615UL / size >= n))
    fatal("xrecalloc: out of memory (%zu, %zu)", n, size);

  n = n * size;
  if(!(n == 0ul))
  {
    ptr=realloc(ptr, n);
    if(ptr == NULL)
      fatal("xrecalloc: out of memory (%zu)", n);

    return ptr;
  }

  else
  {
    free(ptr);
    return NULL;
  }
}

// xstrdup
// file utils.h line 90
char * xstrdup(const char *s)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  void *return_value_sftp__xmalloc_2;
  return_value_sftp__xmalloc_2=sftp__xmalloc(return_value_strlen_1 + (unsigned long int)1);
  char *return_value_strcpy_3;
  return_value_strcpy_3=strcpy((char *)return_value_sftp__xmalloc_2, s);
  return return_value_strcpy_3;
}

