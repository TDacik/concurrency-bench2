// tag-#anon#ST[*{SYM#tag-chunk#}$SYM#tag-chunk#$'vtqe_next'||*{*{SYM#tag-chunk#}$SYM#tag-chunk#$}$*{SYM#tag-chunk#}$SYM#tag-chunk#$$'vtqe_prev'|]
// file vsl_dispatch.c line 105
struct anonymous$22;

// tag-#anon#ST[*{SYM#tag-membit#}$SYM#tag-membit#$'vtqe_next'||*{*{SYM#tag-membit#}$SYM#tag-membit#$}$*{SYM#tag-membit#}$SYM#tag-membit#$$'vtqe_prev'|]
// file vxp.h line 48
struct anonymous$13;

// tag-#anon#ST[*{SYM#tag-membit#}$SYM#tag-membit#$'vtqh_first'||*{*{SYM#tag-membit#}$SYM#tag-membit#$}$*{SYM#tag-membit#}$SYM#tag-membit#$$'vtqh_last'|]
// file vxp.h line 70
struct anonymous$16;

// tag-#anon#ST[*{SYM#tag-synth#}$SYM#tag-synth#$'vtqe_next'||*{*{SYM#tag-synth#}$SYM#tag-synth#$}$*{SYM#tag-synth#}$SYM#tag-synth#$$'vtqe_prev'|]
// file vsl_dispatch.c line 86
struct anonymous$20;

// tag-#anon#ST[*{SYM#tag-synth#}$SYM#tag-synth#$'vtqh_first'||*{*{SYM#tag-synth#}$SYM#tag-synth#$}$*{SYM#tag-synth#}$SYM#tag-synth#$$'vtqh_last'|]
// file vsl_dispatch.c line 162
struct anonymous$19;

// tag-#anon#ST[*{SYM#tag-token#}$SYM#tag-token#$'vtqe_next'||*{*{SYM#tag-token#}$SYM#tag-token#$}$*{SYM#tag-token#}$SYM#tag-token#$$'vtqe_prev'|]
// file vxp.h line 56
struct anonymous$14;

// tag-#anon#ST[*{SYM#tag-token#}$SYM#tag-token#$'vtqh_first'||*{*{SYM#tag-token#}$SYM#tag-token#$}$*{SYM#tag-token#}$SYM#tag-token#$$'vtqh_last'|]
// file vxp.h line 69
struct anonymous$15;

// tag-#anon#ST[*{SYM#tag-top#}$SYM#tag-top#$'rbe_left'||*{SYM#tag-top#}$SYM#tag-top#$'rbe_right'||*{SYM#tag-top#}$SYM#tag-top#$'rbe_parent'||S32'rbe_color'||U32'$pad0'|]
// file varnishtop.c line 73
struct anonymous$3;

// tag-#anon#ST[*{SYM#tag-vsc_pt#}$SYM#tag-vsc_pt#$'vtqe_next'||*{*{SYM#tag-vsc_pt#}$SYM#tag-vsc_pt#$}$*{SYM#tag-vsc_pt#}$SYM#tag-vsc_pt#$$'vtqe_prev'|]
// file vsc.c line 70
struct anonymous$10;

// tag-#anon#ST[*{SYM#tag-vsc_pt#}$SYM#tag-vsc_pt#$'vtqh_first'||*{*{SYM#tag-vsc_pt#}$SYM#tag-vsc_pt#$}$*{SYM#tag-vsc_pt#}$SYM#tag-vsc_pt#$$'vtqh_last'|]
// file vsc.c line 93
struct anonymous$7;

// tag-#anon#ST[*{SYM#tag-vsc_sf#}$SYM#tag-vsc_sf#$'vtqe_next'||*{*{SYM#tag-vsc_sf#}$SYM#tag-vsc_sf#$}$*{SYM#tag-vsc_sf#}$SYM#tag-vsc_sf#$$'vtqe_prev'|]
// file vsc.c line 77
struct anonymous$11;

// tag-#anon#ST[*{SYM#tag-vsc_sf#}$SYM#tag-vsc_sf#$'vtqh_first'||*{*{SYM#tag-vsc_sf#}$SYM#tag-vsc_sf#$}$*{SYM#tag-vsc_sf#}$SYM#tag-vsc_sf#$$'vtqh_last'|]
// file vsc.c line 94
struct anonymous$8;

// tag-#anon#ST[*{SYM#tag-vsc_vf#}$SYM#tag-vsc_vf#$'vtqe_next'||*{*{SYM#tag-vsc_vf#}$SYM#tag-vsc_vf#$}$*{SYM#tag-vsc_vf#}$SYM#tag-vsc_vf#$$'vtqe_prev'|]
// file vsc.c line 61
struct anonymous$9;

// tag-#anon#ST[*{SYM#tag-vsc_vf#}$SYM#tag-vsc_vf#$'vtqh_first'||*{*{SYM#tag-vsc_vf#}$SYM#tag-vsc_vf#$}$*{SYM#tag-vsc_vf#}$SYM#tag-vsc_vf#$$'vtqh_last'|]
// file vsc.c line 92
struct anonymous$6;

// tag-#anon#ST[*{SYM#tag-vslf#}$SYM#tag-vslf#$'vtqe_next'||*{*{SYM#tag-vslf#}$SYM#tag-vslf#$}$*{SYM#tag-vslf#}$SYM#tag-vslf#$$'vtqe_prev'|]
// file vsl_api.h line 63
struct anonymous$2;

// tag-#anon#ST[*{SYM#tag-vslf#}$SYM#tag-vslf#$'vtqh_first'||*{*{SYM#tag-vslf#}$SYM#tag-vslf#$}$*{SYM#tag-vslf#}$SYM#tag-vslf#$$'vtqh_last'|]
// file vsl_api.h line 69
struct anonymous$1;

// tag-#anon#ST[*{SYM#tag-vtx#}$SYM#tag-vtx#$'vtqe_next'||*{*{SYM#tag-vtx#}$SYM#tag-vtx#$}$*{SYM#tag-vtx#}$SYM#tag-vtx#$$'vtqe_prev'|]
// file vsl_dispatch.c line 141
struct anonymous$18;

// tag-#anon#ST[*{SYM#tag-vtx#}$SYM#tag-vtx#$'vtqh_first'||*{*{SYM#tag-vtx#}$SYM#tag-vtx#$}$*{SYM#tag-vtx#}$SYM#tag-vtx#$$'vtqh_last'|]
// file vsl_dispatch.c line 157
struct anonymous$4;

// tag-#anon#ST[*{SYM#tag-vtx_key#}$SYM#tag-vtx_key#$'rbe_left'||*{SYM#tag-vtx_key#}$SYM#tag-vtx_key#$'rbe_right'||*{SYM#tag-vtx_key#}$SYM#tag-vtx_key#$'rbe_parent'||S32'rbe_color'||U32'$pad0'|]
// file vsl_dispatch.c line 133
struct anonymous$17;

// tag-#anon#ST[*{U32}$U32$'data'||U64'space'|]
// file vsl_dispatch.c line 107
struct anonymous$24;

// tag-#anon#ST[SYM#tag-VSLC_ptr#'start'||SYM#tag-#anon#ST[*{SYM#tag-chunk#}$SYM#tag-chunk#$'vtqe_next'||*{*{SYM#tag-chunk#}$SYM#tag-chunk#$}$*{SYM#tag-chunk#}$SYM#tag-chunk#$$'vtqe_prev'|]#'shmref'|]
// file vsl_dispatch.c line 103
struct anonymous$23;

// tag-#anon#ST[SYM#tag-vslc_raw#'c'||SYM#tag-VSL_transaction#'trans'||ARR2{*{SYM#tag-VSL_transaction#}$SYM#tag-VSL_transaction#$}$*{SYM#tag-VSL_transaction#}$SYM#tag-VSL_transaction#$$'ptrans'||SYM#tag-VSLC_ptr#'start'||S64'len'||U64'offset'|]
// file vsl_dispatch.c line 193
struct anonymous$5;

// tag-#anon#ST[U64'attr'||ARR5{S32}$S32$'chars'||U32'$pad0'|]
// file /usr/include/curses.h line 397
struct anonymous;

// tag-#anon#UN[SYM#tag-#anon#ST[SYM#tag-VSLC_ptr#'start'||SYM#tag-#anon#ST[*{SYM#tag-chunk#}$SYM#tag-chunk#$'vtqe_next'||*{*{SYM#tag-chunk#}$SYM#tag-chunk#$}$*{SYM#tag-chunk#}$SYM#tag-chunk#$$'vtqe_prev'|]#'shmref'|]#'shm'||SYM#tag-#anon#ST[*{U32}$U32$'data'||U64'space'|]#'buf'|]
// file vsl_dispatch.c line 102
union anonymous$21;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$0;

// tag-SHA256Context
// file ../../include/vsha256.h line 34
struct SHA256Context;

// tag-VCLI_status_e
// file ../../include/vcli.h line 186
enum VCLI_status_e { CLIS_SYNTAX=100, CLIS_UNKNOWN=101, CLIS_UNIMPL=102, CLIS_TOOFEW=104, CLIS_TOOMANY=105, CLIS_PARAM=106, CLIS_AUTH=107, CLIS_OK=200, CLIS_TRUNCATED=201, CLIS_CANT=300, CLIS_COMMS=400, CLIS_CLOSE=500 };

// tag-VCLS
// file ../../include/vcli_common.h line 34
struct VCLS;

// tag-VSC_C_lck
// file ../../include/tbl/vsc_all.h line 37
struct VSC_C_lck;

// tag-VSC_C_main
// file ../../include/tbl/vsc_all.h line 43
struct VSC_C_main;

// tag-VSC_C_mempool
// file ../../include/tbl/vsc_all.h line 65
struct VSC_C_mempool;

// tag-VSC_C_mgt
// file ../../include/tbl/vsc_all.h line 31
struct VSC_C_mgt;

// tag-VSC_C_sma
// file ../../include/tbl/vsc_all.h line 47
struct VSC_C_sma;

// tag-VSC_C_smf
// file ../../include/tbl/vsc_all.h line 53
struct VSC_C_smf;

// tag-VSC_C_vbe
// file ../../include/tbl/vsc_all.h line 59
struct VSC_C_vbe;

// tag-VSC_desc
// file ../../include/vapi/vsc.h line 106
struct VSC_desc;

// tag-VSC_level_desc
// file ../../include/vapi/vsc.h line 103
struct VSC_level_desc;

// tag-VSC_point
// file ../../include/vapi/vsc.h line 107
struct VSC_point;

// tag-VSC_section
// file ../../include/vapi/vsc.h line 105
struct VSC_section;

// tag-VSC_type_desc
// file ../../include/vapi/vsc.h line 104
struct VSC_type_desc;

// tag-VSLC_ptr
// file ../../include/vapi/vsl.h line 52
struct VSLC_ptr;

// tag-VSLQ
// file ../../include/vapi/vsl.h line 50
struct VSLQ;

// tag-VSL_cursor
// file ../../include/vapi/vsl.h line 79
struct VSL_cursor;

// tag-VSL_data
// file ../../include/vapi/vsl.h line 49
struct VSL_data;

// tag-VSL_grouping_e
// file ../../include/vapi/vsl.h line 119
enum VSL_grouping_e { VSL_g_raw=0, VSL_g_vxid=1, VSL_g_request=2, VSL_g_session=3, VSL_g__MAX=4 };

// tag-VSL_head
// file ../../include/vapi/vsl_int.h line 72
struct VSL_head;

// tag-VSL_reason_e
// file ../../include/vapi/vsl.h line 97
enum VSL_reason_e { VSL_r_unknown=0, VSL_r_http_1=1, VSL_r_rxreq=2, VSL_r_esi=3, VSL_r_restart=4, VSL_r_pass=5, VSL_r_fetch=6, VSL_r_bgfetch=7, VSL_r_pipe=8, VSL_r__MAX=9 };

// tag-VSL_tag_e
// file ../../include/vapi/vsl_int.h line 108
enum VSL_tag_e { SLT__Bogus=0, SLT_Debug=1, SLT_Error=2, SLT_CLI=3, SLT_SessOpen=4, SLT_SessClose=5, SLT_BackendOpen=6, SLT_BackendReuse=7, SLT_BackendClose=8, SLT_HttpGarbage=9, SLT_Backend=10, SLT_Length=11, SLT_FetchError=12, SLT_ReqMethod=13, SLT_ReqURL=14, SLT_ReqProtocol=15, SLT_ReqStatus=16, SLT_ReqReason=17, SLT_ReqHeader=18, SLT_ReqUnset=19, SLT_ReqLost=20, SLT_RespMethod=21, SLT_RespURL=22, SLT_RespProtocol=23, SLT_RespStatus=24, SLT_RespReason=25, SLT_RespHeader=26, SLT_RespUnset=27, SLT_RespLost=28, SLT_BereqMethod=29, SLT_BereqURL=30, SLT_BereqProtocol=31, SLT_BereqStatus=32, SLT_BereqReason=33, SLT_BereqHeader=34, SLT_BereqUnset=35, SLT_BereqLost=36, SLT_BerespMethod=37, SLT_BerespURL=38, SLT_BerespProtocol=39, SLT_BerespStatus=40, SLT_BerespReason=41, SLT_BerespHeader=42, SLT_BerespUnset=43, SLT_BerespLost=44, SLT_ObjMethod=45, SLT_ObjURL=46, SLT_ObjProtocol=47, SLT_ObjStatus=48, SLT_ObjReason=49, SLT_ObjHeader=50, SLT_ObjUnset=51, SLT_ObjLost=52, SLT_BogoHeader=53, SLT_LostHeader=54, SLT_TTL=55, SLT_Fetch_Body=56, SLT_VCL_acl=57, SLT_VCL_call=58, SLT_VCL_trace=59, SLT_VCL_return=60, SLT_ReqStart=61, SLT_Hit=62, SLT_HitPass=63, SLT_ExpBan=64, SLT_ExpKill=65, SLT_WorkThread=66, SLT_ESI_xmlerror=67, SLT_Hash=68, SLT_Backend_health=69, SLT_VCL_Log=70, SLT_VCL_Error=71, SLT_Gzip=72, SLT_Link=73, SLT_Begin=74, SLT_End=75, SLT_VSL=76, SLT_Storage=77, SLT_Timestamp=78, SLT_ReqAcct=79, SLT_ESI_BodyBytes=80, SLT_PipeAcct=81, SLT_BereqAcct=82, SLT__Reserved=254, SLT__Batch=255 };

// tag-VSL_transaction
// file ../../include/vapi/vsl.h line 110
struct VSL_transaction;

// tag-VSL_transaction_e
// file ../../include/vapi/vsl.h line 88
enum VSL_transaction_e { VSL_t_unknown=0, VSL_t_sess=1, VSL_t_req=2, VSL_t_bereq=3, VSL_t_raw=4, VSL_t__MAX=5 };

// tag-VSM_chunk
// file ../../include/vapi/vsm_int.h line 103
struct VSM_chunk;

// tag-VSM_data
// file ../../include/vapi/vsm.h line 42
struct VSM_data;

// tag-VSM_fantom
// file ../../include/vapi/vsm.h line 48
struct VSM_fantom;

// tag-VSM_head
// file ../../include/vapi/vsm_int.h line 113
struct VSM_head;

// tag-VSM_valid_e
// file ../../include/vapi/vsm.h line 161
enum VSM_valid_e { VSM_invalid=0, VSM_valid=1, VSM_similar=2 };

// tag-VUT
// file ../../include/vut.h line 36
struct VUT;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_win_st
// file /usr/include/curses.h line 365
struct _win_st;

// tag-chunk
// file vsl_dispatch.c line 98
struct chunk;

// tag-chunk_t
// file vsl_dispatch.c line 92
enum chunk_t { chunk_t__unassigned=0, chunk_t_shm=1, chunk_t_buf=2 };

// tag-chunkhead
// file vsl_dispatch.c line 116
struct chunkhead;

// tag-cli
// file ../../include/vcli_common.h line 36
struct cli;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-ldat
// file /usr/include/curses.h line 412
struct ldat;

// tag-membit
// file vxp.h line 47
struct membit;

// tag-pcre_extra
// file /usr/include/pcre.h line 376
struct pcre_extra;

// tag-pdat
// file /usr/include/curses.h line 452
struct pdat;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-real_pcre
// file /usr/include/pcre.h line 324
struct real_pcre;

// tag-sha256test
// file ../libvarnish/vsha256.c line 300
struct sha256test;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-synth
// file vsl_dispatch.c line 82
struct synth;

// tag-synthhead
// file vsl_dispatch.c line 90
struct synthhead;

// tag-t_key
// file varnishtop.c line 79
struct t_key;

// tag-t_order
// file varnishtop.c line 78
struct t_order;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-token
// file vxp.h line 52
struct token;

// tag-top
// file varnishtop.c line 67
struct top;

// tag-vas_e
// file ../../include/vas.h line 41
enum vas_e { VAS_WRONG=0, VAS_MISSING=1, VAS_ASSERT=2, VAS_INCOMPLETE=3, VAS_VCL=4 };

// tag-vbitmap
// file ../../include/vbm.h line 42
struct vbitmap;

// tag-vex
// file vxp.h line 80
struct vex;

// tag-vex_lhs
// file vxp.h line 82
struct vex_lhs;

// tag-vex_rhs
// file vxp.h line 104
struct vex_rhs;

// tag-vex_rhs_e
// file vxp.h line 96
enum vex_rhs_e { VEX__UNSET=0, VEX_INT=1, VEX_FLOAT=2, VEX_STRING=3, VEX_REGEX=4 };

// tag-vlu
// file ../../include/vcli_common.h line 33
struct vlu;

// tag-vopt_list
// file ../../include/vapi/voptget.h line 41
struct vopt_list;

// tag-vpf_fh
// file ../../include/vpf.h line 33
struct vpf_fh;

// tag-vre
// file ../../include/vre.h line 38
struct vre;

// tag-vre_limits
// file ../../include/vre.h line 40
struct vre_limits;

// tag-vsb
// file ../../include/vsb.h line 39
struct vsb;

// tag-vsc
// file vsm_api.h line 33
struct vsc;

// tag-vsc_pt
// file vsc.c line 67
struct vsc_pt;

// tag-vsc_sf
// file vsc.c line 74
struct vsc_sf;

// tag-vsc_vf
// file vsc.c line 58
struct vsc_vf;

// tag-vslc_file
// file vsl_cursor.c line 279
struct vslc_file;

// tag-vslc_raw
// file vsl_dispatch.c line 73
struct vslc_raw;

// tag-vslc_tbl
// file vsl_api.h line 50
struct vslc_tbl;

// tag-vslc_vsm
// file vsl_cursor.c line 49
struct vslc_vsm;

// tag-vslc_vtx
// file vsl_dispatch.c line 118
struct vslc_vtx;

// tag-vslf
// file vsl_api.h line 60
struct vslf;

// tag-vslq_query
// file vsl_api.h line 97
struct vslq_query;

// tag-vtx
// file vsl_dispatch.c line 71
struct vtx;

// tag-vtx_key
// file vsl_dispatch.c line 131
struct vtx_key;

// tag-vtx_tree
// file vsl_dispatch.c line 135
struct vtx_tree;

// tag-vxp
// file vxp.h line 61
struct vxp;

#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// SHA256_Final
// file ../../include/vsha256.h line 42
void SHA256_Final(unsigned char *digest, struct SHA256Context *ctx);
// SHA256_Init
// file ../../include/vsha256.h line 40
void SHA256_Init(struct SHA256Context *ctx);
// SHA256_Pad
// file ../libvarnish/vsha256.c line 215
static void SHA256_Pad(struct SHA256Context *ctx);
// SHA256_Test
// file ../libvarnish/vsha256.c line 321
void SHA256_Test(void);
// SHA256_Transform
// file ../libvarnish/vsha256.c line 120
static void SHA256_Transform(unsigned int *state, const unsigned char *block);
// SHA256_Update
// file ../../include/vsha256.h line 41
void SHA256_Update(struct SHA256Context *ctx, const void *in, unsigned long int len);
// VAS_Fail$object
//
void VAS_Fail$object(const char *, const char *, signed int, const char *, signed int, enum vas_e);
// VAS_Fail_default
// file ../../lib/libvarnish/vas.c line 41
static void VAS_Fail_default(const char *func, const char *file, signed int line, const char *cond, signed int err, enum vas_e kind);
// VAS_Fail_default$link1
// file ../libvarnish/vas.c line 41
static void VAS_Fail_default$link1(const char *func$link1, const char *file$link1, signed int line$link1, const char *cond$link1, signed int err$link1, enum vas_e kind$link1);
// VAV_BackSlash
// file ../libvarnish/vav.c line 51
signed int VAV_BackSlash(const char *s, char *res);
// VAV_BackSlashDecode
// file ../libvarnish/vav.c line 107
char * VAV_BackSlashDecode(const char *s, const char *e);
// VAV_Free
// file ../libvarnish/vav.c line 215
void VAV_Free(char **argv);
// VAV_Parse
// file ../libvarnish/vav.c line 136
char ** VAV_Parse(const char *s, signed int *argc, signed int flag);
// VCLI_AuthResponse
// file ../libvarnish/cli_auth.c line 43
void VCLI_AuthResponse(signed int S_fd, const char *challenge, char *response);
// VCLI_Out
// file ../libvarnish/cli_common.c line 55
void VCLI_Out(struct cli *cli, const char *fmt, ...);
// VCLI_Overflow
// file ../libvarnish/cli_common.c line 74
signed int VCLI_Overflow(struct cli *cli);
// VCLI_Quote
// file ../libvarnish/cli_common.c line 85
void VCLI_Quote(struct cli *cli, const char *s);
// VCLI_ReadResult
// file ../libvarnish/cli_common.c line 173
signed int VCLI_ReadResult(signed int fd, unsigned int *status, char **ptr, double tmo);
// VCLI_SetResult
// file ../libvarnish/cli_common.c line 93
void VCLI_SetResult(struct cli *cli, unsigned int res);
// VCLI_WriteResult
// file ../libvarnish/cli_common.c line 106
signed int VCLI_WriteResult(signed int fd, unsigned int status, const char *result);
// VCS_Message
// file ../../include/vcs.h line 33
void VCS_Message(const char *progname);
// VIN_N_Arg
// file ../libvarnish/vin.c line 46
signed int VIN_N_Arg(const char *n_arg, char **name, char **dir, char **vsl);
// VPF_Close
// file ../../lib/libvarnish/vpf.c line 204
signed int VPF_Close(struct vpf_fh *pfh);
// VPF_Open
// file ../../include/vpf.h line 35
struct vpf_fh * VPF_Open(const char *path, unsigned int mode, signed int *pidptr);
// VPF_Remove
// file ../../include/vpf.h line 38
signed int VPF_Remove(struct vpf_fh *pfh);
// VPF_Write
// file ../../include/vpf.h line 36
signed int VPF_Write(struct vpf_fh *pfh);
// VRE_compile
// file ../libvarnish/vre.c line 67
struct vre * VRE_compile(const char *pattern, signed int options, const char **errptr, signed int *erroffset);
// VRE_exec
// file ../libvarnish/vre.c line 102
signed int VRE_exec(const struct vre *code, const char *subject, signed int length, signed int startoffset, signed int options, signed int *ovector, signed int ovecsize, struct vre_limits *lim);
// VRE_free
// file ../libvarnish/vre.c line 129
void VRE_free(struct vre **vv);
// VSB_bcat
// file ../../lib/libvarnish/vsb.c line 286
signed int VSB_bcat(struct vsb *s, const void *buf, unsigned long int len);
// VSB_bcpy
// file ../../lib/libvarnish/vsb.c line 308
signed int VSB_bcpy(struct vsb *s, const void *buf, unsigned long int len);
// VSB_cat
// file ../../lib/libvarnish/vsb.c line 322
signed int VSB_cat(struct vsb *s, const char *str);
// VSB_clear
// file ../../lib/libvarnish/vsb.c line 225
void VSB_clear(struct vsb *s);
// VSB_cpy
// file ../../lib/libvarnish/vsb.c line 343
signed int VSB_cpy(struct vsb *s, const char *str);
// VSB_data
// file ../../lib/libvarnish/vsb.c line 492
char * VSB_data(struct vsb *s);
// VSB_delete
// file ../../lib/libvarnish/vsb.c line 520
void VSB_delete(struct vsb *s);
// VSB_done
// file ../../lib/libvarnish/vsb.c line 539
signed int VSB_done(struct vsb *s);
// VSB_error
// file ../../lib/libvarnish/vsb.c line 464
signed int VSB_error(struct vsb *s);
// VSB_extend
// file ../../lib/libvarnish/vsb.c line 138
static signed int VSB_extend(struct vsb *s, signed int addlen);
// VSB_extend$link1
// file ../libvarnish/vsb.c line 138
static signed int VSB_extend$link1(struct vsb *s$link1, signed int addlen$link1);
// VSB_extendsize
// file ../../lib/libvarnish/vsb.c line 119
static signed int VSB_extendsize(signed int size);
// VSB_extendsize$link1
// file ../libvarnish/vsb.c line 119
static signed int VSB_extendsize$link1(signed int size$link1);
// VSB_finish
// file ../../lib/libvarnish/vsb.c line 474
signed int VSB_finish(struct vsb *s);
// VSB_len
// file ../../lib/libvarnish/vsb.c line 505
signed long int VSB_len(struct vsb *s);
// VSB_new
// file ../../lib/libvarnish/vsb.c line 198
struct vsb * VSB_new(struct vsb *s, char *buf, signed int length, signed int flags);
// VSB_newbuf
// file ../../lib/libvarnish/vsb.c line 165
static struct vsb * VSB_newbuf(struct vsb *s, char *buf, signed int length, signed int flags);
// VSB_newbuf$link1
// file ../libvarnish/vsb.c line 165
static struct vsb * VSB_newbuf$link1(struct vsb *s$link1, char *buf$link1, signed int length$link1, signed int flags$link1);
// VSB_printf
// file ../../lib/libvarnish/vsb.c line 417
signed int VSB_printf(struct vsb *s, const char *fmt, ...);
// VSB_put_byte
// file ../../lib/libvarnish/vsb.c line 265
static void VSB_put_byte(struct vsb *s, signed int c);
// VSB_put_byte$link1
// file ../libvarnish/vsb.c line 265
static void VSB_put_byte$link1(struct vsb *s$link1, signed int c$link1);
// VSB_putc
// file ../../lib/libvarnish/vsb.c line 432
signed int VSB_putc(struct vsb *s, signed int c);
// VSB_quote
// file ../../lib/libvarnish/vsb.c line 549
void VSB_quote(struct vsb *s, const char *p, signed int len, signed int how);
// VSB_setpos
// file ../../lib/libvarnish/vsb.c line 241
signed int VSB_setpos(struct vsb *s, signed long int pos);
// VSB_trim
// file ../../lib/libvarnish/vsb.c line 445
signed int VSB_trim(struct vsb *s);
// VSB_unquote
// file ../../lib/libvarnish/vsb.c line 603
const char * VSB_unquote(struct vsb *s, const char *p, signed int len, signed int how);
// VSB_vprintf
// file ../../lib/libvarnish/vsb.c line 357
signed int VSB_vprintf(struct vsb *s, const char *fmt, void **ap);
// VSC_Arg
// file vsc.c line 289
signed int VSC_Arg(struct VSM_data *vd, signed int arg, const char *opt);
// VSC_Delete
// file vsm_api.h line 61
void VSC_Delete(struct VSM_data *vd);
// VSC_Get
// file vsc.c line 323
void * VSC_Get(struct VSM_data *vd, struct VSM_fantom *fantom, const char *type, const char *ident);
// VSC_Iter
// file vsc.c line 507
signed int VSC_Iter(struct VSM_data *vd, struct VSM_fantom *fantom, signed int (*func)(void *, struct VSC_point *), void *priv);
// VSC_Iter::func$object
//
signed int func$object(void *, struct VSC_point *);
// VSC_LevelDesc
// file vsc.c line 535
struct VSC_level_desc * VSC_LevelDesc(unsigned int level);
// VSC_Main
// file vsc.c line 313
struct VSC_C_main * VSC_Main(struct VSM_data *vd, struct VSM_fantom *fantom);
// VSC_Mgt
// file vsc.c line 304
struct VSC_C_mgt * VSC_Mgt(struct VSM_data *vd, struct VSM_fantom *fantom);
// VSLQ_Delete
// file ../../include/vapi/vsl.h line 481
void VSLQ_Delete(struct VSLQ **pvslq);
// VSLQ_Dispatch
// file ../../include/vapi/vsl.h line 486
signed int VSLQ_Dispatch(struct VSLQ *vslq, signed int (*func)(struct VSL_data *, struct VSL_transaction * const *, void *), void *priv);
// VSLQ_Dispatch::func$object
//
signed int func$object(struct VSL_data *, struct VSL_transaction * const *, void *);
// VSLQ_Flush
// file ../../include/vapi/vsl.h line 502
signed int VSLQ_Flush(struct VSLQ *vslq, signed int (*func)(struct VSL_data *, struct VSL_transaction * const *, void *), void *priv);
// VSLQ_Flush::func$object
//
signed int func$object(struct VSL_data *, struct VSL_transaction * const *, void *);
// VSLQ_Name2Grouping
// file ../../include/vapi/vsl.h line 229
signed int VSLQ_Name2Grouping(const char *name, signed int l);
// VSLQ_New
// file ../../include/vapi/vsl.h line 464
struct VSLQ * VSLQ_New(struct VSL_data *vsl, struct VSL_cursor **cp, enum VSL_grouping_e grouping, const char *querystring);
// VSL_Arg
// file ../../include/vapi/vsl.h line 241
signed int VSL_Arg(struct VSL_data *vsl, signed int opt, const char *arg);
// VSL_Check
// file vsl_cursor.c line 474
signed int VSL_Check(struct VSL_cursor *cursor, struct VSLC_ptr *ptr);
// VSL_CursorFile
// file ../../include/vapi/vsl.h line 284
struct VSL_cursor * VSL_CursorFile(struct VSL_data *vsl, const char *name, unsigned int options);
// VSL_CursorVSM
// file ../../include/vapi/vsl.h line 268
struct VSL_cursor * VSL_CursorVSM(struct VSL_data *vsl, struct VSM_data *vsm, unsigned int options);
// VSL_Delete
// file ../../include/vapi/vsl.h line 250
void VSL_Delete(struct VSL_data *vsl);
// VSL_DeleteCursor
// file vsl_cursor.c line 442
void VSL_DeleteCursor(struct VSL_cursor *cursor);
// VSL_Error
// file ../../include/vapi/vsl.h line 255
const char * VSL_Error(struct VSL_data *vsl);
// VSL_Glob2Tags
// file vsl_arg.c line 88
signed int VSL_Glob2Tags(const char *glob, signed int l, void (*func)(signed int, void *), void *priv);
// VSL_Glob2Tags::func$object
//
void func$object(signed int, void *);
// VSL_List2Tags
// file vsl_arg.c line 157
signed int VSL_List2Tags(const char *list, signed int l, void (*func)(signed int, void *), void *priv);
// VSL_List2Tags::func$object
//
void func$object(signed int, void *);
// VSL_Match
// file ../../include/vapi/vsl.h line 339
signed int VSL_Match(struct VSL_data *vsl, struct VSL_cursor *c);
// VSL_Name2Tag
// file vsl_arg.c line 64
signed int VSL_Name2Tag(const char *name, signed int l);
// VSL_New
// file ../../include/vapi/vsl.h line 240
struct VSL_data * VSL_New(void);
// VSL_Next
// file ../../include/vapi/vsl.h line 326
signed int VSL_Next(struct VSL_cursor *cursor);
// VSL_Print
// file vsl.c line 235
signed int VSL_Print(struct VSL_data *vsl, struct VSL_cursor *c, void *fo);
// VSL_PrintAll
// file vsl.c line 309
signed int VSL_PrintAll(struct VSL_data *vsl, struct VSL_cursor *c, void *fo);
// VSL_PrintTerse
// file vsl.c line 275
signed int VSL_PrintTerse(struct VSL_data *vsl, struct VSL_cursor *c, void *fo);
// VSL_PrintTransactions
// file vsl.c line 328
signed int VSL_PrintTransactions(struct VSL_data *vsl, struct VSL_transaction * const *pt, void *fo);
// VSL_ResetCursor
// file vsl_cursor.c line 453
signed int VSL_ResetCursor(struct VSL_cursor *cursor);
// VSL_ResetError
// file ../../include/vapi/vsl.h line 260
void VSL_ResetError(struct VSL_data *vsl);
// VSL_Write
// file vsl.c line 429
signed int VSL_Write(struct VSL_data *vsl, struct VSL_cursor *c, void *fo);
// VSL_WriteAll
// file vsl.c line 446
signed int VSL_WriteAll(struct VSL_data *vsl, struct VSL_cursor *c, void *fo);
// VSL_WriteOpen
// file vsl.c line 407
struct _IO_FILE * VSL_WriteOpen(struct VSL_data *vsl, const char *name, signed int append, signed int unbuf);
// VSL_WriteTransactions
// file vsl.c line 465
signed int VSL_WriteTransactions(struct VSL_data *vsl, struct VSL_transaction * const *pt, void *fo);
// VSM_Abandoned
// file vsm.c line 308
signed int VSM_Abandoned(struct VSM_data *vd);
// VSM_Close
// file ../../include/vapi/vsm.h line 141
void VSM_Close(struct VSM_data *vd);
// VSM_Delete
// file ../../include/vapi/vsm.h line 75
void VSM_Delete(struct VSM_data *vd);
// VSM_Error
// file ../../include/vapi/vsm.h line 81
const char * VSM_Error(struct VSM_data *vd);
// VSM_Get
// file vsm.c line 437
signed int VSM_Get(struct VSM_data *vd, struct VSM_fantom *vf, const char *class, const char *type, const char *ident);
// VSM_N_Arg
// file ../../include/vapi/vsm.h line 105
signed int VSM_N_Arg(struct VSM_data *vd, const char *arg);
// VSM_Name
// file ../../include/vapi/vsm.h line 115
const char * VSM_Name(struct VSM_data *vd);
// VSM_New
// file ../../include/vapi/vsm.h line 64
struct VSM_data * VSM_New(void);
// VSM_Open
// file ../../include/vapi/vsm.h line 120
signed int VSM_Open(struct VSM_data *vd);
// VSM_ResetError
// file ../../include/vapi/vsm.h line 86
void VSM_ResetError(struct VSM_data *vd);
// VSM_StillValid
// file vsm.c line 407
enum VSM_valid_e VSM_StillValid(struct VSM_data *vd, struct VSM_fantom *vf);
// VSM__iter0
// file vsm.c line 348
void VSM__iter0(struct VSM_data *vd, struct VSM_fantom *vf);
// VSM__itern
// file vsm.c line 358
signed int VSM__itern(struct VSM_data *vd, struct VSM_fantom *vf);
// VSM_n_Arg
// file ../../include/vapi/vsm.h line 93
signed int VSM_n_Arg(struct VSM_data *vd, const char *arg);
// VTIM_format
// file ../../lib/libvarnish/vtim.c line 103
void VTIM_format(double t, char *p);
// VTIM_mono
// file ../../lib/libvarnish/vtim.c line 69
double VTIM_mono(void);
// VTIM_parse
// file ../../lib/libvarnish/vtim.c line 124
double VTIM_parse(const char *p);
// VTIM_real
// file ../../lib/libvarnish/vtim.c line 87
double VTIM_real(void);
// VTIM_sleep
// file ../../include/vtim.h line 37
void VTIM_sleep(double t);
// VTIM_timespec
// file ../../lib/libvarnish/vtim.c line 194
struct timespec VTIM_timespec(double t);
// VTIM_timeval
// file ../../lib/libvarnish/vtim.c line 184
struct timeval VTIM_timeval(double t);
// VUT_Arg
// file ../../include/vut.h line 72
signed int VUT_Arg(signed int opt, const char *arg);
// VUT_Error
// file ../../lib/libvarnishtools/vut.c line 105
void VUT_Error(signed int status, const char *fmt, ...);
// VUT_Fini
// file ../../include/vut.h line 78
void VUT_Fini(void);
// VUT_Init
// file ../../include/vut.h line 76
void VUT_Init(const char *progname);
// VUT_Main
// file ../../include/vut.h line 80
signed int VUT_Main(void);
// VUT_Setup
// file ../../include/vut.h line 74
void VUT_Setup(void);
// VUT_g_Arg
// file ../../lib/libvarnishtools/vut.c line 120
signed int VUT_g_Arg(const char *arg);
// _VPF_Remove
// file ../../lib/libvarnish/vpf.c line 225
static signed int _VPF_Remove(struct vpf_fh *pfh, signed int freeit);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _assert_VSB_integrity
// file ../../lib/libvarnish/vsb.c line 79
static void _assert_VSB_integrity(const char *fun, struct vsb *s);
// _assert_VSB_integrity$link1
// file ../libvarnish/vsb.c line 79
static void _assert_VSB_integrity$link1(const char *fun$link1, struct vsb *s$link1);
// _assert_VSB_state
// file ../../lib/libvarnish/vsb.c line 95
static void _assert_VSB_state(const char *fun, struct vsb *s, signed int state);
// _assert_VSB_state$link1
// file ../libvarnish/vsb.c line 95
static void _assert_VSB_state$link1(const char *fun$link1, struct vsb *s$link1, signed int state$link1);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accumulate
// file varnishtop.c line 117
static signed int accumulate(struct VSL_data *vsl, struct VSL_transaction * const *pt, void *priv);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// be32dec_vect
// file ../libvarnish/vsha256.c line 80
static void be32dec_vect(unsigned int *dst, const unsigned char *src, unsigned long int len);
// be32enc_vect
// file ../libvarnish/vsha256.c line 67
static void be32enc_vect(unsigned char *dst, const unsigned int *src, unsigned long int len);
// beep
// file /usr/include/curses.h line 588
extern signed int beep(void);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chunk_appendbuf
// file vsl_dispatch.c line 373
static void chunk_appendbuf(struct chunk *chunk, const unsigned int *ptr, unsigned long int len);
// chunk_freebuf
// file vsl_dispatch.c line 361
static void chunk_freebuf(struct chunk **pchunk);
// chunk_newbuf
// file vsl_dispatch.c line 341
static struct chunk * chunk_newbuf(struct vtx *vtx, const unsigned int *ptr, unsigned long int len);
// chunk_shm_to_buf
// file vsl_dispatch.c line 390
static void chunk_shm_to_buf(struct VSLQ *vslq, struct chunk *chunk);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// cmp_key
// file varnishtop.c line 82
static inline signed int cmp_key(struct top *a, struct top *b);
// cmp_order
// file varnishtop.c line 94
static inline signed int cmp_order(struct top *a, struct top *b);
// curs_set
// file /usr/include/curses.h line 604
extern signed int curs_set(signed int);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// do_curses
// file varnishtop.c line 235
static void * do_curses(void *arg);
// dump
// file varnishtop.c line 294
static void dump(void);
// endwin
// file /usr/include/curses.h line 618
extern signed int endwin(void);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// flopen
// file ../../lib/libvarnish/flopen.c line 43
signed int flopen(const char *path, signed int flags, ...);
// fltest
// file ../../lib/libvarnish/flopen.c line 118
signed int fltest(signed int fd, signed int *pid);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 214
extern signed int fstat(signed int, struct stat *);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// ftruncate
// file /usr/include/unistd.h line 1016
extern signed int ftruncate(signed int, signed long int);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gmtime_r
// file /usr/include/time.h line 249
extern struct tm * gmtime_r(const signed long int *, struct tm *);
// initscr
// file /usr/include/curses.h line 639
extern struct _win_st * initscr(void);
// intrflush
// file /usr/include/curses.h line 649
extern signed int intrflush(struct _win_st *, _Bool);
// iter_lck
// file ../../include/tbl/vsc_all.h line 37
static void iter_lck(struct vsc *vsc, struct VSC_desc *descs, struct vsc_vf *vf);
// iter_main
// file ../../include/tbl/vsc_all.h line 43
static void iter_main(struct vsc *vsc, struct VSC_desc *descs, struct vsc_vf *vf);
// iter_mempool
// file ../../include/tbl/vsc_all.h line 65
static void iter_mempool(struct vsc *vsc, struct VSC_desc *descs, struct vsc_vf *vf);
// iter_mgt
// file ../../include/tbl/vsc_all.h line 31
static void iter_mgt(struct vsc *vsc, struct VSC_desc *descs, struct vsc_vf *vf);
// iter_sma
// file ../../include/tbl/vsc_all.h line 47
static void iter_sma(struct vsc *vsc, struct VSC_desc *descs, struct vsc_vf *vf);
// iter_smf
// file ../../include/tbl/vsc_all.h line 53
static void iter_smf(struct vsc *vsc, struct VSC_desc *descs, struct vsc_vf *vf);
// iter_test
// file vsc.c line 454
static inline signed int iter_test(const char *s1, const char *s2, signed int wc);
// iter_vbe
// file ../../include/tbl/vsc_all.h line 59
static void iter_vbe(struct vsc *vsc, struct VSC_desc *descs, struct vsc_vf *vf);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// mvprintw
// file /usr/include/curses.h line 681
extern signed int mvprintw(signed int, signed int, const char *, ...);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// noecho
// file /usr/include/curses.h line 718
extern signed int noecho(void);
// nonl
// file /usr/include/curses.h line 719
extern signed int nonl(void);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// pcre_compile
// file /usr/include/pcre.h line 540
extern struct real_pcre * pcre_compile(const char *, signed int, const char **, signed int *, const unsigned char *);
// pcre_exec
// file /usr/include/pcre.h line 573
extern signed int pcre_exec(const struct real_pcre *, const struct pcre_extra *, const char *, signed int, signed int, signed int, signed int *, signed int);
// pcre_free$object
//
void pcre_free$object(void *);
// pcre_free_study
// file /usr/include/pcre.h line 636
extern void pcre_free_study(struct pcre_extra *);
// pcre_study
// file /usr/include/pcre.h line 633
extern struct pcre_extra * pcre_study(const struct real_pcre *, signed int, const char **);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 244
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 261
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_lock(union anonymous$0 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 784
extern signed int pthread_mutex_unlock(union anonymous$0 *);
// pwrite
// file /usr/include/unistd.h line 384
extern signed long int pwrite(signed int, const void *, unsigned long int, signed long int);
// raise
// file /usr/include/signal.h line 139
extern signed int raise(signed int);
// raw
// file /usr/include/curses.h line 734
extern signed int raw(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_tmo
// file ../libvarnish/cli_common.c line 143
static signed int read_tmo(signed int fd, char *ptr, unsigned int len, double tmo);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// setbuf
// file /usr/include/stdio.h line 332
extern void setbuf(struct _IO_FILE *, char *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 209
extern signed int stat(const char *, struct stat *);
// strcasecmp
// file /usr/include/string.h line 534
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 236
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 176
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 413
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 399
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 538
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strptime
// file /usr/include/time.h line 213
extern char * strptime(const char *, const char *, struct tm *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoll
// file /usr/include/stdlib.h line 209
extern signed long long int strtoll(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// t_key_VRB_FIND
// file varnishtop.c line 114
struct top * t_key_VRB_FIND(struct t_key *head, struct top *elm);
// t_key_VRB_INSERT
// file varnishtop.c line 114
struct top * t_key_VRB_INSERT(struct t_key *head, struct top *elm);
// t_key_VRB_INSERT_COLOR
// file varnishtop.c line 114
void t_key_VRB_INSERT_COLOR(struct t_key *head, struct top *elm);
// t_key_VRB_MINMAX
// file varnishtop.c line 114
struct top * t_key_VRB_MINMAX(struct t_key *head, signed int val);
// t_key_VRB_NEXT
// file varnishtop.c line 114
struct top * t_key_VRB_NEXT(struct top *elm);
// t_key_VRB_NFIND
// file varnishtop.c line 114
struct top * t_key_VRB_NFIND(struct t_key *head, struct top *elm);
// t_key_VRB_PREV
// file varnishtop.c line 114
struct top * t_key_VRB_PREV(struct top *elm);
// t_key_VRB_REMOVE
// file varnishtop.c line 114
struct top * t_key_VRB_REMOVE(struct t_key *head, struct top *elm);
// t_key_VRB_REMOVE_COLOR
// file varnishtop.c line 114
void t_key_VRB_REMOVE_COLOR(struct t_key *head, struct top *parent, struct top *elm);
// t_order_VRB_FIND
// file varnishtop.c line 112
struct top * t_order_VRB_FIND(struct t_order *head, struct top *elm);
// t_order_VRB_INSERT
// file varnishtop.c line 112
struct top * t_order_VRB_INSERT(struct t_order *head, struct top *elm);
// t_order_VRB_INSERT_COLOR
// file varnishtop.c line 112
void t_order_VRB_INSERT_COLOR(struct t_order *head, struct top *elm);
// t_order_VRB_MINMAX
// file varnishtop.c line 112
struct top * t_order_VRB_MINMAX(struct t_order *head, signed int val);
// t_order_VRB_NEXT
// file varnishtop.c line 112
struct top * t_order_VRB_NEXT(struct top *elm);
// t_order_VRB_NFIND
// file varnishtop.c line 112
struct top * t_order_VRB_NFIND(struct t_order *head, struct top *elm);
// t_order_VRB_PREV
// file varnishtop.c line 112
struct top * t_order_VRB_PREV(struct top *elm);
// t_order_VRB_REMOVE
// file varnishtop.c line 112
struct top * t_order_VRB_REMOVE(struct t_order *head, struct top *elm);
// t_order_VRB_REMOVE_COLOR
// file varnishtop.c line 112
void t_order_VRB_REMOVE_COLOR(struct t_order *head, struct top *parent, struct top *elm);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timegm
// file /usr/include/time.h line 319
extern signed long int timegm(struct tm *);
// trunc
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 313
extern double trunc(double);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// update
// file varnishtop.c line 183
static void update(signed int p);
// usage
// file varnishtop.c line 308
static void usage(signed int status);
// vbe32dec
// file ../../include/vend.h line 45
static inline unsigned int vbe32dec(const void *pp);
// vbe32enc
// file ../../include/vend.h line 98
static inline void vbe32enc(void *pp, unsigned int u);
// vbe64enc
// file ../../include/vend.h line 109
static inline void vbe64enc(void *pp, unsigned long int u);
// vbit_clr
// file ../../include/vbm.h line 94
static inline void vbit_clr(struct vbitmap *vb, unsigned int bit);
// vbit_destroy
// file ../../include/vbm.h line 75
static inline void vbit_destroy(struct vbitmap *vb);
// vbit_destroy$link1
// file ../../include/vbm.h line 75
static inline void vbit_destroy$link1(struct vbitmap *vb$link1);
// vbit_destroy$link2
// file ../../include/vbm.h line 75
static inline void vbit_destroy$link2(struct vbitmap *vb$link2);
// vbit_expand
// file ../../include/vbm.h line 48
static inline void vbit_expand(struct vbitmap *vb, unsigned int bit);
// vbit_expand$link1
// file ../../include/vbm.h line 48
static inline void vbit_expand$link1(struct vbitmap *vb$link1, unsigned int bit$link1);
// vbit_expand$link2
// file ../../include/vbm.h line 48
static inline void vbit_expand$link2(struct vbitmap *vb$link2, unsigned int bit$link2);
// vbit_init
// file ../../include/vbm.h line 62
static inline struct vbitmap * vbit_init(unsigned int initial);
// vbit_init$link1
// file ../../include/vbm.h line 62
static inline struct vbitmap * vbit_init$link1(unsigned int initial$link1);
// vbit_init$link2
// file ../../include/vbm.h line 62
static inline struct vbitmap * vbit_init$link2(unsigned int initial$link2);
// vbit_set
// file ../../include/vbm.h line 85
static inline void vbit_set(struct vbitmap *vb, unsigned int bit);
// vbit_test
// file ../../include/vbm.h line 102
static inline signed int vbit_test(struct vbitmap *vb, unsigned int bit);
// vbit_test$link1
// file ../../include/vbm.h line 102
static inline signed int vbit_test$link1(struct vbitmap *vb$link1, unsigned int bit$link1);
// vex_Free
// file vxp.h line 146
void vex_Free(struct vex **pvex);
// vex_New
// file vxp.h line 145
struct vex * vex_New(const char *query, struct vsb *sb, unsigned int options);
// vex_alloc
// file vxp_parse.c line 53
static struct vex * vex_alloc(struct vxp *vxp);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vpf_read
// file ../../lib/libvarnish/vpf.c line 74
static signed int vpf_read(const char *path, signed int *pidptr);
// vpf_verify
// file ../../lib/libvarnish/vpf.c line 57
static signed int vpf_verify(struct vpf_fh *pfh);
// vsc_add_pt
// file vsc.c line 365
static void vsc_add_pt(struct vsc *vsc, const volatile void *ptr, struct VSC_desc *desc, struct vsc_vf *vf);
// vsc_add_vf
// file vsc.c line 339
static void vsc_add_vf(struct vsc *vsc, struct VSM_fantom *fantom, struct VSC_type_desc *desc, signed int order);
// vsc_build_pt_list
// file vsc.c line 427
static void vsc_build_pt_list(struct VSM_data *vd);
// vsc_build_vf_list
// file vsc.c line 407
static void vsc_build_vf_list(struct VSM_data *vd);
// vsc_delete_pt_list
// file vsc.c line 132
static void vsc_delete_pt_list(struct vsc *vsc);
// vsc_delete_sf_list
// file vsc.c line 145
static void vsc_delete_sf_list(struct vsc *vsc);
// vsc_delete_vf_list
// file vsc.c line 119
static void vsc_delete_vf_list(struct vsc *vsc);
// vsc_f_arg
// file vsc.c line 178
static signed int vsc_f_arg(struct VSM_data *vd, const char *opt);
// vsc_filter_pt_list
// file vsc.c line 467
static void vsc_filter_pt_list(struct VSM_data *vd);
// vsc_setup
// file vsc.c line 102
static struct vsc * vsc_setup(struct VSM_data *vd);
// vsl_IX_arg
// file vsl_arg.c line 254
static signed int vsl_IX_arg(struct VSL_data *vsl, signed int opt, const char *arg);
// vsl_IX_free
// file vsl.c line 111
static void vsl_IX_free(struct anonymous$1 *filters);
// vsl_diag
// file vsl_api.h line 40
signed int vsl_diag(struct VSL_data *vsl, const char *fmt, ...);
// vsl_ix_arg
// file vsl_arg.c line 231
static signed int vsl_ix_arg(struct VSL_data *vsl, signed int opt, const char *arg);
// vsl_match_IX
// file vsl.c line 166
static signed int vsl_match_IX(struct VSL_data *vsl, const struct anonymous$1 *list, struct VSL_cursor *c);
// vsl_vbm_bitclr
// file vsl_arg.c line 224
void vsl_vbm_bitclr(signed int bit, void *priv);
// vsl_vbm_bitset
// file vsl_arg.c line 217
void vsl_vbm_bitset(signed int bit, void *priv);
// vslc_file_delete
// file vsl_cursor.c line 293
static void vslc_file_delete(struct VSL_cursor *cursor);
// vslc_file_next
// file vsl_cursor.c line 323
static signed int vslc_file_next(struct VSL_cursor *cursor);
// vslc_file_readn
// file vsl_cursor.c line 308
static signed long int vslc_file_readn(signed int fd, void *buf, unsigned long int n);
// vslc_file_reset
// file vsl_cursor.c line 366
static signed int vslc_file_reset(struct VSL_cursor *cursor);
// vslc_raw_next
// file vsl_dispatch.c line 224
static signed int vslc_raw_next(struct VSL_cursor *cursor);
// vslc_raw_reset
// file vsl_dispatch.c line 242
static signed int vslc_raw_reset(struct VSL_cursor *cursor);
// vslc_vsm_check
// file vsl_cursor.c line 77
static signed int vslc_vsm_check(struct VSL_cursor *cursor, struct VSLC_ptr *ptr);
// vslc_vsm_delete
// file vsl_cursor.c line 67
static void vslc_vsm_delete(struct VSL_cursor *cursor);
// vslc_vsm_next
// file vsl_cursor.c line 117
static signed int vslc_vsm_next(struct VSL_cursor *cursor);
// vslc_vsm_reset
// file vsl_cursor.c line 192
static signed int vslc_vsm_reset(struct VSL_cursor *cursor);
// vslc_vtx_next
// file vsl_dispatch.c line 264
static signed int vslc_vtx_next(struct VSL_cursor *cursor);
// vslc_vtx_reset
// file vsl_dispatch.c line 315
static signed int vslc_vtx_reset(struct VSL_cursor *cursor);
// vslq_callback
// file vsl_dispatch.c line 906
static signed int vslq_callback(struct VSLQ *vslq, struct vtx *vtx, signed int (*func)(struct VSL_data *, struct VSL_transaction * const *, void *), void *priv);
// vslq_callback::func$object
//
signed int func$object(struct VSL_data *, struct VSL_transaction * const *, void *);
// vslq_deletequery
// file vsl_api.h line 100
void vslq_deletequery(struct vslq_query **pquery);
// vslq_exec
// file vsl_query.c line 264
static signed int vslq_exec(struct vex *vex, struct VSL_transaction * const *ptrans);
// vslq_newquery
// file vsl_api.h line 98
struct vslq_query * vslq_newquery(struct VSL_data *vsl, enum VSL_grouping_e grouping, const char *querystring);
// vslq_next
// file vsl_dispatch.c line 1218
static signed int vslq_next(struct VSLQ *vslq);
// vslq_process_ready
// file vsl_dispatch.c line 1264
static signed int vslq_process_ready(struct VSLQ *vslq, signed int (*func)(struct VSL_data *, struct VSL_transaction * const *, void *), void *priv);
// vslq_process_ready::func$object
//
signed int func$object(struct VSL_data *, struct VSL_transaction * const *, void *);
// vslq_raw
// file vsl_dispatch.c line 1138
static signed int vslq_raw(struct VSLQ *vslq, signed int (*func)(struct VSL_data *, struct VSL_transaction * const *, void *), void *priv);
// vslq_raw::func$object
//
signed int func$object(struct VSL_data *, struct VSL_transaction * const *, void *);
// vslq_runquery
// file vsl_api.h line 101
signed int vslq_runquery(struct vslq_query *query, struct VSL_transaction * const *ptrans);
// vslq_shmref_check
// file vsl_dispatch.c line 1192
static signed int vslq_shmref_check(struct VSLQ *vslq);
// vslq_test
// file vsl_query.c line 215
static signed int vslq_test(struct vex *vex, struct VSL_transaction * const *ptrans);
// vslq_test_rec
// file vsl_query.c line 72
static signed int vslq_test_rec(struct vex *vex, struct VSLC_ptr *rec);
// vsm_diag
// file vsm.c line 82
signed int vsm_diag(struct VSM_data *vd, const char *fmt, ...);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// vtx_add
// file vsl_dispatch.c line 605
static struct vtx * vtx_add(struct VSLQ *vslq, unsigned int vxid);
// vtx_append
// file vsl_dispatch.c line 423
static void vtx_append(struct VSLQ *vslq, struct vtx *vtx, struct VSLC_ptr *start, unsigned long int len);
// vtx_diag
// file vsl_dispatch.c line 1027
static signed int vtx_diag(struct vtx *vtx, const char *msg);
// vtx_diag_tag
// file vsl_dispatch.c line 1037
static signed int vtx_diag_tag(struct vtx *vtx, const unsigned int *ptr, const char *reason);
// vtx_force
// file vsl_dispatch.c line 887
static void vtx_force(struct VSLQ *vslq, struct vtx *vtx, const char *reason);
// vtx_keycmp
// file vsl_dispatch.c line 211
static inline signed int vtx_keycmp(struct vtx_key *a, struct vtx_key *b);
// vtx_lookup
// file vsl_dispatch.c line 589
static struct vtx * vtx_lookup(struct VSLQ *vslq, unsigned int vxid);
// vtx_mark_complete
// file vsl_dispatch.c line 622
static void vtx_mark_complete(struct VSLQ *vslq, struct vtx *vtx);
// vtx_new
// file vsl_dispatch.c line 466
static struct vtx * vtx_new(struct VSLQ *vslq);
// vtx_parse_link
// file vsl_dispatch.c line 675
static signed int vtx_parse_link(const char *str, enum VSL_transaction_e *ptype, unsigned int *pvxid, enum VSL_reason_e *preason);
// vtx_retire
// file vsl_dispatch.c line 517
static void vtx_retire(struct VSLQ *vslq, struct vtx **pvtx);
// vtx_scan
// file vsl_dispatch.c line 842
static void vtx_scan(struct VSLQ *vslq, struct vtx *vtx);
// vtx_scan_begin
// file vsl_dispatch.c line 714
static signed int vtx_scan_begin(struct VSLQ *vslq, struct vtx *vtx, const unsigned int *ptr);
// vtx_scan_link
// file vsl_dispatch.c line 781
static signed int vtx_scan_link(struct VSLQ *vslq, struct vtx *vtx, const unsigned int *ptr);
// vtx_set_parent
// file vsl_dispatch.c line 655
static void vtx_set_parent(struct vtx *parent, struct vtx *child);
// vtx_synth_rec
// file vsl_dispatch.c line 975
static void vtx_synth_rec(struct vtx *vtx, unsigned int tag, const char *fmt, ...);
// vtx_tree_VRB_FIND
// file vsl_dispatch.c line 221
static struct vtx_key * vtx_tree_VRB_FIND(struct vtx_tree *head, struct vtx_key *elm);
// vtx_tree_VRB_INSERT
// file vsl_dispatch.c line 221
static struct vtx_key * vtx_tree_VRB_INSERT(struct vtx_tree *head, struct vtx_key *elm);
// vtx_tree_VRB_INSERT_COLOR
// file vsl_dispatch.c line 221
static void vtx_tree_VRB_INSERT_COLOR(struct vtx_tree *head, struct vtx_key *elm);
// vtx_tree_VRB_REMOVE
// file vsl_dispatch.c line 221
static struct vtx_key * vtx_tree_VRB_REMOVE(struct vtx_tree *head, struct vtx_key *elm);
// vtx_tree_VRB_REMOVE_COLOR
// file vsl_dispatch.c line 221
static void vtx_tree_VRB_REMOVE_COLOR(struct vtx_tree *head, struct vtx_key *parent, struct vtx_key *elm);
// vut_dispatch
// file ../../lib/libvarnishtools/vut.c line 87
static signed int vut_dispatch(struct VSL_data *vsl, struct VSL_transaction * const *trans, void *priv);
// vut_sighup
// file ../../lib/libvarnishtools/vut.c line 66
static void vut_sighup(signed int sig);
// vut_sigint
// file ../../lib/libvarnishtools/vut.c line 73
static void vut_sigint(signed int sig);
// vut_sigusr1
// file ../../lib/libvarnishtools/vut.c line 80
static void vut_sigusr1(signed int sig);
// vut_vpf_remove
// file ../../lib/libvarnishtools/vut.c line 57
static void vut_vpf_remove(void);
// vxp_Alloc
// file vxp.c line 151
void * vxp_Alloc(struct vxp *vxp, unsigned int len);
// vxp_Delete
// file vxp.c line 178
static void vxp_Delete(struct vxp **pvxp);
// vxp_DoFree
// file vxp.c line 140
static void vxp_DoFree(struct vxp *vxp, void *p);
// vxp_ErrToken
// file vxp.c line 46
static void vxp_ErrToken(struct vxp *vxp, struct token *t);
// vxp_ErrWhere
// file vxp.c line 101
void vxp_ErrWhere(struct vxp *vxp, struct token *t, signed int tokoff);
// vxp_Lexer
// file vxp.h line 140
void vxp_Lexer(struct vxp *vxp);
// vxp_New
// file vxp.c line 162
static struct vxp * vxp_New(struct vsb *sb);
// vxp_NextToken
// file vxp.c line 114
void vxp_NextToken(struct vxp *vxp);
// vxp_Parse
// file vxp.h line 141
struct vex * vxp_Parse(struct vxp *vxp);
// vxp_Pos
// file vxp.c line 56
static void vxp_Pos(struct vxp *vxp, struct vsb *vsb, struct token *t, signed int tokoff);
// vxp__Expect
// file vxp.c line 128
void vxp__Expect(struct vxp *vxp, unsigned int tok);
// vxp_add_token
// file vxp_lexer.c line 45
static void vxp_add_token(struct vxp *vxp, unsigned int tok, const char *b, const char *e);
// vxp_decstr
// file vxp_lexer.c line 62
static signed int vxp_decstr(struct vxp *vxp, signed int quoted);
// vxp_expr
// file vxp_parse.c line 463
static void vxp_expr(struct vxp *vxp, struct vex **pvex);
// vxp_expr_and
// file vxp_parse.c line 407
static void vxp_expr_and(struct vxp *vxp, struct vex **pvex);
// vxp_expr_cmp
// file vxp_parse.c line 277
static void vxp_expr_cmp(struct vxp *vxp, struct vex **pvex);
// vxp_expr_group
// file vxp_parse.c line 356
static void vxp_expr_group(struct vxp *vxp, struct vex **pvex);
// vxp_expr_lhs
// file vxp_parse.c line 64
static void vxp_expr_lhs(struct vxp *vxp, struct vex_lhs **plhs);
// vxp_expr_not
// file vxp_parse.c line 381
static void vxp_expr_not(struct vxp *vxp, struct vex **pvex);
// vxp_expr_num
// file vxp_parse.c line 178
static void vxp_expr_num(struct vxp *vxp, struct vex_rhs **prhs);
// vxp_expr_or
// file vxp_parse.c line 435
static void vxp_expr_or(struct vxp *vxp, struct vex **pvex);
// vxp_expr_regex
// file vxp_parse.c line 238
static void vxp_expr_regex(struct vxp *vxp, struct vex_rhs **prhs);
// vxp_expr_str
// file vxp_parse.c line 217
static void vxp_expr_str(struct vxp *vxp, struct vex_rhs **prhs);
// vxp_fixed_token
// file vxp.h line 44
unsigned int vxp_fixed_token(const char *p, const char **q);
// vxp_quote
// file vxp.c line 72
static void vxp_quote(struct vxp *vxp, const char *b, const char *e, signed int tokoff);
// werase
// file /usr/include/curses.h line 816
extern signed int werase(struct _win_st *);
// wgetch
// file /usr/include/curses.h line 817
extern signed int wgetch(struct _win_st *);
// wredrawln
// file /usr/include/curses.h line 835
extern signed int wredrawln(struct _win_st *, signed int, signed int);
// wrefresh
// file /usr/include/curses.h line 836
extern signed int wrefresh(struct _win_st *);
// writev
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 50
extern signed long int writev(signed int, struct iovec *, signed int);
// wtimeout
// file /usr/include/curses.h line 845
extern void wtimeout(struct _win_st *, signed int);

struct anonymous$22
{
  // vtqe_next
  struct chunk *vtqe_next;
  // vtqe_prev
  struct chunk **vtqe_prev;
};

struct anonymous$13
{
  // vtqe_next
  struct membit *vtqe_next;
  // vtqe_prev
  struct membit **vtqe_prev;
};

struct anonymous$16
{
  // vtqh_first
  struct membit *vtqh_first;
  // vtqh_last
  struct membit **vtqh_last;
};

struct anonymous$20
{
  // vtqe_next
  struct synth *vtqe_next;
  // vtqe_prev
  struct synth **vtqe_prev;
};

struct anonymous$19
{
  // vtqh_first
  struct synth *vtqh_first;
  // vtqh_last
  struct synth **vtqh_last;
};

struct anonymous$14
{
  // vtqe_next
  struct token *vtqe_next;
  // vtqe_prev
  struct token **vtqe_prev;
};

struct anonymous$15
{
  // vtqh_first
  struct token *vtqh_first;
  // vtqh_last
  struct token **vtqh_last;
};

struct anonymous$3
{
  // rbe_left
  struct top *rbe_left;
  // rbe_right
  struct top *rbe_right;
  // rbe_parent
  struct top *rbe_parent;
  // rbe_color
  signed int rbe_color;
};

struct anonymous$10
{
  // vtqe_next
  struct vsc_pt *vtqe_next;
  // vtqe_prev
  struct vsc_pt **vtqe_prev;
};

struct anonymous$7
{
  // vtqh_first
  struct vsc_pt *vtqh_first;
  // vtqh_last
  struct vsc_pt **vtqh_last;
};

struct anonymous$11
{
  // vtqe_next
  struct vsc_sf *vtqe_next;
  // vtqe_prev
  struct vsc_sf **vtqe_prev;
};

struct anonymous$8
{
  // vtqh_first
  struct vsc_sf *vtqh_first;
  // vtqh_last
  struct vsc_sf **vtqh_last;
};

struct anonymous$9
{
  // vtqe_next
  struct vsc_vf *vtqe_next;
  // vtqe_prev
  struct vsc_vf **vtqe_prev;
};

struct anonymous$6
{
  // vtqh_first
  struct vsc_vf *vtqh_first;
  // vtqh_last
  struct vsc_vf **vtqh_last;
};

struct anonymous$2
{
  // vtqe_next
  struct vslf *vtqe_next;
  // vtqe_prev
  struct vslf **vtqe_prev;
};

struct anonymous$1
{
  // vtqh_first
  struct vslf *vtqh_first;
  // vtqh_last
  struct vslf **vtqh_last;
};

struct anonymous$18
{
  // vtqe_next
  struct vtx *vtqe_next;
  // vtqe_prev
  struct vtx **vtqe_prev;
};

struct anonymous$4
{
  // vtqh_first
  struct vtx *vtqh_first;
  // vtqh_last
  struct vtx **vtqh_last;
};

struct anonymous$17
{
  // rbe_left
  struct vtx_key *rbe_left;
  // rbe_right
  struct vtx_key *rbe_right;
  // rbe_parent
  struct vtx_key *rbe_parent;
  // rbe_color
  signed int rbe_color;
};

struct anonymous$24
{
  // data
  unsigned int *data;
  // space
  unsigned long int space;
};

struct VSLC_ptr
{
  // ptr
  const unsigned int *ptr;
  // priv
  unsigned int priv;
};

struct anonymous$23
{
  // start
  struct VSLC_ptr start;
  // shmref
  struct anonymous$22 shmref;
};

struct VSL_cursor
{
  // rec
  struct VSLC_ptr rec;
  // priv_tbl
  const void *priv_tbl;
  // priv_data
  void *priv_data;
};

struct vslc_raw
{
  // magic
  unsigned int magic;
  // cursor
  struct VSL_cursor cursor;
  // ptr
  const unsigned int *ptr;
};

struct VSL_transaction
{
  // level
  unsigned int level;
  // vxid
  signed int vxid;
  // vxid_parent
  signed int vxid_parent;
  // type
  enum VSL_transaction_e type;
  // reason
  enum VSL_reason_e reason;
  // c
  struct VSL_cursor *c;
};

struct anonymous$5
{
  // c
  struct vslc_raw c;
  // trans
  struct VSL_transaction trans;
  // ptrans
  struct VSL_transaction *ptrans[2l];
  // start
  struct VSLC_ptr start;
  // len
  signed long int len;
  // offset
  unsigned long int offset;
};

struct anonymous
{
  // attr
  unsigned long int attr;
  // chars
  signed int chars[5l];
};

union anonymous$21
{
  // shm
  struct anonymous$23 shm;
  // buf
  struct anonymous$24 buf;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$0
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct SHA256Context
{
  // state
  unsigned int state[8l];
  // count
  unsigned long int count;
  // buf
  unsigned char buf[64l];
};

struct VSC_C_lck
{
  // creat
  unsigned long int creat;
  // destroy
  unsigned long int destroy;
  // locks
  unsigned long int locks;
};

struct VSC_C_main
{
  // uptime
  unsigned long int uptime;
  // sess_conn
  unsigned long int sess_conn;
  // sess_drop
  unsigned long int sess_drop;
  // sess_fail
  unsigned long int sess_fail;
  // sess_pipe_overflow
  unsigned long int sess_pipe_overflow;
  // client_req_400
  unsigned long int client_req_400;
  // client_req_411
  unsigned long int client_req_411;
  // client_req_413
  unsigned long int client_req_413;
  // client_req_417
  unsigned long int client_req_417;
  // client_req
  unsigned long int client_req;
  // cache_hit
  unsigned long int cache_hit;
  // cache_hitpass
  unsigned long int cache_hitpass;
  // cache_miss
  unsigned long int cache_miss;
  // backend_conn
  unsigned long int backend_conn;
  // backend_unhealthy
  unsigned long int backend_unhealthy;
  // backend_busy
  unsigned long int backend_busy;
  // backend_fail
  unsigned long int backend_fail;
  // backend_reuse
  unsigned long int backend_reuse;
  // backend_toolate
  unsigned long int backend_toolate;
  // backend_recycle
  unsigned long int backend_recycle;
  // backend_retry
  unsigned long int backend_retry;
  // fetch_head
  unsigned long int fetch_head;
  // fetch_length
  unsigned long int fetch_length;
  // fetch_chunked
  unsigned long int fetch_chunked;
  // fetch_eof
  unsigned long int fetch_eof;
  // fetch_bad
  unsigned long int fetch_bad;
  // fetch_close
  unsigned long int fetch_close;
  // fetch_oldhttp
  unsigned long int fetch_oldhttp;
  // fetch_zero
  unsigned long int fetch_zero;
  // fetch_1xx
  unsigned long int fetch_1xx;
  // fetch_204
  unsigned long int fetch_204;
  // fetch_304
  unsigned long int fetch_304;
  // fetch_failed
  unsigned long int fetch_failed;
  // fetch_no_thread
  unsigned long int fetch_no_thread;
  // pools
  unsigned long int pools;
  // threads
  unsigned long int threads;
  // threads_limited
  unsigned long int threads_limited;
  // threads_created
  unsigned long int threads_created;
  // threads_destroyed
  unsigned long int threads_destroyed;
  // threads_failed
  unsigned long int threads_failed;
  // thread_queue_len
  unsigned long int thread_queue_len;
  // busy_sleep
  unsigned long int busy_sleep;
  // busy_wakeup
  unsigned long int busy_wakeup;
  // sess_queued
  unsigned long int sess_queued;
  // sess_dropped
  unsigned long int sess_dropped;
  // n_object
  unsigned long int n_object;
  // n_vampireobject
  unsigned long int n_vampireobject;
  // n_objectcore
  unsigned long int n_objectcore;
  // n_objecthead
  unsigned long int n_objecthead;
  // n_waitinglist
  unsigned long int n_waitinglist;
  // n_backend
  unsigned long int n_backend;
  // n_expired
  unsigned long int n_expired;
  // n_lru_nuked
  unsigned long int n_lru_nuked;
  // n_lru_moved
  unsigned long int n_lru_moved;
  // losthdr
  unsigned long int losthdr;
  // s_sess
  unsigned long int s_sess;
  // s_req
  unsigned long int s_req;
  // s_pipe
  unsigned long int s_pipe;
  // s_pass
  unsigned long int s_pass;
  // s_fetch
  unsigned long int s_fetch;
  // s_synth
  unsigned long int s_synth;
  // s_req_hdrbytes
  unsigned long int s_req_hdrbytes;
  // s_req_bodybytes
  unsigned long int s_req_bodybytes;
  // s_resp_hdrbytes
  unsigned long int s_resp_hdrbytes;
  // s_resp_bodybytes
  unsigned long int s_resp_bodybytes;
  // s_pipe_hdrbytes
  unsigned long int s_pipe_hdrbytes;
  // s_pipe_in
  unsigned long int s_pipe_in;
  // s_pipe_out
  unsigned long int s_pipe_out;
  // sess_closed
  unsigned long int sess_closed;
  // sess_pipeline
  unsigned long int sess_pipeline;
  // sess_readahead
  unsigned long int sess_readahead;
  // sess_herd
  unsigned long int sess_herd;
  // shm_records
  unsigned long int shm_records;
  // shm_writes
  unsigned long int shm_writes;
  // shm_flushes
  unsigned long int shm_flushes;
  // shm_cont
  unsigned long int shm_cont;
  // shm_cycles
  unsigned long int shm_cycles;
  // sms_nreq
  unsigned long int sms_nreq;
  // sms_nobj
  unsigned long int sms_nobj;
  // sms_nbytes
  unsigned long int sms_nbytes;
  // sms_balloc
  unsigned long int sms_balloc;
  // sms_bfree
  unsigned long int sms_bfree;
  // backend_req
  unsigned long int backend_req;
  // n_vcl
  unsigned long int n_vcl;
  // n_vcl_avail
  unsigned long int n_vcl_avail;
  // n_vcl_discard
  unsigned long int n_vcl_discard;
  // bans
  unsigned long int bans;
  // bans_completed
  unsigned long int bans_completed;
  // bans_obj
  unsigned long int bans_obj;
  // bans_req
  unsigned long int bans_req;
  // bans_added
  unsigned long int bans_added;
  // bans_deleted
  unsigned long int bans_deleted;
  // bans_tested
  unsigned long int bans_tested;
  // bans_obj_killed
  unsigned long int bans_obj_killed;
  // bans_lurker_tested
  unsigned long int bans_lurker_tested;
  // bans_tests_tested
  unsigned long int bans_tests_tested;
  // bans_lurker_tests_tested
  unsigned long int bans_lurker_tests_tested;
  // bans_lurker_obj_killed
  unsigned long int bans_lurker_obj_killed;
  // bans_dups
  unsigned long int bans_dups;
  // bans_lurker_contention
  unsigned long int bans_lurker_contention;
  // bans_persisted_bytes
  unsigned long int bans_persisted_bytes;
  // bans_persisted_fragmentation
  unsigned long int bans_persisted_fragmentation;
  // n_purges
  unsigned long int n_purges;
  // n_obj_purged
  unsigned long int n_obj_purged;
  // exp_mailed
  unsigned long int exp_mailed;
  // exp_received
  unsigned long int exp_received;
  // hcb_nolock
  unsigned long int hcb_nolock;
  // hcb_lock
  unsigned long int hcb_lock;
  // hcb_insert
  unsigned long int hcb_insert;
  // esi_errors
  unsigned long int esi_errors;
  // esi_warnings
  unsigned long int esi_warnings;
  // vmods
  unsigned long int vmods;
  // n_gzip
  unsigned long int n_gzip;
  // n_gunzip
  unsigned long int n_gunzip;
  // vsm_free
  unsigned long int vsm_free;
  // vsm_used
  unsigned long int vsm_used;
  // vsm_cooling
  unsigned long int vsm_cooling;
  // vsm_overflow
  unsigned long int vsm_overflow;
  // vsm_overflowed
  unsigned long int vsm_overflowed;
};

struct VSC_C_mempool
{
  // live
  unsigned long int live;
  // pool
  unsigned long int pool;
  // sz_wanted
  unsigned long int sz_wanted;
  // sz_needed
  unsigned long int sz_needed;
  // allocs
  unsigned long int allocs;
  // frees
  unsigned long int frees;
  // recycle
  unsigned long int recycle;
  // timeout
  unsigned long int timeout;
  // toosmall
  unsigned long int toosmall;
  // surplus
  unsigned long int surplus;
  // randry
  unsigned long int randry;
};

struct VSC_C_mgt
{
  // uptime
  unsigned long int uptime;
  // child_start
  unsigned long int child_start;
  // child_exit
  unsigned long int child_exit;
  // child_stop
  unsigned long int child_stop;
  // child_died
  unsigned long int child_died;
  // child_dump
  unsigned long int child_dump;
  // child_panic
  unsigned long int child_panic;
};

struct VSC_C_sma
{
  // c_req
  unsigned long int c_req;
  // c_fail
  unsigned long int c_fail;
  // c_bytes
  unsigned long int c_bytes;
  // c_freed
  unsigned long int c_freed;
  // g_alloc
  unsigned long int g_alloc;
  // g_bytes
  unsigned long int g_bytes;
  // g_space
  unsigned long int g_space;
};

struct VSC_C_smf
{
  // c_req
  unsigned long int c_req;
  // c_fail
  unsigned long int c_fail;
  // c_bytes
  unsigned long int c_bytes;
  // c_freed
  unsigned long int c_freed;
  // g_alloc
  unsigned long int g_alloc;
  // g_bytes
  unsigned long int g_bytes;
  // g_space
  unsigned long int g_space;
  // g_smf
  unsigned long int g_smf;
  // g_smf_frag
  unsigned long int g_smf_frag;
  // g_smf_large
  unsigned long int g_smf_large;
};

struct VSC_C_vbe
{
  // vcls
  unsigned long int vcls;
  // happy
  unsigned long int happy;
  // bereq_hdrbytes
  unsigned long int bereq_hdrbytes;
  // bereq_bodybytes
  unsigned long int bereq_bodybytes;
  // beresp_hdrbytes
  unsigned long int beresp_hdrbytes;
  // beresp_bodybytes
  unsigned long int beresp_bodybytes;
  // pipe_hdrbytes
  unsigned long int pipe_hdrbytes;
  // pipe_out
  unsigned long int pipe_out;
  // pipe_in
  unsigned long int pipe_in;
};

struct VSC_desc
{
  // name
  const char *name;
  // fmt
  const char *fmt;
  // flag
  signed int flag;
  // sdesc
  const char *sdesc;
  // ldesc
  const char *ldesc;
  // level
  struct VSC_level_desc *level;
};

struct VSC_level_desc
{
  // verbosity
  unsigned int verbosity;
  // label
  const char *label;
  // sdesc
  const char *sdesc;
  // ldesc
  const char *ldesc;
};

struct VSC_point
{
  // desc
  struct VSC_desc *desc;
  // ptr
  const volatile void *ptr;
  // section
  struct VSC_section *section;
};

struct VSC_section
{
  // type
  const char *type;
  // ident
  const char *ident;
  // desc
  struct VSC_type_desc *desc;
  // fantom
  struct VSM_fantom *fantom;
};

struct VSC_type_desc
{
  // label
  const char *label;
  // sdesc
  const char *sdesc;
  // ldesc
  const char *ldesc;
};

struct vtx_tree
{
  // rbh_root
  struct vtx_key *rbh_root;
};

struct chunkhead
{
  // vtqh_first
  struct chunk *vtqh_first;
  // vtqh_last
  struct chunk **vtqh_last;
};

struct VSLQ
{
  // magic
  unsigned int magic;
  // vsl
  struct VSL_data *vsl;
  // c
  struct VSL_cursor *c;
  // query
  struct vslq_query *query;
  // grouping
  enum VSL_grouping_e grouping;
  // tree
  struct vtx_tree tree;
  // ready
  struct anonymous$4 ready;
  // incomplete
  struct anonymous$4 incomplete;
  // n_outstanding
  unsigned int n_outstanding;
  // shmrefs
  struct chunkhead shmrefs;
  // cache
  struct anonymous$4 cache;
  // n_cache
  unsigned int n_cache;
  // raw
  struct anonymous$5 raw;
};

struct VSL_data
{
  // magic
  unsigned int magic;
  // diag
  struct vsb *diag;
  // flags
  unsigned int flags;
  // vbm_select
  struct vbitmap *vbm_select;
  // vbm_supress
  struct vbitmap *vbm_supress;
  // vslf_select
  struct anonymous$1 vslf_select;
  // vslf_suppress
  struct anonymous$1 vslf_suppress;
  // b_opt
  signed int b_opt;
  // c_opt
  signed int c_opt;
  // C_opt
  signed int C_opt;
  // L_opt
  signed int L_opt;
  // T_opt
  double T_opt;
  // v_opt
  signed int v_opt;
};

struct VSL_head
{
  // marker
  char marker[8l];
  // segments
  volatile signed long int segments[8l];
  // segment
  volatile unsigned int segment;
  // seq
  volatile unsigned int seq;
  // log
  unsigned int log[0l];
};

struct VSM_chunk
{
  // marker
  char marker[8l];
  // len
  signed long int len;
  // next
  signed long int next;
  // class
  char class[8l];
  // type
  char type[8l];
  // ident
  char ident[128l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct VSM_data
{
  // magic
  unsigned int magic;
  // diag
  struct vsb *diag;
  // name
  char *name;
  // fname
  char *fname;
  // N_opt
  signed int N_opt;
  // fstat
  struct stat fstat;
  // vsm_fd
  signed int vsm_fd;
  // head
  struct VSM_head *head;
  // b
  char *b;
  // e
  char *e;
  // age_ok
  unsigned long int age_ok;
  // t_ok
  double t_ok;
  // vsc
  struct vsc *vsc;
};

struct VSM_fantom
{
  // chunk
  struct VSM_chunk *chunk;
  // b
  void *b;
  // e
  void *e;
  // priv
  unsigned long int priv;
  // class
  char class[8l];
  // type
  char type[8l];
  // ident
  char ident[128l];
};

struct VSM_head
{
  // marker
  char marker[8l];
  // hdrsize
  signed long int hdrsize;
  // shm_size
  signed long int shm_size;
  // first
  signed long int first;
  // alloc_seq
  unsigned int alloc_seq;
  // age
  unsigned long int age;
};

struct VUT
{
  // progname
  const char *progname;
  // name
  char *name;
  // d_opt
  signed int d_opt;
  // D_opt
  signed int D_opt;
  // g_arg
  signed int g_arg;
  // k_arg
  signed int k_arg;
  // P_arg
  char *P_arg;
  // q_arg
  char *q_arg;
  // r_arg
  char *r_arg;
  // vsl
  struct VSL_data *vsl;
  // vsm
  struct VSM_data *vsm;
  // vslq
  struct VSLQ *vslq;
  // pfh
  struct vpf_fh *pfh;
  // sighup
  signed int sighup;
  // sigint
  signed int sigint;
  // sigusr1
  signed int sigusr1;
  // idle_f
  signed int (*idle_f)(void);
  // sighup_f
  signed int (*sighup_f)(void);
  // dispatch_f
  signed int (*dispatch_f)(struct VSL_data *, struct VSL_transaction * const *, void *);
  // dispatch_priv
  void *dispatch_priv;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct pdat
{
  // _pad_y
  signed short int _pad_y;
  // _pad_x
  signed short int _pad_x;
  // _pad_top
  signed short int _pad_top;
  // _pad_left
  signed short int _pad_left;
  // _pad_bottom
  signed short int _pad_bottom;
  // _pad_right
  signed short int _pad_right;
};

struct _win_st
{
  // _cury
  signed short int _cury;
  // _curx
  signed short int _curx;
  // _maxy
  signed short int _maxy;
  // _maxx
  signed short int _maxx;
  // _begy
  signed short int _begy;
  // _begx
  signed short int _begx;
  // _flags
  signed short int _flags;
  // _attrs
  unsigned long int _attrs;
  // _bkgd
  unsigned long int _bkgd;
  // _notimeout
  _Bool _notimeout;
  // _clear
  _Bool _clear;
  // _leaveok
  _Bool _leaveok;
  // _scroll
  _Bool _scroll;
  // _idlok
  _Bool _idlok;
  // _idcok
  _Bool _idcok;
  // _immed
  _Bool _immed;
  // _sync
  _Bool _sync;
  // _use_keypad
  _Bool _use_keypad;
  // _delay
  signed int _delay;
  // _line
  struct ldat *_line;
  // _regtop
  signed short int _regtop;
  // _regbottom
  signed short int _regbottom;
  // _parx
  signed int _parx;
  // _pary
  signed int _pary;
  // _parent
  struct _win_st *_parent;
  // _pad
  struct pdat _pad;
  // _yoffset
  signed short int _yoffset;
  // _bkgrnd
  struct anonymous _bkgrnd;
};

struct chunk
{
  // magic
  unsigned int magic;
  // type
  enum chunk_t type;
  // $anon0
  union anonymous$21 $anon0;
  // len
  unsigned long int len;
  // vtx
  struct vtx *vtx;
  // list
  struct anonymous$22 list;
};

struct cli
{
  // magic
  unsigned int magic;
  // sb
  struct vsb *sb;
  // result
  enum VCLI_status_e result;
  // cmd
  char *cmd;
  // auth
  unsigned int auth;
  // challenge
  char challenge[34l];
  // ident
  char *ident;
  // vlu
  struct vlu *vlu;
  // cls
  struct VCLS *cls;
  // limit
  volatile unsigned int *limit;
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct membit
{
  // list
  struct anonymous$13 list;
  // ptr
  void *ptr;
};

struct pcre_extra
{
  // flags
  unsigned long int flags;
  // study_data
  void *study_data;
  // match_limit
  unsigned long int match_limit;
  // callout_data
  void *callout_data;
  // tables
  const unsigned char *tables;
  // match_limit_recursion
  unsigned long int match_limit_recursion;
  // mark
  unsigned char **mark;
  // executable_jit
  void *executable_jit;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sha256test
{
  // input
  const char *input;
  // output
  const unsigned char output[32l];
};

struct synth
{
  // magic
  unsigned int magic;
  // list
  struct anonymous$20 list;
  // offset
  unsigned long int offset;
  // data
  unsigned int data[18l];
};

struct synthhead
{
  // vtqh_first
  struct synth *vtqh_first;
  // vtqh_last
  struct synth **vtqh_last;
};

struct t_key
{
  // rbh_root
  struct top *rbh_root;
};

struct t_order
{
  // rbh_root
  struct top *rbh_root;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct token
{
  // tok
  unsigned int tok;
  // b
  const char *b;
  // e
  const char *e;
  // list
  struct anonymous$14 list;
  // cnt
  unsigned int cnt;
  // dec
  char *dec;
};

struct top
{
  // tag
  unsigned char tag;
  // rec_data
  const char *rec_data;
  // rec_buf
  char *rec_buf;
  // clen
  signed int clen;
  // hash
  unsigned int hash;
  // e_order
  struct anonymous$3 e_order;
  // e_key
  struct anonymous$3 e_key;
  // count
  double count;
};

struct vbitmap
{
  // bits
  unsigned int *bits;
  // nbits
  unsigned int nbits;
};

struct vex
{
  // magic
  unsigned int magic;
  // tok
  unsigned int tok;
  // options
  unsigned int options;
  // a
  struct vex *a;
  // b
  struct vex *b;
  // lhs
  struct vex_lhs *lhs;
  // rhs
  struct vex_rhs *rhs;
};

struct vex_lhs
{
  // magic
  unsigned int magic;
  // tags
  struct vbitmap *tags;
  // prefix
  char *prefix;
  // prefixlen
  signed int prefixlen;
  // field
  signed int field;
  // level
  signed int level;
  // level_pm
  signed int level_pm;
};

struct vex_rhs
{
  // magic
  unsigned int magic;
  // type
  enum vex_rhs_e type;
  // val_int
  signed long long int val_int;
  // val_float
  double val_float;
  // val_string
  char *val_string;
  // val_stringlen
  unsigned long int val_stringlen;
  // val_regex
  struct vre *val_regex;
};

struct vopt_list
{
  // option
  const char *option;
  // synopsis
  const char *synopsis;
  // desc
  const char *desc;
  // ldesc
  const char *ldesc;
};

struct vpf_fh
{
  // pf_fd
  signed int pf_fd;
  // pf_path
  char pf_path[4097l];
  // pf_dev
  unsigned long int pf_dev;
  // pf_ino
  unsigned long int pf_ino;
};

struct vre
{
  // magic
  unsigned int magic;
  // re
  struct real_pcre *re;
  // re_extra
  struct pcre_extra *re_extra;
  // my_extra
  signed int my_extra;
};

struct vre_limits
{
  // match
  unsigned int match;
  // match_recursion
  unsigned int match_recursion;
};

struct vsb
{
  // magic
  unsigned int magic;
  // s_buf
  char *s_buf;
  // s_error
  signed int s_error;
  // s_size
  signed long int s_size;
  // s_len
  signed long int s_len;
  // s_flags
  signed int s_flags;
};

struct vsc
{
  // magic
  unsigned int magic;
  // vf_list
  struct anonymous$6 vf_list;
  // pt_list
  struct anonymous$7 pt_list;
  // sf_list
  struct anonymous$8 sf_list;
  // iter_fantom
  struct VSM_fantom iter_fantom;
};

struct vsc_pt
{
  // magic
  unsigned int magic;
  // list
  struct anonymous$10 list;
  // point
  struct VSC_point point;
};

struct vsc_sf
{
  // magic
  unsigned int magic;
  // list
  struct anonymous$11 list;
  // flags
  signed int flags;
  // type
  char *type;
  // ident
  char *ident;
  // name
  char *name;
};

struct vsc_vf
{
  // magic
  unsigned int magic;
  // list
  struct anonymous$9 list;
  // fantom
  struct VSM_fantom fantom;
  // section
  struct VSC_section section;
  // order
  signed int order;
};

struct vslc_file
{
  // magic
  unsigned int magic;
  // cursor
  struct VSL_cursor cursor;
  // error
  signed int error;
  // fd
  signed int fd;
  // close_fd
  signed int close_fd;
  // buflen
  signed long int buflen;
  // buf
  unsigned int *buf;
};

struct vslc_tbl
{
  // magic
  unsigned int magic;
  // delete
  void (*delete)(struct VSL_cursor *);
  // next
  signed int (*next)(struct VSL_cursor *);
  // reset
  signed int (*reset)(struct VSL_cursor *);
  // check
  signed int (*check)(struct VSL_cursor *, struct VSLC_ptr *);
};

struct vslc_vsm
{
  // magic
  unsigned int magic;
  // cursor
  struct VSL_cursor cursor;
  // options
  unsigned int options;
  // vsm
  struct VSM_data *vsm;
  // vf
  struct VSM_fantom vf;
  // head
  struct VSL_head *head;
  // end
  const unsigned int *end;
  // segsize
  signed long int segsize;
  // next
  struct VSLC_ptr next;
};

struct vslc_vtx
{
  // magic
  unsigned int magic;
  // cursor
  struct VSL_cursor cursor;
  // vtx
  struct vtx *vtx;
  // synth
  struct synth *synth;
  // chunk
  struct chunk *chunk;
  // chunkstart
  unsigned long int chunkstart;
  // offset
  unsigned long int offset;
};

struct vslf
{
  // magic
  unsigned int magic;
  // list
  struct anonymous$2 list;
  // tags
  struct vbitmap *tags;
  // vre
  struct vre *vre;
};

struct vslq_query
{
  // magic
  unsigned int magic;
  // vex
  struct vex *vex;
};

struct vtx_key
{
  // vxid
  unsigned int vxid;
  // entry
  struct anonymous$17 entry;
};

struct vtx
{
  // key
  struct vtx_key key;
  // magic
  unsigned int magic;
  // list_child
  struct anonymous$18 list_child;
  // list_vtx
  struct anonymous$18 list_vtx;
  // t_start
  double t_start;
  // flags
  unsigned int flags;
  // type
  enum VSL_transaction_e type;
  // reason
  enum VSL_reason_e reason;
  // parent
  struct vtx *parent;
  // child
  struct anonymous$4 child;
  // n_child
  unsigned int n_child;
  // n_childready
  unsigned int n_childready;
  // n_descend
  unsigned int n_descend;
  // synth
  struct anonymous$19 synth;
  // shmchunks
  struct chunk shmchunks[3l];
  // shmchunks_free
  struct chunkhead shmchunks_free;
  // chunks
  struct chunkhead chunks;
  // len
  unsigned long int len;
  // c
  struct vslc_vtx c;
};

struct vxp
{
  // magic
  unsigned int magic;
  // src
  const char *src;
  // b
  const char *b;
  // e
  const char *e;
  // tokens
  struct anonymous$15 tokens;
  // membits
  struct anonymous$16 membits;
  // t
  struct token *t;
  // vex_options
  unsigned int vex_options;
  // vre_options
  signed int vre_options;
  // sb
  struct vsb *sb;
  // err
  signed int err;
};


// COLS
// file /usr/include/curses.h line 1399
extern signed int COLS;
// LINES
// file /usr/include/curses.h line 1401
extern signed int LINES;
// PAD
// file ../libvarnish/vsha256.c line 206
static const unsigned char PAD[64l] = { (const unsigned char)0x80, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0 };
// VAS_Fail
// file ../../lib/libvarnish/vas.c line 70
void (*VAS_Fail)(const char *, const char *, signed int, const char *, signed int, enum vas_e);
// VAS_Fail
// file ../../lib/libvarnish/vas.c line 70
void (*VAS_Fail)(const char *, const char *, signed int, const char *, signed int, enum vas_e) = VAS_Fail_default;
// VCS_version
// file ../../lib/libvarnish/version.c line 39
const char *VCS_version = "varnish-4.0.3 revision b8c4a34";
// VRE_CASELESS
// file ../libvarnish/vre.c line 63
const unsigned int VRE_CASELESS = (const unsigned int)0x00000001;
// VRE_NOTEMPTY
// file ../libvarnish/vre.c line 64
const unsigned int VRE_NOTEMPTY = (const unsigned int)0x00000400;
// VSC_desc_lck
// file ../../include/tbl/vsc_all.h line 37
struct VSC_desc VSC_desc_lck[3l];
// VSC_level_desc_debug
// file ../../include/tbl/vsc_levels.h line 43
struct VSC_level_desc VSC_level_desc_debug = { .verbosity=(unsigned int)2, .label="DEBUG", .sdesc="Debug counters",
    .ldesc="Counters giving Varnish internals debug information" };
// VSC_desc_lck
// file ../../include/tbl/vsc_all.h line 37
struct VSC_desc VSC_desc_lck[3l] = { { .name="creat", .fmt="uint64_t", .flag=97, .sdesc="Created locks",
    .ldesc="", .level=&VSC_level_desc_debug },
    { .name="destroy", .fmt="uint64_t", .flag=97, .sdesc="Destroyed locks",
    .ldesc="", .level=&VSC_level_desc_debug },
    { .name="locks", .fmt="uint64_t", .flag=97, .sdesc="Lock Operations",
    .ldesc="", .level=&VSC_level_desc_debug } };
// VSC_desc_main
// file ../../include/tbl/vsc_all.h line 43
struct VSC_desc VSC_desc_main[119l];
// VSC_level_desc_diag
// file ../../include/tbl/vsc_levels.h line 41
struct VSC_level_desc VSC_level_desc_diag = { .verbosity=(unsigned int)1, .label="DIAG", .sdesc="Diagnostic counters",
    .ldesc="Counters giving diagnostic information" };
// VSC_level_desc_info
// file ../../include/tbl/vsc_levels.h line 39
struct VSC_level_desc VSC_level_desc_info = { .verbosity=(unsigned int)0, .label="INFO", .sdesc="Informational counters",
    .ldesc="Counters giving runtime information" };
// VSC_desc_main
// file ../../include/tbl/vsc_all.h line 43
struct VSC_desc VSC_desc_main[119l] = { { .name="uptime", .fmt="uint64_t", .flag=97, .sdesc="Child process uptime",
    .ldesc="How long the child process has been running.", .level=&VSC_level_desc_info },
    { .name="sess_conn", .fmt="uint64_t", .flag=99, .sdesc="Sessions accepted",
    .ldesc="Count of sessions successfully accepted", .level=&VSC_level_desc_info },
    { .name="sess_drop", .fmt="uint64_t", .flag=99, .sdesc="Sessions dropped",
    .ldesc="Count of sessions silently dropped due to lack of worker thread.", .level=&VSC_level_desc_info },
    { .name="sess_fail", .fmt="uint64_t", .flag=99, .sdesc="Session accept failures",
    .ldesc="Count of failures to accept TCP connection.  Either the client changed its mind, or the kernel ran out of some resource like file descriptors.", .level=&VSC_level_desc_info },
    { .name="sess_pipe_overflow", .fmt="uint64_t", .flag=99,
    .sdesc="Session pipe overflow", .ldesc="Count of sessions dropped due to the session pipe overflowing.",
    .level=&VSC_level_desc_info },
    { .name="client_req_400", .fmt="uint64_t", .flag=97,
    .sdesc="Client requests received, subject to 400 errors", .ldesc="400 means we couldn't make sense of the request, it was malformed in some drastic way.",
    .level=&VSC_level_desc_info },
    { .name="client_req_411", .fmt="uint64_t", .flag=97,
    .sdesc="Client requests received, subject to 411 errors", .ldesc="411 means the client did not send a Content-Lenght for the req.body.",
    .level=&VSC_level_desc_info },
    { .name="client_req_413", .fmt="uint64_t", .flag=97,
    .sdesc="Client requests received, subject to 413 errors", .ldesc="413 means that HTTP headers exceeded length or count limits.",
    .level=&VSC_level_desc_info },
    { .name="client_req_417", .fmt="uint64_t", .flag=97,
    .sdesc="Client requests received, subject to 417 errors", .ldesc="417 means that something went wrong with an Expect: header.",
    .level=&VSC_level_desc_info },
    { .name="client_req", .fmt="uint64_t", .flag=97, .sdesc="Good client requests received",
    .ldesc="The count of parseable client requests seen.",
    .level=&VSC_level_desc_info },
    { .name="cache_hit", .fmt="uint64_t", .flag=97, .sdesc="Cache hits",
    .ldesc="Count of cache hits.   A cache hit indicates that an object has been delivered to a  client without fetching it from a backend server.", .level=&VSC_level_desc_info },
    { .name="cache_hitpass", .fmt="uint64_t", .flag=97,
    .sdesc="Cache hits for pass", .ldesc="Count of hits for pass  A cache hit for pass indicates that Varnish is going to  pass the request to the backend and this decision has been   cached in it self. This counts how many times the cached   decision is being used.",
    .level=&VSC_level_desc_info },
    { .name="cache_miss", .fmt="uint64_t", .flag=97, .sdesc="Cache misses",
    .ldesc="Count of misses  A cache miss indicates the object was fetched from the  backend before delivering it to the backend.", .level=&VSC_level_desc_info },
    { .name="backend_conn", .fmt="uint64_t", .flag=97,
    .sdesc="Backend conn. success", .ldesc="How many backend connections have successfully been established.",
    .level=&VSC_level_desc_info },
    { .name="backend_unhealthy", .fmt="uint64_t", .flag=97,
    .sdesc="Backend conn. not attempted", .ldesc="",
    .level=&VSC_level_desc_info },
    { .name="backend_busy", .fmt="uint64_t", .flag=97,
    .sdesc="Backend conn. too many", .ldesc="",
    .level=&VSC_level_desc_info },
    { .name="backend_fail", .fmt="uint64_t", .flag=97,
    .sdesc="Backend conn. failures", .ldesc="",
    .level=&VSC_level_desc_info },
    { .name="backend_reuse", .fmt="uint64_t", .flag=97,
    .sdesc="Backend conn. reuses", .ldesc="Count of backend connection reuses  This counter is increased whenever we reuse a recycled connection.",
    .level=&VSC_level_desc_info },
    { .name="backend_toolate", .fmt="uint64_t", .flag=97,
    .sdesc="Backend conn. was closed", .ldesc="",
    .level=&VSC_level_desc_info },
    { .name="backend_recycle", .fmt="uint64_t", .flag=97,
    .sdesc="Backend conn. recycles", .ldesc="Count of backend connection recycles  This counter is increased whenever we have a keep-alive  connection that is put back into the pool of connections.  It has not yet been used, but it might be, unless the backend  closes it.",
    .level=&VSC_level_desc_info },
    { .name="backend_retry", .fmt="uint64_t", .flag=97,
    .sdesc="Backend conn. retry", .ldesc="",
    .level=&VSC_level_desc_info },
    { .name="fetch_head", .fmt="uint64_t", .flag=99, .sdesc="Fetch no body (HEAD)",
    .ldesc="beresp with no body because the request is HEAD.", .level=&VSC_level_desc_info },
    { .name="fetch_length", .fmt="uint64_t", .flag=99,
    .sdesc="Fetch with Length", .ldesc="beresp with Content-Length.",
    .level=&VSC_level_desc_info },
    { .name="fetch_chunked", .fmt="uint64_t", .flag=99,
    .sdesc="Fetch chunked", .ldesc="beresp with Chunked.", .level=&VSC_level_desc_info },
    { .name="fetch_eof", .fmt="uint64_t", .flag=99, .sdesc="Fetch EOF",
    .ldesc="beresp with EOF from lack of other info.", .level=&VSC_level_desc_info },
    { .name="fetch_bad", .fmt="uint64_t", .flag=99, .sdesc="Fetch bad T-E",
    .ldesc="beresp failed due to unknown Transfer-Encoding.", .level=&VSC_level_desc_info },
    { .name="fetch_close", .fmt="uint64_t", .flag=99, .sdesc="Fetch wanted close",
    .ldesc="beresp with EOF due to Connection: Close.", .level=&VSC_level_desc_info },
    { .name="fetch_oldhttp", .fmt="uint64_t", .flag=99,
    .sdesc="Fetch pre HTTP/1.1 closed", .ldesc="beresp with EOF due to HTTP < 1.1",
    .level=&VSC_level_desc_info },
    { .name="fetch_zero", .fmt="uint64_t", .flag=99, .sdesc="Fetch zero len body",
    .ldesc="beresp with EOF due to keep-live but neither Chunked or Len.", .level=&VSC_level_desc_info },
    { .name="fetch_1xx", .fmt="uint64_t", .flag=99, .sdesc="Fetch no body (1xx)",
    .ldesc="beresp with no body because of 1XX response.", .level=&VSC_level_desc_info },
    { .name="fetch_204", .fmt="uint64_t", .flag=99, .sdesc="Fetch no body (204)",
    .ldesc="beresp with no body because of 204 response.", .level=&VSC_level_desc_info },
    { .name="fetch_304", .fmt="uint64_t", .flag=99, .sdesc="Fetch no body (304)",
    .ldesc="beresp with no body because of 304 response.", .level=&VSC_level_desc_info },
    { .name="fetch_failed", .fmt="uint64_t", .flag=99,
    .sdesc="Fetch failed (all causes)", .ldesc="beresp fetch failed.",
    .level=&VSC_level_desc_info },
    { .name="fetch_no_thread", .fmt="uint64_t", .flag=99,
    .sdesc="Fetch failed (no thread)", .ldesc="beresp fetch failed, no thread available.",
    .level=&VSC_level_desc_info },
    { .name="pools", .fmt="uint64_t", .flag=103, .sdesc="Number of thread pools",
    .ldesc="Number of thread pools.  See also parameter thread_pools.  NB: Presently pools cannot be removed once created.", .level=&VSC_level_desc_info },
    { .name="threads", .fmt="uint64_t", .flag=103, .sdesc="Total number of threads",
    .ldesc="Number of threads in all pools.  See also parameters thread_pools, thread_pool_min and thread_pool_max.", .level=&VSC_level_desc_info },
    { .name="threads_limited", .fmt="uint64_t", .flag=99,
    .sdesc="Threads hit max", .ldesc="Number of times more threads were needed, but limit was reached in a thread pool.  See also parameter thread_pool_max.", .level=&VSC_level_desc_info },
    { .name="threads_created", .fmt="uint64_t", .flag=99,
    .sdesc="Threads created", .ldesc="Total number of threads created in all pools.", .level=&VSC_level_desc_info },
    { .name="threads_destroyed", .fmt="uint64_t", .flag=99,
    .sdesc="Threads destroyed", .ldesc="Total number of threads destroyed in all pools.",
    .level=&VSC_level_desc_info },
    { .name="threads_failed", .fmt="uint64_t", .flag=99,
    .sdesc="Thread creation failed", .ldesc="Number of times creating a thread failed.  See VSL::Debug for diagnostics.  See also parameter thread_fail_delay.",
    .level=&VSC_level_desc_info },
    { .name="thread_queue_len", .fmt="uint64_t", .flag=103,
    .sdesc="Length of session queue", .ldesc="Length of session queue waiting for threads.  NB: Only updates once per second.  See also parameter queue_max.",
    .level=&VSC_level_desc_info },
    { .name="busy_sleep", .fmt="uint64_t", .flag=99, .sdesc="Number of requests sent to sleep on busy objhdr",
    .ldesc="Number of requests sent to sleep without a worker thread because they found a busy object.",
    .level=&VSC_level_desc_info },
    { .name="busy_wakeup", .fmt="uint64_t", .flag=99, .sdesc="Number of requests woken after sleep on busy objhdr",
    .ldesc="Number of requests taken of the busy object sleep list and and rescheduled.",
    .level=&VSC_level_desc_info },
    { .name="sess_queued", .fmt="uint64_t", .flag=99, .sdesc="Sessions queued for thread",
    .ldesc="Number of times session was queued waiting for a thread.  See also parameter queue_max.",
    .level=&VSC_level_desc_info },
    { .name="sess_dropped", .fmt="uint64_t", .flag=99,
    .sdesc="Sessions dropped for thread", .ldesc="Number of times session was dropped because the queue were too long already. See also parameter queue_max.",
    .level=&VSC_level_desc_info },
    { .name="n_object", .fmt="uint64_t", .flag=105, .sdesc="object structs made",
    .ldesc="Number of object structs made", .level=&VSC_level_desc_info },
    { .name="n_vampireobject", .fmt="uint64_t", .flag=105,
    .sdesc="unresurrected objects", .ldesc="Number of unresurrected objects",
    .level=&VSC_level_desc_diag },
    { .name="n_objectcore", .fmt="uint64_t", .flag=105,
    .sdesc="objectcore structs made", .ldesc="Number of objectcore structs made",
    .level=&VSC_level_desc_info },
    { .name="n_objecthead", .fmt="uint64_t", .flag=105,
    .sdesc="objecthead structs made", .ldesc="Number of objecthead structs made",
    .level=&VSC_level_desc_info },
    { .name="n_waitinglist", .fmt="uint64_t", .flag=105,
    .sdesc="waitinglist structs made", .ldesc="Number of waitinglist structs made",
    .level=&VSC_level_desc_debug },
    { .name="n_backend", .fmt="uint64_t", .flag=105, .sdesc="Number of backends",
    .ldesc="Number of backends known to us.", .level=&VSC_level_desc_info },
    { .name="n_expired", .fmt="uint64_t", .flag=105, .sdesc="Number of expired objects",
    .ldesc="Number of objects that expired from cache because of old age.", .level=&VSC_level_desc_info },
    { .name="n_lru_nuked", .fmt="uint64_t", .flag=105, .sdesc="Number of LRU nuked objects",
    .ldesc="How many objects have been forcefully evicted from storage to make room for a new object.",
    .level=&VSC_level_desc_info },
    { .name="n_lru_moved", .fmt="uint64_t", .flag=105, .sdesc="Number of LRU moved objects",
    .ldesc="Number of move operations done on the LRU list.",
    .level=&VSC_level_desc_diag },
    { .name="losthdr", .fmt="uint64_t", .flag=97, .sdesc="HTTP header overflows",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="s_sess", .fmt="uint64_t", .flag=97, .sdesc="Total sessions seen",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="s_req", .fmt="uint64_t", .flag=97, .sdesc="Total requests seen",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="s_pipe", .fmt="uint64_t", .flag=97, .sdesc="Total pipe sessions seen",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="s_pass", .fmt="uint64_t", .flag=97, .sdesc="Total pass-ed requests seen",
    .ldesc="",
    .level=&VSC_level_desc_info },
    { .name="s_fetch", .fmt="uint64_t", .flag=97, .sdesc="Total backend fetches initiated",
    .ldesc="",
    .level=&VSC_level_desc_info },
    { .name="s_synth", .fmt="uint64_t", .flag=97, .sdesc="Total synthethic responses made",
    .ldesc="",
    .level=&VSC_level_desc_info },
    { .name="s_req_hdrbytes", .fmt="uint64_t", .flag=97,
    .sdesc="Request header bytes", .ldesc="Total request header bytes received",
    .level=&VSC_level_desc_info },
    { .name="s_req_bodybytes", .fmt="uint64_t", .flag=97,
    .sdesc="Request body bytes", .ldesc="Total request body bytes received",
    .level=&VSC_level_desc_info },
    { .name="s_resp_hdrbytes", .fmt="uint64_t", .flag=97,
    .sdesc="Response header bytes", .ldesc="Total response header bytes transmitted",
    .level=&VSC_level_desc_info },
    { .name="s_resp_bodybytes", .fmt="uint64_t", .flag=97,
    .sdesc="Response body bytes", .ldesc="Total response body bytes transmitted",
    .level=&VSC_level_desc_info },
    { .name="s_pipe_hdrbytes", .fmt="uint64_t", .flag=97,
    .sdesc="Pipe request header bytes", .ldesc="Total request bytes received for piped sessions",
    .level=&VSC_level_desc_info },
    { .name="s_pipe_in", .fmt="uint64_t", .flag=97, .sdesc="Piped bytes from client",
    .ldesc="Total number of bytes forwarded from clients in pipe sessions", .level=&VSC_level_desc_info },
    { .name="s_pipe_out", .fmt="uint64_t", .flag=97, .sdesc="Piped bytes to client",
    .ldesc="Total number of bytes forwarded to clients in pipe sessions", .level=&VSC_level_desc_info },
    { .name="sess_closed", .fmt="uint64_t", .flag=97, .sdesc="Session Closed",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="sess_pipeline", .fmt="uint64_t", .flag=97,
    .sdesc="Session Pipeline", .ldesc="",
    .level=&VSC_level_desc_info },
    { .name="sess_readahead", .fmt="uint64_t", .flag=97,
    .sdesc="Session Read Ahead", .ldesc="",
    .level=&VSC_level_desc_info },
    { .name="sess_herd", .fmt="uint64_t", .flag=97, .sdesc="Session herd",
    .ldesc="", .level=&VSC_level_desc_diag },
    { .name="shm_records", .fmt="uint64_t", .flag=97, .sdesc="SHM records",
    .ldesc="", .level=&VSC_level_desc_diag },
    { .name="shm_writes", .fmt="uint64_t", .flag=97, .sdesc="SHM writes",
    .ldesc="", .level=&VSC_level_desc_diag },
    { .name="shm_flushes", .fmt="uint64_t", .flag=97, .sdesc="SHM flushes due to overflow",
    .ldesc="",
    .level=&VSC_level_desc_diag },
    { .name="shm_cont", .fmt="uint64_t", .flag=97, .sdesc="SHM MTX contention",
    .ldesc="", .level=&VSC_level_desc_diag },
    { .name="shm_cycles", .fmt="uint64_t", .flag=97, .sdesc="SHM cycles through buffer",
    .ldesc="", .level=&VSC_level_desc_diag },
    { .name="sms_nreq", .fmt="uint64_t", .flag=97, .sdesc="SMS allocator requests",
    .ldesc="", .level=&VSC_level_desc_diag },
    { .name="sms_nobj", .fmt="uint64_t", .flag=105, .sdesc="SMS outstanding allocations",
    .ldesc="",
    .level=&VSC_level_desc_diag },
    { .name="sms_nbytes", .fmt="uint64_t", .flag=105, .sdesc="SMS outstanding bytes",
    .ldesc="", .level=&VSC_level_desc_diag },
    { .name="sms_balloc", .fmt="uint64_t", .flag=105, .sdesc="SMS bytes allocated",
    .ldesc="", .level=&VSC_level_desc_diag },
    { .name="sms_bfree", .fmt="uint64_t", .flag=105, .sdesc="SMS bytes freed",
    .ldesc="", .level=&VSC_level_desc_diag },
    { .name="backend_req", .fmt="uint64_t", .flag=97, .sdesc="Backend requests made",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="n_vcl", .fmt="uint64_t", .flag=97, .sdesc="Number of loaded VCLs in total",
    .ldesc="",
    .level=&VSC_level_desc_info },
    { .name="n_vcl_avail", .fmt="uint64_t", .flag=97, .sdesc="Number of VCLs available",
    .ldesc="", .level=&VSC_level_desc_diag },
    { .name="n_vcl_discard", .fmt="uint64_t", .flag=97,
    .sdesc="Number of discarded VCLs", .ldesc="",
    .level=&VSC_level_desc_diag },
    { .name="bans", .fmt="uint64_t", .flag=103, .sdesc="Count of bans",
    .ldesc="Number of all bans in system, including bans superseded by newer bans and bans already checked by the ban-lurker.", .level=&VSC_level_desc_info },
    { .name="bans_completed", .fmt="uint64_t", .flag=103,
    .sdesc="Number of bans marked 'completed'", .ldesc="Number of bans which are no longer active, either because they got checked by the ban-lurker or superseded by newer identical bans.",
    .level=&VSC_level_desc_diag },
    { .name="bans_obj", .fmt="uint64_t", .flag=103, .sdesc="Number of bans using obj.*",
    .ldesc="Number of bans which use obj.* variables.  These bans can possibly be washed by the ban-lurker.",
    .level=&VSC_level_desc_diag },
    { .name="bans_req", .fmt="uint64_t", .flag=103, .sdesc="Number of bans using req.*",
    .ldesc="Number of bans which use req.* variables.  These bans can not be washed by the ban-lurker.",
    .level=&VSC_level_desc_diag },
    { .name="bans_added", .fmt="uint64_t", .flag=99, .sdesc="Bans added",
    .ldesc="Counter of bans added to ban list.", .level=&VSC_level_desc_diag },
    { .name="bans_deleted", .fmt="uint64_t", .flag=99,
    .sdesc="Bans deleted", .ldesc="Counter of bans deleted from ban list.", .level=&VSC_level_desc_diag },
    { .name="bans_tested", .fmt="uint64_t", .flag=99, .sdesc="Bans tested against objects (lookup)",
    .ldesc="Count of how many bans and objects have been tested against each other during hash lookup.",
    .level=&VSC_level_desc_diag },
    { .name="bans_obj_killed", .fmt="uint64_t", .flag=99,
    .sdesc="Objects killed by bans (lookup)", .ldesc="Number of objects killed by bans during object lookup.",
    .level=&VSC_level_desc_diag },
    { .name="bans_lurker_tested", .fmt="uint64_t", .flag=99,
    .sdesc="Bans tested against objects (lurker)", .ldesc="Count of how many bans and objects have been tested against each other by the ban-lurker.",
    .level=&VSC_level_desc_diag },
    { .name="bans_tests_tested", .fmt="uint64_t", .flag=99,
    .sdesc="Ban tests tested against objects (lookup)", .ldesc="Count of how many tests and objects have been tested against each other during lookup.  'ban req.url == foo && req.http.host == bar' counts as one in 'bans_tested' and as two in 'bans_tests_tested'",
    .level=&VSC_level_desc_diag },
    { .name="bans_lurker_tests_tested", .fmt="uint64_t", .flag=99,
    .sdesc="Ban tests tested against objects (lurker)", .ldesc="Count of how many tests and objects have been tested against each other by the ban-lurker.  'ban req.url == foo && req.http.host == bar' counts as one in 'bans_tested' and as two in 'bans_tests_tested'",
    .level=&VSC_level_desc_diag },
    { .name="bans_lurker_obj_killed", .fmt="uint64_t", .flag=99,
    .sdesc="Objects killed by bans (lurker)", .ldesc="Number of objects killed by ban-lurker.",
    .level=&VSC_level_desc_diag },
    { .name="bans_dups", .fmt="uint64_t", .flag=99, .sdesc="Bans superseded by other bans",
    .ldesc="Count of bans replaced by later identical bans.",
    .level=&VSC_level_desc_diag },
    { .name="bans_lurker_contention", .fmt="uint64_t", .flag=99,
    .sdesc="Lurker gave way for lookup", .ldesc="Number of times the ban-lurker had to wait for lookups.",
    .level=&VSC_level_desc_diag },
    { .name="bans_persisted_bytes", .fmt="uint64_t", .flag=103,
    .sdesc="Bytes used by the persisted ban lists", .ldesc="Number of bytes used by the persisted ban lists.",
    .level=&VSC_level_desc_diag },
    { .name="bans_persisted_fragmentation", .fmt="uint64_t", .flag=103,
    .sdesc="Extra bytes in persisted ban lists due to fragmentation", .ldesc="Number of extra bytes accumulated through dropped and completed bans in the persistent ban lists.",
    .level=&VSC_level_desc_diag },
    { .name="n_purges", .fmt="uint64_t", .flag=105, .sdesc="Number of purge operations executed",
    .ldesc="",
    .level=&VSC_level_desc_info },
    { .name="n_obj_purged", .fmt="uint64_t", .flag=105,
    .sdesc="Number of purged objects", .ldesc="",
    .level=&VSC_level_desc_info },
    { .name="exp_mailed", .fmt="uint64_t", .flag=99, .sdesc="Number of objects mailed to expiry thread",
    .ldesc="Number of objects mailed to expiry thread for handling.",
    .level=&VSC_level_desc_diag },
    { .name="exp_received", .fmt="uint64_t", .flag=99,
    .sdesc="Number of objects received by expiry thread", .ldesc="Number of objects received by expiry thread for handling.",
    .level=&VSC_level_desc_diag },
    { .name="hcb_nolock", .fmt="uint64_t", .flag=97, .sdesc="HCB Lookups without lock",
    .ldesc="", .level=&VSC_level_desc_debug },
    { .name="hcb_lock", .fmt="uint64_t", .flag=97, .sdesc="HCB Lookups with lock",
    .ldesc="", .level=&VSC_level_desc_debug },
    { .name="hcb_insert", .fmt="uint64_t", .flag=97, .sdesc="HCB Inserts",
    .ldesc="", .level=&VSC_level_desc_debug },
    { .name="esi_errors", .fmt="uint64_t", .flag=97, .sdesc="ESI parse errors (unlock)",
    .ldesc="", .level=&VSC_level_desc_diag },
    { .name="esi_warnings", .fmt="uint64_t", .flag=97,
    .sdesc="ESI parse warnings (unlock)", .ldesc="",
    .level=&VSC_level_desc_diag },
    { .name="vmods", .fmt="uint64_t", .flag=105, .sdesc="Loaded VMODs",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="n_gzip", .fmt="uint64_t", .flag=97, .sdesc="Gzip operations",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="n_gunzip", .fmt="uint64_t", .flag=97, .sdesc="Gunzip operations",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="vsm_free", .fmt="uint64_t", .flag=103, .sdesc="Free VSM space",
    .ldesc="Number of bytes free in the shared memory used to communicate with tools like varnishstat, varnishlog etc.", .level=&VSC_level_desc_diag },
    { .name="vsm_used", .fmt="uint64_t", .flag=103, .sdesc="Used VSM space",
    .ldesc="Number of bytes used in the shared memory used to communicate with tools like varnishstat, varnishlog etc.", .level=&VSC_level_desc_diag },
    { .name="vsm_cooling", .fmt="uint64_t", .flag=103, .sdesc="Cooling VSM space",
    .ldesc="Number of bytes which will soon (max 1 minute) be freed in the shared memory used to communicate with tools like varnishstat, varnishlog etc.", .level=&VSC_level_desc_debug },
    { .name="vsm_overflow", .fmt="uint64_t", .flag=103,
    .sdesc="Overflow VSM space", .ldesc="Number of bytes which does not fit in the shared memory used to communicate with tools like varnishstat, varnishlog etc.",
    .level=&VSC_level_desc_diag },
    { .name="vsm_overflowed", .fmt="uint64_t", .flag=99,
    .sdesc="Overflowed VSM space", .ldesc="Total number of bytes which did not fit in the shared memory used to communicate with tools like varnishstat, varnishlog etc.",
    .level=&VSC_level_desc_diag } };
// VSC_desc_mempool
// file ../../include/tbl/vsc_all.h line 65
struct VSC_desc VSC_desc_mempool[11l];
// VSC_desc_mempool
// file ../../include/tbl/vsc_all.h line 65
struct VSC_desc VSC_desc_mempool[11l] = { { .name="live", .fmt="uint64_t", .flag=103, .sdesc="In use",
    .ldesc="", .level=&VSC_level_desc_debug },
    { .name="pool", .fmt="uint64_t", .flag=103, .sdesc="In Pool",
    .ldesc="", .level=&VSC_level_desc_debug },
    { .name="sz_wanted", .fmt="uint64_t", .flag=103, .sdesc="Size requested",
    .ldesc="", .level=&VSC_level_desc_debug },
    { .name="sz_needed", .fmt="uint64_t", .flag=103, .sdesc="Size allocated",
    .ldesc="", .level=&VSC_level_desc_debug },
    { .name="allocs", .fmt="uint64_t", .flag=99, .sdesc="Allocations",
    .ldesc="", .level=&VSC_level_desc_debug },
    { .name="frees", .fmt="uint64_t", .flag=99, .sdesc="Frees",
    .ldesc="", .level=&VSC_level_desc_debug },
    { .name="recycle", .fmt="uint64_t", .flag=99, .sdesc="Recycled from pool",
    .ldesc="", .level=&VSC_level_desc_debug },
    { .name="timeout", .fmt="uint64_t", .flag=99, .sdesc="Timed out from pool",
    .ldesc="", .level=&VSC_level_desc_debug },
    { .name="toosmall", .fmt="uint64_t", .flag=99, .sdesc="Too small to recycle",
    .ldesc="", .level=&VSC_level_desc_debug },
    { .name="surplus", .fmt="uint64_t", .flag=99, .sdesc="Too many for pool",
    .ldesc="", .level=&VSC_level_desc_debug },
    { .name="randry", .fmt="uint64_t", .flag=99, .sdesc="Pool ran dry",
    .ldesc="", .level=&VSC_level_desc_debug } };
// VSC_desc_mgt
// file ../../include/tbl/vsc_all.h line 31
struct VSC_desc VSC_desc_mgt[7l];
// VSC_desc_mgt
// file ../../include/tbl/vsc_all.h line 31
struct VSC_desc VSC_desc_mgt[7l] = { { .name="uptime", .fmt="uint64_t", .flag=99, .sdesc="Management process uptime",
    .ldesc="Uptime in seconds of the management process", .level=&VSC_level_desc_info },
    { .name="child_start", .fmt="uint64_t", .flag=99, .sdesc="Child process started",
    .ldesc="Number of times the child process has been started", .level=&VSC_level_desc_diag },
    { .name="child_exit", .fmt="uint64_t", .flag=99, .sdesc="Child process normal exit",
    .ldesc="Number of times the child process has been cleanly stopped", .level=&VSC_level_desc_diag },
    { .name="child_stop", .fmt="uint64_t", .flag=99, .sdesc="Child process unexpected exit",
    .ldesc="Number of times the child process has exited with an unexpected return code",
    .level=&VSC_level_desc_diag },
    { .name="child_died", .fmt="uint64_t", .flag=99, .sdesc="Child process died (signal)",
    .ldesc="Number of times the child process has died due to signals",
    .level=&VSC_level_desc_diag },
    { .name="child_dump", .fmt="uint64_t", .flag=99, .sdesc="Child process core dumped",
    .ldesc="Number of times the child process has produced core dumps", .level=&VSC_level_desc_diag },
    { .name="child_panic", .fmt="uint64_t", .flag=99, .sdesc="Child process panic",
    .ldesc="Number of times the management process has caught a child panic", .level=&VSC_level_desc_diag } };
// VSC_desc_sma
// file ../../include/tbl/vsc_all.h line 47
struct VSC_desc VSC_desc_sma[7l];
// VSC_desc_sma
// file ../../include/tbl/vsc_all.h line 47
struct VSC_desc VSC_desc_sma[7l] = { { .name="c_req", .fmt="uint64_t", .flag=97, .sdesc="Allocator requests",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="c_fail", .fmt="uint64_t", .flag=97, .sdesc="Allocator failures",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="c_bytes", .fmt="uint64_t", .flag=97, .sdesc="Bytes allocated",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="c_freed", .fmt="uint64_t", .flag=97, .sdesc="Bytes freed",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="g_alloc", .fmt="uint64_t", .flag=105, .sdesc="Allocations outstanding",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="g_bytes", .fmt="uint64_t", .flag=105, .sdesc="Bytes outstanding",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="g_space", .fmt="uint64_t", .flag=105, .sdesc="Bytes available",
    .ldesc="", .level=&VSC_level_desc_info } };
// VSC_desc_smf
// file ../../include/tbl/vsc_all.h line 53
struct VSC_desc VSC_desc_smf[10l];
// VSC_desc_smf
// file ../../include/tbl/vsc_all.h line 53
struct VSC_desc VSC_desc_smf[10l] = { { .name="c_req", .fmt="uint64_t", .flag=97, .sdesc="Allocator requests",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="c_fail", .fmt="uint64_t", .flag=97, .sdesc="Allocator failures",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="c_bytes", .fmt="uint64_t", .flag=97, .sdesc="Bytes allocated",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="c_freed", .fmt="uint64_t", .flag=97, .sdesc="Bytes freed",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="g_alloc", .fmt="uint64_t", .flag=105, .sdesc="Allocations outstanding",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="g_bytes", .fmt="uint64_t", .flag=105, .sdesc="Bytes outstanding",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="g_space", .fmt="uint64_t", .flag=105, .sdesc="Bytes available",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="g_smf", .fmt="uint64_t", .flag=105, .sdesc="N struct smf",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="g_smf_frag", .fmt="uint64_t", .flag=105, .sdesc="N small free smf",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="g_smf_large", .fmt="uint64_t", .flag=105, .sdesc="N large free smf",
    .ldesc="", .level=&VSC_level_desc_info } };
// VSC_desc_vbe
// file ../../include/tbl/vsc_all.h line 59
struct VSC_desc VSC_desc_vbe[9l];
// VSC_desc_vbe
// file ../../include/tbl/vsc_all.h line 59
struct VSC_desc VSC_desc_vbe[9l] = { { .name="vcls", .fmt="uint64_t", .flag=105, .sdesc="VCL references",
    .ldesc="", .level=&VSC_level_desc_debug },
    { .name="happy", .fmt="uint64_t", .flag=98, .sdesc="Happy health probes",
    .ldesc="", .level=&VSC_level_desc_info },
    { .name="bereq_hdrbytes", .fmt="uint64_t", .flag=97,
    .sdesc="Request header bytes", .ldesc="Total backend request header bytes sent",
    .level=&VSC_level_desc_info },
    { .name="bereq_bodybytes", .fmt="uint64_t", .flag=97,
    .sdesc="Request body bytes", .ldesc="Total backend request body bytes sent",
    .level=&VSC_level_desc_info },
    { .name="beresp_hdrbytes", .fmt="uint64_t", .flag=97,
    .sdesc="Response header bytes", .ldesc="Total backend response header bytes received",
    .level=&VSC_level_desc_info },
    { .name="beresp_bodybytes", .fmt="uint64_t", .flag=97,
    .sdesc="Response body bytes", .ldesc="Total backend response body bytes received",
    .level=&VSC_level_desc_info },
    { .name="pipe_hdrbytes", .fmt="uint64_t", .flag=97,
    .sdesc="Pipe request header bytes", .ldesc="Total request bytes sent for piped sessions",
    .level=&VSC_level_desc_info },
    { .name="pipe_out", .fmt="uint64_t", .flag=97, .sdesc="Piped bytes to backend",
    .ldesc="Total number of bytes forwarded to backend in pipe sessions", .level=&VSC_level_desc_info },
    { .name="pipe_in", .fmt="uint64_t", .flag=97, .sdesc="Piped bytes from backend",
    .ldesc="Total number of bytes forwarded from backend in pipe sessions", .level=&VSC_level_desc_info } };
// VSC_type_desc_lck
// file ../../include/tbl/vsc_types.h line 62
struct VSC_type_desc VSC_type_desc_lck = { .label="LCK", .sdesc="Lock", .ldesc="Mutex lock counters" };
// VSC_type_desc_main
// file ../../include/tbl/vsc_types.h line 44
struct VSC_type_desc VSC_type_desc_main = { .label="", .sdesc="Child", .ldesc="Child process main counters" };
// VSC_type_desc_mempool
// file ../../include/tbl/vsc_types.h line 50
struct VSC_type_desc VSC_type_desc_mempool = { .label="MEMPOOL", .sdesc="Memory pool", .ldesc="Memory pool counters" };
// VSC_type_desc_mgt
// file ../../include/tbl/vsc_types.h line 47
struct VSC_type_desc VSC_type_desc_mgt = { .label="MGT", .sdesc="Master", .ldesc="Management process counters" };
// VSC_type_desc_sma
// file ../../include/tbl/vsc_types.h line 53
struct VSC_type_desc VSC_type_desc_sma = { .label="SMA", .sdesc="Storage malloc", .ldesc="Malloc storage counters" };
// VSC_type_desc_smf
// file ../../include/tbl/vsc_types.h line 56
struct VSC_type_desc VSC_type_desc_smf = { .label="SMF", .sdesc="Storage file", .ldesc="File storage counters" };
// VSC_type_desc_vbe
// file ../../include/tbl/vsc_types.h line 59
struct VSC_type_desc VSC_type_desc_vbe = { .label="VBE", .sdesc="Backend", .ldesc="Backend counters" };
// VSC_type_lck
// file ../../include/tbl/vsc_types.h line 62
const char *VSC_type_lck = "LCK";
// VSC_type_main
// file ../../include/tbl/vsc_types.h line 44
const char *VSC_type_main = "MAIN";
// VSC_type_mempool
// file ../../include/tbl/vsc_types.h line 50
const char *VSC_type_mempool = "MEMPOOL";
// VSC_type_mgt
// file ../../include/tbl/vsc_types.h line 47
const char *VSC_type_mgt = "MGT";
// VSC_type_sma
// file ../../include/tbl/vsc_types.h line 53
const char *VSC_type_sma = "SMA";
// VSC_type_smf
// file ../../include/tbl/vsc_types.h line 56
const char *VSC_type_smf = "SMF";
// VSC_type_vbe
// file ../../include/tbl/vsc_types.h line 59
const char *VSC_type_vbe = "VBE";
// VSLQ_grouping
// file vsl_arg.c line 186
const char *VSLQ_grouping[4l] = { "raw", "vxid", "request", "session" };
// VSL_tagflags
// file vsl.c line 66
const unsigned int VSL_tagflags[256l] = { 0u, (const unsigned int)(1 << 1), (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)(1 << 1), (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(1 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)(0 != 0 ? 0 : 1 << 0),
    (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u };
// VSL_tags
// file vsl.c line 60
const char * const VSL_tags[256l] = { ((const char *)NULL), "Debug", "Error", "CLI", "SessOpen", "SessClose", "BackendOpen", "BackendReuse", "BackendClose", "HttpGarbage", "Backend", "Length", "FetchError", "ReqMethod", "ReqURL", "ReqProtocol", "ReqStatus", "ReqReason", "ReqHeader", "ReqUnset", "ReqLost", "RespMethod", "RespURL", "RespProtocol", "RespStatus", "RespReason", "RespHeader", "RespUnset", "RespLost", "BereqMethod", "BereqURL", "BereqProtocol", "BereqStatus", "BereqReason", "BereqHeader", "BereqUnset", "BereqLost", "BerespMethod", "BerespURL", "BerespProtocol", "BerespStatus", "BerespReason", "BerespHeader", "BerespUnset", "BerespLost", "ObjMethod", "ObjURL", "ObjProtocol", "ObjStatus", "ObjReason", "ObjHeader", "ObjUnset", "ObjLost", "BogoHeader", "LostHeader", "TTL", "Fetch_Body", "VCL_acl", "VCL_call", "VCL_trace", "VCL_return", "ReqStart", "Hit", "HitPass", "ExpBan", "ExpKill", "WorkThread", "ESI_xmlerror", "Hash", "Backend_health", "VCL_Log", "VCL_Error", "Gzip", "Link", "Begin", "End", "VSL", "Storage", "Timestamp", "ReqAcct", "ESI_BodyBytes", "PipeAcct", "BereqAcct", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
// VSL_transactions
// file vsl.c line 219
static const char * const VSL_transactions[5l] = { "<< Unknown  >>", "<< Session  >>", "<< Request  >>", "<< BeReq    >>", "<< Record   >>" };
// VUT
// file ../../lib/libvarnishtools/vut.c line 54
struct VUT VUT;
// end_of_file
// file varnishtop.c line 65
static signed int end_of_file = 0;
// err_invalid_backslash
// file ../libvarnish/vav.c line 132
static char err_invalid_backslash[27l] = { 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'b', 'a', 'c', 'k', 's', 'l', 'a', 's', 'h', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 0 };
// err_missing_quote
// file ../libvarnish/vav.c line 133
static char err_missing_quote[12l] = { 'M', 'i', 's', 's', 'i', 'n', 'g', ' ', '\'', '"', '\'', 0 };
// f_flag
// file varnishtop.c line 107
static signed int f_flag = 0;
// fmts
// file ../../lib/libvarnish/vtim.c line 114
static const char *fmts[6l] = { "%a, %d %b %Y %T GMT", "%A, %d-%b-%y %T GMT", "%a %b %d %T %Y", "%F %T", "%FT%T", (const char *)(void *)0 };
// fmts$link1
// file ../libvarnish/vtim.c line 114
static const char *fmts$link1[6l] = { "%a, %d %b %Y %T GMT", "%A, %d-%b-%y %T GMT", "%a %b %d %T %Y", "%F %T", "%FT%T", (const char *)(void *)0 };
// h_key
// file varnishtop.c line 79
static struct t_key h_key = { .rbh_root=(struct top *)(void *)0 };
// h_order
// file varnishtop.c line 78
static struct t_order h_order = { .rbh_root=(struct top *)(void *)0 };
// maxfieldlen
// file varnishtop.c line 109
static unsigned int maxfieldlen = (unsigned int)0;
// mtx
// file varnishtop.c line 105
static union anonymous$0 mtx = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// ntop
// file varnishtop.c line 103
static unsigned int ntop;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// pcre_free
// file /usr/include/pcre.h line 490
extern void (*pcre_free)(void *);
// period
// file varnishtop.c line 64
static float period = (float)60;
// progname
// file varnishtop.c line 63
static const char progname[11l] = { 'v', 'a', 'r', 'n', 'i', 's', 'h', 't', 'o', 'p', 0 };
// sha256test
// file ../libvarnish/vsha256.c line 303
static struct sha256test sha256test[4l] = { { .input="", .output={ (const unsigned char)0xe3, (const unsigned char)0xb0, (const unsigned char)0xc4, (const unsigned char)0x42, (const unsigned char)0x98, (const unsigned char)0xfc, (const unsigned char)0x1c, (const unsigned char)0x14, (const unsigned char)0x9a, (const unsigned char)0xfb, (const unsigned char)0xf4, (const unsigned char)0xc8, (const unsigned char)0x99, (const unsigned char)0x6f, (const unsigned char)0xb9, (const unsigned char)0x24, (const unsigned char)0x27, (const unsigned char)0xae, (const unsigned char)0x41, (const unsigned char)0xe4, (const unsigned char)0x64, (const unsigned char)0x9b, (const unsigned char)0x93, (const unsigned char)0x4c, (const unsigned char)0xa4, (const unsigned char)0x95, (const unsigned char)0x99, (const unsigned char)0x1b, (const unsigned char)0x78, (const unsigned char)0x52, (const unsigned char)0xb8, (const unsigned char)0x55 } },
    { .input="message digest", .output={ (const unsigned char)0xf7, (const unsigned char)0x84, (const unsigned char)0x6f, (const unsigned char)0x55, (const unsigned char)0xcf, (const unsigned char)0x23, (const unsigned char)0xe1, (const unsigned char)0x4e, (const unsigned char)0xeb, (const unsigned char)0xea, (const unsigned char)0xb5, (const unsigned char)0xb4, (const unsigned char)0xe1, (const unsigned char)0x55, (const unsigned char)0x0c, (const unsigned char)0xad, (const unsigned char)0x5b, (const unsigned char)0x50, (const unsigned char)0x9e, (const unsigned char)0x33, (const unsigned char)0x48, (const unsigned char)0xfb, (const unsigned char)0xc4, (const unsigned char)0xef, (const unsigned char)0xa3, (const unsigned char)0xa1, (const unsigned char)0x41, (const unsigned char)0x3d, (const unsigned char)0x39, (const unsigned char)0x3c, (const unsigned char)0xb6, (const unsigned char)0x50 } },
    { .input="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", .output={ (const unsigned char)0xdb, (const unsigned char)0x4b, (const unsigned char)0xfc, (const unsigned char)0xbd, (const unsigned char)0x4d, (const unsigned char)0xa0, (const unsigned char)0xcd, (const unsigned char)0x85, (const unsigned char)0xa6, (const unsigned char)0x0c, (const unsigned char)0x3c, (const unsigned char)0x37, (const unsigned char)0xd3, (const unsigned char)0xfb, (const unsigned char)0xd8, (const unsigned char)0x80, (const unsigned char)0x5c, (const unsigned char)0x77, (const unsigned char)0xf1, (const unsigned char)0x5f, (const unsigned char)0xc6, (const unsigned char)0xb1, (const unsigned char)0xfd, (const unsigned char)0xfe, (const unsigned char)0x61, (const unsigned char)0x4e, (const unsigned char)0xe0, (const unsigned char)0xa7, (const unsigned char)0xc8, (const unsigned char)0xfd, (const unsigned char)0xb4, (const unsigned char)0xc0 } },
    { .input=(const char *)(void *)0, .output={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } } };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// stdscr
// file /usr/include/curses.h line 1395
extern struct _win_st *stdscr;
// vopt_list
// file ../../include/vapi/voptget.h line 76
struct vopt_list vopt_list[20l] = { { .option="1", .synopsis="[-1]", .desc="Run once", .ldesc="Instead of a continously updated display, print the statistics once and exit. Implies ``-d``." },
    { .option="b", .synopsis="[-b]", .desc="Only display backend records", .ldesc="Only display transactions and log records coming from backend communication." },
    { .option="c", .synopsis="[-c]", .desc="Only display client records", .ldesc="Only display transactions and log records coming from client communication." },
    { .option="C", .synopsis="[-C]", .desc="Caseless regular expressions", .ldesc="Do all regular expression and string matching caseless." },
    { .option="d", .synopsis="[-d]", .desc="Process old log entries on startup", .ldesc="Start processing log records at the head of the log instead of the tail." },
    { .option="f", .synopsis="[-f]", .desc="First field only", .ldesc="Sort and group only on the first field of each log entry. This is useful when displaying e.g. stataddr entries, where the first field is the client IP address." },
    { .option="g:", .synopsis="[-g <session|request|vxid|raw>]", .desc="Grouping mode (default: vxid)",
    .ldesc="The grouping of the log records. The default is to group by vxid." },
    { .option="h", .synopsis="[-h]", .desc="Usage help", .ldesc="Print program usage and exit" },
    { .option="i:", .synopsis="[-i taglist]", .desc="Include tags",
    .ldesc="Include log records of these tags in output. Taglist is a comma-separated list of tag globs. Multiple -i options may be given.\n\nIf a tag include option is the first of any tag selection options, all tags are first marked excluded." },
    { .option="I:", .synopsis="[-I <[taglist:]regex>]", .desc="Include by regex",
    .ldesc="Include by regex matching. Output only records matching taglist and regular expression. Applies to any tag if taglist is absent.\n\nIf a tag include option is the first of any tag selection options, all tags are first marked excluded." },
    { .option="L:", .synopsis="[-L limit]", .desc="Incomplete transaction limit", .ldesc="Sets the upper limit of incomplete transactions kept before the oldest transaction is force completed. A warning record is synthesized when this happens. This setting keeps an upper bound on the memory usage of running queries. Defaults to 1000 transactions." },
    { .option="n:", .synopsis="[-n name]", .desc="Varnish instance name", .ldesc="Specify the name of the varnishd instance to get logs from. If -n is not specified, the host name is used." },
    { .option="N:", .synopsis="[-N filename]", .desc="VSM filename",
    .ldesc="Specify the filename of a stale VSM instance. When using this option the abandonment checking is disabled." },
    { .option="p:", .synopsis="[-p period]", .desc="Sampling period",
    .ldesc="Specified the number of seconds to measure over, the default is 60 seconds. The first number in the list is the average number of requests seen over this time period." },
    { .option="q:", .synopsis="[-q query]", .desc="VSL query", .ldesc="Specifies the VSL query to use." },
    { .option="r:", .synopsis="[-r filename]", .desc="Binary file input",
    .ldesc="Read log in binary file format from this file." },
    { .option="T:", .synopsis="[-T seconds]", .desc="Transaction end timeout",
    .ldesc="Sets the transaction timeout in seconds. This defines the maximum number of seconds elapsed between a Begin tag and the End tag. If the timeout expires, a warning record is synthesized and the transaction is force completed. Defaults to 120 seconds." },
    { .option="x:", .synopsis="[-x taglist]", .desc="Exclude tags",
    .ldesc="Exclude log records of these tags in output. Taglist is a comma-separated list of tag globs. Multiple -x options may be given.\n" },
    { .option="X:", .synopsis="[-X <[taglist:]regex>]", .desc="Exclude by regex",
    .ldesc="Exclude by regex matching. Do not output records matching taglist and regular expression. Applies to any tag if taglist is absent." },
    { .option="V", .synopsis="[-V]", .desc="Version", .ldesc="Print version information and exit." } };
// vopt_list_n
// file ../../include/vapi/voptget.h line 80
unsigned int vopt_list_n = (unsigned int)(sizeof(struct vopt_list [20l]) /*640ul*/  / sizeof(struct vopt_list) /*32ul*/ );
// vopt_optstring
// file ../../include/vapi/voptget.h line 57
const char vopt_optstring[33l] = { '1', 'b', 'c', 'C', 'd', 'f', 'g', ':', 'h', 'i', ':', 'I', ':', 'L', ':', 'n', ':', 'N', ':', 'p', ':', 'q', ':', 'r', ':', 'T', ':', 'x', ':', 'X', ':', 'V', 0 };
// vopt_synopsis
// file ../../include/vapi/voptget.h line 63
const char vopt_synopsis[230l] = { ' ', '[', '-', '1', ']', ' ', '[', '-', 'b', ']', ' ', '[', '-', 'c', ']', ' ', '[', '-', 'C', ']', ' ', '[', '-', 'd', ']', ' ', '[', '-', 'f', ']', ' ', '[', '-', 'g', ' ', '<', 's', 'e', 's', 's', 'i', 'o', 'n', '|', 'r', 'e', 'q', 'u', 'e', 's', 't', '|', 'v', 'x', 'i', 'd', '|', 'r', 'a', 'w', '>', ']', ' ', '[', '-', 'h', ']', ' ', '[', '-', 'i', ' ', 't', 'a', 'g', 'l', 'i', 's', 't', ']', ' ', '[', '-', 'I', ' ', '<', '[', 't', 'a', 'g', 'l', 'i', 's', 't', ':', ']', 'r', 'e', 'g', 'e', 'x', '>', ']', ' ', '[', '-', 'L', ' ', 'l', 'i', 'm', 'i', 't', ']', ' ', '[', '-', 'n', ' ', 'n', 'a', 'm', 'e', ']', ' ', '[', '-', 'N', ' ', 'f', 'i', 'l', 'e', 'n', 'a', 'm', 'e', ']', ' ', '[', '-', 'p', ' ', 'p', 'e', 'r', 'i', 'o', 'd', ']', ' ', '[', '-', 'q', ' ', 'q', 'u', 'e', 'r', 'y', ']', ' ', '[', '-', 'r', ' ', 'f', 'i', 'l', 'e', 'n', 'a', 'm', 'e', ']', ' ', '[', '-', 'T', ' ', 's', 'e', 'c', 'o', 'n', 'd', 's', ']', ' ', '[', '-', 'x', ' ', 't', 'a', 'g', 'l', 'i', 's', 't', ']', ' ', '[', '-', 'X', ' ', '<', '[', 't', 'a', 'g', 'l', 'i', 's', 't', ':', ']', 'r', 'e', 'g', 'e', 'x', '>', ']', ' ', '[', '-', 'V', ']', 0 };
// vopt_usage
// file ../../include/vapi/voptget.h line 69
const char *vopt_usage[42l] = { "[-1]", "Run once", "[-b]", "Only display backend records", "[-c]", "Only display client records", "[-C]", "Caseless regular expressions", "[-d]", "Process old log entries on startup", "[-f]", "First field only", "[-g <session|request|vxid|raw>]", "Grouping mode (default: vxid)", "[-h]", "Usage help", "[-i taglist]", "Include tags", "[-I <[taglist:]regex>]", "Include by regex", "[-L limit]", "Incomplete transaction limit", "[-n name]", "Varnish instance name", "[-N filename]", "VSM filename", "[-p period]", "Sampling period", "[-q query]", "VSL query", "[-r filename]", "Binary file input", "[-T seconds]", "Transaction end timeout", "[-x taglist]", "Exclude tags", "[-X <[taglist:]regex>]", "Exclude by regex", "[-V]", "Version", (const char *)(void *)0, (const char *)(void *)0 };
// vsl_r_names
// file vsl_dispatch.c line 59
static const char * const vsl_r_names[9l] = { "unknown", "HTTP/1", "rxreq", "esi", "restart", "pass", "fetch", "bgfetch", "pipe" };
// vsl_t_names
// file vsl_dispatch.c line 51
static const char * const vsl_t_names[5l] = { "unknown", "sess", "req", "bereq", "raw" };
// vslc_file_tbl
// file vsl_cursor.c line 373
static struct vslc_tbl vslc_file_tbl;
// vslc_file_tbl
// file vsl_cursor.c line 373
static struct vslc_tbl vslc_file_tbl = { .magic=(unsigned int)0x5007C0DE, .delete=vslc_file_delete, .next=vslc_file_next,
    .reset=vslc_file_reset, .check=(signed int (*)(struct VSL_cursor *, struct VSLC_ptr *))(void *)0 };
// vslc_raw_tbl
// file vsl_dispatch.c line 255
static struct vslc_tbl vslc_raw_tbl;
// vslc_raw_tbl
// file vsl_dispatch.c line 255
static struct vslc_tbl vslc_raw_tbl = { .magic=(unsigned int)0x5007C0DE, .delete=(void (*)(struct VSL_cursor *))(void *)0, .next=vslc_raw_next,
    .reset=vslc_raw_reset, .check=(signed int (*)(struct VSL_cursor *, struct VSLC_ptr *))(void *)0 };
// vslc_vsm_tbl
// file vsl_cursor.c line 217
static struct vslc_tbl vslc_vsm_tbl;
// vslc_vsm_tbl
// file vsl_cursor.c line 217
static struct vslc_tbl vslc_vsm_tbl = { .magic=(unsigned int)0x5007C0DE, .delete=vslc_vsm_delete, .next=vslc_vsm_next,
    .reset=vslc_vsm_reset, .check=vslc_vsm_check };
// vslc_vtx_tbl
// file vsl_dispatch.c line 331
static struct vslc_tbl vslc_vtx_tbl;
// vslc_vtx_tbl
// file vsl_dispatch.c line 331
static struct vslc_tbl vslc_vtx_tbl = { .magic=(unsigned int)0x5007C0DE, .delete=(void (*)(struct VSL_cursor *))(void *)0, .next=vslc_vtx_next,
    .reset=vslc_vtx_reset, .check=(signed int (*)(struct VSL_cursor *, struct VSLC_ptr *))(void *)0 };
// vxp_tnames
// file vxp_fixed_token.c line 155
const char * const vxp_tnames[256l] = { ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "'('", "')'", ((const char *)NULL), ((const char *)NULL), "','", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "':'", ((const char *)NULL), "'<'", ((const char *)NULL), "'>'", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "'['", ((const char *)NULL), "']'", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "'{'", ((const char *)NULL), "'}'", "'~'", ((const char *)NULL), "EOI", "and", "==", ">=", "<=", "!=", "!~", "not", "or", "eq", "ne", "T_TRUE", "VAL", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };

// SHA256_Final
// file ../../include/vsha256.h line 42
void SHA256_Final(unsigned char *digest, struct SHA256Context *ctx)
{
  SHA256_Pad(ctx);
  be32enc_vect(digest, ctx->state, (unsigned long int)32);
  memset((void *)ctx, 0, sizeof(struct SHA256Context) /*104ul*/ );
}

// SHA256_Init
// file ../../include/vsha256.h line 40
void SHA256_Init(struct SHA256Context *ctx)
{
  ctx->count = (unsigned long int)0;
  ctx->state[(signed long int)0] = (unsigned int)0x6A09E667;
  ctx->state[(signed long int)1] = 0xBB67AE85;
  ctx->state[(signed long int)2] = (unsigned int)0x3C6EF372;
  ctx->state[(signed long int)3] = 0xA54FF53A;
  ctx->state[(signed long int)4] = (unsigned int)0x510E527F;
  ctx->state[(signed long int)5] = 0x9B05688C;
  ctx->state[(signed long int)6] = (unsigned int)0x1F83D9AB;
  ctx->state[(signed long int)7] = (unsigned int)0x5BE0CD19;
}

// SHA256_Pad
// file ../libvarnish/vsha256.c line 215
static void SHA256_Pad(struct SHA256Context *ctx)
{
  unsigned char len[8l];
  unsigned int r;
  unsigned int plen;
  vbe64enc((void *)len, ctx->count << 3);
  r = (unsigned int)(ctx->count & (unsigned long int)0x3f);
  plen = r < (unsigned int)56 ? (unsigned int)56 - r : (unsigned int)120 - r;
  SHA256_Update(ctx, (const void *)PAD, (unsigned long int)plen);
  SHA256_Update(ctx, (const void *)len, (unsigned long int)8);
}

// SHA256_Test
// file ../libvarnish/vsha256.c line 321
void SHA256_Test(void)
{
  struct SHA256Context c;
  struct sha256test *p;
  unsigned char o[32l];
  p = sha256test;
  for( ; !(p->input == ((const char *)NULL)); p = p + 1l)
  {
    SHA256_Init(&c);
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(p->input);
    SHA256_Update(&c, (const void *)p->input, return_value_strlen$1);
    SHA256_Final(o, &c);
    do
    {

    __CPROVER_DUMP_L2:
      ;
      signed int return_value_memcmp$3;
      return_value_memcmp$3=memcmp((const void *)o, (const void *)p->output, (unsigned long int)32);
      if(!(return_value_memcmp$3 == 0))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("SHA256_Test", "../libvarnish/vsha256.c", 331, "(memcmp(o, p->output, 32)) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    }
    while((_Bool)0);
  }
}

// SHA256_Transform
// file ../libvarnish/vsha256.c line 120
static void SHA256_Transform(unsigned int *state, const unsigned char *block)
{
  unsigned int W[64l];
  unsigned int S[8l];
  unsigned int t0;
  unsigned int t1;
  signed int i;
  be32dec_vect(W, block, (unsigned long int)64);
  i = 16;
  for( ; !(i >= 64); i = i + 1)
    W[(signed long int)i] = ((W[(signed long int)(i - 2)] >> 17 | W[(signed long int)(i - 2)] << 32 - 17) ^ (W[(signed long int)(i - 2)] >> 19 | W[(signed long int)(i - 2)] << 32 - 19) ^ W[(signed long int)(i - 2)] >> 10) + W[(signed long int)(i - 7)] + ((W[(signed long int)(i - 15)] >> 7 | W[(signed long int)(i - 15)] << 32 - 7) ^ (W[(signed long int)(i - 15)] >> 18 | W[(signed long int)(i - 15)] << 32 - 18) ^ W[(signed long int)(i - 15)] >> 3) + W[(signed long int)(i - 16)];
  memcpy((void *)S, (const void *)state, (unsigned long int)32);
  t0 = S[(signed long int)((71 - 0) % 8)] + ((S[(signed long int)((68 - 0) % 8)] >> 6 | S[(signed long int)((68 - 0) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 0) % 8)] >> 11 | S[(signed long int)((68 - 0) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 0) % 8)] >> 25 | S[(signed long int)((68 - 0) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 0) % 8)] & (S[(signed long int)((69 - 0) % 8)] ^ S[(signed long int)((70 - 0) % 8)]) ^ S[(signed long int)((70 - 0) % 8)]) + W[(signed long int)0] + (unsigned int)0x428a2f98;
  t1 = ((S[(signed long int)((64 - 0) % 8)] >> 2 | S[(signed long int)((64 - 0) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 0) % 8)] >> 13 | S[(signed long int)((64 - 0) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 0) % 8)] >> 22 | S[(signed long int)((64 - 0) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 0) % 8)] & (S[(signed long int)((65 - 0) % 8)] | S[(signed long int)((66 - 0) % 8)]) | S[(signed long int)((65 - 0) % 8)] & S[(signed long int)((66 - 0) % 8)]);
  S[(signed long int)((67 - 0) % 8)] = S[(signed long int)((67 - 0) % 8)] + t0;
  S[(signed long int)((71 - 0) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 1) % 8)] + ((S[(signed long int)((68 - 1) % 8)] >> 6 | S[(signed long int)((68 - 1) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 1) % 8)] >> 11 | S[(signed long int)((68 - 1) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 1) % 8)] >> 25 | S[(signed long int)((68 - 1) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 1) % 8)] & (S[(signed long int)((69 - 1) % 8)] ^ S[(signed long int)((70 - 1) % 8)]) ^ S[(signed long int)((70 - 1) % 8)]) + W[(signed long int)1] + (unsigned int)0x71374491;
  t1 = ((S[(signed long int)((64 - 1) % 8)] >> 2 | S[(signed long int)((64 - 1) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 1) % 8)] >> 13 | S[(signed long int)((64 - 1) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 1) % 8)] >> 22 | S[(signed long int)((64 - 1) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 1) % 8)] & (S[(signed long int)((65 - 1) % 8)] | S[(signed long int)((66 - 1) % 8)]) | S[(signed long int)((65 - 1) % 8)] & S[(signed long int)((66 - 1) % 8)]);
  S[(signed long int)((67 - 1) % 8)] = S[(signed long int)((67 - 1) % 8)] + t0;
  S[(signed long int)((71 - 1) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 2) % 8)] + ((S[(signed long int)((68 - 2) % 8)] >> 6 | S[(signed long int)((68 - 2) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 2) % 8)] >> 11 | S[(signed long int)((68 - 2) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 2) % 8)] >> 25 | S[(signed long int)((68 - 2) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 2) % 8)] & (S[(signed long int)((69 - 2) % 8)] ^ S[(signed long int)((70 - 2) % 8)]) ^ S[(signed long int)((70 - 2) % 8)]) + W[(signed long int)2] + 0xb5c0fbcf;
  t1 = ((S[(signed long int)((64 - 2) % 8)] >> 2 | S[(signed long int)((64 - 2) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 2) % 8)] >> 13 | S[(signed long int)((64 - 2) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 2) % 8)] >> 22 | S[(signed long int)((64 - 2) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 2) % 8)] & (S[(signed long int)((65 - 2) % 8)] | S[(signed long int)((66 - 2) % 8)]) | S[(signed long int)((65 - 2) % 8)] & S[(signed long int)((66 - 2) % 8)]);
  S[(signed long int)((67 - 2) % 8)] = S[(signed long int)((67 - 2) % 8)] + t0;
  S[(signed long int)((71 - 2) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 3) % 8)] + ((S[(signed long int)((68 - 3) % 8)] >> 6 | S[(signed long int)((68 - 3) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 3) % 8)] >> 11 | S[(signed long int)((68 - 3) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 3) % 8)] >> 25 | S[(signed long int)((68 - 3) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 3) % 8)] & (S[(signed long int)((69 - 3) % 8)] ^ S[(signed long int)((70 - 3) % 8)]) ^ S[(signed long int)((70 - 3) % 8)]) + W[(signed long int)3] + 0xe9b5dba5;
  t1 = ((S[(signed long int)((64 - 3) % 8)] >> 2 | S[(signed long int)((64 - 3) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 3) % 8)] >> 13 | S[(signed long int)((64 - 3) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 3) % 8)] >> 22 | S[(signed long int)((64 - 3) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 3) % 8)] & (S[(signed long int)((65 - 3) % 8)] | S[(signed long int)((66 - 3) % 8)]) | S[(signed long int)((65 - 3) % 8)] & S[(signed long int)((66 - 3) % 8)]);
  S[(signed long int)((67 - 3) % 8)] = S[(signed long int)((67 - 3) % 8)] + t0;
  S[(signed long int)((71 - 3) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 4) % 8)] + ((S[(signed long int)((68 - 4) % 8)] >> 6 | S[(signed long int)((68 - 4) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 4) % 8)] >> 11 | S[(signed long int)((68 - 4) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 4) % 8)] >> 25 | S[(signed long int)((68 - 4) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 4) % 8)] & (S[(signed long int)((69 - 4) % 8)] ^ S[(signed long int)((70 - 4) % 8)]) ^ S[(signed long int)((70 - 4) % 8)]) + W[(signed long int)4] + (unsigned int)0x3956c25b;
  t1 = ((S[(signed long int)((64 - 4) % 8)] >> 2 | S[(signed long int)((64 - 4) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 4) % 8)] >> 13 | S[(signed long int)((64 - 4) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 4) % 8)] >> 22 | S[(signed long int)((64 - 4) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 4) % 8)] & (S[(signed long int)((65 - 4) % 8)] | S[(signed long int)((66 - 4) % 8)]) | S[(signed long int)((65 - 4) % 8)] & S[(signed long int)((66 - 4) % 8)]);
  S[(signed long int)((67 - 4) % 8)] = S[(signed long int)((67 - 4) % 8)] + t0;
  S[(signed long int)((71 - 4) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 5) % 8)] + ((S[(signed long int)((68 - 5) % 8)] >> 6 | S[(signed long int)((68 - 5) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 5) % 8)] >> 11 | S[(signed long int)((68 - 5) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 5) % 8)] >> 25 | S[(signed long int)((68 - 5) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 5) % 8)] & (S[(signed long int)((69 - 5) % 8)] ^ S[(signed long int)((70 - 5) % 8)]) ^ S[(signed long int)((70 - 5) % 8)]) + W[(signed long int)5] + (unsigned int)0x59f111f1;
  t1 = ((S[(signed long int)((64 - 5) % 8)] >> 2 | S[(signed long int)((64 - 5) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 5) % 8)] >> 13 | S[(signed long int)((64 - 5) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 5) % 8)] >> 22 | S[(signed long int)((64 - 5) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 5) % 8)] & (S[(signed long int)((65 - 5) % 8)] | S[(signed long int)((66 - 5) % 8)]) | S[(signed long int)((65 - 5) % 8)] & S[(signed long int)((66 - 5) % 8)]);
  S[(signed long int)((67 - 5) % 8)] = S[(signed long int)((67 - 5) % 8)] + t0;
  S[(signed long int)((71 - 5) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 6) % 8)] + ((S[(signed long int)((68 - 6) % 8)] >> 6 | S[(signed long int)((68 - 6) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 6) % 8)] >> 11 | S[(signed long int)((68 - 6) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 6) % 8)] >> 25 | S[(signed long int)((68 - 6) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 6) % 8)] & (S[(signed long int)((69 - 6) % 8)] ^ S[(signed long int)((70 - 6) % 8)]) ^ S[(signed long int)((70 - 6) % 8)]) + W[(signed long int)6] + 0x923f82a4;
  t1 = ((S[(signed long int)((64 - 6) % 8)] >> 2 | S[(signed long int)((64 - 6) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 6) % 8)] >> 13 | S[(signed long int)((64 - 6) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 6) % 8)] >> 22 | S[(signed long int)((64 - 6) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 6) % 8)] & (S[(signed long int)((65 - 6) % 8)] | S[(signed long int)((66 - 6) % 8)]) | S[(signed long int)((65 - 6) % 8)] & S[(signed long int)((66 - 6) % 8)]);
  S[(signed long int)((67 - 6) % 8)] = S[(signed long int)((67 - 6) % 8)] + t0;
  S[(signed long int)((71 - 6) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 7) % 8)] + ((S[(signed long int)((68 - 7) % 8)] >> 6 | S[(signed long int)((68 - 7) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 7) % 8)] >> 11 | S[(signed long int)((68 - 7) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 7) % 8)] >> 25 | S[(signed long int)((68 - 7) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 7) % 8)] & (S[(signed long int)((69 - 7) % 8)] ^ S[(signed long int)((70 - 7) % 8)]) ^ S[(signed long int)((70 - 7) % 8)]) + W[(signed long int)7] + 0xab1c5ed5;
  t1 = ((S[(signed long int)((64 - 7) % 8)] >> 2 | S[(signed long int)((64 - 7) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 7) % 8)] >> 13 | S[(signed long int)((64 - 7) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 7) % 8)] >> 22 | S[(signed long int)((64 - 7) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 7) % 8)] & (S[(signed long int)((65 - 7) % 8)] | S[(signed long int)((66 - 7) % 8)]) | S[(signed long int)((65 - 7) % 8)] & S[(signed long int)((66 - 7) % 8)]);
  S[(signed long int)((67 - 7) % 8)] = S[(signed long int)((67 - 7) % 8)] + t0;
  S[(signed long int)((71 - 7) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 8) % 8)] + ((S[(signed long int)((68 - 8) % 8)] >> 6 | S[(signed long int)((68 - 8) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 8) % 8)] >> 11 | S[(signed long int)((68 - 8) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 8) % 8)] >> 25 | S[(signed long int)((68 - 8) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 8) % 8)] & (S[(signed long int)((69 - 8) % 8)] ^ S[(signed long int)((70 - 8) % 8)]) ^ S[(signed long int)((70 - 8) % 8)]) + W[(signed long int)8] + 0xd807aa98;
  t1 = ((S[(signed long int)((64 - 8) % 8)] >> 2 | S[(signed long int)((64 - 8) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 8) % 8)] >> 13 | S[(signed long int)((64 - 8) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 8) % 8)] >> 22 | S[(signed long int)((64 - 8) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 8) % 8)] & (S[(signed long int)((65 - 8) % 8)] | S[(signed long int)((66 - 8) % 8)]) | S[(signed long int)((65 - 8) % 8)] & S[(signed long int)((66 - 8) % 8)]);
  S[(signed long int)((67 - 8) % 8)] = S[(signed long int)((67 - 8) % 8)] + t0;
  S[(signed long int)((71 - 8) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 9) % 8)] + ((S[(signed long int)((68 - 9) % 8)] >> 6 | S[(signed long int)((68 - 9) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 9) % 8)] >> 11 | S[(signed long int)((68 - 9) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 9) % 8)] >> 25 | S[(signed long int)((68 - 9) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 9) % 8)] & (S[(signed long int)((69 - 9) % 8)] ^ S[(signed long int)((70 - 9) % 8)]) ^ S[(signed long int)((70 - 9) % 8)]) + W[(signed long int)9] + (unsigned int)0x12835b01;
  t1 = ((S[(signed long int)((64 - 9) % 8)] >> 2 | S[(signed long int)((64 - 9) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 9) % 8)] >> 13 | S[(signed long int)((64 - 9) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 9) % 8)] >> 22 | S[(signed long int)((64 - 9) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 9) % 8)] & (S[(signed long int)((65 - 9) % 8)] | S[(signed long int)((66 - 9) % 8)]) | S[(signed long int)((65 - 9) % 8)] & S[(signed long int)((66 - 9) % 8)]);
  S[(signed long int)((67 - 9) % 8)] = S[(signed long int)((67 - 9) % 8)] + t0;
  S[(signed long int)((71 - 9) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 10) % 8)] + ((S[(signed long int)((68 - 10) % 8)] >> 6 | S[(signed long int)((68 - 10) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 10) % 8)] >> 11 | S[(signed long int)((68 - 10) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 10) % 8)] >> 25 | S[(signed long int)((68 - 10) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 10) % 8)] & (S[(signed long int)((69 - 10) % 8)] ^ S[(signed long int)((70 - 10) % 8)]) ^ S[(signed long int)((70 - 10) % 8)]) + W[(signed long int)10] + (unsigned int)0x243185be;
  t1 = ((S[(signed long int)((64 - 10) % 8)] >> 2 | S[(signed long int)((64 - 10) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 10) % 8)] >> 13 | S[(signed long int)((64 - 10) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 10) % 8)] >> 22 | S[(signed long int)((64 - 10) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 10) % 8)] & (S[(signed long int)((65 - 10) % 8)] | S[(signed long int)((66 - 10) % 8)]) | S[(signed long int)((65 - 10) % 8)] & S[(signed long int)((66 - 10) % 8)]);
  S[(signed long int)((67 - 10) % 8)] = S[(signed long int)((67 - 10) % 8)] + t0;
  S[(signed long int)((71 - 10) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 11) % 8)] + ((S[(signed long int)((68 - 11) % 8)] >> 6 | S[(signed long int)((68 - 11) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 11) % 8)] >> 11 | S[(signed long int)((68 - 11) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 11) % 8)] >> 25 | S[(signed long int)((68 - 11) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 11) % 8)] & (S[(signed long int)((69 - 11) % 8)] ^ S[(signed long int)((70 - 11) % 8)]) ^ S[(signed long int)((70 - 11) % 8)]) + W[(signed long int)11] + (unsigned int)0x550c7dc3;
  t1 = ((S[(signed long int)((64 - 11) % 8)] >> 2 | S[(signed long int)((64 - 11) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 11) % 8)] >> 13 | S[(signed long int)((64 - 11) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 11) % 8)] >> 22 | S[(signed long int)((64 - 11) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 11) % 8)] & (S[(signed long int)((65 - 11) % 8)] | S[(signed long int)((66 - 11) % 8)]) | S[(signed long int)((65 - 11) % 8)] & S[(signed long int)((66 - 11) % 8)]);
  S[(signed long int)((67 - 11) % 8)] = S[(signed long int)((67 - 11) % 8)] + t0;
  S[(signed long int)((71 - 11) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 12) % 8)] + ((S[(signed long int)((68 - 12) % 8)] >> 6 | S[(signed long int)((68 - 12) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 12) % 8)] >> 11 | S[(signed long int)((68 - 12) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 12) % 8)] >> 25 | S[(signed long int)((68 - 12) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 12) % 8)] & (S[(signed long int)((69 - 12) % 8)] ^ S[(signed long int)((70 - 12) % 8)]) ^ S[(signed long int)((70 - 12) % 8)]) + W[(signed long int)12] + (unsigned int)0x72be5d74;
  t1 = ((S[(signed long int)((64 - 12) % 8)] >> 2 | S[(signed long int)((64 - 12) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 12) % 8)] >> 13 | S[(signed long int)((64 - 12) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 12) % 8)] >> 22 | S[(signed long int)((64 - 12) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 12) % 8)] & (S[(signed long int)((65 - 12) % 8)] | S[(signed long int)((66 - 12) % 8)]) | S[(signed long int)((65 - 12) % 8)] & S[(signed long int)((66 - 12) % 8)]);
  S[(signed long int)((67 - 12) % 8)] = S[(signed long int)((67 - 12) % 8)] + t0;
  S[(signed long int)((71 - 12) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 13) % 8)] + ((S[(signed long int)((68 - 13) % 8)] >> 6 | S[(signed long int)((68 - 13) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 13) % 8)] >> 11 | S[(signed long int)((68 - 13) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 13) % 8)] >> 25 | S[(signed long int)((68 - 13) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 13) % 8)] & (S[(signed long int)((69 - 13) % 8)] ^ S[(signed long int)((70 - 13) % 8)]) ^ S[(signed long int)((70 - 13) % 8)]) + W[(signed long int)13] + 0x80deb1fe;
  t1 = ((S[(signed long int)((64 - 13) % 8)] >> 2 | S[(signed long int)((64 - 13) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 13) % 8)] >> 13 | S[(signed long int)((64 - 13) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 13) % 8)] >> 22 | S[(signed long int)((64 - 13) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 13) % 8)] & (S[(signed long int)((65 - 13) % 8)] | S[(signed long int)((66 - 13) % 8)]) | S[(signed long int)((65 - 13) % 8)] & S[(signed long int)((66 - 13) % 8)]);
  S[(signed long int)((67 - 13) % 8)] = S[(signed long int)((67 - 13) % 8)] + t0;
  S[(signed long int)((71 - 13) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 14) % 8)] + ((S[(signed long int)((68 - 14) % 8)] >> 6 | S[(signed long int)((68 - 14) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 14) % 8)] >> 11 | S[(signed long int)((68 - 14) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 14) % 8)] >> 25 | S[(signed long int)((68 - 14) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 14) % 8)] & (S[(signed long int)((69 - 14) % 8)] ^ S[(signed long int)((70 - 14) % 8)]) ^ S[(signed long int)((70 - 14) % 8)]) + W[(signed long int)14] + 0x9bdc06a7;
  t1 = ((S[(signed long int)((64 - 14) % 8)] >> 2 | S[(signed long int)((64 - 14) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 14) % 8)] >> 13 | S[(signed long int)((64 - 14) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 14) % 8)] >> 22 | S[(signed long int)((64 - 14) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 14) % 8)] & (S[(signed long int)((65 - 14) % 8)] | S[(signed long int)((66 - 14) % 8)]) | S[(signed long int)((65 - 14) % 8)] & S[(signed long int)((66 - 14) % 8)]);
  S[(signed long int)((67 - 14) % 8)] = S[(signed long int)((67 - 14) % 8)] + t0;
  S[(signed long int)((71 - 14) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 15) % 8)] + ((S[(signed long int)((68 - 15) % 8)] >> 6 | S[(signed long int)((68 - 15) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 15) % 8)] >> 11 | S[(signed long int)((68 - 15) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 15) % 8)] >> 25 | S[(signed long int)((68 - 15) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 15) % 8)] & (S[(signed long int)((69 - 15) % 8)] ^ S[(signed long int)((70 - 15) % 8)]) ^ S[(signed long int)((70 - 15) % 8)]) + W[(signed long int)15] + 0xc19bf174;
  t1 = ((S[(signed long int)((64 - 15) % 8)] >> 2 | S[(signed long int)((64 - 15) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 15) % 8)] >> 13 | S[(signed long int)((64 - 15) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 15) % 8)] >> 22 | S[(signed long int)((64 - 15) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 15) % 8)] & (S[(signed long int)((65 - 15) % 8)] | S[(signed long int)((66 - 15) % 8)]) | S[(signed long int)((65 - 15) % 8)] & S[(signed long int)((66 - 15) % 8)]);
  S[(signed long int)((67 - 15) % 8)] = S[(signed long int)((67 - 15) % 8)] + t0;
  S[(signed long int)((71 - 15) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 16) % 8)] + ((S[(signed long int)((68 - 16) % 8)] >> 6 | S[(signed long int)((68 - 16) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 16) % 8)] >> 11 | S[(signed long int)((68 - 16) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 16) % 8)] >> 25 | S[(signed long int)((68 - 16) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 16) % 8)] & (S[(signed long int)((69 - 16) % 8)] ^ S[(signed long int)((70 - 16) % 8)]) ^ S[(signed long int)((70 - 16) % 8)]) + W[(signed long int)16] + 0xe49b69c1;
  t1 = ((S[(signed long int)((64 - 16) % 8)] >> 2 | S[(signed long int)((64 - 16) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 16) % 8)] >> 13 | S[(signed long int)((64 - 16) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 16) % 8)] >> 22 | S[(signed long int)((64 - 16) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 16) % 8)] & (S[(signed long int)((65 - 16) % 8)] | S[(signed long int)((66 - 16) % 8)]) | S[(signed long int)((65 - 16) % 8)] & S[(signed long int)((66 - 16) % 8)]);
  S[(signed long int)((67 - 16) % 8)] = S[(signed long int)((67 - 16) % 8)] + t0;
  S[(signed long int)((71 - 16) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 17) % 8)] + ((S[(signed long int)((68 - 17) % 8)] >> 6 | S[(signed long int)((68 - 17) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 17) % 8)] >> 11 | S[(signed long int)((68 - 17) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 17) % 8)] >> 25 | S[(signed long int)((68 - 17) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 17) % 8)] & (S[(signed long int)((69 - 17) % 8)] ^ S[(signed long int)((70 - 17) % 8)]) ^ S[(signed long int)((70 - 17) % 8)]) + W[(signed long int)17] + 0xefbe4786;
  t1 = ((S[(signed long int)((64 - 17) % 8)] >> 2 | S[(signed long int)((64 - 17) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 17) % 8)] >> 13 | S[(signed long int)((64 - 17) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 17) % 8)] >> 22 | S[(signed long int)((64 - 17) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 17) % 8)] & (S[(signed long int)((65 - 17) % 8)] | S[(signed long int)((66 - 17) % 8)]) | S[(signed long int)((65 - 17) % 8)] & S[(signed long int)((66 - 17) % 8)]);
  S[(signed long int)((67 - 17) % 8)] = S[(signed long int)((67 - 17) % 8)] + t0;
  S[(signed long int)((71 - 17) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 18) % 8)] + ((S[(signed long int)((68 - 18) % 8)] >> 6 | S[(signed long int)((68 - 18) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 18) % 8)] >> 11 | S[(signed long int)((68 - 18) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 18) % 8)] >> 25 | S[(signed long int)((68 - 18) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 18) % 8)] & (S[(signed long int)((69 - 18) % 8)] ^ S[(signed long int)((70 - 18) % 8)]) ^ S[(signed long int)((70 - 18) % 8)]) + W[(signed long int)18] + (unsigned int)0x0fc19dc6;
  t1 = ((S[(signed long int)((64 - 18) % 8)] >> 2 | S[(signed long int)((64 - 18) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 18) % 8)] >> 13 | S[(signed long int)((64 - 18) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 18) % 8)] >> 22 | S[(signed long int)((64 - 18) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 18) % 8)] & (S[(signed long int)((65 - 18) % 8)] | S[(signed long int)((66 - 18) % 8)]) | S[(signed long int)((65 - 18) % 8)] & S[(signed long int)((66 - 18) % 8)]);
  S[(signed long int)((67 - 18) % 8)] = S[(signed long int)((67 - 18) % 8)] + t0;
  S[(signed long int)((71 - 18) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 19) % 8)] + ((S[(signed long int)((68 - 19) % 8)] >> 6 | S[(signed long int)((68 - 19) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 19) % 8)] >> 11 | S[(signed long int)((68 - 19) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 19) % 8)] >> 25 | S[(signed long int)((68 - 19) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 19) % 8)] & (S[(signed long int)((69 - 19) % 8)] ^ S[(signed long int)((70 - 19) % 8)]) ^ S[(signed long int)((70 - 19) % 8)]) + W[(signed long int)19] + (unsigned int)0x240ca1cc;
  t1 = ((S[(signed long int)((64 - 19) % 8)] >> 2 | S[(signed long int)((64 - 19) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 19) % 8)] >> 13 | S[(signed long int)((64 - 19) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 19) % 8)] >> 22 | S[(signed long int)((64 - 19) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 19) % 8)] & (S[(signed long int)((65 - 19) % 8)] | S[(signed long int)((66 - 19) % 8)]) | S[(signed long int)((65 - 19) % 8)] & S[(signed long int)((66 - 19) % 8)]);
  S[(signed long int)((67 - 19) % 8)] = S[(signed long int)((67 - 19) % 8)] + t0;
  S[(signed long int)((71 - 19) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 20) % 8)] + ((S[(signed long int)((68 - 20) % 8)] >> 6 | S[(signed long int)((68 - 20) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 20) % 8)] >> 11 | S[(signed long int)((68 - 20) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 20) % 8)] >> 25 | S[(signed long int)((68 - 20) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 20) % 8)] & (S[(signed long int)((69 - 20) % 8)] ^ S[(signed long int)((70 - 20) % 8)]) ^ S[(signed long int)((70 - 20) % 8)]) + W[(signed long int)20] + (unsigned int)0x2de92c6f;
  t1 = ((S[(signed long int)((64 - 20) % 8)] >> 2 | S[(signed long int)((64 - 20) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 20) % 8)] >> 13 | S[(signed long int)((64 - 20) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 20) % 8)] >> 22 | S[(signed long int)((64 - 20) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 20) % 8)] & (S[(signed long int)((65 - 20) % 8)] | S[(signed long int)((66 - 20) % 8)]) | S[(signed long int)((65 - 20) % 8)] & S[(signed long int)((66 - 20) % 8)]);
  S[(signed long int)((67 - 20) % 8)] = S[(signed long int)((67 - 20) % 8)] + t0;
  S[(signed long int)((71 - 20) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 21) % 8)] + ((S[(signed long int)((68 - 21) % 8)] >> 6 | S[(signed long int)((68 - 21) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 21) % 8)] >> 11 | S[(signed long int)((68 - 21) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 21) % 8)] >> 25 | S[(signed long int)((68 - 21) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 21) % 8)] & (S[(signed long int)((69 - 21) % 8)] ^ S[(signed long int)((70 - 21) % 8)]) ^ S[(signed long int)((70 - 21) % 8)]) + W[(signed long int)21] + (unsigned int)0x4a7484aa;
  t1 = ((S[(signed long int)((64 - 21) % 8)] >> 2 | S[(signed long int)((64 - 21) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 21) % 8)] >> 13 | S[(signed long int)((64 - 21) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 21) % 8)] >> 22 | S[(signed long int)((64 - 21) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 21) % 8)] & (S[(signed long int)((65 - 21) % 8)] | S[(signed long int)((66 - 21) % 8)]) | S[(signed long int)((65 - 21) % 8)] & S[(signed long int)((66 - 21) % 8)]);
  S[(signed long int)((67 - 21) % 8)] = S[(signed long int)((67 - 21) % 8)] + t0;
  S[(signed long int)((71 - 21) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 22) % 8)] + ((S[(signed long int)((68 - 22) % 8)] >> 6 | S[(signed long int)((68 - 22) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 22) % 8)] >> 11 | S[(signed long int)((68 - 22) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 22) % 8)] >> 25 | S[(signed long int)((68 - 22) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 22) % 8)] & (S[(signed long int)((69 - 22) % 8)] ^ S[(signed long int)((70 - 22) % 8)]) ^ S[(signed long int)((70 - 22) % 8)]) + W[(signed long int)22] + (unsigned int)0x5cb0a9dc;
  t1 = ((S[(signed long int)((64 - 22) % 8)] >> 2 | S[(signed long int)((64 - 22) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 22) % 8)] >> 13 | S[(signed long int)((64 - 22) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 22) % 8)] >> 22 | S[(signed long int)((64 - 22) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 22) % 8)] & (S[(signed long int)((65 - 22) % 8)] | S[(signed long int)((66 - 22) % 8)]) | S[(signed long int)((65 - 22) % 8)] & S[(signed long int)((66 - 22) % 8)]);
  S[(signed long int)((67 - 22) % 8)] = S[(signed long int)((67 - 22) % 8)] + t0;
  S[(signed long int)((71 - 22) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 23) % 8)] + ((S[(signed long int)((68 - 23) % 8)] >> 6 | S[(signed long int)((68 - 23) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 23) % 8)] >> 11 | S[(signed long int)((68 - 23) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 23) % 8)] >> 25 | S[(signed long int)((68 - 23) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 23) % 8)] & (S[(signed long int)((69 - 23) % 8)] ^ S[(signed long int)((70 - 23) % 8)]) ^ S[(signed long int)((70 - 23) % 8)]) + W[(signed long int)23] + (unsigned int)0x76f988da;
  t1 = ((S[(signed long int)((64 - 23) % 8)] >> 2 | S[(signed long int)((64 - 23) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 23) % 8)] >> 13 | S[(signed long int)((64 - 23) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 23) % 8)] >> 22 | S[(signed long int)((64 - 23) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 23) % 8)] & (S[(signed long int)((65 - 23) % 8)] | S[(signed long int)((66 - 23) % 8)]) | S[(signed long int)((65 - 23) % 8)] & S[(signed long int)((66 - 23) % 8)]);
  S[(signed long int)((67 - 23) % 8)] = S[(signed long int)((67 - 23) % 8)] + t0;
  S[(signed long int)((71 - 23) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 24) % 8)] + ((S[(signed long int)((68 - 24) % 8)] >> 6 | S[(signed long int)((68 - 24) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 24) % 8)] >> 11 | S[(signed long int)((68 - 24) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 24) % 8)] >> 25 | S[(signed long int)((68 - 24) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 24) % 8)] & (S[(signed long int)((69 - 24) % 8)] ^ S[(signed long int)((70 - 24) % 8)]) ^ S[(signed long int)((70 - 24) % 8)]) + W[(signed long int)24] + 0x983e5152;
  t1 = ((S[(signed long int)((64 - 24) % 8)] >> 2 | S[(signed long int)((64 - 24) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 24) % 8)] >> 13 | S[(signed long int)((64 - 24) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 24) % 8)] >> 22 | S[(signed long int)((64 - 24) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 24) % 8)] & (S[(signed long int)((65 - 24) % 8)] | S[(signed long int)((66 - 24) % 8)]) | S[(signed long int)((65 - 24) % 8)] & S[(signed long int)((66 - 24) % 8)]);
  S[(signed long int)((67 - 24) % 8)] = S[(signed long int)((67 - 24) % 8)] + t0;
  S[(signed long int)((71 - 24) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 25) % 8)] + ((S[(signed long int)((68 - 25) % 8)] >> 6 | S[(signed long int)((68 - 25) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 25) % 8)] >> 11 | S[(signed long int)((68 - 25) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 25) % 8)] >> 25 | S[(signed long int)((68 - 25) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 25) % 8)] & (S[(signed long int)((69 - 25) % 8)] ^ S[(signed long int)((70 - 25) % 8)]) ^ S[(signed long int)((70 - 25) % 8)]) + W[(signed long int)25] + 0xa831c66d;
  t1 = ((S[(signed long int)((64 - 25) % 8)] >> 2 | S[(signed long int)((64 - 25) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 25) % 8)] >> 13 | S[(signed long int)((64 - 25) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 25) % 8)] >> 22 | S[(signed long int)((64 - 25) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 25) % 8)] & (S[(signed long int)((65 - 25) % 8)] | S[(signed long int)((66 - 25) % 8)]) | S[(signed long int)((65 - 25) % 8)] & S[(signed long int)((66 - 25) % 8)]);
  S[(signed long int)((67 - 25) % 8)] = S[(signed long int)((67 - 25) % 8)] + t0;
  S[(signed long int)((71 - 25) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 26) % 8)] + ((S[(signed long int)((68 - 26) % 8)] >> 6 | S[(signed long int)((68 - 26) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 26) % 8)] >> 11 | S[(signed long int)((68 - 26) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 26) % 8)] >> 25 | S[(signed long int)((68 - 26) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 26) % 8)] & (S[(signed long int)((69 - 26) % 8)] ^ S[(signed long int)((70 - 26) % 8)]) ^ S[(signed long int)((70 - 26) % 8)]) + W[(signed long int)26] + 0xb00327c8;
  t1 = ((S[(signed long int)((64 - 26) % 8)] >> 2 | S[(signed long int)((64 - 26) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 26) % 8)] >> 13 | S[(signed long int)((64 - 26) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 26) % 8)] >> 22 | S[(signed long int)((64 - 26) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 26) % 8)] & (S[(signed long int)((65 - 26) % 8)] | S[(signed long int)((66 - 26) % 8)]) | S[(signed long int)((65 - 26) % 8)] & S[(signed long int)((66 - 26) % 8)]);
  S[(signed long int)((67 - 26) % 8)] = S[(signed long int)((67 - 26) % 8)] + t0;
  S[(signed long int)((71 - 26) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 27) % 8)] + ((S[(signed long int)((68 - 27) % 8)] >> 6 | S[(signed long int)((68 - 27) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 27) % 8)] >> 11 | S[(signed long int)((68 - 27) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 27) % 8)] >> 25 | S[(signed long int)((68 - 27) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 27) % 8)] & (S[(signed long int)((69 - 27) % 8)] ^ S[(signed long int)((70 - 27) % 8)]) ^ S[(signed long int)((70 - 27) % 8)]) + W[(signed long int)27] + 0xbf597fc7;
  t1 = ((S[(signed long int)((64 - 27) % 8)] >> 2 | S[(signed long int)((64 - 27) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 27) % 8)] >> 13 | S[(signed long int)((64 - 27) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 27) % 8)] >> 22 | S[(signed long int)((64 - 27) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 27) % 8)] & (S[(signed long int)((65 - 27) % 8)] | S[(signed long int)((66 - 27) % 8)]) | S[(signed long int)((65 - 27) % 8)] & S[(signed long int)((66 - 27) % 8)]);
  S[(signed long int)((67 - 27) % 8)] = S[(signed long int)((67 - 27) % 8)] + t0;
  S[(signed long int)((71 - 27) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 28) % 8)] + ((S[(signed long int)((68 - 28) % 8)] >> 6 | S[(signed long int)((68 - 28) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 28) % 8)] >> 11 | S[(signed long int)((68 - 28) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 28) % 8)] >> 25 | S[(signed long int)((68 - 28) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 28) % 8)] & (S[(signed long int)((69 - 28) % 8)] ^ S[(signed long int)((70 - 28) % 8)]) ^ S[(signed long int)((70 - 28) % 8)]) + W[(signed long int)28] + 0xc6e00bf3;
  t1 = ((S[(signed long int)((64 - 28) % 8)] >> 2 | S[(signed long int)((64 - 28) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 28) % 8)] >> 13 | S[(signed long int)((64 - 28) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 28) % 8)] >> 22 | S[(signed long int)((64 - 28) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 28) % 8)] & (S[(signed long int)((65 - 28) % 8)] | S[(signed long int)((66 - 28) % 8)]) | S[(signed long int)((65 - 28) % 8)] & S[(signed long int)((66 - 28) % 8)]);
  S[(signed long int)((67 - 28) % 8)] = S[(signed long int)((67 - 28) % 8)] + t0;
  S[(signed long int)((71 - 28) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 29) % 8)] + ((S[(signed long int)((68 - 29) % 8)] >> 6 | S[(signed long int)((68 - 29) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 29) % 8)] >> 11 | S[(signed long int)((68 - 29) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 29) % 8)] >> 25 | S[(signed long int)((68 - 29) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 29) % 8)] & (S[(signed long int)((69 - 29) % 8)] ^ S[(signed long int)((70 - 29) % 8)]) ^ S[(signed long int)((70 - 29) % 8)]) + W[(signed long int)29] + 0xd5a79147;
  t1 = ((S[(signed long int)((64 - 29) % 8)] >> 2 | S[(signed long int)((64 - 29) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 29) % 8)] >> 13 | S[(signed long int)((64 - 29) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 29) % 8)] >> 22 | S[(signed long int)((64 - 29) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 29) % 8)] & (S[(signed long int)((65 - 29) % 8)] | S[(signed long int)((66 - 29) % 8)]) | S[(signed long int)((65 - 29) % 8)] & S[(signed long int)((66 - 29) % 8)]);
  S[(signed long int)((67 - 29) % 8)] = S[(signed long int)((67 - 29) % 8)] + t0;
  S[(signed long int)((71 - 29) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 30) % 8)] + ((S[(signed long int)((68 - 30) % 8)] >> 6 | S[(signed long int)((68 - 30) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 30) % 8)] >> 11 | S[(signed long int)((68 - 30) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 30) % 8)] >> 25 | S[(signed long int)((68 - 30) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 30) % 8)] & (S[(signed long int)((69 - 30) % 8)] ^ S[(signed long int)((70 - 30) % 8)]) ^ S[(signed long int)((70 - 30) % 8)]) + W[(signed long int)30] + (unsigned int)0x06ca6351;
  t1 = ((S[(signed long int)((64 - 30) % 8)] >> 2 | S[(signed long int)((64 - 30) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 30) % 8)] >> 13 | S[(signed long int)((64 - 30) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 30) % 8)] >> 22 | S[(signed long int)((64 - 30) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 30) % 8)] & (S[(signed long int)((65 - 30) % 8)] | S[(signed long int)((66 - 30) % 8)]) | S[(signed long int)((65 - 30) % 8)] & S[(signed long int)((66 - 30) % 8)]);
  S[(signed long int)((67 - 30) % 8)] = S[(signed long int)((67 - 30) % 8)] + t0;
  S[(signed long int)((71 - 30) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 31) % 8)] + ((S[(signed long int)((68 - 31) % 8)] >> 6 | S[(signed long int)((68 - 31) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 31) % 8)] >> 11 | S[(signed long int)((68 - 31) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 31) % 8)] >> 25 | S[(signed long int)((68 - 31) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 31) % 8)] & (S[(signed long int)((69 - 31) % 8)] ^ S[(signed long int)((70 - 31) % 8)]) ^ S[(signed long int)((70 - 31) % 8)]) + W[(signed long int)31] + (unsigned int)0x14292967;
  t1 = ((S[(signed long int)((64 - 31) % 8)] >> 2 | S[(signed long int)((64 - 31) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 31) % 8)] >> 13 | S[(signed long int)((64 - 31) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 31) % 8)] >> 22 | S[(signed long int)((64 - 31) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 31) % 8)] & (S[(signed long int)((65 - 31) % 8)] | S[(signed long int)((66 - 31) % 8)]) | S[(signed long int)((65 - 31) % 8)] & S[(signed long int)((66 - 31) % 8)]);
  S[(signed long int)((67 - 31) % 8)] = S[(signed long int)((67 - 31) % 8)] + t0;
  S[(signed long int)((71 - 31) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 32) % 8)] + ((S[(signed long int)((68 - 32) % 8)] >> 6 | S[(signed long int)((68 - 32) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 32) % 8)] >> 11 | S[(signed long int)((68 - 32) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 32) % 8)] >> 25 | S[(signed long int)((68 - 32) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 32) % 8)] & (S[(signed long int)((69 - 32) % 8)] ^ S[(signed long int)((70 - 32) % 8)]) ^ S[(signed long int)((70 - 32) % 8)]) + W[(signed long int)32] + (unsigned int)0x27b70a85;
  t1 = ((S[(signed long int)((64 - 32) % 8)] >> 2 | S[(signed long int)((64 - 32) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 32) % 8)] >> 13 | S[(signed long int)((64 - 32) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 32) % 8)] >> 22 | S[(signed long int)((64 - 32) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 32) % 8)] & (S[(signed long int)((65 - 32) % 8)] | S[(signed long int)((66 - 32) % 8)]) | S[(signed long int)((65 - 32) % 8)] & S[(signed long int)((66 - 32) % 8)]);
  S[(signed long int)((67 - 32) % 8)] = S[(signed long int)((67 - 32) % 8)] + t0;
  S[(signed long int)((71 - 32) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 33) % 8)] + ((S[(signed long int)((68 - 33) % 8)] >> 6 | S[(signed long int)((68 - 33) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 33) % 8)] >> 11 | S[(signed long int)((68 - 33) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 33) % 8)] >> 25 | S[(signed long int)((68 - 33) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 33) % 8)] & (S[(signed long int)((69 - 33) % 8)] ^ S[(signed long int)((70 - 33) % 8)]) ^ S[(signed long int)((70 - 33) % 8)]) + W[(signed long int)33] + (unsigned int)0x2e1b2138;
  t1 = ((S[(signed long int)((64 - 33) % 8)] >> 2 | S[(signed long int)((64 - 33) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 33) % 8)] >> 13 | S[(signed long int)((64 - 33) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 33) % 8)] >> 22 | S[(signed long int)((64 - 33) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 33) % 8)] & (S[(signed long int)((65 - 33) % 8)] | S[(signed long int)((66 - 33) % 8)]) | S[(signed long int)((65 - 33) % 8)] & S[(signed long int)((66 - 33) % 8)]);
  S[(signed long int)((67 - 33) % 8)] = S[(signed long int)((67 - 33) % 8)] + t0;
  S[(signed long int)((71 - 33) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 34) % 8)] + ((S[(signed long int)((68 - 34) % 8)] >> 6 | S[(signed long int)((68 - 34) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 34) % 8)] >> 11 | S[(signed long int)((68 - 34) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 34) % 8)] >> 25 | S[(signed long int)((68 - 34) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 34) % 8)] & (S[(signed long int)((69 - 34) % 8)] ^ S[(signed long int)((70 - 34) % 8)]) ^ S[(signed long int)((70 - 34) % 8)]) + W[(signed long int)34] + (unsigned int)0x4d2c6dfc;
  t1 = ((S[(signed long int)((64 - 34) % 8)] >> 2 | S[(signed long int)((64 - 34) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 34) % 8)] >> 13 | S[(signed long int)((64 - 34) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 34) % 8)] >> 22 | S[(signed long int)((64 - 34) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 34) % 8)] & (S[(signed long int)((65 - 34) % 8)] | S[(signed long int)((66 - 34) % 8)]) | S[(signed long int)((65 - 34) % 8)] & S[(signed long int)((66 - 34) % 8)]);
  S[(signed long int)((67 - 34) % 8)] = S[(signed long int)((67 - 34) % 8)] + t0;
  S[(signed long int)((71 - 34) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 35) % 8)] + ((S[(signed long int)((68 - 35) % 8)] >> 6 | S[(signed long int)((68 - 35) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 35) % 8)] >> 11 | S[(signed long int)((68 - 35) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 35) % 8)] >> 25 | S[(signed long int)((68 - 35) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 35) % 8)] & (S[(signed long int)((69 - 35) % 8)] ^ S[(signed long int)((70 - 35) % 8)]) ^ S[(signed long int)((70 - 35) % 8)]) + W[(signed long int)35] + (unsigned int)0x53380d13;
  t1 = ((S[(signed long int)((64 - 35) % 8)] >> 2 | S[(signed long int)((64 - 35) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 35) % 8)] >> 13 | S[(signed long int)((64 - 35) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 35) % 8)] >> 22 | S[(signed long int)((64 - 35) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 35) % 8)] & (S[(signed long int)((65 - 35) % 8)] | S[(signed long int)((66 - 35) % 8)]) | S[(signed long int)((65 - 35) % 8)] & S[(signed long int)((66 - 35) % 8)]);
  S[(signed long int)((67 - 35) % 8)] = S[(signed long int)((67 - 35) % 8)] + t0;
  S[(signed long int)((71 - 35) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 36) % 8)] + ((S[(signed long int)((68 - 36) % 8)] >> 6 | S[(signed long int)((68 - 36) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 36) % 8)] >> 11 | S[(signed long int)((68 - 36) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 36) % 8)] >> 25 | S[(signed long int)((68 - 36) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 36) % 8)] & (S[(signed long int)((69 - 36) % 8)] ^ S[(signed long int)((70 - 36) % 8)]) ^ S[(signed long int)((70 - 36) % 8)]) + W[(signed long int)36] + (unsigned int)0x650a7354;
  t1 = ((S[(signed long int)((64 - 36) % 8)] >> 2 | S[(signed long int)((64 - 36) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 36) % 8)] >> 13 | S[(signed long int)((64 - 36) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 36) % 8)] >> 22 | S[(signed long int)((64 - 36) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 36) % 8)] & (S[(signed long int)((65 - 36) % 8)] | S[(signed long int)((66 - 36) % 8)]) | S[(signed long int)((65 - 36) % 8)] & S[(signed long int)((66 - 36) % 8)]);
  S[(signed long int)((67 - 36) % 8)] = S[(signed long int)((67 - 36) % 8)] + t0;
  S[(signed long int)((71 - 36) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 37) % 8)] + ((S[(signed long int)((68 - 37) % 8)] >> 6 | S[(signed long int)((68 - 37) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 37) % 8)] >> 11 | S[(signed long int)((68 - 37) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 37) % 8)] >> 25 | S[(signed long int)((68 - 37) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 37) % 8)] & (S[(signed long int)((69 - 37) % 8)] ^ S[(signed long int)((70 - 37) % 8)]) ^ S[(signed long int)((70 - 37) % 8)]) + W[(signed long int)37] + (unsigned int)0x766a0abb;
  t1 = ((S[(signed long int)((64 - 37) % 8)] >> 2 | S[(signed long int)((64 - 37) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 37) % 8)] >> 13 | S[(signed long int)((64 - 37) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 37) % 8)] >> 22 | S[(signed long int)((64 - 37) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 37) % 8)] & (S[(signed long int)((65 - 37) % 8)] | S[(signed long int)((66 - 37) % 8)]) | S[(signed long int)((65 - 37) % 8)] & S[(signed long int)((66 - 37) % 8)]);
  S[(signed long int)((67 - 37) % 8)] = S[(signed long int)((67 - 37) % 8)] + t0;
  S[(signed long int)((71 - 37) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 38) % 8)] + ((S[(signed long int)((68 - 38) % 8)] >> 6 | S[(signed long int)((68 - 38) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 38) % 8)] >> 11 | S[(signed long int)((68 - 38) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 38) % 8)] >> 25 | S[(signed long int)((68 - 38) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 38) % 8)] & (S[(signed long int)((69 - 38) % 8)] ^ S[(signed long int)((70 - 38) % 8)]) ^ S[(signed long int)((70 - 38) % 8)]) + W[(signed long int)38] + 0x81c2c92e;
  t1 = ((S[(signed long int)((64 - 38) % 8)] >> 2 | S[(signed long int)((64 - 38) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 38) % 8)] >> 13 | S[(signed long int)((64 - 38) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 38) % 8)] >> 22 | S[(signed long int)((64 - 38) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 38) % 8)] & (S[(signed long int)((65 - 38) % 8)] | S[(signed long int)((66 - 38) % 8)]) | S[(signed long int)((65 - 38) % 8)] & S[(signed long int)((66 - 38) % 8)]);
  S[(signed long int)((67 - 38) % 8)] = S[(signed long int)((67 - 38) % 8)] + t0;
  S[(signed long int)((71 - 38) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 39) % 8)] + ((S[(signed long int)((68 - 39) % 8)] >> 6 | S[(signed long int)((68 - 39) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 39) % 8)] >> 11 | S[(signed long int)((68 - 39) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 39) % 8)] >> 25 | S[(signed long int)((68 - 39) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 39) % 8)] & (S[(signed long int)((69 - 39) % 8)] ^ S[(signed long int)((70 - 39) % 8)]) ^ S[(signed long int)((70 - 39) % 8)]) + W[(signed long int)39] + 0x92722c85;
  t1 = ((S[(signed long int)((64 - 39) % 8)] >> 2 | S[(signed long int)((64 - 39) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 39) % 8)] >> 13 | S[(signed long int)((64 - 39) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 39) % 8)] >> 22 | S[(signed long int)((64 - 39) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 39) % 8)] & (S[(signed long int)((65 - 39) % 8)] | S[(signed long int)((66 - 39) % 8)]) | S[(signed long int)((65 - 39) % 8)] & S[(signed long int)((66 - 39) % 8)]);
  S[(signed long int)((67 - 39) % 8)] = S[(signed long int)((67 - 39) % 8)] + t0;
  S[(signed long int)((71 - 39) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 40) % 8)] + ((S[(signed long int)((68 - 40) % 8)] >> 6 | S[(signed long int)((68 - 40) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 40) % 8)] >> 11 | S[(signed long int)((68 - 40) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 40) % 8)] >> 25 | S[(signed long int)((68 - 40) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 40) % 8)] & (S[(signed long int)((69 - 40) % 8)] ^ S[(signed long int)((70 - 40) % 8)]) ^ S[(signed long int)((70 - 40) % 8)]) + W[(signed long int)40] + 0xa2bfe8a1;
  t1 = ((S[(signed long int)((64 - 40) % 8)] >> 2 | S[(signed long int)((64 - 40) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 40) % 8)] >> 13 | S[(signed long int)((64 - 40) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 40) % 8)] >> 22 | S[(signed long int)((64 - 40) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 40) % 8)] & (S[(signed long int)((65 - 40) % 8)] | S[(signed long int)((66 - 40) % 8)]) | S[(signed long int)((65 - 40) % 8)] & S[(signed long int)((66 - 40) % 8)]);
  S[(signed long int)((67 - 40) % 8)] = S[(signed long int)((67 - 40) % 8)] + t0;
  S[(signed long int)((71 - 40) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 41) % 8)] + ((S[(signed long int)((68 - 41) % 8)] >> 6 | S[(signed long int)((68 - 41) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 41) % 8)] >> 11 | S[(signed long int)((68 - 41) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 41) % 8)] >> 25 | S[(signed long int)((68 - 41) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 41) % 8)] & (S[(signed long int)((69 - 41) % 8)] ^ S[(signed long int)((70 - 41) % 8)]) ^ S[(signed long int)((70 - 41) % 8)]) + W[(signed long int)41] + 0xa81a664b;
  t1 = ((S[(signed long int)((64 - 41) % 8)] >> 2 | S[(signed long int)((64 - 41) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 41) % 8)] >> 13 | S[(signed long int)((64 - 41) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 41) % 8)] >> 22 | S[(signed long int)((64 - 41) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 41) % 8)] & (S[(signed long int)((65 - 41) % 8)] | S[(signed long int)((66 - 41) % 8)]) | S[(signed long int)((65 - 41) % 8)] & S[(signed long int)((66 - 41) % 8)]);
  S[(signed long int)((67 - 41) % 8)] = S[(signed long int)((67 - 41) % 8)] + t0;
  S[(signed long int)((71 - 41) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 42) % 8)] + ((S[(signed long int)((68 - 42) % 8)] >> 6 | S[(signed long int)((68 - 42) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 42) % 8)] >> 11 | S[(signed long int)((68 - 42) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 42) % 8)] >> 25 | S[(signed long int)((68 - 42) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 42) % 8)] & (S[(signed long int)((69 - 42) % 8)] ^ S[(signed long int)((70 - 42) % 8)]) ^ S[(signed long int)((70 - 42) % 8)]) + W[(signed long int)42] + 0xc24b8b70;
  t1 = ((S[(signed long int)((64 - 42) % 8)] >> 2 | S[(signed long int)((64 - 42) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 42) % 8)] >> 13 | S[(signed long int)((64 - 42) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 42) % 8)] >> 22 | S[(signed long int)((64 - 42) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 42) % 8)] & (S[(signed long int)((65 - 42) % 8)] | S[(signed long int)((66 - 42) % 8)]) | S[(signed long int)((65 - 42) % 8)] & S[(signed long int)((66 - 42) % 8)]);
  S[(signed long int)((67 - 42) % 8)] = S[(signed long int)((67 - 42) % 8)] + t0;
  S[(signed long int)((71 - 42) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 43) % 8)] + ((S[(signed long int)((68 - 43) % 8)] >> 6 | S[(signed long int)((68 - 43) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 43) % 8)] >> 11 | S[(signed long int)((68 - 43) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 43) % 8)] >> 25 | S[(signed long int)((68 - 43) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 43) % 8)] & (S[(signed long int)((69 - 43) % 8)] ^ S[(signed long int)((70 - 43) % 8)]) ^ S[(signed long int)((70 - 43) % 8)]) + W[(signed long int)43] + 0xc76c51a3;
  t1 = ((S[(signed long int)((64 - 43) % 8)] >> 2 | S[(signed long int)((64 - 43) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 43) % 8)] >> 13 | S[(signed long int)((64 - 43) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 43) % 8)] >> 22 | S[(signed long int)((64 - 43) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 43) % 8)] & (S[(signed long int)((65 - 43) % 8)] | S[(signed long int)((66 - 43) % 8)]) | S[(signed long int)((65 - 43) % 8)] & S[(signed long int)((66 - 43) % 8)]);
  S[(signed long int)((67 - 43) % 8)] = S[(signed long int)((67 - 43) % 8)] + t0;
  S[(signed long int)((71 - 43) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 44) % 8)] + ((S[(signed long int)((68 - 44) % 8)] >> 6 | S[(signed long int)((68 - 44) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 44) % 8)] >> 11 | S[(signed long int)((68 - 44) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 44) % 8)] >> 25 | S[(signed long int)((68 - 44) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 44) % 8)] & (S[(signed long int)((69 - 44) % 8)] ^ S[(signed long int)((70 - 44) % 8)]) ^ S[(signed long int)((70 - 44) % 8)]) + W[(signed long int)44] + 0xd192e819;
  t1 = ((S[(signed long int)((64 - 44) % 8)] >> 2 | S[(signed long int)((64 - 44) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 44) % 8)] >> 13 | S[(signed long int)((64 - 44) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 44) % 8)] >> 22 | S[(signed long int)((64 - 44) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 44) % 8)] & (S[(signed long int)((65 - 44) % 8)] | S[(signed long int)((66 - 44) % 8)]) | S[(signed long int)((65 - 44) % 8)] & S[(signed long int)((66 - 44) % 8)]);
  S[(signed long int)((67 - 44) % 8)] = S[(signed long int)((67 - 44) % 8)] + t0;
  S[(signed long int)((71 - 44) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 45) % 8)] + ((S[(signed long int)((68 - 45) % 8)] >> 6 | S[(signed long int)((68 - 45) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 45) % 8)] >> 11 | S[(signed long int)((68 - 45) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 45) % 8)] >> 25 | S[(signed long int)((68 - 45) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 45) % 8)] & (S[(signed long int)((69 - 45) % 8)] ^ S[(signed long int)((70 - 45) % 8)]) ^ S[(signed long int)((70 - 45) % 8)]) + W[(signed long int)45] + 0xd6990624;
  t1 = ((S[(signed long int)((64 - 45) % 8)] >> 2 | S[(signed long int)((64 - 45) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 45) % 8)] >> 13 | S[(signed long int)((64 - 45) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 45) % 8)] >> 22 | S[(signed long int)((64 - 45) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 45) % 8)] & (S[(signed long int)((65 - 45) % 8)] | S[(signed long int)((66 - 45) % 8)]) | S[(signed long int)((65 - 45) % 8)] & S[(signed long int)((66 - 45) % 8)]);
  S[(signed long int)((67 - 45) % 8)] = S[(signed long int)((67 - 45) % 8)] + t0;
  S[(signed long int)((71 - 45) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 46) % 8)] + ((S[(signed long int)((68 - 46) % 8)] >> 6 | S[(signed long int)((68 - 46) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 46) % 8)] >> 11 | S[(signed long int)((68 - 46) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 46) % 8)] >> 25 | S[(signed long int)((68 - 46) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 46) % 8)] & (S[(signed long int)((69 - 46) % 8)] ^ S[(signed long int)((70 - 46) % 8)]) ^ S[(signed long int)((70 - 46) % 8)]) + W[(signed long int)46] + 0xf40e3585;
  t1 = ((S[(signed long int)((64 - 46) % 8)] >> 2 | S[(signed long int)((64 - 46) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 46) % 8)] >> 13 | S[(signed long int)((64 - 46) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 46) % 8)] >> 22 | S[(signed long int)((64 - 46) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 46) % 8)] & (S[(signed long int)((65 - 46) % 8)] | S[(signed long int)((66 - 46) % 8)]) | S[(signed long int)((65 - 46) % 8)] & S[(signed long int)((66 - 46) % 8)]);
  S[(signed long int)((67 - 46) % 8)] = S[(signed long int)((67 - 46) % 8)] + t0;
  S[(signed long int)((71 - 46) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 47) % 8)] + ((S[(signed long int)((68 - 47) % 8)] >> 6 | S[(signed long int)((68 - 47) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 47) % 8)] >> 11 | S[(signed long int)((68 - 47) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 47) % 8)] >> 25 | S[(signed long int)((68 - 47) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 47) % 8)] & (S[(signed long int)((69 - 47) % 8)] ^ S[(signed long int)((70 - 47) % 8)]) ^ S[(signed long int)((70 - 47) % 8)]) + W[(signed long int)47] + (unsigned int)0x106aa070;
  t1 = ((S[(signed long int)((64 - 47) % 8)] >> 2 | S[(signed long int)((64 - 47) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 47) % 8)] >> 13 | S[(signed long int)((64 - 47) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 47) % 8)] >> 22 | S[(signed long int)((64 - 47) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 47) % 8)] & (S[(signed long int)((65 - 47) % 8)] | S[(signed long int)((66 - 47) % 8)]) | S[(signed long int)((65 - 47) % 8)] & S[(signed long int)((66 - 47) % 8)]);
  S[(signed long int)((67 - 47) % 8)] = S[(signed long int)((67 - 47) % 8)] + t0;
  S[(signed long int)((71 - 47) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 48) % 8)] + ((S[(signed long int)((68 - 48) % 8)] >> 6 | S[(signed long int)((68 - 48) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 48) % 8)] >> 11 | S[(signed long int)((68 - 48) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 48) % 8)] >> 25 | S[(signed long int)((68 - 48) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 48) % 8)] & (S[(signed long int)((69 - 48) % 8)] ^ S[(signed long int)((70 - 48) % 8)]) ^ S[(signed long int)((70 - 48) % 8)]) + W[(signed long int)48] + (unsigned int)0x19a4c116;
  t1 = ((S[(signed long int)((64 - 48) % 8)] >> 2 | S[(signed long int)((64 - 48) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 48) % 8)] >> 13 | S[(signed long int)((64 - 48) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 48) % 8)] >> 22 | S[(signed long int)((64 - 48) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 48) % 8)] & (S[(signed long int)((65 - 48) % 8)] | S[(signed long int)((66 - 48) % 8)]) | S[(signed long int)((65 - 48) % 8)] & S[(signed long int)((66 - 48) % 8)]);
  S[(signed long int)((67 - 48) % 8)] = S[(signed long int)((67 - 48) % 8)] + t0;
  S[(signed long int)((71 - 48) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 49) % 8)] + ((S[(signed long int)((68 - 49) % 8)] >> 6 | S[(signed long int)((68 - 49) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 49) % 8)] >> 11 | S[(signed long int)((68 - 49) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 49) % 8)] >> 25 | S[(signed long int)((68 - 49) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 49) % 8)] & (S[(signed long int)((69 - 49) % 8)] ^ S[(signed long int)((70 - 49) % 8)]) ^ S[(signed long int)((70 - 49) % 8)]) + W[(signed long int)49] + (unsigned int)0x1e376c08;
  t1 = ((S[(signed long int)((64 - 49) % 8)] >> 2 | S[(signed long int)((64 - 49) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 49) % 8)] >> 13 | S[(signed long int)((64 - 49) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 49) % 8)] >> 22 | S[(signed long int)((64 - 49) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 49) % 8)] & (S[(signed long int)((65 - 49) % 8)] | S[(signed long int)((66 - 49) % 8)]) | S[(signed long int)((65 - 49) % 8)] & S[(signed long int)((66 - 49) % 8)]);
  S[(signed long int)((67 - 49) % 8)] = S[(signed long int)((67 - 49) % 8)] + t0;
  S[(signed long int)((71 - 49) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 50) % 8)] + ((S[(signed long int)((68 - 50) % 8)] >> 6 | S[(signed long int)((68 - 50) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 50) % 8)] >> 11 | S[(signed long int)((68 - 50) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 50) % 8)] >> 25 | S[(signed long int)((68 - 50) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 50) % 8)] & (S[(signed long int)((69 - 50) % 8)] ^ S[(signed long int)((70 - 50) % 8)]) ^ S[(signed long int)((70 - 50) % 8)]) + W[(signed long int)50] + (unsigned int)0x2748774c;
  t1 = ((S[(signed long int)((64 - 50) % 8)] >> 2 | S[(signed long int)((64 - 50) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 50) % 8)] >> 13 | S[(signed long int)((64 - 50) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 50) % 8)] >> 22 | S[(signed long int)((64 - 50) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 50) % 8)] & (S[(signed long int)((65 - 50) % 8)] | S[(signed long int)((66 - 50) % 8)]) | S[(signed long int)((65 - 50) % 8)] & S[(signed long int)((66 - 50) % 8)]);
  S[(signed long int)((67 - 50) % 8)] = S[(signed long int)((67 - 50) % 8)] + t0;
  S[(signed long int)((71 - 50) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 51) % 8)] + ((S[(signed long int)((68 - 51) % 8)] >> 6 | S[(signed long int)((68 - 51) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 51) % 8)] >> 11 | S[(signed long int)((68 - 51) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 51) % 8)] >> 25 | S[(signed long int)((68 - 51) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 51) % 8)] & (S[(signed long int)((69 - 51) % 8)] ^ S[(signed long int)((70 - 51) % 8)]) ^ S[(signed long int)((70 - 51) % 8)]) + W[(signed long int)51] + (unsigned int)0x34b0bcb5;
  t1 = ((S[(signed long int)((64 - 51) % 8)] >> 2 | S[(signed long int)((64 - 51) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 51) % 8)] >> 13 | S[(signed long int)((64 - 51) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 51) % 8)] >> 22 | S[(signed long int)((64 - 51) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 51) % 8)] & (S[(signed long int)((65 - 51) % 8)] | S[(signed long int)((66 - 51) % 8)]) | S[(signed long int)((65 - 51) % 8)] & S[(signed long int)((66 - 51) % 8)]);
  S[(signed long int)((67 - 51) % 8)] = S[(signed long int)((67 - 51) % 8)] + t0;
  S[(signed long int)((71 - 51) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 52) % 8)] + ((S[(signed long int)((68 - 52) % 8)] >> 6 | S[(signed long int)((68 - 52) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 52) % 8)] >> 11 | S[(signed long int)((68 - 52) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 52) % 8)] >> 25 | S[(signed long int)((68 - 52) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 52) % 8)] & (S[(signed long int)((69 - 52) % 8)] ^ S[(signed long int)((70 - 52) % 8)]) ^ S[(signed long int)((70 - 52) % 8)]) + W[(signed long int)52] + (unsigned int)0x391c0cb3;
  t1 = ((S[(signed long int)((64 - 52) % 8)] >> 2 | S[(signed long int)((64 - 52) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 52) % 8)] >> 13 | S[(signed long int)((64 - 52) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 52) % 8)] >> 22 | S[(signed long int)((64 - 52) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 52) % 8)] & (S[(signed long int)((65 - 52) % 8)] | S[(signed long int)((66 - 52) % 8)]) | S[(signed long int)((65 - 52) % 8)] & S[(signed long int)((66 - 52) % 8)]);
  S[(signed long int)((67 - 52) % 8)] = S[(signed long int)((67 - 52) % 8)] + t0;
  S[(signed long int)((71 - 52) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 53) % 8)] + ((S[(signed long int)((68 - 53) % 8)] >> 6 | S[(signed long int)((68 - 53) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 53) % 8)] >> 11 | S[(signed long int)((68 - 53) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 53) % 8)] >> 25 | S[(signed long int)((68 - 53) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 53) % 8)] & (S[(signed long int)((69 - 53) % 8)] ^ S[(signed long int)((70 - 53) % 8)]) ^ S[(signed long int)((70 - 53) % 8)]) + W[(signed long int)53] + (unsigned int)0x4ed8aa4a;
  t1 = ((S[(signed long int)((64 - 53) % 8)] >> 2 | S[(signed long int)((64 - 53) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 53) % 8)] >> 13 | S[(signed long int)((64 - 53) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 53) % 8)] >> 22 | S[(signed long int)((64 - 53) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 53) % 8)] & (S[(signed long int)((65 - 53) % 8)] | S[(signed long int)((66 - 53) % 8)]) | S[(signed long int)((65 - 53) % 8)] & S[(signed long int)((66 - 53) % 8)]);
  S[(signed long int)((67 - 53) % 8)] = S[(signed long int)((67 - 53) % 8)] + t0;
  S[(signed long int)((71 - 53) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 54) % 8)] + ((S[(signed long int)((68 - 54) % 8)] >> 6 | S[(signed long int)((68 - 54) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 54) % 8)] >> 11 | S[(signed long int)((68 - 54) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 54) % 8)] >> 25 | S[(signed long int)((68 - 54) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 54) % 8)] & (S[(signed long int)((69 - 54) % 8)] ^ S[(signed long int)((70 - 54) % 8)]) ^ S[(signed long int)((70 - 54) % 8)]) + W[(signed long int)54] + (unsigned int)0x5b9cca4f;
  t1 = ((S[(signed long int)((64 - 54) % 8)] >> 2 | S[(signed long int)((64 - 54) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 54) % 8)] >> 13 | S[(signed long int)((64 - 54) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 54) % 8)] >> 22 | S[(signed long int)((64 - 54) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 54) % 8)] & (S[(signed long int)((65 - 54) % 8)] | S[(signed long int)((66 - 54) % 8)]) | S[(signed long int)((65 - 54) % 8)] & S[(signed long int)((66 - 54) % 8)]);
  S[(signed long int)((67 - 54) % 8)] = S[(signed long int)((67 - 54) % 8)] + t0;
  S[(signed long int)((71 - 54) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 55) % 8)] + ((S[(signed long int)((68 - 55) % 8)] >> 6 | S[(signed long int)((68 - 55) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 55) % 8)] >> 11 | S[(signed long int)((68 - 55) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 55) % 8)] >> 25 | S[(signed long int)((68 - 55) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 55) % 8)] & (S[(signed long int)((69 - 55) % 8)] ^ S[(signed long int)((70 - 55) % 8)]) ^ S[(signed long int)((70 - 55) % 8)]) + W[(signed long int)55] + (unsigned int)0x682e6ff3;
  t1 = ((S[(signed long int)((64 - 55) % 8)] >> 2 | S[(signed long int)((64 - 55) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 55) % 8)] >> 13 | S[(signed long int)((64 - 55) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 55) % 8)] >> 22 | S[(signed long int)((64 - 55) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 55) % 8)] & (S[(signed long int)((65 - 55) % 8)] | S[(signed long int)((66 - 55) % 8)]) | S[(signed long int)((65 - 55) % 8)] & S[(signed long int)((66 - 55) % 8)]);
  S[(signed long int)((67 - 55) % 8)] = S[(signed long int)((67 - 55) % 8)] + t0;
  S[(signed long int)((71 - 55) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 56) % 8)] + ((S[(signed long int)((68 - 56) % 8)] >> 6 | S[(signed long int)((68 - 56) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 56) % 8)] >> 11 | S[(signed long int)((68 - 56) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 56) % 8)] >> 25 | S[(signed long int)((68 - 56) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 56) % 8)] & (S[(signed long int)((69 - 56) % 8)] ^ S[(signed long int)((70 - 56) % 8)]) ^ S[(signed long int)((70 - 56) % 8)]) + W[(signed long int)56] + (unsigned int)0x748f82ee;
  t1 = ((S[(signed long int)((64 - 56) % 8)] >> 2 | S[(signed long int)((64 - 56) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 56) % 8)] >> 13 | S[(signed long int)((64 - 56) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 56) % 8)] >> 22 | S[(signed long int)((64 - 56) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 56) % 8)] & (S[(signed long int)((65 - 56) % 8)] | S[(signed long int)((66 - 56) % 8)]) | S[(signed long int)((65 - 56) % 8)] & S[(signed long int)((66 - 56) % 8)]);
  S[(signed long int)((67 - 56) % 8)] = S[(signed long int)((67 - 56) % 8)] + t0;
  S[(signed long int)((71 - 56) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 57) % 8)] + ((S[(signed long int)((68 - 57) % 8)] >> 6 | S[(signed long int)((68 - 57) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 57) % 8)] >> 11 | S[(signed long int)((68 - 57) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 57) % 8)] >> 25 | S[(signed long int)((68 - 57) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 57) % 8)] & (S[(signed long int)((69 - 57) % 8)] ^ S[(signed long int)((70 - 57) % 8)]) ^ S[(signed long int)((70 - 57) % 8)]) + W[(signed long int)57] + (unsigned int)0x78a5636f;
  t1 = ((S[(signed long int)((64 - 57) % 8)] >> 2 | S[(signed long int)((64 - 57) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 57) % 8)] >> 13 | S[(signed long int)((64 - 57) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 57) % 8)] >> 22 | S[(signed long int)((64 - 57) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 57) % 8)] & (S[(signed long int)((65 - 57) % 8)] | S[(signed long int)((66 - 57) % 8)]) | S[(signed long int)((65 - 57) % 8)] & S[(signed long int)((66 - 57) % 8)]);
  S[(signed long int)((67 - 57) % 8)] = S[(signed long int)((67 - 57) % 8)] + t0;
  S[(signed long int)((71 - 57) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 58) % 8)] + ((S[(signed long int)((68 - 58) % 8)] >> 6 | S[(signed long int)((68 - 58) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 58) % 8)] >> 11 | S[(signed long int)((68 - 58) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 58) % 8)] >> 25 | S[(signed long int)((68 - 58) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 58) % 8)] & (S[(signed long int)((69 - 58) % 8)] ^ S[(signed long int)((70 - 58) % 8)]) ^ S[(signed long int)((70 - 58) % 8)]) + W[(signed long int)58] + 0x84c87814;
  t1 = ((S[(signed long int)((64 - 58) % 8)] >> 2 | S[(signed long int)((64 - 58) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 58) % 8)] >> 13 | S[(signed long int)((64 - 58) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 58) % 8)] >> 22 | S[(signed long int)((64 - 58) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 58) % 8)] & (S[(signed long int)((65 - 58) % 8)] | S[(signed long int)((66 - 58) % 8)]) | S[(signed long int)((65 - 58) % 8)] & S[(signed long int)((66 - 58) % 8)]);
  S[(signed long int)((67 - 58) % 8)] = S[(signed long int)((67 - 58) % 8)] + t0;
  S[(signed long int)((71 - 58) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 59) % 8)] + ((S[(signed long int)((68 - 59) % 8)] >> 6 | S[(signed long int)((68 - 59) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 59) % 8)] >> 11 | S[(signed long int)((68 - 59) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 59) % 8)] >> 25 | S[(signed long int)((68 - 59) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 59) % 8)] & (S[(signed long int)((69 - 59) % 8)] ^ S[(signed long int)((70 - 59) % 8)]) ^ S[(signed long int)((70 - 59) % 8)]) + W[(signed long int)59] + 0x8cc70208;
  t1 = ((S[(signed long int)((64 - 59) % 8)] >> 2 | S[(signed long int)((64 - 59) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 59) % 8)] >> 13 | S[(signed long int)((64 - 59) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 59) % 8)] >> 22 | S[(signed long int)((64 - 59) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 59) % 8)] & (S[(signed long int)((65 - 59) % 8)] | S[(signed long int)((66 - 59) % 8)]) | S[(signed long int)((65 - 59) % 8)] & S[(signed long int)((66 - 59) % 8)]);
  S[(signed long int)((67 - 59) % 8)] = S[(signed long int)((67 - 59) % 8)] + t0;
  S[(signed long int)((71 - 59) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 60) % 8)] + ((S[(signed long int)((68 - 60) % 8)] >> 6 | S[(signed long int)((68 - 60) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 60) % 8)] >> 11 | S[(signed long int)((68 - 60) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 60) % 8)] >> 25 | S[(signed long int)((68 - 60) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 60) % 8)] & (S[(signed long int)((69 - 60) % 8)] ^ S[(signed long int)((70 - 60) % 8)]) ^ S[(signed long int)((70 - 60) % 8)]) + W[(signed long int)60] + 0x90befffa;
  t1 = ((S[(signed long int)((64 - 60) % 8)] >> 2 | S[(signed long int)((64 - 60) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 60) % 8)] >> 13 | S[(signed long int)((64 - 60) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 60) % 8)] >> 22 | S[(signed long int)((64 - 60) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 60) % 8)] & (S[(signed long int)((65 - 60) % 8)] | S[(signed long int)((66 - 60) % 8)]) | S[(signed long int)((65 - 60) % 8)] & S[(signed long int)((66 - 60) % 8)]);
  S[(signed long int)((67 - 60) % 8)] = S[(signed long int)((67 - 60) % 8)] + t0;
  S[(signed long int)((71 - 60) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 61) % 8)] + ((S[(signed long int)((68 - 61) % 8)] >> 6 | S[(signed long int)((68 - 61) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 61) % 8)] >> 11 | S[(signed long int)((68 - 61) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 61) % 8)] >> 25 | S[(signed long int)((68 - 61) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 61) % 8)] & (S[(signed long int)((69 - 61) % 8)] ^ S[(signed long int)((70 - 61) % 8)]) ^ S[(signed long int)((70 - 61) % 8)]) + W[(signed long int)61] + 0xa4506ceb;
  t1 = ((S[(signed long int)((64 - 61) % 8)] >> 2 | S[(signed long int)((64 - 61) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 61) % 8)] >> 13 | S[(signed long int)((64 - 61) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 61) % 8)] >> 22 | S[(signed long int)((64 - 61) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 61) % 8)] & (S[(signed long int)((65 - 61) % 8)] | S[(signed long int)((66 - 61) % 8)]) | S[(signed long int)((65 - 61) % 8)] & S[(signed long int)((66 - 61) % 8)]);
  S[(signed long int)((67 - 61) % 8)] = S[(signed long int)((67 - 61) % 8)] + t0;
  S[(signed long int)((71 - 61) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 62) % 8)] + ((S[(signed long int)((68 - 62) % 8)] >> 6 | S[(signed long int)((68 - 62) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 62) % 8)] >> 11 | S[(signed long int)((68 - 62) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 62) % 8)] >> 25 | S[(signed long int)((68 - 62) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 62) % 8)] & (S[(signed long int)((69 - 62) % 8)] ^ S[(signed long int)((70 - 62) % 8)]) ^ S[(signed long int)((70 - 62) % 8)]) + W[(signed long int)62] + 0xbef9a3f7;
  t1 = ((S[(signed long int)((64 - 62) % 8)] >> 2 | S[(signed long int)((64 - 62) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 62) % 8)] >> 13 | S[(signed long int)((64 - 62) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 62) % 8)] >> 22 | S[(signed long int)((64 - 62) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 62) % 8)] & (S[(signed long int)((65 - 62) % 8)] | S[(signed long int)((66 - 62) % 8)]) | S[(signed long int)((65 - 62) % 8)] & S[(signed long int)((66 - 62) % 8)]);
  S[(signed long int)((67 - 62) % 8)] = S[(signed long int)((67 - 62) % 8)] + t0;
  S[(signed long int)((71 - 62) % 8)] = t0 + t1;
  t0 = S[(signed long int)((71 - 63) % 8)] + ((S[(signed long int)((68 - 63) % 8)] >> 6 | S[(signed long int)((68 - 63) % 8)] << 32 - 6) ^ (S[(signed long int)((68 - 63) % 8)] >> 11 | S[(signed long int)((68 - 63) % 8)] << 32 - 11) ^ (S[(signed long int)((68 - 63) % 8)] >> 25 | S[(signed long int)((68 - 63) % 8)] << 32 - 25)) + (S[(signed long int)((68 - 63) % 8)] & (S[(signed long int)((69 - 63) % 8)] ^ S[(signed long int)((70 - 63) % 8)]) ^ S[(signed long int)((70 - 63) % 8)]) + W[(signed long int)63] + 0xc67178f2;
  t1 = ((S[(signed long int)((64 - 63) % 8)] >> 2 | S[(signed long int)((64 - 63) % 8)] << 32 - 2) ^ (S[(signed long int)((64 - 63) % 8)] >> 13 | S[(signed long int)((64 - 63) % 8)] << 32 - 13) ^ (S[(signed long int)((64 - 63) % 8)] >> 22 | S[(signed long int)((64 - 63) % 8)] << 32 - 22)) + (S[(signed long int)((64 - 63) % 8)] & (S[(signed long int)((65 - 63) % 8)] | S[(signed long int)((66 - 63) % 8)]) | S[(signed long int)((65 - 63) % 8)] & S[(signed long int)((66 - 63) % 8)]);
  S[(signed long int)((67 - 63) % 8)] = S[(signed long int)((67 - 63) % 8)] + t0;
  S[(signed long int)((71 - 63) % 8)] = t0 + t1;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    state[(signed long int)i] = state[(signed long int)i] + S[(signed long int)i];
}

// SHA256_Update
// file ../../include/vsha256.h line 41
void SHA256_Update(struct SHA256Context *ctx, const void *in, unsigned long int len)
{
  unsigned int r;
  unsigned int l;
  const unsigned char *src = (const unsigned char *)in;
  r = (unsigned int)(ctx->count & (unsigned long int)0x3f);
  while(len >= 1ul)
  {
    l = (unsigned int)64 - r;
    if(!(len >= (unsigned long int)l))
      l = (unsigned int)len;

    memcpy((void *)&ctx->buf[(signed long int)r], (const void *)src, (unsigned long int)l);
    len = len - (unsigned long int)l;
    src = src + (signed long int)l;
    ctx->count = ctx->count + (unsigned long int)l;
    r = (unsigned int)(ctx->count & (unsigned long int)0x3f);
    if(r == 0u)
      SHA256_Transform(ctx->state, ctx->buf);

  }
}

// VAS_Fail_default
// file ../../lib/libvarnish/vas.c line 41
static void VAS_Fail_default(const char *func, const char *file, signed int line, const char *cond, signed int err, enum vas_e kind)
{
  if((signed int)kind == VAS_MISSING)
    fprintf(stderr, "Missing errorhandling code in %s(), %s line %d:\n  Condition(%s) not true.\n", func, file, line, cond);

  else
    if((signed int)kind == VAS_INCOMPLETE)
      fprintf(stderr, "Incomplete code in %s(), %s line %d:\n", func, file, line);

    else
      if((signed int)kind == VAS_WRONG)
        fprintf(stderr, "Wrong turn in %s(), %s line %d:\n", func, file, line);

      else
        fprintf(stderr, "Assert error in %s(), %s line %d:\n  Condition(%s) not true.\n", func, file, line, cond);
  char *return_value_strerror$1;
  if(!(err == 0))
  {
    return_value_strerror$1=strerror(err);
    fprintf(stderr, "  errno = %d (%s)\n", err, return_value_strerror$1);
  }

  abort();
}

// VAS_Fail_default$link1
// file ../libvarnish/vas.c line 41
static void VAS_Fail_default$link1(const char *func$link1, const char *file$link1, signed int line$link1, const char *cond$link1, signed int err$link1, enum vas_e kind$link1)
{
  if((signed int)kind$link1 == VAS_MISSING)
    fprintf(stderr, "Missing errorhandling code in %s(), %s line %d:\n  Condition(%s) not true.\n", func$link1, file$link1, line$link1, cond$link1);

  else
    if((signed int)kind$link1 == VAS_INCOMPLETE)
      fprintf(stderr, "Incomplete code in %s(), %s line %d:\n", func$link1, file$link1, line$link1);

    else
      if((signed int)kind$link1 == VAS_WRONG)
        fprintf(stderr, "Wrong turn in %s(), %s line %d:\n", func$link1, file$link1, line$link1);

      else
        fprintf(stderr, "Assert error in %s(), %s line %d:\n  Condition(%s) not true.\n", func$link1, file$link1, line$link1, cond$link1);
  char *return_value_strerror$1$link1;
  if(!(err$link1 == 0))
  {
    return_value_strerror$1$link1=strerror(err$link1);
    fprintf(stderr, "  errno = %d (%s)\n", err$link1, return_value_strerror$1$link1);
  }

  abort();
}

// VAV_BackSlash
// file ../libvarnish/vav.c line 51
signed int VAV_BackSlash(const char *s, char *res)
{
  signed int r;
  char c;
  unsigned int u;
  do
    if(!((signed int)*s == 92))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VAV_BackSlash", "../libvarnish/vav.c", 57, "*s == '\\\\'", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  c = (char)0;
  r = (signed int)c;
  signed int return_value_sscanf$4;
  switch((signed int)s[(signed long int)1])
  {
    case 110:
    {
      c = (char)10;
      r = 2;
      break;
    }
    case 114:
    {
      c = (char)13;
      r = 2;
      break;
    }
    case 116:
    {
      c = (char)9;
      r = 2;
      break;
    }
    case 34:
    {
      c = (char)34;
      r = 2;
      break;
    }
    case 92:
    {
      c = (char)92;
      r = 2;
      break;
    }
    case 48:

    case 49:

    case 50:

    case 51:

    case 52:

    case 53:

    case 54:

    case 55:
    {
      r = 1;
      for( ; !(r >= 4); r = r + 1)
      {
        const unsigned short int **return_value___ctype_b_loc$2;
        return_value___ctype_b_loc$2=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)s[(signed long int)r]]) == 0)
          break;

        if((signed int)s[(signed long int)r] + -48 >= 8)
          break;

        c = c << 3;
        c = c | (char)((signed int)s[(signed long int)r] - 48);
      }
      break;
    }
    case 120:
    {
      return_value_sscanf$4=sscanf(s + (signed long int)1, "x%02x", &u);
      if(return_value_sscanf$4 == 1)
      {

      __CPROVER_DUMP_L13:
        ;
        do
          if(!((4294967040u & u) == 0u))
          {
            signed int *return_value___errno_location$3;
            return_value___errno_location$3=__errno_location();
            VAS_Fail("VAV_BackSlash", "../libvarnish/vav.c", 93, "(u & ~0xff) == 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
        c = (char)u;
        r = 4;
      }

      break;
    }
    default:
      ;
  }
  if(!(res == ((char *)NULL)))
    *res = c;

  return r;
}

// VAV_BackSlashDecode
// file ../libvarnish/vav.c line 107
char * VAV_BackSlashDecode(const char *s, const char *e)
{
  const char *q;
  char *p;
  char *r;
  signed int i;
  if(e == ((const char *)NULL))
    e=strchr(s, 0);

  do
    if(e == ((const char *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VAV_BackSlashDecode", "../libvarnish/vav.c", 115, "e != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  void *return_value_calloc$2;
  return_value_calloc$2=calloc((unsigned long int)((e - s) + (signed long int)1), (unsigned long int)1);
  p = (char *)return_value_calloc$2;
  char *tmp_post$3;
  const char *tmp_post$4;
  if(p == ((char *)NULL))
    return p;

  else
  {
    r = p;
    q = s;
    while(!(q >= e))
      if(!((signed int)*q == 92))
      {
        tmp_post$3 = r;
        r = r + 1l;
        tmp_post$4 = q;
        q = q + 1l;
        *tmp_post$3 = *tmp_post$4;
      }

      else
      {
        i=VAV_BackSlash(q, r);
        q = q + (signed long int)i;
        r = r + 1l;
      }
    *r = (char)0;
    return p;
  }
}

// VAV_Free
// file ../libvarnish/vav.c line 215
void VAV_Free(char **argv)
{
  signed int i = 1;
  for( ; !(argv[(signed long int)i] == ((char *)NULL)); i = i + 1)
    free((void *)argv[(signed long int)i]);
  free((void *)argv);
}

// VAV_Parse
// file ../libvarnish/vav.c line 136
char ** VAV_Parse(const char *s, signed int *argc, signed int flag)
{
  char **argv;
  const char *p;
  signed int nargv;
  signed int largv;
  signed int i;
  signed int quote;
  do
    if(s == ((const char *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VAV_Parse", "../libvarnish/vav.c", 143, "s != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  nargv = 1;
  largv = 16;
  void *return_value_calloc$2;
  return_value_calloc$2=calloc(sizeof(char *) /*8ul*/ , (unsigned long int)largv);
  argv = (char **)return_value_calloc$2;
  _Bool tmp_if_expr$5;
  const unsigned short int **return_value___ctype_b_loc$4;
  signed int tmp_post$10;
  if(argv == ((char **)NULL))
    return (char **)(void *)0;

  else
  {
    while(!((signed int)*s == 0))
    {
      const unsigned short int **return_value___ctype_b_loc$3;
      return_value___ctype_b_loc$3=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*s]) == 0))
        s = s + 1l;

      else
      {
        if(!((1 & flag) == 0))
        {
          if((signed int)*s == 35)
            break;

        }

        if((4 & flag) == 0 && (signed int)*s == 34)
        {
          s = s + 1l;
          p = s;
          quote = 1;
        }

        else
        {
          p = s;
          quote = 0;
        }
        while((_Bool)1)
          if((signed int)*s == 92)
          {
            if(!((4 & flag) == 0))
              goto __CPROVER_DUMP_L9;

            i=VAV_BackSlash(s, (char *)(void *)0);
            if(i == 0)
            {
              argv[(signed long int)0] = err_invalid_backslash;
              return argv;
            }

            s = s + (signed long int)i;
          }

          else
          {

          __CPROVER_DUMP_L9:
            ;
            if(quote == 0)
            {
              if((signed int)*s == 0)
                tmp_if_expr$5 = (_Bool)1;

              else
              {
                return_value___ctype_b_loc$4=__ctype_b_loc();
                tmp_if_expr$5 = ((signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*s] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$5)
                break;

              if(!((2 & flag) == 0))
              {
                if((signed int)*s == 44)
                  break;

              }

              s = s + 1l;
              continue;
            }

            if((signed int)*s == 34)
            {
              if((4 & flag) == 0)
                break;

            }

            if((signed int)*s == 0)
            {
              argv[(signed long int)0] = err_missing_quote;
              return argv;
            }

            s = s + 1l;
          }
        if(1 + nargv >= largv)
        {
          largv = largv + largv;
          void *return_value_realloc$6;
          return_value_realloc$6=realloc((void *)argv, sizeof(char *) /*8ul*/  * (unsigned long int)largv);
          argv = (char **)return_value_realloc$6;
          do
            if(argv == ((char **)NULL))
            {
              signed int *return_value___errno_location$7;
              return_value___errno_location$7=__errno_location();
              VAS_Fail("VAV_Parse", "../libvarnish/vav.c", 194, "argv != NULL", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
            }

          while((_Bool)0);
        }

        if(!((4 & flag) == 0))
        {
          void *return_value_malloc$8;
          return_value_malloc$8=malloc((unsigned long int)((signed long int)1 + (s - p)));
          argv[(signed long int)nargv] = (char *)return_value_malloc$8;
          do
            if(argv[(signed long int)nargv] == ((char *)NULL))
            {
              signed int *return_value___errno_location$9;
              return_value___errno_location$9=__errno_location();
              VAS_Fail("VAV_Parse", "../libvarnish/vav.c", 198, "argv[nargv] != NULL", *return_value___errno_location$9, (enum vas_e)VAS_ASSERT);
            }

          while((_Bool)0);
          memcpy((void *)argv[(signed long int)nargv], (const void *)p, (unsigned long int)(s - p));
          argv[(signed long int)nargv][s - p] = (char)0;
          nargv = nargv + 1;
        }

        else
        {
          tmp_post$10 = nargv;
          nargv = nargv + 1;
          argv[(signed long int)tmp_post$10]=VAV_BackSlashDecode(p, s);
        }
        if(!((signed int)*s == 0))
          s = s + 1l;

      }
    }
    argv[(signed long int)nargv] = (char *)(void *)0;
    if(!(argc == ((signed int *)NULL)))
      *argc = nargv;

    return argv;
  }
}

// VCLI_AuthResponse
// file ../libvarnish/cli_auth.c line 43
void VCLI_AuthResponse(signed int S_fd, const char *challenge, char *response)
{
  struct SHA256Context ctx;
  unsigned char buf[8192l];
  signed int i;
  while((_Bool)0)
    ;
  SHA256_Init(&ctx);
  SHA256_Update(&ctx, (const void *)challenge, (unsigned long int)32);
  SHA256_Update(&ctx, (const void *)"\n", (unsigned long int)1);
  do
  {
    signed long int return_value_read$2;
    return_value_read$2=read(S_fd, (void *)buf, sizeof(unsigned char [8192l]) /*8192ul*/ );
    i = (signed int)return_value_read$2;
    if(i >= 1)
      SHA256_Update(&ctx, (const void *)buf, (unsigned long int)i);

  }
  while(i >= 1);
  SHA256_Update(&ctx, (const void *)challenge, (unsigned long int)32);
  SHA256_Update(&ctx, (const void *)"\n", (unsigned long int)1);
  SHA256_Final(buf, &ctx);
  i = 0;
  for( ; !(i >= 32); i = i + 1)
    sprintf(response + (signed long int)(2 * i), "%02x", buf[(signed long int)i]);
}

// VCLI_Out
// file ../libvarnish/cli_common.c line 55
void VCLI_Out(struct cli *cli, const char *fmt, ...)
{
  void **ap = (void **)&fmt;
  if(!(cli == ((struct cli *)NULL)))
  {

  __CPROVER_DUMP_L1:
    ;
    do
    {
      if(cli == ((struct cli *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("VCLI_Out", "../libvarnish/cli_common.c", 61, "(cli) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(cli->magic == 1077466480u))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          VAS_Fail("VCLI_Out", "../libvarnish/cli_common.c", 61, "(cli)->magic == 0x4038d570", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    signed long int return_value_VSB_len$3;
    return_value_VSB_len$3=VSB_len(cli->sb);
    if(!(return_value_VSB_len$3 >= (signed long int)*cli->limit))
      VSB_vprintf(cli->sb, fmt, ap);

    else
      if((signed int)cli->result == CLIS_OK)
        cli->result = (enum VCLI_status_e)CLIS_TRUNCATED;

  }

  else
    vfprintf(stdout, fmt, ap);
  ap = ((void **)NULL);
}

// VCLI_Overflow
// file ../libvarnish/cli_common.c line 74
signed int VCLI_Overflow(struct cli *cli)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(cli == ((struct cli *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VCLI_Overflow", "../libvarnish/cli_common.c", 76, "(cli) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(cli->magic == 1077466480u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VCLI_Overflow", "../libvarnish/cli_common.c", 76, "(cli)->magic == 0x4038d570", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  _Bool tmp_if_expr$4;
  signed long int return_value_VSB_len$3;
  if((signed int)cli->result == CLIS_TRUNCATED)
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    return_value_VSB_len$3=VSB_len(cli->sb);
    tmp_if_expr$4 = return_value_VSB_len$3 >= (signed long int)*cli->limit ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$4)
    return 1;

  else
    return 0;
}

// VCLI_Quote
// file ../libvarnish/cli_common.c line 85
void VCLI_Quote(struct cli *cli, const char *s)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(cli == ((struct cli *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VCLI_Quote", "../libvarnish/cli_common.c", 88, "(cli) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(cli->magic == 1077466480u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VCLI_Quote", "../libvarnish/cli_common.c", 88, "(cli)->magic == 0x4038d570", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  VSB_quote(cli->sb, s, -1, 0);
}

// VCLI_ReadResult
// file ../libvarnish/cli_common.c line 173
signed int VCLI_ReadResult(signed int fd, unsigned int *status, char **ptr, double tmo)
{
  char res[13l];
  signed int i;
  signed int j;
  unsigned int u;
  unsigned int v;
  unsigned int s;
  char *p = (char *)(void *)0;
  const char *err = "CLI communication error (hdr)";
  if(status == ((unsigned int *)NULL))
    status = &s;

  if(!(ptr == ((char **)NULL)))
    *ptr = (char *)(void *)0;

  i=read_tmo(fd, res, (unsigned int)13, tmo);
  if(i == 13)
  {
    if((signed int)res[3l] == 32)
    {
      if((signed int)res[12l] == 10)
      {
        res[(signed long int)(13 - 1)] = (char)0;
        j=sscanf(res, "%u %u\n", &u, &v);
        if(j == 2)
        {
          err = "CLI communication error (body)";
          *status = u;
          void *return_value_malloc$1;
          return_value_malloc$1=malloc((unsigned long int)((signed long int)v + 1L));
          p = (char *)return_value_malloc$1;
          if(!(p == ((char *)NULL)))
          {
            i=read_tmo(fd, p, v + (unsigned int)1, tmo);
            if(i >= 0)
            {
              if((unsigned int)i == 1u + v)
              {
                if((signed int)p[(signed long int)v] == 10)
                {
                  p[(signed long int)v] = (char)0;
                  if(ptr == ((char **)NULL))
                    free((void *)p);

                  else
                    *ptr = p;
                  return 0;
                }

              }

            }

          }

        }

      }

    }

  }

  if(!(p == ((char *)NULL)))
    free((void *)p);

  *status = (unsigned int)CLIS_COMMS;
  if(!(ptr == ((char **)NULL)))
    *ptr=strdup(err);

  return (signed int)*status;
}

// VCLI_SetResult
// file ../libvarnish/cli_common.c line 93
void VCLI_SetResult(struct cli *cli, unsigned int res)
{
  if(!(cli == ((struct cli *)NULL)))
  {

  __CPROVER_DUMP_L1:
    ;
    do
    {
      if(cli == ((struct cli *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("VCLI_SetResult", "../libvarnish/cli_common.c", 97, "(cli) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(cli->magic == 1077466480u))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          VAS_Fail("VCLI_SetResult", "../libvarnish/cli_common.c", 97, "(cli)->magic == 0x4038d570", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    if(!(res == 200u) || !((signed int)cli->result == CLIS_TRUNCATED))
      cli->result = (enum VCLI_status_e)res;

  }

  else
    printf("CLI result = %u\n", res);
}

// VCLI_WriteResult
// file ../libvarnish/cli_common.c line 106
signed int VCLI_WriteResult(signed int fd, unsigned int status, const char *result)
{
  signed int i;
  signed int l;
  struct iovec iov[3l];
  char nl[2l] = { '\n', 0 };
  unsigned long int len;
  char res[15l];
  do
    if(!(status >= 100u))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VCLI_WriteResult", "../libvarnish/cli_common.c", 117, "status >= 100", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
    if(status >= 1000u)
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("VCLI_WriteResult", "../libvarnish/cli_common.c", 118, "status <= 999", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  len=strlen(result);
  i=snprintf(res, sizeof(char [15l]) /*15ul*/ , "%-3d %-8zd\n", status, len);
  do
    if(!(i == 13))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("VCLI_WriteResult", "../libvarnish/cli_common.c", 124, "i == CLI_LINE0_LEN", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
  {
    unsigned long int return_value_strtoul$5;
    return_value_strtoul$5=strtoul(res + (signed long int)3, (char ** restrict )(void *)0, 10);
    if(!(return_value_strtoul$5 == len))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("VCLI_WriteResult", "../libvarnish/cli_common.c", 125, "strtoul(res + 3, NULL, 10) == len", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

  }
  while((_Bool)0);
  iov[(signed long int)0].iov_base = (void *)res;
  iov[(signed long int)0].iov_len = (unsigned long int)13;
  iov[(signed long int)1].iov_base = (void *)(unsigned long int)result;
  iov[(signed long int)1].iov_len = len;
  iov[(signed long int)2].iov_base = (void *)nl;
  iov[(signed long int)2].iov_len = (unsigned long int)1;
  i = 0;
  l = i;
  for( ; !(i >= 3); i = i + 1)
    l = l + (signed int)iov[(signed long int)i].iov_len;
  signed long int return_value_writev$6;
  return_value_writev$6=writev(fd, iov, 3);
  i = (signed int)return_value_writev$6;
  return (signed int)(i != l);
}

// VCS_Message
// file ../../include/vcs.h line 33
void VCS_Message(const char *progname)
{
  fprintf(stderr, "%s (%s)\n", progname, VCS_version);
  fprintf(stderr, "Copyright (c) 2006 Verdens Gang AS\n");
  fprintf(stderr, "Copyright (c) 2006-2014 Varnish Software AS\n");
}

// VIN_N_Arg
// file ../libvarnish/vin.c line 46
signed int VIN_N_Arg(const char *n_arg, char **name, char **dir, char **vsl)
{
  char nm[4096l];
  char dn[4096l];
  _Bool tmp_if_expr$6;
  if(n_arg == ((const char *)NULL))
    tmp_if_expr$6 = (_Bool)1;

  else
    tmp_if_expr$6 = (signed int)*n_arg == 0 ? (_Bool)1 : (_Bool)0;
  unsigned long int return_value_strlen$5;
  if(tmp_if_expr$6)
  {
    signed int return_value_gethostname$1;
    return_value_gethostname$1=gethostname(nm, sizeof(char [4096l]) /*4096ul*/ );
    if(!(return_value_gethostname$1 == 0))
      return -1;

  }

  else
  {
    return_value_strlen$5=strlen(n_arg);
    if(return_value_strlen$5 >= sizeof(char [4096l]) /*4096ul*/ )
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 36;
      return -1;
    }

    else
      do
      {

      __CPROVER_DUMP_L5:
        ;
        signed int return_value_snprintf$4;
        return_value_snprintf$4=snprintf(nm, sizeof(char [4096l]) /*4096ul*/ , "%s", n_arg);
        if((unsigned long int)return_value_snprintf$4 >= sizeof(char [4096l]) /*4096ul*/ )
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          VAS_Fail("VIN_N_Arg", "../libvarnish/vin.c", 62, "snprintf(nm, sizeof nm, \"%s\", n_arg) < sizeof nm", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
        }

      }
      while((_Bool)0);
  }
  unsigned long int return_value_strlen$10;
  unsigned long int return_value_strlen$11;
  if((signed int)nm[0l] == 47)
    strcpy(dn, nm);

  else
  {
    return_value_strlen$10=strlen("/var/lib/varnish");
    return_value_strlen$11=strlen(nm);
    if(1ul + return_value_strlen$10 + return_value_strlen$11 >= sizeof(char [4096l]) /*4096ul*/ )
    {
      signed int *return_value___errno_location$7;
      return_value___errno_location$7=__errno_location();
      *return_value___errno_location$7 = 36;
      return -1;
    }

    else
      do
      {

      __CPROVER_DUMP_L9:
        ;
        signed int return_value_snprintf$9;
        return_value_snprintf$9=snprintf(dn, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", (const void *)"/var/lib/varnish", (const void *)nm);
        if((unsigned long int)return_value_snprintf$9 >= sizeof(char [4096l]) /*4096ul*/ )
        {
          signed int *return_value___errno_location$8;
          return_value___errno_location$8=__errno_location();
          VAS_Fail("VIN_N_Arg", "../libvarnish/vin.c", 74, "snprintf(dn, sizeof dn, \"%s/%s\", \"/var/lib/varnish\", nm) < sizeof dn", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
        }

      }
      while((_Bool)0);
  }
  unsigned long int return_value_strlen$13;
  return_value_strlen$13=strlen(dn);
  unsigned long int return_value_strlen$14;
  return_value_strlen$14=strlen("_.vsm");
  if(1ul + return_value_strlen$13 + return_value_strlen$14 >= sizeof(char [4096l]) /*4096ul*/ )
  {
    signed int *return_value___errno_location$12;
    return_value___errno_location$12=__errno_location();
    *return_value___errno_location$12 = 36;
    return -1;
  }

  strcat(dn, "/");
  if(!(name == ((char **)NULL)))
  {
    *name=strdup(nm);
    if(!(*name == ((char *)NULL)))
      goto __CPROVER_DUMP_L13;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L13:
    ;
    if(!(dir == ((char **)NULL)))
    {
      *dir=strdup(dn);
      if(!(*dir == ((char *)NULL)))
        goto __CPROVER_DUMP_L14;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L14:
      ;
      if(!(vsl == ((char **)NULL)))
      {
        do
        {

        __CPROVER_DUMP_L15:
          ;
          signed int return_value_snprintf$16;
          return_value_snprintf$16=snprintf(nm, sizeof(char [4096l]) /*4096ul*/ , "%s%s", (const void *)dn, (const void *)"_.vsm");
          if((unsigned long int)return_value_snprintf$16 >= sizeof(char [4096l]) /*4096ul*/ )
          {
            signed int *return_value___errno_location$15;
            return_value___errno_location$15=__errno_location();
            VAS_Fail("VIN_N_Arg", "../libvarnish/vin.c", 96, "snprintf(nm, sizeof nm, \"%s%s\", dn, \"_.vsm\") < sizeof nm", *return_value___errno_location$15, (enum vas_e)VAS_ASSERT);
          }

        }
        while((_Bool)0);
        *vsl=strdup(nm);
        if(!(*vsl == ((char *)NULL)))
          goto __CPROVER_DUMP_L17;

        return -1;
      }

      else
      {

      __CPROVER_DUMP_L17:
        ;
        return 0;
      }
    }
  }
}

// VPF_Close
// file ../../lib/libvarnish/vpf.c line 204
signed int VPF_Close(struct vpf_fh *pfh)
{
  signed int error;
  error=vpf_verify(pfh);
  if(!(error == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = error;
    return -1;
  }

  signed int return_value_close$3;
  return_value_close$3=close(pfh->pf_fd);
  signed int *return_value___errno_location$2;
  if(return_value_close$3 == -1)
  {
    return_value___errno_location$2=__errno_location();
    error = *return_value___errno_location$2;
  }

  free((void *)pfh);
  if(!(error == 0))
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    *return_value___errno_location$4 = error;
    return -1;
  }

  return 0;
}

// VPF_Open
// file ../../include/vpf.h line 35
struct vpf_fh * VPF_Open(const char *path, unsigned int mode, signed int *pidptr)
{
  struct vpf_fh *pfh;
  struct stat sb;
  signed int error;
  signed int fd;
  signed int len;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct vpf_fh) /*4120ul*/ );
  pfh = (struct vpf_fh *)return_value_malloc$1;
  signed int *return_value___errno_location$5;
  if(pfh == ((struct vpf_fh *)NULL))
    return (struct vpf_fh *)(void *)0;

  else
  {
    do
      if(path == ((const char *)NULL))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VPF_Open", "../../lib/libvarnish/vpf.c", 115, "path != NULL", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    len=snprintf(pfh->pf_path, sizeof(char [4097l]) /*4097ul*/ , "%s", path);
    if(len >= (signed int)sizeof(char [4097l]) /*4097*/ )
    {
      free((void *)pfh);
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 36;
      return (struct vpf_fh *)(void *)0;
    }

    fd=flopen(pfh->pf_path, 01 | 0100 | 01000 | 04000, mode);
    if(fd == -1)
    {
      signed int *return_value___errno_location$7;
      return_value___errno_location$7=__errno_location();
      if(*return_value___errno_location$7 == 11)
      {
        if(!(pidptr == ((signed int *)NULL)))
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          *return_value___errno_location$4=vpf_read(pfh->pf_path, pidptr);
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          if(*return_value___errno_location$6 == 0)
          {
            return_value___errno_location$5=__errno_location();
            *return_value___errno_location$5 = 17;
          }

        }

      }

      free((void *)pfh);
      return (struct vpf_fh *)(void *)0;
    }

    signed int return_value_fstat$10;
    return_value_fstat$10=fstat(fd, &sb);
    if(return_value_fstat$10 == -1)
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      error = *return_value___errno_location$8;
      unlink(pfh->pf_path);
      close(fd);
      free((void *)pfh);
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      *return_value___errno_location$9 = error;
      return (struct vpf_fh *)(void *)0;
    }

    pfh->pf_fd = fd;
    pfh->pf_dev = sb.st_dev;
    pfh->pf_ino = sb.st_ino;
    return pfh;
  }
}

// VPF_Remove
// file ../../include/vpf.h line 38
signed int VPF_Remove(struct vpf_fh *pfh)
{
  signed int return_value__VPF_Remove$1;
  return_value__VPF_Remove$1=_VPF_Remove(pfh, 1);
  return return_value__VPF_Remove$1;
}

// VPF_Write
// file ../../include/vpf.h line 36
signed int VPF_Write(struct vpf_fh *pfh)
{
  char pidstr[16l];
  signed int error;
  signed int fd;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1=vpf_verify(pfh);
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  if(!(*return_value___errno_location$2 == 0))
    return -1;

  else
  {
    fd = pfh->pf_fd;
    signed int return_value_ftruncate$5;
    return_value_ftruncate$5=ftruncate(fd, (signed long int)0);
    if(return_value_ftruncate$5 == -1)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      error = *return_value___errno_location$3;
      _VPF_Remove(pfh, 0);
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      *return_value___errno_location$4 = error;
      return -1;
    }

    signed int return_value_getpid$6;
    return_value_getpid$6=getpid();
    error=snprintf(pidstr, sizeof(char [16l]) /*16ul*/ , "%ju", (unsigned long int)return_value_getpid$6);
    do
      if((unsigned long int)error >= sizeof(char [16l]) /*16ul*/ )
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        VAS_Fail("VPF_Write", "../../lib/libvarnish/vpf.c", 192, "error < sizeof pidstr", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    unsigned long int return_value_strlen$10;
    return_value_strlen$10=strlen(pidstr);
    signed long int return_value_pwrite$11;
    return_value_pwrite$11=pwrite(fd, (const void *)pidstr, return_value_strlen$10, (signed long int)0);
    unsigned long int return_value_strlen$12;
    return_value_strlen$12=strlen(pidstr);
    if(!(return_value_pwrite$11 == (signed long int)return_value_strlen$12))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      error = *return_value___errno_location$8;
      _VPF_Remove(pfh, 0);
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      *return_value___errno_location$9 = error;
      return -1;
    }

    return 0;
  }
}

// VRE_compile
// file ../libvarnish/vre.c line 67
struct vre * VRE_compile(const char *pattern, signed int options, const char **errptr, signed int *erroffset)
{
  struct vre *v;
  *errptr = (const char *)(void *)0;
  *erroffset = 0;
  do
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc(sizeof(struct vre) /*32ul*/ , (unsigned long int)1);
    v = (struct vre *)return_value_calloc$1;
    if(!(v == ((struct vre *)NULL)))
      v->magic = 0xe83097dc;

  }
  while((_Bool)0);
  if(v == ((struct vre *)NULL))
  {
    *errptr = "Out of memory for VRE";
    return (struct vre *)(void *)0;
  }

  else
  {
    v->re=pcre_compile(pattern, options, errptr, erroffset, (const unsigned char *)(void *)0);
    if(v->re == ((struct real_pcre *)NULL))
    {
      VRE_free(&v);
      return (struct vre *)(void *)0;
    }

    else
    {
      v->re_extra=pcre_study(v->re, 0, errptr);
      if(!(*errptr == ((const char *)NULL)))
      {
        VRE_free(&v);
        return (struct vre *)(void *)0;
      }

      else
      {
        if(v->re_extra == ((struct pcre_extra *)NULL))
        {
          void *return_value_calloc$2;
          return_value_calloc$2=calloc((unsigned long int)1, sizeof(struct pcre_extra) /*64ul*/ );
          v->re_extra = (struct pcre_extra *)return_value_calloc$2;
          v->my_extra = 1;
          if(v->re_extra == ((struct pcre_extra *)NULL))
          {
            *errptr = "Out of memory for pcre_extra";
            VRE_free(&v);
            return (struct vre *)(void *)0;
          }

        }

        return v;
      }
    }
  }
}

// VRE_exec
// file ../libvarnish/vre.c line 102
signed int VRE_exec(const struct vre *code, const char *subject, signed int length, signed int startoffset, signed int options, signed int *ovector, signed int ovecsize, struct vre_limits *lim)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(code == ((const struct vre *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VRE_exec", "../libvarnish/vre.c", 106, "(code) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(code->magic == 0xe83097dc))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VRE_exec", "../libvarnish/vre.c", 106, "(code)->magic == 0xe83097dc", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  signed int ov[30l];
  if(ovector == ((signed int *)NULL))
  {
    ovector = ov;
    ovecsize = (signed int)(sizeof(signed int [30l]) /*120ul*/  / sizeof(signed int) /*4ul*/ );
  }

  if(!(lim == ((struct vre_limits *)NULL)))
  {
    code->re_extra->match_limit = (unsigned long int)lim->match;
    code->re_extra->flags = code->re_extra->flags | (unsigned long int)0x0002;
    code->re_extra->match_limit_recursion = (unsigned long int)lim->match_recursion;
    code->re_extra->flags = code->re_extra->flags | (unsigned long int)0x0010;
  }

  else
  {
    code->re_extra->flags = code->re_extra->flags & (unsigned long int)~0x0002;
    code->re_extra->flags = code->re_extra->flags & (unsigned long int)~0x0010;
  }
  signed int return_value_pcre_exec$3;
  return_value_pcre_exec$3=pcre_exec(code->re, code->re_extra, subject, length, startoffset, options, ovector, ovecsize);
  return return_value_pcre_exec$3;
}

// VRE_free
// file ../libvarnish/vre.c line 129
void VRE_free(struct vre **vv)
{
  struct vre *v = *vv;
  *vv = (struct vre *)(void *)0;

__CPROVER_DUMP_L1:
  ;
  do
    if(!(v->magic == 0xe83097dc))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VRE_free", "../libvarnish/vre.c", 134, "(v)->magic == 0xe83097dc", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(!(v->re_extra == ((struct pcre_extra *)NULL)))
  {
    if(!(v->my_extra == 0))
      free((void *)v->re_extra);

    else
      pcre_free_study(v->re_extra);
  }

  if(!(v->re == ((struct real_pcre *)NULL)))
    pcre_free((void *)v->re);

  do
  {
    v->magic = (unsigned int)0;
    free((void *)v);
  }
  while((_Bool)0);
}

// VSB_bcat
// file ../../lib/libvarnish/vsb.c line 286
signed int VSB_bcat(struct vsb *s, const void *buf, unsigned long int len)
{
  const char *str = (const char *)buf;
  const char *end = str + (signed long int)len;
  _assert_VSB_integrity("VSB_bcat", s);
  _assert_VSB_state("VSB_bcat", s, 0);
  if(!(s->s_error == 0))
    return -1;

  else
  {
    for( ; !(str >= end); str = str + 1l)
    {
      VSB_put_byte(s, (signed int)*str);
      if(!(s->s_error == 0))
        return -1;

    }
    return 0;
  }
}

// VSB_bcpy
// file ../../lib/libvarnish/vsb.c line 308
signed int VSB_bcpy(struct vsb *s, const void *buf, unsigned long int len)
{
  _assert_VSB_integrity("VSB_bcpy", s);
  _assert_VSB_state("VSB_bcpy", s, 0);
  VSB_clear(s);
  signed int return_value_VSB_bcat$1;
  return_value_VSB_bcat$1=VSB_bcat(s, buf, len);
  return return_value_VSB_bcat$1;
}

// VSB_cat
// file ../../lib/libvarnish/vsb.c line 322
signed int VSB_cat(struct vsb *s, const char *str)
{
  _assert_VSB_integrity("VSB_cat", s);
  _assert_VSB_state("VSB_cat", s, 0);
  const char *tmp_post$1;
  if(!(s->s_error == 0))
    return -1;

  else
  {
    while(!((signed int)*str == 0))
    {
      tmp_post$1 = str;
      str = str + 1l;
      VSB_put_byte(s, (signed int)*tmp_post$1);
      if(!(s->s_error == 0))
        return -1;

    }
    return 0;
  }
}

// VSB_clear
// file ../../lib/libvarnish/vsb.c line 225
void VSB_clear(struct vsb *s)
{
  _assert_VSB_integrity("VSB_clear", s);
  do
    s->s_flags = s->s_flags & ~0x00020000;
  while((_Bool)0);
  s->s_error = 0;
  s->s_len = (signed long int)0;
}

// VSB_cpy
// file ../../lib/libvarnish/vsb.c line 343
signed int VSB_cpy(struct vsb *s, const char *str)
{
  _assert_VSB_integrity("VSB_cpy", s);
  _assert_VSB_state("VSB_cpy", s, 0);
  VSB_clear(s);
  signed int return_value_VSB_cat$1;
  return_value_VSB_cat$1=VSB_cat(s, str);
  return return_value_VSB_cat$1;
}

// VSB_data
// file ../../lib/libvarnish/vsb.c line 492
char * VSB_data(struct vsb *s)
{
  _assert_VSB_integrity("VSB_data", s);
  _assert_VSB_state("VSB_data", s, 0x00020000);
  return s->s_buf;
}

// VSB_delete
// file ../../lib/libvarnish/vsb.c line 520
void VSB_delete(struct vsb *s)
{
  signed int isdyn;
  _assert_VSB_integrity("VSB_delete", s);
  if(!((0x00010000 & s->s_flags) == 0))
    free((void *)s->s_buf);

  isdyn = s->s_flags & 0x00080000;
  memset((void *)s, 0, sizeof(struct vsb) /*48ul*/ );
  if(!(isdyn == 0))
    free((void *)s);

}

// VSB_done
// file ../../lib/libvarnish/vsb.c line 539
signed int VSB_done(struct vsb *s)
{
  return s->s_flags & 0x00020000;
}

// VSB_error
// file ../../lib/libvarnish/vsb.c line 464
signed int VSB_error(struct vsb *s)
{
  return s->s_error;
}

// VSB_extend
// file ../../lib/libvarnish/vsb.c line 138
static signed int VSB_extend(struct vsb *s, signed int addlen)
{
  char *newbuf;
  signed int newsize;
  if((0x00000001 & s->s_flags) == 0)
    return -1;

  else
  {
    newsize=VSB_extendsize((signed int)(s->s_size + (signed long int)addlen));
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)newsize);
    newbuf = (char *)return_value_malloc$1;
    if(newbuf == ((char *)NULL))
      return -1;

    else
    {
      memcpy((void *)newbuf, (const void *)s->s_buf, (unsigned long int)s->s_size);
      if(!((0x00010000 & s->s_flags) == 0))
        free((void *)s->s_buf);

      else
        do
          s->s_flags = s->s_flags | 0x00010000;
        while((_Bool)0);
      s->s_buf = newbuf;
      s->s_size = (signed long int)newsize;
      return 0;
    }
  }
}

// VSB_extend$link1
// file ../libvarnish/vsb.c line 138
static signed int VSB_extend$link1(struct vsb *s$link1, signed int addlen$link1)
{
  char *newbuf$link1;
  signed int newsize$link1;
  if((0x00000001 & s$link1->s_flags) == 0)
    return -1;

  else
  {
    newsize$link1=VSB_extendsize$link1((signed int)(s$link1->s_size + (signed long int)addlen$link1));
    void *return_value_malloc$1$link1;
    return_value_malloc$1$link1=malloc((unsigned long int)newsize$link1);
    newbuf$link1 = (char *)return_value_malloc$1$link1;
    if(newbuf$link1 == ((char *)NULL))
      return -1;

    else
    {
      memcpy((void *)newbuf$link1, (const void *)s$link1->s_buf, (unsigned long int)s$link1->s_size);
      if(!((0x00010000 & s$link1->s_flags) == 0))
        free((void *)s$link1->s_buf);

      else
        do
          s$link1->s_flags = s$link1->s_flags | 0x00010000;
        while((_Bool)0);
      s$link1->s_buf = newbuf$link1;
      s$link1->s_size = (signed long int)newsize$link1;
      return 0;
    }
  }
}

// VSB_extendsize
// file ../../lib/libvarnish/vsb.c line 119
static signed int VSB_extendsize(signed int size)
{
  signed int newsize;
  if(!(size >= 4096))
  {
    newsize = 16;
    for( ; !(newsize >= size); newsize = newsize * 2)
      ;
  }

  else
    newsize = size + (4096 - 1) & ~(4096 - 1);
  do
    if(!(newsize >= size))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSB_extendsize", "../../lib/libvarnish/vsb.c", 130, "newsize >= size", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  return newsize;
}

// VSB_extendsize$link1
// file ../libvarnish/vsb.c line 119
static signed int VSB_extendsize$link1(signed int size$link1)
{
  signed int newsize$link1;
  if(!(size$link1 >= 4096))
  {
    newsize$link1 = 16;
    for( ; !(newsize$link1 >= size$link1); newsize$link1 = newsize$link1 * 2)
      ;
  }

  else
    newsize$link1 = size$link1 + (4096 - 1) & ~(4096 - 1);
  do
    if(!(newsize$link1 >= size$link1))
    {
      signed int *return_value___errno_location$1$link1;
      return_value___errno_location$1$link1=__errno_location();
      VAS_Fail("VSB_extendsize", "../libvarnish/vsb.c", 130, "newsize >= size", *return_value___errno_location$1$link1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  return newsize$link1;
}

// VSB_finish
// file ../../lib/libvarnish/vsb.c line 474
signed int VSB_finish(struct vsb *s)
{
  _assert_VSB_integrity("VSB_finish", s);
  _assert_VSB_state("VSB_finish", s, 0);
  s->s_buf[s->s_len] = (char)0;
  do
    s->s_flags = s->s_flags | 0x00020000;
  while((_Bool)0);
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = s->s_error;
  if(!(s->s_error == 0))
    return -1;

  else
    return 0;
}

// VSB_len
// file ../../lib/libvarnish/vsb.c line 505
signed long int VSB_len(struct vsb *s)
{
  _assert_VSB_integrity("VSB_len", s);
  if(!(s->s_error == 0))
    return (signed long int)-1;

  else
    return s->s_len;
}

// VSB_new
// file ../../lib/libvarnish/vsb.c line 198
struct vsb * VSB_new(struct vsb *s, char *buf, signed int length, signed int flags)
{
  do
    if(!(length >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSB_new", "../../lib/libvarnish/vsb.c", 202, "length >= 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
    if(!((-65536 & flags) == 0))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("VSB_new", "../../lib/libvarnish/vsb.c", 204, "(flags & ~0x0000ffff) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  flags = flags & 0x0000ffff;
  struct vsb *return_value_VSB_newbuf$3;
  if(!(s == ((struct vsb *)NULL)))
  {
    return_value_VSB_newbuf$3=VSB_newbuf(s, buf, length, flags);
    return return_value_VSB_newbuf$3;
  }

  else
  {
    void *return_value_malloc$4;
    return_value_malloc$4=malloc(sizeof(struct vsb) /*48ul*/ );
    s = (struct vsb *)return_value_malloc$4;
    if(s == ((struct vsb *)NULL))
      return (struct vsb *)(void *)0;

    else
    {
      struct vsb *return_value_VSB_newbuf$5;
      return_value_VSB_newbuf$5=VSB_newbuf(s, buf, length, flags);
      if(return_value_VSB_newbuf$5 == ((struct vsb *)NULL))
      {
        free((void *)s);
        return (struct vsb *)(void *)0;
      }

      else
      {
        do
          s->s_flags = s->s_flags | 0x00080000;
        while((_Bool)0);
        return s;
      }
    }
  }
}

// VSB_newbuf
// file ../../lib/libvarnish/vsb.c line 165
static struct vsb * VSB_newbuf(struct vsb *s, char *buf, signed int length, signed int flags)
{
  memset((void *)s, 0, sizeof(struct vsb) /*48ul*/ );
  s->magic = (unsigned int)0x4a82dd8a;
  s->s_flags = flags;
  s->s_size = (signed long int)length;
  s->s_buf = buf;
  if((0x00000001 & s->s_flags) == 0)
    do
      if(!(s->s_size >= 2l))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("VSB_newbuf", "../../lib/libvarnish/vsb.c", 176, "s->s_size > 1", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  signed int return_value_VSB_extendsize$2;
  if(!(s->s_buf == ((char *)NULL)))
    return s;

  else
  {
    if(!((0x00000001 & flags) == 0))
    {
      return_value_VSB_extendsize$2=VSB_extendsize((signed int)s->s_size);
      s->s_size = (signed long int)return_value_VSB_extendsize$2;
    }

    void *return_value_malloc$3;
    return_value_malloc$3=malloc((unsigned long int)s->s_size);
    s->s_buf = (char *)return_value_malloc$3;
    if(s->s_buf == ((char *)NULL))
      return (struct vsb *)(void *)0;

    else
    {
      do
        s->s_flags = s->s_flags | 0x00010000;
      while((_Bool)0);
      return s;
    }
  }
}

// VSB_newbuf$link1
// file ../libvarnish/vsb.c line 165
static struct vsb * VSB_newbuf$link1(struct vsb *s$link1, char *buf$link1, signed int length$link1, signed int flags$link1)
{
  memset((void *)s$link1, 0, sizeof(struct vsb) /*48ul*/ );
  s$link1->magic = (unsigned int)0x4a82dd8a;
  s$link1->s_flags = flags$link1;
  s$link1->s_size = (signed long int)length$link1;
  s$link1->s_buf = buf$link1;
  if((0x00000001 & s$link1->s_flags) == 0)
    do
      if(!(s$link1->s_size >= 2l))
      {
        signed int *return_value___errno_location$1$link1;
        return_value___errno_location$1$link1=__errno_location();
        VAS_Fail("VSB_newbuf", "../libvarnish/vsb.c", 176, "s->s_size > 1", *return_value___errno_location$1$link1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  signed int return_value_VSB_extendsize$2$link1;
  if(!(s$link1->s_buf == ((char *)NULL)))
    return s$link1;

  else
  {
    if(!((0x00000001 & flags$link1) == 0))
    {
      return_value_VSB_extendsize$2$link1=VSB_extendsize$link1((signed int)s$link1->s_size);
      s$link1->s_size = (signed long int)return_value_VSB_extendsize$2$link1;
    }

    void *return_value_malloc$3$link1;
    return_value_malloc$3$link1=malloc((unsigned long int)s$link1->s_size);
    s$link1->s_buf = (char *)return_value_malloc$3$link1;
    if(s$link1->s_buf == ((char *)NULL))
      return (struct vsb *)(void *)0;

    else
    {
      do
        s$link1->s_flags = s$link1->s_flags | 0x00010000;
      while((_Bool)0);
      return s$link1;
    }
  }
}

// VSB_printf
// file ../../lib/libvarnish/vsb.c line 417
signed int VSB_printf(struct vsb *s, const char *fmt, ...)
{
  void **ap;
  signed int result;
  ap = (void **)&fmt;
  result=VSB_vprintf(s, fmt, ap);
  ap = ((void **)NULL);
  return result;
}

// VSB_put_byte
// file ../../lib/libvarnish/vsb.c line 265
static void VSB_put_byte(struct vsb *s, signed int c)
{
  _assert_VSB_integrity("VSB_put_byte", s);
  _assert_VSB_state("VSB_put_byte", s, 0);
  signed long int tmp_post$2;
  if(s->s_error == 0)
  {
    if(!(s->s_size + -(1l + s->s_len) >= 1l))
    {
      signed int return_value_VSB_extend$1;
      return_value_VSB_extend$1=VSB_extend(s, 1);
      if(!(return_value_VSB_extend$1 >= 0))
        s->s_error = 12;

      if(!(s->s_error == 0))
        goto __CPROVER_DUMP_L4;

    }

    tmp_post$2 = s->s_len;
    s->s_len = s->s_len + 1l;
    s->s_buf[tmp_post$2] = (char)c;
  }


__CPROVER_DUMP_L4:
  ;
}

// VSB_put_byte$link1
// file ../libvarnish/vsb.c line 265
static void VSB_put_byte$link1(struct vsb *s$link1, signed int c$link1)
{
  _assert_VSB_integrity$link1("VSB_put_byte", s$link1);
  _assert_VSB_state$link1("VSB_put_byte", s$link1, 0);
  signed long int tmp_post$2$link1;
  if(s$link1->s_error == 0)
  {
    if(!(s$link1->s_size + -(1l + s$link1->s_len) >= 1l))
    {
      signed int return_value_VSB_extend$1$link1;
      return_value_VSB_extend$1$link1=VSB_extend$link1(s$link1, 1);
      if(!(return_value_VSB_extend$1$link1 >= 0))
        s$link1->s_error = 12;

      if(!(s$link1->s_error == 0))
        goto __CPROVER_DUMP_L4;

    }

    tmp_post$2$link1 = s$link1->s_len;
    s$link1->s_len = s$link1->s_len + 1l;
    s$link1->s_buf[tmp_post$2$link1] = (char)c$link1;
  }


__CPROVER_DUMP_L4:
  ;
}

// VSB_putc
// file ../../lib/libvarnish/vsb.c line 432
signed int VSB_putc(struct vsb *s, signed int c)
{
  VSB_put_byte(s, c);
  if(!(s->s_error == 0))
    return -1;

  else
    return 0;
}

// VSB_quote
// file ../../lib/libvarnish/vsb.c line 549
void VSB_quote(struct vsb *s, const char *p, signed int len, signed int how)
{
  const char *q;
  signed int quote = 0;
  (void)how;
  unsigned long int return_value_strlen$1;
  if(len == -1)
  {
    return_value_strlen$1=strlen(p);
    len = (signed int)return_value_strlen$1;
  }

  q = p;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  for( ; !(q >= p + (signed long int)len); q = q + 1l)
  {
    const unsigned short int **return_value___ctype_b_loc$2;
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if((32768 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*q]) == 0)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)*q == 34 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)*q == 92 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
    {
      quote = quote + 1;
      break;
    }

  }
  const unsigned short int **return_value___ctype_b_loc$5;
  if(quote == 0)
    VSB_bcat(s, (const void *)p, (unsigned long int)len);

  else
  {
    VSB_putc(s, 34);
    q = p;
    for( ; !(q >= p + (signed long int)len); q = q + 1l)
      switch((signed int)*q)
      {
        case 32:
        {
          VSB_putc(s, (signed int)*q);
          break;
        }
        case 92:

        case 34:
        {
          VSB_putc(s, 92);
          VSB_putc(s, (signed int)*q);
          break;
        }
        case 10:
        {
          VSB_cat(s, "\\n");
          break;
        }
        case 13:
        {
          VSB_cat(s, "\\r");
          break;
        }
        case 9:
        {
          VSB_cat(s, "\\t");
          break;
        }
        default:
        {
          return_value___ctype_b_loc$5=__ctype_b_loc();
          if(!((32768 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)*q]) == 0))
            VSB_putc(s, (signed int)*q);

          else
            VSB_printf(s, "\\%o", (signed int)*q & 0xff);
        }
      }
    VSB_putc(s, 34);
  }
}

// VSB_setpos
// file ../../lib/libvarnish/vsb.c line 241
signed int VSB_setpos(struct vsb *s, signed long int pos)
{
  _assert_VSB_integrity("VSB_setpos", s);
  _assert_VSB_state("VSB_setpos", s, 0);
  do
    if(!(pos >= 0l))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSB_setpos", "../../lib/libvarnish/vsb.c", 248, "pos >= 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
    if(pos >= s->s_size)
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("VSB_setpos", "../../lib/libvarnish/vsb.c", 251, "pos < s->s_size", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  _Bool tmp_if_expr$3;
  if(!(pos >= 0l))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = pos > s->s_len ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
    return -1;

  else
  {
    s->s_len = pos;
    return 0;
  }
}

// VSB_trim
// file ../../lib/libvarnish/vsb.c line 445
signed int VSB_trim(struct vsb *s)
{
  _assert_VSB_integrity("VSB_trim", s);
  _assert_VSB_state("VSB_trim", s, 0);
  const unsigned short int **return_value___ctype_b_loc$1;
  if(!(s->s_error == 0))
    return -1;

  else
  {
    for( ; s->s_len >= 1l; s->s_len = s->s_len - 1l)
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)s->s_buf[s->s_len + -1l]]) == 0)
        break;

    }
    return 0;
  }
}

// VSB_unquote
// file ../../lib/libvarnish/vsb.c line 603
const char * VSB_unquote(struct vsb *s, const char *p, signed int len, signed int how)
{
  const char *q;
  char *r;
  unsigned long int u;
  char c;
  (void)how;
  unsigned long int return_value_strlen$1;
  if(len == -1)
  {
    return_value_strlen$1=strlen(p);
    len = (signed int)return_value_strlen$1;
  }

  q = p;
  signed int *return_value___errno_location$2;
  signed int *return_value___errno_location$3;
  for( ; !(q >= p + (signed long int)len); q = q + 1l)
    if(!((signed int)*q == 92))
      VSB_bcat(s, (const void *)q, (unsigned long int)1);

    else
    {
      q = q + 1l;
      if(q >= p + (signed long int)len)
        return "Incomplete '\\'-sequence at end of string";

      switch((signed int)*q)
      {
        case 110:
        {
          VSB_bcat(s, (const void *)"\n", (unsigned long int)1);
          break;
        }
        case 114:
        {
          VSB_bcat(s, (const void *)"\r", (unsigned long int)1);
          break;
        }
        case 116:
        {
          VSB_bcat(s, (const void *)"\t", (unsigned long int)1);
          break;
        }
        case 48:

        case 49:

        case 50:

        case 51:

        case 52:

        case 53:

        case 54:

        case 55:
        {
          return_value___errno_location$2=__errno_location();
          *return_value___errno_location$2 = 0;
          u=strtoul(q, &r, 8);
          return_value___errno_location$3=__errno_location();
          if(!((18446744073709551360ul & u) == 0ul) || !(*return_value___errno_location$3 == 0))
            return "\\ooo sequence out of range";

          c = (char)u;
          VSB_bcat(s, (const void *)&c, (unsigned long int)1);
          q = r - (signed long int)1;
          break;
        }
        default:
          VSB_bcat(s, (const void *)q, (unsigned long int)1);
      }
    }
  return (const char *)(void *)0;
}

// VSB_vprintf
// file ../../lib/libvarnish/vsb.c line 357
signed int VSB_vprintf(struct vsb *s, const char *fmt, void **ap)
{
  void **ap_copy;
  signed int len;
  _assert_VSB_integrity("VSB_vprintf", s);
  _assert_VSB_state("VSB_vprintf", s, 0);
  do
    if(fmt == ((const char *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSB_vprintf", "../../lib/libvarnish/vsb.c", 366, "fmt != ((void *)0)", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  _Bool tmp_if_expr$3;
  signed int return_value_VSB_extend$2;
  if(!(s->s_error == 0))
    return -1;

  else
  {
    do
    {
      ap_copy = (void **)ap;
      len=vsnprintf(&s->s_buf[s->s_len], (unsigned long int)((s->s_size - (s->s_len + (signed long int)1)) + (signed long int)1), fmt, ap_copy);
      ap_copy = ((void **)NULL);
      if(!(s->s_size + -(1l + s->s_len) >= (signed long int)len))
      {
        return_value_VSB_extend$2=VSB_extend(s, (signed int)((signed long int)len - (s->s_size - (s->s_len + (signed long int)1))));
        tmp_if_expr$3 = return_value_VSB_extend$2 == 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
    }
    while(tmp_if_expr$3);
    if(!(s->s_size + -(1l + s->s_len) >= (signed long int)len))
      len = (signed int)(s->s_size - (s->s_len + (signed long int)1));

    s->s_len = s->s_len + (signed long int)len;
    if(s->s_len >= s->s_size + -1l)
    {
      if((0x00000001 & s->s_flags) == 0)
        s->s_error = 12;

    }

    do
      if(s->s_len >= s->s_size)
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        VAS_Fail("VSB_vprintf", "../../lib/libvarnish/vsb.c", 406, "s->s_len < s->s_size", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    if(!(s->s_error == 0))
      return -1;

    else
      return 0;
  }
}

// VSC_Arg
// file vsc.c line 289
signed int VSC_Arg(struct VSM_data *vd, signed int arg, const char *opt)
{
  signed int return_value_vsc_f_arg$1;
  signed int return_value_VSM_n_Arg$2;
  signed int return_value_VSM_N_Arg$3;
  switch(arg)
  {
    case 102:
    {
      return_value_vsc_f_arg$1=vsc_f_arg(vd, opt);
      return return_value_vsc_f_arg$1;
    }
    case 110:
    {
      return_value_VSM_n_Arg$2=VSM_n_Arg(vd, opt);
      return return_value_VSM_n_Arg$2;
    }
    case 78:
    {
      return_value_VSM_N_Arg$3=VSM_N_Arg(vd, opt);
      return return_value_VSM_N_Arg$3;
    }
    default:
      return 0;
  }
}

// VSC_Delete
// file vsm_api.h line 61
void VSC_Delete(struct VSM_data *vd)
{
  struct vsc *vsc;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSC_Delete", "vsc.c", 165, "(vd) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->magic == 1849415323u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSC_Delete", "vsc.c", 165, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  vsc = vd->vsc;
  vd->vsc = (struct vsc *)(void *)0;

__CPROVER_DUMP_L5:
  ;
  do
  {
    if(vsc == ((struct vsc *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("VSC_Delete", "vsc.c", 168, "(vsc) != NULL", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsc->magic == 863196490u))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        VAS_Fail("VSC_Delete", "vsc.c", 168, "(vsc)->magic == 0x3373554a", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  vsc_delete_sf_list(vsc);
  vsc_delete_pt_list(vsc);
  vsc_delete_vf_list(vsc);
  do
  {
    vsc->magic = (unsigned int)0;
    free((void *)vsc);
  }
  while((_Bool)0);
}

// VSC_Get
// file vsc.c line 323
void * VSC_Get(struct VSM_data *vd, struct VSM_fantom *fantom, const char *type, const char *ident)
{
  struct VSM_fantom f2 = { .chunk=((struct VSM_chunk *)NULL), .b=NULL, .e=NULL,
    .priv=(unsigned long int)0, .class={ (char)0, 0, 0, 0, 0, 0, 0, 0 },
    .type={ (char)0, 0, 0, 0, 0, 0, 0, 0 },
    .ident={ (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
  if(fantom == ((struct VSM_fantom *)NULL))
    fantom = &f2;

  enum VSM_valid_e return_value_VSM_StillValid$2;
  return_value_VSM_StillValid$2=VSM_StillValid(vd, fantom);
  signed int return_value_VSM_Get$1;
  if((signed int)return_value_VSM_StillValid$2 == VSM_invalid)
  {
    return_value_VSM_Get$1=VSM_Get(vd, fantom, "Stat", type, ident);
    if(!(return_value_VSM_Get$1 == 0))
      goto __CPROVER_DUMP_L2;

    return (void *)0;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    return (void *)fantom->b;
  }
}

// VSC_Iter
// file vsc.c line 507
signed int VSC_Iter(struct VSM_data *vd, struct VSM_fantom *fantom, signed int (*func)(void *, struct VSC_point *), void *priv)
{
  struct vsc *vsc;
  vsc=vsc_setup(vd);
  struct vsc_pt *pt;
  signed int i;
  enum VSM_valid_e return_value_VSM_StillValid$1;
  return_value_VSM_StillValid$1=VSM_StillValid(vd, &vsc->iter_fantom);
  if(!((signed int)return_value_VSM_StillValid$1 == VSM_valid))
  {
    func(priv, (struct VSC_point *)(void *)0);
    vsc_build_vf_list(vd);
    vsc_build_pt_list(vd);
    vsc_filter_pt_list(vd);
  }

  if(!(fantom == ((struct VSM_fantom *)NULL)))
    *fantom = vsc->iter_fantom;

  pt = (&vsc->pt_list)->vtqh_first;
  if(!(pt == ((struct vsc_pt *)NULL)))
  {
    i=func(priv, &pt->point);
    if(!(i == 0))
      return i;

    pt = pt->list.vtqe_next;
  }

  return 0;
}

// VSC_LevelDesc
// file vsc.c line 535
struct VSC_level_desc * VSC_LevelDesc(unsigned int level)
{
  switch(level)
  {
    case (unsigned int)0:
      return &VSC_level_desc_info;
    case (unsigned int)1:
      return &VSC_level_desc_diag;
    case (unsigned int)2:
      return &VSC_level_desc_debug;
    default:
      return (struct VSC_level_desc *)(void *)0;
  }
}

// VSC_Main
// file vsc.c line 313
struct VSC_C_main * VSC_Main(struct VSM_data *vd, struct VSM_fantom *fantom)
{
  void *return_value_VSC_Get$1;
  return_value_VSC_Get$1=VSC_Get(vd, fantom, VSC_type_main, "");
  return (struct VSC_C_main *)return_value_VSC_Get$1;
}

// VSC_Mgt
// file vsc.c line 304
struct VSC_C_mgt * VSC_Mgt(struct VSM_data *vd, struct VSM_fantom *fantom)
{
  void *return_value_VSC_Get$1;
  return_value_VSC_Get$1=VSC_Get(vd, fantom, VSC_type_mgt, "");
  return (struct VSC_C_mgt *)return_value_VSC_Get$1;
}

// VSLQ_Delete
// file ../../include/vapi/vsl.h line 481
void VSLQ_Delete(struct VSLQ **pvslq)
{
  struct VSLQ *vslq;
  struct vtx *vtx;

__CPROVER_DUMP_L1:
  ;
  do
    if(pvslq == ((struct VSLQ **)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSLQ_Delete", "vsl_dispatch.c", 1100, "(pvslq) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vslq = *pvslq;
  *pvslq = (struct VSLQ *)(void *)0;

__CPROVER_DUMP_L3:
  ;
  do
  {
    if(vslq == ((struct VSLQ *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("VSLQ_Delete", "vsl_dispatch.c", 1103, "(vslq) != NULL", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vslq->magic == 598261399u))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("VSLQ_Delete", "vsl_dispatch.c", 1103, "(vslq)->magic == 0x23A8BE97", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  VSLQ_Flush(vslq, (signed int (*)(struct VSL_data *, struct VSL_transaction * const *, void *))(void *)0, (void *)0);

__CPROVER_DUMP_L7:
  ;
  do
    if(!(vslq->incomplete.vtqh_first == ((struct vtx *)NULL)))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("VSLQ_Delete", "vsl_dispatch.c", 1106, "(((&vslq->incomplete)->vtqh_first == ((void *)0))) != 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  while(!(vslq->ready.vtqh_first == ((struct vtx *)NULL)))
  {
    vtx = (&vslq->ready)->vtqh_first;

  __CPROVER_DUMP_L10:
    ;
    do
    {
      if(vtx == ((struct vtx *)NULL))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        VAS_Fail("VSLQ_Delete", "vsl_dispatch.c", 1110, "(vtx) != NULL", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(vtx->magic == 0xACC21D09))
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          VAS_Fail("VSLQ_Delete", "vsl_dispatch.c", 1110, "(vtx)->magic == 0xACC21D09", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {
      if(!(vtx->list_vtx.vtqe_next == ((struct vtx *)NULL)))
        vtx->list_vtx.vtqe_next->list_vtx.vtqe_prev = vtx->list_vtx.vtqe_prev;

      else
        (&vslq->ready)->vtqh_last = vtx->list_vtx.vtqe_prev;
      *vtx->list_vtx.vtqe_prev = vtx->list_vtx.vtqe_next;
    }
    while((_Bool)0);

  __CPROVER_DUMP_L17:
    ;
    do
      if((8u & vtx->flags) == 0u)
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        VAS_Fail("VSLQ_Delete", "vsl_dispatch.c", 1112, "(vtx->flags & 0x8) != 0", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    vtx_retire(vslq, &vtx);
  }

__CPROVER_DUMP_L19:
  ;
  do
    if(!(vslq->n_outstanding == 0u))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      VAS_Fail("VSLQ_Delete", "vsl_dispatch.c", 1115, "(vslq->n_outstanding) == 0", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  VSL_DeleteCursor(vslq->c);
  vslq->c = (struct VSL_cursor *)(void *)0;
  if(!(vslq->query == ((struct vslq_query *)NULL)))
    vslq_deletequery(&vslq->query);


__CPROVER_DUMP_L21:
  ;
  do
    if(!(vslq->query == ((struct vslq_query *)NULL)))
    {
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      VAS_Fail("VSLQ_Delete", "vsl_dispatch.c", 1122, "(vslq->query) == 0", *return_value___errno_location$9, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  while(!(vslq->cache.vtqh_first == ((struct vtx *)NULL)))
  {

  __CPROVER_DUMP_L24:
    ;
    do
      if(vslq->n_cache == 0u)
      {
        signed int *return_value___errno_location$10;
        return_value___errno_location$10=__errno_location();
        VAS_Fail("VSLQ_Delete", "vsl_dispatch.c", 1125, "(vslq->n_cache) != 0", *return_value___errno_location$10, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    vtx = (&vslq->cache)->vtqh_first;
    do
    {
      if(!(vtx->list_child.vtqe_next == ((struct vtx *)NULL)))
        vtx->list_child.vtqe_next->list_child.vtqe_prev = vtx->list_child.vtqe_prev;

      else
        (&vslq->cache)->vtqh_last = vtx->list_child.vtqe_prev;
      *vtx->list_child.vtqe_prev = vtx->list_child.vtqe_next;
    }
    while((_Bool)0);
    vslq->n_cache = vslq->n_cache - 1u;
    do
    {
      vtx->magic = (unsigned int)0;
      free((void *)vtx);
    }
    while((_Bool)0);
  }
  do
  {
    vslq->magic = (unsigned int)0;
    free((void *)vslq);
  }
  while((_Bool)0);
}

// VSLQ_Dispatch
// file ../../include/vapi/vsl.h line 486
signed int VSLQ_Dispatch(struct VSLQ *vslq, signed int (*func)(struct VSL_data *, struct VSL_transaction * const *, void *), void *priv)
{
  signed int i;
  signed int r;
  double now;
  struct vtx *vtx;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vslq == ((struct VSLQ *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSLQ_Dispatch", "vsl_dispatch.c", 1296, "(vslq) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vslq->magic == 598261399u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSLQ_Dispatch", "vsl_dispatch.c", 1296, "(vslq)->magic == 0x23A8BE97", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  signed int return_value_vslq_raw$3;
  if((signed int)vslq->grouping == VSL_g_raw)
  {
    return_value_vslq_raw$3=vslq_raw(vslq, func, priv);
    return return_value_vslq_raw$3;
  }

  else
  {
    r=vslq_shmref_check(vslq);
    if(!(r == 0))
      return r;

    else
    {
      i=vslq_next(vslq);
      if(!(i >= 0))
        return i;

      else
      {
        now=VTIM_mono();
        while(!(vslq->incomplete.vtqh_first == ((struct vtx *)NULL)))
        {
          vtx = (&vslq->incomplete)->vtqh_first;

        __CPROVER_DUMP_L9:
          ;
          do
          {
            if(vtx == ((struct vtx *)NULL))
            {
              signed int *return_value___errno_location$4;
              return_value___errno_location$4=__errno_location();
              VAS_Fail("VSLQ_Dispatch", "vsl_dispatch.c", 1317, "(vtx) != NULL", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
            }

            do
              if(!(vtx->magic == 0xACC21D09))
              {
                signed int *return_value___errno_location$5;
                return_value___errno_location$5=__errno_location();
                VAS_Fail("VSLQ_Dispatch", "vsl_dispatch.c", 1317, "(vtx)->magic == 0xACC21D09", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
              }

            while((_Bool)0);
          }
          while((_Bool)0);
          if(now + -vtx->t_start < vslq->vsl->T_opt)
            break;

          vtx_force(vslq, vtx, "timeout");

        __CPROVER_DUMP_L13:
          ;
          do
            if((4u & vtx->flags) == 0u)
            {
              signed int *return_value___errno_location$6;
              return_value___errno_location$6=__errno_location();
              VAS_Fail("VSLQ_Dispatch", "vsl_dispatch.c", 1321, "(vtx->flags & 0x4) != 0", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
            }

          while((_Bool)0);
        }
        while(!((unsigned int)vslq->vsl->L_opt >= vslq->n_outstanding))
        {
          vtx = (&vslq->incomplete)->vtqh_first;

        __CPROVER_DUMP_L16:
          ;
          do
          {
            if(vtx == ((struct vtx *)NULL))
            {
              signed int *return_value___errno_location$7;
              return_value___errno_location$7=__errno_location();
              VAS_Fail("VSLQ_Dispatch", "vsl_dispatch.c", 1327, "(vtx) != NULL", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
            }

            do
              if(!(vtx->magic == 0xACC21D09))
              {
                signed int *return_value___errno_location$8;
                return_value___errno_location$8=__errno_location();
                VAS_Fail("VSLQ_Dispatch", "vsl_dispatch.c", 1327, "(vtx)->magic == 0xACC21D09", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
              }

            while((_Bool)0);
          }
          while((_Bool)0);
          vtx_force(vslq, vtx, "store overflow");

        __CPROVER_DUMP_L20:
          ;
          do
            if((4u & vtx->flags) == 0u)
            {
              signed int *return_value___errno_location$9;
              return_value___errno_location$9=__errno_location();
              VAS_Fail("VSLQ_Dispatch", "vsl_dispatch.c", 1329, "(vtx->flags & 0x4) != 0", *return_value___errno_location$9, (enum vas_e)VAS_ASSERT);
            }

          while((_Bool)0);
          r=vslq_process_ready(vslq, func, priv);
          if(!(r == 0))
            return r;

        }
        if(!(vslq->ready.vtqh_first == ((struct vtx *)NULL)))
        {
          r=vslq_process_ready(vslq, func, priv);
          if(r == 0)
            goto __CPROVER_DUMP_L24;

          return r;
        }

        else
        {

        __CPROVER_DUMP_L24:
          ;
          return i;
        }
      }
    }
  }
}

// VSLQ_Flush
// file ../../include/vapi/vsl.h line 502
signed int VSLQ_Flush(struct VSLQ *vslq, signed int (*func)(struct VSL_data *, struct VSL_transaction * const *, void *), void *priv)
{
  struct vtx *vtx;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vslq == ((struct VSLQ *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSLQ_Flush", "vsl_dispatch.c", 1355, "(vslq) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vslq->magic == 598261399u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSLQ_Flush", "vsl_dispatch.c", 1355, "(vslq)->magic == 0x23A8BE97", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  while(!(vslq->incomplete.vtqh_first == ((struct vtx *)NULL)))
  {
    vtx = (&vslq->incomplete)->vtqh_first;

  __CPROVER_DUMP_L6:
    ;
    do
    {
      if(vtx == ((struct vtx *)NULL))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("VSLQ_Flush", "vsl_dispatch.c", 1359, "(vtx) != NULL", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(vtx->magic == 0xACC21D09))
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          VAS_Fail("VSLQ_Flush", "vsl_dispatch.c", 1359, "(vtx)->magic == 0xACC21D09", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);

  __CPROVER_DUMP_L10:
    ;
    do
      if(!((4u & vtx->flags) == 0u))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        VAS_Fail("VSLQ_Flush", "vsl_dispatch.c", 1360, "(vtx->flags & 0x4) == 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    vtx_force(vslq, vtx, "flush");
  }
  signed int return_value_vslq_process_ready$6;
  return_value_vslq_process_ready$6=vslq_process_ready(vslq, func, priv);
  return return_value_vslq_process_ready$6;
}

// VSLQ_Name2Grouping
// file ../../include/vapi/vsl.h line 229
signed int VSLQ_Name2Grouping(const char *name, signed int l)
{
  signed int i;
  signed int n;
  unsigned long int return_value_strlen$1;
  if(l == -1)
  {
    return_value_strlen$1=strlen(name);
    l = (signed int)return_value_strlen$1;
  }

  n = -1;
  i = 0;
  for( ; !(i >= VSL_g__MAX); i = i + 1)
  {
    signed int return_value_strncasecmp$3;
    return_value_strncasecmp$3=strncasecmp(name, VSLQ_grouping[(signed long int)i], (unsigned long int)l);
    if(return_value_strncasecmp$3 == 0)
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(VSLQ_grouping[(signed long int)i]);
      if(return_value_strlen$2 == (unsigned long int)l)
        return i;

      if(n == -1)
        n = i;

      else
        n = -2;
    }

  }
  return n;
}

// VSLQ_New
// file ../../include/vapi/vsl.h line 464
struct VSLQ * VSLQ_New(struct VSL_data *vsl, struct VSL_cursor **cp, enum VSL_grouping_e grouping, const char *querystring)
{
  struct vslq_query *query;
  struct VSLQ *vslq;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSLQ_New", "vsl_dispatch.c", 1052, "(vsl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsl->magic == 0x8E6C92AA))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSLQ_New", "vsl_dispatch.c", 1052, "(vsl)->magic == 0x8E6C92AA", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L5:
  ;
  do
    if(cp == ((struct VSL_cursor **)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("VSLQ_New", "vsl_dispatch.c", 1053, "(cp) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if((signed int)grouping >= 4)
  {
    vsl_diag(vsl, "Illegal query grouping");
    return (struct VSLQ *)(void *)0;
  }

  else
  {
    if(!(querystring == ((const char *)NULL)))
    {
      query=vslq_newquery(vsl, grouping, querystring);
      if(query == ((struct vslq_query *)NULL))
        return (struct VSLQ *)(void *)0;

    }

    else
      query = (struct vslq_query *)(void *)0;
    do
    {
      void *return_value_calloc$4;
      return_value_calloc$4=calloc(sizeof(struct VSLQ) /*256ul*/ , (unsigned long int)1);
      vslq = (struct VSLQ *)return_value_calloc$4;
      if(!(vslq == ((struct VSLQ *)NULL)))
        vslq->magic = (unsigned int)0x23A8BE97;

    }
    while((_Bool)0);

  __CPROVER_DUMP_L12:
    ;
    do
      if(vslq == ((struct VSLQ *)NULL))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        VAS_Fail("VSLQ_New", "vsl_dispatch.c", 1066, "(vslq) != 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    vslq->vsl = vsl;
    vslq->c = *cp;
    *cp = (struct VSL_cursor *)(void *)0;
    vslq->grouping = grouping;
    vslq->query = query;
    do
      (&vslq->tree)->rbh_root = (struct vtx_key *)(void *)0;
    while((_Bool)0);
    do
    {
      (&vslq->ready)->vtqh_first = (struct vtx *)(void *)0;
      (&vslq->ready)->vtqh_last = &(&vslq->ready)->vtqh_first;
    }
    while((_Bool)0);
    do
    {
      (&vslq->incomplete)->vtqh_first = (struct vtx *)(void *)0;
      (&vslq->incomplete)->vtqh_last = &(&vslq->incomplete)->vtqh_first;
    }
    while((_Bool)0);
    do
    {
      (&vslq->shmrefs)->vtqh_first = (struct chunk *)(void *)0;
      (&vslq->shmrefs)->vtqh_last = &(&vslq->shmrefs)->vtqh_first;
    }
    while((_Bool)0);
    do
    {
      (&vslq->cache)->vtqh_first = (struct vtx *)(void *)0;
      (&vslq->cache)->vtqh_last = &(&vslq->cache)->vtqh_first;
    }
    while((_Bool)0);
    vslq->raw.c.magic = (unsigned int)0x247EBD44;
    vslq->raw.c.cursor.priv_tbl = (const void *)&vslc_raw_tbl;
    vslq->raw.c.cursor.priv_data = (void *)&vslq->raw.c;
    vslq->raw.trans.level = (unsigned int)0;
    vslq->raw.trans.type = (enum VSL_transaction_e)VSL_t_raw;
    vslq->raw.trans.reason = (enum VSL_reason_e)VSL_r_unknown;
    vslq->raw.trans.c = &vslq->raw.c.cursor;
    vslq->raw.ptrans[(signed long int)0] = &vslq->raw.trans;
    vslq->raw.ptrans[(signed long int)1] = (struct VSL_transaction *)(void *)0;
    return vslq;
  }
}

// VSL_Arg
// file ../../include/vapi/vsl.h line 241
signed int VSL_Arg(struct VSL_data *vsl, signed int opt, const char *arg)
{
  signed int i;
  char *p;
  double d;
  signed long int l;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSL_Arg", "vsl_arg.c", 320, "(vsl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsl->magic == 0x8E6C92AA))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSL_Arg", "vsl_arg.c", 320, "(vsl)->magic == 0x8E6C92AA", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  if(opt == 73 || opt == 105)
  {
    if((1u & vsl->flags) == 0u)
    {
      i = 0;
      for( ; !(i >= 256); i = i + 1)
        vbit_set(vsl->vbm_supress, (unsigned int)i);
    }

  }

  signed int return_value_vsl_ix_arg$3;
  signed int return_value_vsl_IX_arg$4;
  const unsigned short int **return_value___ctype_b_loc$5;
  signed int return_value_vsl_diag$6;
  signed int return_value_vsl_diag$7;
  const unsigned short int **return_value___ctype_b_loc$8;
  signed int return_value_vsl_diag$9;
  signed int return_value_vsl_diag$10;
  switch(opt)
  {
    case 98:
    {
      vsl->b_opt = 1;
      return 1;
    }
    case 99:
    {
      vsl->c_opt = 1;
      return 1;
    }
    case 67:
    {
      vsl->C_opt = 1;
      return 1;
    }
    case 105:

    case 120:
    {
      return_value_vsl_ix_arg$3=vsl_ix_arg(vsl, opt, arg);
      return return_value_vsl_ix_arg$3;
    }
    case 73:

    case 88:
    {
      return_value_vsl_IX_arg$4=vsl_IX_arg(vsl, opt, arg);
      return return_value_vsl_IX_arg$4;
    }
    case 76:
    {
      l=strtol(arg, &p, 0);
      do
      {
        return_value___ctype_b_loc$5=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)*p]) == 0)
          break;

        p = p + 1l;
      }
      while((_Bool)1);
      if(!((signed int)*p == 0))
      {
        return_value_vsl_diag$6=vsl_diag(vsl, "-L: Syntax error");
        return return_value_vsl_diag$6;
      }

      if(l >= 2147483648l || !(l >= 0l))
      {
        return_value_vsl_diag$7=vsl_diag(vsl, "-L: Range error");
        return return_value_vsl_diag$7;
      }

      vsl->L_opt = (signed int)l;
      return 1;
    }
    case 84:
    {
      d=strtod(arg, &p);
      do
      {
        return_value___ctype_b_loc$8=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$8)[(signed long int)(signed int)*p]) == 0)
          break;

        p = p + 1l;
      }
      while((_Bool)1);
      if(!((signed int)*p == 0))
      {
        return_value_vsl_diag$9=vsl_diag(vsl, "-P: Syntax error");
        return return_value_vsl_diag$9;
      }

      if(d < 0.)
      {
        return_value_vsl_diag$10=vsl_diag(vsl, "-L: Range error");
        return return_value_vsl_diag$10;
      }

      vsl->T_opt = d;
      return 1;
    }
    case 118:
    {
      vsl->v_opt = 1;
      return 1;
    }
    default:
      return 0;
  }
}

// VSL_Check
// file vsl_cursor.c line 474
signed int VSL_Check(struct VSL_cursor *cursor, struct VSLC_ptr *ptr)
{
  struct vslc_tbl *tbl;
  do
  {
    tbl = (struct vslc_tbl *)cursor->priv_tbl;
    do
      if(tbl == ((struct vslc_tbl *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("VSL_Check", "vsl_cursor.c", 478, "(tbl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  __CPROVER_DUMP_L4:
    ;
    do
      if(!(tbl->magic == 1342685406u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSL_Check", "vsl_cursor.c", 478, "((tbl))->magic == (0x5007C0DE)", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  if(tbl->check == ((signed int (*)(struct VSL_cursor *, struct VSLC_ptr *))NULL))
    return -1;

  else
  {
    signed int return_value;
    return_value=tbl->check(cursor, ptr);
    return return_value;
  }
}

// VSL_CursorFile
// file ../../include/vapi/vsl.h line 284
struct VSL_cursor * VSL_CursorFile(struct VSL_data *vsl, const char *name, unsigned int options)
{
  struct vslc_file *c;
  signed int fd;
  signed int close_fd = 0;
  char buf[4l] = { 'V', 'S', 'L', 0 };
  signed long int i;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSL_CursorFile", "vsl_cursor.c", 390, "(vsl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsl->magic == 0x8E6C92AA))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSL_CursorFile", "vsl_cursor.c", 390, "(vsl)->magic == 0x8E6C92AA", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L5:
  ;
  do
    if(name == ((const char *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("VSL_CursorFile", "vsl_cursor.c", 391, "(name) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  (void)options;
  signed int return_value_strcmp$6;
  return_value_strcmp$6=strcmp(name, "-");
  if(return_value_strcmp$6 == 0)
    fd = 0;

  else
  {
    fd=open(name, 00);
    if(!(fd >= 0))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      vsl_diag(vsl, "Could not open %s: %s\n", name, return_value_strerror$5);
      return (struct VSL_cursor *)(void *)0;
    }

    close_fd = 1;
  }
  i=vslc_file_readn(fd, (void *)buf, sizeof(char [4l]) /*4ul*/ );
  char *tmp_if_expr$9;
  signed int *return_value___errno_location$7;
  char *return_value_strerror$8;
  if(!(i >= 1l))
  {
    if(!(close_fd == 0))
      close(fd);

    if(!(i >= 0l))
    {
      return_value___errno_location$7=__errno_location();
      return_value_strerror$8=strerror(*return_value___errno_location$7);
      tmp_if_expr$9 = return_value_strerror$8;
    }

    else
      tmp_if_expr$9 = "EOF";
    vsl_diag(vsl, "VSL file read error: %s\n", tmp_if_expr$9);
    return (struct VSL_cursor *)(void *)0;
  }

  do
    if(!((unsigned long int)i == sizeof(char [4l]) /*4ul*/ ))
    {
      signed int *return_value___errno_location$10;
      return_value___errno_location$10=__errno_location();
      VAS_Fail("VSL_CursorFile", "vsl_cursor.c", 414, "i == sizeof buf", *return_value___errno_location$10, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  signed int return_value_memcmp$11;
  return_value_memcmp$11=memcmp((const void *)buf, (const void *)"VSL", sizeof(char [4l]) /*4ul*/ );
  if(!(return_value_memcmp$11 == 0))
  {
    if(!(close_fd == 0))
      close(fd);

    vsl_diag(vsl, "Not a VSL file: %s\n", name);
    return (struct VSL_cursor *)(void *)0;
  }

  else
  {
    do
    {
      void *return_value_calloc$12;
      return_value_calloc$12=calloc(sizeof(struct vslc_file) /*72ul*/ , (unsigned long int)1);
      c = (struct vslc_file *)return_value_calloc$12;
      if(!(c == ((struct vslc_file *)NULL)))
        c->magic = (unsigned int)0x1D65FFEF;

    }
    while((_Bool)0);
    if(c == ((struct vslc_file *)NULL))
    {
      if(!(close_fd == 0))
        close(fd);

      vsl_diag(vsl, "Out of memory\n");
      return (struct VSL_cursor *)(void *)0;
    }

    else
    {
      c->cursor.priv_tbl = (const void *)&vslc_file_tbl;
      c->cursor.priv_data = (void *)c;
      c->fd = fd;
      c->close_fd = close_fd;
      c->buflen = (signed long int)((8192 + 3) / 4);
      void *return_value_malloc$13;
      return_value_malloc$13=malloc((unsigned long int)(c->buflen * (signed long int)4));
      c->buf = (unsigned int *)return_value_malloc$13;

    __CPROVER_DUMP_L20:
      ;
      do
        if(c->buf == ((unsigned int *)NULL))
        {
          signed int *return_value___errno_location$14;
          return_value___errno_location$14=__errno_location();
          VAS_Fail("VSL_CursorFile", "vsl_cursor.c", 436, "(c->buf) != 0", *return_value___errno_location$14, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      return &c->cursor;
    }
  }
}

// VSL_CursorVSM
// file ../../include/vapi/vsl.h line 268
struct VSL_cursor * VSL_CursorVSM(struct VSL_data *vsl, struct VSM_data *vsm, unsigned int options)
{
  struct vslc_vsm *c;
  struct VSM_fantom vf;
  struct VSL_head *head;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSL_CursorVSM", "vsl_cursor.c", 232, "(vsl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsl->magic == 0x8E6C92AA))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSL_CursorVSM", "vsl_cursor.c", 232, "(vsl)->magic == 0x8E6C92AA", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L5:
  ;
  do
  {
    if(vsm == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("VSL_CursorVSM", "vsl_cursor.c", 233, "(vsm) != NULL", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsm->magic == 1849415323u))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        VAS_Fail("VSL_CursorVSM", "vsl_cursor.c", 233, "(vsm)->magic == 0x6e3bd69b", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  signed int return_value_VSM_Get$5;
  return_value_VSM_Get$5=VSM_Get(vsm, &vf, "Log", "", "");
  if(return_value_VSM_Get$5 == 0)
  {
    vsl_diag(vsl, "No VSL chunk found (child not started ?)\n");
    return (struct VSL_cursor *)(void *)0;
  }

  else
  {
    head = (struct VSL_head *)vf.b;
    signed int return_value_memcmp$6;
    return_value_memcmp$6=memcmp((const void *)head->marker, (const void *)"VSLHEAD0", sizeof(char [8l]) /*8ul*/ );
    if(!(return_value_memcmp$6 == 0))
    {
      vsl_diag(vsl, "Not a VSL chunk\n");
      return (struct VSL_cursor *)(void *)0;
    }

    else
      if(head->seq == 0u)
      {
        vsl_diag(vsl, "VSL chunk not initialized\n");
        return (struct VSL_cursor *)(void *)0;
      }

      else
      {
        do
        {
          void *return_value_calloc$7;
          return_value_calloc$7=calloc(sizeof(struct vslc_vsm) /*272ul*/ , (unsigned long int)1);
          c = (struct vslc_vsm *)return_value_calloc$7;
          if(!(c == ((struct vslc_vsm *)NULL)))
            c->magic = (unsigned int)0x4D3903A6;

        }
        while((_Bool)0);
        if(c == ((struct vslc_vsm *)NULL))
        {
          vsl_diag(vsl, "Out of memory\n");
          return (struct VSL_cursor *)(void *)0;
        }

        else
        {
          c->cursor.priv_tbl = (const void *)&vslc_vsm_tbl;
          c->cursor.priv_data = (void *)c;
          c->options = options;
          c->vsm = vsm;
          c->vf = vf;
          c->head = head;
          c->end = (const unsigned int *)vf.e;
          c->segsize = (c->end - c->head->log) / (signed long int)8;
          if(!((1u & c->options) == 0u))
          {
            c->next.ptr = c->head->log + c->head->segments[(signed long int)c->head->segment];
            for( ; !(c->next.ptr >= c->end); c->next.ptr = c->next.ptr + (signed long int)2 + (signed long int)(((c->next.ptr[(signed long int)0] & (unsigned int)0xffff) + (unsigned int)3) / (unsigned int)4))
              if(*c->next.ptr == 4265952581u)
                break;

            c->next.priv = c->head->seq;
          }

          else
            do
            {

            __CPROVER_DUMP_L16:
              ;
              signed int return_value_vslc_vsm_reset$9;
              return_value_vslc_vsm_reset$9=vslc_vsm_reset(&c->cursor);
              if(!(return_value_vslc_vsm_reset$9 == 0))
              {
                signed int *return_value___errno_location$8;
                return_value___errno_location$8=__errno_location();
                VAS_Fail("VSL_CursorVSM", "vsl_cursor.c", 274, "(vslc_vsm_reset(&c->cursor)) == 0", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
              }

            }
            while((_Bool)0);
          return &c->cursor;
        }
      }
  }
}

// VSL_Delete
// file ../../include/vapi/vsl.h line 250
void VSL_Delete(struct VSL_data *vsl)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSL_Delete", "vsl.c", 131, "(vsl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsl->magic == 0x8E6C92AA))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSL_Delete", "vsl.c", 131, "(vsl)->magic == 0x8E6C92AA", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  vbit_destroy$link1(vsl->vbm_select);
  vbit_destroy$link1(vsl->vbm_supress);
  vsl_IX_free(&vsl->vslf_select);
  vsl_IX_free(&vsl->vslf_suppress);
  VSL_ResetError(vsl);
  do
  {
    vsl->magic = (unsigned int)0;
    free((void *)vsl);
  }
  while((_Bool)0);
}

// VSL_DeleteCursor
// file vsl_cursor.c line 442
void VSL_DeleteCursor(struct VSL_cursor *cursor)
{
  struct vslc_tbl *tbl;
  do
  {
    tbl = (struct vslc_tbl *)cursor->priv_tbl;
    do
      if(tbl == ((struct vslc_tbl *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("VSL_DeleteCursor", "vsl_cursor.c", 446, "(tbl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  __CPROVER_DUMP_L4:
    ;
    do
      if(!(tbl->magic == 1342685406u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSL_DeleteCursor", "vsl_cursor.c", 446, "((tbl))->magic == (0x5007C0DE)", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  if(!(tbl->delete == ((void (*)(struct VSL_cursor *))NULL)))
    tbl->delete(cursor);

}

// VSL_Error
// file ../../include/vapi/vsl.h line 255
const char * VSL_Error(struct VSL_data *vsl)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSL_Error", "vsl.c", 145, "(vsl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsl->magic == 0x8E6C92AA))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSL_Error", "vsl.c", 145, "(vsl)->magic == 0x8E6C92AA", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  char *return_value_VSB_data$3;
  if(vsl->diag == ((struct vsb *)NULL))
    return (const char *)(void *)0;

  else
  {
    return_value_VSB_data$3=VSB_data(vsl->diag);
    return return_value_VSB_data$3;
  }
}

// VSL_Glob2Tags
// file vsl_arg.c line 88
signed int VSL_Glob2Tags(const char *glob, signed int l, void (*func)(signed int, void *), void *priv)
{
  signed int i;
  signed int r;
  signed int l2;
  signed int pre = 0;
  signed int post = 0;
  char buf[64l];

__CPROVER_DUMP_L1:
  ;
  do
    if(glob == ((const char *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSL_Glob2Tags", "vsl_arg.c", 95, "(glob) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  unsigned long int return_value_strlen$2;
  if(!(l >= 0))
  {
    return_value_strlen$2=strlen(glob);
    l = (signed int)return_value_strlen$2;
  }

  if(l == 0 || (unsigned long int)l >= 64ul)
    return -1;

  else
  {
    char *return_value_strchr$3;
    return_value_strchr$3=strchr(glob, 42);
    if(!(return_value_strchr$3 == ((char *)NULL)))
    {
      if((signed int)*glob == 42)
      {
        pre = 1;
        glob = glob + 1l;
        l = l - 1;
      }

      if(l >= 1)
      {
        if((signed int)glob[(signed long int)(l + -1)] == 42)
        {
          post = 1;
          l = l - 1;
        }

      }

    }

    if(!(post == 0) && !(pre == 0))
      return -3;

    else
    {
      memcpy((void *)buf, (const void *)glob, (unsigned long int)l);
      buf[(signed long int)l] = (char)0;
      char *return_value_strchr$4;
      return_value_strchr$4=strchr(buf, 42);
      if(!(return_value_strchr$4 == ((char *)NULL)))
        return -3;

      else
        if(post == 0 && pre == 0)
        {
          i=VSL_Name2Tag(buf, l);
          if(!(i >= 0))
            return i;

          if(!(func == ((void (*)(signed int, void *))NULL)))
            func(i, priv);

          return 1;
        }

        else
        {
          r = 0;
          i = 0;
          for( ; !(i >= 256); i = i + 1)
          {
            if(!(VSL_tags[(signed long int)i] == ((const char *)NULL)))
            {
              unsigned long int return_value_strlen$5;
              return_value_strlen$5=strlen(VSL_tags[(signed long int)i]);
              l2 = (signed int)return_value_strlen$5;
              if(l2 >= l)
              {
                if(!(pre == 0))
                {
                  signed int return_value_strcasecmp$6;
                  return_value_strcasecmp$6=strcasecmp(buf, (VSL_tags[(signed long int)i] + (signed long int)l2) - (signed long int)l);
                  if(!(return_value_strcasecmp$6 == 0))
                    goto __CPROVER_DUMP_L19;

                }

                else
                {
                  signed int return_value_strncasecmp$7;
                  return_value_strncasecmp$7=strncasecmp(buf, VSL_tags[(signed long int)i], (unsigned long int)l);
                  if(!(return_value_strncasecmp$7 == 0))
                    goto __CPROVER_DUMP_L19;

                }
                if(!(func == ((void (*)(signed int, void *))NULL)))
                  func(i, priv);

                r = r + 1;
              }

            }


          __CPROVER_DUMP_L19:
            ;
          }
          if(r == 0)
            return -1;

          else
            return r;
        }
    }
  }
}

// VSL_List2Tags
// file vsl_arg.c line 157
signed int VSL_List2Tags(const char *list, signed int l, void (*func)(signed int, void *), void *priv)
{
  const char *p;
  const char *q;
  const char *e;
  signed int r;
  signed int t;
  unsigned long int return_value_strlen$1;
  if(!(l >= 0))
  {
    return_value_strlen$1=strlen(list);
    l = (signed int)return_value_strlen$1;
  }

  p = list;
  e = p + (signed long int)l;
  t = 0;
  for( ; !(p >= e); p = q)
  {
    for( ; !(p >= e); p = p + 1l)
      if(!((signed int)*p == 44))
        break;

    if(p == e)
      break;

    q = p;
    for( ; !(q >= e); q = q + 1l)
      if((signed int)*q == 44)
        break;

    r=VSL_Glob2Tags(p, (signed int)(q - p), func, priv);
    if(!(r >= 0))
      return r;

    t = t + r;
  }
  if(t == 0)
    return -1;

  else
    return t;
}

// VSL_Match
// file ../../include/vapi/vsl.h line 339
signed int VSL_Match(struct VSL_data *vsl, struct VSL_cursor *c)
{
  enum VSL_tag_e tag;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSL_Match", "vsl.c", 194, "(vsl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsl->magic == 0x8E6C92AA))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSL_Match", "vsl.c", 194, "(vsl)->magic == 0x8E6C92AA", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  _Bool tmp_if_expr$3;
  if(c == ((struct VSL_cursor *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = c->rec.ptr == (const unsigned int *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$9;
  signed int return_value_vsl_match_IX$8;
  signed int return_value_vbit_test$7;
  _Bool tmp_if_expr$6;
  signed int return_value_vsl_match_IX$5;
  signed int return_value_vbit_test$4;
  if(tmp_if_expr$3)
    return 0;

  else
  {
    tag = (enum VSL_tag_e)(c->rec.ptr[(signed long int)0] >> 24);
    if((signed int)tag >= SLT__Reserved || !((signed int)tag >= 1))
      return 0;

    else
      if(!(vsl->c_opt == 0))
      {
        if(!((1073741824u & c->rec.ptr[1l]) == 0u))
          goto __CPROVER_DUMP_L9;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L9:
        ;
        if(!(vsl->b_opt == 0))
        {
          if(!((2147483648u & c->rec.ptr[1l]) == 0u))
            goto __CPROVER_DUMP_L10;

          return 0;
        }

        else
        {

        __CPROVER_DUMP_L10:
          ;
          if(!(vsl->vslf_select.vtqh_first == ((struct vslf *)NULL)))
          {
            return_value_vsl_match_IX$8=vsl_match_IX(vsl, &vsl->vslf_select, c);
            tmp_if_expr$9 = return_value_vsl_match_IX$8 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$9 = (_Bool)0;
          if(tmp_if_expr$9)
            return 1;

          else
          {
            return_value_vbit_test$7=vbit_test$link1(vsl->vbm_select, (unsigned int)tag);
            if(!(return_value_vbit_test$7 == 0))
              return 1;

            else
            {
              if(!(vsl->vslf_suppress.vtqh_first == ((struct vslf *)NULL)))
              {
                return_value_vsl_match_IX$5=vsl_match_IX(vsl, &vsl->vslf_suppress, c);
                tmp_if_expr$6 = return_value_vsl_match_IX$5 != 0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$6 = (_Bool)0;
              if(tmp_if_expr$6)
                return 0;

              else
              {
                return_value_vbit_test$4=vbit_test$link1(vsl->vbm_supress, (unsigned int)tag);
                if(!(return_value_vbit_test$4 == 0))
                  return 0;

              }
            }
          }
          return 1;
        }
      }
  }
}

// VSL_Name2Tag
// file vsl_arg.c line 64
signed int VSL_Name2Tag(const char *name, signed int l)
{
  signed int i;
  signed int n;
  unsigned long int return_value_strlen$1;
  if(l == -1)
  {
    return_value_strlen$1=strlen(name);
    l = (signed int)return_value_strlen$1;
  }

  n = -1;
  i = 0;
  signed int return_value_strncasecmp$3;
  for( ; !(i >= 256); i = i + 1)
    if(!(VSL_tags[(signed long int)i] == ((const char *)NULL)))
    {
      return_value_strncasecmp$3=strncasecmp(name, VSL_tags[(signed long int)i], (unsigned long int)l);
      if(return_value_strncasecmp$3 == 0)
      {
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(VSL_tags[(signed long int)i]);
        if(return_value_strlen$2 == (unsigned long int)l)
          return i;

        if(n == -1)
          n = i;

        else
          n = -2;
      }

    }

  return n;
}

// VSL_New
// file ../../include/vapi/vsl.h line 240
struct VSL_data * VSL_New(void)
{
  struct VSL_data *vsl;
  do
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc(sizeof(struct VSL_data) /*104ul*/ , (unsigned long int)1);
    vsl = (struct VSL_data *)return_value_calloc$1;
    if(!(vsl == ((struct VSL_data *)NULL)))
      vsl->magic = 0x8E6C92AA;

  }
  while((_Bool)0);
  if(vsl == ((struct VSL_data *)NULL))
    return (struct VSL_data *)(void *)0;

  else
  {
    vsl->L_opt = 1000;
    vsl->T_opt = 120.;
    vsl->vbm_select=vbit_init$link1((unsigned int)256);
    vsl->vbm_supress=vbit_init$link1((unsigned int)256);
    do
    {
      (&vsl->vslf_select)->vtqh_first = (struct vslf *)(void *)0;
      (&vsl->vslf_select)->vtqh_last = &(&vsl->vslf_select)->vtqh_first;
    }
    while((_Bool)0);
    do
    {
      (&vsl->vslf_suppress)->vtqh_first = (struct vslf *)(void *)0;
      (&vsl->vslf_suppress)->vtqh_last = &(&vsl->vslf_suppress)->vtqh_first;
    }
    while((_Bool)0);
    return vsl;
  }
}

// VSL_Next
// file ../../include/vapi/vsl.h line 326
signed int VSL_Next(struct VSL_cursor *cursor)
{
  struct vslc_tbl *tbl;
  do
  {
    tbl = (struct vslc_tbl *)cursor->priv_tbl;
    do
      if(tbl == ((struct vslc_tbl *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("VSL_Next", "vsl_cursor.c", 468, "(tbl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  __CPROVER_DUMP_L4:
    ;
    do
      if(!(tbl->magic == 1342685406u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSL_Next", "vsl_cursor.c", 468, "((tbl))->magic == (0x5007C0DE)", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L6:
  ;
  do
    if(tbl->next == ((signed int (*)(struct VSL_cursor *))NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("VSL_Next", "vsl_cursor.c", 469, "(tbl->next) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  signed int return_value;
  return_value=tbl->next(cursor);
  return return_value;
}

// VSL_Print
// file vsl.c line 235
signed int VSL_Print(struct VSL_data *vsl, struct VSL_cursor *c, void *fo)
{
  enum VSL_tag_e tag;
  unsigned int vxid;
  unsigned int len;
  const char *data;
  signed int type;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSL_Print", "vsl.c", 243, "(vsl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsl->magic == 0x8E6C92AA))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSL_Print", "vsl.c", 243, "(vsl)->magic == 0x8E6C92AA", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  _Bool tmp_if_expr$3;
  if(c == ((struct VSL_cursor *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = c->rec.ptr == (const unsigned int *)(void *)0 ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr$4;
  unsigned int tmp_post$6;
  _Bool tmp_if_expr$9;
  if(tmp_if_expr$3)
    return 0;

  else
  {
    if(fo == NULL)
      fo = (void *)stdout;

    tag = (enum VSL_tag_e)(c->rec.ptr[(signed long int)0] >> 24);
    vxid = c->rec.ptr[(signed long int)1] & ~(3U << 30);
    len = c->rec.ptr[(signed long int)0] & (unsigned int)0xffff;
    if(!((1073741824u & c->rec.ptr[1l]) == 0u))
      tmp_if_expr$4 = 99;

    else
      tmp_if_expr$4 = (c->rec.ptr[(signed long int)1] & 1U << 31) != 0u ? 98 : 45;
    type = tmp_if_expr$4;
    data = (const char *)(c->rec.ptr + (signed long int)2);
    if(!((2u & VSL_tagflags[(signed long int)tag]) == 0u))
    {
      do
      {
        signed int return_value_fprintf$5;
        return_value_fprintf$5=fprintf((struct _IO_FILE *)fo, "%10u %-14s %c \"", vxid, VSL_tags[(signed long int)tag], type);
        if(!(return_value_fprintf$5 >= 0))
          return -5;

      }
      while((_Bool)0);
      do
      {
        tmp_post$6 = len;
        len = len - 1u;
        if(!(tmp_post$6 >= 1u))
          break;

        if(len == 0u && (signed int)tag == SLT_Debug)
        {
          if((signed int)*data == 0)
            break;

        }

        if((signed int)*data >= 32)
          tmp_if_expr$9 = (signed int)*data <= 126 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$9 = (_Bool)0;
        if(tmp_if_expr$9)
          do
          {
            signed int return_value_fprintf$7;
            return_value_fprintf$7=fprintf((struct _IO_FILE *)fo, "%c", *data);
            if(!(return_value_fprintf$7 >= 0))
              return -5;

          }
          while((_Bool)0);

        else
          do
          {
            signed int return_value_fprintf$8;
            return_value_fprintf$8=fprintf((struct _IO_FILE *)fo, "%%%02x", (unsigned char)*data);
            if(!(return_value_fprintf$8 >= 0))
              return -5;

          }
          while((_Bool)0);
        data = data + 1l;
      }
      while((_Bool)1);
      do
      {
        signed int return_value_fprintf$10;
        return_value_fprintf$10=fprintf((struct _IO_FILE *)fo, "\"\n");
        if(!(return_value_fprintf$10 >= 0))
          return -5;

      }
      while((_Bool)0);
    }

    else
      do
      {
        signed int return_value_fprintf$11;
        return_value_fprintf$11=fprintf((struct _IO_FILE *)fo, "%10u %-14s %c %.*s\n", vxid, VSL_tags[(signed long int)tag], type, (signed int)len, data);
        if(!(return_value_fprintf$11 >= 0))
          return -5;

      }
      while((_Bool)0);
    return 0;
  }
}

// VSL_PrintAll
// file vsl.c line 309
signed int VSL_PrintAll(struct VSL_data *vsl, struct VSL_cursor *c, void *fo)
{
  signed int i;
  if(c == ((struct VSL_cursor *)NULL))
    return 0;

  else
    while((_Bool)1)
    {
      i=VSL_Next(c);
      if(!(i >= 1))
        return i;

      signed int return_value_VSL_Match$1;
      return_value_VSL_Match$1=VSL_Match(vsl, c);
      if(!(return_value_VSL_Match$1 == 0))
      {
        i=VSL_Print(vsl, c, fo);
        if(!(i == 0))
          return i;

      }

    }
}

// VSL_PrintTerse
// file vsl.c line 275
signed int VSL_PrintTerse(struct VSL_data *vsl, struct VSL_cursor *c, void *fo)
{
  enum VSL_tag_e tag;
  unsigned int len;
  const char *data;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSL_PrintTerse", "vsl.c", 281, "(vsl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsl->magic == 0x8E6C92AA))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSL_PrintTerse", "vsl.c", 281, "(vsl)->magic == 0x8E6C92AA", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  _Bool tmp_if_expr$3;
  if(c == ((struct VSL_cursor *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = c->rec.ptr == (const unsigned int *)(void *)0 ? (_Bool)1 : (_Bool)0;
  unsigned int tmp_post$5;
  _Bool tmp_if_expr$8;
  if(tmp_if_expr$3)
    return 0;

  else
  {
    if(fo == NULL)
      fo = (void *)stdout;

    tag = (enum VSL_tag_e)(c->rec.ptr[(signed long int)0] >> 24);
    len = c->rec.ptr[(signed long int)0] & (unsigned int)0xffff;
    data = (const char *)(c->rec.ptr + (signed long int)2);
    if(!((2u & VSL_tagflags[(signed long int)tag]) == 0u))
    {
      do
      {
        signed int return_value_fprintf$4;
        return_value_fprintf$4=fprintf((struct _IO_FILE *)fo, "%-14s \"", VSL_tags[(signed long int)tag]);
        if(!(return_value_fprintf$4 >= 0))
          return -5;

      }
      while((_Bool)0);
      do
      {
        tmp_post$5 = len;
        len = len - 1u;
        if(!(tmp_post$5 >= 1u))
          break;

        if(len == 0u && (signed int)tag == SLT_Debug)
        {
          if((signed int)*data == 0)
            break;

        }

        if((signed int)*data >= 32)
          tmp_if_expr$8 = (signed int)*data <= 126 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$8 = (_Bool)0;
        if(tmp_if_expr$8)
          do
          {
            signed int return_value_fprintf$6;
            return_value_fprintf$6=fprintf((struct _IO_FILE *)fo, "%c", *data);
            if(!(return_value_fprintf$6 >= 0))
              return -5;

          }
          while((_Bool)0);

        else
          do
          {
            signed int return_value_fprintf$7;
            return_value_fprintf$7=fprintf((struct _IO_FILE *)fo, "%%%02x", (unsigned char)*data);
            if(!(return_value_fprintf$7 >= 0))
              return -5;

          }
          while((_Bool)0);
        data = data + 1l;
      }
      while((_Bool)1);
      do
      {
        signed int return_value_fprintf$9;
        return_value_fprintf$9=fprintf((struct _IO_FILE *)fo, "\"\n");
        if(!(return_value_fprintf$9 >= 0))
          return -5;

      }
      while((_Bool)0);
    }

    else
      do
      {
        signed int return_value_fprintf$10;
        return_value_fprintf$10=fprintf((struct _IO_FILE *)fo, "%-14s %.*s\n", VSL_tags[(signed long int)tag], (signed int)len, data);
        if(!(return_value_fprintf$10 >= 0))
          return -5;

      }
      while((_Bool)0);
    return 0;
  }
}

// VSL_PrintTransactions
// file vsl.c line 328
signed int VSL_PrintTransactions(struct VSL_data *vsl, struct VSL_transaction * const *pt, void *fo)
{
  struct VSL_transaction *t;
  signed int i;
  signed int delim = 0;
  signed int verbose;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSL_PrintTransactions", "vsl.c", 336, "(vsl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsl->magic == 0x8E6C92AA))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSL_PrintTransactions", "vsl.c", 336, "(vsl)->magic == 0x8E6C92AA", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  if(fo == NULL)
    fo = (void *)stdout;

  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(*pt == ((struct VSL_transaction *)NULL))
    return 0;

  else
  {
    t = pt[(signed long int)0];
    for( ; !(t == ((struct VSL_transaction *)NULL)); t = *pt)
    {
      if(!(vsl->c_opt == 0))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = vsl->b_opt != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        switch((signed int)t->type)
        {
          case VSL_t_req:
          {
            if(vsl->c_opt == 0)
              goto __CPROVER_DUMP_L36;

            goto __CPROVER_DUMP_L14;
          }
          case VSL_t_bereq:
          {
            if(vsl->b_opt == 0)
              goto __CPROVER_DUMP_L36;

            goto __CPROVER_DUMP_L14;
          }
          case VSL_t_raw:
            goto __CPROVER_DUMP_L14;
          default:
            ;
        }

      else
      {

      __CPROVER_DUMP_L14:
        ;
        verbose = 0;
        if(t->level == 0u)
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = vsl->v_opt != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$4)
          verbose = 1;

        if(!(t->level == 0u))
        {
          if(t->level >= 4u)
            do
            {
              signed int return_value_fprintf$5;
              return_value_fprintf$5=fprintf((struct _IO_FILE *)fo, "*%1.1u* ", t->level);
              if(!(return_value_fprintf$5 >= 0))
                return -5;

            }
            while((_Bool)0);

          else
            do
            {
              signed int return_value_fprintf$6;
              return_value_fprintf$6=fprintf((struct _IO_FILE *)fo, "%-3.*s ", t->level, (const void *)"***");
              if(!(return_value_fprintf$6 >= 0))
                return -5;

            }
            while((_Bool)0);
          do
          {
            signed int return_value_fprintf$7;
            return_value_fprintf$7=fprintf((struct _IO_FILE *)fo, "%*.s%-14s %*.s%-10u\n", verbose != 0 ? 10 + 1 : 0, (const void *)" ", VSL_transactions[(signed long int)t->type], verbose != 0 ? 1 + 1 : 0, (const void *)" ", t->vxid);
            if(!(return_value_fprintf$7 >= 0))
              return -5;

          }
          while((_Bool)0);
          delim = 1;
        }

        while((_Bool)1)
        {
          i=VSL_Next(t->c);
          if(!(i >= 0))
            return i;

          if(i == 0)
            break;

          signed int return_value_VSL_Match$8;
          return_value_VSL_Match$8=VSL_Match(vsl, t->c);
          if(!(return_value_VSL_Match$8 == 0))
          {
            if(t->level >= 4u)
              do
              {
                signed int return_value_fprintf$9;
                return_value_fprintf$9=fprintf((struct _IO_FILE *)fo, "-%1.1u- ", t->level);
                if(!(return_value_fprintf$9 >= 0))
                  return -5;

              }
              while((_Bool)0);

            else
              if(!(t->level == 0u))
                do
                {
                  signed int return_value_fprintf$10;
                  return_value_fprintf$10=fprintf((struct _IO_FILE *)fo, "%-3.*s ", t->level, (const void *)"---");
                  if(!(return_value_fprintf$10 >= 0))
                    return -5;

                }
                while((_Bool)0);

            if(!(verbose == 0))
              i=VSL_Print(vsl, t->c, fo);

            else
              i=VSL_PrintTerse(vsl, t->c, fo);
            if(!(i == 0))
              return i;

          }

        }
      }

    __CPROVER_DUMP_L36:
      ;
      pt = pt + 1l;
    }
    if(!(delim == 0))
      do
      {
        signed int return_value_fprintf$11;
        return_value_fprintf$11=fprintf((struct _IO_FILE *)fo, "\n");
        if(!(return_value_fprintf$11 >= 0))
          return -5;

      }
      while((_Bool)0);

    return 0;
  }
}

// VSL_ResetCursor
// file vsl_cursor.c line 453
signed int VSL_ResetCursor(struct VSL_cursor *cursor)
{
  struct vslc_tbl *tbl;
  do
  {
    tbl = (struct vslc_tbl *)cursor->priv_tbl;
    do
      if(tbl == ((struct vslc_tbl *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("VSL_ResetCursor", "vsl_cursor.c", 457, "(tbl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  __CPROVER_DUMP_L4:
    ;
    do
      if(!(tbl->magic == 1342685406u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSL_ResetCursor", "vsl_cursor.c", 457, "((tbl))->magic == (0x5007C0DE)", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  if(tbl->reset == ((signed int (*)(struct VSL_cursor *))NULL))
    return -1;

  else
  {
    signed int return_value;
    return_value=tbl->reset(cursor);
    return return_value;
  }
}

// VSL_ResetError
// file ../../include/vapi/vsl.h line 260
void VSL_ResetError(struct VSL_data *vsl)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSL_ResetError", "vsl.c", 157, "(vsl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsl->magic == 0x8E6C92AA))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSL_ResetError", "vsl.c", 157, "(vsl)->magic == 0x8E6C92AA", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  if(!(vsl->diag == ((struct vsb *)NULL)))
  {
    VSB_delete(vsl->diag);
    vsl->diag = (struct vsb *)(void *)0;
  }

}

// VSL_Write
// file vsl.c line 429
signed int VSL_Write(struct VSL_data *vsl, struct VSL_cursor *c, void *fo)
{
  unsigned long int r;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSL_Write", "vsl.c", 433, "(vsl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsl->magic == 0x8E6C92AA))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSL_Write", "vsl.c", 433, "(vsl)->magic == 0x8E6C92AA", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  _Bool tmp_if_expr$3;
  if(c == ((struct VSL_cursor *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = c->rec.ptr == (const unsigned int *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
    return 0;

  else
  {
    if(fo == NULL)
      fo = (void *)stdout;

    r=fwrite((const void *)c->rec.ptr, sizeof(const unsigned int) /*4ul*/ , (unsigned long int)((c->rec.ptr + (signed long int)2 + (signed long int)(((c->rec.ptr[(signed long int)0] & (unsigned int)0xffff) + (unsigned int)3) / (unsigned int)4)) - c->rec.ptr), (struct _IO_FILE *)fo);
    if(r == 0ul)
      return -5;

    else
      return 0;
  }
}

// VSL_WriteAll
// file vsl.c line 446
signed int VSL_WriteAll(struct VSL_data *vsl, struct VSL_cursor *c, void *fo)
{
  signed int i;
  if(c == ((struct VSL_cursor *)NULL))
    return 0;

  else
    while((_Bool)1)
    {
      i=VSL_Next(c);
      if(!(i >= 1))
        return i;

      signed int return_value_VSL_Match$1;
      return_value_VSL_Match$1=VSL_Match(vsl, c);
      if(!(return_value_VSL_Match$1 == 0))
      {
        i=VSL_Write(vsl, c, fo);
        if(!(i == 0))
          return i;

      }

    }
}

// VSL_WriteOpen
// file vsl.c line 407
struct _IO_FILE * VSL_WriteOpen(struct VSL_data *vsl, const char *name, signed int append, signed int unbuf)
{
  const char head[4l] = { 'V', 'S', 'L', 0 };
  struct _IO_FILE *f;
  f=fopen(name, append != 0 ? "a" : "w");
  if(f == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    vsl_diag(vsl, "%s", return_value_strerror$2);
    return (struct _IO_FILE *)(void *)0;
  }

  if(!(unbuf == 0))
    setbuf(f, (char *)(void *)0);

  signed long int return_value_ftell$6;
  return_value_ftell$6=ftell(f);
  if(return_value_ftell$6 == 0l)
  {
    unsigned long int return_value_fwrite$5;
    return_value_fwrite$5=fwrite((const void *)head, (unsigned long int)1, sizeof(const char [4l]) /*4ul*/ , f);
    if(!(return_value_fwrite$5 == sizeof(const char [4l]) /*4ul*/ ))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      vsl_diag(vsl, "%s", return_value_strerror$4);
      fclose(f);
      return (struct _IO_FILE *)(void *)0;
    }

  }

  return f;
}

// VSL_WriteTransactions
// file vsl.c line 465
signed int VSL_WriteTransactions(struct VSL_data *vsl, struct VSL_transaction * const *pt, void *fo)
{
  struct VSL_transaction *t;
  signed int i;
  if(pt == ((struct VSL_transaction * const *)NULL))
    return 0;

  else
  {
    i = 0;
    t = pt[(signed long int)0];
    for( ; i == 0 && !(t == ((struct VSL_transaction *)NULL)); t = *pt)
    {
      i=VSL_WriteAll(vsl, t->c, fo);
      pt = pt + 1l;
    }
    return i;
  }
}

// VSM_Abandoned
// file vsm.c line 308
signed int VSM_Abandoned(struct VSM_data *vd)
{
  struct stat st;
  double now;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSM_Abandoned", "vsm.c", 313, "(vd) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->magic == 1849415323u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSM_Abandoned", "vsm.c", 313, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  _Bool tmp_if_expr$4;
  if(vd->head == ((struct VSM_head *)NULL))
    return 1;

  else
    if(!(vd->N_opt == 0))
      return 0;

    else
      if(vd->head->alloc_seq == 0u)
        return 1;

      else
        if(!(vd->head->age >= vd->age_ok))
          return 1;

        else
        {
          now=VTIM_mono();
          if(vd->head->age == vd->age_ok)
            tmp_if_expr$4 = now - vd->t_ok > 2. ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          if(tmp_if_expr$4)
          {
            signed int return_value_stat$3;
            return_value_stat$3=stat(vd->fname, &st);
            if(!(return_value_stat$3 == 0))
              return 1;

            if(!(st.st_dev == vd->fstat.st_dev))
              return 1;

            if(!(st.st_ino == vd->fstat.st_ino))
              return 1;

            vd->t_ok = now;
          }

          else
            if(!(vd->age_ok >= vd->head->age))
            {
              vd->t_ok = now;
              vd->age_ok = vd->head->age;
            }

          return 0;
        }
}

// VSM_Close
// file ../../include/vapi/vsm.h line 141
void VSM_Close(struct VSM_data *vd)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSM_Close", "vsm.c", 291, "(vd) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->magic == 1849415323u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSM_Close", "vsm.c", 291, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  if(!(vd->head == ((struct VSM_head *)NULL)))
  {
    do
      if(!(vd->vsm_fd >= 0))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("VSM_Close", "vsm.c", 296, "vd->vsm_fd >= 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L7:
      ;
      signed int return_value_munmap$5;
      return_value_munmap$5=munmap((void *)vd->b, (unsigned long int)(vd->e - vd->b));
      if(!(return_value_munmap$5 == 0))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        VAS_Fail("VSM_Close", "vsm.c", 297, "(munmap((void*)vd->b, vd->e - vd->b)) == 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
      }

    }
    while((_Bool)0);
    vd->b = (char *)(void *)0;
    vd->e = (char *)(void *)0;
    vd->head = (struct VSM_head *)(void *)0;
    do
    {

    __CPROVER_DUMP_L9:
      ;
      signed int return_value_close$7;
      return_value_close$7=close(vd->vsm_fd);
      if(!(return_value_close$7 == 0))
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        VAS_Fail("VSM_Close", "vsm.c", 301, "(close(vd->vsm_fd)) == 0", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
      }

    }
    while((_Bool)0);
    vd->vsm_fd = -1;
  }

}

// VSM_Delete
// file ../../include/vapi/vsm.h line 75
void VSM_Delete(struct VSM_data *vd)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSM_Delete", "vsm.c", 190, "(vd) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->magic == 1849415323u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSM_Delete", "vsm.c", 190, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  VSM_Close(vd);
  if(!(vd->vsc == ((struct vsc *)NULL)))
    VSC_Delete(vd);

  VSM_ResetError(vd);
  free((void *)vd->name);
  free((void *)vd->fname);
  do
  {
    vd->magic = (unsigned int)0;
    free((void *)vd);
  }
  while((_Bool)0);
}

// VSM_Error
// file ../../include/vapi/vsm.h line 81
const char * VSM_Error(struct VSM_data *vd)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSM_Error", "vsm.c", 105, "(vd) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->magic == 1849415323u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSM_Error", "vsm.c", 105, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  char *return_value_VSB_data$3;
  if(vd->diag == ((struct vsb *)NULL))
    return (const char *)(void *)0;

  else
  {
    return_value_VSB_data$3=VSB_data(vd->diag);
    return return_value_VSB_data$3;
  }
}

// VSM_Get
// file vsm.c line 437
signed int VSM_Get(struct VSM_data *vd, struct VSM_fantom *vf, const char *class, const char *type, const char *ident)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSM_Get", "vsm.c", 441, "(vd) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->magic == 1849415323u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSM_Get", "vsm.c", 441, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  VSM__iter0(vd, vf);
  signed int return_value_VSM__itern$3;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$6;
  do
  {
    return_value_VSM__itern$3=VSM__itern(vd, vf);
    if(return_value_VSM__itern$3 == 0)
      break;

    signed int return_value_strcmp$4;
    return_value_strcmp$4=strcmp(vf->class, class);
    if(return_value_strcmp$4 == 0)
    {
      if(!(type == ((const char *)NULL)))
      {
        return_value_strcmp$5=strcmp(vf->type, type);
        if(return_value_strcmp$5 == 0)
          goto __CPROVER_DUMP_L6;

      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        if(!(ident == ((const char *)NULL)))
        {
          return_value_strcmp$6=strcmp(vf->ident, ident);
          if(return_value_strcmp$6 == 0)
            goto __CPROVER_DUMP_L7;

        }

        else
        {

        __CPROVER_DUMP_L7:
          ;
          return 1;
        }
      }
    }

  }
  while((_Bool)1);
  memset((void *)vf, 0, sizeof(struct VSM_fantom) /*176ul*/ );
  return 0;
}

// VSM_N_Arg
// file ../../include/vapi/vsm.h line 105
signed int VSM_N_Arg(struct VSM_data *vd, const char *arg)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSM_N_Arg", "vsm.c", 162, "(vd) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->magic == 1849415323u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSM_N_Arg", "vsm.c", 162, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L5:
  ;
  do
    if(arg == ((const char *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("VSM_N_Arg", "vsm.c", 163, "(arg) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  signed int return_value_vsm_diag$4;
  if(!(vd->head == ((struct VSM_head *)NULL)))
  {
    return_value_vsm_diag$4=vsm_diag(vd, "VSM_N_Arg: Already open\n");
    return return_value_vsm_diag$4;
  }

  else
  {
    do
    {
      if(!(vd->name == ((char *)NULL)))
        free((void *)vd->name);

      if(!(arg == ((const char *)NULL)))
      {
        vd->name=strdup(arg);

      __CPROVER_DUMP_L9:
        ;
        do
          if(vd->name == ((char *)NULL))
          {
            signed int *return_value___errno_location$5;
            return_value___errno_location$5=__errno_location();
            VAS_Fail("VSM_N_Arg", "vsm.c", 167, "((vd->name)) != 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
      }

      else
        vd->name = (char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      if(!(vd->fname == ((char *)NULL)))
        free((void *)vd->fname);

      if(!(arg == ((const char *)NULL)))
      {
        vd->fname=strdup(arg);

      __CPROVER_DUMP_L15:
        ;
        do
          if(vd->fname == ((char *)NULL))
          {
            signed int *return_value___errno_location$6;
            return_value___errno_location$6=__errno_location();
            VAS_Fail("VSM_N_Arg", "vsm.c", 168, "((vd->fname)) != 0", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
      }

      else
        vd->fname = (char *)(void *)0;
    }
    while((_Bool)0);
    vd->N_opt = 1;
    return 1;
  }
}

// VSM_Name
// file ../../include/vapi/vsm.h line 115
const char * VSM_Name(struct VSM_data *vd)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSM_Name", "vsm.c", 179, "(vd) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->magic == 1849415323u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSM_Name", "vsm.c", 179, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  return vd->name;
}

// VSM_New
// file ../../include/vapi/vsm.h line 64
struct VSM_data * VSM_New(void)
{
  struct VSM_data *vd;
  do
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc(sizeof(struct VSM_data) /*240ul*/ , (unsigned long int)1);
    vd = (struct VSM_data *)return_value_calloc$1;
    if(!(vd == ((struct VSM_data *)NULL)))
      vd->magic = (unsigned int)0x6e3bd69b;

  }
  while((_Bool)0);
  if(vd == ((struct VSM_data *)NULL))
    return vd;

  else
  {
    do
    {
      if(!(vd->name == ((char *)NULL)))
        free((void *)vd->name);

      vd->name=strdup("");

    __CPROVER_DUMP_L5:
      ;
      do
        if(vd->name == ((char *)NULL))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          VAS_Fail("VSM_New", "vsm.c", 72, "((vd->name)) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    vd->vsm_fd = -1;

  __CPROVER_DUMP_L9:
    ;
    do
    {
      if(vd == ((struct VSM_data *)NULL))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("VSM_New", "vsm.c", 75, "(vd) != NULL", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(vd->magic == 1849415323u))
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          VAS_Fail("VSM_New", "vsm.c", 75, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    return vd;
  }
}

// VSM_Open
// file ../../include/vapi/vsm.h line 120
signed int VSM_Open(struct VSM_data *vd)
{
  signed int i;
  struct VSM_head slh;
  void *v;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSM_Open", "vsm.c", 219, "(vd) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->magic == 1849415323u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSM_Open", "vsm.c", 219, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  signed int return_value_vsm_diag$6;
  if(!(vd->head == ((struct VSM_head *)NULL)))
    return 0;

  else
  {
    if(vd->fname == ((char *)NULL))
    {
      i=VSM_n_Arg(vd, "");
      if(!(i >= 0))
        return i;


    __CPROVER_DUMP_L6:
      ;
      do
        if(vd->fname == ((char *)NULL))
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          VAS_Fail("VSM_Open", "vsm.c", 230, "(vd->fname) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }

    vd->vsm_fd=open(vd->fname, 00);
    if(!(vd->vsm_fd >= 0))
    {
      return_value___errno_location$4=__errno_location();
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      return_value_vsm_diag$6=vsm_diag(vd, "Cannot open %s: %s\n", vd->fname, return_value_strerror$5);
      return return_value_vsm_diag$6;
    }

    else
    {
      do
      {

      __CPROVER_DUMP_L9:
        ;
        signed int return_value_fstat$8;
        return_value_fstat$8=fstat(vd->vsm_fd, &vd->fstat);
        if(!(return_value_fstat$8 == 0))
        {
          signed int *return_value___errno_location$7;
          return_value___errno_location$7=__errno_location();
          VAS_Fail("VSM_Open", "vsm.c", 238, "(fstat(vd->vsm_fd, &vd->fstat)) == 0", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
        }

      }
      while((_Bool)0);
      if(!((61440u & vd->fstat.st_mode) == 32768u))
      {
        do
        {

        __CPROVER_DUMP_L11:
          ;
          signed int return_value_close$10;
          return_value_close$10=close(vd->vsm_fd);
          if(!(return_value_close$10 == 0))
          {
            signed int *return_value___errno_location$9;
            return_value___errno_location$9=__errno_location();
            VAS_Fail("VSM_Open", "vsm.c", 240, "(close(vd->vsm_fd)) == 0", *return_value___errno_location$9, (enum vas_e)VAS_ASSERT);
          }

        }
        while((_Bool)0);
        vd->vsm_fd = -1;
        signed int return_value_vsm_diag$11;
        return_value_vsm_diag$11=vsm_diag(vd, "%s is not a regular file\n", vd->fname);
        return return_value_vsm_diag$11;
      }

      signed long int return_value_read$12;
      return_value_read$12=read(vd->vsm_fd, (void *)&slh, sizeof(struct VSM_head) /*48ul*/ );
      i = (signed int)return_value_read$12;
      if(!((unsigned long int)i == sizeof(struct VSM_head) /*48ul*/ ))
      {
        do
        {

        __CPROVER_DUMP_L14:
          ;
          signed int return_value_close$14;
          return_value_close$14=close(vd->vsm_fd);
          if(!(return_value_close$14 == 0))
          {
            signed int *return_value___errno_location$13;
            return_value___errno_location$13=__errno_location();
            VAS_Fail("VSM_Open", "vsm.c", 248, "(close(vd->vsm_fd)) == 0", *return_value___errno_location$13, (enum vas_e)VAS_ASSERT);
          }

        }
        while((_Bool)0);
        vd->vsm_fd = -1;
        signed int *return_value___errno_location$15;
        return_value___errno_location$15=__errno_location();
        char *return_value_strerror$16;
        return_value_strerror$16=strerror(*return_value___errno_location$15);
        signed int return_value_vsm_diag$17;
        return_value_vsm_diag$17=vsm_diag(vd, "Cannot read %s: %s\n", vd->fname, return_value_strerror$16);
        return return_value_vsm_diag$17;
      }

      signed int return_value_memcmp$21;
      return_value_memcmp$21=memcmp((const void *)slh.marker, (const void *)"VSMHEAD0", sizeof(char [8l]) /*8ul*/ );
      if(!(return_value_memcmp$21 == 0))
      {
        do
        {

        __CPROVER_DUMP_L17:
          ;
          signed int return_value_close$19;
          return_value_close$19=close(vd->vsm_fd);
          if(!(return_value_close$19 == 0))
          {
            signed int *return_value___errno_location$18;
            return_value___errno_location$18=__errno_location();
            VAS_Fail("VSM_Open", "vsm.c", 255, "(close(vd->vsm_fd)) == 0", *return_value___errno_location$18, (enum vas_e)VAS_ASSERT);
          }

        }
        while((_Bool)0);
        vd->vsm_fd = -1;
        signed int return_value_vsm_diag$20;
        return_value_vsm_diag$20=vsm_diag(vd, "Not a VSM file %s\n", vd->fname);
        return return_value_vsm_diag$20;
      }

      if(vd->N_opt == 0)
      {
        if(slh.alloc_seq == 0u)
        {
          do
          {

          __CPROVER_DUMP_L20:
            ;
            signed int return_value_close$23;
            return_value_close$23=close(vd->vsm_fd);
            if(!(return_value_close$23 == 0))
            {
              signed int *return_value___errno_location$22;
              return_value___errno_location$22=__errno_location();
              VAS_Fail("VSM_Open", "vsm.c", 261, "(close(vd->vsm_fd)) == 0", *return_value___errno_location$22, (enum vas_e)VAS_ASSERT);
            }

          }
          while((_Bool)0);
          vd->vsm_fd = -1;
          signed int return_value_vsm_diag$24;
          return_value_vsm_diag$24=vsm_diag(vd, "Abandoned VSM file (Varnish not running?) %s\n", vd->fname);
          return return_value_vsm_diag$24;
        }

      }

      v=mmap((void *)0, (unsigned long int)slh.shm_size, 0x1, 0x01 | 0, vd->vsm_fd, (signed long int)0);
      if(v == (void *)-1)
      {
        do
        {

        __CPROVER_DUMP_L23:
          ;
          signed int return_value_close$26;
          return_value_close$26=close(vd->vsm_fd);
          if(!(return_value_close$26 == 0))
          {
            signed int *return_value___errno_location$25;
            return_value___errno_location$25=__errno_location();
            VAS_Fail("VSM_Open", "vsm.c", 271, "(close(vd->vsm_fd)) == 0", *return_value___errno_location$25, (enum vas_e)VAS_ASSERT);
          }

        }
        while((_Bool)0);
        vd->vsm_fd = -1;
        signed int *return_value___errno_location$27;
        return_value___errno_location$27=__errno_location();
        char *return_value_strerror$28;
        return_value_strerror$28=strerror(*return_value___errno_location$27);
        signed int return_value_vsm_diag$29;
        return_value_vsm_diag$29=vsm_diag(vd, "Cannot mmap %s: %s\n", vd->fname, return_value_strerror$28);
        return return_value_vsm_diag$29;
      }

      vd->head = (struct VSM_head *)v;
      vd->b = (char *)v;
      vd->e = vd->b + slh.shm_size;
      vd->age_ok = vd->head->age;
      vd->t_ok=VTIM_mono();
      return 0;
    }
  }
}

// VSM_ResetError
// file ../../include/vapi/vsm.h line 86
void VSM_ResetError(struct VSM_data *vd)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSM_ResetError", "vsm.c", 119, "(vd) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->magic == 1849415323u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSM_ResetError", "vsm.c", 119, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  if(!(vd->diag == ((struct vsb *)NULL)))
  {
    VSB_delete(vd->diag);
    vd->diag = (struct vsb *)(void *)0;
  }

}

// VSM_StillValid
// file vsm.c line 407
enum VSM_valid_e VSM_StillValid(struct VSM_data *vd, struct VSM_fantom *vf)
{
  struct VSM_fantom f2;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSM_StillValid", "vsm.c", 411, "(vd) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->magic == 1849415323u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSM_StillValid", "vsm.c", 411, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L5:
  ;
  do
    if(vf == ((struct VSM_fantom *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("VSM_StillValid", "vsm.c", 412, "(vf) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  signed int return_value_VSM__itern$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  if(vd->head == ((struct VSM_head *)NULL))
    return (enum VSM_valid_e)VSM_invalid;

  else
    if(vd->N_opt == 0)
    {
      if(!(vd->head->alloc_seq == 0u))
        goto __CPROVER_DUMP_L8;

      return (enum VSM_valid_e)VSM_invalid;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      if(vf->chunk == ((struct VSM_chunk *)NULL))
        return (enum VSM_valid_e)VSM_invalid;

      else
        if(vf->priv == (unsigned long int)vd->head->alloc_seq)
          return (enum VSM_valid_e)VSM_valid;

        else
        {
          VSM__iter0(vd, &f2);
          do
          {
            return_value_VSM__itern$4=VSM__itern(vd, &f2);
            if(return_value_VSM__itern$4 == 0)
              break;

            if(!(f2.chunk == vf->chunk))
              tmp_if_expr$5 = (_Bool)1;

            else
              tmp_if_expr$5 = f2.b != vf->b ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$5)
              tmp_if_expr$6 = (_Bool)1;

            else
              tmp_if_expr$6 = f2.e != vf->e ? (_Bool)1 : (_Bool)0;
            if(!tmp_if_expr$6)
            {
              signed int return_value_strcmp$7;
              return_value_strcmp$7=strcmp(f2.class, vf->class);
              if(return_value_strcmp$7 == 0)
              {
                signed int return_value_strcmp$8;
                return_value_strcmp$8=strcmp(f2.type, vf->type);
                if(return_value_strcmp$8 == 0)
                {
                  signed int return_value_strcmp$9;
                  return_value_strcmp$9=strcmp(f2.ident, vf->ident);
                  if(return_value_strcmp$9 == 0)
                  {
                    vf->priv = (unsigned long int)vd->head->alloc_seq;
                    return (enum VSM_valid_e)VSM_similar;
                  }

                }

              }

            }

          }
          while((_Bool)1);
          return (enum VSM_valid_e)VSM_invalid;
        }
    }
}

// VSM__iter0
// file vsm.c line 348
void VSM__iter0(struct VSM_data *vd, struct VSM_fantom *vf)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSM__iter0", "vsm.c", 351, "(vd) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->magic == 1849415323u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSM__iter0", "vsm.c", 351, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L5:
  ;
  do
    if(vf == ((struct VSM_fantom *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("VSM__iter0", "vsm.c", 352, "(vf) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  memset((void *)vf, 0, sizeof(struct VSM_fantom) /*176ul*/ );
}

// VSM__itern
// file vsm.c line 358
signed int VSM__itern(struct VSM_data *vd, struct VSM_fantom *vf)
{
  struct VSM_chunk *c = (struct VSM_chunk *)(void *)0;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSM__itern", "vsm.c", 362, "(vd) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->magic == 1849415323u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSM__itern", "vsm.c", 362, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L5:
  ;
  do
    if(vf == ((struct VSM_fantom *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("VSM__itern", "vsm.c", 363, "(vf) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  _Bool tmp_if_expr$6;
  if(vd->head == ((struct VSM_head *)NULL))
    return 0;

  else
  {
    if(vd->N_opt == 0)
      tmp_if_expr$6 = vd->head->alloc_seq == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
      return 0;

    else
      if(!(vf->chunk == ((struct VSM_chunk *)NULL)))
      {
        if(vd->N_opt == 0)
        {
          if(!(vf->priv == (unsigned long int)vd->head->alloc_seq))
            return 0;

        }

        if(vf->chunk->len == 0l)
          return 0;

        if(vf->chunk->next == 0l)
          return 0;

        c = (struct VSM_chunk *)(void *)(vd->b + vf->chunk->next);
        do
          if(c == vf->chunk)
          {
            signed int *return_value___errno_location$4;
            return_value___errno_location$4=__errno_location();
            VAS_Fail("VSM__itern", "vsm.c", 378, "c != vf->chunk", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
      }

      else
        if(vd->head->first == 0l)
          return 0;

        else
        {

        __CPROVER_DUMP_L17:
          ;
          do
            if(!(vf->chunk == ((struct VSM_chunk *)NULL)))
            {
              signed int *return_value___errno_location$5;
              return_value___errno_location$5=__errno_location();
              VAS_Fail("VSM__itern", "vsm.c", 383, "(vf->chunk) == 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
            }

          while((_Bool)0);
          c = (struct VSM_chunk *)(void *)(vd->b + vd->head->first);
        }

  __CPROVER_DUMP_L19:
    ;
    do
      if(c == ((struct VSM_chunk *)NULL))
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        VAS_Fail("VSM__itern", "vsm.c", 386, "(c) != 0", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    signed int return_value_memcmp$8;
    return_value_memcmp$8=memcmp((const void *)c->marker, (const void *)"VSMCHUNK", sizeof(char [8l]) /*8ul*/ );
    if(!(return_value_memcmp$8 == 0))
      return 0;

    else
    {
      vf->chunk = c;
      vf->priv = (unsigned long int)vd->head->alloc_seq;
      vf->b = (void *)(vf->chunk + (signed long int)1);
      vf->e = (void *)((char *)vf->b + vf->chunk->len);
      strncpy(vf->class, vf->chunk->class, sizeof(char [8l]) /*8ul*/ );
      vf->class[(signed long int)(sizeof(char [8l]) /*8ul*/  - (unsigned long int)1)] = (char)0;
      strncpy(vf->type, vf->chunk->type, sizeof(char [8l]) /*8ul*/ );
      vf->type[(signed long int)(sizeof(char [8l]) /*8ul*/  - (unsigned long int)1)] = (char)0;
      strncpy(vf->ident, vf->chunk->ident, sizeof(char [128l]) /*128ul*/ );
      vf->ident[(signed long int)(sizeof(char [128l]) /*128ul*/  - (unsigned long int)1)] = (char)0;
      return 1;
    }
  }
}

// VSM_n_Arg
// file ../../include/vapi/vsm.h line 93
signed int VSM_n_Arg(struct VSM_data *vd, const char *arg)
{
  char *name = (char *)(void *)0;
  char *fname = (char *)(void *)0;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VSM_n_Arg", "vsm.c", 135, "(vd) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->magic == 1849415323u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("VSM_n_Arg", "vsm.c", 135, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  signed int return_value_vsm_diag$3;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  signed int return_value_vsm_diag$6;
  if(!(vd->head == ((struct VSM_head *)NULL)))
  {
    return_value_vsm_diag$3=vsm_diag(vd, "VSM_n_Arg: Already open\n");
    return return_value_vsm_diag$3;
  }

  else
  {
    signed int return_value_VIN_N_Arg$7;
    return_value_VIN_N_Arg$7=VIN_N_Arg(arg, &name, (char **)(void *)0, &fname);
    if(!(return_value_VIN_N_Arg$7 == 0))
    {
      return_value___errno_location$4=__errno_location();
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      return_value_vsm_diag$6=vsm_diag(vd, "Invalid instance name: %s\n", return_value_strerror$5);
      return return_value_vsm_diag$6;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      do
        if(name == ((char *)NULL))
        {
          signed int *return_value___errno_location$8;
          return_value___errno_location$8=__errno_location();
          VAS_Fail("VSM_n_Arg", "vsm.c", 142, "(name) != 0", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);

    __CPROVER_DUMP_L8:
      ;
      do
        if(fname == ((char *)NULL))
        {
          signed int *return_value___errno_location$9;
          return_value___errno_location$9=__errno_location();
          VAS_Fail("VSM_n_Arg", "vsm.c", 143, "(fname) != 0", *return_value___errno_location$9, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      if(!(vd->name == ((char *)NULL)))
        free((void *)vd->name);

      vd->name = name;
      if(!(vd->fname == ((char *)NULL)))
        free((void *)vd->fname);

      vd->fname = fname;
      vd->N_opt = 0;
      return 1;
    }
  }
}

// VTIM_format
// file ../../lib/libvarnish/vtim.c line 103
void VTIM_format(double t, char *p)
{
  struct tm tm;
  signed long int tt = (signed long int)t;
  gmtime_r(&tt, &tm);
  do
  {

  __CPROVER_DUMP_L1:
    ;
    unsigned long int return_value_strftime$2;
    return_value_strftime$2=strftime(p, (unsigned long int)30, "%a, %d %b %Y %T GMT", &tm);
    if(return_value_strftime$2 == 0ul)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VTIM_format", "../../lib/libvarnish/vtim.c", 110, "(strftime(p, 30, \"%a, %d %b %Y %T GMT\", &tm)) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  }
  while((_Bool)0);
}

// VTIM_mono
// file ../../lib/libvarnish/vtim.c line 69
double VTIM_mono(void)
{
  struct timespec ts;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int return_value_clock_gettime$2;
    return_value_clock_gettime$2=clock_gettime(1, &ts);
    if(!(return_value_clock_gettime$2 == 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VTIM_mono", "../../lib/libvarnish/vtim.c", 76, "(clock_gettime(1, &ts)) == 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  }
  while((_Bool)0);
  return (double)ts.tv_sec + 1e-9 * (double)ts.tv_nsec;
}

// VTIM_parse
// file ../../lib/libvarnish/vtim.c line 124
double VTIM_parse(const char *p)
{
  double t;
  struct tm tm;
  const char **r = fmts;
  for( ; !(*r == ((const char *)NULL)); r = r + 1l)
  {
    memset((void *)&tm, 0, sizeof(struct tm) /*56ul*/ );
    char *return_value_strptime$2;
    return_value_strptime$2=strptime(p, *r, &tm);
    if(!(return_value_strptime$2 == ((char *)NULL)))
    {
      tm.tm_isdst = -1;
      signed long int return_value_timegm$1;
      return_value_timegm$1=timegm(&tm);
      t = (double)return_value_timegm$1;
      return t;
    }

  }
  return (double)0;
}

// VTIM_real
// file ../../lib/libvarnish/vtim.c line 87
double VTIM_real(void)
{
  struct timespec ts;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int return_value_clock_gettime$2;
    return_value_clock_gettime$2=clock_gettime(0, &ts);
    if(!(return_value_clock_gettime$2 == 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VTIM_real", "../../lib/libvarnish/vtim.c", 92, "(clock_gettime(0, &ts)) == 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  }
  while((_Bool)0);
  return (double)ts.tv_sec + 1e-9 * (double)ts.tv_nsec;
}

// VTIM_sleep
// file ../../include/vtim.h line 37
void VTIM_sleep(double t)
{
  struct timespec ts;
  ts=VTIM_timespec(t);
  nanosleep(&ts, (struct timespec *)(void *)0);
}

// VTIM_timespec
// file ../../lib/libvarnish/vtim.c line 194
struct timespec VTIM_timespec(double t)
{
  struct timespec tv;
  double return_value_trunc$1;
  return_value_trunc$1=trunc(t);
  tv.tv_sec = (signed long int)return_value_trunc$1;
  tv.tv_nsec = (signed long int)(signed int)(1e9 * (t - (double)tv.tv_sec));
  return tv;
}

// VTIM_timeval
// file ../../lib/libvarnish/vtim.c line 184
struct timeval VTIM_timeval(double t)
{
  struct timeval tv;
  double return_value_trunc$1;
  return_value_trunc$1=trunc(t);
  tv.tv_sec = (signed long int)return_value_trunc$1;
  tv.tv_usec = (signed long int)(signed int)(1e6 * (t - (double)tv.tv_sec));
  return tv;
}

// VUT_Arg
// file ../../include/vut.h line 72
signed int VUT_Arg(signed int opt, const char *arg)
{
  signed int i;
  char *p;
  signed int return_value_VUT_g_Arg$1;
  signed long int return_value_strtol$2;
  signed int return_value_VSM_n_Arg$5;
  const char *return_value_VSM_Error$4;
  signed int return_value_VSM_N_Arg$8;
  const char *return_value_VSM_Error$7;
  const char *return_value_VSL_Error$13;
  switch(opt)
  {
    case 100:
    {
      VUT.d_opt = 1;
      return 1;
    }
    case 68:
    {
      VUT.D_opt = 1;
      return 1;
    }
    case 103:
    {
      return_value_VUT_g_Arg$1=VUT_g_Arg(arg);
      return return_value_VUT_g_Arg$1;
    }
    case 107:
    {
      return_value_strtol$2=strtol(arg, &p, 10);
      VUT.k_arg = (signed int)return_value_strtol$2;
      if(!((signed int)*p == 0) || !(VUT.k_arg >= 1))
        VUT_Error(1, "-k: Invalid number '%s'", arg);

      return 1;
    }
    case 110:
    {
      if(VUT.vsm == ((struct VSM_data *)NULL))
        VUT.vsm=VSM_New();


    __CPROVER_DUMP_L7:
      ;
      do
        if(VUT.vsm == ((struct VSM_data *)NULL))
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          VAS_Fail("VUT_Arg", "../../lib/libvarnishtools/vut.c", 159, "(VUT.vsm) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      return_value_VSM_n_Arg$5=VSM_n_Arg(VUT.vsm, arg);
      if(!(return_value_VSM_n_Arg$5 >= 1))
      {
        return_value_VSM_Error$4=VSM_Error(VUT.vsm);
        VUT_Error(1, "%s", return_value_VSM_Error$4);
      }

      return 1;
    }
    case 78:
    {
      if(VUT.vsm == ((struct VSM_data *)NULL))
        VUT.vsm=VSM_New();


    __CPROVER_DUMP_L11:
      ;
      do
        if(VUT.vsm == ((struct VSM_data *)NULL))
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          VAS_Fail("VUT_Arg", "../../lib/libvarnishtools/vut.c", 167, "(VUT.vsm) != 0", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      return_value_VSM_N_Arg$8=VSM_N_Arg(VUT.vsm, arg);
      if(!(return_value_VSM_N_Arg$8 >= 1))
      {
        return_value_VSM_Error$7=VSM_Error(VUT.vsm);
        VUT_Error(1, "%s", return_value_VSM_Error$7);
      }

      VUT.d_opt = 1;
      return 1;
    }
    case 80:
    {
      do
      {
        if(!(VUT.P_arg == ((char *)NULL)))
          free((void *)VUT.P_arg);

        if(!(arg == ((const char *)NULL)))
        {
          VUT.P_arg=strdup(arg);

        __CPROVER_DUMP_L16:
          ;
          do
            if(VUT.P_arg == ((char *)NULL))
            {
              signed int *return_value___errno_location$9;
              return_value___errno_location$9=__errno_location();
              VAS_Fail("VUT_Arg", "../../lib/libvarnishtools/vut.c", 174, "((VUT.P_arg)) != 0", *return_value___errno_location$9, (enum vas_e)VAS_ASSERT);
            }

          while((_Bool)0);
        }

        else
          VUT.P_arg = (char *)(void *)0;
      }
      while((_Bool)0);
      return 1;
    }
    case 113:
    {
      do
      {
        if(!(VUT.q_arg == ((char *)NULL)))
          free((void *)VUT.q_arg);

        if(!(arg == ((const char *)NULL)))
        {
          VUT.q_arg=strdup(arg);

        __CPROVER_DUMP_L22:
          ;
          do
            if(VUT.q_arg == ((char *)NULL))
            {
              signed int *return_value___errno_location$10;
              return_value___errno_location$10=__errno_location();
              VAS_Fail("VUT_Arg", "../../lib/libvarnishtools/vut.c", 178, "((VUT.q_arg)) != 0", *return_value___errno_location$10, (enum vas_e)VAS_ASSERT);
            }

          while((_Bool)0);
        }

        else
          VUT.q_arg = (char *)(void *)0;
      }
      while((_Bool)0);
      return 1;
    }
    case 114:
    {
      do
      {
        if(!(VUT.r_arg == ((char *)NULL)))
          free((void *)VUT.r_arg);

        if(!(arg == ((const char *)NULL)))
        {
          VUT.r_arg=strdup(arg);

        __CPROVER_DUMP_L28:
          ;
          do
            if(VUT.r_arg == ((char *)NULL))
            {
              signed int *return_value___errno_location$11;
              return_value___errno_location$11=__errno_location();
              VAS_Fail("VUT_Arg", "../../lib/libvarnishtools/vut.c", 182, "((VUT.r_arg)) != 0", *return_value___errno_location$11, (enum vas_e)VAS_ASSERT);
            }

          while((_Bool)0);
        }

        else
          VUT.r_arg = (char *)(void *)0;
      }
      while((_Bool)0);
      return 1;
    }
    case 86:
    {
      VCS_Message(VUT.progname);
      exit(0);
    }
    default:
    {

    __CPROVER_DUMP_L33:
      ;
      do
        if(VUT.vsl == ((struct VSL_data *)NULL))
        {
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          VAS_Fail("VUT_Arg", "../../lib/libvarnishtools/vut.c", 189, "(VUT.vsl) != 0", *return_value___errno_location$12, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      i=VSL_Arg(VUT.vsl, opt, arg);
      if(!(i >= 0))
      {
        return_value_VSL_Error$13=VSL_Error(VUT.vsl);
        VUT_Error(1, "%s", return_value_VSL_Error$13);
      }

      return i;
    }
  }
}

// VUT_Error
// file ../../lib/libvarnishtools/vut.c line 105
void VUT_Error(signed int status, const char *fmt, ...)
{
  void **ap;

__CPROVER_DUMP_L1:
  ;
  do
    if(fmt == ((const char *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VUT_Error", "../../lib/libvarnishtools/vut.c", 109, "(fmt) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  ap = (void **)&fmt;
  vfprintf(stderr, fmt, ap);
  ap = ((void **)NULL);
  fprintf(stderr, "\n");
  if(!(status == 0))
    exit(status);

}

// VUT_Fini
// file ../../include/vut.h line 78
void VUT_Fini(void)
{
  free((void *)VUT.r_arg);
  free((void *)VUT.P_arg);
  free((void *)VUT.name);
  vut_vpf_remove();

__CPROVER_DUMP_L1:
  ;
  do
    if(!(VUT.pfh == ((struct vpf_fh *)NULL)))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VUT_Fini", "../../lib/libvarnishtools/vut.c", 277, "(VUT.pfh) == 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(!(VUT.vslq == ((struct VSLQ *)NULL)))
    VSLQ_Delete(&VUT.vslq);

  if(!(VUT.vsl == ((struct VSL_data *)NULL)))
    VSL_Delete(VUT.vsl);

  if(!(VUT.vsm == ((struct VSM_data *)NULL)))
    VSM_Delete(VUT.vsm);

  memset((void *)&VUT, 0, sizeof(struct VUT) /*136ul*/ );
}

// VUT_Init
// file ../../include/vut.h line 76
void VUT_Init(const char *progname)
{
  VUT.progname = progname;
  do
  {
    if(!(VUT.name == ((char *)NULL)))
      free((void *)VUT.name);

    VUT.name=strdup("");

  __CPROVER_DUMP_L3:
    ;
    do
      if(VUT.name == ((char *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("VUT_Init", "../../lib/libvarnishtools/vut.c", 201, "((VUT.name)) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  VUT.g_arg = VSL_g_vxid;

__CPROVER_DUMP_L7:
  ;
  do
    if(!(VUT.vsl == ((struct VSL_data *)NULL)))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("VUT_Init", "../../lib/libvarnishtools/vut.c", 203, "(VUT.vsl) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  VUT.vsl=VSL_New();

__CPROVER_DUMP_L9:
  ;
  do
    if(VUT.vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("VUT_Init", "../../lib/libvarnishtools/vut.c", 205, "(VUT.vsl) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  VUT.k_arg = -1;
}

// VUT_Main
// file ../../include/vut.h line 80
signed int VUT_Main(void)
{
  struct VSL_cursor *c;
  signed int i = -1;

__CPROVER_DUMP_L1:
  ;
  do
    if(VUT.vslq == ((struct VSLQ *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VUT_Main", "../../lib/libvarnishtools/vut.c", 295, "(VUT.vslq) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  while(VUT.sigint == 0)
  {
    if(!(VUT.sighup_f == ((signed int (*)(void))NULL)) && !(VUT.sighup == 0))
    {
      VUT.sighup = 0;
      i=VUT.sighup_f();
      if(!(i == 0))
        break;

    }

    if(!(VUT.sigusr1 == 0))
    {
      VUT.sigusr1 = 0;
      if(!(VUT.vslq == ((struct VSLQ *)NULL)))
        VSLQ_Flush(VUT.vslq, vut_dispatch, (void *)0);

    }

    if(VUT.vslq == ((struct VSLQ *)NULL))
    {

    __CPROVER_DUMP_L6:
      ;
      do
        if(!(VUT.r_arg == ((char *)NULL)))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          VAS_Fail("VUT_Main", "../../lib/libvarnishtools/vut.c", 315, "(VUT.r_arg) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);

    __CPROVER_DUMP_L8:
      ;
      do
        if(VUT.vsm == ((struct VSM_data *)NULL))
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          VAS_Fail("VUT_Main", "../../lib/libvarnishtools/vut.c", 316, "(VUT.vsm) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      VTIM_sleep(0.1);
      signed int return_value_VSM_Open$4;
      return_value_VSM_Open$4=VSM_Open(VUT.vsm);
      if(!(return_value_VSM_Open$4 == 0))
      {
        VSM_ResetError(VUT.vsm);
        continue;
      }

      c=VSL_CursorVSM(VUT.vsl, VUT.vsm, (unsigned int)(1 << 0 | 1 << 1));
      if(c == ((struct VSL_cursor *)NULL))
      {
        VSL_ResetError(VUT.vsl);
        VSM_Close(VUT.vsm);
        continue;
      }

      VUT.vslq=VSLQ_New(VUT.vsl, &c, (enum VSL_grouping_e)VUT.g_arg, VUT.q_arg);

    __CPROVER_DUMP_L12:
      ;
      do
        if(VUT.vslq == ((struct VSLQ *)NULL))
        {
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          VAS_Fail("VUT_Main", "../../lib/libvarnishtools/vut.c", 330, "(VUT.vslq) != 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);

    __CPROVER_DUMP_L14:
      ;
      do
        if(!(c == ((struct VSL_cursor *)NULL)))
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          VAS_Fail("VUT_Main", "../../lib/libvarnishtools/vut.c", 331, "(c) == 0", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      VUT_Error(0, "Log reacquired");
    }

    i=VSLQ_Dispatch(VUT.vslq, vut_dispatch, (void *)0);
    if(i == 1)
      continue;

    else
      if(i == 0)
      {
        if(!(VUT.idle_f == ((signed int (*)(void))NULL)))
        {
          i=VUT.idle_f();
          if(!(i == 0))
            break;

        }

        VTIM_sleep(0.01);
        continue;
      }

      else
        if(i == -1)
          break;

    if(VUT.vsm == ((struct VSM_data *)NULL))
      break;

    VSLQ_Flush(VUT.vslq, vut_dispatch, (void *)0);
    VSLQ_Delete(&VUT.vslq);

  __CPROVER_DUMP_L21:
    ;
    do
      if(!(VUT.vslq == ((struct VSLQ *)NULL)))
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        VAS_Fail("VUT_Main", "../../lib/libvarnishtools/vut.c", 360, "(VUT.vslq) == 0", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    if(i == -2)
    {
      VUT_Error(0, "Log abandoned");
      VSM_Close(VUT.vsm);
    }

    else
      if(!(i >= -2))
        VUT_Error(0, "Log overrun");

  }
  return i;
}

// VUT_Setup
// file ../../include/vut.h line 74
void VUT_Setup(void)
{
  struct VSL_cursor *c;

__CPROVER_DUMP_L1:
  ;
  do
    if(VUT.vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("VUT_Setup", "../../lib/libvarnishtools/vut.c", 214, "(VUT.vsl) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(!(VUT.r_arg == ((char *)NULL)) && !(VUT.vsm == ((struct VSM_data *)NULL)))
    VUT_Error(1, "Can't have both -n and -r options");

  const char *return_value_VSM_Error$4;
  if(!(VUT.r_arg == ((char *)NULL)))
  {
    do
    {
      if(!(VUT.name == ((char *)NULL)))
        free((void *)VUT.name);

      if(!(VUT.r_arg == ((char *)NULL)))
      {
        VUT.name=strdup(VUT.r_arg);

      __CPROVER_DUMP_L6:
        ;
        do
          if(VUT.name == ((char *)NULL))
          {
            signed int *return_value___errno_location$2;
            return_value___errno_location$2=__errno_location();
            VAS_Fail("VUT_Setup", "../../lib/libvarnishtools/vut.c", 220, "((VUT.name)) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
      }

      else
        VUT.name = (char *)(void *)0;
    }
    while((_Bool)0);
    c=VSL_CursorFile(VUT.vsl, VUT.r_arg, (unsigned int)0);
  }

  else
  {
    if(VUT.vsm == ((struct VSM_data *)NULL))
      VUT.vsm=VSM_New();


  __CPROVER_DUMP_L11:
    ;
    do
      if(VUT.vsm == ((struct VSM_data *)NULL))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("VUT_Setup", "../../lib/libvarnishtools/vut.c", 226, "(VUT.vsm) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    signed int return_value_VSM_Open$5;
    return_value_VSM_Open$5=VSM_Open(VUT.vsm);
    if(!(return_value_VSM_Open$5 == 0))
    {
      return_value_VSM_Error$4=VSM_Error(VUT.vsm);
      VUT_Error(1, "Can't open VSM file (%s)", return_value_VSM_Error$4);
    }

    do
    {
      if(!(VUT.name == ((char *)NULL)))
        free((void *)VUT.name);

      const char *return_value_VSM_Name$8;
      return_value_VSM_Name$8=VSM_Name(VUT.vsm);
      if(!(return_value_VSM_Name$8 == ((const char *)NULL)))
      {
        const char *return_value_VSM_Name$6;
        return_value_VSM_Name$6=VSM_Name(VUT.vsm);
        VUT.name=strdup(return_value_VSM_Name$6);

      __CPROVER_DUMP_L15:
        ;
        do
          if(VUT.name == ((char *)NULL))
          {
            signed int *return_value___errno_location$7;
            return_value___errno_location$7=__errno_location();
            VAS_Fail("VUT_Setup", "../../lib/libvarnishtools/vut.c", 230, "((VUT.name)) != 0", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
      }

      else
        VUT.name = (char *)(void *)0;
    }
    while((_Bool)0);
    c=VSL_CursorVSM(VUT.vsl, VUT.vsm, (unsigned int)((VUT.d_opt != 0 ? 1 << 2 : 1 << 0) | 1 << 1));
  }
  const char *return_value_VSL_Error$9;
  if(c == ((struct VSL_cursor *)NULL))
  {
    return_value_VSL_Error$9=VSL_Error(VUT.vsl);
    VUT_Error(1, "Can't open log (%s)", return_value_VSL_Error$9);
  }

  VUT.vslq=VSLQ_New(VUT.vsl, &c, (enum VSL_grouping_e)VUT.g_arg, VUT.q_arg);
  const char *return_value_VSL_Error$10;
  if(VUT.vslq == ((struct VSLQ *)NULL))
  {
    return_value_VSL_Error$10=VSL_Error(VUT.vsl);
    VUT_Error(1, "Query expression error:\n%s", return_value_VSL_Error$10);
  }


__CPROVER_DUMP_L21:
  ;
  do
    if(!(c == ((struct VSL_cursor *)NULL)))
    {
      signed int *return_value___errno_location$11;
      return_value___errno_location$11=__errno_location();
      VAS_Fail("VUT_Setup", "../../lib/libvarnishtools/vut.c", 242, "(c) == 0", *return_value___errno_location$11, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  signal(1, vut_sighup);
  signal(2, vut_sigint);
  signal(15, vut_sigint);
  signal(10, vut_sigusr1);
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  if(!(VUT.P_arg == ((char *)NULL)))
  {

  __CPROVER_DUMP_L23:
    ;
    do
      if(!(VUT.pfh == ((struct vpf_fh *)NULL)))
      {
        signed int *return_value___errno_location$12;
        return_value___errno_location$12=__errno_location();
        VAS_Fail("VUT_Setup", "../../lib/libvarnishtools/vut.c", 252, "(VUT.pfh) == 0", *return_value___errno_location$12, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    VUT.pfh=VPF_Open(VUT.P_arg, (unsigned int)0644, (signed int *)(void *)0);
    if(VUT.pfh == ((struct vpf_fh *)NULL))
    {
      return_value___errno_location$13=__errno_location();
      return_value_strerror$14=strerror(*return_value___errno_location$13);
      VUT_Error(1, "%s: %s", VUT.P_arg, return_value_strerror$14);
    }

  }

  signed int return_value_daemon$17;
  signed int *return_value___errno_location$15;
  char *return_value_strerror$16;
  if(!(VUT.D_opt == 0))
  {
    return_value_daemon$17=daemon(0, 0);
    if(return_value_daemon$17 == -1)
    {
      return_value___errno_location$15=__errno_location();
      return_value_strerror$16=strerror(*return_value___errno_location$15);
      VUT_Error(1, "Daemon mode: %s", return_value_strerror$16);
    }

  }

  if(!(VUT.pfh == ((struct vpf_fh *)NULL)))
  {
    VPF_Write(VUT.pfh);
    do
    {

    __CPROVER_DUMP_L28:
      ;
      signed int return_value_atexit$19;
      return_value_atexit$19=atexit(vut_vpf_remove);
      if(!(return_value_atexit$19 == 0))
      {
        signed int *return_value___errno_location$18;
        return_value___errno_location$18=__errno_location();
        VAS_Fail("VUT_Setup", "../../lib/libvarnishtools/vut.c", 265, "(atexit(vut_vpf_remove)) == 0", *return_value___errno_location$18, (enum vas_e)VAS_ASSERT);
      }

    }
    while((_Bool)0);
  }

}

// VUT_g_Arg
// file ../../lib/libvarnishtools/vut.c line 120
signed int VUT_g_Arg(const char *arg)
{
  VUT.g_arg=VSLQ_Name2Grouping(arg, -1);
  if(VUT.g_arg == -2)
    VUT_Error(1, "Ambiguous grouping type: %s", arg);

  else
    if(!(VUT.g_arg >= 0))
      VUT_Error(1, "Unknown grouping type: %s", arg);

  return 1;
}

// _VPF_Remove
// file ../../lib/libvarnish/vpf.c line 225
static signed int _VPF_Remove(struct vpf_fh *pfh, signed int freeit)
{
  signed int error;
  error=vpf_verify(pfh);
  if(!(error == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = error;
    return -1;
  }

  signed int return_value_unlink$3;
  return_value_unlink$3=unlink(pfh->pf_path);
  signed int *return_value___errno_location$2;
  if(return_value_unlink$3 == -1)
  {
    return_value___errno_location$2=__errno_location();
    error = *return_value___errno_location$2;
  }

  signed int return_value_close$5;
  return_value_close$5=close(pfh->pf_fd);
  signed int *return_value___errno_location$4;
  if(return_value_close$5 == -1)
  {
    if(error == 0)
    {
      return_value___errno_location$4=__errno_location();
      error = *return_value___errno_location$4;
    }

  }

  if(!(freeit == 0))
    free((void *)pfh);

  else
    pfh->pf_fd = -1;
  if(!(error == 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    *return_value___errno_location$6 = error;
    return -1;
  }

  return 0;
}

// _assert_VSB_integrity
// file ../../lib/libvarnish/vsb.c line 79
static void _assert_VSB_integrity(const char *fun, struct vsb *s)
{
  (void)fun;
  (void)s;
  do
    if(s == ((struct vsb *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("_assert_VSB_integrity", "../../lib/libvarnish/vsb.c", 85, "s != ((void *)0)", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
    if(!(s->magic == 1250090378u))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("_assert_VSB_integrity", "../../lib/libvarnish/vsb.c", 87, "s->magic == 0x4a82dd8a", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
    if(s->s_buf == ((char *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("_assert_VSB_integrity", "../../lib/libvarnish/vsb.c", 89, "s->s_buf != ((void *)0)", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
    if(s->s_len >= s->s_size)
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("_assert_VSB_integrity", "../../lib/libvarnish/vsb.c", 91, "s->s_len < s->s_size", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
}

// _assert_VSB_integrity$link1
// file ../libvarnish/vsb.c line 79
static void _assert_VSB_integrity$link1(const char *fun$link1, struct vsb *s$link1)
{
  (void)fun$link1;
  (void)s$link1;
  do
    if(s$link1 == ((struct vsb *)NULL))
    {
      signed int *return_value___errno_location$1$link1;
      return_value___errno_location$1$link1=__errno_location();
      VAS_Fail("_assert_VSB_integrity", "../libvarnish/vsb.c", 85, "s != ((void *)0)", *return_value___errno_location$1$link1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
    if(!(s$link1->magic == 1250090378u))
    {
      signed int *return_value___errno_location$2$link1;
      return_value___errno_location$2$link1=__errno_location();
      VAS_Fail("_assert_VSB_integrity", "../libvarnish/vsb.c", 87, "s->magic == 0x4a82dd8a", *return_value___errno_location$2$link1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
    if(s$link1->s_buf == ((char *)NULL))
    {
      signed int *return_value___errno_location$3$link1;
      return_value___errno_location$3$link1=__errno_location();
      VAS_Fail("_assert_VSB_integrity", "../libvarnish/vsb.c", 89, "s->s_buf != ((void *)0)", *return_value___errno_location$3$link1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
    if(s$link1->s_len >= s$link1->s_size)
    {
      signed int *return_value___errno_location$4$link1;
      return_value___errno_location$4$link1=__errno_location();
      VAS_Fail("_assert_VSB_integrity", "../libvarnish/vsb.c", 91, "s->s_len < s->s_size", *return_value___errno_location$4$link1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
}

// _assert_VSB_state
// file ../../lib/libvarnish/vsb.c line 95
static void _assert_VSB_state(const char *fun, struct vsb *s, signed int state)
{
  (void)fun;
  (void)s;
  (void)state;
  do
    if(!((0x00020000 & s->s_flags) == state))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("_assert_VSB_state", "../../lib/libvarnish/vsb.c", 103, "(s->s_flags & 0x00020000) == state", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
}

// _assert_VSB_state$link1
// file ../libvarnish/vsb.c line 95
static void _assert_VSB_state$link1(const char *fun$link1, struct vsb *s$link1, signed int state$link1)
{
  (void)fun$link1;
  (void)s$link1;
  (void)state$link1;
  do
    if(!((0x00020000 & s$link1->s_flags) == state$link1))
    {
      signed int *return_value___errno_location$1$link1;
      return_value___errno_location$1$link1=__errno_location();
      VAS_Fail("_assert_VSB_state", "../libvarnish/vsb.c", 103, "(s->s_flags & 0x00020000) == state", *return_value___errno_location$1$link1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
}

// accumulate
// file varnishtop.c line 117
static signed int accumulate(struct VSL_data *vsl, struct VSL_transaction * const *pt, void *priv)
{
  struct top *tp;
  struct top t;
  unsigned int u;
  unsigned int tag;
  const char *b;
  const char *e;
  const char *p;
  unsigned int len;
  struct VSL_transaction *tr;
  (void)priv;
  tr = pt[(signed long int)0];
  signed int return_value_VSL_Next$1;
  _Bool tmp_if_expr$4;
  const unsigned short int **return_value___ctype_b_loc$3;
  for( ; !(tr == ((struct VSL_transaction *)NULL)); tr = *pt)
  {
    do
    {
      return_value_VSL_Next$1=VSL_Next(tr->c);
      if(!(return_value_VSL_Next$1 == 1))
        break;

      signed int return_value_VSL_Match$2;
      return_value_VSL_Match$2=VSL_Match(vsl, tr->c);
      if(!(return_value_VSL_Match$2 == 0))
      {
        tag = tr->c->rec.ptr[(signed long int)0] >> 24;
        b = (const char *)(tr->c->rec.ptr + (signed long int)2);
        e = b + (signed long int)(tr->c->rec.ptr[(signed long int)0] & (unsigned int)0xffff);
        u = (unsigned int)0;
        p = b;
        for( ; e >= p; p = p + 1l)
        {
          if((signed int)*p == 0)
            break;

          if(!(f_flag == 0))
          {
            if((signed int)*p == 58)
              tmp_if_expr$4 = (_Bool)1;

            else
            {
              return_value___ctype_b_loc$3=__ctype_b_loc();
              tmp_if_expr$4 = ((signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*p] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$4)
              break;

          }

          u = u + (unsigned int)*p;
        }
        len = (unsigned int)(p - b);
        if(!(len == 0u))
        {
          t.hash = u;
          t.tag = (unsigned char)tag;
          t.clen = (signed int)len;
          t.rec_data = (const char *)(tr->c->rec.ptr + (signed long int)2);
          do
          {

          __CPROVER_DUMP_L8:
            ;
            signed int return_value_pthread_mutex_lock$6;
            return_value_pthread_mutex_lock$6=pthread_mutex_lock(&mtx);
            if(!(return_value_pthread_mutex_lock$6 == 0))
            {
              signed int *return_value___errno_location$5;
              return_value___errno_location$5=__errno_location();
              VAS_Fail("accumulate", "varnishtop.c", 153, "(pthread_mutex_lock(&mtx)) == 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
            }

          }
          while((_Bool)0);
          tp=t_key_VRB_FIND(&h_key, &t);
          if(!(tp == ((struct top *)NULL)))
          {
            t_order_VRB_REMOVE(&h_order, tp);
            tp->count = tp->count + 1.0;
            t_order_VRB_INSERT(&h_order, tp);
          }

          else
          {
            ntop = ntop + 1u;
            void *return_value_calloc$7;
            return_value_calloc$7=calloc(sizeof(struct top) /*104ul*/ , (unsigned long int)1);
            tp = (struct top *)return_value_calloc$7;
            do
              if(tp == ((struct top *)NULL))
              {
                signed int *return_value___errno_location$8;
                return_value___errno_location$8=__errno_location();
                VAS_Fail("accumulate", "varnishtop.c", 163, "tp != NULL", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
              }

            while((_Bool)0);
            tp->hash = u;
            tp->count = 1.0;
            tp->clen = (signed int)len;
            tp->tag = (unsigned char)tag;
            tp->rec_buf=strdup(t.rec_data);
            tp->rec_data = tp->rec_buf;

          __CPROVER_DUMP_L13:
            ;
            do
              if(tp->rec_data == ((const char *)NULL))
              {
                signed int *return_value___errno_location$9;
                return_value___errno_location$9=__errno_location();
                VAS_Fail("accumulate", "varnishtop.c", 170, "(tp->rec_data) != 0", *return_value___errno_location$9, (enum vas_e)VAS_ASSERT);
              }

            while((_Bool)0);
            t_key_VRB_INSERT(&h_key, tp);
            t_order_VRB_INSERT(&h_order, tp);
          }
          do
          {

          __CPROVER_DUMP_L15:
            ;
            signed int return_value_pthread_mutex_unlock$11;
            return_value_pthread_mutex_unlock$11=pthread_mutex_unlock(&mtx);
            if(!(return_value_pthread_mutex_unlock$11 == 0))
            {
              signed int *return_value___errno_location$10;
              return_value___errno_location$10=__errno_location();
              VAS_Fail("accumulate", "varnishtop.c", 174, "(pthread_mutex_unlock(&mtx)) == 0", *return_value___errno_location$10, (enum vas_e)VAS_ASSERT);
            }

          }
          while((_Bool)0);
        }

      }

    }
    while((_Bool)1);
    pt = pt + 1l;
  }
  return 0;
}

// be32dec_vect
// file ../libvarnish/vsha256.c line 80
static void be32dec_vect(unsigned int *dst, const unsigned char *src, unsigned long int len)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= len / 4ul); i = i + 1ul)
    dst[(signed long int)i]=vbe32dec((const void *)(src + (signed long int)(i * (unsigned long int)4)));
}

// be32enc_vect
// file ../libvarnish/vsha256.c line 67
static void be32enc_vect(unsigned char *dst, const unsigned int *src, unsigned long int len)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= len / 4ul); i = i + 1ul)
    vbe32enc((void *)(dst + (signed long int)(i * (unsigned long int)4)), src[(signed long int)i]);
}

// chunk_appendbuf
// file vsl_dispatch.c line 373
static void chunk_appendbuf(struct chunk *chunk, const unsigned int *ptr, unsigned long int len)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(chunk == ((struct chunk *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("chunk_appendbuf", "vsl_dispatch.c", 376, "(chunk) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(chunk->magic == 1222377876u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("chunk_appendbuf", "vsl_dispatch.c", 376, "(chunk)->magic == 0x48DC0194", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  do
    if(!((signed int)chunk->type == chunk_t_buf))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("chunk_appendbuf", "vsl_dispatch.c", 377, "chunk->type == chunk_t_buf", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(!(chunk->$anon0.buf.space >= chunk->len + len))
  {
    for( ; !(chunk->$anon0.buf.space >= chunk->len + len); chunk->$anon0.buf.space = chunk->$anon0.buf.space * (unsigned long int)2)
      ;
    void *return_value_realloc$4;
    return_value_realloc$4=realloc((void *)chunk->$anon0.buf.data, sizeof(unsigned int) /*4ul*/  * chunk->$anon0.buf.space);
    chunk->$anon0.buf.data = (unsigned int *)return_value_realloc$4;
  }

  memcpy((void *)(chunk->$anon0.buf.data + (signed long int)chunk->len), (const void *)ptr, sizeof(unsigned int) /*4ul*/  * len);
  chunk->len = chunk->len + len;
}

// chunk_freebuf
// file vsl_dispatch.c line 361
static void chunk_freebuf(struct chunk **pchunk)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(*pchunk == ((struct chunk *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("chunk_freebuf", "vsl_dispatch.c", 364, "(*pchunk) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!((*pchunk)->magic == 1222377876u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("chunk_freebuf", "vsl_dispatch.c", 364, "(*pchunk)->magic == 0x48DC0194", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  do
    if(!((signed int)(*pchunk)->type == chunk_t_buf))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("chunk_freebuf", "vsl_dispatch.c", 365, "(*pchunk)->type == chunk_t_buf", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  free((void *)(*pchunk)->$anon0.buf.data);
  do
  {
    (*pchunk)->magic = (unsigned int)0;
    free((void *)*pchunk);
  }
  while((_Bool)0);
  *pchunk = (struct chunk *)(void *)0;
}

// chunk_newbuf
// file vsl_dispatch.c line 341
static struct chunk * chunk_newbuf(struct vtx *vtx, const unsigned int *ptr, unsigned long int len)
{
  struct chunk *chunk;
  do
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc(sizeof(struct chunk) /*72ul*/ , (unsigned long int)1);
    chunk = (struct chunk *)return_value_calloc$1;
    if(!(chunk == ((struct chunk *)NULL)))
      chunk->magic = (unsigned int)0x48DC0194;

  }
  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(chunk == ((struct chunk *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("chunk_newbuf", "vsl_dispatch.c", 346, "(chunk) != 0", *return_value___errno_location$2, (enum vas_e)VAS_MISSING);
    }

  while((_Bool)0);
  chunk->type = (enum chunk_t)chunk_t_buf;
  chunk->vtx = vtx;
  chunk->$anon0.buf.space = (unsigned long int)64;
  for( ; !(chunk->$anon0.buf.space >= len); chunk->$anon0.buf.space = chunk->$anon0.buf.space * (unsigned long int)2)
    ;
  void *return_value_malloc$3;
  return_value_malloc$3=malloc(sizeof(unsigned int) /*4ul*/  * chunk->$anon0.buf.space);
  chunk->$anon0.buf.data = (unsigned int *)return_value_malloc$3;

__CPROVER_DUMP_L7:
  ;
  do
    if(chunk->$anon0.buf.data == ((unsigned int *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("chunk_newbuf", "vsl_dispatch.c", 353, "(chunk->buf.data) != 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  memcpy((void *)chunk->$anon0.buf.data, (const void *)ptr, sizeof(unsigned int) /*4ul*/  * len);
  chunk->len = len;
  return chunk;
}

// chunk_shm_to_buf
// file vsl_dispatch.c line 390
static void chunk_shm_to_buf(struct VSLQ *vslq, struct chunk *chunk)
{
  struct vtx *vtx;
  struct chunk *buf;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(chunk == ((struct chunk *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("chunk_shm_to_buf", "vsl_dispatch.c", 395, "(chunk) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(chunk->magic == 1222377876u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("chunk_shm_to_buf", "vsl_dispatch.c", 395, "(chunk)->magic == 0x48DC0194", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  do
    if(!((signed int)chunk->type == chunk_t_shm))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("chunk_shm_to_buf", "vsl_dispatch.c", 396, "chunk->type == chunk_t_shm", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vtx = chunk->vtx;

__CPROVER_DUMP_L7:
  ;
  do
  {
    if(vtx == ((struct vtx *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("chunk_shm_to_buf", "vsl_dispatch.c", 398, "(vtx) != NULL", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vtx->magic == 0xACC21D09))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        VAS_Fail("chunk_shm_to_buf", "vsl_dispatch.c", 398, "(vtx)->magic == 0xACC21D09", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  buf = *((struct chunkhead *)chunk->list.vtqe_prev)->vtqh_last;
  _Bool tmp_if_expr$7;
  if(!(buf == ((struct chunk *)NULL)))
    tmp_if_expr$7 = (signed int)buf->type == chunk_t_buf ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$7 = (_Bool)0;
  if(tmp_if_expr$7)
    chunk_appendbuf(buf, chunk->$anon0.shm.start.ptr, chunk->len);

  else
  {
    buf=chunk_newbuf(vtx, chunk->$anon0.shm.start.ptr, chunk->len);

  __CPROVER_DUMP_L14:
    ;
    do
      if(buf == ((struct chunk *)NULL))
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        VAS_Fail("chunk_shm_to_buf", "vsl_dispatch.c", 407, "(buf) != 0", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    do
    {
      buf->list.vtqe_prev = chunk->list.vtqe_prev;
      buf->list.vtqe_next = chunk;
      *chunk->list.vtqe_prev = buf;
      chunk->list.vtqe_prev = &buf->list.vtqe_next;
    }
    while((_Bool)0);
  }
  vtx->c.chunk = (struct chunk *)(void *)0;
  do
  {
    if(!(chunk->$anon0.shm.shmref.vtqe_next == ((struct chunk *)NULL)))
      chunk->$anon0.shm.shmref.vtqe_next->$anon0.shm.shmref.vtqe_prev = chunk->$anon0.shm.shmref.vtqe_prev;

    else
      (&vslq->shmrefs)->vtqh_last = chunk->$anon0.shm.shmref.vtqe_prev;
    *chunk->$anon0.shm.shmref.vtqe_prev = chunk->$anon0.shm.shmref.vtqe_next;
  }
  while((_Bool)0);
  do
  {
    if(!(chunk->list.vtqe_next == ((struct chunk *)NULL)))
      chunk->list.vtqe_next->list.vtqe_prev = chunk->list.vtqe_prev;

    else
      (&vtx->chunks)->vtqh_last = chunk->list.vtqe_prev;
    *chunk->list.vtqe_prev = chunk->list.vtqe_next;
  }
  while((_Bool)0);
  do
  {
    chunk->list.vtqe_next = (&vtx->shmchunks_free)->vtqh_first;
    if(!(chunk->list.vtqe_next == ((struct chunk *)NULL)))
      (&vtx->shmchunks_free)->vtqh_first->list.vtqe_prev = &chunk->list.vtqe_next;

    else
      (&vtx->shmchunks_free)->vtqh_last = &chunk->list.vtqe_next;
    (&vtx->shmchunks_free)->vtqh_first = chunk;
    chunk->list.vtqe_prev = &(&vtx->shmchunks_free)->vtqh_first;
  }
  while((_Bool)0);
}

// cmp_key
// file varnishtop.c line 82
static inline signed int cmp_key(struct top *a, struct top *b)
{
  if(!(a->hash == b->hash))
    return (signed int)(a->hash - b->hash);

  else
    if(!(a->tag == b->tag))
      return (signed int)a->tag - (signed int)b->tag;

    else
      if(!(a->clen == b->clen))
        return a->clen - b->clen;

      else
      {
        signed int return_value_memcmp$1;
        return_value_memcmp$1=memcmp((const void *)a->rec_data, (const void *)b->rec_data, (unsigned long int)a->clen);
        return return_value_memcmp$1;
      }
}

// cmp_order
// file varnishtop.c line 94
static inline signed int cmp_order(struct top *a, struct top *b)
{
  if(a->count > b->count)
    return -1;

  else
    if(a->count < b->count)
      return 1;

  signed int return_value_cmp_key$1;
  return_value_cmp_key$1=cmp_key(a, b);
  return return_value_cmp_key$1;
}

// do_curses
// file varnishtop.c line 235
static void * do_curses(void *arg)
{
  signed int i;
  (void)arg;
  i = 0;
  unsigned long int return_value_strlen$1;
  for( ; !(i >= 256); i = i + 1)
    if(!(VSL_tags[(signed long int)i] == ((const char *)NULL)))
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(VSL_tags[(signed long int)i]);
      if(!((unsigned long int)maxfieldlen >= return_value_strlen$2))
      {
        return_value_strlen$1=strlen(VSL_tags[(signed long int)i]);
        maxfieldlen = (unsigned int)return_value_strlen$1;
      }

    }

  initscr();
  raw();
  noecho();
  nonl();
  intrflush(stdscr, (_Bool)0);
  curs_set(0);
  werase(stdscr);
  signed int tmp_if_expr$8;
  do
  {

  __CPROVER_DUMP_L5:
    ;
    signed int return_value_pthread_mutex_lock$4;
    return_value_pthread_mutex_lock$4=pthread_mutex_lock(&mtx);
    if(!(return_value_pthread_mutex_lock$4 == 0))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("do_curses", "varnishtop.c", 255, "(pthread_mutex_lock(&mtx)) == 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

    update((signed int)period);
    do
    {

    __CPROVER_DUMP_L7:
      ;
      signed int return_value_pthread_mutex_unlock$6;
      return_value_pthread_mutex_unlock$6=pthread_mutex_unlock(&mtx);
      if(!(return_value_pthread_mutex_unlock$6 == 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        VAS_Fail("do_curses", "varnishtop.c", 257, "(pthread_mutex_unlock(&mtx)) == 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
      }

    }
    while((_Bool)0);
    wtimeout(stdscr, 1000);
    signed int return_value_wgetch$7;
    return_value_wgetch$7=wgetch(stdscr);
    if(!(return_value_wgetch$7 == -1))
    {
      if(return_value_wgetch$7 == 0632)
        goto __CPROVER_DUMP_L10;

      if(return_value_wgetch$7 == 12 || return_value_wgetch$7 == 20)
        goto __CPROVER_DUMP_L11;

      if(return_value_wgetch$7 == 26)
        goto __CPROVER_DUMP_L14;

      if(return_value_wgetch$7 == 3 || return_value_wgetch$7 == 17 || return_value_wgetch$7 == 81 || return_value_wgetch$7 == 113)
        goto __CPROVER_DUMP_L17;

    }

    else
    {
      goto __CPROVER_DUMP_L20;

    __CPROVER_DUMP_L10:
      ;
      werase(stdscr);
      goto __CPROVER_DUMP_L20;

    __CPROVER_DUMP_L11:
      ;
      if(!(stdscr == ((struct _win_st *)NULL)))
        tmp_if_expr$8 = (signed int)stdscr->_maxy + 1;

      else
        tmp_if_expr$8 = -1;
      wredrawln(stdscr, 0, tmp_if_expr$8);
      wrefresh(stdscr);
      goto __CPROVER_DUMP_L20;

    __CPROVER_DUMP_L14:
      ;
      endwin();
      do
      {

      __CPROVER_DUMP_L15:
        ;
        signed int return_value_raise$10;
        return_value_raise$10=raise(20);
        if(!(return_value_raise$10 == 0))
        {
          signed int *return_value___errno_location$9;
          return_value___errno_location$9=__errno_location();
          VAS_Fail("do_curses", "varnishtop.c", 275, "(raise(20)) == 0", *return_value___errno_location$9, (enum vas_e)VAS_ASSERT);
        }

      }
      while((_Bool)0);
      goto __CPROVER_DUMP_L20;
      do
      {

      __CPROVER_DUMP_L17:
        ;
        signed int return_value_raise$12;
        return_value_raise$12=raise(2);
        if(!(return_value_raise$12 == 0))
        {
          signed int *return_value___errno_location$11;
          return_value___errno_location$11=__errno_location();
          VAS_Fail("do_curses", "varnishtop.c", 281, "(raise(2)) == 0", *return_value___errno_location$11, (enum vas_e)VAS_ASSERT);
        }

      }
      while((_Bool)0);
      endwin();
      return (void *)0;
    }
    beep();

  __CPROVER_DUMP_L20:
    ;
  }
  while((_Bool)1);
  return (void *)0;
}

// dump
// file varnishtop.c line 294
static void dump(void)
{
  struct top *tp;
  struct top *tp2;
  tp=t_order_VRB_MINMAX(&h_order, -1);
  for( ; !(tp == ((struct top *)NULL)); tp = tp2)
  {
    tp2=t_order_VRB_NEXT(tp);
    if(tp->count <= 1.0)
      break;

    printf("%9.2f %s %*.*s\n", tp->count, VSL_tags[(signed long int)tp->tag], tp->clen, tp->clen, tp->rec_data);
  }
}

// flopen
// file ../../lib/libvarnish/flopen.c line 43
signed int flopen(const char *path, signed int flags, ...)
{
  signed int fd;
  signed int operation;
  signed int serrno;
  signed int flopen$$1$$trunc;
  struct flock lock;
  struct stat sb;
  struct stat fsb;
  unsigned int mode = (unsigned int)0;
  if(!((0100 & flags) == 0))
  {
    __builtin_va_list ap;
    va_start(ap, flags);
    signed int return_value_gcc_builtin_va_arg$1;
    return_value_gcc_builtin_va_arg$1=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg$1));
    mode = (unsigned int)return_value_gcc_builtin_va_arg$1;
    va_end(ap);
  }

  memset((void *)&lock, 0, sizeof(struct flock) /*32ul*/ );
  lock.l_type = (signed short int)((flags & 0003) == 00 ? 0 : 1);
  lock.l_whence = (signed short int)0;
  operation = (flags & 04000) != 0 ? 6 : 7;
  flopen$$1$$trunc = flags & 01000;
  flags = flags & ~01000;
  signed int return_value_ftruncate$11;
  do
  {
    fd=open(path, flags, mode);
    if(fd == -1)
      return -1;

    signed int return_value_fcntl$4;
    return_value_fcntl$4=fcntl(fd, operation, &lock);
    if(return_value_fcntl$4 == -1)
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      serrno = *return_value___errno_location$2;
      close(fd);
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = serrno;
      return -1;
    }

    signed int return_value_stat$5;
    return_value_stat$5=stat(path, &sb);
    if(return_value_stat$5 == -1)
      close(fd);

    else
    {
      signed int return_value_fstat$8;
      return_value_fstat$8=fstat(fd, &fsb);
      if(return_value_fstat$8 == -1)
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        serrno = *return_value___errno_location$6;
        close(fd);
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        *return_value___errno_location$7 = serrno;
        return -1;
      }

      if(!(sb.st_dev == fsb.st_dev) || !(sb.st_ino == fsb.st_ino))
        close(fd);

      else
      {
        if(!(flopen$$1$$trunc == 0))
        {
          return_value_ftruncate$11=ftruncate(fd, (signed long int)0);
          if(!(return_value_ftruncate$11 == 0))
          {
            signed int *return_value___errno_location$9;
            return_value___errno_location$9=__errno_location();
            serrno = *return_value___errno_location$9;
            close(fd);
            signed int *return_value___errno_location$10;
            return_value___errno_location$10=__errno_location();
            *return_value___errno_location$10 = serrno;
            return -1;
          }

        }

        return fd;
      }
    }
  }
  while((_Bool)1);
}

// fltest
// file ../../lib/libvarnish/flopen.c line 118
signed int fltest(signed int fd, signed int *pid)
{
  struct flock lock;
  memset((void *)&lock, 0, sizeof(struct flock) /*32ul*/ );
  lock.l_type = (signed short int)1;
  lock.l_whence = (signed short int)0;
  signed int return_value_fcntl$1;
  return_value_fcntl$1=fcntl(fd, 5, &lock);
  if(return_value_fcntl$1 == -1)
    return -1;

  else
    if((signed int)lock.l_type == 2)
      return 0;

    else
    {
      if(!(pid == ((signed int *)NULL)))
        *pid = lock.l_pid;

      return 1;
    }
}

// iter_lck
// file ../../include/tbl/vsc_all.h line 37
static void iter_lck(struct vsc *vsc, struct VSC_desc *descs, struct vsc_vf *vf)
{
  struct VSC_C_lck *st;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsc == ((struct vsc *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("iter_lck", "../../include/tbl/vsc_all.h", 37, "(vsc) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsc->magic == 863196490u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("iter_lck", "../../include/tbl/vsc_all.h", 37, "(vsc)->magic == 0x3373554a", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  st = (struct VSC_C_lck *)vf->fantom.b;
  struct VSC_desc *tmp_post$3 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->creat, tmp_post$3, vf);
  struct VSC_desc *tmp_post$4 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->destroy, tmp_post$4, vf);
  struct VSC_desc *tmp_post$5 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->locks, tmp_post$5, vf);
}

// iter_main
// file ../../include/tbl/vsc_all.h line 43
static void iter_main(struct vsc *vsc, struct VSC_desc *descs, struct vsc_vf *vf)
{
  struct VSC_C_main *st;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsc == ((struct vsc *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("iter_main", "../../include/tbl/vsc_all.h", 43, "(vsc) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsc->magic == 863196490u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("iter_main", "../../include/tbl/vsc_all.h", 43, "(vsc)->magic == 0x3373554a", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  st = (struct VSC_C_main *)vf->fantom.b;
  struct VSC_desc *tmp_post$3 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->uptime, tmp_post$3, vf);
  struct VSC_desc *tmp_post$4 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sess_conn, tmp_post$4, vf);
  struct VSC_desc *tmp_post$5 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sess_drop, tmp_post$5, vf);
  struct VSC_desc *tmp_post$6 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sess_fail, tmp_post$6, vf);
  struct VSC_desc *tmp_post$7 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sess_pipe_overflow, tmp_post$7, vf);
  struct VSC_desc *tmp_post$8 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->client_req_400, tmp_post$8, vf);
  struct VSC_desc *tmp_post$9 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->client_req_411, tmp_post$9, vf);
  struct VSC_desc *tmp_post$10 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->client_req_413, tmp_post$10, vf);
  struct VSC_desc *tmp_post$11 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->client_req_417, tmp_post$11, vf);
  struct VSC_desc *tmp_post$12 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->client_req, tmp_post$12, vf);
  struct VSC_desc *tmp_post$13 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->cache_hit, tmp_post$13, vf);
  struct VSC_desc *tmp_post$14 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->cache_hitpass, tmp_post$14, vf);
  struct VSC_desc *tmp_post$15 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->cache_miss, tmp_post$15, vf);
  struct VSC_desc *tmp_post$16 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->backend_conn, tmp_post$16, vf);
  struct VSC_desc *tmp_post$17 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->backend_unhealthy, tmp_post$17, vf);
  struct VSC_desc *tmp_post$18 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->backend_busy, tmp_post$18, vf);
  struct VSC_desc *tmp_post$19 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->backend_fail, tmp_post$19, vf);
  struct VSC_desc *tmp_post$20 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->backend_reuse, tmp_post$20, vf);
  struct VSC_desc *tmp_post$21 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->backend_toolate, tmp_post$21, vf);
  struct VSC_desc *tmp_post$22 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->backend_recycle, tmp_post$22, vf);
  struct VSC_desc *tmp_post$23 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->backend_retry, tmp_post$23, vf);
  struct VSC_desc *tmp_post$24 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->fetch_head, tmp_post$24, vf);
  struct VSC_desc *tmp_post$25 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->fetch_length, tmp_post$25, vf);
  struct VSC_desc *tmp_post$26 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->fetch_chunked, tmp_post$26, vf);
  struct VSC_desc *tmp_post$27 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->fetch_eof, tmp_post$27, vf);
  struct VSC_desc *tmp_post$28 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->fetch_bad, tmp_post$28, vf);
  struct VSC_desc *tmp_post$29 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->fetch_close, tmp_post$29, vf);
  struct VSC_desc *tmp_post$30 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->fetch_oldhttp, tmp_post$30, vf);
  struct VSC_desc *tmp_post$31 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->fetch_zero, tmp_post$31, vf);
  struct VSC_desc *tmp_post$32 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->fetch_1xx, tmp_post$32, vf);
  struct VSC_desc *tmp_post$33 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->fetch_204, tmp_post$33, vf);
  struct VSC_desc *tmp_post$34 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->fetch_304, tmp_post$34, vf);
  struct VSC_desc *tmp_post$35 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->fetch_failed, tmp_post$35, vf);
  struct VSC_desc *tmp_post$36 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->fetch_no_thread, tmp_post$36, vf);
  struct VSC_desc *tmp_post$37 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->pools, tmp_post$37, vf);
  struct VSC_desc *tmp_post$38 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->threads, tmp_post$38, vf);
  struct VSC_desc *tmp_post$39 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->threads_limited, tmp_post$39, vf);
  struct VSC_desc *tmp_post$40 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->threads_created, tmp_post$40, vf);
  struct VSC_desc *tmp_post$41 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->threads_destroyed, tmp_post$41, vf);
  struct VSC_desc *tmp_post$42 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->threads_failed, tmp_post$42, vf);
  struct VSC_desc *tmp_post$43 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->thread_queue_len, tmp_post$43, vf);
  struct VSC_desc *tmp_post$44 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->busy_sleep, tmp_post$44, vf);
  struct VSC_desc *tmp_post$45 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->busy_wakeup, tmp_post$45, vf);
  struct VSC_desc *tmp_post$46 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sess_queued, tmp_post$46, vf);
  struct VSC_desc *tmp_post$47 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sess_dropped, tmp_post$47, vf);
  struct VSC_desc *tmp_post$48 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->n_object, tmp_post$48, vf);
  struct VSC_desc *tmp_post$49 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->n_vampireobject, tmp_post$49, vf);
  struct VSC_desc *tmp_post$50 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->n_objectcore, tmp_post$50, vf);
  struct VSC_desc *tmp_post$51 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->n_objecthead, tmp_post$51, vf);
  struct VSC_desc *tmp_post$52 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->n_waitinglist, tmp_post$52, vf);
  struct VSC_desc *tmp_post$53 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->n_backend, tmp_post$53, vf);
  struct VSC_desc *tmp_post$54 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->n_expired, tmp_post$54, vf);
  struct VSC_desc *tmp_post$55 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->n_lru_nuked, tmp_post$55, vf);
  struct VSC_desc *tmp_post$56 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->n_lru_moved, tmp_post$56, vf);
  struct VSC_desc *tmp_post$57 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->losthdr, tmp_post$57, vf);
  struct VSC_desc *tmp_post$58 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->s_sess, tmp_post$58, vf);
  struct VSC_desc *tmp_post$59 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->s_req, tmp_post$59, vf);
  struct VSC_desc *tmp_post$60 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->s_pipe, tmp_post$60, vf);
  struct VSC_desc *tmp_post$61 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->s_pass, tmp_post$61, vf);
  struct VSC_desc *tmp_post$62 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->s_fetch, tmp_post$62, vf);
  struct VSC_desc *tmp_post$63 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->s_synth, tmp_post$63, vf);
  struct VSC_desc *tmp_post$64 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->s_req_hdrbytes, tmp_post$64, vf);
  struct VSC_desc *tmp_post$65 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->s_req_bodybytes, tmp_post$65, vf);
  struct VSC_desc *tmp_post$66 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->s_resp_hdrbytes, tmp_post$66, vf);
  struct VSC_desc *tmp_post$67 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->s_resp_bodybytes, tmp_post$67, vf);
  struct VSC_desc *tmp_post$68 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->s_pipe_hdrbytes, tmp_post$68, vf);
  struct VSC_desc *tmp_post$69 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->s_pipe_in, tmp_post$69, vf);
  struct VSC_desc *tmp_post$70 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->s_pipe_out, tmp_post$70, vf);
  struct VSC_desc *tmp_post$71 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sess_closed, tmp_post$71, vf);
  struct VSC_desc *tmp_post$72 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sess_pipeline, tmp_post$72, vf);
  struct VSC_desc *tmp_post$73 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sess_readahead, tmp_post$73, vf);
  struct VSC_desc *tmp_post$74 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sess_herd, tmp_post$74, vf);
  struct VSC_desc *tmp_post$75 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->shm_records, tmp_post$75, vf);
  struct VSC_desc *tmp_post$76 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->shm_writes, tmp_post$76, vf);
  struct VSC_desc *tmp_post$77 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->shm_flushes, tmp_post$77, vf);
  struct VSC_desc *tmp_post$78 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->shm_cont, tmp_post$78, vf);
  struct VSC_desc *tmp_post$79 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->shm_cycles, tmp_post$79, vf);
  struct VSC_desc *tmp_post$80 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sms_nreq, tmp_post$80, vf);
  struct VSC_desc *tmp_post$81 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sms_nobj, tmp_post$81, vf);
  struct VSC_desc *tmp_post$82 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sms_nbytes, tmp_post$82, vf);
  struct VSC_desc *tmp_post$83 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sms_balloc, tmp_post$83, vf);
  struct VSC_desc *tmp_post$84 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sms_bfree, tmp_post$84, vf);
  struct VSC_desc *tmp_post$85 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->backend_req, tmp_post$85, vf);
  struct VSC_desc *tmp_post$86 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->n_vcl, tmp_post$86, vf);
  struct VSC_desc *tmp_post$87 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->n_vcl_avail, tmp_post$87, vf);
  struct VSC_desc *tmp_post$88 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->n_vcl_discard, tmp_post$88, vf);
  struct VSC_desc *tmp_post$89 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bans, tmp_post$89, vf);
  struct VSC_desc *tmp_post$90 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bans_completed, tmp_post$90, vf);
  struct VSC_desc *tmp_post$91 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bans_obj, tmp_post$91, vf);
  struct VSC_desc *tmp_post$92 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bans_req, tmp_post$92, vf);
  struct VSC_desc *tmp_post$93 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bans_added, tmp_post$93, vf);
  struct VSC_desc *tmp_post$94 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bans_deleted, tmp_post$94, vf);
  struct VSC_desc *tmp_post$95 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bans_tested, tmp_post$95, vf);
  struct VSC_desc *tmp_post$96 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bans_obj_killed, tmp_post$96, vf);
  struct VSC_desc *tmp_post$97 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bans_lurker_tested, tmp_post$97, vf);
  struct VSC_desc *tmp_post$98 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bans_tests_tested, tmp_post$98, vf);
  struct VSC_desc *tmp_post$99 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bans_lurker_tests_tested, tmp_post$99, vf);
  struct VSC_desc *tmp_post$100 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bans_lurker_obj_killed, tmp_post$100, vf);
  struct VSC_desc *tmp_post$101 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bans_dups, tmp_post$101, vf);
  struct VSC_desc *tmp_post$102 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bans_lurker_contention, tmp_post$102, vf);
  struct VSC_desc *tmp_post$103 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bans_persisted_bytes, tmp_post$103, vf);
  struct VSC_desc *tmp_post$104 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bans_persisted_fragmentation, tmp_post$104, vf);
  struct VSC_desc *tmp_post$105 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->n_purges, tmp_post$105, vf);
  struct VSC_desc *tmp_post$106 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->n_obj_purged, tmp_post$106, vf);
  struct VSC_desc *tmp_post$107 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->exp_mailed, tmp_post$107, vf);
  struct VSC_desc *tmp_post$108 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->exp_received, tmp_post$108, vf);
  struct VSC_desc *tmp_post$109 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->hcb_nolock, tmp_post$109, vf);
  struct VSC_desc *tmp_post$110 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->hcb_lock, tmp_post$110, vf);
  struct VSC_desc *tmp_post$111 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->hcb_insert, tmp_post$111, vf);
  struct VSC_desc *tmp_post$112 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->esi_errors, tmp_post$112, vf);
  struct VSC_desc *tmp_post$113 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->esi_warnings, tmp_post$113, vf);
  struct VSC_desc *tmp_post$114 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->vmods, tmp_post$114, vf);
  struct VSC_desc *tmp_post$115 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->n_gzip, tmp_post$115, vf);
  struct VSC_desc *tmp_post$116 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->n_gunzip, tmp_post$116, vf);
  struct VSC_desc *tmp_post$117 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->vsm_free, tmp_post$117, vf);
  struct VSC_desc *tmp_post$118 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->vsm_used, tmp_post$118, vf);
  struct VSC_desc *tmp_post$119 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->vsm_cooling, tmp_post$119, vf);
  struct VSC_desc *tmp_post$120 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->vsm_overflow, tmp_post$120, vf);
  struct VSC_desc *tmp_post$121 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->vsm_overflowed, tmp_post$121, vf);
}

// iter_mempool
// file ../../include/tbl/vsc_all.h line 65
static void iter_mempool(struct vsc *vsc, struct VSC_desc *descs, struct vsc_vf *vf)
{
  struct VSC_C_mempool *st;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsc == ((struct vsc *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("iter_mempool", "../../include/tbl/vsc_all.h", 65, "(vsc) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsc->magic == 863196490u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("iter_mempool", "../../include/tbl/vsc_all.h", 65, "(vsc)->magic == 0x3373554a", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  st = (struct VSC_C_mempool *)vf->fantom.b;
  struct VSC_desc *tmp_post$3 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->live, tmp_post$3, vf);
  struct VSC_desc *tmp_post$4 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->pool, tmp_post$4, vf);
  struct VSC_desc *tmp_post$5 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sz_wanted, tmp_post$5, vf);
  struct VSC_desc *tmp_post$6 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->sz_needed, tmp_post$6, vf);
  struct VSC_desc *tmp_post$7 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->allocs, tmp_post$7, vf);
  struct VSC_desc *tmp_post$8 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->frees, tmp_post$8, vf);
  struct VSC_desc *tmp_post$9 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->recycle, tmp_post$9, vf);
  struct VSC_desc *tmp_post$10 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->timeout, tmp_post$10, vf);
  struct VSC_desc *tmp_post$11 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->toosmall, tmp_post$11, vf);
  struct VSC_desc *tmp_post$12 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->surplus, tmp_post$12, vf);
  struct VSC_desc *tmp_post$13 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->randry, tmp_post$13, vf);
}

// iter_mgt
// file ../../include/tbl/vsc_all.h line 31
static void iter_mgt(struct vsc *vsc, struct VSC_desc *descs, struct vsc_vf *vf)
{
  struct VSC_C_mgt *st;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsc == ((struct vsc *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("iter_mgt", "../../include/tbl/vsc_all.h", 31, "(vsc) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsc->magic == 863196490u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("iter_mgt", "../../include/tbl/vsc_all.h", 31, "(vsc)->magic == 0x3373554a", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  st = (struct VSC_C_mgt *)vf->fantom.b;
  struct VSC_desc *tmp_post$3 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->uptime, tmp_post$3, vf);
  struct VSC_desc *tmp_post$4 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->child_start, tmp_post$4, vf);
  struct VSC_desc *tmp_post$5 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->child_exit, tmp_post$5, vf);
  struct VSC_desc *tmp_post$6 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->child_stop, tmp_post$6, vf);
  struct VSC_desc *tmp_post$7 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->child_died, tmp_post$7, vf);
  struct VSC_desc *tmp_post$8 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->child_dump, tmp_post$8, vf);
  struct VSC_desc *tmp_post$9 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->child_panic, tmp_post$9, vf);
}

// iter_sma
// file ../../include/tbl/vsc_all.h line 47
static void iter_sma(struct vsc *vsc, struct VSC_desc *descs, struct vsc_vf *vf)
{
  struct VSC_C_sma *st;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsc == ((struct vsc *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("iter_sma", "../../include/tbl/vsc_all.h", 47, "(vsc) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsc->magic == 863196490u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("iter_sma", "../../include/tbl/vsc_all.h", 47, "(vsc)->magic == 0x3373554a", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  st = (struct VSC_C_sma *)vf->fantom.b;
  struct VSC_desc *tmp_post$3 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->c_req, tmp_post$3, vf);
  struct VSC_desc *tmp_post$4 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->c_fail, tmp_post$4, vf);
  struct VSC_desc *tmp_post$5 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->c_bytes, tmp_post$5, vf);
  struct VSC_desc *tmp_post$6 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->c_freed, tmp_post$6, vf);
  struct VSC_desc *tmp_post$7 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->g_alloc, tmp_post$7, vf);
  struct VSC_desc *tmp_post$8 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->g_bytes, tmp_post$8, vf);
  struct VSC_desc *tmp_post$9 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->g_space, tmp_post$9, vf);
}

// iter_smf
// file ../../include/tbl/vsc_all.h line 53
static void iter_smf(struct vsc *vsc, struct VSC_desc *descs, struct vsc_vf *vf)
{
  struct VSC_C_smf *st;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsc == ((struct vsc *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("iter_smf", "../../include/tbl/vsc_all.h", 53, "(vsc) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsc->magic == 863196490u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("iter_smf", "../../include/tbl/vsc_all.h", 53, "(vsc)->magic == 0x3373554a", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  st = (struct VSC_C_smf *)vf->fantom.b;
  struct VSC_desc *tmp_post$3 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->c_req, tmp_post$3, vf);
  struct VSC_desc *tmp_post$4 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->c_fail, tmp_post$4, vf);
  struct VSC_desc *tmp_post$5 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->c_bytes, tmp_post$5, vf);
  struct VSC_desc *tmp_post$6 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->c_freed, tmp_post$6, vf);
  struct VSC_desc *tmp_post$7 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->g_alloc, tmp_post$7, vf);
  struct VSC_desc *tmp_post$8 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->g_bytes, tmp_post$8, vf);
  struct VSC_desc *tmp_post$9 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->g_space, tmp_post$9, vf);
  struct VSC_desc *tmp_post$10 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->g_smf, tmp_post$10, vf);
  struct VSC_desc *tmp_post$11 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->g_smf_frag, tmp_post$11, vf);
  struct VSC_desc *tmp_post$12 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->g_smf_large, tmp_post$12, vf);
}

// iter_test
// file vsc.c line 454
static inline signed int iter_test(const char *s1, const char *s2, signed int wc)
{
  signed int return_value_strcmp$1;
  _Bool tmp_if_expr$2;
  if(s1 == ((const char *)NULL))
    return 0;

  else
    if(wc == 0)
    {
      return_value_strcmp$1=strcmp(s1, s2);
      return return_value_strcmp$1;
    }

    else
    {
      do
      {
        if(!((signed int)*s1 == 0))
          tmp_if_expr$2 = *s1 == *s2 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(!tmp_if_expr$2)
          break;

        s1 = s1 + 1l;
        s2 = s2 + 1l;
      }
      while((_Bool)1);
      return (signed int)((signed int)*s1 != 0);
    }
}

// iter_vbe
// file ../../include/tbl/vsc_all.h line 59
static void iter_vbe(struct vsc *vsc, struct VSC_desc *descs, struct vsc_vf *vf)
{
  struct VSC_C_vbe *st;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsc == ((struct vsc *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("iter_vbe", "../../include/tbl/vsc_all.h", 59, "(vsc) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsc->magic == 863196490u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("iter_vbe", "../../include/tbl/vsc_all.h", 59, "(vsc)->magic == 0x3373554a", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  st = (struct VSC_C_vbe *)vf->fantom.b;
  struct VSC_desc *tmp_post$3 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->vcls, tmp_post$3, vf);
  struct VSC_desc *tmp_post$4 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->happy, tmp_post$4, vf);
  struct VSC_desc *tmp_post$5 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bereq_hdrbytes, tmp_post$5, vf);
  struct VSC_desc *tmp_post$6 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->bereq_bodybytes, tmp_post$6, vf);
  struct VSC_desc *tmp_post$7 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->beresp_hdrbytes, tmp_post$7, vf);
  struct VSC_desc *tmp_post$8 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->beresp_bodybytes, tmp_post$8, vf);
  struct VSC_desc *tmp_post$9 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->pipe_hdrbytes, tmp_post$9, vf);
  struct VSC_desc *tmp_post$10 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->pipe_out, tmp_post$10, vf);
  struct VSC_desc *tmp_post$11 = descs;
  descs = descs + 1l;
  vsc_add_pt(vsc, (const volatile void *)&st->pipe_in, tmp_post$11, vf);
}

// main
// file varnishtop.c line 320
signed int main(signed int argc, char **argv)
{
  signed int o;
  signed int once = 0;
  unsigned long int thr;
  VUT_Init(progname);
  signed int *return_value___errno_location$3;
  signed long int return_value_strtol$4;
  signed int *return_value___errno_location$5;
  do
  {
    o=getopt(argc, argv, vopt_optstring);
    if(o == -1)
      break;

    switch(o)
    {
      case 49:
      {
        do
        {

        __CPROVER_DUMP_L2:
          ;
          signed int return_value_VUT_Arg$2;
          return_value_VUT_Arg$2=VUT_Arg(100, (const char *)(void *)0);
          if(return_value_VUT_Arg$2 == 0)
          {
            signed int *return_value___errno_location$1;
            return_value___errno_location$1=__errno_location();
            VAS_Fail("main", "varnishtop.c", 330, "(VUT_Arg('d', ((void *)0))) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
          }

        }
        while((_Bool)0);
        once = 1;
        break;
      }
      case 102:
      {
        f_flag = 1;
        break;
      }
      case 104:
        usage(0);
      case 112:
      {
        return_value___errno_location$3=__errno_location();
        *return_value___errno_location$3 = 0;
        return_value_strtol$4=strtol(optarg, (char ** restrict )(void *)0, 0);
        period = (float)return_value_strtol$4;
        return_value___errno_location$5=__errno_location();
        if(!(*return_value___errno_location$5 == 0))
        {
          fprintf(stderr, "Syntax error, %s is not a number", optarg);
          exit(1);
        }

        break;
      }
      default:
      {
        signed int return_value_VUT_Arg$6;
        return_value_VUT_Arg$6=VUT_Arg(o, optarg);
        if(return_value_VUT_Arg$6 == 0)
          usage(1);

      }
    }
  }
  while((_Bool)1);
  VUT_Setup();
  if(once == 0)
  {
    signed int return_value_pthread_create$9;
    return_value_pthread_create$9=pthread_create(&thr, (const union pthread_attr_t *)(void *)0, do_curses, (void *)0);
    if(!(return_value_pthread_create$9 == 0))
    {
      signed int *return_value___errno_location$7;
      return_value___errno_location$7=__errno_location();
      char *return_value_strerror$8;
      return_value_strerror$8=strerror(*return_value___errno_location$7);
      fprintf(stderr, "pthread_create(): %s\n", return_value_strerror$8);
      exit(1);
    }

  }

  VUT.dispatch_f = accumulate;
  VUT.dispatch_priv = (void *)0;
  VUT_Main();
  end_of_file = 1;
  if(!(once == 0))
    dump();

  else
    pthread_join(thr, (void **)(void *)0);
  VUT_Fini();
  exit(0);
}

// read_tmo
// file ../libvarnish/cli_common.c line 143
static signed int read_tmo(signed int fd, char *ptr, unsigned int len, double tmo)
{
  signed int i;
  signed int j;
  signed int to;
  struct pollfd pfd;
  if(tmo > 0.000000)
    to = (signed int)(tmo * 1e3);

  else
    to = -1;
  pfd.fd = fd;
  pfd.events = (signed short int)0x001;
  j = 0;
  while(len >= 1u)
  {
    i=poll(&pfd, (unsigned long int)1, to);
    if(i == 0)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 110;
      return -1;
    }

    signed long int return_value_read$2;
    return_value_read$2=read(fd, (void *)ptr, (unsigned long int)len);
    i = (signed int)return_value_read$2;
    if(!(i >= 0))
      return i;

    if(i == 0)
      break;

    len = len - (unsigned int)i;
    ptr = ptr + (signed long int)i;
    j = j + i;
  }
  return j;
}

// t_key_VRB_FIND
// file varnishtop.c line 114
struct top * t_key_VRB_FIND(struct t_key *head, struct top *elm)
{
  struct top *tmp = head->rbh_root;
  signed int comp;
  while(!(tmp == ((struct top *)NULL)))
  {
    comp=cmp_key(elm, tmp);
    if(!(comp >= 0))
      tmp = tmp->e_key.rbe_left;

    else
      if(comp >= 1)
        tmp = tmp->e_key.rbe_right;

      else
        return tmp;
  }
  return (struct top *)(void *)0;
}

// t_key_VRB_INSERT
// file varnishtop.c line 114
struct top * t_key_VRB_INSERT(struct t_key *head, struct top *elm)
{
  struct top *tmp;
  struct top *parent = (struct top *)(void *)0;
  signed int comp = 0;
  tmp = head->rbh_root;
  while(!(tmp == ((struct top *)NULL)))
  {
    parent = tmp;
    comp=cmp_key(elm, parent);
    if(!(comp >= 0))
      tmp = tmp->e_key.rbe_left;

    else
      if(comp >= 1)
        tmp = tmp->e_key.rbe_right;

      else
        return tmp;
  }
  do
  {
    elm->e_key.rbe_parent = parent;
    elm->e_key.rbe_right = (struct top *)(void *)0;
    elm->e_key.rbe_left = elm->e_key.rbe_right;
    elm->e_key.rbe_color = 1;
  }
  while((_Bool)0);
  if(!(parent == ((struct top *)NULL)))
  {
    if(!(comp >= 0))
      parent->e_key.rbe_left = elm;

    else
      parent->e_key.rbe_right = elm;
  }

  else
    head->rbh_root = elm;

__CPROVER_DUMP_L7:
  ;
  t_key_VRB_INSERT_COLOR(head, elm);
  return (struct top *)(void *)0;
}

// t_key_VRB_INSERT_COLOR
// file varnishtop.c line 114
void t_key_VRB_INSERT_COLOR(struct t_key *head, struct top *elm)
{
  struct top *parent;
  struct top *gparent;
  struct top *tmp;
  do
  {
    parent = elm->e_key.rbe_parent;
    if(parent == ((struct top *)NULL))
      break;

    if(!(parent->e_key.rbe_color == 1))
      break;

    gparent = parent->e_key.rbe_parent;
    if(parent == gparent->e_key.rbe_left)
    {
      tmp = gparent->e_key.rbe_right;
      if(!(tmp == ((struct top *)NULL)))
      {
        if(tmp->e_key.rbe_color == 1)
        {
          tmp->e_key.rbe_color = 0;
          do
          {
            parent->e_key.rbe_color = 0;
            gparent->e_key.rbe_color = 1;
          }
          while((_Bool)0);
          elm = gparent;
          continue;
        }

      }

      if(parent->e_key.rbe_right == elm)
      {
        do
        {
          tmp = parent->e_key.rbe_right;
          parent->e_key.rbe_right = tmp->e_key.rbe_left;
          if(!(parent->e_key.rbe_right == ((struct top *)NULL)))
            tmp->e_key.rbe_left->e_key.rbe_parent = parent;


        __CPROVER_DUMP_L5:
          ;
          tmp->e_key.rbe_parent = parent->e_key.rbe_parent;
          if(!(tmp->e_key.rbe_parent == ((struct top *)NULL)))
          {
            if(parent == parent->e_key.rbe_parent->e_key.rbe_left)
              parent->e_key.rbe_parent->e_key.rbe_left = tmp;

            else
              parent->e_key.rbe_parent->e_key.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->e_key.rbe_left = parent;
          parent->e_key.rbe_parent = tmp;

        __CPROVER_DUMP_L10:
          ;
          if(!(tmp->e_key.rbe_parent == ((struct top *)NULL)))

            __CPROVER_DUMP_L11:
              ;

        }
        while((_Bool)0);
        tmp = parent;
        parent = elm;
        elm = tmp;
      }

      do
      {
        parent->e_key.rbe_color = 0;
        gparent->e_key.rbe_color = 1;
      }
      while((_Bool)0);
      do
      {
        tmp = gparent->e_key.rbe_left;
        gparent->e_key.rbe_left = tmp->e_key.rbe_right;
        if(!(gparent->e_key.rbe_left == ((struct top *)NULL)))
          tmp->e_key.rbe_right->e_key.rbe_parent = gparent;


      __CPROVER_DUMP_L15:
        ;
        tmp->e_key.rbe_parent = gparent->e_key.rbe_parent;
        if(!(tmp->e_key.rbe_parent == ((struct top *)NULL)))
        {
          if(gparent == gparent->e_key.rbe_parent->e_key.rbe_left)
            gparent->e_key.rbe_parent->e_key.rbe_left = tmp;

          else
            gparent->e_key.rbe_parent->e_key.rbe_right = tmp;
        }

        else
          head->rbh_root = tmp;
        tmp->e_key.rbe_right = gparent;
        gparent->e_key.rbe_parent = tmp;

      __CPROVER_DUMP_L20:
        ;
        if(!(tmp->e_key.rbe_parent == ((struct top *)NULL)))

          __CPROVER_DUMP_L21:
            ;

      }
      while((_Bool)0);
    }

    else
    {
      tmp = gparent->e_key.rbe_left;
      if(!(tmp == ((struct top *)NULL)))
      {
        if(!(tmp->e_key.rbe_color == 1))
          goto __CPROVER_DUMP_L25;

        tmp->e_key.rbe_color = 0;
        do
        {
          parent->e_key.rbe_color = 0;
          gparent->e_key.rbe_color = 1;
        }
        while((_Bool)0);
        elm = gparent;
      }

      else
      {

      __CPROVER_DUMP_L25:
        ;
        if(parent->e_key.rbe_left == elm)
        {
          do
          {
            tmp = parent->e_key.rbe_left;
            parent->e_key.rbe_left = tmp->e_key.rbe_right;
            if(!(parent->e_key.rbe_left == ((struct top *)NULL)))
              tmp->e_key.rbe_right->e_key.rbe_parent = parent;


          __CPROVER_DUMP_L27:
            ;
            tmp->e_key.rbe_parent = parent->e_key.rbe_parent;
            if(!(tmp->e_key.rbe_parent == ((struct top *)NULL)))
            {
              if(parent == parent->e_key.rbe_parent->e_key.rbe_left)
                parent->e_key.rbe_parent->e_key.rbe_left = tmp;

              else
                parent->e_key.rbe_parent->e_key.rbe_right = tmp;
            }

            else
              head->rbh_root = tmp;
            tmp->e_key.rbe_right = parent;
            parent->e_key.rbe_parent = tmp;

          __CPROVER_DUMP_L32:
            ;
            if(!(tmp->e_key.rbe_parent == ((struct top *)NULL)))

              __CPROVER_DUMP_L33:
                ;

          }
          while((_Bool)0);
          tmp = parent;
          parent = elm;
          elm = tmp;
        }

        do
        {
          parent->e_key.rbe_color = 0;
          gparent->e_key.rbe_color = 1;
        }
        while((_Bool)0);
        do
        {
          tmp = gparent->e_key.rbe_right;
          gparent->e_key.rbe_right = tmp->e_key.rbe_left;
          if(!(gparent->e_key.rbe_right == ((struct top *)NULL)))
            tmp->e_key.rbe_left->e_key.rbe_parent = gparent;


        __CPROVER_DUMP_L37:
          ;
          tmp->e_key.rbe_parent = gparent->e_key.rbe_parent;
          if(!(tmp->e_key.rbe_parent == ((struct top *)NULL)))
          {
            if(gparent == gparent->e_key.rbe_parent->e_key.rbe_left)
              gparent->e_key.rbe_parent->e_key.rbe_left = tmp;

            else
              gparent->e_key.rbe_parent->e_key.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->e_key.rbe_left = gparent;
          gparent->e_key.rbe_parent = tmp;

        __CPROVER_DUMP_L42:
          ;
          if(!(tmp->e_key.rbe_parent == ((struct top *)NULL)))

            __CPROVER_DUMP_L43:
              ;

        }
        while((_Bool)0);
      }
    }
  }
  while((_Bool)1);
  head->rbh_root->e_key.rbe_color = 0;
}

// t_key_VRB_MINMAX
// file varnishtop.c line 114
struct top * t_key_VRB_MINMAX(struct t_key *head, signed int val)
{
  struct top *tmp = head->rbh_root;
  struct top *parent = (struct top *)(void *)0;
  while(!(tmp == ((struct top *)NULL)))
  {
    parent = tmp;
    if(!(val >= 0))
      tmp = tmp->e_key.rbe_left;

    else
      tmp = tmp->e_key.rbe_right;
  }
  return parent;
}

// t_key_VRB_NEXT
// file varnishtop.c line 114
struct top * t_key_VRB_NEXT(struct top *elm)
{
  _Bool tmp_if_expr$1;
  if(!(elm->e_key.rbe_right == ((struct top *)NULL)))
  {
    elm = elm->e_key.rbe_right;
    for( ; !(elm->e_key.rbe_left == ((struct top *)NULL)); elm = elm->e_key.rbe_left)
      ;
  }

  else
  {
    if(!(elm->e_key.rbe_parent == ((struct top *)NULL)))
      tmp_if_expr$1 = elm == elm->e_key.rbe_parent->e_key.rbe_left ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      elm = elm->e_key.rbe_parent;

    else
    {
      for( ; !(elm->e_key.rbe_parent == ((struct top *)NULL)); elm = elm->e_key.rbe_parent)
        if(!(elm == elm->e_key.rbe_parent->e_key.rbe_right))
          break;

      elm = elm->e_key.rbe_parent;
    }
  }
  return elm;
}

// t_key_VRB_NFIND
// file varnishtop.c line 114
struct top * t_key_VRB_NFIND(struct t_key *head, struct top *elm)
{
  struct top *tmp = head->rbh_root;
  struct top *res = (struct top *)(void *)0;
  signed int comp;
  while(!(tmp == ((struct top *)NULL)))
  {
    comp=cmp_key(elm, tmp);
    if(!(comp >= 0))
    {
      res = tmp;
      tmp = tmp->e_key.rbe_left;
    }

    else
      if(comp >= 1)
        tmp = tmp->e_key.rbe_right;

      else
        return tmp;
  }
  return res;
}

// t_key_VRB_PREV
// file varnishtop.c line 114
struct top * t_key_VRB_PREV(struct top *elm)
{
  _Bool tmp_if_expr$1;
  if(!(elm->e_key.rbe_left == ((struct top *)NULL)))
  {
    elm = elm->e_key.rbe_left;
    for( ; !(elm->e_key.rbe_right == ((struct top *)NULL)); elm = elm->e_key.rbe_right)
      ;
  }

  else
  {
    if(!(elm->e_key.rbe_parent == ((struct top *)NULL)))
      tmp_if_expr$1 = elm == elm->e_key.rbe_parent->e_key.rbe_right ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      elm = elm->e_key.rbe_parent;

    else
    {
      for( ; !(elm->e_key.rbe_parent == ((struct top *)NULL)); elm = elm->e_key.rbe_parent)
        if(!(elm == elm->e_key.rbe_parent->e_key.rbe_left))
          break;

      elm = elm->e_key.rbe_parent;
    }
  }
  return elm;
}

// t_key_VRB_REMOVE
// file varnishtop.c line 114
struct top * t_key_VRB_REMOVE(struct t_key *head, struct top *elm)
{
  struct top *child;
  struct top *parent;
  struct top *old = elm;
  signed int color;
  if(elm->e_key.rbe_left == ((struct top *)NULL))
    child = elm->e_key.rbe_right;

  else
    if(elm->e_key.rbe_right == ((struct top *)NULL))
      child = elm->e_key.rbe_left;

    else
    {
      struct top *left;
      elm = elm->e_key.rbe_right;
      do
      {
        left = elm->e_key.rbe_left;
        if(left == ((struct top *)NULL))
          break;

        elm = left;
      }
      while((_Bool)1);
      child = elm->e_key.rbe_right;
      parent = elm->e_key.rbe_parent;
      color = elm->e_key.rbe_color;
      if(!(child == ((struct top *)NULL)))
        child->e_key.rbe_parent = parent;

      if(!(parent == ((struct top *)NULL)))
      {
        if(parent->e_key.rbe_left == elm)
          parent->e_key.rbe_left = child;

        else
          parent->e_key.rbe_right = child;
      }

      else
        head->rbh_root = child;

    __CPROVER_DUMP_L7:
      ;
      if(elm->e_key.rbe_parent == old)
        parent = elm;

      elm->e_key = old->e_key;
      if(!(old->e_key.rbe_parent == ((struct top *)NULL)))
      {
        if(old->e_key.rbe_parent->e_key.rbe_left == old)
          old->e_key.rbe_parent->e_key.rbe_left = elm;

        else
          old->e_key.rbe_parent->e_key.rbe_right = elm;
      }

      else
        head->rbh_root = elm;

    __CPROVER_DUMP_L12:
      ;
      old->e_key.rbe_left->e_key.rbe_parent = elm;
      if(!(old->e_key.rbe_right == ((struct top *)NULL)))
        old->e_key.rbe_right->e_key.rbe_parent = elm;

      if(!(parent == ((struct top *)NULL)))
      {
        left = parent;

      __CPROVER_DUMP_L16:
        ;
        while((_Bool)1)
        {
          left = left->e_key.rbe_parent;
          if(left == ((struct top *)NULL))
            break;

        }
      }

      goto color;
    }
  parent = elm->e_key.rbe_parent;
  color = elm->e_key.rbe_color;
  if(!(child == ((struct top *)NULL)))
    child->e_key.rbe_parent = parent;

  if(!(parent == ((struct top *)NULL)))
  {
    if(parent->e_key.rbe_left == elm)
      parent->e_key.rbe_left = child;

    else
      parent->e_key.rbe_right = child;
  }

  else
    head->rbh_root = child;

__CPROVER_DUMP_L21:
  ;

color:
  ;
  if(color == 0)
    t_key_VRB_REMOVE_COLOR(head, parent, child);

  return old;
}

// t_key_VRB_REMOVE_COLOR
// file varnishtop.c line 114
void t_key_VRB_REMOVE_COLOR(struct t_key *head, struct top *parent, struct top *elm)
{
  struct top *tmp;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$6;
  while((_Bool)1)
  {
    if(!(elm == ((struct top *)NULL)))
    {
      if(!(elm->e_key.rbe_color == 0))
        goto __CPROVER_DUMP_L88;

    }

    if(elm == head->rbh_root)
      break;


  __CPROVER_DUMP_L3:
    ;
    do
      if(parent == ((struct top *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("t_key_VRB_REMOVE_COLOR", "varnishtop.c", 114, "(parent) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    if(parent->e_key.rbe_left == elm)
    {
      tmp = parent->e_key.rbe_right;
      if(tmp->e_key.rbe_color == 1)
      {
        do
        {
          tmp->e_key.rbe_color = 0;
          parent->e_key.rbe_color = 1;
        }
        while((_Bool)0);
        do
        {
          tmp = parent->e_key.rbe_right;
          parent->e_key.rbe_right = tmp->e_key.rbe_left;
          if(!(parent->e_key.rbe_right == ((struct top *)NULL)))
            tmp->e_key.rbe_left->e_key.rbe_parent = parent;


        __CPROVER_DUMP_L7:
          ;
          tmp->e_key.rbe_parent = parent->e_key.rbe_parent;
          if(!(tmp->e_key.rbe_parent == ((struct top *)NULL)))
          {
            if(parent == parent->e_key.rbe_parent->e_key.rbe_left)
              parent->e_key.rbe_parent->e_key.rbe_left = tmp;

            else
              parent->e_key.rbe_parent->e_key.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->e_key.rbe_left = parent;
          parent->e_key.rbe_parent = tmp;

        __CPROVER_DUMP_L12:
          ;
          if(!(tmp->e_key.rbe_parent == ((struct top *)NULL)))

            __CPROVER_DUMP_L13:
              ;

        }
        while((_Bool)0);
        tmp = parent->e_key.rbe_right;
      }

      if(tmp->e_key.rbe_left == ((struct top *)NULL))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = tmp->e_key.rbe_left->e_key.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        if(tmp->e_key.rbe_right == ((struct top *)NULL))
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = tmp->e_key.rbe_right->e_key.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
      {
        tmp->e_key.rbe_color = 1;
        elm = parent;
        parent = elm->e_key.rbe_parent;
      }

      else
      {
        if(tmp->e_key.rbe_right == ((struct top *)NULL))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = tmp->e_key.rbe_right->e_key.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
        {
          struct top *oleft = tmp->e_key.rbe_left;
          if(!(oleft == ((struct top *)NULL)))
            oleft->e_key.rbe_color = 0;

          tmp->e_key.rbe_color = 1;
          do
          {
            oleft = tmp->e_key.rbe_left;
            tmp->e_key.rbe_left = oleft->e_key.rbe_right;
            if(!(tmp->e_key.rbe_left == ((struct top *)NULL)))
              oleft->e_key.rbe_right->e_key.rbe_parent = tmp;


          __CPROVER_DUMP_L27:
            ;
            oleft->e_key.rbe_parent = tmp->e_key.rbe_parent;
            if(!(oleft->e_key.rbe_parent == ((struct top *)NULL)))
            {
              if(tmp == tmp->e_key.rbe_parent->e_key.rbe_left)
                tmp->e_key.rbe_parent->e_key.rbe_left = oleft;

              else
                tmp->e_key.rbe_parent->e_key.rbe_right = oleft;
            }

            else
              head->rbh_root = oleft;
            oleft->e_key.rbe_right = tmp;
            tmp->e_key.rbe_parent = oleft;

          __CPROVER_DUMP_L32:
            ;
            if(!(oleft->e_key.rbe_parent == ((struct top *)NULL)))

              __CPROVER_DUMP_L33:
                ;

          }
          while((_Bool)0);
          tmp = parent->e_key.rbe_right;
        }

        tmp->e_key.rbe_color = parent->e_key.rbe_color;
        parent->e_key.rbe_color = 0;
        if(!(tmp->e_key.rbe_right == ((struct top *)NULL)))
          tmp->e_key.rbe_right->e_key.rbe_color = 0;

        do
        {
          tmp = parent->e_key.rbe_right;
          parent->e_key.rbe_right = tmp->e_key.rbe_left;
          if(!(parent->e_key.rbe_right == ((struct top *)NULL)))
            tmp->e_key.rbe_left->e_key.rbe_parent = parent;


        __CPROVER_DUMP_L37:
          ;
          tmp->e_key.rbe_parent = parent->e_key.rbe_parent;
          if(!(tmp->e_key.rbe_parent == ((struct top *)NULL)))
          {
            if(parent == parent->e_key.rbe_parent->e_key.rbe_left)
              parent->e_key.rbe_parent->e_key.rbe_left = tmp;

            else
              parent->e_key.rbe_parent->e_key.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->e_key.rbe_left = parent;
          parent->e_key.rbe_parent = tmp;

        __CPROVER_DUMP_L42:
          ;
          if(!(tmp->e_key.rbe_parent == ((struct top *)NULL)))

            __CPROVER_DUMP_L43:
              ;

        }
        while((_Bool)0);
        elm = head->rbh_root;
        break;
      }
    }

    else
    {
      tmp = parent->e_key.rbe_left;
      if(tmp->e_key.rbe_color == 1)
      {
        do
        {
          tmp->e_key.rbe_color = 0;
          parent->e_key.rbe_color = 1;
        }
        while((_Bool)0);
        do
        {
          tmp = parent->e_key.rbe_left;
          parent->e_key.rbe_left = tmp->e_key.rbe_right;
          if(!(parent->e_key.rbe_left == ((struct top *)NULL)))
            tmp->e_key.rbe_right->e_key.rbe_parent = parent;


        __CPROVER_DUMP_L49:
          ;
          tmp->e_key.rbe_parent = parent->e_key.rbe_parent;
          if(!(tmp->e_key.rbe_parent == ((struct top *)NULL)))
          {
            if(parent == parent->e_key.rbe_parent->e_key.rbe_left)
              parent->e_key.rbe_parent->e_key.rbe_left = tmp;

            else
              parent->e_key.rbe_parent->e_key.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->e_key.rbe_right = parent;
          parent->e_key.rbe_parent = tmp;

        __CPROVER_DUMP_L54:
          ;
          if(!(tmp->e_key.rbe_parent == ((struct top *)NULL)))

            __CPROVER_DUMP_L55:
              ;

        }
        while((_Bool)0);
        tmp = parent->e_key.rbe_left;
      }

      if(tmp->e_key.rbe_left == ((struct top *)NULL))
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = tmp->e_key.rbe_left->e_key.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
      {
        if(tmp->e_key.rbe_right == ((struct top *)NULL))
          tmp_if_expr$8 = (_Bool)1;

        else
          tmp_if_expr$8 = tmp->e_key.rbe_right->e_key.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$9 = tmp_if_expr$8 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$9 = (_Bool)0;
      if(tmp_if_expr$9)
      {
        tmp->e_key.rbe_color = 1;
        elm = parent;
        parent = elm->e_key.rbe_parent;
      }

      else
      {
        if(tmp->e_key.rbe_left == ((struct top *)NULL))
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = tmp->e_key.rbe_left->e_key.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
        {
          struct top *oright = tmp->e_key.rbe_right;
          if(!(oright == ((struct top *)NULL)))
            oright->e_key.rbe_color = 0;

          tmp->e_key.rbe_color = 1;
          do
          {
            oright = tmp->e_key.rbe_right;
            tmp->e_key.rbe_right = oright->e_key.rbe_left;
            if(!(tmp->e_key.rbe_right == ((struct top *)NULL)))
              oright->e_key.rbe_left->e_key.rbe_parent = tmp;


          __CPROVER_DUMP_L69:
            ;
            oright->e_key.rbe_parent = tmp->e_key.rbe_parent;
            if(!(oright->e_key.rbe_parent == ((struct top *)NULL)))
            {
              if(tmp == tmp->e_key.rbe_parent->e_key.rbe_left)
                tmp->e_key.rbe_parent->e_key.rbe_left = oright;

              else
                tmp->e_key.rbe_parent->e_key.rbe_right = oright;
            }

            else
              head->rbh_root = oright;
            oright->e_key.rbe_left = tmp;
            tmp->e_key.rbe_parent = oright;

          __CPROVER_DUMP_L74:
            ;
            if(!(oright->e_key.rbe_parent == ((struct top *)NULL)))

              __CPROVER_DUMP_L75:
                ;

          }
          while((_Bool)0);
          tmp = parent->e_key.rbe_left;
        }

        tmp->e_key.rbe_color = parent->e_key.rbe_color;
        parent->e_key.rbe_color = 0;
        if(!(tmp->e_key.rbe_left == ((struct top *)NULL)))
          tmp->e_key.rbe_left->e_key.rbe_color = 0;

        do
        {
          tmp = parent->e_key.rbe_left;
          parent->e_key.rbe_left = tmp->e_key.rbe_right;
          if(!(parent->e_key.rbe_left == ((struct top *)NULL)))
            tmp->e_key.rbe_right->e_key.rbe_parent = parent;


        __CPROVER_DUMP_L79:
          ;
          tmp->e_key.rbe_parent = parent->e_key.rbe_parent;
          if(!(tmp->e_key.rbe_parent == ((struct top *)NULL)))
          {
            if(parent == parent->e_key.rbe_parent->e_key.rbe_left)
              parent->e_key.rbe_parent->e_key.rbe_left = tmp;

            else
              parent->e_key.rbe_parent->e_key.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->e_key.rbe_right = parent;
          parent->e_key.rbe_parent = tmp;

        __CPROVER_DUMP_L84:
          ;
          if(!(tmp->e_key.rbe_parent == ((struct top *)NULL)))

            __CPROVER_DUMP_L85:
              ;

        }
        while((_Bool)0);
        elm = head->rbh_root;
        break;
      }
    }
  }

__CPROVER_DUMP_L88:
  ;
  if(!(elm == ((struct top *)NULL)))
    elm->e_key.rbe_color = 0;

}

// t_order_VRB_FIND
// file varnishtop.c line 112
struct top * t_order_VRB_FIND(struct t_order *head, struct top *elm)
{
  struct top *tmp = head->rbh_root;
  signed int comp;
  while(!(tmp == ((struct top *)NULL)))
  {
    comp=cmp_order(elm, tmp);
    if(!(comp >= 0))
      tmp = tmp->e_order.rbe_left;

    else
      if(comp >= 1)
        tmp = tmp->e_order.rbe_right;

      else
        return tmp;
  }
  return (struct top *)(void *)0;
}

// t_order_VRB_INSERT
// file varnishtop.c line 112
struct top * t_order_VRB_INSERT(struct t_order *head, struct top *elm)
{
  struct top *tmp;
  struct top *parent = (struct top *)(void *)0;
  signed int comp = 0;
  tmp = head->rbh_root;
  while(!(tmp == ((struct top *)NULL)))
  {
    parent = tmp;
    comp=cmp_order(elm, parent);
    if(!(comp >= 0))
      tmp = tmp->e_order.rbe_left;

    else
      if(comp >= 1)
        tmp = tmp->e_order.rbe_right;

      else
        return tmp;
  }
  do
  {
    elm->e_order.rbe_parent = parent;
    elm->e_order.rbe_right = (struct top *)(void *)0;
    elm->e_order.rbe_left = elm->e_order.rbe_right;
    elm->e_order.rbe_color = 1;
  }
  while((_Bool)0);
  if(!(parent == ((struct top *)NULL)))
  {
    if(!(comp >= 0))
      parent->e_order.rbe_left = elm;

    else
      parent->e_order.rbe_right = elm;
  }

  else
    head->rbh_root = elm;

__CPROVER_DUMP_L7:
  ;
  t_order_VRB_INSERT_COLOR(head, elm);
  return (struct top *)(void *)0;
}

// t_order_VRB_INSERT_COLOR
// file varnishtop.c line 112
void t_order_VRB_INSERT_COLOR(struct t_order *head, struct top *elm)
{
  struct top *parent;
  struct top *gparent;
  struct top *tmp;
  do
  {
    parent = elm->e_order.rbe_parent;
    if(parent == ((struct top *)NULL))
      break;

    if(!(parent->e_order.rbe_color == 1))
      break;

    gparent = parent->e_order.rbe_parent;
    if(parent == gparent->e_order.rbe_left)
    {
      tmp = gparent->e_order.rbe_right;
      if(!(tmp == ((struct top *)NULL)))
      {
        if(tmp->e_order.rbe_color == 1)
        {
          tmp->e_order.rbe_color = 0;
          do
          {
            parent->e_order.rbe_color = 0;
            gparent->e_order.rbe_color = 1;
          }
          while((_Bool)0);
          elm = gparent;
          continue;
        }

      }

      if(parent->e_order.rbe_right == elm)
      {
        do
        {
          tmp = parent->e_order.rbe_right;
          parent->e_order.rbe_right = tmp->e_order.rbe_left;
          if(!(parent->e_order.rbe_right == ((struct top *)NULL)))
            tmp->e_order.rbe_left->e_order.rbe_parent = parent;


        __CPROVER_DUMP_L5:
          ;
          tmp->e_order.rbe_parent = parent->e_order.rbe_parent;
          if(!(tmp->e_order.rbe_parent == ((struct top *)NULL)))
          {
            if(parent == parent->e_order.rbe_parent->e_order.rbe_left)
              parent->e_order.rbe_parent->e_order.rbe_left = tmp;

            else
              parent->e_order.rbe_parent->e_order.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->e_order.rbe_left = parent;
          parent->e_order.rbe_parent = tmp;

        __CPROVER_DUMP_L10:
          ;
          if(!(tmp->e_order.rbe_parent == ((struct top *)NULL)))

            __CPROVER_DUMP_L11:
              ;

        }
        while((_Bool)0);
        tmp = parent;
        parent = elm;
        elm = tmp;
      }

      do
      {
        parent->e_order.rbe_color = 0;
        gparent->e_order.rbe_color = 1;
      }
      while((_Bool)0);
      do
      {
        tmp = gparent->e_order.rbe_left;
        gparent->e_order.rbe_left = tmp->e_order.rbe_right;
        if(!(gparent->e_order.rbe_left == ((struct top *)NULL)))
          tmp->e_order.rbe_right->e_order.rbe_parent = gparent;


      __CPROVER_DUMP_L15:
        ;
        tmp->e_order.rbe_parent = gparent->e_order.rbe_parent;
        if(!(tmp->e_order.rbe_parent == ((struct top *)NULL)))
        {
          if(gparent == gparent->e_order.rbe_parent->e_order.rbe_left)
            gparent->e_order.rbe_parent->e_order.rbe_left = tmp;

          else
            gparent->e_order.rbe_parent->e_order.rbe_right = tmp;
        }

        else
          head->rbh_root = tmp;
        tmp->e_order.rbe_right = gparent;
        gparent->e_order.rbe_parent = tmp;

      __CPROVER_DUMP_L20:
        ;
        if(!(tmp->e_order.rbe_parent == ((struct top *)NULL)))

          __CPROVER_DUMP_L21:
            ;

      }
      while((_Bool)0);
    }

    else
    {
      tmp = gparent->e_order.rbe_left;
      if(!(tmp == ((struct top *)NULL)))
      {
        if(!(tmp->e_order.rbe_color == 1))
          goto __CPROVER_DUMP_L25;

        tmp->e_order.rbe_color = 0;
        do
        {
          parent->e_order.rbe_color = 0;
          gparent->e_order.rbe_color = 1;
        }
        while((_Bool)0);
        elm = gparent;
      }

      else
      {

      __CPROVER_DUMP_L25:
        ;
        if(parent->e_order.rbe_left == elm)
        {
          do
          {
            tmp = parent->e_order.rbe_left;
            parent->e_order.rbe_left = tmp->e_order.rbe_right;
            if(!(parent->e_order.rbe_left == ((struct top *)NULL)))
              tmp->e_order.rbe_right->e_order.rbe_parent = parent;


          __CPROVER_DUMP_L27:
            ;
            tmp->e_order.rbe_parent = parent->e_order.rbe_parent;
            if(!(tmp->e_order.rbe_parent == ((struct top *)NULL)))
            {
              if(parent == parent->e_order.rbe_parent->e_order.rbe_left)
                parent->e_order.rbe_parent->e_order.rbe_left = tmp;

              else
                parent->e_order.rbe_parent->e_order.rbe_right = tmp;
            }

            else
              head->rbh_root = tmp;
            tmp->e_order.rbe_right = parent;
            parent->e_order.rbe_parent = tmp;

          __CPROVER_DUMP_L32:
            ;
            if(!(tmp->e_order.rbe_parent == ((struct top *)NULL)))

              __CPROVER_DUMP_L33:
                ;

          }
          while((_Bool)0);
          tmp = parent;
          parent = elm;
          elm = tmp;
        }

        do
        {
          parent->e_order.rbe_color = 0;
          gparent->e_order.rbe_color = 1;
        }
        while((_Bool)0);
        do
        {
          tmp = gparent->e_order.rbe_right;
          gparent->e_order.rbe_right = tmp->e_order.rbe_left;
          if(!(gparent->e_order.rbe_right == ((struct top *)NULL)))
            tmp->e_order.rbe_left->e_order.rbe_parent = gparent;


        __CPROVER_DUMP_L37:
          ;
          tmp->e_order.rbe_parent = gparent->e_order.rbe_parent;
          if(!(tmp->e_order.rbe_parent == ((struct top *)NULL)))
          {
            if(gparent == gparent->e_order.rbe_parent->e_order.rbe_left)
              gparent->e_order.rbe_parent->e_order.rbe_left = tmp;

            else
              gparent->e_order.rbe_parent->e_order.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->e_order.rbe_left = gparent;
          gparent->e_order.rbe_parent = tmp;

        __CPROVER_DUMP_L42:
          ;
          if(!(tmp->e_order.rbe_parent == ((struct top *)NULL)))

            __CPROVER_DUMP_L43:
              ;

        }
        while((_Bool)0);
      }
    }
  }
  while((_Bool)1);
  head->rbh_root->e_order.rbe_color = 0;
}

// t_order_VRB_MINMAX
// file varnishtop.c line 112
struct top * t_order_VRB_MINMAX(struct t_order *head, signed int val)
{
  struct top *tmp = head->rbh_root;
  struct top *parent = (struct top *)(void *)0;
  while(!(tmp == ((struct top *)NULL)))
  {
    parent = tmp;
    if(!(val >= 0))
      tmp = tmp->e_order.rbe_left;

    else
      tmp = tmp->e_order.rbe_right;
  }
  return parent;
}

// t_order_VRB_NEXT
// file varnishtop.c line 112
struct top * t_order_VRB_NEXT(struct top *elm)
{
  _Bool tmp_if_expr$1;
  if(!(elm->e_order.rbe_right == ((struct top *)NULL)))
  {
    elm = elm->e_order.rbe_right;
    for( ; !(elm->e_order.rbe_left == ((struct top *)NULL)); elm = elm->e_order.rbe_left)
      ;
  }

  else
  {
    if(!(elm->e_order.rbe_parent == ((struct top *)NULL)))
      tmp_if_expr$1 = elm == elm->e_order.rbe_parent->e_order.rbe_left ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      elm = elm->e_order.rbe_parent;

    else
    {
      for( ; !(elm->e_order.rbe_parent == ((struct top *)NULL)); elm = elm->e_order.rbe_parent)
        if(!(elm == elm->e_order.rbe_parent->e_order.rbe_right))
          break;

      elm = elm->e_order.rbe_parent;
    }
  }
  return elm;
}

// t_order_VRB_NFIND
// file varnishtop.c line 112
struct top * t_order_VRB_NFIND(struct t_order *head, struct top *elm)
{
  struct top *tmp = head->rbh_root;
  struct top *res = (struct top *)(void *)0;
  signed int comp;
  while(!(tmp == ((struct top *)NULL)))
  {
    comp=cmp_order(elm, tmp);
    if(!(comp >= 0))
    {
      res = tmp;
      tmp = tmp->e_order.rbe_left;
    }

    else
      if(comp >= 1)
        tmp = tmp->e_order.rbe_right;

      else
        return tmp;
  }
  return res;
}

// t_order_VRB_PREV
// file varnishtop.c line 112
struct top * t_order_VRB_PREV(struct top *elm)
{
  _Bool tmp_if_expr$1;
  if(!(elm->e_order.rbe_left == ((struct top *)NULL)))
  {
    elm = elm->e_order.rbe_left;
    for( ; !(elm->e_order.rbe_right == ((struct top *)NULL)); elm = elm->e_order.rbe_right)
      ;
  }

  else
  {
    if(!(elm->e_order.rbe_parent == ((struct top *)NULL)))
      tmp_if_expr$1 = elm == elm->e_order.rbe_parent->e_order.rbe_right ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      elm = elm->e_order.rbe_parent;

    else
    {
      for( ; !(elm->e_order.rbe_parent == ((struct top *)NULL)); elm = elm->e_order.rbe_parent)
        if(!(elm == elm->e_order.rbe_parent->e_order.rbe_left))
          break;

      elm = elm->e_order.rbe_parent;
    }
  }
  return elm;
}

// t_order_VRB_REMOVE
// file varnishtop.c line 112
struct top * t_order_VRB_REMOVE(struct t_order *head, struct top *elm)
{
  struct top *child;
  struct top *parent;
  struct top *old = elm;
  signed int color;
  if(elm->e_order.rbe_left == ((struct top *)NULL))
    child = elm->e_order.rbe_right;

  else
    if(elm->e_order.rbe_right == ((struct top *)NULL))
      child = elm->e_order.rbe_left;

    else
    {
      struct top *left;
      elm = elm->e_order.rbe_right;
      do
      {
        left = elm->e_order.rbe_left;
        if(left == ((struct top *)NULL))
          break;

        elm = left;
      }
      while((_Bool)1);
      child = elm->e_order.rbe_right;
      parent = elm->e_order.rbe_parent;
      color = elm->e_order.rbe_color;
      if(!(child == ((struct top *)NULL)))
        child->e_order.rbe_parent = parent;

      if(!(parent == ((struct top *)NULL)))
      {
        if(parent->e_order.rbe_left == elm)
          parent->e_order.rbe_left = child;

        else
          parent->e_order.rbe_right = child;
      }

      else
        head->rbh_root = child;

    __CPROVER_DUMP_L7:
      ;
      if(elm->e_order.rbe_parent == old)
        parent = elm;

      elm->e_order = old->e_order;
      if(!(old->e_order.rbe_parent == ((struct top *)NULL)))
      {
        if(old->e_order.rbe_parent->e_order.rbe_left == old)
          old->e_order.rbe_parent->e_order.rbe_left = elm;

        else
          old->e_order.rbe_parent->e_order.rbe_right = elm;
      }

      else
        head->rbh_root = elm;

    __CPROVER_DUMP_L12:
      ;
      old->e_order.rbe_left->e_order.rbe_parent = elm;
      if(!(old->e_order.rbe_right == ((struct top *)NULL)))
        old->e_order.rbe_right->e_order.rbe_parent = elm;

      if(!(parent == ((struct top *)NULL)))
      {
        left = parent;

      __CPROVER_DUMP_L16:
        ;
        while((_Bool)1)
        {
          left = left->e_order.rbe_parent;
          if(left == ((struct top *)NULL))
            break;

        }
      }

      goto color;
    }
  parent = elm->e_order.rbe_parent;
  color = elm->e_order.rbe_color;
  if(!(child == ((struct top *)NULL)))
    child->e_order.rbe_parent = parent;

  if(!(parent == ((struct top *)NULL)))
  {
    if(parent->e_order.rbe_left == elm)
      parent->e_order.rbe_left = child;

    else
      parent->e_order.rbe_right = child;
  }

  else
    head->rbh_root = child;

__CPROVER_DUMP_L21:
  ;

color:
  ;
  if(color == 0)
    t_order_VRB_REMOVE_COLOR(head, parent, child);

  return old;
}

// t_order_VRB_REMOVE_COLOR
// file varnishtop.c line 112
void t_order_VRB_REMOVE_COLOR(struct t_order *head, struct top *parent, struct top *elm)
{
  struct top *tmp;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$6;
  while((_Bool)1)
  {
    if(!(elm == ((struct top *)NULL)))
    {
      if(!(elm->e_order.rbe_color == 0))
        goto __CPROVER_DUMP_L88;

    }

    if(elm == head->rbh_root)
      break;


  __CPROVER_DUMP_L3:
    ;
    do
      if(parent == ((struct top *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("t_order_VRB_REMOVE_COLOR", "varnishtop.c", 112, "(parent) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    if(parent->e_order.rbe_left == elm)
    {
      tmp = parent->e_order.rbe_right;
      if(tmp->e_order.rbe_color == 1)
      {
        do
        {
          tmp->e_order.rbe_color = 0;
          parent->e_order.rbe_color = 1;
        }
        while((_Bool)0);
        do
        {
          tmp = parent->e_order.rbe_right;
          parent->e_order.rbe_right = tmp->e_order.rbe_left;
          if(!(parent->e_order.rbe_right == ((struct top *)NULL)))
            tmp->e_order.rbe_left->e_order.rbe_parent = parent;


        __CPROVER_DUMP_L7:
          ;
          tmp->e_order.rbe_parent = parent->e_order.rbe_parent;
          if(!(tmp->e_order.rbe_parent == ((struct top *)NULL)))
          {
            if(parent == parent->e_order.rbe_parent->e_order.rbe_left)
              parent->e_order.rbe_parent->e_order.rbe_left = tmp;

            else
              parent->e_order.rbe_parent->e_order.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->e_order.rbe_left = parent;
          parent->e_order.rbe_parent = tmp;

        __CPROVER_DUMP_L12:
          ;
          if(!(tmp->e_order.rbe_parent == ((struct top *)NULL)))

            __CPROVER_DUMP_L13:
              ;

        }
        while((_Bool)0);
        tmp = parent->e_order.rbe_right;
      }

      if(tmp->e_order.rbe_left == ((struct top *)NULL))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = tmp->e_order.rbe_left->e_order.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        if(tmp->e_order.rbe_right == ((struct top *)NULL))
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = tmp->e_order.rbe_right->e_order.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
      {
        tmp->e_order.rbe_color = 1;
        elm = parent;
        parent = elm->e_order.rbe_parent;
      }

      else
      {
        if(tmp->e_order.rbe_right == ((struct top *)NULL))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = tmp->e_order.rbe_right->e_order.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
        {
          struct top *oleft = tmp->e_order.rbe_left;
          if(!(oleft == ((struct top *)NULL)))
            oleft->e_order.rbe_color = 0;

          tmp->e_order.rbe_color = 1;
          do
          {
            oleft = tmp->e_order.rbe_left;
            tmp->e_order.rbe_left = oleft->e_order.rbe_right;
            if(!(tmp->e_order.rbe_left == ((struct top *)NULL)))
              oleft->e_order.rbe_right->e_order.rbe_parent = tmp;


          __CPROVER_DUMP_L27:
            ;
            oleft->e_order.rbe_parent = tmp->e_order.rbe_parent;
            if(!(oleft->e_order.rbe_parent == ((struct top *)NULL)))
            {
              if(tmp == tmp->e_order.rbe_parent->e_order.rbe_left)
                tmp->e_order.rbe_parent->e_order.rbe_left = oleft;

              else
                tmp->e_order.rbe_parent->e_order.rbe_right = oleft;
            }

            else
              head->rbh_root = oleft;
            oleft->e_order.rbe_right = tmp;
            tmp->e_order.rbe_parent = oleft;

          __CPROVER_DUMP_L32:
            ;
            if(!(oleft->e_order.rbe_parent == ((struct top *)NULL)))

              __CPROVER_DUMP_L33:
                ;

          }
          while((_Bool)0);
          tmp = parent->e_order.rbe_right;
        }

        tmp->e_order.rbe_color = parent->e_order.rbe_color;
        parent->e_order.rbe_color = 0;
        if(!(tmp->e_order.rbe_right == ((struct top *)NULL)))
          tmp->e_order.rbe_right->e_order.rbe_color = 0;

        do
        {
          tmp = parent->e_order.rbe_right;
          parent->e_order.rbe_right = tmp->e_order.rbe_left;
          if(!(parent->e_order.rbe_right == ((struct top *)NULL)))
            tmp->e_order.rbe_left->e_order.rbe_parent = parent;


        __CPROVER_DUMP_L37:
          ;
          tmp->e_order.rbe_parent = parent->e_order.rbe_parent;
          if(!(tmp->e_order.rbe_parent == ((struct top *)NULL)))
          {
            if(parent == parent->e_order.rbe_parent->e_order.rbe_left)
              parent->e_order.rbe_parent->e_order.rbe_left = tmp;

            else
              parent->e_order.rbe_parent->e_order.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->e_order.rbe_left = parent;
          parent->e_order.rbe_parent = tmp;

        __CPROVER_DUMP_L42:
          ;
          if(!(tmp->e_order.rbe_parent == ((struct top *)NULL)))

            __CPROVER_DUMP_L43:
              ;

        }
        while((_Bool)0);
        elm = head->rbh_root;
        break;
      }
    }

    else
    {
      tmp = parent->e_order.rbe_left;
      if(tmp->e_order.rbe_color == 1)
      {
        do
        {
          tmp->e_order.rbe_color = 0;
          parent->e_order.rbe_color = 1;
        }
        while((_Bool)0);
        do
        {
          tmp = parent->e_order.rbe_left;
          parent->e_order.rbe_left = tmp->e_order.rbe_right;
          if(!(parent->e_order.rbe_left == ((struct top *)NULL)))
            tmp->e_order.rbe_right->e_order.rbe_parent = parent;


        __CPROVER_DUMP_L49:
          ;
          tmp->e_order.rbe_parent = parent->e_order.rbe_parent;
          if(!(tmp->e_order.rbe_parent == ((struct top *)NULL)))
          {
            if(parent == parent->e_order.rbe_parent->e_order.rbe_left)
              parent->e_order.rbe_parent->e_order.rbe_left = tmp;

            else
              parent->e_order.rbe_parent->e_order.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->e_order.rbe_right = parent;
          parent->e_order.rbe_parent = tmp;

        __CPROVER_DUMP_L54:
          ;
          if(!(tmp->e_order.rbe_parent == ((struct top *)NULL)))

            __CPROVER_DUMP_L55:
              ;

        }
        while((_Bool)0);
        tmp = parent->e_order.rbe_left;
      }

      if(tmp->e_order.rbe_left == ((struct top *)NULL))
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = tmp->e_order.rbe_left->e_order.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
      {
        if(tmp->e_order.rbe_right == ((struct top *)NULL))
          tmp_if_expr$8 = (_Bool)1;

        else
          tmp_if_expr$8 = tmp->e_order.rbe_right->e_order.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$9 = tmp_if_expr$8 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$9 = (_Bool)0;
      if(tmp_if_expr$9)
      {
        tmp->e_order.rbe_color = 1;
        elm = parent;
        parent = elm->e_order.rbe_parent;
      }

      else
      {
        if(tmp->e_order.rbe_left == ((struct top *)NULL))
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = tmp->e_order.rbe_left->e_order.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
        {
          struct top *oright = tmp->e_order.rbe_right;
          if(!(oright == ((struct top *)NULL)))
            oright->e_order.rbe_color = 0;

          tmp->e_order.rbe_color = 1;
          do
          {
            oright = tmp->e_order.rbe_right;
            tmp->e_order.rbe_right = oright->e_order.rbe_left;
            if(!(tmp->e_order.rbe_right == ((struct top *)NULL)))
              oright->e_order.rbe_left->e_order.rbe_parent = tmp;


          __CPROVER_DUMP_L69:
            ;
            oright->e_order.rbe_parent = tmp->e_order.rbe_parent;
            if(!(oright->e_order.rbe_parent == ((struct top *)NULL)))
            {
              if(tmp == tmp->e_order.rbe_parent->e_order.rbe_left)
                tmp->e_order.rbe_parent->e_order.rbe_left = oright;

              else
                tmp->e_order.rbe_parent->e_order.rbe_right = oright;
            }

            else
              head->rbh_root = oright;
            oright->e_order.rbe_left = tmp;
            tmp->e_order.rbe_parent = oright;

          __CPROVER_DUMP_L74:
            ;
            if(!(oright->e_order.rbe_parent == ((struct top *)NULL)))

              __CPROVER_DUMP_L75:
                ;

          }
          while((_Bool)0);
          tmp = parent->e_order.rbe_left;
        }

        tmp->e_order.rbe_color = parent->e_order.rbe_color;
        parent->e_order.rbe_color = 0;
        if(!(tmp->e_order.rbe_left == ((struct top *)NULL)))
          tmp->e_order.rbe_left->e_order.rbe_color = 0;

        do
        {
          tmp = parent->e_order.rbe_left;
          parent->e_order.rbe_left = tmp->e_order.rbe_right;
          if(!(parent->e_order.rbe_left == ((struct top *)NULL)))
            tmp->e_order.rbe_right->e_order.rbe_parent = parent;


        __CPROVER_DUMP_L79:
          ;
          tmp->e_order.rbe_parent = parent->e_order.rbe_parent;
          if(!(tmp->e_order.rbe_parent == ((struct top *)NULL)))
          {
            if(parent == parent->e_order.rbe_parent->e_order.rbe_left)
              parent->e_order.rbe_parent->e_order.rbe_left = tmp;

            else
              parent->e_order.rbe_parent->e_order.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->e_order.rbe_right = parent;
          parent->e_order.rbe_parent = tmp;

        __CPROVER_DUMP_L84:
          ;
          if(!(tmp->e_order.rbe_parent == ((struct top *)NULL)))

            __CPROVER_DUMP_L85:
              ;

        }
        while((_Bool)0);
        elm = head->rbh_root;
        break;
      }
    }
  }

__CPROVER_DUMP_L88:
  ;
  if(!(elm == ((struct top *)NULL)))
    elm->e_order.rbe_color = 0;

}

// update
// file varnishtop.c line 183
static void update(signed int p)
{
  struct top *tp;
  struct top *tp2;
  signed int l;
  signed int len;
  double t = (double)0;
  signed long int now;
  now=time((signed long int *)(void *)0);
  unsigned long int return_value_strlen$1;
  unsigned long int return_value_strlen$2;
  static signed long int last = (signed long int)0;
  if(!(now == last))
  {
    last = now;
    l = 1;
    static unsigned int n;
    if(!(n >= (unsigned int)p))
      n = n + 1u;

    werase(stdscr);
    if(!(end_of_file == 0))
    {
      return_value_strlen$1=strlen(VUT.name);
      mvprintw(0, (signed int)(((unsigned long int)(COLS - 1) - return_value_strlen$1) - (unsigned long int)5), "%s (EOF)", VUT.name);
    }

    else
    {
      return_value_strlen$2=strlen(VUT.name);
      mvprintw(0, (signed int)((unsigned long int)(COLS - 1) - return_value_strlen$2), "%s", VUT.name);
    }
    mvprintw(0, 0, "list length %u", ntop);
    tp=t_order_VRB_MINMAX(&h_order, -1);
    for( ; !(tp == ((struct top *)NULL)); tp = tp2)
    {
      tp2=t_order_VRB_NEXT(tp);
      l = l + 1;
      if(!(l >= LINES))
      {
        len = tp->clen;
        if(!(COLS + -20 >= len))
          len = COLS - 20;

        mvprintw(l, 0, "%9.2f %-*.*s %*.*s\n", tp->count, maxfieldlen, maxfieldlen, VSL_tags[(signed long int)tp->tag], len, len, tp->rec_data);
        t = tp->count;
      }

      if(end_of_file == 0)
      {
        tp->count = tp->count + (1.0 / 3.0 - tp->count) / (double)n;
        if(tp->count * 10.000000 < t || !(10 * LINES >= l))
        {
          t_key_VRB_REMOVE(&h_key, tp);
          t_order_VRB_REMOVE(&h_order, tp);
          free((void *)tp->rec_buf);
          free((void *)tp);
          ntop = ntop - 1u;
        }

      }

    }
    wrefresh(stdscr);
  }

}

// usage
// file varnishtop.c line 308
static void usage(signed int status)
{
  const char **opt;
  fprintf(stderr, "Usage: %s <options>\n\n", (const void *)progname);
  fprintf(stderr, "Options:\n");
  opt = vopt_usage;
  for( ; !(*opt == ((const char *)NULL)); opt = opt + (signed long int)2)
    fprintf(stderr, " %-25s %s\n", *opt, opt[(signed long int)1]);
  exit(status);
}

// vbe32dec
// file ../../include/vend.h line 45
static inline unsigned int vbe32dec(const void *pp)
{
  const unsigned char *p = (const unsigned char *)pp;
  return (unsigned int)p[(signed long int)0] << 24 | (unsigned int)((signed int)p[(signed long int)1] << 16) | (unsigned int)((signed int)p[(signed long int)2] << 8) | (unsigned int)p[(signed long int)3];
}

// vbe32enc
// file ../../include/vend.h line 98
static inline void vbe32enc(void *pp, unsigned int u)
{
  unsigned char *p = (unsigned char *)pp;
  p[(signed long int)0] = (unsigned char)(u >> 24 & (unsigned int)0xff);
  p[(signed long int)1] = (unsigned char)(u >> 16 & (unsigned int)0xff);
  p[(signed long int)2] = (unsigned char)(u >> 8 & (unsigned int)0xff);
  p[(signed long int)3] = (unsigned char)(u & (unsigned int)0xff);
}

// vbe64enc
// file ../../include/vend.h line 109
static inline void vbe64enc(void *pp, unsigned long int u)
{
  unsigned char *p = (unsigned char *)pp;
  vbe32enc((void *)p, (unsigned int)(u >> 32));
  vbe32enc((void *)(p + (signed long int)4), (unsigned int)(u & (unsigned long int)0xffffffffU));
}

// vbit_clr
// file ../../include/vbm.h line 94
static inline void vbit_clr(struct vbitmap *vb, unsigned int bit)
{
  if(!(bit >= vb->nbits))
    vb->bits[(signed long int)((unsigned long int)bit / (sizeof(unsigned int) /*4ul*/  * (unsigned long int)8))] = vb->bits[(signed long int)((unsigned long int)bit / (sizeof(unsigned int) /*4ul*/  * (unsigned long int)8))] & ~(1U << (unsigned long int)bit % (sizeof(unsigned int) /*4ul*/  * (unsigned long int)8));

}

// vbit_destroy
// file ../../include/vbm.h line 75
static inline void vbit_destroy(struct vbitmap *vb)
{
  if(!(vb == ((struct vbitmap *)NULL)))
  {
    free((void *)vb->bits);
    free((void *)vb);
  }

}

// vbit_destroy$link1
// file ../../include/vbm.h line 75
static inline void vbit_destroy$link1(struct vbitmap *vb$link1)
{
  if(!(vb$link1 == ((struct vbitmap *)NULL)))
  {
    free((void *)vb$link1->bits);
    free((void *)vb$link1);
  }

}

// vbit_destroy$link2
// file ../../include/vbm.h line 75
static inline void vbit_destroy$link2(struct vbitmap *vb$link2)
{
  if(!(vb$link2 == ((struct vbitmap *)NULL)))
  {
    free((void *)vb$link2->bits);
    free((void *)vb$link2);
  }

}

// vbit_expand
// file ../../include/vbm.h line 48
static inline void vbit_expand(struct vbitmap *vb, unsigned int bit)
{
  unsigned char *p;
  bit = bit + (unsigned int)(1024 - 1);
  bit = bit - bit % (unsigned int)1024;
  void *return_value_realloc$1;
  return_value_realloc$1=realloc((void *)vb->bits, (unsigned long int)(bit / (unsigned int)8));
  p = (unsigned char *)return_value_realloc$1;
  do
    if(p == ((unsigned char *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vbit_expand", "../../include/vbm.h", 55, "p != NULL", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  memset((void *)(p + (signed long int)(vb->nbits / (unsigned int)8)), 0, (unsigned long int)((bit - vb->nbits) / (unsigned int)8));
  vb->bits = (unsigned int *)(void *)p;
  vb->nbits = bit;
}

// vbit_expand$link1
// file ../../include/vbm.h line 48
static inline void vbit_expand$link1(struct vbitmap *vb$link1, unsigned int bit$link1)
{
  unsigned char *p$link1;
  bit$link1 = bit$link1 + (unsigned int)(1024 - 1);
  bit$link1 = bit$link1 - bit$link1 % (unsigned int)1024;
  void *return_value_realloc$1$link1;
  return_value_realloc$1$link1=realloc((void *)vb$link1->bits, (unsigned long int)(bit$link1 / (unsigned int)8));
  p$link1 = (unsigned char *)return_value_realloc$1$link1;
  do
    if(p$link1 == ((unsigned char *)NULL))
    {
      signed int *return_value___errno_location$2$link1;
      return_value___errno_location$2$link1=__errno_location();
      VAS_Fail("vbit_expand", "../../include/vbm.h", 55, "p != NULL", *return_value___errno_location$2$link1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  memset((void *)(p$link1 + (signed long int)(vb$link1->nbits / (unsigned int)8)), 0, (unsigned long int)((bit$link1 - vb$link1->nbits) / (unsigned int)8));
  vb$link1->bits = (unsigned int *)(void *)p$link1;
  vb$link1->nbits = bit$link1;
}

// vbit_expand$link2
// file ../../include/vbm.h line 48
static inline void vbit_expand$link2(struct vbitmap *vb$link2, unsigned int bit$link2)
{
  unsigned char *p$link2;
  bit$link2 = bit$link2 + (unsigned int)(1024 - 1);
  bit$link2 = bit$link2 - bit$link2 % (unsigned int)1024;
  void *return_value_realloc$1$link2;
  return_value_realloc$1$link2=realloc((void *)vb$link2->bits, (unsigned long int)(bit$link2 / (unsigned int)8));
  p$link2 = (unsigned char *)return_value_realloc$1$link2;
  do
    if(p$link2 == ((unsigned char *)NULL))
    {
      signed int *return_value___errno_location$2$link2;
      return_value___errno_location$2$link2=__errno_location();
      VAS_Fail("vbit_expand", "../../include/vbm.h", 55, "p != NULL", *return_value___errno_location$2$link2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  memset((void *)(p$link2 + (signed long int)(vb$link2->nbits / (unsigned int)8)), 0, (unsigned long int)((bit$link2 - vb$link2->nbits) / (unsigned int)8));
  vb$link2->bits = (unsigned int *)(void *)p$link2;
  vb$link2->nbits = bit$link2;
}

// vbit_init
// file ../../include/vbm.h line 62
static inline struct vbitmap * vbit_init(unsigned int initial)
{
  struct vbitmap *vb;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc(sizeof(struct vbitmap) /*16ul*/ , (unsigned long int)1);
  vb = (struct vbitmap *)return_value_calloc$1;
  do
    if(vb == ((struct vbitmap *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vbit_init", "../../include/vbm.h", 67, "vb != NULL", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(initial == 0u)
    initial = (unsigned int)1024;

  vbit_expand(vb, initial);
  return vb;
}

// vbit_init$link1
// file ../../include/vbm.h line 62
static inline struct vbitmap * vbit_init$link1(unsigned int initial$link1)
{
  struct vbitmap *vb$link1;
  void *return_value_calloc$1$link1;
  return_value_calloc$1$link1=calloc(sizeof(struct vbitmap) /*16ul*/ , (unsigned long int)1);
  vb$link1 = (struct vbitmap *)return_value_calloc$1$link1;
  do
    if(vb$link1 == ((struct vbitmap *)NULL))
    {
      signed int *return_value___errno_location$2$link1;
      return_value___errno_location$2$link1=__errno_location();
      VAS_Fail("vbit_init", "../../include/vbm.h", 67, "vb != NULL", *return_value___errno_location$2$link1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(initial$link1 == 0u)
    initial$link1 = (unsigned int)1024;

  vbit_expand$link1(vb$link1, initial$link1);
  return vb$link1;
}

// vbit_init$link2
// file ../../include/vbm.h line 62
static inline struct vbitmap * vbit_init$link2(unsigned int initial$link2)
{
  struct vbitmap *vb$link2;
  void *return_value_calloc$1$link2;
  return_value_calloc$1$link2=calloc(sizeof(struct vbitmap) /*16ul*/ , (unsigned long int)1);
  vb$link2 = (struct vbitmap *)return_value_calloc$1$link2;
  do
    if(vb$link2 == ((struct vbitmap *)NULL))
    {
      signed int *return_value___errno_location$2$link2;
      return_value___errno_location$2$link2=__errno_location();
      VAS_Fail("vbit_init", "../../include/vbm.h", 67, "vb != NULL", *return_value___errno_location$2$link2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(initial$link2 == 0u)
    initial$link2 = (unsigned int)1024;

  vbit_expand$link2(vb$link2, initial$link2);
  return vb$link2;
}

// vbit_set
// file ../../include/vbm.h line 85
static inline void vbit_set(struct vbitmap *vb, unsigned int bit)
{
  if(bit >= vb->nbits)
    vbit_expand(vb, bit);

  vb->bits[(signed long int)((unsigned long int)bit / (sizeof(unsigned int) /*4ul*/  * (unsigned long int)8))] = vb->bits[(signed long int)((unsigned long int)bit / (sizeof(unsigned int) /*4ul*/  * (unsigned long int)8))] | 1U << (unsigned long int)bit % (sizeof(unsigned int) /*4ul*/  * (unsigned long int)8);
}

// vbit_test
// file ../../include/vbm.h line 102
static inline signed int vbit_test(struct vbitmap *vb, unsigned int bit)
{
  if(bit >= vb->nbits)
    return 0;

  else
    return (signed int)(vb->bits[(signed long int)((unsigned long int)bit / (sizeof(unsigned int) /*4ul*/  * (unsigned long int)8))] & 1U << (unsigned long int)bit % (sizeof(unsigned int) /*4ul*/  * (unsigned long int)8));
}

// vbit_test$link1
// file ../../include/vbm.h line 102
static inline signed int vbit_test$link1(struct vbitmap *vb$link1, unsigned int bit$link1)
{
  if(bit$link1 >= vb$link1->nbits)
    return 0;

  else
    return (signed int)(vb$link1->bits[(signed long int)((unsigned long int)bit$link1 / (sizeof(unsigned int) /*4ul*/  * (unsigned long int)8))] & 1U << (unsigned long int)bit$link1 % (sizeof(unsigned int) /*4ul*/  * (unsigned long int)8));
}

// vex_Free
// file vxp.h line 146
void vex_Free(struct vex **pvex)
{
  if(!((*pvex)->lhs == ((struct vex_lhs *)NULL)))
  {
    if(!((*pvex)->lhs->tags == ((struct vbitmap *)NULL)))
      vbit_destroy$link2((*pvex)->lhs->tags);

    if(!((*pvex)->lhs->prefix == ((char *)NULL)))
      free((void *)(*pvex)->lhs->prefix);

    do
    {
      (*pvex)->lhs->magic = (unsigned int)0;
      free((void *)(*pvex)->lhs);
    }
    while((_Bool)0);
  }

  if(!((*pvex)->rhs == ((struct vex_rhs *)NULL)))
  {
    if(!((*pvex)->rhs->val_string == ((char *)NULL)))
      free((void *)(*pvex)->rhs->val_string);

    if(!((*pvex)->rhs->val_regex == ((struct vre *)NULL)))
      VRE_free(&(*pvex)->rhs->val_regex);

    do
    {
      (*pvex)->rhs->magic = (unsigned int)0;
      free((void *)(*pvex)->rhs);
    }
    while((_Bool)0);
  }

  if(!((*pvex)->a == ((struct vex *)NULL)))
  {
    vex_Free(&(*pvex)->a);

  __CPROVER_DUMP_L7:
    ;
    do
      if(!((*pvex)->a == ((struct vex *)NULL)))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vex_Free", "vxp_parse.c", 519, "((*pvex)->a) == 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }

  if(!((*pvex)->b == ((struct vex *)NULL)))
  {
    vex_Free(&(*pvex)->b);

  __CPROVER_DUMP_L10:
    ;
    do
      if(!((*pvex)->b == ((struct vex *)NULL)))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vex_Free", "vxp_parse.c", 523, "((*pvex)->b) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }

  do
  {
    (*pvex)->magic = (unsigned int)0;
    free((void *)*pvex);
  }
  while((_Bool)0);
  *pvex = (struct vex *)(void *)0;
}

// vex_New
// file vxp.h line 145
struct vex * vex_New(const char *query, struct vsb *sb, unsigned int options)
{
  struct vxp *vxp;
  struct vex *vex;

__CPROVER_DUMP_L1:
  ;
  do
    if(query == ((const char *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vex_New", "vxp.c", 204, "(query) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(sb == ((struct vsb *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vex_New", "vxp.c", 205, "(sb) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vxp=vxp_New(sb);
  vxp->b = query;
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(query);
  vxp->e = query + (signed long int)return_value_strlen$3;
  vxp->vex_options = options;
  if(!((1u & options) == 0u))
    vxp->vre_options = vxp->vre_options | (signed int)VRE_CASELESS;

  vxp_Lexer(vxp);
  if(!(vxp->err == 0))
  {
    vxp_Delete(&vxp);

  __CPROVER_DUMP_L6:
    ;
    do
      if(!(vxp == ((struct vxp *)NULL)))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        VAS_Fail("vex_New", "vxp.c", 221, "(vxp) == 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    return (struct vex *)(void *)0;
  }

  else
  {
    vex=vxp_Parse(vxp);
    vxp_Delete(&vxp);

  __CPROVER_DUMP_L9:
    ;
    do
      if(!(vxp == ((struct vxp *)NULL)))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        VAS_Fail("vex_New", "vxp.c", 233, "(vxp) == 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    return vex;
  }
}

// vex_alloc
// file vxp_parse.c line 53
static struct vex * vex_alloc(struct vxp *vxp)
{
  struct vex *vex;
  do
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc(sizeof(struct vex) /*48ul*/ , (unsigned long int)1);
    vex = (struct vex *)return_value_calloc$1;
    if(!(vex == ((struct vex *)NULL)))
      vex->magic = 0xC7DB792D;

  }
  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(vex == ((struct vex *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vex_alloc", "vxp_parse.c", 58, "(vex) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vex->options = vxp->vex_options;
  return vex;
}

// vpf_read
// file ../../lib/libvarnish/vpf.c line 74
static signed int vpf_read(const char *path, signed int *pidptr)
{
  char buf[16l];
  char *endptr;
  signed int error;
  signed int fd;
  signed int i;
  fd=open(path, 00);
  signed int *return_value___errno_location$1;
  if(fd == -1)
  {
    return_value___errno_location$1=__errno_location();
    return *return_value___errno_location$1;
  }

  else
  {
    signed long int return_value_read$2;
    return_value_read$2=read(fd, (void *)buf, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
    i = (signed int)return_value_read$2;
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    error = *return_value___errno_location$3;
    close(fd);
    if(i == -1)
      return error;

    else
    {
      buf[(signed long int)i] = (char)0;
      signed long int return_value_strtol$4;
      return_value_strtol$4=strtol(buf, &endptr, 10);
      *pidptr = (signed int)return_value_strtol$4;
      if(!(endptr == buf + (signed long int)i))
        return 22;

      else
        return 0;
    }
  }
}

// vpf_verify
// file ../../lib/libvarnish/vpf.c line 57
static signed int vpf_verify(struct vpf_fh *pfh)
{
  struct stat sb;
  _Bool tmp_if_expr$1;
  if(pfh == ((struct vpf_fh *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = pfh->pf_fd == -1 ? (_Bool)1 : (_Bool)0;
  signed int *return_value___errno_location$2;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$1)
    return 22;

  else
  {
    signed int return_value_fstat$3;
    return_value_fstat$3=fstat(pfh->pf_fd, &sb);
    if(return_value_fstat$3 == -1)
    {
      return_value___errno_location$2=__errno_location();
      return *return_value___errno_location$2;
    }

    else
    {
      if(!(sb.st_dev == pfh->pf_dev))
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = sb.st_ino != pfh->pf_ino ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        return 22;

      else
        return 0;
    }
  }
}

// vsc_add_pt
// file vsc.c line 365
static void vsc_add_pt(struct vsc *vsc, const volatile void *ptr, struct VSC_desc *desc, struct vsc_vf *vf)
{
  struct vsc_pt *pt;
  do
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc(sizeof(struct vsc_pt) /*48ul*/ , (unsigned long int)1);
    pt = (struct vsc_pt *)return_value_calloc$1;
    if(!(pt == ((struct vsc_pt *)NULL)))
      pt->magic = 0xa4ff159a;

  }
  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(pt == ((struct vsc_pt *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vsc_add_pt", "vsc.c", 371, "(pt) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  pt->point.desc = desc;
  pt->point.ptr = ptr;
  pt->point.section = &vf->section;
  do
  {
    pt->list.vtqe_next = (struct vsc_pt *)(void *)0;
    pt->list.vtqe_prev = (&vsc->pt_list)->vtqh_last;
    *(&vsc->pt_list)->vtqh_last = pt;
    (&vsc->pt_list)->vtqh_last = &pt->list.vtqe_next;
  }
  while((_Bool)0);
}

// vsc_add_vf
// file vsc.c line 339
static void vsc_add_vf(struct vsc *vsc, struct VSM_fantom *fantom, struct VSC_type_desc *desc, signed int order)
{
  struct vsc_vf *vf;
  struct vsc_vf *vf2;
  do
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc(sizeof(struct vsc_vf) /*240ul*/ , (unsigned long int)1);
    vf = (struct vsc_vf *)return_value_calloc$1;
    if(!(vf == ((struct vsc_vf *)NULL)))
      vf->magic = (unsigned int)0x516519f8;

  }
  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(vf == ((struct vsc_vf *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vsc_add_vf", "vsc.c", 345, "(vf) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vf->fantom = *fantom;
  vf->section.type = vf->fantom.type;
  vf->section.ident = vf->fantom.ident;
  vf->section.desc = desc;
  vf->section.fantom = &vf->fantom;
  vf->order = order;
  vf2 = (&vsc->vf_list)->vtqh_first;
  for( ; !(vf2 == ((struct vsc_vf *)NULL)); vf2 = vf2->list.vtqe_next)
    if(!(vf->order >= vf2->order))
      break;

  if(!(vf2 == ((struct vsc_vf *)NULL)))
    do
    {
      vf->list.vtqe_prev = vf2->list.vtqe_prev;
      vf->list.vtqe_next = vf2;
      *vf2->list.vtqe_prev = vf;
      vf2->list.vtqe_prev = &vf->list.vtqe_next;
    }
    while((_Bool)0);

  else
    do
    {
      vf->list.vtqe_next = (struct vsc_vf *)(void *)0;
      vf->list.vtqe_prev = (&vsc->vf_list)->vtqh_last;
      *(&vsc->vf_list)->vtqh_last = vf;
      (&vsc->vf_list)->vtqh_last = &vf->list.vtqe_next;
    }
    while((_Bool)0);
}

// vsc_build_pt_list
// file vsc.c line 427
static void vsc_build_pt_list(struct VSM_data *vd)
{
  struct vsc *vsc;
  vsc=vsc_setup(vd);
  struct vsc_vf *vf;
  vsc_delete_pt_list(vsc);
  vf = (&vsc->vf_list)->vtqh_first;
  for( ; !(vf == ((struct vsc_vf *)NULL)); vf = vf->list.vtqe_next)
  {

  __CPROVER_DUMP_L2:
    ;
    do
    {
      if(vf == ((struct vsc_vf *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vsc_build_pt_list", "../../include/tbl/vsc_all.h", 31, "(vf) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(vf->magic == 1365580280u))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          VAS_Fail("vsc_build_pt_list", "../../include/tbl/vsc_all.h", 31, "(vf)->magic == 0x516519f8", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp(vf->fantom.type, VSC_type_mgt);
    if(return_value_strcmp$3 == 0)
      iter_mgt(vsc, VSC_desc_mgt, vf);


  __CPROVER_DUMP_L6:
    ;
    do
    {
      if(vf == ((struct vsc_vf *)NULL))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        VAS_Fail("vsc_build_pt_list", "../../include/tbl/vsc_all.h", 37, "(vf) != NULL", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(vf->magic == 1365580280u))
        {
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          VAS_Fail("vsc_build_pt_list", "../../include/tbl/vsc_all.h", 37, "(vf)->magic == 0x516519f8", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    signed int return_value_strcmp$6;
    return_value_strcmp$6=strcmp(vf->fantom.type, VSC_type_lck);
    if(return_value_strcmp$6 == 0)
      iter_lck(vsc, VSC_desc_lck, vf);


  __CPROVER_DUMP_L10:
    ;
    do
    {
      if(vf == ((struct vsc_vf *)NULL))
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        VAS_Fail("vsc_build_pt_list", "../../include/tbl/vsc_all.h", 43, "(vf) != NULL", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(vf->magic == 1365580280u))
        {
          signed int *return_value___errno_location$8;
          return_value___errno_location$8=__errno_location();
          VAS_Fail("vsc_build_pt_list", "../../include/tbl/vsc_all.h", 43, "(vf)->magic == 0x516519f8", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    signed int return_value_strcmp$9;
    return_value_strcmp$9=strcmp(vf->fantom.type, VSC_type_main);
    if(return_value_strcmp$9 == 0)
      iter_main(vsc, VSC_desc_main, vf);


  __CPROVER_DUMP_L14:
    ;
    do
    {
      if(vf == ((struct vsc_vf *)NULL))
      {
        signed int *return_value___errno_location$10;
        return_value___errno_location$10=__errno_location();
        VAS_Fail("vsc_build_pt_list", "../../include/tbl/vsc_all.h", 47, "(vf) != NULL", *return_value___errno_location$10, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(vf->magic == 1365580280u))
        {
          signed int *return_value___errno_location$11;
          return_value___errno_location$11=__errno_location();
          VAS_Fail("vsc_build_pt_list", "../../include/tbl/vsc_all.h", 47, "(vf)->magic == 0x516519f8", *return_value___errno_location$11, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    signed int return_value_strcmp$12;
    return_value_strcmp$12=strcmp(vf->fantom.type, VSC_type_sma);
    if(return_value_strcmp$12 == 0)
      iter_sma(vsc, VSC_desc_sma, vf);


  __CPROVER_DUMP_L18:
    ;
    do
    {
      if(vf == ((struct vsc_vf *)NULL))
      {
        signed int *return_value___errno_location$13;
        return_value___errno_location$13=__errno_location();
        VAS_Fail("vsc_build_pt_list", "../../include/tbl/vsc_all.h", 53, "(vf) != NULL", *return_value___errno_location$13, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(vf->magic == 1365580280u))
        {
          signed int *return_value___errno_location$14;
          return_value___errno_location$14=__errno_location();
          VAS_Fail("vsc_build_pt_list", "../../include/tbl/vsc_all.h", 53, "(vf)->magic == 0x516519f8", *return_value___errno_location$14, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    signed int return_value_strcmp$15;
    return_value_strcmp$15=strcmp(vf->fantom.type, VSC_type_smf);
    if(return_value_strcmp$15 == 0)
      iter_smf(vsc, VSC_desc_smf, vf);


  __CPROVER_DUMP_L22:
    ;
    do
    {
      if(vf == ((struct vsc_vf *)NULL))
      {
        signed int *return_value___errno_location$16;
        return_value___errno_location$16=__errno_location();
        VAS_Fail("vsc_build_pt_list", "../../include/tbl/vsc_all.h", 59, "(vf) != NULL", *return_value___errno_location$16, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(vf->magic == 1365580280u))
        {
          signed int *return_value___errno_location$17;
          return_value___errno_location$17=__errno_location();
          VAS_Fail("vsc_build_pt_list", "../../include/tbl/vsc_all.h", 59, "(vf)->magic == 0x516519f8", *return_value___errno_location$17, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    signed int return_value_strcmp$18;
    return_value_strcmp$18=strcmp(vf->fantom.type, VSC_type_vbe);
    if(return_value_strcmp$18 == 0)
      iter_vbe(vsc, VSC_desc_vbe, vf);


  __CPROVER_DUMP_L26:
    ;
    do
    {
      if(vf == ((struct vsc_vf *)NULL))
      {
        signed int *return_value___errno_location$19;
        return_value___errno_location$19=__errno_location();
        VAS_Fail("vsc_build_pt_list", "../../include/tbl/vsc_all.h", 65, "(vf) != NULL", *return_value___errno_location$19, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(vf->magic == 1365580280u))
        {
          signed int *return_value___errno_location$20;
          return_value___errno_location$20=__errno_location();
          VAS_Fail("vsc_build_pt_list", "../../include/tbl/vsc_all.h", 65, "(vf)->magic == 0x516519f8", *return_value___errno_location$20, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    signed int return_value_strcmp$21;
    return_value_strcmp$21=strcmp(vf->fantom.type, VSC_type_mempool);
    if(return_value_strcmp$21 == 0)
      iter_mempool(vsc, VSC_desc_mempool, vf);

  }
}

// vsc_build_vf_list
// file vsc.c line 407
static void vsc_build_vf_list(struct VSM_data *vd)
{
  struct vsc *vsc;
  vsc=vsc_setup(vd);
  vsc_delete_pt_list(vsc);
  vsc_delete_vf_list(vsc);
  VSM__iter0(vd, &vsc->iter_fantom);
  signed int return_value_VSM__itern$1;
  do
  {
    return_value_VSM__itern$1=VSM__itern(vd, &vsc->iter_fantom);
    if(return_value_VSM__itern$1 == 0)
      break;

    signed int return_value_strcmp$2;
    return_value_strcmp$2=strcmp(vsc->iter_fantom.class, "Stat");
    if(return_value_strcmp$2 == 0)
    {
      signed int return_value_strcmp$3;
      return_value_strcmp$3=strcmp(vsc->iter_fantom.type, "MAIN");
      if(return_value_strcmp$3 == 0)
        vsc_add_vf(vsc, &vsc->iter_fantom, &VSC_type_desc_main, 0);

      signed int return_value_strcmp$4;
      return_value_strcmp$4=strcmp(vsc->iter_fantom.type, "MGT");
      if(return_value_strcmp$4 == 0)
        vsc_add_vf(vsc, &vsc->iter_fantom, &VSC_type_desc_mgt, 1);

      signed int return_value_strcmp$5;
      return_value_strcmp$5=strcmp(vsc->iter_fantom.type, "MEMPOOL");
      if(return_value_strcmp$5 == 0)
        vsc_add_vf(vsc, &vsc->iter_fantom, &VSC_type_desc_mempool, 2);

      signed int return_value_strcmp$6;
      return_value_strcmp$6=strcmp(vsc->iter_fantom.type, "SMA");
      if(return_value_strcmp$6 == 0)
        vsc_add_vf(vsc, &vsc->iter_fantom, &VSC_type_desc_sma, 3);

      signed int return_value_strcmp$7;
      return_value_strcmp$7=strcmp(vsc->iter_fantom.type, "SMF");
      if(return_value_strcmp$7 == 0)
        vsc_add_vf(vsc, &vsc->iter_fantom, &VSC_type_desc_smf, 4);

      signed int return_value_strcmp$8;
      return_value_strcmp$8=strcmp(vsc->iter_fantom.type, "VBE");
      if(return_value_strcmp$8 == 0)
        vsc_add_vf(vsc, &vsc->iter_fantom, &VSC_type_desc_vbe, 5);

      signed int return_value_strcmp$9;
      return_value_strcmp$9=strcmp(vsc->iter_fantom.type, "LCK");
      if(return_value_strcmp$9 == 0)
        vsc_add_vf(vsc, &vsc->iter_fantom, &VSC_type_desc_lck, 6);

    }

  }
  while((_Bool)1);
}

// vsc_delete_pt_list
// file vsc.c line 132
static void vsc_delete_pt_list(struct vsc *vsc)
{
  struct vsc_pt *pt;
  while(!(vsc->pt_list.vtqh_first == ((struct vsc_pt *)NULL)))
  {
    pt = (&vsc->pt_list)->vtqh_first;

  __CPROVER_DUMP_L2:
    ;
    do
    {
      if(pt == ((struct vsc_pt *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vsc_delete_pt_list", "vsc.c", 138, "(pt) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(pt->magic == 0xa4ff159a))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          VAS_Fail("vsc_delete_pt_list", "vsc.c", 138, "(pt)->magic == 0xa4ff159a", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {
      if(!(pt->list.vtqe_next == ((struct vsc_pt *)NULL)))
        pt->list.vtqe_next->list.vtqe_prev = pt->list.vtqe_prev;

      else
        (&vsc->pt_list)->vtqh_last = pt->list.vtqe_prev;
      *pt->list.vtqe_prev = pt->list.vtqe_next;
    }
    while((_Bool)0);
    do
    {
      pt->magic = (unsigned int)0;
      free((void *)pt);
    }
    while((_Bool)0);
  }
}

// vsc_delete_sf_list
// file vsc.c line 145
static void vsc_delete_sf_list(struct vsc *vsc)
{
  struct vsc_sf *sf;
  while(!(vsc->sf_list.vtqh_first == ((struct vsc_sf *)NULL)))
  {
    sf = (&vsc->sf_list)->vtqh_first;

  __CPROVER_DUMP_L2:
    ;
    do
    {
      if(sf == ((struct vsc_sf *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vsc_delete_sf_list", "vsc.c", 151, "(sf) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(sf->magic == 1434745053u))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          VAS_Fail("vsc_delete_sf_list", "vsc.c", 151, "(sf)->magic == 0x558478dd", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {
      if(!(sf->list.vtqe_next == ((struct vsc_sf *)NULL)))
        sf->list.vtqe_next->list.vtqe_prev = sf->list.vtqe_prev;

      else
        (&vsc->sf_list)->vtqh_last = sf->list.vtqe_prev;
      *sf->list.vtqe_prev = sf->list.vtqe_next;
    }
    while((_Bool)0);
    free((void *)sf->type);
    free((void *)sf->ident);
    free((void *)sf->name);
    do
    {
      sf->magic = (unsigned int)0;
      free((void *)sf);
    }
    while((_Bool)0);
  }
}

// vsc_delete_vf_list
// file vsc.c line 119
static void vsc_delete_vf_list(struct vsc *vsc)
{
  struct vsc_vf *vf;
  while(!(vsc->vf_list.vtqh_first == ((struct vsc_vf *)NULL)))
  {
    vf = (&vsc->vf_list)->vtqh_first;

  __CPROVER_DUMP_L2:
    ;
    do
    {
      if(vf == ((struct vsc_vf *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vsc_delete_vf_list", "vsc.c", 125, "(vf) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(vf->magic == 1365580280u))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          VAS_Fail("vsc_delete_vf_list", "vsc.c", 125, "(vf)->magic == 0x516519f8", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {
      if(!(vf->list.vtqe_next == ((struct vsc_vf *)NULL)))
        vf->list.vtqe_next->list.vtqe_prev = vf->list.vtqe_prev;

      else
        (&vsc->vf_list)->vtqh_last = vf->list.vtqe_prev;
      *vf->list.vtqe_prev = vf->list.vtqe_next;
    }
    while((_Bool)0);
    do
    {
      vf->magic = (unsigned int)0;
      free((void *)vf);
    }
    while((_Bool)0);
  }
}

// vsc_f_arg
// file vsc.c line 178
static signed int vsc_f_arg(struct VSM_data *vd, const char *opt)
{
  struct vsc *vsc;
  vsc=vsc_setup(vd);
  struct vsc_sf *sf;
  const char *error = (const char *)(void *)0;
  const char *p;
  const char *q;
  char *r;
  signed int i;
  signed int flags = 0;
  char *parts[3l];

__CPROVER_DUMP_L1:
  ;
  do
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vsc_f_arg", "vsc.c", 189, "(vd) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(opt == ((const char *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vsc_f_arg", "vsc.c", 190, "(opt) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if((signed int)*opt == 94)
  {
    flags = flags | 1 << 0;
    opt = opt + 1l;
  }

  memset((void *)parts, 0, sizeof(char *[3l]) /*24ul*/ );
  i = 0;
  p = opt;
  _Bool tmp_if_expr$3;
  char *tmp_post$6;
  const char *tmp_post$7;
  for( ; !((signed int)*p == 0); i = i + 1)
  {
    q = p;
    do
    {
      if(!((signed int)*q == 0))
        tmp_if_expr$3 = (signed int)*q != 46 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(!tmp_if_expr$3)
        break;

      if((signed int)*q == 92)
        q = q + 1l;

      q = q + 1l;
    }
    while((_Bool)1);
    if(!(i >= 3))
    {
      void *return_value_malloc$4;
      return_value_malloc$4=malloc((unsigned long int)(((signed long int)1 + q) - p));
      parts[(signed long int)i] = (char *)return_value_malloc$4;

    __CPROVER_DUMP_L12:
      ;
      do
        if(parts[(signed long int)i] == ((char *)NULL))
        {
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          VAS_Fail("vsc_f_arg", "vsc.c", 205, "(parts[i]) != 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      memcpy((void *)parts[(signed long int)i], (const void *)p, (unsigned long int)(q - p));
      parts[(signed long int)i][q - p] = (char)0;
      r = parts[(signed long int)i];
      p = r;
      for( ; (_Bool)1; *tmp_post$6 = *tmp_post$7)
      {
        if((signed int)*p == 92)
          p = p + 1l;

        if((signed int)*p == 0)
          break;

        tmp_post$6 = r;
        r = r + 1l;
        tmp_post$7 = p;
        p = p + 1l;
      }
      *r = (char)0;
    }

    p = q;
    if((signed int)*p == 46)
      p = p + 1l;

  }
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$16;
  if(i >= 4 || !(i >= 1))
  {
    vsm_diag(vd, "-f: Wrong number of elements");
    i = 0;
    for( ; !(i >= 3); i = i + 1)
      free((void *)parts[(signed long int)i]);
    return -1;
  }

  else
  {
    do
    {
      void *return_value_calloc$8;
      return_value_calloc$8=calloc(sizeof(struct vsc_sf) /*56ul*/ , (unsigned long int)1);
      sf = (struct vsc_sf *)return_value_calloc$8;
      if(!(sf == ((struct vsc_sf *)NULL)))
        sf->magic = (unsigned int)0x558478dd;

    }
    while((_Bool)0);

  __CPROVER_DUMP_L24:
    ;
    do
      if(sf == ((struct vsc_sf *)NULL))
      {
        signed int *return_value___errno_location$9;
        return_value___errno_location$9=__errno_location();
        VAS_Fail("vsc_f_arg", "vsc.c", 233, "(sf) != 0", *return_value___errno_location$9, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    sf->flags = flags;

  __CPROVER_DUMP_L26:
    ;
    do
      if(parts[0l] == ((char *)NULL))
      {
        signed int *return_value___errno_location$10;
        return_value___errno_location$10=__errno_location();
        VAS_Fail("vsc_f_arg", "vsc.c", 235, "(parts[0]) != 0", *return_value___errno_location$10, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    sf->type = parts[(signed long int)0];
    if(i == 2)
    {

    __CPROVER_DUMP_L28:
      ;
      do
        if(parts[1l] == ((char *)NULL))
        {
          signed int *return_value___errno_location$11;
          return_value___errno_location$11=__errno_location();
          VAS_Fail("vsc_f_arg", "vsc.c", 238, "(parts[1]) != 0", *return_value___errno_location$11, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      sf->name = parts[(signed long int)1];
    }

    else
      if(i == 3)
      {

      __CPROVER_DUMP_L31:
        ;
        do
          if(parts[1l] == ((char *)NULL))
          {
            signed int *return_value___errno_location$12;
            return_value___errno_location$12=__errno_location();
            VAS_Fail("vsc_f_arg", "vsc.c", 241, "(parts[1]) != 0", *return_value___errno_location$12, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
        sf->ident = parts[(signed long int)1];

      __CPROVER_DUMP_L33:
        ;
        do
          if(parts[2l] == ((char *)NULL))
          {
            signed int *return_value___errno_location$13;
            return_value___errno_location$13=__errno_location();
            VAS_Fail("vsc_f_arg", "vsc.c", 243, "(parts[2]) != 0", *return_value___errno_location$13, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
        sf->name = parts[(signed long int)2];
      }

    if(!(sf->type == ((char *)NULL)))
    {
      r=strchr(sf->type, 42);
      if(!(r == ((char *)NULL)))
        tmp_if_expr$14 = (signed int)r[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$14 = (_Bool)0;
      if(tmp_if_expr$14)
      {
        *r = (char)0;
        sf->flags = sf->flags | 1 << 1;
      }

      else
        if(!(r == ((char *)NULL)))
          error = "-f: Wildcard not last";

    }

    if(!(sf->ident == ((char *)NULL)))
    {
      r=strchr(sf->ident, 42);
      if(!(r == ((char *)NULL)))
        tmp_if_expr$15 = (signed int)r[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$15 = (_Bool)0;
      if(tmp_if_expr$15)
      {
        *r = (char)0;
        sf->flags = sf->flags | 1 << 2;
      }

      else
        if(!(r == ((char *)NULL)))
          error = "-f: Wildcard not last";

    }

    if(!(sf->name == ((char *)NULL)))
    {
      r=strchr(sf->name, 42);
      if(!(r == ((char *)NULL)))
        tmp_if_expr$16 = (signed int)r[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$16 = (_Bool)0;
      if(tmp_if_expr$16)
      {
        *r = (char)0;
        sf->flags = sf->flags | 1 << 3;
      }

      else
        if(!(r == ((char *)NULL)))
          error = "-f: Wildcard not last";

    }

    if(!(error == ((const char *)NULL)))
    {
      vsm_diag(vd, "%s", error);
      free((void *)sf->type);
      free((void *)sf->ident);
      free((void *)sf->name);
      do
      {
        sf->magic = (unsigned int)0;
        free((void *)sf);
      }
      while((_Bool)0);
      return -1;
    }

    else
    {
      do
      {
        sf->list.vtqe_next = (struct vsc_sf *)(void *)0;
        sf->list.vtqe_prev = (&vsc->sf_list)->vtqh_last;
        *(&vsc->sf_list)->vtqh_last = sf;
        (&vsc->sf_list)->vtqh_last = &sf->list.vtqe_next;
      }
      while((_Bool)0);
      return 1;
    }
  }
}

// vsc_filter_pt_list
// file vsc.c line 467
static void vsc_filter_pt_list(struct VSM_data *vd)
{
  struct vsc *vsc;
  vsc=vsc_setup(vd);
  struct vsc_sf *sf;
  struct vsc_pt *pt;
  struct vsc_pt *pt2;
  /* tag-#anon#lST[l*{lSYM#tag-vsc_pt#}$lSYM#tag-vsc_pt#$'vtqh_first'||l*{l*{lSYM#tag-vsc_pt#}$lSYM#tag-vsc_pt#$}$l*{lSYM#tag-vsc_pt#}$lSYM#tag-vsc_pt#$$'vtqh_last'|] */
struct anonymous$12
{
  // vtqh_first
  struct vsc_pt *vtqh_first;
  // vtqh_last
  struct vsc_pt **vtqh_last;
};

/* */
  ;
  struct anonymous$12 pt_list;
  _Bool tmp_if_expr$3;
  if(!(vsc->sf_list.vtqh_first == ((struct vsc_sf *)NULL)))
  {
    do
    {
      (&pt_list)->vtqh_first = (struct vsc_pt *)(void *)0;
      (&pt_list)->vtqh_last = &(&pt_list)->vtqh_first;
    }
    while((_Bool)0);
    sf = (&vsc->sf_list)->vtqh_first;
    for( ; !(sf == ((struct vsc_sf *)NULL)); sf = sf->list.vtqe_next)
    {

    __CPROVER_DUMP_L3:
      ;
      do
      {
        if(sf == ((struct vsc_sf *)NULL))
        {
          signed int *return_value___errno_location$1;
          return_value___errno_location$1=__errno_location();
          VAS_Fail("vsc_filter_pt_list", "vsc.c", 479, "(sf) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
        }

        do
          if(!(sf->magic == 1434745053u))
          {
            signed int *return_value___errno_location$2;
            return_value___errno_location$2=__errno_location();
            VAS_Fail("vsc_filter_pt_list", "vsc.c", 479, "(sf)->magic == 0x558478dd", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
      }
      while((_Bool)0);
      pt = (&vsc->pt_list)->vtqh_first;
      do
      {
        if(!(pt == ((struct vsc_pt *)NULL)))
        {
          pt2 = pt->list.vtqe_next;
          tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$3 = (_Bool)0;
        if(!tmp_if_expr$3)
          break;


      __CPROVER_DUMP_L10:
        ;
        do
        {
          if(pt == ((struct vsc_pt *)NULL))
          {
            signed int *return_value___errno_location$4;
            return_value___errno_location$4=__errno_location();
            VAS_Fail("vsc_filter_pt_list", "vsc.c", 481, "(pt) != NULL", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
          }

          do
            if(!(pt->magic == 0xa4ff159a))
            {
              signed int *return_value___errno_location$5;
              return_value___errno_location$5=__errno_location();
              VAS_Fail("vsc_filter_pt_list", "vsc.c", 481, "(pt)->magic == 0xa4ff159a", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
            }

          while((_Bool)0);
        }
        while((_Bool)0);
        signed int return_value_iter_test$6;
        return_value_iter_test$6=iter_test(sf->type, pt->point.section->type, sf->flags & 1 << 1);
        if(return_value_iter_test$6 == 0)
        {
          signed int return_value_iter_test$7;
          return_value_iter_test$7=iter_test(sf->ident, pt->point.section->ident, sf->flags & 1 << 2);
          if(return_value_iter_test$7 == 0)
          {
            signed int return_value_iter_test$8;
            return_value_iter_test$8=iter_test(sf->name, pt->point.desc->name, sf->flags & 1 << 3);
            if(return_value_iter_test$8 == 0)
            {
              do
              {
                if(!(pt->list.vtqe_next == ((struct vsc_pt *)NULL)))
                  pt->list.vtqe_next->list.vtqe_prev = pt->list.vtqe_prev;

                else
                  (&vsc->pt_list)->vtqh_last = pt->list.vtqe_prev;
                *pt->list.vtqe_prev = pt->list.vtqe_next;
              }
              while((_Bool)0);
              if(!((1 & sf->flags) == 0))
                do
                {
                  pt->magic = (unsigned int)0;
                  free((void *)pt);
                }
                while((_Bool)0);

              else
                do
                {
                  pt->list.vtqe_next = (struct vsc_pt *)(void *)0;
                  pt->list.vtqe_prev = (&pt_list)->vtqh_last;
                  *(&pt_list)->vtqh_last = pt;
                  (&pt_list)->vtqh_last = &pt->list.vtqe_next;
                }
                while((_Bool)0);
            }

          }

        }

        pt = pt2;
      }
      while((_Bool)1);
    }
    vsc_delete_pt_list(vsc);
    do
      if(!(pt_list.vtqh_first == ((struct vsc_pt *)NULL)))
      {
        *(&vsc->pt_list)->vtqh_last = (&pt_list)->vtqh_first;
        (&pt_list)->vtqh_first->list.vtqe_prev = (&vsc->pt_list)->vtqh_last;
        (&vsc->pt_list)->vtqh_last = (&pt_list)->vtqh_last;
        do
        {
          (&pt_list)->vtqh_first = (struct vsc_pt *)(void *)0;
          (&pt_list)->vtqh_last = &(&pt_list)->vtqh_first;
        }
        while((_Bool)0);
      }

    while((_Bool)0);
  }

}

// vsc_setup
// file vsc.c line 102
static struct vsc * vsc_setup(struct VSM_data *vd)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vsc_setup", "vsc.c", 105, "(vd) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->magic == 1849415323u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vsc_setup", "vsc.c", 105, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  if(vd->vsc == ((struct vsc *)NULL))
  {
    do
    {
      void *return_value_calloc$3;
      return_value_calloc$3=calloc(sizeof(struct vsc) /*232ul*/ , (unsigned long int)1);
      vd->vsc = (struct vsc *)return_value_calloc$3;
      if(!(vd->vsc == ((struct vsc *)NULL)))
        vd->vsc->magic = (unsigned int)0x3373554a;

    }
    while((_Bool)0);
    do
    {
      (&vd->vsc->vf_list)->vtqh_first = (struct vsc_vf *)(void *)0;
      (&vd->vsc->vf_list)->vtqh_last = &(&vd->vsc->vf_list)->vtqh_first;
    }
    while((_Bool)0);
    do
    {
      (&vd->vsc->pt_list)->vtqh_first = (struct vsc_pt *)(void *)0;
      (&vd->vsc->pt_list)->vtqh_last = &(&vd->vsc->pt_list)->vtqh_first;
    }
    while((_Bool)0);
    do
    {
      (&vd->vsc->sf_list)->vtqh_first = (struct vsc_sf *)(void *)0;
      (&vd->vsc->sf_list)->vtqh_last = &(&vd->vsc->sf_list)->vtqh_first;
    }
    while((_Bool)0);
  }


__CPROVER_DUMP_L10:
  ;
  do
  {
    if(vd->vsc == ((struct vsc *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("vsc_setup", "vsc.c", 112, "(vd->vsc) != NULL", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->vsc->magic == 863196490u))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        VAS_Fail("vsc_setup", "vsc.c", 112, "(vd->vsc)->magic == 0x3373554a", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  return vd->vsc;
}

// vsl_IX_arg
// file vsl_arg.c line 254
static signed int vsl_IX_arg(struct VSL_data *vsl, signed int opt, const char *arg)
{
  signed int i;
  signed int l;
  signed int off;
  const char *b;
  const char *e;
  const char *err;
  struct vre *vre;
  struct vslf *vslf;
  struct vbitmap *tags = (struct vbitmap *)(void *)0;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vsl_IX_arg", "vsl_arg.c", 262, "(vsl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsl->magic == 0x8E6C92AA))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vsl_IX_arg", "vsl_arg.c", 262, "(vsl)->magic == 0x8E6C92AA", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  vsl->flags = vsl->flags | (unsigned int)(1 << 0);
  b = arg;
  e=strchr(b, 58);
  signed int return_value_vsl_diag$4;
  signed int return_value_vsl_diag$5;
  signed int return_value_vsl_diag$6;
  if(!(e == ((const char *)NULL)))
  {
    tags=vbit_init((unsigned int)256);

  __CPROVER_DUMP_L5:
    ;
    do
      if(tags == ((struct vbitmap *)NULL))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("vsl_IX_arg", "vsl_arg.c", 269, "(tags) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    l = (signed int)(e - b);
    i=VSL_List2Tags(b, l, vsl_vbm_bitset, (void *)tags);
    if(!(i >= 0))
      vbit_destroy(tags);

    if(i == -1)
    {
      return_value_vsl_diag$4=vsl_diag(vsl, "-%c: \"%*.*s\" matches zero tags", (char)opt, l, l, b);
      return return_value_vsl_diag$4;
    }

    else
      if(i == -2)
      {
        return_value_vsl_diag$5=vsl_diag(vsl, "-%c: \"%*.*s\" is ambiguous", (char)opt, l, l, b);
        return return_value_vsl_diag$5;
      }

      else
        if(!(i >= -2))
        {
          return_value_vsl_diag$6=vsl_diag(vsl, "-%c: Syntax error in \"%*.*s\"", (char)opt, l, l, b);
          return return_value_vsl_diag$6;
        }

    b = e + (signed long int)1;
  }

  vre=VRE_compile(b, (signed int)(vsl->C_opt != 0 ? VRE_CASELESS : (unsigned int)0), &err, &off);
  if(vre == ((struct vre *)NULL))
  {
    if(!(tags == ((struct vbitmap *)NULL)))
      vbit_destroy(tags);

    signed int return_value_vsl_diag$7;
    return_value_vsl_diag$7=vsl_diag(vsl, "-%c: Regex error at position %d (%s)\n", (char)opt, off, err);
    return return_value_vsl_diag$7;
  }

  do
  {
    void *return_value_calloc$8;
    return_value_calloc$8=calloc(sizeof(struct vslf) /*40ul*/ , (unsigned long int)1);
    vslf = (struct vslf *)return_value_calloc$8;
    if(!(vslf == ((struct vslf *)NULL)))
      vslf->magic = (unsigned int)0x08650B39;

  }
  while((_Bool)0);

__CPROVER_DUMP_L15:
  ;
  do
    if(vslf == ((struct vslf *)NULL))
    {
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      VAS_Fail("vsl_IX_arg", "vsl_arg.c", 298, "(vslf) != 0", *return_value___errno_location$9, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vslf->tags = tags;
  vslf->vre = vre;
  if(opt == 73)
    do
    {
      vslf->list.vtqe_next = (struct vslf *)(void *)0;
      vslf->list.vtqe_prev = (&vsl->vslf_select)->vtqh_last;
      *(&vsl->vslf_select)->vtqh_last = vslf;
      (&vsl->vslf_select)->vtqh_last = &vslf->list.vtqe_next;
    }
    while((_Bool)0);

  else
  {
    do
      if(!(opt == 88))
      {
        signed int *return_value___errno_location$10;
        return_value___errno_location$10=__errno_location();
        VAS_Fail("vsl_IX_arg", "vsl_arg.c", 305, "opt == 'X'", *return_value___errno_location$10, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    do
    {
      vslf->list.vtqe_next = (struct vslf *)(void *)0;
      vslf->list.vtqe_prev = (&vsl->vslf_suppress)->vtqh_last;
      *(&vsl->vslf_suppress)->vtqh_last = vslf;
      (&vsl->vslf_suppress)->vtqh_last = &vslf->list.vtqe_next;
    }
    while((_Bool)0);
  }
  return 1;
}

// vsl_IX_free
// file vsl.c line 111
static void vsl_IX_free(struct anonymous$1 *filters)
{
  struct vslf *vslf;
  while(!(filters->vtqh_first == ((struct vslf *)NULL)))
  {
    vslf = filters->vtqh_first;

  __CPROVER_DUMP_L2:
    ;
    do
    {
      if(vslf == ((struct vslf *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vsl_IX_free", "vsl.c", 117, "(vslf) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(vslf->magic == 140839737u))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          VAS_Fail("vsl_IX_free", "vsl.c", 117, "(vslf)->magic == 0x08650B39", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {
      if(!(vslf->list.vtqe_next == ((struct vslf *)NULL)))
        vslf->list.vtqe_next->list.vtqe_prev = vslf->list.vtqe_prev;

      else
        filters->vtqh_last = vslf->list.vtqe_prev;
      *vslf->list.vtqe_prev = vslf->list.vtqe_next;
    }
    while((_Bool)0);
    if(!(vslf->tags == ((struct vbitmap *)NULL)))
      vbit_destroy$link1(vslf->tags);


  __CPROVER_DUMP_L9:
    ;
    do
      if(vslf->vre == ((struct vre *)NULL))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("vsl_IX_free", "vsl.c", 121, "(vslf->vre) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    VRE_free(&vslf->vre);

  __CPROVER_DUMP_L11:
    ;
    do
      if(!(vslf->vre == ((struct vre *)NULL)))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        VAS_Fail("vsl_IX_free", "vsl.c", 123, "(vslf->vre) == 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
}

// vsl_diag
// file vsl_api.h line 40
signed int vsl_diag(struct VSL_data *vsl, const char *fmt, ...)
{
  void **ap;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vsl_diag", "vsl.c", 77, "(vsl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsl->magic == 0x8E6C92AA))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vsl_diag", "vsl.c", 77, "(vsl)->magic == 0x8E6C92AA", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L5:
  ;
  do
    if(fmt == ((const char *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vsl_diag", "vsl.c", 78, "(fmt) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(vsl->diag == ((struct vsb *)NULL))
    vsl->diag=VSB_new((struct vsb *)(void *)0, (char *)(void *)0, 0, 0x00000001);


__CPROVER_DUMP_L7:
  ;
  do
    if(vsl->diag == ((struct vsb *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("vsl_diag", "vsl.c", 82, "(vsl->diag) != 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  VSB_clear(vsl->diag);
  ap = (void **)&fmt;
  VSB_vprintf(vsl->diag, fmt, ap);
  ap = ((void **)NULL);
  do
  {

  __CPROVER_DUMP_L9:
    ;
    signed int return_value_VSB_finish$6;
    return_value_VSB_finish$6=VSB_finish(vsl->diag);
    if(!(return_value_VSB_finish$6 == 0))
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      VAS_Fail("vsl_diag", "vsl.c", 87, "(VSB_finish(vsl->diag)) == 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
    }

  }
  while((_Bool)0);
  return -1;
}

// vsl_ix_arg
// file vsl_arg.c line 231
static signed int vsl_ix_arg(struct VSL_data *vsl, signed int opt, const char *arg)
{
  signed int i;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vsl == ((struct VSL_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vsl_ix_arg", "vsl_arg.c", 235, "(vsl) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vsl->magic == 0x8E6C92AA))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vsl_ix_arg", "vsl_arg.c", 235, "(vsl)->magic == 0x8E6C92AA", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  vsl->flags = vsl->flags | (unsigned int)(1 << 0);
  i=VSL_List2Tags(arg, -1, opt == 120 ? vsl_vbm_bitset : vsl_vbm_bitclr, (void *)vsl->vbm_supress);
  signed int return_value_vsl_diag$3;
  signed int return_value_vsl_diag$4;
  signed int return_value_vsl_diag$5;
  if(i == -1)
  {
    return_value_vsl_diag$3=vsl_diag(vsl, "-%c: \"%s\" matches zero tags", (char)opt, arg);
    return return_value_vsl_diag$3;
  }

  else
    if(i == -2)
    {
      return_value_vsl_diag$4=vsl_diag(vsl, "-%c: \"%s\" is ambiguous", (char)opt, arg);
      return return_value_vsl_diag$4;
    }

    else
      if(i == -3)
      {
        return_value_vsl_diag$5=vsl_diag(vsl, "-%c: Syntax error in \"%s\"", (char)opt, arg);
        return return_value_vsl_diag$5;
      }

  return 1;
}

// vsl_match_IX
// file vsl.c line 166
static signed int vsl_match_IX(struct VSL_data *vsl, const struct anonymous$1 *list, struct VSL_cursor *c)
{
  enum VSL_tag_e tag;
  const char *cdata;
  signed int len;
  struct vslf *vslf;
  (void)vsl;
  tag = (enum VSL_tag_e)(c->rec.ptr[(signed long int)0] >> 24);
  cdata = (const char *)(c->rec.ptr + (signed long int)2);
  len = (signed int)(c->rec.ptr[(signed long int)0] & (unsigned int)0xffff);
  vslf = list->vtqh_first;
  signed int return_value_vbit_test$3;
  for( ; !(vslf == ((struct vslf *)NULL)); vslf = vslf->list.vtqe_next)
  {

  __CPROVER_DUMP_L2:
    ;
    do
    {
      if(vslf == ((struct vslf *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vsl_match_IX", "vsl.c", 180, "(vslf) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(vslf->magic == 140839737u))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          VAS_Fail("vsl_match_IX", "vsl.c", 180, "(vslf)->magic == 0x08650B39", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    if(!(vslf->tags == ((struct vbitmap *)NULL)))
    {
      return_value_vbit_test$3=vbit_test$link1(vslf->tags, (unsigned int)tag);
      if(return_value_vbit_test$3 == 0)
        goto __CPROVER_DUMP_L8;

    }

    signed int return_value_VRE_exec$4;
    return_value_VRE_exec$4=VRE_exec(vslf->vre, cdata, len, 0, 0, (signed int *)(void *)0, 0, (struct vre_limits *)(void *)0);
    if(return_value_VRE_exec$4 >= 0)
      return 1;


  __CPROVER_DUMP_L8:
    ;
  }
  return 0;
}

// vsl_vbm_bitclr
// file vsl_arg.c line 224
void vsl_vbm_bitclr(signed int bit, void *priv)
{
  vbit_clr((struct vbitmap *)priv, (unsigned int)bit);
}

// vsl_vbm_bitset
// file vsl_arg.c line 217
void vsl_vbm_bitset(signed int bit, void *priv)
{
  vbit_set((struct vbitmap *)priv, (unsigned int)bit);
}

// vslc_file_delete
// file vsl_cursor.c line 293
static void vslc_file_delete(struct VSL_cursor *cursor)
{
  struct vslc_file *c;
  do
  {
    c = (struct vslc_file *)cursor->priv_data;
    do
      if(c == ((struct vslc_file *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vslc_file_delete", "vsl_cursor.c", 297, "(c) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  __CPROVER_DUMP_L4:
    ;
    do
      if(!(c->magic == 493223919u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vslc_file_delete", "vsl_cursor.c", 297, "((c))->magic == (0x1D65FFEF)", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  do
    if(!(&c->cursor == cursor))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vslc_file_delete", "vsl_cursor.c", 298, "&c->cursor == cursor", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(!(c->close_fd == 0))
    close(c->fd);

  if(!(c->buf == ((unsigned int *)NULL)))
    free((void *)c->buf);

  do
  {
    c->magic = (unsigned int)0;
    free((void *)c);
  }
  while((_Bool)0);
}

// vslc_file_next
// file vsl_cursor.c line 323
static signed int vslc_file_next(struct VSL_cursor *cursor)
{
  struct vslc_file *c;
  signed long int i;
  unsigned long int l;
  do
  {
    c = (struct vslc_file *)cursor->priv_data;
    do
      if(c == ((struct vslc_file *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vslc_file_next", "vsl_cursor.c", 329, "(c) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  __CPROVER_DUMP_L4:
    ;
    do
      if(!(c->magic == 493223919u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vslc_file_next", "vsl_cursor.c", 329, "((c))->magic == (0x1D65FFEF)", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  do
    if(!(&c->cursor == cursor))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vslc_file_next", "vsl_cursor.c", 330, "&c->cursor == cursor", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(!(c->error == 0))
    return c->error;

  else
  {
    do
    {
      c->cursor.rec.ptr = (const unsigned int *)(void *)0;
      do
        if(!(c->buflen >= 2l))
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          VAS_Fail("vslc_file_next", "vsl_cursor.c", 337, "c->buflen >= 2", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      i=vslc_file_readn(c->fd, (void *)c->buf, (unsigned long int)(2 * 4));
      if(!(i >= 0l))
        return -4;

      if(i == 0l)
        return -1;

      do
        if(!(i == 8l))
        {
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          VAS_Fail("vslc_file_next", "vsl_cursor.c", 343, "i == VSL_BYTES(2)", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      l = (unsigned long int)((unsigned int)2 + ((c->buf[(signed long int)0] & (unsigned int)0xffff) + (unsigned int)3) / (unsigned int)4);
      if(!((unsigned long int)c->buflen >= l))
      {
        for( ; !((unsigned long int)c->buflen >= l); c->buflen = (signed long int)((unsigned long int)2 * l))
          ;
        void *return_value_realloc$6;
        return_value_realloc$6=realloc((void *)c->buf, (unsigned long int)(c->buflen * (signed long int)4));
        c->buf = (unsigned int *)return_value_realloc$6;

      __CPROVER_DUMP_L16:
        ;
        do
          if(c->buf == ((unsigned int *)NULL))
          {
            signed int *return_value___errno_location$7;
            return_value___errno_location$7=__errno_location();
            VAS_Fail("vslc_file_next", "vsl_cursor.c", 349, "(c->buf) != 0", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
      }

      if(l >= 3ul)
      {
        i=vslc_file_readn(c->fd, (void *)(c->buf + (signed long int)2), (l - (unsigned long int)2) * (unsigned long int)4);
        if(!(i >= 0l))
          return -4;

        if(i == 0l)
          return -1;

        do
          if(!((unsigned long int)i == (l + 18446744073709551614ul) * 4ul))
          {
            signed int *return_value___errno_location$8;
            return_value___errno_location$8=__errno_location();
            VAS_Fail("vslc_file_next", "vsl_cursor.c", 358, "i == VSL_BYTES(l - 2)", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
      }

      c->cursor.rec.ptr = c->buf;
    }
    while(*c->cursor.rec.ptr >> 24 == 255u);
    return 1;
  }
}

// vslc_file_readn
// file vsl_cursor.c line 308
static signed long int vslc_file_readn(signed int fd, void *buf, unsigned long int n)
{
  unsigned long int t = (unsigned long int)0;
  signed long int l;
  for( ; !(t >= n); t = t + (unsigned long int)l)
  {
    l=read(fd, (void *)((char *)buf + (signed long int)t), n - t);
    if(!(l >= 1l))
      return l;

  }
  return (signed long int)t;
}

// vslc_file_reset
// file vsl_cursor.c line 366
static signed int vslc_file_reset(struct VSL_cursor *cursor)
{
  (void)cursor;
  return -1;
}

// vslc_raw_next
// file vsl_dispatch.c line 224
static signed int vslc_raw_next(struct VSL_cursor *cursor)
{
  struct vslc_raw *c;
  do
  {
    c = (struct vslc_raw *)cursor->priv_data;
    do
      if(c == ((struct vslc_raw *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vslc_raw_next", "vsl_dispatch.c", 228, "(c) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  __CPROVER_DUMP_L4:
    ;
    do
      if(!(c->magic == 612285764u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vslc_raw_next", "vsl_dispatch.c", 228, "((c))->magic == (0x247EBD44)", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  do
    if(!(&c->cursor == cursor))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vslc_raw_next", "vsl_dispatch.c", 229, "&c->cursor == cursor", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L8:
  ;
  do
    if(c->ptr == ((const unsigned int *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("vslc_raw_next", "vsl_dispatch.c", 231, "(c->ptr) != 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(c->cursor.rec.ptr == ((const unsigned int *)NULL))
  {
    c->cursor.rec.ptr = c->ptr;
    return 1;
  }

  else
  {
    c->cursor.rec.ptr = (const unsigned int *)(void *)0;
    return 0;
  }
}

// vslc_raw_reset
// file vsl_dispatch.c line 242
static signed int vslc_raw_reset(struct VSL_cursor *cursor)
{
  struct vslc_raw *c;
  do
  {
    c = (struct vslc_raw *)cursor->priv_data;
    do
      if(c == ((struct vslc_raw *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vslc_raw_reset", "vsl_dispatch.c", 246, "(c) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  __CPROVER_DUMP_L4:
    ;
    do
      if(!(c->magic == 612285764u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vslc_raw_reset", "vsl_dispatch.c", 246, "((c))->magic == (0x247EBD44)", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  do
    if(!(&c->cursor == cursor))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vslc_raw_reset", "vsl_dispatch.c", 247, "&c->cursor == cursor", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L8:
  ;
  do
    if(c->ptr == ((const unsigned int *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("vslc_raw_reset", "vsl_dispatch.c", 249, "(c->ptr) != 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  c->cursor.rec.ptr = (const unsigned int *)(void *)0;
  return 0;
}

// vslc_vsm_check
// file vsl_cursor.c line 77
static signed int vslc_vsm_check(struct VSL_cursor *cursor, struct VSLC_ptr *ptr)
{
  struct vslc_vsm *c;
  unsigned int seqdiff;
  unsigned int segment;
  unsigned int segdiff;
  do
  {
    c = (struct vslc_vsm *)cursor->priv_data;
    do
      if(c == ((struct vslc_vsm *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vslc_vsm_check", "vsl_cursor.c", 82, "(c) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  __CPROVER_DUMP_L4:
    ;
    do
      if(!(c->magic == 1295582118u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vslc_vsm_check", "vsl_cursor.c", 82, "((c))->magic == (0x4D3903A6)", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  do
    if(!(&c->cursor == cursor))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vslc_vsm_check", "vsl_cursor.c", 83, "&c->cursor == cursor", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(ptr->ptr == ((const unsigned int *)NULL))
    return 0;

  else
  {
    seqdiff = c->head->seq - ptr->priv;
    if(!(c->head->seq >= ptr->priv))
      seqdiff = seqdiff - (unsigned int)1;

    if(seqdiff >= 2u)
      return 0;

    else
    {
      segment = (unsigned int)((ptr->ptr - c->head->log) / c->segsize);
      if(segment >= 8u)
        segment = (unsigned int)(8 - 1);

      segdiff = (segment - c->head->segment) % (unsigned int)8;
      if(segdiff == 0u && seqdiff == 0u)
        return 2;

      else
        if(!(segdiff >= 3u))
          return 0;

        else
          if(!(segdiff >= 5u))
            return 1;

          else
            return 2;
    }
  }
}

// vslc_vsm_delete
// file vsl_cursor.c line 67
static void vslc_vsm_delete(struct VSL_cursor *cursor)
{
  struct vslc_vsm *c;
  do
  {
    c = (struct vslc_vsm *)cursor->priv_data;
    do
      if(c == ((struct vslc_vsm *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vslc_vsm_delete", "vsl_cursor.c", 71, "(c) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  __CPROVER_DUMP_L4:
    ;
    do
      if(!(c->magic == 1295582118u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vslc_vsm_delete", "vsl_cursor.c", 71, "((c))->magic == (0x4D3903A6)", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  do
    if(!(&c->cursor == cursor))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vslc_vsm_delete", "vsl_cursor.c", 72, "&c->cursor == cursor", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
  {
    c->magic = (unsigned int)0;
    free((void *)c);
  }
  while((_Bool)0);
}

// vslc_vsm_next
// file vsl_cursor.c line 117
static signed int vslc_vsm_next(struct VSL_cursor *cursor)
{
  struct vslc_vsm *c;
  signed int i;
  unsigned int t;
  do
  {
    c = (struct vslc_vsm *)cursor->priv_data;
    do
      if(c == ((struct vslc_vsm *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vslc_vsm_next", "vsl_cursor.c", 123, "(c) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  __CPROVER_DUMP_L4:
    ;
    do
      if(!(c->magic == 1295582118u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vslc_vsm_next", "vsl_cursor.c", 123, "((c))->magic == (0x4D3903A6)", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  do
    if(!(&c->cursor == cursor))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vslc_vsm_next", "vsl_cursor.c", 124, "&c->cursor == cursor", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L8:
  ;
  do
  {
    if(c->vsm == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("vslc_vsm_next", "vsl_cursor.c", 125, "(c->vsm) != NULL", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(c->vsm->magic == 1849415323u))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        VAS_Fail("vslc_vsm_next", "vsl_cursor.c", 125, "(c->vsm)->magic == 0x6e3bd69b", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L12:
  ;
  do
    if(c->next.ptr == ((const unsigned int *)NULL))
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      VAS_Fail("vslc_vsm_next", "vsl_cursor.c", 128, "(c->next.ptr) != 0", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
    if(!(c->next.ptr >= c->head->log))
    {
      signed int *return_value___errno_location$7;
      return_value___errno_location$7=__errno_location();
      VAS_Fail("vslc_vsm_next", "vsl_cursor.c", 129, "c->next.ptr >= c->head->log", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
    if(c->next.ptr >= c->end)
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      VAS_Fail("vslc_vsm_next", "vsl_cursor.c", 130, "c->next.ptr < c->end", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  i=vslc_vsm_check(&c->cursor, &c->next);
  _Bool tmp_if_expr$11;
  signed int return_value_VSM_Abandoned$10;
  if(!(i >= 1))
    return -3;

  else
  {
    if(*c->next.ptr == 4265952581u)
    {
      enum VSM_valid_e return_value_VSM_StillValid$9;
      return_value_VSM_StillValid$9=VSM_StillValid(c->vsm, &c->vf);
      if((signed int)return_value_VSM_StillValid$9 == VSM_invalid)
        tmp_if_expr$11 = (_Bool)1;

      else
      {
        return_value_VSM_Abandoned$10=VSM_Abandoned(c->vsm);
        tmp_if_expr$11 = return_value_VSM_Abandoned$10 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$11)
        return -2;

    }

    while((_Bool)1)
    {
      do
        if(!(c->next.ptr >= c->head->log))
        {
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          VAS_Fail("vslc_vsm_next", "vsl_cursor.c", 145, "c->next.ptr >= c->head->log", *return_value___errno_location$12, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      do
        if(c->next.ptr >= c->end)
        {
          signed int *return_value___errno_location$13;
          return_value___errno_location$13=__errno_location();
          VAS_Fail("vslc_vsm_next", "vsl_cursor.c", 146, "c->next.ptr < c->end", *return_value___errno_location$13, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);

    __CPROVER_DUMP_L27:
      ;
      do
        if(c->head->seq == 0u)
        {
          signed int *return_value___errno_location$14;
          return_value___errno_location$14=__errno_location();
          VAS_Fail("vslc_vsm_next", "vsl_cursor.c", 147, "(c->head->seq) != 0", *return_value___errno_location$14, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      t = *((const volatile unsigned int *)c->next.ptr);

    __CPROVER_DUMP_L29:
      ;
      do
        if(t == 0u)
        {
          signed int *return_value___errno_location$15;
          return_value___errno_location$15=__errno_location();
          VAS_Fail("vslc_vsm_next", "vsl_cursor.c", 149, "(t) != 0", *return_value___errno_location$15, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      if(t == 4267136855u)
      {
        do
          if(c->next.ptr == c->head->log)
          {
            signed int *return_value___errno_location$16;
            return_value___errno_location$16=__errno_location();
            VAS_Fail("vslc_vsm_next", "vsl_cursor.c", 153, "c->next.ptr != c->head->log", *return_value___errno_location$16, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
        c->next.ptr = c->head->log;
      }

      else
      {
        if(t == 4265952581u)
        {
          if(!(c->next.ptr == c->head->log))
          {
            if(!(c->next.priv == c->head->seq))
            {
              c->next.ptr = c->head->log;
              continue;
            }

          }

          if(!((4u & c->options) == 0u))
            return -1;

          else
            return 0;
        }

        if(c->next.ptr == c->head->log)
          c->next.priv = c->head->seq;

        c->cursor.rec = c->next;
        c->next.ptr = c->next.ptr + (signed long int)2 + (signed long int)(((c->next.ptr[(signed long int)0] & (unsigned int)0xffff) + (unsigned int)3) / (unsigned int)4);
        if(*c->cursor.rec.ptr >> 24 == 255u)
        {
          if((2u & c->options) == 0u)
            continue;

          c->next.ptr = c->next.ptr + (signed long int)((c->cursor.rec.ptr[(signed long int)1] + (unsigned int)3) / (unsigned int)4);
        }

        return 1;
      }
    }
  }
}

// vslc_vsm_reset
// file vsl_cursor.c line 192
static signed int vslc_vsm_reset(struct VSL_cursor *cursor)
{
  struct vslc_vsm *c;
  unsigned int segment;
  do
  {
    c = (struct vslc_vsm *)cursor->priv_data;
    do
      if(c == ((struct vslc_vsm *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vslc_vsm_reset", "vsl_cursor.c", 197, "(c) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  __CPROVER_DUMP_L4:
    ;
    do
      if(!(c->magic == 1295582118u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vslc_vsm_reset", "vsl_cursor.c", 197, "((c))->magic == (0x4D3903A6)", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  do
    if(!(&c->cursor == cursor))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vslc_vsm_reset", "vsl_cursor.c", 198, "&c->cursor == cursor", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  segment = (c->head->segment + (unsigned int)3) % (unsigned int)8;
  if(!(c->head->segments[(signed long int)segment] >= 0l))
    segment = (unsigned int)0;

  do
    if(!(c->head->segments[(signed long int)segment] >= 0l))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("vslc_vsm_reset", "vsl_cursor.c", 209, "c->head->segments[segment] >= 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  c->next.ptr = c->head->log + c->head->segments[(signed long int)segment];
  c->next.priv = c->head->seq;
  c->cursor.rec.ptr = (const unsigned int *)(void *)0;
  return 0;
}

// vslc_vtx_next
// file vsl_dispatch.c line 264
static signed int vslc_vtx_next(struct VSL_cursor *cursor)
{
  struct vslc_vtx *c;
  const unsigned int *ptr;
  do
  {
    c = (struct vslc_vtx *)cursor->priv_data;
    do
      if(c == ((struct vslc_vtx *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vslc_vtx_next", "vsl_dispatch.c", 269, "(c) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  __CPROVER_DUMP_L4:
    ;
    do
      if(!(c->magic == 1959154239u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vslc_vtx_next", "vsl_dispatch.c", 269, "((c))->magic == (0x74C6523F)", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  do
    if(!(&c->cursor == cursor))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vslc_vtx_next", "vsl_dispatch.c", 270, "&c->cursor == cursor", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L8:
  ;
  do
  {
    if(c->vtx == ((struct vtx *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("vslc_vtx_next", "vsl_dispatch.c", 271, "(c->vtx) != NULL", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(c->vtx->magic == 0xACC21D09))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        VAS_Fail("vslc_vtx_next", "vsl_dispatch.c", 271, "(c->vtx)->magic == 0xACC21D09", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L12:
  ;
  _Bool tmp_if_expr$13;
  while((_Bool)1)
  {
    if(!(c->synth == ((struct synth *)NULL)))
      do
        if(!(c->synth->magic == 0xC654479F))
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          VAS_Fail("vslc_vtx_next", "vsl_dispatch.c", 274, "(c->synth)->magic == 0xC654479F", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);

    if(!(c->synth == ((struct synth *)NULL)))
      tmp_if_expr$13 = c->synth->offset == c->offset ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$13 = (_Bool)0;
    if(tmp_if_expr$13)
    {
      c->cursor.rec.ptr = c->synth->data;
      c->synth = c->synth->list.vtqe_next;
    }

    else
    {
      do
        if(!(c->vtx->len >= c->offset))
        {
          signed int *return_value___errno_location$7;
          return_value___errno_location$7=__errno_location();
          VAS_Fail("vslc_vtx_next", "vsl_dispatch.c", 281, "c->offset <= c->vtx->len", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      if(c->offset == c->vtx->len)
        return 0;

      if(c->chunk == ((struct chunk *)NULL))
      {
        c->chunk = (&c->vtx->chunks)->vtqh_first;
        c->chunkstart = (unsigned long int)0;
      }


    __CPROVER_DUMP_L21:
      ;
      do
      {
        if(c->chunk == ((struct chunk *)NULL))
        {
          signed int *return_value___errno_location$8;
          return_value___errno_location$8=__errno_location();
          VAS_Fail("vslc_vtx_next", "vsl_dispatch.c", 291, "(c->chunk) != NULL", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
        }

        do
          if(!(c->chunk->magic == 1222377876u))
          {
            signed int *return_value___errno_location$9;
            return_value___errno_location$9=__errno_location();
            VAS_Fail("vslc_vtx_next", "vsl_dispatch.c", 291, "(c->chunk)->magic == 0x48DC0194", *return_value___errno_location$9, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
      }
      while((_Bool)0);
      while(c->offset >= c->chunk->len + c->chunkstart)
      {
        c->chunkstart = c->chunkstart + c->chunk->len;
        c->chunk = c->chunk->list.vtqe_next;

      __CPROVER_DUMP_L26:
        ;
        do
        {
          if(c->chunk == ((struct chunk *)NULL))
          {
            signed int *return_value___errno_location$10;
            return_value___errno_location$10=__errno_location();
            VAS_Fail("vslc_vtx_next", "vsl_dispatch.c", 295, "(c->chunk) != NULL", *return_value___errno_location$10, (enum vas_e)VAS_ASSERT);
          }

          do
            if(!(c->chunk->magic == 1222377876u))
            {
              signed int *return_value___errno_location$11;
              return_value___errno_location$11=__errno_location();
              VAS_Fail("vslc_vtx_next", "vsl_dispatch.c", 295, "(c->chunk)->magic == 0x48DC0194", *return_value___errno_location$11, (enum vas_e)VAS_ASSERT);
            }

          while((_Bool)0);
        }
        while((_Bool)0);
      }
      if((signed int)c->chunk->type == chunk_t_shm)
        ptr = c->chunk->$anon0.shm.start.ptr;

      else
      {
        do
          if(!((signed int)c->chunk->type == chunk_t_buf))
          {
            signed int *return_value___errno_location$12;
            return_value___errno_location$12=__errno_location();
            VAS_Fail("vslc_vtx_next", "vsl_dispatch.c", 302, "c->chunk->type == chunk_t_buf", *return_value___errno_location$12, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
        ptr = c->chunk->$anon0.buf.data;
      }
      c->cursor.rec.ptr = (ptr + (signed long int)c->offset) - (signed long int)c->chunkstart;
      c->offset = c->offset + (unsigned long int)((c->cursor.rec.ptr + (signed long int)2 + (signed long int)(((c->cursor.rec.ptr[(signed long int)0] & (unsigned int)0xffff) + (unsigned int)3) / (unsigned int)4)) - c->cursor.rec.ptr);
    }
    if(!(*c->cursor.rec.ptr >> 24 == 255u))
      break;

  }
  return 1;
}

// vslc_vtx_reset
// file vsl_dispatch.c line 315
static signed int vslc_vtx_reset(struct VSL_cursor *cursor)
{
  struct vslc_vtx *c;
  do
  {
    c = (struct vslc_vtx *)cursor->priv_data;
    do
      if(c == ((struct vslc_vtx *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vslc_vtx_reset", "vsl_dispatch.c", 319, "(c) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  __CPROVER_DUMP_L4:
    ;
    do
      if(!(c->magic == 1959154239u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vslc_vtx_reset", "vsl_dispatch.c", 319, "((c))->magic == (0x74C6523F)", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  do
    if(!(&c->cursor == cursor))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vslc_vtx_reset", "vsl_dispatch.c", 320, "&c->cursor == cursor", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L8:
  ;
  do
  {
    if(c->vtx == ((struct vtx *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("vslc_vtx_reset", "vsl_dispatch.c", 321, "(c->vtx) != NULL", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(c->vtx->magic == 0xACC21D09))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        VAS_Fail("vslc_vtx_reset", "vsl_dispatch.c", 321, "(c->vtx)->magic == 0xACC21D09", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  c->synth = (&c->vtx->synth)->vtqh_first;
  c->chunk = (struct chunk *)(void *)0;
  c->chunkstart = (unsigned long int)0;
  c->offset = (unsigned long int)0;
  c->cursor.rec.ptr = (const unsigned int *)(void *)0;
  return 0;
}

// vslq_callback
// file vsl_dispatch.c line 906
static signed int vslq_callback(struct VSLQ *vslq, struct vtx *vtx, signed int (*func)(struct VSL_data *, struct VSL_transaction * const *, void *), void *priv)
{
  unsigned int n = vtx->n_descend + (unsigned int)1;
  const signed long int n$array_size0 = (signed long int)n;
  struct vtx *vtxs[n$array_size0];
  const signed long int vtxs$array_size0 = (signed long int)n;
  struct VSL_transaction trans[vtxs$array_size0];
  const signed long int trans$array_size0 = (signed long int)(n + (unsigned int)1);
  struct VSL_transaction *ptrans[trans$array_size0];
  unsigned int i;
  unsigned int j;

__CPROVER_DUMP_L1:
  ;
  do
    if(vslq == ((struct VSLQ *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vslq_callback", "vsl_dispatch.c", 915, "(vslq) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
  {
    if(vtx == ((struct vtx *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vslq_callback", "vsl_dispatch.c", 916, "(vtx) != NULL", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vtx->magic == 0xACC21D09))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("vslq_callback", "vsl_dispatch.c", 916, "(vtx)->magic == 0xACC21D09", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L7:
  ;
  do
    if((8u & vtx->flags) == 0u)
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("vslq_callback", "vsl_dispatch.c", 917, "(vtx->flags & 0x8) != 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L9:
  ;
  do
    if(func == ((signed int (*)(struct VSL_data *, struct VSL_transaction * const *, void *))NULL))
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      VAS_Fail("vslq_callback", "vsl_dispatch.c", 918, "(func) != 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  signed int return_value_vslq_runquery$8;
  if((signed int)vslq->grouping == VSL_g_session)
  {
    if((signed int)vtx->type == VSL_t_sess)
      goto __CPROVER_DUMP_L11;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L11:
    ;
    if((signed int)vslq->grouping == VSL_g_request)
    {
      if((signed int)vtx->type == VSL_t_req)
        goto __CPROVER_DUMP_L12;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L12:
      ;
      vslc_vtx_reset(&vtx->c.cursor);
      vtxs[(signed long int)0] = vtx;
      trans[(signed long int)0].level = (unsigned int)1;
      trans[(signed long int)0].vxid = (signed int)vtx->key.vxid;
      trans[(signed long int)0].vxid_parent = 0;
      trans[(signed long int)0].type = vtx->type;
      trans[(signed long int)0].reason = vtx->reason;
      trans[(signed long int)0].c = &vtx->c.cursor;
      i = (unsigned int)1;
      j = (unsigned int)0;
      for( ; !(j >= i); j = j + 1u)
      {
        vtx = (&vtxs[(signed long int)j]->child)->vtqh_first;
        for( ; !(vtx == ((struct vtx *)NULL)); vtx = vtx->list_child.vtqe_next)
        {
          do
            if(i >= n)
            {
              signed int *return_value___errno_location$6;
              return_value___errno_location$6=__errno_location();
              VAS_Fail("vslq_callback", "vsl_dispatch.c", 940, "i < n", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
            }

          while((_Bool)0);
          vslc_vtx_reset(&vtx->c.cursor);
          vtxs[(signed long int)i] = vtx;
          if((signed int)vtx->reason == VSL_r_restart)
            trans[(signed long int)i].level = trans[(signed long int)j].level;

          else
            trans[(signed long int)i].level = trans[(signed long int)j].level + (unsigned int)1;
          trans[(signed long int)i].vxid = (signed int)vtx->key.vxid;
          trans[(signed long int)i].vxid_parent = trans[(signed long int)j].vxid;
          trans[(signed long int)i].type = vtx->type;
          trans[(signed long int)i].reason = vtx->reason;
          trans[(signed long int)i].c = &vtx->c.cursor;
          i = i + 1u;
        }
      }
      do
        if(!(i == n))
        {
          signed int *return_value___errno_location$7;
          return_value___errno_location$7=__errno_location();
          VAS_Fail("vslq_callback", "vsl_dispatch.c", 957, "i == n", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      i = (unsigned int)0;
      for( ; !(i >= n); i = i + 1u)
        ptrans[(signed long int)i] = &trans[(signed long int)i];
      ptrans[(signed long int)i] = (struct VSL_transaction *)(void *)0;
      if(!(vslq->query == ((struct vslq_query *)NULL)))
      {
        return_value_vslq_runquery$8=vslq_runquery(vslq->query, ptrans);
        if(!(return_value_vslq_runquery$8 == 0))
          goto __CPROVER_DUMP_L24;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L24:
        ;
        signed int return_value;
        return_value=func(vslq->vsl, ptrans, priv);
        return return_value;
      }
    }
  }
}

// vslq_deletequery
// file vsl_api.h line 100
void vslq_deletequery(struct vslq_query **pquery)
{
  struct vslq_query *query;

__CPROVER_DUMP_L1:
  ;
  do
    if(pquery == ((struct vslq_query **)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vslq_deletequery", "vsl_query.c", 329, "(pquery) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  query = *pquery;
  *pquery = (struct vslq_query *)(void *)0;

__CPROVER_DUMP_L3:
  ;
  do
  {
    if(query == ((struct vslq_query *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vslq_deletequery", "vsl_query.c", 332, "(query) != NULL", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(query->magic == 304292517u))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("vslq_deletequery", "vsl_query.c", 332, "(query)->magic == 0x122322A5", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L7:
  ;
  do
    if(query->vex == ((struct vex *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("vslq_deletequery", "vsl_query.c", 334, "(query->vex) != 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vex_Free(&query->vex);

__CPROVER_DUMP_L9:
  ;
  do
    if(!(query->vex == ((struct vex *)NULL)))
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      VAS_Fail("vslq_deletequery", "vsl_query.c", 336, "(query->vex) == 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
  {
    query->magic = (unsigned int)0;
    free((void *)query);
  }
  while((_Bool)0);
}

// vslq_exec
// file vsl_query.c line 264
static signed int vslq_exec(struct vex *vex, struct VSL_transaction * const *ptrans)
{
  signed int r;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vex == ((struct vex *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vslq_exec", "vsl_query.c", 268, "(vex) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vex->magic == 0xC7DB792D))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vslq_exec", "vsl_query.c", 268, "(vex)->magic == 0xC7DB792D", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  signed int return_value_vslq_exec$5;
  signed int return_value_vslq_exec$8;
  signed int return_value_vslq_test$11;
  switch(vex->tok)
  {
    case (unsigned int)136:
    {

    __CPROVER_DUMP_L5:
      ;
      do
        if(vex->a == ((struct vex *)NULL))
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          VAS_Fail("vslq_exec", "vsl_query.c", 272, "(vex->a) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);

    __CPROVER_DUMP_L7:
      ;
      do
        if(vex->b == ((struct vex *)NULL))
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          VAS_Fail("vslq_exec", "vsl_query.c", 273, "(vex->b) != 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      r=vslq_exec(vex->a, ptrans);
      if(!(r == 0))
        return r;

      return_value_vslq_exec$5=vslq_exec(vex->b, ptrans);
      return return_value_vslq_exec$5;
    }
    case (unsigned int)129:
    {

    __CPROVER_DUMP_L10:
      ;
      do
        if(vex->a == ((struct vex *)NULL))
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          VAS_Fail("vslq_exec", "vsl_query.c", 279, "(vex->a) != 0", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);

    __CPROVER_DUMP_L12:
      ;
      do
        if(vex->b == ((struct vex *)NULL))
        {
          signed int *return_value___errno_location$7;
          return_value___errno_location$7=__errno_location();
          VAS_Fail("vslq_exec", "vsl_query.c", 280, "(vex->b) != 0", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      r=vslq_exec(vex->a, ptrans);
      if(!(r >= 1))
        return r;

      return_value_vslq_exec$8=vslq_exec(vex->b, ptrans);
      return return_value_vslq_exec$8;
    }
    case (unsigned int)135:
    {

    __CPROVER_DUMP_L15:
      ;
      do
        if(vex->a == ((struct vex *)NULL))
        {
          signed int *return_value___errno_location$9;
          return_value___errno_location$9=__errno_location();
          VAS_Fail("vslq_exec", "vsl_query.c", 286, "(vex->a) != 0", *return_value___errno_location$9, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);

    __CPROVER_DUMP_L17:
      ;
      do
        if(!(vex->b == ((struct vex *)NULL)))
        {
          signed int *return_value___errno_location$10;
          return_value___errno_location$10=__errno_location();
          VAS_Fail("vslq_exec", "vsl_query.c", 287, "(vex->b) == 0", *return_value___errno_location$10, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      r=vslq_exec(vex->a, ptrans);
      if(!(r >= 0))
        return r;

      return (signed int)!(r != 0);
    }
    default:
    {
      return_value_vslq_test$11=vslq_test(vex, ptrans);
      return return_value_vslq_test$11;
    }
  }
  return 0;
}

// vslq_newquery
// file vsl_api.h line 98
struct vslq_query * vslq_newquery(struct VSL_data *vsl, enum VSL_grouping_e grouping, const char *querystring)
{
  struct vsb *vsb;
  struct vex *vex;
  struct vslq_query *query = (struct vslq_query *)(void *)0;
  (void)grouping;

__CPROVER_DUMP_L1:
  ;
  do
    if(querystring == ((const char *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vslq_newquery", "vsl_query.c", 307, "(querystring) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vsb=VSB_new((struct vsb *)(void *)0, (char *)(void *)0, 0, 0x00000001);

__CPROVER_DUMP_L3:
  ;
  do
    if(vsb == ((struct vsb *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vslq_newquery", "vsl_query.c", 310, "(vsb) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vex=vex_New(querystring, vsb, (unsigned int)(vsl->C_opt != 0 ? 1 << 0 : 0));
  do
  {

  __CPROVER_DUMP_L5:
    ;
    signed int return_value_VSB_finish$4;
    return_value_VSB_finish$4=VSB_finish(vsb);
    if(!(return_value_VSB_finish$4 == 0))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vslq_newquery", "vsl_query.c", 312, "(VSB_finish(vsb)) == 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  }
  while((_Bool)0);
  char *return_value_VSB_data$5;
  if(vex == ((struct vex *)NULL))
  {
    return_value_VSB_data$5=VSB_data(vsb);
    vsl_diag(vsl, "%s", return_value_VSB_data$5);
  }

  else
  {
    do
    {
      void *return_value_calloc$6;
      return_value_calloc$6=calloc(sizeof(struct vslq_query) /*16ul*/ , (unsigned long int)1);
      query = (struct vslq_query *)return_value_calloc$6;
      if(!(query == ((struct vslq_query *)NULL)))
        query->magic = (unsigned int)0x122322A5;

    }
    while((_Bool)0);

  __CPROVER_DUMP_L9:
    ;
    do
      if(query == ((struct vslq_query *)NULL))
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        VAS_Fail("vslq_newquery", "vsl_query.c", 317, "(query) != 0", *return_value___errno_location$7, (enum vas_e)VAS_MISSING);
      }

    while((_Bool)0);
    query->vex = vex;
  }
  VSB_delete(vsb);
  return query;
}

// vslq_next
// file vsl_dispatch.c line 1218
static signed int vslq_next(struct VSLQ *vslq)
{
  struct VSL_cursor *c;
  signed int i;
  enum VSL_tag_e tag;
  signed long int len;
  unsigned int vxid;
  struct vtx *vtx;
  c = vslq->c;
  i=VSL_Next(c);
  if(!(i == 1))
    return i;

  else
  {
    tag = (enum VSL_tag_e)(c->rec.ptr[(signed long int)0] >> 24);
    if((signed int)tag == SLT__Batch)
    {
      vxid = (c->rec.ptr + (signed long int)2)[(signed long int)1] & ~(3U << 30);
      len = (c->rec.ptr + (signed long int)2 + (signed long int)((c->rec.ptr[(signed long int)1] + (unsigned int)3) / (unsigned int)4)) - c->rec.ptr;
      if(len == 0l)
        return i;

      tag = (enum VSL_tag_e)((c->rec.ptr + (signed long int)2 + (signed long int)(((c->rec.ptr[(signed long int)0] & (unsigned int)0xffff) + (unsigned int)3) / (unsigned int)4))[(signed long int)0] >> 24);
    }

    else
    {
      vxid = c->rec.ptr[(signed long int)1] & ~(3U << 30);
      len = (c->rec.ptr + (signed long int)2 + (signed long int)(((c->rec.ptr[(signed long int)0] & (unsigned int)0xffff) + (unsigned int)3) / (unsigned int)4)) - c->rec.ptr;
    }
    do
      if(!(len >= 1l))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vslq_next", "vsl_dispatch.c", 1244, "len > 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    if(vxid == 0u)
      return i;

    else
    {
      vtx=vtx_lookup(vslq, vxid);
      if(vtx == ((struct vtx *)NULL) && (signed int)tag == SLT_Begin)
      {
        vtx=vtx_add(vslq, vxid);

      __CPROVER_DUMP_L7:
        ;
        do
          if(vtx == ((struct vtx *)NULL))
          {
            signed int *return_value___errno_location$2;
            return_value___errno_location$2=__errno_location();
            VAS_Fail("vslq_next", "vsl_dispatch.c", 1252, "(vtx) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
      }

      if(!(vtx == ((struct vtx *)NULL)))
      {
        vtx_append(vslq, vtx, &c->rec, (unsigned long int)len);
        vtx_scan(vslq, vtx);
      }

      return i;
    }
  }
}

// vslq_process_ready
// file vsl_dispatch.c line 1264
static signed int vslq_process_ready(struct VSLQ *vslq, signed int (*func)(struct VSL_data *, struct VSL_transaction * const *, void *), void *priv)
{
  struct vtx *vtx;
  signed int i = 0;

__CPROVER_DUMP_L1:
  ;
  do
    if(vslq == ((struct VSLQ *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vslq_process_ready", "vsl_dispatch.c", 1269, "(vslq) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  while(!(vslq->ready.vtqh_first == ((struct vtx *)NULL)))
  {
    vtx = (&vslq->ready)->vtqh_first;

  __CPROVER_DUMP_L4:
    ;
    do
    {
      if(vtx == ((struct vtx *)NULL))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vslq_process_ready", "vsl_dispatch.c", 1273, "(vtx) != NULL", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(vtx->magic == 0xACC21D09))
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          VAS_Fail("vslq_process_ready", "vsl_dispatch.c", 1273, "(vtx)->magic == 0xACC21D09", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {
      if(!(vtx->list_vtx.vtqe_next == ((struct vtx *)NULL)))
        vtx->list_vtx.vtqe_next->list_vtx.vtqe_prev = vtx->list_vtx.vtqe_prev;

      else
        (&vslq->ready)->vtqh_last = vtx->list_vtx.vtqe_prev;
      *vtx->list_vtx.vtqe_prev = vtx->list_vtx.vtqe_next;
    }
    while((_Bool)0);

  __CPROVER_DUMP_L11:
    ;
    do
      if((8u & vtx->flags) == 0u)
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        VAS_Fail("vslq_process_ready", "vsl_dispatch.c", 1275, "(vtx->flags & 0x8) != 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    if(!(func == ((signed int (*)(struct VSL_data *, struct VSL_transaction * const *, void *))NULL)))
      i=vslq_callback(vslq, vtx, func, priv);

    vtx_retire(vslq, &vtx);

  __CPROVER_DUMP_L14:
    ;
    do
      if(!(vtx == ((struct vtx *)NULL)))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        VAS_Fail("vslq_process_ready", "vsl_dispatch.c", 1279, "(vtx) == 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    if(!(i == 0))
      return i;

  }
  return 0;
}

// vslq_raw
// file vsl_dispatch.c line 1138
static signed int vslq_raw(struct VSLQ *vslq, signed int (*func)(struct VSL_data *, struct VSL_transaction * const *, void *), void *priv)
{
  signed int i = 1;
  signed int r;
  do
    if(!((signed int)vslq->grouping == VSL_g_raw))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vslq_raw", "vsl_dispatch.c", 1143, "vslq->grouping == VSL_g_raw", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
    if(!((unsigned long int)vslq->raw.len >= vslq->raw.offset))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vslq_raw", "vsl_dispatch.c", 1145, "vslq->raw.offset <= vslq->raw.len", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  while((_Bool)1)
  {
    if(vslq->raw.offset == (unsigned long int)vslq->raw.len)
    {
      i=VSL_Next(vslq->c);
      if(!(i >= 1))
        return i;


    __CPROVER_DUMP_L6:
      ;
      do
        if(vslq->c->rec.ptr == ((const unsigned int *)NULL))
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          VAS_Fail("vslq_raw", "vsl_dispatch.c", 1151, "(vslq->c->rec.ptr) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      vslq->raw.start = vslq->c->rec;
      if(*vslq->c->rec.ptr >> 24 == 255u)
        vslq->raw.len = (vslq->c->rec.ptr + (signed long int)2 + (signed long int)((vslq->c->rec.ptr[(signed long int)1] + (unsigned int)3) / (unsigned int)4)) - vslq->c->rec.ptr;

      else
        vslq->raw.len = (vslq->raw.start.ptr + (signed long int)2 + (signed long int)(((vslq->raw.start.ptr[(signed long int)0] & (unsigned int)0xffff) + (unsigned int)3) / (unsigned int)4)) - vslq->raw.start.ptr;
      do
        if(!(vslq->raw.len >= 1l))
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          VAS_Fail("vslq_raw", "vsl_dispatch.c", 1160, "vslq->raw.len > 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      vslq->raw.offset = (unsigned long int)0;
    }

    vslq->raw.c.ptr = vslq->raw.start.ptr + (signed long int)vslq->raw.offset;
    vslq->raw.c.cursor.rec.ptr = (const unsigned int *)(void *)0;
    vslq->raw.trans.vxid = (signed int)(vslq->raw.c.ptr[(signed long int)1] & ~(3U << 30));
    vslq->raw.offset = vslq->raw.offset + (unsigned long int)((vslq->raw.c.ptr + (signed long int)2 + (signed long int)(((vslq->raw.c.ptr[(signed long int)0] & (unsigned int)0xffff) + (unsigned int)3) / (unsigned int)4)) - vslq->raw.c.ptr);
    if(!(*vslq->raw.c.ptr >> 24 == 255u))
      break;

  }
  signed int return_value_vslq_runquery$5;
  if(func == ((signed int (*)(struct VSL_data *, struct VSL_transaction * const *, void *))NULL))
    return i;

  else
    if(!(vslq->query == ((struct vslq_query *)NULL)))
    {
      return_value_vslq_runquery$5=vslq_runquery(vslq->query, vslq->raw.ptrans);
      if(!(return_value_vslq_runquery$5 == 0))
        goto __CPROVER_DUMP_L13;

      return i;
    }

    else
    {

    __CPROVER_DUMP_L13:
      ;
      r=func(vslq->vsl, vslq->raw.ptrans, priv);
      if(!(r == 0))
        return r;

      else
        return i;
    }
}

// vslq_runquery
// file vsl_api.h line 101
signed int vslq_runquery(struct vslq_query *query, struct VSL_transaction * const *ptrans)
{
  struct VSL_transaction *t;
  signed int r;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(query == ((struct vslq_query *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vslq_runquery", "vsl_query.c", 348, "(query) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(query->magic == 304292517u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vslq_runquery", "vsl_query.c", 348, "(query)->magic == 0x122322A5", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  r=vslq_exec(query->vex, ptrans);
  t = ptrans[(signed long int)0];
  for( ; !(t == ((struct VSL_transaction *)NULL)); t = *ptrans)
  {
    do
    {

    __CPROVER_DUMP_L6:
      ;
      signed int return_value_VSL_ResetCursor$4;
      return_value_VSL_ResetCursor$4=VSL_ResetCursor(t->c);
      if(!(return_value_VSL_ResetCursor$4 == 0))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("vslq_runquery", "vsl_query.c", 352, "(VSL_ResetCursor(t->c)) == 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

    }
    while((_Bool)0);
    ptrans = ptrans + 1l;
  }
  return r;
}

// vslq_shmref_check
// file vsl_dispatch.c line 1192
static signed int vslq_shmref_check(struct VSLQ *vslq)
{
  struct chunk *chunk;
  signed int i;
  do
  {
    chunk = (&vslq->shmrefs)->vtqh_first;
    if(chunk == ((struct chunk *)NULL))
      break;


  __CPROVER_DUMP_L2:
    ;
    do
    {
      if(chunk == ((struct chunk *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vslq_shmref_check", "vsl_dispatch.c", 1198, "(chunk) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(chunk->magic == 1222377876u))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          VAS_Fail("vslq_shmref_check", "vsl_dispatch.c", 1198, "(chunk)->magic == 0x48DC0194", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    do
      if(!((signed int)chunk->type == chunk_t_shm))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("vslq_shmref_check", "vsl_dispatch.c", 1199, "chunk->type == chunk_t_shm", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    i=VSL_Check(vslq->c, &chunk->$anon0.shm.start);
    if(i == 2)
      return 0;

    else
      if(i == 1)
        chunk_shm_to_buf(vslq, chunk);

      else
        return -3;
  }
  while((_Bool)1);
  return 0;
}

// vslq_test
// file vsl_query.c line 215
static signed int vslq_test(struct vex *vex, struct VSL_transaction * const *ptrans)
{
  struct VSL_transaction *t;
  signed int i;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vex == ((struct vex *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vslq_test", "vsl_query.c", 220, "(vex) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vex->magic == 0xC7DB792D))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vslq_test", "vsl_query.c", 220, "(vex)->magic == 0xC7DB792D", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L5:
  ;
  do
  {
    if(vex->lhs == ((struct vex_lhs *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vslq_test", "vsl_query.c", 221, "(vex->lhs) != NULL", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vex->lhs->magic == 450090893u))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        VAS_Fail("vslq_test", "vsl_query.c", 221, "(vex->lhs)->magic == 0x1AD3D78D", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L9:
  ;
  do
    if(vex->lhs->tags == ((struct vbitmap *)NULL))
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      VAS_Fail("vslq_test", "vsl_query.c", 222, "(vex->lhs->tags) != 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  t = ptrans[(signed long int)0];
  for( ; !(t == ((struct VSL_transaction *)NULL)); t = *ptrans)
  {
    if(vex->lhs->level >= 0)
    {
      if(!(vex->lhs->level_pm >= 0))
      {
        if(!((unsigned int)vex->lhs->level >= t->level))
          goto __CPROVER_DUMP_L24;

      }

      else
        if(vex->lhs->level_pm >= 1)
        {
          if(!(t->level >= (unsigned int)vex->lhs->level))
            goto __CPROVER_DUMP_L24;

        }

        else
          if(!(t->level == (unsigned int)vex->lhs->level))
            goto __CPROVER_DUMP_L24;

    }

    do
    {

    __CPROVER_DUMP_L14:
      ;
      signed int return_value_VSL_ResetCursor$7;
      return_value_VSL_ResetCursor$7=VSL_ResetCursor(t->c);
      if(!(return_value_VSL_ResetCursor$7 == 0))
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        VAS_Fail("vslq_test", "vsl_query.c", 241, "(VSL_ResetCursor(t->c)) == 0", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
      }

    }
    while((_Bool)0);
    while((_Bool)1)
    {
      i=VSL_Next(t->c);
      if(!(i >= 0))
        return i;

      if(i == 0)
        break;

      do
        if(!(i == 1))
        {
          signed int *return_value___errno_location$8;
          return_value___errno_location$8=__errno_location();
          VAS_Fail("vslq_test", "vsl_query.c", 248, "i == 1", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);

    __CPROVER_DUMP_L20:
      ;
      do
        if(t->c->rec.ptr == ((const unsigned int *)NULL))
        {
          signed int *return_value___errno_location$9;
          return_value___errno_location$9=__errno_location();
          VAS_Fail("vslq_test", "vsl_query.c", 249, "(t->c->rec.ptr) != 0", *return_value___errno_location$9, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      signed int return_value_vbit_test$10;
      return_value_vbit_test$10=vbit_test(vex->lhs->tags, t->c->rec.ptr[(signed long int)0] >> 24);
      if(!(return_value_vbit_test$10 == 0))
      {
        i=vslq_test_rec(vex, &t->c->rec);
        if(!(i == 0))
          return i;

      }

    }

  __CPROVER_DUMP_L24:
    ;
    ptrans = ptrans + 1l;
  }
  return 0;
}

// vslq_test_rec
// file vsl_query.c line 72
static signed int vslq_test_rec(struct vex *vex, struct VSLC_ptr *rec)
{
  struct vex_rhs *rhs;
  signed long long int lhs_int = (signed long long int)0;
  double lhs_float = 0.;
  const char *b;
  const char *e;
  char *p;
  signed int i;

__CPROVER_DUMP_L1:
  ;
  do
    if(vex == ((struct vex *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vslq_test_rec", "vsl_query.c", 81, "(vex) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(rec == ((struct VSLC_ptr *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vslq_test_rec", "vsl_query.c", 82, "(rec) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  b = (const char *)(rec->ptr + (signed long int)2);
  e = (b + (signed long int)(rec->ptr[(signed long int)0] & (unsigned int)0xffff)) - (signed long int)1;
  const unsigned short int **return_value___ctype_b_loc$4;
  if(!(vex->lhs->prefix == ((char *)NULL)))
  {
    signed int return_value_strncasecmp$3;
    return_value_strncasecmp$3=strncasecmp(b, vex->lhs->prefix, (unsigned long int)vex->lhs->prefixlen);
    if(!(return_value_strncasecmp$3 == 0))
      return 0;

    if(!((signed int)b[(signed long int)vex->lhs->prefixlen] == 58))
      return 0;

    b = b + (signed long int)(vex->lhs->prefixlen + 1);
    for( ; !(*b == 0); b = b + 1l)
    {
      return_value___ctype_b_loc$4=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*b]) == 0)
        break;

    }
  }

  _Bool tmp_if_expr$5;
  const unsigned short int **return_value___ctype_b_loc$6;
  const unsigned short int **return_value___ctype_b_loc$7;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$13;
  const unsigned short int **return_value___ctype_b_loc$12;
  _Bool tmp_if_expr$15;
  const unsigned short int **return_value___ctype_b_loc$14;
  signed int *return_value___errno_location$16;
  signed int *return_value___errno_location$17;
  signed int *return_value___errno_location$18;
  signed int *return_value___errno_location$19;
  signed int *return_value___errno_location$20;
  signed int *return_value___errno_location$21;
  signed int *return_value___errno_location$22;
  _Bool tmp_if_expr$30;
  _Bool tmp_if_expr$32;
  signed int *return_value___errno_location$33;
  if(vex->lhs->field >= 1)
  {
    e = b;
    i = 0;
    do
    {
      if(!(*e == 0))
        tmp_if_expr$5 = i < vex->lhs->field ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(!tmp_if_expr$5)
        break;

      b = e;
      for( ; !(*b == 0); b = b + 1l)
      {
        return_value___ctype_b_loc$6=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)*b]) == 0)
          break;

      }
      e = b;
      for( ; !(*e == 0); e = e + 1l)
      {
        return_value___ctype_b_loc$7=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)*e]) == 0))
          break;

      }
      i = i + 1;
    }
    while((_Bool)1);
    do
      if(!(e >= b))
      {
        signed int *return_value___errno_location$8;
        return_value___errno_location$8=__errno_location();
        VAS_Fail("vslq_test_rec", "vsl_query.c", 111, "b <= e", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    if((signed int)*b == 0)
      tmp_if_expr$9 = (_Bool)1;

    else
      tmp_if_expr$9 = i < vex->lhs->field ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$9)
      goto __CPROVER_DUMP_L21;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L21:
    ;
    if(vex->tok == 139u)
      return 1;

    else
    {
      rhs = vex->rhs;

    __CPROVER_DUMP_L23:
      ;
      do
      {
        if(rhs == ((struct vex_rhs *)NULL))
        {
          signed int *return_value___errno_location$10;
          return_value___errno_location$10=__errno_location();
          VAS_Fail("vslq_test_rec", "vsl_query.c", 122, "(rhs) != NULL", *return_value___errno_location$10, (enum vas_e)VAS_ASSERT);
        }

        do
          if(!(rhs->magic == 1058052453u))
          {
            signed int *return_value___errno_location$11;
            return_value___errno_location$11=__errno_location();
            VAS_Fail("vslq_test_rec", "vsl_query.c", 122, "(rhs)->magic == 0x3F109965", *return_value___errno_location$11, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
      }
      while((_Bool)0);
      if(vex->tok == 60u || vex->tok == 62u || vex->tok == 130u || vex->tok == 131u || vex->tok == 132u || vex->tok == 133u)
      {
        if((signed int)*b == 0)
          return 0;

        switch((signed int)rhs->type)
        {
          case VEX_INT:
          {
            lhs_int=strtoll(b, &p, 0);
            if((signed int)*p == 0)
              tmp_if_expr$13 = (_Bool)1;

            else
            {
              return_value___ctype_b_loc$12=__ctype_b_loc();
              tmp_if_expr$13 = ((signed int)(*return_value___ctype_b_loc$12)[(signed long int)(signed int)*p] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$13)
              break;

            return 0;
          }
          case VEX_FLOAT:
          {
            lhs_float=strtod(b, &p);
            if((signed int)*p == 0)
              tmp_if_expr$15 = (_Bool)1;

            else
            {
              return_value___ctype_b_loc$14=__ctype_b_loc();
              tmp_if_expr$15 = ((signed int)(*return_value___ctype_b_loc$14)[(signed long int)(signed int)*p] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$15)
              break;

            return 0;
          }
          default:
          {
            return_value___errno_location$16=__errno_location();
            VAS_Fail("vslq_test_rec", "vsl_query.c", 150, "Wrong RHS type", *return_value___errno_location$16, (enum vas_e)VAS_WRONG);
          }
        }
      }

      switch(vex->tok)
      {
        case (unsigned int)130:
          switch((signed int)rhs->type)
          {
            case VEX_INT:
            {
              if(lhs_int == rhs->val_int)
                return 1;

              return 0;
            }
            case VEX_FLOAT:
            {
              if(IEEE_FLOAT_EQUAL(lhs_float, rhs->val_float))
                return 1;

              return 0;
            }
            default:
            {
              return_value___errno_location$17=__errno_location();
              VAS_Fail("vslq_test_rec", "vsl_query.c", 160, "Wrong RHS type", *return_value___errno_location$17, (enum vas_e)VAS_WRONG);
            }
          }
        case (unsigned int)133:
          switch((signed int)rhs->type)
          {
            case VEX_INT:
            {
              if(!(lhs_int == rhs->val_int))
                return 1;

              return 0;
            }
            case VEX_FLOAT:
            {
              if(IEEE_FLOAT_NOTEQUAL(lhs_float, rhs->val_float))
                return 1;

              return 0;
            }
            default:
            {
              return_value___errno_location$18=__errno_location();
              VAS_Fail("vslq_test_rec", "vsl_query.c", 162, "Wrong RHS type", *return_value___errno_location$18, (enum vas_e)VAS_WRONG);
            }
          }
        case (unsigned int)60:
          switch((signed int)rhs->type)
          {
            case VEX_INT:
            {
              if(!(lhs_int >= rhs->val_int))
                return 1;

              return 0;
            }
            case VEX_FLOAT:
            {
              if(lhs_float < rhs->val_float)
                return 1;

              return 0;
            }
            default:
            {
              return_value___errno_location$19=__errno_location();
              VAS_Fail("vslq_test_rec", "vsl_query.c", 164, "Wrong RHS type", *return_value___errno_location$19, (enum vas_e)VAS_WRONG);
            }
          }
        case (unsigned int)62:
          switch((signed int)rhs->type)
          {
            case VEX_INT:
            {
              if(!(rhs->val_int >= lhs_int))
                return 1;

              return 0;
            }
            case VEX_FLOAT:
            {
              if(lhs_float > rhs->val_float)
                return 1;

              return 0;
            }
            default:
            {
              return_value___errno_location$20=__errno_location();
              VAS_Fail("vslq_test_rec", "vsl_query.c", 166, "Wrong RHS type", *return_value___errno_location$20, (enum vas_e)VAS_WRONG);
            }
          }
        case (unsigned int)132:
          switch((signed int)rhs->type)
          {
            case VEX_INT:
            {
              if(rhs->val_int >= lhs_int)
                return 1;

              return 0;
            }
            case VEX_FLOAT:
            {
              if(lhs_float <= rhs->val_float)
                return 1;

              return 0;
            }
            default:
            {
              return_value___errno_location$21=__errno_location();
              VAS_Fail("vslq_test_rec", "vsl_query.c", 168, "Wrong RHS type", *return_value___errno_location$21, (enum vas_e)VAS_WRONG);
            }
          }
        case (unsigned int)131:
          switch((signed int)rhs->type)
          {
            case VEX_INT:
            {
              if(lhs_int >= rhs->val_int)
                return 1;

              return 0;
            }
            case VEX_FLOAT:
            {
              if(lhs_float >= rhs->val_float)
                return 1;

              return 0;
            }
            default:
            {
              return_value___errno_location$22=__errno_location();
              VAS_Fail("vslq_test_rec", "vsl_query.c", 170, "Wrong RHS type", *return_value___errno_location$22, (enum vas_e)VAS_WRONG);
            }
          }
        case (unsigned int)137:
        {
          do
            if(!((signed int)rhs->type == VEX_STRING))
            {
              signed int *return_value___errno_location$23;
              return_value___errno_location$23=__errno_location();
              VAS_Fail("vslq_test_rec", "vsl_query.c", 172, "rhs->type == VEX_STRING", *return_value___errno_location$23, (enum vas_e)VAS_ASSERT);
            }

          while((_Bool)0);
          if(!((unsigned long int)(e - b) == rhs->val_stringlen))
            return 0;

          if(!((1u & vex->options) == 0u))
          {
            signed int return_value_strncasecmp$24;
            return_value_strncasecmp$24=strncasecmp(b, rhs->val_string, (unsigned long int)(e - b));
            if(!(return_value_strncasecmp$24 == 0))
              return 0;

          }

          else
          {
            signed int return_value_strncmp$25;
            return_value_strncmp$25=strncmp(b, rhs->val_string, (unsigned long int)(e - b));
            if(!(return_value_strncmp$25 == 0))
              return 0;

          }
          return 1;
        }
        case (unsigned int)138:
        {
          do
            if(!((signed int)rhs->type == VEX_STRING))
            {
              signed int *return_value___errno_location$26;
              return_value___errno_location$26=__errno_location();
              VAS_Fail("vslq_test_rec", "vsl_query.c", 184, "rhs->type == VEX_STRING", *return_value___errno_location$26, (enum vas_e)VAS_ASSERT);
            }

          while((_Bool)0);
          if(!((unsigned long int)(e - b) == rhs->val_stringlen))
            return 1;

          if(!((1u & vex->options) == 0u))
          {
            signed int return_value_strncasecmp$27;
            return_value_strncasecmp$27=strncasecmp(b, rhs->val_string, (unsigned long int)(e - b));
            if(!(return_value_strncasecmp$27 == 0))
              return 1;

          }

          else
          {
            signed int return_value_strncmp$28;
            return_value_strncmp$28=strncmp(b, rhs->val_string, (unsigned long int)(e - b));
            if(!(return_value_strncmp$28 == 0))
              return 1;

          }
          return 0;
        }
        case (unsigned int)126:
        {
          do
          {
            if((signed int)rhs->type == VEX_REGEX)
              tmp_if_expr$30 = rhs->val_regex != (struct vre *)(void *)0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$30 = (_Bool)0;
            if(!tmp_if_expr$30)
            {
              signed int *return_value___errno_location$29;
              return_value___errno_location$29=__errno_location();
              VAS_Fail("vslq_test_rec", "vsl_query.c", 196, "rhs->type == VEX_REGEX && rhs->val_regex != NULL", *return_value___errno_location$29, (enum vas_e)VAS_ASSERT);
            }

          }
          while((_Bool)0);
          i=VRE_exec(rhs->val_regex, b, (signed int)(e - b), 0, 0, (signed int *)(void *)0, 0, (struct vre_limits *)(void *)0);
          if(!(i == -1))
            return 1;

          return 0;
        }
        case (unsigned int)134:
        {
          do
          {
            if((signed int)rhs->type == VEX_REGEX)
              tmp_if_expr$32 = rhs->val_regex != (struct vre *)(void *)0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$32 = (_Bool)0;
            if(!tmp_if_expr$32)
            {
              signed int *return_value___errno_location$31;
              return_value___errno_location$31=__errno_location();
              VAS_Fail("vslq_test_rec", "vsl_query.c", 202, "rhs->type == VEX_REGEX && rhs->val_regex != NULL", *return_value___errno_location$31, (enum vas_e)VAS_ASSERT);
            }

          }
          while((_Bool)0);
          i=VRE_exec(rhs->val_regex, b, (signed int)(e - b), 0, 0, (signed int *)(void *)0, 0, (struct vre_limits *)(void *)0);
          if(i == -1)
            return 1;

          return 0;
        }
        default:
        {
          return_value___errno_location$33=__errno_location();
          VAS_Fail("vslq_test_rec", "vsl_query.c", 208, "Bad expression token", *return_value___errno_location$33, (enum vas_e)VAS_WRONG);
        }
      }
      return 0;
    }
  }
}

// vsm_diag
// file vsm.c line 82
signed int vsm_diag(struct VSM_data *vd, const char *fmt, ...)
{
  void **ap;

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(vd == ((struct VSM_data *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vsm_diag", "vsm.c", 86, "(vd) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vd->magic == 1849415323u))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vsm_diag", "vsm.c", 86, "(vd)->magic == 0x6e3bd69b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L5:
  ;
  do
    if(fmt == ((const char *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vsm_diag", "vsm.c", 87, "(fmt) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(vd->diag == ((struct vsb *)NULL))
    vd->diag=VSB_new((struct vsb *)(void *)0, (char *)(void *)0, 0, 0x00000001);


__CPROVER_DUMP_L7:
  ;
  do
    if(vd->diag == ((struct vsb *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("vsm_diag", "vsm.c", 91, "(vd->diag) != 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  VSB_clear(vd->diag);
  ap = (void **)&fmt;
  VSB_vprintf(vd->diag, fmt, ap);
  ap = ((void **)NULL);
  do
  {

  __CPROVER_DUMP_L9:
    ;
    signed int return_value_VSB_finish$6;
    return_value_VSB_finish$6=VSB_finish(vd->diag);
    if(!(return_value_VSB_finish$6 == 0))
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      VAS_Fail("vsm_diag", "vsm.c", 96, "(VSB_finish(vd->diag)) == 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
    }

  }
  while((_Bool)0);
  return -1;
}

// vtx_add
// file vsl_dispatch.c line 605
static struct vtx * vtx_add(struct VSLQ *vslq, unsigned int vxid)
{
  struct vtx *vtx;

__CPROVER_DUMP_L1:
  ;
  do
    if(vslq == ((struct VSLQ *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vtx_add", "vsl_dispatch.c", 609, "(vslq) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vtx=vtx_new(vslq);

__CPROVER_DUMP_L3:
  ;
  do
    if(vtx == ((struct vtx *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vtx_add", "vsl_dispatch.c", 611, "(vtx) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vtx->key.vxid = vxid;
  do
  {

  __CPROVER_DUMP_L5:
    ;
    struct vtx_key *return_value_vtx_tree_VRB_INSERT$4;
    return_value_vtx_tree_VRB_INSERT$4=vtx_tree_VRB_INSERT(&vslq->tree, &vtx->key);
    if(!(return_value_vtx_tree_VRB_INSERT$4 == ((struct vtx_key *)NULL)))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vtx_add", "vsl_dispatch.c", 613, "(vtx_tree_VRB_INSERT(&vslq->tree, &vtx->key)) == 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  }
  while((_Bool)0);
  do
  {
    vtx->list_vtx.vtqe_next = (struct vtx *)(void *)0;
    vtx->list_vtx.vtqe_prev = (&vslq->incomplete)->vtqh_last;
    *(&vslq->incomplete)->vtqh_last = vtx;
    (&vslq->incomplete)->vtqh_last = &vtx->list_vtx.vtqe_next;
  }
  while((_Bool)0);
  vslq->n_outstanding = vslq->n_outstanding + 1u;
  return vtx;
}

// vtx_append
// file vsl_dispatch.c line 423
static void vtx_append(struct VSLQ *vslq, struct vtx *vtx, struct VSLC_ptr *start, unsigned long int len)
{
  struct chunk *chunk;

__CPROVER_DUMP_L1:
  ;
  do
    if(vtx == ((struct vtx *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vtx_append", "vsl_dispatch.c", 428, "(vtx) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$9;
  if(!(len == 0ul))
  {

  __CPROVER_DUMP_L3:
    ;
    do
      if(start == ((struct VSLC_ptr *)NULL))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vtx_append", "vsl_dispatch.c", 431, "(start) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    signed int return_value_VSL_Check$10;
    return_value_VSL_Check$10=VSL_Check(vslq->c, start);
    if(return_value_VSL_Check$10 == 2)
      tmp_if_expr$11 = !((&vtx->shmchunks_free)->vtqh_first == (struct chunk *)(void *)0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$11 = (_Bool)0;
    if(tmp_if_expr$11)
    {
      chunk = (&vtx->shmchunks_free)->vtqh_first;

    __CPROVER_DUMP_L7:
      ;
      do
      {
        if(chunk == ((struct chunk *)NULL))
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          VAS_Fail("vtx_append", "vsl_dispatch.c", 437, "(chunk) != NULL", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
        }

        do
          if(!(chunk->magic == 1222377876u))
          {
            signed int *return_value___errno_location$4;
            return_value___errno_location$4=__errno_location();
            VAS_Fail("vtx_append", "vsl_dispatch.c", 437, "(chunk)->magic == 0x48DC0194", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
      }
      while((_Bool)0);
      do
        if(!((signed int)chunk->type == chunk_t_shm))
        {
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          VAS_Fail("vtx_append", "vsl_dispatch.c", 438, "chunk->type == chunk_t_shm", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      do
        if(!(chunk->vtx == vtx))
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          VAS_Fail("vtx_append", "vsl_dispatch.c", 439, "chunk->vtx == vtx", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      do
      {
        if(!(chunk->list.vtqe_next == ((struct chunk *)NULL)))
          chunk->list.vtqe_next->list.vtqe_prev = chunk->list.vtqe_prev;

        else
          (&vtx->shmchunks_free)->vtqh_last = chunk->list.vtqe_prev;
        *chunk->list.vtqe_prev = chunk->list.vtqe_next;
      }
      while((_Bool)0);
      chunk->$anon0.shm.start = *start;
      chunk->len = len;
      do
      {
        chunk->list.vtqe_next = (struct chunk *)(void *)0;
        chunk->list.vtqe_prev = (&vtx->chunks)->vtqh_last;
        *(&vtx->chunks)->vtqh_last = chunk;
        (&vtx->chunks)->vtqh_last = &chunk->list.vtqe_next;
      }
      while((_Bool)0);
      do
      {
        chunk->$anon0.shm.shmref.vtqe_next = (struct chunk *)(void *)0;
        chunk->$anon0.shm.shmref.vtqe_prev = (&vslq->shmrefs)->vtqh_last;
        *(&vslq->shmrefs)->vtqh_last = chunk;
        (&vslq->shmrefs)->vtqh_last = &chunk->$anon0.shm.shmref.vtqe_next;
      }
      while((_Bool)0);
    }

    else
    {
      chunk = *((struct chunkhead *)(&vtx->chunks)->vtqh_last)->vtqh_last;
      do
        if(!(chunk == ((struct chunk *)NULL)))
          do
            if(!(chunk->magic == 1222377876u))
            {
              signed int *return_value___errno_location$7;
              return_value___errno_location$7=__errno_location();
              VAS_Fail("vtx_append", "vsl_dispatch.c", 450, "(chunk)->magic == 0x48DC0194", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
            }

          while((_Bool)0);

      while((_Bool)0);
      if(!(chunk == ((struct chunk *)NULL)))
        tmp_if_expr$9 = (signed int)chunk->type == chunk_t_buf ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$9 = (_Bool)0;
      if(tmp_if_expr$9)
        chunk_appendbuf(chunk, start->ptr, len);

      else
      {
        chunk=chunk_newbuf(vtx, start->ptr, len);

      __CPROVER_DUMP_L28:
        ;
        do
          if(chunk == ((struct chunk *)NULL))
          {
            signed int *return_value___errno_location$8;
            return_value___errno_location$8=__errno_location();
            VAS_Fail("vtx_append", "vsl_dispatch.c", 457, "(chunk) != 0", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
        do
        {
          chunk->list.vtqe_next = (struct chunk *)(void *)0;
          chunk->list.vtqe_prev = (&vtx->chunks)->vtqh_last;
          *(&vtx->chunks)->vtqh_last = chunk;
          (&vtx->chunks)->vtqh_last = &chunk->list.vtqe_next;
        }
        while((_Bool)0);
      }
    }
    vtx->len = vtx->len + len;
  }

}

// vtx_diag
// file vsl_dispatch.c line 1027
static signed int vtx_diag(struct vtx *vtx, const char *msg)
{
  vtx_synth_rec(vtx, (unsigned int)SLT_VSL, msg);
  return -1;
}

// vtx_diag_tag
// file vsl_dispatch.c line 1037
static signed int vtx_diag_tag(struct vtx *vtx, const unsigned int *ptr, const char *reason)
{
  vtx_synth_rec(vtx, (unsigned int)SLT_VSL, "%s (%u:%s \"%.*s\")", reason, ptr[(signed long int)1] & ~(3U << 30), VSL_tags[(signed long int)(ptr[(signed long int)0] >> 24)], (signed int)(ptr[(signed long int)0] & (unsigned int)0xffff), (const char *)(ptr + (signed long int)2));
  return -1;
}

// vtx_force
// file vsl_dispatch.c line 887
static void vtx_force(struct VSLQ *vslq, struct vtx *vtx, const char *reason)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(!((4u & vtx->flags) == 0u))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vtx_force", "vsl_dispatch.c", 890, "(vtx->flags & 0x4) == 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(!((8u & vtx->flags) == 0u))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vtx_force", "vsl_dispatch.c", 891, "(vtx->flags & 0x8) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vtx_scan(vslq, vtx);
  if((1u & vtx->flags) == 0u)
    vtx_synth_rec(vtx, (unsigned int)SLT_Begin, "%s %u synth", vsl_t_names[(signed long int)vtx->type], 0);

  vtx_diag(vtx, reason);
  if((2u & vtx->flags) == 0u)
    vtx_synth_rec(vtx, (unsigned int)SLT_End, "synth");

  vtx_scan(vslq, vtx);

__CPROVER_DUMP_L7:
  ;
  do
    if((4u & vtx->flags) == 0u)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vtx_force", "vsl_dispatch.c", 900, "(vtx->flags & 0x4) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
}

// vtx_keycmp
// file vsl_dispatch.c line 211
static inline signed int vtx_keycmp(struct vtx_key *a, struct vtx_key *b)
{
  if(!(a->vxid >= b->vxid))
    return -1;

  else
    if(!(b->vxid >= a->vxid))
      return 1;

    else
      return 0;
}

// vtx_lookup
// file vsl_dispatch.c line 589
static struct vtx * vtx_lookup(struct VSLQ *vslq, unsigned int vxid)
{
  struct vtx_key lkey;
  struct vtx_key *key;
  struct vtx *vtx;

__CPROVER_DUMP_L1:
  ;
  do
    if(vslq == ((struct VSLQ *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vtx_lookup", "vsl_dispatch.c", 594, "(vslq) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  lkey.vxid = vxid;
  key=vtx_tree_VRB_FIND(&vslq->tree, &lkey);
  if(key == ((struct vtx_key *)NULL))
    return (struct vtx *)(void *)0;

  else
  {
    do
    {
      vtx = (struct vtx *)(void *)key;
      do
        if(vtx == ((struct vtx *)NULL))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          VAS_Fail("vtx_lookup", "vsl_dispatch.c", 599, "(vtx) != NULL", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);

    __CPROVER_DUMP_L6:
      ;
      do
        if(!(vtx->magic == 0xACC21D09))
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          VAS_Fail("vtx_lookup", "vsl_dispatch.c", 599, "((vtx))->magic == (0xACC21D09)", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    return vtx;
  }
}

// vtx_mark_complete
// file vsl_dispatch.c line 622
static void vtx_mark_complete(struct VSLQ *vslq, struct vtx *vtx)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(vslq == ((struct VSLQ *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vtx_mark_complete", "vsl_dispatch.c", 625, "(vslq) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if((2u & vtx->flags) == 0u)
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vtx_mark_complete", "vsl_dispatch.c", 626, "(vtx->flags & 0x2) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L5:
  ;
  do
    if(!((4u & vtx->flags) == 0u))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vtx_mark_complete", "vsl_dispatch.c", 627, "(vtx->flags & 0x4) == 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if((signed int)vtx->type == VSL_t_unknown)
    vtx_diag(vtx, "vtx of unknown type marked complete");

  vtx->flags = vtx->flags | (unsigned int)0x4;
  do
  {
    if(!(vtx->list_vtx.vtqe_next == ((struct vtx *)NULL)))
      vtx->list_vtx.vtqe_next->list_vtx.vtqe_prev = vtx->list_vtx.vtqe_prev;

    else
      (&vslq->incomplete)->vtqh_last = vtx->list_vtx.vtqe_prev;
    *vtx->list_vtx.vtqe_prev = vtx->list_vtx.vtqe_next;
  }
  while((_Bool)0);
  _Bool tmp_if_expr$5;
  while((_Bool)1)
  {

  __CPROVER_DUMP_L12:
    ;
    do
      if(!((8u & vtx->flags) == 0u))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        VAS_Fail("vtx_mark_complete", "vsl_dispatch.c", 636, "(vtx->flags & 0x8) == 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    if(!((4u & vtx->flags) == 0u))
      tmp_if_expr$5 = vtx->n_child == vtx->n_childready ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
      vtx->flags = vtx->flags | (unsigned int)0x8;

    else
      break;
    if(vtx->parent == ((struct vtx *)NULL))
    {
      do
      {
        vtx->list_vtx.vtqe_next = (struct vtx *)(void *)0;
        vtx->list_vtx.vtqe_prev = (&vslq->ready)->vtqh_last;
        *(&vslq->ready)->vtqh_last = vtx;
        (&vslq->ready)->vtqh_last = &vtx->list_vtx.vtqe_next;
      }
      while((_Bool)0);
      break;
    }

    vtx = vtx->parent;
    vtx->n_childready = vtx->n_childready + 1u;
    do
      if(!(vtx->n_child >= vtx->n_childready))
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        VAS_Fail("vtx_mark_complete", "vsl_dispatch.c", 649, "vtx->n_child >= vtx->n_childready", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
}

// vtx_new
// file vsl_dispatch.c line 466
static struct vtx * vtx_new(struct VSLQ *vslq)
{
  struct vtx *vtx;
  signed int i;

__CPROVER_DUMP_L1:
  ;
  do
    if(vslq == ((struct VSLQ *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vtx_new", "vsl_dispatch.c", 471, "(vslq) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(!(vslq->n_cache == 0u))
  {

  __CPROVER_DUMP_L3:
    ;
    do
      if(vslq->cache.vtqh_first == ((struct vtx *)NULL))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vtx_new", "vsl_dispatch.c", 473, "(((&vslq->cache)->vtqh_first == ((void *)0))) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    vtx = (&vslq->cache)->vtqh_first;
    do
    {
      if(!(vtx->list_child.vtqe_next == ((struct vtx *)NULL)))
        vtx->list_child.vtqe_next->list_child.vtqe_prev = vtx->list_child.vtqe_prev;

      else
        (&vslq->cache)->vtqh_last = vtx->list_child.vtqe_prev;
      *vtx->list_child.vtqe_prev = vtx->list_child.vtqe_next;
    }
    while((_Bool)0);
    vslq->n_cache = vslq->n_cache - 1u;
  }

  else
  {
    do
    {
      void *return_value_calloc$3;
      return_value_calloc$3=calloc(sizeof(struct vtx) /*496ul*/ , (unsigned long int)1);
      vtx = (struct vtx *)return_value_calloc$3;
      if(!(vtx == ((struct vtx *)NULL)))
        vtx->magic = 0xACC21D09;

    }
    while((_Bool)0);

  __CPROVER_DUMP_L10:
    ;
    do
      if(vtx == ((struct vtx *)NULL))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        VAS_Fail("vtx_new", "vsl_dispatch.c", 479, "(vtx) != 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    do
    {
      (&vtx->child)->vtqh_first = (struct vtx *)(void *)0;
      (&vtx->child)->vtqh_last = &(&vtx->child)->vtqh_first;
    }
    while((_Bool)0);
    do
    {
      (&vtx->shmchunks_free)->vtqh_first = (struct chunk *)(void *)0;
      (&vtx->shmchunks_free)->vtqh_last = &(&vtx->shmchunks_free)->vtqh_first;
    }
    while((_Bool)0);
    i = 0;
    for( ; !(i >= 3); i = i + 1)
    {
      vtx->shmchunks[(signed long int)i].magic = (unsigned int)0x48DC0194;
      vtx->shmchunks[(signed long int)i].type = (enum chunk_t)chunk_t_shm;
      vtx->shmchunks[(signed long int)i].vtx = vtx;
      do
      {
        (&vtx->shmchunks[(signed long int)i])->list.vtqe_next = (struct chunk *)(void *)0;
        (&vtx->shmchunks[(signed long int)i])->list.vtqe_prev = (&vtx->shmchunks_free)->vtqh_last;
        *(&vtx->shmchunks_free)->vtqh_last = &vtx->shmchunks[(signed long int)i];
        (&vtx->shmchunks_free)->vtqh_last = &(&vtx->shmchunks[(signed long int)i])->list.vtqe_next;
      }
      while((_Bool)0);
    }
    do
    {
      (&vtx->chunks)->vtqh_first = (struct chunk *)(void *)0;
      (&vtx->chunks)->vtqh_last = &(&vtx->chunks)->vtqh_first;
    }
    while((_Bool)0);
    do
    {
      (&vtx->synth)->vtqh_first = (struct synth *)(void *)0;
      (&vtx->synth)->vtqh_last = &(&vtx->synth)->vtqh_first;
    }
    while((_Bool)0);
    vtx->c.magic = (unsigned int)0x74C6523F;
    vtx->c.vtx = vtx;
    vtx->c.cursor.priv_tbl = (const void *)&vslc_vtx_tbl;
    vtx->c.cursor.priv_data = (void *)&vtx->c;
  }

__CPROVER_DUMP_L18:
  ;
  do
  {
    if(vtx == ((struct vtx *)NULL))
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      VAS_Fail("vtx_new", "vsl_dispatch.c", 498, "(vtx) != NULL", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vtx->magic == 0xACC21D09))
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        VAS_Fail("vtx_new", "vsl_dispatch.c", 498, "(vtx)->magic == 0xACC21D09", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  vtx->key.vxid = (unsigned int)0;
  vtx->t_start=VTIM_mono();
  vtx->flags = (unsigned int)0;
  vtx->type = (enum VSL_transaction_e)VSL_t_unknown;
  vtx->reason = (enum VSL_reason_e)VSL_r_unknown;
  vtx->parent = (struct vtx *)(void *)0;
  vtx->n_child = (unsigned int)0;
  vtx->n_childready = (unsigned int)0;
  vtx->n_descend = (unsigned int)0;
  vtx->len = (unsigned long int)0;
  vslc_vtx_reset(&vtx->c.cursor);
  return vtx;
}

// vtx_parse_link
// file vsl_dispatch.c line 675
static signed int vtx_parse_link(const char *str, enum VSL_transaction_e *ptype, unsigned int *pvxid, enum VSL_reason_e *preason)
{
  char type[16l];
  char reason[16l];
  unsigned int vxid;
  signed int i;
  signed int j;

__CPROVER_DUMP_L1:
  ;
  do
    if(str == ((const char *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vtx_parse_link", "vsl_dispatch.c", 682, "(str) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(ptype == ((enum VSL_transaction_e *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vtx_parse_link", "vsl_dispatch.c", 683, "(ptype) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L5:
  ;
  do
    if(pvxid == ((unsigned int *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vtx_parse_link", "vsl_dispatch.c", 684, "(pvxid) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L7:
  ;
  do
    if(preason == ((enum VSL_reason_e *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("vtx_parse_link", "vsl_dispatch.c", 685, "(preason) != 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  i=sscanf(str, "%15s %u %15s", (const void *)type, &vxid, (const void *)reason);
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$6;
  if(!(i >= 1))
    return 0;

  else
  {
    j = 0;
    for( ; !(j >= VSL_t__MAX); j = j + 1)
    {
      return_value_strcmp$5=strcmp(type, vsl_t_names[(signed long int)j]);
      if(return_value_strcmp$5 == 0)
        break;

    }
    if(!(j >= VSL_t__MAX))
      *ptype = (enum VSL_transaction_e)j;

    else
      *ptype = (enum VSL_transaction_e)VSL_t_unknown;
    if(i == 1)
      return 1;

    else
    {
      *pvxid = vxid;
      if(i == 2)
        return 2;

      else
      {
        j = 0;
        for( ; !(j >= VSL_r__MAX); j = j + 1)
        {
          return_value_strcmp$6=strcmp(reason, vsl_r_names[(signed long int)j]);
          if(return_value_strcmp$6 == 0)
            break;

        }
        if(!(j >= VSL_r__MAX))
          *preason = (enum VSL_reason_e)j;

        else
          *preason = (enum VSL_reason_e)VSL_r_unknown;
        return 3;
      }
    }
  }
}

// vtx_retire
// file vsl_dispatch.c line 517
static void vtx_retire(struct VSLQ *vslq, struct vtx **pvtx)
{
  struct vtx *vtx;
  struct vtx *child;
  struct synth *synth;
  struct chunk *chunk;

__CPROVER_DUMP_L1:
  ;
  do
    if(vslq == ((struct VSLQ *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vtx_retire", "vsl_dispatch.c", 524, "(vslq) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(pvtx == ((struct vtx **)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vtx_retire", "vsl_dispatch.c", 525, "(pvtx) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vtx = *pvtx;
  *pvtx = (struct vtx *)(void *)0;

__CPROVER_DUMP_L5:
  ;
  do
  {
    if(vtx == ((struct vtx *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vtx_retire", "vsl_dispatch.c", 529, "(vtx) != NULL", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vtx->magic == 0xACC21D09))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        VAS_Fail("vtx_retire", "vsl_dispatch.c", 529, "(vtx)->magic == 0xACC21D09", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L9:
  ;
  do
    if((4u & vtx->flags) == 0u)
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      VAS_Fail("vtx_retire", "vsl_dispatch.c", 531, "(vtx->flags & 0x4) != 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L11:
  ;
  do
    if((8u & vtx->flags) == 0u)
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      VAS_Fail("vtx_retire", "vsl_dispatch.c", 532, "(vtx->flags & 0x8) != 0", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L13:
  ;
  do
    if(!(vtx->parent == ((struct vtx *)NULL)))
    {
      signed int *return_value___errno_location$7;
      return_value___errno_location$7=__errno_location();
      VAS_Fail("vtx_retire", "vsl_dispatch.c", 533, "(vtx->parent) == 0", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  while(!(vtx->child.vtqh_first == ((struct vtx *)NULL)))
  {
    child = (&vtx->child)->vtqh_first;
    do
      if(!(child->parent == vtx))
      {
        signed int *return_value___errno_location$8;
        return_value___errno_location$8=__errno_location();
        VAS_Fail("vtx_retire", "vsl_dispatch.c", 537, "child->parent == vtx", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);

  __CPROVER_DUMP_L18:
    ;
    do
      if(vtx->n_child == 0u)
      {
        signed int *return_value___errno_location$9;
        return_value___errno_location$9=__errno_location();
        VAS_Fail("vtx_retire", "vsl_dispatch.c", 538, "(vtx->n_child) != 0", *return_value___errno_location$9, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    do
      if(!(vtx->n_descend >= 1u + child->n_descend))
      {
        signed int *return_value___errno_location$10;
        return_value___errno_location$10=__errno_location();
        VAS_Fail("vtx_retire", "vsl_dispatch.c", 539, "vtx->n_descend >= child->n_descend + 1", *return_value___errno_location$10, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    do
    {
      if(!(child->list_child.vtqe_next == ((struct vtx *)NULL)))
        child->list_child.vtqe_next->list_child.vtqe_prev = child->list_child.vtqe_prev;

      else
        (&vtx->child)->vtqh_last = child->list_child.vtqe_prev;
      *child->list_child.vtqe_prev = child->list_child.vtqe_next;
    }
    while((_Bool)0);
    child->parent = (struct vtx *)(void *)0;
    vtx->n_child = vtx->n_child - 1u;
    vtx->n_descend = vtx->n_descend - (child->n_descend + (unsigned int)1);
    vtx_retire(vslq, &child);

  __CPROVER_DUMP_L25:
    ;
    do
      if(!(child == ((struct vtx *)NULL)))
      {
        signed int *return_value___errno_location$11;
        return_value___errno_location$11=__errno_location();
        VAS_Fail("vtx_retire", "vsl_dispatch.c", 545, "(child) == 0", *return_value___errno_location$11, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }

__CPROVER_DUMP_L27:
  ;
  do
    if(!(vtx->n_child == 0u))
    {
      signed int *return_value___errno_location$12;
      return_value___errno_location$12=__errno_location();
      VAS_Fail("vtx_retire", "vsl_dispatch.c", 547, "(vtx->n_child) == 0", *return_value___errno_location$12, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L29:
  ;
  do
    if(!(vtx->n_descend == 0u))
    {
      signed int *return_value___errno_location$13;
      return_value___errno_location$13=__errno_location();
      VAS_Fail("vtx_retire", "vsl_dispatch.c", 548, "(vtx->n_descend) == 0", *return_value___errno_location$13, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vtx->n_childready = (unsigned int)0;
  do
  {

  __CPROVER_DUMP_L31:
    ;
    struct vtx_key *return_value_vtx_tree_VRB_REMOVE$15;
    return_value_vtx_tree_VRB_REMOVE$15=vtx_tree_VRB_REMOVE(&vslq->tree, &vtx->key);
    if(return_value_vtx_tree_VRB_REMOVE$15 == ((struct vtx_key *)NULL))
    {
      signed int *return_value___errno_location$14;
      return_value___errno_location$14=__errno_location();
      VAS_Fail("vtx_retire", "vsl_dispatch.c", 550, "(vtx_tree_VRB_REMOVE(&vslq->tree, &vtx->key)) != 0", *return_value___errno_location$14, (enum vas_e)VAS_ASSERT);
    }

  }
  while((_Bool)0);
  vtx->key.vxid = (unsigned int)0;
  vtx->flags = (unsigned int)0;
  while(!(vtx->synth.vtqh_first == ((struct synth *)NULL)))
  {
    synth = (&vtx->synth)->vtqh_first;

  __CPROVER_DUMP_L34:
    ;
    do
    {
      if(synth == ((struct synth *)NULL))
      {
        signed int *return_value___errno_location$16;
        return_value___errno_location$16=__errno_location();
        VAS_Fail("vtx_retire", "vsl_dispatch.c", 556, "(synth) != NULL", *return_value___errno_location$16, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(synth->magic == 0xC654479F))
        {
          signed int *return_value___errno_location$17;
          return_value___errno_location$17=__errno_location();
          VAS_Fail("vtx_retire", "vsl_dispatch.c", 556, "(synth)->magic == 0xC654479F", *return_value___errno_location$17, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {
      if(!(synth->list.vtqe_next == ((struct synth *)NULL)))
        synth->list.vtqe_next->list.vtqe_prev = synth->list.vtqe_prev;

      else
        (&vtx->synth)->vtqh_last = synth->list.vtqe_prev;
      *synth->list.vtqe_prev = synth->list.vtqe_next;
    }
    while((_Bool)0);
    do
    {
      synth->magic = (unsigned int)0;
      free((void *)synth);
    }
    while((_Bool)0);
  }
  while(!(vtx->chunks.vtqh_first == ((struct chunk *)NULL)))
  {
    chunk = (&vtx->chunks)->vtqh_first;

  __CPROVER_DUMP_L43:
    ;
    do
    {
      if(chunk == ((struct chunk *)NULL))
      {
        signed int *return_value___errno_location$18;
        return_value___errno_location$18=__errno_location();
        VAS_Fail("vtx_retire", "vsl_dispatch.c", 563, "(chunk) != NULL", *return_value___errno_location$18, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(chunk->magic == 1222377876u))
        {
          signed int *return_value___errno_location$19;
          return_value___errno_location$19=__errno_location();
          VAS_Fail("vtx_retire", "vsl_dispatch.c", 563, "(chunk)->magic == 0x48DC0194", *return_value___errno_location$19, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {
      if(!(chunk->list.vtqe_next == ((struct chunk *)NULL)))
        chunk->list.vtqe_next->list.vtqe_prev = chunk->list.vtqe_prev;

      else
        (&vtx->chunks)->vtqh_last = chunk->list.vtqe_prev;
      *chunk->list.vtqe_prev = chunk->list.vtqe_next;
    }
    while((_Bool)0);
    if((signed int)chunk->type == chunk_t_shm)
    {
      do
      {
        if(!(chunk->$anon0.shm.shmref.vtqe_next == ((struct chunk *)NULL)))
          chunk->$anon0.shm.shmref.vtqe_next->$anon0.shm.shmref.vtqe_prev = chunk->$anon0.shm.shmref.vtqe_prev;

        else
          (&vslq->shmrefs)->vtqh_last = chunk->$anon0.shm.shmref.vtqe_prev;
        *chunk->$anon0.shm.shmref.vtqe_prev = chunk->$anon0.shm.shmref.vtqe_next;
      }
      while((_Bool)0);
      do
      {
        chunk->list.vtqe_next = (&vtx->shmchunks_free)->vtqh_first;
        if(!(chunk->list.vtqe_next == ((struct chunk *)NULL)))
          (&vtx->shmchunks_free)->vtqh_first->list.vtqe_prev = &chunk->list.vtqe_next;

        else
          (&vtx->shmchunks_free)->vtqh_last = &chunk->list.vtqe_next;
        (&vtx->shmchunks_free)->vtqh_first = chunk;
        chunk->list.vtqe_prev = &(&vtx->shmchunks_free)->vtqh_first;
      }
      while((_Bool)0);
    }

    else
    {
      do
        if(!((signed int)chunk->type == chunk_t_buf))
        {
          signed int *return_value___errno_location$20;
          return_value___errno_location$20=__errno_location();
          VAS_Fail("vtx_retire", "vsl_dispatch.c", 569, "chunk->type == chunk_t_buf", *return_value___errno_location$20, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      chunk_freebuf(&chunk);

    __CPROVER_DUMP_L58:
      ;
      do
        if(!(chunk == ((struct chunk *)NULL)))
        {
          signed int *return_value___errno_location$21;
          return_value___errno_location$21=__errno_location();
          VAS_Fail("vtx_retire", "vsl_dispatch.c", 571, "(chunk) == 0", *return_value___errno_location$21, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
  }
  vtx->len = (unsigned long int)0;

__CPROVER_DUMP_L62:
  ;
  do
    if(vslq->n_outstanding == 0u)
    {
      signed int *return_value___errno_location$22;
      return_value___errno_location$22=__errno_location();
      VAS_Fail("vtx_retire", "vsl_dispatch.c", 575, "(vslq->n_outstanding) != 0", *return_value___errno_location$22, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vslq->n_outstanding = vslq->n_outstanding - 1u;
  if(!(vslq->n_cache >= 10u))
  {
    do
    {
      vtx->list_child.vtqe_next = (&vslq->cache)->vtqh_first;
      if(!(vtx->list_child.vtqe_next == ((struct vtx *)NULL)))
        (&vslq->cache)->vtqh_first->list_child.vtqe_prev = &vtx->list_child.vtqe_next;

      else
        (&vslq->cache)->vtqh_last = &vtx->list_child.vtqe_next;
      (&vslq->cache)->vtqh_first = vtx;
      vtx->list_child.vtqe_prev = &(&vslq->cache)->vtqh_first;
    }
    while((_Bool)0);
    vslq->n_cache = vslq->n_cache + 1u;
  }

  else
  {
    do
    {
      vtx->magic = (unsigned int)0;
      free((void *)vtx);
    }
    while((_Bool)0);
    vtx = (struct vtx *)(void *)0;
  }
}

// vtx_scan
// file vsl_dispatch.c line 842
static void vtx_scan(struct VSLQ *vslq, struct vtx *vtx)
{
  const unsigned int *ptr;
  enum VSL_tag_e tag;
  signed int return_value_vslc_vtx_next$1;
  while((4u & vtx->flags) == 0u)
  {
    return_value_vslc_vtx_next$1=vslc_vtx_next(&vtx->c.cursor);
    if(!(return_value_vslc_vtx_next$1 == 1))
      break;

    ptr = vtx->c.cursor.rec.ptr;
    if(!((1073741823u & ptr[1l]) == vtx->key.vxid))
      vtx_diag_tag(vtx, ptr, "vxid mismatch");

    else
    {
      tag = (enum VSL_tag_e)(ptr[(signed long int)0] >> 24);
      do
        if((signed int)tag == SLT__Batch)
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          VAS_Fail("vtx_scan", "vsl_dispatch.c", 856, "tag != SLT__Batch", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      switch((signed int)tag)
      {
        case SLT_Begin:
        {
          if(!((1u & vtx->flags) == 0u))
            vtx_diag_tag(vtx, ptr, "duplicate begin");

          else
          {
            vtx_scan_begin(vslq, vtx, ptr);
            vtx->flags = vtx->flags | (unsigned int)0x1;
          }
          break;
        }
        case SLT_Link:
        {
          vtx_scan_link(vslq, vtx, ptr);
          break;
        }
        case SLT_End:
        {

        __CPROVER_DUMP_L9:
          ;
          do
            if(!((2u & vtx->flags) == 0u))
            {
              signed int *return_value___errno_location$3;
              return_value___errno_location$3=__errno_location();
              VAS_Fail("vtx_scan", "vsl_dispatch.c", 873, "(vtx->flags & 0x2) == 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
            }

          while((_Bool)0);
          vtx->flags = vtx->flags | (unsigned int)0x2;
          vtx_mark_complete(vslq, vtx);
        }
      }
    }
  }
}

// vtx_scan_begin
// file vsl_dispatch.c line 714
static signed int vtx_scan_begin(struct VSLQ *vslq, struct vtx *vtx, const unsigned int *ptr)
{
  signed int i;
  enum VSL_transaction_e type;
  enum VSL_reason_e reason;
  unsigned int p_vxid;
  struct vtx *p_vtx;
  do
    if(!(*ptr >> 24 == 74u))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vtx_scan_begin", "vsl_dispatch.c", 722, "VSL_TAG(ptr) == SLT_Begin", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(!((8u & vtx->flags) == 0u))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vtx_scan_begin", "vsl_dispatch.c", 724, "(vtx->flags & 0x8) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  i=vtx_parse_link((const char *)(ptr + (signed long int)2), &type, &p_vxid, &reason);
  signed int return_value_vtx_diag_tag$3;
  signed int return_value_vtx_diag_tag$4;
  signed int return_value_vtx_diag_tag$9;
  if(!(i == 3))
  {
    return_value_vtx_diag_tag$3=vtx_diag_tag(vtx, ptr, "parse error");
    return return_value_vtx_diag_tag$3;
  }

  else
  {
    if((signed int)type == VSL_t_unknown)
      vtx_diag_tag(vtx, ptr, "unknown vxid type");

    if(!((signed int)vtx->type == VSL_t_unknown))
    {
      if(!(vtx->type == type))
        vtx_diag_tag(vtx, ptr, "type mismatch");

    }

    vtx->type = type;
    vtx->reason = reason;
    if(p_vxid == 0u)
      return 0;

    else
      if(p_vxid == vtx->key.vxid)
      {
        return_value_vtx_diag_tag$4=vtx_diag_tag(vtx, ptr, "link to self");
        return return_value_vtx_diag_tag$4;
      }

      else
        if((signed int)vslq->grouping == VSL_g_vxid)
          return 0;

        else
          if((signed int)vslq->grouping == VSL_g_request)
          {
            if(!((signed int)vtx->type == VSL_t_req))
              goto __CPROVER_DUMP_L11;

            if(!((signed int)vtx->reason == VSL_r_rxreq))
              goto __CPROVER_DUMP_L11;

            return 0;
          }

          else
          {

          __CPROVER_DUMP_L11:
            ;
            if(!(vtx->parent == ((struct vtx *)NULL)))
            {
              if(!(vtx->parent->key.vxid == p_vxid))
              {
                signed int return_value_vtx_diag_tag$5;
                return_value_vtx_diag_tag$5=vtx_diag_tag(vtx, ptr, "link mismatch");
                return return_value_vtx_diag_tag$5;
              }

              return 0;
            }

            else
            {
              p_vtx=vtx_lookup(vslq, p_vxid);
              if(p_vtx == ((struct vtx *)NULL))
              {
                p_vtx=vtx_add(vslq, p_vxid);

              __CPROVER_DUMP_L14:
                ;
                do
                  if(p_vtx == ((struct vtx *)NULL))
                  {
                    signed int *return_value___errno_location$6;
                    return_value___errno_location$6=__errno_location();
                    VAS_Fail("vtx_scan_begin", "vsl_dispatch.c", 766, "(p_vtx) != 0", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
                  }

                while((_Bool)0);
              }

              else
              {

              __CPROVER_DUMP_L16:
                ;
                do
                {
                  if(p_vtx == ((struct vtx *)NULL))
                  {
                    signed int *return_value___errno_location$7;
                    return_value___errno_location$7=__errno_location();
                    VAS_Fail("vtx_scan_begin", "vsl_dispatch.c", 768, "(p_vtx) != NULL", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
                  }

                  do
                    if(!(p_vtx->magic == 0xACC21D09))
                    {
                      signed int *return_value___errno_location$8;
                      return_value___errno_location$8=__errno_location();
                      VAS_Fail("vtx_scan_begin", "vsl_dispatch.c", 768, "(p_vtx)->magic == 0xACC21D09", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
                    }

                  while((_Bool)0);
                }
                while((_Bool)0);
                if(!((4u & p_vtx->flags) == 0u))
                {
                  return_value_vtx_diag_tag$9=vtx_diag_tag(vtx, ptr, "link too late");
                  return return_value_vtx_diag_tag$9;
                }

              }
              vtx_set_parent(p_vtx, vtx);
              return 0;
            }
          }
  }
}

// vtx_scan_link
// file vsl_dispatch.c line 781
static signed int vtx_scan_link(struct VSLQ *vslq, struct vtx *vtx, const unsigned int *ptr)
{
  signed int i;
  enum VSL_transaction_e c_type;
  enum VSL_reason_e c_reason;
  unsigned int c_vxid;
  struct vtx *c_vtx;
  do
    if(!(*ptr >> 24 == 73u))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vtx_scan_link", "vsl_dispatch.c", 789, "VSL_TAG(ptr) == SLT_Link", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(!((8u & vtx->flags) == 0u))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vtx_scan_link", "vsl_dispatch.c", 791, "(vtx->flags & 0x8) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  i=vtx_parse_link((const char *)(ptr + (signed long int)2), &c_type, &c_vxid, &c_reason);
  signed int return_value_vtx_diag_tag$3;
  signed int return_value_vtx_diag_tag$4;
  signed int return_value_vtx_diag_tag$5;
  signed int return_value_vtx_diag_tag$10;
  signed int return_value_vtx_diag_tag$11;
  if(!(i == 3))
  {
    return_value_vtx_diag_tag$3=vtx_diag_tag(vtx, ptr, "parse error");
    return return_value_vtx_diag_tag$3;
  }

  else
  {
    if((signed int)c_type == VSL_t_unknown)
      vtx_diag_tag(vtx, ptr, "unknown vxid type");

    if((signed int)vslq->grouping == VSL_g_vxid)
      return 0;

    else
      if((signed int)vslq->grouping == VSL_g_request)
      {
        if(!((signed int)vtx->type == VSL_t_sess))
          goto __CPROVER_DUMP_L8;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L8:
        ;
        if(c_vxid == 0u)
        {
          return_value_vtx_diag_tag$4=vtx_diag_tag(vtx, ptr, "illegal link vxid");
          return return_value_vtx_diag_tag$4;
        }

        else
          if(c_vxid == vtx->key.vxid)
          {
            return_value_vtx_diag_tag$5=vtx_diag_tag(vtx, ptr, "link to self");
            return return_value_vtx_diag_tag$5;
          }

          else
          {
            c_vtx=vtx_lookup(vslq, c_vxid);
            if(c_vtx == ((struct vtx *)NULL))
            {
              c_vtx=vtx_add(vslq, c_vxid);

            __CPROVER_DUMP_L11:
              ;
              do
                if(c_vtx == ((struct vtx *)NULL))
                {
                  signed int *return_value___errno_location$6;
                  return_value___errno_location$6=__errno_location();
                  VAS_Fail("vtx_scan_link", "vsl_dispatch.c", 814, "(c_vtx) != 0", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
                }

              while((_Bool)0);

            __CPROVER_DUMP_L13:
              ;
              do
                if(!(c_vtx->parent == ((struct vtx *)NULL)))
                {
                  signed int *return_value___errno_location$7;
                  return_value___errno_location$7=__errno_location();
                  VAS_Fail("vtx_scan_link", "vsl_dispatch.c", 815, "(c_vtx->parent) == 0", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
                }

              while((_Bool)0);
              c_vtx->type = c_type;
              c_vtx->reason = c_reason;
              vtx_set_parent(vtx, c_vtx);
              return 0;
            }

            else
            {

            __CPROVER_DUMP_L15:
              ;
              do
              {
                if(c_vtx == ((struct vtx *)NULL))
                {
                  signed int *return_value___errno_location$8;
                  return_value___errno_location$8=__errno_location();
                  VAS_Fail("vtx_scan_link", "vsl_dispatch.c", 822, "(c_vtx) != NULL", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
                }

                do
                  if(!(c_vtx->magic == 0xACC21D09))
                  {
                    signed int *return_value___errno_location$9;
                    return_value___errno_location$9=__errno_location();
                    VAS_Fail("vtx_scan_link", "vsl_dispatch.c", 822, "(c_vtx)->magic == 0xACC21D09", *return_value___errno_location$9, (enum vas_e)VAS_ASSERT);
                  }

                while((_Bool)0);
              }
              while((_Bool)0);
              if(c_vtx->parent == vtx)
                return 0;

              else
                if(!(c_vtx->parent == vtx))
                {
                  return_value_vtx_diag_tag$10=vtx_diag_tag(vtx, ptr, "duplicate link");
                  return return_value_vtx_diag_tag$10;
                }

                else
                  if(!((4u & c_vtx->flags) == 0u))
                  {
                    return_value_vtx_diag_tag$11=vtx_diag_tag(vtx, ptr, "link too late");
                    return return_value_vtx_diag_tag$11;
                  }

                  else
                  {
                    if(!((signed int)c_vtx->type == VSL_t_unknown))
                    {
                      if(!(c_vtx->type == c_type))
                        vtx_diag_tag(vtx, ptr, "type mismatch");

                    }

                    c_vtx->type = c_type;
                    c_vtx->reason = c_reason;
                    vtx_set_parent(vtx, c_vtx);
                    return 0;
                  }
            }
          }
      }
  }
}

// vtx_set_parent
// file vsl_dispatch.c line 655
static void vtx_set_parent(struct vtx *parent, struct vtx *child)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(parent == ((struct vtx *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vtx_set_parent", "vsl_dispatch.c", 658, "(parent) != NULL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(parent->magic == 0xACC21D09))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vtx_set_parent", "vsl_dispatch.c", 658, "(parent)->magic == 0xACC21D09", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L5:
  ;
  do
  {
    if(child == ((struct vtx *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vtx_set_parent", "vsl_dispatch.c", 659, "(child) != NULL", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(child->magic == 0xACC21D09))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        VAS_Fail("vtx_set_parent", "vsl_dispatch.c", 659, "(child)->magic == 0xACC21D09", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  do
    if(parent == child)
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      VAS_Fail("vtx_set_parent", "vsl_dispatch.c", 660, "parent != child", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L11:
  ;
  do
    if(!((4u & parent->flags) == 0u))
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      VAS_Fail("vtx_set_parent", "vsl_dispatch.c", 661, "(parent->flags & 0x4) == 0", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L13:
  ;
  do
    if(!((4u & child->flags) == 0u))
    {
      signed int *return_value___errno_location$7;
      return_value___errno_location$7=__errno_location();
      VAS_Fail("vtx_set_parent", "vsl_dispatch.c", 662, "(child->flags & 0x4) == 0", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L15:
  ;
  do
    if(!(child->parent == ((struct vtx *)NULL)))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      VAS_Fail("vtx_set_parent", "vsl_dispatch.c", 663, "(child->parent) == 0", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  child->parent = parent;
  do
  {
    child->list_child.vtqe_next = (struct vtx *)(void *)0;
    child->list_child.vtqe_prev = (&parent->child)->vtqh_last;
    *(&parent->child)->vtqh_last = child;
    (&parent->child)->vtqh_last = &child->list_child.vtqe_next;
  }
  while((_Bool)0);
  parent->n_child = parent->n_child + 1u;
  do
  {
    parent->n_descend = parent->n_descend + (unsigned int)1 + child->n_descend;
    parent = parent->parent;
  }
  while(!(parent == ((struct vtx *)NULL)));
}

// vtx_synth_rec
// file vsl_dispatch.c line 975
static void vtx_synth_rec(struct vtx *vtx, unsigned int tag, const char *fmt, ...)
{
  struct synth *synth;
  struct synth *it;
  void **ap;
  char *buf;
  signed int l;
  signed int buflen;
  do
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc(sizeof(struct synth) /*104ul*/ , (unsigned long int)1);
    synth = (struct synth *)return_value_calloc$1;
    if(!(synth == ((struct synth *)NULL)))
      synth->magic = 0xC654479F;

  }
  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(synth == ((struct synth *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vtx_synth_rec", "vsl_dispatch.c", 983, "(synth) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  buf = (char *)&synth->data[(signed long int)2];
  buflen = (signed int)(sizeof(unsigned int [18l]) /*72ul*/  - (unsigned long int)2 * sizeof(unsigned int) /*4ul*/ );
  ap = (void **)&fmt;
  l=vsnprintf(buf, (unsigned long int)buflen, fmt, ap);
  do
    if(!(l >= 0))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vtx_synth_rec", "vsl_dispatch.c", 989, "l >= 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  ap = ((void **)NULL);
  if(!(buflen + -1 >= l))
    l = buflen - 1;

  signed int tmp_post$4 = l;
  l = l + 1;
  buf[(signed long int)tmp_post$4] = (char)0;
  synth->data[(signed long int)1] = vtx->key.vxid;
  switch((signed int)vtx->type)
  {
    case VSL_t_req:
    {
      synth->data[(signed long int)1] = synth->data[(signed long int)1] | 1U << 30;
      break;
    }
    case VSL_t_bereq:
      synth->data[(signed long int)1] = synth->data[(signed long int)1] | 1U << 31;
  }
  synth->data[(signed long int)0] = (tag & (unsigned int)0xff) << 24 | (unsigned int)l;
  synth->offset = vtx->c.offset;
  it = *((struct synthhead *)(&vtx->synth)->vtqh_last)->vtqh_last;
  for( ; !(it == ((struct synth *)NULL)); it = *((struct synthhead *)it->list.vtqe_prev)->vtqh_last)
  {

  __CPROVER_DUMP_L12:
    ;
    do
    {
      if(it == ((struct synth *)NULL))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        VAS_Fail("vtx_synth_rec", "vsl_dispatch.c", 1010, "(it) != NULL", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
      }

      do
        if(!(it->magic == 0xC654479F))
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          VAS_Fail("vtx_synth_rec", "vsl_dispatch.c", 1010, "(it)->magic == 0xC654479F", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
    }
    while((_Bool)0);
    if(synth->offset >= it->offset)
      break;

  }
  if(!(it == ((struct synth *)NULL)))
    do
    {
      synth->list.vtqe_next = it->list.vtqe_next;
      if(!(synth->list.vtqe_next == ((struct synth *)NULL)))
        synth->list.vtqe_next->list.vtqe_prev = &synth->list.vtqe_next;

      else
        (&vtx->synth)->vtqh_last = &synth->list.vtqe_next;
      it->list.vtqe_next = synth;
      synth->list.vtqe_prev = &it->list.vtqe_next;
    }
    while((_Bool)0);

  else
    do
    {
      synth->list.vtqe_next = (&vtx->synth)->vtqh_first;
      if(!(synth->list.vtqe_next == ((struct synth *)NULL)))
        (&vtx->synth)->vtqh_first->list.vtqe_prev = &synth->list.vtqe_next;

      else
        (&vtx->synth)->vtqh_last = &synth->list.vtqe_next;
      (&vtx->synth)->vtqh_first = synth;
      synth->list.vtqe_prev = &(&vtx->synth)->vtqh_first;
    }
    while((_Bool)0);
  do
    if(!(vtx->c.synth == ((struct synth *)NULL)))
      do
        if(!(vtx->c.synth->magic == 0xC654479F))
        {
          signed int *return_value___errno_location$7;
          return_value___errno_location$7=__errno_location();
          VAS_Fail("vtx_synth_rec", "vsl_dispatch.c", 1020, "(vtx->c.synth)->magic == 0xC654479F", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);

  while((_Bool)0);
  _Bool tmp_if_expr$8;
  if(vtx->c.synth == ((struct synth *)NULL))
    tmp_if_expr$8 = (_Bool)1;

  else
    tmp_if_expr$8 = vtx->c.synth->offset > synth->offset ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$8)
    vtx->c.synth = synth;

}

// vtx_tree_VRB_FIND
// file vsl_dispatch.c line 221
static struct vtx_key * vtx_tree_VRB_FIND(struct vtx_tree *head, struct vtx_key *elm)
{
  struct vtx_key *tmp = head->rbh_root;
  signed int comp;
  while(!(tmp == ((struct vtx_key *)NULL)))
  {
    comp=vtx_keycmp(elm, tmp);
    if(!(comp >= 0))
      tmp = tmp->entry.rbe_left;

    else
      if(comp >= 1)
        tmp = tmp->entry.rbe_right;

      else
        return tmp;
  }
  return (struct vtx_key *)(void *)0;
}

// vtx_tree_VRB_INSERT
// file vsl_dispatch.c line 221
static struct vtx_key * vtx_tree_VRB_INSERT(struct vtx_tree *head, struct vtx_key *elm)
{
  struct vtx_key *tmp;
  struct vtx_key *parent = (struct vtx_key *)(void *)0;
  signed int comp = 0;
  tmp = head->rbh_root;
  while(!(tmp == ((struct vtx_key *)NULL)))
  {
    parent = tmp;
    comp=vtx_keycmp(elm, parent);
    if(!(comp >= 0))
      tmp = tmp->entry.rbe_left;

    else
      if(comp >= 1)
        tmp = tmp->entry.rbe_right;

      else
        return tmp;
  }
  do
  {
    elm->entry.rbe_parent = parent;
    elm->entry.rbe_right = (struct vtx_key *)(void *)0;
    elm->entry.rbe_left = elm->entry.rbe_right;
    elm->entry.rbe_color = 1;
  }
  while((_Bool)0);
  if(!(parent == ((struct vtx_key *)NULL)))
  {
    if(!(comp >= 0))
      parent->entry.rbe_left = elm;

    else
      parent->entry.rbe_right = elm;
  }

  else
    head->rbh_root = elm;

__CPROVER_DUMP_L7:
  ;
  vtx_tree_VRB_INSERT_COLOR(head, elm);
  return (struct vtx_key *)(void *)0;
}

// vtx_tree_VRB_INSERT_COLOR
// file vsl_dispatch.c line 221
static void vtx_tree_VRB_INSERT_COLOR(struct vtx_tree *head, struct vtx_key *elm)
{
  struct vtx_key *parent;
  struct vtx_key *gparent;
  struct vtx_key *tmp;
  do
  {
    parent = elm->entry.rbe_parent;
    if(parent == ((struct vtx_key *)NULL))
      break;

    if(!(parent->entry.rbe_color == 1))
      break;

    gparent = parent->entry.rbe_parent;
    if(parent == gparent->entry.rbe_left)
    {
      tmp = gparent->entry.rbe_right;
      if(!(tmp == ((struct vtx_key *)NULL)))
      {
        if(tmp->entry.rbe_color == 1)
        {
          tmp->entry.rbe_color = 0;
          do
          {
            parent->entry.rbe_color = 0;
            gparent->entry.rbe_color = 1;
          }
          while((_Bool)0);
          elm = gparent;
          continue;
        }

      }

      if(parent->entry.rbe_right == elm)
      {
        do
        {
          tmp = parent->entry.rbe_right;
          parent->entry.rbe_right = tmp->entry.rbe_left;
          if(!(parent->entry.rbe_right == ((struct vtx_key *)NULL)))
            tmp->entry.rbe_left->entry.rbe_parent = parent;


        __CPROVER_DUMP_L5:
          ;
          tmp->entry.rbe_parent = parent->entry.rbe_parent;
          if(!(tmp->entry.rbe_parent == ((struct vtx_key *)NULL)))
          {
            if(parent == parent->entry.rbe_parent->entry.rbe_left)
              parent->entry.rbe_parent->entry.rbe_left = tmp;

            else
              parent->entry.rbe_parent->entry.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->entry.rbe_left = parent;
          parent->entry.rbe_parent = tmp;

        __CPROVER_DUMP_L10:
          ;
          if(!(tmp->entry.rbe_parent == ((struct vtx_key *)NULL)))

            __CPROVER_DUMP_L11:
              ;

        }
        while((_Bool)0);
        tmp = parent;
        parent = elm;
        elm = tmp;
      }

      do
      {
        parent->entry.rbe_color = 0;
        gparent->entry.rbe_color = 1;
      }
      while((_Bool)0);
      do
      {
        tmp = gparent->entry.rbe_left;
        gparent->entry.rbe_left = tmp->entry.rbe_right;
        if(!(gparent->entry.rbe_left == ((struct vtx_key *)NULL)))
          tmp->entry.rbe_right->entry.rbe_parent = gparent;


      __CPROVER_DUMP_L15:
        ;
        tmp->entry.rbe_parent = gparent->entry.rbe_parent;
        if(!(tmp->entry.rbe_parent == ((struct vtx_key *)NULL)))
        {
          if(gparent == gparent->entry.rbe_parent->entry.rbe_left)
            gparent->entry.rbe_parent->entry.rbe_left = tmp;

          else
            gparent->entry.rbe_parent->entry.rbe_right = tmp;
        }

        else
          head->rbh_root = tmp;
        tmp->entry.rbe_right = gparent;
        gparent->entry.rbe_parent = tmp;

      __CPROVER_DUMP_L20:
        ;
        if(!(tmp->entry.rbe_parent == ((struct vtx_key *)NULL)))

          __CPROVER_DUMP_L21:
            ;

      }
      while((_Bool)0);
    }

    else
    {
      tmp = gparent->entry.rbe_left;
      if(!(tmp == ((struct vtx_key *)NULL)))
      {
        if(!(tmp->entry.rbe_color == 1))
          goto __CPROVER_DUMP_L25;

        tmp->entry.rbe_color = 0;
        do
        {
          parent->entry.rbe_color = 0;
          gparent->entry.rbe_color = 1;
        }
        while((_Bool)0);
        elm = gparent;
      }

      else
      {

      __CPROVER_DUMP_L25:
        ;
        if(parent->entry.rbe_left == elm)
        {
          do
          {
            tmp = parent->entry.rbe_left;
            parent->entry.rbe_left = tmp->entry.rbe_right;
            if(!(parent->entry.rbe_left == ((struct vtx_key *)NULL)))
              tmp->entry.rbe_right->entry.rbe_parent = parent;


          __CPROVER_DUMP_L27:
            ;
            tmp->entry.rbe_parent = parent->entry.rbe_parent;
            if(!(tmp->entry.rbe_parent == ((struct vtx_key *)NULL)))
            {
              if(parent == parent->entry.rbe_parent->entry.rbe_left)
                parent->entry.rbe_parent->entry.rbe_left = tmp;

              else
                parent->entry.rbe_parent->entry.rbe_right = tmp;
            }

            else
              head->rbh_root = tmp;
            tmp->entry.rbe_right = parent;
            parent->entry.rbe_parent = tmp;

          __CPROVER_DUMP_L32:
            ;
            if(!(tmp->entry.rbe_parent == ((struct vtx_key *)NULL)))

              __CPROVER_DUMP_L33:
                ;

          }
          while((_Bool)0);
          tmp = parent;
          parent = elm;
          elm = tmp;
        }

        do
        {
          parent->entry.rbe_color = 0;
          gparent->entry.rbe_color = 1;
        }
        while((_Bool)0);
        do
        {
          tmp = gparent->entry.rbe_right;
          gparent->entry.rbe_right = tmp->entry.rbe_left;
          if(!(gparent->entry.rbe_right == ((struct vtx_key *)NULL)))
            tmp->entry.rbe_left->entry.rbe_parent = gparent;


        __CPROVER_DUMP_L37:
          ;
          tmp->entry.rbe_parent = gparent->entry.rbe_parent;
          if(!(tmp->entry.rbe_parent == ((struct vtx_key *)NULL)))
          {
            if(gparent == gparent->entry.rbe_parent->entry.rbe_left)
              gparent->entry.rbe_parent->entry.rbe_left = tmp;

            else
              gparent->entry.rbe_parent->entry.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->entry.rbe_left = gparent;
          gparent->entry.rbe_parent = tmp;

        __CPROVER_DUMP_L42:
          ;
          if(!(tmp->entry.rbe_parent == ((struct vtx_key *)NULL)))

            __CPROVER_DUMP_L43:
              ;

        }
        while((_Bool)0);
      }
    }
  }
  while((_Bool)1);
  head->rbh_root->entry.rbe_color = 0;
}

// vtx_tree_VRB_REMOVE
// file vsl_dispatch.c line 221
static struct vtx_key * vtx_tree_VRB_REMOVE(struct vtx_tree *head, struct vtx_key *elm)
{
  struct vtx_key *child;
  struct vtx_key *parent;
  struct vtx_key *old = elm;
  signed int color;
  if(elm->entry.rbe_left == ((struct vtx_key *)NULL))
    child = elm->entry.rbe_right;

  else
    if(elm->entry.rbe_right == ((struct vtx_key *)NULL))
      child = elm->entry.rbe_left;

    else
    {
      struct vtx_key *left;
      elm = elm->entry.rbe_right;
      do
      {
        left = elm->entry.rbe_left;
        if(left == ((struct vtx_key *)NULL))
          break;

        elm = left;
      }
      while((_Bool)1);
      child = elm->entry.rbe_right;
      parent = elm->entry.rbe_parent;
      color = elm->entry.rbe_color;
      if(!(child == ((struct vtx_key *)NULL)))
        child->entry.rbe_parent = parent;

      if(!(parent == ((struct vtx_key *)NULL)))
      {
        if(parent->entry.rbe_left == elm)
          parent->entry.rbe_left = child;

        else
          parent->entry.rbe_right = child;
      }

      else
        head->rbh_root = child;

    __CPROVER_DUMP_L7:
      ;
      if(elm->entry.rbe_parent == old)
        parent = elm;

      elm->entry = old->entry;
      if(!(old->entry.rbe_parent == ((struct vtx_key *)NULL)))
      {
        if(old->entry.rbe_parent->entry.rbe_left == old)
          old->entry.rbe_parent->entry.rbe_left = elm;

        else
          old->entry.rbe_parent->entry.rbe_right = elm;
      }

      else
        head->rbh_root = elm;

    __CPROVER_DUMP_L12:
      ;
      old->entry.rbe_left->entry.rbe_parent = elm;
      if(!(old->entry.rbe_right == ((struct vtx_key *)NULL)))
        old->entry.rbe_right->entry.rbe_parent = elm;

      if(!(parent == ((struct vtx_key *)NULL)))
      {
        left = parent;

      __CPROVER_DUMP_L16:
        ;
        while((_Bool)1)
        {
          left = left->entry.rbe_parent;
          if(left == ((struct vtx_key *)NULL))
            break;

        }
      }

      goto color;
    }
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if(!(child == ((struct vtx_key *)NULL)))
    child->entry.rbe_parent = parent;

  if(!(parent == ((struct vtx_key *)NULL)))
  {
    if(parent->entry.rbe_left == elm)
      parent->entry.rbe_left = child;

    else
      parent->entry.rbe_right = child;
  }

  else
    head->rbh_root = child;

__CPROVER_DUMP_L21:
  ;

color:
  ;
  if(color == 0)
    vtx_tree_VRB_REMOVE_COLOR(head, parent, child);

  return old;
}

// vtx_tree_VRB_REMOVE_COLOR
// file vsl_dispatch.c line 221
static void vtx_tree_VRB_REMOVE_COLOR(struct vtx_tree *head, struct vtx_key *parent, struct vtx_key *elm)
{
  struct vtx_key *tmp;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$6;
  while((_Bool)1)
  {
    if(!(elm == ((struct vtx_key *)NULL)))
    {
      if(!(elm->entry.rbe_color == 0))
        goto __CPROVER_DUMP_L88;

    }

    if(elm == head->rbh_root)
      break;


  __CPROVER_DUMP_L3:
    ;
    do
      if(parent == ((struct vtx_key *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vtx_tree_VRB_REMOVE_COLOR", "vsl_dispatch.c", 221, "(parent) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    if(parent->entry.rbe_left == elm)
    {
      tmp = parent->entry.rbe_right;
      if(tmp->entry.rbe_color == 1)
      {
        do
        {
          tmp->entry.rbe_color = 0;
          parent->entry.rbe_color = 1;
        }
        while((_Bool)0);
        do
        {
          tmp = parent->entry.rbe_right;
          parent->entry.rbe_right = tmp->entry.rbe_left;
          if(!(parent->entry.rbe_right == ((struct vtx_key *)NULL)))
            tmp->entry.rbe_left->entry.rbe_parent = parent;


        __CPROVER_DUMP_L7:
          ;
          tmp->entry.rbe_parent = parent->entry.rbe_parent;
          if(!(tmp->entry.rbe_parent == ((struct vtx_key *)NULL)))
          {
            if(parent == parent->entry.rbe_parent->entry.rbe_left)
              parent->entry.rbe_parent->entry.rbe_left = tmp;

            else
              parent->entry.rbe_parent->entry.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->entry.rbe_left = parent;
          parent->entry.rbe_parent = tmp;

        __CPROVER_DUMP_L12:
          ;
          if(!(tmp->entry.rbe_parent == ((struct vtx_key *)NULL)))

            __CPROVER_DUMP_L13:
              ;

        }
        while((_Bool)0);
        tmp = parent->entry.rbe_right;
      }

      if(tmp->entry.rbe_left == ((struct vtx_key *)NULL))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = tmp->entry.rbe_left->entry.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        if(tmp->entry.rbe_right == ((struct vtx_key *)NULL))
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = tmp->entry.rbe_right->entry.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
      {
        tmp->entry.rbe_color = 1;
        elm = parent;
        parent = elm->entry.rbe_parent;
      }

      else
      {
        if(tmp->entry.rbe_right == ((struct vtx_key *)NULL))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = tmp->entry.rbe_right->entry.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
        {
          struct vtx_key *oleft = tmp->entry.rbe_left;
          if(!(oleft == ((struct vtx_key *)NULL)))
            oleft->entry.rbe_color = 0;

          tmp->entry.rbe_color = 1;
          do
          {
            oleft = tmp->entry.rbe_left;
            tmp->entry.rbe_left = oleft->entry.rbe_right;
            if(!(tmp->entry.rbe_left == ((struct vtx_key *)NULL)))
              oleft->entry.rbe_right->entry.rbe_parent = tmp;


          __CPROVER_DUMP_L27:
            ;
            oleft->entry.rbe_parent = tmp->entry.rbe_parent;
            if(!(oleft->entry.rbe_parent == ((struct vtx_key *)NULL)))
            {
              if(tmp == tmp->entry.rbe_parent->entry.rbe_left)
                tmp->entry.rbe_parent->entry.rbe_left = oleft;

              else
                tmp->entry.rbe_parent->entry.rbe_right = oleft;
            }

            else
              head->rbh_root = oleft;
            oleft->entry.rbe_right = tmp;
            tmp->entry.rbe_parent = oleft;

          __CPROVER_DUMP_L32:
            ;
            if(!(oleft->entry.rbe_parent == ((struct vtx_key *)NULL)))

              __CPROVER_DUMP_L33:
                ;

          }
          while((_Bool)0);
          tmp = parent->entry.rbe_right;
        }

        tmp->entry.rbe_color = parent->entry.rbe_color;
        parent->entry.rbe_color = 0;
        if(!(tmp->entry.rbe_right == ((struct vtx_key *)NULL)))
          tmp->entry.rbe_right->entry.rbe_color = 0;

        do
        {
          tmp = parent->entry.rbe_right;
          parent->entry.rbe_right = tmp->entry.rbe_left;
          if(!(parent->entry.rbe_right == ((struct vtx_key *)NULL)))
            tmp->entry.rbe_left->entry.rbe_parent = parent;


        __CPROVER_DUMP_L37:
          ;
          tmp->entry.rbe_parent = parent->entry.rbe_parent;
          if(!(tmp->entry.rbe_parent == ((struct vtx_key *)NULL)))
          {
            if(parent == parent->entry.rbe_parent->entry.rbe_left)
              parent->entry.rbe_parent->entry.rbe_left = tmp;

            else
              parent->entry.rbe_parent->entry.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->entry.rbe_left = parent;
          parent->entry.rbe_parent = tmp;

        __CPROVER_DUMP_L42:
          ;
          if(!(tmp->entry.rbe_parent == ((struct vtx_key *)NULL)))

            __CPROVER_DUMP_L43:
              ;

        }
        while((_Bool)0);
        elm = head->rbh_root;
        break;
      }
    }

    else
    {
      tmp = parent->entry.rbe_left;
      if(tmp->entry.rbe_color == 1)
      {
        do
        {
          tmp->entry.rbe_color = 0;
          parent->entry.rbe_color = 1;
        }
        while((_Bool)0);
        do
        {
          tmp = parent->entry.rbe_left;
          parent->entry.rbe_left = tmp->entry.rbe_right;
          if(!(parent->entry.rbe_left == ((struct vtx_key *)NULL)))
            tmp->entry.rbe_right->entry.rbe_parent = parent;


        __CPROVER_DUMP_L49:
          ;
          tmp->entry.rbe_parent = parent->entry.rbe_parent;
          if(!(tmp->entry.rbe_parent == ((struct vtx_key *)NULL)))
          {
            if(parent == parent->entry.rbe_parent->entry.rbe_left)
              parent->entry.rbe_parent->entry.rbe_left = tmp;

            else
              parent->entry.rbe_parent->entry.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->entry.rbe_right = parent;
          parent->entry.rbe_parent = tmp;

        __CPROVER_DUMP_L54:
          ;
          if(!(tmp->entry.rbe_parent == ((struct vtx_key *)NULL)))

            __CPROVER_DUMP_L55:
              ;

        }
        while((_Bool)0);
        tmp = parent->entry.rbe_left;
      }

      if(tmp->entry.rbe_left == ((struct vtx_key *)NULL))
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = tmp->entry.rbe_left->entry.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
      {
        if(tmp->entry.rbe_right == ((struct vtx_key *)NULL))
          tmp_if_expr$8 = (_Bool)1;

        else
          tmp_if_expr$8 = tmp->entry.rbe_right->entry.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$9 = tmp_if_expr$8 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$9 = (_Bool)0;
      if(tmp_if_expr$9)
      {
        tmp->entry.rbe_color = 1;
        elm = parent;
        parent = elm->entry.rbe_parent;
      }

      else
      {
        if(tmp->entry.rbe_left == ((struct vtx_key *)NULL))
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = tmp->entry.rbe_left->entry.rbe_color == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
        {
          struct vtx_key *oright = tmp->entry.rbe_right;
          if(!(oright == ((struct vtx_key *)NULL)))
            oright->entry.rbe_color = 0;

          tmp->entry.rbe_color = 1;
          do
          {
            oright = tmp->entry.rbe_right;
            tmp->entry.rbe_right = oright->entry.rbe_left;
            if(!(tmp->entry.rbe_right == ((struct vtx_key *)NULL)))
              oright->entry.rbe_left->entry.rbe_parent = tmp;


          __CPROVER_DUMP_L69:
            ;
            oright->entry.rbe_parent = tmp->entry.rbe_parent;
            if(!(oright->entry.rbe_parent == ((struct vtx_key *)NULL)))
            {
              if(tmp == tmp->entry.rbe_parent->entry.rbe_left)
                tmp->entry.rbe_parent->entry.rbe_left = oright;

              else
                tmp->entry.rbe_parent->entry.rbe_right = oright;
            }

            else
              head->rbh_root = oright;
            oright->entry.rbe_left = tmp;
            tmp->entry.rbe_parent = oright;

          __CPROVER_DUMP_L74:
            ;
            if(!(oright->entry.rbe_parent == ((struct vtx_key *)NULL)))

              __CPROVER_DUMP_L75:
                ;

          }
          while((_Bool)0);
          tmp = parent->entry.rbe_left;
        }

        tmp->entry.rbe_color = parent->entry.rbe_color;
        parent->entry.rbe_color = 0;
        if(!(tmp->entry.rbe_left == ((struct vtx_key *)NULL)))
          tmp->entry.rbe_left->entry.rbe_color = 0;

        do
        {
          tmp = parent->entry.rbe_left;
          parent->entry.rbe_left = tmp->entry.rbe_right;
          if(!(parent->entry.rbe_left == ((struct vtx_key *)NULL)))
            tmp->entry.rbe_right->entry.rbe_parent = parent;


        __CPROVER_DUMP_L79:
          ;
          tmp->entry.rbe_parent = parent->entry.rbe_parent;
          if(!(tmp->entry.rbe_parent == ((struct vtx_key *)NULL)))
          {
            if(parent == parent->entry.rbe_parent->entry.rbe_left)
              parent->entry.rbe_parent->entry.rbe_left = tmp;

            else
              parent->entry.rbe_parent->entry.rbe_right = tmp;
          }

          else
            head->rbh_root = tmp;
          tmp->entry.rbe_right = parent;
          parent->entry.rbe_parent = tmp;

        __CPROVER_DUMP_L84:
          ;
          if(!(tmp->entry.rbe_parent == ((struct vtx_key *)NULL)))

            __CPROVER_DUMP_L85:
              ;

        }
        while((_Bool)0);
        elm = head->rbh_root;
        break;
      }
    }
  }

__CPROVER_DUMP_L88:
  ;
  if(!(elm == ((struct vtx_key *)NULL)))
    elm->entry.rbe_color = 0;

}

// vut_dispatch
// file ../../lib/libvarnishtools/vut.c line 87
static signed int vut_dispatch(struct VSL_data *vsl, struct VSL_transaction * const *trans, void *priv)
{
  signed int i;
  (void)priv;
  if(VUT.k_arg == 0)
    return -1;

  else
  {

  __CPROVER_DUMP_L1:
    ;
    do
      if(VUT.dispatch_f == ((signed int (*)(struct VSL_data *, struct VSL_transaction * const *, void *))NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        VAS_Fail("vut_dispatch", "../../lib/libvarnishtools/vut.c", 95, "(VUT.dispatch_f) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    i=VUT.dispatch_f(vsl, trans, VUT.dispatch_priv);
    if(VUT.k_arg >= 1)
      VUT.k_arg = VUT.k_arg - 1;

    if(VUT.k_arg == 0 && i >= 0)
      return -1;

    else
      return i;
  }
}

// vut_sighup
// file ../../lib/libvarnishtools/vut.c line 66
static void vut_sighup(signed int sig)
{
  (void)sig;
  VUT.sighup = 1;
}

// vut_sigint
// file ../../lib/libvarnishtools/vut.c line 73
static void vut_sigint(signed int sig)
{
  (void)sig;
  VUT.sigint = 1;
}

// vut_sigusr1
// file ../../lib/libvarnishtools/vut.c line 80
static void vut_sigusr1(signed int sig)
{
  (void)sig;
  VUT.sigusr1 = 1;
}

// vut_vpf_remove
// file ../../lib/libvarnishtools/vut.c line 57
static void vut_vpf_remove(void)
{
  if(!(VUT.pfh == ((struct vpf_fh *)NULL)))
  {
    VPF_Remove(VUT.pfh);
    VUT.pfh = (struct vpf_fh *)(void *)0;
  }

}

// vxp_Alloc
// file vxp.c line 151
void * vxp_Alloc(struct vxp *vxp, unsigned int len)
{
  void *p;
  p=calloc((unsigned long int)len, (unsigned long int)1);

__CPROVER_DUMP_L1:
  ;
  do
    if(p == NULL)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_Alloc", "vxp.c", 156, "(p) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vxp_DoFree(vxp, p);
  return p;
}

// vxp_Delete
// file vxp.c line 178
static void vxp_Delete(struct vxp **pvxp)
{
  struct vxp *vxp;
  struct membit *mb;

__CPROVER_DUMP_L1:
  ;
  do
    if(pvxp == ((struct vxp **)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_Delete", "vxp.c", 183, "(pvxp) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vxp = *pvxp;
  *pvxp = (struct vxp *)(void *)0;

__CPROVER_DUMP_L3:
  ;
  do
  {
    if(vxp == ((struct vxp *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vxp_Delete", "vxp.c", 186, "(vxp) != NULL", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

    do
      if(!(vxp->magic == 1506277036u))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("vxp_Delete", "vxp.c", 186, "(vxp)->magic == 0x59C7F6AC", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
  }
  while((_Bool)0);
  while(!(vxp->membits.vtqh_first == ((struct membit *)NULL)))
  {
    mb = (&vxp->membits)->vtqh_first;
    do
    {
      if(!(mb->list.vtqe_next == ((struct membit *)NULL)))
        mb->list.vtqe_next->list.vtqe_prev = mb->list.vtqe_prev;

      else
        (&vxp->membits)->vtqh_last = mb->list.vtqe_prev;
      *mb->list.vtqe_prev = mb->list.vtqe_next;
    }
    while((_Bool)0);
    free(mb->ptr);
    free((void *)mb);
  }
  do
  {
    vxp->magic = (unsigned int)0;
    free((void *)vxp);
  }
  while((_Bool)0);
}

// vxp_DoFree
// file vxp.c line 140
static void vxp_DoFree(struct vxp *vxp, void *p)
{
  struct membit *mb;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc(sizeof(struct membit) /*24ul*/ , (unsigned long int)1);
  mb = (struct membit *)return_value_calloc$1;

__CPROVER_DUMP_L1:
  ;
  do
    if(mb == ((struct membit *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vxp_DoFree", "vxp.c", 145, "(mb) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  mb->ptr = p;
  do
  {
    mb->list.vtqe_next = (struct membit *)(void *)0;
    mb->list.vtqe_prev = (&vxp->membits)->vtqh_last;
    *(&vxp->membits)->vtqh_last = mb;
    (&vxp->membits)->vtqh_last = &mb->list.vtqe_next;
  }
  while((_Bool)0);
}

// vxp_ErrToken
// file vxp.c line 46
static void vxp_ErrToken(struct vxp *vxp, struct token *t)
{
  if(t->tok == 128u)
    VSB_printf(vxp->sb, "end of input");

  else
    VSB_printf(vxp->sb, "'%.*s'", (signed int)(t->e - t->b), t->b);
}

// vxp_ErrWhere
// file vxp.c line 101
void vxp_ErrWhere(struct vxp *vxp, struct token *t, signed int tokoff)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(vxp == ((struct vxp *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_ErrWhere", "vxp.c", 104, "(vxp) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(t == ((struct token *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vxp_ErrWhere", "vxp.c", 105, "(t) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vxp_Pos(vxp, vxp->sb, t, tokoff);
  VSB_putc(vxp->sb, 10);
  vxp_quote(vxp, t->b, t->e, tokoff);
  VSB_putc(vxp->sb, 10);
  vxp->err = 1;
}

// vxp_Lexer
// file vxp.h line 140
void vxp_Lexer(struct vxp *vxp)
{
  const char *p;
  const char *q;
  unsigned int u;
  char quote;
  p = vxp->b;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$16;
  const unsigned short int **return_value___ctype_b_loc$15;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$21;
  const unsigned short int **return_value___ctype_b_loc$5;
  _Bool tmp_if_expr$7;
  const unsigned short int **return_value___ctype_b_loc$6;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  while(!(p >= vxp->e))
  {
    const unsigned short int **return_value___ctype_b_loc$1;
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*p]) == 0))
      p = p + 1l;

    else
    {
      u=vxp_fixed_token(p, &q);
      if(!(u == 0u))
      {

      __CPROVER_DUMP_L3:
        ;
        do
          if(q == ((const char *)NULL))
          {
            signed int *return_value___errno_location$2;
            return_value___errno_location$2=__errno_location();
            VAS_Fail("vxp_Lexer", "vxp_lexer.c", 120, "(q) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
          }

        while((_Bool)0);
        vxp_add_token(vxp, u, p, q);
        p = q;
      }

      else
      {
        if((signed int)*p == 34)
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = (signed int)*p == 39 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$4)
        {
          quote = *p;
          q = p + (signed long int)1;
          for( ; !(q >= vxp->e); q = q + 1l)
            if(!((signed int)q[-1l] == 92))
            {
              if(*q == quote)
              {
                q = q + 1l;
                quote = (char)0;
                break;
              }

            }

          vxp_add_token(vxp, (unsigned int)140, p, q);
          if(!((signed int)quote == 0))
          {
            VSB_printf(vxp->sb, "Unterminated string ");
            vxp_ErrWhere(vxp, vxp->t, (signed int)((q - p) - (signed long int)1));
            goto __CPROVER_DUMP_L44;
          }

          signed int return_value_vxp_decstr$3;
          return_value_vxp_decstr$3=vxp_decstr(vxp, 1);
          if(!(return_value_vxp_decstr$3 == 0))
            goto __CPROVER_DUMP_L44;

          p = q;
          continue;
        }

        const unsigned short int **return_value___ctype_b_loc$14;
        return_value___ctype_b_loc$14=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$14)[(signed long int)(signed int)*p]) == 0))
          tmp_if_expr$16 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$15=__ctype_b_loc();
          tmp_if_expr$16 = ((signed int)(*return_value___ctype_b_loc$15)[(signed long int)(signed int)*p] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$16)
          tmp_if_expr$17 = (_Bool)1;

        else
          tmp_if_expr$17 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$17)
          tmp_if_expr$18 = (_Bool)1;

        else
          tmp_if_expr$18 = (signed int)*p == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$18)
          tmp_if_expr$19 = (_Bool)1;

        else
          tmp_if_expr$19 = (signed int)*p == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$19)
          tmp_if_expr$20 = (_Bool)1;

        else
          tmp_if_expr$20 = (signed int)*p == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$20)
          tmp_if_expr$21 = (_Bool)1;

        else
          tmp_if_expr$21 = (signed int)*p == 42 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$21)
        {
          q = p;
          for( ; !(q >= vxp->e); q = q + 1l)
          {
            return_value___ctype_b_loc$5=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)*q]) == 0))
              tmp_if_expr$7 = (_Bool)1;

            else
            {
              return_value___ctype_b_loc$6=__ctype_b_loc();
              tmp_if_expr$7 = ((signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)*q] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$7)
              tmp_if_expr$8 = (_Bool)1;

            else
              tmp_if_expr$8 = (signed int)*q == 95 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$8)
              tmp_if_expr$9 = (_Bool)1;

            else
              tmp_if_expr$9 = (signed int)*q == 45 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$9)
              tmp_if_expr$10 = (_Bool)1;

            else
              tmp_if_expr$10 = (signed int)*q == 43 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$10)
              tmp_if_expr$11 = (_Bool)1;

            else
              tmp_if_expr$11 = (signed int)*q == 46 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$11)
              tmp_if_expr$12 = (_Bool)1;

            else
              tmp_if_expr$12 = (signed int)*q == 42 ? (_Bool)1 : (_Bool)0;
            if(!tmp_if_expr$12)
              break;

          }
          vxp_add_token(vxp, (unsigned int)140, p, q);
          signed int return_value_vxp_decstr$13;
          return_value_vxp_decstr$13=vxp_decstr(vxp, 0);
          if(!(return_value_vxp_decstr$13 == 0))
            goto __CPROVER_DUMP_L44;

          p = q;
          continue;
        }

        vxp_add_token(vxp, (unsigned int)128, p, p + (signed long int)1);
        VSB_printf(vxp->sb, "Syntax error ");
        vxp_ErrWhere(vxp, vxp->t, (signed int)(q - p));
        goto __CPROVER_DUMP_L44;
      }
    }
  }
  vxp_add_token(vxp, (unsigned int)128, vxp->e, vxp->e);

__CPROVER_DUMP_L44:
  ;
}

// vxp_New
// file vxp.c line 162
static struct vxp * vxp_New(struct vsb *sb)
{
  struct vxp *vxp;

__CPROVER_DUMP_L1:
  ;
  do
    if(sb == ((struct vsb *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_New", "vxp.c", 166, "(sb) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
  {
    void *return_value_calloc$2;
    return_value_calloc$2=calloc(sizeof(struct vxp) /*96ul*/ , (unsigned long int)1);
    vxp = (struct vxp *)return_value_calloc$2;
    if(!(vxp == ((struct vxp *)NULL)))
      vxp->magic = (unsigned int)0x59C7F6AC;

  }
  while((_Bool)0);

__CPROVER_DUMP_L5:
  ;
  do
    if(vxp == ((struct vxp *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vxp_New", "vxp.c", 169, "(vxp) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
  {
    (&vxp->membits)->vtqh_first = (struct membit *)(void *)0;
    (&vxp->membits)->vtqh_last = &(&vxp->membits)->vtqh_first;
  }
  while((_Bool)0);
  do
  {
    (&vxp->tokens)->vtqh_first = (struct token *)(void *)0;
    (&vxp->tokens)->vtqh_last = &(&vxp->tokens)->vtqh_first;
  }
  while((_Bool)0);
  vxp->sb = sb;
  return vxp;
}

// vxp_NextToken
// file vxp.c line 114
void vxp_NextToken(struct vxp *vxp)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(vxp->t == ((struct token *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_NextToken", "vxp.c", 117, "(vxp->t) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vxp->t = vxp->t->list.vtqe_next;
  if(vxp->t == ((struct token *)NULL))
  {
    VSB_printf(vxp->sb, "Ran out of input, something is missing or maybe unbalanced parenthesis\n");
    vxp->err = 1;
  }

}

// vxp_Parse
// file vxp.h line 141
struct vex * vxp_Parse(struct vxp *vxp)
{
  struct vex *vex = (struct vex *)(void *)0;
  vxp->t = (&vxp->tokens)->vtqh_first;
  if(vxp->t == ((struct token *)NULL))
    return (struct vex *)(void *)0;

  else
  {
    vxp_expr(vxp, &vex);
    if(!(vxp->err == 0))
    {
      if(!(vex == ((struct vex *)NULL)))
        vex_Free(&vex);


    __CPROVER_DUMP_L2:
      ;
      do
        if(!(vex == ((struct vex *)NULL)))
        {
          signed int *return_value___errno_location$1;
          return_value___errno_location$1=__errno_location();
          VAS_Fail("vxp_Parse", "vxp_parse.c", 488, "(vex) == 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      return (struct vex *)(void *)0;
    }

    else
      return vex;
  }
}

// vxp_Pos
// file vxp.c line 56
static void vxp_Pos(struct vxp *vxp, struct vsb *vsb, struct token *t, signed int tokoff)
{
  unsigned int pos;

__CPROVER_DUMP_L1:
  ;
  do
    if(vxp == ((struct vxp *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_Pos", "vxp.c", 61, "(vxp) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(vsb == ((struct vsb *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vxp_Pos", "vxp.c", 62, "(vsb) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L5:
  ;
  do
    if(t == ((struct token *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vxp_Pos", "vxp.c", 63, "(t) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
    if(!(t->b >= vxp->b))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("vxp_Pos", "vxp.c", 64, "t->b >= vxp->b", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  pos = (unsigned int)(t->b - vxp->b);
  if(tokoff >= 1)
    pos = pos + (unsigned int)tokoff;

  VSB_printf(vsb, "(Pos %u)", pos + (unsigned int)1);
}

// vxp__Expect
// file vxp.c line 128
void vxp__Expect(struct vxp *vxp, unsigned int tok)
{
  if(!(vxp->t->tok == tok))
  {
    VSB_printf(vxp->sb, "Expected %s got ", vxp_tnames[(signed long int)tok]);
    vxp_ErrToken(vxp, vxp->t);
    VSB_putc(vxp->sb, 32);
    vxp_ErrWhere(vxp, vxp->t, -1);
  }

}

// vxp_add_token
// file vxp_lexer.c line 45
static void vxp_add_token(struct vxp *vxp, unsigned int tok, const char *b, const char *e)
{
  struct token *t;
  void *return_value_vxp_Alloc$1;
  return_value_vxp_Alloc$1=vxp_Alloc(vxp, (unsigned int)sizeof(struct token) /*56ul*/ );
  t = (struct token *)return_value_vxp_Alloc$1;

__CPROVER_DUMP_L1:
  ;
  do
    if(t == ((struct token *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vxp_add_token", "vxp_lexer.c", 50, "(t) != 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  t->tok = tok;
  t->b = b;
  t->e = e;
  if(!(vxp->t == ((struct token *)NULL)))
    do
    {
      t->list.vtqe_next = vxp->t->list.vtqe_next;
      if(!(t->list.vtqe_next == ((struct token *)NULL)))
        t->list.vtqe_next->list.vtqe_prev = &t->list.vtqe_next;

      else
        (&vxp->tokens)->vtqh_last = &t->list.vtqe_next;
      vxp->t->list.vtqe_next = t;
      t->list.vtqe_prev = &vxp->t->list.vtqe_next;
    }
    while((_Bool)0);

  else
    do
    {
      t->list.vtqe_next = (struct token *)(void *)0;
      t->list.vtqe_prev = (&vxp->tokens)->vtqh_last;
      *(&vxp->tokens)->vtqh_last = t;
      (&vxp->tokens)->vtqh_last = &t->list.vtqe_next;
    }
    while((_Bool)0);
  vxp->t = t;
}

// vxp_decstr
// file vxp_lexer.c line 62
static signed int vxp_decstr(struct vxp *vxp, signed int quoted)
{
  const char *b;
  const char *e;
  const char *p;
  char *s;
  unsigned int l;
  signed int esc = 0;
  do
    if(!(vxp->t->tok == 140u))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_decstr", "vxp_lexer.c", 69, "vxp->t->tok == VAL", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  b = vxp->t->b;
  e = vxp->t->e;
  if(!(quoted == 0))
  {
    do
      if(!(e - b >= 2l))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        VAS_Fail("vxp_decstr", "vxp_lexer.c", 74, "e - b >= 2", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    b = b + 1l;
    e = e - 1l;
  }

  l = (unsigned int)(e - b);
  void *return_value_vxp_Alloc$3;
  return_value_vxp_Alloc$3=vxp_Alloc(vxp, l + (unsigned int)1);
  vxp->t->dec = (char *)return_value_vxp_Alloc$3;
  s = vxp->t->dec;

__CPROVER_DUMP_L6:
  ;
  do
    if(vxp->t->dec == ((char *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("vxp_decstr", "vxp_lexer.c", 80, "(vxp->t->dec) != 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  p = b;
  char *tmp_post$5;
  for( ; !(p >= e); p = p + 1l)
    if(esc == 0)
    {
      if(!((signed int)*p == 92))
        goto __CPROVER_DUMP_L9;

      esc = 1;
    }

    else
    {

    __CPROVER_DUMP_L9:
      ;
      esc = 0;
      tmp_post$5 = s;
      s = s + 1l;
      *tmp_post$5 = *p;
    }
  *s = (char)0;
  if(!(p == e) || !(esc == 0))
  {
    VSB_printf(vxp->sb, "Syntax error ");
    vxp_ErrWhere(vxp, vxp->t, -1);
    return 1;
  }

  else
    return 0;
}

// vxp_expr
// file vxp_parse.c line 463
static void vxp_expr(struct vxp *vxp, struct vex **pvex)
{
  vxp_expr_or(vxp, pvex);
  do
    if(!(vxp->err == 0))
      goto __CPROVER_DUMP_L4;

  while((_Bool)0);
  do
  {
    vxp__Expect(vxp, (unsigned int)128);
    do
      if(!(vxp->err == 0))
        break;

    while((_Bool)0);
  }
  while((_Bool)0);

__CPROVER_DUMP_L4:
  ;
}

// vxp_expr_and
// file vxp_parse.c line 407
static void vxp_expr_and(struct vxp *vxp, struct vex **pvex)
{
  struct vex *a;

__CPROVER_DUMP_L1:
  ;
  do
    if(pvex == ((struct vex **)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_expr_and", "vxp_parse.c", 411, "(pvex) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(!(*pvex == ((struct vex *)NULL)))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vxp_expr_and", "vxp_parse.c", 412, "(*pvex) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vxp_expr_not(vxp, pvex);
  do
    if(!(vxp->err == 0))
      goto __CPROVER_DUMP_L15;

  while((_Bool)0);
  while(vxp->t->tok == 129u)
  {
    a = *pvex;
    *pvex=vex_alloc(vxp);

  __CPROVER_DUMP_L8:
    ;
    do
      if(*pvex == ((struct vex *)NULL))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("vxp_expr_and", "vxp_parse.c", 418, "(*pvex) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    (*pvex)->tok = vxp->t->tok;
    (*pvex)->a = a;
    vxp_NextToken(vxp);
    do
      if(!(vxp->err == 0))
        goto __CPROVER_DUMP_L15;

    while((_Bool)0);
    vxp_expr_not(vxp, &(*pvex)->b);
    do
      if(!(vxp->err == 0))
        goto __CPROVER_DUMP_L15;

    while((_Bool)0);
  }

__CPROVER_DUMP_L15:
  ;
}

// vxp_expr_cmp
// file vxp_parse.c line 277
static void vxp_expr_cmp(struct vxp *vxp, struct vex **pvex)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(pvex == ((struct vex **)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_expr_cmp", "vxp_parse.c", 280, "(pvex) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(!(*pvex == ((struct vex *)NULL)))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vxp_expr_cmp", "vxp_parse.c", 281, "(*pvex) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  *pvex=vex_alloc(vxp);

__CPROVER_DUMP_L5:
  ;
  do
    if(*pvex == ((struct vex *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vxp_expr_cmp", "vxp_parse.c", 283, "(*pvex) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vxp_expr_lhs(vxp, &(*pvex)->lhs);
  do
    if(!(vxp->err == 0))
      goto __CPROVER_DUMP_L18;

  while((_Bool)0);
  switch(vxp->t->tok)
  {
    case (unsigned int)128:

    case (unsigned int)129:

    case (unsigned int)136:

    case (unsigned int)41:
    {
      (*pvex)->tok = (unsigned int)139;
      goto __CPROVER_DUMP_L18;
    }
    case (unsigned int)130:

    case (unsigned int)60:

    case (unsigned int)62:

    case (unsigned int)131:

    case (unsigned int)132:

    case (unsigned int)133:

    case (unsigned int)137:

    case (unsigned int)138:

    case (unsigned int)126:

    case (unsigned int)134:
    {
      (*pvex)->tok = vxp->t->tok;
      break;
    }
    default:
    {
      VSB_printf(vxp->sb, "Expected operator got '%.*s' ", (signed int)(vxp->t->e - vxp->t->b), vxp->t->b);
      vxp_ErrWhere(vxp, vxp->t, -1);
      goto __CPROVER_DUMP_L18;
    }
  }
  vxp_NextToken(vxp);
  do
    if(!(vxp->err == 0))
      goto __CPROVER_DUMP_L18;

  while((_Bool)0);
  signed int *return_value___errno_location$4;
  signed int *return_value___errno_location$5;
  switch((*pvex)->tok)
  {
    case (unsigned int)0:
    {
      return_value___errno_location$4=__errno_location();
      VAS_Fail("vxp_expr_cmp", "vxp_parse.c", 325, "Missing token", *return_value___errno_location$4, (enum vas_e)VAS_WRONG);
    }
    case (unsigned int)130:

    case (unsigned int)60:

    case (unsigned int)62:

    case (unsigned int)131:

    case (unsigned int)132:

    case (unsigned int)133:
    {
      vxp_expr_num(vxp, &(*pvex)->rhs);
      break;
    }
    case (unsigned int)137:

    case (unsigned int)138:
    {
      vxp_expr_str(vxp, &(*pvex)->rhs);
      break;
    }
    case (unsigned int)126:

    case (unsigned int)134:
    {
      vxp_expr_regex(vxp, &(*pvex)->rhs);
      break;
    }
    default:
    {
      return_value___errno_location$5=__errno_location();
      VAS_Fail("vxp_expr_cmp", "vxp_parse.c", 344, "", *return_value___errno_location$5, (enum vas_e)VAS_INCOMPLETE);
    }
  }

__CPROVER_DUMP_L18:
  ;
}

// vxp_expr_group
// file vxp_parse.c line 356
static void vxp_expr_group(struct vxp *vxp, struct vex **pvex)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(pvex == ((struct vex **)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_expr_group", "vxp_parse.c", 359, "(pvex) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(!(*pvex == ((struct vex *)NULL)))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vxp_expr_group", "vxp_parse.c", 360, "(*pvex) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(vxp->t->tok == 40u)
  {
    do
    {
      vxp__Expect(vxp, (unsigned int)40);
      do
        if(!(vxp->err == 0))
          goto __CPROVER_DUMP_L11;

      while((_Bool)0);
      vxp_NextToken(vxp);
    }
    while((_Bool)0);
    vxp_expr_or(vxp, pvex);
    do
      if(!(vxp->err == 0))
        goto __CPROVER_DUMP_L11;

    while((_Bool)0);
    do
    {
      vxp__Expect(vxp, (unsigned int)41);
      do
        if(!(vxp->err == 0))
          goto __CPROVER_DUMP_L11;

      while((_Bool)0);
      vxp_NextToken(vxp);
    }
    while((_Bool)0);
  }

  else
    vxp_expr_cmp(vxp, pvex);

__CPROVER_DUMP_L11:
  ;
}

// vxp_expr_lhs
// file vxp_parse.c line 64
static void vxp_expr_lhs(struct vxp *vxp, struct vex_lhs **plhs)
{
  char *p;
  signed int i;

__CPROVER_DUMP_L1:
  ;
  do
    if(plhs == ((struct vex_lhs **)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_expr_lhs", "vxp_parse.c", 69, "(plhs) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(!(*plhs == ((struct vex_lhs *)NULL)))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vxp_expr_lhs", "vxp_parse.c", 70, "(*plhs) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
  {
    void *return_value_calloc$3;
    return_value_calloc$3=calloc(sizeof(struct vex_lhs) /*40ul*/ , (unsigned long int)1);
    *plhs = (struct vex_lhs *)return_value_calloc$3;
    if(!(*plhs == ((struct vex_lhs *)NULL)))
      (*plhs)->magic = (unsigned int)0x1AD3D78D;

  }
  while((_Bool)0);

__CPROVER_DUMP_L7:
  ;
  do
    if(*plhs == ((struct vex_lhs *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      VAS_Fail("vxp_expr_lhs", "vxp_parse.c", 72, "(*plhs) != 0", *return_value___errno_location$4, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  (*plhs)->tags=vbit_init$link2((unsigned int)256);
  (*plhs)->level = -1;
  if(vxp->t->tok == 123u)
  {
    vxp_NextToken(vxp);
    if(!(vxp->t->tok == 140u))
    {
      VSB_printf(vxp->sb, "Expected integer got '%.*s' ", (signed int)(vxp->t->e - vxp->t->b), vxp->t->b);
      vxp_ErrWhere(vxp, vxp->t, -1);
      goto __CPROVER_DUMP_L37;
    }

    signed long int return_value_strtol$5;
    return_value_strtol$5=strtol(vxp->t->dec, &p, 0);
    (*plhs)->level = (signed int)return_value_strtol$5;
    if(!((*plhs)->level >= 0))
    {
      VSB_printf(vxp->sb, "Expected positive integer ");
      vxp_ErrWhere(vxp, vxp->t, -1);
      goto __CPROVER_DUMP_L37;
    }

    if((signed int)*p == 45)
    {
      (*plhs)->level_pm = -1;
      p = p + 1l;
    }

    else
      if((signed int)*p == 43)
      {
        (*plhs)->level_pm = 1;
        p = p + 1l;
      }

    if(!(*p == 0))
    {
      VSB_printf(vxp->sb, "Syntax error in level limit ");
      vxp_ErrWhere(vxp, vxp->t, -1);
      goto __CPROVER_DUMP_L37;
    }

    vxp_NextToken(vxp);
    do
    {
      vxp__Expect(vxp, (unsigned int)125);
      do
        if(!(vxp->err == 0))
          goto __CPROVER_DUMP_L37;

      while((_Bool)0);
    }
    while((_Bool)0);
    vxp_NextToken(vxp);
  }

  while((_Bool)1)
  {
    if(!(vxp->t->tok == 140u))
    {
      VSB_printf(vxp->sb, "Expected VSL tag name got '%.*s' ", (signed int)(vxp->t->e - vxp->t->b), vxp->t->b);
      vxp_ErrWhere(vxp, vxp->t, -1);
      goto __CPROVER_DUMP_L37;
    }

    i=VSL_Glob2Tags(vxp->t->dec, -1, vsl_vbm_bitset, (void *)(*plhs)->tags);
    if(i == -1)
    {
      VSB_printf(vxp->sb, "Tag name matches zero tags ");
      vxp_ErrWhere(vxp, vxp->t, -1);
      goto __CPROVER_DUMP_L37;
    }

    if(i == -2)
    {
      VSB_printf(vxp->sb, "Tag name is ambiguous ");
      vxp_ErrWhere(vxp, vxp->t, -1);
      goto __CPROVER_DUMP_L37;
    }

    if(i == -3)
    {
      VSB_printf(vxp->sb, "Syntax error in tag name ");
      vxp_ErrWhere(vxp, vxp->t, -1);
      goto __CPROVER_DUMP_L37;
    }

    do
      if(!(i >= 1))
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        VAS_Fail("vxp_expr_lhs", "vxp_parse.c", 133, "i > 0", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    vxp_NextToken(vxp);
    if(!(vxp->t->tok == 44u))
      break;

    vxp_NextToken(vxp);
  }
  if(vxp->t->tok == 58u)
  {
    vxp_NextToken(vxp);
    if(!(vxp->t->tok == 140u))
    {
      VSB_printf(vxp->sb, "Expected string got '%.*s' ", (signed int)(vxp->t->e - vxp->t->b), vxp->t->b);
      vxp_ErrWhere(vxp, vxp->t, -1);
      goto __CPROVER_DUMP_L37;
    }


  __CPROVER_DUMP_L24:
    ;
    do
      if(vxp->t->dec == ((char *)NULL))
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        VAS_Fail("vxp_expr_lhs", "vxp_parse.c", 149, "(vxp->t->dec) != 0", *return_value___errno_location$7, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    (*plhs)->prefix=strdup(vxp->t->dec);

  __CPROVER_DUMP_L26:
    ;
    do
      if((*plhs)->prefix == ((char *)NULL))
      {
        signed int *return_value___errno_location$8;
        return_value___errno_location$8=__errno_location();
        VAS_Fail("vxp_expr_lhs", "vxp_parse.c", 151, "((*plhs)->prefix) != 0", *return_value___errno_location$8, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    unsigned long int return_value_strlen$9;
    return_value_strlen$9=strlen((*plhs)->prefix);
    (*plhs)->prefixlen = (signed int)return_value_strlen$9;
    vxp_NextToken(vxp);
  }

  _Bool tmp_if_expr$11;
  if(vxp->t->tok == 91u)
  {
    vxp_NextToken(vxp);
    if(!(vxp->t->tok == 140u))
    {
      VSB_printf(vxp->sb, "Expected integer got '%.*s' ", (signed int)(vxp->t->e - vxp->t->b), vxp->t->b);
      vxp_ErrWhere(vxp, vxp->t, -1);
      goto __CPROVER_DUMP_L37;
    }

    signed long int return_value_strtol$10;
    return_value_strtol$10=strtol(vxp->t->dec, &p, 0);
    (*plhs)->field = (signed int)return_value_strtol$10;
    if(!(*p == 0))
      tmp_if_expr$11 = (_Bool)1;

    else
      tmp_if_expr$11 = (*plhs)->field <= 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$11)
    {
      VSB_printf(vxp->sb, "Expected positive integer ");
      vxp_ErrWhere(vxp, vxp->t, -1);
      goto __CPROVER_DUMP_L37;
    }

    vxp_NextToken(vxp);
    do
    {
      vxp__Expect(vxp, (unsigned int)93);
      do
        if(!(vxp->err == 0))
          goto __CPROVER_DUMP_L37;

      while((_Bool)0);
    }
    while((_Bool)0);
    vxp_NextToken(vxp);
  }


__CPROVER_DUMP_L37:
  ;
}

// vxp_expr_not
// file vxp_parse.c line 381
static void vxp_expr_not(struct vxp *vxp, struct vex **pvex)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(pvex == ((struct vex **)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_expr_not", "vxp_parse.c", 384, "(pvex) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(!(*pvex == ((struct vex *)NULL)))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vxp_expr_not", "vxp_parse.c", 385, "(*pvex) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(vxp->t->tok == 135u)
  {
    *pvex=vex_alloc(vxp);

  __CPROVER_DUMP_L5:
    ;
    do
      if(*pvex == ((struct vex *)NULL))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("vxp_expr_not", "vxp_parse.c", 389, "(*pvex) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    (*pvex)->tok = vxp->t->tok;
    vxp_NextToken(vxp);
    vxp_expr_group(vxp, &(*pvex)->a);
  }

  else
    vxp_expr_group(vxp, pvex);
}

// vxp_expr_num
// file vxp_parse.c line 178
static void vxp_expr_num(struct vxp *vxp, struct vex_rhs **prhs)
{
  char *endptr;

__CPROVER_DUMP_L1:
  ;
  do
    if(prhs == ((struct vex_rhs **)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_expr_num", "vxp_parse.c", 182, "(prhs) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(!(*prhs == ((struct vex_rhs *)NULL)))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vxp_expr_num", "vxp_parse.c", 183, "(*prhs) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  const unsigned short int **return_value___ctype_b_loc$6;
  const unsigned short int **return_value___ctype_b_loc$7;
  if(!(vxp->t->tok == 140u))
  {
    VSB_printf(vxp->sb, "Expected number got '%.*s' ", (signed int)(vxp->t->e - vxp->t->b), vxp->t->b);
    vxp_ErrWhere(vxp, vxp->t, -1);
  }

  else
  {

  __CPROVER_DUMP_L5:
    ;
    do
      if(vxp->t->dec == ((char *)NULL))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("vxp_expr_num", "vxp_parse.c", 189, "(vxp->t->dec) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    do
    {
      void *return_value_calloc$4;
      return_value_calloc$4=calloc(sizeof(struct vex_rhs) /*48ul*/ , (unsigned long int)1);
      *prhs = (struct vex_rhs *)return_value_calloc$4;
      if(!(*prhs == ((struct vex_rhs *)NULL)))
        (*prhs)->magic = (unsigned int)0x3F109965;

    }
    while((_Bool)0);

  __CPROVER_DUMP_L9:
    ;
    do
      if(*prhs == ((struct vex_rhs *)NULL))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        VAS_Fail("vxp_expr_num", "vxp_parse.c", 191, "(*prhs) != 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    char *return_value_strchr$8;
    return_value_strchr$8=strchr(vxp->t->dec, 46);
    if(!(return_value_strchr$8 == ((char *)NULL)))
    {
      (*prhs)->type = (enum vex_rhs_e)VEX_FLOAT;
      (*prhs)->val_float=strtod(vxp->t->dec, &endptr);
      do
      {
        return_value___ctype_b_loc$6=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)*endptr]) == 0)
          break;

        endptr = endptr + 1l;
      }
      while((_Bool)1);
      if(!((signed int)*endptr == 0))
      {
        VSB_printf(vxp->sb, "Floating point parse error ");
        vxp_ErrWhere(vxp, vxp->t, -1);
        goto __CPROVER_DUMP_L19;
      }

    }

    else
    {
      (*prhs)->type = (enum vex_rhs_e)VEX_INT;
      (*prhs)->val_int=strtoll(vxp->t->dec, &endptr, 0);
      do
      {
        return_value___ctype_b_loc$7=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)*endptr]) == 0)
          break;

        endptr = endptr + 1l;
      }
      while((_Bool)1);
      if(!((signed int)*endptr == 0))
      {
        VSB_printf(vxp->sb, "Integer parse error ");
        vxp_ErrWhere(vxp, vxp->t, -1);
        goto __CPROVER_DUMP_L19;
      }

    }
    vxp_NextToken(vxp);
  }

__CPROVER_DUMP_L19:
  ;
}

// vxp_expr_or
// file vxp_parse.c line 435
static void vxp_expr_or(struct vxp *vxp, struct vex **pvex)
{
  struct vex *a;

__CPROVER_DUMP_L1:
  ;
  do
    if(pvex == ((struct vex **)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_expr_or", "vxp_parse.c", 439, "(pvex) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(!(*pvex == ((struct vex *)NULL)))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vxp_expr_or", "vxp_parse.c", 440, "(*pvex) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  vxp_expr_and(vxp, pvex);
  do
    if(!(vxp->err == 0))
      goto __CPROVER_DUMP_L15;

  while((_Bool)0);
  while(vxp->t->tok == 136u)
  {
    a = *pvex;
    *pvex=vex_alloc(vxp);

  __CPROVER_DUMP_L8:
    ;
    do
      if(*pvex == ((struct vex *)NULL))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("vxp_expr_or", "vxp_parse.c", 446, "(*pvex) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    (*pvex)->tok = vxp->t->tok;
    (*pvex)->a = a;
    vxp_NextToken(vxp);
    do
      if(!(vxp->err == 0))
        goto __CPROVER_DUMP_L15;

    while((_Bool)0);
    vxp_expr_and(vxp, &(*pvex)->b);
    do
      if(!(vxp->err == 0))
        goto __CPROVER_DUMP_L15;

    while((_Bool)0);
  }

__CPROVER_DUMP_L15:
  ;
}

// vxp_expr_regex
// file vxp_parse.c line 238
static void vxp_expr_regex(struct vxp *vxp, struct vex_rhs **prhs)
{
  const char *errptr;
  signed int erroff;

__CPROVER_DUMP_L1:
  ;
  do
    if(prhs == ((struct vex_rhs **)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_expr_regex", "vxp_parse.c", 245, "(prhs) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(!(*prhs == ((struct vex_rhs *)NULL)))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vxp_expr_regex", "vxp_parse.c", 246, "(*prhs) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(!(vxp->t->tok == 140u))
  {
    VSB_printf(vxp->sb, "Expected regular expression got '%.*s' ", (signed int)(vxp->t->e - vxp->t->b), vxp->t->b);
    vxp_ErrWhere(vxp, vxp->t, -1);
  }

  else
  {

  __CPROVER_DUMP_L5:
    ;
    do
      if(vxp->t->dec == ((char *)NULL))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("vxp_expr_regex", "vxp_parse.c", 253, "(vxp->t->dec) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    do
    {
      void *return_value_calloc$4;
      return_value_calloc$4=calloc(sizeof(struct vex_rhs) /*48ul*/ , (unsigned long int)1);
      *prhs = (struct vex_rhs *)return_value_calloc$4;
      if(!(*prhs == ((struct vex_rhs *)NULL)))
        (*prhs)->magic = (unsigned int)0x3F109965;

    }
    while((_Bool)0);

  __CPROVER_DUMP_L9:
    ;
    do
      if(*prhs == ((struct vex_rhs *)NULL))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        VAS_Fail("vxp_expr_regex", "vxp_parse.c", 255, "(*prhs) != 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    (*prhs)->type = (enum vex_rhs_e)VEX_REGEX;
    (*prhs)->val_string=strdup(vxp->t->dec);
    (*prhs)->val_regex=VRE_compile(vxp->t->dec, vxp->vre_options, &errptr, &erroff);
    if((*prhs)->val_regex == ((struct vre *)NULL))
    {

    __CPROVER_DUMP_L11:
      ;
      do
        if(errptr == ((const char *)NULL))
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          VAS_Fail("vxp_expr_regex", "vxp_parse.c", 261, "(errptr) != 0", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
        }

      while((_Bool)0);
      VSB_printf(vxp->sb, "Regular expression error: %s ", errptr);
      vxp_ErrWhere(vxp, vxp->t, erroff);
    }

    else
      vxp_NextToken(vxp);
  }
}

// vxp_expr_str
// file vxp_parse.c line 217
static void vxp_expr_str(struct vxp *vxp, struct vex_rhs **prhs)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(prhs == ((struct vex_rhs **)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_expr_str", "vxp_parse.c", 220, "(prhs) != 0", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  do
    if(!(*prhs == ((struct vex_rhs *)NULL)))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vxp_expr_str", "vxp_parse.c", 221, "(*prhs) == 0", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  if(!(vxp->t->tok == 140u))
  {
    VSB_printf(vxp->sb, "Expected string got '%.*s' ", (signed int)(vxp->t->e - vxp->t->b), vxp->t->b);
    vxp_ErrWhere(vxp, vxp->t, -1);
  }

  else
  {

  __CPROVER_DUMP_L5:
    ;
    do
      if(vxp->t->dec == ((char *)NULL))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        VAS_Fail("vxp_expr_str", "vxp_parse.c", 227, "(vxp->t->dec) != 0", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    do
    {
      void *return_value_calloc$4;
      return_value_calloc$4=calloc(sizeof(struct vex_rhs) /*48ul*/ , (unsigned long int)1);
      *prhs = (struct vex_rhs *)return_value_calloc$4;
      if(!(*prhs == ((struct vex_rhs *)NULL)))
        (*prhs)->magic = (unsigned int)0x3F109965;

    }
    while((_Bool)0);

  __CPROVER_DUMP_L9:
    ;
    do
      if(*prhs == ((struct vex_rhs *)NULL))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        VAS_Fail("vxp_expr_str", "vxp_parse.c", 229, "(*prhs) != 0", *return_value___errno_location$5, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    (*prhs)->type = (enum vex_rhs_e)VEX_STRING;
    (*prhs)->val_string=strdup(vxp->t->dec);

  __CPROVER_DUMP_L11:
    ;
    do
      if((*prhs)->val_string == ((char *)NULL))
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        VAS_Fail("vxp_expr_str", "vxp_parse.c", 232, "((*prhs)->val_string) != 0", *return_value___errno_location$6, (enum vas_e)VAS_ASSERT);
      }

    while((_Bool)0);
    (*prhs)->val_stringlen=strlen((*prhs)->val_string);
    vxp_NextToken(vxp);
  }
}

// vxp_fixed_token
// file vxp.h line 44
unsigned int vxp_fixed_token(const char *p, const char **q)
{
  const unsigned short int **return_value___ctype_b_loc$1;
  _Bool tmp_if_expr$3;
  const unsigned short int **return_value___ctype_b_loc$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  signed int tmp_if_expr$17;
  const unsigned short int **return_value___ctype_b_loc$9;
  _Bool tmp_if_expr$11;
  const unsigned short int **return_value___ctype_b_loc$10;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$16;
  const unsigned short int **return_value___ctype_b_loc$18;
  _Bool tmp_if_expr$20;
  const unsigned short int **return_value___ctype_b_loc$19;
  _Bool tmp_if_expr$21;
  _Bool tmp_if_expr$22;
  _Bool tmp_if_expr$23;
  _Bool tmp_if_expr$24;
  _Bool tmp_if_expr$25;
  signed int tmp_if_expr$34;
  const unsigned short int **return_value___ctype_b_loc$26;
  _Bool tmp_if_expr$28;
  const unsigned short int **return_value___ctype_b_loc$27;
  _Bool tmp_if_expr$29;
  _Bool tmp_if_expr$30;
  _Bool tmp_if_expr$31;
  _Bool tmp_if_expr$32;
  _Bool tmp_if_expr$33;
  const unsigned short int **return_value___ctype_b_loc$35;
  _Bool tmp_if_expr$37;
  const unsigned short int **return_value___ctype_b_loc$36;
  _Bool tmp_if_expr$38;
  _Bool tmp_if_expr$39;
  _Bool tmp_if_expr$40;
  _Bool tmp_if_expr$41;
  _Bool tmp_if_expr$42;
  signed int tmp_if_expr$51;
  const unsigned short int **return_value___ctype_b_loc$43;
  _Bool tmp_if_expr$45;
  const unsigned short int **return_value___ctype_b_loc$44;
  _Bool tmp_if_expr$46;
  _Bool tmp_if_expr$47;
  _Bool tmp_if_expr$48;
  _Bool tmp_if_expr$49;
  _Bool tmp_if_expr$50;
  const unsigned short int **return_value___ctype_b_loc$52;
  _Bool tmp_if_expr$54;
  const unsigned short int **return_value___ctype_b_loc$53;
  _Bool tmp_if_expr$55;
  _Bool tmp_if_expr$56;
  _Bool tmp_if_expr$57;
  _Bool tmp_if_expr$58;
  _Bool tmp_if_expr$59;
  signed int tmp_if_expr$68;
  const unsigned short int **return_value___ctype_b_loc$60;
  _Bool tmp_if_expr$62;
  const unsigned short int **return_value___ctype_b_loc$61;
  _Bool tmp_if_expr$63;
  _Bool tmp_if_expr$64;
  _Bool tmp_if_expr$65;
  _Bool tmp_if_expr$66;
  _Bool tmp_if_expr$67;
  const unsigned short int **return_value___ctype_b_loc$69;
  _Bool tmp_if_expr$71;
  const unsigned short int **return_value___ctype_b_loc$70;
  _Bool tmp_if_expr$72;
  _Bool tmp_if_expr$73;
  _Bool tmp_if_expr$74;
  _Bool tmp_if_expr$75;
  _Bool tmp_if_expr$76;
  signed int tmp_if_expr$85;
  const unsigned short int **return_value___ctype_b_loc$77;
  _Bool tmp_if_expr$79;
  const unsigned short int **return_value___ctype_b_loc$78;
  _Bool tmp_if_expr$80;
  _Bool tmp_if_expr$81;
  _Bool tmp_if_expr$82;
  _Bool tmp_if_expr$83;
  _Bool tmp_if_expr$84;
  const unsigned short int **return_value___ctype_b_loc$86;
  _Bool tmp_if_expr$88;
  const unsigned short int **return_value___ctype_b_loc$87;
  _Bool tmp_if_expr$89;
  _Bool tmp_if_expr$90;
  _Bool tmp_if_expr$91;
  _Bool tmp_if_expr$92;
  _Bool tmp_if_expr$93;
  signed int tmp_if_expr$102;
  const unsigned short int **return_value___ctype_b_loc$94;
  _Bool tmp_if_expr$96;
  const unsigned short int **return_value___ctype_b_loc$95;
  _Bool tmp_if_expr$97;
  _Bool tmp_if_expr$98;
  _Bool tmp_if_expr$99;
  _Bool tmp_if_expr$100;
  _Bool tmp_if_expr$101;
  const unsigned short int **return_value___ctype_b_loc$103;
  _Bool tmp_if_expr$105;
  const unsigned short int **return_value___ctype_b_loc$104;
  _Bool tmp_if_expr$106;
  _Bool tmp_if_expr$107;
  _Bool tmp_if_expr$108;
  _Bool tmp_if_expr$109;
  _Bool tmp_if_expr$110;
  signed int tmp_if_expr$119;
  const unsigned short int **return_value___ctype_b_loc$111;
  _Bool tmp_if_expr$113;
  const unsigned short int **return_value___ctype_b_loc$112;
  _Bool tmp_if_expr$114;
  _Bool tmp_if_expr$115;
  _Bool tmp_if_expr$116;
  _Bool tmp_if_expr$117;
  _Bool tmp_if_expr$118;
  const unsigned short int **return_value___ctype_b_loc$120;
  _Bool tmp_if_expr$122;
  const unsigned short int **return_value___ctype_b_loc$121;
  _Bool tmp_if_expr$123;
  _Bool tmp_if_expr$124;
  _Bool tmp_if_expr$125;
  _Bool tmp_if_expr$126;
  _Bool tmp_if_expr$127;
  signed int tmp_if_expr$136;
  const unsigned short int **return_value___ctype_b_loc$128;
  _Bool tmp_if_expr$130;
  const unsigned short int **return_value___ctype_b_loc$129;
  _Bool tmp_if_expr$131;
  _Bool tmp_if_expr$132;
  _Bool tmp_if_expr$133;
  _Bool tmp_if_expr$134;
  _Bool tmp_if_expr$135;
  const unsigned short int **return_value___ctype_b_loc$137;
  _Bool tmp_if_expr$139;
  const unsigned short int **return_value___ctype_b_loc$138;
  _Bool tmp_if_expr$140;
  _Bool tmp_if_expr$141;
  _Bool tmp_if_expr$142;
  _Bool tmp_if_expr$143;
  _Bool tmp_if_expr$144;
  signed int tmp_if_expr$153;
  const unsigned short int **return_value___ctype_b_loc$145;
  _Bool tmp_if_expr$147;
  const unsigned short int **return_value___ctype_b_loc$146;
  _Bool tmp_if_expr$148;
  _Bool tmp_if_expr$149;
  _Bool tmp_if_expr$150;
  _Bool tmp_if_expr$151;
  _Bool tmp_if_expr$152;
  const unsigned short int **return_value___ctype_b_loc$154;
  _Bool tmp_if_expr$156;
  const unsigned short int **return_value___ctype_b_loc$155;
  _Bool tmp_if_expr$157;
  _Bool tmp_if_expr$158;
  _Bool tmp_if_expr$159;
  _Bool tmp_if_expr$160;
  _Bool tmp_if_expr$161;
  signed int tmp_if_expr$170;
  const unsigned short int **return_value___ctype_b_loc$162;
  _Bool tmp_if_expr$164;
  const unsigned short int **return_value___ctype_b_loc$163;
  _Bool tmp_if_expr$165;
  _Bool tmp_if_expr$166;
  _Bool tmp_if_expr$167;
  _Bool tmp_if_expr$168;
  _Bool tmp_if_expr$169;
  const unsigned short int **return_value___ctype_b_loc$171;
  _Bool tmp_if_expr$173;
  const unsigned short int **return_value___ctype_b_loc$172;
  _Bool tmp_if_expr$174;
  _Bool tmp_if_expr$175;
  _Bool tmp_if_expr$176;
  _Bool tmp_if_expr$177;
  _Bool tmp_if_expr$178;
  signed int tmp_if_expr$187;
  const unsigned short int **return_value___ctype_b_loc$179;
  _Bool tmp_if_expr$181;
  const unsigned short int **return_value___ctype_b_loc$180;
  _Bool tmp_if_expr$182;
  _Bool tmp_if_expr$183;
  _Bool tmp_if_expr$184;
  _Bool tmp_if_expr$185;
  _Bool tmp_if_expr$186;
  const unsigned short int **return_value___ctype_b_loc$188;
  _Bool tmp_if_expr$190;
  const unsigned short int **return_value___ctype_b_loc$189;
  _Bool tmp_if_expr$191;
  _Bool tmp_if_expr$192;
  _Bool tmp_if_expr$193;
  _Bool tmp_if_expr$194;
  _Bool tmp_if_expr$195;
  signed int tmp_if_expr$204;
  const unsigned short int **return_value___ctype_b_loc$196;
  _Bool tmp_if_expr$198;
  const unsigned short int **return_value___ctype_b_loc$197;
  _Bool tmp_if_expr$199;
  _Bool tmp_if_expr$200;
  _Bool tmp_if_expr$201;
  _Bool tmp_if_expr$202;
  _Bool tmp_if_expr$203;
  const unsigned short int **return_value___ctype_b_loc$205;
  _Bool tmp_if_expr$207;
  const unsigned short int **return_value___ctype_b_loc$206;
  _Bool tmp_if_expr$208;
  _Bool tmp_if_expr$209;
  _Bool tmp_if_expr$210;
  _Bool tmp_if_expr$211;
  _Bool tmp_if_expr$212;
  signed int tmp_if_expr$221;
  const unsigned short int **return_value___ctype_b_loc$213;
  _Bool tmp_if_expr$215;
  const unsigned short int **return_value___ctype_b_loc$214;
  _Bool tmp_if_expr$216;
  _Bool tmp_if_expr$217;
  _Bool tmp_if_expr$218;
  _Bool tmp_if_expr$219;
  _Bool tmp_if_expr$220;
  const unsigned short int **return_value___ctype_b_loc$222;
  _Bool tmp_if_expr$224;
  const unsigned short int **return_value___ctype_b_loc$223;
  _Bool tmp_if_expr$225;
  _Bool tmp_if_expr$226;
  _Bool tmp_if_expr$227;
  _Bool tmp_if_expr$228;
  _Bool tmp_if_expr$229;
  signed int tmp_if_expr$238;
  const unsigned short int **return_value___ctype_b_loc$230;
  _Bool tmp_if_expr$232;
  const unsigned short int **return_value___ctype_b_loc$231;
  _Bool tmp_if_expr$233;
  _Bool tmp_if_expr$234;
  _Bool tmp_if_expr$235;
  _Bool tmp_if_expr$236;
  _Bool tmp_if_expr$237;
  const unsigned short int **return_value___ctype_b_loc$239;
  _Bool tmp_if_expr$241;
  const unsigned short int **return_value___ctype_b_loc$240;
  _Bool tmp_if_expr$242;
  _Bool tmp_if_expr$243;
  _Bool tmp_if_expr$244;
  _Bool tmp_if_expr$245;
  _Bool tmp_if_expr$246;
  signed int tmp_if_expr$255;
  const unsigned short int **return_value___ctype_b_loc$247;
  _Bool tmp_if_expr$249;
  const unsigned short int **return_value___ctype_b_loc$248;
  _Bool tmp_if_expr$250;
  _Bool tmp_if_expr$251;
  _Bool tmp_if_expr$252;
  _Bool tmp_if_expr$253;
  _Bool tmp_if_expr$254;
  const unsigned short int **return_value___ctype_b_loc$256;
  _Bool tmp_if_expr$258;
  const unsigned short int **return_value___ctype_b_loc$257;
  _Bool tmp_if_expr$259;
  _Bool tmp_if_expr$260;
  _Bool tmp_if_expr$261;
  _Bool tmp_if_expr$262;
  _Bool tmp_if_expr$263;
  signed int tmp_if_expr$272;
  const unsigned short int **return_value___ctype_b_loc$264;
  _Bool tmp_if_expr$266;
  const unsigned short int **return_value___ctype_b_loc$265;
  _Bool tmp_if_expr$267;
  _Bool tmp_if_expr$268;
  _Bool tmp_if_expr$269;
  _Bool tmp_if_expr$270;
  _Bool tmp_if_expr$271;
  const unsigned short int **return_value___ctype_b_loc$273;
  _Bool tmp_if_expr$275;
  const unsigned short int **return_value___ctype_b_loc$274;
  _Bool tmp_if_expr$276;
  _Bool tmp_if_expr$277;
  _Bool tmp_if_expr$278;
  _Bool tmp_if_expr$279;
  _Bool tmp_if_expr$280;
  signed int tmp_if_expr$289;
  const unsigned short int **return_value___ctype_b_loc$281;
  _Bool tmp_if_expr$283;
  const unsigned short int **return_value___ctype_b_loc$282;
  _Bool tmp_if_expr$284;
  _Bool tmp_if_expr$285;
  _Bool tmp_if_expr$286;
  _Bool tmp_if_expr$287;
  _Bool tmp_if_expr$288;
  const unsigned short int **return_value___ctype_b_loc$290;
  _Bool tmp_if_expr$292;
  const unsigned short int **return_value___ctype_b_loc$291;
  _Bool tmp_if_expr$293;
  _Bool tmp_if_expr$294;
  _Bool tmp_if_expr$295;
  _Bool tmp_if_expr$296;
  _Bool tmp_if_expr$297;
  signed int tmp_if_expr$306;
  const unsigned short int **return_value___ctype_b_loc$298;
  _Bool tmp_if_expr$300;
  const unsigned short int **return_value___ctype_b_loc$299;
  _Bool tmp_if_expr$301;
  _Bool tmp_if_expr$302;
  _Bool tmp_if_expr$303;
  _Bool tmp_if_expr$304;
  _Bool tmp_if_expr$305;
  const unsigned short int **return_value___ctype_b_loc$307;
  _Bool tmp_if_expr$309;
  const unsigned short int **return_value___ctype_b_loc$308;
  _Bool tmp_if_expr$310;
  _Bool tmp_if_expr$311;
  _Bool tmp_if_expr$312;
  _Bool tmp_if_expr$313;
  _Bool tmp_if_expr$314;
  signed int tmp_if_expr$323;
  const unsigned short int **return_value___ctype_b_loc$315;
  _Bool tmp_if_expr$317;
  const unsigned short int **return_value___ctype_b_loc$316;
  _Bool tmp_if_expr$318;
  _Bool tmp_if_expr$319;
  _Bool tmp_if_expr$320;
  _Bool tmp_if_expr$321;
  _Bool tmp_if_expr$322;
  const unsigned short int **return_value___ctype_b_loc$324;
  _Bool tmp_if_expr$326;
  const unsigned short int **return_value___ctype_b_loc$325;
  _Bool tmp_if_expr$327;
  _Bool tmp_if_expr$328;
  _Bool tmp_if_expr$329;
  _Bool tmp_if_expr$330;
  _Bool tmp_if_expr$331;
  signed int tmp_if_expr$340;
  const unsigned short int **return_value___ctype_b_loc$332;
  _Bool tmp_if_expr$334;
  const unsigned short int **return_value___ctype_b_loc$333;
  _Bool tmp_if_expr$335;
  _Bool tmp_if_expr$336;
  _Bool tmp_if_expr$337;
  _Bool tmp_if_expr$338;
  _Bool tmp_if_expr$339;
  const unsigned short int **return_value___ctype_b_loc$341;
  _Bool tmp_if_expr$343;
  const unsigned short int **return_value___ctype_b_loc$342;
  _Bool tmp_if_expr$344;
  _Bool tmp_if_expr$345;
  _Bool tmp_if_expr$346;
  _Bool tmp_if_expr$347;
  _Bool tmp_if_expr$348;
  signed int tmp_if_expr$357;
  const unsigned short int **return_value___ctype_b_loc$349;
  _Bool tmp_if_expr$351;
  const unsigned short int **return_value___ctype_b_loc$350;
  _Bool tmp_if_expr$352;
  _Bool tmp_if_expr$353;
  _Bool tmp_if_expr$354;
  _Bool tmp_if_expr$355;
  _Bool tmp_if_expr$356;
  switch((signed int)p[(signed long int)0])
  {
    case 33:
    {
      if((signed int)p[1l] == 61)
      {
        return_value___ctype_b_loc$1=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$3 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$2=__ctype_b_loc();
          tmp_if_expr$3 = ((signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$3)
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$4)
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$7)
          tmp_if_expr$8 = (_Bool)1;

        else
          tmp_if_expr$8 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$8)
        {
          return_value___ctype_b_loc$9=__ctype_b_loc();
          if(!((1024 & (signed int)(*return_value___ctype_b_loc$9)[(signed long int)(signed int)p[2l]]) == 0))
            tmp_if_expr$11 = (_Bool)1;

          else
          {
            return_value___ctype_b_loc$10=__ctype_b_loc();
            tmp_if_expr$11 = ((signed int)(*return_value___ctype_b_loc$10)[(signed long int)(signed int)p[(signed long int)2]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$11)
            tmp_if_expr$12 = (_Bool)1;

          else
            tmp_if_expr$12 = (signed int)p[(signed long int)2] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$12)
            tmp_if_expr$13 = (_Bool)1;

          else
            tmp_if_expr$13 = (signed int)p[(signed long int)2] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$13)
            tmp_if_expr$14 = (_Bool)1;

          else
            tmp_if_expr$14 = (signed int)p[(signed long int)2] == 43 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$14)
            tmp_if_expr$15 = (_Bool)1;

          else
            tmp_if_expr$15 = (signed int)p[(signed long int)2] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$15)
            tmp_if_expr$16 = (_Bool)1;

          else
            tmp_if_expr$16 = (signed int)p[(signed long int)2] == 42 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$17 = (signed int)!tmp_if_expr$16;
        }

        else
          tmp_if_expr$17 = 1;
        if(!(tmp_if_expr$17 == 0))
        {
          *q = p + (signed long int)2;
          return (unsigned int)133;
        }

      }

      if((signed int)p[1l] == 126)
      {
        return_value___ctype_b_loc$18=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$18)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$20 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$19=__ctype_b_loc();
          tmp_if_expr$20 = ((signed int)(*return_value___ctype_b_loc$19)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$20)
          tmp_if_expr$21 = (_Bool)1;

        else
          tmp_if_expr$21 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$21)
          tmp_if_expr$22 = (_Bool)1;

        else
          tmp_if_expr$22 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$22)
          tmp_if_expr$23 = (_Bool)1;

        else
          tmp_if_expr$23 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$23)
          tmp_if_expr$24 = (_Bool)1;

        else
          tmp_if_expr$24 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$24)
          tmp_if_expr$25 = (_Bool)1;

        else
          tmp_if_expr$25 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$25)
        {
          return_value___ctype_b_loc$26=__ctype_b_loc();
          if(!((1024 & (signed int)(*return_value___ctype_b_loc$26)[(signed long int)(signed int)p[2l]]) == 0))
            tmp_if_expr$28 = (_Bool)1;

          else
          {
            return_value___ctype_b_loc$27=__ctype_b_loc();
            tmp_if_expr$28 = ((signed int)(*return_value___ctype_b_loc$27)[(signed long int)(signed int)p[(signed long int)2]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$28)
            tmp_if_expr$29 = (_Bool)1;

          else
            tmp_if_expr$29 = (signed int)p[(signed long int)2] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$29)
            tmp_if_expr$30 = (_Bool)1;

          else
            tmp_if_expr$30 = (signed int)p[(signed long int)2] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$30)
            tmp_if_expr$31 = (_Bool)1;

          else
            tmp_if_expr$31 = (signed int)p[(signed long int)2] == 43 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$31)
            tmp_if_expr$32 = (_Bool)1;

          else
            tmp_if_expr$32 = (signed int)p[(signed long int)2] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$32)
            tmp_if_expr$33 = (_Bool)1;

          else
            tmp_if_expr$33 = (signed int)p[(signed long int)2] == 42 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$34 = (signed int)!tmp_if_expr$33;
        }

        else
          tmp_if_expr$34 = 1;
        if(!(tmp_if_expr$34 == 0))
        {
          *q = p + (signed long int)2;
          return (unsigned int)134;
        }

      }

      return (unsigned int)0;
    }
    case 40:
    {
      return_value___ctype_b_loc$35=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc$35)[(signed long int)(signed int)*p]) == 0))
        tmp_if_expr$37 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc$36=__ctype_b_loc();
        tmp_if_expr$37 = ((signed int)(*return_value___ctype_b_loc$36)[(signed long int)(signed int)p[(signed long int)0]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$37)
        tmp_if_expr$38 = (_Bool)1;

      else
        tmp_if_expr$38 = (signed int)p[(signed long int)0] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$38)
        tmp_if_expr$39 = (_Bool)1;

      else
        tmp_if_expr$39 = (signed int)p[(signed long int)0] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$39)
        tmp_if_expr$40 = (_Bool)1;

      else
        tmp_if_expr$40 = (signed int)p[(signed long int)0] == 43 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$40)
        tmp_if_expr$41 = (_Bool)1;

      else
        tmp_if_expr$41 = (signed int)p[(signed long int)0] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$41)
        tmp_if_expr$42 = (_Bool)1;

      else
        tmp_if_expr$42 = (signed int)p[(signed long int)0] == 42 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$42)
      {
        return_value___ctype_b_loc$43=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$43)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$45 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$44=__ctype_b_loc();
          tmp_if_expr$45 = ((signed int)(*return_value___ctype_b_loc$44)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$45)
          tmp_if_expr$46 = (_Bool)1;

        else
          tmp_if_expr$46 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$46)
          tmp_if_expr$47 = (_Bool)1;

        else
          tmp_if_expr$47 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$47)
          tmp_if_expr$48 = (_Bool)1;

        else
          tmp_if_expr$48 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$48)
          tmp_if_expr$49 = (_Bool)1;

        else
          tmp_if_expr$49 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$49)
          tmp_if_expr$50 = (_Bool)1;

        else
          tmp_if_expr$50 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$51 = (signed int)!tmp_if_expr$50;
      }

      else
        tmp_if_expr$51 = 1;
      if(!(tmp_if_expr$51 == 0))
      {
        *q = p + (signed long int)1;
        return (unsigned int)40;
      }

      return (unsigned int)0;
    }
    case 41:
    {
      return_value___ctype_b_loc$52=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc$52)[(signed long int)(signed int)*p]) == 0))
        tmp_if_expr$54 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc$53=__ctype_b_loc();
        tmp_if_expr$54 = ((signed int)(*return_value___ctype_b_loc$53)[(signed long int)(signed int)p[(signed long int)0]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$54)
        tmp_if_expr$55 = (_Bool)1;

      else
        tmp_if_expr$55 = (signed int)p[(signed long int)0] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$55)
        tmp_if_expr$56 = (_Bool)1;

      else
        tmp_if_expr$56 = (signed int)p[(signed long int)0] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$56)
        tmp_if_expr$57 = (_Bool)1;

      else
        tmp_if_expr$57 = (signed int)p[(signed long int)0] == 43 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$57)
        tmp_if_expr$58 = (_Bool)1;

      else
        tmp_if_expr$58 = (signed int)p[(signed long int)0] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$58)
        tmp_if_expr$59 = (_Bool)1;

      else
        tmp_if_expr$59 = (signed int)p[(signed long int)0] == 42 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$59)
      {
        return_value___ctype_b_loc$60=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$60)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$62 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$61=__ctype_b_loc();
          tmp_if_expr$62 = ((signed int)(*return_value___ctype_b_loc$61)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$62)
          tmp_if_expr$63 = (_Bool)1;

        else
          tmp_if_expr$63 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$63)
          tmp_if_expr$64 = (_Bool)1;

        else
          tmp_if_expr$64 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$64)
          tmp_if_expr$65 = (_Bool)1;

        else
          tmp_if_expr$65 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$65)
          tmp_if_expr$66 = (_Bool)1;

        else
          tmp_if_expr$66 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$66)
          tmp_if_expr$67 = (_Bool)1;

        else
          tmp_if_expr$67 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$68 = (signed int)!tmp_if_expr$67;
      }

      else
        tmp_if_expr$68 = 1;
      if(!(tmp_if_expr$68 == 0))
      {
        *q = p + (signed long int)1;
        return (unsigned int)41;
      }

      return (unsigned int)0;
    }
    case 44:
    {
      return_value___ctype_b_loc$69=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc$69)[(signed long int)(signed int)*p]) == 0))
        tmp_if_expr$71 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc$70=__ctype_b_loc();
        tmp_if_expr$71 = ((signed int)(*return_value___ctype_b_loc$70)[(signed long int)(signed int)p[(signed long int)0]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$71)
        tmp_if_expr$72 = (_Bool)1;

      else
        tmp_if_expr$72 = (signed int)p[(signed long int)0] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$72)
        tmp_if_expr$73 = (_Bool)1;

      else
        tmp_if_expr$73 = (signed int)p[(signed long int)0] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$73)
        tmp_if_expr$74 = (_Bool)1;

      else
        tmp_if_expr$74 = (signed int)p[(signed long int)0] == 43 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$74)
        tmp_if_expr$75 = (_Bool)1;

      else
        tmp_if_expr$75 = (signed int)p[(signed long int)0] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$75)
        tmp_if_expr$76 = (_Bool)1;

      else
        tmp_if_expr$76 = (signed int)p[(signed long int)0] == 42 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$76)
      {
        return_value___ctype_b_loc$77=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$77)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$79 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$78=__ctype_b_loc();
          tmp_if_expr$79 = ((signed int)(*return_value___ctype_b_loc$78)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$79)
          tmp_if_expr$80 = (_Bool)1;

        else
          tmp_if_expr$80 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$80)
          tmp_if_expr$81 = (_Bool)1;

        else
          tmp_if_expr$81 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$81)
          tmp_if_expr$82 = (_Bool)1;

        else
          tmp_if_expr$82 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$82)
          tmp_if_expr$83 = (_Bool)1;

        else
          tmp_if_expr$83 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$83)
          tmp_if_expr$84 = (_Bool)1;

        else
          tmp_if_expr$84 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$85 = (signed int)!tmp_if_expr$84;
      }

      else
        tmp_if_expr$85 = 1;
      if(!(tmp_if_expr$85 == 0))
      {
        *q = p + (signed long int)1;
        return (unsigned int)44;
      }

      return (unsigned int)0;
    }
    case 58:
    {
      return_value___ctype_b_loc$86=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc$86)[(signed long int)(signed int)*p]) == 0))
        tmp_if_expr$88 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc$87=__ctype_b_loc();
        tmp_if_expr$88 = ((signed int)(*return_value___ctype_b_loc$87)[(signed long int)(signed int)p[(signed long int)0]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$88)
        tmp_if_expr$89 = (_Bool)1;

      else
        tmp_if_expr$89 = (signed int)p[(signed long int)0] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$89)
        tmp_if_expr$90 = (_Bool)1;

      else
        tmp_if_expr$90 = (signed int)p[(signed long int)0] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$90)
        tmp_if_expr$91 = (_Bool)1;

      else
        tmp_if_expr$91 = (signed int)p[(signed long int)0] == 43 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$91)
        tmp_if_expr$92 = (_Bool)1;

      else
        tmp_if_expr$92 = (signed int)p[(signed long int)0] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$92)
        tmp_if_expr$93 = (_Bool)1;

      else
        tmp_if_expr$93 = (signed int)p[(signed long int)0] == 42 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$93)
      {
        return_value___ctype_b_loc$94=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$94)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$96 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$95=__ctype_b_loc();
          tmp_if_expr$96 = ((signed int)(*return_value___ctype_b_loc$95)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$96)
          tmp_if_expr$97 = (_Bool)1;

        else
          tmp_if_expr$97 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$97)
          tmp_if_expr$98 = (_Bool)1;

        else
          tmp_if_expr$98 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$98)
          tmp_if_expr$99 = (_Bool)1;

        else
          tmp_if_expr$99 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$99)
          tmp_if_expr$100 = (_Bool)1;

        else
          tmp_if_expr$100 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$100)
          tmp_if_expr$101 = (_Bool)1;

        else
          tmp_if_expr$101 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$102 = (signed int)!tmp_if_expr$101;
      }

      else
        tmp_if_expr$102 = 1;
      if(!(tmp_if_expr$102 == 0))
      {
        *q = p + (signed long int)1;
        return (unsigned int)58;
      }

      return (unsigned int)0;
    }
    case 60:
    {
      if((signed int)p[1l] == 61)
      {
        return_value___ctype_b_loc$103=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$103)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$105 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$104=__ctype_b_loc();
          tmp_if_expr$105 = ((signed int)(*return_value___ctype_b_loc$104)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$105)
          tmp_if_expr$106 = (_Bool)1;

        else
          tmp_if_expr$106 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$106)
          tmp_if_expr$107 = (_Bool)1;

        else
          tmp_if_expr$107 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$107)
          tmp_if_expr$108 = (_Bool)1;

        else
          tmp_if_expr$108 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$108)
          tmp_if_expr$109 = (_Bool)1;

        else
          tmp_if_expr$109 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$109)
          tmp_if_expr$110 = (_Bool)1;

        else
          tmp_if_expr$110 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$110)
        {
          return_value___ctype_b_loc$111=__ctype_b_loc();
          if(!((1024 & (signed int)(*return_value___ctype_b_loc$111)[(signed long int)(signed int)p[2l]]) == 0))
            tmp_if_expr$113 = (_Bool)1;

          else
          {
            return_value___ctype_b_loc$112=__ctype_b_loc();
            tmp_if_expr$113 = ((signed int)(*return_value___ctype_b_loc$112)[(signed long int)(signed int)p[(signed long int)2]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$113)
            tmp_if_expr$114 = (_Bool)1;

          else
            tmp_if_expr$114 = (signed int)p[(signed long int)2] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$114)
            tmp_if_expr$115 = (_Bool)1;

          else
            tmp_if_expr$115 = (signed int)p[(signed long int)2] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$115)
            tmp_if_expr$116 = (_Bool)1;

          else
            tmp_if_expr$116 = (signed int)p[(signed long int)2] == 43 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$116)
            tmp_if_expr$117 = (_Bool)1;

          else
            tmp_if_expr$117 = (signed int)p[(signed long int)2] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$117)
            tmp_if_expr$118 = (_Bool)1;

          else
            tmp_if_expr$118 = (signed int)p[(signed long int)2] == 42 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$119 = (signed int)!tmp_if_expr$118;
        }

        else
          tmp_if_expr$119 = 1;
        if(!(tmp_if_expr$119 == 0))
        {
          *q = p + (signed long int)2;
          return (unsigned int)132;
        }

      }

      return_value___ctype_b_loc$120=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc$120)[(signed long int)(signed int)*p]) == 0))
        tmp_if_expr$122 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc$121=__ctype_b_loc();
        tmp_if_expr$122 = ((signed int)(*return_value___ctype_b_loc$121)[(signed long int)(signed int)p[(signed long int)0]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$122)
        tmp_if_expr$123 = (_Bool)1;

      else
        tmp_if_expr$123 = (signed int)p[(signed long int)0] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$123)
        tmp_if_expr$124 = (_Bool)1;

      else
        tmp_if_expr$124 = (signed int)p[(signed long int)0] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$124)
        tmp_if_expr$125 = (_Bool)1;

      else
        tmp_if_expr$125 = (signed int)p[(signed long int)0] == 43 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$125)
        tmp_if_expr$126 = (_Bool)1;

      else
        tmp_if_expr$126 = (signed int)p[(signed long int)0] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$126)
        tmp_if_expr$127 = (_Bool)1;

      else
        tmp_if_expr$127 = (signed int)p[(signed long int)0] == 42 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$127)
      {
        return_value___ctype_b_loc$128=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$128)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$130 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$129=__ctype_b_loc();
          tmp_if_expr$130 = ((signed int)(*return_value___ctype_b_loc$129)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$130)
          tmp_if_expr$131 = (_Bool)1;

        else
          tmp_if_expr$131 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$131)
          tmp_if_expr$132 = (_Bool)1;

        else
          tmp_if_expr$132 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$132)
          tmp_if_expr$133 = (_Bool)1;

        else
          tmp_if_expr$133 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$133)
          tmp_if_expr$134 = (_Bool)1;

        else
          tmp_if_expr$134 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$134)
          tmp_if_expr$135 = (_Bool)1;

        else
          tmp_if_expr$135 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$136 = (signed int)!tmp_if_expr$135;
      }

      else
        tmp_if_expr$136 = 1;
      if(!(tmp_if_expr$136 == 0))
      {
        *q = p + (signed long int)1;
        return (unsigned int)60;
      }

      return (unsigned int)0;
    }
    case 61:
    {
      if((signed int)p[1l] == 61)
      {
        return_value___ctype_b_loc$137=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$137)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$139 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$138=__ctype_b_loc();
          tmp_if_expr$139 = ((signed int)(*return_value___ctype_b_loc$138)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$139)
          tmp_if_expr$140 = (_Bool)1;

        else
          tmp_if_expr$140 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$140)
          tmp_if_expr$141 = (_Bool)1;

        else
          tmp_if_expr$141 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$141)
          tmp_if_expr$142 = (_Bool)1;

        else
          tmp_if_expr$142 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$142)
          tmp_if_expr$143 = (_Bool)1;

        else
          tmp_if_expr$143 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$143)
          tmp_if_expr$144 = (_Bool)1;

        else
          tmp_if_expr$144 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$144)
        {
          return_value___ctype_b_loc$145=__ctype_b_loc();
          if(!((1024 & (signed int)(*return_value___ctype_b_loc$145)[(signed long int)(signed int)p[2l]]) == 0))
            tmp_if_expr$147 = (_Bool)1;

          else
          {
            return_value___ctype_b_loc$146=__ctype_b_loc();
            tmp_if_expr$147 = ((signed int)(*return_value___ctype_b_loc$146)[(signed long int)(signed int)p[(signed long int)2]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$147)
            tmp_if_expr$148 = (_Bool)1;

          else
            tmp_if_expr$148 = (signed int)p[(signed long int)2] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$148)
            tmp_if_expr$149 = (_Bool)1;

          else
            tmp_if_expr$149 = (signed int)p[(signed long int)2] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$149)
            tmp_if_expr$150 = (_Bool)1;

          else
            tmp_if_expr$150 = (signed int)p[(signed long int)2] == 43 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$150)
            tmp_if_expr$151 = (_Bool)1;

          else
            tmp_if_expr$151 = (signed int)p[(signed long int)2] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$151)
            tmp_if_expr$152 = (_Bool)1;

          else
            tmp_if_expr$152 = (signed int)p[(signed long int)2] == 42 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$153 = (signed int)!tmp_if_expr$152;
        }

        else
          tmp_if_expr$153 = 1;
        if(!(tmp_if_expr$153 == 0))
        {
          *q = p + (signed long int)2;
          return (unsigned int)130;
        }

      }

      return (unsigned int)0;
    }
    case 62:
    {
      if((signed int)p[1l] == 61)
      {
        return_value___ctype_b_loc$154=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$154)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$156 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$155=__ctype_b_loc();
          tmp_if_expr$156 = ((signed int)(*return_value___ctype_b_loc$155)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$156)
          tmp_if_expr$157 = (_Bool)1;

        else
          tmp_if_expr$157 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$157)
          tmp_if_expr$158 = (_Bool)1;

        else
          tmp_if_expr$158 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$158)
          tmp_if_expr$159 = (_Bool)1;

        else
          tmp_if_expr$159 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$159)
          tmp_if_expr$160 = (_Bool)1;

        else
          tmp_if_expr$160 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$160)
          tmp_if_expr$161 = (_Bool)1;

        else
          tmp_if_expr$161 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$161)
        {
          return_value___ctype_b_loc$162=__ctype_b_loc();
          if(!((1024 & (signed int)(*return_value___ctype_b_loc$162)[(signed long int)(signed int)p[2l]]) == 0))
            tmp_if_expr$164 = (_Bool)1;

          else
          {
            return_value___ctype_b_loc$163=__ctype_b_loc();
            tmp_if_expr$164 = ((signed int)(*return_value___ctype_b_loc$163)[(signed long int)(signed int)p[(signed long int)2]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$164)
            tmp_if_expr$165 = (_Bool)1;

          else
            tmp_if_expr$165 = (signed int)p[(signed long int)2] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$165)
            tmp_if_expr$166 = (_Bool)1;

          else
            tmp_if_expr$166 = (signed int)p[(signed long int)2] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$166)
            tmp_if_expr$167 = (_Bool)1;

          else
            tmp_if_expr$167 = (signed int)p[(signed long int)2] == 43 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$167)
            tmp_if_expr$168 = (_Bool)1;

          else
            tmp_if_expr$168 = (signed int)p[(signed long int)2] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$168)
            tmp_if_expr$169 = (_Bool)1;

          else
            tmp_if_expr$169 = (signed int)p[(signed long int)2] == 42 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$170 = (signed int)!tmp_if_expr$169;
        }

        else
          tmp_if_expr$170 = 1;
        if(!(tmp_if_expr$170 == 0))
        {
          *q = p + (signed long int)2;
          return (unsigned int)131;
        }

      }

      return_value___ctype_b_loc$171=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc$171)[(signed long int)(signed int)*p]) == 0))
        tmp_if_expr$173 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc$172=__ctype_b_loc();
        tmp_if_expr$173 = ((signed int)(*return_value___ctype_b_loc$172)[(signed long int)(signed int)p[(signed long int)0]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$173)
        tmp_if_expr$174 = (_Bool)1;

      else
        tmp_if_expr$174 = (signed int)p[(signed long int)0] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$174)
        tmp_if_expr$175 = (_Bool)1;

      else
        tmp_if_expr$175 = (signed int)p[(signed long int)0] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$175)
        tmp_if_expr$176 = (_Bool)1;

      else
        tmp_if_expr$176 = (signed int)p[(signed long int)0] == 43 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$176)
        tmp_if_expr$177 = (_Bool)1;

      else
        tmp_if_expr$177 = (signed int)p[(signed long int)0] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$177)
        tmp_if_expr$178 = (_Bool)1;

      else
        tmp_if_expr$178 = (signed int)p[(signed long int)0] == 42 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$178)
      {
        return_value___ctype_b_loc$179=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$179)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$181 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$180=__ctype_b_loc();
          tmp_if_expr$181 = ((signed int)(*return_value___ctype_b_loc$180)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$181)
          tmp_if_expr$182 = (_Bool)1;

        else
          tmp_if_expr$182 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$182)
          tmp_if_expr$183 = (_Bool)1;

        else
          tmp_if_expr$183 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$183)
          tmp_if_expr$184 = (_Bool)1;

        else
          tmp_if_expr$184 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$184)
          tmp_if_expr$185 = (_Bool)1;

        else
          tmp_if_expr$185 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$185)
          tmp_if_expr$186 = (_Bool)1;

        else
          tmp_if_expr$186 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$187 = (signed int)!tmp_if_expr$186;
      }

      else
        tmp_if_expr$187 = 1;
      if(!(tmp_if_expr$187 == 0))
      {
        *q = p + (signed long int)1;
        return (unsigned int)62;
      }

      return (unsigned int)0;
    }
    case 91:
    {
      return_value___ctype_b_loc$188=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc$188)[(signed long int)(signed int)*p]) == 0))
        tmp_if_expr$190 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc$189=__ctype_b_loc();
        tmp_if_expr$190 = ((signed int)(*return_value___ctype_b_loc$189)[(signed long int)(signed int)p[(signed long int)0]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$190)
        tmp_if_expr$191 = (_Bool)1;

      else
        tmp_if_expr$191 = (signed int)p[(signed long int)0] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$191)
        tmp_if_expr$192 = (_Bool)1;

      else
        tmp_if_expr$192 = (signed int)p[(signed long int)0] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$192)
        tmp_if_expr$193 = (_Bool)1;

      else
        tmp_if_expr$193 = (signed int)p[(signed long int)0] == 43 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$193)
        tmp_if_expr$194 = (_Bool)1;

      else
        tmp_if_expr$194 = (signed int)p[(signed long int)0] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$194)
        tmp_if_expr$195 = (_Bool)1;

      else
        tmp_if_expr$195 = (signed int)p[(signed long int)0] == 42 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$195)
      {
        return_value___ctype_b_loc$196=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$196)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$198 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$197=__ctype_b_loc();
          tmp_if_expr$198 = ((signed int)(*return_value___ctype_b_loc$197)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$198)
          tmp_if_expr$199 = (_Bool)1;

        else
          tmp_if_expr$199 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$199)
          tmp_if_expr$200 = (_Bool)1;

        else
          tmp_if_expr$200 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$200)
          tmp_if_expr$201 = (_Bool)1;

        else
          tmp_if_expr$201 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$201)
          tmp_if_expr$202 = (_Bool)1;

        else
          tmp_if_expr$202 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$202)
          tmp_if_expr$203 = (_Bool)1;

        else
          tmp_if_expr$203 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$204 = (signed int)!tmp_if_expr$203;
      }

      else
        tmp_if_expr$204 = 1;
      if(!(tmp_if_expr$204 == 0))
      {
        *q = p + (signed long int)1;
        return (unsigned int)91;
      }

      return (unsigned int)0;
    }
    case 93:
    {
      return_value___ctype_b_loc$205=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc$205)[(signed long int)(signed int)*p]) == 0))
        tmp_if_expr$207 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc$206=__ctype_b_loc();
        tmp_if_expr$207 = ((signed int)(*return_value___ctype_b_loc$206)[(signed long int)(signed int)p[(signed long int)0]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$207)
        tmp_if_expr$208 = (_Bool)1;

      else
        tmp_if_expr$208 = (signed int)p[(signed long int)0] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$208)
        tmp_if_expr$209 = (_Bool)1;

      else
        tmp_if_expr$209 = (signed int)p[(signed long int)0] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$209)
        tmp_if_expr$210 = (_Bool)1;

      else
        tmp_if_expr$210 = (signed int)p[(signed long int)0] == 43 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$210)
        tmp_if_expr$211 = (_Bool)1;

      else
        tmp_if_expr$211 = (signed int)p[(signed long int)0] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$211)
        tmp_if_expr$212 = (_Bool)1;

      else
        tmp_if_expr$212 = (signed int)p[(signed long int)0] == 42 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$212)
      {
        return_value___ctype_b_loc$213=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$213)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$215 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$214=__ctype_b_loc();
          tmp_if_expr$215 = ((signed int)(*return_value___ctype_b_loc$214)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$215)
          tmp_if_expr$216 = (_Bool)1;

        else
          tmp_if_expr$216 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$216)
          tmp_if_expr$217 = (_Bool)1;

        else
          tmp_if_expr$217 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$217)
          tmp_if_expr$218 = (_Bool)1;

        else
          tmp_if_expr$218 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$218)
          tmp_if_expr$219 = (_Bool)1;

        else
          tmp_if_expr$219 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$219)
          tmp_if_expr$220 = (_Bool)1;

        else
          tmp_if_expr$220 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$221 = (signed int)!tmp_if_expr$220;
      }

      else
        tmp_if_expr$221 = 1;
      if(!(tmp_if_expr$221 == 0))
      {
        *q = p + (signed long int)1;
        return (unsigned int)93;
      }

      return (unsigned int)0;
    }
    case 97:
    {
      if((signed int)p[1l] == 110)
      {
        if((signed int)p[2l] == 100)
        {
          return_value___ctype_b_loc$222=__ctype_b_loc();
          if(!((1024 & (signed int)(*return_value___ctype_b_loc$222)[(signed long int)(signed int)p[2l]]) == 0))
            tmp_if_expr$224 = (_Bool)1;

          else
          {
            return_value___ctype_b_loc$223=__ctype_b_loc();
            tmp_if_expr$224 = ((signed int)(*return_value___ctype_b_loc$223)[(signed long int)(signed int)p[(signed long int)2]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$224)
            tmp_if_expr$225 = (_Bool)1;

          else
            tmp_if_expr$225 = (signed int)p[(signed long int)2] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$225)
            tmp_if_expr$226 = (_Bool)1;

          else
            tmp_if_expr$226 = (signed int)p[(signed long int)2] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$226)
            tmp_if_expr$227 = (_Bool)1;

          else
            tmp_if_expr$227 = (signed int)p[(signed long int)2] == 43 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$227)
            tmp_if_expr$228 = (_Bool)1;

          else
            tmp_if_expr$228 = (signed int)p[(signed long int)2] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$228)
            tmp_if_expr$229 = (_Bool)1;

          else
            tmp_if_expr$229 = (signed int)p[(signed long int)2] == 42 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$229)
          {
            return_value___ctype_b_loc$230=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$230)[(signed long int)(signed int)p[3l]]) == 0))
              tmp_if_expr$232 = (_Bool)1;

            else
            {
              return_value___ctype_b_loc$231=__ctype_b_loc();
              tmp_if_expr$232 = ((signed int)(*return_value___ctype_b_loc$231)[(signed long int)(signed int)p[(signed long int)3]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$232)
              tmp_if_expr$233 = (_Bool)1;

            else
              tmp_if_expr$233 = (signed int)p[(signed long int)3] == 95 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$233)
              tmp_if_expr$234 = (_Bool)1;

            else
              tmp_if_expr$234 = (signed int)p[(signed long int)3] == 45 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$234)
              tmp_if_expr$235 = (_Bool)1;

            else
              tmp_if_expr$235 = (signed int)p[(signed long int)3] == 43 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$235)
              tmp_if_expr$236 = (_Bool)1;

            else
              tmp_if_expr$236 = (signed int)p[(signed long int)3] == 46 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$236)
              tmp_if_expr$237 = (_Bool)1;

            else
              tmp_if_expr$237 = (signed int)p[(signed long int)3] == 42 ? (_Bool)1 : (_Bool)0;
            tmp_if_expr$238 = (signed int)!tmp_if_expr$237;
          }

          else
            tmp_if_expr$238 = 1;
          if(!(tmp_if_expr$238 == 0))
          {
            *q = p + (signed long int)3;
            return (unsigned int)129;
          }

        }

      }

      return (unsigned int)0;
    }
    case 101:
    {
      if((signed int)p[1l] == 113)
      {
        return_value___ctype_b_loc$239=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$239)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$241 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$240=__ctype_b_loc();
          tmp_if_expr$241 = ((signed int)(*return_value___ctype_b_loc$240)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$241)
          tmp_if_expr$242 = (_Bool)1;

        else
          tmp_if_expr$242 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$242)
          tmp_if_expr$243 = (_Bool)1;

        else
          tmp_if_expr$243 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$243)
          tmp_if_expr$244 = (_Bool)1;

        else
          tmp_if_expr$244 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$244)
          tmp_if_expr$245 = (_Bool)1;

        else
          tmp_if_expr$245 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$245)
          tmp_if_expr$246 = (_Bool)1;

        else
          tmp_if_expr$246 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$246)
        {
          return_value___ctype_b_loc$247=__ctype_b_loc();
          if(!((1024 & (signed int)(*return_value___ctype_b_loc$247)[(signed long int)(signed int)p[2l]]) == 0))
            tmp_if_expr$249 = (_Bool)1;

          else
          {
            return_value___ctype_b_loc$248=__ctype_b_loc();
            tmp_if_expr$249 = ((signed int)(*return_value___ctype_b_loc$248)[(signed long int)(signed int)p[(signed long int)2]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$249)
            tmp_if_expr$250 = (_Bool)1;

          else
            tmp_if_expr$250 = (signed int)p[(signed long int)2] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$250)
            tmp_if_expr$251 = (_Bool)1;

          else
            tmp_if_expr$251 = (signed int)p[(signed long int)2] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$251)
            tmp_if_expr$252 = (_Bool)1;

          else
            tmp_if_expr$252 = (signed int)p[(signed long int)2] == 43 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$252)
            tmp_if_expr$253 = (_Bool)1;

          else
            tmp_if_expr$253 = (signed int)p[(signed long int)2] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$253)
            tmp_if_expr$254 = (_Bool)1;

          else
            tmp_if_expr$254 = (signed int)p[(signed long int)2] == 42 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$255 = (signed int)!tmp_if_expr$254;
        }

        else
          tmp_if_expr$255 = 1;
        if(!(tmp_if_expr$255 == 0))
        {
          *q = p + (signed long int)2;
          return (unsigned int)137;
        }

      }

      return (unsigned int)0;
    }
    case 110:
    {
      if((signed int)p[1l] == 111)
      {
        if((signed int)p[2l] == 116)
        {
          return_value___ctype_b_loc$256=__ctype_b_loc();
          if(!((1024 & (signed int)(*return_value___ctype_b_loc$256)[(signed long int)(signed int)p[2l]]) == 0))
            tmp_if_expr$258 = (_Bool)1;

          else
          {
            return_value___ctype_b_loc$257=__ctype_b_loc();
            tmp_if_expr$258 = ((signed int)(*return_value___ctype_b_loc$257)[(signed long int)(signed int)p[(signed long int)2]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$258)
            tmp_if_expr$259 = (_Bool)1;

          else
            tmp_if_expr$259 = (signed int)p[(signed long int)2] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$259)
            tmp_if_expr$260 = (_Bool)1;

          else
            tmp_if_expr$260 = (signed int)p[(signed long int)2] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$260)
            tmp_if_expr$261 = (_Bool)1;

          else
            tmp_if_expr$261 = (signed int)p[(signed long int)2] == 43 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$261)
            tmp_if_expr$262 = (_Bool)1;

          else
            tmp_if_expr$262 = (signed int)p[(signed long int)2] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$262)
            tmp_if_expr$263 = (_Bool)1;

          else
            tmp_if_expr$263 = (signed int)p[(signed long int)2] == 42 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$263)
          {
            return_value___ctype_b_loc$264=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$264)[(signed long int)(signed int)p[3l]]) == 0))
              tmp_if_expr$266 = (_Bool)1;

            else
            {
              return_value___ctype_b_loc$265=__ctype_b_loc();
              tmp_if_expr$266 = ((signed int)(*return_value___ctype_b_loc$265)[(signed long int)(signed int)p[(signed long int)3]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$266)
              tmp_if_expr$267 = (_Bool)1;

            else
              tmp_if_expr$267 = (signed int)p[(signed long int)3] == 95 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$267)
              tmp_if_expr$268 = (_Bool)1;

            else
              tmp_if_expr$268 = (signed int)p[(signed long int)3] == 45 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$268)
              tmp_if_expr$269 = (_Bool)1;

            else
              tmp_if_expr$269 = (signed int)p[(signed long int)3] == 43 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$269)
              tmp_if_expr$270 = (_Bool)1;

            else
              tmp_if_expr$270 = (signed int)p[(signed long int)3] == 46 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$270)
              tmp_if_expr$271 = (_Bool)1;

            else
              tmp_if_expr$271 = (signed int)p[(signed long int)3] == 42 ? (_Bool)1 : (_Bool)0;
            tmp_if_expr$272 = (signed int)!tmp_if_expr$271;
          }

          else
            tmp_if_expr$272 = 1;
          if(!(tmp_if_expr$272 == 0))
          {
            *q = p + (signed long int)3;
            return (unsigned int)135;
          }

        }

      }

      if((signed int)p[1l] == 101)
      {
        return_value___ctype_b_loc$273=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$273)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$275 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$274=__ctype_b_loc();
          tmp_if_expr$275 = ((signed int)(*return_value___ctype_b_loc$274)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$275)
          tmp_if_expr$276 = (_Bool)1;

        else
          tmp_if_expr$276 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$276)
          tmp_if_expr$277 = (_Bool)1;

        else
          tmp_if_expr$277 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$277)
          tmp_if_expr$278 = (_Bool)1;

        else
          tmp_if_expr$278 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$278)
          tmp_if_expr$279 = (_Bool)1;

        else
          tmp_if_expr$279 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$279)
          tmp_if_expr$280 = (_Bool)1;

        else
          tmp_if_expr$280 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$280)
        {
          return_value___ctype_b_loc$281=__ctype_b_loc();
          if(!((1024 & (signed int)(*return_value___ctype_b_loc$281)[(signed long int)(signed int)p[2l]]) == 0))
            tmp_if_expr$283 = (_Bool)1;

          else
          {
            return_value___ctype_b_loc$282=__ctype_b_loc();
            tmp_if_expr$283 = ((signed int)(*return_value___ctype_b_loc$282)[(signed long int)(signed int)p[(signed long int)2]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$283)
            tmp_if_expr$284 = (_Bool)1;

          else
            tmp_if_expr$284 = (signed int)p[(signed long int)2] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$284)
            tmp_if_expr$285 = (_Bool)1;

          else
            tmp_if_expr$285 = (signed int)p[(signed long int)2] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$285)
            tmp_if_expr$286 = (_Bool)1;

          else
            tmp_if_expr$286 = (signed int)p[(signed long int)2] == 43 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$286)
            tmp_if_expr$287 = (_Bool)1;

          else
            tmp_if_expr$287 = (signed int)p[(signed long int)2] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$287)
            tmp_if_expr$288 = (_Bool)1;

          else
            tmp_if_expr$288 = (signed int)p[(signed long int)2] == 42 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$289 = (signed int)!tmp_if_expr$288;
        }

        else
          tmp_if_expr$289 = 1;
        if(!(tmp_if_expr$289 == 0))
        {
          *q = p + (signed long int)2;
          return (unsigned int)138;
        }

      }

      return (unsigned int)0;
    }
    case 111:
    {
      if((signed int)p[1l] == 114)
      {
        return_value___ctype_b_loc$290=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$290)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$292 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$291=__ctype_b_loc();
          tmp_if_expr$292 = ((signed int)(*return_value___ctype_b_loc$291)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$292)
          tmp_if_expr$293 = (_Bool)1;

        else
          tmp_if_expr$293 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$293)
          tmp_if_expr$294 = (_Bool)1;

        else
          tmp_if_expr$294 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$294)
          tmp_if_expr$295 = (_Bool)1;

        else
          tmp_if_expr$295 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$295)
          tmp_if_expr$296 = (_Bool)1;

        else
          tmp_if_expr$296 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$296)
          tmp_if_expr$297 = (_Bool)1;

        else
          tmp_if_expr$297 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$297)
        {
          return_value___ctype_b_loc$298=__ctype_b_loc();
          if(!((1024 & (signed int)(*return_value___ctype_b_loc$298)[(signed long int)(signed int)p[2l]]) == 0))
            tmp_if_expr$300 = (_Bool)1;

          else
          {
            return_value___ctype_b_loc$299=__ctype_b_loc();
            tmp_if_expr$300 = ((signed int)(*return_value___ctype_b_loc$299)[(signed long int)(signed int)p[(signed long int)2]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$300)
            tmp_if_expr$301 = (_Bool)1;

          else
            tmp_if_expr$301 = (signed int)p[(signed long int)2] == 95 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$301)
            tmp_if_expr$302 = (_Bool)1;

          else
            tmp_if_expr$302 = (signed int)p[(signed long int)2] == 45 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$302)
            tmp_if_expr$303 = (_Bool)1;

          else
            tmp_if_expr$303 = (signed int)p[(signed long int)2] == 43 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$303)
            tmp_if_expr$304 = (_Bool)1;

          else
            tmp_if_expr$304 = (signed int)p[(signed long int)2] == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$304)
            tmp_if_expr$305 = (_Bool)1;

          else
            tmp_if_expr$305 = (signed int)p[(signed long int)2] == 42 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$306 = (signed int)!tmp_if_expr$305;
        }

        else
          tmp_if_expr$306 = 1;
        if(!(tmp_if_expr$306 == 0))
        {
          *q = p + (signed long int)2;
          return (unsigned int)136;
        }

      }

      return (unsigned int)0;
    }
    case 123:
    {
      return_value___ctype_b_loc$307=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc$307)[(signed long int)(signed int)*p]) == 0))
        tmp_if_expr$309 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc$308=__ctype_b_loc();
        tmp_if_expr$309 = ((signed int)(*return_value___ctype_b_loc$308)[(signed long int)(signed int)p[(signed long int)0]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$309)
        tmp_if_expr$310 = (_Bool)1;

      else
        tmp_if_expr$310 = (signed int)p[(signed long int)0] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$310)
        tmp_if_expr$311 = (_Bool)1;

      else
        tmp_if_expr$311 = (signed int)p[(signed long int)0] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$311)
        tmp_if_expr$312 = (_Bool)1;

      else
        tmp_if_expr$312 = (signed int)p[(signed long int)0] == 43 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$312)
        tmp_if_expr$313 = (_Bool)1;

      else
        tmp_if_expr$313 = (signed int)p[(signed long int)0] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$313)
        tmp_if_expr$314 = (_Bool)1;

      else
        tmp_if_expr$314 = (signed int)p[(signed long int)0] == 42 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$314)
      {
        return_value___ctype_b_loc$315=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$315)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$317 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$316=__ctype_b_loc();
          tmp_if_expr$317 = ((signed int)(*return_value___ctype_b_loc$316)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$317)
          tmp_if_expr$318 = (_Bool)1;

        else
          tmp_if_expr$318 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$318)
          tmp_if_expr$319 = (_Bool)1;

        else
          tmp_if_expr$319 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$319)
          tmp_if_expr$320 = (_Bool)1;

        else
          tmp_if_expr$320 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$320)
          tmp_if_expr$321 = (_Bool)1;

        else
          tmp_if_expr$321 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$321)
          tmp_if_expr$322 = (_Bool)1;

        else
          tmp_if_expr$322 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$323 = (signed int)!tmp_if_expr$322;
      }

      else
        tmp_if_expr$323 = 1;
      if(!(tmp_if_expr$323 == 0))
      {
        *q = p + (signed long int)1;
        return (unsigned int)123;
      }

      return (unsigned int)0;
    }
    case 125:
    {
      return_value___ctype_b_loc$324=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc$324)[(signed long int)(signed int)*p]) == 0))
        tmp_if_expr$326 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc$325=__ctype_b_loc();
        tmp_if_expr$326 = ((signed int)(*return_value___ctype_b_loc$325)[(signed long int)(signed int)p[(signed long int)0]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$326)
        tmp_if_expr$327 = (_Bool)1;

      else
        tmp_if_expr$327 = (signed int)p[(signed long int)0] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$327)
        tmp_if_expr$328 = (_Bool)1;

      else
        tmp_if_expr$328 = (signed int)p[(signed long int)0] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$328)
        tmp_if_expr$329 = (_Bool)1;

      else
        tmp_if_expr$329 = (signed int)p[(signed long int)0] == 43 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$329)
        tmp_if_expr$330 = (_Bool)1;

      else
        tmp_if_expr$330 = (signed int)p[(signed long int)0] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$330)
        tmp_if_expr$331 = (_Bool)1;

      else
        tmp_if_expr$331 = (signed int)p[(signed long int)0] == 42 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$331)
      {
        return_value___ctype_b_loc$332=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$332)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$334 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$333=__ctype_b_loc();
          tmp_if_expr$334 = ((signed int)(*return_value___ctype_b_loc$333)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$334)
          tmp_if_expr$335 = (_Bool)1;

        else
          tmp_if_expr$335 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$335)
          tmp_if_expr$336 = (_Bool)1;

        else
          tmp_if_expr$336 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$336)
          tmp_if_expr$337 = (_Bool)1;

        else
          tmp_if_expr$337 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$337)
          tmp_if_expr$338 = (_Bool)1;

        else
          tmp_if_expr$338 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$338)
          tmp_if_expr$339 = (_Bool)1;

        else
          tmp_if_expr$339 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$340 = (signed int)!tmp_if_expr$339;
      }

      else
        tmp_if_expr$340 = 1;
      if(!(tmp_if_expr$340 == 0))
      {
        *q = p + (signed long int)1;
        return (unsigned int)125;
      }

      return (unsigned int)0;
    }
    case 126:
    {
      return_value___ctype_b_loc$341=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc$341)[(signed long int)(signed int)*p]) == 0))
        tmp_if_expr$343 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc$342=__ctype_b_loc();
        tmp_if_expr$343 = ((signed int)(*return_value___ctype_b_loc$342)[(signed long int)(signed int)p[(signed long int)0]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$343)
        tmp_if_expr$344 = (_Bool)1;

      else
        tmp_if_expr$344 = (signed int)p[(signed long int)0] == 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$344)
        tmp_if_expr$345 = (_Bool)1;

      else
        tmp_if_expr$345 = (signed int)p[(signed long int)0] == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$345)
        tmp_if_expr$346 = (_Bool)1;

      else
        tmp_if_expr$346 = (signed int)p[(signed long int)0] == 43 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$346)
        tmp_if_expr$347 = (_Bool)1;

      else
        tmp_if_expr$347 = (signed int)p[(signed long int)0] == 46 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$347)
        tmp_if_expr$348 = (_Bool)1;

      else
        tmp_if_expr$348 = (signed int)p[(signed long int)0] == 42 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$348)
      {
        return_value___ctype_b_loc$349=__ctype_b_loc();
        if(!((1024 & (signed int)(*return_value___ctype_b_loc$349)[(signed long int)(signed int)p[1l]]) == 0))
          tmp_if_expr$351 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc$350=__ctype_b_loc();
          tmp_if_expr$351 = ((signed int)(*return_value___ctype_b_loc$350)[(signed long int)(signed int)p[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$351)
          tmp_if_expr$352 = (_Bool)1;

        else
          tmp_if_expr$352 = (signed int)p[(signed long int)1] == 95 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$352)
          tmp_if_expr$353 = (_Bool)1;

        else
          tmp_if_expr$353 = (signed int)p[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$353)
          tmp_if_expr$354 = (_Bool)1;

        else
          tmp_if_expr$354 = (signed int)p[(signed long int)1] == 43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$354)
          tmp_if_expr$355 = (_Bool)1;

        else
          tmp_if_expr$355 = (signed int)p[(signed long int)1] == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$355)
          tmp_if_expr$356 = (_Bool)1;

        else
          tmp_if_expr$356 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$357 = (signed int)!tmp_if_expr$356;
      }

      else
        tmp_if_expr$357 = 1;
      if(!(tmp_if_expr$357 == 0))
      {
        *q = p + (signed long int)1;
        return (unsigned int)126;
      }

      return (unsigned int)0;
    }
    default:
      return (unsigned int)0;
  }
}

// vxp_quote
// file vxp.c line 72
static void vxp_quote(struct vxp *vxp, const char *b, const char *e, signed int tokoff)
{
  const char *p;
  char c;
  do
    if(!(e >= b))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      VAS_Fail("vxp_quote", "vxp.c", 77, "b <= e", *return_value___errno_location$1, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
    if(!(b >= vxp->b))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      VAS_Fail("vxp_quote", "vxp.c", 78, "b >= vxp->b", *return_value___errno_location$2, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  do
    if(!(vxp->e >= e))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      VAS_Fail("vxp_quote", "vxp.c", 79, "e <= vxp->e", *return_value___errno_location$3, (enum vas_e)VAS_ASSERT);
    }

  while((_Bool)0);
  p = vxp->b;
  for( ; !(p >= vxp->e); p = p + 1l)
  {
    const unsigned short int **return_value___ctype_b_loc$4;
    return_value___ctype_b_loc$4=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*p]) == 0))
      VSB_bcat(vxp->sb, (const void *)" ", (unsigned long int)1);

    else
      VSB_bcat(vxp->sb, (const void *)p, (unsigned long int)1);
  }
  VSB_putc(vxp->sb, 10);
  p = vxp->b;
  for( ; !(p >= vxp->e); p = p + 1l)
  {
    if(p >= b && !(p >= e))
    {
      if(p - b == (signed long int)tokoff)
        c = (char)94;

      else
        c = (char)35;
    }

    else
      c = (char)45;
    VSB_putc(vxp->sb, (signed int)c);
  }
  VSB_putc(vxp->sb, 10);
}

