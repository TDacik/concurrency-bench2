// #anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4
// file /usr/include/g3d/types.h line 132
enum anonymous$8 { G3D_TEXENV_UNSPECIFIED=0, G3D_TEXENV_BLEND=1, G3D_TEXENV_DECAL=2, G3D_TEXENV_MODULATE=3, G3D_TEXENV_REPLACE=4 };

// tag-#anon#ST[*{S8}$S8$'filename'||*{SYM#tag-#anon#ST[*{SYM#tag-_GSList#}$SYM#tag-_GSList#$'plugins'||*{V}$V$'magic_cookie'||*{SYM#tag-_GHashTable#}$SYM#tag-_GHashTable#$'exts_import'||*{SYM#tag-_GHashTable#}$SYM#tag-_GHashTable#$'exts_image'||*{S32(F32|F32|F32|F32|*{V}$V$)->S32}$S32(F32|F32|F32|F32|*{V}$V$)->S32$'set_bgcolor_func'||*{V}$V$'set_bgcolor_data'||*{S32(*{V}$V$)->S32}$S32(*{V}$V$)->S32$'update_interface_func'||*{V}$V$'update_interface_data'||*{S32(F32|S32|*{V}$V$)->S32}$S32(F32|S32|*{V}$V$)->S32$'update_progress_bar_func'||*{V}$V$'update_progress_bar_data'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_GSList#}$SYM#tag-_GSList#$'plugins'||*{V}$V$'magic_cookie'||*{SYM#tag-_GHashTable#}$SYM#tag-_GHashTable#$'exts_import'||*{SYM#tag-_GHashTable#}$SYM#tag-_GHashTable#$'exts_image'||*{S32(F32|F32|F32|F32|*{V}$V$)->S32}$S32(F32|F32|F32|F32|*{V}$V$)->S32$'set_bgcolor_func'||*{V}$V$'set_bgcolor_data'||*{S32(*{V}$V$)->S32}$S32(*{V}$V$)->S32$'update_interface_func'||*{V}$V$'update_interface_data'||*{S32(F32|S32|*{V}$V$)->S32}$S32(F32|S32|*{V}$V$)->S32$'update_progress_bar_func'||*{V}$V$'update_progress_bar_data'|]#$'context'||*{SYM#tag-_GSList#}$SYM#tag-_GSList#$'materials'||*{SYM#tag-_GSList#}$SYM#tag-_GSList#$'objects'||*{SYM#tag-_GHashTable#}$SYM#tag-_GHashTable#$'tex_images'||*{SYM#tag-_G3DPlugin#}$SYM#tag-_G3DPlugin#$'plugin'|]
// file /usr/include/g3d/types.h line 412
struct anonymous$5;

// tag-#anon#ST[*{S8}$S8$'name'||*{SYM#tag-_GSList#}$SYM#tag-_GSList#$'materials'||*{SYM#tag-_GSList#}$SYM#tag-_GSList#$'faces'||*{SYM#tag-_GSList#}$SYM#tag-_GSList#$'objects'||*{SYM#tag-#anon#ST[ARR16{F32}$F32$'matrix'||U32'flags'|]#}$SYM#tag-#anon#ST[ARR16{F32}$F32$'matrix'||U32'flags'|]#$'transformation'||S32'hide'||U32'vertex_count'||*{F32}$F32$'vertex_data'||U32'tex_vertex_count'||U32'$pad0'||*{F32}$F32$'tex_vertex_data'||*{SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#$'tex_image'||*{F32}$F32$'_normals'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'||F32'r'||F32'g'||F32'b'||F32'a'||F32'shininess'||ARR4{F32}$F32$'specular'||U32'flags'||*{SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#$'tex_image'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'name'||F32'r'||F32'g'||F32'b'||F32'a'||F32'shininess'||ARR4{F32}$F32$'specular'||U32'flags'||*{SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#$'tex_image'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'||F32'r'||F32'g'||F32'b'||F32'a'||F32'shininess'||ARR4{F32}$F32$'specular'||U32'flags'||*{SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#$'tex_image'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'name'||F32'r'||F32'g'||F32'b'||F32'a'||F32'shininess'||ARR4{F32}$F32$'specular'||U32'flags'||*{SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#$'tex_image'|]#$$'_materials'||U32'_num_faces'||U32'$pad1'||*{U32}$U32$'_indices'||*{U32}$U32$'_flags'||*{U32}$U32$'_tex_images'||*{F32}$F32$'_tex_coords'|]
// file /usr/include/g3d/types.h line 287
struct anonymous$11;

// tag-#anon#ST[*{S8}$S8$'name'||F32'r'||F32'g'||F32'b'||F32'a'||F32'shininess'||ARR4{F32}$F32$'specular'||U32'flags'||*{SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#$'tex_image'|]
// file /usr/include/g3d/types.h line 196
struct anonymous$10;

// tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]
// file /usr/include/g3d/types.h line 155
struct anonymous$9;

// tag-#anon#ST[*{SYM#tag-_GSList#}$SYM#tag-_GSList#$'plugins'||*{V}$V$'magic_cookie'||*{SYM#tag-_GHashTable#}$SYM#tag-_GHashTable#$'exts_import'||*{SYM#tag-_GHashTable#}$SYM#tag-_GHashTable#$'exts_image'||*{S32(F32|F32|F32|F32|*{V}$V$)->S32}$S32(F32|F32|F32|F32|*{V}$V$)->S32$'set_bgcolor_func'||*{V}$V$'set_bgcolor_data'||*{S32(*{V}$V$)->S32}$S32(*{V}$V$)->S32$'update_interface_func'||*{V}$V$'update_interface_data'||*{S32(F32|S32|*{V}$V$)->S32}$S32(F32|S32|*{V}$V$)->S32$'update_progress_bar_func'||*{V}$V$'update_progress_bar_data'|]
// file /usr/include/g3d/types.h line 378
struct anonymous$4;

// tag-#anon#ST[ARR16{F32}$F32$'matrix'||U32'flags'|]
// file /usr/include/g3d/types.h line 264
struct anonymous$6;

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$13;

// tag-#anon#ST[F64'x'||F64'y'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_triangulate.h line 49
struct anonymous$1;

// tag-#anon#ST[S32'lseg'||S32'rseg'||SYM#tag-#anon#ST[F64'x'||F64'y'|]#'hi'||SYM#tag-#anon#ST[F64'x'||F64'y'|]#'lo'||S32'u0'||S32'u1'||S32'd0'||S32'd1'||S32'sink'||S32'usave'||S32'uside'||S32'state'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_triangulate.h line 67
struct anonymous$3;

// tag-#anon#ST[S32'nodetype'||S32'segnum'||SYM#tag-#anon#ST[F64'x'||F64'y'|]#'yval'||S32'trnum'||S32'parent'||S32'left'||S32'right'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_triangulate.h line 80
struct anonymous$15;

// tag-#anon#ST[S32'vnum'||S32'next'||S32'prev'||S32'marked'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_triangulate.h line 90
struct anonymous$0;

// tag-#anon#ST[SYM#tag-#anon#ST[F64'x'||F64'y'|]#'pt'||ARR4{S32}$S32$'vnext'||ARR4{S32}$S32$'vpos'||S32'nextfree'||U32'$pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_triangulate.h line 98
struct anonymous$2;

// tag-#anon#ST[SYM#tag-#anon#ST[F64'x'||F64'y'|]#'v0'||SYM#tag-#anon#ST[F64'x'||F64'y'|]#'v1'||S32'is_inserted'||S32'root0'||S32'root1'||S32'next'||S32'prev'||U32'$pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_triangulate.h line 56
struct anonymous$14;

// tag-#anon#ST[U32'vertex_count'||U32'$pad0'||*{U32}$U32$'vertex_indices'||*{SYM#tag-#anon#ST[*{S8}$S8$'name'||F32'r'||F32'g'||F32'b'||F32'a'||F32'shininess'||ARR4{F32}$F32$'specular'||U32'flags'||*{SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#$'tex_image'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'name'||F32'r'||F32'g'||F32'b'||F32'a'||F32'shininess'||ARR4{F32}$F32$'specular'||U32'flags'||*{SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#$'tex_image'|]#$'material'||U32'flags'||U32'$pad1'||*{F32}$F32$'normals'||*{SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'width'||U32'height'||U8'depth'||U24'$pad0'||U32'flags'||*{U8}$U8$'pixeldata'||U32'tex_id'||EN#anon_enum$G3D_TEXENV_UNSPECIFIED=0$G3D_TEXENV_BLEND=1$G3D_TEXENV_DECAL=2$G3D_TEXENV_MODULATE=3$G3D_TEXENV_REPLACE=4#{U32}$U32$'tex_env'||F32'tex_scale_u'||F32'tex_scale_v'|]#$'tex_image'||U32'tex_vertex_count'||U32'$pad2'||*{F32}$F32$'tex_vertex_data'|]
// file /usr/include/g3d/types.h line 238
struct anonymous$12;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$7;

// tag-#anon#cST[S32'err_code'||U32'$pad0'||*{cS8}$cS8$'err_msg'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 39
struct anonymous;

// tag-FT_BBox_
// file /usr/include/freetype2/freetype/ftimage.h line 115
struct FT_BBox_;

// tag-FT_Bitmap_
// file /usr/include/freetype2/freetype/ftimage.h line 261
struct FT_Bitmap_;

// tag-FT_Bitmap_Size_
// file /usr/include/freetype2/freetype/freetype.h line 363
struct FT_Bitmap_Size_;

// tag-FT_CharMapRec_
// file /usr/include/freetype2/freetype/freetype.h line 579
struct FT_CharMapRec_;

// tag-FT_DriverRec_
// file /usr/include/freetype2/freetype/freetype.h line 441
struct FT_DriverRec_;

// tag-FT_Encoding_
// file /usr/include/freetype2/freetype/freetype.h line 757
enum FT_Encoding_ { FT_ENCODING_NONE=0, FT_ENCODING_MS_SYMBOL=1937337698, FT_ENCODING_UNICODE=1970170211, FT_ENCODING_SJIS=1936353651, FT_ENCODING_GB2312=1734484000, FT_ENCODING_BIG5=1651074869, FT_ENCODING_WANSUNG=2002873971, FT_ENCODING_JOHAB=1785686113, FT_ENCODING_MS_SJIS=1936353651, FT_ENCODING_MS_GB2312=1734484000, FT_ENCODING_MS_BIG5=1651074869, FT_ENCODING_MS_WANSUNG=2002873971, FT_ENCODING_MS_JOHAB=1785686113, FT_ENCODING_ADOBE_STANDARD=1094995778, FT_ENCODING_ADOBE_EXPERT=1094992453, FT_ENCODING_ADOBE_CUSTOM=1094992451, FT_ENCODING_ADOBE_LATIN_1=1818326065, FT_ENCODING_OLD_LATIN_2=1818326066, FT_ENCODING_APPLE_ROMAN=1634889070 };

// tag-FT_FaceRec_
// file /usr/include/freetype2/freetype/freetype.h line 495
struct FT_FaceRec_;

// tag-FT_Face_InternalRec_
// file /usr/include/freetype2/freetype/freetype.h line 862
struct FT_Face_InternalRec_;

// tag-FT_Generic_
// file /usr/include/freetype2/freetype/fttypes.h line 459
struct FT_Generic_;

// tag-FT_GlyphSlotRec_
// file /usr/include/freetype2/freetype/freetype.h line 547
struct FT_GlyphSlotRec_;

// tag-FT_Glyph_Format_
// file /usr/include/freetype2/freetype/ftimage.h line 715
enum FT_Glyph_Format_ { FT_GLYPH_FORMAT_NONE=0, FT_GLYPH_FORMAT_COMPOSITE=1668246896, FT_GLYPH_FORMAT_BITMAP=1651078259, FT_GLYPH_FORMAT_OUTLINE=1869968492, FT_GLYPH_FORMAT_PLOTTER=1886154612 };

// tag-FT_Glyph_Metrics_
// file /usr/include/freetype2/freetype/freetype.h line 309
struct FT_Glyph_Metrics_;

// tag-FT_LibraryRec_
// file /usr/include/freetype2/freetype/freetype.h line 409
struct FT_LibraryRec_;

// tag-FT_ListNodeRec_
// file /usr/include/freetype2/freetype/fttypes.h line 515
struct FT_ListNodeRec_;

// tag-FT_ListRec_
// file /usr/include/freetype2/freetype/fttypes.h line 526
struct FT_ListRec_;

// tag-FT_MemoryRec_
// file /usr/include/freetype2/freetype/ftsystem.h line 66
struct FT_MemoryRec_;

// tag-FT_Outline_
// file /usr/include/freetype2/freetype/ftimage.h line 334
struct FT_Outline_;

// tag-FT_SizeRec_
// file /usr/include/freetype2/freetype/freetype.h line 526
struct FT_SizeRec_;

// tag-FT_Size_InternalRec_
// file /usr/include/freetype2/freetype/freetype.h line 1443
struct FT_Size_InternalRec_;

// tag-FT_Size_Metrics_
// file /usr/include/freetype2/freetype/freetype.h line 1501
struct FT_Size_Metrics_;

// tag-FT_Slot_InternalRec_
// file /usr/include/freetype2/freetype/freetype.h line 1574
struct FT_Slot_InternalRec_;

// tag-FT_StreamDesc_
// file /usr/include/freetype2/freetype/ftsystem.h line 213
union FT_StreamDesc_;

// tag-FT_StreamRec_
// file /usr/include/freetype2/freetype/ftsystem.h line 200
struct FT_StreamRec_;

// tag-FT_SubGlyphRec_
// file /usr/include/freetype2/freetype/freetype.h line 1562
struct FT_SubGlyphRec_;

// tag-FT_Vector_
// file /usr/include/freetype2/freetype/ftimage.h line 74
struct FT_Vector_;

// tag-_FcConfig
// file /usr/include/fontconfig/fontconfig.h line 288
struct _FcConfig;

// tag-_FcMatchKind
// file /usr/include/fontconfig/fontconfig.h line 260
enum _FcMatchKind { FcMatchPattern=0, FcMatchFont=1, FcMatchScan=2 };

// tag-_FcPattern
// file /usr/include/fontconfig/fontconfig.h line 230
struct _FcPattern;

// tag-_FcResult
// file /usr/include/fontconfig/fontconfig.h line 225
enum _FcResult { FcResultMatch=0, FcResultNoMatch=1, FcResultTypeMismatch=2, FcResultNoId=3, FcResultOutOfMemory=4 };

// tag-_G3DPlugin
// file /usr/include/g3d/types.h line 398
struct _G3DPlugin;

// tag-_GHashTable
// file /usr/include/glib-2.0/glib/ghash.h line 37
struct _GHashTable;

// tag-_GSList
// file /usr/include/glib-2.0/glib/gslist.h line 37
struct _GSList;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_s3dw_button
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/s3dw.h line 80
struct _s3dw_button;

// tag-_s3dw_input
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/s3dw.h line 84
struct _s3dw_input;

// tag-_s3dw_label
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/s3dw.h line 81
struct _s3dw_label;

// tag-_s3dw_scrollbar
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/s3dw.h line 83
struct _s3dw_scrollbar;

// tag-_s3dw_style
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/s3dw.h line 86
struct _s3dw_style;

// tag-_s3dw_surface
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/s3dw.h line 85
struct _s3dw_surface;

// tag-_s3dw_textbox
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/s3dw.h line 82
struct _s3dw_textbox;

// tag-_s3dw_widget
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/s3dw.h line 79
struct _s3dw_widget;

// tag-buf_t
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 150
struct buf_t;

// tag-element_t
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.h line 34
struct element_t;

// tag-hash_it_t
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.h line 39
struct hash_it_t;

// tag-hashtable_t
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.h line 46
struct hashtable_t;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-ipc_perm
// file /usr/include/x86_64-linux-gnu/bits/ipc.h line 42
struct ipc_perm;

// tag-kismet_src
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.h line 49
struct kismet_src;

// tag-list_head
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/list.h line 29
struct list_head;

// tag-material2texture
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/modelread.c line 35
struct material2texture;

// tag-mcp_object
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 99
struct mcp_object;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-s3d_evt
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 60
struct s3d_evt;

// tag-s3d_key_event
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 139
struct s3d_key_event;

// tag-s3d_obj_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 117
struct s3d_obj_info;

// tag-s3d_tex
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 95
struct s3d_tex;

// tag-s3d_texshm
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 90
struct s3d_texshm;

// tag-shmid_ds
// file /usr/include/x86_64-linux-gnu/bits/shm.h line 49
struct shmid_ds;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-t_buf
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 163
struct t_buf;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-wlan_client
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.h line 87
struct wlan_client;

// tag-wlan_network
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.h line 63
struct wlan_network;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// FT_Init_FreeType
// file /usr/include/freetype2/freetype/freetype.h line 1818
extern signed int FT_Init_FreeType(struct FT_LibraryRec_ **);
// FT_Load_Char
// file /usr/include/freetype2/freetype/freetype.h line 2618
extern signed int FT_Load_Char(struct FT_FaceRec_ *, unsigned long int, signed int);
// FT_New_Memory_Face
// file /usr/include/freetype2/freetype/freetype.h line 2045
extern signed int FT_New_Memory_Face(struct FT_LibraryRec_ *, const unsigned char *, signed long int, signed long int, struct FT_FaceRec_ **);
// FcConfigSubstitute
// file /usr/include/fontconfig/fontconfig.h line 421
signed int FcConfigSubstitute(struct _FcConfig *, struct _FcPattern *, enum _FcMatchKind);
// FcDefaultSubstitute
// file /usr/include/fontconfig/fontconfig.h line 517
void FcDefaultSubstitute(struct _FcPattern *);
// FcFontMatch
// file /usr/include/fontconfig/fontconfig.h line 703
struct _FcPattern * FcFontMatch(struct _FcConfig *, struct _FcPattern *, enum _FcResult *);
// FcNameParse
// file /usr/include/fontconfig/fontconfig.h line 778
struct _FcPattern * FcNameParse(const unsigned char *);
// FcPatternGetString
// file /usr/include/fontconfig/fontconfig.h line 860
enum _FcResult FcPatternGetString(const struct _FcPattern *, const char *, signed int, unsigned char **);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __list_add
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/list.h line 81
static inline void __list_add(struct list_head *n, struct list_head *prev, struct list_head *next);
// __list_del
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/list.h line 115
static inline void __list_del(struct list_head *prev, struct list_head *next);
// _equal_to
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 123
extern signed int _equal_to(struct anonymous$1 *v0, struct anonymous$1 *v1);
// _greater_than
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 112
extern signed int _greater_than(struct anonymous$1 *v0, struct anonymous$1 *v1);
// _greater_than_equal_to
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 128
extern signed int _greater_than_equal_to(struct anonymous$1 *v0, struct anonymous$1 *v1);
// _less_than
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 138
extern signed int _less_than(struct anonymous$1 *v0, struct anonymous$1 *v1);
// _max
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 79
static signed int _max(struct anonymous$1 *yval, struct anonymous$1 *v0, struct anonymous$1 *v1);
// _max$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 79
static signed int _max$link1(struct anonymous$1 *yval$link1, struct anonymous$1 *v0$link1, struct anonymous$1 *v1$link1);
// _min
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 96
static signed int _min(struct anonymous$1 *yval, struct anonymous$1 *v0, struct anonymous$1 *v1);
// _min$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 96
static signed int _min$link1(struct anonymous$1 *yval$link1, struct anonymous$1 *v0$link1, struct anonymous$1 *v1$link1);
// _queue_fill
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/object_queue.c line 62
signed int _queue_fill(void);
// _queue_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/object_queue.c line 49
signed int _queue_init(void);
// _queue_new_object
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/object_queue.c line 71
signed int _queue_new_object(unsigned int oid);
// _queue_quit
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/object_queue.c line 125
signed int _queue_quit(void);
// _queue_want_object
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/object_queue.c line 92
unsigned int _queue_want_object(void);
// _s3d_add_tessbuf
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 116
static signed int _s3d_add_tessbuf(unsigned short int a);
// _s3d_add_tessbuf$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 116
static signed int _s3d_add_tessbuf$link1(unsigned short int a$link1);
// _s3d_choose_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 40
static signed int _s3d_choose_cb(const void *d1, signed int size);
// _s3d_choose_cb$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 40
static signed int _s3d_choose_cb$link1(const void *d1$link1, signed int size$link1);
// _s3d_clear_tessbuf
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 97
static signed int _s3d_clear_tessbuf(void);
// _s3d_clear_tessbuf$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 97
static signed int _s3d_clear_tessbuf$link1(void);
// _s3d_compare_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 46
static signed int _s3d_compare_cb(const void *d1, const void *d2);
// _s3d_compare_cb$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 46
static signed int _s3d_compare_cb$link1(const void *d1$link1, const void *d2$link1);
// _s3d_draw_tessbuf
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 261
static signed int _s3d_draw_tessbuf(signed int oid, unsigned short int a, signed int *voff, float *xoff);
// _s3d_draw_tessbuf$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 261
static signed int _s3d_draw_tessbuf$link1(signed int oid$link1, unsigned short int a$link1, signed int *voff$link1, float *xoff$link1);
// _s3d_free_s3dtex
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 56
static void _s3d_free_s3dtex(void *d1);
// _s3d_free_s3dtex$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 56
static void _s3d_free_s3dtex$link1(void *d1$link1);
// _s3d_handle_texshm
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 70
void _s3d_handle_texshm(struct s3d_texshm *tshm);
// _s3d_hash_add
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 175
signed int _s3d_hash_add(struct hashtable_t *hash, void *data);
// _s3d_hash_debug
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 304
void _s3d_hash_debug(struct hashtable_t *hash);
// _s3d_hash_delete
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 45
void _s3d_hash_delete(struct hashtable_t *hash, void (*free_cb)(void *));
// _s3d_hash_delete::free_cb$link1$object
//
void free_cb$link1$object(void *);
// _s3d_hash_delete::free_cb$object
//
void free_cb$object(void *);
// _s3d_hash_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 71
void _s3d_hash_destroy(struct hashtable_t *hash);
// _s3d_hash_find
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 210
void * _s3d_hash_find(struct hashtable_t *hash, void *keydata);
// _s3d_hash_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 32
void _s3d_hash_init(struct hashtable_t *hash);
// _s3d_hash_iterate
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 84
struct hash_it_t * _s3d_hash_iterate(struct hashtable_t *hash, struct hash_it_t *iter_in);
// _s3d_hash_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 154
struct hashtable_t * _s3d_hash_new(signed int size, signed int (*compare)(const void *, const void *), signed int (*choose)(const void *, signed int));
// _s3d_hash_new::choose$link1$object
//
signed int choose$link1$object(const void *, signed int);
// _s3d_hash_new::choose$object
//
signed int choose$object(const void *, signed int);
// _s3d_hash_new::compare$link1$object
//
signed int compare$link1$object(const void *, const void *);
// _s3d_hash_new::compare$object
//
signed int compare$object(const void *, const void *);
// _s3d_hash_remove
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 256
void * _s3d_hash_remove(struct hashtable_t *hash, void *data);
// _s3d_hash_remove_bucket
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 232
void * _s3d_hash_remove_bucket(struct hashtable_t *hash, struct hash_it_t *hash_it_t);
// _s3d_hash_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 280
struct hashtable_t * _s3d_hash_resize(struct hashtable_t *hash, signed int size);
// _s3d_ignore
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/callback.c line 54
static signed int _s3d_ignore(struct s3d_evt *evt);
// _s3d_ignore$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/callback.c line 54
static signed int _s3d_ignore$link1(struct s3d_evt *evt$link1);
// _s3d_load_texture_shm
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 96
signed int _s3d_load_texture_shm(signed int object, unsigned int tid, unsigned short int xpos, unsigned short int ypos, unsigned short int w, unsigned short int h, const unsigned char *data);
// _s3d_net_receive
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/network.c line 63
static signed int _s3d_net_receive(void);
// _s3d_net_receive$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/network.c line 63
static signed int _s3d_net_receive$link1(void);
// _s3d_tcp_net_receive
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 143
signed int _s3d_tcp_net_receive(void);
// _s3d_texture_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 134
signed int _s3d_texture_init(void);
// _s3d_texture_quit
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 142
signed int _s3d_texture_quit(void);
// _s3d_update_texture
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 1058
signed int _s3d_update_texture(signed int object, unsigned int tex, unsigned short int xpos, unsigned short int ypos, unsigned short int w, unsigned short int h);
// _s3dw_textbox_scrollbar_down
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 185
static void _s3dw_textbox_scrollbar_down(struct _s3dw_widget *widget);
// _s3dw_textbox_scrollbar_left
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 189
static void _s3dw_textbox_scrollbar_left(struct _s3dw_widget *widget);
// _s3dw_textbox_scrollbar_right
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 193
static void _s3dw_textbox_scrollbar_right(struct _s3dw_widget *widget);
// _s3dw_textbox_scrollbar_up
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 181
static void _s3dw_textbox_scrollbar_up(struct _s3dw_widget *widget);
// _shm_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 55
signed int _shm_init(char *ftoken);
// _shm_net_receive
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 169
signed int _shm_net_receive(void);
// _shm_quit
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 115
signed int _shm_quit(void);
// _tcp_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 56
signed int _tcp_init(const char *sv, signed int pn);
// _tcp_init::$tmp::return_value_signal$10$link1$object
//
void return_value_signal$10$link1$object(signed int);
// _tcp_init::$tmp::return_value_signal$10$object
//
void return_value_signal$10$object(signed int);
// _tcp_init::$tmp::return_value_signal$12$link1$object
//
void return_value_signal$12$link1$object(signed int);
// _tcp_init::$tmp::return_value_signal$12$object
//
void return_value_signal$12$object(signed int);
// _tcp_quit
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 109
signed int _tcp_quit(void);
// acos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 54
extern double acos(double);
// add_segment
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 419
static signed int add_segment(signed int segnum);
// add_segment$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 419
static signed int add_segment$link1(signed int segnum$link1);
// alloc_memory
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 55
void * alloc_memory(signed int len);
// atan2
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 60
extern double atan2(double, double);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// ceil
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 178
extern double ceil(double);
// choose_segment
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_misc.c line 79
extern signed int choose_segment(void);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// construct_trapezoids
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 920
extern signed int construct_trapezoids(signed int nseg);
// cos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
extern double cos(double);
// errdn
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 111
static inline void errdn(signed int relevance, const char *func, signed int en);
// errdn$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 111
static inline void errdn$link1(signed int relevance$link1, const char *func$link1, signed int en$link1);
// errds
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 114
static inline void errds(signed int relevance, const char *func, const char *fmt, ...);
// errds$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 114
static inline void errds$link1(signed int relevance$link1, const char *func$link1, const char *fmt$link1, ...);
// errn
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/error.c line 63
void errn(const char *func, signed int en);
// errs
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/error.c line 67
void errs(const char *func, const char *msg);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fabs
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 181
extern double fabs(double);
// fabsf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 181
extern float fabsf(float);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// find_new_roots
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 903
static signed int find_new_roots(signed int segnum);
// find_new_roots$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 903
static signed int find_new_roots$link1(signed int segnum$link1);
// find_wlan_network
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/network.c line 81
struct wlan_network * find_wlan_network(char *bssid);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 219
extern signed int fstat(signed int, struct stat *);
// ftok
// file /usr/include/x86_64-linux-gnu/sys/ipc.h line 54
extern signed int ftok(const char *, signed int);
// g3d_context_free
// file /usr/include/g3d/context.h line 57
void g3d_context_free(struct anonymous$4 *);
// g3d_context_new
// file /usr/include/g3d/context.h line 48
struct anonymous$4 * g3d_context_new(void);
// g3d_matrix_identity
// file /usr/include/g3d/matrix.h line 50
signed int g3d_matrix_identity(float *);
// g3d_matrix_rotate_xyz
// file /usr/include/g3d/matrix.h line 127
signed int g3d_matrix_rotate_xyz(float, float, float, float *);
// g3d_model_free
// file /usr/include/g3d/model.h line 140
void g3d_model_free(struct anonymous$5 *);
// g3d_model_load_full
// file /usr/include/g3d/model.h line 90
struct anonymous$5 * g3d_model_load_full(struct anonymous$4 *, const char *, unsigned int);
// g3d_model_transform
// file /usr/include/g3d/model.h line 162
signed int g3d_model_transform(struct anonymous$5 *, float *);
// generate_random_ordering
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_misc.c line 53
extern signed int generate_random_ordering(signed int n);
// get_angle
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 100
static double get_angle(struct anonymous$1 *vp0, struct anonymous$1 *vpnext, struct anonymous$1 *vp1);
// get_angle$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 100
static double get_angle$link1(struct anonymous$1 *vp0$link1, struct anonymous$1 *vpnext$link1, struct anonymous$1 *vp1$link1);
// get_mat2tex
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/modelread.c line 91
static struct material2texture * get_mat2tex(struct material2texture **mat2tex, void *mat_ptr);
// get_mat2tex$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/modelread.c line 91
static struct material2texture * get_mat2tex$link1(struct material2texture **mat2tex$link1, void *mat_ptr$link1);
// get_time
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 73
unsigned int get_time(void);
// get_vertex_positions
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 119
static signed int get_vertex_positions(signed int v0, signed int v1, signed int *ip, signed int *iq);
// get_vertex_positions$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 119
static signed int get_vertex_positions$link1(signed int v0$link1, signed int v1$link1, signed int *ip$link1, signed int *iq$link1);
// get_wlan_client
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/client.c line 32
struct wlan_client * get_wlan_client(char *mac);
// get_wlan_network
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/network.c line 32
struct wlan_network * get_wlan_network(char *bssid);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// gui_main
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 426
void * gui_main(void *unused);
// handle_clients
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 249
static signed int handle_clients(void);
// handle_networks
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 121
static signed int handle_networks(void);
// htonfb
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/endian.c line 30
void htonfb(float *netfloat, signed int num);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htonlb
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/endian.c line 48
void htonlb(unsigned int *netint32, signed int num);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// htonsb
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/endian.c line 66
void htonsb(unsigned short int *netint16, signed int num);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// init_query_structure
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 162
static signed int init_query_structure(signed int segnum);
// init_query_structure$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 162
static signed int init_query_structure$link1(signed int segnum$link1);
// initialise
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_tri.c line 45
static signed int initialise(signed int n);
// initialise$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_tri.c line 45
static signed int initialise$link1(signed int n$link1);
// inserted
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 288
static signed int inserted(signed int segnum, signed int whichpt);
// inserted$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 288
static signed int inserted$link1(signed int segnum$link1, signed int whichpt$link1);
// inside_polygon
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 68
static signed int inside_polygon(struct anonymous$3 *t);
// inside_polygon$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 68
static signed int inside_polygon$link1(struct anonymous$3 *t$link1);
// is_left_of
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 243
static signed int is_left_of(signed int segnum, struct anonymous$1 *v);
// is_left_of$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 243
static signed int is_left_of$link1(signed int segnum$link1, struct anonymous$1 *v$link1);
// list_add_tail
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/list.h line 101
static inline void list_add_tail(struct list_head *n, struct list_head *head);
// list_del
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/list.h line 128
static inline void list_del(struct list_head *entry);
// locate_endpoint
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 300
extern signed int locate_endpoint(struct anonymous$1 *v, struct anonymous$1 *vo, signed int r);
// log
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern double log(double);
// lrand48
// file /usr/include/stdlib.h line 393
extern signed long int lrand48(void);
// mainloop
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 383
static void mainloop(void);
// make_new_monotone_poly
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 171
static signed int make_new_monotone_poly(signed int mcur, signed int v0, signed int v1);
// make_new_monotone_poly$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 171
static signed int make_new_monotone_poly$link1(signed int mcur$link1, signed int v0$link1, signed int v1$link1);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// math_N
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_misc.c line 98
extern signed int math_N(signed int n, signed int h);
// math_logstar_n
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_misc.c line 86
extern signed int math_logstar_n(signed int n);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// merge_trapezoids
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 354
static signed int merge_trapezoids(signed int segnum, signed int tfirst, signed int tlast, signed int side);
// merge_trapezoids$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 354
static signed int merge_trapezoids$link1(signed int segnum$link1, signed int tfirst$link1, signed int tlast$link1, signed int side$link1);
// mlog2
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_misc.c line 47
static double mlog2(double x);
// mlog2$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_misc.c line 47
static double mlog2$link1(double x$link1);
// model_load
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/modelread.c line 125
static signed int model_load(char *file);
// model_load$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/modelread.c line 125
static signed int model_load$link1(char *file$link1);
// monotonate_trapezoids
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 230
extern signed int monotonate_trapezoids(signed int n);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// net_prot_in
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_in.c line 34
signed int net_prot_in(unsigned char opcode, unsigned short int length, char *buf);
// net_send
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/network.c line 37
signed int net_send(unsigned char opcode, char *buf, unsigned short int length);
// new_chain_element
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 94
static signed int new_chain_element(void);
// new_chain_element$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 94
static signed int new_chain_element$link1(void);
// newmon
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 87
static signed int newmon(void);
// newmon$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 87
static signed int newmon$link1(void);
// newnode
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 53
static signed int newnode(void);
// newnode$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 53
static signed int newnode$link1(void);
// newtrap
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 64
static signed int newtrap(void);
// newtrap$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 64
static signed int newtrap$link1(void);
// ntohfb
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/endian.c line 39
void ntohfb(float *netfloat, signed int num);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// ntohlb
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/endian.c line 57
void ntohlb(unsigned int *netint32, signed int num);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// ntohsb
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/endian.c line 75
void ntohsb(unsigned short int *netint16, signed int num);
// object_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 313
static signed int object_click(struct s3d_evt *evt);
// object_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 357
static signed int object_info(struct s3d_evt *hrmz);
// parse_args
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/io.c line 80
static signed int parse_args(signed int *argc, char ***argv);
// parse_args$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/io.c line 80
static signed int parse_args$link1(signed int *argc$link1, char ***argv$link1);
// parse_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 86
static void parse_buffer(struct kismet_src *kismet_src);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$7 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$7 *);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// s3d_angle_to_cam
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 234
float s3d_angle_to_cam(const float *obj_pos, const float *cam_pos, float *angle_rad);
// s3d_clear_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/callback.c line 89
void s3d_clear_callback(unsigned char event);
// s3d_clone
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 209
signed int s3d_clone(signed int oid);
// s3d_clone_target
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 78
signed int s3d_clone_target(signed int oid, signed int toid);
// s3d_del_object
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 207
signed int s3d_del_object(signed int oid);
// s3d_delete_event
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/event.c line 99
signed int s3d_delete_event(struct s3d_evt *devt);
// s3d_draw_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 225
signed int s3d_draw_string(const char *str, float *xlen);
// s3d_find_event
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/event.c line 83
struct s3d_evt * s3d_find_event(unsigned char event);
// s3d_findfont
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/fontselect.c line 42
char * s3d_findfont(const char *mask);
// s3d_flags_off
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 216
signed int s3d_flags_off(signed int object, unsigned int flags);
// s3d_flags_on
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 215
signed int s3d_flags_on(signed int object, unsigned int flags);
// s3d_ft_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 63
static signed int s3d_ft_init(void);
// s3d_ft_init$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 63
static signed int s3d_ft_init$link1(void);
// s3d_ft_load_font
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 79
static signed int s3d_ft_load_font(void);
// s3d_ft_load_font$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 79
static signed int s3d_ft_load_font$link1(void);
// s3d_get_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/callback.c line 115
signed int (*s3d_get_callback(unsigned char event))(struct s3d_evt *);
// s3d_ignore_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/callback.c line 99
void s3d_ignore_callback(unsigned char event);
// s3d_import_model_file
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 222
signed int s3d_import_model_file(const char *fname);
// s3d_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 153
signed int s3d_init(signed int *argc, char ***argv, const char *name);
// s3d_init::$tmp::return_value_signal$7$link1$object
//
void return_value_signal$7$link1$object(signed int);
// s3d_init::$tmp::return_value_signal$7$object
//
void return_value_signal$7$object(signed int);
// s3d_init::$tmp::return_value_signal$9$link1$object
//
void return_value_signal$9$link1$object(signed int);
// s3d_init::$tmp::return_value_signal$9$object
//
void return_value_signal$9$object(signed int);
// s3d_link
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 212
signed int s3d_link(signed int oid_from, signed int oid_to);
// s3d_load_line_normals
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 201
signed int s3d_load_line_normals(signed int object, const float *nbuf, unsigned int start, unsigned short int n);
// s3d_load_materials_a
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 1013
signed int s3d_load_materials_a(signed int object, const float *mbuf, unsigned int start, unsigned short int n);
// s3d_load_polygon_normals
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 911
signed int s3d_load_polygon_normals(signed int object, const float *nbuf, unsigned int start, unsigned short int n);
// s3d_load_polygon_tex_coords
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 979
signed int s3d_load_polygon_tex_coords(signed int object, const float *tbuf, unsigned int start, unsigned short int n);
// s3d_load_texture
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 1089
signed int s3d_load_texture(signed int object, unsigned int tex, unsigned short int xpos, unsigned short int ypos, unsigned short int w, unsigned short int h, const unsigned char *data);
// s3d_mainloop
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 155
signed int s3d_mainloop(void (*f)(void));
// s3d_mainloop::f$link1$object
//
void f$link1$object(void);
// s3d_mainloop::f$object
//
void f$object(void);
// s3d_mcp_focus
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 1265
signed int s3d_mcp_focus(signed int object);
// s3d_net_check
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/network.c line 75
signed int s3d_net_check(void);
// s3d_net_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/network.c line 99
signed int s3d_net_init(char *urlc);
// s3d_new_object
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 206
signed int s3d_new_object(void);
// s3d_open_file
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/io.c line 271
signed int s3d_open_file(const char *fname, char **pointer);
// s3d_pep_line
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 794
signed int s3d_pep_line(signed int object, signed int v1, signed int v2, signed int material);
// s3d_pep_line_normals
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 752
signed int s3d_pep_line_normals(signed int object, const float *nbuf, unsigned short int n);
// s3d_pep_lines
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 818
signed int s3d_pep_lines(signed int object, const unsigned int *lbuf, unsigned short int n);
// s3d_pep_material
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 605
signed int s3d_pep_material(signed int object, float amb_r, float amb_g, float amb_b, float spec_r, float spec_g, float spec_b, float diff_r, float diff_g, float diff_b);
// s3d_pep_material_a
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 653
signed int s3d_pep_material_a(signed int object, float amb_r, float amb_g, float amb_b, float amb_a, float spec_r, float spec_g, float spec_b, float spec_a, float diff_r, float diff_g, float diff_b, float diff_a);
// s3d_pep_material_texture
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 1047
signed int s3d_pep_material_texture(signed int object, unsigned int tex);
// s3d_pep_materials_a
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 178
signed int s3d_pep_materials_a(signed int object, const float *mbuf, unsigned short int n);
// s3d_pep_polygon_normals
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 727
signed int s3d_pep_polygon_normals(signed int object, const float *nbuf, unsigned short int n);
// s3d_pep_polygon_tex_coord
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 863
signed int s3d_pep_polygon_tex_coord(signed int object, float x1, float y1, float x2, float y2, float x3, float y3);
// s3d_pep_polygon_tex_coords
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 892
signed int s3d_pep_polygon_tex_coords(signed int object, const float *tbuf, unsigned short int n);
// s3d_pep_vertex
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 771
signed int s3d_pep_vertex(signed int object, float x, float y, float z);
// s3d_pep_vertices
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 840
signed int s3d_pep_vertices(signed int object, const float *vbuf, unsigned short int n);
// s3d_pop_event
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/event.c line 71
struct s3d_evt * s3d_pop_event(void);
// s3d_pop_line
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 575
signed int s3d_pop_line(signed int object, unsigned int n);
// s3d_pop_material
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 547
signed int s3d_pop_material(signed int object, unsigned int n);
// s3d_pop_polygon
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 561
signed int s3d_pop_polygon(signed int object, unsigned int n);
// s3d_pop_texture
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 589
signed int s3d_pop_texture(signed int object, unsigned int n);
// s3d_pop_vertex
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 533
signed int s3d_pop_vertex(signed int object, unsigned int n);
// s3d_process_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/event.c line 129
void s3d_process_stack(void);
// s3d_process_stack::1::cb$link1$object
//
signed int cb$link1$object(struct s3d_evt *);
// s3d_process_stack::1::cb$object
//
signed int cb$object(struct s3d_evt *);
// s3d_push_event
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/event.c line 38
void s3d_push_event(struct s3d_evt *newevt);
// s3d_push_event::1::cb$link1$object
//
signed int cb$link1$object(struct s3d_evt *);
// s3d_push_event::1::cb$object
//
signed int cb$object(struct s3d_evt *);
// s3d_push_line
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 381
signed int s3d_push_line(signed int object, unsigned int v1, unsigned int v2, unsigned int material);
// s3d_push_lines
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 183
signed int s3d_push_lines(signed int object, const unsigned int *lbuf, unsigned short int n);
// s3d_push_material
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 160
signed int s3d_push_material(signed int object, float amb_r, float amb_g, float amb_b, float spec_r, float spec_g, float spec_b, float diff_r, float diff_g, float diff_b);
// s3d_push_material_a
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 248
signed int s3d_push_material_a(signed int object, float amb_r, float amb_g, float amb_b, float amb_a, float spec_r, float spec_g, float spec_b, float spec_a, float diff_r, float diff_g, float diff_b, float diff_a);
// s3d_push_materials_a
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 172
signed int s3d_push_materials_a(signed int object, const float *mbuf, unsigned short int n);
// s3d_push_polygon
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 180
signed int s3d_push_polygon(signed int object, unsigned int v1, unsigned int v2, unsigned int v3, unsigned int material);
// s3d_push_polygons
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 181
signed int s3d_push_polygons(signed int object, const unsigned int *pbuf, unsigned short int n);
// s3d_push_texture
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 479
signed int s3d_push_texture(signed int object, unsigned short int w, unsigned short int h);
// s3d_push_textures
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 500
signed int s3d_push_textures(signed int object, const unsigned short int *tbuf, unsigned short int n);
// s3d_push_vertex
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 158
signed int s3d_push_vertex(signed int object, float x, float y, float z);
// s3d_push_vertices
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 159
signed int s3d_push_vertices(signed int object, const float *vbuf, unsigned short int n);
// s3d_quit
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 154
signed int s3d_quit(void);
// s3d_rotate
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 218
signed int s3d_rotate(signed int object, float x, float y, float z);
// s3d_scale
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 219
signed int s3d_scale(signed int object, float s);
// s3d_select_font
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 224
signed int s3d_select_font(const char *path);
// s3d_set_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 243
void s3d_set_callback(unsigned char event, signed int (*func)(struct s3d_evt *));
// s3d_set_callback::func$link1$object
//
signed int func$link1$object(struct s3d_evt *);
// s3d_set_callback::func$object
//
signed int func$object(struct s3d_evt *);
// s3d_strlen
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 226
float s3d_strlen(const char *str);
// s3d_translate
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 217
signed int s3d_translate(signed int object, float x, float y, float z);
// s3d_unlink
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 119
signed int s3d_unlink(signed int oid);
// s3d_usage
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/io.c line 73
void s3d_usage(void);
// s3d_vector_angle
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 233
float s3d_vector_angle(const float *vector1, const float *vector2);
// s3d_vector_cross_product
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/vector.c line 74
void s3d_vector_cross_product(const float *vector1, const float *vector2, float *result_vector);
// s3d_vector_dot_product
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/vector.c line 63
float s3d_vector_dot_product(const float *vector1, const float *vector2);
// s3d_vector_length
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 230
float s3d_vector_length(const float *vector);
// s3d_vector_subtract
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/vector.c line 48
void s3d_vector_subtract(const float *vector1, const float *vector2, float *result_vector);
// s3dprintf
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 109
static inline void s3dprintf(signed int relevance, const char *fmt, ...);
// s3dprintf$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 109
static inline void s3dprintf$link1(signed int relevance$link1, const char *fmt$link1, ...);
// s3dprintf$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 109
static inline void s3dprintf$link2(signed int relevance$link2, const char *fmt$link2, ...);
// s3dw_ani_add
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 47
void s3dw_ani_add(struct _s3dw_widget *f);
// s3dw_ani_check
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 121
signed int s3dw_ani_check(struct _s3dw_widget *f);
// s3dw_ani_del
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 66
void s3dw_ani_del(signed int i);
// s3dw_ani_doit
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 78
void s3dw_ani_doit(struct _s3dw_widget *f);
// s3dw_ani_finish
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 93
void s3dw_ani_finish(struct _s3dw_widget *f, signed int i);
// s3dw_ani_iterate
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 108
void s3dw_ani_iterate(struct _s3dw_widget *f);
// s3dw_ani_mate
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 165
void s3dw_ani_mate(void);
// s3dw_ani_needarr
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 137
void s3dw_ani_needarr(void);
// s3dw_ani_stackpos
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 36
signed int s3dw_ani_stackpos(struct _s3dw_widget *f);
// s3dw_arr_normdir
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/arrange.c line 54
void s3dw_arr_normdir(float *dir);
// s3dw_arr_widgetcenter
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/arrange.c line 32
void s3dw_arr_widgetcenter(struct _s3dw_widget *widget, float *center);
// s3dw_arrange
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/arrange.c line 152
void s3dw_arrange(void);
// s3dw_button_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/button.c line 136
void s3dw_button_destroy(struct _s3dw_widget *widget);
// s3dw_button_draw
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/button.c line 31
void s3dw_button_draw(struct _s3dw_widget *widget);
// s3dw_button_erase
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/button.c line 128
void s3dw_button_erase(struct _s3dw_widget *widget);
// s3dw_button_event_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/button.c line 150
signed int s3dw_button_event_click(struct _s3dw_widget *widget, unsigned int oid);
// s3dw_button_event_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/button.c line 144
signed int s3dw_button_event_key(struct _s3dw_widget *widget, struct s3d_key_event *keys);
// s3dw_button_hide
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/button.c line 121
void s3dw_button_hide(struct _s3dw_widget *widget);
// s3dw_button_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/button.c line 96
struct _s3dw_button * s3dw_button_new(const struct _s3dw_surface *surface, const char *text, float posx, float posy);
// s3dw_button_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/button.c line 114
void s3dw_button_show(struct _s3dw_widget *widget);
// s3dw_click_nothing
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 47
signed int s3dw_click_nothing(struct _s3dw_widget *widget, unsigned int dummy);
// s3dw_delete
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 105
void s3dw_delete(struct _s3dw_widget *widget);
// s3dw_focus
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 131
void s3dw_focus(struct _s3dw_widget *focus);
// s3dw_follow
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/arrange.c line 120
static void s3dw_follow(void);
// s3dw_get_type_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 56
const char * s3dw_get_type_string(signed int type);
// s3dw_getroot
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 94
struct _s3dw_widget * s3dw_getroot(void);
// s3dw_handle_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/s3dw.h line 273
signed int s3dw_handle_click(struct s3d_evt *evt);
// s3dw_handle_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/event.c line 79
signed int s3dw_handle_key(struct s3d_evt *evt);
// s3dw_input_change_text
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 189
void s3dw_input_change_text(struct _s3dw_input *input, const char *text);
// s3dw_input_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 177
void s3dw_input_destroy(struct _s3dw_widget *widget);
// s3dw_input_draw
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 48
void s3dw_input_draw(struct _s3dw_widget *widget);
// s3dw_input_draw_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 33
unsigned int s3dw_input_draw_string(struct _s3dw_widget *widget);
// s3dw_input_erase
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 169
void s3dw_input_erase(struct _s3dw_widget *widget);
// s3dw_input_event_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 238
signed int s3dw_input_event_click(struct _s3dw_widget *widget, unsigned int oid);
// s3dw_input_event_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 203
signed int s3dw_input_event_key(struct _s3dw_widget *widget, struct s3d_key_event *keys);
// s3dw_input_gettext
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 253
char * s3dw_input_gettext(struct _s3dw_input *input);
// s3dw_input_hide
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 134
void s3dw_input_hide(struct _s3dw_widget *widget);
// s3dw_input_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 150
struct _s3dw_input * s3dw_input_new(const struct _s3dw_surface *surface, float width, float posx, float posy);
// s3dw_input_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 127
void s3dw_input_show(struct _s3dw_widget *widget);
// s3dw_key_nothing
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 51
signed int s3dw_key_nothing(struct _s3dw_widget *widget, struct s3d_key_event *dummy);
// s3dw_label_change_text
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 57
void s3dw_label_change_text(struct _s3dw_label *label, const char *text);
// s3dw_label_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 98
void s3dw_label_destroy(struct _s3dw_widget *widget);
// s3dw_label_draw
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 31
void s3dw_label_draw(struct _s3dw_widget *widget);
// s3dw_label_erase
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 93
void s3dw_label_erase(struct _s3dw_widget *widget);
// s3dw_label_event_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 111
signed int s3dw_label_event_click(struct _s3dw_widget *widget, unsigned int oid);
// s3dw_label_event_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 106
signed int s3dw_label_event_key(struct _s3dw_widget *widget, struct s3d_key_event *keys);
// s3dw_label_hide
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 48
void s3dw_label_hide(struct _s3dw_widget *widget);
// s3dw_label_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 77
struct _s3dw_label * s3dw_label_new(const struct _s3dw_surface *surface, const char *text, float posx, float posy);
// s3dw_label_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 43
void s3dw_label_show(struct _s3dw_widget *widget);
// s3dw_moveit
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 160
void s3dw_moveit(struct _s3dw_widget *widget);
// s3dw_nothing
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 44
void s3dw_nothing(struct _s3dw_widget *widget);
// s3dw_object_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/s3dw.h line 275
signed int s3dw_object_info(struct s3d_evt *evt);
// s3dw_root_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 39
void s3dw_root_destroy(struct _s3dw_widget *widget);
// s3dw_scrollbar_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/scrollbar.c line 360
void s3dw_scrollbar_destroy(struct _s3dw_widget *widget);
// s3dw_scrollbar_draw
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/scrollbar.c line 31
static void s3dw_scrollbar_draw(struct _s3dw_widget *widget);
// s3dw_scrollbar_erase
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/scrollbar.c line 351
void s3dw_scrollbar_erase(struct _s3dw_widget *widget);
// s3dw_scrollbar_event_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/scrollbar.c line 372
signed int s3dw_scrollbar_event_click(struct _s3dw_widget *widget, unsigned int oid);
// s3dw_scrollbar_event_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/scrollbar.c line 367
signed int s3dw_scrollbar_event_key(struct _s3dw_widget *widget, struct s3d_key_event *keys);
// s3dw_scrollbar_hide
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/scrollbar.c line 314
void s3dw_scrollbar_hide(struct _s3dw_widget *widget);
// s3dw_scrollbar_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/scrollbar.c line 324
struct _s3dw_scrollbar * s3dw_scrollbar_new(struct _s3dw_widget *parent, signed int type, float posx, float posy, float length);
// s3dw_scrollbar_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/scrollbar.c line 304
void s3dw_scrollbar_show(struct _s3dw_widget *widget);
// s3dw_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 119
void s3dw_show(struct _s3dw_widget *widget);
// s3dw_surface_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/surface.c line 172
void s3dw_surface_destroy(struct _s3dw_widget *widget);
// s3dw_surface_draw
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/surface.c line 32
void s3dw_surface_draw(struct _s3dw_widget *widget);
// s3dw_surface_erase
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/surface.c line 164
void s3dw_surface_erase(struct _s3dw_widget *widget);
// s3dw_surface_event_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/surface.c line 185
signed int s3dw_surface_event_click(struct _s3dw_widget *widget, unsigned int oid);
// s3dw_surface_event_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/surface.c line 180
signed int s3dw_surface_event_key(struct _s3dw_widget *widget, struct s3d_key_event *keys);
// s3dw_surface_hide
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/surface.c line 121
void s3dw_surface_hide(struct _s3dw_widget *widget);
// s3dw_surface_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/surface.c line 136
struct _s3dw_surface * s3dw_surface_new(const char *title, float width, float height);
// s3dw_surface_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/surface.c line 113
void s3dw_surface_show(struct _s3dw_widget *widget);
// s3dw_textbox_change_text
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 304
void s3dw_textbox_change_text(struct _s3dw_textbox *textbox, const char *text);
// s3dw_textbox_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 319
void s3dw_textbox_destroy(struct _s3dw_widget *widget);
// s3dw_textbox_draw
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 31
static void s3dw_textbox_draw(struct _s3dw_widget *widget);
// s3dw_textbox_drawtext
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 109
void s3dw_textbox_drawtext(struct _s3dw_widget *widget);
// s3dw_textbox_erase
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 312
void s3dw_textbox_erase(struct _s3dw_widget *widget);
// s3dw_textbox_erasetext
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 146
void s3dw_textbox_erasetext(struct _s3dw_widget *widget);
// s3dw_textbox_event_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 332
signed int s3dw_textbox_event_click(struct _s3dw_widget *widget, unsigned int oid);
// s3dw_textbox_event_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 327
signed int s3dw_textbox_event_key(struct _s3dw_widget *widget, struct s3d_key_event *keys);
// s3dw_textbox_hide
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 172
void s3dw_textbox_hide(struct _s3dw_widget *widget);
// s3dw_textbox_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 206
struct _s3dw_textbox * s3dw_textbox_new(const struct _s3dw_surface *surface, const char *text, float posx, float posy, float width, float height);
// s3dw_textbox_redraw
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 234
static void s3dw_textbox_redraw(struct _s3dw_widget *widget);
// s3dw_textbox_scrolldown
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 257
void s3dw_textbox_scrolldown(struct _s3dw_textbox *textbox);
// s3dw_textbox_scrollleft
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 268
void s3dw_textbox_scrollleft(struct _s3dw_textbox *textbox);
// s3dw_textbox_scrollright
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 279
void s3dw_textbox_scrollright(struct _s3dw_textbox *textbox);
// s3dw_textbox_scrollto
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 290
void s3dw_textbox_scrollto(struct _s3dw_textbox *textbox, signed int x, signed int y);
// s3dw_textbox_scrollup
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 246
void s3dw_textbox_scrollup(struct _s3dw_textbox *textbox);
// s3dw_textbox_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 163
void s3dw_textbox_show(struct _s3dw_widget *widget);
// s3dw_turn
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/arrange.c line 68
void s3dw_turn(void);
// s3dw_widget_append
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 71
void s3dw_widget_append(struct _s3dw_widget *parent, struct _s3dw_widget *widget);
// s3dw_widget_event_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 51
signed int s3dw_widget_event_click(struct _s3dw_widget *widget, unsigned int oid);
// s3dw_widget_event_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 61
signed int s3dw_widget_event_key(struct _s3dw_widget *widget, struct s3d_key_event *keys);
// s3dw_widget_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 29
struct _s3dw_widget * s3dw_widget_new(struct _s3dw_widget *widget);
// s3dw_widget_remove
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 82
static void s3dw_widget_remove(struct _s3dw_widget *widget);
// s3dw_widget_visible
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 142
void s3dw_widget_visible(struct _s3dw_widget *widget);
// sei_triangulate_polygon
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_tri.c line 80
extern signed int sei_triangulate_polygon(signed int ncontours, signed int *cntr, double (*vertices)[2l], signed int (*triangles)[3l]);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$13 *, struct anonymous$13 *, struct anonymous$13 *, struct timeval *);
// shm_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm_ringbuf.c line 75
unsigned int shm_read(struct buf_t *rb, char *buf, unsigned int n);
// shm_readn
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 148
signed int shm_readn(char *str, signed int s);
// shm_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm_ringbuf.c line 30
unsigned int shm_write(struct buf_t *rb, char *buf, unsigned int n);
// shm_writen
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 129
signed int shm_writen(char *str, signed int s);
// shmat
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 56
extern void * shmat(signed int, const void *, signed int);
// shmctl
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 50
extern signed int shmctl(signed int, signed int, struct shmid_ds *);
// shmdt
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 60
extern signed int shmdt(const void *);
// shmget
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 53
extern signed int shmget(signed int, unsigned long int, signed int);
// sigint_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/io.c line 59
static void sigint_handler(signed int sig, signed int code);
// sigint_handler$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/io.c line 59
static void sigint_handler$link1(signed int sig$link1, signed int code$link1);
// sigio_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 50
static void sigio_handler(signed int sig, signed int code);
// sigio_handler$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 50
static void sigio_handler$link1(signed int sig$link1, signed int code$link1);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sigpipe_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 46
static void sigpipe_handler(signed int sig, signed int code);
// sigpipe_handler$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 46
static void sigpipe_handler$link1(signed int sig$link1, signed int code$link1);
// sin
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 65
extern double sin(double);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern double sqrt(double);
// srand48
// file /usr/include/stdlib.h line 403
extern void srand48(signed long int);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// tcp_readn
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 118
signed int tcp_readn(char *str, signed int s);
// tcp_writen
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 131
signed int tcp_writen(char *str, signed int s);
// traverse_polygon
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 277
static signed int traverse_polygon(signed int mcur, signed int trnum, signed int from, signed int dir);
// traverse_polygon$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 277
static signed int traverse_polygon$link1(signed int mcur$link1, signed int trnum$link1, signed int from$link1, signed int dir$link1);
// triangulate_monotone_polygons
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 495
extern signed int triangulate_monotone_polygons(signed int nvert, signed int nmonpoly, signed int (*op)[3l]);
// triangulate_single_polygon
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 558
static signed int triangulate_single_polygon(signed int nvert, signed int posmax, signed int side, signed int (*op)[3l]);
// triangulate_single_polygon$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 558
static signed int triangulate_single_polygon$link1(signed int nvert$link1, signed int posmax$link1, signed int side$link1, signed int (*op$link1)[3l]);
// wire_sphere
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 52
static signed int wire_sphere(signed int slices, signed int stacks);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$5
{
  // filename
  char *filename;
  // context
  struct anonymous$4 *context;
  // materials
  struct _GSList *materials;
  // objects
  struct _GSList *objects;
  // tex_images
  struct _GHashTable *tex_images;
  // plugin
  struct _G3DPlugin *plugin;
};

struct anonymous$11
{
  // name
  char *name;
  // materials
  struct _GSList *materials;
  // faces
  struct _GSList *faces;
  // objects
  struct _GSList *objects;
  // transformation
  struct anonymous$6 *transformation;
  // hide
  signed int hide;
  // vertex_count
  unsigned int vertex_count;
  // vertex_data
  float *vertex_data;
  // tex_vertex_count
  unsigned int tex_vertex_count;
  // tex_vertex_data
  float *tex_vertex_data;
  // tex_image
  struct anonymous$9 *tex_image;
  // _normals
  float *_normals;
  // _materials
  struct anonymous$10 **_materials;
  // _num_faces
  unsigned int _num_faces;
  // _indices
  unsigned int *_indices;
  // _flags
  unsigned int *_flags;
  // _tex_images
  unsigned int *_tex_images;
  // _tex_coords
  float *_tex_coords;
};

struct anonymous$10
{
  // name
  char *name;
  // r
  float r;
  // g
  float g;
  // b
  float b;
  // a
  float a;
  // shininess
  float shininess;
  // specular
  float specular[4l];
  // flags
  unsigned int flags;
  // tex_image
  struct anonymous$9 *tex_image;
};

struct anonymous$9
{
  // name
  char *name;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // depth
  unsigned char depth;
  // flags
  unsigned int flags;
  // pixeldata
  unsigned char *pixeldata;
  // tex_id
  unsigned int tex_id;
  // tex_env
  enum anonymous$8 tex_env;
  // tex_scale_u
  float tex_scale_u;
  // tex_scale_v
  float tex_scale_v;
};

struct anonymous$4
{
  // plugins
  struct _GSList *plugins;
  // magic_cookie
  void *magic_cookie;
  // exts_import
  struct _GHashTable *exts_import;
  // exts_image
  struct _GHashTable *exts_image;
  // set_bgcolor_func
  signed int (*set_bgcolor_func)(float, float, float, float, void *);
  // set_bgcolor_data
  void *set_bgcolor_data;
  // update_interface_func
  signed int (*update_interface_func)(void *);
  // update_interface_data
  void *update_interface_data;
  // update_progress_bar_func
  signed int (*update_progress_bar_func)(float, signed int, void *);
  // update_progress_bar_data
  void *update_progress_bar_data;
};

struct anonymous$6
{
  // matrix
  float matrix[16l];
  // flags
  unsigned int flags;
};

struct anonymous$13
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$1
{
  // x
  double x;
  // y
  double y;
};

struct anonymous$3
{
  // lseg
  signed int lseg;
  // rseg
  signed int rseg;
  // hi
  struct anonymous$1 hi;
  // lo
  struct anonymous$1 lo;
  // u0
  signed int u0;
  // u1
  signed int u1;
  // d0
  signed int d0;
  // d1
  signed int d1;
  // sink
  signed int sink;
  // usave
  signed int usave;
  // uside
  signed int uside;
  // state
  signed int state;
};

struct anonymous$15
{
  // nodetype
  signed int nodetype;
  // segnum
  signed int segnum;
  // yval
  struct anonymous$1 yval;
  // trnum
  signed int trnum;
  // parent
  signed int parent;
  // left
  signed int left;
  // right
  signed int right;
};

struct anonymous$0
{
  // vnum
  signed int vnum;
  // next
  signed int next;
  // prev
  signed int prev;
  // marked
  signed int marked;
};

struct anonymous$2
{
  // pt
  struct anonymous$1 pt;
  // vnext
  signed int vnext[4l];
  // vpos
  signed int vpos[4l];
  // nextfree
  signed int nextfree;
};

struct anonymous$14
{
  // v0
  struct anonymous$1 v0;
  // v1
  struct anonymous$1 v1;
  // is_inserted
  signed int is_inserted;
  // root0
  signed int root0;
  // root1
  signed int root1;
  // next
  signed int next;
  // prev
  signed int prev;
};

struct anonymous$12
{
  // vertex_count
  unsigned int vertex_count;
  // vertex_indices
  unsigned int *vertex_indices;
  // material
  struct anonymous$10 *material;
  // flags
  unsigned int flags;
  // normals
  float *normals;
  // tex_image
  struct anonymous$9 *tex_image;
  // tex_vertex_count
  unsigned int tex_vertex_count;
  // tex_vertex_data
  float *tex_vertex_data;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$7
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous
{
  // err_code
  signed int err_code;
  // err_msg
  const char *err_msg;
};

struct FT_BBox_
{
  // xMin
  signed long int xMin;
  // yMin
  signed long int yMin;
  // xMax
  signed long int xMax;
  // yMax
  signed long int yMax;
};

struct FT_Bitmap_
{
  // rows
  unsigned int rows;
  // width
  unsigned int width;
  // pitch
  signed int pitch;
  // buffer
  unsigned char *buffer;
  // num_grays
  unsigned short int num_grays;
  // pixel_mode
  unsigned char pixel_mode;
  // palette_mode
  unsigned char palette_mode;
  // palette
  void *palette;
};

struct FT_Bitmap_Size_
{
  // height
  signed short int height;
  // width
  signed short int width;
  // size
  signed long int size;
  // x_ppem
  signed long int x_ppem;
  // y_ppem
  signed long int y_ppem;
};

struct FT_CharMapRec_
{
  // face
  struct FT_FaceRec_ *face;
  // encoding
  enum FT_Encoding_ encoding;
  // platform_id
  unsigned short int platform_id;
  // encoding_id
  unsigned short int encoding_id;
};

struct FT_Generic_
{
  // data
  void *data;
  // finalizer
  void (*finalizer)(void *);
};

struct FT_ListRec_
{
  // head
  struct FT_ListNodeRec_ *head;
  // tail
  struct FT_ListNodeRec_ *tail;
};

struct FT_FaceRec_
{
  // num_faces
  signed long int num_faces;
  // face_index
  signed long int face_index;
  // face_flags
  signed long int face_flags;
  // style_flags
  signed long int style_flags;
  // num_glyphs
  signed long int num_glyphs;
  // family_name
  char *family_name;
  // style_name
  char *style_name;
  // num_fixed_sizes
  signed int num_fixed_sizes;
  // available_sizes
  struct FT_Bitmap_Size_ *available_sizes;
  // num_charmaps
  signed int num_charmaps;
  // charmaps
  struct FT_CharMapRec_ **charmaps;
  // generic
  struct FT_Generic_ generic;
  // bbox
  struct FT_BBox_ bbox;
  // units_per_EM
  unsigned short int units_per_EM;
  // ascender
  signed short int ascender;
  // descender
  signed short int descender;
  // height
  signed short int height;
  // max_advance_width
  signed short int max_advance_width;
  // max_advance_height
  signed short int max_advance_height;
  // underline_position
  signed short int underline_position;
  // underline_thickness
  signed short int underline_thickness;
  // glyph
  struct FT_GlyphSlotRec_ *glyph;
  // size
  struct FT_SizeRec_ *size;
  // charmap
  struct FT_CharMapRec_ *charmap;
  // driver
  struct FT_DriverRec_ *driver;
  // memory
  struct FT_MemoryRec_ *memory;
  // stream
  struct FT_StreamRec_ *stream;
  // sizes_list
  struct FT_ListRec_ sizes_list;
  // autohint
  struct FT_Generic_ autohint;
  // extensions
  void *extensions;
  // internal
  struct FT_Face_InternalRec_ *internal;
};

struct FT_Glyph_Metrics_
{
  // width
  signed long int width;
  // height
  signed long int height;
  // horiBearingX
  signed long int horiBearingX;
  // horiBearingY
  signed long int horiBearingY;
  // horiAdvance
  signed long int horiAdvance;
  // vertBearingX
  signed long int vertBearingX;
  // vertBearingY
  signed long int vertBearingY;
  // vertAdvance
  signed long int vertAdvance;
};

struct FT_Vector_
{
  // x
  signed long int x;
  // y
  signed long int y;
};

struct FT_Outline_
{
  // n_contours
  signed short int n_contours;
  // n_points
  signed short int n_points;
  // points
  struct FT_Vector_ *points;
  // tags
  char *tags;
  // contours
  signed short int *contours;
  // flags
  signed int flags;
};

struct FT_GlyphSlotRec_
{
  // library
  struct FT_LibraryRec_ *library;
  // face
  struct FT_FaceRec_ *face;
  // next
  struct FT_GlyphSlotRec_ *next;
  // reserved
  unsigned int reserved;
  // generic
  struct FT_Generic_ generic;
  // metrics
  struct FT_Glyph_Metrics_ metrics;
  // linearHoriAdvance
  signed long int linearHoriAdvance;
  // linearVertAdvance
  signed long int linearVertAdvance;
  // advance
  struct FT_Vector_ advance;
  // format
  enum FT_Glyph_Format_ format;
  // bitmap
  struct FT_Bitmap_ bitmap;
  // bitmap_left
  signed int bitmap_left;
  // bitmap_top
  signed int bitmap_top;
  // outline
  struct FT_Outline_ outline;
  // num_subglyphs
  unsigned int num_subglyphs;
  // subglyphs
  struct FT_SubGlyphRec_ *subglyphs;
  // control_data
  void *control_data;
  // control_len
  signed long int control_len;
  // lsb_delta
  signed long int lsb_delta;
  // rsb_delta
  signed long int rsb_delta;
  // other
  void *other;
  // internal
  struct FT_Slot_InternalRec_ *internal;
};

struct FT_ListNodeRec_
{
  // prev
  struct FT_ListNodeRec_ *prev;
  // next
  struct FT_ListNodeRec_ *next;
  // data
  void *data;
};

struct FT_MemoryRec_
{
  // user
  void *user;
  // alloc
  void * (*alloc)(struct FT_MemoryRec_ *, signed long int);
  // free
  void (*free)(struct FT_MemoryRec_ *, void *);
  // realloc
  void * (*realloc)(struct FT_MemoryRec_ *, signed long int, signed long int, void *);
};

struct FT_Size_Metrics_
{
  // x_ppem
  unsigned short int x_ppem;
  // y_ppem
  unsigned short int y_ppem;
  // x_scale
  signed long int x_scale;
  // y_scale
  signed long int y_scale;
  // ascender
  signed long int ascender;
  // descender
  signed long int descender;
  // height
  signed long int height;
  // max_advance
  signed long int max_advance;
};

struct FT_SizeRec_
{
  // face
  struct FT_FaceRec_ *face;
  // generic
  struct FT_Generic_ generic;
  // metrics
  struct FT_Size_Metrics_ metrics;
  // internal
  struct FT_Size_InternalRec_ *internal;
};

union FT_StreamDesc_
{
  // value
  signed long int value;
  // pointer
  void *pointer;
};

struct FT_StreamRec_
{
  // base
  unsigned char *base;
  // size
  unsigned long int size;
  // pos
  unsigned long int pos;
  // descriptor
  union FT_StreamDesc_ descriptor;
  // pathname
  union FT_StreamDesc_ pathname;
  // read
  unsigned long int (*read)(struct FT_StreamRec_ *, unsigned long int, unsigned char *, unsigned long int);
  // close
  void (*close)(struct FT_StreamRec_ *);
  // memory
  struct FT_MemoryRec_ *memory;
  // cursor
  unsigned char *cursor;
  // limit
  unsigned char *limit;
};

struct _GSList
{
  // data
  void *data;
  // next
  struct _GSList *next;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _s3dw_widget
{
  // type
  signed int type;
  // parent
  struct _s3dw_widget *parent;
  // style
  struct _s3dw_style *style;
  // nobj
  signed int nobj;
  // pobj
  struct _s3dw_widget **pobj;
  // focus
  signed int focus;
  // flags
  signed int flags;
  // ax
  float ax;
  // ay
  float ay;
  // az
  float az;
  // as
  float as;
  // arx
  float arx;
  // ary
  float ary;
  // arz
  float arz;
  // width
  float width;
  // height
  float height;
  // oid
  unsigned int oid;
  // ptr
  void *ptr;
  // x
  float x;
  // y
  float y;
  // z
  float z;
  // s
  float s;
  // rx
  float rx;
  // ry
  float ry;
  // rz
  float rz;
};

struct _s3dw_button
{
  // widget
  struct _s3dw_widget widget;
  // text
  char *text;
  // oid_text
  unsigned int oid_text;
  // onclick
  void (*onclick)(struct _s3dw_widget *);
};

struct _s3dw_input
{
  // widget
  struct _s3dw_widget widget;
  // text
  char *text;
  // oid_text
  unsigned int oid_text;
  // onclick
  void (*onclick)(struct _s3dw_widget *);
  // onedit
  void (*onedit)(struct _s3dw_widget *);
};

struct _s3dw_label
{
  // widget
  struct _s3dw_widget widget;
  // text
  char *text;
  // onclick
  void (*onclick)(struct _s3dw_widget *);
};

struct _s3dw_scrollbar
{
  // widget
  struct _s3dw_widget widget;
  // pos
  float pos;
  // max
  float max;
  // type
  signed int type;
  // loid
  signed int loid;
  // roid
  signed int roid;
  // baroid
  signed int baroid;
  // lonclick
  void (*lonclick)(struct _s3dw_widget *);
  // ronclick
  void (*ronclick)(struct _s3dw_widget *);
};

struct _s3dw_style
{
  // name
  const char *name;
  // fontface
  const char *fontface;
  // surface_mat
  float surface_mat[12l];
  // input_mat
  float input_mat[12l];
  // inputback_mat
  float inputback_mat[12l];
  // text_mat
  float text_mat[12l];
  // title_mat
  float title_mat[12l];
  // title_text_mat
  float title_text_mat[12l];
};

struct _s3dw_surface
{
  // widget
  struct _s3dw_widget widget;
  // oid_title
  unsigned int oid_title;
  // oid_tbar
  unsigned int oid_tbar;
  // title
  char *title;
};

struct _s3dw_textbox
{
  // widget
  struct _s3dw_widget widget;
  // scroll_vertical
  struct _s3dw_scrollbar *scroll_vertical;
  // scroll_horizontal
  struct _s3dw_scrollbar *scroll_horizontal;
  // text
  char *text;
  // n_lineoids
  signed int n_lineoids;
  // p_lineoids
  signed int *p_lineoids;
  // window_x
  signed int window_x;
  // window_y
  signed int window_y;
  // onclick
  void (*onclick)(struct _s3dw_widget *);
};

struct buf_t
{
  // start
  unsigned int start;
  // end
  unsigned int end;
  // bufsize
  unsigned int bufsize;
};

struct element_t
{
  // data
  void *data;
  // next
  struct element_t *next;
};

struct hash_it_t
{
  // index
  signed int index;
  // bucket
  struct element_t *bucket;
  // prev_bucket
  struct element_t *prev_bucket;
  // first_bucket
  struct element_t **first_bucket;
};

struct hashtable_t
{
  // table
  struct element_t **table;
  // elements
  signed int elements;
  // size
  signed int size;
  // compare
  signed int (*compare)(const void *, const void *);
  // choose
  signed int (*choose)(const void *, signed int);
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct ipc_perm
{
  // __key
  signed int __key;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // cuid
  unsigned int cuid;
  // cgid
  unsigned int cgid;
  // mode
  unsigned short int mode;
  // __pad1
  unsigned short int __pad1;
  // __seq
  unsigned short int __seq;
  // __pad2
  unsigned short int __pad2;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
};

struct list_head
{
  // next
  struct list_head *next;
  // prev
  struct list_head *prev;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct kismet_src
{
  // list
  struct list_head list;
  // ip
  unsigned int ip;
  // port
  signed int port;
  // sock
  signed int sock;
  // kismet_ip
  char *kismet_ip;
  // recv_buff
  char *recv_buff;
  // kismet_addr
  struct sockaddr_in kismet_addr;
  // enable_level
  signed int enable_level;
};

struct material2texture
{
  // next_ptr
  struct material2texture *next_ptr;
  // material_ptr
  void *material_ptr;
  // texture_ptr
  void *texture_ptr;
  // material_id
  signed int material_id;
  // texture_id
  signed int texture_id;
};

struct mcp_object
{
  // object
  unsigned int object;
  // trans_x
  float trans_x;
  // trans_y
  float trans_y;
  // trans_z
  float trans_z;
  // r
  float r;
  // name
  char name[256l];
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct s3d_evt
{
  // event
  unsigned char event;
  // length
  signed int length;
  // buf
  char *buf;
  // next
  struct s3d_evt *next;
};

struct s3d_key_event
{
  // keysym
  unsigned short int keysym;
  // unicode
  unsigned short int unicode;
  // modifier
  unsigned short int modifier;
  // state
  unsigned short int state;
};

struct s3d_obj_info
{
  // object
  unsigned int object;
  // flags
  unsigned int flags;
  // trans_x
  float trans_x;
  // trans_y
  float trans_y;
  // trans_z
  float trans_z;
  // rot_x
  float rot_x;
  // rot_y
  float rot_y;
  // rot_z
  float rot_z;
  // scale
  float scale;
  // r
  float r;
  // name
  char name[256l];
};

struct s3d_texshm
{
  // oid
  signed int oid;
  // tex
  signed int tex;
  // shmid
  signed int shmid;
  // tw
  unsigned short int tw;
  // th
  unsigned short int th;
  // w
  unsigned short int w;
  // h
  unsigned short int h;
} __attribute__ ((__packed__));

struct s3d_tex
{
  // tshm
  struct s3d_texshm tshm;
  // buf
  char *buf;
} __attribute__ ((__packed__));

struct shmid_ds
{
  // shm_perm
  struct ipc_perm shm_perm;
  // shm_segsz
  unsigned long int shm_segsz;
  // shm_atime
  signed long int shm_atime;
  // shm_dtime
  signed long int shm_dtime;
  // shm_ctime
  signed long int shm_ctime;
  // shm_cpid
  signed int shm_cpid;
  // shm_lpid
  signed int shm_lpid;
  // shm_nattch
  unsigned long int shm_nattch;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
  // __glibc_reserved5
  unsigned long int __glibc_reserved5;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct t_buf
{
  // vbuf
  float *vbuf;
  // pbuf
  unsigned int *pbuf;
  // pn
  signed int pn;
  // vn
  signed int vn;
  // xoff
  float xoff;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct wlan_client
{
  // list
  struct list_head list;
  // bssid
  char bssid[18l];
  // mac
  char mac[18l];
  // ip
  char ip[16l];
  // wlan_network
  struct wlan_network *wlan_network;
  // props_changed
  signed int props_changed;
  // visible
  signed int visible;
  // pos_vec
  float pos_vec[3l];
  // mov_vec
  float mov_vec[3l];
  // obj_id
  signed int obj_id;
  // symbol_id
  signed int symbol_id;
  // ip_id
  signed int ip_id;
  // ip_len
  float ip_len;
};

struct wlan_network
{
  // list
  struct list_head list;
  // bssid
  char bssid[18l];
  // ssid
  char *ssid;
  // type
  signed int type;
  // chan
  signed int chan;
  // num_wlan_clients
  signed int num_wlan_clients;
  // props_changed
  signed int props_changed;
  // visible
  signed int visible;
  // pos_vec
  float pos_vec[3l];
  // obj_id
  signed int obj_id;
  // wrsphr_id
  signed int wrsphr_id;
  // bssid_id
  signed int bssid_id;
  // click_id
  signed int click_id;
  // ssid_id
  signed int ssid_id;
  // misc_id
  signed int misc_id;
  // rotation
  signed int rotation;
  // scale_fac
  signed int scale_fac;
  // text_width
  float text_width;
};


// CamPosition
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 37
static float CamPosition[2l][3l];
// Cam_target
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 42
static void *Cam_target = (void *)0;
// Client_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 43
struct list_head Client_list;
// Client_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 43
struct list_head Client_list = { .next=&Client_list, .prev=&Client_list };
// Client_list_mutex
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 47
union anonymous$7 Client_list_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// Client_obj
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 44
static signed int Client_obj;
// Kism3d_aborted
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 50
signed int Kism3d_aborted = 0;
// Last_Click_Oid
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 39
static signed int Last_Click_Oid = 0;
// Last_Click_Time
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 40
static unsigned int Last_Click_Time = (unsigned int)0;
// Network_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 42
struct list_head Network_list;
// Network_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 42
struct list_head Network_list = { .next=&Network_list, .prev=&Network_list };
// Network_list_mutex
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 46
union anonymous$7 Network_list_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// Num_networks
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 51
signed int Num_networks = 0;
// _s3d_ready
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/io.c line 66
signed int _s3d_ready = 0;
// _s3d_sigio
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/io.c line 58
signed int _s3d_sigio = 0;
// _s3dw_cam
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/arrange.c line 30
struct _s3dw_widget *_s3dw_cam = (struct _s3dw_widget *)(void *)0;
// ani_n
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 31
static signed int ani_n = 0;
// ani_need_arr
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 33
signed int ani_need_arr = 0;
// ani_s
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 30
static struct _s3dw_widget *ani_s[128l];
// animation_on
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 32
static signed int animation_on = 0;
// cb_lock
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/event.c line 31
signed int cb_lock = 2;
// chain_idx
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 61
static signed int chain_idx;
// chain_idx$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 61
static signed int chain_idx$link1;
// choose_idx
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_misc.c line 45
static signed int choose_idx;
// choose_idx$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_misc.c line 45
static signed int choose_idx$link1;
// con_type
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/network.c line 32
signed int con_type = 0;
// data_in
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 47
static struct buf_t *data_in;
// data_in$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 47
static struct buf_t *data_in$link1;
// data_out
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 47
static struct buf_t *data_out;
// data_out$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 47
static struct buf_t *data_out$link1;
// def_style
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/style.c line 31
struct _s3dw_style def_style = { .name="default", .fontface="vera", .surface_mat={ (float)0.7, (float)0.7, (float)0.7, (float)1.0, (float)0.7, (float)0.7, (float)0.7, (float)1.0, (float)0.7, (float)0.7, (float)0.7, (float)1.0 }, .input_mat={ (float)0.7, (float)0.7, (float)0.7, (float)1.0, (float)0.7, (float)0.7, (float)0.7, (float)1.0, (float)0.7, (float)0.7, (float)0.7, (float)1.0 },
    .inputback_mat={ (float)0.9, (float)0.9, (float)0.9, (float)1.0, (float)0.9, (float)0.9, (float)0.9, (float)1.0, (float)0.9, (float)0.9, (float)0.9, (float)1.0 },
    .text_mat={ (float)0.0, (float)0.0, (float)0.0, (float)1.0, (float)1.0, (float)1.0, (float)1.0, (float)1.0, (float)0.0, (float)0.0, (float)0.0, (float)1.0 },
    .title_mat={ (float)0.0, (float)0.4, (float)0.8, (float)1.0, (float)1.0, (float)1.0, (float)1.0, (float)1.0, (float)0.0, (float)0.4, (float)0.8, (float)1.0 },
    .title_text_mat={ (float)0.0, (float)0.0, (float)0.0, (float)1.0, (float)0.0, (float)0.0, (float)0.0, (float)1.0, (float)0.0, (float)0.0, (float)0.0, (float)1.0 } };
// face
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 51
static struct FT_FaceRec_ *face;
// face$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 51
static struct FT_FaceRec_ *face$link1;
// face_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 56
static signed int face_init = 0;
// face_init$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 56
static signed int face_init$link1 = 0;
// ft_errors
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 42
static struct anonymous ft_errors[92l] = { { .err_code=0, .err_msg="no error" }, { .err_code=1, .err_msg="cannot open resource" },
    { .err_code=2, .err_msg="unknown file format" },
    { .err_code=3, .err_msg="broken file" },
    { .err_code=4, .err_msg="invalid FreeType version" },
    { .err_code=5, .err_msg="module version is too low" },
    { .err_code=6, .err_msg="invalid argument" },
    { .err_code=7, .err_msg="unimplemented feature" },
    { .err_code=8, .err_msg="broken table" },
    { .err_code=9, .err_msg="broken offset within table" },
    { .err_code=10, .err_msg="array allocation size too large" },
    { .err_code=11, .err_msg="missing module" },
    { .err_code=12, .err_msg="missing property" },
    { .err_code=16, .err_msg="invalid glyph index" },
    { .err_code=17, .err_msg="invalid character code" },
    { .err_code=18, .err_msg="unsupported glyph image format" },
    { .err_code=19, .err_msg="cannot render this glyph format" },
    { .err_code=20, .err_msg="invalid outline" },
    { .err_code=21, .err_msg="invalid composite glyph" },
    { .err_code=22, .err_msg="too many hints" },
    { .err_code=23, .err_msg="invalid pixel size" },
    { .err_code=32, .err_msg="invalid object handle" },
    { .err_code=33, .err_msg="invalid library handle" },
    { .err_code=34, .err_msg="invalid module handle" },
    { .err_code=35, .err_msg="invalid face handle" },
    { .err_code=36, .err_msg="invalid size handle" },
    { .err_code=37, .err_msg="invalid glyph slot handle" },
    { .err_code=38, .err_msg="invalid charmap handle" },
    { .err_code=39, .err_msg="invalid cache manager handle" },
    { .err_code=40, .err_msg="invalid stream handle" },
    { .err_code=48, .err_msg="too many modules" },
    { .err_code=49, .err_msg="too many extensions" },
    { .err_code=64, .err_msg="out of memory" },
    { .err_code=65, .err_msg="unlisted object" },
    { .err_code=81, .err_msg="cannot open stream" },
    { .err_code=82, .err_msg="invalid stream seek" },
    { .err_code=83, .err_msg="invalid stream skip" },
    { .err_code=84, .err_msg="invalid stream read" },
    { .err_code=85, .err_msg="invalid stream operation" },
    { .err_code=86, .err_msg="invalid frame operation" },
    { .err_code=87, .err_msg="nested frame access" },
    { .err_code=88, .err_msg="invalid frame read" },
    { .err_code=96, .err_msg="raster uninitialized" },
    { .err_code=97, .err_msg="raster corrupted" },
    { .err_code=98, .err_msg="raster overflow" },
    { .err_code=99, .err_msg="negative height while rastering" },
    { .err_code=112, .err_msg="too many registered caches" },
    { .err_code=128, .err_msg="invalid opcode" },
    { .err_code=129, .err_msg="too few arguments" },
    { .err_code=130, .err_msg="stack overflow" },
    { .err_code=131, .err_msg="code overflow" },
    { .err_code=132, .err_msg="bad argument" },
    { .err_code=133, .err_msg="division by zero" },
    { .err_code=134, .err_msg="invalid reference" },
    { .err_code=135, .err_msg="found debug opcode" },
    { .err_code=136, .err_msg="found ENDF opcode in execution stream" },
    { .err_code=137, .err_msg="nested DEFS" },
    { .err_code=138, .err_msg="invalid code range" },
    { .err_code=139, .err_msg="execution context too long" },
    { .err_code=140, .err_msg="too many function definitions" },
    { .err_code=141, .err_msg="too many instruction definitions" },
    { .err_code=142, .err_msg="SFNT font table missing" },
    { .err_code=143, .err_msg="horizontal header (hhea) table missing" },
    { .err_code=144, .err_msg="locations (loca) table missing" },
    { .err_code=145, .err_msg="name table missing" },
    { .err_code=146, .err_msg="character map (cmap) table missing" },
    { .err_code=147, .err_msg="horizontal metrics (hmtx) table missing" },
    { .err_code=148, .err_msg="PostScript (post) table missing" },
    { .err_code=149, .err_msg="invalid horizontal metrics" },
    { .err_code=150, .err_msg="invalid character map (cmap) format" },
    { .err_code=151, .err_msg="invalid ppem value" },
    { .err_code=152, .err_msg="invalid vertical metrics" },
    { .err_code=153, .err_msg="could not find context" },
    { .err_code=154, .err_msg="invalid PostScript (post) table format" },
    { .err_code=155, .err_msg="invalid PostScript (post) table" },
    { .err_code=160, .err_msg="opcode syntax error" },
    { .err_code=161, .err_msg="argument stack underflow" },
    { .err_code=162, .err_msg="ignore" }, { .err_code=163, .err_msg="no Unicode glyph name found" },
    { .err_code=164, .err_msg="glyph to big for hinting" },
    { .err_code=176, .err_msg="`STARTFONT' field missing" },
    { .err_code=177, .err_msg="`FONT' field missing" },
    { .err_code=178, .err_msg="`SIZE' field missing" },
    { .err_code=179, .err_msg="`FONTBOUNDINGBOX' field missing" },
    { .err_code=180, .err_msg="`CHARS' field missing" },
    { .err_code=181, .err_msg="`STARTCHAR' field missing" },
    { .err_code=182, .err_msg="`ENCODING' field missing" },
    { .err_code=183, .err_msg="`BBX' field missing" },
    { .err_code=184, .err_msg="`BBX' too big" },
    { .err_code=185, .err_msg="Font header corrupted or missing fields" },
    { .err_code=186, .err_msg="Font glyphs corrupted or missing fields" },
    { .err_code=0, .err_msg=((const char *)NULL) } };
// ft_errors$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 42
static struct anonymous ft_errors$link1[92l] = { { .err_code=0, .err_msg="no error" }, { .err_code=1, .err_msg="cannot open resource" },
    { .err_code=2, .err_msg="unknown file format" },
    { .err_code=3, .err_msg="broken file" },
    { .err_code=4, .err_msg="invalid FreeType version" },
    { .err_code=5, .err_msg="module version is too low" },
    { .err_code=6, .err_msg="invalid argument" },
    { .err_code=7, .err_msg="unimplemented feature" },
    { .err_code=8, .err_msg="broken table" },
    { .err_code=9, .err_msg="broken offset within table" },
    { .err_code=10, .err_msg="array allocation size too large" },
    { .err_code=11, .err_msg="missing module" },
    { .err_code=12, .err_msg="missing property" },
    { .err_code=16, .err_msg="invalid glyph index" },
    { .err_code=17, .err_msg="invalid character code" },
    { .err_code=18, .err_msg="unsupported glyph image format" },
    { .err_code=19, .err_msg="cannot render this glyph format" },
    { .err_code=20, .err_msg="invalid outline" },
    { .err_code=21, .err_msg="invalid composite glyph" },
    { .err_code=22, .err_msg="too many hints" },
    { .err_code=23, .err_msg="invalid pixel size" },
    { .err_code=32, .err_msg="invalid object handle" },
    { .err_code=33, .err_msg="invalid library handle" },
    { .err_code=34, .err_msg="invalid module handle" },
    { .err_code=35, .err_msg="invalid face handle" },
    { .err_code=36, .err_msg="invalid size handle" },
    { .err_code=37, .err_msg="invalid glyph slot handle" },
    { .err_code=38, .err_msg="invalid charmap handle" },
    { .err_code=39, .err_msg="invalid cache manager handle" },
    { .err_code=40, .err_msg="invalid stream handle" },
    { .err_code=48, .err_msg="too many modules" },
    { .err_code=49, .err_msg="too many extensions" },
    { .err_code=64, .err_msg="out of memory" },
    { .err_code=65, .err_msg="unlisted object" },
    { .err_code=81, .err_msg="cannot open stream" },
    { .err_code=82, .err_msg="invalid stream seek" },
    { .err_code=83, .err_msg="invalid stream skip" },
    { .err_code=84, .err_msg="invalid stream read" },
    { .err_code=85, .err_msg="invalid stream operation" },
    { .err_code=86, .err_msg="invalid frame operation" },
    { .err_code=87, .err_msg="nested frame access" },
    { .err_code=88, .err_msg="invalid frame read" },
    { .err_code=96, .err_msg="raster uninitialized" },
    { .err_code=97, .err_msg="raster corrupted" },
    { .err_code=98, .err_msg="raster overflow" },
    { .err_code=99, .err_msg="negative height while rastering" },
    { .err_code=112, .err_msg="too many registered caches" },
    { .err_code=128, .err_msg="invalid opcode" },
    { .err_code=129, .err_msg="too few arguments" },
    { .err_code=130, .err_msg="stack overflow" },
    { .err_code=131, .err_msg="code overflow" },
    { .err_code=132, .err_msg="bad argument" },
    { .err_code=133, .err_msg="division by zero" },
    { .err_code=134, .err_msg="invalid reference" },
    { .err_code=135, .err_msg="found debug opcode" },
    { .err_code=136, .err_msg="found ENDF opcode in execution stream" },
    { .err_code=137, .err_msg="nested DEFS" },
    { .err_code=138, .err_msg="invalid code range" },
    { .err_code=139, .err_msg="execution context too long" },
    { .err_code=140, .err_msg="too many function definitions" },
    { .err_code=141, .err_msg="too many instruction definitions" },
    { .err_code=142, .err_msg="SFNT font table missing" },
    { .err_code=143, .err_msg="horizontal header (hhea) table missing" },
    { .err_code=144, .err_msg="locations (loca) table missing" },
    { .err_code=145, .err_msg="name table missing" },
    { .err_code=146, .err_msg="character map (cmap) table missing" },
    { .err_code=147, .err_msg="horizontal metrics (hmtx) table missing" },
    { .err_code=148, .err_msg="PostScript (post) table missing" },
    { .err_code=149, .err_msg="invalid horizontal metrics" },
    { .err_code=150, .err_msg="invalid character map (cmap) format" },
    { .err_code=151, .err_msg="invalid ppem value" },
    { .err_code=152, .err_msg="invalid vertical metrics" },
    { .err_code=153, .err_msg="could not find context" },
    { .err_code=154, .err_msg="invalid PostScript (post) table format" },
    { .err_code=155, .err_msg="invalid PostScript (post) table" },
    { .err_code=160, .err_msg="opcode syntax error" },
    { .err_code=161, .err_msg="argument stack underflow" },
    { .err_code=162, .err_msg="ignore" }, { .err_code=163, .err_msg="no Unicode glyph name found" },
    { .err_code=164, .err_msg="glyph to big for hinting" },
    { .err_code=176, .err_msg="`STARTFONT' field missing" },
    { .err_code=177, .err_msg="`FONT' field missing" },
    { .err_code=178, .err_msg="`SIZE' field missing" },
    { .err_code=179, .err_msg="`FONTBOUNDINGBOX' field missing" },
    { .err_code=180, .err_msg="`CHARS' field missing" },
    { .err_code=181, .err_msg="`STARTCHAR' field missing" },
    { .err_code=182, .err_msg="`ENCODING' field missing" },
    { .err_code=183, .err_msg="`BBX' field missing" },
    { .err_code=184, .err_msg="`BBX' too big" },
    { .err_code=185, .err_msg="Font header corrupted or missing fields" },
    { .err_code=186, .err_msg="Font glyphs corrupted or missing fields" },
    { .err_code=0, .err_msg=((const char *)NULL) } };
// ft_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 55
static signed int ft_init = 0;
// ft_init$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 55
static signed int ft_init$link1 = 0;
// kismet_src_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 41
static struct list_head kismet_src_list;
// kismet_src_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 41
static struct list_head kismet_src_list = { .next=&kismet_src_list, .prev=&kismet_src_list };
// library
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 50
static struct FT_LibraryRec_ *library;
// library$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 50
static struct FT_LibraryRec_ *library$link1;
// mat2tex_root
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/modelread.c line 42
static struct material2texture *mat2tex_root = (struct material2texture *)(void *)0;
// mat2tex_root$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/modelread.c line 42
static struct material2texture *mat2tex_root$link1 = (struct material2texture *)(void *)0;
// mchain
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 47
static struct anonymous$0 mchain[800l];
// mchain$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 47
static struct anonymous$0 mchain$link1[800l];
// memory_font
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 52
static char *memory_font = (char *)(void *)0;
// memory_font$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 52
static char *memory_font$link1 = (char *)(void *)0;
// memory_font_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 54
static signed int memory_font_size = 0;
// memory_font_size$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 54
static signed int memory_font_size$link1 = 0;
// mon
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 58
static signed int mon[200l];
// mon$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 58
static signed int mon$link1[200l];
// mon_idx
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 61
static signed int mon_idx;
// mon_idx$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 61
static signed int mon_idx$link1;
// oldfontpath
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 53
static char oldfontpath[256l];
// oldfontpath$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 53
static char oldfontpath$link1[256l];
// op_idx
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 61
static signed int op_idx;
// op_idx$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 61
static signed int op_idx$link1;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// opterr
// file /usr/include/getopt.h line 76
extern signed int opterr;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// permute
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_misc.c line 46
static signed int permute[200l];
// permute$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_misc.c line 46
static signed int permute$link1[200l];
// q_idx
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 49
static signed int q_idx;
// q_idx$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 49
static signed int q_idx$link1;
// qs
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 45
struct anonymous$15 qs[1600l];
// queue
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/object_queue.c line 44
static unsigned int *queue;
// queue$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/object_queue.c line 44
static unsigned int *queue$link1;
// queue_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/object_queue.c line 45
static signed int queue_size = 0;
// queue_size$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/object_queue.c line 45
static signed int queue_size$link1 = 0;
// requested
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/object_queue.c line 46
static signed int requested;
// requested$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/object_queue.c line 46
static signed int requested$link1;
// root
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 36
static struct _s3dw_widget *root = (struct _s3dw_widget *)(void *)0;
// s3d_cb_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/callback.c line 32
signed int (*s3d_cb_list[256l])(struct s3d_evt *);
// s3d_cb_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/callback.c line 32
signed int (*s3d_cb_list[256l])(struct s3d_evt *) = { (signed int (*)(struct s3d_evt *))(void *)0,
    _s3d_ignore, _s3d_ignore, _s3d_ignore, _s3d_ignore, _s3d_ignore, (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    _s3d_ignore, _s3d_ignore, (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    _s3d_ignore, (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0,
    (signed int (*)(struct s3d_evt *))(void *)0 };
// s3d_socket
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 43
static signed int s3d_socket;
// s3d_socket$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 43
static signed int s3d_socket$link1;
// s3d_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/event.c line 30
static struct s3d_evt *s3d_stack;
// s3d_stack$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/event.c line 30
static struct s3d_evt *s3d_stack$link1;
// s3d_thread_id
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 45
static unsigned long int s3d_thread_id;
// s3dwcb_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 32
signed int (*s3dwcb_click[8l])(struct _s3dw_widget *, unsigned int);
// s3dwcb_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 31
void (*s3dwcb_destroy[8l])(struct _s3dw_widget *);
// s3dwcb_hide
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 30
void (*s3dwcb_hide[8l])(struct _s3dw_widget *);
// s3dwcb_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 33
signed int (*s3dwcb_key[8l])(struct _s3dw_widget *, struct s3d_key_event *);
// s3dwcb_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 29
void (*s3dwcb_show[8l])(struct _s3dw_widget *);
// seg
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 47
struct anonymous$14 seg[200l];
// shm_idle
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 49
static signed int shm_idle = 0;
// shm_idle$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 49
static signed int shm_idle$link1 = 0;
// shmid_in
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 48
static signed int shmid_in;
// shmid_in$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 48
static signed int shmid_in$link1;
// shmid_out
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 48
static signed int shmid_out;
// shmid_out$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 48
static signed int shmid_out$link1;
// sleeptime
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 46
static struct timespec sleeptime = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)(100 * 1000 * 1000) };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// t
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 50
static struct timespec t = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)(10 * 1000 * 1000) };
// t$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 50
static struct timespec t$link1 = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)(10 * 1000 * 1000) };
// tess_buf
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 58
static struct t_buf tess_buf[256l];
// tess_buf$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 58
static struct t_buf tess_buf$link1[256l];
// tex_hash
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 38
static struct hashtable_t *tex_hash = (struct hashtable_t *)(void *)0;
// tex_hash$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 38
static struct hashtable_t *tex_hash$link1 = (struct hashtable_t *)(void *)0;
// thread_running
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 49
static signed int thread_running = 0;
// tr
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 46
struct anonymous$3 tr[800l];
// tr_idx
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 50
static signed int tr_idx;
// tr_idx$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 50
static signed int tr_idx$link1;
// url
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/io.c line 55
static char *url = (char *)(void *)0;
// url$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/io.c line 55
static char *url$link1 = (char *)(void *)0;
// vert
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 51
static struct anonymous$2 vert[200l];
// vert$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 51
static struct anonymous$2 vert$link1[200l];
// visited
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 60
static signed int visited[800l];
// visited$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 60
static signed int visited$link1[800l];

// __list_add
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/list.h line 81
static inline void __list_add(struct list_head *n, struct list_head *prev, struct list_head *next)
{
  next->prev = n;
  n->next = next;
  n->prev = prev;
  prev->next = n;
}

// __list_del
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/list.h line 115
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
  next->prev = prev;
  prev->next = next;
}

// _equal_to
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 123
extern signed int _equal_to(struct anonymous$1 *v0, struct anonymous$1 *v1)
{
  double return_value_fabs$1;
  return_value_fabs$1=fabs(v0->y - v1->y);
  _Bool tmp_if_expr$3;
  double return_value_fabs$2;
  if(return_value_fabs$1 <= 1.0e-7)
  {
    return_value_fabs$2=fabs(v0->x - v1->x);
    tmp_if_expr$3 = return_value_fabs$2 <= 1.0e-7 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  return (signed int)tmp_if_expr$3;
}

// _greater_than
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 112
extern signed int _greater_than(struct anonymous$1 *v0, struct anonymous$1 *v1)
{
  if(v0->y > v1->y + 1.0e-7)
    return 1;

  else
    if(v0->y < v1->y + -1.000000e-7)
      return 0;

    else
      return (signed int)(v0->x > v1->x);
}

// _greater_than_equal_to
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 128
extern signed int _greater_than_equal_to(struct anonymous$1 *v0, struct anonymous$1 *v1)
{
  if(v0->y > v1->y + 1.0e-7)
    return 1;

  else
    if(v0->y < v1->y + -1.000000e-7)
      return 0;

    else
      return (signed int)(v0->x >= v1->x);
}

// _less_than
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 138
extern signed int _less_than(struct anonymous$1 *v0, struct anonymous$1 *v1)
{
  if(v0->y < v1->y + -1.000000e-7)
    return 1;

  else
    if(v0->y > v1->y + 1.0e-7)
      return 0;

    else
      return (signed int)(v0->x < v1->x);
}

// _max
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 79
static signed int _max(struct anonymous$1 *yval, struct anonymous$1 *v0, struct anonymous$1 *v1)
{
  double return_value_fabs$1;
  if(v0->y > v1->y + 1.0e-7)
    *yval = *v0;

  else
  {
    return_value_fabs$1=fabs(v0->y - v1->y);
    if(return_value_fabs$1 <= 1.0e-7)
    {
      if(v0->x > v1->x + 1.0e-7)
        *yval = *v0;

      else
        *yval = *v1;
    }

    else
      *yval = *v1;
  }
  return 0;
}

// _max$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 79
static signed int _max$link1(struct anonymous$1 *yval$link1, struct anonymous$1 *v0$link1, struct anonymous$1 *v1$link1)
{
  double return_value_fabs$1$link1;
  if(v0$link1->y > v1$link1->y + 1.0e-7)
    *yval$link1 = *v0$link1;

  else
  {
    return_value_fabs$1$link1=fabs(v0$link1->y - v1$link1->y);
    if(return_value_fabs$1$link1 <= 1.0e-7)
    {
      if(v0$link1->x > v1$link1->x + 1.0e-7)
        *yval$link1 = *v0$link1;

      else
        *yval$link1 = *v1$link1;
    }

    else
      *yval$link1 = *v1$link1;
  }
  return 0;
}

// _min
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 96
static signed int _min(struct anonymous$1 *yval, struct anonymous$1 *v0, struct anonymous$1 *v1)
{
  double return_value_fabs$1;
  if(v0->y < v1->y + -1.000000e-7)
    *yval = *v0;

  else
  {
    return_value_fabs$1=fabs(v0->y - v1->y);
    if(return_value_fabs$1 <= 1.0e-7)
    {
      if(v0->x < v1->x)
        *yval = *v0;

      else
        *yval = *v1;
    }

    else
      *yval = *v1;
  }
  return 0;
}

// _min$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 96
static signed int _min$link1(struct anonymous$1 *yval$link1, struct anonymous$1 *v0$link1, struct anonymous$1 *v1$link1)
{
  double return_value_fabs$1$link1;
  if(v0$link1->y < v1$link1->y + -1.000000e-7)
    *yval$link1 = *v0$link1;

  else
  {
    return_value_fabs$1$link1=fabs(v0$link1->y - v1$link1->y);
    if(return_value_fabs$1$link1 <= 1.0e-7)
    {
      if(v0$link1->x < v1$link1->x)
        *yval$link1 = *v0$link1;

      else
        *yval$link1 = *v1$link1;
    }

    else
      *yval$link1 = *v1$link1;
  }
  return 0;
}

// _queue_fill
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/object_queue.c line 62
signed int _queue_fill(void)
{
  signed int i = 0;
  for( ; !(i >= queue_size); i = i + 1)
    if(queue[(signed long int)i] == 4294967295u)
      net_send((unsigned char)3, (char *)(void *)0, (unsigned short int)0);

  return 0;
}

// _queue_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/object_queue.c line 49
signed int _queue_init(void)
{
  signed int i;
  queue_size = 1;
  requested = 0;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)queue_size);
  queue = (unsigned int *)return_value_malloc$1;
  i = 0;
  for( ; !(i >= queue_size); i = i + 1)
    queue[(signed long int)i] = (unsigned int)~0;
  _queue_fill();
  return 0;
}

// _queue_new_object
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/object_queue.c line 71
signed int _queue_new_object(unsigned int oid)
{
  signed int i = 0;
  for( ; !(i >= queue_size); i = i + 1)
    if(queue[(signed long int)i] == 4294967295u)
    {
      queue[(signed long int)i] = oid;
      requested = requested - 1;
      return 0;
    }

  if(queue_size == 0)
    return -1;

  else
  {
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)queue, sizeof(unsigned int) /*4ul*/  * (unsigned long int)(queue_size + 1));
    queue = (unsigned int *)return_value_realloc$1;
    queue_size = queue_size + 1;
    requested = requested - 1;
    queue[(signed long int)(queue_size - 1)] = oid;
    return 0;
  }
}

// _queue_quit
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/object_queue.c line 125
signed int _queue_quit(void)
{
  if(!(queue == ((unsigned int *)NULL)))
  {
    free((void *)queue);
    queue = (unsigned int *)(void *)0;
  }

  queue_size = 0;
  return 0;
}

// _queue_want_object
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/object_queue.c line 92
unsigned int _queue_want_object(void)
{
  unsigned int ret;
  signed int i;
  signed int j = 0;
  signed int tmp_post$1;
  do
  {
    i = 0;
    for( ; !(i >= queue_size); i = i + 1)
      if(!(queue[(signed long int)i] == 4294967295u))
      {
        ret = queue[(signed long int)i];
        queue[(signed long int)i] = (unsigned int)~0;
        net_send((unsigned char)3, (char *)(void *)0, (unsigned short int)0);
        return ret;
      }

    if(queue_size == 0)
      return (unsigned int)-1;

    if(!(requested >= 100))
    {
      net_send((unsigned char)3, (char *)(void *)0, (unsigned short int)0);
      requested = requested + 1;
    }

    s3d_net_check();
    static struct timespec _queue_want_object$$1$$t = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)(10 * 1000) };
    nanosleep(&_queue_want_object$$1$$t, (struct timespec *)(void *)0);
    tmp_post$1 = j;
    j = j + 1;
  }
  while(!(tmp_post$1 >= 100000));
  errds(2, "_queue_want_object()", "timeout is reached. server is extremly slow/laggy or dead");
  return (unsigned int)-1;
}

// _s3d_add_tessbuf
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 116
static signed int _s3d_add_tessbuf(unsigned short int a)
{
  float norm;
  float ar;
  float xa;
  float ya;
  signed int i;
  signed int j;
  signed int k;
  signed int c;
  signed int n;
  signed int outl;
  signed int s;
  signed int e;
  signed int np;
  signed int pos;
  signed int triangles[400l][3l];
  signed int ncontours;
  signed int ncon;
  signed int cntr[200l];
  signed int ncntr[200l];
  signed int csta[200l];
  signed int ncsta[200l];
  signed int perm[200l];
  float area[200l];
  double vertices[201l][2l];
  double nvertices[201l][2l];
  signed int error;
  error=FT_Load_Char(face, (unsigned long int)a, (signed int)(1L << 3 | 1L << 0));
  if(!(error == 0))
  {
    errds(5, "_s3d_add_tessbuf():FT_Load_Char()", "can't load character %d : (%d) %s", a, ft_errors[(signed long int)error].err_code, ft_errors[(signed long int)error].err_msg);
    return -1;
  }

  else
  {
    s3dprintf$link1(1, "[T]riangulating character %c", a);
    norm = (float)(1.0 / (double)face->glyph->metrics.vertAdvance);
    if((signed int)face->glyph->outline.n_points >= 1)
    {
      if(!((signed int)face->glyph->outline.n_points >= 200))
      {
        tess_buf[(signed long int)a].vn = (signed int)face->glyph->outline.n_points;
        void *return_value_malloc$1;
        return_value_malloc$1=malloc(sizeof(float) /*4ul*/  * (unsigned long int)face->glyph->outline.n_points * (unsigned long int)3);
        tess_buf[(signed long int)a].vbuf = (float *)return_value_malloc$1;
        j = 0;
        ncontours = (signed int)face->glyph->outline.n_contours;
        c = 0;
        for( ; !(c >= ncontours); c = c + 1)
        {
          i = 0;
          ncon = (signed int)face->glyph->outline.contours[(signed long int)c];
          cntr[(signed long int)c] = (ncon - j) + 1;
          csta[(signed long int)c] = j + 1;
          ar = 0.0f;
          for( ; !(j >= 1 + ncon); i = i + 1)
          {
            k = (((j + 2) - csta[(signed long int)c]) % cntr[(signed long int)c] + csta[(signed long int)c]) - 1;
            ar = ar - (float)((face->glyph->outline.points + (signed long int)j)->x * (face->glyph->outline.points + (signed long int)k)->y);
            ar = ar + (float)((face->glyph->outline.points + (signed long int)k)->x * (face->glyph->outline.points + (signed long int)j)->y);
            pos = ncon - i;
            vertices[(signed long int)(pos + 1)][(signed long int)0] = (double)((float)(face->glyph->outline.points + (signed long int)j)->x * norm);
            vertices[(signed long int)(pos + 1)][(signed long int)1] = (double)((float)(face->glyph->outline.points + (signed long int)j)->y * norm);
            j = j + 1;
          }
          ar = 0.5f * norm * norm * ar;
          s3dprintf$link1(1, "contour %d has area of %3.3f, cntr is %d, contour starts at %d, ncon %d", c, ar, cntr[(signed long int)c], csta[(signed long int)c], ncon);
          area[(signed long int)c] = ar;
        }
        n = ncontours;
        i = 0;
        for( ; !(i >= n); i = i + 1)
          perm[(signed long int)i] = i;
        for( ; !(n == 0); n = n - 1)
        {
          outl = -1;
          i = 0;
          for( ; !(i >= n); i = i + 1)
            if(area[(signed long int)perm[(signed long int)i]] > 0.000000f)
            {
              outl = i;
              break;
            }

          if(outl == -1)
          {
            s3dprintf$link1(4, "hole without outline found, exiting ... %c", a);
            return -1;
          }

          i = 0;
          for( ; !(i >= n); i = i + 1)
            if(area[(signed long int)perm[(signed long int)i]] < 0.000000f)
            {
              xa = (float)vertices[(signed long int)csta[(signed long int)perm[(signed long int)i]]][(signed long int)0];
              ya = (float)vertices[(signed long int)csta[(signed long int)perm[(signed long int)i]]][(signed long int)1];
              s = csta[(signed long int)perm[(signed long int)outl]];
              e = (csta[(signed long int)perm[(signed long int)outl]] + cntr[(signed long int)perm[(signed long int)outl]]) - 1;
              ar = (float)0;
              j = s;
              for( ; !(j >= e); j = j + 1)
              {
                double return_value_atan2$2;
                return_value_atan2$2=atan2((vertices[(signed long int)(j + 1)][(signed long int)1] - (double)ya) * (vertices[(signed long int)j][(signed long int)0] - (double)xa) - (vertices[(signed long int)(j + 1)][(signed long int)0] - (double)xa) * (vertices[(signed long int)j][(signed long int)1] - (double)ya), (vertices[(signed long int)(j + 1)][(signed long int)0] - (double)xa) * (vertices[(signed long int)j][(signed long int)0] - (double)xa) + (vertices[(signed long int)(j + 1)][(signed long int)1] - (double)ya) * (vertices[(signed long int)j][(signed long int)1] - (double)ya));
                ar = ar + (float)return_value_atan2$2;
              }
              double return_value_atan2$3;
              return_value_atan2$3=atan2((vertices[(signed long int)s][(signed long int)1] - (double)ya) * (vertices[(signed long int)e][(signed long int)0] - (double)xa) - (vertices[(signed long int)s][(signed long int)0] - (double)xa) * (vertices[(signed long int)e][(signed long int)1] - (double)ya), (vertices[(signed long int)s][(signed long int)0] - (double)xa) * (vertices[(signed long int)e][(signed long int)0] - (double)xa) + (vertices[(signed long int)s][(signed long int)1] - (double)ya) * (vertices[(signed long int)e][(signed long int)1] - (double)ya));
              ar = ar + (float)return_value_atan2$3;
              float return_value_fabsf$4;
              return_value_fabsf$4=fabsf(ar);
              if(return_value_fabsf$4 > 1.000000f)
              {
                s3dprintf$link1(1, "hole %d (%d) in %d (%d): interior angle sum %f (n=%d)", i, perm[(signed long int)i], outl, perm[(signed long int)outl], ar, n);
                j = perm[(signed long int)(n - 1)];
                perm[(signed long int)(n - 1)] = perm[(signed long int)i];
                perm[(signed long int)i] = j;
                if(outl == n + -1)
                  outl = i;

                n = n - 1;
                i = i - 1;
              }

            }

          j = perm[(signed long int)(n - 1)];
          perm[(signed long int)(n - 1)] = perm[(signed long int)outl];
          perm[(signed long int)outl] = j;
        }
        n = 1;
        c = 0;
        for( ; !(c >= ncontours); c = c + 1)
        {
          ncsta[(signed long int)c] = n - 1;
          j = csta[(signed long int)perm[(signed long int)c]];
          for( ; !(j >= cntr[(signed long int)perm[(signed long int)c]] + csta[(signed long int)perm[(signed long int)c]]); j = j + 1)
          {
            nvertices[(signed long int)n][(signed long int)0] = vertices[(signed long int)j][(signed long int)0];
            nvertices[(signed long int)n][(signed long int)1] = vertices[(signed long int)j][(signed long int)1];
            tess_buf[(signed long int)a].vbuf[(signed long int)((n - 1) * 3)] = (float)nvertices[(signed long int)n][(signed long int)0];
            tess_buf[(signed long int)a].vbuf[(signed long int)((n - 1) * 3 + 1)] = (float)nvertices[(signed long int)n][(signed long int)1];
            tess_buf[(signed long int)a].vbuf[(signed long int)((n - 1) * 3 + 2)] = (float)0;
            n = n + 1;
          }
          ncntr[(signed long int)c] = cntr[(signed long int)perm[(signed long int)c]];
        }
        n = 0;
        void *return_value_malloc$5;
        return_value_malloc$5=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)4 * (unsigned long int)((signed int)face->glyph->outline.n_points + 2 * (signed int)face->glyph->outline.n_contours));
        tess_buf[(signed long int)a].pbuf = (unsigned int *)return_value_malloc$5;
        k = 0;
        c = ncontours - 1;
        for( ; c >= 0; c = c - 1)
        {
          n = n + 1;
          if(area[(signed long int)perm[(signed long int)c]] > 0.000000f)
          {
            s3dprintf$link1(1, "[T]riangulation from outline %d (%d contours, area = %f)", perm[(signed long int)c], n, area[(signed long int)perm[(signed long int)c]]);
            np=sei_triangulate_polygon(n, ncntr + (signed long int)c, nvertices + (signed long int)ncsta[(signed long int)c], triangles);
            i = 0;
            for( ; !(i >= np); i = i + 1)
            {
              tess_buf[(signed long int)a].pbuf[(signed long int)(k * 4)] = (unsigned int)((triangles[(signed long int)i][(signed long int)0] + ncsta[(signed long int)c]) - 1);
              tess_buf[(signed long int)a].pbuf[(signed long int)(k * 4 + 1)] = (unsigned int)((triangles[(signed long int)i][(signed long int)2] + ncsta[(signed long int)c]) - 1);
              tess_buf[(signed long int)a].pbuf[(signed long int)(k * 4 + 2)] = (unsigned int)((triangles[(signed long int)i][(signed long int)1] + ncsta[(signed long int)c]) - 1);
              tess_buf[(signed long int)a].pbuf[(signed long int)(k * 4 + 3)] = (unsigned int)0;
              k = k + 1;
            }
            n = 0;
          }

        }
        tess_buf[(signed long int)a].pn = k;
      }

    }

    tess_buf[(signed long int)a].xoff = (float)(1.0 * (double)face->glyph->metrics.horiAdvance * (double)norm);
    return 0;
  }
}

// _s3d_add_tessbuf$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 116
static signed int _s3d_add_tessbuf$link1(unsigned short int a$link1)
{
  float norm$link1;
  float ar$link1;
  float xa$link1;
  float ya$link1;
  signed int i$link1;
  signed int j$link1;
  signed int k$link1;
  signed int c$link1;
  signed int n$link1;
  signed int outl$link1;
  signed int s$link1;
  signed int e$link1;
  signed int np$link1;
  signed int pos$link1;
  signed int triangles$link1[400l][3l];
  signed int ncontours$link1;
  signed int ncon$link1;
  signed int cntr$link1[200l];
  signed int ncntr$link1[200l];
  signed int csta$link1[200l];
  signed int ncsta$link1[200l];
  signed int perm$link1[200l];
  float area$link1[200l];
  double vertices$link1[201l][2l];
  double nvertices$link1[201l][2l];
  signed int error$link1;
  error$link1=FT_Load_Char(face$link1, (unsigned long int)a$link1, (signed int)(1L << 3 | 1L << 0));
  if(!(error$link1 == 0))
  {
    errds$link1(5, "_s3d_add_tessbuf():FT_Load_Char()", "can't load character %d : (%d) %s", a$link1, ft_errors$link1[(signed long int)error$link1].err_code, ft_errors$link1[(signed long int)error$link1].err_msg);
    return -1;
  }

  else
  {
    s3dprintf$link2(1, "[T]riangulating character %c", a$link1);
    norm$link1 = (float)(1.0 / (double)face$link1->glyph->metrics.vertAdvance);
    if((signed int)face$link1->glyph->outline.n_points >= 1)
    {
      if(!((signed int)face$link1->glyph->outline.n_points >= 200))
      {
        tess_buf$link1[(signed long int)a$link1].vn = (signed int)face$link1->glyph->outline.n_points;
        void *return_value_malloc$1$link1;
        return_value_malloc$1$link1=malloc(sizeof(float) /*4ul*/  * (unsigned long int)face$link1->glyph->outline.n_points * (unsigned long int)3);
        tess_buf$link1[(signed long int)a$link1].vbuf = (float *)return_value_malloc$1$link1;
        j$link1 = 0;
        ncontours$link1 = (signed int)face$link1->glyph->outline.n_contours;
        c$link1 = 0;
        for( ; !(c$link1 >= ncontours$link1); c$link1 = c$link1 + 1)
        {
          i$link1 = 0;
          ncon$link1 = (signed int)face$link1->glyph->outline.contours[(signed long int)c$link1];
          cntr$link1[(signed long int)c$link1] = (ncon$link1 - j$link1) + 1;
          csta$link1[(signed long int)c$link1] = j$link1 + 1;
          ar$link1 = 0.0f;
          for( ; !(j$link1 >= 1 + ncon$link1); i$link1 = i$link1 + 1)
          {
            k$link1 = (((j$link1 + 2) - csta$link1[(signed long int)c$link1]) % cntr$link1[(signed long int)c$link1] + csta$link1[(signed long int)c$link1]) - 1;
            ar$link1 = ar$link1 - (float)((face$link1->glyph->outline.points + (signed long int)j$link1)->x * (face$link1->glyph->outline.points + (signed long int)k$link1)->y);
            ar$link1 = ar$link1 + (float)((face$link1->glyph->outline.points + (signed long int)k$link1)->x * (face$link1->glyph->outline.points + (signed long int)j$link1)->y);
            pos$link1 = ncon$link1 - i$link1;
            vertices$link1[(signed long int)(pos$link1 + 1)][(signed long int)0] = (double)((float)(face$link1->glyph->outline.points + (signed long int)j$link1)->x * norm$link1);
            vertices$link1[(signed long int)(pos$link1 + 1)][(signed long int)1] = (double)((float)(face$link1->glyph->outline.points + (signed long int)j$link1)->y * norm$link1);
            j$link1 = j$link1 + 1;
          }
          ar$link1 = 0.5f * norm$link1 * norm$link1 * ar$link1;
          s3dprintf$link2(1, "contour %d has area of %3.3f, cntr is %d, contour starts at %d, ncon %d", c$link1, ar$link1, cntr$link1[(signed long int)c$link1], csta$link1[(signed long int)c$link1], ncon$link1);
          area$link1[(signed long int)c$link1] = ar$link1;
        }
        n$link1 = ncontours$link1;
        i$link1 = 0;
        for( ; !(i$link1 >= n$link1); i$link1 = i$link1 + 1)
          perm$link1[(signed long int)i$link1] = i$link1;
        for( ; !(n$link1 == 0); n$link1 = n$link1 - 1)
        {
          outl$link1 = -1;
          i$link1 = 0;
          for( ; !(i$link1 >= n$link1); i$link1 = i$link1 + 1)
            if(area$link1[(signed long int)perm$link1[(signed long int)i$link1]] > 0.000000f)
            {
              outl$link1 = i$link1;
              break;
            }

          if(outl$link1 == -1)
          {
            s3dprintf$link2(4, "hole without outline found, exiting ... %c", a$link1);
            return -1;
          }

          i$link1 = 0;
          for( ; !(i$link1 >= n$link1); i$link1 = i$link1 + 1)
            if(area$link1[(signed long int)perm$link1[(signed long int)i$link1]] < 0.000000f)
            {
              xa$link1 = (float)vertices$link1[(signed long int)csta$link1[(signed long int)perm$link1[(signed long int)i$link1]]][(signed long int)0];
              ya$link1 = (float)vertices$link1[(signed long int)csta$link1[(signed long int)perm$link1[(signed long int)i$link1]]][(signed long int)1];
              s$link1 = csta$link1[(signed long int)perm$link1[(signed long int)outl$link1]];
              e$link1 = (csta$link1[(signed long int)perm$link1[(signed long int)outl$link1]] + cntr$link1[(signed long int)perm$link1[(signed long int)outl$link1]]) - 1;
              ar$link1 = (float)0;
              j$link1 = s$link1;
              for( ; !(j$link1 >= e$link1); j$link1 = j$link1 + 1)
              {
                double return_value_atan2$2$link1;
                return_value_atan2$2$link1=atan2((vertices$link1[(signed long int)(j$link1 + 1)][(signed long int)1] - (double)ya$link1) * (vertices$link1[(signed long int)j$link1][(signed long int)0] - (double)xa$link1) - (vertices$link1[(signed long int)(j$link1 + 1)][(signed long int)0] - (double)xa$link1) * (vertices$link1[(signed long int)j$link1][(signed long int)1] - (double)ya$link1), (vertices$link1[(signed long int)(j$link1 + 1)][(signed long int)0] - (double)xa$link1) * (vertices$link1[(signed long int)j$link1][(signed long int)0] - (double)xa$link1) + (vertices$link1[(signed long int)(j$link1 + 1)][(signed long int)1] - (double)ya$link1) * (vertices$link1[(signed long int)j$link1][(signed long int)1] - (double)ya$link1));
                ar$link1 = ar$link1 + (float)return_value_atan2$2$link1;
              }
              double return_value_atan2$3$link1;
              return_value_atan2$3$link1=atan2((vertices$link1[(signed long int)s$link1][(signed long int)1] - (double)ya$link1) * (vertices$link1[(signed long int)e$link1][(signed long int)0] - (double)xa$link1) - (vertices$link1[(signed long int)s$link1][(signed long int)0] - (double)xa$link1) * (vertices$link1[(signed long int)e$link1][(signed long int)1] - (double)ya$link1), (vertices$link1[(signed long int)s$link1][(signed long int)0] - (double)xa$link1) * (vertices$link1[(signed long int)e$link1][(signed long int)0] - (double)xa$link1) + (vertices$link1[(signed long int)s$link1][(signed long int)1] - (double)ya$link1) * (vertices$link1[(signed long int)e$link1][(signed long int)1] - (double)ya$link1));
              ar$link1 = ar$link1 + (float)return_value_atan2$3$link1;
              float return_value_fabsf$4$link1;
              return_value_fabsf$4$link1=fabsf(ar$link1);
              if(return_value_fabsf$4$link1 > 1.000000f)
              {
                s3dprintf$link2(1, "hole %d (%d) in %d (%d): interior angle sum %f (n=%d)", i$link1, perm$link1[(signed long int)i$link1], outl$link1, perm$link1[(signed long int)outl$link1], ar$link1, n$link1);
                j$link1 = perm$link1[(signed long int)(n$link1 - 1)];
                perm$link1[(signed long int)(n$link1 - 1)] = perm$link1[(signed long int)i$link1];
                perm$link1[(signed long int)i$link1] = j$link1;
                if(outl$link1 == n$link1 + -1)
                  outl$link1 = i$link1;

                n$link1 = n$link1 - 1;
                i$link1 = i$link1 - 1;
              }

            }

          j$link1 = perm$link1[(signed long int)(n$link1 - 1)];
          perm$link1[(signed long int)(n$link1 - 1)] = perm$link1[(signed long int)outl$link1];
          perm$link1[(signed long int)outl$link1] = j$link1;
        }
        n$link1 = 1;
        c$link1 = 0;
        for( ; !(c$link1 >= ncontours$link1); c$link1 = c$link1 + 1)
        {
          ncsta$link1[(signed long int)c$link1] = n$link1 - 1;
          j$link1 = csta$link1[(signed long int)perm$link1[(signed long int)c$link1]];
          for( ; !(j$link1 >= cntr$link1[(signed long int)perm$link1[(signed long int)c$link1]] + csta$link1[(signed long int)perm$link1[(signed long int)c$link1]]); j$link1 = j$link1 + 1)
          {
            nvertices$link1[(signed long int)n$link1][(signed long int)0] = vertices$link1[(signed long int)j$link1][(signed long int)0];
            nvertices$link1[(signed long int)n$link1][(signed long int)1] = vertices$link1[(signed long int)j$link1][(signed long int)1];
            tess_buf$link1[(signed long int)a$link1].vbuf[(signed long int)((n$link1 - 1) * 3)] = (float)nvertices$link1[(signed long int)n$link1][(signed long int)0];
            tess_buf$link1[(signed long int)a$link1].vbuf[(signed long int)((n$link1 - 1) * 3 + 1)] = (float)nvertices$link1[(signed long int)n$link1][(signed long int)1];
            tess_buf$link1[(signed long int)a$link1].vbuf[(signed long int)((n$link1 - 1) * 3 + 2)] = (float)0;
            n$link1 = n$link1 + 1;
          }
          ncntr$link1[(signed long int)c$link1] = cntr$link1[(signed long int)perm$link1[(signed long int)c$link1]];
        }
        n$link1 = 0;
        void *return_value_malloc$5$link1;
        return_value_malloc$5$link1=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)4 * (unsigned long int)((signed int)face$link1->glyph->outline.n_points + 2 * (signed int)face$link1->glyph->outline.n_contours));
        tess_buf$link1[(signed long int)a$link1].pbuf = (unsigned int *)return_value_malloc$5$link1;
        k$link1 = 0;
        c$link1 = ncontours$link1 - 1;
        for( ; c$link1 >= 0; c$link1 = c$link1 - 1)
        {
          n$link1 = n$link1 + 1;
          if(area$link1[(signed long int)perm$link1[(signed long int)c$link1]] > 0.000000f)
          {
            s3dprintf$link2(1, "[T]riangulation from outline %d (%d contours, area = %f)", perm$link1[(signed long int)c$link1], n$link1, area$link1[(signed long int)perm$link1[(signed long int)c$link1]]);
            np$link1=sei_triangulate_polygon(n$link1, ncntr$link1 + (signed long int)c$link1, nvertices$link1 + (signed long int)ncsta$link1[(signed long int)c$link1], triangles$link1);
            i$link1 = 0;
            for( ; !(i$link1 >= np$link1); i$link1 = i$link1 + 1)
            {
              tess_buf$link1[(signed long int)a$link1].pbuf[(signed long int)(k$link1 * 4)] = (unsigned int)((triangles$link1[(signed long int)i$link1][(signed long int)0] + ncsta$link1[(signed long int)c$link1]) - 1);
              tess_buf$link1[(signed long int)a$link1].pbuf[(signed long int)(k$link1 * 4 + 1)] = (unsigned int)((triangles$link1[(signed long int)i$link1][(signed long int)2] + ncsta$link1[(signed long int)c$link1]) - 1);
              tess_buf$link1[(signed long int)a$link1].pbuf[(signed long int)(k$link1 * 4 + 2)] = (unsigned int)((triangles$link1[(signed long int)i$link1][(signed long int)1] + ncsta$link1[(signed long int)c$link1]) - 1);
              tess_buf$link1[(signed long int)a$link1].pbuf[(signed long int)(k$link1 * 4 + 3)] = (unsigned int)0;
              k$link1 = k$link1 + 1;
            }
            n$link1 = 0;
          }

        }
        tess_buf$link1[(signed long int)a$link1].pn = k$link1;
      }

    }

    tess_buf$link1[(signed long int)a$link1].xoff = (float)(1.0 * (double)face$link1->glyph->metrics.horiAdvance * (double)norm$link1);
    return 0;
  }
}

// _s3d_choose_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 40
static signed int _s3d_choose_cb(const void *d1, signed int size)
{
  struct s3d_texshm *t1 = (struct s3d_texshm *)d1;
  return (t1->oid * 32 + t1->tex) % size;
}

// _s3d_choose_cb$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 40
static signed int _s3d_choose_cb$link1(const void *d1$link1, signed int size$link1)
{
  struct s3d_texshm *t1$link1 = (struct s3d_texshm *)d1$link1;
  return (t1$link1->oid * 32 + t1$link1->tex) % size$link1;
}

// _s3d_clear_tessbuf
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 97
static signed int _s3d_clear_tessbuf(void)
{
  signed int i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    if(!(tess_buf[(signed long int)i].vbuf == ((float *)NULL)))
      free((void *)tess_buf[(signed long int)i].vbuf);

    if(!(tess_buf[(signed long int)i].pbuf == ((unsigned int *)NULL)))
      free((void *)tess_buf[(signed long int)i].pbuf);

  }
  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    tess_buf[(signed long int)i].vbuf = (float *)(void *)0;
    tess_buf[(signed long int)i].pbuf = (unsigned int *)(void *)0;
  }
  return 0;
}

// _s3d_clear_tessbuf$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 97
static signed int _s3d_clear_tessbuf$link1(void)
{
  signed int i$link1 = 0;
  for( ; !(i$link1 >= 256); i$link1 = i$link1 + 1)
  {
    if(!(tess_buf$link1[(signed long int)i$link1].vbuf == ((float *)NULL)))
      free((void *)tess_buf$link1[(signed long int)i$link1].vbuf);

    if(!(tess_buf$link1[(signed long int)i$link1].pbuf == ((unsigned int *)NULL)))
      free((void *)tess_buf$link1[(signed long int)i$link1].pbuf);

  }
  i$link1 = 0;
  for( ; !(i$link1 >= 256); i$link1 = i$link1 + 1)
  {
    tess_buf$link1[(signed long int)i$link1].vbuf = (float *)(void *)0;
    tess_buf$link1[(signed long int)i$link1].pbuf = (unsigned int *)(void *)0;
  }
  return 0;
}

// _s3d_compare_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 46
static signed int _s3d_compare_cb(const void *d1, const void *d2)
{
  struct s3d_texshm *t1;
  struct s3d_texshm *t2;
  t1 = (struct s3d_texshm *)d1;
  t2 = (struct s3d_texshm *)d2;
  if(t1->oid == t2->oid)
  {
    if(!(t1->tex == t2->tex))
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 1;
  }
}

// _s3d_compare_cb$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 46
static signed int _s3d_compare_cb$link1(const void *d1$link1, const void *d2$link1)
{
  struct s3d_texshm *t1$link1;
  struct s3d_texshm *t2$link1;
  t1$link1 = (struct s3d_texshm *)d1$link1;
  t2$link1 = (struct s3d_texshm *)d2$link1;
  if(t1$link1->oid == t2$link1->oid)
  {
    if(!(t1$link1->tex == t2$link1->tex))
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 1;
  }
}

// _s3d_draw_tessbuf
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 261
static signed int _s3d_draw_tessbuf(signed int oid, unsigned short int a, signed int *voff, float *xoff)
{
  float *vbuf;
  unsigned int *pbuf;
  signed int i;
  _Bool tmp_if_expr$1;
  if(!(tess_buf[(signed long int)a].vbuf == ((float *)NULL)))
    tmp_if_expr$1 = tess_buf[(signed long int)a].pbuf != ((unsigned int *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    _s3d_add_tessbuf(a);

  if(!(tess_buf[(signed long int)a].pn == 0))
  {
    if(!(tess_buf[(signed long int)a].vn == 0))
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(float) /*4ul*/  * (unsigned long int)3 * (unsigned long int)tess_buf[(signed long int)a].vn);
      vbuf = (float *)return_value_malloc$2;
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)4 * (unsigned long int)tess_buf[(signed long int)a].pn);
      pbuf = (unsigned int *)return_value_malloc$3;
      memcpy((void *)vbuf, (const void *)tess_buf[(signed long int)a].vbuf, sizeof(float) /*4ul*/  * (unsigned long int)3 * (unsigned long int)tess_buf[(signed long int)a].vn);
      memcpy((void *)pbuf, (const void *)tess_buf[(signed long int)a].pbuf, sizeof(unsigned int) /*4ul*/  * (unsigned long int)4 * (unsigned long int)tess_buf[(signed long int)a].pn);
      i = 0;
      for( ; !(i >= tess_buf[(signed long int)a].vn); i = i + 1)
        vbuf[(signed long int)(i * 3)] = vbuf[(signed long int)(i * 3)] + *xoff;
      i = 0;
      for( ; !(i >= tess_buf[(signed long int)a].pn); i = i + 1)
      {
        pbuf[(signed long int)(i * 4)] = pbuf[(signed long int)(i * 4)] + (unsigned int)*voff;
        pbuf[(signed long int)(i * 4 + 1)] = pbuf[(signed long int)(i * 4 + 1)] + (unsigned int)*voff;
        pbuf[(signed long int)(i * 4 + 2)] = pbuf[(signed long int)(i * 4 + 2)] + (unsigned int)*voff;
      }
      s3dprintf$link1(1, "commiting %d vertices, %d polygons", tess_buf[(signed long int)a].vn, tess_buf[(signed long int)a].pn);
      s3d_push_vertices(oid, vbuf, (unsigned short int)tess_buf[(signed long int)a].vn);
      s3d_push_polygons(oid, pbuf, (unsigned short int)tess_buf[(signed long int)a].pn);
      *voff = *voff + tess_buf[(signed long int)a].vn;
      free((void *)vbuf);
      free((void *)pbuf);
    }

  }

  *xoff = *xoff + tess_buf[(signed long int)a].xoff;
  return 0;
}

// _s3d_draw_tessbuf$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 261
static signed int _s3d_draw_tessbuf$link1(signed int oid$link1, unsigned short int a$link1, signed int *voff$link1, float *xoff$link1)
{
  float *vbuf$link1;
  unsigned int *pbuf$link1;
  signed int i$link1;
  _Bool tmp_if_expr$1$link1;
  if(!(tess_buf$link1[(signed long int)a$link1].vbuf == ((float *)NULL)))
    tmp_if_expr$1$link1 = tess_buf$link1[(signed long int)a$link1].pbuf != ((unsigned int *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1$link1 = (_Bool)0;
  if(!tmp_if_expr$1$link1)
    _s3d_add_tessbuf$link1(a$link1);

  if(!(tess_buf$link1[(signed long int)a$link1].pn == 0))
  {
    if(!(tess_buf$link1[(signed long int)a$link1].vn == 0))
    {
      void *return_value_malloc$2$link1;
      return_value_malloc$2$link1=malloc(sizeof(float) /*4ul*/  * (unsigned long int)3 * (unsigned long int)tess_buf$link1[(signed long int)a$link1].vn);
      vbuf$link1 = (float *)return_value_malloc$2$link1;
      void *return_value_malloc$3$link1;
      return_value_malloc$3$link1=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)4 * (unsigned long int)tess_buf$link1[(signed long int)a$link1].pn);
      pbuf$link1 = (unsigned int *)return_value_malloc$3$link1;
      memcpy((void *)vbuf$link1, (const void *)tess_buf$link1[(signed long int)a$link1].vbuf, sizeof(float) /*4ul*/  * (unsigned long int)3 * (unsigned long int)tess_buf$link1[(signed long int)a$link1].vn);
      memcpy((void *)pbuf$link1, (const void *)tess_buf$link1[(signed long int)a$link1].pbuf, sizeof(unsigned int) /*4ul*/  * (unsigned long int)4 * (unsigned long int)tess_buf$link1[(signed long int)a$link1].pn);
      i$link1 = 0;
      for( ; !(i$link1 >= tess_buf$link1[(signed long int)a$link1].vn); i$link1 = i$link1 + 1)
        vbuf$link1[(signed long int)(i$link1 * 3)] = vbuf$link1[(signed long int)(i$link1 * 3)] + *xoff$link1;
      i$link1 = 0;
      for( ; !(i$link1 >= tess_buf$link1[(signed long int)a$link1].pn); i$link1 = i$link1 + 1)
      {
        pbuf$link1[(signed long int)(i$link1 * 4)] = pbuf$link1[(signed long int)(i$link1 * 4)] + (unsigned int)*voff$link1;
        pbuf$link1[(signed long int)(i$link1 * 4 + 1)] = pbuf$link1[(signed long int)(i$link1 * 4 + 1)] + (unsigned int)*voff$link1;
        pbuf$link1[(signed long int)(i$link1 * 4 + 2)] = pbuf$link1[(signed long int)(i$link1 * 4 + 2)] + (unsigned int)*voff$link1;
      }
      s3dprintf$link2(1, "commiting %d vertices, %d polygons", tess_buf$link1[(signed long int)a$link1].vn, tess_buf$link1[(signed long int)a$link1].pn);
      s3d_push_vertices(oid$link1, vbuf$link1, (unsigned short int)tess_buf$link1[(signed long int)a$link1].vn);
      s3d_push_polygons(oid$link1, pbuf$link1, (unsigned short int)tess_buf$link1[(signed long int)a$link1].pn);
      *voff$link1 = *voff$link1 + tess_buf$link1[(signed long int)a$link1].vn;
      free((void *)vbuf$link1);
      free((void *)pbuf$link1);
    }

  }

  *xoff$link1 = *xoff$link1 + tess_buf$link1[(signed long int)a$link1].xoff;
  return 0;
}

// _s3d_free_s3dtex
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 56
static void _s3d_free_s3dtex(void *d1)
{
  struct s3d_tex *tex = (struct s3d_tex *)d1;
  if(!(tex->buf == ((char *)NULL)))
  {
    shmdt((const void *)tex->buf);
    tex->buf = (char *)(void *)0;
  }

  shmctl(tex->tshm.shmid, 0, (struct shmid_ds *)(void *)0);
  free((void *)tex);
  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// _s3d_free_s3dtex$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 56
static void _s3d_free_s3dtex$link1(void *d1$link1)
{
  struct s3d_tex *tex$link1 = (struct s3d_tex *)d1$link1;
  if(!(tex$link1->buf == ((char *)NULL)))
  {
    shmdt((const void *)tex$link1->buf);
    tex$link1->buf = (char *)(void *)0;
  }

  shmctl(tex$link1->tshm.shmid, 0, (struct shmid_ds *)(void *)0);
  free((void *)tex$link1);
  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// _s3d_handle_texshm
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 70
void _s3d_handle_texshm(struct s3d_texshm *tshm)
{
  struct s3d_tex *tex = (struct s3d_tex *)(void *)0;
  s3dprintf$link1(4, "handling new texture ...");
  if(!(tex_hash == ((struct hashtable_t *)NULL)))
  {
    void *return_value__s3d_hash_remove$1;
    return_value__s3d_hash_remove$1=_s3d_hash_remove(tex_hash, (void *)tshm);
    tex = (struct s3d_tex *)return_value__s3d_hash_remove$1;
    if(!(tex == ((struct s3d_tex *)NULL)))
      _s3d_free_s3dtex((void *)tex);

    if(!(tshm->shmid == -1))
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(struct s3d_tex) /*28ul*/ );
      tex = (struct s3d_tex *)return_value_malloc$2;
      tex->tshm = *tshm;
      void *return_value_shmat$3;
      return_value_shmat$3=shmat(tex->tshm.shmid, (void *)0, 0);
      tex->buf = (char *)return_value_shmat$3;
      if((signed int *)tex->buf == (signed int *)-1)
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        errn("shm_init():shmat()", *return_value___errno_location$4);
        free((void *)tex);
        goto __CPROVER_DUMP_L5;
      }

      s3dprintf$link1(4, "adding new texture ...");
      _s3d_hash_add(tex_hash, (void *)tex);
      goto __CPROVER_DUMP_L5;
    }

  }


__CPROVER_DUMP_L5:
  ;
}

// _s3d_hash_add
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 175
signed int _s3d_hash_add(struct hashtable_t *hash, void *data)
{
  signed int index;
  struct element_t *bucket;
  struct element_t *prev_bucket = (struct element_t *)(void *)0;
  index=hash->choose(data, hash->size);
  bucket = hash->table[(signed long int)index];
  if(!(bucket == ((struct element_t *)NULL)))
  {
    signed int return_value;
    return_value=hash->compare(bucket->data, data);
    if(return_value == 0)
      return -1;

    prev_bucket = bucket;
    bucket = bucket->next;
  }

  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct element_t) /*16ul*/ );
  bucket = (struct element_t *)return_value_malloc$1;
  if(bucket == ((struct element_t *)NULL))
    return -1;

  else
  {
    bucket->data = data;
    bucket->next = (struct element_t *)(void *)0;
    if(prev_bucket == ((struct element_t *)NULL))
      hash->table[(signed long int)index] = bucket;

    else
      prev_bucket->next = bucket;
    hash->elements = hash->elements + 1;
    return 0;
  }
}

// _s3d_hash_debug
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 304
void _s3d_hash_debug(struct hashtable_t *hash)
{
  signed int i;
  struct element_t *bucket;
  i = 0;
  for( ; !(i >= hash->size); i = i + 1)
  {
    printf("[%d] ", i);
    bucket = hash->table[(signed long int)i];
    for( ; !(bucket == ((struct element_t *)NULL)); bucket = bucket->next)
      printf("-> [%10p] ", (void *)bucket);
    printf("\n");
  }
  printf("\n");
}

// _s3d_hash_delete
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 45
void _s3d_hash_delete(struct hashtable_t *hash, void (*free_cb)(void *))
{
  struct element_t *bucket;
  struct element_t *last_bucket;
  signed int i = 0;
  for( ; !(i >= hash->size); i = i + 1)
  {
    bucket = hash->table[(signed long int)i];
    while(!(bucket == ((struct element_t *)NULL)))
    {
      if(!(free_cb == ((void (*)(void *))NULL)))
        free_cb(bucket->data);

      last_bucket = bucket;
      bucket = bucket->next;
      free((void *)last_bucket);
    }
  }
  _s3d_hash_destroy(hash);
}

// _s3d_hash_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 71
void _s3d_hash_destroy(struct hashtable_t *hash)
{
  free((void *)hash->table);
  free((void *)hash);
}

// _s3d_hash_find
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 210
void * _s3d_hash_find(struct hashtable_t *hash, void *keydata)
{
  signed int index;
  struct element_t *bucket;
  index=hash->choose(keydata, hash->size);
  bucket = hash->table[(signed long int)index];
  if(!(bucket == ((struct element_t *)NULL)))
  {
    signed int return_value;
    return_value=hash->compare(bucket->data, keydata);
    if(return_value == 0)
      return bucket->data;

    bucket = bucket->next;
  }

  return (void *)0;
}

// _s3d_hash_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 32
void _s3d_hash_init(struct hashtable_t *hash)
{
  signed int i;
  hash->elements = 0;
  i = 0;
  for( ; !(i >= hash->size); i = i + 1)
    hash->table[(signed long int)i] = (struct element_t *)(void *)0;
}

// _s3d_hash_iterate
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 84
struct hash_it_t * _s3d_hash_iterate(struct hashtable_t *hash, struct hash_it_t *iter_in)
{
  struct hash_it_t *iter;
  if(iter_in == ((struct hash_it_t *)NULL))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct hash_it_t) /*32ul*/ );
    iter = (struct hash_it_t *)return_value_malloc$1;
    iter->index = -1;
    iter->bucket = (struct element_t *)(void *)0;
    iter->prev_bucket = (struct element_t *)(void *)0;
  }

  else
    iter = iter_in;
  if(!(iter->bucket == ((struct element_t *)NULL)))
  {
    if(!(iter->first_bucket == ((struct element_t **)NULL)))
    {
      if(!(*iter->first_bucket == iter->bucket))
      {
        if(!(*iter->first_bucket == ((struct element_t *)NULL)))
        {
          iter->prev_bucket = (struct element_t *)(void *)0;
          iter->bucket = *iter->first_bucket;
          iter->first_bucket = &hash->table[(signed long int)iter->index];
          return iter;
        }

        else
          iter->bucket = (struct element_t *)(void *)0;
      }

    }

    else
      if(!(iter->prev_bucket == ((struct element_t *)NULL)))
      {
        if(!(iter->prev_bucket->next == iter->bucket))
          iter->bucket = iter->prev_bucket;

      }

  }

  if(!(iter->bucket == ((struct element_t *)NULL)))
  {
    if(iter->bucket->next == ((struct element_t *)NULL))
      goto __CPROVER_DUMP_L7;

    iter->prev_bucket = iter->bucket;
    iter->bucket = iter->bucket->next;
    iter->first_bucket = (struct element_t **)(void *)0;
    return iter;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    iter->index = iter->index + 1;
    while(!(iter->index >= hash->size))
      if(!(hash->table[(signed long int)iter->index] == ((struct element_t *)NULL)))
      {
        iter->prev_bucket = (struct element_t *)(void *)0;
        iter->bucket = hash->table[(signed long int)iter->index];
        iter->first_bucket = &hash->table[(signed long int)iter->index];
        return iter;
      }

      else
        iter->index = iter->index + 1;
    free((void *)iter);
    return (struct hash_it_t *)(void *)0;
  }
}

// _s3d_hash_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 154
struct hashtable_t * _s3d_hash_new(signed int size, signed int (*compare)(const void *, const void *), signed int (*choose)(const void *, signed int))
{
  struct hashtable_t *hash;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct hashtable_t) /*32ul*/ );
  hash = (struct hashtable_t *)return_value_malloc$1;
  if(hash == ((struct hashtable_t *)NULL))
    return (struct hashtable_t *)(void *)0;

  else
  {
    hash->size = size;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct element_t *) /*8ul*/  * (unsigned long int)size);
    hash->table = (struct element_t **)return_value_malloc$2;
    if(hash->table == ((struct element_t **)NULL))
    {
      free((void *)hash);
      return (struct hashtable_t *)(void *)0;
    }

    else
    {
      _s3d_hash_init(hash);
      hash->compare = compare;
      hash->choose = choose;
      return hash;
    }
  }
}

// _s3d_hash_remove
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 256
void * _s3d_hash_remove(struct hashtable_t *hash, void *data)
{
  struct hash_it_t hash_it_t;
  hash_it_t.index=hash->choose(data, hash->size);
  hash_it_t.bucket = hash->table[(signed long int)hash_it_t.index];
  hash_it_t.prev_bucket = (struct element_t *)(void *)0;
  struct element_t **tmp_if_expr$1;
  if(!(hash_it_t.bucket == ((struct element_t *)NULL)))
  {
    signed int return_value;
    return_value=hash->compare(hash_it_t.bucket->data, data);
    if(return_value == 0)
    {
      if(hash_it_t.bucket == hash->table[(signed long int)hash_it_t.index])
        tmp_if_expr$1 = &hash->table[(signed long int)hash_it_t.index];

      else
        tmp_if_expr$1 = (struct element_t **)(void *)0;
      hash_it_t.first_bucket = tmp_if_expr$1;
      void *return_value__s3d_hash_remove_bucket$2;
      return_value__s3d_hash_remove_bucket$2=_s3d_hash_remove_bucket(hash, &hash_it_t);
      return return_value__s3d_hash_remove_bucket$2;
    }

    hash_it_t.prev_bucket = hash_it_t.bucket;
    hash_it_t.bucket = hash_it_t.bucket->next;
  }

  return (void *)0;
}

// _s3d_hash_remove_bucket
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 232
void * _s3d_hash_remove_bucket(struct hashtable_t *hash, struct hash_it_t *hash_it_t)
{
  void *data_save = hash_it_t->bucket->data;
  if(!(hash_it_t->prev_bucket == ((struct element_t *)NULL)))
    hash_it_t->prev_bucket->next = hash_it_t->bucket->next;

  else
    if(!(hash_it_t->first_bucket == ((struct element_t **)NULL)))
      *hash_it_t->first_bucket = hash_it_t->bucket->next;

  free((void *)hash_it_t->bucket);
  hash->elements = hash->elements - 1;
  return data_save;
}

// _s3d_hash_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/hash.c line 280
struct hashtable_t * _s3d_hash_resize(struct hashtable_t *hash, signed int size)
{
  struct hashtable_t *new_hash;
  struct element_t *bucket;
  signed int i;
  new_hash=_s3d_hash_new(size, hash->compare, hash->choose);
  if(new_hash == ((struct hashtable_t *)NULL))
    return (struct hashtable_t *)(void *)0;

  else
  {
    i = 0;
    for( ; !(i >= hash->size); i = i + 1)
    {
      bucket = hash->table[(signed long int)i];
      for( ; !(bucket == ((struct element_t *)NULL)); bucket = bucket->next)
        _s3d_hash_add(new_hash, bucket->data);
    }
    _s3d_hash_delete(hash, (void (*)(void *))(void *)0);
    return new_hash;
  }
}

// _s3d_ignore
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/callback.c line 54
static signed int _s3d_ignore(struct s3d_evt *evt)
{
  return 0;
}

// _s3d_ignore$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/callback.c line 54
static signed int _s3d_ignore$link1(struct s3d_evt *evt$link1)
{
  return 0;
}

// _s3d_load_texture_shm
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 96
signed int _s3d_load_texture_shm(signed int object, unsigned int tid, unsigned short int xpos, unsigned short int ypos, unsigned short int w, unsigned short int h, const unsigned char *data)
{
  struct s3d_texshm check;
  struct s3d_tex *tex;
  signed int i;
  signed int p1;
  signed int p2;
  signed int m;
  signed short int mw;
  signed short int mh;
  if(tex_hash == ((struct hashtable_t *)NULL))
    return -1;

  else
  {
    check.oid = object;
    check.tex = (signed int)tid;
    void *return_value__s3d_hash_find$1;
    return_value__s3d_hash_find$1=_s3d_hash_find(tex_hash, (void *)&check);
    tex = (struct s3d_tex *)return_value__s3d_hash_find$1;
    if(tex == ((struct s3d_tex *)NULL))
      return -1;

    else
    {
      s3dprintf$link1(1, "texture: oid %d, tex %d, shmid %d, tw %d, th %d, w %d, h %d ...", tex->tshm.oid, tex->tshm.tex, tex->tshm.shmid, tex->tshm.tw, tex->tshm.th, tex->tshm.w, tex->tshm.th);
      m = (signed int)tex->tshm.w * (signed int)tex->tshm.th + (signed int)tex->tshm.tw;
      if(!((signed int)tex->tshm.tw >= (signed int)w + (signed int)xpos))
        mw = (signed short int)((signed int)tex->tshm.tw - (signed int)xpos);

      else
        mw = (signed short int)w;
      if(!((signed int)tex->tshm.th >= (signed int)h + (signed int)ypos))
        mh = (signed short int)((signed int)tex->tshm.th - (signed int)ypos);

      else
        mh = (signed short int)h;
      if(!((signed int)mw >= 1))
        return 0;

      else
      {
        i = 0;
        for( ; !(i >= (signed int)mh); i = i + 1)
        {
          p1 = ((signed int)ypos + i) * (signed int)tex->tshm.w + (signed int)xpos;
          p2 = (signed int)mw;
          if(!(m >= p1))
            break;

          memcpy((void *)(tex->buf + (signed long int)(4 * p1)), (const void *)(data + (signed long int)(4 * i * (signed int)w)), (unsigned long int)(4 * p2));
        }
        return 0;
      }
    }
  }
}

// _s3d_net_receive
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/network.c line 63
static signed int _s3d_net_receive(void)
{
  signed int return_value__s3d_tcp_net_receive$1;
  return_value__s3d_tcp_net_receive$1=_s3d_tcp_net_receive();
  return return_value__s3d_tcp_net_receive$1;
}

// _s3d_net_receive$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/network.c line 63
static signed int _s3d_net_receive$link1(void)
{
  signed int return_value__s3d_tcp_net_receive$1$link1;
  return_value__s3d_tcp_net_receive$1$link1=_s3d_tcp_net_receive();
  return return_value__s3d_tcp_net_receive$1$link1;
}

// _s3d_tcp_net_receive
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 143
signed int _s3d_tcp_net_receive(void)
{
  struct anonymous$13 fs_proc;
  struct timeval tv;
  signed int found = 0;
  char opcode;
  char *buf;
  unsigned short int length;
  if(!(s3d_socket == -1))
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$13) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fs_proc)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    tv.tv_usec = (signed long int)0;
    tv.tv_sec = tv.tv_usec;
    (&fs_proc)->__fds_bits[(signed long int)(s3d_socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fs_proc)->__fds_bits[(signed long int)(s3d_socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << s3d_socket % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    signed int return_value_select$4;
    return_value_select$4=select(1024, &fs_proc, (struct anonymous$13 *)(void *)0, (struct anonymous$13 *)(void *)0, &tv);
    if(return_value_select$4 == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      errn("select()", *return_value___errno_location$1);
    }

    else
      if(!((fs_proc.__fds_bits[(signed long int)(s3d_socket / 8)] & (signed long int)(1UL << s3d_socket % 8)) == 0l))
      {
        signed int return_value_tcp_readn$3;
        return_value_tcp_readn$3=tcp_readn(&opcode, 1);
        if(return_value_tcp_readn$3 == 1)
        {
          tcp_readn((char *)&length, 2);
          length=ntohs(length);
          void *return_value_malloc$2;
          return_value_malloc$2=malloc((unsigned long int)length);
          buf = (char *)return_value_malloc$2;
          tcp_readn(buf, (signed int)length);
          net_prot_in((unsigned char)opcode, length, buf);
          found = 1;
        }

        else
        {
          s3dprintf$link1(4, "socket seems to be dead ...");
          s3d_quit();
        }
      }

  }

  return found;
}

// _s3d_texture_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 134
signed int _s3d_texture_init(void)
{
  tex_hash=_s3d_hash_new(256, _s3d_compare_cb, _s3d_choose_cb);
  if(tex_hash == ((struct hashtable_t *)NULL))
    return -1;

  else
    return 0;
}

// _s3d_texture_quit
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/texture.c line 142
signed int _s3d_texture_quit(void)
{
  if(tex_hash == ((struct hashtable_t *)NULL))
    return -1;

  else
  {
    _s3d_hash_delete(tex_hash, _s3d_free_s3dtex);
    tex_hash = (struct hashtable_t *)(void *)0;
    return 0;
  }
}

// _s3d_update_texture
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 1058
signed int _s3d_update_texture(signed int object, unsigned int tex, unsigned short int xpos, unsigned short int ypos, unsigned short int w, unsigned short int h)
{
  char buf[16l];
  char *ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((unsigned int *)ptr)=htonl(tex);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((unsigned short int *)ptr)=htons(xpos);
  ptr = ptr + (signed long int)sizeof(unsigned short int) /*2ul*/ ;
  *((unsigned short int *)ptr)=htons(ypos);
  ptr = ptr + (signed long int)sizeof(unsigned short int) /*2ul*/ ;
  *((unsigned short int *)ptr)=htons(w);
  ptr = ptr + (signed long int)sizeof(unsigned short int) /*2ul*/ ;
  *((unsigned short int *)ptr)=htons(h);
  net_send((unsigned char)29, buf, (unsigned short int)16);
  return 0;
}

// _s3dw_textbox_scrollbar_down
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 185
static void _s3dw_textbox_scrollbar_down(struct _s3dw_widget *widget)
{
  s3dw_textbox_scrolldown((struct _s3dw_textbox *)widget->parent);
}

// _s3dw_textbox_scrollbar_left
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 189
static void _s3dw_textbox_scrollbar_left(struct _s3dw_widget *widget)
{
  s3dw_textbox_scrollleft((struct _s3dw_textbox *)widget->parent);
}

// _s3dw_textbox_scrollbar_right
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 193
static void _s3dw_textbox_scrollbar_right(struct _s3dw_widget *widget)
{
  s3dw_textbox_scrollright((struct _s3dw_textbox *)widget->parent);
}

// _s3dw_textbox_scrollbar_up
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 181
static void _s3dw_textbox_scrollbar_up(struct _s3dw_widget *widget)
{
  s3dw_textbox_scrollup((struct _s3dw_textbox *)widget->parent);
}

// _shm_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 55
signed int _shm_init(char *ftoken)
{
  signed int shmid;
  unsigned int *next_key;
  signed int key;
  signed int key_out;
  signed int key_in;
  s3dprintf$link1(3, "connecting to shm token %s", ftoken);
  key=ftok(ftoken, 82);
  if(key == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    errn("shm_init():ftok()", *return_value___errno_location$1);
    return 1;
  }

  s3dprintf$link1(3, "init key is 0x%08x", key);
  shmid=shmget(key, sizeof(signed int) /*4ul*/  * (unsigned long int)2, 0644);
  if(shmid == -1)
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    errn("shm_init():shmget()", *return_value___errno_location$2);
    return 1;
  }

  void *return_value_shmat$3;
  return_value_shmat$3=shmat(shmid, (void *)0, 0);
  next_key = (unsigned int *)return_value_shmat$3;
  if(next_key == (unsigned int *)-1)
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    errn("shm_init():shmat()", *return_value___errno_location$4);
    return 1;
  }

  s3dprintf$link1(3, "right now, next_keys are: %08x, %08x", next_key[(signed long int)0], next_key[(signed long int)1]);
  do
  {
    key_in = (signed int)next_key[(signed long int)1];
    if(!(key_in == 0))
    {
      key_out = (signed int)next_key[(signed long int)0];
      if(!(key_out == 0))
        break;

    }

  }
  while((_Bool)1);
  next_key[(signed long int)1] = (unsigned int)0;
  next_key[(signed long int)0] = next_key[(signed long int)1];
  s3dprintf$link1(3, "right now, next_keys are: %08x, %08x", key_in, key_out);
  signed int return_value_shmdt$6;
  return_value_shmdt$6=shmdt((const void *)next_key);
  if(return_value_shmdt$6 == -1)
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    errn("shm_init():shmdt()", *return_value___errno_location$5);
    return 1;
  }

  shmid_in=shmget(key_in, (unsigned long int)(1024 * 512), 0644);
  if(shmid_in == -1)
  {
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    errn("shm_init():shmget()", *return_value___errno_location$7);
    return 1;
  }

  void *return_value_shmat$8;
  return_value_shmat$8=shmat(shmid_in, (void *)0, 0);
  data_in = (struct buf_t *)return_value_shmat$8;
  if(data_in == (struct buf_t *)-1)
  {
    signed int *return_value___errno_location$9;
    return_value___errno_location$9=__errno_location();
    errn("shm_init():shmat()", *return_value___errno_location$9);
    return 1;
  }

  shmid_out=shmget(key_out, (unsigned long int)(1024 * 512), 0644);
  if(shmid_out == -1)
  {
    signed int *return_value___errno_location$10;
    return_value___errno_location$10=__errno_location();
    errn("shm_init():shmget()", *return_value___errno_location$10);
    return 1;
  }

  void *return_value_shmat$11;
  return_value_shmat$11=shmat(shmid_out, (void *)0, 0);
  data_out = (struct buf_t *)return_value_shmat$11;
  if(data_out == (struct buf_t *)-1)
  {
    signed int *return_value___errno_location$12;
    return_value___errno_location$12=__errno_location();
    errn("shm_init():shmat()", *return_value___errno_location$12);
    return 1;
  }

  return 0;
}

// _shm_net_receive
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 169
signed int _shm_net_receive(void)
{
  signed int found = 0;
  char opcode;
  char *buf;
  unsigned short int length;
  struct shmid_ds d;
  signed int tmp_post$3;
  if(data_in == ((struct buf_t *)NULL))
    return found;

  else
  {
    if(!(data_in->start == data_in->end))
    {
      signed int return_value_shm_readn$2;
      return_value_shm_readn$2=shm_readn(&opcode, 1);
      if(return_value_shm_readn$2 == 1)
      {
        shm_readn((char *)&length, 2);
        length=ntohs(length);
        void *return_value_malloc$1;
        return_value_malloc$1=malloc((unsigned long int)length);
        buf = (char *)return_value_malloc$1;
        shm_readn(buf, (signed int)length);
        net_prot_in((unsigned char)opcode, length, buf);
        found = 1;
      }

      else
      {
        s3dprintf$link1(4, "socket seems to be dead ...");
        s3d_quit();
      }
    }

    else
    {
      tmp_post$3 = shm_idle;
      shm_idle = shm_idle + 1;
      if(tmp_post$3 >= 201)
      {
        shmctl(shmid_in, 2, &d);
        if(d.shm_nattch == 1ul)
        {
          s3dprintf$link1(3, "server vanished ... ");
          s3d_quit();
        }

        else
          shm_idle = 0;
      }

    }
    return found;
  }
}

// _shm_quit
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 115
signed int _shm_quit(void)
{
  signed int return_value_shmdt$2;
  return_value_shmdt$2=shmdt((const void *)data_in);
  if(return_value_shmdt$2 == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    errn("shm_init():shmdt()", *return_value___errno_location$1);
    return 1;
  }

  signed int return_value_shmdt$4;
  return_value_shmdt$4=shmdt((const void *)data_out);
  if(return_value_shmdt$4 == -1)
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    errn("shm_init():shmdt()", *return_value___errno_location$3);
    return 1;
  }

  data_out = (struct buf_t *)(void *)0;
  data_in = data_out;
  return 0;
}

// _tcp_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 56
signed int _tcp_init(const char *sv, signed int pn)
{
  signed int sd;
  signed int res;
  struct sockaddr_in sock;
  struct hostent *server = (struct hostent *)(void *)0;
  _s3d_sigio = 0;
  sd=socket(2, 1, 6);
  if(!(sd >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    errn("_tcp_init()():socket()", *return_value___errno_location$1);
    return -1;
  }

  sock.sin_family = (unsigned short int)2;
  if((signed int)*sv == 0)
    sv = "127.0.0.1";

  server=gethostbyname(sv);
  if(!(server == ((struct hostent *)NULL)))
    memcpy((void *)&sock.sin_addr.s_addr, (const void *)server->h_addr_list[(signed long int)0], (unsigned long int)4);

  else
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    errn("_tcp_init()():gethostbyname()", *return_value___errno_location$2);
    return -1;
  }
  sock.sin_port=htons((unsigned short int)pn);
  res=connect(sd, (struct sockaddr *)&sock, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(res >= 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    errn("_tcp_init()():connect()", *return_value___errno_location$3);
    return -1;
  }

  signed int return_value_fcntl$5;
  return_value_fcntl$5=fcntl(sd, 4, 020000);
  signed int *return_value___errno_location$4;
  if(!(return_value_fcntl$5 >= 0))
  {
    return_value___errno_location$4=__errno_location();
    errn("fcntl()", *return_value___errno_location$4);
  }

  signed int return_value_getpid$7;
  return_value_getpid$7=getpid();
  signed int return_value_fcntl$8;
  return_value_fcntl$8=fcntl(sd, 8, return_value_getpid$7);
  signed int *return_value___errno_location$6;
  if(!(return_value_fcntl$8 >= 0))
  {
    return_value___errno_location$6=__errno_location();
    errn("fcntl()", *return_value___errno_location$6);
  }

  void (*return_value_signal$10)(signed int);
  return_value_signal$10=signal(13, (void (*)(signed int))sigpipe_handler);
  signed int *return_value___errno_location$9;
  if(return_value_signal$10 == (void (*)(signed int))-1)
  {
    return_value___errno_location$9=__errno_location();
    errn("_tcp_init():signal()", *return_value___errno_location$9);
  }

  void (*return_value_signal$12)(signed int);
  return_value_signal$12=signal(29, (void (*)(signed int))sigio_handler);
  signed int *return_value___errno_location$11;
  if(return_value_signal$12 == (void (*)(signed int))-1)
  {
    return_value___errno_location$11=__errno_location();
    errn("_tcp_init():signal()", *return_value___errno_location$11);
  }

  s3d_socket = sd;
  s3dprintf$link1(3, "connection to %s:%d established", sv, pn);
  return 0;
}

// _tcp_quit
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 109
signed int _tcp_quit(void)
{
  if(!(s3d_socket == 0))
  {
    s3dprintf$link1(3, "closing socket %d", s3d_socket);
    close(s3d_socket);
    s3d_socket = 0;
  }

  return 0;
}

// add_segment
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 419
static signed int add_segment(signed int segnum)
{
  struct anonymous$14 s;
  signed int tu;
  signed int tl;
  signed int sk;
  signed int tfirst;
  signed int tlast;
  signed int tfirstr = 0;
  signed int tlastr = 0;
  signed int tfirstl;
  signed int tlastl;
  signed int i1;
  signed int i2;
  signed int add_segment$$1$$t;
  signed int tn;
  struct anonymous$1 tpt;
  signed int tribot = 0;
  signed int is_swapped = 0;
  signed int tmptriseg;
  signed int tmpseg = 1;
  s = seg[(signed long int)segnum];
  signed int return_value__greater_than$1;
  return_value__greater_than$1=_greater_than(&s.v1, &s.v0);
  if(!(return_value__greater_than$1 == 0))
  {
    signed int tmp;
    tpt = s.v0;
    s.v0 = s.v1;
    s.v1 = tpt;
    tmp = s.root0;
    s.root0 = s.root1;
    s.root1 = tmp;
    is_swapped = 1;
  }

  signed int tmp_if_expr$4;
  signed int return_value_inserted$2;
  signed int return_value_inserted$3;
  if(!(is_swapped == 0))
  {
    return_value_inserted$2=inserted(segnum, 2);
    tmp_if_expr$4 = (signed int)!(return_value_inserted$2 != 0);
  }

  else
  {
    return_value_inserted$3=inserted(segnum, 1);
    tmp_if_expr$4 = (signed int)!(return_value_inserted$3 != 0);
  }
  if(!(tmp_if_expr$4 == 0))
  {
    signed int tmp_d;
    tu=locate_endpoint(&s.v0, &s.v1, s.root0);
    tl=newtrap();
    tr[(signed long int)tl].state = 1;
    tr[(signed long int)tl] = tr[(signed long int)tu];
    tr[(signed long int)tl].hi.y = s.v0.y;
    tr[(signed long int)tu].lo.y = tr[(signed long int)tl].hi.y;
    tr[(signed long int)tl].hi.x = s.v0.x;
    tr[(signed long int)tu].lo.x = tr[(signed long int)tl].hi.x;
    tr[(signed long int)tu].d0 = tl;
    tr[(signed long int)tu].d1 = 0;
    tr[(signed long int)tl].u0 = tu;
    tr[(signed long int)tl].u1 = 0;
    tmp_d = tr[(signed long int)tl].d0;
    if(tmp_d >= 1)
    {
      if(tr[(signed long int)tmp_d].u0 == tu)
        tr[(signed long int)tmp_d].u0 = tl;

    }

    tmp_d = tr[(signed long int)tl].d0;
    if(tmp_d >= 1)
    {
      if(tr[(signed long int)tmp_d].u1 == tu)
        tr[(signed long int)tmp_d].u1 = tl;

    }

    tmp_d = tr[(signed long int)tl].d1;
    if(tmp_d >= 1)
    {
      if(tr[(signed long int)tmp_d].u0 == tu)
        tr[(signed long int)tmp_d].u0 = tl;

    }

    tmp_d = tr[(signed long int)tl].d1;
    if(tmp_d >= 1)
    {
      if(tr[(signed long int)tmp_d].u1 == tu)
        tr[(signed long int)tmp_d].u1 = tl;

    }

    i1=newnode();
    i2=newnode();
    sk = tr[(signed long int)tu].sink;
    qs[(signed long int)sk].nodetype = 2;
    qs[(signed long int)sk].yval = s.v0;
    qs[(signed long int)sk].segnum = segnum;
    qs[(signed long int)sk].left = i2;
    qs[(signed long int)sk].right = i1;
    qs[(signed long int)i1].nodetype = 3;
    qs[(signed long int)i1].trnum = tu;
    qs[(signed long int)i1].parent = sk;
    qs[(signed long int)i2].nodetype = 3;
    qs[(signed long int)i2].trnum = tl;
    qs[(signed long int)i2].parent = sk;
    tr[(signed long int)tu].sink = i1;
    tr[(signed long int)tl].sink = i2;
    tfirst = tl;
  }

  else
    tfirst=locate_endpoint(&s.v0, &s.v1, s.root0);
  signed int tmp_if_expr$7;
  signed int return_value_inserted$5;
  signed int return_value_inserted$6;
  if(!(is_swapped == 0))
  {
    return_value_inserted$5=inserted(segnum, 1);
    tmp_if_expr$7 = (signed int)!(return_value_inserted$5 != 0);
  }

  else
  {
    return_value_inserted$6=inserted(segnum, 2);
    tmp_if_expr$7 = (signed int)!(return_value_inserted$6 != 0);
  }
  if(!(tmp_if_expr$7 == 0))
  {
    signed int add_segment$$1$$4$$tmp_d;
    tu=locate_endpoint(&s.v1, &s.v0, s.root1);
    tl=newtrap();
    tr[(signed long int)tl].state = 1;
    tr[(signed long int)tl] = tr[(signed long int)tu];
    tr[(signed long int)tl].hi.y = s.v1.y;
    tr[(signed long int)tu].lo.y = tr[(signed long int)tl].hi.y;
    tr[(signed long int)tl].hi.x = s.v1.x;
    tr[(signed long int)tu].lo.x = tr[(signed long int)tl].hi.x;
    tr[(signed long int)tu].d0 = tl;
    tr[(signed long int)tu].d1 = 0;
    tr[(signed long int)tl].u0 = tu;
    tr[(signed long int)tl].u1 = 0;
    add_segment$$1$$4$$tmp_d = tr[(signed long int)tl].d0;
    if(add_segment$$1$$4$$tmp_d >= 1)
    {
      if(tr[(signed long int)add_segment$$1$$4$$tmp_d].u0 == tu)
        tr[(signed long int)add_segment$$1$$4$$tmp_d].u0 = tl;

    }

    add_segment$$1$$4$$tmp_d = tr[(signed long int)tl].d0;
    if(add_segment$$1$$4$$tmp_d >= 1)
    {
      if(tr[(signed long int)add_segment$$1$$4$$tmp_d].u1 == tu)
        tr[(signed long int)add_segment$$1$$4$$tmp_d].u1 = tl;

    }

    add_segment$$1$$4$$tmp_d = tr[(signed long int)tl].d1;
    if(add_segment$$1$$4$$tmp_d >= 1)
    {
      if(tr[(signed long int)add_segment$$1$$4$$tmp_d].u0 == tu)
        tr[(signed long int)add_segment$$1$$4$$tmp_d].u0 = tl;

    }

    add_segment$$1$$4$$tmp_d = tr[(signed long int)tl].d1;
    if(add_segment$$1$$4$$tmp_d >= 1)
    {
      if(tr[(signed long int)add_segment$$1$$4$$tmp_d].u1 == tu)
        tr[(signed long int)add_segment$$1$$4$$tmp_d].u1 = tl;

    }

    i1=newnode();
    i2=newnode();
    sk = tr[(signed long int)tu].sink;
    qs[(signed long int)sk].nodetype = 2;
    qs[(signed long int)sk].yval = s.v1;
    qs[(signed long int)sk].segnum = segnum;
    qs[(signed long int)sk].left = i2;
    qs[(signed long int)sk].right = i1;
    qs[(signed long int)i1].nodetype = 3;
    qs[(signed long int)i1].trnum = tu;
    qs[(signed long int)i1].parent = sk;
    qs[(signed long int)i2].nodetype = 3;
    qs[(signed long int)i2].trnum = tl;
    qs[(signed long int)i2].parent = sk;
    tr[(signed long int)tu].sink = i1;
    tr[(signed long int)tl].sink = i2;
    tlast = tu;
  }

  else
  {
    tlast=locate_endpoint(&s.v1, &s.v0, s.root1);
    tribot = 1;
  }
  add_segment$$1$$t = tfirst;
  signed int return_value__greater_than_equal_to$8;
  _Bool tmp_if_expr$39;
  _Bool tmp_if_expr$38;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$11;
  signed int return_value_is_left_of$10;
  _Bool tmp_if_expr$18;
  double return_value_fabs$17;
  _Bool tmp_if_expr$15;
  signed int return_value_is_left_of$14;
  _Bool tmp_if_expr$37;
  _Bool tmp_if_expr$22;
  _Bool tmp_if_expr$21;
  _Bool tmp_if_expr$20;
  signed int return_value_is_left_of$19;
  _Bool tmp_if_expr$27;
  double return_value_fabs$26;
  _Bool tmp_if_expr$24;
  signed int return_value_is_left_of$23;
  _Bool tmp_if_expr$33;
  _Bool tmp_if_expr$32;
  _Bool tmp_if_expr$31;
  signed int return_value_is_left_of$30;
  _Bool tmp_if_expr$36;
  double return_value_fabs$35;
  while(add_segment$$1$$t >= 1)
  {
    return_value__greater_than_equal_to$8=_greater_than_equal_to(&tr[(signed long int)add_segment$$1$$t].lo, &tr[(signed long int)tlast].lo);
    if(return_value__greater_than_equal_to$8 == 0)
      break;

    signed int t_sav;
    signed int tn_sav;
    sk = tr[(signed long int)add_segment$$1$$t].sink;
    i1=newnode();
    i2=newnode();
    qs[(signed long int)sk].nodetype = 1;
    qs[(signed long int)sk].segnum = segnum;
    qs[(signed long int)sk].left = i1;
    qs[(signed long int)sk].right = i2;
    qs[(signed long int)i1].nodetype = 3;
    qs[(signed long int)i1].trnum = add_segment$$1$$t;
    qs[(signed long int)i1].parent = sk;
    qs[(signed long int)i2].nodetype = 3;
    tn=newtrap();
    qs[(signed long int)i2].trnum = tn;
    tr[(signed long int)tn].state = 1;
    qs[(signed long int)i2].parent = sk;
    if(add_segment$$1$$t == tfirst)
      tfirstr = tn;

    signed int return_value__equal_to$9;
    return_value__equal_to$9=_equal_to(&tr[(signed long int)add_segment$$1$$t].lo, &tr[(signed long int)tlast].lo);
    if(!(return_value__equal_to$9 == 0))
      tlastr = tn;

    tr[(signed long int)tn] = tr[(signed long int)add_segment$$1$$t];
    tr[(signed long int)add_segment$$1$$t].sink = i1;
    tr[(signed long int)tn].sink = i2;
    t_sav = add_segment$$1$$t;
    tn_sav = tn;
    if(!(tr[(signed long int)add_segment$$1$$t].d0 >= 1))
      tmp_if_expr$39 = tr[(signed long int)add_segment$$1$$t].d1 <= 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$39 = (_Bool)0;
    if(tmp_if_expr$39)
    {
      errs("sei:add_segment()", "error");
      break;
    }

    else
    {
      if(tr[(signed long int)add_segment$$1$$t].d0 >= 1)
        tmp_if_expr$38 = tr[(signed long int)add_segment$$1$$t].d1 <= 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$38 = (_Bool)0;
      if(tmp_if_expr$38)
      {
        if(tr[(signed long int)add_segment$$1$$t].u0 >= 1)
          tmp_if_expr$13 = tr[(signed long int)add_segment$$1$$t].u1 > 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$13 = (_Bool)0;
        if(tmp_if_expr$13)
        {
          if(tr[(signed long int)add_segment$$1$$t].usave >= 1)
          {
            if(tr[(signed long int)add_segment$$1$$t].uside == 1)
            {
              tr[(signed long int)tn].u0 = tr[(signed long int)add_segment$$1$$t].u1;
              tr[(signed long int)add_segment$$1$$t].u1 = -1;
              tr[(signed long int)tn].u1 = tr[(signed long int)add_segment$$1$$t].usave;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u0].d0 = add_segment$$1$$t;
              tr[(signed long int)tr[(signed long int)tn].u0].d0 = tn;
              tr[(signed long int)tr[(signed long int)tn].u1].d0 = tn;
            }

            else
            {
              tr[(signed long int)tn].u1 = -1;
              tr[(signed long int)tn].u0 = tr[(signed long int)add_segment$$1$$t].u1;
              tr[(signed long int)add_segment$$1$$t].u1 = tr[(signed long int)add_segment$$1$$t].u0;
              tr[(signed long int)add_segment$$1$$t].u0 = tr[(signed long int)add_segment$$1$$t].usave;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u0].d0 = add_segment$$1$$t;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u1].d0 = add_segment$$1$$t;
              tr[(signed long int)tr[(signed long int)tn].u0].d0 = tn;
            }
            tr[(signed long int)tn].usave = 0;
            tr[(signed long int)add_segment$$1$$t].usave = tr[(signed long int)tn].usave;
          }

          else
          {
            tr[(signed long int)tn].u0 = tr[(signed long int)add_segment$$1$$t].u1;
            tr[(signed long int)tn].u1 = -1;
            tr[(signed long int)add_segment$$1$$t].u1 = tr[(signed long int)tn].u1;
            tr[(signed long int)tr[(signed long int)tn].u0].d0 = tn;
          }
        }

        else
        {
          signed int tmp_u = tr[(signed long int)add_segment$$1$$t].u0;
          signed int add_segment$$1$$6$$2$$2$$td0 = tr[(signed long int)tmp_u].d0;
          if(add_segment$$1$$6$$2$$2$$td0 >= 1)
            tmp_if_expr$12 = tr[(signed long int)tmp_u].d1 > 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$12 = (_Bool)0;
          if(tmp_if_expr$12)
          {
            if(tr[(signed long int)add_segment$$1$$6$$2$$2$$td0].rseg >= 1)
            {
              return_value_is_left_of$10=is_left_of(tr[(signed long int)add_segment$$1$$6$$2$$2$$td0].rseg, &s.v1);
              tmp_if_expr$11 = !(return_value_is_left_of$10 != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$11 = (_Bool)0;
            if(tmp_if_expr$11)
            {
              tr[(signed long int)tn].u1 = -1;
              tr[(signed long int)add_segment$$1$$t].u1 = tr[(signed long int)tn].u1;
              tr[(signed long int)add_segment$$1$$t].u0 = tr[(signed long int)add_segment$$1$$t].u1;
              tr[(signed long int)tr[(signed long int)tn].u0].d1 = tn;
            }

            else
            {
              tr[(signed long int)add_segment$$1$$t].u1 = -1;
              tr[(signed long int)tn].u1 = tr[(signed long int)add_segment$$1$$t].u1;
              tr[(signed long int)tn].u0 = tr[(signed long int)tn].u1;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u0].d0 = add_segment$$1$$t;
            }
          }

          else
          {
            tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u0].d0 = add_segment$$1$$t;
            tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u0].d1 = tn;
          }
        }
        double return_value_fabs$16;
        return_value_fabs$16=fabs(tr[(signed long int)add_segment$$1$$t].lo.y - tr[(signed long int)tlast].lo.y);
        if(return_value_fabs$16 <= 1.0e-7)
        {
          return_value_fabs$17=fabs(tr[(signed long int)add_segment$$1$$t].lo.x - tr[(signed long int)tlast].lo.x);
          tmp_if_expr$18 = return_value_fabs$17 <= 1.0e-7 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$18 = (_Bool)0;
        if(!(tribot == 0) && tmp_if_expr$18)
        {
          if(!(is_swapped == 0))
            tmptriseg = seg[(signed long int)segnum].prev;

          else
            tmptriseg = seg[(signed long int)segnum].next;
          if(tmptriseg >= 1)
          {
            return_value_is_left_of$14=is_left_of(tmptriseg, &s.v0);
            tmp_if_expr$15 = return_value_is_left_of$14 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$15 = (_Bool)0;
          if(tmp_if_expr$15)
          {
            tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].u0 = add_segment$$1$$t;
            tr[(signed long int)tn].d1 = -1;
            tr[(signed long int)tn].d0 = tr[(signed long int)tn].d1;
          }

          else
          {
            tr[(signed long int)tr[(signed long int)tn].d0].u1 = tn;
            tr[(signed long int)add_segment$$1$$t].d1 = -1;
            tr[(signed long int)add_segment$$1$$t].d0 = tr[(signed long int)add_segment$$1$$t].d1;
          }
        }

        else
        {
          if(tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].u0 >= 1)
          {
            if(tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].u1 >= 1)
            {
              if(tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].u0 == add_segment$$1$$t)
              {
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].usave = tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].u1;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].uside = 1;
              }

              else
              {
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].usave = tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].u0;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].uside = 2;
              }
            }

          }

          tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].u0 = add_segment$$1$$t;
          tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].u1 = tn;
        }
        add_segment$$1$$t = tr[(signed long int)add_segment$$1$$t].d0;
      }

      else
      {
        if(!(tr[(signed long int)add_segment$$1$$t].d0 >= 1))
          tmp_if_expr$37 = tr[(signed long int)add_segment$$1$$t].d1 > 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$37 = (_Bool)0;
        if(tmp_if_expr$37)
        {
          if(tr[(signed long int)add_segment$$1$$t].u0 >= 1)
            tmp_if_expr$22 = tr[(signed long int)add_segment$$1$$t].u1 > 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$22 = (_Bool)0;
          if(tmp_if_expr$22)
          {
            if(tr[(signed long int)add_segment$$1$$t].usave >= 1)
            {
              if(tr[(signed long int)add_segment$$1$$t].uside == 1)
              {
                tr[(signed long int)tn].u0 = tr[(signed long int)add_segment$$1$$t].u1;
                tr[(signed long int)add_segment$$1$$t].u1 = -1;
                tr[(signed long int)tn].u1 = tr[(signed long int)add_segment$$1$$t].usave;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u0].d0 = add_segment$$1$$t;
                tr[(signed long int)tr[(signed long int)tn].u0].d0 = tn;
                tr[(signed long int)tr[(signed long int)tn].u1].d0 = tn;
              }

              else
              {
                tr[(signed long int)tn].u1 = -1;
                tr[(signed long int)tn].u0 = tr[(signed long int)add_segment$$1$$t].u1;
                tr[(signed long int)add_segment$$1$$t].u1 = tr[(signed long int)add_segment$$1$$t].u0;
                tr[(signed long int)add_segment$$1$$t].u0 = tr[(signed long int)add_segment$$1$$t].usave;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u0].d0 = add_segment$$1$$t;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u1].d0 = add_segment$$1$$t;
                tr[(signed long int)tr[(signed long int)tn].u0].d0 = tn;
              }
              tr[(signed long int)tn].usave = 0;
              tr[(signed long int)add_segment$$1$$t].usave = tr[(signed long int)tn].usave;
            }

            else
            {
              tr[(signed long int)tn].u0 = tr[(signed long int)add_segment$$1$$t].u1;
              tr[(signed long int)tn].u1 = -1;
              tr[(signed long int)add_segment$$1$$t].u1 = tr[(signed long int)tn].u1;
              tr[(signed long int)tr[(signed long int)tn].u0].d0 = tn;
            }
          }

          else
          {
            signed int add_segment$$1$$6$$3$$2$$tmp_u = tr[(signed long int)add_segment$$1$$t].u0;
            signed int add_segment$$1$$6$$3$$2$$td0 = tr[(signed long int)add_segment$$1$$6$$3$$2$$tmp_u].d0;
            if(add_segment$$1$$6$$3$$2$$td0 >= 1)
              tmp_if_expr$21 = tr[(signed long int)add_segment$$1$$6$$3$$2$$tmp_u].d1 > 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$21 = (_Bool)0;
            if(tmp_if_expr$21)
            {
              if(tr[(signed long int)add_segment$$1$$6$$3$$2$$td0].rseg >= 1)
              {
                return_value_is_left_of$19=is_left_of(tr[(signed long int)add_segment$$1$$6$$3$$2$$td0].rseg, &s.v1);
                tmp_if_expr$20 = !(return_value_is_left_of$19 != 0) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$20 = (_Bool)0;
              if(tmp_if_expr$20)
              {
                tr[(signed long int)tn].u1 = -1;
                tr[(signed long int)add_segment$$1$$t].u1 = tr[(signed long int)tn].u1;
                tr[(signed long int)add_segment$$1$$t].u0 = tr[(signed long int)add_segment$$1$$t].u1;
                tr[(signed long int)tr[(signed long int)tn].u0].d1 = tn;
              }

              else
              {
                tr[(signed long int)add_segment$$1$$t].u1 = -1;
                tr[(signed long int)tn].u1 = tr[(signed long int)add_segment$$1$$t].u1;
                tr[(signed long int)tn].u0 = tr[(signed long int)tn].u1;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u0].d0 = add_segment$$1$$t;
              }
            }

            else
            {
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u0].d0 = add_segment$$1$$t;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u0].d1 = tn;
            }
          }
          double return_value_fabs$25;
          return_value_fabs$25=fabs(tr[(signed long int)add_segment$$1$$t].lo.y - tr[(signed long int)tlast].lo.y);
          if(return_value_fabs$25 <= 1.0e-7)
          {
            return_value_fabs$26=fabs(tr[(signed long int)add_segment$$1$$t].lo.x - tr[(signed long int)tlast].lo.x);
            tmp_if_expr$27 = return_value_fabs$26 <= 1.0e-7 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$27 = (_Bool)0;
          if(!(tribot == 0) && tmp_if_expr$27)
          {
            if(tmpseg >= 1)
            {
              return_value_is_left_of$23=is_left_of(tmpseg, &s.v0);
              tmp_if_expr$24 = return_value_is_left_of$23 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$24 = (_Bool)0;
            if(tmp_if_expr$24)
            {
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].u0 = add_segment$$1$$t;
              tr[(signed long int)tn].d1 = -1;
              tr[(signed long int)tn].d0 = tr[(signed long int)tn].d1;
            }

            else
            {
              tr[(signed long int)tr[(signed long int)tn].d1].u1 = tn;
              tr[(signed long int)add_segment$$1$$t].d1 = -1;
              tr[(signed long int)add_segment$$1$$t].d0 = tr[(signed long int)add_segment$$1$$t].d1;
            }
          }

          else
          {
            if(tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].u0 >= 1)
            {
              if(tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].u1 >= 1)
              {
                if(tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].u0 == add_segment$$1$$t)
                {
                  tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].usave = tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].u1;
                  tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].uside = 1;
                }

                else
                {
                  tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].usave = tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].u0;
                  tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].uside = 2;
                }
              }

            }

            tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].u0 = add_segment$$1$$t;
            tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].u1 = tn;
          }
          add_segment$$1$$t = tr[(signed long int)add_segment$$1$$t].d1;
        }

        else
        {
          double y0;
          double yt;
          struct anonymous$1 tmppt;
          signed int tnext;
          signed int i_d0;
          tmpseg = tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].rseg;
          i_d0 = 0;
          double return_value_fabs$29;
          return_value_fabs$29=fabs(tr[(signed long int)add_segment$$1$$t].lo.y - s.v0.y);
          if(return_value_fabs$29 <= 1.0e-7)
          {
            if(tr[(signed long int)add_segment$$1$$t].lo.x > s.v0.x)
              i_d0 = 1;

          }

          else
          {
            y0 = tr[(signed long int)add_segment$$1$$t].lo.y;
            tmppt.y = y0;
            yt = (y0 - s.v0.y) / (s.v1.y - s.v0.y);
            tmppt.x = s.v0.x + yt * (s.v1.x - s.v0.x);
            signed int return_value__less_than$28;
            return_value__less_than$28=_less_than(&tmppt, &tr[(signed long int)add_segment$$1$$t].lo);
            if(!(return_value__less_than$28 == 0))
              i_d0 = 1;

          }
          if(tr[(signed long int)add_segment$$1$$t].u0 >= 1)
            tmp_if_expr$33 = tr[(signed long int)add_segment$$1$$t].u1 > 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$33 = (_Bool)0;
          if(tmp_if_expr$33)
          {
            if(tr[(signed long int)add_segment$$1$$t].usave >= 1)
            {
              if(tr[(signed long int)add_segment$$1$$t].uside == 1)
              {
                tr[(signed long int)tn].u0 = tr[(signed long int)add_segment$$1$$t].u1;
                tr[(signed long int)add_segment$$1$$t].u1 = -1;
                tr[(signed long int)tn].u1 = tr[(signed long int)add_segment$$1$$t].usave;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u0].d0 = add_segment$$1$$t;
                tr[(signed long int)tr[(signed long int)tn].u0].d0 = tn;
                tr[(signed long int)tr[(signed long int)tn].u1].d0 = tn;
              }

              else
              {
                tr[(signed long int)tn].u1 = -1;
                tr[(signed long int)tn].u0 = tr[(signed long int)add_segment$$1$$t].u1;
                tr[(signed long int)add_segment$$1$$t].u1 = tr[(signed long int)add_segment$$1$$t].u0;
                tr[(signed long int)add_segment$$1$$t].u0 = tr[(signed long int)add_segment$$1$$t].usave;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u0].d0 = add_segment$$1$$t;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u1].d0 = add_segment$$1$$t;
                tr[(signed long int)tr[(signed long int)tn].u0].d0 = tn;
              }
              tr[(signed long int)tn].usave = 0;
              tr[(signed long int)add_segment$$1$$t].usave = tr[(signed long int)tn].usave;
            }

            else
            {
              tr[(signed long int)tn].u0 = tr[(signed long int)add_segment$$1$$t].u1;
              tr[(signed long int)tn].u1 = -1;
              tr[(signed long int)add_segment$$1$$t].u1 = -1;
              tr[(signed long int)tr[(signed long int)tn].u0].d0 = tn;
            }
          }

          else
          {
            signed int add_segment$$1$$6$$4$$4$$tmp_u = tr[(signed long int)add_segment$$1$$t].u0;
            signed int td0 = tr[(signed long int)add_segment$$1$$6$$4$$4$$tmp_u].d0;
            if(td0 >= 1)
              tmp_if_expr$32 = tr[(signed long int)add_segment$$1$$6$$4$$4$$tmp_u].d1 > 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$32 = (_Bool)0;
            if(tmp_if_expr$32)
            {
              if(tr[(signed long int)td0].rseg >= 1)
              {
                return_value_is_left_of$30=is_left_of(tr[(signed long int)td0].rseg, &s.v1);
                tmp_if_expr$31 = !(return_value_is_left_of$30 != 0) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$31 = (_Bool)0;
              if(tmp_if_expr$31)
              {
                tr[(signed long int)tn].u1 = -1;
                tr[(signed long int)add_segment$$1$$t].u1 = tr[(signed long int)tn].u1;
                tr[(signed long int)add_segment$$1$$t].u0 = tr[(signed long int)add_segment$$1$$t].u1;
                tr[(signed long int)tr[(signed long int)tn].u0].d1 = tn;
              }

              else
              {
                tr[(signed long int)add_segment$$1$$t].u1 = -1;
                tr[(signed long int)tn].u1 = tr[(signed long int)add_segment$$1$$t].u1;
                tr[(signed long int)tn].u0 = tr[(signed long int)tn].u1;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u0].d0 = add_segment$$1$$t;
              }
            }

            else
            {
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u0].d0 = add_segment$$1$$t;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].u0].d1 = tn;
            }
          }
          double return_value_fabs$34;
          return_value_fabs$34=fabs(tr[(signed long int)add_segment$$1$$t].lo.y - tr[(signed long int)tlast].lo.y);
          if(return_value_fabs$34 <= 1.0e-7)
          {
            return_value_fabs$35=fabs(tr[(signed long int)add_segment$$1$$t].lo.x - tr[(signed long int)tlast].lo.x);
            tmp_if_expr$36 = return_value_fabs$35 <= 1.0e-7 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$36 = (_Bool)0;
          if(!(tribot == 0) && tmp_if_expr$36)
          {
            tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].u0 = add_segment$$1$$t;
            tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].u1 = -1;
            tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].u0 = tn;
            tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].u1 = -1;
            tr[(signed long int)tn].d0 = tr[(signed long int)add_segment$$1$$t].d1;
            tr[(signed long int)tn].d1 = -1;
            tr[(signed long int)add_segment$$1$$t].d1 = tr[(signed long int)tn].d1;
            tnext = tr[(signed long int)add_segment$$1$$t].d1;
          }

          else
            if(!(i_d0 == 0))
            {
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].u0 = add_segment$$1$$t;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].u1 = tn;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].u0 = tn;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].u1 = -1;
              tr[(signed long int)add_segment$$1$$t].d1 = -1;
              tnext = tr[(signed long int)add_segment$$1$$t].d0;
            }

            else
            {
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].u0 = add_segment$$1$$t;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d0].u1 = -1;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].u0 = add_segment$$1$$t;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t].d1].u1 = tn;
              tr[(signed long int)tn].d0 = tr[(signed long int)add_segment$$1$$t].d1;
              tr[(signed long int)tn].d1 = -1;
              tnext = tr[(signed long int)add_segment$$1$$t].d1;
            }
          add_segment$$1$$t = tnext;
        }
      }
    }
    tr[(signed long int)tn_sav].lseg = segnum;
    tr[(signed long int)t_sav].rseg = tr[(signed long int)tn_sav].lseg;
  }
  tfirstl = tfirst;
  tlastl = tlast;
  merge_trapezoids(segnum, tfirstl, tlastl, 1);
  merge_trapezoids(segnum, tfirstr, tlastr, 2);
  seg[(signed long int)segnum].is_inserted = 1;
  return 0;
}

// add_segment$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 419
static signed int add_segment$link1(signed int segnum$link1)
{
  struct anonymous$14 s$link1;
  signed int tu$link1;
  signed int tl$link1;
  signed int sk$link1;
  signed int tfirst$link1;
  signed int tlast$link1;
  signed int tfirstr$link1 = 0;
  signed int tlastr$link1 = 0;
  signed int tfirstl$link1;
  signed int tlastl$link1;
  signed int i1$link1;
  signed int i2$link1;
  signed int add_segment$$1$$t$link1;
  signed int tn$link1;
  struct anonymous$1 tpt$link1;
  signed int tribot$link1 = 0;
  signed int is_swapped$link1 = 0;
  signed int tmptriseg$link1;
  signed int tmpseg$link1 = 1;
  s$link1 = seg[(signed long int)segnum$link1];
  signed int return_value__greater_than$1$link1;
  return_value__greater_than$1$link1=_greater_than(&s$link1.v1, &s$link1.v0);
  if(!(return_value__greater_than$1$link1 == 0))
  {
    signed int tmp$link1;
    tpt$link1 = s$link1.v0;
    s$link1.v0 = s$link1.v1;
    s$link1.v1 = tpt$link1;
    tmp$link1 = s$link1.root0;
    s$link1.root0 = s$link1.root1;
    s$link1.root1 = tmp$link1;
    is_swapped$link1 = 1;
  }

  signed int tmp_if_expr$4$link1;
  signed int return_value_inserted$2$link1;
  signed int return_value_inserted$3$link1;
  if(!(is_swapped$link1 == 0))
  {
    return_value_inserted$2$link1=inserted$link1(segnum$link1, 2);
    tmp_if_expr$4$link1 = (signed int)!(return_value_inserted$2$link1 != 0);
  }

  else
  {
    return_value_inserted$3$link1=inserted$link1(segnum$link1, 1);
    tmp_if_expr$4$link1 = (signed int)!(return_value_inserted$3$link1 != 0);
  }
  if(!(tmp_if_expr$4$link1 == 0))
  {
    signed int tmp_d$link1;
    tu$link1=locate_endpoint(&s$link1.v0, &s$link1.v1, s$link1.root0);
    tl$link1=newtrap$link1();
    tr[(signed long int)tl$link1].state = 1;
    tr[(signed long int)tl$link1] = tr[(signed long int)tu$link1];
    tr[(signed long int)tl$link1].hi.y = s$link1.v0.y;
    tr[(signed long int)tu$link1].lo.y = tr[(signed long int)tl$link1].hi.y;
    tr[(signed long int)tl$link1].hi.x = s$link1.v0.x;
    tr[(signed long int)tu$link1].lo.x = tr[(signed long int)tl$link1].hi.x;
    tr[(signed long int)tu$link1].d0 = tl$link1;
    tr[(signed long int)tu$link1].d1 = 0;
    tr[(signed long int)tl$link1].u0 = tu$link1;
    tr[(signed long int)tl$link1].u1 = 0;
    tmp_d$link1 = tr[(signed long int)tl$link1].d0;
    if(tmp_d$link1 >= 1)
    {
      if(tr[(signed long int)tmp_d$link1].u0 == tu$link1)
        tr[(signed long int)tmp_d$link1].u0 = tl$link1;

    }

    tmp_d$link1 = tr[(signed long int)tl$link1].d0;
    if(tmp_d$link1 >= 1)
    {
      if(tr[(signed long int)tmp_d$link1].u1 == tu$link1)
        tr[(signed long int)tmp_d$link1].u1 = tl$link1;

    }

    tmp_d$link1 = tr[(signed long int)tl$link1].d1;
    if(tmp_d$link1 >= 1)
    {
      if(tr[(signed long int)tmp_d$link1].u0 == tu$link1)
        tr[(signed long int)tmp_d$link1].u0 = tl$link1;

    }

    tmp_d$link1 = tr[(signed long int)tl$link1].d1;
    if(tmp_d$link1 >= 1)
    {
      if(tr[(signed long int)tmp_d$link1].u1 == tu$link1)
        tr[(signed long int)tmp_d$link1].u1 = tl$link1;

    }

    i1$link1=newnode$link1();
    i2$link1=newnode$link1();
    sk$link1 = tr[(signed long int)tu$link1].sink;
    qs[(signed long int)sk$link1].nodetype = 2;
    qs[(signed long int)sk$link1].yval = s$link1.v0;
    qs[(signed long int)sk$link1].segnum = segnum$link1;
    qs[(signed long int)sk$link1].left = i2$link1;
    qs[(signed long int)sk$link1].right = i1$link1;
    qs[(signed long int)i1$link1].nodetype = 3;
    qs[(signed long int)i1$link1].trnum = tu$link1;
    qs[(signed long int)i1$link1].parent = sk$link1;
    qs[(signed long int)i2$link1].nodetype = 3;
    qs[(signed long int)i2$link1].trnum = tl$link1;
    qs[(signed long int)i2$link1].parent = sk$link1;
    tr[(signed long int)tu$link1].sink = i1$link1;
    tr[(signed long int)tl$link1].sink = i2$link1;
    tfirst$link1 = tl$link1;
  }

  else
    tfirst$link1=locate_endpoint(&s$link1.v0, &s$link1.v1, s$link1.root0);
  signed int tmp_if_expr$7$link1;
  signed int return_value_inserted$5$link1;
  signed int return_value_inserted$6$link1;
  if(!(is_swapped$link1 == 0))
  {
    return_value_inserted$5$link1=inserted$link1(segnum$link1, 1);
    tmp_if_expr$7$link1 = (signed int)!(return_value_inserted$5$link1 != 0);
  }

  else
  {
    return_value_inserted$6$link1=inserted$link1(segnum$link1, 2);
    tmp_if_expr$7$link1 = (signed int)!(return_value_inserted$6$link1 != 0);
  }
  if(!(tmp_if_expr$7$link1 == 0))
  {
    signed int add_segment$$1$$4$$tmp_d$link1;
    tu$link1=locate_endpoint(&s$link1.v1, &s$link1.v0, s$link1.root1);
    tl$link1=newtrap$link1();
    tr[(signed long int)tl$link1].state = 1;
    tr[(signed long int)tl$link1] = tr[(signed long int)tu$link1];
    tr[(signed long int)tl$link1].hi.y = s$link1.v1.y;
    tr[(signed long int)tu$link1].lo.y = tr[(signed long int)tl$link1].hi.y;
    tr[(signed long int)tl$link1].hi.x = s$link1.v1.x;
    tr[(signed long int)tu$link1].lo.x = tr[(signed long int)tl$link1].hi.x;
    tr[(signed long int)tu$link1].d0 = tl$link1;
    tr[(signed long int)tu$link1].d1 = 0;
    tr[(signed long int)tl$link1].u0 = tu$link1;
    tr[(signed long int)tl$link1].u1 = 0;
    add_segment$$1$$4$$tmp_d$link1 = tr[(signed long int)tl$link1].d0;
    if(add_segment$$1$$4$$tmp_d$link1 >= 1)
    {
      if(tr[(signed long int)add_segment$$1$$4$$tmp_d$link1].u0 == tu$link1)
        tr[(signed long int)add_segment$$1$$4$$tmp_d$link1].u0 = tl$link1;

    }

    add_segment$$1$$4$$tmp_d$link1 = tr[(signed long int)tl$link1].d0;
    if(add_segment$$1$$4$$tmp_d$link1 >= 1)
    {
      if(tr[(signed long int)add_segment$$1$$4$$tmp_d$link1].u1 == tu$link1)
        tr[(signed long int)add_segment$$1$$4$$tmp_d$link1].u1 = tl$link1;

    }

    add_segment$$1$$4$$tmp_d$link1 = tr[(signed long int)tl$link1].d1;
    if(add_segment$$1$$4$$tmp_d$link1 >= 1)
    {
      if(tr[(signed long int)add_segment$$1$$4$$tmp_d$link1].u0 == tu$link1)
        tr[(signed long int)add_segment$$1$$4$$tmp_d$link1].u0 = tl$link1;

    }

    add_segment$$1$$4$$tmp_d$link1 = tr[(signed long int)tl$link1].d1;
    if(add_segment$$1$$4$$tmp_d$link1 >= 1)
    {
      if(tr[(signed long int)add_segment$$1$$4$$tmp_d$link1].u1 == tu$link1)
        tr[(signed long int)add_segment$$1$$4$$tmp_d$link1].u1 = tl$link1;

    }

    i1$link1=newnode$link1();
    i2$link1=newnode$link1();
    sk$link1 = tr[(signed long int)tu$link1].sink;
    qs[(signed long int)sk$link1].nodetype = 2;
    qs[(signed long int)sk$link1].yval = s$link1.v1;
    qs[(signed long int)sk$link1].segnum = segnum$link1;
    qs[(signed long int)sk$link1].left = i2$link1;
    qs[(signed long int)sk$link1].right = i1$link1;
    qs[(signed long int)i1$link1].nodetype = 3;
    qs[(signed long int)i1$link1].trnum = tu$link1;
    qs[(signed long int)i1$link1].parent = sk$link1;
    qs[(signed long int)i2$link1].nodetype = 3;
    qs[(signed long int)i2$link1].trnum = tl$link1;
    qs[(signed long int)i2$link1].parent = sk$link1;
    tr[(signed long int)tu$link1].sink = i1$link1;
    tr[(signed long int)tl$link1].sink = i2$link1;
    tlast$link1 = tu$link1;
  }

  else
  {
    tlast$link1=locate_endpoint(&s$link1.v1, &s$link1.v0, s$link1.root1);
    tribot$link1 = 1;
  }
  add_segment$$1$$t$link1 = tfirst$link1;
  signed int return_value__greater_than_equal_to$8$link1;
  _Bool tmp_if_expr$39$link1;
  _Bool tmp_if_expr$38$link1;
  _Bool tmp_if_expr$13$link1;
  _Bool tmp_if_expr$12$link1;
  _Bool tmp_if_expr$11$link1;
  signed int return_value_is_left_of$10$link1;
  _Bool tmp_if_expr$18$link1;
  double return_value_fabs$17$link1;
  _Bool tmp_if_expr$15$link1;
  signed int return_value_is_left_of$14$link1;
  _Bool tmp_if_expr$37$link1;
  _Bool tmp_if_expr$22$link1;
  _Bool tmp_if_expr$21$link1;
  _Bool tmp_if_expr$20$link1;
  signed int return_value_is_left_of$19$link1;
  _Bool tmp_if_expr$27$link1;
  double return_value_fabs$26$link1;
  _Bool tmp_if_expr$24$link1;
  signed int return_value_is_left_of$23$link1;
  _Bool tmp_if_expr$33$link1;
  _Bool tmp_if_expr$32$link1;
  _Bool tmp_if_expr$31$link1;
  signed int return_value_is_left_of$30$link1;
  _Bool tmp_if_expr$36$link1;
  double return_value_fabs$35$link1;
  while(add_segment$$1$$t$link1 >= 1)
  {
    return_value__greater_than_equal_to$8$link1=_greater_than_equal_to(&tr[(signed long int)add_segment$$1$$t$link1].lo, &tr[(signed long int)tlast$link1].lo);
    if(return_value__greater_than_equal_to$8$link1 == 0)
      break;

    signed int t_sav$link1;
    signed int tn_sav$link1;
    sk$link1 = tr[(signed long int)add_segment$$1$$t$link1].sink;
    i1$link1=newnode$link1();
    i2$link1=newnode$link1();
    qs[(signed long int)sk$link1].nodetype = 1;
    qs[(signed long int)sk$link1].segnum = segnum$link1;
    qs[(signed long int)sk$link1].left = i1$link1;
    qs[(signed long int)sk$link1].right = i2$link1;
    qs[(signed long int)i1$link1].nodetype = 3;
    qs[(signed long int)i1$link1].trnum = add_segment$$1$$t$link1;
    qs[(signed long int)i1$link1].parent = sk$link1;
    qs[(signed long int)i2$link1].nodetype = 3;
    tn$link1=newtrap$link1();
    qs[(signed long int)i2$link1].trnum = tn$link1;
    tr[(signed long int)tn$link1].state = 1;
    qs[(signed long int)i2$link1].parent = sk$link1;
    if(add_segment$$1$$t$link1 == tfirst$link1)
      tfirstr$link1 = tn$link1;

    signed int return_value__equal_to$9$link1;
    return_value__equal_to$9$link1=_equal_to(&tr[(signed long int)add_segment$$1$$t$link1].lo, &tr[(signed long int)tlast$link1].lo);
    if(!(return_value__equal_to$9$link1 == 0))
      tlastr$link1 = tn$link1;

    tr[(signed long int)tn$link1] = tr[(signed long int)add_segment$$1$$t$link1];
    tr[(signed long int)add_segment$$1$$t$link1].sink = i1$link1;
    tr[(signed long int)tn$link1].sink = i2$link1;
    t_sav$link1 = add_segment$$1$$t$link1;
    tn_sav$link1 = tn$link1;
    if(!(tr[(signed long int)add_segment$$1$$t$link1].d0 >= 1))
      tmp_if_expr$39$link1 = tr[(signed long int)add_segment$$1$$t$link1].d1 <= 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$39$link1 = (_Bool)0;
    if(tmp_if_expr$39$link1)
    {
      errs("sei:add_segment()", "error");
      break;
    }

    else
    {
      if(tr[(signed long int)add_segment$$1$$t$link1].d0 >= 1)
        tmp_if_expr$38$link1 = tr[(signed long int)add_segment$$1$$t$link1].d1 <= 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$38$link1 = (_Bool)0;
      if(tmp_if_expr$38$link1)
      {
        if(tr[(signed long int)add_segment$$1$$t$link1].u0 >= 1)
          tmp_if_expr$13$link1 = tr[(signed long int)add_segment$$1$$t$link1].u1 > 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$13$link1 = (_Bool)0;
        if(tmp_if_expr$13$link1)
        {
          if(tr[(signed long int)add_segment$$1$$t$link1].usave >= 1)
          {
            if(tr[(signed long int)add_segment$$1$$t$link1].uside == 1)
            {
              tr[(signed long int)tn$link1].u0 = tr[(signed long int)add_segment$$1$$t$link1].u1;
              tr[(signed long int)add_segment$$1$$t$link1].u1 = -1;
              tr[(signed long int)tn$link1].u1 = tr[(signed long int)add_segment$$1$$t$link1].usave;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u0].d0 = add_segment$$1$$t$link1;
              tr[(signed long int)tr[(signed long int)tn$link1].u0].d0 = tn$link1;
              tr[(signed long int)tr[(signed long int)tn$link1].u1].d0 = tn$link1;
            }

            else
            {
              tr[(signed long int)tn$link1].u1 = -1;
              tr[(signed long int)tn$link1].u0 = tr[(signed long int)add_segment$$1$$t$link1].u1;
              tr[(signed long int)add_segment$$1$$t$link1].u1 = tr[(signed long int)add_segment$$1$$t$link1].u0;
              tr[(signed long int)add_segment$$1$$t$link1].u0 = tr[(signed long int)add_segment$$1$$t$link1].usave;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u0].d0 = add_segment$$1$$t$link1;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u1].d0 = add_segment$$1$$t$link1;
              tr[(signed long int)tr[(signed long int)tn$link1].u0].d0 = tn$link1;
            }
            tr[(signed long int)tn$link1].usave = 0;
            tr[(signed long int)add_segment$$1$$t$link1].usave = tr[(signed long int)tn$link1].usave;
          }

          else
          {
            tr[(signed long int)tn$link1].u0 = tr[(signed long int)add_segment$$1$$t$link1].u1;
            tr[(signed long int)tn$link1].u1 = -1;
            tr[(signed long int)add_segment$$1$$t$link1].u1 = tr[(signed long int)tn$link1].u1;
            tr[(signed long int)tr[(signed long int)tn$link1].u0].d0 = tn$link1;
          }
        }

        else
        {
          signed int tmp_u$link1 = tr[(signed long int)add_segment$$1$$t$link1].u0;
          signed int add_segment$$1$$6$$2$$2$$td0$link1 = tr[(signed long int)tmp_u$link1].d0;
          if(add_segment$$1$$6$$2$$2$$td0$link1 >= 1)
            tmp_if_expr$12$link1 = tr[(signed long int)tmp_u$link1].d1 > 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$12$link1 = (_Bool)0;
          if(tmp_if_expr$12$link1)
          {
            if(tr[(signed long int)add_segment$$1$$6$$2$$2$$td0$link1].rseg >= 1)
            {
              return_value_is_left_of$10$link1=is_left_of$link1(tr[(signed long int)add_segment$$1$$6$$2$$2$$td0$link1].rseg, &s$link1.v1);
              tmp_if_expr$11$link1 = !(return_value_is_left_of$10$link1 != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$11$link1 = (_Bool)0;
            if(tmp_if_expr$11$link1)
            {
              tr[(signed long int)tn$link1].u1 = -1;
              tr[(signed long int)add_segment$$1$$t$link1].u1 = tr[(signed long int)tn$link1].u1;
              tr[(signed long int)add_segment$$1$$t$link1].u0 = tr[(signed long int)add_segment$$1$$t$link1].u1;
              tr[(signed long int)tr[(signed long int)tn$link1].u0].d1 = tn$link1;
            }

            else
            {
              tr[(signed long int)add_segment$$1$$t$link1].u1 = -1;
              tr[(signed long int)tn$link1].u1 = tr[(signed long int)add_segment$$1$$t$link1].u1;
              tr[(signed long int)tn$link1].u0 = tr[(signed long int)tn$link1].u1;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u0].d0 = add_segment$$1$$t$link1;
            }
          }

          else
          {
            tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u0].d0 = add_segment$$1$$t$link1;
            tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u0].d1 = tn$link1;
          }
        }
        double return_value_fabs$16$link1;
        return_value_fabs$16$link1=fabs(tr[(signed long int)add_segment$$1$$t$link1].lo.y - tr[(signed long int)tlast$link1].lo.y);
        if(return_value_fabs$16$link1 <= 1.0e-7)
        {
          return_value_fabs$17$link1=fabs(tr[(signed long int)add_segment$$1$$t$link1].lo.x - tr[(signed long int)tlast$link1].lo.x);
          tmp_if_expr$18$link1 = return_value_fabs$17$link1 <= 1.0e-7 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$18$link1 = (_Bool)0;
        if(!(tribot$link1 == 0) && tmp_if_expr$18$link1)
        {
          if(!(is_swapped$link1 == 0))
            tmptriseg$link1 = seg[(signed long int)segnum$link1].prev;

          else
            tmptriseg$link1 = seg[(signed long int)segnum$link1].next;
          if(tmptriseg$link1 >= 1)
          {
            return_value_is_left_of$14$link1=is_left_of$link1(tmptriseg$link1, &s$link1.v0);
            tmp_if_expr$15$link1 = return_value_is_left_of$14$link1 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$15$link1 = (_Bool)0;
          if(tmp_if_expr$15$link1)
          {
            tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].u0 = add_segment$$1$$t$link1;
            tr[(signed long int)tn$link1].d1 = -1;
            tr[(signed long int)tn$link1].d0 = tr[(signed long int)tn$link1].d1;
          }

          else
          {
            tr[(signed long int)tr[(signed long int)tn$link1].d0].u1 = tn$link1;
            tr[(signed long int)add_segment$$1$$t$link1].d1 = -1;
            tr[(signed long int)add_segment$$1$$t$link1].d0 = tr[(signed long int)add_segment$$1$$t$link1].d1;
          }
        }

        else
        {
          if(tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].u0 >= 1)
          {
            if(tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].u1 >= 1)
            {
              if(tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].u0 == add_segment$$1$$t$link1)
              {
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].usave = tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].u1;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].uside = 1;
              }

              else
              {
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].usave = tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].u0;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].uside = 2;
              }
            }

          }

          tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].u0 = add_segment$$1$$t$link1;
          tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].u1 = tn$link1;
        }
        add_segment$$1$$t$link1 = tr[(signed long int)add_segment$$1$$t$link1].d0;
      }

      else
      {
        if(!(tr[(signed long int)add_segment$$1$$t$link1].d0 >= 1))
          tmp_if_expr$37$link1 = tr[(signed long int)add_segment$$1$$t$link1].d1 > 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$37$link1 = (_Bool)0;
        if(tmp_if_expr$37$link1)
        {
          if(tr[(signed long int)add_segment$$1$$t$link1].u0 >= 1)
            tmp_if_expr$22$link1 = tr[(signed long int)add_segment$$1$$t$link1].u1 > 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$22$link1 = (_Bool)0;
          if(tmp_if_expr$22$link1)
          {
            if(tr[(signed long int)add_segment$$1$$t$link1].usave >= 1)
            {
              if(tr[(signed long int)add_segment$$1$$t$link1].uside == 1)
              {
                tr[(signed long int)tn$link1].u0 = tr[(signed long int)add_segment$$1$$t$link1].u1;
                tr[(signed long int)add_segment$$1$$t$link1].u1 = -1;
                tr[(signed long int)tn$link1].u1 = tr[(signed long int)add_segment$$1$$t$link1].usave;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u0].d0 = add_segment$$1$$t$link1;
                tr[(signed long int)tr[(signed long int)tn$link1].u0].d0 = tn$link1;
                tr[(signed long int)tr[(signed long int)tn$link1].u1].d0 = tn$link1;
              }

              else
              {
                tr[(signed long int)tn$link1].u1 = -1;
                tr[(signed long int)tn$link1].u0 = tr[(signed long int)add_segment$$1$$t$link1].u1;
                tr[(signed long int)add_segment$$1$$t$link1].u1 = tr[(signed long int)add_segment$$1$$t$link1].u0;
                tr[(signed long int)add_segment$$1$$t$link1].u0 = tr[(signed long int)add_segment$$1$$t$link1].usave;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u0].d0 = add_segment$$1$$t$link1;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u1].d0 = add_segment$$1$$t$link1;
                tr[(signed long int)tr[(signed long int)tn$link1].u0].d0 = tn$link1;
              }
              tr[(signed long int)tn$link1].usave = 0;
              tr[(signed long int)add_segment$$1$$t$link1].usave = tr[(signed long int)tn$link1].usave;
            }

            else
            {
              tr[(signed long int)tn$link1].u0 = tr[(signed long int)add_segment$$1$$t$link1].u1;
              tr[(signed long int)tn$link1].u1 = -1;
              tr[(signed long int)add_segment$$1$$t$link1].u1 = tr[(signed long int)tn$link1].u1;
              tr[(signed long int)tr[(signed long int)tn$link1].u0].d0 = tn$link1;
            }
          }

          else
          {
            signed int add_segment$$1$$6$$3$$2$$tmp_u$link1 = tr[(signed long int)add_segment$$1$$t$link1].u0;
            signed int add_segment$$1$$6$$3$$2$$td0$link1 = tr[(signed long int)add_segment$$1$$6$$3$$2$$tmp_u$link1].d0;
            if(add_segment$$1$$6$$3$$2$$td0$link1 >= 1)
              tmp_if_expr$21$link1 = tr[(signed long int)add_segment$$1$$6$$3$$2$$tmp_u$link1].d1 > 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$21$link1 = (_Bool)0;
            if(tmp_if_expr$21$link1)
            {
              if(tr[(signed long int)add_segment$$1$$6$$3$$2$$td0$link1].rseg >= 1)
              {
                return_value_is_left_of$19$link1=is_left_of$link1(tr[(signed long int)add_segment$$1$$6$$3$$2$$td0$link1].rseg, &s$link1.v1);
                tmp_if_expr$20$link1 = !(return_value_is_left_of$19$link1 != 0) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$20$link1 = (_Bool)0;
              if(tmp_if_expr$20$link1)
              {
                tr[(signed long int)tn$link1].u1 = -1;
                tr[(signed long int)add_segment$$1$$t$link1].u1 = tr[(signed long int)tn$link1].u1;
                tr[(signed long int)add_segment$$1$$t$link1].u0 = tr[(signed long int)add_segment$$1$$t$link1].u1;
                tr[(signed long int)tr[(signed long int)tn$link1].u0].d1 = tn$link1;
              }

              else
              {
                tr[(signed long int)add_segment$$1$$t$link1].u1 = -1;
                tr[(signed long int)tn$link1].u1 = tr[(signed long int)add_segment$$1$$t$link1].u1;
                tr[(signed long int)tn$link1].u0 = tr[(signed long int)tn$link1].u1;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u0].d0 = add_segment$$1$$t$link1;
              }
            }

            else
            {
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u0].d0 = add_segment$$1$$t$link1;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u0].d1 = tn$link1;
            }
          }
          double return_value_fabs$25$link1;
          return_value_fabs$25$link1=fabs(tr[(signed long int)add_segment$$1$$t$link1].lo.y - tr[(signed long int)tlast$link1].lo.y);
          if(return_value_fabs$25$link1 <= 1.0e-7)
          {
            return_value_fabs$26$link1=fabs(tr[(signed long int)add_segment$$1$$t$link1].lo.x - tr[(signed long int)tlast$link1].lo.x);
            tmp_if_expr$27$link1 = return_value_fabs$26$link1 <= 1.0e-7 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$27$link1 = (_Bool)0;
          if(!(tribot$link1 == 0) && tmp_if_expr$27$link1)
          {
            if(tmpseg$link1 >= 1)
            {
              return_value_is_left_of$23$link1=is_left_of$link1(tmpseg$link1, &s$link1.v0);
              tmp_if_expr$24$link1 = return_value_is_left_of$23$link1 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$24$link1 = (_Bool)0;
            if(tmp_if_expr$24$link1)
            {
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].u0 = add_segment$$1$$t$link1;
              tr[(signed long int)tn$link1].d1 = -1;
              tr[(signed long int)tn$link1].d0 = tr[(signed long int)tn$link1].d1;
            }

            else
            {
              tr[(signed long int)tr[(signed long int)tn$link1].d1].u1 = tn$link1;
              tr[(signed long int)add_segment$$1$$t$link1].d1 = -1;
              tr[(signed long int)add_segment$$1$$t$link1].d0 = tr[(signed long int)add_segment$$1$$t$link1].d1;
            }
          }

          else
          {
            if(tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].u0 >= 1)
            {
              if(tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].u1 >= 1)
              {
                if(tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].u0 == add_segment$$1$$t$link1)
                {
                  tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].usave = tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].u1;
                  tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].uside = 1;
                }

                else
                {
                  tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].usave = tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].u0;
                  tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].uside = 2;
                }
              }

            }

            tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].u0 = add_segment$$1$$t$link1;
            tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].u1 = tn$link1;
          }
          add_segment$$1$$t$link1 = tr[(signed long int)add_segment$$1$$t$link1].d1;
        }

        else
        {
          double y0$link1;
          double yt$link1;
          struct anonymous$1 tmppt$link1;
          signed int tnext$link1;
          signed int i_d0$link1;
          tmpseg$link1 = tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].rseg;
          i_d0$link1 = 0;
          double return_value_fabs$29$link1;
          return_value_fabs$29$link1=fabs(tr[(signed long int)add_segment$$1$$t$link1].lo.y - s$link1.v0.y);
          if(return_value_fabs$29$link1 <= 1.0e-7)
          {
            if(tr[(signed long int)add_segment$$1$$t$link1].lo.x > s$link1.v0.x)
              i_d0$link1 = 1;

          }

          else
          {
            y0$link1 = tr[(signed long int)add_segment$$1$$t$link1].lo.y;
            tmppt$link1.y = y0$link1;
            yt$link1 = (y0$link1 - s$link1.v0.y) / (s$link1.v1.y - s$link1.v0.y);
            tmppt$link1.x = s$link1.v0.x + yt$link1 * (s$link1.v1.x - s$link1.v0.x);
            signed int return_value__less_than$28$link1;
            return_value__less_than$28$link1=_less_than(&tmppt$link1, &tr[(signed long int)add_segment$$1$$t$link1].lo);
            if(!(return_value__less_than$28$link1 == 0))
              i_d0$link1 = 1;

          }
          if(tr[(signed long int)add_segment$$1$$t$link1].u0 >= 1)
            tmp_if_expr$33$link1 = tr[(signed long int)add_segment$$1$$t$link1].u1 > 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$33$link1 = (_Bool)0;
          if(tmp_if_expr$33$link1)
          {
            if(tr[(signed long int)add_segment$$1$$t$link1].usave >= 1)
            {
              if(tr[(signed long int)add_segment$$1$$t$link1].uside == 1)
              {
                tr[(signed long int)tn$link1].u0 = tr[(signed long int)add_segment$$1$$t$link1].u1;
                tr[(signed long int)add_segment$$1$$t$link1].u1 = -1;
                tr[(signed long int)tn$link1].u1 = tr[(signed long int)add_segment$$1$$t$link1].usave;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u0].d0 = add_segment$$1$$t$link1;
                tr[(signed long int)tr[(signed long int)tn$link1].u0].d0 = tn$link1;
                tr[(signed long int)tr[(signed long int)tn$link1].u1].d0 = tn$link1;
              }

              else
              {
                tr[(signed long int)tn$link1].u1 = -1;
                tr[(signed long int)tn$link1].u0 = tr[(signed long int)add_segment$$1$$t$link1].u1;
                tr[(signed long int)add_segment$$1$$t$link1].u1 = tr[(signed long int)add_segment$$1$$t$link1].u0;
                tr[(signed long int)add_segment$$1$$t$link1].u0 = tr[(signed long int)add_segment$$1$$t$link1].usave;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u0].d0 = add_segment$$1$$t$link1;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u1].d0 = add_segment$$1$$t$link1;
                tr[(signed long int)tr[(signed long int)tn$link1].u0].d0 = tn$link1;
              }
              tr[(signed long int)tn$link1].usave = 0;
              tr[(signed long int)add_segment$$1$$t$link1].usave = tr[(signed long int)tn$link1].usave;
            }

            else
            {
              tr[(signed long int)tn$link1].u0 = tr[(signed long int)add_segment$$1$$t$link1].u1;
              tr[(signed long int)tn$link1].u1 = -1;
              tr[(signed long int)add_segment$$1$$t$link1].u1 = -1;
              tr[(signed long int)tr[(signed long int)tn$link1].u0].d0 = tn$link1;
            }
          }

          else
          {
            signed int add_segment$$1$$6$$4$$4$$tmp_u$link1 = tr[(signed long int)add_segment$$1$$t$link1].u0;
            signed int td0$link1 = tr[(signed long int)add_segment$$1$$6$$4$$4$$tmp_u$link1].d0;
            if(td0$link1 >= 1)
              tmp_if_expr$32$link1 = tr[(signed long int)add_segment$$1$$6$$4$$4$$tmp_u$link1].d1 > 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$32$link1 = (_Bool)0;
            if(tmp_if_expr$32$link1)
            {
              if(tr[(signed long int)td0$link1].rseg >= 1)
              {
                return_value_is_left_of$30$link1=is_left_of$link1(tr[(signed long int)td0$link1].rseg, &s$link1.v1);
                tmp_if_expr$31$link1 = !(return_value_is_left_of$30$link1 != 0) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$31$link1 = (_Bool)0;
              if(tmp_if_expr$31$link1)
              {
                tr[(signed long int)tn$link1].u1 = -1;
                tr[(signed long int)add_segment$$1$$t$link1].u1 = tr[(signed long int)tn$link1].u1;
                tr[(signed long int)add_segment$$1$$t$link1].u0 = tr[(signed long int)add_segment$$1$$t$link1].u1;
                tr[(signed long int)tr[(signed long int)tn$link1].u0].d1 = tn$link1;
              }

              else
              {
                tr[(signed long int)add_segment$$1$$t$link1].u1 = -1;
                tr[(signed long int)tn$link1].u1 = tr[(signed long int)add_segment$$1$$t$link1].u1;
                tr[(signed long int)tn$link1].u0 = tr[(signed long int)tn$link1].u1;
                tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u0].d0 = add_segment$$1$$t$link1;
              }
            }

            else
            {
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u0].d0 = add_segment$$1$$t$link1;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].u0].d1 = tn$link1;
            }
          }
          double return_value_fabs$34$link1;
          return_value_fabs$34$link1=fabs(tr[(signed long int)add_segment$$1$$t$link1].lo.y - tr[(signed long int)tlast$link1].lo.y);
          if(return_value_fabs$34$link1 <= 1.0e-7)
          {
            return_value_fabs$35$link1=fabs(tr[(signed long int)add_segment$$1$$t$link1].lo.x - tr[(signed long int)tlast$link1].lo.x);
            tmp_if_expr$36$link1 = return_value_fabs$35$link1 <= 1.0e-7 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$36$link1 = (_Bool)0;
          if(!(tribot$link1 == 0) && tmp_if_expr$36$link1)
          {
            tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].u0 = add_segment$$1$$t$link1;
            tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].u1 = -1;
            tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].u0 = tn$link1;
            tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].u1 = -1;
            tr[(signed long int)tn$link1].d0 = tr[(signed long int)add_segment$$1$$t$link1].d1;
            tr[(signed long int)tn$link1].d1 = -1;
            tr[(signed long int)add_segment$$1$$t$link1].d1 = tr[(signed long int)tn$link1].d1;
            tnext$link1 = tr[(signed long int)add_segment$$1$$t$link1].d1;
          }

          else
            if(!(i_d0$link1 == 0))
            {
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].u0 = add_segment$$1$$t$link1;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].u1 = tn$link1;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].u0 = tn$link1;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].u1 = -1;
              tr[(signed long int)add_segment$$1$$t$link1].d1 = -1;
              tnext$link1 = tr[(signed long int)add_segment$$1$$t$link1].d0;
            }

            else
            {
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].u0 = add_segment$$1$$t$link1;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d0].u1 = -1;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].u0 = add_segment$$1$$t$link1;
              tr[(signed long int)tr[(signed long int)add_segment$$1$$t$link1].d1].u1 = tn$link1;
              tr[(signed long int)tn$link1].d0 = tr[(signed long int)add_segment$$1$$t$link1].d1;
              tr[(signed long int)tn$link1].d1 = -1;
              tnext$link1 = tr[(signed long int)add_segment$$1$$t$link1].d1;
            }
          add_segment$$1$$t$link1 = tnext$link1;
        }
      }
    }
    tr[(signed long int)tn_sav$link1].lseg = segnum$link1;
    tr[(signed long int)t_sav$link1].rseg = tr[(signed long int)tn_sav$link1].lseg;
  }
  tfirstl$link1 = tfirst$link1;
  tlastl$link1 = tlast$link1;
  merge_trapezoids$link1(segnum$link1, tfirstl$link1, tlastl$link1, 1);
  merge_trapezoids$link1(segnum$link1, tfirstr$link1, tlastr$link1, 2);
  seg[(signed long int)segnum$link1].is_inserted = 1;
  return 0;
}

// alloc_memory
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 55
void * alloc_memory(signed int len)
{
  void *res;
  res=malloc((unsigned long int)len);
  if(res == NULL)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    printf("Error - can't allocate memory: %s\n", return_value_strerror$2);
    exit(1);
  }

  memset(res, 0, (unsigned long int)len);
  return res;
}

// choose_segment
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_misc.c line 79
extern signed int choose_segment(void)
{
  errds(1, "sei:choose_segment()", "%d", permute[(signed long int)choose_idx]);
  signed int tmp_post$1 = choose_idx;
  choose_idx = choose_idx + 1;
  return permute[(signed long int)tmp_post$1];
}

// construct_trapezoids
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 920
extern signed int construct_trapezoids(signed int nseg)
{
  signed int i;
  signed int construct_trapezoids$$1$$root;
  signed int h;
  signed int return_value_choose_segment$1;
  return_value_choose_segment$1=choose_segment();
  construct_trapezoids$$1$$root=init_query_structure(return_value_choose_segment$1);
  i = 1;
  for( ; nseg >= i; i = i + 1)
  {
    seg[(signed long int)i].root1 = construct_trapezoids$$1$$root;
    seg[(signed long int)i].root0 = seg[(signed long int)i].root1;
  }
  h = 1;
  signed int return_value_math_logstar_n$2;
  signed int return_value_math_N$4;
  signed int return_value_choose_segment$5;
  do
  {
    return_value_math_logstar_n$2=math_logstar_n(nseg);
    if(!(return_value_math_logstar_n$2 >= h))
      break;

    signed int return_value_math_N$3;
    return_value_math_N$3=math_N(nseg, h - 1);
    i = return_value_math_N$3 + 1;
    do
    {
      return_value_math_N$4=math_N(nseg, h);
      if(!(return_value_math_N$4 >= i))
        break;

      return_value_choose_segment$5=choose_segment();
      add_segment(return_value_choose_segment$5);
      i = i + 1;
    }
    while((_Bool)1);
    i = 1;
    for( ; nseg >= i; i = i + 1)
      find_new_roots(i);
    h = h + 1;
  }
  while((_Bool)1);
  signed int return_value_math_logstar_n$6;
  return_value_math_logstar_n$6=math_logstar_n(nseg);
  signed int return_value_math_N$7;
  return_value_math_N$7=math_N(nseg, return_value_math_logstar_n$6);
  i = return_value_math_N$7 + 1;
  signed int return_value_choose_segment$8;
  for( ; nseg >= i; i = i + 1)
  {
    return_value_choose_segment$8=choose_segment();
    add_segment(return_value_choose_segment$8);
  }
  return 0;
}

// errdn
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 111
static inline void errdn(signed int relevance, const char *func, signed int en)
{
  ;
}

// errdn$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 111
static inline void errdn$link1(signed int relevance$link1, const char *func$link1, signed int en$link1)
{
  ;
}

// errds
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 114
static inline void errds(signed int relevance, const char *func, const char *fmt, ...)
{
  ;
}

// errds$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 114
static inline void errds$link1(signed int relevance$link1, const char *func$link1, const char *fmt$link1, ...)
{
  ;
}

// errn
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/error.c line 63
void errn(const char *func, signed int en)
{
  char *return_value_strerror$1;
  return_value_strerror$1=strerror(en);
  fprintf(stderr, "s3dlib error: %s: (%d) %s\n", func, en, return_value_strerror$1);
}

// errs
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/error.c line 67
void errs(const char *func, const char *msg)
{
  fprintf(stderr, "s3dlib error: %s: %s\n", func, msg);
}

// find_new_roots
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 903
static signed int find_new_roots(signed int segnum)
{
  struct anonymous$14 *s = &seg[(signed long int)segnum];
  if(!(s->is_inserted == 0))
    return 0;

  else
  {
    s->root0=locate_endpoint(&s->v0, &s->v1, s->root0);
    s->root0 = tr[(signed long int)s->root0].sink;
    s->root1=locate_endpoint(&s->v1, &s->v0, s->root1);
    s->root1 = tr[(signed long int)s->root1].sink;
    return 0;
  }
}

// find_new_roots$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 903
static signed int find_new_roots$link1(signed int segnum$link1)
{
  struct anonymous$14 *s$link1 = &seg[(signed long int)segnum$link1];
  if(!(s$link1->is_inserted == 0))
    return 0;

  else
  {
    s$link1->root0=locate_endpoint(&s$link1->v0, &s$link1->v1, s$link1->root0);
    s$link1->root0 = tr[(signed long int)s$link1->root0].sink;
    s$link1->root1=locate_endpoint(&s$link1->v1, &s$link1->v0, s$link1->root1);
    s$link1->root1 = tr[(signed long int)s$link1->root1].sink;
    return 0;
  }
}

// find_wlan_network
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/network.c line 81
struct wlan_network * find_wlan_network(char *bssid)
{
  struct list_head *network_pos;
  struct wlan_network *wlan_network;
  network_pos = (&Network_list)->next;
  for( ; !(network_pos == &Network_list); network_pos = network_pos->next)
  {
    wlan_network = (struct wlan_network *)((char *)network_pos - (signed long int)(unsigned long int)&((struct wlan_network *)0)->list);
    signed int return_value_strncmp$1;
    return_value_strncmp$1=strncmp(wlan_network->bssid, bssid, (unsigned long int)18);
    if(return_value_strncmp$1 == 0)
      return wlan_network;

  }
  return (struct wlan_network *)(void *)0;
}

// generate_random_ordering
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_misc.c line 53
extern signed int generate_random_ordering(signed int n)
{
  struct timeval tval;
  signed int i;
  signed int m;
  signed int st[200l];
  signed int *p;
  choose_idx = 1;
  gettimeofday(&tval, (struct timezone *)(void *)0);
  srand48(tval.tv_sec);
  i = 0;
  for( ; n >= i; i = i + 1)
    st[(signed long int)i] = i;
  p = st;
  i = 1;
  for( ; n >= i; p = p + 1l)
  {
    signed long int return_value_lrand48$1;
    return_value_lrand48$1=lrand48();
    m = (signed int)(return_value_lrand48$1 % (signed long int)((n + 1) - i) + (signed long int)1);
    permute[(signed long int)i] = p[(signed long int)m];
    if(!(m == 1))
      p[(signed long int)m] = p[(signed long int)1];

    i = i + 1;
  }
  return 0;
}

// get_angle
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 100
static double get_angle(struct anonymous$1 *vp0, struct anonymous$1 *vpnext, struct anonymous$1 *vp1)
{
  struct anonymous$1 v0;
  struct anonymous$1 v1;
  v0.x = vpnext->x - vp0->x;
  v0.y = vpnext->y - vp0->y;
  v1.x = vp1->x - vp0->x;
  v1.y = vp1->y - vp0->y;
  double return_value_sqrt$1;
  double return_value_sqrt$2;
  double return_value_sqrt$3;
  double return_value_sqrt$4;
  if(v0.x * v1.y + -(v1.x * v0.y) >= 0.000000)
  {
    return_value_sqrt$1=sqrt(v0.x * v0.x + v0.y * v0.y);
    return_value_sqrt$2=sqrt(v1.x * v1.x + v1.y * v1.y);
    return ((v0.x * v1.x + v0.y * v1.y) / return_value_sqrt$1) / return_value_sqrt$2;
  }

  else
  {
    return_value_sqrt$3=sqrt(v0.x * v0.x + v0.y * v0.y);
    return_value_sqrt$4=sqrt(v1.x * v1.x + v1.y * v1.y);
    return ((-1.0 * (v0.x * v1.x + v0.y * v1.y)) / return_value_sqrt$3) / return_value_sqrt$4 - (double)2;
  }
}

// get_angle$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 100
static double get_angle$link1(struct anonymous$1 *vp0$link1, struct anonymous$1 *vpnext$link1, struct anonymous$1 *vp1$link1)
{
  struct anonymous$1 v0$link1;
  struct anonymous$1 v1$link1;
  v0$link1.x = vpnext$link1->x - vp0$link1->x;
  v0$link1.y = vpnext$link1->y - vp0$link1->y;
  v1$link1.x = vp1$link1->x - vp0$link1->x;
  v1$link1.y = vp1$link1->y - vp0$link1->y;
  double return_value_sqrt$1$link1;
  double return_value_sqrt$2$link1;
  double return_value_sqrt$3$link1;
  double return_value_sqrt$4$link1;
  if(v0$link1.x * v1$link1.y + -(v1$link1.x * v0$link1.y) >= 0.000000)
  {
    return_value_sqrt$1$link1=sqrt(v0$link1.x * v0$link1.x + v0$link1.y * v0$link1.y);
    return_value_sqrt$2$link1=sqrt(v1$link1.x * v1$link1.x + v1$link1.y * v1$link1.y);
    return ((v0$link1.x * v1$link1.x + v0$link1.y * v1$link1.y) / return_value_sqrt$1$link1) / return_value_sqrt$2$link1;
  }

  else
  {
    return_value_sqrt$3$link1=sqrt(v0$link1.x * v0$link1.x + v0$link1.y * v0$link1.y);
    return_value_sqrt$4$link1=sqrt(v1$link1.x * v1$link1.x + v1$link1.y * v1$link1.y);
    return ((-1.0 * (v0$link1.x * v1$link1.x + v0$link1.y * v1$link1.y)) / return_value_sqrt$3$link1) / return_value_sqrt$4$link1 - (double)2;
  }
}

// get_mat2tex
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/modelread.c line 91
static struct material2texture * get_mat2tex(struct material2texture **mat2tex, void *mat_ptr)
{
  for( ; !(*mat2tex == ((struct material2texture *)NULL)); mat2tex = &(*mat2tex)->next_ptr)
    if((*mat2tex)->material_ptr == mat_ptr)
      return *mat2tex;

  if(*mat2tex == ((struct material2texture *)NULL))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct material2texture) /*32ul*/ );
    *mat2tex = (struct material2texture *)return_value_malloc$1;
    if(*mat2tex == ((struct material2texture *)NULL))
    {
      errs("model_import()", "Sorry - you ran out of memory !\n");
      exit(8);
    }

    (*mat2tex)->next_ptr = (struct material2texture *)(void *)0;
    (*mat2tex)->material_ptr = mat_ptr;
    (*mat2tex)->texture_ptr = (void *)0;
    (*mat2tex)->material_id = -1;
    (*mat2tex)->texture_id = -1;
    return *mat2tex;
  }

  return (struct material2texture *)(void *)0;
}

// get_mat2tex$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/modelread.c line 91
static struct material2texture * get_mat2tex$link1(struct material2texture **mat2tex$link1, void *mat_ptr$link1)
{
  for( ; !(*mat2tex$link1 == ((struct material2texture *)NULL)); mat2tex$link1 = &(*mat2tex$link1)->next_ptr)
    if((*mat2tex$link1)->material_ptr == mat_ptr$link1)
      return *mat2tex$link1;

  if(*mat2tex$link1 == ((struct material2texture *)NULL))
  {
    void *return_value_malloc$1$link1;
    return_value_malloc$1$link1=malloc(sizeof(struct material2texture) /*32ul*/ );
    *mat2tex$link1 = (struct material2texture *)return_value_malloc$1$link1;
    if(*mat2tex$link1 == ((struct material2texture *)NULL))
    {
      errs("model_import()", "Sorry - you ran out of memory !\n");
      exit(8);
    }

    (*mat2tex$link1)->next_ptr = (struct material2texture *)(void *)0;
    (*mat2tex$link1)->material_ptr = mat_ptr$link1;
    (*mat2tex$link1)->texture_ptr = (void *)0;
    (*mat2tex$link1)->material_id = -1;
    (*mat2tex$link1)->texture_id = -1;
    return *mat2tex$link1;
  }

  return (struct material2texture *)(void *)0;
}

// get_time
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 73
unsigned int get_time(void)
{
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  return (unsigned int)(tv.tv_sec * (signed long int)1000 + tv.tv_usec / (signed long int)1000);
}

// get_vertex_positions
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 119
static signed int get_vertex_positions(signed int v0, signed int v1, signed int *ip, signed int *iq)
{
  struct anonymous$2 *vp0;
  struct anonymous$2 *vp1;
  signed int i;
  double angle;
  double temp;
  signed int tp;
  signed int tq = 0;
  tp = tq;
  vp0 = &vert[(signed long int)v0];
  vp1 = &vert[(signed long int)v1];
  angle = -4.0;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
    if(vp0->vnext[(signed long int)i] >= 1)
    {
      temp=get_angle(&vp0->pt, &vert[(signed long int)vp0->vnext[(signed long int)i]].pt, &vp1->pt);
      if(temp > angle)
      {
        angle = temp;
        tp = i;
      }

    }

  *ip = tp;
  angle = -4.0;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
    if(vp1->vnext[(signed long int)i] >= 1)
    {
      temp=get_angle(&vp1->pt, &vert[(signed long int)vp1->vnext[(signed long int)i]].pt, &vp0->pt);
      if(temp > angle)
      {
        angle = temp;
        tq = i;
      }

    }

  *iq = tq;
  return 0;
}

// get_vertex_positions$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 119
static signed int get_vertex_positions$link1(signed int v0$link1, signed int v1$link1, signed int *ip$link1, signed int *iq$link1)
{
  struct anonymous$2 *vp0$link1;
  struct anonymous$2 *vp1$link1;
  signed int i$link1;
  double angle$link1;
  double temp$link1;
  signed int tp$link1;
  signed int tq$link1 = 0;
  tp$link1 = tq$link1;
  vp0$link1 = &vert$link1[(signed long int)v0$link1];
  vp1$link1 = &vert$link1[(signed long int)v1$link1];
  angle$link1 = -4.0;
  i$link1 = 0;
  for( ; !(i$link1 >= 4); i$link1 = i$link1 + 1)
    if(vp0$link1->vnext[(signed long int)i$link1] >= 1)
    {
      temp$link1=get_angle$link1(&vp0$link1->pt, &vert$link1[(signed long int)vp0$link1->vnext[(signed long int)i$link1]].pt, &vp1$link1->pt);
      if(temp$link1 > angle$link1)
      {
        angle$link1 = temp$link1;
        tp$link1 = i$link1;
      }

    }

  *ip$link1 = tp$link1;
  angle$link1 = -4.0;
  i$link1 = 0;
  for( ; !(i$link1 >= 4); i$link1 = i$link1 + 1)
    if(vp1$link1->vnext[(signed long int)i$link1] >= 1)
    {
      temp$link1=get_angle$link1(&vp1$link1->pt, &vert$link1[(signed long int)vp1$link1->vnext[(signed long int)i$link1]].pt, &vp0$link1->pt);
      if(temp$link1 > angle$link1)
      {
        angle$link1 = temp$link1;
        tq$link1 = i$link1;
      }

    }

  *iq$link1 = tq$link1;
  return 0;
}

// get_wlan_client
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/client.c line 32
struct wlan_client * get_wlan_client(char *mac)
{
  struct list_head *client_pos;
  struct wlan_client *wlan_client;
  client_pos = (&Client_list)->next;
  for( ; !(client_pos == &Client_list); client_pos = client_pos->next)
  {
    wlan_client = (struct wlan_client *)((char *)client_pos - (signed long int)(unsigned long int)&((struct wlan_client *)0)->list);
    signed int return_value_strncmp$1;
    return_value_strncmp$1=strncmp(wlan_client->mac, mac, (unsigned long int)18);
    if(return_value_strncmp$1 == 0)
      return wlan_client;

  }
  void *return_value_alloc_memory$2;
  return_value_alloc_memory$2=alloc_memory((signed int)sizeof(struct wlan_client) /*128ul*/ );
  wlan_client = (struct wlan_client *)return_value_alloc_memory$2;
  do
  {
    (&wlan_client->list)->next = &wlan_client->list;
    (&wlan_client->list)->prev = &wlan_client->list;
  }
  while((_Bool)0);
  strncpy(wlan_client->mac, mac, (unsigned long int)18);
  wlan_client->wlan_network = (struct wlan_network *)(void *)0;
  wlan_client->props_changed = 1;
  wlan_client->visible = 1;
  signed int return_value_rand$3;
  return_value_rand$3=rand();
  wlan_client->pos_vec[(signed long int)0] = (float)((double)(((float)2.0 * (float)return_value_rand$3) / (float)2147483647) - 1.0);
  signed int return_value_rand$4;
  return_value_rand$4=rand();
  wlan_client->pos_vec[(signed long int)1] = (float)((double)(((float)2.0 * (float)return_value_rand$4) / (float)2147483647) - 1.0);
  signed int return_value_rand$5;
  return_value_rand$5=rand();
  wlan_client->pos_vec[(signed long int)2] = (float)((double)(((float)2.0 * (float)return_value_rand$5) / (float)2147483647) - 1.0);
  wlan_client->mov_vec[(signed long int)2] = (float)0.0;
  wlan_client->mov_vec[(signed long int)1] = wlan_client->mov_vec[(signed long int)2];
  wlan_client->mov_vec[(signed long int)0] = wlan_client->mov_vec[(signed long int)1];
  wlan_client->obj_id = -1;
  wlan_client->ip_id = -1;
  list_add_tail(&wlan_client->list, &Client_list);
  return wlan_client;
}

// get_wlan_network
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/network.c line 32
struct wlan_network * get_wlan_network(char *bssid)
{
  struct wlan_network *wlan_network;
  wlan_network=find_wlan_network(bssid);
  if(!(wlan_network == ((struct wlan_network *)NULL)))
    return wlan_network;

  else
  {
    void *return_value_alloc_memory$1;
    return_value_alloc_memory$1=alloc_memory((signed int)sizeof(struct wlan_network) /*120ul*/ );
    wlan_network = (struct wlan_network *)return_value_alloc_memory$1;
    do
    {
      (&wlan_network->list)->next = &wlan_network->list;
      (&wlan_network->list)->prev = &wlan_network->list;
    }
    while((_Bool)0);
    strncpy(wlan_network->bssid, bssid, (unsigned long int)18);
    wlan_network->type = -1;
    wlan_network->chan = -1;
    wlan_network->ssid = (char *)(void *)0;
    wlan_network->num_wlan_clients = 0;
    wlan_network->visible = 1;
    wlan_network->pos_vec[(signed long int)2] = (float)0;
    wlan_network->pos_vec[(signed long int)1] = wlan_network->pos_vec[(signed long int)2];
    wlan_network->pos_vec[(signed long int)0] = wlan_network->pos_vec[(signed long int)1];
    wlan_network->obj_id = -1;
    wlan_network->bssid_id = -1;
    wlan_network->ssid_id = -1;
    wlan_network->misc_id = -1;
    wlan_network->rotation = 0;
    wlan_network->scale_fac = 0;
    wlan_network->props_changed = 1;
    list_add_tail(&wlan_network->list, &Network_list);
    Num_networks = Num_networks + 1;
    return wlan_network;
  }
}

// gui_main
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 426
void * gui_main(void *unused)
{
  signed int return_value_s3d_init$2;
  return_value_s3d_init$2=s3d_init((signed int *)(void *)0, (char ***)(void *)0, "kism3d");
  if(return_value_s3d_init$2 == 0)
  {
    signed int return_value_s3d_select_font$1;
    return_value_s3d_select_font$1=s3d_select_font("vera");
    if(!(return_value_s3d_select_font$1 == 0))
      printf("font 'vera' not found\n");

    else
    {
      s3d_set_callback((unsigned char)17, object_info);
      s3d_set_callback((unsigned char)1, object_click);
      Client_obj=s3d_import_model_file("objs/accesspoint.3ds");
      s3d_mainloop(mainloop);
    }
    s3d_quit();
  }

  Kism3d_aborted = 1;
  return (void *)0;
}

// handle_clients
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 249
static signed int handle_clients(void)
{
  struct list_head *client_pos;
  struct wlan_client *wlan_client;
  float angle;
  float angle_rad;
  pthread_mutex_lock(&Client_list_mutex);
  client_pos = (&Client_list)->next;
  for( ; !(client_pos == &Client_list); client_pos = client_pos->next)
  {
    wlan_client = (struct wlan_client *)((char *)client_pos - (signed long int)(unsigned long int)&((struct wlan_client *)0)->list);
    if(!(wlan_client->visible == 0))
    {
      if(wlan_client->obj_id == -1)
      {
        wlan_client->obj_id=s3d_new_object();
        wlan_client->symbol_id=s3d_clone(Client_obj);
        s3d_link(wlan_client->symbol_id, wlan_client->obj_id);
        s3d_flags_on(wlan_client->symbol_id, (unsigned int)0x00000001);
      }

      if(!(wlan_client->props_changed == 0))
      {
        wlan_client->props_changed = 0;
        if(!(wlan_client->ip_id == -1))
          s3d_del_object(wlan_client->ip_id);

        wlan_client->ip_id=s3d_draw_string(wlan_client->ip, &wlan_client->ip_len);
        s3d_link(wlan_client->ip_id, wlan_client->obj_id);
        s3d_translate(wlan_client->ip_id, -wlan_client->ip_len / (float)2, (float)2, (float)0);
        s3d_scale(wlan_client->ip_id, (float)0.2);
        s3d_flags_on(wlan_client->ip_id, (unsigned int)0x00000001);
      }

      angle=s3d_angle_to_cam(wlan_client->pos_vec, CamPosition[(signed long int)0], &angle_rad);
      s3d_rotate(wlan_client->ip_id, (float)0, angle, (float)0);
      double return_value_cos$1;
      return_value_cos$1=cos((double)angle_rad);
      double return_value_sin$2;
      return_value_sin$2=sin((double)angle_rad);
      s3d_translate(wlan_client->ip_id, (float)((-return_value_cos$1 * 0.2 * (double)wlan_client->ip_len) / (double)2), (float)2, (float)((return_value_sin$2 * 0.2 * (double)wlan_client->ip_len) / (double)2));
    }

  }
  pthread_mutex_unlock(&Client_list_mutex);
  return 0;
}

// handle_networks
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 121
static signed int handle_networks(void)
{
  struct list_head *network_pos;
  struct wlan_network *wlan_network;
  float real_node_pos_x;
  float real_node_pos_z;
  float angle;
  float angle_rad;
  signed int network_index = 0;
  char label_str[101l];
  float maxlen;
  float templen;
  pthread_mutex_lock(&Network_list_mutex);
  network_pos = (&Network_list)->next;
  _Bool tmp_if_expr$7;
  double return_value_fabs$6;
  char *tmp_if_expr$9;
  char *tmp_if_expr$8;
  for( ; !(network_pos == &Network_list); network_pos = network_pos->next)
  {
    wlan_network = (struct wlan_network *)((char *)network_pos - (signed long int)(unsigned long int)&((struct wlan_network *)0)->list);
    if(!(wlan_network->visible == 0))
    {
      network_index = network_index + 1;
      if(wlan_network->obj_id == -1)
      {
        wlan_network->obj_id=s3d_new_object();
        wlan_network->wrsphr_id=wire_sphere(30, 30);
        s3d_link(wlan_network->wrsphr_id, wlan_network->obj_id);
        s3d_flags_on(wlan_network->wrsphr_id, (unsigned int)0x00000001);
      }

      wlan_network->scale_fac = wlan_network->num_wlan_clients + 2;
      s3d_translate(wlan_network->wrsphr_id, (float)0, (float)0, (float)0);
      s3d_scale(wlan_network->obj_id, (float)wlan_network->scale_fac);
      double return_value_sin$1;
      return_value_sin$1=sin((2.0 * 3.14159265358979323846 * (double)network_index) / (double)(float)Num_networks);
      real_node_pos_x = (float)(return_value_sin$1 * (double)((1 * Num_networks) / 2) * 3.14159265358979323846);
      double return_value_cos$2;
      return_value_cos$2=cos((2.0 * 3.14159265358979323846 * (double)network_index) / (double)(float)Num_networks);
      real_node_pos_z = (float)(return_value_cos$2 * (double)((1 * Num_networks) / 2) * 3.14159265358979323846);
      double return_value_fabs$5;
      return_value_fabs$5=fabs((double)(wlan_network->pos_vec[(signed long int)0] - real_node_pos_x));
      if(return_value_fabs$5 > 0.5)
        tmp_if_expr$7 = (_Bool)1;

      else
      {
        return_value_fabs$6=fabs((double)(wlan_network->pos_vec[(signed long int)2] - real_node_pos_z));
        tmp_if_expr$7 = return_value_fabs$6 > 0.5 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$7)
      {
        double return_value_fabs$3;
        return_value_fabs$3=fabs((double)(wlan_network->pos_vec[(signed long int)0] - real_node_pos_x));
        if(return_value_fabs$3 > 0.5)
          wlan_network->pos_vec[(signed long int)0] = (wlan_network->pos_vec[(signed long int)0] * (float)9 + real_node_pos_x) / (float)10;

        double return_value_fabs$4;
        return_value_fabs$4=fabs((double)(wlan_network->pos_vec[(signed long int)2] - real_node_pos_z));
        if(return_value_fabs$4 > 0.5)
          wlan_network->pos_vec[(signed long int)2] = (wlan_network->pos_vec[(signed long int)2] * (float)9 + real_node_pos_z) / (float)10;

        s3d_translate(wlan_network->obj_id, wlan_network->pos_vec[(signed long int)0], wlan_network->pos_vec[(signed long int)1], wlan_network->pos_vec[(signed long int)2]);
      }

      if(!(wlan_network->props_changed == 0))
      {
        if(wlan_network->type == 0)
          tmp_if_expr$9 = "Managed";

        else
        {
          if(wlan_network->type == 1)
            tmp_if_expr$8 = "Ad-Hoc";

          else
            tmp_if_expr$8 = wlan_network->type == 2 ? "Prober" : "unknown";
          tmp_if_expr$9 = tmp_if_expr$8;
        }
        snprintf(label_str, (unsigned long int)100, "Type: %s, CH: %i, Clients: %i", tmp_if_expr$9, wlan_network->chan, wlan_network->num_wlan_clients);
        maxlen=s3d_strlen(label_str);
        templen=s3d_strlen(wlan_network->ssid);
        if(templen > maxlen)
          maxlen = templen;

        templen=s3d_strlen(wlan_network->bssid);
        if(templen > maxlen)
          maxlen = templen;

        wlan_network->props_changed = 0;
        if(!(wlan_network->ssid_id == -1))
          s3d_del_object(wlan_network->ssid_id);

        if(!(wlan_network->misc_id == -1))
          s3d_del_object(wlan_network->misc_id);

        if(wlan_network->bssid_id == -1)
        {
          wlan_network->bssid_id=s3d_draw_string(wlan_network->bssid, (float *)(void *)0);
          wlan_network->text_width = maxlen;
          s3d_link(wlan_network->bssid_id, wlan_network->obj_id);
          s3d_translate(wlan_network->bssid_id, -maxlen / (float)2, (float)(2 + wlan_network->scale_fac), (float)0);
          s3d_scale(wlan_network->bssid_id, (float)0.2);
          s3d_flags_on(wlan_network->bssid_id, (unsigned int)0x00000001);
          wlan_network->click_id=s3d_new_object();
          s3d_link(wlan_network->click_id, wlan_network->bssid_id);
          s3d_push_material(wlan_network->click_id, (float)0, (float)0, (float)0, (float)0, (float)0, (float)0, (float)0, (float)0, (float)0);
          s3d_push_vertex(wlan_network->click_id, (float)0, (float)1, (float)0.1);
          s3d_push_vertex(wlan_network->click_id, maxlen, (float)1, (float)0.1);
          s3d_push_vertex(wlan_network->click_id, maxlen, (float)-2.5, (float)0.1);
          s3d_push_vertex(wlan_network->click_id, (float)0, (float)-2.5, (float)0.1);
          s3d_push_polygon(wlan_network->click_id, (unsigned int)0, (unsigned int)1, (unsigned int)2, (unsigned int)0);
          s3d_push_polygon(wlan_network->click_id, (unsigned int)0, (unsigned int)2, (unsigned int)3, (unsigned int)0);
          s3d_flags_on(wlan_network->click_id, (unsigned int)0x00000002);
        }

        wlan_network->ssid_id=s3d_draw_string(wlan_network->ssid, (float *)(void *)0);
        s3d_link(wlan_network->ssid_id, wlan_network->bssid_id);
        s3d_translate(wlan_network->ssid_id, (float)0, (float)-1, (float)0);
        s3d_flags_on(wlan_network->ssid_id, (unsigned int)0x00000001);
        wlan_network->misc_id=s3d_draw_string(label_str, (float *)(void *)0);
        s3d_link(wlan_network->misc_id, wlan_network->ssid_id);
        s3d_translate(wlan_network->misc_id, (float)0, (float)-1, (float)0);
        s3d_flags_on(wlan_network->misc_id, (unsigned int)0x00000001);
      }

      angle=s3d_angle_to_cam(wlan_network->pos_vec, CamPosition[(signed long int)0], &angle_rad);
      s3d_rotate(wlan_network->bssid_id, (float)0, angle, (float)0);
      double return_value_cos$10;
      return_value_cos$10=cos((double)angle_rad);
      double return_value_sin$11;
      return_value_sin$11=sin((double)angle_rad);
      s3d_translate(wlan_network->bssid_id, (float)((-return_value_cos$10 * 0.2 * (double)wlan_network->text_width) / (double)2), (float)2, (float)((return_value_sin$11 * 0.2 * (double)wlan_network->text_width) / (double)2));
      wlan_network->rotation = (wlan_network->rotation + 1) % 360;
      s3d_rotate(wlan_network->wrsphr_id, (float)0, (float)wlan_network->rotation, (float)0);
    }

  }
  pthread_mutex_unlock(&Network_list_mutex);
  return 0;
}

// htonfb
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/endian.c line 30
void htonfb(float *netfloat, signed int num)
{
  signed int i = 0;
  for( ; !(i >= num); i = i + 1)
    *((unsigned int *)&netfloat[(signed long int)i])=htonl(*((unsigned int *)&netfloat[(signed long int)i]));
}

// htonlb
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/endian.c line 48
void htonlb(unsigned int *netint32, signed int num)
{
  signed int i = 0;
  for( ; !(i >= num); i = i + 1)
    netint32[(signed long int)i]=htonl(netint32[(signed long int)i]);
}

// htonsb
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/endian.c line 66
void htonsb(unsigned short int *netint16, signed int num)
{
  signed int i = 0;
  for( ; !(i >= num); i = i + 1)
    netint16[(signed long int)i]=htons(netint16[(signed long int)i]);
}

// init_query_structure
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 162
static signed int init_query_structure(signed int segnum)
{
  signed int i1;
  signed int i2;
  signed int i3;
  signed int i4;
  signed int i5;
  signed int i6;
  signed int i7;
  signed int init_query_structure$$1$$root;
  signed int t1;
  signed int t2;
  signed int t3;
  signed int t4;
  struct anonymous$14 *s = &seg[(signed long int)segnum];
  tr_idx = 1;
  q_idx = tr_idx;
  memset((void *)tr, 0, sizeof(struct anonymous$3 [800l]) /*57600ul*/ );
  memset((void *)qs, 0, sizeof(struct anonymous$15 [1600l]) /*64000ul*/ );
  i1=newnode();
  qs[(signed long int)i1].nodetype = 2;
  _max(&qs[(signed long int)i1].yval, &s->v0, &s->v1);
  init_query_structure$$1$$root = i1;
  i2=newnode();
  qs[(signed long int)i1].right = i2;
  qs[(signed long int)i2].nodetype = 3;
  qs[(signed long int)i2].parent = i1;
  i3=newnode();
  qs[(signed long int)i1].left = i3;
  qs[(signed long int)i3].nodetype = 2;
  _min(&qs[(signed long int)i3].yval, &s->v0, &s->v1);
  qs[(signed long int)i3].parent = i1;
  i4=newnode();
  qs[(signed long int)i3].left = i4;
  qs[(signed long int)i4].nodetype = 3;
  qs[(signed long int)i4].parent = i3;
  i5=newnode();
  qs[(signed long int)i3].right = i5;
  qs[(signed long int)i5].nodetype = 1;
  qs[(signed long int)i5].segnum = segnum;
  qs[(signed long int)i5].parent = i3;
  i6=newnode();
  qs[(signed long int)i5].left = i6;
  qs[(signed long int)i6].nodetype = 3;
  qs[(signed long int)i6].parent = i5;
  i7=newnode();
  qs[(signed long int)i5].right = i7;
  qs[(signed long int)i7].nodetype = 3;
  qs[(signed long int)i7].parent = i5;
  t1=newtrap();
  t2=newtrap();
  t3=newtrap();
  t4=newtrap();
  tr[(signed long int)t4].lo = qs[(signed long int)i1].yval;
  tr[(signed long int)t2].hi = tr[(signed long int)t4].lo;
  tr[(signed long int)t1].hi = tr[(signed long int)t2].hi;
  tr[(signed long int)t3].hi = qs[(signed long int)i3].yval;
  tr[(signed long int)t2].lo = tr[(signed long int)t3].hi;
  tr[(signed long int)t1].lo = tr[(signed long int)t2].lo;
  tr[(signed long int)t4].hi.y=__builtin_huge_val();
  tr[(signed long int)t4].hi.x=__builtin_huge_val();
  double return_value___builtin_huge_val$1;
  return_value___builtin_huge_val$1=__builtin_huge_val();
  tr[(signed long int)t3].lo.y = -return_value___builtin_huge_val$1;
  double return_value___builtin_huge_val$2;
  return_value___builtin_huge_val$2=__builtin_huge_val();
  tr[(signed long int)t3].lo.x = -return_value___builtin_huge_val$2;
  tr[(signed long int)t2].lseg = segnum;
  tr[(signed long int)t1].rseg = tr[(signed long int)t2].lseg;
  tr[(signed long int)t2].u0 = t4;
  tr[(signed long int)t1].u0 = tr[(signed long int)t2].u0;
  tr[(signed long int)t2].d0 = t3;
  tr[(signed long int)t1].d0 = tr[(signed long int)t2].d0;
  tr[(signed long int)t3].u0 = t1;
  tr[(signed long int)t4].d0 = tr[(signed long int)t3].u0;
  tr[(signed long int)t3].u1 = t2;
  tr[(signed long int)t4].d1 = tr[(signed long int)t3].u1;
  tr[(signed long int)t1].sink = i6;
  tr[(signed long int)t2].sink = i7;
  tr[(signed long int)t3].sink = i4;
  tr[(signed long int)t4].sink = i2;
  tr[(signed long int)t2].state = 1;
  tr[(signed long int)t1].state = tr[(signed long int)t2].state;
  tr[(signed long int)t4].state = 1;
  tr[(signed long int)t3].state = tr[(signed long int)t4].state;
  qs[(signed long int)i2].trnum = t4;
  qs[(signed long int)i4].trnum = t3;
  qs[(signed long int)i6].trnum = t1;
  qs[(signed long int)i7].trnum = t2;
  s->is_inserted = 1;
  return init_query_structure$$1$$root;
}

// init_query_structure$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 162
static signed int init_query_structure$link1(signed int segnum$link1)
{
  signed int i1$link1;
  signed int i2$link1;
  signed int i3$link1;
  signed int i4$link1;
  signed int i5$link1;
  signed int i6$link1;
  signed int i7$link1;
  signed int root$link1;
  signed int t1$link1;
  signed int t2$link1;
  signed int t3$link1;
  signed int t4$link1;
  struct anonymous$14 *s$link1 = &seg[(signed long int)segnum$link1];
  tr_idx$link1 = 1;
  q_idx$link1 = tr_idx$link1;
  memset((void *)tr, 0, sizeof(struct anonymous$3 [800l]) /*57600ul*/ );
  memset((void *)qs, 0, sizeof(struct anonymous$15 [1600l]) /*64000ul*/ );
  i1$link1=newnode$link1();
  qs[(signed long int)i1$link1].nodetype = 2;
  _max$link1(&qs[(signed long int)i1$link1].yval, &s$link1->v0, &s$link1->v1);
  root$link1 = i1$link1;
  i2$link1=newnode$link1();
  qs[(signed long int)i1$link1].right = i2$link1;
  qs[(signed long int)i2$link1].nodetype = 3;
  qs[(signed long int)i2$link1].parent = i1$link1;
  i3$link1=newnode$link1();
  qs[(signed long int)i1$link1].left = i3$link1;
  qs[(signed long int)i3$link1].nodetype = 2;
  _min$link1(&qs[(signed long int)i3$link1].yval, &s$link1->v0, &s$link1->v1);
  qs[(signed long int)i3$link1].parent = i1$link1;
  i4$link1=newnode$link1();
  qs[(signed long int)i3$link1].left = i4$link1;
  qs[(signed long int)i4$link1].nodetype = 3;
  qs[(signed long int)i4$link1].parent = i3$link1;
  i5$link1=newnode$link1();
  qs[(signed long int)i3$link1].right = i5$link1;
  qs[(signed long int)i5$link1].nodetype = 1;
  qs[(signed long int)i5$link1].segnum = segnum$link1;
  qs[(signed long int)i5$link1].parent = i3$link1;
  i6$link1=newnode$link1();
  qs[(signed long int)i5$link1].left = i6$link1;
  qs[(signed long int)i6$link1].nodetype = 3;
  qs[(signed long int)i6$link1].parent = i5$link1;
  i7$link1=newnode$link1();
  qs[(signed long int)i5$link1].right = i7$link1;
  qs[(signed long int)i7$link1].nodetype = 3;
  qs[(signed long int)i7$link1].parent = i5$link1;
  t1$link1=newtrap$link1();
  t2$link1=newtrap$link1();
  t3$link1=newtrap$link1();
  t4$link1=newtrap$link1();
  tr[(signed long int)t4$link1].lo = qs[(signed long int)i1$link1].yval;
  tr[(signed long int)t2$link1].hi = tr[(signed long int)t4$link1].lo;
  tr[(signed long int)t1$link1].hi = tr[(signed long int)t2$link1].hi;
  tr[(signed long int)t3$link1].hi = qs[(signed long int)i3$link1].yval;
  tr[(signed long int)t2$link1].lo = tr[(signed long int)t3$link1].hi;
  tr[(signed long int)t1$link1].lo = tr[(signed long int)t2$link1].lo;
  tr[(signed long int)t4$link1].hi.y=__builtin_huge_val();
  tr[(signed long int)t4$link1].hi.x=__builtin_huge_val();
  double return_value___builtin_huge_val$1$link1;
  return_value___builtin_huge_val$1$link1=__builtin_huge_val();
  tr[(signed long int)t3$link1].lo.y = -return_value___builtin_huge_val$1$link1;
  double return_value___builtin_huge_val$2$link1;
  return_value___builtin_huge_val$2$link1=__builtin_huge_val();
  tr[(signed long int)t3$link1].lo.x = -return_value___builtin_huge_val$2$link1;
  tr[(signed long int)t2$link1].lseg = segnum$link1;
  tr[(signed long int)t1$link1].rseg = tr[(signed long int)t2$link1].lseg;
  tr[(signed long int)t2$link1].u0 = t4$link1;
  tr[(signed long int)t1$link1].u0 = tr[(signed long int)t2$link1].u0;
  tr[(signed long int)t2$link1].d0 = t3$link1;
  tr[(signed long int)t1$link1].d0 = tr[(signed long int)t2$link1].d0;
  tr[(signed long int)t3$link1].u0 = t1$link1;
  tr[(signed long int)t4$link1].d0 = tr[(signed long int)t3$link1].u0;
  tr[(signed long int)t3$link1].u1 = t2$link1;
  tr[(signed long int)t4$link1].d1 = tr[(signed long int)t3$link1].u1;
  tr[(signed long int)t1$link1].sink = i6$link1;
  tr[(signed long int)t2$link1].sink = i7$link1;
  tr[(signed long int)t3$link1].sink = i4$link1;
  tr[(signed long int)t4$link1].sink = i2$link1;
  tr[(signed long int)t2$link1].state = 1;
  tr[(signed long int)t1$link1].state = tr[(signed long int)t2$link1].state;
  tr[(signed long int)t4$link1].state = 1;
  tr[(signed long int)t3$link1].state = tr[(signed long int)t4$link1].state;
  qs[(signed long int)i2$link1].trnum = t4$link1;
  qs[(signed long int)i4$link1].trnum = t3$link1;
  qs[(signed long int)i6$link1].trnum = t1$link1;
  qs[(signed long int)i7$link1].trnum = t2$link1;
  s$link1->is_inserted = 1;
  return root$link1;
}

// initialise
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_tri.c line 45
static signed int initialise(signed int n)
{
  signed int i = 1;
  for( ; n >= i; i = i + 1)
    seg[(signed long int)i].is_inserted = 0;
  generate_random_ordering(n);
  return 0;
}

// initialise$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_tri.c line 45
static signed int initialise$link1(signed int n$link1)
{
  signed int i$link1 = 1;
  for( ; n$link1 >= i$link1; i$link1 = i$link1 + 1)
    seg[(signed long int)i$link1].is_inserted = 0;
  generate_random_ordering(n$link1);
  return 0;
}

// inserted
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 288
static signed int inserted(signed int segnum, signed int whichpt)
{
  if(whichpt == 1)
    return seg[(signed long int)seg[(signed long int)segnum].prev].is_inserted;

  else
    return seg[(signed long int)seg[(signed long int)segnum].next].is_inserted;
}

// inserted$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 288
static signed int inserted$link1(signed int segnum$link1, signed int whichpt$link1)
{
  if(whichpt$link1 == 1)
    return seg[(signed long int)seg[(signed long int)segnum$link1].prev].is_inserted;

  else
    return seg[(signed long int)seg[(signed long int)segnum$link1].next].is_inserted;
}

// inside_polygon
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 68
static signed int inside_polygon(struct anonymous$3 *t)
{
  signed int rseg = t->rseg;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  signed int return_value__greater_than$2;
  if(t->state == 2)
    return 0;

  else
  {
    if(!(t->lseg >= 1))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = t->rseg <= 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      return 0;

    else
    {
      if(!(t->u0 >= 1))
        tmp_if_expr$3 = t->u1 <= 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        if(!(t->d0 >= 1))
          tmp_if_expr$4 = t->d1 <= 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
      {
        return_value__greater_than$2=_greater_than(&seg[(signed long int)rseg].v1, &seg[(signed long int)rseg].v0);
        return return_value__greater_than$2;
      }

      else
        return 0;
    }
  }
}

// inside_polygon$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 68
static signed int inside_polygon$link1(struct anonymous$3 *t$link1)
{
  signed int rseg$link1 = t$link1->rseg;
  _Bool tmp_if_expr$1$link1;
  _Bool tmp_if_expr$3$link1;
  _Bool tmp_if_expr$5$link1;
  _Bool tmp_if_expr$4$link1;
  signed int return_value__greater_than$2$link1;
  if(t$link1->state == 2)
    return 0;

  else
  {
    if(!(t$link1->lseg >= 1))
      tmp_if_expr$1$link1 = (_Bool)1;

    else
      tmp_if_expr$1$link1 = t$link1->rseg <= 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1$link1)
      return 0;

    else
    {
      if(!(t$link1->u0 >= 1))
        tmp_if_expr$3$link1 = t$link1->u1 <= 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3$link1 = (_Bool)0;
      if(tmp_if_expr$3$link1)
        tmp_if_expr$5$link1 = (_Bool)1;

      else
      {
        if(!(t$link1->d0 >= 1))
          tmp_if_expr$4$link1 = t$link1->d1 <= 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4$link1 = (_Bool)0;
        tmp_if_expr$5$link1 = tmp_if_expr$4$link1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5$link1)
      {
        return_value__greater_than$2$link1=_greater_than(&seg[(signed long int)rseg$link1].v1, &seg[(signed long int)rseg$link1].v0);
        return return_value__greater_than$2$link1;
      }

      else
        return 0;
    }
  }
}

// is_left_of
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 243
static signed int is_left_of(signed int segnum, struct anonymous$1 *v)
{
  struct anonymous$14 *s = &seg[(signed long int)segnum];
  double area;
  signed int return_value__greater_than$5;
  return_value__greater_than$5=_greater_than(&s->v1, &s->v0);
  double return_value_fabs$1;
  double return_value_fabs$3;
  if(!(return_value__greater_than$5 == 0))
  {
    double return_value_fabs$2;
    return_value_fabs$2=fabs(s->v1.y - v->y);
    if(return_value_fabs$2 <= 1.0e-7)
    {
      if(v->x < s->v1.x)
        area = 1.0;

      else
        area = -1.0;
    }

    else
    {
      return_value_fabs$1=fabs(s->v0.y - v->y);
      if(return_value_fabs$1 <= 1.0e-7)
      {
        if(v->x < s->v0.x)
          area = 1.0;

        else
          area = -1.0;
      }

      else
        area = (s->v1.x - s->v0.x) * (v->y - s->v0.y) - (s->v1.y - s->v0.y) * (v->x - s->v0.x);
    }
  }

  else
  {
    double return_value_fabs$4;
    return_value_fabs$4=fabs(s->v1.y - v->y);
    if(return_value_fabs$4 <= 1.0e-7)
    {
      if(v->x < s->v1.x)
        area = 1.0;

      else
        area = -1.0;
    }

    else
    {
      return_value_fabs$3=fabs(s->v0.y - v->y);
      if(return_value_fabs$3 <= 1.0e-7)
      {
        if(v->x < s->v0.x)
          area = 1.0;

        else
          area = -1.0;
      }

      else
        area = (s->v0.x - s->v1.x) * (v->y - s->v1.y) - (s->v0.y - s->v1.y) * (v->x - s->v1.x);
    }
  }
  if(area > 0.0)
    return 1;

  else
    return 0;
}

// is_left_of$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 243
static signed int is_left_of$link1(signed int segnum$link1, struct anonymous$1 *v$link1)
{
  struct anonymous$14 *s$link1 = &seg[(signed long int)segnum$link1];
  double area$link1;
  signed int return_value__greater_than$5$link1;
  return_value__greater_than$5$link1=_greater_than(&s$link1->v1, &s$link1->v0);
  double return_value_fabs$1$link1;
  double return_value_fabs$3$link1;
  if(!(return_value__greater_than$5$link1 == 0))
  {
    double return_value_fabs$2$link1;
    return_value_fabs$2$link1=fabs(s$link1->v1.y - v$link1->y);
    if(return_value_fabs$2$link1 <= 1.0e-7)
    {
      if(v$link1->x < s$link1->v1.x)
        area$link1 = 1.0;

      else
        area$link1 = -1.0;
    }

    else
    {
      return_value_fabs$1$link1=fabs(s$link1->v0.y - v$link1->y);
      if(return_value_fabs$1$link1 <= 1.0e-7)
      {
        if(v$link1->x < s$link1->v0.x)
          area$link1 = 1.0;

        else
          area$link1 = -1.0;
      }

      else
        area$link1 = (s$link1->v1.x - s$link1->v0.x) * (v$link1->y - s$link1->v0.y) - (s$link1->v1.y - s$link1->v0.y) * (v$link1->x - s$link1->v0.x);
    }
  }

  else
  {
    double return_value_fabs$4$link1;
    return_value_fabs$4$link1=fabs(s$link1->v1.y - v$link1->y);
    if(return_value_fabs$4$link1 <= 1.0e-7)
    {
      if(v$link1->x < s$link1->v1.x)
        area$link1 = 1.0;

      else
        area$link1 = -1.0;
    }

    else
    {
      return_value_fabs$3$link1=fabs(s$link1->v0.y - v$link1->y);
      if(return_value_fabs$3$link1 <= 1.0e-7)
      {
        if(v$link1->x < s$link1->v0.x)
          area$link1 = 1.0;

        else
          area$link1 = -1.0;
      }

      else
        area$link1 = (s$link1->v0.x - s$link1->v1.x) * (v$link1->y - s$link1->v1.y) - (s$link1->v0.y - s$link1->v1.y) * (v$link1->x - s$link1->v1.x);
    }
  }
  if(area$link1 > 0.0)
    return 1;

  else
    return 0;
}

// list_add_tail
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/list.h line 101
static inline void list_add_tail(struct list_head *n, struct list_head *head)
{
  __list_add(n, head->prev, head);
}

// list_del
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/list.h line 128
static inline void list_del(struct list_head *entry)
{
  __list_del(entry->prev, entry->next);
  entry->next = (struct list_head *)(void *)0;
  entry->prev = (struct list_head *)(void *)0;
}

// locate_endpoint
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 300
extern signed int locate_endpoint(struct anonymous$1 *v, struct anonymous$1 *vo, signed int r)
{
  struct anonymous$15 *rptr = &qs[(signed long int)r];
  signed int return_value__greater_than$7;
  signed int return_value_locate_endpoint$1;
  signed int return_value__equal_to$6;
  signed int return_value_locate_endpoint$2;
  signed int return_value_locate_endpoint$3;
  signed int return_value_locate_endpoint$5;
  signed int return_value__equal_to$17;
  _Bool tmp_if_expr$19;
  signed int return_value__equal_to$18;
  signed int return_value_locate_endpoint$8;
  signed int return_value_locate_endpoint$9;
  signed int return_value_is_left_of$12;
  signed int return_value_locate_endpoint$10;
  signed int return_value_locate_endpoint$11;
  signed int return_value_is_left_of$16;
  signed int return_value_locate_endpoint$14;
  signed int return_value_locate_endpoint$15;
  switch(rptr->nodetype)
  {
    case 3:
      return rptr->trnum;
    case 2:
    {
      return_value__greater_than$7=_greater_than(v, &rptr->yval);
      if(!(return_value__greater_than$7 == 0))
      {
        return_value_locate_endpoint$1=locate_endpoint(v, vo, rptr->right);
        return return_value_locate_endpoint$1;
      }

      else
      {
        return_value__equal_to$6=_equal_to(v, &rptr->yval);
        if(!(return_value__equal_to$6 == 0))
        {
          signed int return_value__greater_than$4;
          return_value__greater_than$4=_greater_than(vo, &rptr->yval);
          if(!(return_value__greater_than$4 == 0))
          {
            return_value_locate_endpoint$2=locate_endpoint(v, vo, rptr->right);
            return return_value_locate_endpoint$2;
          }

          else
          {
            return_value_locate_endpoint$3=locate_endpoint(v, vo, rptr->left);
            return return_value_locate_endpoint$3;
          }
        }

        else
        {
          return_value_locate_endpoint$5=locate_endpoint(v, vo, rptr->left);
          return return_value_locate_endpoint$5;
        }
      }
    }
    case 1:
    {
      return_value__equal_to$17=_equal_to(v, &seg[(signed long int)rptr->segnum].v0);
      if(!(return_value__equal_to$17 == 0))
        tmp_if_expr$19 = (_Bool)1;

      else
      {
        return_value__equal_to$18=_equal_to(v, &seg[(signed long int)rptr->segnum].v1);
        tmp_if_expr$19 = return_value__equal_to$18 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$19)
      {
        double return_value_fabs$13;
        return_value_fabs$13=fabs(v->y - vo->y);
        if(return_value_fabs$13 <= 1.0e-7)
        {
          if(vo->x < v->x)
          {
            return_value_locate_endpoint$8=locate_endpoint(v, vo, rptr->left);
            return return_value_locate_endpoint$8;
          }

          else
          {
            return_value_locate_endpoint$9=locate_endpoint(v, vo, rptr->right);
            return return_value_locate_endpoint$9;
          }
        }

        else
        {
          return_value_is_left_of$12=is_left_of(rptr->segnum, vo);
          if(!(return_value_is_left_of$12 == 0))
          {
            return_value_locate_endpoint$10=locate_endpoint(v, vo, rptr->left);
            return return_value_locate_endpoint$10;
          }

          else
          {
            return_value_locate_endpoint$11=locate_endpoint(v, vo, rptr->right);
            return return_value_locate_endpoint$11;
          }
        }
      }

      else
      {
        return_value_is_left_of$16=is_left_of(rptr->segnum, v);
        if(!(return_value_is_left_of$16 == 0))
        {
          return_value_locate_endpoint$14=locate_endpoint(v, vo, rptr->left);
          return return_value_locate_endpoint$14;
        }

        else
        {
          return_value_locate_endpoint$15=locate_endpoint(v, vo, rptr->right);
          return return_value_locate_endpoint$15;
        }
      }
    }
    default:
    {
      errs("sei:locate_endpoint()", "Haggu!!!! (whatever)");
      return -1;
    }
  }
}

// main
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 347
signed int main(signed int argc, char **argv)
{
  struct in_addr tmp_ip_holder;
  struct kismet_src *kismet_src;
  struct list_head *kismet_pos;
  struct list_head *kismet_pos_tmp;
  struct timeval tv;
  signed int num_kismet_sources = 0;
  signed int found_args = 1;
  signed int max_sock = -1;
  signed int res;
  signed int status;
  char *colon_ptr;
  char buff[1000l];
  struct anonymous$13 wait_sockets;
  struct anonymous$13 tmp_wait_sockets;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$13) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wait_sockets)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  _Bool tmp_if_expr$4;
  while(!(found_args >= argc))
  {
    void *return_value_alloc_memory$1;
    return_value_alloc_memory$1=alloc_memory((signed int)sizeof(struct kismet_src) /*72ul*/ );
    kismet_src = (struct kismet_src *)return_value_alloc_memory$1;
    do
    {
      (&kismet_src->list)->next = &kismet_src->list;
      (&kismet_src->list)->prev = &kismet_src->list;
    }
    while((_Bool)0);
    kismet_src->enable_level = 0;
    colon_ptr=strchr(argv[(signed long int)found_args], 58);
    if(!(colon_ptr == ((char *)NULL)))
    {
      *colon_ptr = (char)0;
      colon_ptr = colon_ptr + 1l;
    }

    signed int return_value_inet_pton$2;
    return_value_inet_pton$2=inet_pton(2, argv[(signed long int)found_args], (void *)&tmp_ip_holder);
    if(!(return_value_inet_pton$2 >= 1))
    {
      printf("Invalid kismet IP specified: %s\n", argv[(signed long int)found_args]);
      free((void *)kismet_src);
      found_args = found_args + 1;
      continue;
    }

    else
      kismet_src->ip = tmp_ip_holder.s_addr;
    if(!(colon_ptr == ((char *)NULL)))
    {
      signed long int return_value_strtol$3;
      return_value_strtol$3=strtol(colon_ptr, (char ** restrict )(void *)0, 10);
      kismet_src->port = (signed int)return_value_strtol$3;
      if(!(kismet_src->port >= 1))
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = kismet_src->port > 65535 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
      {
        printf("Invalid kismet PORT specified: %s\n", colon_ptr);
        free((void *)kismet_src);
        found_args = found_args + 1;
        continue;
      }

    }

    else
      kismet_src->port = 2501;
    kismet_src->kismet_addr.sin_family = (unsigned short int)2;
    kismet_src->kismet_addr.sin_port=htons((unsigned short int)kismet_src->port);
    kismet_src->kismet_addr.sin_addr.s_addr = kismet_src->ip;
    void *return_value_alloc_memory$5;
    return_value_alloc_memory$5=alloc_memory(16);
    kismet_src->kismet_ip = (char *)return_value_alloc_memory$5;
    inet_ntop(2, (const void *)&kismet_src->ip, kismet_src->kismet_ip, (unsigned int)16);
    kismet_src->sock=socket(2, 1, 0);
    if(!(kismet_src->sock >= 0))
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      char *return_value_strerror$7;
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      printf("Error - can't create tcp socket (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, return_value_strerror$7);
      free((void *)kismet_src->kismet_ip);
      free((void *)kismet_src);
      found_args = found_args + 1;
      continue;
    }

    signed int return_value_connect$10;
    return_value_connect$10=connect(kismet_src->sock, (struct sockaddr *)&kismet_src->kismet_addr, (unsigned int)sizeof(struct sockaddr) /*16ul*/ );
    if(!(return_value_connect$10 >= 0))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      char *return_value_strerror$9;
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      printf("Error - can't connect to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, return_value_strerror$9);
      close(kismet_src->sock);
      free((void *)kismet_src->kismet_ip);
      free((void *)kismet_src);
      found_args = found_args + 1;
      continue;
    }

    void *return_value_alloc_memory$11;
    return_value_alloc_memory$11=alloc_memory(1500);
    kismet_src->recv_buff = (char *)return_value_alloc_memory$11;
    (&wait_sockets)->__fds_bits[(signed long int)(kismet_src->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wait_sockets)->__fds_bits[(signed long int)(kismet_src->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << kismet_src->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    if(!(max_sock >= kismet_src->sock))
      max_sock = kismet_src->sock;

    list_add_tail(&kismet_src->list, &kismet_src_list);
    num_kismet_sources = num_kismet_sources + 1;
    found_args = found_args + 1;
  }
  if(num_kismet_sources == 0)
  {
    printf("Exiting - can't find any valid kismet server\n");
    exit(1);
  }

  signed int *return_value___errno_location$21;
  while(Kism3d_aborted == 0 && num_kismet_sources >= 1)
  {
    tv.tv_sec = (signed long int)0;
    tv.tv_usec = (signed long int)250;
    tmp_wait_sockets = wait_sockets;
    res=select(max_sock + 1, &tmp_wait_sockets, (struct anonymous$13 *)(void *)0, (struct anonymous$13 *)(void *)0, &tv);
    if(res >= 1)
    {
      max_sock = -1;
      kismet_pos = (&kismet_src_list)->next;
      kismet_pos_tmp = kismet_pos->next;
      for( ; !(kismet_pos == &kismet_src_list); kismet_pos_tmp = kismet_pos->next)
      {
        kismet_src = (struct kismet_src *)((char *)kismet_pos - (signed long int)(unsigned long int)&((struct kismet_src *)0)->list);
        if(!((tmp_wait_sockets.__fds_bits[(signed long int)(kismet_src->sock / 8)] & (signed long int)(1UL << kismet_src->sock % 8)) == 0l))
        {
          signed long int return_value_read$12;
          return_value_read$12=read(kismet_src->sock, (void *)buff, sizeof(char [1000l]) /*1000ul*/ );
          status = (signed int)return_value_read$12;
          if(status >= 1)
          {
            if(!(max_sock >= kismet_src->sock))
              max_sock = kismet_src->sock;

            buff[(signed long int)status] = (char)0;
            unsigned long int return_value_strlen$15;
            return_value_strlen$15=strlen(kismet_src->recv_buff);
            unsigned long int return_value_strlen$16;
            return_value_strlen$16=strlen(buff);
            if(!(return_value_strlen$15 + return_value_strlen$16 >= 1500ul))
              strncat(kismet_src->recv_buff, buff, (unsigned long int)1000);

            else
            {
              unsigned long int return_value_strlen$14;
              return_value_strlen$14=strlen(kismet_src->recv_buff);
              if(!(return_value_strlen$14 >= 1500ul))
              {
                printf("WARNING: receive buffer almost filled without *any* carriage return within that data !\nAppending truncated buffer to receive buffer to prevent buffer overflow.\n");
                unsigned long int return_value_strlen$13;
                return_value_strlen$13=strlen(kismet_src->recv_buff);
                strncat(kismet_src->recv_buff, buff, (unsigned long int)1500 - return_value_strlen$13);
              }

              else
              {
                printf("ERROR: receive buffer filled without *any* carriage return within that data !\nClearing receive buffer to prevent buffer overflow.\n");
                strncpy(kismet_src->recv_buff, buff, (unsigned long int)1000);
              }
            }
            parse_buffer(kismet_src);
          }

          else
          {
            if(!(status >= 0))
            {
              signed int *return_value___errno_location$17;
              return_value___errno_location$17=__errno_location();
              char *return_value_strerror$18;
              return_value_strerror$18=strerror(*return_value___errno_location$17);
              printf("Error - can't read message from %s:%i: %s\n", kismet_src->kismet_ip, kismet_src->port, return_value_strerror$18);
            }

            else
              printf("Kismet server %s:%i closed connection ...\n", kismet_src->kismet_ip, kismet_src->port);
            (&wait_sockets)->__fds_bits[(signed long int)(kismet_src->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wait_sockets)->__fds_bits[(signed long int)(kismet_src->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << kismet_src->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
            close(kismet_src->sock);
            list_del(kismet_pos);
            free((void *)kismet_src->kismet_ip);
            free((void *)kismet_pos);
            num_kismet_sources = num_kismet_sources - 1;
          }
        }

        else
          if(!(max_sock >= kismet_src->sock))
            max_sock = kismet_src->sock;

        kismet_pos = kismet_pos_tmp;
      }
    }

    else
      if(!(res >= 0))
      {
        return_value___errno_location$21=__errno_location();
        if(!(*return_value___errno_location$21 == 4))
        {
          signed int *return_value___errno_location$19;
          return_value___errno_location$19=__errno_location();
          char *return_value_strerror$20;
          return_value_strerror$20=strerror(*return_value___errno_location$19);
          printf("Error - can't select: %s\n", return_value_strerror$20);
          break;
        }

      }

  }
  if(!(Kism3d_aborted == 0))
  {
    printf("Closing all sockets ... \n");
    kismet_pos = (&kismet_src_list)->next;
    for( ; !(kismet_pos == &kismet_src_list); kismet_pos = kismet_pos->next)
    {
      kismet_src = (struct kismet_src *)((char *)kismet_pos - (signed long int)(unsigned long int)&((struct kismet_src *)0)->list);
      close(kismet_src->sock);
    }
  }

  else
  {
    Kism3d_aborted = 1;
    pthread_join(s3d_thread_id, (void **)(void *)0);
  }
  return 0;
}

// mainloop
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 383
static void mainloop(void)
{
  float angle;
  float diff_vec[3l];
  float tmp_vec[3l] = { (float)0.0, (float)0.0, (float)-1.0 };
  handle_networks();
  handle_clients();
  double return_value_fabs$2;
  double return_value_fabs$1;
  if(!(Cam_target == NULL))
  {
    CamPosition[(signed long int)0][(signed long int)0] = (CamPosition[(signed long int)0][(signed long int)0] * (float)4 + ((struct wlan_network *)Cam_target)->pos_vec[(signed long int)0] + (float)10) / (float)5;
    CamPosition[(signed long int)0][(signed long int)1] = (CamPosition[(signed long int)0][(signed long int)1] * (float)4 + ((struct wlan_network *)Cam_target)->pos_vec[(signed long int)1]) / (float)5;
    CamPosition[(signed long int)0][(signed long int)2] = (CamPosition[(signed long int)0][(signed long int)2] * (float)4 + ((struct wlan_network *)Cam_target)->pos_vec[(signed long int)2]) / (float)5;
    diff_vec[(signed long int)0] = CamPosition[(signed long int)0][(signed long int)0] - ((struct wlan_network *)Cam_target)->pos_vec[(signed long int)0];
    diff_vec[(signed long int)1] = (float)0.0;
    diff_vec[(signed long int)2] = CamPosition[(signed long int)0][(signed long int)2] - ((struct wlan_network *)Cam_target)->pos_vec[(signed long int)2];
    angle=s3d_vector_angle(diff_vec, tmp_vec);
    angle = (float)((double)180 - ((double)180 / 3.14159265358979323846) * (double)angle);
    CamPosition[(signed long int)1][(signed long int)1] = (CamPosition[(signed long int)1][(signed long int)1] * (float)4 + angle) / (float)5;
    s3d_translate(0, CamPosition[(signed long int)0][(signed long int)0], CamPosition[(signed long int)0][(signed long int)1], CamPosition[(signed long int)0][(signed long int)2]);
    s3d_rotate(0, CamPosition[(signed long int)1][(signed long int)0], CamPosition[(signed long int)1][(signed long int)1], CamPosition[(signed long int)1][(signed long int)2]);
    double return_value_fabs$3;
    return_value_fabs$3=fabs((double)diff_vec[(signed long int)0]);
    if(return_value_fabs$3 < 11.0)
    {
      return_value_fabs$2=fabs((double)(CamPosition[(signed long int)0][(signed long int)1] - ((struct wlan_network *)Cam_target)->pos_vec[(signed long int)1]));
      if(return_value_fabs$2 < 1.0)
      {
        return_value_fabs$1=fabs((double)diff_vec[(signed long int)2]);
        if(return_value_fabs$1 < 1.0)
          Cam_target = (void *)0;

      }

    }

  }

  if(!(Kism3d_aborted == 0))
    s3d_quit();

  nanosleep(&sleeptime, (struct timespec *)(void *)0);
}

// make_new_monotone_poly
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 171
static signed int make_new_monotone_poly(signed int mcur, signed int v0, signed int v1)
{
  signed int p;
  signed int q;
  signed int ip;
  signed int iq;
  signed int mnew;
  mnew=newmon();
  signed int i;
  signed int j;
  signed int nf0;
  signed int nf1;
  struct anonymous$2 *vp0;
  struct anonymous$2 *vp1;
  vp0 = &vert[(signed long int)v0];
  vp1 = &vert[(signed long int)v1];
  get_vertex_positions(v0, v1, &ip, &iq);
  p = vp0->vpos[(signed long int)ip];
  q = vp1->vpos[(signed long int)iq];
  i=new_chain_element();
  j=new_chain_element();
  mchain[(signed long int)i].vnum = v0;
  mchain[(signed long int)j].vnum = v1;
  mchain[(signed long int)i].next = mchain[(signed long int)p].next;
  mchain[(signed long int)mchain[(signed long int)p].next].prev = i;
  mchain[(signed long int)i].prev = j;
  mchain[(signed long int)j].next = i;
  mchain[(signed long int)j].prev = mchain[(signed long int)q].prev;
  mchain[(signed long int)mchain[(signed long int)q].prev].next = j;
  mchain[(signed long int)p].next = q;
  mchain[(signed long int)q].prev = p;
  nf0 = vp0->nextfree;
  nf1 = vp1->nextfree;
  vp0->vnext[(signed long int)ip] = v1;
  vp0->vpos[(signed long int)nf0] = i;
  vp0->vnext[(signed long int)nf0] = mchain[(signed long int)mchain[(signed long int)i].next].vnum;
  vp1->vpos[(signed long int)nf1] = j;
  vp1->vnext[(signed long int)nf1] = v0;
  vp0->nextfree = vp0->nextfree + 1;
  vp1->nextfree = vp1->nextfree + 1;
  errds(1, "sei:make_poly()", ": mcur = %d, (v0, v1) = (%d, %d)", mcur, v0, v1);
  errds(1, "sei:make_poly()", "next posns = (p, q) = (%d, %d)", p, q);
  mon[(signed long int)mcur] = p;
  mon[(signed long int)mnew] = i;
  return mnew;
}

// make_new_monotone_poly$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 171
static signed int make_new_monotone_poly$link1(signed int mcur$link1, signed int v0$link1, signed int v1$link1)
{
  signed int p$link1;
  signed int q$link1;
  signed int ip$link1;
  signed int iq$link1;
  signed int mnew$link1;
  mnew$link1=newmon$link1();
  signed int i$link1;
  signed int j$link1;
  signed int nf0$link1;
  signed int nf1$link1;
  struct anonymous$2 *vp0$link1;
  struct anonymous$2 *vp1$link1;
  vp0$link1 = &vert$link1[(signed long int)v0$link1];
  vp1$link1 = &vert$link1[(signed long int)v1$link1];
  get_vertex_positions$link1(v0$link1, v1$link1, &ip$link1, &iq$link1);
  p$link1 = vp0$link1->vpos[(signed long int)ip$link1];
  q$link1 = vp1$link1->vpos[(signed long int)iq$link1];
  i$link1=new_chain_element$link1();
  j$link1=new_chain_element$link1();
  mchain$link1[(signed long int)i$link1].vnum = v0$link1;
  mchain$link1[(signed long int)j$link1].vnum = v1$link1;
  mchain$link1[(signed long int)i$link1].next = mchain$link1[(signed long int)p$link1].next;
  mchain$link1[(signed long int)mchain$link1[(signed long int)p$link1].next].prev = i$link1;
  mchain$link1[(signed long int)i$link1].prev = j$link1;
  mchain$link1[(signed long int)j$link1].next = i$link1;
  mchain$link1[(signed long int)j$link1].prev = mchain$link1[(signed long int)q$link1].prev;
  mchain$link1[(signed long int)mchain$link1[(signed long int)q$link1].prev].next = j$link1;
  mchain$link1[(signed long int)p$link1].next = q$link1;
  mchain$link1[(signed long int)q$link1].prev = p$link1;
  nf0$link1 = vp0$link1->nextfree;
  nf1$link1 = vp1$link1->nextfree;
  vp0$link1->vnext[(signed long int)ip$link1] = v1$link1;
  vp0$link1->vpos[(signed long int)nf0$link1] = i$link1;
  vp0$link1->vnext[(signed long int)nf0$link1] = mchain$link1[(signed long int)mchain$link1[(signed long int)i$link1].next].vnum;
  vp1$link1->vpos[(signed long int)nf1$link1] = j$link1;
  vp1$link1->vnext[(signed long int)nf1$link1] = v0$link1;
  vp0$link1->nextfree = vp0$link1->nextfree + 1;
  vp1$link1->nextfree = vp1$link1->nextfree + 1;
  errds$link1(1, "sei:make_poly()", ": mcur = %d, (v0, v1) = (%d, %d)", mcur$link1, v0$link1, v1$link1);
  errds$link1(1, "sei:make_poly()", "next posns = (p, q) = (%d, %d)", p$link1, q$link1);
  mon$link1[(signed long int)mcur$link1] = p$link1;
  mon$link1[(signed long int)mnew$link1] = i$link1;
  return mnew$link1;
}

// math_N
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_misc.c line 98
extern signed int math_N(signed int n, signed int h)
{
  signed int i;
  double v;
  i = 0;
  v = (double)(signed int)n;
  for( ; !(i >= h); i = i + 1)
    v=mlog2(v);
  double return_value_ceil$1;
  return_value_ceil$1=ceil(((double)1.0 * (double)n) / v);
  return (signed int)return_value_ceil$1;
}

// math_logstar_n
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_misc.c line 86
extern signed int math_logstar_n(signed int n)
{
  signed int i;
  double v;
  i = 0;
  v = (double)n;
  for( ; v >= 1.000000; i = i + 1)
    v=mlog2(v);
  return i - 1;
}

// merge_trapezoids
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 354
static signed int merge_trapezoids(signed int segnum, signed int tfirst, signed int tlast, signed int side)
{
  signed int merge_trapezoids$$1$$t;
  signed int tnext;
  signed int cond;
  signed int ptnext;
  merge_trapezoids$$1$$t = tfirst;
  signed int return_value__greater_than_equal_to$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$8;
  while(merge_trapezoids$$1$$t >= 1)
  {
    return_value__greater_than_equal_to$1=_greater_than_equal_to(&tr[(signed long int)merge_trapezoids$$1$$t].lo, &tr[(signed long int)tlast].lo);
    if(return_value__greater_than_equal_to$1 == 0)
      break;

    if(side == 1)
    {
      tnext = tr[(signed long int)merge_trapezoids$$1$$t].d0;
      if(tnext >= 1)
        tmp_if_expr$2 = tr[(signed long int)tnext].rseg == segnum ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$4 = (_Bool)1;

      else
      {
        tnext = tr[(signed long int)merge_trapezoids$$1$$t].d1;
        if(tnext >= 1)
          tmp_if_expr$3 = tr[(signed long int)tnext].rseg == segnum ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
      }
      cond = (signed int)tmp_if_expr$4;
    }

    else
    {
      tnext = tr[(signed long int)merge_trapezoids$$1$$t].d0;
      if(tnext >= 1)
        tmp_if_expr$5 = tr[(signed long int)tnext].lseg == segnum ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$7 = (_Bool)1;

      else
      {
        tnext = tr[(signed long int)merge_trapezoids$$1$$t].d1;
        if(tnext >= 1)
          tmp_if_expr$6 = tr[(signed long int)tnext].lseg == segnum ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$6 = (_Bool)0;
        tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
      }
      cond = (signed int)tmp_if_expr$7;
    }
    if(!(cond == 0))
    {
      if(tr[(signed long int)merge_trapezoids$$1$$t].lseg == tr[(signed long int)tnext].lseg)
        tmp_if_expr$8 = tr[(signed long int)merge_trapezoids$$1$$t].rseg == tr[(signed long int)tnext].rseg ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$8 = (_Bool)0;
      if(tmp_if_expr$8)
      {
        ptnext = qs[(signed long int)tr[(signed long int)tnext].sink].parent;
        if(qs[(signed long int)ptnext].left == tr[(signed long int)tnext].sink)
          qs[(signed long int)ptnext].left = tr[(signed long int)merge_trapezoids$$1$$t].sink;

        else
          qs[(signed long int)ptnext].right = tr[(signed long int)merge_trapezoids$$1$$t].sink;
        tr[(signed long int)merge_trapezoids$$1$$t].d0 = tr[(signed long int)tnext].d0;
        if(tr[(signed long int)merge_trapezoids$$1$$t].d0 >= 1)
        {
          if(tr[(signed long int)tr[(signed long int)merge_trapezoids$$1$$t].d0].u0 == tnext)
            tr[(signed long int)tr[(signed long int)merge_trapezoids$$1$$t].d0].u0 = merge_trapezoids$$1$$t;

          else
            if(tr[(signed long int)tr[(signed long int)merge_trapezoids$$1$$t].d0].u1 == tnext)
              tr[(signed long int)tr[(signed long int)merge_trapezoids$$1$$t].d0].u1 = merge_trapezoids$$1$$t;

        }

        tr[(signed long int)merge_trapezoids$$1$$t].d1 = tr[(signed long int)tnext].d1;
        if(tr[(signed long int)merge_trapezoids$$1$$t].d1 >= 1)
        {
          if(tr[(signed long int)tr[(signed long int)merge_trapezoids$$1$$t].d1].u0 == tnext)
            tr[(signed long int)tr[(signed long int)merge_trapezoids$$1$$t].d1].u0 = merge_trapezoids$$1$$t;

          else
            if(tr[(signed long int)tr[(signed long int)merge_trapezoids$$1$$t].d1].u1 == tnext)
              tr[(signed long int)tr[(signed long int)merge_trapezoids$$1$$t].d1].u1 = merge_trapezoids$$1$$t;

        }

        tr[(signed long int)merge_trapezoids$$1$$t].lo = tr[(signed long int)tnext].lo;
        tr[(signed long int)tnext].state = 2;
      }

      else
        merge_trapezoids$$1$$t = tnext;
    }

    else
      merge_trapezoids$$1$$t = tnext;
  }
  return 0;
}

// merge_trapezoids$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 354
static signed int merge_trapezoids$link1(signed int segnum$link1, signed int tfirst$link1, signed int tlast$link1, signed int side$link1)
{
  signed int merge_trapezoids$$1$$t$link1;
  signed int tnext$link1;
  signed int cond$link1;
  signed int ptnext$link1;
  merge_trapezoids$$1$$t$link1 = tfirst$link1;
  signed int return_value__greater_than_equal_to$1$link1;
  _Bool tmp_if_expr$2$link1;
  _Bool tmp_if_expr$4$link1;
  _Bool tmp_if_expr$3$link1;
  _Bool tmp_if_expr$5$link1;
  _Bool tmp_if_expr$7$link1;
  _Bool tmp_if_expr$6$link1;
  _Bool tmp_if_expr$8$link1;
  while(merge_trapezoids$$1$$t$link1 >= 1)
  {
    return_value__greater_than_equal_to$1$link1=_greater_than_equal_to(&tr[(signed long int)merge_trapezoids$$1$$t$link1].lo, &tr[(signed long int)tlast$link1].lo);
    if(return_value__greater_than_equal_to$1$link1 == 0)
      break;

    if(side$link1 == 1)
    {
      tnext$link1 = tr[(signed long int)merge_trapezoids$$1$$t$link1].d0;
      if(tnext$link1 >= 1)
        tmp_if_expr$2$link1 = tr[(signed long int)tnext$link1].rseg == segnum$link1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2$link1 = (_Bool)0;
      if(tmp_if_expr$2$link1)
        tmp_if_expr$4$link1 = (_Bool)1;

      else
      {
        tnext$link1 = tr[(signed long int)merge_trapezoids$$1$$t$link1].d1;
        if(tnext$link1 >= 1)
          tmp_if_expr$3$link1 = tr[(signed long int)tnext$link1].rseg == segnum$link1 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3$link1 = (_Bool)0;
        tmp_if_expr$4$link1 = tmp_if_expr$3$link1 ? (_Bool)1 : (_Bool)0;
      }
      cond$link1 = (signed int)tmp_if_expr$4$link1;
    }

    else
    {
      tnext$link1 = tr[(signed long int)merge_trapezoids$$1$$t$link1].d0;
      if(tnext$link1 >= 1)
        tmp_if_expr$5$link1 = tr[(signed long int)tnext$link1].lseg == segnum$link1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5$link1 = (_Bool)0;
      if(tmp_if_expr$5$link1)
        tmp_if_expr$7$link1 = (_Bool)1;

      else
      {
        tnext$link1 = tr[(signed long int)merge_trapezoids$$1$$t$link1].d1;
        if(tnext$link1 >= 1)
          tmp_if_expr$6$link1 = tr[(signed long int)tnext$link1].lseg == segnum$link1 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$6$link1 = (_Bool)0;
        tmp_if_expr$7$link1 = tmp_if_expr$6$link1 ? (_Bool)1 : (_Bool)0;
      }
      cond$link1 = (signed int)tmp_if_expr$7$link1;
    }
    if(!(cond$link1 == 0))
    {
      if(tr[(signed long int)merge_trapezoids$$1$$t$link1].lseg == tr[(signed long int)tnext$link1].lseg)
        tmp_if_expr$8$link1 = tr[(signed long int)merge_trapezoids$$1$$t$link1].rseg == tr[(signed long int)tnext$link1].rseg ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$8$link1 = (_Bool)0;
      if(tmp_if_expr$8$link1)
      {
        ptnext$link1 = qs[(signed long int)tr[(signed long int)tnext$link1].sink].parent;
        if(qs[(signed long int)ptnext$link1].left == tr[(signed long int)tnext$link1].sink)
          qs[(signed long int)ptnext$link1].left = tr[(signed long int)merge_trapezoids$$1$$t$link1].sink;

        else
          qs[(signed long int)ptnext$link1].right = tr[(signed long int)merge_trapezoids$$1$$t$link1].sink;
        tr[(signed long int)merge_trapezoids$$1$$t$link1].d0 = tr[(signed long int)tnext$link1].d0;
        if(tr[(signed long int)merge_trapezoids$$1$$t$link1].d0 >= 1)
        {
          if(tr[(signed long int)tr[(signed long int)merge_trapezoids$$1$$t$link1].d0].u0 == tnext$link1)
            tr[(signed long int)tr[(signed long int)merge_trapezoids$$1$$t$link1].d0].u0 = merge_trapezoids$$1$$t$link1;

          else
            if(tr[(signed long int)tr[(signed long int)merge_trapezoids$$1$$t$link1].d0].u1 == tnext$link1)
              tr[(signed long int)tr[(signed long int)merge_trapezoids$$1$$t$link1].d0].u1 = merge_trapezoids$$1$$t$link1;

        }

        tr[(signed long int)merge_trapezoids$$1$$t$link1].d1 = tr[(signed long int)tnext$link1].d1;
        if(tr[(signed long int)merge_trapezoids$$1$$t$link1].d1 >= 1)
        {
          if(tr[(signed long int)tr[(signed long int)merge_trapezoids$$1$$t$link1].d1].u0 == tnext$link1)
            tr[(signed long int)tr[(signed long int)merge_trapezoids$$1$$t$link1].d1].u0 = merge_trapezoids$$1$$t$link1;

          else
            if(tr[(signed long int)tr[(signed long int)merge_trapezoids$$1$$t$link1].d1].u1 == tnext$link1)
              tr[(signed long int)tr[(signed long int)merge_trapezoids$$1$$t$link1].d1].u1 = merge_trapezoids$$1$$t$link1;

        }

        tr[(signed long int)merge_trapezoids$$1$$t$link1].lo = tr[(signed long int)tnext$link1].lo;
        tr[(signed long int)tnext$link1].state = 2;
      }

      else
        merge_trapezoids$$1$$t$link1 = tnext$link1;
    }

    else
      merge_trapezoids$$1$$t$link1 = tnext$link1;
  }
  return 0;
}

// mlog2
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_misc.c line 47
static double mlog2(double x)
{
  double return_value_log$1;
  return_value_log$1=log(x);
  double return_value_log$2;
  return_value_log$2=log((double)2);
  return return_value_log$1 / return_value_log$2;
}

// mlog2$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_misc.c line 47
static double mlog2$link1(double x$link1)
{
  double return_value_log$1$link1;
  return_value_log$1$link1=log(x$link1);
  double return_value_log$2$link1;
  return_value_log$2$link1=log((double)2);
  return return_value_log$1$link1 / return_value_log$2$link1;
}

// model_load
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/modelread.c line 125
static signed int model_load(char *file)
{
  struct anonymous$4 *context;
  struct anonymous$5 *model;
  struct anonymous$11 *object;
  struct anonymous$12 *model_load$$1$$face;
  struct _GSList *oitem;
  struct _GSList *oface;
  float rmatrix[16l];
  struct material2texture *mat2tex;
  unsigned int i;
  unsigned int k;
  signed int j;
  signed int material_count;
  signed int texture_count;
  signed int voff;
  signed int obj_id;
  unsigned int polybuf[400l];
  unsigned int npoly;
  unsigned int oldflags;
  float normalbuf[900l];
  float texcoordbuf[600l];
  float swaph;
  unsigned char *s3d_pixeldata = (unsigned char *)(void *)0;
  context=g3d_context_new();
  obj_id = -1;
  model=g3d_model_load_full(context, file, (unsigned int)0);
  if(!(model == ((struct anonymous$5 *)NULL)))
  {
    g3d_matrix_identity(rmatrix);
    g3d_matrix_rotate_xyz((float)((3.1415926535897932384626433832795028841971693993751 * 90.0) / (double)180), (float)0.0, (float)0.0, rmatrix);
    g3d_model_transform(model, rmatrix);
    oitem = model->objects;
    obj_id=s3d_new_object();
    voff = 0;
    texture_count = voff;
    material_count = texture_count;
    while(!(oitem == ((struct _GSList *)NULL)))
    {
      object = (struct anonymous$11 *)oitem->data;
      i = (unsigned int)0;
      for( ; !(i >= object->vertex_count); i = i + 1u)
      {
        object->vertex_data[(signed long int)(i * (unsigned int)3 + (unsigned int)0)] = object->vertex_data[(signed long int)(i * (unsigned int)3 + (unsigned int)0)];
        swaph = object->vertex_data[(signed long int)(i * (unsigned int)3 + (unsigned int)2)];
        object->vertex_data[(signed long int)(i * (unsigned int)3 + (unsigned int)2)] = -object->vertex_data[(signed long int)(i * (unsigned int)3 + (unsigned int)1)];
        object->vertex_data[(signed long int)(i * (unsigned int)3 + (unsigned int)1)] = swaph;
      }
      s3d_push_vertices(obj_id, object->vertex_data, (unsigned short int)object->vertex_count);
      oface = object->faces;
      if(oface == ((struct _GSList *)NULL))
      {
        voff = voff + (signed int)object->vertex_count;
        oitem = oitem->next;
      }

      else
      {
        npoly = (unsigned int)0;
        oldflags = ((struct anonymous$12 *)oface->data)->flags;
        for( ; !(oface == ((struct _GSList *)NULL)); oface = oface->next)
        {
          model_load$$1$$face = (struct anonymous$12 *)oface->data;
          mat2tex=get_mat2tex(&mat2tex_root, (void *)model_load$$1$$face->material);
          if(mat2tex->material_id == -1)
          {
            s3d_push_material_a(obj_id, model_load$$1$$face->material->r, model_load$$1$$face->material->g, model_load$$1$$face->material->b, model_load$$1$$face->material->a, model_load$$1$$face->material->specular[(signed long int)0], model_load$$1$$face->material->specular[(signed long int)1], model_load$$1$$face->material->specular[(signed long int)2], model_load$$1$$face->material->specular[(signed long int)3], model_load$$1$$face->material->r, model_load$$1$$face->material->g, model_load$$1$$face->material->b, model_load$$1$$face->material->a);
            mat2tex->material_id = material_count;
            material_count = material_count + 1;
            if(!(model_load$$1$$face->tex_image == ((struct anonymous$9 *)NULL)))
            {
              if(!(s3d_pixeldata == ((unsigned char *)NULL)))
                free((void *)s3d_pixeldata);

              void *return_value_malloc$1;
              return_value_malloc$1=malloc(sizeof(unsigned char) /*1ul*/  * (unsigned long int)model_load$$1$$face->tex_image->width * (unsigned long int)model_load$$1$$face->tex_image->height * (unsigned long int)32);
              s3d_pixeldata = (unsigned char *)return_value_malloc$1;
              if(s3d_pixeldata == ((unsigned char *)NULL))
              {
                errs("model_load()", "Sorry - you ran out of memory !\n");
                exit(8);
              }

              j = (signed int)(model_load$$1$$face->tex_image->height - (unsigned int)1);
              for( ; j >= 0; j = j - 1)
              {
                k = (unsigned int)0;
                for( ; !(k >= model_load$$1$$face->tex_image->width); k = k + 1u)
                {
                  s3d_pixeldata[(signed long int)(((unsigned int)j * model_load$$1$$face->tex_image->width + k) * (unsigned int)4 + (unsigned int)0)] = model_load$$1$$face->tex_image->pixeldata[(signed long int)(((unsigned int)j * model_load$$1$$face->tex_image->width + k) * (unsigned int)4 + (unsigned int)2)];
                  s3d_pixeldata[(signed long int)(((unsigned int)j * model_load$$1$$face->tex_image->width + k) * (unsigned int)4 + (unsigned int)1)] = model_load$$1$$face->tex_image->pixeldata[(signed long int)(((unsigned int)j * model_load$$1$$face->tex_image->width + k) * (unsigned int)4 + (unsigned int)1)];
                  s3d_pixeldata[(signed long int)(((unsigned int)j * model_load$$1$$face->tex_image->width + k) * (unsigned int)4 + (unsigned int)2)] = model_load$$1$$face->tex_image->pixeldata[(signed long int)(((unsigned int)j * model_load$$1$$face->tex_image->width + k) * (unsigned int)4 + (unsigned int)0)];
                  s3d_pixeldata[(signed long int)(((unsigned int)j * model_load$$1$$face->tex_image->width + k) * (unsigned int)4 + (unsigned int)3)] = model_load$$1$$face->tex_image->pixeldata[(signed long int)(((unsigned int)j * model_load$$1$$face->tex_image->width + k) * (unsigned int)4 + (unsigned int)3)];
                }
              }
              s3d_push_texture(obj_id, (unsigned short int)model_load$$1$$face->tex_image->width, (unsigned short int)model_load$$1$$face->tex_image->height);
              s3d_pep_material_texture(obj_id, (unsigned int)texture_count);
              s3d_load_texture(obj_id, (unsigned int)texture_count, (unsigned short int)0, (unsigned short int)0, (unsigned short int)model_load$$1$$face->tex_image->width, (unsigned short int)model_load$$1$$face->tex_image->height, s3d_pixeldata);
              mat2tex->texture_id = texture_count;
              texture_count = texture_count + 1;
            }

          }

          if(npoly >= 100u || !(model_load$$1$$face->flags == oldflags))
          {
            s3d_push_polygons(obj_id, polybuf, (unsigned short int)npoly);
            if(!((1L & (signed long int)oldflags) == 0l))
              s3d_pep_polygon_normals(obj_id, normalbuf, (unsigned short int)npoly);

            if(!((2l & (signed long int)oldflags) == 0l))
              s3d_pep_polygon_tex_coords(obj_id, texcoordbuf, (unsigned short int)npoly);

            npoly = (unsigned int)0;
          }

          oldflags = model_load$$1$$face->flags;
          polybuf[(signed long int)(npoly * (unsigned int)4 + (unsigned int)0)] = model_load$$1$$face->vertex_indices[(signed long int)0] + (unsigned int)voff;
          polybuf[(signed long int)(npoly * (unsigned int)4 + (unsigned int)1)] = model_load$$1$$face->vertex_indices[(signed long int)2] + (unsigned int)voff;
          polybuf[(signed long int)(npoly * (unsigned int)4 + (unsigned int)2)] = model_load$$1$$face->vertex_indices[(signed long int)1] + (unsigned int)voff;
          polybuf[(signed long int)(npoly * (unsigned int)4 + (unsigned int)3)] = (unsigned int)mat2tex->material_id;
          if(!((1L & (signed long int)model_load$$1$$face->flags) == 0l))
          {
            normalbuf[(signed long int)(npoly * (unsigned int)9 + (unsigned int)0)] = -model_load$$1$$face->normals[(signed long int)0];
            normalbuf[(signed long int)(npoly * (unsigned int)9 + (unsigned int)1)] = -model_load$$1$$face->normals[(signed long int)2];
            normalbuf[(signed long int)(npoly * (unsigned int)9 + (unsigned int)2)] = model_load$$1$$face->normals[(signed long int)1];
            normalbuf[(signed long int)(npoly * (unsigned int)9 + (unsigned int)3)] = -model_load$$1$$face->normals[(signed long int)6];
            normalbuf[(signed long int)(npoly * (unsigned int)9 + (unsigned int)4)] = -model_load$$1$$face->normals[(signed long int)8];
            normalbuf[(signed long int)(npoly * (unsigned int)9 + (unsigned int)5)] = model_load$$1$$face->normals[(signed long int)7];
            normalbuf[(signed long int)(npoly * (unsigned int)9 + (unsigned int)6)] = -model_load$$1$$face->normals[(signed long int)3];
            normalbuf[(signed long int)(npoly * (unsigned int)9 + (unsigned int)7)] = -model_load$$1$$face->normals[(signed long int)5];
            normalbuf[(signed long int)(npoly * (unsigned int)9 + (unsigned int)8)] = model_load$$1$$face->normals[(signed long int)4];
          }

          if(!((2l & (signed long int)model_load$$1$$face->flags) == 0l))
          {
            texcoordbuf[(signed long int)(npoly * (unsigned int)6 + (unsigned int)0)] = model_load$$1$$face->tex_vertex_data[(signed long int)0];
            texcoordbuf[(signed long int)(npoly * (unsigned int)6 + (unsigned int)1)] = model_load$$1$$face->tex_vertex_data[(signed long int)1];
            texcoordbuf[(signed long int)(npoly * (unsigned int)6 + (unsigned int)2)] = model_load$$1$$face->tex_vertex_data[(signed long int)4];
            texcoordbuf[(signed long int)(npoly * (unsigned int)6 + (unsigned int)3)] = model_load$$1$$face->tex_vertex_data[(signed long int)5];
            texcoordbuf[(signed long int)(npoly * (unsigned int)6 + (unsigned int)4)] = model_load$$1$$face->tex_vertex_data[(signed long int)2];
            texcoordbuf[(signed long int)(npoly * (unsigned int)6 + (unsigned int)5)] = model_load$$1$$face->tex_vertex_data[(signed long int)3];
          }

          npoly = npoly + 1u;
        }
        if(npoly >= 1u)
        {
          s3d_push_polygons(obj_id, polybuf, (unsigned short int)npoly);
          if(!((1L & (signed long int)oldflags) == 0l))
            s3d_pep_polygon_normals(obj_id, normalbuf, (unsigned short int)npoly);

          if(!((2l & (signed long int)oldflags) == 0l))
            s3d_pep_polygon_tex_coords(obj_id, texcoordbuf, (unsigned short int)npoly);

        }

        voff = voff + (signed int)object->vertex_count;
        oitem = oitem->next;
      }
    }
    g3d_model_free(model);
  }

  g3d_context_free(context);
  return obj_id;
}

// model_load$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/modelread.c line 125
static signed int model_load$link1(char *file$link1)
{
  struct anonymous$4 *context$link1;
  struct anonymous$5 *model$link1;
  struct anonymous$11 *object$link1;
  struct anonymous$12 *model_load$$1$$face$link1;
  struct _GSList *oitem$link1;
  struct _GSList *oface$link1;
  float rmatrix$link1[16l];
  struct material2texture *mat2tex$link1;
  unsigned int i$link1;
  unsigned int k$link1;
  signed int j$link1;
  signed int material_count$link1;
  signed int texture_count$link1;
  signed int voff$link1;
  signed int obj_id$link1;
  unsigned int polybuf$link1[400l];
  unsigned int npoly$link1;
  unsigned int oldflags$link1;
  float normalbuf$link1[900l];
  float texcoordbuf$link1[600l];
  float swaph$link1;
  unsigned char *s3d_pixeldata$link1 = (unsigned char *)(void *)0;
  context$link1=g3d_context_new();
  obj_id$link1 = -1;
  model$link1=g3d_model_load_full(context$link1, file$link1, (unsigned int)0);
  if(!(model$link1 == ((struct anonymous$5 *)NULL)))
  {
    g3d_matrix_identity(rmatrix$link1);
    g3d_matrix_rotate_xyz((float)((3.1415926535897932384626433832795028841971693993751 * 90.0) / (double)180), (float)0.0, (float)0.0, rmatrix$link1);
    g3d_model_transform(model$link1, rmatrix$link1);
    oitem$link1 = model$link1->objects;
    obj_id$link1=s3d_new_object();
    voff$link1 = 0;
    texture_count$link1 = voff$link1;
    material_count$link1 = texture_count$link1;
    while(!(oitem$link1 == ((struct _GSList *)NULL)))
    {
      object$link1 = (struct anonymous$11 *)oitem$link1->data;
      i$link1 = (unsigned int)0;
      for( ; !(i$link1 >= object$link1->vertex_count); i$link1 = i$link1 + 1u)
      {
        object$link1->vertex_data[(signed long int)(i$link1 * (unsigned int)3 + (unsigned int)0)] = object$link1->vertex_data[(signed long int)(i$link1 * (unsigned int)3 + (unsigned int)0)];
        swaph$link1 = object$link1->vertex_data[(signed long int)(i$link1 * (unsigned int)3 + (unsigned int)2)];
        object$link1->vertex_data[(signed long int)(i$link1 * (unsigned int)3 + (unsigned int)2)] = -object$link1->vertex_data[(signed long int)(i$link1 * (unsigned int)3 + (unsigned int)1)];
        object$link1->vertex_data[(signed long int)(i$link1 * (unsigned int)3 + (unsigned int)1)] = swaph$link1;
      }
      s3d_push_vertices(obj_id$link1, object$link1->vertex_data, (unsigned short int)object$link1->vertex_count);
      oface$link1 = object$link1->faces;
      if(oface$link1 == ((struct _GSList *)NULL))
      {
        voff$link1 = voff$link1 + (signed int)object$link1->vertex_count;
        oitem$link1 = oitem$link1->next;
      }

      else
      {
        npoly$link1 = (unsigned int)0;
        oldflags$link1 = ((struct anonymous$12 *)oface$link1->data)->flags;
        for( ; !(oface$link1 == ((struct _GSList *)NULL)); oface$link1 = oface$link1->next)
        {
          model_load$$1$$face$link1 = (struct anonymous$12 *)oface$link1->data;
          mat2tex$link1=get_mat2tex$link1(&mat2tex_root$link1, (void *)model_load$$1$$face$link1->material);
          if(mat2tex$link1->material_id == -1)
          {
            s3d_push_material_a(obj_id$link1, model_load$$1$$face$link1->material->r, model_load$$1$$face$link1->material->g, model_load$$1$$face$link1->material->b, model_load$$1$$face$link1->material->a, model_load$$1$$face$link1->material->specular[(signed long int)0], model_load$$1$$face$link1->material->specular[(signed long int)1], model_load$$1$$face$link1->material->specular[(signed long int)2], model_load$$1$$face$link1->material->specular[(signed long int)3], model_load$$1$$face$link1->material->r, model_load$$1$$face$link1->material->g, model_load$$1$$face$link1->material->b, model_load$$1$$face$link1->material->a);
            mat2tex$link1->material_id = material_count$link1;
            material_count$link1 = material_count$link1 + 1;
            if(!(model_load$$1$$face$link1->tex_image == ((struct anonymous$9 *)NULL)))
            {
              if(!(s3d_pixeldata$link1 == ((unsigned char *)NULL)))
                free((void *)s3d_pixeldata$link1);

              void *return_value_malloc$1$link1;
              return_value_malloc$1$link1=malloc(sizeof(unsigned char) /*1ul*/  * (unsigned long int)model_load$$1$$face$link1->tex_image->width * (unsigned long int)model_load$$1$$face$link1->tex_image->height * (unsigned long int)32);
              s3d_pixeldata$link1 = (unsigned char *)return_value_malloc$1$link1;
              if(s3d_pixeldata$link1 == ((unsigned char *)NULL))
              {
                errs("model_load()", "Sorry - you ran out of memory !\n");
                exit(8);
              }

              j$link1 = (signed int)(model_load$$1$$face$link1->tex_image->height - (unsigned int)1);
              for( ; j$link1 >= 0; j$link1 = j$link1 - 1)
              {
                k$link1 = (unsigned int)0;
                for( ; !(k$link1 >= model_load$$1$$face$link1->tex_image->width); k$link1 = k$link1 + 1u)
                {
                  s3d_pixeldata$link1[(signed long int)(((unsigned int)j$link1 * model_load$$1$$face$link1->tex_image->width + k$link1) * (unsigned int)4 + (unsigned int)0)] = model_load$$1$$face$link1->tex_image->pixeldata[(signed long int)(((unsigned int)j$link1 * model_load$$1$$face$link1->tex_image->width + k$link1) * (unsigned int)4 + (unsigned int)2)];
                  s3d_pixeldata$link1[(signed long int)(((unsigned int)j$link1 * model_load$$1$$face$link1->tex_image->width + k$link1) * (unsigned int)4 + (unsigned int)1)] = model_load$$1$$face$link1->tex_image->pixeldata[(signed long int)(((unsigned int)j$link1 * model_load$$1$$face$link1->tex_image->width + k$link1) * (unsigned int)4 + (unsigned int)1)];
                  s3d_pixeldata$link1[(signed long int)(((unsigned int)j$link1 * model_load$$1$$face$link1->tex_image->width + k$link1) * (unsigned int)4 + (unsigned int)2)] = model_load$$1$$face$link1->tex_image->pixeldata[(signed long int)(((unsigned int)j$link1 * model_load$$1$$face$link1->tex_image->width + k$link1) * (unsigned int)4 + (unsigned int)0)];
                  s3d_pixeldata$link1[(signed long int)(((unsigned int)j$link1 * model_load$$1$$face$link1->tex_image->width + k$link1) * (unsigned int)4 + (unsigned int)3)] = model_load$$1$$face$link1->tex_image->pixeldata[(signed long int)(((unsigned int)j$link1 * model_load$$1$$face$link1->tex_image->width + k$link1) * (unsigned int)4 + (unsigned int)3)];
                }
              }
              s3d_push_texture(obj_id$link1, (unsigned short int)model_load$$1$$face$link1->tex_image->width, (unsigned short int)model_load$$1$$face$link1->tex_image->height);
              s3d_pep_material_texture(obj_id$link1, (unsigned int)texture_count$link1);
              s3d_load_texture(obj_id$link1, (unsigned int)texture_count$link1, (unsigned short int)0, (unsigned short int)0, (unsigned short int)model_load$$1$$face$link1->tex_image->width, (unsigned short int)model_load$$1$$face$link1->tex_image->height, s3d_pixeldata$link1);
              mat2tex$link1->texture_id = texture_count$link1;
              texture_count$link1 = texture_count$link1 + 1;
            }

          }

          if(npoly$link1 >= 100u || !(model_load$$1$$face$link1->flags == oldflags$link1))
          {
            s3d_push_polygons(obj_id$link1, polybuf$link1, (unsigned short int)npoly$link1);
            if(!((1L & (signed long int)oldflags$link1) == 0l))
              s3d_pep_polygon_normals(obj_id$link1, normalbuf$link1, (unsigned short int)npoly$link1);

            if(!((2l & (signed long int)oldflags$link1) == 0l))
              s3d_pep_polygon_tex_coords(obj_id$link1, texcoordbuf$link1, (unsigned short int)npoly$link1);

            npoly$link1 = (unsigned int)0;
          }

          oldflags$link1 = model_load$$1$$face$link1->flags;
          polybuf$link1[(signed long int)(npoly$link1 * (unsigned int)4 + (unsigned int)0)] = model_load$$1$$face$link1->vertex_indices[(signed long int)0] + (unsigned int)voff$link1;
          polybuf$link1[(signed long int)(npoly$link1 * (unsigned int)4 + (unsigned int)1)] = model_load$$1$$face$link1->vertex_indices[(signed long int)2] + (unsigned int)voff$link1;
          polybuf$link1[(signed long int)(npoly$link1 * (unsigned int)4 + (unsigned int)2)] = model_load$$1$$face$link1->vertex_indices[(signed long int)1] + (unsigned int)voff$link1;
          polybuf$link1[(signed long int)(npoly$link1 * (unsigned int)4 + (unsigned int)3)] = (unsigned int)mat2tex$link1->material_id;
          if(!((1L & (signed long int)model_load$$1$$face$link1->flags) == 0l))
          {
            normalbuf$link1[(signed long int)(npoly$link1 * (unsigned int)9 + (unsigned int)0)] = -model_load$$1$$face$link1->normals[(signed long int)0];
            normalbuf$link1[(signed long int)(npoly$link1 * (unsigned int)9 + (unsigned int)1)] = -model_load$$1$$face$link1->normals[(signed long int)2];
            normalbuf$link1[(signed long int)(npoly$link1 * (unsigned int)9 + (unsigned int)2)] = model_load$$1$$face$link1->normals[(signed long int)1];
            normalbuf$link1[(signed long int)(npoly$link1 * (unsigned int)9 + (unsigned int)3)] = -model_load$$1$$face$link1->normals[(signed long int)6];
            normalbuf$link1[(signed long int)(npoly$link1 * (unsigned int)9 + (unsigned int)4)] = -model_load$$1$$face$link1->normals[(signed long int)8];
            normalbuf$link1[(signed long int)(npoly$link1 * (unsigned int)9 + (unsigned int)5)] = model_load$$1$$face$link1->normals[(signed long int)7];
            normalbuf$link1[(signed long int)(npoly$link1 * (unsigned int)9 + (unsigned int)6)] = -model_load$$1$$face$link1->normals[(signed long int)3];
            normalbuf$link1[(signed long int)(npoly$link1 * (unsigned int)9 + (unsigned int)7)] = -model_load$$1$$face$link1->normals[(signed long int)5];
            normalbuf$link1[(signed long int)(npoly$link1 * (unsigned int)9 + (unsigned int)8)] = model_load$$1$$face$link1->normals[(signed long int)4];
          }

          if(!((2l & (signed long int)model_load$$1$$face$link1->flags) == 0l))
          {
            texcoordbuf$link1[(signed long int)(npoly$link1 * (unsigned int)6 + (unsigned int)0)] = model_load$$1$$face$link1->tex_vertex_data[(signed long int)0];
            texcoordbuf$link1[(signed long int)(npoly$link1 * (unsigned int)6 + (unsigned int)1)] = model_load$$1$$face$link1->tex_vertex_data[(signed long int)1];
            texcoordbuf$link1[(signed long int)(npoly$link1 * (unsigned int)6 + (unsigned int)2)] = model_load$$1$$face$link1->tex_vertex_data[(signed long int)4];
            texcoordbuf$link1[(signed long int)(npoly$link1 * (unsigned int)6 + (unsigned int)3)] = model_load$$1$$face$link1->tex_vertex_data[(signed long int)5];
            texcoordbuf$link1[(signed long int)(npoly$link1 * (unsigned int)6 + (unsigned int)4)] = model_load$$1$$face$link1->tex_vertex_data[(signed long int)2];
            texcoordbuf$link1[(signed long int)(npoly$link1 * (unsigned int)6 + (unsigned int)5)] = model_load$$1$$face$link1->tex_vertex_data[(signed long int)3];
          }

          npoly$link1 = npoly$link1 + 1u;
        }
        if(npoly$link1 >= 1u)
        {
          s3d_push_polygons(obj_id$link1, polybuf$link1, (unsigned short int)npoly$link1);
          if(!((1L & (signed long int)oldflags$link1) == 0l))
            s3d_pep_polygon_normals(obj_id$link1, normalbuf$link1, (unsigned short int)npoly$link1);

          if(!((2l & (signed long int)oldflags$link1) == 0l))
            s3d_pep_polygon_tex_coords(obj_id$link1, texcoordbuf$link1, (unsigned short int)npoly$link1);

        }

        voff$link1 = voff$link1 + (signed int)object$link1->vertex_count;
        oitem$link1 = oitem$link1->next;
      }
    }
    g3d_model_free(model$link1);
  }

  g3d_context_free(context$link1);
  return obj_id$link1;
}

// monotonate_trapezoids
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 230
extern signed int monotonate_trapezoids(signed int n)
{
  signed int i;
  signed int tr_start;
  memset((void *)vert, 0, sizeof(struct anonymous$2 [200l]) /*11200ul*/ );
  memset((void *)visited, 0, sizeof(signed int [800l]) /*3200ul*/ );
  memset((void *)mchain, 0, sizeof(struct anonymous$0 [800l]) /*12800ul*/ );
  memset((void *)mon, 0, sizeof(signed int [200l]) /*800ul*/ );
  i = 0;
  signed int return_value_inside_polygon$1;
  for( ; !(i >= 4); i = i + 1)
  {
    return_value_inside_polygon$1=inside_polygon(&tr[(signed long int)i]);
    if(!(return_value_inside_polygon$1 == 0))
      break;

  }
  tr_start = i;
  i = 1;
  for( ; n >= i; i = i + 1)
  {
    mchain[(signed long int)i].prev = seg[(signed long int)i].prev;
    mchain[(signed long int)i].next = seg[(signed long int)i].next;
    mchain[(signed long int)i].vnum = i;
    vert[(signed long int)i].pt = seg[(signed long int)i].v0;
    vert[(signed long int)i].vnext[(signed long int)0] = seg[(signed long int)i].next;
    vert[(signed long int)i].vpos[(signed long int)0] = i;
    vert[(signed long int)i].nextfree = 1;
  }
  chain_idx = n;
  mon_idx = 0;
  mon[(signed long int)0] = 1;
  if(tr[(signed long int)tr_start].u0 >= 1)
    traverse_polygon(0, tr_start, tr[(signed long int)tr_start].u0, 1);

  else
    if(tr[(signed long int)tr_start].d0 >= 1)
      traverse_polygon(0, tr_start, tr[(signed long int)tr_start].d0, 2);

  signed int return_value_newmon$2;
  return_value_newmon$2=newmon();
  return return_value_newmon$2;
}

// net_prot_in
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_in.c line 34
signed int net_prot_in(unsigned char opcode, unsigned short int length, char *buf)
{
  unsigned int oid = ~0u;
  struct s3d_evt *s3devt = (struct s3d_evt *)(void *)0;
  struct mcp_object *mo;
  struct s3d_obj_info *oi;
  struct s3d_texshm *tshm;
  switch((signed int)opcode)
  {
    case 1:
    {
      s3dprintf$link1(3, "S3D_P_S_INIT: init!!");
      _s3d_ready = 1;
      break;
    }
    case 2:
    {
      s3dprintf$link1(3, "S3D_P_S_QUIT: server wants us to go. well ...");
      s3d_quit();
      break;
    }
    case 3:
    {
      if((signed int)length == 4)
      {
        oid=ntohl(*((unsigned int *)buf));
        void *return_value_malloc$1;
        return_value_malloc$1=malloc(sizeof(struct s3d_evt) /*24ul*/ );
        s3devt = (struct s3d_evt *)return_value_malloc$1;
        if(!(s3devt == ((struct s3d_evt *)NULL)))
        {
          *((unsigned int *)buf) = oid;
          s3devt->event = (unsigned char)1;
          s3devt->length = 4;
          s3devt->buf = buf;
        }

        s3dprintf$link1(3, "S3D_P_S_CLICK: %d got clicked ....", oid);
      }

      break;
    }
    case 16:
    {
      if((signed int)length == 4)
      {
        oid=ntohl(*((unsigned int *)buf));
        _queue_new_object(oid);
        s3dprintf$link1(1, "S3D_P_S_NEWOBJ: new object %d", oid);
      }

      break;
    }
    case 4:
    {
      if((signed int)length == 8)
      {
        void *return_value_malloc$2;
        return_value_malloc$2=malloc(sizeof(struct s3d_evt) /*24ul*/ );
        s3devt = (struct s3d_evt *)return_value_malloc$2;
        if(!(s3devt == ((struct s3d_evt *)NULL)))
        {
          struct s3d_key_event *keyevent;
          s3devt->length = 2;
          keyevent = (struct s3d_key_event *)buf;
          keyevent->keysym=ntohs(keyevent->keysym);
          keyevent->unicode=ntohs(keyevent->unicode);
          keyevent->modifier=ntohs(keyevent->modifier);
          keyevent->state=ntohs(keyevent->state);
          s3devt->buf = buf;
          s3devt->event = (unsigned char)((signed int)keyevent->state == 0 ? 2 : 4);
          s3dprintf$link1(1, "S3D_P_S_KEY: key %d hit!!", *((unsigned short int *)s3devt->buf));
        }

      }

      break;
    }
    case 5:
    {
      if((signed int)length == 2)
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc(sizeof(struct s3d_evt) /*24ul*/ );
        s3devt = (struct s3d_evt *)return_value_malloc$3;
        if(!(s3devt == ((struct s3d_evt *)NULL)))
        {
          s3devt->event = (unsigned char)3;
          s3devt->length = 2;
          s3devt->buf = buf;
          s3dprintf$link1(1, "S3D_P_S_MBUTTON: mbutton %d, state %d !!", *((unsigned char *)s3devt->buf), *((signed long int)1 + (unsigned char *)s3devt->buf));
        }

      }

      break;
    }
    case 67:
    {
      if((unsigned long int)length == sizeof(struct mcp_object) /*276ul*/ )
      {
        void *return_value_malloc$4;
        return_value_malloc$4=malloc(sizeof(struct s3d_evt) /*24ul*/ );
        s3devt = (struct s3d_evt *)return_value_malloc$4;
        if(!(s3devt == ((struct s3d_evt *)NULL)))
        {
          s3devt->event = (unsigned char)32;
          s3devt->length = (signed int)length;
          mo = (struct mcp_object *)buf;
          *((unsigned int *)buf)=ntohl(*((unsigned int *)buf));
          ntohfb(&mo->trans_x, 4);
          buf[(signed long int)((signed int)length - 1)] = (char)0;
          s3devt->buf = buf;
          s3dprintf$link1(1, "S3D_P_MCP_OBEJCT: something is happening to object %d, name %s", mo->object, (const void *)mo->name);
        }

      }

      else
        s3dprintf$link1(3, "wrong length for S3D_P_MCP_OBJECT length %d != %d", length, (signed int)sizeof(struct mcp_object) /*276ul*/ );
      break;
    }
    case 32:
    {
      if((unsigned long int)length == sizeof(struct s3d_obj_info) /*296ul*/ )
      {
        void *return_value_malloc$5;
        return_value_malloc$5=malloc(sizeof(struct s3d_evt) /*24ul*/ );
        s3devt = (struct s3d_evt *)return_value_malloc$5;
        if(!(s3devt == ((struct s3d_evt *)NULL)))
        {
          s3devt->event = (unsigned char)17;
          s3devt->length = (signed int)length;
          oi = (struct s3d_obj_info *)buf;
          oi->object=ntohl(oi->object);
          oi->flags=ntohl(oi->flags);
          ntohfb(&oi->trans_x, 8);
          buf[(signed long int)((signed int)length - 1)] = (char)0;
          s3devt->buf = buf;
          s3dprintf$link1(1, "S3D_P_S_OINFO: something is happening to object %d, name %s", oi->object, (const void *)oi->name);
        }

      }

      else
        s3dprintf$link1(3, "wrong length for S3D_P_S_OINFO length %d != %d", length, (signed int)sizeof(struct s3d_obj_info) /*296ul*/ );
      break;
    }
    case 6:
    {
      if((unsigned long int)length == sizeof(struct s3d_texshm) /*20ul*/ )
      {
        tshm = (struct s3d_texshm *)buf;
        unsigned int return_value_ntohl$6;
        return_value_ntohl$6=ntohl((unsigned int)tshm->oid);
        tshm->oid = (signed int)return_value_ntohl$6;
        unsigned int return_value_ntohl$7;
        return_value_ntohl$7=ntohl((unsigned int)tshm->tex);
        tshm->tex = (signed int)return_value_ntohl$7;
        unsigned int return_value_ntohl$8;
        return_value_ntohl$8=ntohl((unsigned int)tshm->shmid);
        tshm->shmid = (signed int)return_value_ntohl$8;
        tshm->tw=ntohs(tshm->tw);
        tshm->th=ntohs(tshm->th);
        tshm->w=ntohs(tshm->w);
        tshm->h=ntohs(tshm->h);
        s3dprintf$link1(3, "S3D_P_S_SHMTEX: texture %d of object %d is available under shmid %d", tshm->tex, tshm->oid, tshm->shmid);
        _s3d_handle_texshm(tshm);
        free((void *)buf);
      }

      else
        s3dprintf$link1(3, "wrong length for S3D_P_S_SHMTEX length %d != %d", length, (signed int)sizeof(struct s3d_texshm) /*20ul*/ );
      break;
    }
    case 68:
    {
      if((signed int)length == 4)
      {
        void *return_value_malloc$9;
        return_value_malloc$9=malloc(sizeof(struct s3d_evt) /*24ul*/ );
        s3devt = (struct s3d_evt *)return_value_malloc$9;
        if(!(s3devt == ((struct s3d_evt *)NULL)))
        {
          s3devt->event = (unsigned char)33;
          s3devt->length = (signed int)length;
          *((unsigned int *)buf)=ntohl(*((unsigned int *)buf));
          s3dprintf$link1(3, "S3D_P_MCP_DEL_OBEJCT: deleting object %d", *((unsigned int *)buf));
          s3devt->buf = buf;
        }

      }

      break;
    }
    default:
    {
      s3dprintf$link1(3, "don't know command %d", opcode);
      if(!(buf == ((char *)NULL)))
        free((void *)buf);

    }
  }
  if(!(s3devt == ((struct s3d_evt *)NULL)))
    s3d_push_event(s3devt);

  return 0;
}

// net_send
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/network.c line 37
signed int net_send(unsigned char opcode, char *buf, unsigned short int length)
{
  char *ptr;
  char buff[65539l];
  buff[0l] = (char)opcode;
  ptr = buff + (signed long int)1;
  *((unsigned short int *)ptr)=htons(length);
  if(!((signed int)length == 0))
    memcpy((void *)(buff + (signed long int)3), (const void *)buf, (unsigned long int)length);

  switch(con_type)
  {
    case 1:
    {
      shm_writen(buff, (signed int)length + 3);
      break;
    }
    case 2:
      tcp_writen(buff, (signed int)length + 3);
  }
  return 0;
}

// new_chain_element
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 94
static signed int new_chain_element(void)
{
  chain_idx = chain_idx + 1;
  return chain_idx;
}

// new_chain_element$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 94
static signed int new_chain_element$link1(void)
{
  chain_idx$link1 = chain_idx$link1 + 1;
  return chain_idx$link1;
}

// newmon
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 87
static signed int newmon(void)
{
  mon_idx = mon_idx + 1;
  return mon_idx;
}

// newmon$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 87
static signed int newmon$link1(void)
{
  mon_idx$link1 = mon_idx$link1 + 1;
  return mon_idx$link1;
}

// newnode
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 53
static signed int newnode(void)
{
  signed int tmp_post$1;
  if(!(q_idx >= 8))
  {
    tmp_post$1 = q_idx;
    q_idx = q_idx + 1;
    return tmp_post$1;
  }

  else
  {
    errs("sei:newnode()", "Query-table overflow");
    return -1;
  }
}

// newnode$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 53
static signed int newnode$link1(void)
{
  signed int tmp_post$1$link1;
  if(!(q_idx$link1 >= 8))
  {
    tmp_post$1$link1 = q_idx$link1;
    q_idx$link1 = q_idx$link1 + 1;
    return tmp_post$1$link1;
  }

  else
  {
    errs("sei:newnode()", "Query-table overflow");
    return -1;
  }
}

// newtrap
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 64
static signed int newtrap(void)
{
  signed int tmp_post$1;
  if(!(tr_idx >= 4))
  {
    tr[(signed long int)tr_idx].lseg = -1;
    tr[(signed long int)tr_idx].rseg = -1;
    tr[(signed long int)tr_idx].state = 1;
    tmp_post$1 = tr_idx;
    tr_idx = tr_idx + 1;
    return tmp_post$1;
  }

  else
  {
    errs("sei:newtrap()", "Trapezoid-table overflow");
    return -1;
  }
}

// newtrap$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_construct.c line 64
static signed int newtrap$link1(void)
{
  signed int tmp_post$1$link1;
  if(!(tr_idx$link1 >= 4))
  {
    tr[(signed long int)tr_idx$link1].lseg = -1;
    tr[(signed long int)tr_idx$link1].rseg = -1;
    tr[(signed long int)tr_idx$link1].state = 1;
    tmp_post$1$link1 = tr_idx$link1;
    tr_idx$link1 = tr_idx$link1 + 1;
    return tmp_post$1$link1;
  }

  else
  {
    errs("sei:newtrap()", "Trapezoid-table overflow");
    return -1;
  }
}

// ntohfb
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/endian.c line 39
void ntohfb(float *netfloat, signed int num)
{
  signed int i = 0;
  for( ; !(i >= num); i = i + 1)
    *((unsigned int *)&netfloat[(signed long int)i])=ntohl(*((unsigned int *)&netfloat[(signed long int)i]));
}

// ntohlb
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/endian.c line 57
void ntohlb(unsigned int *netint32, signed int num)
{
  signed int i = 0;
  for( ; !(i >= num); i = i + 1)
    netint32[(signed long int)i]=ntohl(netint32[(signed long int)i]);
}

// ntohsb
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/endian.c line 75
void ntohsb(unsigned short int *netint16, signed int num)
{
  signed int i = 0;
  for( ; !(i >= num); i = i + 1)
    netint16[(signed long int)i]=ntohs(netint16[(signed long int)i]);
}

// object_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 313
static signed int object_click(struct s3d_evt *evt)
{
  struct list_head *network_pos;
  struct wlan_network *wlan_network;
  signed int clicked_id = (signed int)*((unsigned int *)evt->buf);
  s3dw_handle_click(evt);
  unsigned int return_value_get_time$1;
  if(Last_Click_Oid == clicked_id)
  {
    return_value_get_time$1=get_time();
    if(!(return_value_get_time$1 >= 250u + Last_Click_Time))
    {
      network_pos = (&Network_list)->next;
      for( ; !(network_pos == &Network_list); network_pos = network_pos->next)
      {
        wlan_network = (struct wlan_network *)((char *)network_pos - (signed long int)(unsigned long int)&((struct wlan_network *)0)->list);
        if(wlan_network->click_id == clicked_id)
        {
          Cam_target = (void *)wlan_network;
          break;
        }

      }
    }

  }

  Last_Click_Oid = clicked_id;
  Last_Click_Time=get_time();
  return 0;
}

// object_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 357
static signed int object_info(struct s3d_evt *hrmz)
{
  struct s3d_obj_info *inf = (struct s3d_obj_info *)hrmz->buf;
  s3dw_object_info(hrmz);
  if(inf->object == 0u)
  {
    CamPosition[(signed long int)0][(signed long int)0] = inf->trans_x;
    CamPosition[(signed long int)0][(signed long int)1] = inf->trans_y;
    CamPosition[(signed long int)0][(signed long int)2] = inf->trans_z;
    CamPosition[(signed long int)1][(signed long int)0] = inf->rot_x;
    CamPosition[(signed long int)1][(signed long int)1] = inf->rot_y;
    CamPosition[(signed long int)1][(signed long int)2] = inf->rot_z;
  }

  return 0;
}

// parse_args
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/io.c line 80
static signed int parse_args(signed int *argc, char ***argv)
{
  signed int c;
  signed int lopt_idx;
  signed int old_argc;
  signed int curopt;
  struct option long_options[4l] = { { .name="s3d-url", .has_arg=1, .flag=(signed int *)(void *)0, .val=117 },
    { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 },
    { .name="s3d-help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
  signed int return_value_strcmp$1;
  if(argv == ((char ***)NULL) || argc == ((signed int *)NULL))
    return 0;

  else
  {
    old_argc = *argc;
    optind = 0;
    opterr = 0;
    *argc = 1;
    curopt = 1;
    do
    {
      c=getopt_long(old_argc, *argv, "-h", long_options, &lopt_idx);
      if(c == -1)
        break;

      switch(c)
      {
        case 117:
        {
          return_value_strcmp$1=strcmp(long_options[(signed long int)lopt_idx].name, "s3d-url");
          if(return_value_strcmp$1 == 0)
          {
            if(!(optarg == ((char *)NULL)))
            {
              url = optarg;
              s3dprintf$link1(4, "connecting to %s", url);
            }

          }

          break;
        }
        case 104:
        {
          printf("usage: %s [options]", (*argv)[(signed long int)0]);
          s3d_usage();
          return -1;
        }
        default:
        {
          (*argv)[(signed long int)*argc] = (*argv)[(signed long int)curopt];
          *argc = *argc + 1;
        }
      }
      curopt = optind;
    }
    while((_Bool)1);
    c = optind;
    for( ; !(c >= old_argc); c = c + 1)
    {
      (*argv)[(signed long int)*argc] = (*argv)[(signed long int)c];
      *argc = *argc + 1;
    }
    optind = 0;
    return 0;
  }
}

// parse_args$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/io.c line 80
static signed int parse_args$link1(signed int *argc$link1, char ***argv$link1)
{
  signed int c$link1;
  signed int lopt_idx$link1;
  signed int old_argc$link1;
  signed int curopt$link1;
  struct option long_options$link1[4l] = { { .name="s3d-url", .has_arg=1, .flag=(signed int *)(void *)0, .val=117 },
    { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 },
    { .name="s3d-help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
  signed int return_value_strcmp$1$link1;
  if(argv$link1 == ((char ***)NULL) || argc$link1 == ((signed int *)NULL))
    return 0;

  else
  {
    old_argc$link1 = *argc$link1;
    optind = 0;
    opterr = 0;
    *argc$link1 = 1;
    curopt$link1 = 1;
    do
    {
      c$link1=getopt_long(old_argc$link1, *argv$link1, "-h", long_options$link1, &lopt_idx$link1);
      if(c$link1 == -1)
        break;

      switch(c$link1)
      {
        case 117:
        {
          return_value_strcmp$1$link1=strcmp(long_options$link1[(signed long int)lopt_idx$link1].name, "s3d-url");
          if(return_value_strcmp$1$link1 == 0)
          {
            if(!(optarg == ((char *)NULL)))
            {
              url$link1 = optarg;
              s3dprintf$link2(4, "connecting to %s", url$link1);
            }

          }

          break;
        }
        case 104:
        {
          printf("usage: %s [options]", (*argv$link1)[(signed long int)0]);
          s3d_usage();
          return -1;
        }
        default:
        {
          (*argv$link1)[(signed long int)*argc$link1] = (*argv$link1)[(signed long int)curopt$link1];
          *argc$link1 = *argc$link1 + 1;
        }
      }
      curopt$link1 = optind;
    }
    while((_Bool)1);
    c$link1 = optind;
    for( ; !(c$link1 >= old_argc$link1); c$link1 = c$link1 + 1)
    {
      (*argv$link1)[(signed long int)*argc$link1] = (*argv$link1)[(signed long int)c$link1];
      *argc$link1 = *argc$link1 + 1;
    }
    optind = 0;
    return 0;
  }
}

// parse_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/kism3d.c line 86
static void parse_buffer(struct kismet_src *kismet_src)
{
  struct wlan_network *wlan_network;
  struct wlan_client *wlan_client;
  char enable_network[43l] = { '!', '0', ' ', 'E', 'N', 'A', 'B', 'L', 'E', ' ', 'N', 'E', 'T', 'W', 'O', 'R', 'K', ' ', 'b', 's', 's', 'i', 'd', ',', 't', 'y', 'p', 'e', ',', 'c', 'h', 'a', 'n', 'n', 'e', 'l', ',', 's', 's', 'i', 'd', '\n', 0 };
  char enable_client[31l] = { '!', '0', ' ', 'E', 'N', 'A', 'B', 'L', 'E', ' ', 'C', 'L', 'I', 'E', 'N', 'T', ' ', 'b', 's', 's', 'i', 'd', ',', 'm', 'a', 'c', ',', 'i', 'p', '\n', 0 };
  char enable_alert[19l] = { '!', '0', ' ', 'E', 'N', 'A', 'B', 'L', 'E', ' ', 'A', 'L', 'E', 'R', 'T', ' ', '*', '\n', 0 };
  char *read_ptr;
  char *line_ptr;
  char *last_cr_ptr = (char *)(void *)0;
  char *parse_begin_ptr;
  char *parse_end_ptr;
  char *bssid;
  char *channel;
  char *type;
  char *ssid;
  char *mac;
  char *ip;
  signed int count;
  read_ptr = kismet_src->recv_buff;
  line_ptr = kismet_src->recv_buff;
  signed long int return_value_write$3;
  signed long int return_value_write$6;
  signed long int return_value_write$9;
  unsigned long int return_value_strlen$18;
  signed int return_value_strncmp$19;
  unsigned long int return_value_strlen$16;
  signed int return_value_strncmp$17;
  unsigned long int return_value_strlen$14;
  signed int return_value_strncmp$15;
  for( ; !((signed int)*read_ptr == 0); read_ptr = read_ptr + 1l)
    if((signed int)*read_ptr == 10)
    {
      last_cr_ptr = read_ptr;
      *last_cr_ptr = (char)0;
      ip = (char *)(void *)0;
      mac = ip;
      ssid = mac;
      type = ssid;
      channel = type;
      bssid = channel;
      unsigned long int return_value_strlen$20;
      return_value_strlen$20=strlen("*TIME: ");
      signed int return_value_strncmp$21;
      return_value_strncmp$21=strncmp(line_ptr, "*TIME: ", return_value_strlen$20);
      if(return_value_strncmp$21 == 0)
      {
        if(!(kismet_src->enable_level >= 4))
        {
          switch(kismet_src->enable_level)
          {
            case 0:
            {
              return_value_write$3=write(kismet_src->sock, (const void *)enable_alert, sizeof(char [19l]) /*19ul*/ );
              if(!(return_value_write$3 >= 0l))
              {
                signed int *return_value___errno_location$1;
                return_value___errno_location$1=__errno_location();
                char *return_value_strerror$2;
                return_value_strerror$2=strerror(*return_value___errno_location$1);
                printf("Warning - can't send ENABLE ALERT message to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, return_value_strerror$2);
              }

              break;
            }
            case 1:
            {
              return_value_write$6=write(kismet_src->sock, (const void *)enable_client, sizeof(char [31l]) /*31ul*/ );
              if(!(return_value_write$6 >= 0l))
              {
                signed int *return_value___errno_location$4;
                return_value___errno_location$4=__errno_location();
                char *return_value_strerror$5;
                return_value_strerror$5=strerror(*return_value___errno_location$4);
                printf("Warning - can't send ENABLE CLIENT message to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, return_value_strerror$5);
              }

              break;
            }
            case 2:
            {
              return_value_write$9=write(kismet_src->sock, (const void *)enable_network, sizeof(char [43l]) /*43ul*/ );
              if(!(return_value_write$9 >= 0l))
              {
                signed int *return_value___errno_location$7;
                return_value___errno_location$7=__errno_location();
                char *return_value_strerror$8;
                return_value_strerror$8=strerror(*return_value___errno_location$7);
                printf("Warning - can't send ENABLE NETWORK message to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, return_value_strerror$8);
              }

              break;
            }
            case 3:
              if(thread_running == 0)
              {
                thread_running = thread_running + 1;
                pthread_create(&s3d_thread_id, (const union pthread_attr_t *)(void *)0, gui_main, (void *)0);
              }

          }
          kismet_src->enable_level = kismet_src->enable_level + 1;
        }

      }

      else
      {
        return_value_strlen$18=strlen("*NETWORK: ");
        return_value_strncmp$19=strncmp(line_ptr, "*NETWORK: ", return_value_strlen$18);
        if(return_value_strncmp$19 == 0)
        {
          unsigned long int return_value_strlen$10;
          return_value_strlen$10=strlen("*NETWORK: ");
          parse_end_ptr = line_ptr + (signed long int)return_value_strlen$10;
          parse_begin_ptr = parse_end_ptr;
          count = 0;
          for( ; !((signed int)*parse_end_ptr == 0); parse_end_ptr = parse_end_ptr + 1l)
            if((signed int)*parse_end_ptr == 32)
            {
              switch(count)
              {
                case 0:
                {
                  bssid = parse_begin_ptr;
                  break;
                }
                case 1:
                {
                  type = parse_begin_ptr;
                  break;
                }
                case 2:
                {
                  channel = parse_begin_ptr;
                  break;
                }
                case 3:
                {
                  if((signed int)*parse_begin_ptr == 1)
                  {
                    parse_begin_ptr = parse_begin_ptr + 1l;
                    parse_end_ptr=strchr(parse_begin_ptr, 1);
                    *parse_end_ptr = (char)0;
                    count = count + 1;
                  }

                  ssid = parse_begin_ptr;
                }
              }
              if(count == 4)
                break;

              *parse_end_ptr = (char)0;
              parse_begin_ptr = parse_end_ptr + (signed long int)1;
              count = count + 1;
            }

          pthread_mutex_lock(&Network_list_mutex);
          wlan_network=get_wlan_network(bssid);
          if(!(channel == ((char *)NULL)))
            wlan_network->chan=atoi(channel);

          else
            wlan_network->chan = 0;
          if(!(type == ((char *)NULL)))
            wlan_network->type=atoi(type);

          else
            wlan_network->type = 0;
          if(!(wlan_network->ssid == ((char *)NULL)))
            free((void *)wlan_network->ssid);

          unsigned long int return_value_strlen$11;
          return_value_strlen$11=strlen(ssid);
          void *return_value_alloc_memory$12;
          return_value_alloc_memory$12=alloc_memory((signed int)return_value_strlen$11);
          wlan_network->ssid = (char *)return_value_alloc_memory$12;
          strcpy(wlan_network->ssid, ssid);
          pthread_mutex_unlock(&Network_list_mutex);
        }

        else
        {
          return_value_strlen$16=strlen("*CLIENT: ");
          return_value_strncmp$17=strncmp(line_ptr, "*CLIENT: ", return_value_strlen$16);
          if(return_value_strncmp$17 == 0)
          {
            unsigned long int return_value_strlen$13;
            return_value_strlen$13=strlen("*CLIENT: ");
            parse_end_ptr = line_ptr + (signed long int)return_value_strlen$13;
            parse_begin_ptr = parse_end_ptr;
            count = 0;
            for( ; !((signed int)*parse_end_ptr == 0); parse_end_ptr = parse_end_ptr + 1l)
              if((signed int)*parse_end_ptr == 32)
              {
                switch(count)
                {
                  case 0:
                  {
                    bssid = parse_begin_ptr;
                    break;
                  }
                  case 1:
                  {
                    mac = parse_begin_ptr;
                    break;
                  }
                  case 2:
                    ip = parse_begin_ptr;
                }
                if(count == 2)
                  break;

                *parse_end_ptr = (char)0;
                parse_begin_ptr = parse_end_ptr + (signed long int)1;
                count = count + 1;
              }

            wlan_client=get_wlan_client(mac);
            strncpy(wlan_client->bssid, bssid, (unsigned long int)18);
            strncpy(wlan_client->ip, ip, (unsigned long int)16);
            wlan_network=find_wlan_network(wlan_client->bssid);
            if(!(wlan_client->wlan_network == wlan_network))
            {
              if(!(wlan_client->wlan_network == ((struct wlan_network *)NULL)))
              {
                wlan_client->wlan_network->num_wlan_clients = wlan_client->wlan_network->num_wlan_clients - 1;
                wlan_client->wlan_network->props_changed = 1;
              }

              if(!(wlan_network == ((struct wlan_network *)NULL)))
              {
                wlan_network->num_wlan_clients = wlan_network->num_wlan_clients + 1;
                wlan_network->props_changed = 1;
              }

              wlan_client->wlan_network = wlan_network;
            }

          }

          else
          {
            return_value_strlen$14=strlen("*ALERT: ");
            return_value_strncmp$15=strncmp(line_ptr, "*ALERT: ", return_value_strlen$14);
          }
        }
      }
      *last_cr_ptr = (char)10;
      line_ptr = last_cr_ptr + (signed long int)1;
    }

  unsigned long int return_value_strlen$22;
  if(!(last_cr_ptr == ((char *)NULL)))
  {
    return_value_strlen$22=strlen(last_cr_ptr);
    memmove((void *)kismet_src->recv_buff, (const void *)(last_cr_ptr + (signed long int)1), return_value_strlen$22);
  }

}

// s3d_angle_to_cam
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 234
float s3d_angle_to_cam(const float *obj_pos, const float *cam_pos, float *angle_rad)
{
  float angle;
  float tmp_mov_vec[3l];
  float desc_norm_vec[3l] = { (float)0.0, (float)0.0, (float)-1.0 };
  tmp_mov_vec[(signed long int)0] = cam_pos[(signed long int)0] - obj_pos[(signed long int)0];
  tmp_mov_vec[(signed long int)1] = (float)0;
  tmp_mov_vec[(signed long int)2] = cam_pos[(signed long int)2] - obj_pos[(signed long int)2];
  angle=s3d_vector_angle(desc_norm_vec, tmp_mov_vec);
  if(tmp_mov_vec[0l] > 0.000000f)
  {
    *angle_rad = (float)(90.0 / 3.14159265358979323846 - (double)angle);
    angle = (float)((double)180 - (180.0 / 3.14159265358979323846) * (double)angle);
  }

  else
  {
    *angle_rad = (float)(90.0 / 3.14159265358979323846 + (double)angle);
    angle = (float)((double)180 + (180.0 / 3.14159265358979323846) * (double)angle);
  }
  return angle;
}

// s3d_clear_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/callback.c line 89
void s3d_clear_callback(unsigned char event)
{
  s3d_cb_list[(signed long int)(signed int)event] = (signed int (*)(struct s3d_evt *))(void *)0;
}

// s3d_clone
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 209
signed int s3d_clone(signed int oid)
{
  unsigned int res;
  signed int return_value_s3d_new_object$1;
  return_value_s3d_new_object$1=s3d_new_object();
  res = (unsigned int)return_value_s3d_new_object$1;
  s3d_clone_target((signed int)res, oid);
  return (signed int)res;
}

// s3d_clone_target
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 78
signed int s3d_clone_target(signed int oid, signed int toid)
{
  unsigned int buf[2l];
  buf[(signed long int)0]=htonl((unsigned int)oid);
  buf[(signed long int)1]=htonl((unsigned int)toid);
  net_send((unsigned char)5, (char *)&buf, (unsigned short int)8);
  return oid;
}

// s3d_del_object
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 207
signed int s3d_del_object(signed int oid)
{
  unsigned int res;
  res=htonl((unsigned int)oid);
  net_send((unsigned char)4, (char *)&res, (unsigned short int)4);
  return oid;
}

// s3d_delete_event
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/event.c line 99
signed int s3d_delete_event(struct s3d_evt *devt)
{
  struct s3d_evt *previous = (struct s3d_evt *)(void *)0;
  struct s3d_evt *p = s3d_stack;
  for( ; !(p == ((struct s3d_evt *)NULL)); p = p->next)
  {
    if(p == devt)
    {
      if(p->length >= 1)
        free((void *)p->buf);

      if(previous == ((struct s3d_evt *)NULL))
        s3d_stack = p->next;

      else
        previous->next = p->next;
      free((void *)p);
    }

    previous = p;
  }
  return -1;
}

// s3d_draw_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 225
signed int s3d_draw_string(const char *str, float *xlen)
{
  signed int i;
  float xoff;
  signed int voff;
  signed int len;
  unsigned int f_oid;
  signed int return_value_s3d_ft_init$1;
  if(ft_init == 0)
  {
    return_value_s3d_ft_init$1=s3d_ft_init();
    if(return_value_s3d_ft_init$1 == 0)
      goto __CPROVER_DUMP_L1;

    errds(5, "s3d_draw_string()", "error in initializtation (ft_init())");
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(face_init == 0)
    {
      errds(5, "s3d_draw_string()", "no font to draw with");
      return -1;
    }

    else
    {
      signed int return_value_s3d_new_object$2;
      return_value_s3d_new_object$2=s3d_new_object();
      f_oid = (unsigned int)return_value_s3d_new_object$2;
      s3d_push_material((signed int)f_oid, (float)1.0, (float)1.0, (float)1.0, (float)1.0, (float)1.0, (float)1.0, (float)1.0, (float)1.0, (float)1.0);
      xoff = (float)0;
      voff = 0;
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(str);
      len = (signed int)return_value_strlen$3;
      i = 0;
      for( ; !(i >= len); i = i + 1)
        _s3d_draw_tessbuf((signed int)f_oid, (unsigned short int)(unsigned char)str[(signed long int)i], &voff, &xoff);
      if(!(xlen == ((float *)NULL)))
        *xlen = xoff;

      return (signed int)f_oid;
    }
  }
}

// s3d_find_event
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/event.c line 83
struct s3d_evt * s3d_find_event(unsigned char event)
{
  struct s3d_evt *p = s3d_stack;
  for( ; !(p == ((struct s3d_evt *)NULL)); p = p->next)
    if(p->event == event)
      return p;

  return (struct s3d_evt *)(void *)0;
}

// s3d_findfont
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/fontselect.c line 42
char * s3d_findfont(const char *mask)
{
  struct _FcPattern *pattern = (struct _FcPattern *)(void *)0;
  struct _FcPattern *match = (struct _FcPattern *)(void *)0;
  unsigned char *file = (unsigned char *)(void *)0;
  enum _FcResult result;
  pattern=FcNameParse((unsigned char *)mask);
  FcConfigSubstitute((struct _FcConfig *)(void *)0, pattern, (enum _FcMatchKind)FcMatchPattern);
  FcDefaultSubstitute(pattern);
  s3dprintf$link1(2, "Looking for font %s", mask);
  match=FcFontMatch((struct _FcConfig *)(void *)0, pattern, &result);
  if(match == ((struct _FcPattern *)NULL))
    return (char *)(void *)0;

  else
  {
    enum _FcResult return_value_FcPatternGetString$1;
    return_value_FcPatternGetString$1=FcPatternGetString(match, "file", 0, &file);
    if(!((signed int)return_value_FcPatternGetString$1 == FcResultMatch))
      return (char *)(void *)0;

    else
      return (char *)file;
  }
}

// s3d_flags_off
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 216
signed int s3d_flags_off(signed int object, unsigned int flags)
{
  char buf[9l];
  char *ptr;
  signed int len = 4 + 1 + 4;
  ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *ptr = (char)2;
  ptr = ptr + (signed long int)sizeof(unsigned char) /*1ul*/ ;
  *((unsigned int *)ptr)=htonl(flags);
  net_send((unsigned char)32, buf, (unsigned short int)len);
  return 0;
}

// s3d_flags_on
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 215
signed int s3d_flags_on(signed int object, unsigned int flags)
{
  char buf[9l];
  char *ptr;
  signed int len = 4 + 1 + 4;
  ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *ptr = (char)1;
  ptr = ptr + (signed long int)sizeof(unsigned char) /*1ul*/ ;
  *((unsigned int *)ptr)=htonl(flags);
  net_send((unsigned char)32, buf, (unsigned short int)len);
  return 0;
}

// s3d_ft_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 63
static signed int s3d_ft_init(void)
{
  signed int error;
  error=FT_Init_FreeType(&library);
  signed int i;
  oldfontpath[(signed long int)0] = (char)0;
  if(!(error == 0))
    return -1;

  else
  {
    ft_init = 1;
    i = 0;
    for( ; !(i >= 256); i = i + 1)
    {
      tess_buf[(signed long int)i].vbuf = (float *)(void *)0;
      tess_buf[(signed long int)i].pbuf = (unsigned int *)(void *)0;
    }
    return 0;
  }
}

// s3d_ft_init$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 63
static signed int s3d_ft_init$link1(void)
{
  signed int error$link1;
  error$link1=FT_Init_FreeType(&library$link1);
  signed int i$link1;
  oldfontpath$link1[(signed long int)0] = (char)0;
  if(!(error$link1 == 0))
    return -1;

  else
  {
    ft_init$link1 = 1;
    i$link1 = 0;
    for( ; !(i$link1 >= 256); i$link1 = i$link1 + 1)
    {
      tess_buf$link1[(signed long int)i$link1].vbuf = (float *)(void *)0;
      tess_buf$link1[(signed long int)i$link1].pbuf = (unsigned int *)(void *)0;
    }
    return 0;
  }
}

// s3d_ft_load_font
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 79
static signed int s3d_ft_load_font(void)
{
  signed int error;
  if(memory_font == ((char *)NULL) || memory_font_size == 0)
  {
    errds(4, "s3d_ft_load_font()", "there is no font in memory, breaking");
    return -1;
  }

  else
  {
    face_init = 0;
    error=FT_New_Memory_Face(library, (unsigned char *)memory_font, (signed long int)memory_font_size, (signed long int)0, &face);
    if(!(error == 0))
    {
      errds(5, "s3d_ft_load_font():FT_New_Memory_Face", "can't load font : (%d) %s", ft_errors[(signed long int)error].err_code, ft_errors[(signed long int)error].err_msg);
      return -1;
    }

    else
    {
      s3dprintf$link1(2, "Load Font successful ...");
      face_init = 1;
      return 0;
    }
  }
}

// s3d_ft_load_font$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/freetype.c line 79
static signed int s3d_ft_load_font$link1(void)
{
  signed int error$link1;
  if(memory_font$link1 == ((char *)NULL) || memory_font_size$link1 == 0)
  {
    errds$link1(4, "s3d_ft_load_font()", "there is no font in memory, breaking");
    return -1;
  }

  else
  {
    face_init$link1 = 0;
    error$link1=FT_New_Memory_Face(library$link1, (unsigned char *)memory_font$link1, (signed long int)memory_font_size$link1, (signed long int)0, &face$link1);
    if(!(error$link1 == 0))
    {
      errds$link1(5, "s3d_ft_load_font():FT_New_Memory_Face", "can't load font : (%d) %s", ft_errors$link1[(signed long int)error$link1].err_code, ft_errors$link1[(signed long int)error$link1].err_msg);
      return -1;
    }

    else
    {
      s3dprintf$link2(2, "Load Font successful ...");
      face_init$link1 = 1;
      return 0;
    }
  }
}

// s3d_get_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/callback.c line 115
signed int (*s3d_get_callback(unsigned char event))(struct s3d_evt *)
{
  return s3d_cb_list[(signed long int)(signed int)event];
}

// s3d_ignore_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/callback.c line 99
void s3d_ignore_callback(unsigned char event)
{
  s3d_set_callback(event, _s3d_ignore);
}

// s3d_import_model_file
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 222
signed int s3d_import_model_file(const char *fname)
{
  char *buf;
  char *ptr;
  char *next;
  char searchpath[1024l];
  char path[1024l];
  signed int oid;
  if(fname == ((const char *)NULL))
    return -1;

  else
  {
    strncpy(searchpath, ":./:../:../../:/usr/local/share/s3d/:/usr/share/s3d/", (unsigned long int)1023);
    searchpath[(signed long int)1023] = (char)0;
    ptr = searchpath;
    next = ptr;
    while(!(next == ((char *)NULL)))
    {
      next = (char *)(void *)0;
      next=strchr(ptr, 58);
      if(!(next == ((char *)NULL)))
      {
        *next = (char)0;
        next = next + (signed long int)1;
      }

      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(ptr);
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(fname);
      if(!(return_value_strlen$2 + return_value_strlen$3 >= 1024ul))
      {
        strcpy(path, ptr);
        strcat(path, fname);
        signed int return_value_s3d_open_file$1;
        return_value_s3d_open_file$1=s3d_open_file(path, &buf);
        if(!(return_value_s3d_open_file$1 == -1))
        {
          free((void *)buf);
          oid=model_load(path);
          if(!(oid == -1))
            return oid;

        }

      }

      if(!(next == ((char *)NULL)))
        ptr = next;

    }
    errds(2, "s3d_import_model_file()", "Could not open %s", fname);
    return -1;
  }
}

// s3d_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 153
signed int s3d_init(signed int *argc, char ***argv, const char *name)
{
  char *s;
  char urlc[256l];
  char buf[258l];
  signed int i;
  struct timespec s3d_init$$1$$t = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)(100 * 1000 * 1000) };
  cb_lock = 1;
  s=getenv("S3D");
  if(!(s == ((char *)NULL)))
  {
    s3dprintf$link1(1, "at least we have the environment variable ... %s", s);
    url = s;
  }

  parse_args(argc, argv);
  if(url == ((char *)NULL))
  {
    strncpy(urlc, "s3d:///tmp/.s3d:shm/", (unsigned long int)256);
    signed int return_value_s3d_net_init$2;
    return_value_s3d_net_init$2=s3d_net_init(urlc);
    if(return_value_s3d_net_init$2 == 0)
    {
      strncpy(urlc, "s3d://127.0.0.1:6066/", (unsigned long int)256);
      signed int return_value_s3d_net_init$1;
      return_value_s3d_net_init$1=s3d_net_init(urlc);
      if(return_value_s3d_net_init$1 == 0)
        return -1;

    }

  }

  else
  {
    strncpy(urlc, url, (unsigned long int)256);
    urlc[(signed long int)255] = (char)0;
    signed int return_value_strncmp$4;
    return_value_strncmp$4=strncmp(urlc, "s3d:// ", (unsigned long int)6);
    if(return_value_strncmp$4 == 0)
    {
      signed int return_value_s3d_net_init$3;
      return_value_s3d_net_init$3=s3d_net_init(urlc);
      if(return_value_s3d_net_init$3 == 0)
        return -1;

    }

    else
    {
      errs("s3d_init()", "invalid url");
      return -1;
    }
  }
  strncpy(buf, name, (unsigned long int)256);
  unsigned long int return_value_strlen$5;
  return_value_strlen$5=strlen(buf);
  net_send((unsigned char)1, buf, (unsigned short int)return_value_strlen$5);
  _queue_init();
  _s3d_texture_init();
  void (*return_value_signal$7)(signed int);
  return_value_signal$7=signal(2, (void (*)(signed int))sigint_handler);
  signed int *return_value___errno_location$6;
  if(return_value_signal$7 == (void (*)(signed int))-1)
  {
    return_value___errno_location$6=__errno_location();
    errdn(2, "s3d_init():signal()", *return_value___errno_location$6);
  }

  void (*return_value_signal$9)(signed int);
  return_value_signal$9=signal(15, (void (*)(signed int))sigint_handler);
  signed int *return_value___errno_location$8;
  if(return_value_signal$9 == (void (*)(signed int))-1)
  {
    return_value___errno_location$8=__errno_location();
    errdn(2, "s3d_init():signal()", *return_value___errno_location$8);
  }

  i = 0;
  for( ; !(i >= 100); i = i + 1)
  {
    s3d_net_check();
    nanosleep(&s3d_init$$1$$t, (struct timespec *)(void *)0);
    if(!(_s3d_ready == 0))
    {
      cb_lock = cb_lock - 1;
      return 0;
    }

  }
  return -1;
}

// s3d_link
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 212
signed int s3d_link(signed int oid_from, signed int oid_to)
{
  unsigned int buf[2l];
  buf[(signed long int)0]=htonl((unsigned int)oid_from);
  buf[(signed long int)1]=htonl((unsigned int)oid_to);
  net_send((unsigned char)6, (char *)buf, (unsigned short int)8);
  return 0;
}

// s3d_load_line_normals
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 201
signed int s3d_load_line_normals(signed int object, const float *nbuf, unsigned int start, unsigned short int n)
{
  char buf[65534l];
  char *ptr;
  signed int f;
  signed int i;
  signed int len = (signed int)n * 6 * 4;
  signed int flen;
  signed int stepl;
  unsigned int mstart;
  if(!((signed int)n >= 1))
    return -1;

  else
  {
    mstart = start;
    stepl = (signed int)((65530 - 8) / (6 * 4)) * 6 * 4;
    f = len / (65530 - 8) + 1;
    i = 0;
    for( ; !(i >= f); i = i + 1)
    {
      ptr = buf;
      *((unsigned int *)ptr)=htonl((unsigned int)object);
      ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
      *((unsigned int *)ptr)=htonl(mstart);
      ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
      if(!(stepl >= len + -(i * stepl)))
        flen = stepl;

      else
        flen = len - i * stepl;
      memcpy((void *)ptr, (const void *)((char *)nbuf + (signed long int)(i * stepl)), (unsigned long int)flen);
      htonfb((float *)ptr, flen / 4);
      net_send((unsigned char)30, buf, (unsigned short int)(flen + 8));
      mstart = mstart + (unsigned int)stepl;
    }
    return 0;
  }
}

// s3d_load_materials_a
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 1013
signed int s3d_load_materials_a(signed int object, const float *mbuf, unsigned int start, unsigned short int n)
{
  char buf[65534l];
  char *ptr;
  signed int f;
  signed int i;
  signed int len = (signed int)n * 12 * 4;
  signed int flen;
  signed int stepl;
  unsigned int mstart;
  if(!((signed int)n >= 1))
    return -1;

  else
  {
    mstart = start;
    stepl = (signed int)((65530 - 8) / (12 * 4)) * 12 * 4;
    f = len / (65530 - 8) + 1;
    i = 0;
    for( ; !(i >= f); i = i + 1)
    {
      ptr = buf;
      *((unsigned int *)ptr)=htonl((unsigned int)object);
      ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
      *((unsigned int *)ptr)=htonl(mstart);
      ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
      if(!(stepl >= len + -(i * stepl)))
        flen = stepl;

      else
        flen = len - i * stepl;
      memcpy((void *)ptr, (const void *)((char *)mbuf + (signed long int)(i * stepl)), (unsigned long int)flen);
      htonfb((float *)ptr, flen / 4);
      net_send((unsigned char)26, buf, (unsigned short int)(flen + 8));
      mstart = mstart + (unsigned int)stepl;
    }
    return 0;
  }
}

// s3d_load_polygon_normals
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 911
signed int s3d_load_polygon_normals(signed int object, const float *nbuf, unsigned int start, unsigned short int n)
{
  char buf[65534l];
  char *ptr;
  signed int f;
  signed int i;
  signed int len = (signed int)n * 9 * 4;
  signed int flen;
  signed int stepl;
  unsigned int mstart;
  if(!((signed int)n >= 1))
    return -1;

  else
  {
    mstart = start;
    stepl = (signed int)((65530 - 8) / (9 * 4)) * 9 * 4;
    f = len / (65530 - 8) + 1;
    i = 0;
    for( ; !(i >= f); i = i + 1)
    {
      ptr = buf;
      *((unsigned int *)ptr)=htonl((unsigned int)object);
      ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
      *((unsigned int *)ptr)=htonl(mstart);
      ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
      if(!(stepl >= len + -(i * stepl)))
        flen = stepl;

      else
        flen = len - i * stepl;
      memcpy((void *)ptr, (const void *)((char *)nbuf + (signed long int)(i * stepl)), (unsigned long int)flen);
      htonfb((float *)ptr, flen / 4);
      net_send((unsigned char)24, buf, (unsigned short int)(flen + 8));
      mstart = mstart + (unsigned int)stepl;
    }
    return 0;
  }
}

// s3d_load_polygon_tex_coords
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 979
signed int s3d_load_polygon_tex_coords(signed int object, const float *tbuf, unsigned int start, unsigned short int n)
{
  char buf[65534l];
  char *ptr;
  signed int f;
  signed int i;
  signed int len = (signed int)n * 6 * 4;
  signed int flen;
  signed int stepl;
  unsigned int mstart;
  if(!((signed int)n >= 1))
    return -1;

  else
  {
    mstart = start;
    stepl = (signed int)((65530 - 8) / (6 * 4)) * 6 * 4;
    f = len / (65530 - 8) + 1;
    i = 0;
    for( ; !(i >= f); i = i + 1)
    {
      ptr = buf;
      *((unsigned int *)ptr)=htonl((unsigned int)object);
      ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
      *((unsigned int *)ptr)=htonl(mstart);
      ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
      if(!(stepl >= len + -(i * stepl)))
        flen = stepl;

      else
        flen = len - i * stepl;
      memcpy((void *)ptr, (const void *)((char *)tbuf + (signed long int)(i * stepl)), (unsigned long int)flen);
      htonfb((float *)ptr, flen / 4);
      net_send((unsigned char)25, buf, (unsigned short int)(flen + 8));
      mstart = mstart + (unsigned int)stepl;
    }
    return 0;
  }
}

// s3d_load_texture
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 1089
signed int s3d_load_texture(signed int object, unsigned int tex, unsigned short int xpos, unsigned short int ypos, unsigned short int w, unsigned short int h, const unsigned char *data)
{
  char buf[65534l];
  char *ptr;
  signed int linestep;
  signed int lines;
  signed int i;
  signed int return_value__s3d_load_texture_shm$1;
  return_value__s3d_load_texture_shm$1=_s3d_load_texture_shm(object, tex, xpos, ypos, w, h, data);
  if(return_value__s3d_load_texture_shm$1 == 0)
  {
    _s3d_update_texture(object, tex, xpos, ypos, w, h);
    return 0;
  }

  else
  {
    linestep = (65530 - 16) / ((signed int)w * 4);
    if(linestep == 0)
      return -1;

    else
    {
      i = 0;
      for( ; !(i >= (signed int)h); i = i + linestep)
      {
        ptr = buf;
        *((unsigned int *)ptr)=htonl((unsigned int)object);
        ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
        *((unsigned int *)ptr)=htonl(tex);
        ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
        *((unsigned short int *)ptr)=htons(xpos);
        ptr = ptr + (signed long int)sizeof(unsigned short int) /*2ul*/ ;
        *((unsigned short int *)ptr)=htons((unsigned short int)((signed int)ypos + i));
        ptr = ptr + (signed long int)sizeof(unsigned short int) /*2ul*/ ;
        *((unsigned short int *)ptr)=htons(w);
        ptr = ptr + (signed long int)sizeof(unsigned short int) /*2ul*/ ;
        if(!(linestep >= (signed int)h + -i))
          lines = linestep;

        else
          lines = (signed int)h - i;
        *((unsigned short int *)ptr)=htons((unsigned short int)lines);
        ptr = ptr + (signed long int)sizeof(unsigned short int) /*2ul*/ ;
        memcpy((void *)ptr, (const void *)(data + (signed long int)(i * (signed int)w * 4)), (unsigned long int)(lines * (signed int)w * 4));
        net_send((unsigned char)28, buf, (unsigned short int)(16 + lines * (signed int)w * 4));
      }
      return 0;
    }
  }
}

// s3d_mainloop
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 155
signed int s3d_mainloop(void (*f)(void))
{
  while(!(con_type == 0))
  {
    cb_lock = cb_lock + 1;
    if(!(f == ((void (*)(void))NULL)))
      f();

    cb_lock = cb_lock - 1;
    s3d_process_stack();
    s3d_net_check();
  }
  return 0;
}

// s3d_mcp_focus
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 1265
signed int s3d_mcp_focus(signed int object)
{
  unsigned int buf;
  buf=htonl((unsigned int)object);
  net_send((unsigned char)66, (char *)&buf, (unsigned short int)4);
  return 0;
}

// s3d_net_check
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/network.c line 75
signed int s3d_net_check(void)
{
  signed int return_value__s3d_net_receive$1;
  signed int return_value__shm_net_receive$2;
  switch(con_type)
  {
    case 2:
    {
      if(!(_s3d_sigio == 0))
      {
        do
        {
          return_value__s3d_net_receive$1=_s3d_net_receive();
          if(return_value__s3d_net_receive$1 == 0)
            break;

        }
        while((_Bool)1);
        _s3d_sigio = 0;
      }

      break;
    }
    case 1:
      do
      {
        return_value__shm_net_receive$2=_shm_net_receive();
        if(return_value__shm_net_receive$2 == 0)
          break;

      }
      while((_Bool)1);
  }
  s3d_process_stack();
  return 0;
}

// s3d_net_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/network.c line 99
signed int s3d_net_init(char *urlc)
{
  char *s;
  char *sv;
  char *port = (char *)(void *)0;
  char *first_slash = (char *)(void *)0;
  signed int pn = 0;
  signed int tcp;
  signed int shm = 1;
  tcp = shm;
  sv = urlc + (signed long int)6;
  s = sv;
  for( ; !((signed int)*s == 0); s = s + 1l)
  {
    if((signed int)*s == 47)
    {
      if(first_slash == ((char *)NULL))
        first_slash = s;

      if(!(port == ((char *)NULL)))
        break;

    }

    if((signed int)*s == 58)
    {
      port = s + (signed long int)1;
      *s = (char)0;
    }

  }
  *s = (char)0;
  if(port == ((char *)NULL))
  {
    shm = 0;
    if(!(first_slash == ((char *)NULL)))
      *first_slash = (char)0;

  }

  else
  {
    if(!(first_slash >= port))
      tcp = 0;

    else
      if(!(first_slash == ((char *)NULL)))
        *first_slash = (char)0;

    signed int return_value_strncmp$1;
    return_value_strncmp$1=strncmp(port, "shm", (unsigned long int)3);
    if(return_value_strncmp$1 == 0)
      tcp = 0;

    else
      shm = 0;
  }
  signed int return_value__shm_init$2;
  if(!(shm == 0))
  {
    signed int return_value_strncmp$3;
    return_value_strncmp$3=strncmp(port, "shm", (unsigned long int)3);
    if(return_value_strncmp$3 == 0)
    {
      return_value__shm_init$2=_shm_init(sv);
      if(return_value__shm_init$2 == 0)
      {
        con_type = 1;
        return con_type;
      }

    }

  }

  if(!(tcp == 0))
  {
    pn = 6066;
    if(!(port == ((char *)NULL)))
    {
      pn=atoi(port);
      if(pn == 0)
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        errn("s3d_init():atoi()", *return_value___errno_location$4);
        pn = 6066;
      }

    }

    signed int return_value__tcp_init$5;
    return_value__tcp_init$5=_tcp_init(sv, pn);
    if(return_value__tcp_init$5 == 0)
    {
      con_type = 2;
      return con_type;
    }

  }

  return 0;
}

// s3d_new_object
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 206
signed int s3d_new_object(void)
{
  signed int oid;
  cb_lock = cb_lock + 1;
  unsigned int return_value__queue_want_object$1;
  return_value__queue_want_object$1=_queue_want_object();
  oid = (signed int)return_value__queue_want_object$1;
  cb_lock = cb_lock - 1;
  return oid;
}

// s3d_open_file
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/io.c line 271
signed int s3d_open_file(const char *fname, char **pointer)
{
  struct _IO_FILE *fp;
  char *buf = (char *)(void *)0;
  unsigned long int filesize;
  unsigned long int read_items;
  struct stat bf;
  *pointer = (char *)(void *)0;
  fp=fopen(fname, "rb");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    errdn(1, "s3d_open_file():fopen()", *return_value___errno_location$1);
    return -1;
  }

  signed int return_value_fileno$3;
  return_value_fileno$3=fileno(fp);
  signed int return_value_fstat$4;
  return_value_fstat$4=fstat(return_value_fileno$3, &bf);
  if(!(return_value_fstat$4 == 0))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    errdn(1, "s3d_open_file():fstat()", *return_value___errno_location$2);
    fclose(fp);
    return -1;
  }

  filesize = (unsigned long int)bf.st_size;
  void *return_value_malloc$6;
  return_value_malloc$6=malloc(filesize);
  buf = (char *)return_value_malloc$6;
  if(buf == ((char *)NULL))
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    errn("s3d_open_3ds_file():malloc()", *return_value___errno_location$5);
    exit(-1);
  }

  read_items=fread((void *)buf, (unsigned long int)1, filesize, fp);
  fclose(fp);
  if(!(read_items == filesize))
  {
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    errdn(1, "s3d_open_file():fread()", *return_value___errno_location$7);
    free((void *)buf);
    return -1;
  }

  *pointer = buf;
  return (signed int)filesize;
}

// s3d_pep_line
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 794
signed int s3d_pep_line(signed int object, signed int v1, signed int v2, signed int material)
{
  char buf[16l];
  char *ptr;
  signed int len = 4 + 3 * 4;
  ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((unsigned int *)ptr)=htonl((unsigned int)v1);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((unsigned int *)ptr)=htonl((unsigned int)v2);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((unsigned int *)ptr)=htonl((unsigned int)material);
  net_send((unsigned char)21, buf, (unsigned short int)len);
  return 0;
}

// s3d_pep_line_normals
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 752
signed int s3d_pep_line_normals(signed int object, const float *nbuf, unsigned short int n)
{
  unsigned char buf[65534l];
  if(sizeof(float) /*4ul*/  * (unsigned long int)(9 * (signed int)n) + 4ul >= 65531ul)
  {
    errds(3, "s3d_pep_line_normals()", "too much data");
    return -1;
  }

  else
  {
    *((unsigned int *)buf)=htonl((unsigned int)object);
    memcpy((void *)(buf + (signed long int)4), (const void *)nbuf, (unsigned long int)(6 * (signed int)n) * sizeof(float) /*4ul*/ );
    htonfb((float *)(buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), 6 * (signed int)n);
    net_send((unsigned char)23, (char *)buf, (unsigned short int)((unsigned long int)((signed int)n * 6) * sizeof(float) /*4ul*/  + (unsigned long int)4));
    return 0;
  }
}

// s3d_pep_lines
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 818
signed int s3d_pep_lines(signed int object, const unsigned int *lbuf, unsigned short int n)
{
  unsigned int buf[65534l];
  signed int i;
  if(3 * (signed int)n + 4 >= 65531)
  {
    errds(3, "s3d_pep_lines()", "too much data");
    return -1;
  }

  else
  {
    buf[(signed long int)0]=htonl((unsigned int)object);
    i = 0;
    for( ; !(i >= 3 * (signed int)n); i = i + 1)
      buf[(signed long int)(i + 1)]=htonl(lbuf[(signed long int)0]);
    net_send((unsigned char)21, (char *)buf, (unsigned short int)((signed int)n * 3 * 4 + 4));
    return 0;
  }
}

// s3d_pep_material
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 605
signed int s3d_pep_material(signed int object, float amb_r, float amb_g, float amb_b, float spec_r, float spec_g, float spec_b, float diff_r, float diff_g, float diff_b)
{
  char buf[52l];
  char *ptr;
  signed int len = 4 + 4 * 12;
  ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((float *)ptr) = amb_r;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = amb_g;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = amb_b;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = (float)1.0;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = spec_r;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = spec_g;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = spec_b;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = (float)1.0;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = diff_r;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = diff_g;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = diff_b;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = (float)1.0;
  htonfb((float *)(buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), 12);
  net_send((unsigned char)18, buf, (unsigned short int)len);
  return 0;
}

// s3d_pep_material_a
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 653
signed int s3d_pep_material_a(signed int object, float amb_r, float amb_g, float amb_b, float amb_a, float spec_r, float spec_g, float spec_b, float spec_a, float diff_r, float diff_g, float diff_b, float diff_a)
{
  char buf[52l];
  char *ptr;
  signed int len = 4 + 4 * 12;
  ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((float *)ptr) = amb_r;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = amb_g;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = amb_b;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = amb_a;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = spec_r;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = spec_g;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = spec_b;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = spec_a;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = diff_r;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = diff_g;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = diff_b;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = diff_a;
  htonfb((float *)(buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), 12);
  net_send((unsigned char)18, buf, (unsigned short int)len);
  return 0;
}

// s3d_pep_material_texture
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 1047
signed int s3d_pep_material_texture(signed int object, unsigned int tex)
{
  char buf[8l];
  char *ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((unsigned int *)ptr)=htonl(tex);
  net_send((unsigned char)19, buf, (unsigned short int)8);
  return 0;
}

// s3d_pep_materials_a
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 178
signed int s3d_pep_materials_a(signed int object, const float *mbuf, unsigned short int n)
{
  char buf[65534l];
  if(sizeof(float) /*4ul*/  * (unsigned long int)(12 * (signed int)n) + 4ul >= 65531ul)
  {
    errds(3, "s3d_pep_materials_a()", "too much data");
    return -1;
  }

  else
  {
    *((unsigned int *)buf)=htonl((unsigned int)object);
    memcpy((void *)(buf + (signed long int)4), (const void *)mbuf, (unsigned long int)(12 * (signed int)n) * sizeof(float) /*4ul*/ );
    htonfb((float *)(buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), (signed int)n * 12);
    net_send((unsigned char)18, buf, (unsigned short int)((unsigned long int)((signed int)n * 12) * sizeof(float) /*4ul*/  + (unsigned long int)4));
    return 0;
  }
}

// s3d_pep_polygon_normals
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 727
signed int s3d_pep_polygon_normals(signed int object, const float *nbuf, unsigned short int n)
{
  unsigned char buf[65534l];
  if(sizeof(float) /*4ul*/  * (unsigned long int)(9 * (signed int)n) + 4ul >= 65531ul)
  {
    errds(3, "s3d_pep_polygon_normals()", "too much data");
    return -1;
  }

  else
  {
    *((unsigned int *)buf)=htonl((unsigned int)object);
    memcpy((void *)(buf + (signed long int)4), (const void *)nbuf, (unsigned long int)(9 * (signed int)n) * sizeof(float) /*4ul*/ );
    htonfb((float *)(buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), 9 * (signed int)n);
    net_send((unsigned char)16, (char *)buf, (unsigned short int)((unsigned long int)((signed int)n * 9) * sizeof(float) /*4ul*/  + (unsigned long int)4));
    return 0;
  }
}

// s3d_pep_polygon_tex_coord
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 863
signed int s3d_pep_polygon_tex_coord(signed int object, float x1, float y1, float x2, float y2, float x3, float y3)
{
  char *ptr;
  char buf[28l];
  ptr = buf;
  *((unsigned int *)buf)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((float *)ptr) = x1;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = y1;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = x2;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = y2;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = x3;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = y3;
  htonfb((float *)(buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), 6);
  net_send((unsigned char)17, (char *)buf, (unsigned short int)(6 * 4 + 4));
  return 0;
}

// s3d_pep_polygon_tex_coords
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 892
signed int s3d_pep_polygon_tex_coords(signed int object, const float *tbuf, unsigned short int n)
{
  char buf[65534l];
  if(sizeof(float) /*4ul*/  * (unsigned long int)(6 * (signed int)n) >= 65531ul)
  {
    errds(3, "s3d_pep_polygon_tex_coords()", "too much data");
    return -1;
  }

  else
  {
    *((unsigned int *)buf)=htonl((unsigned int)object);
    memcpy((void *)(buf + (signed long int)4), (const void *)tbuf, (unsigned long int)(6 * (signed int)n) * sizeof(float) /*4ul*/ );
    htonfb((float *)(buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), 6 * (signed int)n);
    net_send((unsigned char)17, (char *)buf, (unsigned short int)((unsigned long int)((signed int)n * 6) * sizeof(float) /*4ul*/  + (unsigned long int)4));
    return 0;
  }
}

// s3d_pep_vertex
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 771
signed int s3d_pep_vertex(signed int object, float x, float y, float z)
{
  char buf[16l];
  char *ptr;
  signed int len = 4 + 3 * 4;
  ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((float *)ptr) = x;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = y;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = z;
  htonfb((float *)(buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), 3);
  net_send((unsigned char)20, buf, (unsigned short int)len);
  return 0;
}

// s3d_pep_vertices
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 840
signed int s3d_pep_vertices(signed int object, const float *vbuf, unsigned short int n)
{
  unsigned char buf[65534l];
  if(sizeof(float) /*4ul*/  * (unsigned long int)(3 * (signed int)n) + 4ul >= 65531ul)
  {
    errds(3, "s3d_pep_vertices()", "too much data");
    return -1;
  }

  else
  {
    *((unsigned int *)buf)=htonl((unsigned int)object);
    memcpy((void *)(buf + (signed long int)4), (const void *)vbuf, (unsigned long int)(3 * (signed int)n) * sizeof(float) /*4ul*/ );
    htonfb((float *)(buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), 3 * (signed int)n);
    net_send((unsigned char)20, (char *)buf, (unsigned short int)((unsigned long int)((signed int)n * 3) * sizeof(float) /*4ul*/  + (unsigned long int)4));
    return 0;
  }
}

// s3d_pop_event
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/event.c line 71
struct s3d_evt * s3d_pop_event(void)
{
  struct s3d_evt *ret = s3d_stack;
  if(!(ret == ((struct s3d_evt *)NULL)))
    s3d_stack = s3d_stack->next;

  return ret;
}

// s3d_pop_line
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 575
signed int s3d_pop_line(signed int object, unsigned int n)
{
  unsigned int buf[2l];
  buf[(signed long int)0]=htonl((unsigned int)object);
  buf[(signed long int)1]=htonl(n);
  net_send((unsigned char)22, (char *)buf, (unsigned short int)(4 * 2));
  return 0;
}

// s3d_pop_material
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 547
signed int s3d_pop_material(signed int object, unsigned int n)
{
  unsigned int buf[2l];
  buf[(signed long int)0]=htonl((unsigned int)object);
  buf[(signed long int)1]=htonl(n);
  net_send((unsigned char)14, (char *)buf, (unsigned short int)(4 * 2));
  return 0;
}

// s3d_pop_polygon
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 561
signed int s3d_pop_polygon(signed int object, unsigned int n)
{
  unsigned int buf[2l];
  buf[(signed long int)0]=htonl((unsigned int)object);
  buf[(signed long int)1]=htonl(n);
  net_send((unsigned char)13, (char *)buf, (unsigned short int)(4 * 2));
  return 0;
}

// s3d_pop_texture
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 589
signed int s3d_pop_texture(signed int object, unsigned int n)
{
  unsigned int buf[2l];
  buf[(signed long int)0]=htonl((unsigned int)object);
  buf[(signed long int)1]=htonl(n);
  net_send((unsigned char)15, (char *)buf, (unsigned short int)(4 * 2));
  return 0;
}

// s3d_pop_vertex
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 533
signed int s3d_pop_vertex(signed int object, unsigned int n)
{
  unsigned int buf[2l];
  buf[(signed long int)0]=htonl((unsigned int)object);
  buf[(signed long int)1]=htonl(n);
  net_send((unsigned char)12, (char *)buf, (unsigned short int)(4 * 2));
  return 0;
}

// s3d_process_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/event.c line 129
void s3d_process_stack(void)
{
  struct s3d_evt *p;
  signed int (*cb)(struct s3d_evt *);
  if(cb_lock >= 1)
    s3dprintf$link1(1, "cb_lock = %d, processing later", cb_lock);

  else
  {
    s3dprintf$link1(1, "processing stack ...");
    do
    {
      p=s3d_pop_event();
      if(p == ((struct s3d_evt *)NULL))
        break;

      cb=s3d_get_callback(p->event);
      if(!(cb == ((signed int (*)(struct s3d_evt *))NULL)))
      {
        cb_lock = cb_lock + 1;
        cb(p);
        cb_lock = cb_lock - 1;
      }

      if(p->length >= 1)
        free((void *)p->buf);

      free((void *)p);
    }
    while((_Bool)1);
  }
}

// s3d_push_event
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/event.c line 38
void s3d_push_event(struct s3d_evt *newevt)
{
  struct s3d_evt *p;
  signed int (*cb)(struct s3d_evt *);
  s3dprintf$link1(1, "pushed event %d, cb_lock = %d", newevt->event, cb_lock);
  if((signed int)newevt->event == 16)
    _queue_new_object(*((unsigned int *)newevt->buf));

  if(cb_lock == 0)
  {
    cb=s3d_get_callback(newevt->event);
    if(cb == ((signed int (*)(struct s3d_evt *))NULL))
      goto __CPROVER_DUMP_L2;

    cb_lock = cb_lock + 1;
    cb(newevt);
    cb_lock = cb_lock - 1;
    free((void *)newevt);
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    newevt->next = (struct s3d_evt *)(void *)0;
    if(!(s3d_stack == ((struct s3d_evt *)NULL)))
    {
      p = s3d_stack;
      for( ; !(p->next == ((struct s3d_evt *)NULL)); p = p->next)
        ;
      p->next = newevt;
    }

    else
      s3d_stack = newevt;
  }
}

// s3d_push_line
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 381
signed int s3d_push_line(signed int object, unsigned int v1, unsigned int v2, unsigned int material)
{
  char buf[16l];
  char *ptr;
  signed int len = 4 + 3 * 4;
  ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((unsigned int *)ptr)=htonl(v1);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((unsigned int *)ptr)=htonl(v2);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((unsigned int *)ptr)=htonl(material);
  net_send((unsigned char)7, buf, (unsigned short int)len);
  return 0;
}

// s3d_push_lines
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 183
signed int s3d_push_lines(signed int object, const unsigned int *lbuf, unsigned short int n)
{
  unsigned int buf[16383l];
  const unsigned int *s;
  unsigned int *d;
  signed int f;
  signed int i;
  signed int j;
  signed int len = (signed int)n * 4 * 3;
  signed int flen;
  signed int stepl;
  if(!((signed int)n >= 1))
    return -1;

  else
  {
    stepl = (signed int)((65530 - 4) / (4 * 3)) * 4 * 3;
    f = len / (65530 - 4) + 1;
    buf[(signed long int)0]=htonl((unsigned int)object);
    d = buf + (signed long int)1;
    i = 0;
    for( ; !(i >= f); i = i + 1)
    {
      if(!(stepl >= len + -(i * stepl)))
        flen = stepl;

      else
        flen = len - i * stepl;
      s = lbuf + (signed long int)((i * stepl) / 4);
      j = 0;
      for( ; !(j >= flen / 4); j = j + 1)
        d[(signed long int)j]=htonl(s[(signed long int)j]);
      net_send((unsigned char)7, (char *)buf, (unsigned short int)(flen + 4));
    }
    return 0;
  }
}

// s3d_push_material
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 160
signed int s3d_push_material(signed int object, float amb_r, float amb_g, float amb_b, float spec_r, float spec_g, float spec_b, float diff_r, float diff_g, float diff_b)
{
  char buf[52l];
  char *ptr;
  signed int len = 4 + 4 * 12;
  ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((float *)ptr) = amb_r;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = amb_g;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = amb_b;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = (float)1.0;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = spec_r;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = spec_g;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = spec_b;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = (float)1.0;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = diff_r;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = diff_g;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = diff_b;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = (float)1.0;
  htonfb((float *)(buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), 12);
  net_send((unsigned char)9, buf, (unsigned short int)len);
  return 0;
}

// s3d_push_material_a
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 248
signed int s3d_push_material_a(signed int object, float amb_r, float amb_g, float amb_b, float amb_a, float spec_r, float spec_g, float spec_b, float spec_a, float diff_r, float diff_g, float diff_b, float diff_a)
{
  char buf[52l];
  char *ptr;
  signed int len = 4 + 4 * 12;
  ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((float *)ptr) = amb_r;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = amb_g;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = amb_b;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = amb_a;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = spec_r;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = spec_g;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = spec_b;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = spec_a;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = diff_r;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = diff_g;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = diff_b;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = diff_a;
  htonfb((float *)(buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), 12);
  net_send((unsigned char)9, buf, (unsigned short int)len);
  return 0;
}

// s3d_push_materials_a
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 172
signed int s3d_push_materials_a(signed int object, const float *mbuf, unsigned short int n)
{
  char buf[65534l];
  char *ptr;
  signed int f;
  signed int i;
  signed int len = (signed int)n * 4 * 12;
  signed int flen;
  signed int stepl;
  if(!((signed int)n >= 1))
    return -1;

  else
  {
    stepl = (signed int)((65530 - 4) / (4 * 12)) * 4 * 12;
    f = len / (65530 - 4) + 1;
    i = 0;
    for( ; !(i >= f); i = i + 1)
    {
      ptr = buf;
      *((unsigned int *)ptr)=htonl((unsigned int)object);
      ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
      if(!(stepl >= len + -(i * stepl)))
        flen = stepl;

      else
        flen = len - i * stepl;
      memcpy((void *)ptr, (const void *)((char *)mbuf + (signed long int)(i * stepl)), (unsigned long int)flen);
      htonfb((float *)ptr, flen / 4);
      net_send((unsigned char)9, buf, (unsigned short int)(flen + 4));
    }
    return 0;
  }
}

// s3d_push_polygon
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 180
signed int s3d_push_polygon(signed int object, unsigned int v1, unsigned int v2, unsigned int v3, unsigned int material)
{
  char buf[20l];
  char *ptr;
  signed int len = 4 + 4 * 4;
  ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((unsigned int *)ptr)=htonl(v1);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((unsigned int *)ptr)=htonl(v2);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((unsigned int *)ptr)=htonl(v3);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((unsigned int *)ptr)=htonl(material);
  net_send((unsigned char)10, buf, (unsigned short int)len);
  return 0;
}

// s3d_push_polygons
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 181
signed int s3d_push_polygons(signed int object, const unsigned int *pbuf, unsigned short int n)
{
  unsigned int buf[16383l];
  const unsigned int *s;
  unsigned int *d;
  signed int f;
  signed int i;
  signed int j;
  signed int len = (signed int)n * 4 * 4;
  signed int flen;
  signed int stepl;
  if(!((signed int)n >= 1))
    return -1;

  else
  {
    stepl = (signed int)((65530 - 4) / (4 * 4)) * 4 * 4;
    f = len / (65530 - 4) + 1;
    buf[(signed long int)0]=htonl((unsigned int)object);
    d = buf + (signed long int)1;
    i = 0;
    for( ; !(i >= f); i = i + 1)
    {
      if(!(stepl >= len + -(i * stepl)))
        flen = stepl;

      else
        flen = len - i * stepl;
      s = pbuf + (signed long int)((i * stepl) / 4);
      j = 0;
      for( ; !(j >= flen / 4); j = j + 1)
        d[(signed long int)j]=htonl(s[(signed long int)j]);
      net_send((unsigned char)10, (char *)buf, (unsigned short int)(flen + 4));
    }
    return 0;
  }
}

// s3d_push_texture
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 479
signed int s3d_push_texture(signed int object, unsigned short int w, unsigned short int h)
{
  char buf[8l];
  char *ptr;
  signed int len = 4 + 2 * 2;
  ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((unsigned short int *)ptr)=htons(w);
  ptr = ptr + (signed long int)sizeof(unsigned short int) /*2ul*/ ;
  *((unsigned short int *)ptr)=htons(h);
  net_send((unsigned char)11, buf, (unsigned short int)len);
  return 0;
}

// s3d_push_textures
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 500
signed int s3d_push_textures(signed int object, const unsigned short int *tbuf, unsigned short int n)
{
  unsigned int buf[16383l];
  const unsigned short int *s;
  unsigned short int *d;
  signed int f;
  signed int i;
  signed int j;
  signed int len = (signed int)n * 2 * 2;
  signed int flen;
  signed int stepl;
  if(!((signed int)n >= 1))
    return -1;

  else
  {
    stepl = (signed int)((65530 - 4) / (2 * 2)) * 2 * 2;
    f = len / (65530 - 4) + 1;
    *((unsigned int *)buf)=htonl((unsigned int)object);
    d = (unsigned short int *)(buf + (signed long int)1);
    i = 0;
    for( ; !(i >= f); i = i + 1)
    {
      if(!(stepl >= len + -(i * stepl)))
        flen = stepl;

      else
        flen = len - i * stepl;
      s = tbuf + (signed long int)((i * stepl) / 2);
      j = 0;
      for( ; !(j >= flen / 2); j = j + 1)
        d[(signed long int)j]=htons(s[(signed long int)j]);
      net_send((unsigned char)11, (char *)buf, (unsigned short int)(flen + 4));
    }
    return 0;
  }
}

// s3d_push_vertex
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 158
signed int s3d_push_vertex(signed int object, float x, float y, float z)
{
  char buf[16l];
  char *ptr;
  signed int len = 4 + 3 * 4;
  ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  *((float *)ptr) = x;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = y;
  ptr = ptr + (signed long int)sizeof(float) /*4ul*/ ;
  *((float *)ptr) = z;
  htonfb((float *)(buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), 3);
  net_send((unsigned char)8, buf, (unsigned short int)len);
  return 0;
}

// s3d_push_vertices
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 159
signed int s3d_push_vertices(signed int object, const float *vbuf, unsigned short int n)
{
  char buf[65534l];
  char *ptr;
  signed int f;
  signed int i;
  signed int len = (signed int)n * 4 * 3;
  signed int flen;
  signed int stepl;
  if(!((signed int)n >= 1))
    return -1;

  else
  {
    stepl = (signed int)((65530 - 4) / (4 * 3)) * 4 * 3;
    f = len / (65530 - 4) + 1;
    i = 0;
    for( ; !(i >= f); i = i + 1)
    {
      ptr = buf;
      *((unsigned int *)ptr)=htonl((unsigned int)object);
      ptr = ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
      if(!(stepl >= len + -(i * stepl)))
        flen = stepl;

      else
        flen = len - i * stepl;
      memcpy((void *)ptr, (const void *)((char *)vbuf + (signed long int)(i * stepl)), (unsigned long int)flen);
      htonfb((float *)ptr, flen / 4);
      net_send((unsigned char)8, buf, (unsigned short int)(flen + 4));
    }
    return 0;
  }
}

// s3d_quit
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 154
signed int s3d_quit(void)
{
  struct s3d_evt *ret;
  _s3d_texture_quit();
  if(!(_s3d_ready == 0) && !(con_type == 0))
  {
    net_send((unsigned char)2, (char *)(void *)0, (unsigned short int)0);
    switch(con_type)
    {
      case 2:
      {
        _tcp_quit();
        break;
      }
      case 1:
        _shm_quit();
    }
    con_type = 0;
    _s3d_ready = 0;
    _queue_quit();
    do
    {
      ret=s3d_pop_event();
      if(ret == ((struct s3d_evt *)NULL))
        break;

      s3d_delete_event(ret);
    }
    while((_Bool)1);
    cb_lock = 0;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct s3d_evt) /*24ul*/ );
    ret = (struct s3d_evt *)return_value_malloc$1;
    ret->event = (unsigned char)255;
    ret->length = 0;
    s3d_push_event(ret);
  }

  return 0;
}

// s3d_rotate
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 218
signed int s3d_rotate(signed int object, float x, float y, float z)
{
  char buf[16l];
  char *ptr;
  signed int len = 4 + 4 * 3;
  ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)4;
  *((float *)ptr) = x;
  ptr = ptr + (signed long int)4;
  *((float *)ptr) = y;
  ptr = ptr + (signed long int)4;
  *((float *)ptr) = z;
  htonfb((float *)(buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), 3);
  net_send((unsigned char)34, buf, (unsigned short int)len);
  return 0;
}

// s3d_scale
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 219
signed int s3d_scale(signed int object, float s)
{
  char buf[8l];
  char *ptr;
  signed int len = 4 + 4;
  ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)4;
  *((float *)ptr) = s;
  htonfb((float *)(buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), 1);
  net_send((unsigned char)35, buf, (unsigned short int)len);
  return 0;
}

// s3d_select_font
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 224
signed int s3d_select_font(const char *path)
{
  char *oldfont = memory_font;
  signed int oldsize = memory_font_size;
  char *c;
  char **p;
  signed int return_value_s3d_ft_init$1;
  if(ft_init == 0)
  {
    return_value_s3d_ft_init$1=s3d_ft_init();
    if(return_value_s3d_ft_init$1 == 0)
      goto __CPROVER_DUMP_L1;

    errds(5, "s3d_select_font()", "error in initializtation (ft_init())");
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    signed int return_value_strncmp$2;
    return_value_strncmp$2=strncmp(oldfontpath, path, (unsigned long int)256);
    if(return_value_strncmp$2 == 0)
    {
      s3dprintf$link1(1, "font already %s loaded.", path);
      return -1;
    }

    else
    {
      c=s3d_findfont(path);
      if(!(c == ((char *)NULL)))
      {
        s3dprintf$link1(2, "Loading Font %s ... ", c);
        _s3d_clear_tessbuf();
        p = &memory_font;
        memory_font_size=s3d_open_file(c, p);
        if(memory_font_size >= 1)
        {
          signed int return_value_s3d_ft_load_font$3;
          return_value_s3d_ft_load_font$3=s3d_ft_load_font();
          if(return_value_s3d_ft_load_font$3 == 0)
          {
            if(!(oldfont == ((char *)NULL)))
              free((void *)oldfont);

            strncpy(oldfontpath, path, (unsigned long int)256);
            return 0;
          }

          else
          {
            memory_font = oldfont;
            memory_font_size = oldsize;
          }
        }

        else
          errds(5, "s3d_select_font()", "Could not open fontfile %s", c);
      }

      return -1;
    }
  }
}

// s3d_set_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 243
void s3d_set_callback(unsigned char event, signed int (*func)(struct s3d_evt *))
{
  s3d_cb_list[(signed long int)(signed int)event] = func;
  s3d_process_stack();
}

// s3d_strlen
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 226
float s3d_strlen(const char *str)
{
  signed int i;
  float xoff;
  signed int len;
  unsigned short int a;
  signed int return_value_s3d_ft_init$1;
  _Bool tmp_if_expr$3;
  if(ft_init == 0)
  {
    return_value_s3d_ft_init$1=s3d_ft_init();
    if(return_value_s3d_ft_init$1 == 0)
      goto __CPROVER_DUMP_L1;

    errds(5, "s3d_draw_string()", "error in initializtation (ft_init())");
    return (float)0.0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(face_init == 0)
    {
      errds(5, "s3d_draw_string()", "no font to draw with");
      return (float)0.0;
    }

    else
    {
      xoff = (float)0;
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(str);
      len = (signed int)return_value_strlen$2;
      i = 0;
      for( ; !(i >= len); i = i + 1)
      {
        a = (unsigned short int)(unsigned char)str[(signed long int)i];
        if(!(tess_buf[(signed long int)a].vbuf == ((float *)NULL)))
          tmp_if_expr$3 = tess_buf[(signed long int)a].pbuf != ((unsigned int *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(!tmp_if_expr$3)
          _s3d_add_tessbuf(a);

        xoff = xoff + tess_buf[(signed long int)a].xoff;
      }
      return xoff;
    }
  }
}

// s3d_translate
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 217
signed int s3d_translate(signed int object, float x, float y, float z)
{
  char buf[16l];
  char *ptr;
  signed int len = 4 + 4 * 3;
  ptr = buf;
  *((unsigned int *)ptr)=htonl((unsigned int)object);
  ptr = ptr + (signed long int)4;
  *((float *)ptr) = x;
  ptr = ptr + (signed long int)4;
  *((float *)ptr) = y;
  ptr = ptr + (signed long int)4;
  *((float *)ptr) = z;
  htonfb((float *)(buf + (signed long int)sizeof(unsigned int) /*4ul*/ ), 3);
  net_send((unsigned char)33, buf, (unsigned short int)len);
  return 0;
}

// s3d_unlink
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/proto_out.c line 119
signed int s3d_unlink(signed int oid)
{
  unsigned int buf;
  buf=htonl((unsigned int)oid);
  net_send((unsigned char)6, (char *)&buf, (unsigned short int)4);
  return 0;
}

// s3d_usage
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/io.c line 73
void s3d_usage(void)
{
  printf("s3d-parameters:\n");
  printf(" --s3d-url <url>: skip S3D environment and connect to this url\n");
  printf(" --help, -h, --s3d-help: this helpful text\n");
}

// s3d_vector_angle
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 233
float s3d_vector_angle(const float *vector1, const float *vector2)
{
  float return_value_s3d_vector_dot_product$1;
  return_value_s3d_vector_dot_product$1=s3d_vector_dot_product(vector1, vector2);
  float return_value_s3d_vector_length$2;
  return_value_s3d_vector_length$2=s3d_vector_length(vector1);
  float return_value_s3d_vector_length$3;
  return_value_s3d_vector_length$3=s3d_vector_length(vector2);
  double return_value_acos$4;
  return_value_acos$4=acos((double)(return_value_s3d_vector_dot_product$1 / (return_value_s3d_vector_length$2 * return_value_s3d_vector_length$3)));
  return (float)return_value_acos$4;
}

// s3d_vector_cross_product
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/vector.c line 74
void s3d_vector_cross_product(const float *vector1, const float *vector2, float *result_vector)
{
  result_vector[(signed long int)0] = vector1[(signed long int)1] * vector2[(signed long int)2] - vector1[(signed long int)2] * vector2[(signed long int)1];
  result_vector[(signed long int)1] = vector1[(signed long int)2] * vector2[(signed long int)0] - vector1[(signed long int)0] * vector2[(signed long int)2];
  result_vector[(signed long int)2] = vector1[(signed long int)0] * vector2[(signed long int)1] - vector1[(signed long int)1] * vector2[(signed long int)0];
}

// s3d_vector_dot_product
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/vector.c line 63
float s3d_vector_dot_product(const float *vector1, const float *vector2)
{
  return vector1[(signed long int)0] * vector2[(signed long int)0] + vector1[(signed long int)1] * vector2[(signed long int)1] + vector1[(signed long int)2] * vector2[(signed long int)2];
}

// s3d_vector_length
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3d.h line 230
float s3d_vector_length(const float *vector)
{
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt((double)(vector[(signed long int)0] * vector[(signed long int)0] + vector[(signed long int)1] * vector[(signed long int)1] + vector[(signed long int)2] * vector[(signed long int)2]));
  return (float)return_value_sqrt$1;
}

// s3d_vector_subtract
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/vector.c line 48
void s3d_vector_subtract(const float *vector1, const float *vector2, float *result_vector)
{
  result_vector[(signed long int)0] = vector2[(signed long int)0] - vector1[(signed long int)0];
  result_vector[(signed long int)1] = vector2[(signed long int)1] - vector1[(signed long int)1];
  result_vector[(signed long int)2] = vector2[(signed long int)2] - vector1[(signed long int)2];
}

// s3dprintf
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 109
static inline void s3dprintf(signed int relevance, const char *fmt, ...)
{
  ;
}

// s3dprintf$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 109
static inline void s3dprintf$link1(signed int relevance$link1, const char *fmt$link1, ...)
{
  ;
}

// s3dprintf$link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/s3dlib.h line 109
static inline void s3dprintf$link2(signed int relevance$link2, const char *fmt$link2, ...)
{
  ;
}

// s3dw_ani_add
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 47
void s3dw_ani_add(struct _s3dw_widget *f)
{
  const char *return_value_s3dw_get_type_string$1;
  return_value_s3dw_get_type_string$1=s3dw_get_type_string(f->type);
  s3dprintf(1, "[A]ni ADD (%10p), oid = %d, ani_n = %d, type is %s\n", (void *)f, f->oid, ani_n, return_value_s3dw_get_type_string$1);
  if(f->oid == 0u)
  {
    if(f->type == 1)
      goto __CPROVER_DUMP_L1;

    s3dprintf(4, "s3dw_ani_add() assert failed: weird, moving cam but its not a cam object?");
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(animation_on == 0) && !(ani_n >= 128))
    {
      signed int return_value_s3dw_ani_stackpos$2;
      return_value_s3dw_ani_stackpos$2=s3dw_ani_stackpos(f);
      if(!(return_value_s3dw_ani_stackpos$2 == -1))
        goto __CPROVER_DUMP_L5;

      ani_s[(signed long int)ani_n] = f;
      s3dw_ani_iterate(f);
      ani_n = ani_n + 1;
    }

    else
      s3dw_ani_finish(f, -1);
  }

__CPROVER_DUMP_L5:
  ;
}

// s3dw_ani_check
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 121
signed int s3dw_ani_check(struct _s3dw_widget *f)
{
  float x;
  float y;
  float z;
  float rx;
  float ry;
  float rz;
  x = f->ax - f->x;
  y = f->ay - f->y;
  z = f->az - f->z;
  rx = f->arx - f->rx;
  ry = f->ary - f->ry;
  rz = f->arz - f->rz;
  double return_value_fabs$1;
  return_value_fabs$1=fabs((double)(f->as - f->s));
  _Bool tmp_if_expr$3;
  double return_value_sqrt$2;
  if(return_value_fabs$1 / (double)f->s > 0.01)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_sqrt$2=sqrt((double)(x * x + y * y + z * z));
    tmp_if_expr$3 = return_value_sqrt$2 > 0.01 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  double return_value_sqrt$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_sqrt$4=sqrt((double)(rx * rx + ry * ry + rz * rz));
    tmp_if_expr$5 = return_value_sqrt$4 > 0.01 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
    return 0;

  else
    return 1;
}

// s3dw_ani_del
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 66
void s3dw_ani_del(signed int i)
{
  if(i >= 0 && !(i >= ani_n))
  {
    s3dprintf(1, "[A]ni DEL %d, ani_n = %d\n", i, ani_n);
    ani_n = ani_n - 1;
    ani_s[(signed long int)i] = ani_s[(signed long int)ani_n];
  }

  else
    s3dprintf(3, "[F]ATAL: can't delete animation!\n");
}

// s3dw_ani_doit
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 78
void s3dw_ani_doit(struct _s3dw_widget *f)
{
  _Bool tmp_if_expr$1;
  if(f->oid == 0u)
    tmp_if_expr$1 = f->type != 1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    s3dprintf(4, "s3dw_ani_doit() assert failed: weird, moving cam but its not a cam object?");

  else
  {
    if(f->oid == 0u)
      s3dprintf(4, "moving cam");

    s3d_translate((signed int)f->oid, f->ax, f->ay, f->az);
    s3d_rotate((signed int)f->oid, f->arx, f->ary, f->arz);
    s3d_scale((signed int)f->oid, f->as);
  }
}

// s3dw_ani_finish
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 93
void s3dw_ani_finish(struct _s3dw_widget *f, signed int i)
{
  f->ax = f->x;
  f->ay = f->y;
  f->az = f->z;
  f->arx = f->rx;
  f->ary = f->ry;
  f->arz = f->rz;
  f->as = f->s;
  s3dw_ani_doit(f);
  if(!(i == -1))
    s3dw_ani_del(i);

}

// s3dw_ani_iterate
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 108
void s3dw_ani_iterate(struct _s3dw_widget *f)
{
  f->ax = (f->x + f->ax * (float)5) / (float)(5 + 1);
  f->ay = (f->y + f->ay * (float)5) / (float)(5 + 1);
  f->az = (f->z + f->az * (float)5) / (float)(5 + 1);
  f->arx = (f->rx + f->arx * (float)5) / (float)(5 + 1);
  f->ary = (f->ry + f->ary * (float)5) / (float)(5 + 1);
  f->arz = (f->rz + f->arz * (float)5) / (float)(5 + 1);
  f->as = (f->s + f->as * (float)5) / (float)(5 + 1);
}

// s3dw_ani_mate
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 165
void s3dw_ani_mate(void)
{
  signed int i;
  struct _s3dw_widget *f;
  animation_on = 1;
  if(!(ani_need_arr == 0))
    s3dw_arrange();

  i = 0;
  for( ; !(i >= ani_n); i = i + 1)
  {
    f = ani_s[(signed long int)i];
    s3dw_ani_iterate(f);
    signed int return_value_s3dw_ani_check$1;
    return_value_s3dw_ani_check$1=s3dw_ani_check(f);
    if(!(return_value_s3dw_ani_check$1 == 0))
    {
      s3dw_ani_finish(f, i);
      i = i - 1;
    }

    else
      s3dw_ani_doit(f);
  }
}

// s3dw_ani_needarr
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 137
void s3dw_ani_needarr(void)
{
  ani_need_arr = 1;
  if(animation_on == 0)
    while(!(ani_need_arr == 0))
      s3dw_arrange();

}

// s3dw_ani_stackpos
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/animate.c line 36
signed int s3dw_ani_stackpos(struct _s3dw_widget *f)
{
  signed int i = 0;
  for( ; !(i >= ani_n); i = i + 1)
    if(ani_s[(signed long int)i] == f)
      return i;

  return -1;
}

// s3dw_arr_normdir
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/arrange.c line 54
void s3dw_arr_normdir(float *dir)
{
  float dirlen;
  do
  {
    dirlen=s3d_vector_length(dir);
    if(!IEEE_FLOAT_EQUAL(dirlen, 0.000000f))
      break;

    signed int return_value_rand$1;
    return_value_rand$1=rand();
    dir[(signed long int)0] = (float)(((double)(float)return_value_rand$1 - (double)2147483647 / 2.0) / (double)2147483647);
    signed int return_value_rand$2;
    return_value_rand$2=rand();
    dir[(signed long int)1] = (float)(((double)(float)return_value_rand$2 - (double)2147483647 / 2.0) / (double)2147483647);
    signed int return_value_rand$3;
    return_value_rand$3=rand();
    dir[(signed long int)2] = (float)(((double)(float)return_value_rand$3 - (double)2147483647 / 2.0) / (double)2147483647);
  }
  while((_Bool)1);
  dir[(signed long int)0] = dir[(signed long int)0] / dirlen;
  dir[(signed long int)1] = dir[(signed long int)1] / dirlen;
  dir[(signed long int)2] = dir[(signed long int)2] / dirlen;
}

// s3dw_arr_widgetcenter
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/arrange.c line 32
void s3dw_arr_widgetcenter(struct _s3dw_widget *widget, float *center)
{
  float x;
  float y;
  float z;
  float xt;
  float yt;
  float zt;
  x = (widget->s * widget->width) / (float)2;
  y = (float)((double)((widget->s * -widget->height) / (float)2) + 0.5);
  z = (float)((double)widget->s * 0.5);
  double return_value_cos$1;
  return_value_cos$1=cos((double)widget->ry / ((double)180 / 3.14159265358979323846));
  double return_value_sin$2;
  return_value_sin$2=sin((double)widget->ry / ((double)180 / 3.14159265358979323846));
  xt = (float)(return_value_cos$1 * (double)x + return_value_sin$2 * (double)z);
  yt = y;
  double return_value_sin$3;
  return_value_sin$3=sin((double)widget->ry / ((double)180 / 3.14159265358979323846));
  double return_value_cos$4;
  return_value_cos$4=cos((double)widget->ry / ((double)180 / 3.14159265358979323846));
  zt = (float)(-return_value_sin$3 * (double)x + return_value_cos$4 * (double)z);
  x = xt;
  double return_value_cos$5;
  return_value_cos$5=cos((double)widget->rx / ((double)180 / 3.14159265358979323846));
  double return_value_sin$6;
  return_value_sin$6=sin((double)widget->rx / ((double)180 / 3.14159265358979323846));
  y = (float)(return_value_cos$5 * (double)yt + return_value_sin$6 * (double)zt);
  double return_value_sin$7;
  return_value_sin$7=sin((double)widget->rx / ((double)180 / 3.14159265358979323846));
  double return_value_cos$8;
  return_value_cos$8=cos((double)widget->rx / ((double)180 / 3.14159265358979323846));
  z = (float)(-return_value_sin$7 * (double)yt + return_value_cos$8 * (double)zt);
  center[(signed long int)0] = x;
  center[(signed long int)1] = y;
  center[(signed long int)2] = z;
}

// s3dw_arrange
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/arrange.c line 152
void s3dw_arrange(void)
{
  struct _s3dw_widget *w1;
  struct _s3dw_widget *w2;
  struct _s3dw_widget *s3dw_arrange$$1$$root;
  s3dw_arrange$$1$$root=s3dw_getroot();
  signed int i;
  signed int j;
  signed int arranged;
  signed int allarr;
  float len1;
  float len2;
  float dirlen;
  float tomove;
  float move1;
  float move2;
  float f1[3l];
  float f2[3l];
  float dir[3l];
  arranged = 1;
  i = 0;
  for( ; !(i >= s3dw_arrange$$1$$root->nobj); i = i + 1)
    if((512 & s3dw_arrange$$1$$root->pobj[(signed long int)i]->flags) == 0)
      arranged = 0;

  if(!(ani_need_arr == 0) || arranged == 0)
  {
    ani_need_arr = 0;
    if(s3dw_arrange$$1$$root->nobj == 1)
    {
      w1 = s3dw_arrange$$1$$root->pobj[(signed long int)0];
      w1->flags = w1->flags | 512;
    }

    else
    {
      allarr = 1;
      i = 0;
      for( ; !(i >= s3dw_arrange$$1$$root->nobj); i = i + 1)
      {
        w1 = s3dw_arrange$$1$$root->pobj[(signed long int)i];
        arranged = 1;
        j = 0;
        for( ; !(j >= s3dw_arrange$$1$$root->nobj); j = j + 1)
        {
          w2 = s3dw_arrange$$1$$root->pobj[(signed long int)j];
          if(!(i == j))
          {
            if(!(w1->oid == 0u))
            {
              if(!(w2->oid == 0u))
              {
                s3dw_arr_widgetcenter(w1, f1);
                s3dw_arr_widgetcenter(w2, f2);
                len1=s3d_vector_length(f1);
                len2=s3d_vector_length(f2);
                dir[(signed long int)0] = (w1->x + f1[(signed long int)0]) - (w2->x + f2[(signed long int)0]);
                dir[(signed long int)1] = (w1->y + f1[(signed long int)1]) - (w2->y + f2[(signed long int)1]);
                dir[(signed long int)2] = (w1->z + f1[(signed long int)2]) - (w2->z + f2[(signed long int)2]);
                dirlen=s3d_vector_length(dir);
                if(dirlen < len1 + len2)
                {
                  allarr = 0;
                  arranged = 0;
                  w1->flags = w1->flags & ~512;
                  w2->flags = w2->flags & ~512;
                  s3dw_arr_normdir(dir);
                  tomove = (len1 + len2 + (float)1) - dirlen;
                  move1 = len1 / (len1 + len2);
                  move2 = len2 / (len1 + len2);
                  if(!(w1->oid == 0u))
                  {
                    w1->x = w1->x + tomove * move1 * dir[(signed long int)0];
                    w1->y = w1->y + tomove * move1 * dir[(signed long int)1];
                    w1->z = w1->z + tomove * move1 * dir[(signed long int)2];
                    s3dw_ani_add(w1);
                  }

                  else
                  {
                    w2->x = w2->x + tomove * move2 * -dir[(signed long int)0];
                    w2->y = w2->y + tomove * move2 * -dir[(signed long int)1];
                    w2->z = w2->z + tomove * move2 * -dir[(signed long int)2];
                  }
                  if(!(w2->oid == 0u))
                  {
                    w2->x = w2->x + tomove * move2 * -dir[(signed long int)0];
                    w2->y = w2->y + tomove * move2 * -dir[(signed long int)1];
                    w2->z = w2->z + tomove * move2 * -dir[(signed long int)2];
                    s3dw_ani_add(w2);
                  }

                  else
                  {
                    w1->x = w1->x + tomove * move1 * dir[(signed long int)0];
                    w1->y = w1->y + tomove * move1 * dir[(signed long int)1];
                    w1->z = w1->z + tomove * move1 * dir[(signed long int)2];
                  }
                }

              }

            }

          }

        }
        if(!(arranged == 0))
          w1->flags = w1->flags | 512;

      }
      if(!(allarr == 0))
        ani_need_arr = 0;

      s3dw_turn();
      s3dw_follow();
    }
  }

}

// s3dw_button_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/button.c line 136
void s3dw_button_destroy(struct _s3dw_widget *widget)
{
  struct _s3dw_button *button = (struct _s3dw_button *)widget;
  s3dw_button_erase(widget);
  free((void *)button->text);
  free((void *)button);
}

// s3dw_button_draw
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/button.c line 31
void s3dw_button_draw(struct _s3dw_widget *widget)
{
  struct _s3dw_button *button = (struct _s3dw_button *)widget;
  float length;
  float vertices[24l];
  unsigned int polygons[40l] = { (unsigned int)0, (unsigned int)4, (unsigned int)5, (unsigned int)0, (unsigned int)0, (unsigned int)5, (unsigned int)1, (unsigned int)0, (unsigned int)1, (unsigned int)5, (unsigned int)6, (unsigned int)0, (unsigned int)1, (unsigned int)6, (unsigned int)2, (unsigned int)0, (unsigned int)2, (unsigned int)6, (unsigned int)7, (unsigned int)0, (unsigned int)2, (unsigned int)7, (unsigned int)3, (unsigned int)0, (unsigned int)3, (unsigned int)7, (unsigned int)4, (unsigned int)0, (unsigned int)3, (unsigned int)4, (unsigned int)0, (unsigned int)0, (unsigned int)4, (unsigned int)7, (unsigned int)6, (unsigned int)0, (unsigned int)4, (unsigned int)6, (unsigned int)5, (unsigned int)0 };
  signed int return_value_s3d_draw_string$1;
  return_value_s3d_draw_string$1=s3d_draw_string(button->text, &length);
  button->oid_text = (unsigned int)return_value_s3d_draw_string$1;
  s3d_pep_materials_a((signed int)button->oid_text, widget->style->text_mat, (unsigned short int)1);
  vertices[(signed long int)(0 * 3 + 0)] = (float)0.0;
  vertices[(signed long int)(0 * 3 + 1)] = (float)0.0;
  vertices[(signed long int)(0 * 3 + 2)] = (float)0.0;
  vertices[(signed long int)(1 * 3 + 0)] = (float)0.0;
  vertices[(signed long int)(1 * 3 + 1)] = (float)-2.0;
  vertices[(signed long int)(1 * 3 + 2)] = (float)0.0;
  vertices[(signed long int)(2 * 3 + 0)] = length + (float)1;
  vertices[(signed long int)(2 * 3 + 1)] = (float)-2.0;
  vertices[(signed long int)(2 * 3 + 2)] = (float)0.0;
  vertices[(signed long int)(3 * 3 + 0)] = length + (float)1;
  vertices[(signed long int)(3 * 3 + 1)] = (float)0.0;
  vertices[(signed long int)(3 * 3 + 2)] = (float)0.0;
  vertices[(signed long int)(4 * 3 + 0)] = (float)0.25;
  vertices[(signed long int)(4 * 3 + 1)] = (float)-0.25;
  vertices[(signed long int)(4 * 3 + 2)] = (float)0.25;
  vertices[(signed long int)(5 * 3 + 0)] = (float)0.25;
  vertices[(signed long int)(5 * 3 + 1)] = (float)-1.75;
  vertices[(signed long int)(5 * 3 + 2)] = (float)0.25;
  vertices[(signed long int)(6 * 3 + 0)] = (float)((double)length + 0.75);
  vertices[(signed long int)(6 * 3 + 1)] = (float)-1.75;
  vertices[(signed long int)(6 * 3 + 2)] = (float)0.25;
  vertices[(signed long int)(7 * 3 + 0)] = (float)((double)length + 0.75);
  vertices[(signed long int)(7 * 3 + 1)] = (float)-0.25;
  vertices[(signed long int)(7 * 3 + 2)] = (float)0.25;
  signed int return_value_s3d_new_object$2;
  return_value_s3d_new_object$2=s3d_new_object();
  widget->oid = (unsigned int)return_value_s3d_new_object$2;
  s3d_push_materials_a((signed int)widget->oid, widget->style->input_mat, (unsigned short int)1);
  s3d_push_vertices((signed int)widget->oid, vertices, (unsigned short int)8);
  s3d_push_polygons((signed int)widget->oid, polygons, (unsigned short int)10);
  s3d_link((signed int)widget->oid, (signed int)widget->parent->oid);
  s3d_link((signed int)button->oid_text, (signed int)widget->oid);
  s3d_translate((signed int)button->oid_text, (float)0.5, (float)-1.5, (float)0.30);
  s3d_translate((signed int)widget->oid, widget->x, -widget->y, (float)0);
  widget->width = length + (float)1;
  widget->height = (float)2;
}

// s3dw_button_erase
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/button.c line 128
void s3dw_button_erase(struct _s3dw_widget *widget)
{
  struct _s3dw_button *button = (struct _s3dw_button *)widget;
  s3d_del_object((signed int)button->oid_text);
  s3d_del_object((signed int)widget->oid);
}

// s3dw_button_event_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/button.c line 150
signed int s3dw_button_event_click(struct _s3dw_widget *widget, unsigned int oid)
{
  struct _s3dw_button *button = (struct _s3dw_button *)widget;
  _Bool tmp_if_expr$1;
  if(button->oid_text == oid)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = widget->oid == oid ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    button->onclick(widget);
    return 1;
  }

  else
    return 0;
}

// s3dw_button_event_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/button.c line 144
signed int s3dw_button_event_key(struct _s3dw_widget *widget, struct s3d_key_event *keys)
{
  return 0;
}

// s3dw_button_hide
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/button.c line 121
void s3dw_button_hide(struct _s3dw_widget *widget)
{
  struct _s3dw_button *button = (struct _s3dw_button *)widget;
  s3d_flags_off((signed int)widget->oid, (unsigned int)(0x00000001 | 0x00000002));
  s3d_flags_off((signed int)button->oid_text, (unsigned int)(0x00000001 | 0x00000002));
}

// s3dw_button_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/button.c line 96
struct _s3dw_button * s3dw_button_new(const struct _s3dw_surface *surface, const char *text, float posx, float posy)
{
  struct _s3dw_button *button;
  struct _s3dw_widget *widget;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _s3dw_button) /*152ul*/ );
  button = (struct _s3dw_button *)return_value_malloc$1;
  button->text=strdup(text);
  button->onclick = s3dw_nothing;
  widget=s3dw_widget_new((struct _s3dw_widget *)button);
  widget->type = 3;
  widget->x = posx;
  widget->y = posy;
  widget->style = ((struct _s3dw_widget *)surface)->style;
  s3dw_widget_append((struct _s3dw_widget *)surface, widget);
  s3dw_button_draw(widget);
  return button;
}

// s3dw_button_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/button.c line 114
void s3dw_button_show(struct _s3dw_widget *widget)
{
  struct _s3dw_button *button = (struct _s3dw_button *)widget;
  s3d_flags_on((signed int)widget->oid, (unsigned int)(0x00000001 | 0x00000002));
  s3d_flags_on((signed int)button->oid_text, (unsigned int)(0x00000001 | 0x00000002));
}

// s3dw_click_nothing
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 47
signed int s3dw_click_nothing(struct _s3dw_widget *widget, unsigned int dummy)
{
  return 0;
}

// s3dw_delete
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 105
void s3dw_delete(struct _s3dw_widget *widget)
{
  s3dw_widget_remove(widget);
  while(widget->nobj >= 1)
    s3dw_delete(widget->pobj[(signed long int)0]);
  free((void *)widget->pobj);
  s3dwcb_destroy[(signed long int)widget->type](widget);
}

// s3dw_focus
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 131
void s3dw_focus(struct _s3dw_widget *focus)
{
  signed int i = 0;
  for( ; !(i >= focus->parent->nobj); i = i + 1)
    if(focus->parent->pobj[(signed long int)i] == focus)
    {
      focus->parent->focus = i;
      goto __CPROVER_DUMP_L4;
    }


__CPROVER_DUMP_L4:
  ;
}

// s3dw_follow
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/arrange.c line 120
static void s3dw_follow(void)
{
  struct _s3dw_widget *w;
  struct _s3dw_widget *s3dw_follow$$1$$root;
  s3dw_follow$$1$$root=s3dw_getroot();
  signed int i;
  float b[3l];
  float op[3l];
  float lsqr;
  float l;
  i = 0;
  for( ; !(i >= s3dw_follow$$1$$root->nobj); i = i + 1)
  {
    w = s3dw_follow$$1$$root->pobj[(signed long int)i];
    if(!(w->oid == 0u))
    {
      if(!((1024 & w->flags) == 0))
      {
        s3dw_arr_widgetcenter(w, op);
        b[(signed long int)0] = _s3dw_cam->x - (w->x + op[(signed long int)0]);
        b[(signed long int)1] = _s3dw_cam->y - (w->y + op[(signed long int)1]);
        b[(signed long int)2] = _s3dw_cam->z - (w->z + op[(signed long int)2]);
        lsqr = b[(signed long int)0] * b[(signed long int)0] + b[(signed long int)1] * b[(signed long int)1] + b[(signed long int)2] * b[(signed long int)2];
        if(lsqr > 1600.000000f)
        {
          double return_value_sqrt$1;
          return_value_sqrt$1=sqrt((double)lsqr);
          l = (float)return_value_sqrt$1;
          w->x = w->x + (float)((double)b[(signed long int)0] - ((double)b[(signed long int)0] * 40.0) / (double)l);
          w->y = w->y + (float)((double)b[(signed long int)1] - ((double)b[(signed long int)1] * 40.0) / (double)l);
          w->z = w->z + (float)((double)b[(signed long int)2] - ((double)b[(signed long int)2] * 40.0) / (double)l);
          w->flags = w->flags & ~512;
          ani_need_arr = 1;
          s3dw_ani_add(w);
        }

      }

    }

  }
}

// s3dw_get_type_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 56
const char * s3dw_get_type_string(signed int type)
{
  switch(type)
  {
    case 0:
      return "root";
    case 1:
      return "cam";
    case 2:
      return "surface";
    case 3:
      return "button";
    case 4:
      return "label";
    case 5:
      return "input";
    case 6:
      return "textbox";
    case 7:
      return "scrollbar";
    default:
      return (const char *)(void *)0;
  }
}

// s3dw_getroot
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 94
struct _s3dw_widget * s3dw_getroot(void)
{
  if(root == ((struct _s3dw_widget *)NULL))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct _s3dw_widget) /*128ul*/ );
    root = (struct _s3dw_widget *)return_value_malloc$1;
    root=s3dw_widget_new(root);
    root->type = 0;
    signed int return_value_s3d_new_object$2;
    return_value_s3d_new_object$2=s3d_new_object();
    root->oid = (unsigned int)return_value_s3d_new_object$2;
    root->style = &def_style;
    root->flags = 1 | 2;
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(sizeof(struct _s3dw_widget) /*128ul*/ );
    _s3dw_cam = (struct _s3dw_widget *)return_value_malloc$3;
    s3dw_widget_new(_s3dw_cam);
    _s3dw_cam->type = 1;
    _s3dw_cam->oid = (unsigned int)0;
    _s3dw_cam->style = &def_style;
    _s3dw_cam->s = (float)10;
    _s3dw_cam->width = (float)1;
    _s3dw_cam->height = (float)0;
    _s3dw_cam->flags = 1 | 2;
    s3dw_widget_append(root, _s3dw_cam);
    s3dwcb_show[(signed long int)0] = s3dw_nothing;
    s3dwcb_show[(signed long int)1] = s3dw_nothing;
    s3dwcb_show[(signed long int)2] = s3dw_surface_show;
    s3dwcb_show[(signed long int)3] = s3dw_button_show;
    s3dwcb_show[(signed long int)4] = s3dw_label_show;
    s3dwcb_show[(signed long int)5] = s3dw_input_show;
    s3dwcb_show[(signed long int)6] = s3dw_textbox_show;
    s3dwcb_show[(signed long int)7] = s3dw_scrollbar_show;
    s3dwcb_hide[(signed long int)0] = s3dw_nothing;
    s3dwcb_hide[(signed long int)2] = s3dw_surface_hide;
    s3dwcb_hide[(signed long int)3] = s3dw_button_hide;
    s3dwcb_hide[(signed long int)4] = s3dw_label_hide;
    s3dwcb_hide[(signed long int)5] = s3dw_input_hide;
    s3dwcb_hide[(signed long int)6] = s3dw_textbox_hide;
    s3dwcb_hide[(signed long int)7] = s3dw_scrollbar_hide;
    s3dwcb_destroy[(signed long int)0] = s3dw_root_destroy;
    s3dwcb_destroy[(signed long int)1] = s3dw_root_destroy;
    s3dwcb_destroy[(signed long int)2] = s3dw_surface_destroy;
    s3dwcb_destroy[(signed long int)3] = s3dw_button_destroy;
    s3dwcb_destroy[(signed long int)4] = s3dw_label_destroy;
    s3dwcb_destroy[(signed long int)5] = s3dw_input_destroy;
    s3dwcb_destroy[(signed long int)6] = s3dw_textbox_destroy;
    s3dwcb_destroy[(signed long int)7] = s3dw_scrollbar_destroy;
    s3dwcb_click[(signed long int)0] = s3dw_click_nothing;
    s3dwcb_click[(signed long int)1] = s3dw_click_nothing;
    s3dwcb_click[(signed long int)2] = s3dw_surface_event_click;
    s3dwcb_click[(signed long int)3] = s3dw_button_event_click;
    s3dwcb_click[(signed long int)4] = s3dw_label_event_click;
    s3dwcb_click[(signed long int)5] = s3dw_input_event_click;
    s3dwcb_click[(signed long int)6] = s3dw_textbox_event_click;
    s3dwcb_click[(signed long int)7] = s3dw_scrollbar_event_click;
    s3dwcb_key[(signed long int)0] = s3dw_key_nothing;
    s3dwcb_key[(signed long int)1] = s3dw_key_nothing;
    s3dwcb_key[(signed long int)2] = s3dw_surface_event_key;
    s3dwcb_key[(signed long int)3] = s3dw_button_event_key;
    s3dwcb_key[(signed long int)4] = s3dw_label_event_key;
    s3dwcb_key[(signed long int)5] = s3dw_input_event_key;
    s3dwcb_key[(signed long int)6] = s3dw_key_nothing;
    s3dwcb_key[(signed long int)7] = s3dw_key_nothing;
  }

  return root;
}

// s3dw_handle_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/s3dw.h line 273
signed int s3dw_handle_click(struct s3d_evt *evt)
{
  unsigned int oid = *((unsigned int *)evt->buf);
  struct _s3dw_widget *return_value_s3dw_getroot$1;
  return_value_s3dw_getroot$1=s3dw_getroot();
  signed int return_value_s3dw_widget_event_click$2;
  return_value_s3dw_widget_event_click$2=s3dw_widget_event_click(return_value_s3dw_getroot$1, oid);
  return return_value_s3dw_widget_event_click$2;
}

// s3dw_handle_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/event.c line 79
signed int s3dw_handle_key(struct s3d_evt *evt)
{
  struct s3d_key_event *keys = (struct s3d_key_event *)evt->buf;
  struct _s3dw_widget *return_value_s3dw_getroot$1;
  return_value_s3dw_getroot$1=s3dw_getroot();
  signed int return_value_s3dw_widget_event_key$2;
  return_value_s3dw_widget_event_key$2=s3dw_widget_event_key(return_value_s3dw_getroot$1, keys);
  return return_value_s3dw_widget_event_key$2;
}

// s3dw_input_change_text
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 189
void s3dw_input_change_text(struct _s3dw_input *input, const char *text)
{
  struct _s3dw_widget *widget = (struct _s3dw_widget *)input;
  unsigned int oid_text;
  free((void *)input->text);
  input->text=strdup(text);
  oid_text=s3dw_input_draw_string(widget);
  if(!((256 & widget->flags) == 0))
    s3d_flags_on((signed int)oid_text, (unsigned int)(0x00000001 | 0x00000002));

  s3d_del_object((signed int)input->oid_text);
  input->oid_text = oid_text;
}

// s3dw_input_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 177
void s3dw_input_destroy(struct _s3dw_widget *widget)
{
  struct _s3dw_input *input = (struct _s3dw_input *)widget;
  s3dw_input_erase(widget);
  free((void *)input->text);
  free((void *)input);
}

// s3dw_input_draw
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 48
void s3dw_input_draw(struct _s3dw_widget *widget)
{
  struct _s3dw_input *input = (struct _s3dw_input *)widget;
  float length;
  float vertices[36l];
  unsigned int polygons[72l] = { (unsigned int)0, (unsigned int)4, (unsigned int)5, (unsigned int)1, (unsigned int)0, (unsigned int)5, (unsigned int)1, (unsigned int)1, (unsigned int)1, (unsigned int)5, (unsigned int)6, (unsigned int)1, (unsigned int)1, (unsigned int)6, (unsigned int)2, (unsigned int)1, (unsigned int)2, (unsigned int)6, (unsigned int)7, (unsigned int)1, (unsigned int)2, (unsigned int)7, (unsigned int)3, (unsigned int)1, (unsigned int)3, (unsigned int)7, (unsigned int)4, (unsigned int)1, (unsigned int)3, (unsigned int)4, (unsigned int)0, (unsigned int)1, (unsigned int)4, (unsigned int)8, (unsigned int)9, (unsigned int)1, (unsigned int)4, (unsigned int)9, (unsigned int)5, (unsigned int)1, (unsigned int)5, (unsigned int)9, (unsigned int)10, (unsigned int)1, (unsigned int)5, (unsigned int)10, (unsigned int)6, (unsigned int)1, (unsigned int)6, (unsigned int)10, (unsigned int)11, (unsigned int)1, (unsigned int)6, (unsigned int)11, (unsigned int)7, (unsigned int)1, (unsigned int)7, (unsigned int)11, (unsigned int)8, (unsigned int)1, (unsigned int)7, (unsigned int)8, (unsigned int)4, (unsigned int)1, (unsigned int)8, (unsigned int)11, (unsigned int)10, (unsigned int)0, (unsigned int)8, (unsigned int)10, (unsigned int)9, (unsigned int)0 };
  length = widget->width - (float)1;
  if(!(widget->width < 1.000000f))
  {
    widget->height = (float)2;
    vertices[(signed long int)(0 * 3 + 0)] = (float)0.0;
    vertices[(signed long int)(0 * 3 + 1)] = (float)0.0;
    vertices[(signed long int)(0 * 3 + 2)] = (float)0.0;
    vertices[(signed long int)(1 * 3 + 0)] = (float)0.0;
    vertices[(signed long int)(1 * 3 + 1)] = (float)-2.0;
    vertices[(signed long int)(1 * 3 + 2)] = (float)0.0;
    vertices[(signed long int)(2 * 3 + 0)] = length + (float)1;
    vertices[(signed long int)(2 * 3 + 1)] = (float)-2.0;
    vertices[(signed long int)(2 * 3 + 2)] = (float)0.0;
    vertices[(signed long int)(3 * 3 + 0)] = length + (float)1;
    vertices[(signed long int)(3 * 3 + 1)] = (float)0.0;
    vertices[(signed long int)(3 * 3 + 2)] = (float)0.0;
    vertices[(signed long int)(4 * 3 + 0)] = (float)0.125;
    vertices[(signed long int)(4 * 3 + 1)] = (float)-0.125;
    vertices[(signed long int)(4 * 3 + 2)] = (float)0.25;
    vertices[(signed long int)(5 * 3 + 0)] = (float)0.125;
    vertices[(signed long int)(5 * 3 + 1)] = (float)-1.875;
    vertices[(signed long int)(5 * 3 + 2)] = (float)0.25;
    vertices[(signed long int)(6 * 3 + 0)] = (float)((double)length + 0.875);
    vertices[(signed long int)(6 * 3 + 1)] = (float)-1.875;
    vertices[(signed long int)(6 * 3 + 2)] = (float)0.25;
    vertices[(signed long int)(7 * 3 + 0)] = (float)((double)length + 0.875);
    vertices[(signed long int)(7 * 3 + 1)] = (float)-0.125;
    vertices[(signed long int)(7 * 3 + 2)] = (float)0.25;
    vertices[(signed long int)(8 * 3 + 0)] = (float)0.25;
    vertices[(signed long int)(8 * 3 + 1)] = (float)-0.25;
    vertices[(signed long int)(8 * 3 + 2)] = (float)0.125;
    vertices[(signed long int)(9 * 3 + 0)] = (float)0.25;
    vertices[(signed long int)(9 * 3 + 1)] = (float)-1.75;
    vertices[(signed long int)(9 * 3 + 2)] = (float)0.125;
    vertices[(signed long int)(10 * 3 + 0)] = (float)((double)length + 0.75);
    vertices[(signed long int)(10 * 3 + 1)] = (float)-1.75;
    vertices[(signed long int)(10 * 3 + 2)] = (float)0.125;
    vertices[(signed long int)(11 * 3 + 0)] = (float)((double)length + 0.75);
    vertices[(signed long int)(11 * 3 + 1)] = (float)-0.25;
    vertices[(signed long int)(11 * 3 + 2)] = (float)0.125;
    signed int return_value_s3d_new_object$1;
    return_value_s3d_new_object$1=s3d_new_object();
    widget->oid = (unsigned int)return_value_s3d_new_object$1;
    s3d_push_materials_a((signed int)widget->oid, widget->style->inputback_mat, (unsigned short int)1);
    s3d_push_materials_a((signed int)widget->oid, widget->style->input_mat, (unsigned short int)1);
    s3d_push_vertices((signed int)widget->oid, vertices, (unsigned short int)12);
    s3d_push_polygons((signed int)widget->oid, polygons, (unsigned short int)18);
    s3d_link((signed int)widget->oid, (signed int)widget->parent->oid);
    s3d_translate((signed int)widget->oid, widget->x, -widget->y, (float)0);
    input->oid_text=s3dw_input_draw_string(widget);
  }

}

// s3dw_input_draw_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 33
unsigned int s3dw_input_draw_string(struct _s3dw_widget *widget)
{
  struct _s3dw_input *input = (struct _s3dw_input *)widget;
  unsigned int oid_text;
  signed int i;
  float tlen;
  float return_value_s3d_strlen$1;
  if(widget->width < 1.000000f)
    return (unsigned int)-1;

  else
  {
    i = 0;
    do
    {
      return_value_s3d_strlen$1=s3d_strlen(input->text + (signed long int)i);
      if(!(return_value_s3d_strlen$1 > widget->width + -1.000000f))
        break;

      i = i + 1;
    }
    while((_Bool)1);
    signed int return_value_s3d_draw_string$2;
    return_value_s3d_draw_string$2=s3d_draw_string(input->text + (signed long int)i, &tlen);
    oid_text = (unsigned int)return_value_s3d_draw_string$2;
    s3d_pep_materials_a((signed int)oid_text, widget->style->text_mat, (unsigned short int)1);
    s3d_translate((signed int)oid_text, (float)0.5, (float)-1.5, (float)0.30);
    s3d_link((signed int)oid_text, (signed int)widget->oid);
    return oid_text;
  }
}

// s3dw_input_erase
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 169
void s3dw_input_erase(struct _s3dw_widget *widget)
{
  struct _s3dw_input *input = (struct _s3dw_input *)widget;
  s3d_del_object((signed int)input->oid_text);
  s3d_del_object((signed int)widget->oid);
}

// s3dw_input_event_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 238
signed int s3dw_input_event_click(struct _s3dw_widget *widget, unsigned int oid)
{
  struct _s3dw_input *input = (struct _s3dw_input *)widget;
  _Bool tmp_if_expr$1;
  if(input->oid_text == oid)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = widget->oid == oid ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    s3dw_focus(widget);
    input->onclick(widget);
    return 1;
  }

  else
    return 0;
}

// s3dw_input_event_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 203
signed int s3dw_input_event_key(struct _s3dw_widget *widget, struct s3d_key_event *keys)
{
  struct _s3dw_input *input = (struct _s3dw_input *)widget;
  char *newtext;
  char key = (char)keys->unicode;
  signed int len;
  s3dprintf(3, "edit field got key %d!!", key);
  unsigned long int return_value_strlen$2;
  if((signed int)keys->keysym == 8)
  {
    return_value_strlen$2=strlen(input->text);
    len = (signed int)return_value_strlen$2;
    if(len >= 1)
    {
      void *return_value_malloc$1;
      return_value_malloc$1=malloc((unsigned long int)(len + 0));
      newtext = (char *)return_value_malloc$1;
      strncpy(newtext, input->text, (unsigned long int)len);
      newtext[(signed long int)(len - 1)] = (char)0;
      s3dw_input_change_text(input, newtext);
      free((void *)newtext);
      return 1;
    }

    goto __CPROVER_DUMP_L5;
  }

  const unsigned short int **return_value___ctype_b_loc$5;
  return_value___ctype_b_loc$5=__ctype_b_loc();
  if(!((16384 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)key]) == 0))
  {
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(input->text);
    len = (signed int)return_value_strlen$3;
    void *return_value_malloc$4;
    return_value_malloc$4=malloc((unsigned long int)(len + 2));
    newtext = (char *)return_value_malloc$4;
    strcpy(newtext, input->text);
    newtext[(signed long int)len] = key;
    newtext[(signed long int)(len + 1)] = (char)0;
    s3dw_input_change_text(input, newtext);
    free((void *)newtext);
    return 1;
  }


__CPROVER_DUMP_L5:
  ;
  return 0;
}

// s3dw_input_gettext
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 253
char * s3dw_input_gettext(struct _s3dw_input *input)
{
  char *return_value_strdup$1;
  return_value_strdup$1=strdup(input->text);
  return return_value_strdup$1;
}

// s3dw_input_hide
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 134
void s3dw_input_hide(struct _s3dw_widget *widget)
{
  struct _s3dw_input *input = (struct _s3dw_input *)widget;
  s3d_flags_off((signed int)widget->oid, (unsigned int)(0x00000001 | 0x00000002));
  s3d_flags_off((signed int)input->oid_text, (unsigned int)(0x00000001 | 0x00000002));
}

// s3dw_input_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 150
struct _s3dw_input * s3dw_input_new(const struct _s3dw_surface *surface, float width, float posx, float posy)
{
  struct _s3dw_input *input;
  struct _s3dw_widget *widget;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _s3dw_input) /*160ul*/ );
  input = (struct _s3dw_input *)return_value_malloc$1;
  input->text=strdup("");
  input->onclick = s3dw_nothing;
  input->onedit = s3dw_nothing;
  widget=s3dw_widget_new((struct _s3dw_widget *)input);
  widget->type = 5;
  widget->x = posx;
  widget->y = posy;
  widget->width = width;
  widget->height = (float)2;
  s3dw_widget_append((struct _s3dw_widget *)surface, widget);
  s3dw_input_draw(widget);
  return input;
}

// s3dw_input_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/input.c line 127
void s3dw_input_show(struct _s3dw_widget *widget)
{
  struct _s3dw_input *input = (struct _s3dw_input *)widget;
  s3d_flags_on((signed int)widget->oid, (unsigned int)(0x00000001 | 0x00000002));
  s3d_flags_on((signed int)input->oid_text, (unsigned int)(0x00000001 | 0x00000002));
}

// s3dw_key_nothing
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 51
signed int s3dw_key_nothing(struct _s3dw_widget *widget, struct s3d_key_event *dummy)
{
  return 0;
}

// s3dw_label_change_text
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 57
void s3dw_label_change_text(struct _s3dw_label *label, const char *text)
{
  struct _s3dw_widget *widget = (struct _s3dw_widget *)label;
  free((void *)label->text);
  label->text=strdup(text);
  s3dw_label_erase(widget);
  s3dw_label_draw(widget);
  if(!((256 & widget->flags) == 0))
    s3dw_label_show(widget);

}

// s3dw_label_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 98
void s3dw_label_destroy(struct _s3dw_widget *widget)
{
  struct _s3dw_label *label = (struct _s3dw_label *)widget;
  s3dw_label_erase(widget);
  free((void *)label->text);
  free((void *)label);
}

// s3dw_label_draw
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 31
void s3dw_label_draw(struct _s3dw_widget *widget)
{
  struct _s3dw_label *label = (struct _s3dw_label *)widget;
  float length;
  signed int return_value_s3d_draw_string$1;
  return_value_s3d_draw_string$1=s3d_draw_string(label->text, &length);
  widget->oid = (unsigned int)return_value_s3d_draw_string$1;
  s3d_pep_materials_a((signed int)widget->oid, widget->style->text_mat, (unsigned short int)1);
  s3d_link((signed int)widget->oid, (signed int)widget->parent->oid);
  s3d_translate((signed int)widget->oid, widget->x, -widget->y, (float)0.1);
  widget->width = length + (float)1;
  widget->height = (float)2;
}

// s3dw_label_erase
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 93
void s3dw_label_erase(struct _s3dw_widget *widget)
{
  s3d_del_object((signed int)widget->oid);
}

// s3dw_label_event_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 111
signed int s3dw_label_event_click(struct _s3dw_widget *widget, unsigned int oid)
{
  struct _s3dw_label *label = (struct _s3dw_label *)widget;
  if(widget->oid == oid)
  {
    label->onclick(widget);
    return 1;
  }

  else
    return 0;
}

// s3dw_label_event_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 106
signed int s3dw_label_event_key(struct _s3dw_widget *widget, struct s3d_key_event *keys)
{
  return 0;
}

// s3dw_label_hide
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 48
void s3dw_label_hide(struct _s3dw_widget *widget)
{
  s3d_flags_off((signed int)widget->oid, (unsigned int)(0x00000001 | 0x00000002));
}

// s3dw_label_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 77
struct _s3dw_label * s3dw_label_new(const struct _s3dw_surface *surface, const char *text, float posx, float posy)
{
  struct _s3dw_label *label;
  struct _s3dw_widget *widget;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _s3dw_label) /*144ul*/ );
  label = (struct _s3dw_label *)return_value_malloc$1;
  widget=s3dw_widget_new((struct _s3dw_widget *)label);
  widget->type = 4;
  widget->x = posx;
  widget->y = posy;
  label->text=strdup(text);
  label->onclick = s3dw_nothing;
  s3dw_widget_append((struct _s3dw_widget *)surface, widget);
  s3dw_label_draw(widget);
  return label;
}

// s3dw_label_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/label.c line 43
void s3dw_label_show(struct _s3dw_widget *widget)
{
  s3d_flags_on((signed int)widget->oid, (unsigned int)(0x00000001 | 0x00000002));
}

// s3dw_moveit
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 160
void s3dw_moveit(struct _s3dw_widget *widget)
{
  s3dw_ani_add(widget);
}

// s3dw_nothing
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 44
void s3dw_nothing(struct _s3dw_widget *widget)
{
  ;
}

// s3dw_object_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/s3dw.h line 275
signed int s3dw_object_info(struct s3d_evt *evt)
{
  struct s3d_obj_info *info = (struct s3d_obj_info *)evt->buf;
  if(info->object == 0u)
  {
    if(_s3dw_cam == ((struct _s3dw_widget *)NULL))
      s3dw_getroot();

    _s3dw_cam->x = info->trans_x;
    _s3dw_cam->ax = _s3dw_cam->x;
    _s3dw_cam->y = info->trans_y;
    _s3dw_cam->ay = _s3dw_cam->y;
    _s3dw_cam->z = info->trans_z;
    _s3dw_cam->az = _s3dw_cam->z;
    _s3dw_cam->rx = info->rot_x;
    _s3dw_cam->arx = _s3dw_cam->rx;
    _s3dw_cam->ry = info->rot_y;
    _s3dw_cam->ary = _s3dw_cam->ry;
    _s3dw_cam->rz = info->rot_z;
    _s3dw_cam->arz = _s3dw_cam->rz;
    _s3dw_cam->flags = _s3dw_cam->flags & ~512;
    s3dw_ani_needarr();
  }

  return 0;
}

// s3dw_root_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/root.c line 39
void s3dw_root_destroy(struct _s3dw_widget *widget)
{
  free((void *)widget);
}

// s3dw_scrollbar_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/scrollbar.c line 360
void s3dw_scrollbar_destroy(struct _s3dw_widget *widget)
{
  struct _s3dw_scrollbar *scrollbar = (struct _s3dw_scrollbar *)widget;
  s3dw_scrollbar_erase(widget);
  free((void *)scrollbar);
}

// s3dw_scrollbar_draw
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/scrollbar.c line 31
static void s3dw_scrollbar_draw(struct _s3dw_widget *widget)
{
  struct _s3dw_scrollbar *scrollbar = (struct _s3dw_scrollbar *)widget;
  float back_vertices[96l];
  signed int i;
  signed int j;
  unsigned int back_polygons[176l] = { (unsigned int)0, (unsigned int)4, (unsigned int)5, (unsigned int)0, (unsigned int)0, (unsigned int)5, (unsigned int)1, (unsigned int)0, (unsigned int)1, (unsigned int)5, (unsigned int)6, (unsigned int)0, (unsigned int)1, (unsigned int)6, (unsigned int)2, (unsigned int)0, (unsigned int)3, (unsigned int)2, (unsigned int)7, (unsigned int)0, (unsigned int)7, (unsigned int)2, (unsigned int)6, (unsigned int)0, (unsigned int)3, (unsigned int)7, (unsigned int)4, (unsigned int)0, (unsigned int)3, (unsigned int)4, (unsigned int)0, (unsigned int)0, (unsigned int)12, (unsigned int)13, (unsigned int)9, (unsigned int)0, (unsigned int)12, (unsigned int)9, (unsigned int)8, (unsigned int)0, (unsigned int)14, (unsigned int)15, (unsigned int)11, (unsigned int)0, (unsigned int)14, (unsigned int)11, (unsigned int)10, (unsigned int)0, (unsigned int)9, (unsigned int)16, (unsigned int)17, (unsigned int)0, (unsigned int)9, (unsigned int)17, (unsigned int)10, (unsigned int)0, (unsigned int)17, (unsigned int)18, (unsigned int)14, (unsigned int)0, (unsigned int)17, (unsigned int)14, (unsigned int)10, (unsigned int)0, (unsigned int)13, (unsigned int)14, (unsigned int)18, (unsigned int)0, (unsigned int)13, (unsigned int)18, (unsigned int)19, (unsigned int)0, (unsigned int)13, (unsigned int)19, (unsigned int)16, (unsigned int)0, (unsigned int)13, (unsigned int)16, (unsigned int)9, (unsigned int)0, (unsigned int)19, (unsigned int)18, (unsigned int)17, (unsigned int)0, (unsigned int)19, (unsigned int)17, (unsigned int)16, (unsigned int)0, (unsigned int)7, (unsigned int)6, (unsigned int)15, (unsigned int)0, (unsigned int)7, (unsigned int)15, (unsigned int)14, (unsigned int)0, (unsigned int)7, (unsigned int)14, (unsigned int)13, (unsigned int)0, (unsigned int)7, (unsigned int)13, (unsigned int)12, (unsigned int)0, (unsigned int)20, (unsigned int)23, (unsigned int)24, (unsigned int)0, (unsigned int)20, (unsigned int)24, (unsigned int)21, (unsigned int)0, (unsigned int)21, (unsigned int)24, (unsigned int)25, (unsigned int)0, (unsigned int)21, (unsigned int)25, (unsigned int)22, (unsigned int)0, (unsigned int)20, (unsigned int)22, (unsigned int)25, (unsigned int)0, (unsigned int)20, (unsigned int)25, (unsigned int)23, (unsigned int)0, (unsigned int)23, (unsigned int)25, (unsigned int)24, (unsigned int)0, (unsigned int)4, (unsigned int)8, (unsigned int)9, (unsigned int)0, (unsigned int)4, (unsigned int)9, (unsigned int)10, (unsigned int)0, (unsigned int)4, (unsigned int)10, (unsigned int)11, (unsigned int)0, (unsigned int)4, (unsigned int)11, (unsigned int)5, (unsigned int)0, (unsigned int)26, (unsigned int)27, (unsigned int)31, (unsigned int)0, (unsigned int)26, (unsigned int)31, (unsigned int)30, (unsigned int)0, (unsigned int)31, (unsigned int)27, (unsigned int)28, (unsigned int)0, (unsigned int)31, (unsigned int)28, (unsigned int)29, (unsigned int)0, (unsigned int)26, (unsigned int)30, (unsigned int)29, (unsigned int)0, (unsigned int)26, (unsigned int)29, (unsigned int)28, (unsigned int)0, (unsigned int)30, (unsigned int)31, (unsigned int)29, (unsigned int)0 };
  unsigned int bar_polygons[56l] = { (unsigned int)0, (unsigned int)4, (unsigned int)5, (unsigned int)0, (unsigned int)0, (unsigned int)5, (unsigned int)1, (unsigned int)0, (unsigned int)1, (unsigned int)5, (unsigned int)6, (unsigned int)0, (unsigned int)1, (unsigned int)6, (unsigned int)2, (unsigned int)0, (unsigned int)3, (unsigned int)2, (unsigned int)6, (unsigned int)0, (unsigned int)3, (unsigned int)6, (unsigned int)7, (unsigned int)0, (unsigned int)3, (unsigned int)7, (unsigned int)4, (unsigned int)0, (unsigned int)3, (unsigned int)4, (unsigned int)0, (unsigned int)0, (unsigned int)7, (unsigned int)6, (unsigned int)4, (unsigned int)0, (unsigned int)4, (unsigned int)6, (unsigned int)5, (unsigned int)0, (unsigned int)2, (unsigned int)3, (unsigned int)11, (unsigned int)0, (unsigned int)2, (unsigned int)11, (unsigned int)10, (unsigned int)0, (unsigned int)1, (unsigned int)9, (unsigned int)8, (unsigned int)0, (unsigned int)1, (unsigned int)8, (unsigned int)0, (unsigned int)0 };
  float bar_vertices[36l];
  float w;
  float h;
  float temp;
  float tmp_if_expr$1;
  if(scrollbar->type == 1)
    tmp_if_expr$1 = widget->width;

  else
    tmp_if_expr$1 = widget->height;
  w = tmp_if_expr$1;
  float tmp_if_expr$2;
  if(scrollbar->type == 1)
    tmp_if_expr$2 = widget->height;

  else
    tmp_if_expr$2 = widget->width;
  h = tmp_if_expr$2;
  back_vertices[(signed long int)(0 * 3 + 0)] = (float)((double)w * 0.0);
  back_vertices[(signed long int)(0 * 3 + 1)] = (float)(0.0 - (double)h);
  back_vertices[(signed long int)(0 * 3 + 2)] = (float)0.0;
  back_vertices[(signed long int)(1 * 3 + 0)] = (float)((double)w * 1.0);
  back_vertices[(signed long int)(1 * 3 + 1)] = (float)(0.0 - (double)h);
  back_vertices[(signed long int)(1 * 3 + 2)] = (float)0.0;
  back_vertices[(signed long int)(2 * 3 + 0)] = (float)((double)w * 1.0);
  back_vertices[(signed long int)(2 * 3 + 1)] = (float)0.0;
  back_vertices[(signed long int)(2 * 3 + 2)] = (float)0.0;
  back_vertices[(signed long int)(3 * 3 + 0)] = (float)((double)w * 0.0);
  back_vertices[(signed long int)(3 * 3 + 1)] = (float)0.0;
  back_vertices[(signed long int)(3 * 3 + 2)] = (float)0.0;
  back_vertices[(signed long int)(4 * 3 + 0)] = (float)((double)w * 0.125);
  back_vertices[(signed long int)(4 * 3 + 1)] = (float)((double)w * 0.125 - (double)h);
  back_vertices[(signed long int)(4 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(5 * 3 + 0)] = (float)((double)w * 0.875);
  back_vertices[(signed long int)(5 * 3 + 1)] = (float)((double)w * 0.125 - (double)h);
  back_vertices[(signed long int)(5 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(6 * 3 + 0)] = (float)((double)w * 0.875);
  back_vertices[(signed long int)(6 * 3 + 1)] = (float)((double)w * -0.125);
  back_vertices[(signed long int)(6 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(7 * 3 + 0)] = (float)((double)w * 0.125);
  back_vertices[(signed long int)(7 * 3 + 1)] = (float)((double)w * -0.125);
  back_vertices[(signed long int)(7 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(8 * 3 + 0)] = (float)((double)w * 0.125);
  back_vertices[(signed long int)(8 * 3 + 1)] = w - h;
  back_vertices[(signed long int)(8 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(9 * 3 + 0)] = (float)((double)w * 0.25);
  back_vertices[(signed long int)(9 * 3 + 1)] = w - h;
  back_vertices[(signed long int)(9 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(10 * 3 + 0)] = (float)((double)w * 0.75);
  back_vertices[(signed long int)(10 * 3 + 1)] = w - h;
  back_vertices[(signed long int)(10 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(11 * 3 + 0)] = (float)((double)w * 0.875);
  back_vertices[(signed long int)(11 * 3 + 1)] = w - h;
  back_vertices[(signed long int)(11 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(12 * 3 + 0)] = (float)((double)w * 0.125);
  back_vertices[(signed long int)(12 * 3 + 1)] = -w;
  back_vertices[(signed long int)(12 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(13 * 3 + 0)] = (float)((double)w * 0.25);
  back_vertices[(signed long int)(13 * 3 + 1)] = -w;
  back_vertices[(signed long int)(13 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(14 * 3 + 0)] = (float)((double)w * 0.75);
  back_vertices[(signed long int)(14 * 3 + 1)] = -w;
  back_vertices[(signed long int)(14 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(15 * 3 + 0)] = (float)((double)w * 0.875);
  back_vertices[(signed long int)(15 * 3 + 1)] = -w;
  back_vertices[(signed long int)(15 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(16 * 3 + 0)] = (float)((double)w * 0.25);
  back_vertices[(signed long int)(16 * 3 + 1)] = (float)(((double)w * 0.125 - (double)h) + (double)w);
  back_vertices[(signed long int)(16 * 3 + 2)] = (float)0.125;
  back_vertices[(signed long int)(17 * 3 + 0)] = (float)((double)w * 0.75);
  back_vertices[(signed long int)(17 * 3 + 1)] = (float)(((double)w * 0.125 - (double)h) + (double)w);
  back_vertices[(signed long int)(17 * 3 + 2)] = (float)0.125;
  back_vertices[(signed long int)(18 * 3 + 0)] = (float)((double)w * 0.75);
  back_vertices[(signed long int)(18 * 3 + 1)] = (float)((double)w * -0.125 - (double)w);
  back_vertices[(signed long int)(18 * 3 + 2)] = (float)0.125;
  back_vertices[(signed long int)(19 * 3 + 0)] = (float)((double)w * 0.25);
  back_vertices[(signed long int)(19 * 3 + 1)] = (float)((double)w * -0.125 - (double)w);
  back_vertices[(signed long int)(19 * 3 + 2)] = (float)0.125;
  back_vertices[(signed long int)(20 * 3 + 0)] = (float)((double)w * 0.25);
  back_vertices[(signed long int)(20 * 3 + 1)] = (float)((double)w * -0.875);
  back_vertices[(signed long int)(20 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(21 * 3 + 0)] = (float)((double)w * 0.75);
  back_vertices[(signed long int)(21 * 3 + 1)] = (float)((double)w * -0.875);
  back_vertices[(signed long int)(21 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(22 * 3 + 0)] = (float)((double)w * 0.5);
  back_vertices[(signed long int)(22 * 3 + 1)] = (float)((double)w * -0.25);
  back_vertices[(signed long int)(22 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(23 * 3 + 0)] = (float)((double)w * 0.375);
  back_vertices[(signed long int)(23 * 3 + 1)] = (float)((double)w * -0.75);
  back_vertices[(signed long int)(23 * 3 + 2)] = (float)0.375;
  back_vertices[(signed long int)(24 * 3 + 0)] = (float)((double)w * 0.625);
  back_vertices[(signed long int)(24 * 3 + 1)] = (float)((double)w * -0.75);
  back_vertices[(signed long int)(24 * 3 + 2)] = (float)0.375;
  back_vertices[(signed long int)(25 * 3 + 0)] = (float)((double)w * 0.5);
  back_vertices[(signed long int)(25 * 3 + 1)] = (float)((double)w * -0.375);
  back_vertices[(signed long int)(25 * 3 + 2)] = (float)0.375;
  back_vertices[(signed long int)(26 * 3 + 0)] = (float)((double)w * 0.25);
  back_vertices[(signed long int)(26 * 3 + 1)] = (float)((double)-h + (double)w * 0.875);
  back_vertices[(signed long int)(26 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(27 * 3 + 0)] = (float)((double)w * 0.75);
  back_vertices[(signed long int)(27 * 3 + 1)] = (float)((double)-h + (double)w * 0.875);
  back_vertices[(signed long int)(27 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(28 * 3 + 0)] = (float)((double)w * 0.5);
  back_vertices[(signed long int)(28 * 3 + 1)] = (float)((double)-h + (double)w * 0.25);
  back_vertices[(signed long int)(28 * 3 + 2)] = (float)0.25;
  back_vertices[(signed long int)(29 * 3 + 0)] = (float)((double)w * 0.375);
  back_vertices[(signed long int)(29 * 3 + 1)] = (float)((double)-h + (double)w * 0.75);
  back_vertices[(signed long int)(29 * 3 + 2)] = (float)0.375;
  back_vertices[(signed long int)(30 * 3 + 0)] = (float)((double)w * 0.625);
  back_vertices[(signed long int)(30 * 3 + 1)] = (float)((double)-h + (double)w * 0.75);
  back_vertices[(signed long int)(30 * 3 + 2)] = (float)0.375;
  back_vertices[(signed long int)(31 * 3 + 0)] = (float)((double)w * 0.5);
  back_vertices[(signed long int)(31 * 3 + 1)] = (float)((double)-h + (double)w * 0.375);
  back_vertices[(signed long int)(31 * 3 + 2)] = (float)0.375;
  bar_vertices[(signed long int)(0 * 3 + 0)] = (float)((double)w * 0.25);
  bar_vertices[(signed long int)(0 * 3 + 1)] = (float)((double)-(h - (float)3) + (double)w * 0.125);
  bar_vertices[(signed long int)(0 * 3 + 2)] = (float)0.25;
  bar_vertices[(signed long int)(1 * 3 + 0)] = (float)((double)w * 0.75);
  bar_vertices[(signed long int)(1 * 3 + 1)] = (float)((double)-(h - (float)3) + (double)w * 0.125);
  bar_vertices[(signed long int)(1 * 3 + 2)] = (float)0.25;
  bar_vertices[(signed long int)(2 * 3 + 0)] = (float)((double)w * 0.75);
  bar_vertices[(signed long int)(2 * 3 + 1)] = (float)((double)-w * 0.125);
  bar_vertices[(signed long int)(2 * 3 + 2)] = (float)0.25;
  bar_vertices[(signed long int)(3 * 3 + 0)] = (float)((double)w * 0.25);
  bar_vertices[(signed long int)(3 * 3 + 1)] = (float)((double)-w * 0.125);
  bar_vertices[(signed long int)(3 * 3 + 2)] = (float)0.25;
  bar_vertices[(signed long int)(4 * 3 + 0)] = (float)((double)w * 0.125);
  bar_vertices[(signed long int)(4 * 3 + 1)] = (float)((double)-(h - (float)3) + (double)w * 0.25);
  bar_vertices[(signed long int)(4 * 3 + 2)] = (float)0.375;
  bar_vertices[(signed long int)(5 * 3 + 0)] = (float)((double)w * 0.875);
  bar_vertices[(signed long int)(5 * 3 + 1)] = (float)((double)-(h - (float)3) + (double)w * 0.25);
  bar_vertices[(signed long int)(5 * 3 + 2)] = (float)0.375;
  bar_vertices[(signed long int)(6 * 3 + 0)] = (float)((double)w * 0.875);
  bar_vertices[(signed long int)(6 * 3 + 1)] = (float)((double)-w * 0.25);
  bar_vertices[(signed long int)(6 * 3 + 2)] = (float)0.375;
  bar_vertices[(signed long int)(7 * 3 + 0)] = (float)((double)w * 0.125);
  bar_vertices[(signed long int)(7 * 3 + 1)] = (float)((double)-w * 0.25);
  bar_vertices[(signed long int)(7 * 3 + 2)] = (float)0.375;
  bar_vertices[(signed long int)(8 * 3 + 0)] = (float)((double)w * 0.125);
  bar_vertices[(signed long int)(8 * 3 + 1)] = (float)((double)-(h - (float)3) + (double)w * 0.25);
  bar_vertices[(signed long int)(8 * 3 + 2)] = (float)0.175;
  bar_vertices[(signed long int)(9 * 3 + 0)] = (float)((double)w * 0.875);
  bar_vertices[(signed long int)(9 * 3 + 1)] = (float)((double)-(h - (float)3) + (double)w * 0.25);
  bar_vertices[(signed long int)(9 * 3 + 2)] = (float)0.175;
  bar_vertices[(signed long int)(10 * 3 + 0)] = (float)((double)w * 0.875);
  bar_vertices[(signed long int)(10 * 3 + 1)] = (float)((double)-w * 0.25);
  bar_vertices[(signed long int)(10 * 3 + 2)] = (float)0.175;
  bar_vertices[(signed long int)(11 * 3 + 0)] = (float)((double)w * 0.125);
  bar_vertices[(signed long int)(11 * 3 + 1)] = (float)((double)-w * 0.25);
  bar_vertices[(signed long int)(11 * 3 + 2)] = (float)0.175;
  if(scrollbar->type == 0)
  {
    i = 0;
    for( ; !(i >= 32); i = i + 1)
    {
      temp = back_vertices[(signed long int)(i * 3)];
      back_vertices[(signed long int)(i * 3)] = -back_vertices[(signed long int)(i * 3 + 1)];
      back_vertices[(signed long int)(i * 3 + 1)] = -temp;
    }
    i = 0;
    for( ; !(i >= 44); i = i + 1)
    {
      j = (signed int)back_polygons[(signed long int)(i * 4)];
      back_polygons[(signed long int)(i * 4)] = back_polygons[(signed long int)(i * 4 + 1)];
      back_polygons[(signed long int)(i * 4 + 1)] = (unsigned int)j;
    }
    i = 0;
    for( ; !(i >= 12); i = i + 1)
    {
      temp = bar_vertices[(signed long int)(i * 3)];
      bar_vertices[(signed long int)(i * 3)] = -bar_vertices[(signed long int)(i * 3 + 1)];
      bar_vertices[(signed long int)(i * 3 + 1)] = -temp;
    }
    i = 0;
    for( ; !(i >= 14); i = i + 1)
    {
      j = (signed int)bar_polygons[(signed long int)(i * 4)];
      bar_polygons[(signed long int)(i * 4)] = bar_polygons[(signed long int)(i * 4 + 1)];
      bar_polygons[(signed long int)(i * 4 + 1)] = (unsigned int)j;
    }
  }

  signed int return_value_s3d_new_object$3;
  return_value_s3d_new_object$3=s3d_new_object();
  widget->oid = (unsigned int)return_value_s3d_new_object$3;
  scrollbar->loid=s3d_new_object();
  scrollbar->roid=s3d_new_object();
  scrollbar->baroid=s3d_new_object();
  s3d_push_materials_a((signed int)widget->oid, widget->style->input_mat, (unsigned short int)1);
  s3d_push_materials_a(scrollbar->loid, widget->style->input_mat, (unsigned short int)1);
  s3d_push_materials_a(scrollbar->roid, widget->style->input_mat, (unsigned short int)1);
  s3d_push_materials_a(scrollbar->baroid, widget->style->input_mat, (unsigned short int)1);
  s3d_push_vertices((signed int)widget->oid, back_vertices, (unsigned short int)20);
  s3d_push_vertices(scrollbar->loid, back_vertices, (unsigned short int)32);
  s3d_push_vertices(scrollbar->roid, back_vertices, (unsigned short int)32);
  s3d_push_vertices(scrollbar->baroid, bar_vertices, (unsigned short int)12);
  s3d_push_polygons((signed int)widget->oid, back_polygons, (unsigned short int)22);
  s3d_push_polygons(scrollbar->loid, back_polygons + (signed long int)(4 * 22), (unsigned short int)11);
  s3d_push_polygons(scrollbar->roid, back_polygons + (signed long int)(4 * 33), (unsigned short int)11);
  s3d_push_polygons(scrollbar->baroid, bar_polygons, (unsigned short int)14);
  s3d_link((signed int)widget->oid, (signed int)widget->parent->oid);
  s3d_link(scrollbar->loid, (signed int)widget->oid);
  s3d_link(scrollbar->roid, (signed int)widget->oid);
  s3d_link(scrollbar->baroid, (signed int)widget->oid);
  s3d_translate((signed int)widget->oid, widget->x, -widget->y, (float)0);
  if(scrollbar->type == 1)
    s3d_translate(scrollbar->baroid, (float)0, (float)-1.5, (float)0);

  else
    s3d_translate(scrollbar->baroid, (float)1.5, (float)0, (float)0);
}

// s3dw_scrollbar_erase
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/scrollbar.c line 351
void s3dw_scrollbar_erase(struct _s3dw_widget *widget)
{
  struct _s3dw_scrollbar *scrollbar = (struct _s3dw_scrollbar *)widget;
  s3d_del_object((signed int)widget->oid);
  s3d_del_object(scrollbar->loid);
  s3d_del_object(scrollbar->roid);
  s3d_del_object(scrollbar->baroid);
}

// s3dw_scrollbar_event_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/scrollbar.c line 372
signed int s3dw_scrollbar_event_click(struct _s3dw_widget *widget, unsigned int oid)
{
  struct _s3dw_scrollbar *scrollbar = (struct _s3dw_scrollbar *)widget;
  if(scrollbar->loid == (signed int)oid)
  {
    scrollbar->lonclick(widget);
    return 1;
  }

  else
    if(scrollbar->roid == (signed int)oid)
    {
      scrollbar->ronclick(widget);
      return 1;
    }

    else
      return 0;
}

// s3dw_scrollbar_event_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/scrollbar.c line 367
signed int s3dw_scrollbar_event_key(struct _s3dw_widget *widget, struct s3d_key_event *keys)
{
  return 0;
}

// s3dw_scrollbar_hide
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/scrollbar.c line 314
void s3dw_scrollbar_hide(struct _s3dw_widget *widget)
{
  struct _s3dw_scrollbar *scrollbar = (struct _s3dw_scrollbar *)widget;
  s3d_flags_off((signed int)widget->oid, (unsigned int)(0x00000001 | 0x00000002));
  s3d_flags_off(scrollbar->loid, (unsigned int)(0x00000001 | 0x00000002));
  s3d_flags_off(scrollbar->roid, (unsigned int)(0x00000001 | 0x00000002));
  s3d_flags_off(scrollbar->baroid, (unsigned int)(0x00000001 | 0x00000002));
}

// s3dw_scrollbar_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/scrollbar.c line 324
struct _s3dw_scrollbar * s3dw_scrollbar_new(struct _s3dw_widget *parent, signed int type, float posx, float posy, float length)
{
  struct _s3dw_scrollbar *scrollbar;
  struct _s3dw_widget *widget;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _s3dw_scrollbar) /*168ul*/ );
  scrollbar = (struct _s3dw_scrollbar *)return_value_malloc$1;
  widget=s3dw_widget_new((struct _s3dw_widget *)scrollbar);
  widget->type = 7;
  scrollbar->type = type;
  if(scrollbar->type == 0)
  {
    widget->height = (float)1;
    widget->width = length;
  }

  else
  {
    widget->width = (float)1;
    widget->height = length;
  }
  widget->x = posx;
  widget->y = posy;
  widget->oid = (unsigned int)-1;
  scrollbar->loid = -1;
  scrollbar->roid = -1;
  scrollbar->baroid = -1;
  scrollbar->lonclick = s3dw_nothing;
  scrollbar->ronclick = s3dw_nothing;
  s3dw_widget_append(parent, widget);
  s3dw_scrollbar_draw(widget);
  return scrollbar;
}

// s3dw_scrollbar_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/scrollbar.c line 304
void s3dw_scrollbar_show(struct _s3dw_widget *widget)
{
  struct _s3dw_scrollbar *scrollbar = (struct _s3dw_scrollbar *)widget;
  s3d_flags_on((signed int)widget->oid, (unsigned int)(0x00000001 | 0x00000002));
  s3d_flags_on(scrollbar->loid, (unsigned int)(0x00000001 | 0x00000002));
  s3d_flags_on(scrollbar->roid, (unsigned int)(0x00000001 | 0x00000002));
  s3d_flags_on(scrollbar->baroid, (unsigned int)(0x00000001 | 0x00000002));
}

// s3dw_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 119
void s3dw_show(struct _s3dw_widget *widget)
{
  widget->flags = widget->flags | 1;
  s3dw_widget_visible(widget);
}

// s3dw_surface_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/surface.c line 172
void s3dw_surface_destroy(struct _s3dw_widget *widget)
{
  struct _s3dw_surface *surface = (struct _s3dw_surface *)widget;
  s3dw_surface_erase(widget);
  free((void *)surface->title);
  free((void *)surface);
}

// s3dw_surface_draw
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/surface.c line 32
void s3dw_surface_draw(struct _s3dw_widget *widget)
{
  struct _s3dw_surface *surface = (struct _s3dw_surface *)widget;
  signed int textlen;
  float length;
  float vertices[24l] = { (float)0, (float)0, (float)0, (float)1, (float)0, (float)0, (float)1, (float)1, (float)0, (float)0, (float)1, (float)0, (float)0, (float)0, (float)1, (float)1, (float)0, (float)1, (float)1, (float)1, (float)1, (float)0, (float)1, (float)1 };
  float sver[24l];
  float tver[24l];
  unsigned int polygon[40l] = { (unsigned int)0, (unsigned int)1, (unsigned int)2, (unsigned int)0, (unsigned int)0, (unsigned int)2, (unsigned int)3, (unsigned int)0, (unsigned int)1, (unsigned int)5, (unsigned int)6, (unsigned int)0, (unsigned int)1, (unsigned int)6, (unsigned int)2, (unsigned int)0, (unsigned int)2, (unsigned int)6, (unsigned int)7, (unsigned int)0, (unsigned int)2, (unsigned int)7, (unsigned int)3, (unsigned int)0, (unsigned int)4, (unsigned int)0, (unsigned int)3, (unsigned int)0, (unsigned int)4, (unsigned int)3, (unsigned int)7, (unsigned int)0, (unsigned int)5, (unsigned int)4, (unsigned int)7, (unsigned int)0, (unsigned int)5, (unsigned int)7, (unsigned int)6, (unsigned int)0 };
  unsigned int tpol[40l];
  signed int i;
  signed int return_value_s3d_new_object$1;
  return_value_s3d_new_object$1=s3d_new_object();
  widget->oid = (unsigned int)return_value_s3d_new_object$1;
  signed int return_value_s3d_new_object$2;
  return_value_s3d_new_object$2=s3d_new_object();
  surface->oid_tbar = (unsigned int)return_value_s3d_new_object$2;
  s3d_select_font("vera");
  signed int return_value_s3d_draw_string$3;
  return_value_s3d_draw_string$3=s3d_draw_string(surface->title, &length);
  surface->oid_title = (unsigned int)return_value_s3d_draw_string$3;
  while(length > widget->width + 1.000000f)
  {
    s3dprintf(4, "%f > %f", length, widget->width + (float)1);
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(surface->title);
    textlen = (signed int)return_value_strlen$4;
    if((double)length > (double)(widget->width + 1.000000f) * 1.3)
      textlen = (signed int)((double)textlen * (((double)(widget->width + (float)1) * 1.1) / (double)length));

    if(textlen >= 5)
    {
      surface->title[(signed long int)(textlen - 2)] = (char)0;
      surface->title[(signed long int)(textlen - 3)] = (char)46;
      surface->title[(signed long int)(textlen - 4)] = (char)46;
      s3d_del_object((signed int)surface->oid_title);
      signed int return_value_s3d_draw_string$5;
      return_value_s3d_draw_string$5=s3d_draw_string(surface->title, &length);
      surface->oid_title = (unsigned int)return_value_s3d_draw_string$5;
    }

    else
      break;
  }
  i = 0;
  for( ; !(i >= 8); i = i + 1)
  {
    sver[(signed long int)(i * 3 + 0)] = vertices[(signed long int)(i * 3 + 0)] * widget->width;
    sver[(signed long int)(i * 3 + 1)] = vertices[(signed long int)(i * 3 + 1)] * -widget->height;
    sver[(signed long int)(i * 3 + 2)] = vertices[(signed long int)(i * 3 + 2)] * (float)-1;
    tver[(signed long int)(i * 3 + 0)] = vertices[(signed long int)(i * 3 + 0)] * widget->width;
    tver[(signed long int)(i * 3 + 1)] = vertices[(signed long int)(i * 3 + 1)];
    tver[(signed long int)(i * 3 + 2)] = vertices[(signed long int)(i * 3 + 2)] * (float)-1;
  }
  i = 0;
  for( ; !(i >= 10); i = i + 1)
  {
    tpol[(signed long int)(i * 4 + 0)] = polygon[(signed long int)(i * 4 + 1)];
    tpol[(signed long int)(i * 4 + 1)] = polygon[(signed long int)(i * 4 + 0)];
    tpol[(signed long int)(i * 4 + 2)] = polygon[(signed long int)(i * 4 + 2)];
    tpol[(signed long int)(i * 4 + 3)] = polygon[(signed long int)(i * 4 + 3)];
  }
  s3d_push_vertices((signed int)widget->oid, sver, (unsigned short int)8);
  s3d_push_vertices((signed int)surface->oid_tbar, tver, (unsigned short int)8);
  s3d_push_materials_a((signed int)widget->oid, widget->style->surface_mat, (unsigned short int)1);
  s3d_push_materials_a((signed int)surface->oid_tbar, widget->style->title_mat, (unsigned short int)1);
  s3d_pep_materials_a((signed int)surface->oid_title, widget->style->title_text_mat, (unsigned short int)1);
  s3d_push_polygons((signed int)widget->oid, polygon, (unsigned short int)10);
  s3d_push_polygons((signed int)surface->oid_tbar, tpol, (unsigned short int)10);
  s3d_link((signed int)surface->oid_tbar, (signed int)widget->oid);
  s3d_link((signed int)surface->oid_title, (signed int)surface->oid_tbar);
  s3d_link((signed int)widget->oid, (signed int)widget->parent->oid);
  s3d_translate((signed int)surface->oid_title, (float)0.5, (float)0.2, (float)0.1);
  s3d_scale((signed int)widget->oid, widget->as);
  s3d_translate((signed int)widget->oid, widget->ax, widget->ay, widget->az);
}

// s3dw_surface_erase
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/surface.c line 164
void s3dw_surface_erase(struct _s3dw_widget *widget)
{
  struct _s3dw_surface *surface = (struct _s3dw_surface *)widget;
  s3d_del_object((signed int)widget->oid);
  s3d_del_object((signed int)surface->oid_tbar);
  s3d_del_object((signed int)surface->oid_title);
}

// s3dw_surface_event_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/surface.c line 185
signed int s3dw_surface_event_click(struct _s3dw_widget *widget, unsigned int oid)
{
  struct _s3dw_surface *surface = (struct _s3dw_surface *)widget;
  _Bool tmp_if_expr$1;
  if(widget->oid == oid)
  {
    s3dw_focus(widget);
    s3dprintf(3, "body %s clicked", surface->title);
    return 1;
  }

  else
  {
    if(surface->oid_tbar == oid)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = surface->oid_title == oid ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      s3dw_focus(widget);
      s3dprintf(3, "title %s clicked", surface->title);
      return 1;
    }

    else
      return 0;
  }
}

// s3dw_surface_event_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/surface.c line 180
signed int s3dw_surface_event_key(struct _s3dw_widget *widget, struct s3d_key_event *keys)
{
  return 0;
}

// s3dw_surface_hide
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/surface.c line 121
void s3dw_surface_hide(struct _s3dw_widget *widget)
{
  struct _s3dw_surface *surface = (struct _s3dw_surface *)widget;
  s3d_flags_off((signed int)widget->oid, (unsigned int)(0x00000001 | 0x00000002));
  s3d_flags_off((signed int)surface->oid_title, (unsigned int)(0x00000001 | 0x00000002));
  s3d_flags_off((signed int)surface->oid_tbar, (unsigned int)(0x00000001 | 0x00000002));
}

// s3dw_surface_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/surface.c line 136
struct _s3dw_surface * s3dw_surface_new(const char *title, float width, float height)
{
  struct _s3dw_surface *surface;
  struct _s3dw_widget *widget;
  float f1[3l];
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _s3dw_surface) /*144ul*/ );
  surface = (struct _s3dw_surface *)return_value_malloc$1;
  surface->title=strdup(title);
  widget=s3dw_widget_new((struct _s3dw_widget *)surface);
  widget->type = 2;
  widget->width = width;
  widget->height = height;
  widget->as = (float)0.01;
  s3dw_arr_widgetcenter(widget, f1);
  struct _s3dw_widget *return_value_s3dw_getroot$2;
  return_value_s3dw_getroot$2=s3dw_getroot();
  s3dw_widget_append(return_value_s3dw_getroot$2, widget);
  double return_value_sin$3;
  return_value_sin$3=sin(((double)_s3dw_cam->ry * 3.14159265358979323846) / (double)180);
  double return_value_cos$4;
  return_value_cos$4=cos(((double)_s3dw_cam->rx * 3.14159265358979323846) / (double)180);
  widget->x = (float)((double)(-f1[(signed long int)0] + _s3dw_cam->x) - return_value_sin$3 * return_value_cos$4 * (double)20);
  double return_value_sin$5;
  return_value_sin$5=sin(((double)_s3dw_cam->rx * 3.14159265358979323846) / (double)180);
  widget->y = (float)((double)(-f1[(signed long int)1] + _s3dw_cam->y) + return_value_sin$5 * (double)20);
  double return_value_cos$6;
  return_value_cos$6=cos(((double)_s3dw_cam->ry * 3.14159265358979323846) / (double)180);
  double return_value_cos$7;
  return_value_cos$7=cos(((double)_s3dw_cam->rx * 3.14159265358979323846) / (double)180);
  widget->z = (float)((double)(-f1[(signed long int)2] + _s3dw_cam->z) - return_value_cos$6 * return_value_cos$7 * (double)20);
  widget->ax = widget->x;
  widget->ay = widget->y;
  widget->az = widget->z;
  widget->flags = widget->flags | 1024 | 2048;
  s3dw_surface_draw(widget);
  s3dw_ani_needarr();
  s3dw_ani_add(widget);
  return surface;
}

// s3dw_surface_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/surface.c line 113
void s3dw_surface_show(struct _s3dw_widget *widget)
{
  struct _s3dw_surface *surface = (struct _s3dw_surface *)widget;
  s3d_flags_on((signed int)widget->oid, (unsigned int)(0x00000001 | 0x00000002));
  s3d_flags_on((signed int)surface->oid_title, (unsigned int)(0x00000001 | 0x00000002));
  s3d_flags_on((signed int)surface->oid_tbar, (unsigned int)(0x00000001 | 0x00000002));
}

// s3dw_textbox_change_text
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 304
void s3dw_textbox_change_text(struct _s3dw_textbox *textbox, const char *text)
{
  struct _s3dw_widget *widget = (struct _s3dw_widget *)textbox;
  free((void *)textbox->text);
  textbox->text=strdup(text);
  s3dw_textbox_redraw(widget);
}

// s3dw_textbox_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 319
void s3dw_textbox_destroy(struct _s3dw_widget *widget)
{
  struct _s3dw_textbox *textbox = (struct _s3dw_textbox *)widget;
  s3dw_textbox_erase(widget);
  free((void *)textbox->text);
  free((void *)textbox);
}

// s3dw_textbox_draw
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 31
static void s3dw_textbox_draw(struct _s3dw_widget *widget)
{
  float h;
  float w;
  float vertices[36l];
  unsigned int polygons[72l] = { (unsigned int)0, (unsigned int)4, (unsigned int)5, (unsigned int)1, (unsigned int)0, (unsigned int)5, (unsigned int)1, (unsigned int)1, (unsigned int)1, (unsigned int)5, (unsigned int)6, (unsigned int)1, (unsigned int)1, (unsigned int)6, (unsigned int)2, (unsigned int)1, (unsigned int)2, (unsigned int)6, (unsigned int)7, (unsigned int)1, (unsigned int)2, (unsigned int)7, (unsigned int)3, (unsigned int)1, (unsigned int)3, (unsigned int)7, (unsigned int)4, (unsigned int)1, (unsigned int)3, (unsigned int)4, (unsigned int)0, (unsigned int)1, (unsigned int)4, (unsigned int)8, (unsigned int)9, (unsigned int)1, (unsigned int)4, (unsigned int)9, (unsigned int)5, (unsigned int)1, (unsigned int)5, (unsigned int)9, (unsigned int)10, (unsigned int)1, (unsigned int)5, (unsigned int)10, (unsigned int)6, (unsigned int)1, (unsigned int)6, (unsigned int)10, (unsigned int)11, (unsigned int)1, (unsigned int)6, (unsigned int)11, (unsigned int)7, (unsigned int)1, (unsigned int)7, (unsigned int)11, (unsigned int)8, (unsigned int)1, (unsigned int)7, (unsigned int)8, (unsigned int)4, (unsigned int)1, (unsigned int)8, (unsigned int)11, (unsigned int)10, (unsigned int)0, (unsigned int)8, (unsigned int)10, (unsigned int)9, (unsigned int)0 };
  w = widget->width - (float)2;
  h = widget->height - (float)3;
  if(!(widget->width < 1.000000f))
  {
    vertices[(signed long int)(0 * 3 + 0)] = (float)0.0;
    vertices[(signed long int)(0 * 3 + 1)] = (float)0.0;
    vertices[(signed long int)(0 * 3 + 2)] = (float)0.0;
    vertices[(signed long int)(1 * 3 + 0)] = (float)0.0;
    vertices[(signed long int)(1 * 3 + 1)] = (float)((double)-h - 2.0);
    vertices[(signed long int)(1 * 3 + 2)] = (float)0.0;
    vertices[(signed long int)(2 * 3 + 0)] = w + (float)1;
    vertices[(signed long int)(2 * 3 + 1)] = (float)((double)-h - 2.0);
    vertices[(signed long int)(2 * 3 + 2)] = (float)0.0;
    vertices[(signed long int)(3 * 3 + 0)] = w + (float)1;
    vertices[(signed long int)(3 * 3 + 1)] = (float)0.0;
    vertices[(signed long int)(3 * 3 + 2)] = (float)0.0;
    vertices[(signed long int)(4 * 3 + 0)] = (float)0.125;
    vertices[(signed long int)(4 * 3 + 1)] = (float)-0.125;
    vertices[(signed long int)(4 * 3 + 2)] = (float)0.25;
    vertices[(signed long int)(5 * 3 + 0)] = (float)0.125;
    vertices[(signed long int)(5 * 3 + 1)] = (float)((double)-h - 1.875);
    vertices[(signed long int)(5 * 3 + 2)] = (float)0.25;
    vertices[(signed long int)(6 * 3 + 0)] = (float)((double)w + 0.875);
    vertices[(signed long int)(6 * 3 + 1)] = (float)((double)-h - 1.875);
    vertices[(signed long int)(6 * 3 + 2)] = (float)0.25;
    vertices[(signed long int)(7 * 3 + 0)] = (float)((double)w + 0.875);
    vertices[(signed long int)(7 * 3 + 1)] = (float)-0.125;
    vertices[(signed long int)(7 * 3 + 2)] = (float)0.25;
    vertices[(signed long int)(8 * 3 + 0)] = (float)0.25;
    vertices[(signed long int)(8 * 3 + 1)] = (float)-0.25;
    vertices[(signed long int)(8 * 3 + 2)] = (float)0.125;
    vertices[(signed long int)(9 * 3 + 0)] = (float)0.25;
    vertices[(signed long int)(9 * 3 + 1)] = (float)((double)-h - 1.75);
    vertices[(signed long int)(9 * 3 + 2)] = (float)0.125;
    vertices[(signed long int)(10 * 3 + 0)] = (float)((double)w + 0.75);
    vertices[(signed long int)(10 * 3 + 1)] = (float)((double)-h - 1.75);
    vertices[(signed long int)(10 * 3 + 2)] = (float)0.125;
    vertices[(signed long int)(11 * 3 + 0)] = (float)((double)w + 0.75);
    vertices[(signed long int)(11 * 3 + 1)] = (float)-0.25;
    vertices[(signed long int)(11 * 3 + 2)] = (float)0.125;
    signed int return_value_s3d_new_object$1;
    return_value_s3d_new_object$1=s3d_new_object();
    widget->oid = (unsigned int)return_value_s3d_new_object$1;
    s3d_push_materials_a((signed int)widget->oid, widget->style->inputback_mat, (unsigned short int)1);
    s3d_push_materials_a((signed int)widget->oid, widget->style->input_mat, (unsigned short int)1);
    s3d_push_vertices((signed int)widget->oid, vertices, (unsigned short int)12);
    s3d_push_polygons((signed int)widget->oid, polygons, (unsigned short int)18);
    s3d_link((signed int)widget->oid, (signed int)widget->parent->oid);
    s3d_translate((signed int)widget->oid, widget->x, -widget->y, (float)0);
    s3dw_textbox_drawtext(widget);
  }

}

// s3dw_textbox_drawtext
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 109
void s3dw_textbox_drawtext(struct _s3dw_widget *widget)
{
  struct _s3dw_textbox *textbox = (struct _s3dw_textbox *)widget;
  char *text;
  char *rest;
  char *linefeedpos;
  signed int i;
  signed int x;
  signed int y;
  float width;
  textbox->n_lineoids = (signed int)(widget->height - (float)2);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)textbox->n_lineoids * sizeof(signed int) /*4ul*/ );
  textbox->p_lineoids = (signed int *)return_value_malloc$1;
  width = (float)((double)widget->width - 1.5);
  y = -textbox->window_y;
  x = textbox->window_x;
  i = 0;
  for( ; !(i >= textbox->n_lineoids); i = i + 1)
    textbox->p_lineoids[(signed long int)i] = -1;
  text=strdup(textbox->text);
  rest = text;
  unsigned long int return_value_strlen$2;
  float return_value_s3d_strlen$3;
  unsigned long int return_value_strlen$4;
  do
  {
    linefeedpos=strchr(rest, 10);
    if(linefeedpos == ((char *)NULL))
      break;

    linefeedpos[(signed long int)0] = (char)0;
    unsigned long int return_value_strlen$6;
    return_value_strlen$6=strlen(rest);
    if(!(x >= (signed int)return_value_strlen$6))
    {
      if(y >= 0)
      {
        if(!(y >= textbox->n_lineoids))
        {
          rest = rest + (signed long int)x;
          do
          {
            return_value_strlen$2=strlen(rest);
            if(!(return_value_strlen$2 >= 1ul))
              break;

            return_value_s3d_strlen$3=s3d_strlen(rest);
            if(!(return_value_s3d_strlen$3 > width))
              break;

            return_value_strlen$4=strlen(rest);
            rest[(signed long int)(return_value_strlen$4 - (unsigned long int)1)] = (char)0;
          }
          while((_Bool)1);
          unsigned long int return_value_strlen$5;
          return_value_strlen$5=strlen(rest);
          if(return_value_strlen$5 >= 1ul)
          {
            textbox->p_lineoids[(signed long int)y]=s3d_draw_string(rest, (float *)(void *)0);
            s3d_pep_materials_a(textbox->p_lineoids[(signed long int)y], widget->style->text_mat, (unsigned short int)1);
            s3d_translate(textbox->p_lineoids[(signed long int)y], (float)0.5, (float)(-y - 1), (float)0.30);
            s3d_link(textbox->p_lineoids[(signed long int)y], (signed int)widget->oid);
          }

        }

      }

    }

    rest = linefeedpos + (signed long int)1;
    y = y + 1;
  }
  while((_Bool)1);
  if(!(y >= 0))
    textbox->window_y = textbox->window_y - y;

  free((void *)text);
}

// s3dw_textbox_erase
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 312
void s3dw_textbox_erase(struct _s3dw_widget *widget)
{
  s3dw_textbox_erasetext(widget);
  s3d_del_object((signed int)widget->oid);
}

// s3dw_textbox_erasetext
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 146
void s3dw_textbox_erasetext(struct _s3dw_widget *widget)
{
  struct _s3dw_textbox *textbox = (struct _s3dw_textbox *)widget;
  signed int i;
  if(!(textbox->p_lineoids == ((signed int *)NULL)))
  {
    i = 0;
    for( ; !(i >= textbox->n_lineoids); i = i + 1)
      if(!(textbox->p_lineoids[(signed long int)i] == -1))
        s3d_del_object(textbox->p_lineoids[(signed long int)i]);

    free((void *)textbox->p_lineoids);
    textbox->p_lineoids = (signed int *)(void *)0;
    textbox->n_lineoids = 0;
  }

}

// s3dw_textbox_event_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 332
signed int s3dw_textbox_event_click(struct _s3dw_widget *widget, unsigned int oid)
{
  struct _s3dw_textbox *textbox = (struct _s3dw_textbox *)widget;
  if(widget->oid == oid)
  {
    textbox->onclick(widget);
    return 1;
  }

  else
    return 0;
}

// s3dw_textbox_event_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 327
signed int s3dw_textbox_event_key(struct _s3dw_widget *widget, struct s3d_key_event *keys)
{
  return 0;
}

// s3dw_textbox_hide
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 172
void s3dw_textbox_hide(struct _s3dw_widget *widget)
{
  struct _s3dw_textbox *textbox = (struct _s3dw_textbox *)widget;
  signed int i;
  s3d_flags_off((signed int)widget->oid, (unsigned int)(0x00000001 | 0x00000002));
  i = 0;
  for( ; !(i >= textbox->n_lineoids); i = i + 1)
    s3d_flags_on(textbox->p_lineoids[(signed long int)i], (unsigned int)(0x00000001 | 0x00000002));
}

// s3dw_textbox_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 206
struct _s3dw_textbox * s3dw_textbox_new(const struct _s3dw_surface *surface, const char *text, float posx, float posy, float width, float height)
{
  struct _s3dw_textbox *textbox;
  struct _s3dw_widget *widget;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _s3dw_textbox) /*184ul*/ );
  textbox = (struct _s3dw_textbox *)return_value_malloc$1;
  widget=s3dw_widget_new((struct _s3dw_widget *)textbox);
  widget->type = 6;
  widget->x = posx;
  widget->y = posy;
  widget->width = width;
  widget->height = height;
  textbox->window_x = 0;
  textbox->window_y = 0;
  textbox->p_lineoids = (signed int *)(void *)0;
  textbox->n_lineoids = 0;
  textbox->text=strdup(text);
  textbox->onclick = s3dw_nothing;
  s3dw_widget_append((struct _s3dw_widget *)surface, widget);
  s3dw_textbox_draw(widget);
  textbox->scroll_horizontal=s3dw_scrollbar_new(widget, 0, (float)0, widget->height - (float)1, widget->width - (float)1);
  textbox->scroll_vertical=s3dw_scrollbar_new(widget, 1, widget->width - (float)1, (float)0, widget->height - (float)1);
  textbox->scroll_horizontal->lonclick = _s3dw_textbox_scrollbar_left;
  textbox->scroll_horizontal->ronclick = _s3dw_textbox_scrollbar_right;
  textbox->scroll_vertical->lonclick = _s3dw_textbox_scrollbar_up;
  textbox->scroll_vertical->ronclick = _s3dw_textbox_scrollbar_down;
  return textbox;
}

// s3dw_textbox_redraw
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 234
static void s3dw_textbox_redraw(struct _s3dw_widget *widget)
{
  s3dw_textbox_erasetext(widget);
  s3dw_textbox_drawtext(widget);
  if(!((256 & widget->flags) == 0))
    s3dw_textbox_show(widget);

}

// s3dw_textbox_scrolldown
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 257
void s3dw_textbox_scrolldown(struct _s3dw_textbox *textbox)
{
  textbox->window_y = textbox->window_y + 1;
  s3dw_textbox_redraw((struct _s3dw_widget *)textbox);
}

// s3dw_textbox_scrollleft
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 268
void s3dw_textbox_scrollleft(struct _s3dw_textbox *textbox)
{
  if(textbox->window_x >= 1)
    textbox->window_x = textbox->window_x - 1;

  s3dw_textbox_redraw((struct _s3dw_widget *)textbox);
}

// s3dw_textbox_scrollright
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 279
void s3dw_textbox_scrollright(struct _s3dw_textbox *textbox)
{
  textbox->window_x = textbox->window_x + 1;
  s3dw_textbox_redraw((struct _s3dw_widget *)textbox);
}

// s3dw_textbox_scrollto
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 290
void s3dw_textbox_scrollto(struct _s3dw_textbox *textbox, signed int x, signed int y)
{
  struct _s3dw_widget *widget = (struct _s3dw_widget *)textbox;
  if(!(x >= 0))
    x = 0;

  if(!(y >= 0))
    y = 0;

  textbox->window_x = x;
  textbox->window_y = y;
  s3dw_textbox_redraw(widget);
}

// s3dw_textbox_scrollup
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 246
void s3dw_textbox_scrollup(struct _s3dw_textbox *textbox)
{
  if(textbox->window_y >= 1)
    textbox->window_y = textbox->window_y - 1;

  s3dw_textbox_redraw((struct _s3dw_widget *)textbox);
}

// s3dw_textbox_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/textbox.c line 163
void s3dw_textbox_show(struct _s3dw_widget *widget)
{
  struct _s3dw_textbox *textbox = (struct _s3dw_textbox *)widget;
  signed int i;
  s3d_flags_on((signed int)widget->oid, (unsigned int)(0x00000001 | 0x00000002));
  i = 0;
  for( ; !(i >= textbox->n_lineoids); i = i + 1)
    s3d_flags_on(textbox->p_lineoids[(signed long int)i], (unsigned int)(0x00000001 | 0x00000002));
}

// s3dw_turn
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/arrange.c line 68
void s3dw_turn(void)
{
  struct _s3dw_widget *w;
  struct _s3dw_widget *s3dw_turn$$1$$root;
  s3dw_turn$$1$$root=s3dw_getroot();
  signed int i;
  float a[3l];
  float b[3l];
  float rx;
  float ry;
  float op[3l];
  float np[3l];
  a[(signed long int)0] = (float)0;
  a[(signed long int)1] = (float)0;
  a[(signed long int)2] = (float)1;
  i = 0;
  for( ; !(i >= s3dw_turn$$1$$root->nobj); i = i + 1)
  {
    w = s3dw_turn$$1$$root->pobj[(signed long int)i];
    if(!(w->oid == 0u))
    {
      if(!((2048 & w->flags) == 0))
      {
        s3dw_arr_widgetcenter(w, op);
        b[(signed long int)0] = (w->x + op[(signed long int)0]) - _s3dw_cam->x;
        b[(signed long int)1] = (float)0;
        b[(signed long int)2] = (w->z + op[(signed long int)2]) - _s3dw_cam->z;
        float return_value_s3d_vector_angle$1;
        return_value_s3d_vector_angle$1=s3d_vector_angle(a, b);
        ry = (float)((double)((float)180 * return_value_s3d_vector_angle$1) / 3.14159265358979323846);
        if(IEEE_FLOAT_EQUAL(b[0l], 0.000000f))
        {
          if(IEEE_FLOAT_EQUAL(b[1l], 0.000000f))
          {
            if(IEEE_FLOAT_EQUAL(b[2l], 0.000000f))
              ry = (float)0;

          }

        }

        if(b[0l] < 0.000000f)
          ry = (float)180 - ry;

        else
          ry = (float)180 + ry;
        double return_value_sqrt$2;
        return_value_sqrt$2=sqrt((double)(b[(signed long int)0] * b[(signed long int)0] + b[(signed long int)2] * b[(signed long int)2]));
        b[(signed long int)2] = (float)return_value_sqrt$2;
        b[(signed long int)1] = (w->y + op[(signed long int)1]) - _s3dw_cam->y;
        b[(signed long int)0] = (float)0;
        float return_value_s3d_vector_angle$3;
        return_value_s3d_vector_angle$3=s3d_vector_angle(a, b);
        rx = (float)((double)((float)180 * return_value_s3d_vector_angle$3) / 3.14159265358979323846);
        if(IEEE_FLOAT_EQUAL(b[0l], 0.000000f))
        {
          if(IEEE_FLOAT_EQUAL(b[1l], 0.000000f))
          {
            if(IEEE_FLOAT_EQUAL(b[2l], 0.000000f))
              rx = (float)0;

          }

        }

        if(b[1l] > 0.000000f)
          rx = (float)180 - rx;

        else
          rx = (float)180 + rx;
        if(rx <= 180.000000f && rx > 90.000000f)
          rx = (float)180 - rx;

        else
          if(rx < 270.000000f && rx >= 180.000000f)
            rx = (float)540 - rx;

        w->rx = rx;
        w->ry = ry;
        if(w->arx + -w->rx > 180.000000f)
          w->arx = w->arx - (float)360;

        if(w->arx + -w->rx < -180.000000f)
          w->arx = w->arx + (float)360;

        if(w->ary + -w->ry > 180.000000f)
          w->ary = w->ary - (float)360;

        if(w->ary + -w->ry < -180.000000f)
          w->ary = w->ary + (float)360;

        s3dw_arr_widgetcenter(w, np);
        w->x = w->x - (np[(signed long int)0] - op[(signed long int)0]);
        w->y = w->y - (np[(signed long int)1] - op[(signed long int)1]);
        w->z = w->z - (np[(signed long int)2] - op[(signed long int)2]);
        s3dw_ani_add(w);
      }

    }

  }
}

// s3dw_widget_append
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 71
void s3dw_widget_append(struct _s3dw_widget *parent, struct _s3dw_widget *widget)
{
  parent->nobj = parent->nobj + 1;
  void *return_value_realloc$1;
  return_value_realloc$1=realloc((void *)parent->pobj, sizeof(struct _s3dw_widget **) /*8ul*/  * (unsigned long int)parent->nobj);
  parent->pobj = (struct _s3dw_widget **)return_value_realloc$1;
  parent->pobj[(signed long int)(parent->nobj - 1)] = widget;
  widget->parent = parent;
  widget->style = parent->style;
  if((1 & parent->flags) == 0)
    widget->flags = widget->flags | 1;

}

// s3dw_widget_event_click
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 51
signed int s3dw_widget_event_click(struct _s3dw_widget *widget, unsigned int oid)
{
  signed int i;
  s3dprintf(1, "processing click event for widget %10p of type %d, oid %d (%d), subobjects: %d", (void *)widget, widget->type, widget->oid, oid, widget->nobj);
  signed int return_value;
  return_value=s3dwcb_click[(signed long int)widget->type](widget, oid);
  signed int return_value_s3dw_widget_event_click$1;
  if(!(return_value == 0))
    return 1;

  else
  {
    i = 0;
    if(!(i >= widget->nobj))
    {
      return_value_s3dw_widget_event_click$1=s3dw_widget_event_click(widget->pobj[(signed long int)i], oid);
      if(!(return_value_s3dw_widget_event_click$1 == 0))
        return 1;

      i = i + 1;
    }

    return 0;
  }
}

// s3dw_widget_event_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 61
signed int s3dw_widget_event_key(struct _s3dw_widget *widget, struct s3d_key_event *keys)
{
  signed int return_value;
  return_value=s3dwcb_key[(signed long int)widget->type](widget, keys);
  signed int return_value_s3dw_widget_event_key$1;
  if(!(return_value == 0))
    return 1;

  else
    if(!(widget->focus == -1))
    {
      return_value_s3dw_widget_event_key$1=s3dw_widget_event_key(widget->pobj[(signed long int)widget->focus], keys);
      return 1;
    }

    else
      return 0;
}

// s3dw_widget_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 29
struct _s3dw_widget * s3dw_widget_new(struct _s3dw_widget *widget)
{
  widget->type = -1;
  widget->ax = (float)0;
  widget->x = widget->ax;
  widget->ay = (float)0;
  widget->y = widget->ay;
  widget->az = (float)0;
  widget->z = widget->az;
  widget->arx = (float)0;
  widget->rx = widget->arx;
  widget->ary = (float)0;
  widget->ry = widget->ary;
  widget->arz = (float)0;
  widget->rz = widget->arz;
  widget->as = (float)1;
  widget->s = widget->as;
  widget->width = (float)0;
  widget->height = (float)0;
  widget->nobj = 0;
  widget->pobj = (struct _s3dw_widget **)(void *)0;
  widget->parent = (struct _s3dw_widget *)(void *)0;
  widget->ptr = (void *)0;
  widget->focus = -1;
  widget->flags = 2;
  widget->oid = (unsigned int)-1;
  return widget;
}

// s3dw_widget_remove
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 82
static void s3dw_widget_remove(struct _s3dw_widget *widget)
{
  struct _s3dw_widget *parent = widget->parent;
  signed int i;
  signed int stackpos;
  stackpos=s3dw_ani_stackpos(widget);
  if(!(stackpos == -1))
    s3dw_ani_del(stackpos);

  if(!(parent == ((struct _s3dw_widget *)NULL)))
  {
    i = 0;
    for( ; !(i >= parent->nobj); i = i + 1)
      if(parent->pobj[(signed long int)i] == widget)
      {
        if(parent->focus == i)
          parent->focus = -1;

        if(parent->focus == parent->nobj + -1)
          parent->focus = i;

        parent->pobj[(signed long int)i] = parent->pobj[(signed long int)(parent->nobj - 1)];
        parent->nobj = parent->nobj - 1;
      }

  }

}

// s3dw_widget_visible
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3dw/widget.c line 142
void s3dw_widget_visible(struct _s3dw_widget *widget)
{
  signed int i;
  struct _s3dw_widget *kid;
  i = 0;
  for( ; !(i >= widget->nobj); i = i + 1)
  {
    kid = widget->pobj[(signed long int)i];
    if(!((1 & widget->flags) == 0))
      s3dw_widget_visible(kid);

  }
  widget->flags = widget->flags | 256;
  s3dwcb_show[(signed long int)widget->type](widget);
}

// sei_triangulate_polygon
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_tri.c line 80
extern signed int sei_triangulate_polygon(signed int ncontours, signed int *cntr, double (*vertices)[2l], signed int (*triangles)[3l])
{
  signed int i;
  signed int nmonpoly;
  signed int ccount;
  signed int npoints;
  signed int n;
  memset((void *)seg, 0, sizeof(struct anonymous$14 [200l]) /*11200ul*/ );
  ccount = 0;
  i = 1;
  while(!(ccount >= ncontours))
  {
    signed int j;
    signed int first;
    signed int last;
    npoints = cntr[(signed long int)ccount];
    first = i;
    last = (first + npoints) - 1;
    j = 0;
    for( ; !(j >= npoints); i = i + 1)
    {
      seg[(signed long int)i].v0.x = vertices[(signed long int)i][(signed long int)0];
      seg[(signed long int)i].v0.y = vertices[(signed long int)i][(signed long int)1];
      if(i == last)
      {
        seg[(signed long int)i].next = first;
        seg[(signed long int)i].prev = i - 1;
        seg[(signed long int)(i - 1)].v1 = seg[(signed long int)i].v0;
      }

      else
        if(i == first)
        {
          seg[(signed long int)i].next = i + 1;
          seg[(signed long int)i].prev = last;
          seg[(signed long int)last].v1 = seg[(signed long int)i].v0;
        }

        else
        {
          seg[(signed long int)i].prev = i - 1;
          seg[(signed long int)i].next = i + 1;
          seg[(signed long int)(i - 1)].v1 = seg[(signed long int)i].v0;
        }
      seg[(signed long int)i].is_inserted = 0;
      j = j + 1;
    }
    ccount = ccount + 1;
  }
  n = i - 1;
  initialise(n);
  construct_trapezoids(n);
  nmonpoly=monotonate_trapezoids(n);
  signed int return_value_triangulate_monotone_polygons$1;
  return_value_triangulate_monotone_polygons$1=triangulate_monotone_polygons(n, nmonpoly, triangles);
  return return_value_triangulate_monotone_polygons$1;
}

// shm_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm_ringbuf.c line 75
unsigned int shm_read(struct buf_t *rb, char *buf, unsigned int n)
{
  signed int wrap = 0;
  unsigned int mn;
  unsigned int rs;
  unsigned int e;
  unsigned int s;
  unsigned int size;
  char *data;
  e = rb->end;
  s = rb->start;
  size = rb->bufsize;
  data = (char *)rb + (signed long int)sizeof(struct buf_t) /*12ul*/ ;
  if(!(e >= s))
    wrap = 1;

  rs = (e + (unsigned int)wrap * size) - s;
  mn = n > rs ? rs : n;
  if(!(wrap == 0) && !(size + -s >= mn))
  {
    rs = size - s;
    memcpy((void *)buf, (const void *)(data + (signed long int)s), (unsigned long int)rs);
    memcpy((void *)(buf + (signed long int)rs), (const void *)data, (unsigned long int)(mn - rs));
  }

  else
    memcpy((void *)buf, (const void *)(data + (signed long int)s), (unsigned long int)mn);
  rb->start = s + mn;
  if(rb->start >= rb->bufsize)
    rb->start = rb->start - rb->bufsize;

  return mn;
}

// shm_readn
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 148
signed int shm_readn(char *str, signed int s)
{
  signed int no_left;
  signed int no_read;
  signed int wait = 0;
  no_left = s;
  signed int tmp_post$2;
  while(no_left >= 1)
  {
    unsigned int return_value_shm_read$1;
    return_value_shm_read$1=shm_read(data_in, str, (unsigned int)no_left);
    no_read = (signed int)return_value_shm_read$1;
    if(!(no_read >= 0))
      return no_read;

    if(no_read == 0)
      break;

    no_left = no_left - no_read;
    str = str + (signed long int)no_read;
    tmp_post$2 = wait;
    wait = wait + 1;
    if(tmp_post$2 >= 101)
    {
      s3dprintf$link1(4, "shm_readn():waited too long ...");
      return -1;
    }

    if(wait >= 11)
      nanosleep(&t, (struct timespec *)(void *)0);

  }
  return s - no_left;
}

// shm_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm_ringbuf.c line 30
unsigned int shm_write(struct buf_t *rb, char *buf, unsigned int n)
{
  unsigned int wrap = (unsigned int)0;
  signed int rs;
  unsigned int e;
  unsigned int s;
  unsigned int size;
  char *data;
  e = rb->end;
  s = rb->start;
  size = rb->bufsize;
  data = (char *)rb + (signed long int)sizeof(struct buf_t) /*12ul*/ ;
  if(!(e >= s))
    wrap = (unsigned int)1;

  while(!((1u + -wrap) * size + s + -e >= 1u + n))
    return (unsigned int)0;
  if(!(size >= e + n))
  {
    rs = (signed int)(size - e);
    memcpy((void *)(data + (signed long int)e), (const void *)buf, (unsigned long int)rs);
    memcpy((void *)data, (const void *)(buf + (signed long int)rs), (unsigned long int)(n - (unsigned int)rs));
  }

  else
    memcpy((void *)(data + (signed long int)e), (const void *)buf, (unsigned long int)n);
  rb->end = e + n;
  if(rb->end >= rb->bufsize)
    rb->end = rb->end - rb->bufsize;

  return n;
}

// shm_writen
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/shm.c line 129
signed int shm_writen(char *str, signed int s)
{
  signed int no_left;
  signed int no_written;
  signed int wait = 0;
  no_left = s;
  signed int tmp_post$2;
  while(no_left >= 1)
  {
    unsigned int return_value_shm_write$1;
    return_value_shm_write$1=shm_write(data_out, str, (unsigned int)no_left);
    no_written = (signed int)return_value_shm_write$1;
    if(!(no_written >= 0))
      return no_written;

    no_left = no_left - no_written;
    str = str + (signed long int)no_written;
    tmp_post$2 = wait;
    wait = wait + 1;
    if(tmp_post$2 >= 101)
    {
      s3dprintf$link1(4, "shm_writen():waited too long ...");
      return -1;
    }

    if(wait >= 11)
      nanosleep(&t, (struct timespec *)(void *)0);

  }
  return s - no_left;
}

// sigint_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/io.c line 59
static void sigint_handler(signed int sig, signed int code)
{
  exit(-1);
}

// sigint_handler$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/io.c line 59
static void sigint_handler$link1(signed int sig$link1, signed int code$link1)
{
  exit(-1);
}

// sigio_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 50
static void sigio_handler(signed int sig, signed int code)
{
  _s3d_sigio = 1;
}

// sigio_handler$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 50
static void sigio_handler$link1(signed int sig$link1, signed int code$link1)
{
  _s3d_sigio = 1;
}

// sigpipe_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 46
static void sigpipe_handler(signed int sig, signed int code)
{
  errs("sigpipe_handler()", "there is a broken pipe somewhere");
}

// sigpipe_handler$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 46
static void sigpipe_handler$link1(signed int sig$link1, signed int code$link1)
{
  errs("sigpipe_handler()", "there is a broken pipe somewhere");
}

// tcp_readn
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 118
signed int tcp_readn(char *str, signed int s)
{
  signed int no_left;
  signed int no_read;
  no_left = s;
  while(no_left >= 1)
  {
    signed long int return_value_read$1;
    return_value_read$1=read(s3d_socket, (void *)str, (unsigned long int)no_left);
    no_read = (signed int)return_value_read$1;
    if(!(no_read >= 0))
      return no_read;

    if(no_read == 0)
      break;

    no_left = no_left - no_read;
    str = str + (signed long int)no_read;
  }
  return s - no_left;
}

// tcp_writen
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/tcp.c line 131
signed int tcp_writen(char *str, signed int s)
{
  signed int no_left;
  signed int no_written;
  no_left = s;
  while(no_left >= 1)
  {
    signed long int return_value_write$1;
    return_value_write$1=write(s3d_socket, (const void *)str, (unsigned long int)no_left);
    no_written = (signed int)return_value_write$1;
    if(!(no_written >= 1))
      return no_written;

    no_left = no_left - no_written;
    str = str + (signed long int)no_written;
  }
  return s - no_left;
}

// traverse_polygon
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 277
static signed int traverse_polygon(signed int mcur, signed int trnum, signed int from, signed int dir)
{
  struct anonymous$3 *traverse_polygon$$1$$t = &tr[(signed long int)trnum];
  signed int mnew;
  signed int v0;
  signed int v1;
  signed int retval = -1;
  _Bool tmp_if_expr$1;
  if(!(trnum >= 1))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = visited[(signed long int)trnum] != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$24;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$23;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$22;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$21;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$19;
  signed int return_value__equal_to$18;
  signed int return_value__equal_to$14;
  _Bool tmp_if_expr$16;
  signed int return_value__equal_to$15;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    visited[(signed long int)trnum] = 1;
    if(!(traverse_polygon$$1$$t->u0 >= 1))
      tmp_if_expr$24 = traverse_polygon$$1$$t->u1 <= 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$24 = (_Bool)0;
    if(tmp_if_expr$24)
    {
      if(traverse_polygon$$1$$t->d0 >= 1)
        tmp_if_expr$2 = traverse_polygon$$1$$t->d1 > 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
      {
        v0 = tr[(signed long int)traverse_polygon$$1$$t->d1].lseg;
        v1 = traverse_polygon$$1$$t->lseg;
        if(from == traverse_polygon$$1$$t->d1)
        {
          mnew=make_new_monotone_poly(mcur, v1, v0);
          traverse_polygon(mcur, traverse_polygon$$1$$t->d1, trnum, 1);
          traverse_polygon(mnew, traverse_polygon$$1$$t->d0, trnum, 1);
        }

        else
        {
          mnew=make_new_monotone_poly(mcur, v0, v1);
          traverse_polygon(mcur, traverse_polygon$$1$$t->d0, trnum, 1);
          traverse_polygon(mnew, traverse_polygon$$1$$t->d1, trnum, 1);
        }
      }

      else
      {
        retval = -1;
        traverse_polygon(mcur, traverse_polygon$$1$$t->u0, trnum, 2);
        traverse_polygon(mcur, traverse_polygon$$1$$t->u1, trnum, 2);
        traverse_polygon(mcur, traverse_polygon$$1$$t->d0, trnum, 1);
        traverse_polygon(mcur, traverse_polygon$$1$$t->d1, trnum, 1);
      }
    }

    else
    {
      if(!(traverse_polygon$$1$$t->d0 >= 1))
        tmp_if_expr$23 = traverse_polygon$$1$$t->d1 <= 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$23 = (_Bool)0;
      if(tmp_if_expr$23)
      {
        if(traverse_polygon$$1$$t->u0 >= 1)
          tmp_if_expr$3 = traverse_polygon$$1$$t->u1 > 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
        {
          v0 = traverse_polygon$$1$$t->rseg;
          v1 = tr[(signed long int)traverse_polygon$$1$$t->u0].rseg;
          if(from == traverse_polygon$$1$$t->u1)
          {
            mnew=make_new_monotone_poly(mcur, v1, v0);
            traverse_polygon(mcur, traverse_polygon$$1$$t->u1, trnum, 2);
            traverse_polygon(mnew, traverse_polygon$$1$$t->u0, trnum, 2);
          }

          else
          {
            mnew=make_new_monotone_poly(mcur, v0, v1);
            traverse_polygon(mcur, traverse_polygon$$1$$t->u0, trnum, 2);
            traverse_polygon(mnew, traverse_polygon$$1$$t->u1, trnum, 2);
          }
        }

        else
        {
          retval = -1;
          traverse_polygon(mcur, traverse_polygon$$1$$t->u0, trnum, 2);
          traverse_polygon(mcur, traverse_polygon$$1$$t->u1, trnum, 2);
          traverse_polygon(mcur, traverse_polygon$$1$$t->d0, trnum, 1);
          traverse_polygon(mcur, traverse_polygon$$1$$t->d1, trnum, 1);
        }
      }

      else
      {
        if(traverse_polygon$$1$$t->u0 >= 1)
          tmp_if_expr$22 = traverse_polygon$$1$$t->u1 > 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$22 = (_Bool)0;
        if(tmp_if_expr$22)
        {
          if(traverse_polygon$$1$$t->d0 >= 1)
            tmp_if_expr$10 = traverse_polygon$$1$$t->d1 > 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$10 = (_Bool)0;
          if(tmp_if_expr$10)
          {
            v0 = tr[(signed long int)traverse_polygon$$1$$t->d1].lseg;
            v1 = tr[(signed long int)traverse_polygon$$1$$t->u0].rseg;
            retval = 3;
            if(dir == 2)
              tmp_if_expr$4 = traverse_polygon$$1$$t->d1 == from ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$4 = (_Bool)0;
            if(tmp_if_expr$4)
              tmp_if_expr$6 = (_Bool)1;

            else
            {
              if(dir == 1)
                tmp_if_expr$5 = traverse_polygon$$1$$t->u1 == from ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$5 = (_Bool)0;
              tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$6)
            {
              mnew=make_new_monotone_poly(mcur, v1, v0);
              traverse_polygon(mcur, traverse_polygon$$1$$t->u1, trnum, 2);
              traverse_polygon(mcur, traverse_polygon$$1$$t->d1, trnum, 1);
              traverse_polygon(mnew, traverse_polygon$$1$$t->u0, trnum, 2);
              traverse_polygon(mnew, traverse_polygon$$1$$t->d0, trnum, 1);
            }

            else
            {
              mnew=make_new_monotone_poly(mcur, v0, v1);
              traverse_polygon(mcur, traverse_polygon$$1$$t->u0, trnum, 2);
              traverse_polygon(mcur, traverse_polygon$$1$$t->d0, trnum, 1);
              traverse_polygon(mnew, traverse_polygon$$1$$t->u1, trnum, 2);
              traverse_polygon(mnew, traverse_polygon$$1$$t->d1, trnum, 1);
            }
          }

          else
          {
            signed int return_value__equal_to$9;
            return_value__equal_to$9=_equal_to(&traverse_polygon$$1$$t->lo, &seg[(signed long int)traverse_polygon$$1$$t->lseg].v1);
            if(!(return_value__equal_to$9 == 0))
            {
              v0 = tr[(signed long int)traverse_polygon$$1$$t->u0].rseg;
              v1 = seg[(signed long int)traverse_polygon$$1$$t->lseg].next;
              retval = 4;
              if(dir == 1)
                tmp_if_expr$7 = traverse_polygon$$1$$t->u0 == from ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$7 = (_Bool)0;
              if(tmp_if_expr$7)
              {
                mnew=make_new_monotone_poly(mcur, v1, v0);
                traverse_polygon(mcur, traverse_polygon$$1$$t->u0, trnum, 2);
                traverse_polygon(mnew, traverse_polygon$$1$$t->d0, trnum, 1);
                traverse_polygon(mnew, traverse_polygon$$1$$t->u1, trnum, 2);
                traverse_polygon(mnew, traverse_polygon$$1$$t->d1, trnum, 1);
              }

              else
              {
                mnew=make_new_monotone_poly(mcur, v0, v1);
                traverse_polygon(mcur, traverse_polygon$$1$$t->u1, trnum, 2);
                traverse_polygon(mcur, traverse_polygon$$1$$t->d0, trnum, 1);
                traverse_polygon(mcur, traverse_polygon$$1$$t->d1, trnum, 1);
                traverse_polygon(mnew, traverse_polygon$$1$$t->u0, trnum, 2);
              }
            }

            else
            {
              v0 = traverse_polygon$$1$$t->rseg;
              v1 = tr[(signed long int)traverse_polygon$$1$$t->u0].rseg;
              retval = 5;
              if(dir == 1)
                tmp_if_expr$8 = traverse_polygon$$1$$t->u1 == from ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$8 = (_Bool)0;
              if(tmp_if_expr$8)
              {
                mnew=make_new_monotone_poly(mcur, v1, v0);
                traverse_polygon(mcur, traverse_polygon$$1$$t->u1, trnum, 2);
                traverse_polygon(mnew, traverse_polygon$$1$$t->d1, trnum, 1);
                traverse_polygon(mnew, traverse_polygon$$1$$t->d0, trnum, 1);
                traverse_polygon(mnew, traverse_polygon$$1$$t->u0, trnum, 2);
              }

              else
              {
                mnew=make_new_monotone_poly(mcur, v0, v1);
                traverse_polygon(mcur, traverse_polygon$$1$$t->u0, trnum, 2);
                traverse_polygon(mcur, traverse_polygon$$1$$t->d0, trnum, 1);
                traverse_polygon(mcur, traverse_polygon$$1$$t->d1, trnum, 1);
                traverse_polygon(mnew, traverse_polygon$$1$$t->u1, trnum, 2);
              }
            }
          }
        }

        else
        {
          if(traverse_polygon$$1$$t->u0 >= 1)
            tmp_if_expr$21 = (_Bool)1;

          else
            tmp_if_expr$21 = traverse_polygon$$1$$t->u1 > 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$21)
          {
            if(traverse_polygon$$1$$t->d0 >= 1)
              tmp_if_expr$20 = traverse_polygon$$1$$t->d1 > 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$20 = (_Bool)0;
            if(tmp_if_expr$20)
            {
              signed int return_value__equal_to$13;
              return_value__equal_to$13=_equal_to(&traverse_polygon$$1$$t->hi, &seg[(signed long int)traverse_polygon$$1$$t->lseg].v0);
              if(!(return_value__equal_to$13 == 0))
              {
                v0 = tr[(signed long int)traverse_polygon$$1$$t->d1].lseg;
                v1 = traverse_polygon$$1$$t->lseg;
                retval = 6;
                if(dir == 2)
                  tmp_if_expr$11 = traverse_polygon$$1$$t->d0 == from ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$11 = (_Bool)0;
                if(!tmp_if_expr$11)
                {
                  mnew=make_new_monotone_poly(mcur, v1, v0);
                  traverse_polygon(mcur, traverse_polygon$$1$$t->u1, trnum, 2);
                  traverse_polygon(mcur, traverse_polygon$$1$$t->d1, trnum, 1);
                  traverse_polygon(mcur, traverse_polygon$$1$$t->u0, trnum, 2);
                  traverse_polygon(mnew, traverse_polygon$$1$$t->d0, trnum, 1);
                }

                else
                {
                  mnew=make_new_monotone_poly(mcur, v0, v1);
                  traverse_polygon(mcur, traverse_polygon$$1$$t->d0, trnum, 1);
                  traverse_polygon(mnew, traverse_polygon$$1$$t->u0, trnum, 2);
                  traverse_polygon(mnew, traverse_polygon$$1$$t->u1, trnum, 2);
                  traverse_polygon(mnew, traverse_polygon$$1$$t->d1, trnum, 1);
                }
              }

              else
              {
                v0 = tr[(signed long int)traverse_polygon$$1$$t->d1].lseg;
                v1 = seg[(signed long int)traverse_polygon$$1$$t->rseg].next;
                retval = 7;
                if(dir == 2)
                  tmp_if_expr$12 = traverse_polygon$$1$$t->d1 == from ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$12 = (_Bool)0;
                if(tmp_if_expr$12)
                {
                  mnew=make_new_monotone_poly(mcur, v1, v0);
                  traverse_polygon(mcur, traverse_polygon$$1$$t->d1, trnum, 1);
                  traverse_polygon(mnew, traverse_polygon$$1$$t->u1, trnum, 2);
                  traverse_polygon(mnew, traverse_polygon$$1$$t->u0, trnum, 2);
                  traverse_polygon(mnew, traverse_polygon$$1$$t->d0, trnum, 1);
                }

                else
                {
                  mnew=make_new_monotone_poly(mcur, v0, v1);
                  traverse_polygon(mcur, traverse_polygon$$1$$t->u0, trnum, 2);
                  traverse_polygon(mcur, traverse_polygon$$1$$t->d0, trnum, 1);
                  traverse_polygon(mcur, traverse_polygon$$1$$t->u1, trnum, 2);
                  traverse_polygon(mnew, traverse_polygon$$1$$t->d1, trnum, 1);
                }
              }
            }

            else
            {
              signed int return_value__equal_to$17;
              return_value__equal_to$17=_equal_to(&traverse_polygon$$1$$t->hi, &seg[(signed long int)traverse_polygon$$1$$t->lseg].v0);
              if(!(return_value__equal_to$17 == 0))
              {
                return_value__equal_to$18=_equal_to(&traverse_polygon$$1$$t->lo, &seg[(signed long int)traverse_polygon$$1$$t->rseg].v0);
                tmp_if_expr$19 = return_value__equal_to$18 != 0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$19 = (_Bool)0;
              if(tmp_if_expr$19)
              {
                v0 = traverse_polygon$$1$$t->rseg;
                v1 = traverse_polygon$$1$$t->lseg;
                retval = 2;
                if(dir == 1)
                {
                  mnew=make_new_monotone_poly(mcur, v1, v0);
                  traverse_polygon(mcur, traverse_polygon$$1$$t->u0, trnum, 2);
                  traverse_polygon(mcur, traverse_polygon$$1$$t->u1, trnum, 2);
                  traverse_polygon(mnew, traverse_polygon$$1$$t->d1, trnum, 1);
                  traverse_polygon(mnew, traverse_polygon$$1$$t->d0, trnum, 1);
                }

                else
                {
                  mnew=make_new_monotone_poly(mcur, v0, v1);
                  traverse_polygon(mcur, traverse_polygon$$1$$t->d1, trnum, 1);
                  traverse_polygon(mcur, traverse_polygon$$1$$t->d0, trnum, 1);
                  traverse_polygon(mnew, traverse_polygon$$1$$t->u0, trnum, 2);
                  traverse_polygon(mnew, traverse_polygon$$1$$t->u1, trnum, 2);
                }
              }

              else
              {
                return_value__equal_to$14=_equal_to(&traverse_polygon$$1$$t->hi, &seg[(signed long int)traverse_polygon$$1$$t->rseg].v1);
                if(!(return_value__equal_to$14 == 0))
                {
                  return_value__equal_to$15=_equal_to(&traverse_polygon$$1$$t->lo, &seg[(signed long int)traverse_polygon$$1$$t->lseg].v1);
                  tmp_if_expr$16 = return_value__equal_to$15 != 0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$16 = (_Bool)0;
                if(tmp_if_expr$16)
                {
                  v0 = seg[(signed long int)traverse_polygon$$1$$t->rseg].next;
                  v1 = seg[(signed long int)traverse_polygon$$1$$t->lseg].next;
                  retval = 1;
                  if(dir == 1)
                  {
                    mnew=make_new_monotone_poly(mcur, v1, v0);
                    traverse_polygon(mcur, traverse_polygon$$1$$t->u0, trnum, 2);
                    traverse_polygon(mcur, traverse_polygon$$1$$t->u1, trnum, 2);
                    traverse_polygon(mnew, traverse_polygon$$1$$t->d1, trnum, 1);
                    traverse_polygon(mnew, traverse_polygon$$1$$t->d0, trnum, 1);
                  }

                  else
                  {
                    mnew=make_new_monotone_poly(mcur, v0, v1);
                    traverse_polygon(mcur, traverse_polygon$$1$$t->d1, trnum, 1);
                    traverse_polygon(mcur, traverse_polygon$$1$$t->d0, trnum, 1);
                    traverse_polygon(mnew, traverse_polygon$$1$$t->u0, trnum, 2);
                    traverse_polygon(mnew, traverse_polygon$$1$$t->u1, trnum, 2);
                  }
                }

                else
                {
                  retval = -1;
                  traverse_polygon(mcur, traverse_polygon$$1$$t->u0, trnum, 2);
                  traverse_polygon(mcur, traverse_polygon$$1$$t->d0, trnum, 1);
                  traverse_polygon(mcur, traverse_polygon$$1$$t->u1, trnum, 2);
                  traverse_polygon(mcur, traverse_polygon$$1$$t->d1, trnum, 1);
                }
              }
            }
          }

        }
      }
    }
    return retval;
  }
}

// traverse_polygon$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 277
static signed int traverse_polygon$link1(signed int mcur$link1, signed int trnum$link1, signed int from$link1, signed int dir$link1)
{
  struct anonymous$3 *traverse_polygon$$1$$t$link1 = &tr[(signed long int)trnum$link1];
  signed int mnew$link1;
  signed int v0$link1;
  signed int v1$link1;
  signed int retval$link1 = -1;
  _Bool tmp_if_expr$1$link1;
  if(!(trnum$link1 >= 1))
    tmp_if_expr$1$link1 = (_Bool)1;

  else
    tmp_if_expr$1$link1 = visited$link1[(signed long int)trnum$link1] != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$24$link1;
  _Bool tmp_if_expr$2$link1;
  _Bool tmp_if_expr$23$link1;
  _Bool tmp_if_expr$3$link1;
  _Bool tmp_if_expr$22$link1;
  _Bool tmp_if_expr$10$link1;
  _Bool tmp_if_expr$4$link1;
  _Bool tmp_if_expr$6$link1;
  _Bool tmp_if_expr$5$link1;
  _Bool tmp_if_expr$7$link1;
  _Bool tmp_if_expr$8$link1;
  _Bool tmp_if_expr$21$link1;
  _Bool tmp_if_expr$20$link1;
  _Bool tmp_if_expr$11$link1;
  _Bool tmp_if_expr$12$link1;
  _Bool tmp_if_expr$19$link1;
  signed int return_value__equal_to$18$link1;
  signed int return_value__equal_to$14$link1;
  _Bool tmp_if_expr$16$link1;
  signed int return_value__equal_to$15$link1;
  if(tmp_if_expr$1$link1)
    return 0;

  else
  {
    visited$link1[(signed long int)trnum$link1] = 1;
    if(!(traverse_polygon$$1$$t$link1->u0 >= 1))
      tmp_if_expr$24$link1 = traverse_polygon$$1$$t$link1->u1 <= 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$24$link1 = (_Bool)0;
    if(tmp_if_expr$24$link1)
    {
      if(traverse_polygon$$1$$t$link1->d0 >= 1)
        tmp_if_expr$2$link1 = traverse_polygon$$1$$t$link1->d1 > 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2$link1 = (_Bool)0;
      if(tmp_if_expr$2$link1)
      {
        v0$link1 = tr[(signed long int)traverse_polygon$$1$$t$link1->d1].lseg;
        v1$link1 = traverse_polygon$$1$$t$link1->lseg;
        if(from$link1 == traverse_polygon$$1$$t$link1->d1)
        {
          mnew$link1=make_new_monotone_poly$link1(mcur$link1, v1$link1, v0$link1);
          traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
          traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
        }

        else
        {
          mnew$link1=make_new_monotone_poly$link1(mcur$link1, v0$link1, v1$link1);
          traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
          traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
        }
      }

      else
      {
        retval$link1 = -1;
        traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
        traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
        traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
        traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
      }
    }

    else
    {
      if(!(traverse_polygon$$1$$t$link1->d0 >= 1))
        tmp_if_expr$23$link1 = traverse_polygon$$1$$t$link1->d1 <= 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$23$link1 = (_Bool)0;
      if(tmp_if_expr$23$link1)
      {
        if(traverse_polygon$$1$$t$link1->u0 >= 1)
          tmp_if_expr$3$link1 = traverse_polygon$$1$$t$link1->u1 > 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3$link1 = (_Bool)0;
        if(tmp_if_expr$3$link1)
        {
          v0$link1 = traverse_polygon$$1$$t$link1->rseg;
          v1$link1 = tr[(signed long int)traverse_polygon$$1$$t$link1->u0].rseg;
          if(from$link1 == traverse_polygon$$1$$t$link1->u1)
          {
            mnew$link1=make_new_monotone_poly$link1(mcur$link1, v1$link1, v0$link1);
            traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
            traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
          }

          else
          {
            mnew$link1=make_new_monotone_poly$link1(mcur$link1, v0$link1, v1$link1);
            traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
            traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
          }
        }

        else
        {
          retval$link1 = -1;
          traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
          traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
          traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
          traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
        }
      }

      else
      {
        if(traverse_polygon$$1$$t$link1->u0 >= 1)
          tmp_if_expr$22$link1 = traverse_polygon$$1$$t$link1->u1 > 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$22$link1 = (_Bool)0;
        if(tmp_if_expr$22$link1)
        {
          if(traverse_polygon$$1$$t$link1->d0 >= 1)
            tmp_if_expr$10$link1 = traverse_polygon$$1$$t$link1->d1 > 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$10$link1 = (_Bool)0;
          if(tmp_if_expr$10$link1)
          {
            v0$link1 = tr[(signed long int)traverse_polygon$$1$$t$link1->d1].lseg;
            v1$link1 = tr[(signed long int)traverse_polygon$$1$$t$link1->u0].rseg;
            retval$link1 = 3;
            if(dir$link1 == 2)
              tmp_if_expr$4$link1 = traverse_polygon$$1$$t$link1->d1 == from$link1 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$4$link1 = (_Bool)0;
            if(tmp_if_expr$4$link1)
              tmp_if_expr$6$link1 = (_Bool)1;

            else
            {
              if(dir$link1 == 1)
                tmp_if_expr$5$link1 = traverse_polygon$$1$$t$link1->u1 == from$link1 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$5$link1 = (_Bool)0;
              tmp_if_expr$6$link1 = tmp_if_expr$5$link1 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$6$link1)
            {
              mnew$link1=make_new_monotone_poly$link1(mcur$link1, v1$link1, v0$link1);
              traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
              traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
              traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
              traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
            }

            else
            {
              mnew$link1=make_new_monotone_poly$link1(mcur$link1, v0$link1, v1$link1);
              traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
              traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
              traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
              traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
            }
          }

          else
          {
            signed int return_value__equal_to$9$link1;
            return_value__equal_to$9$link1=_equal_to(&traverse_polygon$$1$$t$link1->lo, &seg[(signed long int)traverse_polygon$$1$$t$link1->lseg].v1);
            if(!(return_value__equal_to$9$link1 == 0))
            {
              v0$link1 = tr[(signed long int)traverse_polygon$$1$$t$link1->u0].rseg;
              v1$link1 = seg[(signed long int)traverse_polygon$$1$$t$link1->lseg].next;
              retval$link1 = 4;
              if(dir$link1 == 1)
                tmp_if_expr$7$link1 = traverse_polygon$$1$$t$link1->u0 == from$link1 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$7$link1 = (_Bool)0;
              if(tmp_if_expr$7$link1)
              {
                mnew$link1=make_new_monotone_poly$link1(mcur$link1, v1$link1, v0$link1);
                traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
                traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
                traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
                traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
              }

              else
              {
                mnew$link1=make_new_monotone_poly$link1(mcur$link1, v0$link1, v1$link1);
                traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
                traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
                traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
                traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
              }
            }

            else
            {
              v0$link1 = traverse_polygon$$1$$t$link1->rseg;
              v1$link1 = tr[(signed long int)traverse_polygon$$1$$t$link1->u0].rseg;
              retval$link1 = 5;
              if(dir$link1 == 1)
                tmp_if_expr$8$link1 = traverse_polygon$$1$$t$link1->u1 == from$link1 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$8$link1 = (_Bool)0;
              if(tmp_if_expr$8$link1)
              {
                mnew$link1=make_new_monotone_poly$link1(mcur$link1, v1$link1, v0$link1);
                traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
                traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
                traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
                traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
              }

              else
              {
                mnew$link1=make_new_monotone_poly$link1(mcur$link1, v0$link1, v1$link1);
                traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
                traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
                traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
                traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
              }
            }
          }
        }

        else
        {
          if(traverse_polygon$$1$$t$link1->u0 >= 1)
            tmp_if_expr$21$link1 = (_Bool)1;

          else
            tmp_if_expr$21$link1 = traverse_polygon$$1$$t$link1->u1 > 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$21$link1)
          {
            if(traverse_polygon$$1$$t$link1->d0 >= 1)
              tmp_if_expr$20$link1 = traverse_polygon$$1$$t$link1->d1 > 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$20$link1 = (_Bool)0;
            if(tmp_if_expr$20$link1)
            {
              signed int return_value__equal_to$13$link1;
              return_value__equal_to$13$link1=_equal_to(&traverse_polygon$$1$$t$link1->hi, &seg[(signed long int)traverse_polygon$$1$$t$link1->lseg].v0);
              if(!(return_value__equal_to$13$link1 == 0))
              {
                v0$link1 = tr[(signed long int)traverse_polygon$$1$$t$link1->d1].lseg;
                v1$link1 = traverse_polygon$$1$$t$link1->lseg;
                retval$link1 = 6;
                if(dir$link1 == 2)
                  tmp_if_expr$11$link1 = traverse_polygon$$1$$t$link1->d0 == from$link1 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$11$link1 = (_Bool)0;
                if(!tmp_if_expr$11$link1)
                {
                  mnew$link1=make_new_monotone_poly$link1(mcur$link1, v1$link1, v0$link1);
                  traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
                  traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
                  traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
                  traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
                }

                else
                {
                  mnew$link1=make_new_monotone_poly$link1(mcur$link1, v0$link1, v1$link1);
                  traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
                  traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
                  traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
                  traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
                }
              }

              else
              {
                v0$link1 = tr[(signed long int)traverse_polygon$$1$$t$link1->d1].lseg;
                v1$link1 = seg[(signed long int)traverse_polygon$$1$$t$link1->rseg].next;
                retval$link1 = 7;
                if(dir$link1 == 2)
                  tmp_if_expr$12$link1 = traverse_polygon$$1$$t$link1->d1 == from$link1 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$12$link1 = (_Bool)0;
                if(tmp_if_expr$12$link1)
                {
                  mnew$link1=make_new_monotone_poly$link1(mcur$link1, v1$link1, v0$link1);
                  traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
                  traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
                  traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
                  traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
                }

                else
                {
                  mnew$link1=make_new_monotone_poly$link1(mcur$link1, v0$link1, v1$link1);
                  traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
                  traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
                  traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
                  traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
                }
              }
            }

            else
            {
              signed int return_value__equal_to$17$link1;
              return_value__equal_to$17$link1=_equal_to(&traverse_polygon$$1$$t$link1->hi, &seg[(signed long int)traverse_polygon$$1$$t$link1->lseg].v0);
              if(!(return_value__equal_to$17$link1 == 0))
              {
                return_value__equal_to$18$link1=_equal_to(&traverse_polygon$$1$$t$link1->lo, &seg[(signed long int)traverse_polygon$$1$$t$link1->rseg].v0);
                tmp_if_expr$19$link1 = return_value__equal_to$18$link1 != 0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$19$link1 = (_Bool)0;
              if(tmp_if_expr$19$link1)
              {
                v0$link1 = traverse_polygon$$1$$t$link1->rseg;
                v1$link1 = traverse_polygon$$1$$t$link1->lseg;
                retval$link1 = 2;
                if(dir$link1 == 1)
                {
                  mnew$link1=make_new_monotone_poly$link1(mcur$link1, v1$link1, v0$link1);
                  traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
                  traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
                  traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
                  traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
                }

                else
                {
                  mnew$link1=make_new_monotone_poly$link1(mcur$link1, v0$link1, v1$link1);
                  traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
                  traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
                  traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
                  traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
                }
              }

              else
              {
                return_value__equal_to$14$link1=_equal_to(&traverse_polygon$$1$$t$link1->hi, &seg[(signed long int)traverse_polygon$$1$$t$link1->rseg].v1);
                if(!(return_value__equal_to$14$link1 == 0))
                {
                  return_value__equal_to$15$link1=_equal_to(&traverse_polygon$$1$$t$link1->lo, &seg[(signed long int)traverse_polygon$$1$$t$link1->lseg].v1);
                  tmp_if_expr$16$link1 = return_value__equal_to$15$link1 != 0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$16$link1 = (_Bool)0;
                if(tmp_if_expr$16$link1)
                {
                  v0$link1 = seg[(signed long int)traverse_polygon$$1$$t$link1->rseg].next;
                  v1$link1 = seg[(signed long int)traverse_polygon$$1$$t$link1->lseg].next;
                  retval$link1 = 1;
                  if(dir$link1 == 1)
                  {
                    mnew$link1=make_new_monotone_poly$link1(mcur$link1, v1$link1, v0$link1);
                    traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
                    traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
                    traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
                    traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
                  }

                  else
                  {
                    mnew$link1=make_new_monotone_poly$link1(mcur$link1, v0$link1, v1$link1);
                    traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
                    traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
                    traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
                    traverse_polygon$link1(mnew$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
                  }
                }

                else
                {
                  retval$link1 = -1;
                  traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u0, trnum$link1, 2);
                  traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d0, trnum$link1, 1);
                  traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->u1, trnum$link1, 2);
                  traverse_polygon$link1(mcur$link1, traverse_polygon$$1$$t$link1->d1, trnum$link1, 1);
                }
              }
            }
          }

        }
      }
    }
    return retval$link1;
  }
}

// triangulate_monotone_polygons
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 495
extern signed int triangulate_monotone_polygons(signed int nvert, signed int nmonpoly, signed int (*op)[3l])
{
  signed int i;
  struct anonymous$1 ymax;
  struct anonymous$1 ymin;
  signed int p;
  signed int vfirst;
  signed int posmax;
  signed int v;
  signed int vcount;
  signed int processed;
  op_idx = 0;
  i = 0;
  for( ; !(i >= nmonpoly); i = i + 1)
  {
    vcount = 1;
    processed = 0;
    vfirst = mchain[(signed long int)mon[(signed long int)i]].vnum;
    ymin = vert[(signed long int)vfirst].pt;
    ymax = ymin;
    posmax = mon[(signed long int)i];
    mchain[(signed long int)mon[(signed long int)i]].marked = 1;
    p = mchain[(signed long int)mon[(signed long int)i]].next;
    do
    {
      v = mchain[(signed long int)p].vnum;
      if(v == vfirst)
        break;

      if(!(mchain[(signed long int)p].marked == 0))
      {
        processed = 1;
        break;
      }

      else
        mchain[(signed long int)p].marked = 1;
      signed int return_value__greater_than$1;
      return_value__greater_than$1=_greater_than(&vert[(signed long int)v].pt, &ymax);
      if(!(return_value__greater_than$1 == 0))
      {
        ymax = vert[(signed long int)v].pt;
        posmax = p;
      }

      signed int return_value__less_than$2;
      return_value__less_than$2=_less_than(&vert[(signed long int)v].pt, &ymin);
      if(!(return_value__less_than$2 == 0))
        ymin = vert[(signed long int)v].pt;

      p = mchain[(signed long int)p].next;
      vcount = vcount + 1;
    }
    while((_Bool)1);
    if(processed == 0)
    {
      if(vcount == 3)
      {
        op[(signed long int)op_idx][(signed long int)0] = mchain[(signed long int)p].vnum;
        op[(signed long int)op_idx][(signed long int)1] = mchain[(signed long int)mchain[(signed long int)p].next].vnum;
        op[(signed long int)op_idx][(signed long int)2] = mchain[(signed long int)mchain[(signed long int)p].prev].vnum;
        op_idx = op_idx + 1;
      }

      else
      {
        v = mchain[(signed long int)mchain[(signed long int)posmax].next].vnum;
        signed int return_value__equal_to$3;
        return_value__equal_to$3=_equal_to(&vert[(signed long int)v].pt, &ymin);
        if(!(return_value__equal_to$3 == 0))
          triangulate_single_polygon(nvert, posmax, 1, op);

        else
          triangulate_single_polygon(nvert, posmax, 2, op);
      }
    }

  }
  i = 0;
  for( ; !(i >= op_idx); i = i + 1)
    errds(1, "sei:triangulate_monotone_polygons()", "tri #%d: (%d, %d, %d)\n", i, op[(signed long int)i][(signed long int)0], op[(signed long int)i][(signed long int)1], op[(signed long int)i][(signed long int)2]);
  return op_idx;
}

// triangulate_single_polygon
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 558
static signed int triangulate_single_polygon(signed int nvert, signed int posmax, signed int side, signed int (*op)[3l])
{
  signed int v;
  signed int rc[200l];
  signed int ri = 0;
  signed int endv;
  signed int tmp;
  signed int vpos;
  if(side == 2)
  {
    rc[(signed long int)0] = mchain[(signed long int)posmax].vnum;
    tmp = mchain[(signed long int)posmax].next;
    rc[(signed long int)1] = mchain[(signed long int)tmp].vnum;
    ri = 1;
    vpos = mchain[(signed long int)tmp].next;
    v = mchain[(signed long int)vpos].vnum;
    endv = mchain[(signed long int)mchain[(signed long int)posmax].prev].vnum;
    if(endv == 0)
      endv = nvert;

  }

  else
  {
    tmp = mchain[(signed long int)posmax].next;
    rc[(signed long int)0] = mchain[(signed long int)tmp].vnum;
    tmp = mchain[(signed long int)tmp].next;
    rc[(signed long int)1] = mchain[(signed long int)tmp].vnum;
    ri = 1;
    vpos = mchain[(signed long int)tmp].next;
    v = mchain[(signed long int)vpos].vnum;
    endv = mchain[(signed long int)posmax].vnum;
  }
  while(ri >= 2 || !(v == endv))
    if(ri >= 1)
    {
      if((vert[(signed long int)rc[(signed long int)(ri + -1)]].pt.x + -vert[(signed long int)v].pt.x) * (vert[(signed long int)rc[(signed long int)ri]].pt.y + -vert[(signed long int)v].pt.y) + -((vert[(signed long int)rc[(signed long int)(ri + -1)]].pt.y + -vert[(signed long int)v].pt.y) * (vert[(signed long int)rc[(signed long int)ri]].pt.x + -vert[(signed long int)v].pt.x)) > 0.000000)
      {
        op[(signed long int)op_idx][(signed long int)0] = rc[(signed long int)(ri - 1)];
        op[(signed long int)op_idx][(signed long int)1] = rc[(signed long int)ri];
        op[(signed long int)op_idx][(signed long int)2] = v;
        op_idx = op_idx + 1;
        ri = ri - 1;
      }

      else
      {
        ri = ri + 1;
        rc[(signed long int)ri] = v;
        vpos = mchain[(signed long int)vpos].next;
        v = mchain[(signed long int)vpos].vnum;
      }
    }

    else
    {
      ri = ri + 1;
      rc[(signed long int)ri] = v;
      vpos = mchain[(signed long int)vpos].next;
      v = mchain[(signed long int)vpos].vnum;
    }
  op[(signed long int)op_idx][(signed long int)0] = rc[(signed long int)(ri - 1)];
  op[(signed long int)op_idx][(signed long int)1] = rc[(signed long int)ri];
  op[(signed long int)op_idx][(signed long int)2] = v;
  op_idx = op_idx + 1;
  ri = ri - 1;
  return 0;
}

// triangulate_single_polygon$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/libs3d/sei_monotone.c line 558
static signed int triangulate_single_polygon$link1(signed int nvert$link1, signed int posmax$link1, signed int side$link1, signed int (*op$link1)[3l])
{
  signed int v$link1;
  signed int rc$link1[200l];
  signed int ri$link1 = 0;
  signed int endv$link1;
  signed int tmp$link1;
  signed int vpos$link1;
  if(side$link1 == 2)
  {
    rc$link1[(signed long int)0] = mchain$link1[(signed long int)posmax$link1].vnum;
    tmp$link1 = mchain$link1[(signed long int)posmax$link1].next;
    rc$link1[(signed long int)1] = mchain$link1[(signed long int)tmp$link1].vnum;
    ri$link1 = 1;
    vpos$link1 = mchain$link1[(signed long int)tmp$link1].next;
    v$link1 = mchain$link1[(signed long int)vpos$link1].vnum;
    endv$link1 = mchain$link1[(signed long int)mchain$link1[(signed long int)posmax$link1].prev].vnum;
    if(endv$link1 == 0)
      endv$link1 = nvert$link1;

  }

  else
  {
    tmp$link1 = mchain$link1[(signed long int)posmax$link1].next;
    rc$link1[(signed long int)0] = mchain$link1[(signed long int)tmp$link1].vnum;
    tmp$link1 = mchain$link1[(signed long int)tmp$link1].next;
    rc$link1[(signed long int)1] = mchain$link1[(signed long int)tmp$link1].vnum;
    ri$link1 = 1;
    vpos$link1 = mchain$link1[(signed long int)tmp$link1].next;
    v$link1 = mchain$link1[(signed long int)vpos$link1].vnum;
    endv$link1 = mchain$link1[(signed long int)posmax$link1].vnum;
  }
  while(ri$link1 >= 2 || !(v$link1 == endv$link1))
    if(ri$link1 >= 1)
    {
      if((vert$link1[(signed long int)rc$link1[(signed long int)(ri$link1 + -1)]].pt.x + -vert$link1[(signed long int)v$link1].pt.x) * (vert$link1[(signed long int)rc$link1[(signed long int)ri$link1]].pt.y + -vert$link1[(signed long int)v$link1].pt.y) + -((vert$link1[(signed long int)rc$link1[(signed long int)(ri$link1 + -1)]].pt.y + -vert$link1[(signed long int)v$link1].pt.y) * (vert$link1[(signed long int)rc$link1[(signed long int)ri$link1]].pt.x + -vert$link1[(signed long int)v$link1].pt.x)) > 0.000000)
      {
        op$link1[(signed long int)op_idx$link1][(signed long int)0] = rc$link1[(signed long int)(ri$link1 - 1)];
        op$link1[(signed long int)op_idx$link1][(signed long int)1] = rc$link1[(signed long int)ri$link1];
        op$link1[(signed long int)op_idx$link1][(signed long int)2] = v$link1;
        op_idx$link1 = op_idx$link1 + 1;
        ri$link1 = ri$link1 - 1;
      }

      else
      {
        ri$link1 = ri$link1 + 1;
        rc$link1[(signed long int)ri$link1] = v$link1;
        vpos$link1 = mchain$link1[(signed long int)vpos$link1].next;
        v$link1 = mchain$link1[(signed long int)vpos$link1].vnum;
      }
    }

    else
    {
      ri$link1 = ri$link1 + 1;
      rc$link1[(signed long int)ri$link1] = v$link1;
      vpos$link1 = mchain$link1[(signed long int)vpos$link1].next;
      v$link1 = mchain$link1[(signed long int)vpos$link1].vnum;
    }
  op$link1[(signed long int)op_idx$link1][(signed long int)0] = rc$link1[(signed long int)(ri$link1 - 1)];
  op$link1[(signed long int)op_idx$link1][(signed long int)1] = rc$link1[(signed long int)ri$link1];
  op$link1[(signed long int)op_idx$link1][(signed long int)2] = v$link1;
  op_idx$link1 = op_idx$link1 + 1;
  ri$link1 = ri$link1 - 1;
  return 0;
}

// wire_sphere
// file /srv/jenkins-slave/workspace/sid-goto-cc-s3d/s3d-0.2.2/apps/kism3d/gui.c line 52
static signed int wire_sphere(signed int slices, signed int stacks)
{
  signed int x;
  signed int y;
  signed int i;
  signed int o;
  signed int num_v;
  signed int num_l;
  float *v;
  float *n;
  float alpha;
  float beta;
  unsigned int *l;
  num_v = (stacks + 1) * slices;
  num_l = stacks * slices + (stacks - 1) * slices;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(float) /*4ul*/  * (unsigned long int)3 * (unsigned long int)num_v);
  v = (float *)return_value_malloc$1;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(float) /*4ul*/  * (unsigned long int)6 * (unsigned long int)num_l);
  n = (float *)return_value_malloc$2;
  void *return_value_malloc$3;
  return_value_malloc$3=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)3 * (unsigned long int)num_l);
  l = (unsigned int *)return_value_malloc$3;
  i = 0;
  x = 0;
  for( ; !(x >= slices); x = x + 1)
  {
    alpha = (float)(((((double)x * 360.0) / (double)slices) * 3.14159265358979323846) / 180.0);
    y = 0;
    for( ; !(y >= 1 + stacks); y = y + 1)
    {
      beta = (float)((((double)((y * 180) / slices) - 90.0) * 3.14159265358979323846) / 180.0);
      double return_value_cos$4;
      return_value_cos$4=cos((double)alpha);
      double return_value_cos$5;
      return_value_cos$5=cos((double)beta);
      v[(signed long int)(i * 3 + 0)] = (float)(return_value_cos$4 * return_value_cos$5);
      double return_value_sin$6;
      return_value_sin$6=sin((double)beta);
      v[(signed long int)(i * 3 + 1)] = (float)return_value_sin$6;
      double return_value_sin$7;
      return_value_sin$7=sin((double)alpha);
      double return_value_cos$8;
      return_value_cos$8=cos((double)beta);
      v[(signed long int)(i * 3 + 2)] = (float)(return_value_sin$7 * return_value_cos$8);
      i = i + 1;
    }
  }
  i = 0;
  x = 0;
  for( ; !(x >= slices); x = x + 1)
  {
    y = 0;
    for( ; !(y >= stacks); y = y + 1)
    {
      if(!(y == 0) && !(y == stacks))
      {
        l[(signed long int)(i * 3 + 0)] = (unsigned int)(x * (stacks + 1) + y);
        l[(signed long int)(i * 3 + 1)] = (unsigned int)(((x + 1) % slices) * (stacks + 1) + y);
        l[(signed long int)(i * 3 + 2)] = (unsigned int)0;
        n[(signed long int)(i * 6 + 0)] = v[(signed long int)(l[(signed long int)(i * 3 + 0)] * (unsigned int)3 + (unsigned int)0)];
        n[(signed long int)(i * 6 + 1)] = v[(signed long int)(l[(signed long int)(i * 3 + 0)] * (unsigned int)3 + (unsigned int)1)];
        n[(signed long int)(i * 6 + 2)] = v[(signed long int)(l[(signed long int)(i * 3 + 0)] * (unsigned int)3 + (unsigned int)2)];
        n[(signed long int)(i * 6 + 3)] = v[(signed long int)(l[(signed long int)(i * 3 + 1)] * (unsigned int)3 + (unsigned int)0)];
        n[(signed long int)(i * 6 + 4)] = v[(signed long int)(l[(signed long int)(i * 3 + 1)] * (unsigned int)3 + (unsigned int)1)];
        n[(signed long int)(i * 6 + 5)] = v[(signed long int)(l[(signed long int)(i * 3 + 1)] * (unsigned int)3 + (unsigned int)2)];
        i = i + 1;
      }

      l[(signed long int)(i * 3 + 0)] = (unsigned int)(x * (stacks + 1) + y);
      l[(signed long int)(i * 3 + 1)] = (unsigned int)(x * (stacks + 1) + y + 1);
      l[(signed long int)(i * 3 + 2)] = (unsigned int)0;
      n[(signed long int)(i * 6 + 0)] = v[(signed long int)(l[(signed long int)(i * 3 + 0)] * (unsigned int)3 + (unsigned int)0)];
      n[(signed long int)(i * 6 + 1)] = v[(signed long int)(l[(signed long int)(i * 3 + 0)] * (unsigned int)3 + (unsigned int)1)];
      n[(signed long int)(i * 6 + 2)] = v[(signed long int)(l[(signed long int)(i * 3 + 0)] * (unsigned int)3 + (unsigned int)2)];
      n[(signed long int)(i * 6 + 3)] = v[(signed long int)(l[(signed long int)(i * 3 + 1)] * (unsigned int)3 + (unsigned int)0)];
      n[(signed long int)(i * 6 + 4)] = v[(signed long int)(l[(signed long int)(i * 3 + 1)] * (unsigned int)3 + (unsigned int)1)];
      n[(signed long int)(i * 6 + 5)] = v[(signed long int)(l[(signed long int)(i * 3 + 1)] * (unsigned int)3 + (unsigned int)2)];
      i = i + 1;
    }
  }
  o=s3d_new_object();
  s3d_push_material(o, (float)0, (float)0, (float)1, (float)1, (float)0, (float)0, (float)0, (float)1, (float)0);
  s3d_push_vertices(o, v, (unsigned short int)num_v);
  s3d_push_lines(o, l, (unsigned short int)num_l);
  s3d_load_line_normals(o, n, (unsigned int)0, (unsigned short int)num_l);
  free((void *)v);
  free((void *)n);
  free((void *)l);
  return o;
}

